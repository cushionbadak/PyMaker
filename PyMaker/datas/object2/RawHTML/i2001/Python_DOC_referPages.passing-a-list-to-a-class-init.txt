<div class="post-text" itemprop="text">
<p>I am trying to understand class structure.</p>
<p>The example is a pizza order with <code>__size</code> and <code>__toppings_list</code>.
I can pass size easy enough but it wont let me passing toppings as a list
I keep getting </p>
<pre><code>size = small
toppings = small
</code></pre>
<p>No matter how I try to evoke the <code>__string__</code> print function it just won't play nice.</p>
<pre><code>class Pizza:

    def __init__(self, size = "small", topping_list = []):
        self.__size = size
        self.__topping_list = topping_list

    def __string__(self):
        string = "Size is" + self.__size + ' and Topping is ' + self.__topping_list
        return string

    def set_size(self, size):
        self.__size = size

    def get_size(self):
        return self.__size

    def set_topping(self, topping):
        self.__topping_list

    def get_topping(self):
        return self.__size

    def add_topping(self, topping):
        self.__topping_list

    def get_cost(self):
        cost = 0
        size = pizza.get_size()
        toppings = pizza.get_topping()
        totalToppings = len(toppings)

        if size == "small":
            cost += 10
        elif size == "medium":
            cost += 12
        elif size == "large":
            cost +=14        
        cost += totalToppings * 2

        return cost


pizza = Pizza("small",["meat"])
size = pizza.get_size()
toppings = pizza.get_topping()
print(size)
print(toppings)
pizza_string = str(pizza)
print(pizza_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's a lot of small weird things going on with your code.</p>
<p>First of all, fix <code>get_topping</code> method (as pointed in comments), re-create your instance and it will work — this is for fixing your main issue.</p>
<p>Minor things, but highly recommended:</p>
<ul>
<li><p>using [empty] list as default argument is not a good idea, until you know what you're doing. List is mutable and arguments is "bound" to function object. So changing that default value once will affect all subsequent calls.</p></li>
<li><p>thing you're trying to achieve with <code>__string__</code> looks like mistake while implementing <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer"><code>__str__</code></a></p></li>
<li><p>please, think twice (or more) when you're using <code>__attr</code>. Probably it looks like a good idea, if you're experienced with languages like Java, but in python its generally a bad idea to "hide" attributes this way. This still will be available for users, while making your class hard to inherit — and non-collaborative classes isn't fun to work with. If you want to identify non-public interface — consider using single underscore (<code>_size</code>). If you not sure if this should be public — make it public. You can always make it <code>@property</code> without breaking interface. Same applies to <code>get_...</code> methods — there's no point to have code like this, if you're retrieving attribute without having attributes. Just having <code>self.size</code> attribute and using it is fine. If you're 100% sure you don't want to make this editable after instantiation, make it</p>
<pre><code>def __init__(...):
    self._size = ...
@property
def size(self):
    return self._size
</code></pre></li>
</ul>
</div>
<span class="comment-copy"><code>def get_topping(self): return self.__size</code> &lt;- see a problem in that code?</span>
<span class="comment-copy">See also: <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument" title="least astonishment and the mutable default argument">stackoverflow.com/questions/1132941/…</a>. And <code>def set_topping(self, topping): self.__topping_list</code> won't do much either.</span>
<span class="comment-copy">There are a lot of issues here to address: <code>print(value)</code> will use <code>str(value)</code>, which in turn looks for <code>__str__</code>. <code>__string__</code> plays no role in that path. Python has <b>no privacy model</b>, names starting with double underscores do not hide internal state, that only renames attributes to help avoid clashes with subclasses. Don't use <code>__</code> to start names unless you are writing a framework API to be extended by third-party developers.</span>
<span class="comment-copy">Python doesn't need to use getters and setters, as it is trivial to update a class later on to use a <code>@property</code> if you find you need one at that time, unlike Java, where you can't later on make that switch so it makes sense to always use setters and getters there. Don't try to use Python as if it is Java. If you had not used getters and setters you'd have been far less likely to run into your simple error here, where your <code>get_topping</code> getter returns <code>__size</code>.</span>
<span class="comment-copy">You also have a problem with <code>topping_list = []</code> in your <code>__init__</code> signature, that list is <i>shared between all instances</i>, see <a href="//stackoverflow.com/q/1132941">"Least Astonishment" and the Mutable Default Argument</a>.</span>
<span class="comment-copy">TY :-) .. I am going to go read up on @property .. and have a quite chat with my uni lecturer ;-) about the professional feedback here .. I learnt more in 5 minutes with you people than in the last week covering python classes</span>
