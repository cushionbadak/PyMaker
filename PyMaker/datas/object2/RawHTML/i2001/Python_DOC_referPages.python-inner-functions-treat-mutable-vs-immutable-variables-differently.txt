<div class="post-text" itemprop="text">
<p>I am trying to understand why does the inner function has access to the outer list (arr) but not the outer boolean variable (found). </p>
<pre><code>def outer():
    arr = [1, 2, 3]
    found = False
    print("outer func ids: ", id(arr), id(found))
    def inner(num):
        arr.append(4)
        found = True
        print("inner func ids:", id(arr), id(found))
    inner(3)
    print("outer func ids: ", id(arr), id(found))
    return found
outer()
</code></pre>
<p>Output:</p>
<pre><code>('outer func ids: ', 4536180248, 140736008926072)
('inner func ids:', 4536180248, 140736008926048)
('outer func ids: ', 4536180248, 140736008926072)
</code></pre>
<p>Can someone please clarify. Why does the list have the same id even though we are doing append operation in the inner function ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because redefining <code>found</code> in <code>inner</code> makes it local. Nothing to do with mutable or not.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's because Python uses static scope/is statically scoped. At implementation level Python has what is called a Symbol Table which has entries for things you define in code like variables and functions.</p>
<p>Each of those things are represented by a lexeme and have attributes like "value" and "scope". </p>
<p>For example for the first found, you have:</p>
<pre><code>LEXEME |  VALUE | SCOPE

found  |  False |  outer
</code></pre>
<p>When you defined a second found, an entry was generated for that found with a scope "inner". So at the moment of execution of  <code>print("inner func ids:", id(arr), id(found))</code> Python searched the Symbol Table for an entry of "found" and used the most recent one (the one with the inner scope). Like this:</p>
<pre><code>LEXEME |  VALUE | SCOPE

found  |  False |  outer
found  |  True  |  inner
</code></pre>
<p>The array is just unique, so when searching for that <code>arr</code> you again get the last entry for that lexeme or symbol and get the value of the unique outer array.</p>
<p>It's not about mutable or immutable but rather about scope.</p>
</div>
<div class="post-text" itemprop="text">
<p>From python <a href="https://docs.python.org/3/faq/programming.html#id9" rel="nofollow noreferrer">Faq</a></p>
<p>Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function’s body, it’s assumed to be a local unless explicitly declared as global.</p>
<p>Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you’d be using global all the time. You’d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.</p>
<p>Try <strong>not</strong> to assign value to <code>found</code> and see its id.</p>
<p>Let's see some examples:</p>
<pre><code>a = [1, 2, 3]
b = True
c = 123
d = "Hello"

def print_global1():
  print("print_global1: a=", a, id(a))
  print("print_global1: b=", b, id(b))
  print("print_global1: c=", c, id(c))
  print("print_global1: d=", d, id(d))

def print_global2():
  global a, b, c, d
  print("print_global2: a=", a, id(a))
  print("print_global2: b=", b, id(b))
  print("print_global2: c=", c, id(c))
  print("print_global2: d=", d, id(d))

def print_global3():
  global a, b, c, d
  a.append(4)
  b = False
  c += 1
  d = d.upper()
  print("print_global3: a=", a, id(a))
  print("print_global3: b=", b, id(b))
  print("print_global3: c=", c, id(c))
  print("print_global3: d=", d, id(d))

print("a=", a, id(a))
print("b=", b, id(b))
print("c=", c, id(c))
print("c=", d, id(c))
print("")
print_global1()
print("")
print_global2()
print("")
print_global3()
</code></pre>
<p>The outputs are:</p>
<pre><code>a= [1, 2, 3] 3206482320648
b= True 1625616544
c= 123 1626110848
c= Hello 1626110848

print_global1: a= [1, 2, 3] 3206482320648
print_global1: b= True 1625616544
print_global1: c= 123 1626110848
print_global1: d= Hello 3206481522616

print_global2: a= [1, 2, 3] 3206482320648
print_global2: b= True 1625616544
print_global2: c= 123 1626110848
print_global2: d= Hello 3206481522616

print_global3: a= [1, 2, 3, 4] 3206482320648
print_global3: b= False 1625616576
print_global3: c= 124 1626110880
print_global3: d= HELLO 3206482331664
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/41367656/use-local-function-variable-inside-loop">Use local function variable inside loop</a></span>
<span class="comment-copy">Because you explicitly reassign the variable. Please read <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a> This has nothing to do with mutable/immutable. If you did <code>arr = ['foo','bar']</code> you'd see the same result. Note, <b>variables</b> are neither mutable nor immutable, the <i>objects the refer to</i> can be. But variables can be reassigned to any sort of object. Python does not have typed variables</span>
<span class="comment-copy">And note, if you <i>didn't</i> reassign <code>found</code> in <code>inner</code>, and simply did <code>print(id(found))</code> you'd see the same object (although in this case, it's sort of moot since <code>True</code> and <code>False</code> are singletons).</span>
<span class="comment-copy">what I am not getting clarity is, why did the array have the same id in-spite of having an append operation ?</span>
