<div class="post-text" itemprop="text">
<p>I have a nested list:</p>
<pre><code>  output= [('the', 'B', 'NNP'), ('wall', 'I', 'NNP'), ('street', 'I', 'NNP'), ('journal', 'I', 'NNP'), ('reported', 'O', 'VB'), ('today', 'O', 'NNP'), ('that', 'O', 'NNP'), ('apple', 'B', 'NNP'), ('corporation', 'I', 'NNP'), ('made', 'O', 'VB'), ('money', 'O', 'NNP'), ('.', 'O', '.'), ('georgia', 'B', 'NNP'), ('tech', 'I', 'NNP'), ('is', 'O', 'NNP'), ('a', 'O', '.'), ('university', 'O', 'NNP'), ('in', 'O', 'NNP'), ('georgia', 'B', 'NNP'),('.', 'O', '.')]
</code></pre>
<p>I want to re-format it to the following expected format:</p>
<pre><code>new_output= [(['the', 'wall', 'street', 'journal', 'reported', 'today', 'that', 'apple', 'corporation', 'made', 'money'], ['B', 'I', 'I', 'I', 'O', 'O', 'O', 'B', 'I', 'O', 'O']), (['georgia', 'tech', 'is', 'a', 'university', 'in', 'georgia'], ['B', 'I', 'O', 'O', 'O', 'O', 'B'])]
</code></pre>
<p>My attempt is:</p>
<pre><code>import string
word = []
token = []
result_word = []
result_token = []

result = []
for i in output[0]:
    for every_word in i:
        word.append(every_word)
result_word = " ".join(" ".join(word).split()[::3])
</code></pre>
<p>How can I get my expected format?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> to group the non-period items into sentences, then use <code>zip</code> to split the words from the parts of speech indicators:</p>
<pre><code>from itertools import groupby

l =   output= [('the', 'B', 'NNP'), ('wall', 'I', 'NNP'), ('street', 'I', 'NNP'), ('journal', 'I', 'NNP'), ('reported', 'O', 'VB'), ('today', 'O', 'NNP'), ('that', 'O', 'NNP'), ('apple', 'B', 'NNP'), ('corporation', 'I', 'NNP'), ('made', 'O', 'VB'), ('money', 'O', 'NNP'), ('.', 'O', '.'), ('georgia', 'B', 'NNP'), ('tech', 'I', 'NNP'), ('is', 'O', 'NNP'), ('a', 'O', '.'), ('university', 'O', 'NNP'), ('in', 'O', 'NNP'), ('georgia', 'B', 'NNP'),('.', 'O', '.')]


groups = (g for k, g in groupby(l, lambda x: x[0] != '.') if k)
zs = (zip(*g) for g in groups)
res = [(next(z), next(z)) for z in zs]
</code></pre>
<p><code>res</code> is then</p>
<pre><code>[(('the', 'wall', 'street', 'journal', 'reported', 'today', 'that', 'apple', 'corporation', 'made', 'money'), 
  ('B', 'I', 'I', 'I', 'O', 'O', 'O', 'B', 'I', 'O', 'O')), 
 (('georgia', 'tech', 'is', 'a', 'university', 'in', 'georgia'), 
  ('B', 'I', 'O', 'O', 'O', 'O', 'B'))
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

output = [('the', 'B', 'NNP'), ('wall', 'I', 'NNP'), ('street', 'I', 'NNP'), ('journal', 'I', 'NNP'),
          ('reported', 'O', 'VB'), ('today', 'O', 'NNP'), ('that', 'O', 'NNP'), ('apple', 'B', 'NNP'),
          ('corporation', 'I', 'NNP'), ('made', 'O', 'VB'), ('money', 'O', 'NNP'), ('.', 'O', '.'),
          ('georgia', 'B', 'NNP'), ('tech', 'I', 'NNP'), ('is', 'O', 'NNP'), ('a', 'O', '.'),
          ('university', 'O', 'NNP'), ('in', 'O', 'NNP'), ('georgia', 'B', 'NNP'), ('.', 'O', '.')]

sentences = [list(group) for k, group in groupby(output, lambda x: x[0] == ".") if not k]
result = [tuple(map(list, zip(*map(itemgetter(0, 1), sentence)))) for sentence in sentences]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[(['the', 'wall', 'street', 'journal', 'reported', 'today', 'that', 'apple', 'corporation', 'made', 'money'], ['B', 'I', 'I', 'I', 'O', 'O', 'O', 'B', 'I', 'O', 'O']), (['georgia', 'tech', 'is', 'a', 'university', 'in', 'georgia'], ['B', 'I', 'O', 'O', 'O', 'O', 'B'])]
</code></pre>
<p><strong>Explanation</strong> </p>
<p>As far as I understood you want to <em>unpack</em> the first and the last element of each of the sentences.</p>
<p>The line:</p>
<pre><code>sentences = [list(group) for k, group in groupby(output, lambda x: x[0] == ".") if not k]
</code></pre>
<p>splits <code>output</code> into sentences by each <code>.</code>, the second line just unpacks each sentence:</p>
<pre><code>result = [tuple(map(list, zip(*map(itemgetter(0, 1), sentence)))) for sentence in sentences]
</code></pre>
<p>As you want to a list of tuple of lists and <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip</a> returns a list of tuples you have to map each tuple with list and then convert the result of map to a tuple.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>output = [('the', 'B', 'NNP'), ('wall', 'I', 'NNP'), ('street', 'I', 'NNP'), ('journal', 'I', 'NNP'), ('reported', 'O', 'VB'), ('today', 'O', 'NNP'), ('that', 'O', 'NNP'), ('apple', 'B', 'NNP'), ('corporation', 'I', 'NNP'), ('made', 'O', 'VB'), ('money', 'O', 'NNP'), ('.', 'O', '.'), ('georgia', 'B', 'NNP'), ('tech', 'I', 'NNP'), ('is', 'O', 'NNP'), ('a', 'O', '.'), ('university', 'O', 'NNP'), ('in', 'O', 'NNP'), ('georgia', 'B', 'NNP'),('.', 'O', '.')]
result, words, tokens = [], [], []
for word, token, _ in output:  # this is tuple like ('the', 'B', 'NNP')
    if word == '.':   # end of sentence, save current and start new one
        result.append((words, tokens))
        words, tokens = [], []
    else:   # add new word to current sentence
        words.append(word)
        tokens.append(token)

print(result)
</code></pre>
<p>Output:</p>
<blockquote>
<p>[(['the', 'wall', 'street', 'journal', 'reported', 'today', 'that', 'apple', 'corporation', 'made', 'money'], ['B', 'I', 'I', 'I', 'O', 'O', 'O', 'B', 'I', 'O', 'O']), (['georgia', 'tech', 'is', 'a', 'university', 'in', 'georgia'], ['B', 'I', 'O', 'O', 'O', 'O', 'B'])]</p>
</blockquote>
</div>
<span class="comment-copy">I don't quite understand the logic behind your desired output.</span>
<span class="comment-copy">The mapping from input to output isn't clear to me. How is the input being transformed to produce the output?</span>
<span class="comment-copy">re-format the nested list to be [(sentence1, token),(sentence2, token)]</span>
<span class="comment-copy">did you forget <code>.</code> in reformatted list? or you're using it for split?</span>
<span class="comment-copy">punctuation is not necessary in reformatted list.</span>
