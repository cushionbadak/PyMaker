<div class="post-text" itemprop="text">
<p>I am working with string formatting. For english the formatting is neat but for unicode characters the formatting is haphazard. Can anyone please tell me the reason?
Example:</p>
<pre><code>form = u'{:&lt;15}{:&lt;3}({})'
a = [
 u'സി ട്രീമിം',
 u'ബി ഡോഗേറ്റ്',
 u'ജെ ഹോളണ്ട്',
 u'എം നസീർ ',
 u'എം ബസ്ചാഗൻ…',
 u'ടി ഹെഡ് ',
 u'കെ ഭാരത് ',
 u'എം സിറാജ് ',
 u'എ ഈശ്വരൻ ',
 u'സി ഹാൻഡ്‌സ്‌കോംബ് ബി',]

 for i in range(0, 10):
     print form.format(a[i][:12], 1, 2)
</code></pre>
<p>Gives output as 
<a href="https://i.stack.imgur.com/K2Tl2.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/K2Tl2.png"/></a></p>
<p>While </p>
<pre><code>s = [
 u'abcdef',
 u'akash',
 u'rohit',
 u'anubhav',
 u'bhargav',
 u'achut',
 u'punnet',
 u'tom',
 u'rach',
 u'kamal'
 ]
for i in range(0, 10):
     print form.format(s[i][:12], 1, 2)
</code></pre>
<p>Gives:
<a href="https://i.stack.imgur.com/dqSK7.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/dqSK7.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You are printing <a href="https://en.wikipedia.org/wiki/Malayalam_(Unicode_block)" rel="nofollow noreferrer">Malayalam Unicode codepoints</a>, which uses a lot of <a href="https://en.wikipedia.org/wiki/Malayalam_script#Vowel_letters_and_vowel_signs" rel="nofollow noreferrer">vowel signs</a> to modify the preceding glyph. These vowel sign codepoints that do not themselves form a new letter, and Malayalam doesn't produce the same regular width of output in a terminal as ASCII letters would.</p>
<p>For example, in your first string starts with <a href="https://codepoints.net/U+0D38" rel="nofollow noreferrer">U+0D38 MALAYALAM LETTER SA</a> and <a href="https://codepoints.net/U+0d3f" rel="nofollow noreferrer">U+0D3F MALAYALAM VOWEL SIGN I</a>.  The first, <em>letter SA</em>, takes a full position on the screen, but the second character, the <em>vowel sign I</em>, when preceding by SA, alters how the letter is printed. Note how with 2 codepoints printed, there is just <em>one</em> visible glyph:</p>
<pre><code>&gt;&gt;&gt; print u'\u0d38'  # letter SA
സ
&gt;&gt;&gt; print u'\u0d3f'  # vowel sign I
 ി
&gt;&gt;&gt; print u'\u0d38\u0d3f'  # both together
സി
</code></pre>
<p>The widths of Malayalam codepoints is also different; if you add ASCII letters below SA and vowel sign I, separately and combined, it looks like this:</p>
<pre><code>&gt;&gt;&gt; print u'\u0d38\nA..\n\u0d3f\nB..\n\u0d38\u0d3f\nAB.'  # with ASCII letters for size
സ
A..
 ി
B..
സി
AB.
</code></pre>
<p>Note how <code>സ</code> is wider than <code>A</code> (about 2.5 times as wide), while <code>സി</code> is almost as wide as 3 ASCII codepoints in fixed width! Not all Malayalam letters are this wide, however.  The next letter in the first example is <a href="https://codepoints.net/U+0D1F" rel="nofollow noreferrer">U+0D1F MALAYALAM LETTER TTA</a>, which is much less wide:</p>
<pre><code>&gt;&gt;&gt; print u'\u0d38\nA..\n\u0d1f\nB..'
സ
A..
ട
B..
</code></pre>
<p>In practice, I'm hoping that the difference doesn't matter and codepoints are instead combined such that the output ends up roughly the same width.</p>
<p>Next, Malayalam has other combining characters too; your first string has <a href="https://codepoints.net/U+0D4D" rel="nofollow noreferrer">U+0D4D MALAYALAM SIGN VIRAMA</a>, which has been combined with the preceding letter TTA.</p>
<p>Diacritical marks, when combined with the preceding letter, play havoc with printing width:</p>
<pre><code>&gt;&gt;&gt; print u'\u0d1f\nA..\n\u0d4d\nB..\n\u0d1f\u0d4d\nAB.'
ട
A..
 ്
B..
ട്
AB.
</code></pre>
<p>The letter TTA is just as wide as an ASCII letter, and when you add the virama sign, the width didn't actually change.</p>
<p>You can approximate sizes by looking at the codepoint <a href="https://en.wikipedia.org/wiki/Unicode_character_property#General_Category" rel="nofollow noreferrer"><em>Unicode general categories</em></a>. The <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.category" rel="nofollow noreferrer"><code>unicodedata.category()</code> function</a> gives you the category as a string:</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.category(u'\u0d38')
'Lo'
&gt;&gt;&gt; unicodedata.category(u'\u0d3f')
'Mc'
&gt;&gt;&gt; unicodedata.category(u'\u0d4d')
'Mn'
</code></pre>
<p>The letter SA is <code>Lo</code> (Letter, other), the vowel sign is <code>Mc</code> (Mark, spacing combining), and the virama sign is <code>Mn</code> (Mark, nonspacing).</p>
<pre><code>&gt;&gt;&gt; categories = {}
&gt;&gt;&gt; for c in a[0]:
...     cat = unicodedata.category(c)
...     categories[cat] = categories.get(cat, 0) + 1
... 
&gt;&gt;&gt; categories
{'Lo': 4, 'Mn': 1, 'Mc': 4, 'Zs': 1}
</code></pre>
<p>So for the first string, there are 4 letters, 4 combining marks, and the one vowel sign.  The <code>Zs</code> category (Separator, space) is for the <code>' '</code> ASCII space character.</p>
<p>Can we get their widths predicted better if we skipped <code>Mc</code> and <code>Mn</code> characters? String <code>a[0]</code> would be 5 characters wide (4 times <code>Lo</code> and 1 space):</p>
<pre><code>&gt;&gt;&gt; print a[0] + '\nABCDE.'
സി ട്രീമിം
ABCDE.
</code></pre>
<p>In the browser, that doesn't look close enough, but in my iTerm terminal window it looks like this:</p>
<p><a href="https://i.stack.imgur.com/onwSs.png" rel="nofollow noreferrer"><img alt="Python 2.7 output printing the strings &lt;code&gt;സി ട്രീമിം&lt;/code&gt; and &lt;code&gt;ABCDE.&lt;/code&gt;, with the capital letters in the second string producing roughly the same width on the screen as the first line." src="https://i.stack.imgur.com/onwSs.png"/></a></p>
<p>To get your lines to line up, you'd have to calculate the right width for your strings to add extra spaces for the difference in display width and the number of codepoints:</p>
<pre><code>import unicodedata

def malayalam_width(s):
    return sum(1 for c in s if unicodedata.category(c)[0] != 'M')

form = u'{:&lt;{width}}{:&lt;3}({})'
for line in a:
    line = line[:12]
    adjust = len(line) - malayalam_width(line)
    print form.format(line, 1, 2, width=15 + adjust)
</code></pre>
<p>This improves the output <em>a lot</em> already:</p>
<p><a href="https://i.stack.imgur.com/0bhbu.png" rel="nofollow noreferrer"><img alt="Output on terminal with adjusted code; columns line up better but still too far apart" src="https://i.stack.imgur.com/0bhbu.png"/></a></p>
<p>It appears those wider letters do make a difference after all. You'd have to manually add further width for those to get a better result; with a mapping from letter to adjusted width you could get this to align a little better again. However, the codepoint widths are set by the font you use, and I'm not sure how easy it is to find a font that uses equal width for all Malayalam letters.</p>
<p>I find it much easier to just use tab stops, using</p>
<pre><code>form = u'{:&lt;{width}}\t{:&lt;3}({})'
for line in a:
    line = line[:12]
    adjust = len(line) - malayalam_width(line)
    print form.format(line, 1, 2, width=12 + adjust)
</code></pre>
<p>Now the numbers do line up:</p>
<p><a href="https://i.stack.imgur.com/s8a37.png" rel="nofollow noreferrer"><img alt="Lined up columns with tabs" src="https://i.stack.imgur.com/s8a37.png"/></a></p>
<p>You do need to keep adjusting for widths; otherwise you end up at the wrong tab stop half the time.</p>
<p>Caveat: I'm not at all familiar with the Malayalam script, and I'm sure to have missed subtleties about how the various letters, vowel signs and diacritical marks interact. Someone who is more familiar with the script and Unicode codepoints is probably going to be able to produce a better width approximation function than I presented here.</p>
<p>I've also ignored the 2 <a href="https://codepoints.net/U+200C" rel="nofollow noreferrer">U+200C ZERO WIDTH NON-JOINER</a> codepoints that are currently present in your last string; you may want to remove those from your data. As it's name suggests, it has no width either.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <code>wcwidth</code> module, it overcomes issues where tab length is interpreted differently in various terminals (as far as I know).</p>
<p>I used Python 3 here, I take it you're using 2, so your mileage may vary. Also, I modified the formatting of your output to demonstrate some of the variables in use</p>
<h1>Solution</h1>
<pre><code>from wcwidth import wcswidth

a = [
    u'സി ട്രീമിം',
    u'ബി ഡോഗേറ്റ്',
    u'ജെ ഹോളണ്ട്',
    u'എം നസീർ ',
    u'എം ബസ്ചാഗൻ…',
    u'ടി ഹെഡ് ',
    u'കെ ഭാരത് ',
    u'എം സിറാജ് ',
    u'എ ഈശ്വരൻ ',
    u'സി ഹാൻഡ്‌സ്‌കോംബ് ബി'
]

desired = 15
max_str = 12

for item in a:

    sub_str = item[:max_str]

    diff = len(sub_str) - wcswidth(sub_str)

    indent = desired + diff if desired - wcswidth(sub_str) &gt; 0 else desired + diff - 1

    form = u'{:&lt;'+ str(indent) +'} {:&lt;3}{:&lt;3}{:&lt;3}'

    print (form.format(sub_str, len(sub_str), wcswidth(sub_str), indent))
</code></pre>
<h1>Result:</h1>
<p><a href="https://i.stack.imgur.com/D38my.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/D38my.png"/></a></p>
</div>
<span class="comment-copy">Not all Unicode characters are created equal. Or at least, use equal width.</span>
<span class="comment-copy">Thank you for the great explanation</span>
<span class="comment-copy">Thank you for your answer,  can you please explain why <code>else desired + diff - 1</code> this is to be done?</span>
<span class="comment-copy">Note: you can nest <code>{}</code> sections to specify a width in <code>str.format()</code> templates. Don't use string concatenation to build a template here. <code>u'{:&lt;{indent}} {:&lt;3}{:&lt;3}{indent:&lt;3}'</code> and <code>form.format(sub_str, len(sub_str), wcswidth(sub_str), indent=indent)</code> would work better.</span>
<span class="comment-copy">@MartijnPieters thanks, couldn't remember how to do that at the time. @Savitha Suresh I can't run it at the moment, but that little bit of math might not actually be necessary, I think just <code>else desired</code> should suffice. The general idea is that indentation should be added if there's a gap, otherwise not.</span>
<span class="comment-copy">Note that <code>wcwidth</code> is not any better at this than using <code>unicodedata</code>. All that <code>wcswidth</code> does is give us the exact same info as what we already can glean from using <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.east_asian_width" rel="nofollow noreferrer"><code>unicodedata.east_asian_width</code></a> and <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.combining" rel="nofollow noreferrer"><code>unicodedata.combining</code></a> give us (the source code for the functions just replicates the Unicode data table for combining and EAW characters and gives you 0, 1 or 2 for a codepoint based on those tables.</span>
<span class="comment-copy">The <code>if desired - wcswidth(sub_str) &gt; 0 else</code> logic makes no sense here; none of the strings have a longer width anyway, certainly not since there are no EAW codepoints here at all (nothing will take 2 blocks, everything takes 0 or 1 position). The use of <code>wcwidth</code> doesn't produce anything helpful here as it actively misses out on combining marks and over-estimates the lengths. I'm not sure how your terminal managed to produce the output you show in the screenshot, on my machine i get very different output even though the <code>wcswidth()</code> numbers are exactly the same.</span>
