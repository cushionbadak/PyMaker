<div class="post-text" itemprop="text">
<p>How to get last 'n' groups after <code>df.groupby()</code> and combine them as a dataframe. </p>
<pre><code>data = pd.read_sql_query(sql=sqlstr, con=sql_conn, index_col='SampleTime')
grouped = data.groupby(data.index.date,sort=False)
</code></pre>
<p>After doing <code>grouped.ngroups</code> i am getting total number of groups 277. I want to combine last 12 groups and generate a dataframe.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pandas <code>GroupBy</code> objects are iterables. To extract the last <em>n</em> elements of an iterable, there's generally no need to create a list from the iterable and slice the last <em>n</em> elements. This will be memory-expensive.</p>
<p>Instead, you can use either <code>itertools.islice</code> (as suggested by @mtraceur) or <code>collections.deque</code>. Both work in O(<em>n</em>) time.</p>
<h3><a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a></h3>
<p>Unlike a generator, a Pandas <code>GroupBy</code> object is an iterable which can be reused. Therefore, you can calculate the number of groups via <code>len(g)</code> for a <code>GroupBy</code> object <code>g</code> and then slice <code>g</code> via <code>islice</code>. Or, perhaps  more idiomatic, you can use <code>GroupBy.ngroups</code>. Then use <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.concat.html" rel="nofollow noreferrer"><code>pd.concat</code></a> to concatenate an iterable of dataframes:</p>
<pre><code>from operator import itemgetter

g = data.groupby(data.index.date, sort=False)
res = pd.concat(islice(map(itemgetter(1), g), max(0, g.ngroups-12), None))
</code></pre>
<h3><a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a></h3>
<p>Alternatively, you can use <code>collections.deque</code> and specify <code>maxlen</code>, then concatenate as before.</p>
<pre><code>from collections import deque

grouped = data.groupby(data.index.date, sort=False)
res = pd.concat(deque(map(itemgetter(1), grouped), maxlen=12))
</code></pre>
<p>As described in the <code>collections</code> docs:</p>
<blockquote>
<p>Once a bounded length <code>deque</code> is full, when new items are added, a
  corresponding number of items are discarded from the opposite end....
  They are also useful for tracking transactions and other pools of data
  where only the most recent activity is of interest.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you know the order of <code>grouped</code></p>
<pre><code>grouped = zip(*df.groupby(data.index.date,sort=False))
pd.concat(list(grouped)[1][-12:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <code>pd.concat</code> on lists comprehension and <code>groupby.get_group</code></p>
<pre><code>pd.concat([grouped.get_group(x) for x in list(grouped.groups.keys())[-12:]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could pass a list comprehension to <code>pd.concat()</code>:</p>
<pre><code>import pandas as pd

df = pd.DataFrame([
['A',1,2],
['A',7,6],
['B',1,3],
['B',9,9],
['C',1,8],
['A',4,3],
['C',7,6],
['D',4,2]],
columns=['Var','Val1','Val2'])

last_n = 2
grouped = df.groupby('Var')

pd.concat([grouped.get_group(group) for i, group in enumerate(grouped.groups) if i&gt;=len(grouped)-last_n])
</code></pre>
<p>Yields:</p>
<pre><code>  Var  Val1  Val2
4   C     1     8
6   C     7     6
7   D     4     2
</code></pre>
</div>
<span class="comment-copy">in your example where can it be seen that you recover the last 5?</span>
<span class="comment-copy">Great catch using deques, but you are still iterating over all groups. So the advantage is to save memory in this case, am I right? Good catch anyway</span>
<span class="comment-copy">@RafaelC, Yes, the advantage is principally lower memory usage. You can't avoid iterating over all groups.</span>
<span class="comment-copy">I'm curious, did you also consider/evaluate doing <code>itertools.islice(map(...), len(grouped) - 12, len(grouped)</code> instead of a <code>collections.deque(map(...), maxlen=12)</code>? My intuition is to prefer <code>islice</code> in this case, but maybe I'm missing something?</span>
<span class="comment-copy">@mtraceur, I've gone ahead and added the <code>islice</code> solution (but using <code>ngroups</code>), hope that's ok.</span>
<span class="comment-copy">I just tried this on a dataframe I was working on, and this seemed to be what OP asked for? <code>ed:</code> the concat didn't work, but <code>.tail(12)</code> returned the final 12 groups</span>
<span class="comment-copy">new version should be aligned to what OP wants :) (although it doesn't provide much vs rahlf23's version)</span>
<span class="comment-copy">@MathewSavage that is really interesting, doc says it return the last rows from each group, not the last groups. Maybe I should test it too</span>
