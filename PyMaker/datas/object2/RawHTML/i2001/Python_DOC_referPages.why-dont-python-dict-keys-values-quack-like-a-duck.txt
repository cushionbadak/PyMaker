<div class="post-text" itemprop="text">
<p>Python is <a href="https://hackernoon.com/python-duck-typing-or-automatic-interfaces-73988ec9037f" rel="nofollow noreferrer">duck typed</a>, and generally this avoids casting faff when dealing with primitive objects.</p>
<blockquote>
<p>The canonical example (and the reason behind the name) is the duck test: If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p>
</blockquote>
<p>However one notable exception is dict keys/values, which look like a duck and swim like a duck, but notably <em>do not quack like a duck</em>.</p>
<pre><code>&gt;&gt;&gt; ls = ['hello']
&gt;&gt;&gt; d = {'foo': 'bar'}
&gt;&gt;&gt; for key in d.keys():
..      print(key)
..
'foo'
&gt;&gt;&gt; ls + d.keys()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate list (not "dict_keys") to list
</code></pre>
<p>Can someone enlighten me as to why this is?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is an explicit check for <code>list</code> type (or its children) in python source code (so even <code>tuple</code> doesn't qualify):</p>
<pre><code>static PyObject *
list_concat(PyListObject *a, PyObject *bb)
{
    Py_ssize_t size;
    Py_ssize_t i;
    PyObject **src, **dest;
    PyListObject *np;
    if (!PyList_Check(bb)) {
        PyErr_Format(PyExc_TypeError,
                  "can only concatenate list (not \"%.200s\") to list",
                  bb-&gt;ob_type-&gt;tp_name);
        return NULL;
    }
</code></pre>
<p>so python can compute size very quickly and reallocate the result without trying all containers or iterate on the right hand to find out, providing very fast list addition.</p>
<pre><code>#define b ((PyListObject *)bb)
    size = Py_SIZE(a) + Py_SIZE(b);
    if (size &lt; 0)
        return PyErr_NoMemory();
    np = (PyListObject *) PyList_New(size);
    if (np == NULL) {
        return NULL;
    }
</code></pre>
<p>One way to workaround this is to use in-place extension/addition:</p>
<pre><code>my_list += my_dict  # adding .keys() is useless
</code></pre>
<p>because in that case, in-place add iterates on the right hand side: so every collection qualifies.</p>
<p>(or of course force iteration of the right hand: <code>+ list(my_dict)</code>)</p>
<p>So it <em>could</em> accept any type but I suspect that the makers of python didn't find it worth it and were satisfied with a simple &amp; fast implementation which is used 99% of the time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Dict keys actually implements the set's interface rather than the list's, so you can perform set operations with dict keys directly with other sets:</p>
<pre><code>d.keys() &amp; {'foo', 'bar'} # returns {'foo'}
</code></pre>
<p>But it doesn't implement the <code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, and <code>insert</code> methods, which are required to "quack" like a list, so it cannot perform any of the list operations without being explicitly converted to a list first:</p>
<pre><code>ls + list(d.keys()) # returns ['hello', 'foo']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you go into the definition of <code>d.keys()</code> the you can see the following. </p>
<pre><code>def keys(self): # real signature unknown; restored from __doc__
    """ D.keys() -&gt; a set-like object providing a view on D's keys """
    pass
</code></pre>
<p>Or use this statement:</p>
<pre><code>print(d.keys.__doc__)
</code></pre>
<p>It clearly mentions that the output is <code>set-like</code> object. </p>
<p>Now you are trying to append a set to a list. </p>
<p>You need to convert the set into list and then append it.</p>
<pre><code>x = ls + list(d.keys())
print(x)
# ['hello', 'foo']
</code></pre>
</div>
<span class="comment-copy"><a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">en.wikipedia.org/wiki/Duck_typing</a></span>
<span class="comment-copy"><code>ls + list(d.keys())</code>?</span>
<span class="comment-copy">IIn older Python versions <code>dict.keys()</code> was a list but that changed and now it is a dict view object: From the help: <code>D.keys() -&gt; a set-like object providing a view on D's keys</code></span>
<span class="comment-copy">Python makes it pretty clear it is not a list: <code>&gt;&gt;&gt;d.keys()</code> returns <code>dict_keys(['foo'])</code></span>
<span class="comment-copy">but you cannot concatenate list + dict and dict implements <code>__getitem__</code>: <code>&gt;&gt;&gt; d.__getitem__ &lt;built-in method __getitem__ of dict object at 0x0000000002FD9048&gt;</code>. The fact that <code>__getitem__</code> isn't defined isn't the reason.</span>
<span class="comment-copy">@Jean-FrançoisFabre: a dict lacks other Sequence methods that are required for an object to be treated as a list (e.g. <code>__reversed__</code>). The table at <a href="https://docs.python.org/3/library/collections.abc.html#module-collections.abc" rel="nofollow noreferrer">docs.python.org/3/library/…</a> is a helpful reference.</span>
<span class="comment-copy">if you check the source code, it's really more basic than that. it just <i>has</i> to be a <code>list</code></span>
<span class="comment-copy"><code>PyList_Check</code>? Yeah you're right, I guess it is more basic in reality: CPython checks if the <code>Py_TPFLAGS_LIST_SUBCLASS</code> bit is set on the object type's <code>tp_flags</code>. So this answer addresses why a dict_keys object does quack like a list from an ABC perspective, but a more direct answer is probably that dict_keys does not inherit from list and fails <code>PyList_Check</code>.</span>
<span class="comment-copy">so this highly voted answer is <i>wrong</i>. I guess people were impressed by the usage of dunder methods.</span>
