<div class="post-text" itemprop="text">
<p>Have a bunch of lists that are converted from a <strong>.txt</strong> file that have been read as a collection of strings that look like:</p>
<pre><code>['New', 'Jersey', '1', '0', '1', '999']
['West', 'North', 'Central', '1', '0', '100', '90']
</code></pre>
<p>These lists have differing numbers of side-by-side words (the first has 2 the second has 3, etc..)</p>
<p>I want to output a new list (then into a compiled dataframe) that joins the words together that are side-by-side like:</p>
<pre><code>['New Jersey', '1', '0', '1', '999']
['West North Central', '1', '0', '100', '90']
</code></pre>
<p>Which will make the new list (and dataframe) of the same length.</p>
<p>It's easy to just <code>append(line.split())</code> into a new list for each string but can't figure out the if-statement and .join() needed to join all words and append each number separately.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby</code></a>, you can group by <code>str.isalpha</code>, join strings conditionally, and then chain the results:</p>
<pre><code>from itertools import chain, groupby

L = ['New', 'Jersey', '1', '0', '1', '999']

grouper = groupby(L, key=str.isalpha)
joins = [[' '.join(v)] if alpha_flag else list(v) for alpha_flag, v in grouper]
res = list(chain.from_iterable(joins))

print(res)

['New Jersey', '1', '0', '1', '999']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am basically looping through the strings in list1. If it happens to be a word I append it to list2, or else it's appended to list3. The method isdigit() returns true if the string consists of only digits. And finally append all the contents of list2 to answer as a single string using 'join', and use extend to add all elements of list3 to the end of answer[].</p>
<pre><code>list1=['West North Central', '1', '0', '100', '90']
list2=[]
list3=[]
for i in list1:
    if i.isdigit():
        list3.append(i)
    else:
        list2.append(i)
answer = []
answer.append(' '.join(list2))
answer.extend(list3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>line = ['West', 'North', 'Central', '1', '0', '100', '90']
words = []
nums = []

for word in line:
    if word.isalpha():
        words.append(word)
    else:
        nums.append(word)

new_line = [' '.join(words)]
new_line.extend(nums)

# new_line == ['West North Central', '1', '0', '100', '90']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can write you own function to make concatenation, for example:</p>
<pre><code>l = [
    ['New', 'Jersey', '1', '0', '1', '999'],
    ['West', 'North', 'Central', '1', '0', '100', '90']]

def my_concat(l):
    nl = []
    cur = None
    delim = ""
    for i in l:
        if isinstance(i, (str, unicode)) and i.isalpha():
            if cur == None:
                cur = ""
            cur += delim + i
            delim = " "
        else:
            if cur != None:
                nl.append(cur)
                cur = None
                delim = ""
            nl.append(i)
    return nl

for i in l:
    print my_concat(i)
</code></pre>
<p>output:</p>
<pre><code>['New Jersey', '1', '0', '1', '999']
['West North Central', '1', '0', '100', '90']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.groupby</code>:</p>
<pre><code>from itertools import groupby
l = [
    ['New', 'Jersey', '1', '0', '1', '999'],
    ['West', 'North', 'Central', '1', '0', '100', '90']
]
print([list.__add__(*(list(g) if k else [' '.join(g)] for k, g in groupby(s, key=str.isdigit))) for s in l])
</code></pre>
<p>This outputs:</p>
<pre><code>[['New Jersey', '1', '0', '1', '999'], ['West North Central', '1', '0', '100', '90']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest the following steps:</p>
<p>1) Find the indeces for word entrees 
2) If you have two or more consecutive indeces that are not numeric, append them</p>
<p>Case:</p>
<pre><code>import re

numeric_regex = re.compile('[0-9]+?') #Regex to find numeric indices 
test = ['New', 'Jersey', '1', '0', '1', '999', 'West', 'North', 'Central', '1', '0']

#Comprehension to find word indices 
word_indices = [idx for idx, x in enumerate(test) if numeric_regex.match(x) is None]

#Comprehension to find indices to merge on
merge_on = [idx for idx, x in enumerate(word_indices) if word_indices[idx-1] == x-1]
</code></pre>
<p>At this point I'm stumped on a way to do this without a for loop, so I'll just use a for loop:</p>
<pre><code>reversed_merge_on = reversed(merge_on)
for x in reversed_merge_on:
    test[word_indices[x]-1] = ' '.join(test[word_indices[x]-1:word_indices[x]+1])
    del test[word_indices[x]]
</code></pre>
<p>This will get you through any given list. You can put it into a function and apply it to many lists. The code above will work as is, so you can copy to Python (I'm using 2.7) to see for yourself. </p>
</div>
<div class="post-text" itemprop="text">
<p>Use list comprehension and join non-digit items in one index, and then unpack a list comprehension for the digits. </p>
<pre><code>lst = ['West', 'North', 'Central', '1', '0', '100', '90']
res = [' '.join([i for i in lst if not i.isdigit()]),*[i for i in lst if i.isdigit()]]
print(res)
# ['West North Central', '1', '0', '100', '90']
</code></pre>
</div>
<span class="comment-copy"><a href="http://idownvotedbecau.se/nocode/" rel="nofollow noreferrer"><b>Itâ€™s hard to answer a programming question without code</b></a>.</span>
<span class="comment-copy">Someone once said "great minds think alike"</span>
<span class="comment-copy">@pault, Wow, and 4 seconds apart!</span>
<span class="comment-copy">@blhsing <code>'kids' &gt; 'SO'</code> is <code>True</code> fortunately ;)</span>
<span class="comment-copy">@blhsing (moved comment from your answer to here) - Though it won't make a huge deal in this particular example, using <code>list.__add__</code> is generally a <a href="https://stackoverflow.com/a/41772165/5858851">bad way of flattening nested lists</a>.</span>
<span class="comment-copy">@blhsing im surprised you and jpp went groupby on this one, maybe I fell out of the great minds connection :/</span>
<span class="comment-copy">could you please add more explain for your code .Thanks.</span>
<span class="comment-copy">not sure which part of the code is unclear, could you point out for which part do you need an explanation</span>
<span class="comment-copy">i know it's clear for people professional  but there is first step learn person need more explain for every line just hint about reason of why you write this line of  code.Thanks . again.welcome in world of stack overflow for explain code.</span>
<span class="comment-copy">@hollopost I have edited the answer, let me know if it's clear now. Thanks</span>
<span class="comment-copy">thanks for your quick respond .i wish i'm not annoying person .but this is roles of stack overflow explain for clarity . this is clear now thanks.</span>
<span class="comment-copy"><code>if word.isalpha():</code> could replace <code>all(...)</code>, also could append/extend to <code>new_line</code> in the loop</span>
<span class="comment-copy">Thanks, editing.</span>
<span class="comment-copy">what if the list is like <code>lst = ['1', '0', '100', '90', 'West', 'North', 'Central']</code></span>
<span class="comment-copy">@KhalilAlHooti then it still works, did you attempt to plug it in?</span>
<span class="comment-copy">it returns <code>['West North Central', '1', '0', '100', '90']</code>, instead of <code>['1', '0', '100', '90', 'West North Central']</code></span>
<span class="comment-copy">@KhalilAlHooti isnt that the desired output, why would we produce the opposite of the desired output, all demonstrated outputs are organized word first, with no mention that it should be otherwise</span>
<span class="comment-copy">@KhalilAlHooti I respect and understand what you are saying, but I have to tailor my response according to what OP provides and only thing provided was outputs that are in this fashion, assuming for a reason as well</span>
