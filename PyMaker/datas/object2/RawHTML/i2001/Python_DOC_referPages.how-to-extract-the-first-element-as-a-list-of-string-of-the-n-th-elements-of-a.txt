<div class="post-text" itemprop="text">
<p>I am a fresh python beginner and trying to extract the first element of the first n-th elements of a nested list. But it doesn't work so far.</p>
<p>Say: </p>
<pre><code>list = [["Anna","w",15],["Peter","m",20],["Zani","m",10], ["Lily","w",19]]
</code></pre>
<p>Goal:</p>
<pre><code>list_new = ['Anna','Peter','Zani'...(#until the n-th elements)]
</code></pre>
<p>If I want to first element of all the elements in the list, it should be:</p>
<pre><code>for i in list:
    for j in i:
        print j[0]
</code></pre>
<p>But what if i only want to strip the first element of the n-th elements of the list, instead of all the elements.</p>
<p>For example for the first 2 elements:
I tried:</p>
<pre><code>for i in list[0:2]:
    for j in i:
        print j[0]
</code></pre>
<p>but it didn't work.</p>
<p>What's more, if i want to give the value of n later by using </p>
<pre><code>def sheet(list, n) 
</code></pre>
<p>and the return statement, how could i do it?</p>
<p>Thank you very much!!</p>
</div>
<div class="post-text" itemprop="text">
<p>Be careful, list is reserved for the built-in function <code>list()</code> in python, you should not use 'list' as variable name.</p>
<p>To get the first element of each nested list : </p>
<pre><code>l = [["Anna","w",15],["Peter","m",20],["Zani","m",10], ["Lily","w",19]]
for e in l:
     print(e[0])
</code></pre>
<p>Prints :</p>
<pre><code>Anna
Peter
Zani
Lily
</code></pre>
<p>To do the same on the nth first elements : </p>
<pre><code>def sheet(l, n):
    return [e[0] for e in l[:n]]

sheet(l, 3)
</code></pre>
<p>Returns </p>
<pre><code>['Anna', 'Peter', 'Zani']
</code></pre>
<hr/>
<p><strong>EDIT</strong></p>
<pre><code>def sheet(l, n):
    for e in l[:n]
        return [e[0]]
</code></pre>
<p>This code only returns <code>['Anna']</code> because the <code>return</code> statement stops the function. The for loop is stopped at the first element.</p>
<pre><code>def sheet(l, n):
    return [e[0] for e in l[:n]]
</code></pre>
<p>is equivalent to :</p>
<pre><code>def sheet(l, n):
    result = [e[0] for e in l[:n]]
    return result
</code></pre>
<p>which is equivalent to :</p>
<pre><code>def sheet(l, n):
    result = []
    for e in l[:n]:
        result.append(e[0])
    return result
</code></pre>
<p>The for loop can ends before the return statement.</p>
<p>More informations <a href="https://docs.python.org/3/tutorial/datastructures.html#tut-listcomps" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst = [["Anna","w",15],["Peter","m",20],["Zani","m",10], ["Lily","w",19]]
n = 2
print(lst[n][0])
</code></pre>
<p>Output:
Zani</p>
<p>---Updated answer for the details added in the question---</p>
<pre><code>l = [["Anna","w",15],["Peter","m",20],["Zani","m",10], ["Lily","w",19]]
n = 2
for i in range(n):
  print(l[i][0])
</code></pre>
<p>Output:</p>
<p>Anna</p>
<p>Peter</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension. Given an input list of lists <code>L</code>:</p>
<pre><code>L_new = [i[0] for i in L[:n]]
</code></pre>
<p>Functionally, you can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a>. In addition, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a> to avoid creating an intermediary list:</p>
<pre><code>from operator import itemgetter
from itertools import islice

L_new = list(map(itemgetter(0), islice(L, 0, n)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just try this one which will be <strong>easier</strong> for you to understand:</p>
<pre><code>n = int(input())

lst = [["Anna","w",15],["Peter","m",20],["Zani","m",10], ["Lily","w",19]]
lst_new = []

for item in lst[:n]:
    name, *rest = item
    lst_new.append(name)
</code></pre>
</div>
<span class="comment-copy">Side note: <i>never</i> name a variable after a built-in class, e.g. use <code>L</code> or <code>lst</code> instead of <code>list</code>.</span>
<span class="comment-copy">@jpp variables should not start with caps so 'l' instead of 'L' (pep8)</span>
<span class="comment-copy">@CorentinLimier, <code>l</code> is a <i>big</i> "no". In many fonts, it is confused with capital <code>I</code>. In any case, the point about shadowing built-ins is different and far more important. You <b>never</b> want to override built-ins.</span>
<span class="comment-copy">Thank you very much!! but the expected result should be a list of string -&gt; ["Anna", "Peter","Zani"]</span>
<span class="comment-copy">result IS a list of strings @SuwanWang</span>
<span class="comment-copy">I see! Thank you!!</span>
<span class="comment-copy">Hey @Corentin Limier! Could you please also explain what is the difference between return [e[0] for e in l[:n]] and for e in  l[:n]] \n return [e[0]]. With the second one, it only returns ["Anna"]. But the logic seems the same. Thank you in advance!</span>
<span class="comment-copy">@SuwanWang I edited to add more details on this.</span>
<span class="comment-copy">Does not answer the question</span>
<span class="comment-copy">easier ? with *rest ? This is advanced python</span>
<span class="comment-copy">I would not say it is advanced one. At least it is easier to visualize. *rest just get all elements after the first one.</span>
