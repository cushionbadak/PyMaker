<div class="post-text" itemprop="text">
<p>I have the following problem with the constraint that I do not have access to <code>import pandas</code> or anything but the standard libraries. </p>
<p>Dictionary with ID-type1 : label.</p>
<pre><code>{'ID1': 'Label1',
 'ID2': 'Label2',
 'ID3': 'Label2',
 'ID3': 'Label3',
 'ID4': 'Label1',
 'ID5': 'Label4'...}
</code></pre>
<p>List of 3-tuples with ID-type1, ID-type2, Val. Each ID has thousands of unique values.</p>
<pre><code>[('ID1', 'ID_Type2_1', 0.3695652173913043),
 ('ID1', 'ID_Type2_2', 0.35714285714285715),
 ('ID1', 'ID_Type2_3', 0.4146341463414634),
 ('ID2', 'ID_Type2_1', 0.3125),
 ('ID2', 'ID_Type2_2', 0.4418604651162791),
 ('ID2', 'ID_Type2_3', 0.34285714285714286),
 ('ID3', 'ID_Type2_5', 0.35714285714285715),
 ('ID3', 'ID_Type2_3', 0.3488372093023256),
 ('ID3', 'ID_Type2_2', 0.3958333333333333)...]
</code></pre>
<p>If the dictionary were a dataframe with name A (3 columns), and the list a dataframe with name B (2 columns). I would like to do the following pseudo logic.</p>
<p>Attach label to the list of tuples.</p>
<p><code>C = left_join(A, B, on =ID-type1)</code></p>
<p>Then select the mode(label) for each ID-type2 among rows corresponding to the top m values in the column <code>Val</code> or in other words, group by ID-type-2, then keep only the top <code>m</code> (integer) rows based on <code>Val</code> column, then select the mode/most common value of the <code>label</code> column.</p>
<p><code>C.groupby(ID_type-2).arrange(Val).select(rank = n()).filter(rank &lt;= m).select(mode(label))</code></p>
<p>In other words, the desired output is a list of tuple with (ID-type2, Label)</p>
<p>edit: I think the first step can be done with something like this? But the second step is the challenging part</p>
<pre><code>from collections import defaultdict
dd = defaultdict(list)
for d in (d1, labels): # you can list as many input dicts as you want here
    # d.iteritems() in 2.0
    for key, value in d.items():
        dd[key].append(value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you can do this with <a href="https://docs.python.org/2/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> and the <a href="https://docs.python.org/3/library/statistics.html#statistics.mode" rel="nofollow noreferrer"><code>statistics</code></a> module. Consider the following sample data that you posted in your question:</p>
<pre><code>import itertools
import statistics

d = {'ID1': 'Label1',
     'ID2': 'Label2',
     'ID3': 'Label2',
     'ID3': 'Label3',
     'ID4': 'Label1',
     'ID5': 'Label4'}

tups = [('ID1', 'ID_Type2_1', 0.3695652173913043),
        ('ID1', 'ID_Type2_2', 0.35714285714285715),
        ('ID1', 'ID_Type2_3', 0.4146341463414634),
        ('ID2', 'ID_Type2_1', 0.3125),
        ('ID2', 'ID_Type2_2', 0.4418604651162791),
        ('ID2', 'ID_Type2_3', 0.34285714285714286),
        ('ID3', 'ID_Type2_5', 0.35714285714285715),
        ('ID3', 'ID_Type2_3', 0.3488372093023256),
        ('ID3', 'ID_Type2_2', 0.3958333333333333),
        ('ID2', 'ID_Type2_5', 0.4958333333333333)]
</code></pre>
<p>You can create the "join" with a simple list comprehension:</p>
<pre><code>res = [(idt2, idt1, d[idt1], val) for idt1, idt2, val in tups]
</code></pre>
<p>Now, you can create your groups with <code>itertools.groupby</code>. Here I'm storing the grouped results in another dictionary:</p>
<pre><code>res.sort() # groupby expects the list to be sorted by the grouping key

# group by id type 2 and store those grouped lists sorted in descending order of Val
groups = {k: sorted(list(g), key=lambda x: x[-1], reverse=True) for k, g in itertools.groupby(res, key=lambda x: x[0])}
</code></pre>
<p>For the sample data above, the groups look like this:</p>
<pre><code>[('ID_Type2_3', 'ID1', 'Label1', 0.4146341463414634), ('ID_Type2_3', 'ID3', 'Label3', 0.3488372093023256), ('ID_Type2_3', 'ID2', 'Label2', 0.34285714285714286)]                   
[('ID_Type2_1', 'ID1', 'Label1', 0.3695652173913043), ('ID_Type2_1', 'ID2', 'Label2', 0.3125)]                                                                                     
[('ID_Type2_2', 'ID2', 'Label2', 0.4418604651162791), ('ID_Type2_2', 'ID3', 'Label3', 0.3958333333333333), ('ID_Type2_2', 'ID1', 'Label1', 0.35714285714285715)]                   
[('ID_Type2_5', 'ID2', 'Label2', 0.4958333333333333), ('ID_Type2_5', 'ID3', 'Label3', 0.35714285714285715)]
</code></pre>
<p>And now you can get your mode with a simple list slice of each group up to <code>m</code> values:</p>
<pre><code>for k, g in groups.items():
    # label_mode_of_first_m_values_for_this_group = statistics.mode([label for idt2, idt1, label, val in g[:m]])
</code></pre>
</div>
<span class="comment-copy">I don't see any coding attempt within your given restrictions.  What you've supplied is not pseudo-code within the given paradigm.  This appears to be a simple matter: iterate through your triples.  For each, use the first element to look up the label.  Emit that with your second element, appending <i>that</i> tuple to your output list.</span>
<span class="comment-copy">I'm struggling to understand the question of the second part, not clear to me what <code>m</code> is and how to filter based on it?</span>
<span class="comment-copy">@SvenHarris For each ID-type2 group, only keep the top m (integer) values of <code>Val</code> and their corresponding <code>label</code>s.</span>
<span class="comment-copy">Thank you it worked. On python 2, so had to use a different method for mode.</span>
