<div class="post-text" itemprop="text">
<p>What I try to implement is a timeout countdown which can be interrupted by a <code>pynput</code> key event.</p>
<p>In my first implementation there is a bug: I do not see a possibility to tell the pynput thread that the timeout is over.</p>
<p>According to Python <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a> documentation, do I need to create a more complex <em>Condition</em> object, or kind of a sync thread? Or is what I want to extend the original pynput class?</p>
<p>For me it is very hard to understand in this case which one thread is here <em>producer</em> either <em>consumer</em>.</p>
<p>The code..</p>
<p>Module code</p>
<pre><code>import threading
import time
from pynput import keyboard
import subprocess

class CountdownWithInterrupt:
    """A countdown feature which user can interrupt by pressing Enter key"""
    def __init__(self, interval, message="Press enter to continue..."):
        """Constructor"""
        self.window_id = self.obtain_window_id()
        self.interrupt_key = keyboard.Key.enter
        self.message = message
        self.user_pressed_key = False
        self.timeout_over = False
        self.timer_thread = threading.Thread(name='timer',
                                             target=self.timer,
                                             kwargs={"interval":interval})
        self.kblistener_thread = threading.Thread(name='keyboard_listener',
                                                  target=self.keyboard_listener)

    def obtain_window_id(self):
    """Ignore keyboard events if they come from other windows"""
        try:
            result = subprocess.run(['xdotool', 'getactivewindow'], stdout=subprocess.PIPE)
            window_id = result.stdout
        except DisplayNameError:
            window_id = print (random.randint(1,21)*5)

        return window_id

    def lock(self):
        return self.user_pressed_key or self.timeout_over

    def start(self):
        """starts countdown"""
        print(self.message)
        self.timer_thread.start()
        self.kblistener_thread.start()


    def on_release(self, key):
        """listener action"""
        if (self.window_id != self.obtain_window_id()):
            return True
        if key == self.interrupt_key:
            # Stop listener
            self.user_pressed_key = True
            return False

        return True

    def keyboard_listener(self):
        """listen for interrupt"""
        with keyboard.Listener(on_release=self.on_release) as listener:
            listener.join()

    def timer(self, interval):
        """set up the resource to be used by the consumer"""
        time_left = interval
        while time_left &gt; 0:
            if self.user_pressed_key:
                break
            print(time_left, end='\r', flush=True)
            time.sleep(1)
            time_left = time_left - 1
        self.timeout_over = True
</code></pre>
<p>The actual program</p>
<pre><code>from modules.helpers import CountdownWithInterrupt

msg =  ("Press enter..")
interruptableCountdown = CountdownWithInterrupt(5, msg)
interruptableCountdown.start()
while(interruptableCountdown.lock() == False):
    pass
print("tuut!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Worked for me with <code>listener.stop()</code>.</p>
</div>
