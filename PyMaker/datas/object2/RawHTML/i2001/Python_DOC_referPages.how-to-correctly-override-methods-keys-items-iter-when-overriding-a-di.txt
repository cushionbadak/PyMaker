<div class="post-text" itemprop="text">
<p>I am trying to make an enhancement in dict which supports file operation in particular folder in a way it's done in a dict. 
Following is an example</p>
<pre><code>if __name__ == "__main__":
    d = FolderDict("LALALA", create_new=True)
    d["File1"] = "Content of file 1"
    d["File2"] = "Content of file 2"
</code></pre>
<p>It creates two files in LALALA folder with correct content.
I could handle get,set,contains,del,pop methods correctly but I can't seem to wrap my hand around keys(),values(),<strong>iter</strong> methods.</p>
<p>I want all the file names to be printed when I call keys(), and when I iter on it I want </p>
<p>k - Name of file
v - content of file</p>
<p>Following my code, Please have a look and help.</p>
<pre><code>import os


class FolderDict(dict):

    def get_absolute_path(self, file_name):
        return os.path.join(self.folder_path, file_name)

    def __init__(self, folder_path, create_new=False):
        super().__init__()
        self.folder_path = folder_path
        if os.path.exists(self.folder_path) and os.path.isdir(self.folder_path):
            for file_name in os.listdir(self.folder_path):
                with open(self.get_absolute_path(file_name), "r") as reader:
                    self[file_name] = reader.read()
        else:
            if create_new:
                os.makedirs(folder_path, exist_ok=True)
            else:
                raise FileNotFoundError("[Errno 2] No such file or directory: '{}'".format(self.folder_path))

    def __getitem__(self, item):
        with open(self.get_absolute_path(item), "r") as reader:
            return reader.read()

    def __setitem__(self, key, value):
        """
        Be careful,it will overwrite the existing file.
        We support w mode not a mode now
        """
        with open(self.get_absolute_path(key), "w") as writer:
            writer.write(value)

    def keys(self):
        yield from super().keys()

    def __iter__(self):
        yield from self.keys()

    def __contains__(self, item):
        return os.path.exists(self.get_absolute_path(item))

    def __missing__(self, key):
        raise FileNotFoundError("[Errno 2] No such file or directory: '{}'".format(self.get_absolute_path(key)))

    def __delitem__(self, key):
        os.remove(self.get_absolute_path(key))

    def get(self, k, default=None):
        return self[k] if k in self else default

    def pop(self, k):
        content = self[k]
        os.remove(self.get_absolute_path(k))
        return content

    def __repr__(self):
        return "FolderDict for folder {}".format(self.folder_path)

    __str__ = __repr__


if __name__ == "__main__":
    d = FolderDict("LALALA", create_new=True)
    d["File1"] = "Content of file 1"
    d["File2"] = "Content of file 2"
    d["File3"] = "Content of file 3"

    for k,v in d:
        print(k)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>1:you didn't even save the information of filenames,so your keys() function doesn't work</p>
<p>2:Inherit class UserDict instead of inheriting class dict</p>
<p>3:I can't see what's the meaning of inherit class like dict/UserDict ....</p>
<p>4:To use FolderDict like real dict ,what you need to to is write <code>__iter__  __next__ __getitem__  __setitem__  __next__  __getattribute__   __delitem__ keys items values</code> ...... in your class.</p>
<pre><code>import os
from collections import UserDict


class FolderDict(UserDict):

    def get_absolute_path(self, file_name):
        return os.path.join(self.folder_path, file_name)

    def __init__(self, folder_path, create_new=False):
        super().__init__()
        self._dict = {}
        self.folder_path = folder_path
        if os.path.exists(self.folder_path) and os.path.isdir(self.folder_path):
            for file_name in os.listdir(self.folder_path):
                with open(self.get_absolute_path(file_name), "r") as reader:
                    self[file_name] = reader.read()
        else:
            if create_new:
                os.makedirs(folder_path, exist_ok=True)
            else:
                raise FileNotFoundError("[Errno 2] No such file or directory: '{}'".format(self.folder_path))

    def __getitem__(self, item):
        with open(self.get_absolute_path(item), "r") as reader:
            return reader.read()

    def __setitem__(self, key, value):
        """
        Be careful,it will overwrite the existing file.
        We support w mode not a mode now
        """
        with open(self.get_absolute_path(key), "w") as writer:
            writer.write(value)
        self._dict[key] = value

    def keys(self):
        return self._dict.keys()

    def __iter__(self):
        return iter(self._dict.items())

    def __contains__(self, item):
        return os.path.exists(self.get_absolute_path(item))

    def __missing__(self, key):
        raise FileNotFoundError("[Errno 2] No such file or directory: '{}'".format(self.get_absolute_path(key)))

    def __delitem__(self, key):
        os.remove(self.get_absolute_path(key))

    def get(self, k, default=None):
        return self[k] if k in self else default

    def pop(self, k):
        content = self[k]
        os.remove(self.get_absolute_path(k))
        return content

    def __repr__(self):
        return "FolderDict for folder {}".format(self.folder_path)

    __str__ = __repr__


if __name__ == "__main__":
    d = FolderDict("LALALA", create_new=True)
    d["File1"] = "Content of file 1"
    d["File2"] = "Content of file 2"
    d["File3"] = "Content of file 3"

    for k,v in d:
        print(k,v)
    for k in d.keys():
        print(k)
</code></pre>
</div>
<span class="comment-copy">in python 3 <code>dict.keys()</code> and <code>dict.values()</code> returns a view object, explained briefly in <code>help(dict.keys)</code>: <code>D.keys() -&gt; a set-like object providing a view on D's keys</code>, or <a href="https://docs.python.org/3/library/stdtypes.html#dict.keys" rel="nofollow noreferrer">more here</a>.</span>
