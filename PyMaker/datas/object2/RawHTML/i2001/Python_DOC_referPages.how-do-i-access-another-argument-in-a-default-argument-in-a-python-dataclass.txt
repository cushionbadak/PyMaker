<div class="post-text" itemprop="text">
<p>I am trying to derive the default value of <code>id_</code> from <code>name</code> and vice versa.</p>
<pre><code>@dataclass
class Item:
    id_ = NAME_TO_ID[name]
    name = ID_TO_NAME[id_]
</code></pre>
<p>I should be able to call the class like so:</p>
<pre><code>Item(id_=123)
Item(name='foo')
</code></pre>
<p>If possible, I would also like the class to raise an error when both <code>id_</code> and <code>name</code> are provided.</p>
<pre><code>Item(id_=123, name='foo')  # ValueError: id_ and name cannot be provided together
</code></pre>
<p>Any recommendations on how I should go about doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use write a <a href="https://docs.python.org/3/library/dataclasses.html#post-init-processing" rel="nofollow noreferrer"><code>__post_init__</code></a> method to do these validations</p>
<pre><code>from dataclasses import dataclass, field

@dataclass
class Item:
    id_: int = field(default=None)
    name: str = field(default=None)
    def __post_init__(self):
        if self.id_ is None and self.name is None:
            raise TypeError("You must provide exactly one of name or id_")
        if self.id_ is not None and self.name is not None:
            raise TypeError("You must provide exactly one of name or id_")
        if self.id_ is not None:
            self.name = id_to_name(self.id_)
        else:
            self.id_ = name_to_id(self.name)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You'll need to use the <code>__init__</code> function of your <code>class</code>.</p>
<p>For example,</p>
<pre><code>class Item:
    # define __init__ such that it has a condition when both id_ and name are supplied
    # a ValueError is raised
    def __init__(self, id_, name=None):
        if (id_ and name):
            # raise error because both were supplied
            raise ValueError
        if (id_):
            # assign name and id
        elif (name):
            # assign name and id
</code></pre>
<p>Here, though, the user has to pass a value for both.  You can simply supply <code>False</code> or <code>None</code> or some falsy value so that it is passed over and the ValueError isn't thrown.</p>
</div>
<div class="post-text" itemprop="text">
<p>Would something as simple as the below work for you?</p>
<p>At object instantiation, check if too much or too little data was provided, then define a property that will compute the value if necessary?</p>
<pre><code>class Item ():
    def __init__(self, id: int =None, name:str= None):
        if all ([name, id]):
            raise ValueError ("id_ and name cannot be provided together")
        elif not any ([name, id]):
            raise ValueError ("name or id must be provided for Item instantiation")
        else:
            self._name = name
            self._id = id
    @property
    def name (self) -&gt; str:
        if self._name is None:
            #Compute the value and return it
            pass #remove this once you figure out your algorithm
        else:
            return self._name
    @property
    def id (self) -&gt;int:
        if self._id is None:
            #Compute the value and return it
            pass #remove this once you figure out your algorithm
       else:
           return self._id
</code></pre>
<p>Note that you must also take into consideration what a valid value is. In my provided example case, it is not sufficient if you consider integer <code>0</code> a valid <code>id</code>, and an empty string <code>""</code> a valid <code>name</code>.</p>
</div>
<span class="comment-copy">You should use a standard python class instead</span>
<span class="comment-copy">Yeah, I am. I'm just trying to see if there's a way to approach this with dataclasses.</span>
<span class="comment-copy">How is that any better than just a <code>__init__</code> with the validation for both fields? We don't need to push dataclasses for everything</span>
<span class="comment-copy">@JBernardo Because if you have other fields, you can use the generated <code>__init__</code> for them.  This is a question explicitly about dataclasses</span>
<span class="comment-copy">Was that tag just added? The comment the OP made seemed to imply that he was just trying to see if a dataclass solution makes sense, but in my opinion it's a little overkill. That is just my opinion, however.</span>
<span class="comment-copy">Yes (by me).  The title was always "How do I access another argument in a default argument in a python dataclass?" though</span>
