<div class="post-text" itemprop="text">
<p>I was given a homework assignment to find all possible sequences of a given word. eg. if <code>word = 'abc'</code>, the below code would return <code>['a', 'ab', 'abc', 'ac', 'acb', 'b', 'ba', 'bac', 'bc', 'bca', 'c', 'ca', 'cab', 'cb', 'cba']</code>.</p>
<p>However, this feels inefficient. I'm just starting to learn recursion, so I'm not sure if there is a better or more efficient way to produce these sequences?</p>
<p>edit:
I think it's necessary to add a couple things as I kept working and reading the material</p>
<ul>
<li>Duplicates are fine, those are sorted out in a separate function</li>
<li>Each value is unique, so sequence 'aab' should produce two 'aa' sequences</li>
</ul>
<hr/>
<pre><code>def gen_all_strings(word):
    if len(word) == 1:
        return list(word)
    else:
        main_list = list()
        for idx in range(len(word)):
            cur_val = word[idx]
            rest = gen_all_strings(word[:idx] + word[idx+1:])
            main_list.append(cur_val)
            for seq in rest:
                main_list.append(cur_val + seq)
        return main_list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Itertools and list comprehensions are good for breaking stuff down like this.</p>
<pre><code>import itertools

["".join(x) for y in range(1, len(word) + 1) for x in itertools.permutations(word, y)]
</code></pre>
</div>
<span class="comment-copy">If you're only looking for efficiency, python has an optimized <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> library that has built-in cobination/permutation functions</span>
