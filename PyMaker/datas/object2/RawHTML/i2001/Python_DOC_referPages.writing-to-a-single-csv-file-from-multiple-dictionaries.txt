<div class="post-text" itemprop="text">
<p><strong>Background</strong></p>
<p>I have multiple dictionaries of different lengths. I need to write the values of dictionaries to a single CSV file. I figured I can loop through each dictionary one by one and write the data to CSV. I ran in to a small formatting issue.</p>
<p><strong>Problem/Solution</strong></p>
<p>I realized after I loop through the first dictionary the data of the second writing gets written the row where the first dictionary ended as displayed in the <strong>first image</strong> I would ideally want my data to print as show in the <strong>second image</strong></p>
<p><a href="https://i.stack.imgur.com/tHqQB.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/tHqQB.png"/></a>
<a href="https://i.stack.imgur.com/qvk5E.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/qvk5E.png"/></a></p>
<p><strong>My Code</strong></p>
<pre><code>import csv

    e = {'Jay':10,'Ray':40}
    c = {'Google':5000}

    def writeData():
        with open('employee_file20.csv', mode='w') as csv_file:
            fieldnames = ['emp_name','age','company_name','size']
            writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
            writer.writeheader()

            for name in e:
                 writer.writerow({'emp_name':name,'age':e.get(name)})

            for company in c:
                writer.writerow({'company_name':company,'size':c.get(company)})


    writeData()
</code></pre>
<p>PS: I would have more than 2 dictionaries so I am looking for a generic way where I can print data from row under the header for all the dictionaries. I am open to all solutions and suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>If all dictionaries are of equal size, you could use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to iterate over them in parallel. If they aren't of equal size, and you want the iteration to pad to the longest dict, you could use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a></p>
<p>For example:</p>
<pre><code>import csv
from itertools import zip_longest

e = {'Jay':10,'Ray':40}
c = {'Google':5000}

def writeData():
    with open('employee_file20.csv', mode='w') as csv_file:
        fieldnames = ['emp_name','age','company_name','size']
        writer = csv.writer(csv_file)
        writer.writerow(fieldnames)

        for employee, company in zip_longest(e.items(), c.items()):
            row = list(employee)
            row += list(company) if company is not None else ['', '']  # Write empty fields if no company

            writer.writerow(row)

writeData()
</code></pre>
<p>If the dicts are of equal size, it's simpler:</p>
<pre><code>import csv

e = {'Jay':10,'Ray':40}
c = {'Google':5000, 'Yahoo': 3000}

def writeData():
    with open('employee_file20.csv', mode='w') as csv_file:
        fieldnames = ['emp_name', 'age', 'company_name', 'size']
        writer = csv.writer(csv_file)
        writer.writerow(fieldnames)

        for employee, company in zip(e.items(), c.items()):
            writer.writerow(employee + company)

writeData()
</code></pre>
<p>A little side note: If you use Python3, dictionaries are ordered. This isn't the case in Python2. So if you use Python2, you should use <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> instead of the standard dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>There might be a more pythonic solution, but I'd do something like this:</p>
<p>I haven't used your .csv writer thing before, so I just made my own comma separated output.</p>
<pre><code>e = {'Jay':10,'Ray':40}
c = {'Google':5000}
dict_list = [e,c] # add more dicts here.
max_dict_size = max(len(d) for d in dict_list)
output = ""
# Add header information here.
for i in range(max_dict_size):
  for j in range(len(dict_list)):
    key, value = dict_list[j].popitem() if len(dict_list[j]) else ("","")
    output += f"{key},{value},"
  output += "\n"
# Now output should contain the full text of the .csv file
# Do file manipulation here.
# You could also do it after each row,
# Where I currently have the output += "\n"
</code></pre>
<p>Edit: A little more thinking and I found something that might polish this a bit. You could first map the dictionary into a list of keys using the .key() function on each dictionary and appending those to an empty list.</p>
<p>The advantage with that is that you'd be able to go "forward" instead of popping the dictionary items off the back. It also wouldn't destroy the dictionary.</p>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/53013274/writing-data-to-csv-from-dictionaries-with-multiple-values-per-key/53013353#53013353" title="writing data to csv from dictionaries with multiple values per key">stackoverflow.com/questions/53013274/â€¦</a></span>
<span class="comment-copy">I posted a follow up question not sure if you know the solution around it.</span>
