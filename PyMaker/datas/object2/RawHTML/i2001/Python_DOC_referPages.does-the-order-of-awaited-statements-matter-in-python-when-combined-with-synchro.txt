<div class="post-text" itemprop="text">
<p>Does it make sense to move operations that can be awaited to the top of a method to be able to do work while they are being awaited?</p>
<h2>Example</h2>
<h3>in logical order</h3>
<pre><code>async def set_new_password(user_id, new_password):
    hash = bcrypt(new_password)
    db_handle = await async_get_db_handle()
    await async_write_password(db_handle, user_id, hash)
</code></pre>
<p>Here afaiu Python will calculate the hash, then create the coroutine for the db handle, then the coroutine for the write operation and then give control to the event loop that will schedule both operations.</p>
<p>In that case, assuming this is our only method call, we "wasted" time hashing the password, and the following would be faster.</p>
<h3>synchronous as late as possible</h3>
<pre><code>async def set_new_password(user_id, new_password):
    db_handle = await async_get_db_handle()
    hash = bcrypt(new_password)
    await async_write_password(dh_handle, user_id, hash)
</code></pre>
<p>Here while the db_handle is awaited the password would be hashed, so we would use the "down time" to do something useful.</p>
<p><strong>So should I aspire to always put not-awaitable statements as late as possible so that they can be executed while awaitable statements are awaited?</strong></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>... while the db_handle is awaited the password would be hashed, so we would use the "down time" to do something useful.</p>
</blockquote>
<p>I don't think this is correct. The effect of <code>await</code> is to prevent the next line from executing until the db_handle is returned. It makes the calling code behave like synchronous code, so the normal ordering considerations apply.</p>
<p>If you want to do some work while getting the handle you could use a <a href="https://docs.python.org/3/library/asyncio-task.html#awaitables" rel="nofollow noreferrer">Task</a>.</p>
<pre><code>async def set_new_password(user_id, new_password):
    task = asyncio.create_task(get_db_handle())
    hash = bcrypt(new_password)
    db_handle = await task
    await async_write_password(db_handle, user_id, hash)
</code></pre>
</div>
<span class="comment-copy">Ah, yes. I forgot about that. So the event loop would only process other code (from other methods) that is awaited but not the subsequent code of this method?</span>
<span class="comment-copy">I think it might not have bene clear that get_db_handle() is asynchronous as well. I changed the name to make it so. Sorry about that.</span>
<span class="comment-copy">Yes, it could do other work while blocked by the <code>await</code>. (And, yes, I was aware that get_db_handle() was asynchronous.)</span>
<span class="comment-copy">But then how is your solution different from my first solution. I am awaiting a couroutine, you are awaiting a task. How is this different?</span>
<span class="comment-copy">In this case it may not be different, because bcrypt will probably return before the task begins running anyway. But if that operation contains asynchronous operations it may get a chance to run in parallel.</span>
