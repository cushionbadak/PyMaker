<div class="post-text" itemprop="text">
<p>Is there a built-in function that could compare the values of a dictionary, like the built-in <code>all()</code> function can compare a list or tuple for example and return <code>True</code> or <code>False</code> + the dictionary key that it was from?</p>
<p>What I want to achieve, is to give the <code>all()</code> function a dictionary rather than a list. The default behaviour for <code>all()</code> would be to return <code>True</code> if there is an element missing or that is falsey:</p>
<pre><code>&gt;&gt;&gt; all([1,2,3,4,0])
False
&gt;&gt;&gt; all(['hello', 'world', ''])
False
&gt;&gt;&gt; all(['hello', 'world', None])
False
&gt;&gt;&gt; all([1,2,3,4])
True
&gt;&gt;&gt; all(['hello', 'world'])
True
</code></pre>
<p>With the vanilla <code>all()</code> function, it only returns the <code>True</code> of <code>False</code> value, which is fine for comparison if I want to check these booleans. However, I cannot then know which of the values were  falsey, in order to tell the user why there was a problem.</p>
<p>I have created a function which will just that. In addition to a boolean, it returns the element's key for which the value was falsey:</p>
<pre><code># dictionary all function (working with 3.x)
def dict_all(iterable):
    for key in iterable:
        if not iterable[key]:
            return False, key
    return True
</code></pre>
<p>I want it to exit early, we don't need to test all values.</p>
<p>Is there a built-in function that does this? If not, why not? It seems like it would be useful in all sorts of instances.</p>
<p>I'm using this for a function where each of the keyword arguments have a default value of <code>None</code>, to supply a default for when the user does not set a value. I use  <code>dict_all()</code> function provide an error message when <code>False, key</code> is returned.</p>
<p>For example:</p>
<pre><code>dictionary = {'jira_key' : 'REDACTED',
    'summary' : 'this is a test',
    'desc' : 'this is a description',
    'req_type' : 'PMV',
    'comp_type' : None}
</code></pre>
<p>Expected outcome is return <code>False, 'comp_type'</code></p>
<p>Also for those refuting the usefulness of the <code>True</code> and <code>False</code> being returned as a Tuple, I give you this example:</p>
<pre><code>&gt;&gt;&gt; example = dict_all(iterable)
#if iterable is the example dictionary above
#the result would be
&gt;&gt;&gt; print(example)
(False, 'comp_type')
#which means
#example[0] is a Truthy or Falsey for the value in the key
#they key is example[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All you need to do is to iterate over the key-value <em>pairs</em> so you can test the value without having to refer back to the original mapping again, and return the key when the value is falsey. You also need to be <em>consistent in your return type</em>, and return a tuple in both cases:</p>
<pre><code>def dict_all(mapping):
    for key, value in mapping.items():
        if not value:
            return False, key
    return True, None
</code></pre>
<p>Note the change on the last line, you really don't want to return a tuple for the false case, and a single boolean for the true case, because then you also have to test the return type before you can actually know what was missing.</p>
<p>There is no 'built-in' function for this because <code>all()</code> (and <code>any()</code>) are designed purely to produce a yes or no answer to the question: <em>do all elements of an iterable pass a test</em>.</p>
<p>You are asking something different; your code needs to know <em>what the first key is that fails to pass the test</em>. </p>
<p>For that question, I'd use the <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next()</code> function</a>, with a generator expression and a default value:</p>
<pre><code>empty = next((key for key, value in mapping.items() if not value), None)
if empty is not None:
    raise CustomException('Missing value for {}'.format(empty))
</code></pre>
<p>There is no need to return <code>True</code> or <code>False</code> here; we detect that there was no key that failed the test when the default case was picked, we replaced the <code>True</code> or <code>False</code> value with a test for <code>empty is not None</code>.</p>
<p>Any unique sentinel will do; <code>None</code> is the usual choice, but you could use <code>object()</code> if your input dictionary used <code>None</code> as a valid key:</p>
<pre><code>_sentinel = object()
empty = next((key for key, value in mapping.items() if not value), _sentinel)
if empty is not _sentinel:
    raise CustomException('Missing value for {}'.format(empty))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>edit: This answer was written in the context of your original <code>dict_all</code> function before you edited it.</p>
<pre><code>def dict_all(iterable):
    for i, e in enumerate(iterable):
        if not iterable[e]:
            return False, e
    return True
</code></pre>
<p>I have three remarks.</p>
<p>First, I'm not sure whether you are aware of it, so I'll point it out: your <code>dict_all</code> looks for falsy <em>values</em>, while a dictionary is an iterable over its keys.</p>
<pre><code>&gt;&gt;&gt; d = {1:2, 3:0}
&gt;&gt;&gt; all(d)
True
&gt;&gt;&gt; dict_all(d)
(False, 3)
</code></pre>
<p>Second, the <code>enumerate</code> in your function seems pointless. Consider the following generator expression.</p>
<pre><code>&gt;&gt;&gt; next(((False, key) for key, value in d.items() if not value), (True, None))
(False, 3)
&gt;&gt;&gt; d = {1:2, 3:4}
&gt;&gt;&gt; next(((False, key) for key, value in d.items() if not value), (True, None))
(True, None)
</code></pre>
<p>Third, wouldn't be getting the actual falsy value be more useful than just getting <code>False</code>? In that case use <code>(value, key)</code> instead of <code>(False, key)</code> in the expression above.</p>
<p>edit: since you asked for a library function, you could use <code>itertools.dropwhile</code> to drop dictionary items with truthy values.</p>
<pre><code>&gt;&gt;&gt; from itertools import dropwhile    
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; 
&gt;&gt;&gt; d = {1:2, 3:4, 5:0}
&gt;&gt;&gt; next((dropwhile(itemgetter(1), d.items())), None)
&gt;&gt;&gt; (5, 0)
</code></pre>
<p>This will give you <em>a</em> (key, value) pair with a falsy value or <code>None</code>.</p>
</div>
<span class="comment-copy">what about <code>all(my_dict.values())</code> ?</span>
<span class="comment-copy">You edited your <code>dict_all</code> function to do something different. Which one are you using? Should I delete my answer?</span>
<span class="comment-copy">@Jean-FrançoisFabre I had not considered that. I will give it a whirl and get back to you :)</span>
<span class="comment-copy">@Jean-FrançoisFabre: that won't work because each <code>(key, value)</code> tuple is true, and <code>all()</code> still will only produce a yes or no answer, not the answer to this different question, which is "what is the first key that fails to meet the criteria set".</span>
<span class="comment-copy">@Swift: no need, what Jean-François proposes can't work.</span>
<span class="comment-copy">I edited some of the scoped variables in the dict_all() function because you said I am not comparing the values, but that I'm checking for falsey keys, which I believe is a misunderstanding of the code.</span>
<span class="comment-copy">Vanilla <code>all()</code> function would check for falsey keys</span>
<span class="comment-copy">And also, please accept my thanks for your answer. I see the point your making but I think I made a mess of the question. Sorry Martijn :(</span>
<span class="comment-copy">@Swift: it's okay, we got there in the end.</span>
<span class="comment-copy">I like this <code>_sentinel</code> answer, I've not dived into custom errornhandlong much and that would be a very good use of my time to understand how that works. Thanks again Martijn. I will verify you answer works for purpose but it sounds like we have a weiner</span>
<span class="comment-copy">Sorry, I meant to comment on the other answer</span>
<span class="comment-copy">@Swift your original <code>dict_all</code> looks for falsy values in the dict and then returns the key. <code>all</code> looks whether there is any falsy key in the dict.</span>
<span class="comment-copy">I want the key from a falsey value. Sorry if that is not clear. If i just wanted falsey keys, then the builtin <code>all()</code> would work just fine :)</span>
<span class="comment-copy">@Swift yes, your function does that. The generators do this, too. I just wanted to point out that your <code>dict_all</code> does not just behave like <code>all</code> plus returning the falsy value.</span>
<span class="comment-copy">@Swift added mentioning <code>dropwhile</code> from <code>itertools</code>. You might find it useful for this task.</span>
