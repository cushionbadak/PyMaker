<div class="post-text" itemprop="text">
<p>I have a list of tuples for eg.  </p>
<pre><code>l1 = [(1, 'a', 'x'), (2, 'b', 'y'), (3, 'a', 'z'), (4, 'c', 'xyz')]
</code></pre>
<p>I have another list </p>
<pre><code>l2 = ['a', 'b', 'c']
</code></pre>
<p>I want to sort <code>l1</code> on the second value of every tuple according to the order present in <code>l2</code>. 
The final result should be </p>
<pre><code>l1 = [(1, 'a', 'x'), (3, 'a', 'z'), (2, 'b', 'y'), (4, 'c', 'xyz')]
</code></pre>
<p>As you can see, the tuples whose second value was <code>a</code> are present first, then comes tuples with second value <code>b</code> and the lastly those which have <code>c</code>.</p>
<p>I wrote the following:</p>
<pre><code>l = []
for i in l2:
    for j in l1:
        if i == j(1):
        l.append(j)
</code></pre>
<p>This is pretty straight forward. But I was wondering if there is any pythonic way to get this thing done?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted</code></a> with an appropriate <code>key</code> function:</p>
<pre><code>l1 = [(1, 'a', 'x'), (2, 'b', 'y'), (3, 'a', 'z'), (4, 'c', 'xyz')]
l2 = ['a', 'b', 'c']
d2 = {v: i for i, v in enumerate(l2)}  # map elements to indexes
# {'a': 0, 'b': 1, 'c': 2}

sorted(l1, key=lambda x: d2[x[1]])
# [(1, 'a', 'x'), (3, 'a', 'z'), (2, 'b', 'y'), (4, 'c', 'xyz')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a <code>dict</code> that uses the value as key and the index given by <code>enumerate(l2)</code> to sort it:</p>
<pre><code>l1 = [(1, 'a', 'x'), (2, 'b', 'y'), (3, 'a', 'z'), (4, 'c', 'xyz')]
l2 = ['a', 'b', 'c']

sorting ={key:idx for idx,key in enumerate(l2)}

l3 = sorted(l1, key = lambda x: sorting.get(x[1],9999999999))

print(l3)
</code></pre>
<p>Using a dict that way has the advantage of not using <code>index(...)</code> on every lookup into <code>l2</code>. </p>
<p>You would use <code>dict.get()</code> to avoid missing keys causing trouble and just provide a default thats sure to not be in the list so they get put at the end/front.</p>
<p>Output:</p>
<pre><code>[(1, 'a', 'x'), (3, 'a', 'z'), (2, 'b', 'y'), (4, 'c', 'xyz')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also just use the <em>sort</em> method of the list <code>l1</code> to sort on the second value of each tuple:</p>
<pre><code>l1 = [(1, 'a', 'x'), (2, 'b', 'y'), (3, 'a', 'z'), (4, 'c', 'xyz')]

l1.sort(key=lambda x: x[1])

print(l1)
</code></pre>
<p>If this is not sufficient and you need the second list <code>l2</code> for the definition of the order, you can use the <em>index</em> method of the list:</p>
<pre><code>l1 = [(1, 'a', 'x'), (2, 'b', 'y'), (3, 'a', 'z'), (4, 'c', 'xyz')]
l2 = ['a', 'b', 'c']

l1.sort(key=lambda x: l2.index(x[1]))

print(l1)
</code></pre>
</div>
