<div class="post-text" itemprop="text">
<p>I have a medium size excel file, with about 25000 rows.</p>
<p>In the excel file I check if a specific column value is in a list, and if is in the list I delete the row.</p>
<p>I'm using openpyxl.</p>
<p>The code:</p>
<pre><code>   count = 1
    while count &lt;= ws.max_row:
        if ws.cell(row=count, column=2).value in remove_list:
            ws.delete_rows(count, 1)
        else:
            count += 1
    wb.save(src)
</code></pre>
<p>The code works, but is very slow(take hours) to finish. </p>
<p>I know that is a read-only and write-only modes, but in my case, I use both, first checking and second deleting.</p>
</div>
<div class="post-text" itemprop="text">
<p>I see you are using a list of rows which you need to delete. Instead, you can create "sequences" of rows to delete, thus changing a delete list like [2,3,4,5,6,7,8,45,46,47,48] to one like [[2, 7],[45, 4]]</p>
<p>i.e. Delete 7 rows starting at row 2, then delete 4 rows starting at row 45</p>
<p>Deleting in bulk is faster than 1 by 1. I deleted 6k rows in around 10 seconds</p>
<p>The following code will convert a list to a list of lists/sequences:</p>
<pre><code>def get_sequences(list_of_ints):
    sequence_count = 1
    sequences = []
    for row in list_of_ints:
        next_item = None
        if list_of_ints.index(row) &lt; (len(list_of_ints) - 1):
            next_item = list_of_ints[list_of_ints.index(row) + 1]

        if (row + 1) == next_item:
            sequence_count += 1
        else:
            first_in_sequence = list_of_ints[list_of_ints.index(row) - sequence_count + 1]
            sequences.append([first_in_sequence, sequence_count])
            sequence_count = 1

    return sequences
</code></pre>
<p>Then run another loop to delete</p>
<pre><code>    for sequence in sequences:
        sheet.delete_rows(sequence[0], sequence[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Personally, I would do two things:</p>
<p>first transform the list into a set so the lookup of the item takes less time</p>
<pre><code>remove_set = set(remove_list)
...
if ws.cell(row=count, column=2).value in remove_set:
</code></pre>
<p>then I would avoid removing the rows in place, as it takes a lot of time to reorganise the data structures representing the sheet.</p>
<p>I would create a new blank worksheet and add to it only the rows which must be kept.</p>
<p>Then save the new worksheet, overwriting the original if you wish.</p>
<p>If it still takes too long, consider using a CSV format so you can treat the input data as text and output it the same way, re-importing the data later from the spreadsheet program (e.g. Ms-Excel)</p>
<p>Have a look at the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">official docs</a> and at <a href="https://realpython.com/python-csv/" rel="nofollow noreferrer">this tutorial</a> to find out how to use the CSV library</p>
<p>Further note: as spotted by @Charlie Clark, the calculation of</p>
<pre><code>ws.max_row
</code></pre>
<p>may take some time as well and there is no need to repeat it.</p>
<p>To do that, the easiest solution is to work backwards from the last row down to the first, so that the deleted rows do not affect the position of the ones before them.</p>
</div>
<span class="comment-copy">The slowdown is probably caused by the repeated calculation of <code>ws.max_row</code></span>
<span class="comment-copy">possible, but needs to be calculate each time because by deleting the total row nr is changing; an alternative ?</span>
<span class="comment-copy">Just work backwards from the end of the worksheet.</span>
<span class="comment-copy">The shuffling the cells doesn't take that long and gets quicker as you move down the rows. Probably quicker than going to and from CSV.</span>
<span class="comment-copy">the elements in the list are already unique, so besides that how a set can help ?</span>
<span class="comment-copy">Please read <a href="https://stackoverflow.com/q/8929284/1830895">here</a></span>
