<div class="post-text" itemprop="text">
<p>I have an input of the form: </p>
<pre><code>[[41.0, 42.0], [42.0, 17.0], [17.0, 46.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [36.0, 7.0], [36.0, 6.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]
</code></pre>
<p>How can I sort these pairs and keep just the consecutive ones (<strong>by consecutive I mean <code>[a, b]</code> where <code>b</code> is the next element, larger than <code>a</code>, but not necessarily in an increment of 1.</strong>). </p>
<p><strong>EDIT:</strong> My attempt: </p>
<pre><code>test_lst = [[41.0, 42.0], [42.0, 17.0], [17.0, 46.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [36.0, 7.0], [36.0, 6.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]
new_lst = []
for elem in test_lst:
    if elem[1] &gt; elem[0]:
        new_lst.append(elem)
</code></pre>
<p>where <code>new_lst</code> looks like: </p>
<pre><code>[[41.0, 42.0], [17.0, 46.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]
</code></pre>
<p>Now, for example, for the groups <code>[17.0, 46.0]</code> and <code>[17.0, 29.0]</code>, I want to keep just the second one in my list, so the one with the smallest difference between <code>elem[1]</code> and <code>elem[0]</code>.</p>
<p><strong>EDIT 2</strong> : </p>
<pre><code>test_lst = [[41.0, 42.0], [42.0, 17.0], [17.0, 46.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [36.0, 7.0], [36.0, 6.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]

sorted_lst = sorted(test_lst, key = lambda x: int(x[0]))
</code></pre>
<p>which gives: </p>
<pre><code>[[6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 46.0], [17.0, 29.0], [29.0, 30.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [36.0, 7.0], [36.0, 6.0], [41.0, 42.0], [42.0, 17.0], [46.0, 47.0]]
</code></pre>
<p>Now all I need to do is, in the case of repeating first element, keep the pair with the smallest second element. How can I do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since there are floats involved you should take some precautions when checking for exact equality:</p>
<pre><code>e = 0.0000001  # some epsilon value accounting for imprecision
sorted(x for x in lst if abs(x[1]-x[0]-1) &lt;= e)
# [[6.0, 7.0], [29.0, 30.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [41.0, 42.0], [46.0, 47.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>&gt;&gt;&gt; [x for x in a if x[0] + 1 == x[1]]
[[41.0, 42.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [6.0, 7.0], [29.0, 30.0]]
</code></pre>
<p>Then <a href="https://docs.python.org/3/howto/sorting.html#key-functions" rel="nofollow noreferrer">sort</a> it:</p>
<pre><code>&gt;&gt;&gt; sorted([x for x in a if x[0] + 1 == x[1]], key=lambda x: x[0])
[[6.0, 7.0], [29.0, 30.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [41.0, 42.0], [46.0, 47.0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>outer_list = [[41.0, 42.0], [42.0, 17.0], [17.0, 46.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [36.0, 7.0], [36.0, 6.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]
new_outer_list = []
for inner_list in outer_list:
    if inner_list[0]+1 == inner_list[1]:
        new_outer_list.append(inner_list)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like:</p>
<pre><code>values = [[41.0, 42.0], [42.0, 17.0], [17.0, 46.0], [46.0, 47.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [36.0, 7.0], [36.0, 6.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]

sortedValues = []

for value in values:
    if value[1] &gt; value[0]:
        sortedValues.append(value)

print(sortedValues)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pair the adjacent items in the list by zipping the list with itself but with one index apart, and since you apparently want the last item despite it not having a next item to compare to, you can manually add it to the list after reversing it so that it will always match. The following example assumes that your list is stored in variable <code>lst</code>:</p>
<pre><code>[[a, b] for (a, b), (n, _) in zip(lst, lst[1:] + [lst[-1][::-1]]) if b == n and b &gt; a]
</code></pre>
<p>This returns:</p>
<pre><code>[[41.0, 42.0], [17.0, 46.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0]]
</code></pre>
<p>Note that the third item <code>[46.0, 47.0]</code> in your expected output is incorrect because it is actually followed by <code>[33.0, 34.0]</code> in your original list, whose first element is not <code>47.0</code>.</p>
<p>And if you want to keep the items with the smallest second item when the first items duplicate, you can sort the list by the first item first, and the second item in reverse order, so that you can use the <code>dict</code> constructor to convert the list of two-item sublists into a dict to eliminate duplicates, and then convert the dict items to a list of sublists by mapping them to the <code>list</code> constructor:</p>
<pre><code>list(map(list, dict(sorted([(a, b) for (a, b), (n, _) in zip(lst, lst[1:] + [lst[-1][::-1]]) if b == n and b &gt; a], key=lambda t: (t[0], -t[1]))).items()))
</code></pre>
<p>This returns:</p>
<pre><code>[[6.0, 7.0], [7.0, 12.0], [12.0, 17.0], [17.0, 29.0], [29.0, 30.0], [33.0, 34.0], [34.0, 35.0], [35.0, 36.0], [41.0, 42.0]]
</code></pre>
</div>
<span class="comment-copy"><a href="https://mattgemmell.com/what-have-you-tried/" rel="nofollow noreferrer">what-have-you-tried</a></span>
<span class="comment-copy">edited, please look above</span>
<span class="comment-copy">So you first want to <code>filter</code> your list, so each sub-list is in order, and as a second step remove duplicate sublists (identified by the first entry) depending on the smallest second entry?</span>
<span class="comment-copy">Something like this.</span>
<span class="comment-copy">@bro-grammer please see my edit.</span>
<span class="comment-copy">Nice! Depending on python version you can also suggest <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-485-a-function-for-testing-approximate-equality" rel="nofollow noreferrer">math.isclose</a></span>
<span class="comment-copy">This does not look like what the OP wants at all. I'm baffled.</span>
<span class="comment-copy">Thanks, I managed the sorting, now how do I remove, for example   [17.0, 46.0] from  [17.0, 29.0], [17.0, 46.0] ?</span>
<span class="comment-copy">I've updated my answer accordingly then.</span>
<span class="comment-copy">Just noticed that you accepted a different answer whose result looks nothing like mine or what you posted in the question. Can you clarify why that answer is what you are looking for?</span>
