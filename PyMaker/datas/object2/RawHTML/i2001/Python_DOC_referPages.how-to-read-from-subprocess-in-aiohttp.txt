<div class="post-text" itemprop="text">
<p>I have a very simple server which reads from a subprocess and passes the data to any opened websockets. The problem I'm running into is that my approach to reading from the subprocess seems to break aiohttp in a way that I can't seem to follow:</p>
<pre><code>#!/usr/bin/env python3

import asyncio
from aiohttp import web
import subprocess

async def websocket_handler(request):
    ws = web.WebSocketResponse()
    await ws.prepare(request)
    request.app['websockets'].append(ws)
    try:
        async for msg in ws:
            print(msg)
            await asyncio.sleep(1)
    finally:
        request.app['websockets'].remove(ws)
    return ws


async def on_shutdown(app):
    for ws in app['websockets']:
        await ws.close(code=999, message='Server shutdown')
</code></pre>
<p>Here's where things go wrong:</p>
<pre><code>async def listen_to_process(app):
    print("listen to process")
    while True:
        print(" looping? ")
        await asyncio.sleep(0.1)
        # the problem seems to be here
        line = await app['process'].stdout.readline()
        # if line:
        #     buffer.append(line)

async def start_background_tasks(app):
    app['process_listener'] = app.loop.create_task(listen_to_process(app))


async def cleanup_background_tasks(app):
    print('cleanup background tasks...')
    app['process_listener'].cancel()
    await app['process_listener']


def init():
    app = web.Application()
    app['websockets'] = []
    app.router.add_get('/updates', websocket_handler)
    cmd = "very long running subprocess"
    app['process'] = subprocess.Popen(cmd.split(" "), stdout=subprocess.PIPE)
    app.on_startup.append(start_background_tasks)
    app.on_cleanup.append(cleanup_background_tasks)
    app.on_shutdown.append(on_shutdown)
    return app


web.run_app(init())
</code></pre>
<p>So, my question is: how can I read lines from stdout in a loop in the background of my application? Thank you kindly for any pointers.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please use <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio-subprocess" rel="nofollow noreferrer">asyncio subprocess API</a>:</p>
<pre><code>app['process'] = await asyncio.create_subprocess_exec(
                           shlex.split(cmd), stdout=subprocess.PIPE)
</code></pre>
<p>Small neat: use <a href="https://docs.python.org/3/library/shlex.html#shlex.split" rel="nofollow noreferrer">shlex</a> module to safely split a command line into a list of arguments.</p>
</div>
<span class="comment-copy">Basically, <code>subprocess.Popen</code> doesn't support asynchronous operation. You cannot <code>await</code> it. I am not sure will <code>aiohttp</code> automatically provide an alternative, but as you have the problem, I guess not.</span>
