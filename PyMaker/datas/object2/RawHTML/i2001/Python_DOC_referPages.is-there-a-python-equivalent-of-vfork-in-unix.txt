<div class="post-text" itemprop="text">
<p>I'm reading APUE. </p>
<pre><code>#include "apue.h"
int     globvar = 6;        /* external variable in initialized data */
int main(void)
{
    int     var;        /* automatic variable on the stack */
    pid_t   pid;
    var = 88;
    printf("before vfork\n");   /* we don′t flush stdio */
    if ((pid = vfork()) &lt; 0) {
        err_sys("vfork error");
    } else if (pid == 0) {      /* child */
        globvar++;              /* modify parent′s variables */
        var++;
        _exit(0);               /* child terminates */
    }
   /* parent continues here */
   printf("pid = %ld, glob = %d, var = %d\n", (long)getpid(), globvar, var);
   exit()

}
</code></pre>
<p>It's said that vfork() creates a child process without copying the address space the parent process has. And parent will wait until child process calls exit or exec. 
Is there anything similar in Python give this kind of low level control? How can this be achieved in Python if possible? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>vfork</code> is a mostly-obsolete optimization of <code>fork</code>, intended solely for uses where it is immediately followed by an <code>exec</code>. It was designed back when <code>fork</code> didn't use copy-on-write, and has been rendered almost entirely pointless by copy-on-write.</p>
<p>Your use of <code>vfork</code> is undefined behavior; modifying variables like <code>globvar</code> or <code>var</code> in the child is not allowed. Almost the only thing the child is allowed to do is call one of the <code>exec*</code> functions. The details are in the <a href="http://man7.org/linux/man-pages/man2/vfork.2.html" rel="nofollow noreferrer">man page</a>.</p>
<p>If your goal is to share memory between Python processes, you should do that with the <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code> module</a> and <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.sharedctypes" rel="nofollow noreferrer"><code>multiprocessing.sharedctypes</code></a>.</p>
<p>If your goal is to call <code>vfork</code>, go ahead and call it with <code>ctypes</code>, and watch your program immediately fall apart because it's impossible to call <code>vfork</code> safely from Python:</p>
<pre><code>$ cat asdf.py
import ctypes
import os

lib = ctypes.CDLL('libc.so.6')
vfork = lib.vfork

if not vfork():
    os.execv('/usr/bin/echo', ['echo', 'hello', 'world'])

print("Should print in parent, but doesn't due to memory corruption.")
$ python3.6 asdf.py
hello world
Segmentation fault (core dumped)
</code></pre>
</div>
<span class="comment-copy">On Linux a fork in Python is usually copy on write.</span>
<span class="comment-copy">This use of <code>vfork</code> is already undefined behavior in C.</span>
