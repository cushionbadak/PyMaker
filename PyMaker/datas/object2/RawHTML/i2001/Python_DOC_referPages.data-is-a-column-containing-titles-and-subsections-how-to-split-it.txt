<div class="post-text" itemprop="text">
<p>I have a list of strings that looks like this:</p>
<pre><code>'A[title]'
'a'
'b'
'c'
'B[title]'
'd'
'C[title]'
'e'
'f'
...
</code></pre>
<p>Where each block is separated by a title marked with 'title'.
I need to separate these blocks and format it like this:</p>
<pre><code>'A[title]' ,'a'
'A[title]' ,'b'
'A[title]' ,'c'
'B[title]' ,'d'
'C[title]' ,'e'
'C[title]' ,'f'
...
</code></pre>
<p>I'm currently using a for loop to do the job, my code looks like this:</p>
<pre><code>data=pd.Series(data)

newd = []
for i in data.index:
    if '[' not in data[i]:
        current_title = data[i]
    else:
        newd.append([current_title,data[i]])
</code></pre>
<p>which is the desired format, but I'm actually trying to avoid the use of for loops.
So, is there a way of doing this with a built-in pandas function?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with <code>str.contains</code> and <code>ffill</code></p>
<pre><code>data=data.to_frame('ori')
data['title']=data.ori[data.ori.str.contains('title')]
data=data.ffill().loc[lambda x : x.ori!=x.title]
data
Out[499]: 
  ori     title
1   a  A[title]
2   b  A[title]
3   c  A[title]
5   d  B[title]
7   e  C[title]
8   f  C[title]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a pure Python solution, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby

L = ['A[title]', 'a', 'b', 'c', 'B[title]', 'd', 'C[title]', 'e', 'f']

grouper = groupby(L, key=lambda x: x.endswith('[title]'))
g = [list(b) for _, b in grouper]
res = [[i[0], k] for i, j in zip(g[::2], g[1::2]) for k in j]

print(res)

[['A[title]', 'a'], ['A[title]', 'b'], ['A[title]', 'c'],
 ['B[title]', 'd'], ['C[title]', 'e'], ['C[title]', 'f']]
</code></pre>
<p><strong>Explanation</strong></p>
<ol>
<li>Group by whether the string ends in <code>[title]</code>.</li>
<li>Extract results as a list for slicing later.</li>
<li>Extract the odd elements as titles and even elements as names via a nested list comprehension with <code>zip</code>.</li>
</ol>
</div>
<span class="comment-copy">This is actually very smart :)</span>
<span class="comment-copy">@jpp thank you man : -)</span>
<span class="comment-copy">OP specified they wanted to avoid using for-loops and only use pandas-based logic. Isn't a list comprehension essentially the same thing in disguise?</span>
<span class="comment-copy">@BrianJoseph, Do Pandas <code>str</code> methods <i>not</i> use a <code>for</code> loop internally? It's instructive to note that <code>str</code> methods are implemented <i>less efficiently</i> in Pandas versus a regular Python loop in a list comp.</span>
<span class="comment-copy">Of course, I totally agree that pandas methods are probably slower in this case. I just figured OP wanted  to avoid for-loops in their solution, not for the sake of efficiency, but for the sake of learning the pandas language. As OP already made it clear they could solve the problem with iteration/loops but not in pandas syntax.</span>
