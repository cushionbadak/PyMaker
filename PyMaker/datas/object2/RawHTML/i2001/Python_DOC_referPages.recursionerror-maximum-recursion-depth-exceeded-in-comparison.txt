<div class="post-text" itemprop="text">
<p>I hope that this is not a duplicate, I apologise if so, but have done some googling and looking around stack overflow and not found anything as yet...</p>
<p><strong>MCVE</strong></p>
<p>I understand that if a function keeps calling itself, this can't keep happening indefinitely without a stack overflow, and so an error is raised after a certain limit. For example:</p>
<pre><code>def foo():
    return foo()

foo()
</code></pre>
<p>This gives rise to the following error:</p>
<pre><code>RecursionError: maximum recursion depth exceeded
</code></pre>
<p>However, if I write a function such as the following:</p>
<pre><code>def count(n):
    if n == 0:
        return 0
    else:
        return count(n-1)+1

count(1000)
</code></pre>
<p>I get a slightly different error:</p>
<pre><code>RecursionError: maximum recursion depth exceeded in comparison
</code></pre>
<p><strong>The question</strong></p>
<p>What is the  "in comparison" referring to in the above error. I guess what I'm asking is what is difference between these two situations, that gives rise to two different errors.</p>
</div>
<div class="post-text" itemprop="text">
<p>When a <code>RecursionError</code> is raised, the python interpreter may also offer you the context of the call that caused the error. This only serves for debugging, to give you a hint where in your code you should look in order to fix the problem.</p>
<p>See for example this circular <code>str</code>-call setup that leads to a different message:</p>
<pre><code>&gt;&gt;&gt; class A:
...     def __str__(self):
...         return str(self.parent)
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.parent = a
&gt;&gt;&gt; str(a)
RecursionError: maximum recursion depth exceeded while calling a Python object
</code></pre>
<hr/>
<p>There is no documentation of this behaviour on <a href="https://bugs.python.org/issue19235" rel="nofollow noreferrer">the issue discussion</a> where <code>RecursionError</code> was introduced, but you can just search the cpython code for occurences of <a href="https://github.com/python/cpython/blob/master/Include/ceval.h#L90" rel="nofollow noreferrer">Py_EnterRecursiveCall</a>. Then you can see the actual contexts that will be returned depending on where the error is raised:</p>
<pre><code>Py_EnterRecursiveCall(" while encoding a JSON object")
Py_EnterRecursiveCall(" while pickling an object")
Py_EnterRecursiveCall(" in __instancecheck__")
Py_EnterRecursiveCall(" in __subclasscheck__")
Py_EnterRecursiveCall(" in comparison")
Py_EnterRecursiveCall(" while getting the repr of an object")
Py_EnterRecursiveCall(" while getting the str of an object")
Py_EnterRecursiveCall(" while calling a Python object")
Py_EnterRecursiveCall("while processing _as_parameter_") # sic
# .. and some more that I might have missed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I played around with it and found some interesting results.</p>
<p>As we know:</p>
<pre><code>def foo():
    foo()
</code></pre>
<p>Gives rise to </p>
<pre><code>RecursionError: maximum recursion depth exceeded
</code></pre>
<p>What I found was</p>
<pre><code>def bar():
    if False:
        return 0
    else:
        bar()

def baz():
    if True:
        baz()
    else:
        return 0
</code></pre>
<p>Both <code>bar()</code> and <code>baz()</code> give rise to </p>
<pre><code>RecursionError: maximum recursion depth exceeded
</code></pre>
<p>And then </p>
<pre><code>def ding():
    if 1 == 2:
        return 0
    else:
        ding()

def dong():
    if 1 != 2:
        dong()
    else:
        return 0
</code></pre>
<p>Both <code>ding()</code> and <code>dong()</code> give rise to </p>
<pre><code>RecursionError: maximum recursion depth exceeded in comparison
</code></pre>
<p>My intuition here is that python knows you are doing a comparison using the comparators <code>=,!,&lt;,&gt;</code> and that this comparison never reaches the 'base case' condition (within the limits of the maximum depth). So python is letting you know that your comparison never converges to meet the condition.</p>
<p>This helpfulness starts to break down when you try</p>
<pre><code>def oops():
    if 1 == 2:
        oops()
    else:
        oops()
</code></pre>
<p>But in the end python can only be so helpful with error messages.</p>
</div>
<span class="comment-copy">The recursion depth is around 1000, so the value is too large.</span>
<span class="comment-copy">Just guessing: the comparison is <code>n==0</code>, and the error message tells us that this is a <i>conditional</i> recursion.</span>
<span class="comment-copy">It means that a stack overflow happened in the comparison <code>n == 0</code>. What's the big deal?</span>
<span class="comment-copy">Thank you for this very comprehensive answer. I think my notion of what recursion depth actually is might be off? By way of clarification: Would an if statement increase the recursion depth? Would for example 1000 nested if statements raise a similar error?</span>
<span class="comment-copy">No, <code>RecursionError</code>s only occur when the interpreter finds a cycle, meaning one and the same function gets called infinitely.</span>
<span class="comment-copy">okay. Thankyou. I guess I'm confused why the <code>RecursionError</code> occurs in the comparison. If I have other lines in my function before the comparison, I still get the error <code>in comparison</code>. What is special about that, as apposed to other lines before? Why is the error not occuring at the point when the function is called one too many times?</span>
<span class="comment-copy">There is a limited number of hints python can give you about where the error occurred. The guy who implemented the Recursion error decided that <i>if it happened in an if-else block that included a comparison, print that as the context</i>.</span>
<span class="comment-copy">It's not true that RecursionError is raised when there's a cycle. RecursionError is thrown when there are too many function calls on the stack. <code>n == 0</code> calls a function (<a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a>), and that function is causing your program to hit the stack limit. Python detects that, and prints an informative error message.</span>
