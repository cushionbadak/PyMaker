<div class="post-text" itemprop="text">
<p>Firstly, yes I know this is not good practice. It's just an experiment, not actual planned code.</p>
<p>The problem:
I have a function</p>
<pre><code>def foo:
    print("hi there")

def foo2:
    #Any stack/recompiling manipulation goes here

def main:
    foo2()
    foo()
</code></pre>
<p>Is there any way to manipulate the definition of foo() from foo2() during runtime? </p>
<p>I have been fiddling with trying to change variables in the frames, but most are read only (save f_local).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are interested in byte code level stuff in python let me introduce <code>dis</code>, <code>compile</code> and <code>CodeType</code></p>
<p><strong>don't do any of this in production code</strong></p>
<p>You can <code>compile</code> python code (as a string) into a Code object which can then override a functions <code>__code__</code> property</p>
<pre><code>def foo():
    print('hi there')
code_stuff = compile("print('this is hacked in')", "dummy file", "exec")
foo.__code__ = code_stuff
foo() #prints "this is hacked in"
</code></pre>
<p>if you want to modify more than a no inputs no outputs function take a look at the <code>types.CodeType</code> constructor:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; help(types.CodeType)
Help on class code in module builtins:

class code(object)
 |  code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,
 |        constants, names, varnames, filename, name, firstlineno,
 |        lnotab[, freevars[, cellvars]])
 |  
 |  Create a code object.  Not for the faint of heart.
 |  ...
</code></pre>
<p>Which - much like writing assembly code - involves risking seg-faults, crashing the python interpreter or worse.  You know when the only documentation is <code>Not for the faint of heart.</code> the developer was not intending for it to be directly used.</p>
<p>if you want to see what byte code actually executes as you can use <code>dis</code>. which is short for "disassemble"</p>
<pre><code>def foo():
    print('hi there')

import dis
dis.dis(foo)
</code></pre>
<p>This is interesting to see how python code actually executes.</p>
<p>I'm not sure exactly what you are trying to do with the stack but I'm fairly certain what ever it is, the developers of python have made sure it's not easy since that is not something you should be touching in python. These types only exist in python for introspection reasons (like seeing what the arguments of a function are at runtime by inspecting it's call signature)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to manipulate the definition of <code>foo</code>, it's straightforward to redefine <code>foo</code> much the same way you would assign any other global variable, with a <code>global</code> statement and <code>=</code>:</p>
<pre><code>def foo():
    print('hi there')

def foo2():
    global foo
    def replacement_foo():
        print('hi from over here')
    foo = replacement_foo

def main():
    foo2()
    foo()

main()
</code></pre>
<p>It's probably also safe to just <code>def foo(): ...</code> inside <code>foo2</code> instead of defining <code>replacement_foo</code> and then assigning, but that's <a href="https://docs.python.org/3/reference/simple_stmts.html#the-global-statement" rel="nofollow noreferrer">officially not permitted</a>, even though the implementation doesn't enforce it.</p>
<hr/>
<p>In the comments, you seem to be very interested in manipulating <code>foo</code> through the stack somehow. The definition of <code>foo</code> doesn't live on the stack, and no call to <code>foo</code> is on the stack during the execution of <code>foo</code>, so the stack is the wrong place to look.</p>
<p>Also, most of Python's stack inspection is read-only. Even if you were to reassign a function's code object, it wouldn't change the code of calls already on the stack. You can't change <code>main</code>'s code object to make it not call <code>foo</code> (though you can change <code>foo</code>'s code object, and that'll take effect when <code>main</code> calls <code>foo</code>).</p>
</div>
<span class="comment-copy">completely depends on what you are trying to modify, if it fits any use case that might come up in the real world there may be things you can do with decorators/factory functions but we need to know what you want to do with it.</span>
<span class="comment-copy">What are "variables in the frames"?</span>
<span class="comment-copy">The variable I most wanted to change is f_code. From there I would hope to change main to do things such as skip over foo() entirely.</span>
<span class="comment-copy">@JonathanBurk please tell us what you are actually trying to do.  The more specific you can be the more likely we can give you what you need.  just saying you want to "modify it at runtime" is far to vague to get decent answers.</span>
<span class="comment-copy">Responding with "I just want to learn about the stack" is valid, I can point you to non-manipulative resources in that case, but I really think that anything else has a better solution than low level monkey patching.</span>
<span class="comment-copy">Thank you! This is very helpful. Is there any way to modify the execution flow with this method? For example, if we now wish to overwrite main() from foo()</span>
<span class="comment-copy">If you want to screw with a function's internals, this is only the tip of the iceberg, though. There are a lot more fiddly bits, version-specific details, and other things to get right, and especially if you try to construct code objects directly, it's easy to segfault your interpreter.</span>
<span class="comment-copy">@JonathanBurk: Nope. Replacing a function's code object won't change the code object for calls already on the stack.</span>
<span class="comment-copy">Good to know. Is there any way to jump to lines/skip lines by manipulating the stack?</span>
<span class="comment-copy">Also, seconding the point about telling us exactly what you want to do. This question is too vague and broad as it stands.</span>
<span class="comment-copy">This doesn't modify the original function <code>foo</code>, though, it replaces it with a completely unrelated function by reassigning to the global name <code>foo</code>. (Which might or might not be what the OP is looking for.)</span>
<span class="comment-copy">That's true, although that does help, I'm wondering if it's possible to replace things in the stack. For example, modifying the current line/place in the execution flow, changing the underlying bytecode of main etc.</span>
<span class="comment-copy">@JonathanBurk: <code>foo</code> isn't <i>on</i> the stack when <code>foo2</code> runs, so I'm not sure why you're talking about the stack. Is your goal to fiddle with the stack? It didn't sound like it from your question.</span>
<span class="comment-copy">Wouldn't main have the execution flow with something like foo2() then foo() then end?</span>
<span class="comment-copy">@JonathanBurk: Yes. <code>foo</code> still isn't on the stack when <code>foo2</code> runs, though. You asked about manipulating the definition of <code>foo</code>, so I wrote an answer that redefines <code>foo</code>.</span>
