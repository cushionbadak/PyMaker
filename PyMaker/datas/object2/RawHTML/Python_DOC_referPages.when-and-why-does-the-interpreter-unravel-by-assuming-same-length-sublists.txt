<div class="post-text" itemprop="text">
<p>I'm impressed by and enjoy the fact that a simple Python <code>for</code> statement can easily unravel a list of lists, without the need for <code>numpy.unravel</code> or an equivalent flatten function. However, the trade-off is now that I can't access elements of a list like this:</p>
<pre><code>for a,b,c in [[5],[6],[7]]:
     print(str(a),str(b),str(c))
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: not enough values to unpack (expected 3, got 1)
</code></pre>
<p>and instead, this works, up until the length-1 <code>[5]</code>: </p>
<pre><code>for a,b,c in [[1,2,3],[4,5,6],[7,8,9],[0,0,0], [5]]:
     print(a,b,c)

1 2 3
4 5 6
7 8 9
0 0 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: not enough values to unpack (expected 3, got 1)
</code></pre>
<p>Logically, it doesn't make sense to assume that a list would have a fixed number of elements. How come then, Python allows us to assume that a list of lists would always have the same number of elements?</p>
<p>I'd like to be aware of what Python expects, because I want to anticipate wrongly formatted lists/sublists.</p>
<p>I've poked around Python documentation and Stackoverflow, but haven't found the reasoning or how the interpreter is doing this.</p>
<p>My guess is that flattening same-length arrays is such a common occurrence (e.g. machine learning dimensionality reduction, matrix transformations, etc.), that there's utility in providing this feature at the trade-off of being unable to do what I've tried above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not assume same length lists because this is not only for lists.</p>
<p>When you iterate <code>for a,b,c in [[1,2,3],[4,5,6],[7,8,9],[0,0,0], [5]]</code> what is happening is that python returns a <a href="https://wiki.python.org/moin/Iterator" rel="nofollow noreferrer">iterator</a> that will iterate(return) each list values.</p>
<p>So that for is equivalent with:</p>
<pre><code>l = [[1,2,3],[4,5,6],[7,8,9],[0,0,0], [5]]

l_iter = iter(l)

a,b,c = next(l_iter)
</code></pre>
<p><code>next(l_iter)</code> will return each element from the list until it will raise a <code>StopIteration</code> execption according to the python iteration protocol.</p>
<p>This means:</p>
<pre><code>a,b,c = [1,2,3]
a,b,c = [4,5,6]
a,b,c = [7,8,9]
a,b,c = [0,0,0]
a,b,c = [5]
</code></pre>
<p>As you can see now python can't unpack <code>[5]</code> into <code>a,b,c</code> as there is only one value.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't know, you just <em>told</em> it to expect three elements by unpacking to three names. The <code>ValueError</code> says "you told us three, but we found a sub-iterable that didn't have three elements, and we don't know what to do).</p>
<p>Python isn't really doing anything special to implement this; aside from special cases for built-in types like <code>tuple</code> (and probably <code>list</code>), the implementation is just to iterate the sub-iterable the expected number of times and dump all the values found on the interpreter stack, then store them to the provided names. It also tries to iterate one more time (expecting <code>StopIteration</code>) so you don't silently ignore extra values.</p>
<p>For limited cases, you can be flexible by having one of the unpack names preceded with a <code>*</code>, so you capture all the "didn't fit" elements into that name (as a <code>list</code>). That lets you set a minimum number of elements while allowing more, e.g. if you really only need the first element from your second example, you could do:</p>
<pre><code>for a, *_ in [[1,2,3],[4,5,6],[7,8,9],[0,0,0], [5]]:
    print(a,b,c)
</code></pre>
<p>where <code>_</code> is just a name that, by convention, means "I don't actually care about this value, but I needed a placeholder name".</p>
<p>Another example would be when you want the first and last element, but otherwise don't care about the middle:</p>
<pre><code>for first, *middle, last in myiterable:
    ...
</code></pre>
<p>But otherwise, if you need to handle variable length iterables, don't unpack, just store to a single name and iterate that name manually in whatever way makes sense to your program logic.</p>
</div>
<div class="post-text" itemprop="text">
<p>The interpreter <em>always</em> assumes the length is matching when making an unpacking assignment, and just crashes with <code>ValueError</code> if it doesn't match. A for-loop is actually very similar to a kind of "repeated assignment statement", with the LHS being the free variable(s) of the loop and the RHS being an iterable container yielding the successive value(s) to use in each step of the iteration.  </p>
<p>One assignment per iteration, made at the beginning of the loop body - in your case, it's an unpacking assignment, which binds multiple names.</p>
<p>So, in order to be properly equivalent to the second example, your first example which was:</p>
<pre><code>for a,b,c in [[5],[6],[7]]:
    ...
</code></pre>
<p>should have been written instead:</p>
<pre><code>for a, in [[5],[6],[7]]:
    ...
</code></pre>
<p>There is no "anticipation", and there can't be because (in the general case) you may be iterating over anything, e.g. data streaming in from a socket.</p>
<p>In order to fully grasp how for-loop flow works, the analogy with assignment statements is very useful. Anything that you can use on the left hand side of an assignment statement, you can use as the target in a for-loop. For example, this is equivalent to setting <code>d[1] = 2</code> etc in a dict - and should make same result as <code>dict(RHS)</code>:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for k, d[k] in [[1, 2], [3, 4]]: 
...     pass 
...
&gt;&gt;&gt; d
{1: 2, 3: 4}
</code></pre>
<p>It's just a bunch of assignments, in a well-defined order.</p>
</div>
<span class="comment-copy"><code>for a,b,c in [[5],[6],[7]]:</code> has <i>absolutely nothing</i> to do with numpy. That's a Python list. Nor does <code>for a,b,c in [[1,2,3],[4,5,6],[7,8,9],[0,0,0], [5]]:</code></span>
<span class="comment-copy">First, you aren't dealing with a <code>numpy</code> behavior.  This is basic Python iteration.  Secondly, you appear to be confusing two items - the <code>for</code> iteration, and the <code>a,b,c</code> unpacking.  Unpacking is inflexible when it comes to the number items it expects, in this case 3 (one value for each variable).  Also it doesn't let you assume anything - it raises a runtime <code>ValueError</code> if you get it wrong.  (this mismatch isn't a syntax error).</span>
<span class="comment-copy">Python doesn’t assume anything. It lets you unpack any <i>iterable</i>. It’s up to you to ensure your iterables have the expected number of items.</span>
<span class="comment-copy">"How come then, Python allows us to assume that a list of lists would always have the same number of elements?" - same reason it lets you assume a list has at least 3 elements when you do <code>l[2]</code>, or why it lets you assume every element of a list is a number when you write <code>for x in l: s += x</code>. Why wouldn't it let you?</span>
<span class="comment-copy">There are ways to "unravel" sequences with unequal sub-sequences. See the question <a href="https://stackoverflow.com/questions/38054593/zip-longest-without-fillvalue">zip_longest without fillvalue</a>.</span>
<span class="comment-copy">I'd suggest illustrating with <code>next(l_iter)</code>, not <code>l_iter.next()</code>; the latter is wrong in Python 3 (where the name is <code>__next__</code>), while the top level <code>next()</code> built-in function works on 2.7 and 3.x (and is the generally approved approach, in the same way <code>len(seq)</code> is preferred over <code>seq.__len__()</code>, even though technically both work).</span>
<span class="comment-copy">Yes you are right, i have edited. Thx</span>
<span class="comment-copy">Thank you for the clear, concise explanation.</span>
<span class="comment-copy">Not quite; it would need to be: <code>for [a],[b],[c] in [[[5],[6],[7]]]:</code> (note extra brackets on thing being iterated). Otherwise it would be trying to unpack <code>[5]</code> to <code>[a],[b],[c]</code>.</span>
<span class="comment-copy">Your post-edit approach also works :-). As does <code>for [a] in [[5],[6],[7]]:</code>. I'll stop before I get into <a href="https://stackoverflow.com/a/33161467/364696">the many ways of unpacking single element lists...</a> :-)</span>
