<div class="post-text" itemprop="text">
<p><strong>EDIT</strong>: I'm using Python 3.5.0, and so <code>map()</code> will return an iterator instead of a <code>list</code>, unlike Python 2.x</p>
<p>I have a list of units and I am calling a REST api on all of them to return more data about them. I'm using <code>map()</code> to do this, but when I try to convert that map to a list, the program hangs there and doesn't proceed (both when I run it and debug it)</p>
<pre><code>data = list(map(lambda product: client.request(units_url + "/" + product), units))
</code></pre>
<p>At first I thought maybe it was an issue with calling the api so quickly, but when I iterate through the map (without converting it to a list) manually and print it goes just fine:</p>
<pre><code>data = map(lambda product: client.request(units_url + "/" + product), units)
for item in data:
    print(item)    # &lt;-- this works just fine for the entire map
</code></pre>
<p>Anyone know why I'm getting this behavior? </p>
</div>
<div class="post-text" itemprop="text">
<p>When you <code>list</code>-ify the <code>map</code>, that means every single request is dispatched serially, waits for completion, then stores to the resulting <code>list</code>. If you're dispatching 1000 requests, that means each request must complete in order, one by one, before the <code>list</code> is constructed and you see the first result; it's entirely synchronous.</p>
<p>You get results (almost) immediately in the direct <code>map</code> iteration case because it only makes one request at a time; instead of waiting for 1000 requests, it waits for 1, you process that result, then it waits for another, etc.</p>
<p>If the goal is to minimize latency, take a look at <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered" rel="nofollow"><code>multiprocessing.Pool.imap</code></a> (or the thread based version of the pool implemented in <code>multiprocessing.dummy</code>; threads can be ideal for parallel network I/O requests and won't require pickling data for IPC). With the <code>Pool</code>'s <code>map</code>, <code>imap</code>, or <code>imap_unordered</code> methods (choose one based on your needs), the requests will be dispatched asynchronously, several at a time (depending on the number of workers you select). If you absolutely must have a <code>list</code>, <code>Pool.map</code> will usually construct it faster; if you can iterate directly and don't care about the ordering of results, <code>Pool.imap_unordered</code> will get you results as fast as the workers can get them, in whatever order they are satisfied in. Plain <code>map</code> without a <code>Pool</code> isn't getting you any magical performance benefits (a list comprehension would usually run faster actually), so use a <code>Pool</code>.</p>
<p>Simple example code for fastest results:</p>
<pre><code>import multiprocessing.dummy as multiprocessing  # Import thread based version of library; for network I/O should work fine

with multiprocessing.Pool(8) as pool:  # Pool of eight worker threads
    for item in pool.imap_unordered(lambda product: client.request(units_url + "/" + product), units):
        print(item)
</code></pre>
<p>If you really need to, you can use <code>Pool.map</code> and store to a real <code>list</code>, and assuming you have the bandwidth to run eight parallel requests (or however many workers you configure the pool for), that should (roughly) divide the time to complete the <code>map</code> by eight.</p>
</div>
<div class="post-text" itemprop="text">
<p>Better answer than I previously had.  Check out <a href="https://stackoverflow.com/questions/1247486/python-list-comprehension-vs-map">this link</a>. Near the bottom of the answer it gives a great analysis on why you should really use a list comprehension.</p>
<p>data = [ client.request(units_url + "/" + product) for product in units ]</p>
</div>
<span class="comment-copy">is <code>units</code> a list?</span>
<span class="comment-copy">yep! <code>units</code> is just a list of strings</span>
<span class="comment-copy">Why you are trying to convert list into list again? <code>data = list(map(...), units))</code> since as you said units is a list</span>
<span class="comment-copy">because in python 3.x+ <code>map()</code> returns an iterator instead of a <code>list</code>, so i need to convert it back</span>
<span class="comment-copy">try this: <code>data = list(client.request(units_url + "/" + product) for product in units)</code></span>
<span class="comment-copy">For the record, if you don't need order <code>imap_unordered</code> is the best possible version, since a single delayed network request won't prevent you from getting other results. With <code>Pool.map</code> and <code>Pool.imap</code>, if even one network request gets held up, you can end up with a long stall before you see any results at all.</span>
<span class="comment-copy">thanks for that great explanation! Does that also account for why it still hangs when I save the <code>map()</code> into an intermediate variable <code>results</code>, then call <code>list(results)</code>?</span>
<span class="comment-copy">Yup. All the <code>list</code> constructor does is iterate the generator <code>map</code> returns, one at a time, until it stops getting new values. The normal <code>map</code> function is lazy; you could save it to a variable, wait 10 minutes, then ask for a value, and it still would have to scramble to get it for you; it hasn't started calculating anything at all. By contrast, the <code>Pool</code> equivalent methods (<code>imap</code>/<code>imap_unordered</code>) start working when you call them; if you delay before retrieving any results, the initial values will come instantly for a while. When you do work between retrievals, they do too.</span>
<span class="comment-copy">That's awesome. Thanks! +1</span>
<span class="comment-copy">That will make next to no difference. It is faster, don't get me wrong, but it's faster in the sense of shaving a few microseconds per element processed at best. When we're talking about network requests, the costs typically start in the milliseconds per request (1000x longer); microsecond costs are noise.</span>
<span class="comment-copy">Well the big difference is that navigating an iterator doesn't build the list, it just gets the results sequentially. Faster, no building of the big object.  If you build the list, you are doing exactly that, getting the results sequentially, building a complex data structure and holding it in memory. So do you really need a list? If not, just stick with the iterator.</span>
<span class="comment-copy">And I'm curious... did you try the list comprehension?</span>
