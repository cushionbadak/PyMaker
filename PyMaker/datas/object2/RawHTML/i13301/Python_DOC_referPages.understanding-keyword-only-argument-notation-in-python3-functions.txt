<div class="post-text" itemprop="text">
<p>I am having some difficulty behaviour of <a href="https://www.python.org/dev/peps/pep-3102/">keyword only arguments</a> feature in python3 when used with <a href="https://docs.python.org/3.4/library/functools.html#functools.partial">partial</a>. Other <a href="https://docs.python.org/3/glossary.html#term-parameter">info</a> on keyword only arguments. </p>
<p>Here is my code:</p>
<pre><code>def awesome_function(a = 0, b = 0, *, prefix):
    print('a -&gt;', a)
    print('b -&gt;', b)
    print('prefix -&gt;', prefix)
    return prefix + str(a+b)
</code></pre>
<p>Here is my understanding of partial:</p>
<pre><code>&gt;&gt;&gt; two_pow = partial(pow, 2)
&gt;&gt;&gt; two_pow(5)
32
&gt;&gt;&gt;
</code></pre>
<p>What I understood is in the above example, <code>partial</code> makes the second argument to <code>pow</code> function as the only argument of <code>two_pow</code>.</p>
<p>My question is why does the following work:</p>
<pre><code>&gt;&gt;&gt; g = partial(awesome_function, prefix='$')
&gt;&gt;&gt; g(3, 5)
a -&gt; 3
b -&gt; 5
prefix -&gt; $
'$8'
&gt;&gt;&gt;
</code></pre>
<p>But I get error in this:</p>
<pre><code>&gt;&gt;&gt; awesome_function(prefix='$', 3, 5)
  File "&lt;stdin&gt;", line 1
SyntaxError: non-keyword arg after keyword arg
&gt;&gt;&gt;
</code></pre>
<p>I know that I can call <code>awesome_function</code> directly by</p>
<pre><code>&gt;&gt;&gt; awesome_function(prefix='$', a = 3, b = 5)
a -&gt; 3
b -&gt; 5
prefix -&gt; $
'$8'
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As per the semantics of the <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow">function calls in Python</a>, the rules for the arguments to be passed are as follows</p>
<pre class="lang-none prettyprint-override"><code>argument_list   ::=  positional_arguments ["," keyword_arguments]
                       ["," "*" expression] ["," keyword_arguments]
                       ["," "**" expression]
                     | keyword_arguments ["," "*" expression]
                       ["," keyword_arguments] ["," "**"     expression]
                     | "*" expression ["," keyword_arguments] ["," "**" expression]
                     | "**" expression
</code></pre>
<p>As you see here, the positional arguments should always appear at the beginning of the function calls. They cannot appear anywhere else. When you do</p>
<pre><code>awesome_function(prefix='$', 3, 5)
</code></pre>
<p>it violates the above rule, as you are passing two positional arguments (<code>3</code> and <code>5</code>) after a keyword argument (<code>prefix</code>). That is why you are getting a <code>SyntaxError</code>, as Python is not able to parse the function call expression.</p>
<hr/>
<p>But, when you are using <code>partial</code> it works, because <code>partial</code> creates a new function object and it stores all the parameters to be passed to it. When you actually invoke the function object returned by <code>partial</code>, it applies all the positional arguments first and then the keyword arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>The error you get - <code>SyntaxError: non-keyword arg after keyword arg</code> - is because you tried to send positional arguments (like <code>3,5</code>) after a keyword argument, that is not a valid syntax, and hence a syntax error. In the function call -</p>
<pre><code> awesome_function(prefix='$', 3, 5)
                          ^   ^  ^
                          |     These two are the positional argument.
                          ----- This is the keyword argument.                                
</code></pre>
<p>It works when using <code>functools.partial</code> because <code>functools.partial</code> knows to put positional arguments before keyword arguments , hence when you call the partial function - <code>g()</code> - with positional arguments , it sends those positional arguments before the keyword argument . Hence, in your case <code>g(3, 5) ==&gt; awesome_function(3, 5, prefix='$')</code> .</p>
<p>A simple example to show this -</p>
<pre><code>&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; def func(a=0,b=1):
...     print(a,b)
...
&gt;&gt;&gt; ptfunc = partial(func,a=10)
&gt;&gt;&gt; ptfunc(20)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: func() got multiple values for argument 'a'
</code></pre>
<p>In the above case, when we called <code>ptfunc(20)</code>, <code>20</code> was passed as positional argument first, and then the keyword argument <code>a=10</code> was passed, hence it complained that it got multiple values for the argument <code>a</code>. </p>
<hr/>
<p>And also as given in <a href="https://docs.python.org/2/library/functools.html#functools.partial" rel="nofollow">the documentation -</a></p>
<blockquote>
<p><code>functools.partial</code> is Roughly equivalent to:</p>
<pre><code>def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*(args + fargs), **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc
</code></pre>
</blockquote>
</div>
