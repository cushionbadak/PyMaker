<div class="post-text" itemprop="text">
<pre><code>import numpy as np
def gen_c():
    c = np.ones(5, dtype=int)
    j = 0
    t = 10
    while j &lt; t:
        c[0] = j
        yield c.tolist()
        j += 1 

# What I did:
# res = np.array(list(gen_c())) &lt;-- useless allocation of memory

# this line is what I'd like to do and it's killing me
res = np.fromiter(gen_c(), dtype=int) # dtype=list ?
</code></pre>
<p>The error said <code>ValueError: setting an array element with a sequence.</code></p>
<p>This is a very stupid piece of code. I'd like to create an array of list(finally a 2D array) from a generator...</p>
<p>Although I searched everywhere, I still cannot figure out how to make it work.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can only use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html" rel="nofollow"><code>numpy.fromiter()</code></a> to create 1-dimensional arrays (not 2-D arrays) as given in the <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html" rel="nofollow">documentation of <code>numpy.fromiter</code></a> -</p>
<blockquote>
<p><strong>numpy.fromiter(iterable, dtype, count=-1)</strong></p>
<p>Create a new 1-dimensional array from an iterable object.</p>
</blockquote>
<p>One thing you can do is convert your generator function to give out single values from <code>c</code> and then create a 1D array from it and then reshape it to <code>(-1,5)</code> . Example -</p>
<pre><code>import numpy as np
def gen_c():
    c = np.ones(5, dtype=int)
    j = 0
    t = 10
    while j &lt; t:
        c[0] = j
        for i in c:
            yield i
        j += 1

np.fromiter(gen_c(),dtype=int).reshape((-1,5))
</code></pre>
<p>Demo -</p>
<pre><code>In [5]: %paste
import numpy as np
def gen_c():
    c = np.ones(5, dtype=int)
    j = 0
    t = 10
    while j &lt; t:
        c[0] = j
        for i in c:
            yield i
        j += 1

np.fromiter(gen_c(),dtype=int).reshape((-1,5))

## -- End pasted text --
Out[5]:
array([[0, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [2, 1, 1, 1, 1],
       [3, 1, 1, 1, 1],
       [4, 1, 1, 1, 1],
       [5, 1, 1, 1, 1],
       [6, 1, 1, 1, 1],
       [7, 1, 1, 1, 1],
       [8, 1, 1, 1, 1],
       [9, 1, 1, 1, 1]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As the docs suggested, <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html" rel="nofollow noreferrer"><code>np.fromiter()</code></a> only accepts 1-dimensional iterables.
You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code></a> to flatten the iterable first, and <code>np.reshape()</code> it back later:</p>
<pre><code>import itertools
import numpy as np

def fromiter2d(it, dtype):

    # clone the iterator to get its length
    it, it2 = itertools.tee(it)
    length = sum(1 for _ in it2)

    flattened = itertools.chain.from_iterable(it)
    array_1d = np.fromiter(flattened, dtype)
    array_2d = np.reshape(array_1d, (length, -1))
    return array_2d
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; iter2d = (range(i, i + 4) for i in range(0, 12, 4))

&gt;&gt;&gt; from_2d_iter(iter2d, int)
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>
<p>Only tested on Python 3.6, but should also work with Python 2.</p>
</div>
<span class="comment-copy">thank you again! You answered all my two questions :D</span>
<span class="comment-copy">Always glad to be of help! :-)</span>
<span class="comment-copy">PS: in fact, this solution(I'm not saying yours, i'm talking about mine) do not improve the performance in my case...</span>
<span class="comment-copy">Yes, because <code>c.tolist()</code> is muuuch faster than looping through <code>c</code> and yielding each value</span>
