<div class="post-text" itemprop="text">
<p>In an effort to apply <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" rel="nofollow">SOLID</a> principles to a Python project that has grown organically and is in need of re-factoring, I am trying to understand how the <strong><a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" rel="nofollow">Interface Segregation Principle</a></strong> can be applied to the <strong>Python</strong> language, when Interfaces don't exist as a language feature?  </p>
</div>
<div class="post-text" itemprop="text">
<p>An interface is something that you can type hint against, literally in source code or simply informally in documentation. Python 3 supports <a href="https://www.python.org/dev/peps/pep-3107/">function annotations</a>, 3.5+ actual <a href="https://www.python.org/dev/peps/pep-0484/">type hints</a>, and even if all that wasn't there, you could still informally type hint simply in the documentation. A type hint simply says that a specific parameter is expected to have specific characteristics.</p>
<p>In more concrete terms:</p>
<pre><code>interface Foo {
    string public function bar();
}

function baz(Foo obj) { .. }
</code></pre>
<p>All this does is declare that whatever parameter is passed into <code>baz</code> shall be an object with a method <code>bar</code> which takes no arguments and returns a string. Even if Python did not implement anything at the language level to <em>enforce</em> this, you can still declare these things any number of ways.</p>
<p>Python does support two important things though: <a href="https://docs.python.org/3/library/abc.html">abstract classes</a> and multiple inheritance.</p>
<p>Instead of <code>interface Foo</code>, in Python you do this:</p>
<pre><code>import abc

class Foo(abc.ABC):
    @abc.abstractmethod
    def bar() -&gt; str:
        pass
</code></pre>
<p>Instead of <code>implements Foo</code>, you do:</p>
<pre><code>class MyClass(Foo):
    def bar() -&gt; str:
        return 'string'
</code></pre>
<p>Instead of <code>function baz(Foo obj)</code>, you do:</p>
<pre><code>def baz(obj: Foo):
    obj.bar()
</code></pre>
<p>Due to the multiple inheritance feature, you can segregate your interfaces/abstract classes as finely as you like.</p>
<p>Python is based on the duck-typing principle, so instead of enforcing all this through interface declarations and inheritance, it's usually more loosely defined in terms of "parameter must be an iterable" and such, and the caller simply needs to ensure that the arguments are <em>iterable</em>. Abstract classes and function annotations, coupled with the right development tools, can aid developers in conforming to such contracts at various levels of enforcement.</p>
</div>
<span class="comment-copy">I didn't mention that this was asked about a 2.7 project, but I am interested in the answers for 3.x and 2.7.</span>
<span class="comment-copy">Thanks for the comprehensive answer. I forgot to mention this is a 2.7 project, but you cover that too. I look forward to exploring the more advanced features of Python 3 in the future.</span>
