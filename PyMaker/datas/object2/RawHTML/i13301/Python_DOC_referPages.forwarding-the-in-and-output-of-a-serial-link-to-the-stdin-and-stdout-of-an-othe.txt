<div class="post-text" itemprop="text">
<p>I implemented a serial protocol for an embedded device and to debug the code I compiled it on my host machine [Widows 7 MinGW] simply using stdin and stdout to communicate, now I want to hook it up to the controll software using a virtual null modem cable.</p>
<p>I thought it could not be to difficult to write a python3 script that does exactly that taking the stdout of a program and forwarding it to a serial link while sending the data coming in serial to the stdin but, i can not get it running. Here is my best try [I replaced my executable with cat]:</p>
<pre><code>import subprocess
import serial
import threading

def forward_to_serial():
    while True:
        ser.write(proc.stdout.read())

def forward_to_cmd():
    while True:
        proc.stdin.write(ser.read())
        proc.stdin.flush()

ser = serial.Serial('COM27', timeout = 100)

proc = subprocess.Popen("cat", stdout=subprocess.PIPE, stdin=subprocess.PIPE)

fwc = threading.Thread(target = forward_to_cmd)
fwc.start()

forward_to_serial()
</code></pre>
<p>It does not work probably due to the two active threads accessing the Popen object. When I reduce the problem to only forward data from the serial link to the Popen object it works as intended</p>
<pre><code>proc = subprocess.Popen("cat", stdin=subprocess.PIPE)

fwc = threading.Thread(target = forward_to_cmd)
fwc.start()

#forward_to_serial()
</code></pre>
<p>Is there a way to get it working?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase.read" rel="nofollow"><code>read()</code> method</a>, when its argument is omitted, blocks until it has read <em>all</em> of the data from the stream, which doesn't happen until the subprocess exits.</p>
<p>You should instead be reading as much as the OS will give you at any one time, e.g. with the <a href="https://docs.python.org/3/library/io.html#io.BufferedIOBase.read1" rel="nofollow"><code>read1()</code> method</a>.  That way, if you get a partial read (because the subprocess wrote or the user typed some data without closing the stream), you can immediately forward it, rather than buffering it in memory and waiting until the stream is closed.  For example:</p>
<pre><code>MAX_READ_SIZE = 4096
def forward_to_serial():
    while True:
        data = proc.stdout.read1(MAX_READ_SIZE)
        if not data:
            break  # EOF
        ser.write(data)
</code></pre>
<p>Note that in the case of <code>forward_to_cmd()</code>, when reading from the serial port, the <a href="https://pyserial.readthedocs.org/en/latest/pyserial_api.html#serial.Serial.read" rel="nofollow"><code>serial.read()</code></a> does <em>not</em> have the same behavior of blocking until EOF if the argument is omitted.  Instead, it defaults to 1, and therefore will just try to read one byte for every call.</p>
</div>
<span class="comment-copy">if <code>ser.fileno()</code> returns a real file descriptor then try to pass it directly as <code>stdout</code> parameter i.e., cut the middle man (Python) redirect subprocess' stdout to the serial directly.</span>
<span class="comment-copy">Thank you very much, I was not aware of <code>read1</code>, but it only worked when using <code>read1(1)</code></span>
<span class="comment-copy">@the_architect: You should not use a buffer size of 1 if you can avoid, that will lead to poor performance.  I'd recommend instead a larger buffer size like 4096, so that if a bunch of data becomes available at once, it's read in a single system call and written back in a single system call; and if less data is available, it's still read immediately.</span>
