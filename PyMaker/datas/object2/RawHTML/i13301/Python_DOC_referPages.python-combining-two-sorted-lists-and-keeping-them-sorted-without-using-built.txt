<div class="post-text" itemprop="text">
<p>I found this merge sort solutions online and I'm wondering if while loops is the way to go or if there is also a way of using 2 for loops and comparing those.</p>
<pre><code>def merge(l, m):
    result = []
    i = j = 0
    total = len(l) + len(m)
    while len(result) != total:
        if len(l) == i:
            result += m[j:]
            break
        elif len(m) == j:
            result += l[i:]
            break
        elif l[i] &lt; m[j]:
            result.append(l[i])
            i += 1
        else:
            result.append(m[j])
            j += 1
    print result
</code></pre>
<p>merge([1,2,6,7], [1,3,5,9])</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily change while to for:</p>
<pre><code>def merge_for(l,m):
    result = []
    i = j = 0
    total = len(l) + len(m)

    for k in range(total):

        if len(l) == i:
            result += m[j:]
            print("append el {} at index {}".format(m[j], k))

            break
        elif len(m) == j:
            result += l[i:]
            break
        elif l[i] &lt; m[j]:
            result.append(l[i])
            print("append el {} at index {}".format(l[i], k))
            i += 1
        else:
            result.append(m[j])
            print("append el {} at index {}".format(m[j], k))
            j += 1

    print(result)


print(merge_for([1,2,6,7], [1,3,5,9]))

append el 1 at index 0
append el 1 at index 1
append el 2 at index 2
append el 3 at index 3
append el 5 at index 4
append el 6 at index 5
append el 7 at index 6
append el 9 at index 7

[1, 1, 2, 3, 5, 6, 7, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's builtin <code>sorted</code> would actually be pretty efficient at this (since the <code>TimSort</code> it uses takes advantage of existing ordering in subsets of a list). That said, there is a built-in that avoids the need to even construct a new <code>list</code> like <code>sorted</code> (or your solution) would: <a href="https://docs.python.org/3/library/heapq.html#heapq.merge" rel="nofollow"><code>heapq.merge</code></a></p>
<p>It's designed precisely for scenarios where you have existing lists that are each independently sorted. It's a generator function, so it doesn't require the creation of a new <code>list</code> at all. If you are trying to do this to learn, enjoy yourself, but if this is for "real" code, use the included batteries and avoid reinventing the wheel.</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution using  using a generator:</p>
<pre><code>from itertools import chain
def merge(l1,l2):
    i,j = 0,0
    try:
        while True:
            if l1[i] &lt; l2[j]:
                yield l1[i]
                i +=1
            else:
                yield l2[j]
                j+=1
    except IndexError:
        for e in chain(l1[i:],l2[j:]):
            yield e

[x for x in merge([1,2,6,7], [1,3,5,9])]
</code></pre>
<blockquote>
<p>[1, 1, 2, 3, 5, 6, 7, 9]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you have a sorted list you <a href="https://docs.python.org/2/library/bisect.html#bisect.insort" rel="nofollow">bisect.insort</a> the other:</p>
<pre><code>from bisect import insort

a,b = [1,2,6,7], [1,3,5,9]

for ele in b:
    insort(a, ele)
print(a)
[1, 1, 2, 3, 5, 6, 7, 9]
</code></pre>
</div>
<span class="comment-copy">Ah, gotchya. So pretty much k is unused, and you create your own "mock" for loops (i += 1 &amp; j += 1)?</span>
<span class="comment-copy">@IntrepidDiamond put k to work, now it prints the index of insersion</span>
<span class="comment-copy">The heapq.merge answer is the right. This is just for fun and learning.</span>
