<div class="post-text" itemprop="text">
<p>I have created a script that gets the <code>href</code> link from inside an anchor tag, along with the text.</p>
<p>Here is my python code:</p>
<pre><code>import re
import cssselect
from lxml import html

mainTree = html.fromstring('&lt;a href="https://www.example.com/laptops/" title="Laptops"&gt;&lt;div class="subCategoryItem"&gt;Laptops &lt;span class="cnv-items"&gt;(229)&lt;/span&gt;&lt;/div&gt;&lt;/a&gt;')

for links in mainTree.cssselect('a'):
    urls = [links.get('href')]
    texts = re.findall(re.compile(u'[A-z- &amp;]+'), links.text_content())

    for text in texts:
        print (text)

    for url in urls:
        print (url)
</code></pre>
<p>Output:</p>
<pre><code>Laptops 
https://www.example.com/laptops/
</code></pre>
<p>Instead of using two for loops can I do this?</p>
<pre><code>for text, url in texts, urls:
    print (text)
    print (url)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's examine what you're trying to do here:</p>
<pre><code>for text, url in texts, urls:
    print (text)
    print (url)
</code></pre>
<p>The <code>text, url</code> part right after the <code>for</code> indicates 'unpack the <a href="http://openbookproject.net/thinkcs/python/english3e/tuples.html" rel="nofollow">tuple</a> indicated after <code>in</code> into two parts'. If the tuple doesn't have two parts you'll get a <a href="https://docs.python.org/3.1/library/re.html" rel="nofollow"><code>ValueError</code></a>.</p>
<p>Both of the lists you're iterating through have single values, and simply putting a <code>,</code> between them won't do what you're looking for. As suggested in another answer, you can <a href="http://openbookproject.net/thinkcs/python/english3e/tuples.html" rel="nofollow"><code>zip</code></a> them into a single array:</p>
<pre><code>for text, url in zip(texts, urls):
    print (text)
    print (url)
</code></pre>
<p>What zip does is return a list where each element is a tuple comprised of one element from each of the provided lists. This works well, but doesn't solve the problem of not looping through your list twice: you're still doing that, once for zip  and once to unpack the zip. Your deeper problem is <em>how</em> you're getting your values.</p>
<p>You seem to be stepping through each link you have, and then <em>for each link</em> you are getting the url and the text and putting it into a list. You're then printing everything in those lists. Do those lists ever have a length greater than one? </p>
<p>The <a href="https://docs.python.org/3.1/library/re.html" rel="nofollow"><code>get</code></a> function will only return a single value:</p>
<pre><code>urls = [links.get('href')]  //Gets one value and puts it in a list of length one
</code></pre>
<p>Putting it into a list there is not meaningful. As for your regex search, it could in theory return multiple values, but if you use <a href="https://docs.python.org/3.1/library/re.html" rel="nofollow"><code>re.search()</code></a>, then you'll only get the first match and don't need to worry about additional values. This is what you're currently doing:</p>
<pre><code>for each link in the document
  put the url into a list
  put all the matching text into a list
  for each url in the list print it
  for each text in the list print it
</code></pre>
<p>When really you can simplify to:</p>
<pre><code>for each link in the document
  print the url
  find the first text and print it
</code></pre>
<p>Then you don't have to worry about the additional for loops and zipping. This refactors to:</p>
<pre><code>for links in mainTree.cssselect('a'):
    print(links.get('href'))
    print(re.search(re.compile(u'[A-z- &amp;]+'), links.text_content()))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip</a> function:</p>
<pre><code>for text, url in zip(texts, urls):
    print (text)
    print (url)
</code></pre>
<p>What it does is <em>zips</em> two or more iterables. They need not be of the same size either.</p>
<pre><code>&gt;&gt;&gt; l1 = range(5)
&gt;&gt;&gt; l2 = range(6)
&gt;&gt;&gt; list(zip(l1,l2)) #produces
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">What happened when you tried it out?</span>
<span class="comment-copy">@NathanielFord I get this: "ValueError: need more than 1 value to unpack".</span>
<span class="comment-copy">I think this is a bit of an XY problem. The question you're asking about combined loops is indeed answered by <code>zip</code> as described by @kmad1729. However, I don't know why you're looping at all. You'll only ever have one URL per <code>&lt;a&gt;</code> tag, and so I suspect <code>zip</code> won't do what you want if you get multiple hits on your <code>re.findall</code> search (all but the first result will be ignored). Perhaps you just want to filter out inappropriate characters from the string returned by the <code>text_content</code> call?</span>
<span class="comment-copy"><code>zip</code> is a great function! Note that here it is overkill and doesn't actually reduce the computational complexity.</span>
