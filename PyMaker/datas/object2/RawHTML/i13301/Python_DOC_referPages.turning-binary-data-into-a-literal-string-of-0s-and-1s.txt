<div class="post-text" itemprop="text">
<p>I have a file filled with binary data representing a sequence of 2 byte instructions in big endian ordering.</p>
<p>I need to be able to decode these instructions into their more meaningful equivalents, but I'm having trouble getting the data into a format I can work with. </p>
<p>I think it would be best If I turned the instructions into actual strings of 0's and 1's.</p>
<p>So far, I've written this:</p>
<pre><code> def slurpInstructions(filename):
  instructions = []
  with open(filename, 'rb') as f:
    while True:
      try:
        chunk = f.read(1)
        print(struct.unpack('c', chunk))
      except: 
        break
</code></pre>
<p>which prints out the bytes 1 at a time, like this:</p>
<pre><code>(b'\x00',)
(b'a',)
</code></pre>
<p>I know the first instruction in the file is:</p>
<pre><code>0000000001100001
</code></pre>
<p>So, it looks like it's printing out the ascii chars corresponding to the integer values of each byte, except it's just printing out the hex representation when there's no ascii char for the int value.  </p>
<p>Where do I go from here though? I need to turn my <code>b'a'</code> into <code>'1100001'</code> because I actually care about the bits, not the bytes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could convert <code>b'a'</code> to its corresponding integer <a href="https://docs.python.org/3/library/functions.html#ord" rel="nofollow"><code>ord</code></a> value, and then print the int in binary format using <a href="http://docs.python.org/library/string.html#format-string-syntax" rel="nofollow"><code>'{:b}'.format</code></a>:</p>
<pre><code>In [6]: '{:b}'.format(ord(b'a'))
Out[6]: '1100001'
</code></pre>
<hr/>
<ul>
<li><p>Reading a large file one-byte-at-a-time can be very slow. You'll get better performance by reading more bytes per call to <code>f.read</code>.
You can iterate over the contents of the file in chunks of 1024 bytes using:</p>
<pre><code>with open(filename, 'rb') as f:
    for chunk in iter(lambda: f.read(1024), b''):
</code></pre></li>
<li><p>Similarly, calling <code>print</code> once for each byte can be very slow. You'll get better performance by printing more bytes per call to <code>print</code>. So you could use a list comprehension to loop over the bytes in <code>chunk</code>, convert each to its string-binary format and then use <code>''.join</code> to join the strings together:</p>
<pre><code>print(''.join(['{:b}'.format(ord(c)) for c in chunk]), end='')
</code></pre></li>
<li><p>Use bare <code>except</code> is <a href="https://docs.python.org/2/howto/doanddont.html#except" rel="nofollow">considered a bad practice</a>. If you choose to use <code>try..except</code> here, list only those Exceptions you wish to handle:</p>
<pre><code>try:
    ...
except IOError:          
</code></pre></li>
</ul>
<hr/>
<pre><code>def slurpInstructions(filename):
    with open(filename, 'rb') as f:
        for chunk in iter(lambda: f.read(1024), b''):
            print(''.join(['{:b}'.format(c) for c in chunk]), end='')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, to convert 2 bytes into a bitstring (<a href="https://stackoverflow.com/questions/12161988/multiplying-a-huge-number-times-random-python/12162190#comment16278452_12162856"><code>'{:b}'.format()</code> may be  slightly slower</a>):</p>
<pre><code>&gt;&gt;&gt; bin(int.from_bytes(b'\x00a', 'big'))[2:].zfill(16)
'0000000001100001'
</code></pre>
<p>For a single-source Python 2/3 compatible version, see <a href="https://stackoverflow.com/q/7396849/4279">Convert binary to ASCII and vice versa</a></p>
<p>To load all instructions both <a href="https://stackoverflow.com/a/5805696/4279">time- and space-efficiently</a>, you could use <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer"><code>array</code> module</a>:</p>
<pre><code>#!/usr/bin/env python
import os
import sys
from array import array

instructions = array('H') # each instruction is &gt;=2 bytes   
n = os.path.getsize(filename) // instructions.itemsize # number of instructions
with open(filename, 'rb') as file:
    instructions.fromfile(file, n) # slurp file
if sys.byteorder == 'little':
    instructions.byteswap() # force big-endian order

for h in instructions: # print as bitstrings
    print('{:016b}'.format(h))
</code></pre>
<p>For other ways to read a binary file efficiently, see <a href="https://stackoverflow.com/a/20014805/4279">Reading binary file in Python and looping over each byte</a>.</p>
</div>
<span class="comment-copy">Your bare <code>try/except</code> is not considered good practice. It could catch either an IO error on the read or a <code>struct.error</code> on the struct.unpack or (likely) the end of the file. Confusing and not good practice.</span>
<span class="comment-copy">Much better Python (than the OP's function)!</span>
<span class="comment-copy"><code>''.join(map('{:08b}'.format, chunk))</code> could be used instead of the list comprehension.</span>
