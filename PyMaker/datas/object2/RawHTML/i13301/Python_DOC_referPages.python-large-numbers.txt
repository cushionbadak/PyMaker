<div class="post-text" itemprop="text">
<p>Is there anyway to run a for loop with a range of over 13 characters?
For example:</p>
<pre><code>for i in range (1000000000000):
</code></pre>
<p>I know this won't work but is there any way it could?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>xrange</code> can also give you <code>Python int too large to convert to C long</code> Error as the number has to fit into a C long. To overcome this use <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> to create you own range:</p>
<pre><code>  from itertools import count

def myx_range(start, end):
    return iter(count(start).next, end)
</code></pre>
<p>If you wanted to use the same logic with python 3:</p>
<pre><code>from itertools import count

def myx_range(start, end):
    cn = count(start)
    return iter(lambda: next(cn), end)
</code></pre>
<p>Or a <code>while</code> loop:</p>
<pre><code>from itertools import count

def myx_range(start, end):
    while start &lt; end:
        yield start
        start += 1
</code></pre>
<p>A long is <code>32bit</code> on windows so you are going to hit the limit using <code>xrange</code> with  a number that large. </p>
<p>See <a href="https://stackoverflow.com/questions/384502/what-is-the-bit-size-of-long-on-64-bit-windows">what-is-the-bit-size-of-long-on-64-bit-windows</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>For python 2.7, use <a href="https://docs.python.org/2/library/functions.html#xrange" rel="nofollow"><code>xrange</code></a> (which uses a generator instead of initializing a large list) instead:</p>
<pre><code>for i in xrange(1000000000000):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the bounds and step are within the range [-sys.maxsize-1, sys.maxsize), and the total number of elements is <code>&lt;= sys.maxsize</code>, then <a href="https://docs.python.org/2/library/functions.html#xrange" rel="nofollow"><code>xrange</code></a> has you covered.</p>
<p>If not, <code>itertools</code> provides the parts you need to completely reimplement <code>xrange</code> (and efficiently too, pushing all the work to the C layer in CPython) for the purposes of generation (<code>xrange</code> is a real object can be generated over and over and supports a few other features; this only generates, and only once per call):</p>
<pre><code>from itertools import count, islice

def myxrange(stop, *args):
    '''Replacement for xrange to generate ranges of arbitrarily large numbers efficiently
    '''
    start, step = 0, 1  # Defaults when only one argument passed
    if args:
        if len(args) &gt; 2:
            raise TypeError("myxrange expected at most 3 arguments, got {}".format(len(args)))
        start = stop  # When 2+ args passed, stop is really start
        stop, step = (args + (1,))[:2]  # Use step if given, otherwise 1
    # islice slices x items, we need to calculate the number to slice
    # from the bounds given
    numitems = (stop - start + (step - (1 if step &gt; 0 else -1))) // step
    return islice(count(start, step), numitems)
</code></pre>
<p>The above is obviously slightly overkill to handle <code>step</code>s other than the default 1; it could be simplified dramatically if <code>step</code> support wasn't needed.</p>
<p>In CPython (the reference interpreter) this should run more efficiently than using Python level code (which requires repeated byte code execution); once initialized, <code>islice</code> and <code>count</code> do all their work at the C layer, which can dramatically improve performance. For example, compared to the <code>while</code> based loop from the other answer, in ipython running on Python 2.7 on my machine:</p>
<pre><code>&gt;&gt;&gt; %timeit -r5 list(xrange(10, 2000))
100000 loops, best of 5: 15.2 μs per loop
&gt;&gt;&gt; %timeit -r5 list(myxrange(10, 2000)) # Version in my answer
10000 loops, best of 5: 24.9 μs per loop
&gt;&gt;&gt; %timeit -r5 list(myxrange2(10, 2000)) # Version using while from Padraig's answer
1000 loops, best of 5: 173 μs per loop

# Padraig's count based version takes 124 μs, though it could be optimized
# down to ~59 μs by changing it to the C layer version (though either
# version breaks if start &gt; stop):
def myxrange(start, stop):
    return iter(count(start).next, end)
</code></pre>
<p>Even with the overhead of mimicking <code>xrange</code>s non-standard argument prototype, the overhead for the <code>count</code>+<code>islice</code> code is only about 50% over <code>xrange</code>, which ain't half bad given that it actually handles scenarios <code>xrange</code> can't.</p>
</div>
<div class="post-text" itemprop="text">
<p>Remember that there is a limit of minumum and maximum value to store in processor register. It means that not all modules can receive big numbers as arguments.</p>
</div>
<span class="comment-copy"><code>range()</code> works fine in Python3 (returns an iterator), however <code>range()</code> returns a list in Python2, use <code>xrange()</code> for an iterator. You can iterate for as long as you want with no additional memory overhead.</span>
<span class="comment-copy">When I use xrange it says 'Python int too large to convert to C long'</span>
<span class="comment-copy">Can't replicate, which python are you using?</span>
<span class="comment-copy">@AChampion python 2.7</span>
<span class="comment-copy">On what platform?</span>
<span class="comment-copy">Good sentinel use of <code>iter()</code></span>
<span class="comment-copy">This doesn't seem to work in my program. I have to do a nested loop with the same parameters on each loop and it won't work on the second loop.</span>
<span class="comment-copy">@T.Green, how would it not?  <code>for i in myx_range(0, 100000000000)</code> will work as many times as you want it to</span>
<span class="comment-copy">@PadraicCunningham I was using it wrong, I thought the function was the loop, I didn't realise ro had to write the <code>for i in myx_range(0, 1000000000000)</code> but know it works. Thanks! :)</span>
<span class="comment-copy">@ShadowRanger, True, originally I did not have it in a function  so just left the loop. I changed it but kept the lambda  in case someone wanted to use a variation of it with python3.</span>
