<div class="post-text" itemprop="text">
<p>I have tried to somehow get a documentation for a partialmethod to work. My current code is</p>
<pre><code>from functools import partialmethod

class Fun(object):

  def test(self, num):
    """
    I have a documentation
    """
    return num

  test2 = partialmethod(test, num=10)
  test2.__doc__ = """Blub"""

  test3 = partialmethod(test, num=20)
</code></pre>
<p>But if I run</p>
<pre><code>a = Fun()
a.test2.__doc__ # only returns the partials documentation not "Blub"
Fun.test2.__doc__ # gives nothing
</code></pre>
<p>and Sphinx lists them using <code>autoclass</code> as <code>undocumented members</code>.</p>
<p>I have read <a href="https://docs.python.org/3/library/functools.html#partial-objects" rel="nofollow">https://docs.python.org/3/library/functools.html#partial-objects</a> and <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow">https://docs.python.org/3/library/functools.html#functools.partialmethod</a> but does that mean that there is <em>no way</em> of getting documentations into partialmethods or am I just too stupid about it?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's not possible to set a docstring on a <code>partialmethod</code> object. That's because <code>partialmethod</code> is a class written in Python, and instances of classes get their docstring from the class's <code>__doc__</code>, not from a <code>__doc__</code> attribute on the instances. Functions behave differently, with the <code>__doc__</code> attribute of the function object being looked at.</p>
<p>Depending on how complicated your use of <code>partialmethod</code> is, you may be able to write your own version that returns a function, rather than an instance, thus allowing you to customize the documentation by assigning to the <code>__doc__</code> attribute.</p>
<p>Here's a quick version I've thrown together with only basic testing. I think it works for common cases (e.g. where <code>func</code> is an actual function), but it probably won't be as flexible as the regular <code>partialmethod</code> type, so you should double check that it does everything you need it to do:</p>
<pre><code>import functools

def my_partialmethod(func, *args1, **kwargs1):
    @functools.wraps(func)  # copy attributes to start, they can be overwritten later
    def method(self, *args2, **kwargs2):
        return func(self, *args1, *args2, **kwargs1, **kwargs2)
    return method
</code></pre>
<p>The multiple unpacking in the call to <code>func</code> is only legal in Python 3.5. In older Python versions, you'll have to merge the arguments yourself with something like this:</p>
<pre><code>    def method(self, *args2, **kwargs2):
        kwargs = kwargs1.copy()
        kwargs.update(kwargs2)
        return func(self, *(args1+args2), **kwargs)
</code></pre>
<p>Here's an example use:</p>
<pre><code>class Test(object):
    def method1(self, arg):
        "docstring1"
        print(arg)

    method2 = my_partial_method(method1, "foo")
    method2.__name__ = "method2"
    method2.__doc__ = "docstring2"

    method3 = my_partial_method(method1, arg="bar")
    method3.__name__ = "method3"
    method3.__doc__ = "docstring3"
</code></pre>
<p>You can of course pick which attributes to overwrite. I'm not sure if using <code>functools.wraps</code> is a good idea or not, as it may copy over a bunch of invalid attributes, beyond the ones I'm modifying in my example.</p>
</div>
<span class="comment-copy">I actually had such a decorator (ok, it was a bit different) before using <code>functools.partialmethod</code>. But that approach has some downsides - i.e. it copies the original function signature (which normally is a good thing but not with partials). But it seems very sad that the partialmethod is not capable of providing such functionality. Especially because <code>partial</code> allows such an usage - but only for functions not methods. But nevertheless many thanks for your answer and if no other possibility presents itself I will accept your answer tomorrow. :-)</span>
<span class="comment-copy">Yeah, my function is essentially <code>partial</code> with a special case for <code>self</code>. It should work find when wrapping ordinary methods, but won't work if you're wrapping something like a <code>staticmethod</code> or another descriptor that doesn't expect to get <code>self</code>. If the <code>wraps</code> call causes more trouble than good, you can remove it (the signature of the wrapper function will then be <code>(*args2, **kwargs2)</code>, which may or may not be an improvement).</span>
