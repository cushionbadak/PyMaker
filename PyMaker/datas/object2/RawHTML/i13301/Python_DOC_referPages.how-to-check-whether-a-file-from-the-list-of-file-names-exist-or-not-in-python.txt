<div class="post-text" itemprop="text">
<p>How do I see if a file exists or not, without using the <a href="https://docs.python.org/3.6/reference/compound_stmts.html#try" rel="noreferrer"><code>try</code></a> statement?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the reason you're checking is so you can do something like <code>if file_exists: open_it()</code>, it's safer to use a <code>try</code> around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</p>
<p>If you're not planning to open the file immediately, you can use <a href="https://docs.python.org/2/library/os.path.html#os.path.isfile" rel="noreferrer"><code>os.path.isfile</code></a></p>
<blockquote>
<p>Return <code>True</code> if path is an existing regular file. This follows symbolic links, so both <a href="https://docs.python.org/2/library/os.path.html#os.path.islink" rel="noreferrer">islink()</a> and <a href="https://docs.python.org/2/library/os.path.html#os.path.isfile" rel="noreferrer">isfile()</a> can be true for the same path.</p>
</blockquote>
<pre><code>import os.path
os.path.isfile(fname) 
</code></pre>
<p>if you need to be sure it's a file.</p>
<p>Starting with Python 3.4, the <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file" rel="noreferrer"><code>pathlib</code> module</a> offers an object-oriented approach (backported to <code>pathlib2</code> in Python 2.7):</p>
<pre><code>from pathlib import Path

my_file = Path("/path/to/file")
if my_file.is_file():
    # file exists
</code></pre>
<p>To check a directory, do:</p>
<pre><code>if my_file.is_dir():
    # directory exists
</code></pre>
<p>To check whether a <code>Path</code> object exists independently of whether is it a file or directory, use <code>exists()</code>:</p>
<pre><code>if my_file.exists():
    # path exists
</code></pre>
<p>You can also use <code>resolve(strict=True)</code> in a <code>try</code> block:</p>
<pre><code>try:
    my_abs_path = my_file.resolve(strict=True)
except FileNotFoundError:
    # doesn't exist
else:
    # exists
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have the <a href="https://docs.python.org/2/library/os.path.html#os.path.exists" rel="noreferrer"><code>os.path.exists</code></a> function:</p>
<pre><code>import os.path
os.path.exists(file_path)
</code></pre>
<p>This returns <code>True</code> for both files and directories but you can instead use</p>
<pre><code>os.path.isfile(file_path)
</code></pre>
<p>to test if it's a file specifically. It follows symlinks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unlike <a href="http://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile" rel="noreferrer"><code>isfile()</code></a>, <a href="http://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.exists" rel="noreferrer"><code>exists()</code></a> will return <code>True</code> for directories.<br/>
So depending on if you want only plain files or also directories, you'll use <code>isfile()</code> or <code>exists()</code>. Here is a simple REPL output.</p>
<pre><code>&gt;&gt;&gt; print os.path.isfile("/etc/password.txt")
True
&gt;&gt;&gt; print os.path.isfile("/etc")
False
&gt;&gt;&gt; print os.path.isfile("/does/not/exist")
False
&gt;&gt;&gt; print os.path.exists("/etc/password.txt")
True
&gt;&gt;&gt; print os.path.exists("/etc")
True
&gt;&gt;&gt; print os.path.exists("/does/not/exist")
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os.path

if os.path.isfile(filepath):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile" rel="noreferrer"><code>os.path.isfile()</code></a> with <a href="https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access" rel="noreferrer"><code>os.access()</code></a>:</p>
<pre><code>import os
import os.path

PATH='./file.txt'

if os.path.isfile(PATH) and os.access(PATH, os.R_OK):
    print "File exists and is readable"
else:
    print "Either the file is missing or not readable"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
os.path.exists(path) # Returns whether the path (directory or file) exists or not
os.path.isfile(path) # Returns whether the file exists or not
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although almost every possible way has been listed in (at least one of) the existing answers (e.g. <em>Python 3.4</em> specific stuff was added), I'll try to group everything together.</p>
<p><strong>Note</strong>: every piece of <em>Python</em> standard library code that I'm going to post, belongs to version <strong>3.5.3</strong>.</p>
<p><strong>Problem statement</strong>:</p>
<ol>
<li>Check file (<em>arguable</em>: also folder ("special" file) ?) existence</li>
<li>Don't use <strong><em>try</em></strong> / <strong><em>except</em></strong> / <strong><em>else</em></strong> / <strong><em>finally</em></strong> blocks</li>
</ol>
<p><strong>Possible solutions</strong>:</p>
<ol>
<li><p><a href="https://docs.python.org/3/library/os.path.html#os.path.exists" rel="noreferrer">[Python 3]: os.path.<strong>exists</strong>(<em>path</em>)</a> (also check other function family members like <code>os.path.isfile</code>, <code>os.path.isdir</code>, <code>os.path.lexists</code> for slightly different behaviors)</p>
<pre class="lang-py prettyprint-override"><code>os.path.exists(path)
</code></pre>
<blockquote>
<p>Return <code>True</code> if <em>path</em> refers to an existing path or an open file descriptor. Returns <code>False</code> for broken symbolic links. On some platforms, this function may return <code>False</code> if permission is not granted to execute <a href="https://docs.python.org/3/library/os.html#os.stat" rel="noreferrer">os.stat()</a> on the requested file, even if the <em>path</em> physically exists.</p>
</blockquote>
<p>All good, but if following the import tree:</p>
<ul>
<li><p><code>os.path</code> - <em>posixpath.py</em> (<em>ntpath.py</em>)</p>
<ul>
<li><p><em>genericpath.py</em>, line <em>~#20+</em></p>
<pre class="lang-py prettyprint-override"><code>def exists(path):
    """Test whether a path exists.  Returns False for broken symbolic links"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return True
</code></pre></li>
</ul></li>
</ul>
<p>it's just a <strong><em>try</em></strong> / <strong><em>except</em></strong> block around <a href="https://docs.python.org/3/library/os.html#os.stat" rel="noreferrer">[Python 3]: os.<strong>stat</strong>(<em>path, *, dir_fd=None, follow_symlinks=True</em>)</a>. So, your code is <strong><em>try</em></strong> / <strong><em>except</em></strong> free, but lower in the framestack there's (at least) <strong>one</strong> such block. This also applies to other funcs (<strong>including</strong> <code>os.path.isfile</code>).</p>
<p>1.1. <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file" rel="noreferrer">[Python 3]: Path.<strong>is_file</strong>()</a></p>
<ul>
<li>It's a fancier (and more <em>python</em>ic) way of handling paths, <strong>but</strong></li>
<li><p>Under the hood, it does <strong>exactly</strong> the same thing (<em>pathlib.py</em>, line <em>~#1330</em>):</p>
<pre class="lang-py prettyprint-override"><code>def is_file(self):
    """
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
    """
    try:
        return S_ISREG(self.stat().st_mode)
    except OSError as e:
        if e.errno not in (ENOENT, ENOTDIR):
            raise
        # Path doesn't exist or is a broken symlink
        # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
        return False
</code></pre></li>
</ul></li>
<li><p><a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="noreferrer">[Python 3]: With Statement Context Managers</a>. Either:</p>
<ul>
<li><p>Create one:</p>
<pre class="lang-py prettyprint-override"><code>class Swallow:  # Dummy example
    swallowed_exceptions = (FileNotFoundError,)

    def __enter__(self):
        print("Entering...")

    def __exit__(self, exc_type, exc_value, exc_traceback):
        print("Exiting:", exc_type, exc_value, exc_traceback)
        return exc_type in Swallow.swallowed_exceptions  # only swallow FileNotFoundError (not e.g. TypeError - if the user passes a wrong argument like None or float or ...)
</code></pre>
<ul>
<li><p>And its usage - I'll replicate the <code>os.path.isfile</code> behavior (note that this is just for demonstrating purposes, do <strong>not</strong> attempt to write such code for <em>production</em>):</p>
<pre class="lang-py prettyprint-override"><code>import os
import stat


def isfile_seaman(path):  # Dummy func
    result = False
    with Swallow():
        result = stat.S_ISREG(os.stat(path).st_mode)
    return result
</code></pre></li>
</ul></li>
<li><p>Use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="noreferrer">[Python 3]: contextlib.<strong>suppress</strong>(<em>*exceptions</em>)</a> - which was <strong>specifically</strong> designed for selectively suppressing exceptions</p></li>
</ul>
<p><br/>But, they seem to be wrappers over <strong><em>try</em></strong> / <strong><em>except</em></strong> / <strong><em>else</em></strong> / <strong><em>finally</em></strong> blocks, as <a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="noreferrer">[Python 3]: The <em>with</em> statement</a> states:</p>
<blockquote>
<p>This allows common <a href="https://docs.python.org/3/reference/compound_stmts.html#try" rel="noreferrer">try</a>...<a href="https://docs.python.org/3/reference/compound_stmts.html#except" rel="noreferrer">except</a>...<a href="https://docs.python.org/3/reference/compound_stmts.html#finally" rel="noreferrer">finally</a> usage patterns to be encapsulated for convenient reuse.</p>
</blockquote></li>
<li><p>Filesystem traversal functions (and search the results for matching item(s))</p>
<ul>
<li><p><a href="https://docs.python.org/3/library/os.html#os.listdir" rel="noreferrer">[Python 3]: os.<strong>listdir</strong>(<em>path='.'</em>)</a> (or <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="noreferrer">[Python 3]: os.<strong>scandir</strong>(<em>path='.'</em>)</a> on <em>Python v<strong>3.5</strong></em></p></li></ul></li></ol></div>
<div class="post-text" itemprop="text">
<p>This is the simplest way to check if a file exists. Just <strong>because</strong> the file existed when you checked doesn't <strong>guarantee</strong> that it will be there when you need to open it.</p>
<pre><code>import os
fname = "foo.txt"
if os.path.isfile(fname):
    print("file does exist at this time")
else:
    print("no such file exists at this time")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 3.4+</strong> has an object-oriented path module: <a href="http://docs.python.org/3.4/library/pathlib.html" rel="noreferrer"><strong>pathlib</strong></a>.  Using this new module, you can check whether a file exists like this:</p>
<pre><code>import pathlib
p = pathlib.Path('path/to/file')
if p.is_file():  # or p.is_dir() to see if it is a directory
    # do stuff
</code></pre>
<p>You can (and usually should) still use a <code>try/except</code> block when opening files:</p>
<pre><code>try:
    with p.open() as f:
        # do awesome stuff
except OSError:
    print('Well darn.')
</code></pre>
<p>The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:</p>
<pre><code># installs pathlib2 on older Python versions
# the original third-party module, pathlib, is no longer maintained.
pip install pathlib2
</code></pre>
<p>Then import it as follows:</p>
<pre><code># Older Python versions
import pathlib2 as pathlib
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Prefer the try statement. It's considered better style and avoids race conditions.</p>
<p>Don't take my word for it. There's plenty of support for this theory. Here's a couple:</p>
<ul>
<li>Style: Section "Handling unusual conditions" of <a href="http://allendowney.com/sd/notes/notes11.txt" rel="noreferrer">http://allendowney.com/sd/notes/notes11.txt</a></li>
<li><a href="https://developer.apple.com/library/mac/#documentation/security/conceptual/SecureCodingGuide/Articles/RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW8" rel="noreferrer">Avoiding Race Conditions</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>How do I check whether a file exists, using Python, without using a try statement?</h2>
</blockquote>
<p>Now available since Python 3.4, import and instantiate a <code>Path</code> object with the file name, and check the <code>is_file</code> method (note that this returns True for symlinks pointing to regular files as well):</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; Path('/').is_file()
False
&gt;&gt;&gt; Path('/initrd.img').is_file()
True
&gt;&gt;&gt; Path('/doesnotexist').is_file()
False
</code></pre>
<p>If you're on Python 2, you can backport the pathlib module from pypi, <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer"><code>pathlib2</code></a>, or otherwise check <code>isfile</code> from the <code>os.path</code> module:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.isfile('/')
False
&gt;&gt;&gt; os.path.isfile('/initrd.img')
True
&gt;&gt;&gt; os.path.isfile('/doesnotexist')
False
</code></pre>
<p>Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a <code>try</code>, but Python uses <code>try</code> everywhere in its implementation. </p>
<p>Because Python uses <code>try</code> everywhere, there's really no reason to avoid an implementation that uses it.</p>
<p>But the rest of this answer attempts to consider these caveats.</p>
<h2>Longer, much more pedantic answer</h2>
<p>Available since Python 3.4, use the new <code>Path</code> object in <code>pathlib</code>. Note that <code>.exists</code> is not quite right, because directories are not files (except in the unix sense that <em>everything</em> is a file).</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; root = Path('/')
&gt;&gt;&gt; root.exists()
True
</code></pre>
<p>So we need to use <code>is_file</code>:</p>
<pre><code>&gt;&gt;&gt; root.is_file()
False
</code></pre>
<p>Here's the help on <code>is_file</code>:</p>
<pre><code>is_file(self)
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
</code></pre>
<p>So let's get a file that we know is a file:</p>
<pre><code>&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; file = tempfile.NamedTemporaryFile()
&gt;&gt;&gt; filepathobj = Path(file.name)
&gt;&gt;&gt; filepathobj.is_file()
True
&gt;&gt;&gt; filepathobj.exists()
True
</code></pre>
<p>By default, <code>NamedTemporaryFile</code> deletes the file when closed (and will automatically close when no more references exist to it).</p>
<pre><code>&gt;&gt;&gt; del file
&gt;&gt;&gt; filepathobj.exists()
False
&gt;&gt;&gt; filepathobj.is_file()
False
</code></pre>
<p>If you dig into <a href="https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318" rel="noreferrer">the implementation</a>, though, you'll see that <code>is_file</code> uses <code>try</code>:</p>
<pre><code>def is_file(self):
    """
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
    """
    try:
        return S_ISREG(self.stat().st_mode)
    except OSError as e:
        if e.errno not in (ENOENT, ENOTDIR):
            raise
        # Path doesn't exist or is a broken symlink
        # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
        return False
</code></pre>
<h2>Race Conditions: Why we like try</h2>
<p>We like <code>try</code> because it avoids race conditions. With <code>try</code>, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.</p>
<p>If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a <strong>race condition</strong> if you check it exists, because you are then <em>racing</em> to open it before its <em>condition</em> (its existence) changes. </p>
<p>Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.</p>
<p>But if this is your motivation, you <em>can</em> get the value of a <code>try</code> statement by using the <code>suppress</code> context manager.</p>
<h2>Avoiding race conditions without a try statement: <code>suppress</code></h2>
<p>Python 3.4 gives us the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="noreferrer"><code>suppress</code></a> context manager (previously the <a href="https://bugs.python.org/issue19266" rel="noreferrer"><code>ignore</code></a> context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a <code>try</code> statement:</p>
<pre><code>from contextlib import suppress
from pathlib import Path
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; with suppress(OSError), Path('doesnotexist').open() as f:
...     for line in f:
...         print(line)
... 
&gt;&gt;&gt;
&gt;&gt;&gt; with suppress(OSError):
...     Path('doesnotexist').unlink()
... 
&gt;&gt;&gt; 
</code></pre>
<p>For earlier Pythons, you could roll your own <code>suppress</code>, but without a <code>try</code> will be more verbose than with. I do believe <strong>this actually is the only answer that doesn't use <code>try</code> at any level in the Python</strong> that can be applied to prior to Python 3.4 because it uses a context manager instead:</p>
<pre><code>class suppress(object):
    def __init__(self, *exceptions):
        self.exceptions = exceptions
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            return issubclass(exc_type, self.exceptions)
</code></pre>
<p>Perhaps easier with a try:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def suppress(*exceptions):
    try:
        yield
    except exceptions:
        pass
</code></pre>
<h2>Other options that don't meet the ask for "without try":</h2>
<p><strong>isfile</strong></p>
<pre><code>import os
os.path.isfile(path)
</code></pre>
<p>from the <a href="https://docs.python.org/library/os.path.html#os.path.isfile" rel="noreferrer">docs</a>:</p>
<blockquote>
<p><code>os.path.isfile(path)</code></p>
<p>Return True if path is an existing regular file. This follows symbolic
  links, so both <code>islink()</code> and <code>isfile()</code> can be true for the same path.</p>
</blockquote>
<p>But if you examine the <a href="https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25" rel="noreferrer">source</a> of this function, you'll see it actually does use a try statement:</p>
<blockquote>
<pre><code># This follows symbolic links, so both islink() and isdir() can be true
# for the same path on systems that support symlinks
def isfile(path):
    """Test whether a path is a regular file"""
    try:
        st = os.stat(path)
    except os.error:
        return False
    return stat.S_ISREG(st.st_mode)
</code></pre>
</blockquote>
<pre><code>&gt;&gt;&gt; OSError is os.error
True
</code></pre>
<p>All it's doing is using the given path to see if it can get stats on it,  catching <code>OSError</code> and then checking if it's a file if it didn't raise the exception.</p>
<p>If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:</p>
<pre><code>try:
    with open(path) as f:
        f.read()
except OSError:
    pass
</code></pre>
<p><strong>os.access</strong></p>
<p>Available for Unix and Windows is <code>os.access</code>, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:</p>
<pre><code>import os
os.access(path, os.F_OK)
</code></pre>
<p>It also suffers from the same race condition problems as <code>isfile</code>. From the <a href="https://docs.python.org/2/library/os.html#os.access" rel="noreferrer">docs</a>:</p>
<blockquote>
<p>Note:
  Using access() to check if a user is authorized to e.g. open a file
  before actually doing so using open() creates a security hole, because
  the user might exploit the short time interval between checking and
  opening the file to manipulate it. It’s preferable to use EAFP
  techniques. For example:</p>
<pre><code>if os.access("myfile", os.R_OK):
    with open("myfile") as fp:
        return fp.read()
return "some default data"
</code></pre>
<p>is better written as:</p>
<pre><code>try:
    fp = open("myfile")
except IOError as e:
    if e.errno == errno.EACCES:
        return "some default data"
    # Not a permission error.
    raise
else:
    with fp:
        return fp.read()
</code></pre>
</blockquote>
<p>Avoid using <code>os.access</code>. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.</p>
<h3>Criticism of another answer:</h3>
<p>Another answer says this about <code>os.access</code>:</p>
<blockquote>
<p>Personally, I prefer this one because under the hood, it calls native APIs (via "${PYTHON_SRC_DIR}/Modules/posixmodule.c"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:</p>
</blockquote>
<p>This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them. </p>
<p>It also creates a context manager which, by unconditionally returning <code>True</code>, allows all Exceptions (including <code>KeyboardInterrupt</code> and <code>SystemExit</code>!) to pass silently, which is a good way to hide bugs.</p>
<p>This seems to encourage users to adopt poor practices.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
#Your path here e.g. "C:\Program Files\text.txt"
#For access purposes: "C:\\Program Files\\text.txt"
if os.path.exists("C:\..."):   
    print "File found!"
else:
    print "File not found!"
</code></pre>
<p>Importing <code>os</code> makes it easier to navigate and perform standard actions with your operating system. </p>
<p>For reference also see <a href="/q/82831">How to check whether a file exists using Python?</a></p>
<p>If you need high-level operations, use <code>shutil</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Testing for files and folders with <code>os.path.isfile()</code>, <code>os.path.isdir()</code> and <code>os.path.exists()</code></p>
<p>Assuming that the "path" is a valid path, this table shows what is returned by each function for files and folders:</p>
<p><a href="https://i.stack.imgur.com/tOs9p.png"><img alt="enter image description here" src="https://i.stack.imgur.com/tOs9p.png"/></a></p>
<p>You can also test if a file is a certain type of file using <code>os.path.splitext()</code> to get the extension (if you don't already know it)</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; path = "path to a word document"
&gt;&gt;&gt; os.path.isfile(path)
True
&gt;&gt;&gt; os.path.splitext(path)[1] == ".docx" # test if the extension is .docx
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In 2016 the best way is still using <code>os.path.isfile</code>:</p>
<pre><code>&gt;&gt;&gt; os.path.isfile('/path/to/some/file.txt')
</code></pre>
<p>Or in Python 3 you can use <code>pathlib</code>:</p>
<pre><code>import pathlib
path = pathlib.Path('/path/to/some/file.txt')
if path.is_file():
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It doesn't seem like there's a meaningful functional difference between try/except and <code>isfile()</code>, so you should use which one makes sense.</p>
<p>If you want to read a file, if it exists, do</p>
<pre><code>try:
    f = open(filepath)
except IOError:
    print 'Oh dear.'
</code></pre>
<p>But if you just wanted to rename a file if it exists, and therefore don't need to open it, do</p>
<pre><code>if os.path.isfile(filepath):
    os.rename(filepath, filepath + '.old')
</code></pre>
<p>If you want to write to a file, if it doesn't exist, do</p>
<pre><code># python 2
if not os.path.isfile(filepath):
    f = open(filepath, 'w')

# python 3, x opens for exclusive creation, failing if the file already exists
try:
    f = open(filepath, 'wx')
except IOError:
    print 'file already exists'
</code></pre>
<p>If you need file locking, that's a different matter.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try this (safer):</p>
<pre><code>try:
    # http://effbot.org/zone/python-with-statement.htm
    # 'with' is safer to open a file
    with open('whatever.txt') as fh:
        # Do something with 'fh'
except IOError as e:
    print("({})".format(e))
</code></pre>
<p>The ouput would be:</p>
<blockquote>
<p>([Errno 2] No such file or directory:
  'whatever.txt')</p>
</blockquote>
<p>Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Although I always recommend using <code>try</code> and <code>except</code> statements, here are a few possibilities for you (my personal favourite is using <code>os.access</code>):</p>
<ol>
<li><p>Try opening the file:</p>
<p>Opening the file will always verify the existence of the file. You can make a function just like so:</p>
<pre><code>def File_Existence(filepath):
    f = open(filepath)
    return True
</code></pre>
<p>If it's False, it will stop execution with an unhanded IOError
or OSError in later versions of Python. To catch the exception,
you have to use a try except clause. Of course, you can always
use a <code>try</code> except` statement like so (thanks to <a href="https://stackoverflow.com/users/3256073/hsandt">hsandt</a>
for making me think):</p>
<pre><code>def File_Existence(filepath):
    try:
        f = open(filepath)
    except IOError, OSError: # Note OSError is for later versions of Python
        return False

    return True
</code></pre></li>
<li><p>Use <code>os.path.exists(path)</code>:</p>
<p>This will check the existence of what you specify. However, it checks for files <em>and</em> directories so beware about how you use it.</p>
<pre><code>import os.path
&gt;&gt;&gt; os.path.exists("this/is/a/directory")
True
&gt;&gt;&gt; os.path.exists("this/is/a/file.txt")
True
&gt;&gt;&gt; os.path.exists("not/a/directory")
False
</code></pre></li>
<li><p>Use <code>os.access(path, mode)</code>:</p>
<p>This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in <code>os.F_OK</code>, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (<a href="https://docs.python.org/2/glossary.html#term-eafp" rel="noreferrer">EAFP</a> vs <a href="https://docs.python.org/2/glossary.html#term-lbyl" rel="noreferrer">LBYP</a>). If you're not going to open the file afterwards, and only checking its existence, then you can use this.</p>
<p>Anyway, here:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.access("/is/a/file.txt", os.F_OK)
True
</code></pre></li>
</ol>
<p>I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be <code>permission denied</code> or <code>no such file or directory</code>. If you catch an <code>IOError</code>, set the <code>IOError as e</code> (like my first option), and then type in <code>print(e.args)</code> so that you can hopefully determine your issue. I hope it helps! :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Date:2017-12-04</p>
<p>Every possible solution has been listed in other answers.</p>
<p>An intuitive and arguable way to check if a file exists is the following:</p>
<pre><code>import os
os.path.isfile('~/file.md')  # Returns True if exists, else False
# additionaly check a dir
os.path.isdir('~/folder')  # Returns True if the folder exists, else False
# check either a dir or a file
os.path.exists('~/file')
</code></pre>
<p>I made an exhaustive cheatsheet for your reference:</p>
<pre><code>#os.path methods in exhaustive cheatsheet
{'definition': ['dirname',
               'basename',
               'abspath',
               'relpath',
               'commonpath',
               'normpath',
               'realpath'],
'operation': ['split', 'splitdrive', 'splitext',
               'join', 'normcase'],
'compare': ['samefile', 'sameopenfile', 'samestat'],
'condition': ['isdir',
              'isfile',
              'exists',
              'lexists'
              'islink',
              'isabs',
              'ismount',],
 'expand': ['expanduser',
            'expandvars'],
 'stat': ['getatime', 'getctime', 'getmtime',
          'getsize']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4 the language provides a new module to manage files:</p>
<pre><code>import pathlib
path = pathlib.Path('path/to/file')
if path.is_file(): # If you want to check a directory: path.is_dir()
    # If it is true, return true on your code.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Additionally, <code>os.access()</code>:</p>
<pre><code>if os.access("myfile", os.R_OK):
    with open("myfile") as fp:
        return fp.read()
</code></pre>
<p>Being <code>R_OK</code>, <code>W_OK</code>, and <code>X_OK</code> the flags to test for permissions (<a href="https://docs.python.org/3/library/os.html#os.access" rel="noreferrer">doc</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>If the file is for opening you could use one of the following techniques:</p>
<pre><code>&gt;&gt;&gt; with open('somefile', 'xt') as f: #Using the x-flag, Python3.3 and above
...     f.write('Hello\n')

&gt;&gt;&gt; if not os.path.exists('somefile'): 
...     with open('somefile', 'wt') as f:
...         f.write("Hello\n")
... else:
...     print('File already exists!')
</code></pre>
<hr/>
<p><strong>UPDATE</strong></p>
<p>Just to avoid confusion and based on the answers I got, current answer finds either a file <strong>or</strong> a directory with the given name.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>if os.path.isfile(path_to_file):
    try: 
        open(path_to_file)
            pass
    except IOError as e:
        print "Unable to open file"
</code></pre>
<blockquote>
<p>Raising exceptions is considered to be an acceptable, and Pythonic,
  approach for flow control in your program. Consider handling missing
  files with IOErrors. In this situation, an IOError exception will be
  raised if the file exists but the user does not have read permissions.</p>
</blockquote>
<p>SRC: <a href="http://www.pfinn.net/python-check-if-file-exists.html">http://www.pfinn.net/python-check-if-file-exists.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can write Brian's suggestion without the <code>try:</code>.</p>
<pre><code>from contextlib import suppress

with suppress(IOError), open('filename'):
    process()
</code></pre>
<p><code>suppress</code> is part of Python 3.4. In older releases you can quickly write your own suppress:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def suppress(*exceptions):
    try:
        yield
    except exceptions:
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you imported NumPy already for other purposes then there is no need to import other libraries like <code>pathlib</code>, <code>os</code>, <code>paths</code>, etc.</p>
<pre><code>import numpy as np
np.DataSource().exists("path/to/your/file")
</code></pre>
<p>This will return true or false based on its existence.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Check file or directory exists</h1>
<p>You can follow these three ways:</p>
<blockquote>
<p>Note1: The <code>os.path.isfile</code> used only for files</p>
</blockquote>
<pre><code>import os.path
os.path.isfile(filename) # True if file exists
os.path.isfile(dirname) # False if directory exists
</code></pre>
<blockquote>
<p>Note2: The <code>os.path.exists</code> used for both files and directories</p>
</blockquote>
<pre><code>import os.path
os.path.exists(filename) # True if file exists
os.path.exists(dirname) #True if directory exists
</code></pre>
<blockquote>
<p>The <code>pathlib.Path</code> method (included in Python 3+, installable with pip for Python 2)</p>
</blockquote>
<pre><code>from pathlib import Path
Path(filename).exists()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Adding one more slight variation which isn't exactly reflected in the other answers.</p>
<p>This will handle the case of the <code>file_path</code> being <code>None</code> or empty string.</p>
<p></p>
<pre><code>def file_exists(file_path):
    if not file_path:
        return False
    elif not os.path.isfile(file_path):
        return False
    else:
        return True
</code></pre>
<p>Adding a variant based on suggestion from Shahbaz
</p>
<pre><code>def file_exists(file_path):
    if not file_path:
        return False
    else:
        return os.path.isfile(file_path)
</code></pre>
<p>Adding a variant based on suggestion from Peter Wood
</p>
<pre><code>def file_exists(file_path):
    return file_path and os.path.isfile(file_path):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses <code>Popen</code> to access <code>find</code>.  However, if you are on Windows, it replicates <code>find</code> with an efficient filesystem walker.</p>
<p>The code itself does not use a <code>try</code> block… except in determining the operating system and thus steering you to the "Unix"-style <code>find</code> or the hand-buillt <code>find</code>. Timing tests showed that the <code>try</code> was faster in determining the OS, so I did use one there (but nowhere else).</p>
<pre><code>&gt;&gt;&gt; import pox
&gt;&gt;&gt; pox.find('*python*', type='file', root=pox.homedir(), recurse=False)
['/Users/mmckerns/.python']
</code></pre>
<p>And the doc…</p>
<pre><code>&gt;&gt;&gt; print pox.find.__doc__
find(patterns[,root,recurse,type]); Get path to a file or directory

    patterns: name or partial name string of items to search for
    root: path string of top-level directory to search
    recurse: if True, recurse down from root directory
    type: item filter; one of {None, file, dir, link, socket, block, char}
    verbose: if True, be a little verbose about the search

    On some OS, recursion can be specified by recursion depth (an integer).
    patterns can be specified with basic pattern matching. Additionally,
    multiple patterns can be specified by splitting patterns with a ';'
    For example:
        &gt;&gt;&gt; find('pox*', root='..')
        ['/Users/foo/pox/pox', '/Users/foo/pox/scripts/pox_launcher.py']

        &gt;&gt;&gt; find('*shutils*;*init*')
        ['/Users/foo/pox/pox/shutils.py', '/Users/foo/pox/pox/__init__.py']

&gt;&gt;&gt;
</code></pre>
<p>The implementation, if you care to look, is here:
<a href="https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190" rel="noreferrer">https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I'm not such a hot Bash guy.</p>
<pre><code>python -c "import os.path; print os.path.isfile('/path_to/file.xxx')"
</code></pre>
<p>I hope this is helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the "OS" library of Python:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.exists("C:\\Users\\####\\Desktop\\test.txt") 
True
&gt;&gt;&gt; os.path.exists("C:\\Users\\####\\Desktop\\test.tx")
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>How do I check whether a file exists, without using the try statement?</strong></p>
</blockquote>
<p>In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:</p>
<pre><code>import os
os.path.isfile('./file.txt')    # Returns True if exists, else False
</code></pre>
<p><code>isfile</code> is actually just a helper method that internally uses <code>os.stat</code> and <code>stat.S_ISREG(mode)</code> underneath. This <code>os.stat</code> is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. <a href="https://docs.python.org/2/library/os.html#os.stat" rel="nofollow noreferrer">More about os.stat here</a></p>
<p><strong>Note:</strong> However, this approach will not lock the file in any way and therefore your code can become vulnerable to "<strong>time of check to time of use</strong>" (<em>TOCTTOU</em>) bugs.</p>
<p>So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than <code>if</code> statements (<em>just an advice</em>).</p>
</div>
<span class="comment-copy">A quick read of the <a href="https://docs.python.org/2/library/os.path.html" rel="nofollow noreferrer">os.path documentation</a> shows that this is achieved in a one-liner: <code>os.path.isfile(FILEPATH)</code>, as can many similar operations.</span>
<span class="comment-copy">Why would you want to avoid the exceptions in Python? They are the idiomatic way to do things.</span>
<span class="comment-copy">concerning the first remark (use "try" if check before open) unfortunately this will not work if you want to open for appending being sure it exists before since 'a' mode will create if not exists.</span>
<span class="comment-copy">Note that <code>FileNotFoundError</code> was introduced in Python 3. If you also need to support Python 2.7 as well as Python 3, you can use <code>IOError</code> instead (which <code>FileNotFoundError</code> subclasses) <a href="https://stackoverflow.com/a/21368457/1960959">stackoverflow.com/a/21368457/1960959</a></span>
<span class="comment-copy">Thanks for explaining the difference using variations in <code>isfile()</code> and <code>exists()</code>.</span>
<span class="comment-copy">having multiple conditions, some of which are superfluous, is <i>less</i> clear and explicit.</span>
<span class="comment-copy">It is also redundant. If the file doesn't exist, <code>os.access()</code> will return false.</span>
<span class="comment-copy">@EJP In linux files can exist but not accesible.</span>
<span class="comment-copy">since you <code>import os</code>, you do not need to <code>import os.path</code> again as it is already part of <code>os</code>. You just need to import <code>os.path</code> if you are only going to use functions from <code>os.path</code> and not from <code>os</code> itself, to import a smaller thing, but as you use <code>os.access</code> and <code>os.R_OK</code>, the second import is not needed.</span>
<span class="comment-copy">Can you elaborate on this statement? "Although it's not a good practice, I'm using os.F_OK in the call, but that's just for clarity (its value is 0)"</span>
<span class="comment-copy">@sk8asd123: Kind of hard to doo it in a comment: generally, it's best to use constants with functions that they come together with. That applies when working with multiple modules that define the same constant, because some might not be up to date, and it's best for the functions and constants to be in sync. When working with <i>ctypes</i> (calling the functions directly) I should have defined the constant (from <i>MSDN</i>), or not use a constant at all. It's just a guideline that I use, in 99.9% it probably makes no difference (functionally).</span>
<span class="comment-copy">@CristiFati: As of 3.6, <a href="https://docs.python.org/3/whatsnew/3.6.html#optimizations" rel="nofollow noreferrer"><code>glob.iglob</code> (and <code>glob.glob</code> as well) are based on <code>os.scandir</code></a>, so it's lazy now; to get the first hit in a directory of 10M files, you only scan until you reach the first hit. And even pre-3.6, if you use <code>glob</code> methods w/o any wildcards, the function is smart: It knows you can only have one hit, so <a href="https://github.com/python/cpython/blob/3ae41554c69b807659fab815ad5675bed5ae237/Lib/glob.py#L41" rel="nofollow noreferrer">it simplifies the globbing to just <code>os.path.isdir</code> or <code>os.path.lexists</code></a> (depending on whether path ends in <code>/</code>).</span>
<span class="comment-copy">That second part of my comment (non-wildcarded globbing doesn't actually iterate the folder, and never has) does mean it's a perfectly efficient solution to the problem (slower than directly calling <code>os.path.isdir</code> or <code>os.path.lexist</code> since it's a bunch of Python level function calls and string operations before it decides the efficient path is viable, but no additional system call or I/O work, which is orders of magnitude slower).</span>
<span class="comment-copy">As long as you intend to access the file, the race condition <i>does exist</i>, regardless of how your program is constructed.  Your program cannot guarantee that another process on the computer has not modified the file.  It's what Eric Lippert refers to as an <a href="http://blogs.msdn.com/b/ericlippert/archive/2008/09/10/vexing-exceptions.aspx" rel="nofollow noreferrer">exogenous exception</a>.  You cannot avoid it by checking for the file's existence beforehand.</span>
<span class="comment-copy">@IsaacSupeene Best practice is to make the window of (file) operation as small as possible followed by a proper exception handling</span>
<span class="comment-copy">Please add better sources to support your statement.</span>
<span class="comment-copy">The cited Avoiding Race Conditions (apple dev support) link does not support your answer.  It concerns only using temporary files that contain sensitive information on poorly designed operating systems that don't properly sandbox temporary files / directories via restricted permissions.  Using <code>try...except</code> doesn't help resolve <i>that</i> problem anyway.</span>
<span class="comment-copy">While this link may answer the question, it is better to include the essential parts of the answer here and provide the link for reference.  Link-only answers can become invalid if the linked page changes. - <a href="/review/low-quality-posts/18859700">From Review</a></span>
<span class="comment-copy">@chrisz I don't think that it's link-only - it actually has information other than the link.</span>
<span class="comment-copy">This answer is wrong. <code>os.path.exists</code> returns true for things that aren't files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.</span>
<span class="comment-copy">May I ask: What's the advantage of using the module 'pathlib' instead of the module 'os' in python3 for this checking?</span>
<span class="comment-copy"><code>pathlib</code> is python's OOP solution for paths. You can do a lot more with it. If you just need to check existance, the advantage is not so big.</span>
<span class="comment-copy">This answer is wrong. <code>os.path.exists</code> returns true for things that aren't files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.</span>
<span class="comment-copy">On your third example, I create a link named <code>filepath</code> with the right timing, and <i>BAM</i>, you overwrite the target file. You should do <code>open(filepath, 'wx')</code> in a <code>try...except</code> block to avoid the issue.</span>
<span class="comment-copy">In your second example, at least in Windows, you will get an <code>OSError</code> if <code>filepath + '.old'</code> already exists: "On Windows, if dst already exists, OSError will be raised even if it is a file; there may be no way to implement an atomic rename when dst names an existing file."</span>
<span class="comment-copy">@TomMyddeltyn: <a href="https://docs.python.org/3/library/os.html#os.replace" rel="nofollow noreferrer">As of Python 3.3, <code>os.replace</code></a> portably performs silent replacement of the destination file (it's identical to <code>os.rename</code>'s Linux behavior) (it only errors if the destination name exists and is a directory). So you're stuck on 2.x, but Py3 users have had a good option for several years now.</span>
<span class="comment-copy">On the <code>rename</code> example: It should still be done with <code>try</code>/<code>except</code>. <code>os.rename</code> (or <code>os.replace</code> on modern Python) is atomic; making it check then rename introduces an unnecessary race and additional system calls. Just do <code>try: os.replace(filepath, filepath + '.old') except OSError: pass</code></span>
<span class="comment-copy">The original question asked for a solution that does not use <code>try</code></span>
<span class="comment-copy">This answer misses the point of the OP.  Checking is a file exists is not the same as checking if you can open it.  There will be cases where a file does exist but for a variety of reasons, you can't open it.</span>
<span class="comment-copy">How is this any different from Cody Piersall's <a href="http://stackoverflow.com/a/21641213/369450">answer</a>?</span>
<span class="comment-copy">This answer is wrong. <code>os.path.exists</code> returns true for things that aren't files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.</span>
<span class="comment-copy">got the false positive problem also.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/os.path.html#os.path.exists" rel="nofollow noreferrer">docs.python.org/3/library/os.path.html#os.path.exists</a> <b>To the above statement from chris</b> &gt;&gt;os.path.exists(path) &gt; Return True if path refers to an existing path or an open file descriptor. Returns False for broken symbolic links. On some platforms, this function may return False if permission is not granted to execute os.stat() on the requested file, even if the path physically exists.  Changed in version 3.3: path can now be an integer: True is returned if it is an open file descriptor, False otherwise.  Changed in version 3.6: Accepts a path-like object.</span>
<span class="comment-copy">The OP asked how to check if a file exists.  It's possible for a file to exist but for you to not be able to open it.  Therefore using opening a file as a proxy for checking if the file exists is not correct: will have false negatives.</span>
<span class="comment-copy"><code>if (x) return true; else return false;</code> is really just <code>return x</code>. Your last four lines can become <code>return os.path.isfile(file_path)</code>. While we're at it, the whole function can be simplified as <code>return file_path and os.path.isfile(file_path)</code>.</span>
<span class="comment-copy">You have to be careful with <code>return x</code> in the case of <code>if (x)</code>.  Python will consider an empty string False in which case we would be returning an empty string instead of a bool.  The purpose of this function is to always return bool.</span>
<span class="comment-copy">True. In this case however, <code>x</code> is <code>os.path.isfile(..)</code> so it's already bool.</span>
<span class="comment-copy"><code>os.path.isfile(None)</code> raises an exception which is why I added the if check.  I could probably just wrap it in a try/except instead but I felt it was more explicit this way.</span>
<span class="comment-copy"><code>return file_path and os.path.isfile(file_path)</code></span>
<span class="comment-copy">One-line check in bash: <code>[ -f "${file}" ] &amp;&amp; echo "file found" || echo "file not found"</code> (which is the same as <code>if [ ... ]; then ...; else ...; fi</code>).</span>
<span class="comment-copy">This answer is wrong. <code>os.path.exists</code> returns true for things that aren't files, such as directories. This gives false positives. See the other answers that recommend <code>os.path.isfile</code>.</span>
<span class="comment-copy">@Chris Johnson , os.path.exists() function checks whether a path exists in system. PATH may be a DIRECTORY or FILE. It will work fine on both the cases. Please try with some example</span>
<span class="comment-copy">So, this answer works. Great. <b>Iff</b> the path isn't that of a file. Is that what the question was about? No.</span>
<span class="comment-copy">It depends. If the goal of determining the existence of a "file" is to find out whether the path already exists (and is therefore not a path where new data can be stored without deleting other information), then <code>exists</code> is fine. If the goal is to determine whether it's safe to open a presumably existing file, then the criticism is justified and exists is not precise enough. Sadly, the OP doesn't specify which is the desired goal (and probably won't do so any more).</span>
