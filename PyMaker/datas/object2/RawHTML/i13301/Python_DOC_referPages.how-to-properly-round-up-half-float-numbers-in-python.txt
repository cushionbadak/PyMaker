<div class="post-text" itemprop="text">
<p>I am facing a strange behavior of the <code>round()</code> function:</p>
<pre><code>for i in range(1, 15, 2):
    n = i / 2
    print(n, "=&gt;", round(n))
</code></pre>
<p>This code prints:</p>
<pre><code>0.5 =&gt; 0
1.5 =&gt; 2
2.5 =&gt; 2
3.5 =&gt; 4
4.5 =&gt; 4
5.5 =&gt; 6
6.5 =&gt; 6
</code></pre>
<p>I expected the floating values to be always rounded up, but instead, it is rounded to the nearest even number.</p>
<p>Why such behavior, and what is the best way to get the correct result?</p>
<p>I tried to use the <a href="https://docs.python.org/3.5/library/fractions.html" rel="noreferrer"><code>fractions</code></a> but the result is the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex" rel="noreferrer"><em>Numeric Types</em> section</a> documents this behaviour explicitly:</p>
<blockquote>
<p><code>round(x[, n])</code><br/>
<em>x</em> rounded to n digits, rounding half to even. If n is omitted, it defaults to 0.    </p>
</blockquote>
<p>Note the <em>rounding half to even</em>. This is also called <em>bankers rounding</em>; instead of always rounding up or down (compounding rounding errors), by rounding to the nearest <em>even</em> number you average out rounding errors.</p>
<p>If you need more control over the rounding behaviour, use the <a href="https://docs.python.org/3/library/decimal.html" rel="noreferrer"><code>decimal</code> module</a>, which lets you specify exactly what <a href="https://docs.python.org/3/library/decimal.html#rounding-modes" rel="noreferrer">rounding strategy should be used</a>. </p>
<p>For example, to round up from half:</p>
<pre><code>&gt;&gt;&gt; from decimal import localcontext, Decimal, ROUND_HALF_UP
&gt;&gt;&gt; with localcontext() as ctx:
...     ctx.rounding = ROUND_HALF_UP
...     for i in range(1, 15, 2):
...         n = Decimal(i) / 2
...         print(n, '=&gt;', n.to_integral_value())
...
0.5 =&gt; 1
1.5 =&gt; 2
2.5 =&gt; 3
3.5 =&gt; 4
4.5 =&gt; 5
5.5 =&gt; 6
6.5 =&gt; 7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For example:</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP

Decimal(1.5).quantize(0, ROUND_HALF_UP)

# This also works for rounding to the integer part:
Decimal(1.5).to_integral_value(rounding=ROUND_HALF_UP)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>round()</code> will round either up or down, depending on if the number is even or odd. A simple way to only round up is:</p>
<pre><code>int(num + 0.5)
</code></pre>
<p>If you want this to work properly for negative numbers use:</p>
<pre><code>((num &gt; 0) - (num &lt; 0)) * int(abs(num) + 0.5)
</code></pre>
<p>Note, this can mess up for large numbers or really precise numbers like <code>5000000000000001.0</code> and <code>0.49999999999999994</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this:</p>
<pre><code>import math
def normal_round(n):
    if n - math.floor(n) &lt; 0.5:
        return math.floor(n)
    return math.ceil(n)
</code></pre>
<p>It will round number up or down properly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The behavior you are seeing is typical IEEE 754 rounding behavior. If it has to choose between two numbers that are equally different from the input, it always picks the even one. The advantage of this behavior is that the average rounding effect is zero - equally many numbers round up and down. If you round the half way numbers in a consistent direction the rounding will affect the expected value.</p>
<p>The behavior you are seeing is correct if the objective is fair rounding, but that is not always what is needed.</p>
<p>One trick to get the type of rounding you want is to add 0.5 and then take the floor. For example, adding 0.5 to 2.5 gives 3, with floor 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short version: use the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow">decimal module</a>. It can represent numbers like 2.675 precisely, unlike Python floats where 2.675 is <strong>really</strong> 2.67499999999999982236431605997495353221893310546875 (exactly). And you can specify the rounding you desire: ROUND_CEILING, ROUND_DOWN, ROUND_FLOOR, ROUND_HALF_DOWN, ROUND_HALF_EVEN, ROUND_HALF_UP, ROUND_UP, and ROUND_05UP are all options.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rounding to the nearest even number has become common practice in numerical disciplines.  "Rounding up" produces a slight bias towards larger results.</p>
<p>So, from the perspective of the scientific establishment, <code>round</code> has the correct behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP

for i in range(1, 15, 2):
    n = i / 2
    print(n, "=&gt;", Decimal(str(n)).quantize(Decimal("1"), rounding=ROUND_HALF_UP))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Love the <a href="https://stackoverflow.com/users/4770410/fedor2612">fedor2612</a> answer. I expanded it with an optional "decimals" argument for those who want to use this function to round any number of decimals (say for example if you want to round a currency $26.455 to $26.46).</p>
<pre><code>import math

def normal_round(n, decimals=0):
    expoN = n * 10 ** decimals
    if abs(expoN) - abs(math.floor(expoN)) &lt; 0.5:
        return math.floor(expoN) / 10 ** decimals
    return math.ceil(expoN) / 10 ** decimals

oldRounding = round(26.455,2)
newRounding = normal_round(26.455,2)

print(oldRounding)
print(newRounding)
</code></pre>
<p>Output:</p>
<blockquote>
<p>26.45</p>
<p>26.46</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Here is another solution.
It will work as normal rounding in excel.</p>
<pre><code>from decimal import Decimal, getcontext, ROUND_HALF_UP

round_context = getcontext()
round_context.rounding = ROUND_HALF_UP

def c_round(x, digits, precision=5):
    tmp = round(Decimal(x), precision)
    return float(tmp.__round__(digits))
</code></pre>
<p><code>c_round(0.15, 1) -&gt; 0.2, c_round(0.5, 0) -&gt; 1</code></p>
</div>
<div class="post-text" itemprop="text">
<h1>A classical mathematical rounding without any libraries</h1>
<pre><code>def rd(x,y=0):
''' A classical mathematical rounding by Voznica '''
m = int('1'+'0'*y) # multiplier - how many positions to the right
q = x*m # shift to the right by multiplier
c = int(q) # new number
i = int( (q-c)*10 ) # indicator number on the right
if i &gt;= 5:
    c += 1
return c/m

Compare:

print( round(0.49), round(0.51), round(0.5), round(1.5), round(2.5), round(0.15,1))  # 0  1  0  2  2  0.1

print( rd(0.49), rd(0.51), rd(0.5), rd(1.5), rd(2.5), rd(0.15,1))  # 0  1  1  2  3  0.2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following solution achieved "school fashion rounding" without using the <code>decimal</code> module (which turns out to be slow).</p>
<pre><code>def school_round(a_in,n_in):
''' python uses "banking round; while this round 0.05 up" '''
    if (a_in * 10 ** (n_in + 1)) % 10 == 5:
        return round(a_in + 1 / 10 ** (n_in + 1), n_in)
    else:
        return round(a_in, n_in)
</code></pre>
<p>e.g. </p>
<pre><code>print(round(0.005,2)) # 0
print(school_round(0.005,2)) #0.01
</code></pre>
</div>
<span class="comment-copy">can't explain the behaviour of <code>round()</code> but you could use <code>math.ceil()</code>  if you always want to round up</span>
<span class="comment-copy">@yurib I would like <code>1.3</code> to be rounded down to <code>1</code>, so I can not use <code>ceil()</code>.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/455612/limiting-floats-to-two-decimal-points">Limiting floats to two decimal points</a></span>
<span class="comment-copy">Many days have passed since I studied error analysis. However If I recall correctly, the rounding of <code>5*10**-k</code> depends on the digit preceding it. By rounding up for uneven digits and down for even digits, you get a positive error half the time and an even error half the time (in theory). When you perform many additions, those errors can cancel each-other</span>
<span class="comment-copy">IEEE 754 rounding half to even is also described at <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="nofollow noreferrer">en.wikipedia.org/wiki/Rounding#Round_half_to_even</a></span>
<span class="comment-copy">In your example, is there a benefit to modifying the local context as opposed to just using the <code>rounding</code> argument as in: <code>n.to_integral_value(rounding=ROUND_HALF_UP)</code>?</span>
<span class="comment-copy">@dhobbs: setting the context once is clearer in intent, but from a technical point of view there is no difference.</span>
<span class="comment-copy">There are some subtleties that aren't addressed by this solution. E.g., what result does this give if <code>num = -2.4</code>?  What about <code>num = 0.49999999999999994</code>? <code>num = 5000000000000001.0</code>? On a typical machine using IEEE 754 format and semantics, this solution gives the wrong answer for all three of these cases.</span>
<span class="comment-copy">@Mark Dickinson I've updated the post to mention this. Thanks</span>
