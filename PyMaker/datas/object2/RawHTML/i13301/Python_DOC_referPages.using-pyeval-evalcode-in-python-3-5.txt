<div class="post-text" itemprop="text">
<p>I'm trying to port an extension module from 2.7 to 3.5.  The extension module uses <code>PyEval_EvalCode</code>.  It does this with some code similar to the following:</p>
<pre><code>struct _node *compiled_node = PyParser_SimpleParseString (in_string, Py_file_input);
if (compiled_node)
{
    PyCodeObject *compiled_code = PyNode_Compile (compiled_node, "temp.py");
    if (compiled_code)
    {
      return_value.Reset(PyEval_EvalCode (compiled_code, globals.get(), locals.get()));
    }
}
</code></pre>
<p>In Python 2.7 this works fine.  In Python 3.5 I get a compilation failure, because <code>PyNode_Compile</code> returns a <code>PyCodeObject</code>, but in Python 3.5 <code>PyEval_EvalCode</code> <em>accepts</em> a <code>PyObject*</code>.  What do I need to do to convert this into a <code>PyObject</code> that I can pass to <code>PyEval_EvalCode</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>For the vast majority of Python types, <code>PyObject</code> is the "parent" struct of the type. Try casting the argument: <code>(PyObject*)compiled_code</code>.</p>
<p>The <a href="https://docs.python.org/3/c-api/code.html" rel="nofollow">Code Objects</a> docs make it clear that <code>PyObject*</code> can be <code>PyCodeObject*</code> (otherwise <code>PyCode_Check</code> wouldn't exist), so if you know it's a code object, the cast is safe.</p>
</div>
<span class="comment-copy">Thanks, it's weird that they decided to have <code>PyNode_Compile</code> return a <code>PyCodeObject</code> instead of a <code>PyObject</code> like all the other methods do.  That threw me for a loop.</span>
