<div class="post-text" itemprop="text">
<p>If I have a very long string (say 100 million characters), is there a way to iterate through the characters using something like <code>for c in str:</code> but starting a certain number of characters in? I'd prefer not to slice the string and use a subset, because I understand that slicing the string will make a copy (very expensive in my case). In other words, can I specify a start point for an iterator over a string?</p>
</div>
<div class="post-text" itemprop="text">
<p>In python3 <code>range</code> is an generator, and not a list. That means that the following code will not require excessive memory:</p>
<pre><code>for i in range(start_pos, len(my_string)):
   print(my_string[i])
</code></pre>
<p>If you'd rather use an iterator over <code>my_string</code> then you need to write it yourself:</p>
<pre><code>def iter_starting_at(start_pos, string):
    for i in range(start_pos, len(string)):
        yield string[i]

for character in iter_starting_at(start_pos, my_string):
    print(character)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can do it using string indexes, like it's list:</p>
<pre><code>for i in xrange(100, 200):
    print(s[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Consider using <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow">itertools.islice</a> as follows:</p>
<pre><code>from itertools import islice

for c in islice(my_str, start, stop):
    print(c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of generating indexes into the string, we could use <code>itertools.islice</code>, which returns an iterator over a slice.</p>
<pre><code>for c in itertools.islice(my_enormous_string, start_pos):
    ...
</code></pre>
</div>
<span class="comment-copy">Oh - I'm mainly using python 3, if that makes  difference. But would be interested to know for 2.7 as well</span>
<span class="comment-copy">Sounds slow to use an index every time. But maybe it's just as quick as an iterator. <code>range(100,100000000)</code> looks worryingly intensive to me, although again I may be wrong because the range result is probably an iterator, not an actual list.</span>
<span class="comment-copy">In Python 3, <code>range</code> is an iterator ... In Python 2.7 it is not, and you should use <code>xrange</code></span>
<span class="comment-copy">@donkopotamus thanks, I've replaced range to xrange.</span>
<span class="comment-copy">Note that <code>islice</code> will actually iterate over the first <code>start_pos</code> characters doing nothing though. String indexing will be faster for a large start position.</span>
<span class="comment-copy">@poke, absolutely right. I tend to forget this nuance in its behaviour :(</span>
<span class="comment-copy">Note that <code>islice</code> will actually iterate over the first <code>start_pos</code> characters doing nothing though. String indexing will be faster for a large start position.</span>
<span class="comment-copy">+1 for using the islice built in. But looking at the code this just does a range operator anyway, and is not optimised for large start positions as @poke says.</span>
