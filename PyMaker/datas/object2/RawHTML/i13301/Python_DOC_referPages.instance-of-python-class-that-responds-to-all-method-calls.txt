<div class="post-text" itemprop="text">
<p>Is there a way to create a class which instances respond to arbitrary method calls? </p>
<p>I know there is a the special method <code>__getattr__(self, attr)</code> which would be called when someone is trying to access an attribute of an instance. I am searching for something similar that enables me to intercept method calls, too. The desired behavior would look something like this:</p>
<pre><code>class A(object):
    def __methodintercept__(self, method, *args, **kwargs): # is there a special method like this??
        print(str(method))


&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.foomatic()
foomatic
</code></pre>
<p><strong>EDIT</strong></p>
<p>The other suggested questions do not address my case: I do not want to wrap another class or change the metaclass of a second class or similar. I just want to have a class that responds to arbitrary method calls.</p>
<p>Thanks to jonrshape I now know that <code>__getattr__(self, attr)</code> will also be called when a method is called in the same way as it would be when an attribute is accessed. But how do i distinguish in <code>__getattr__</code> if <code>attr</code> comes from a method call or an attribute access and how to get the parameters of a potential method call? </p>
</div>
<div class="post-text" itemprop="text">
<p>This is something I came up with, which will behave exactly as if the method exists.</p>
<p>First let's establish one thing: You cannot distinguish in <code>__getattr__</code> if <code>attr</code> comes from a function call or an "attribute access", because a class method <strong>is an attribute</strong> of your class. So someone can access that method even if they don't intend to call it, as in: </p>
<pre><code>class Test:
    def method(self):
        print "Hi, I am method"

&gt;&gt; t = Test()
&gt;&gt; t.method # just access the method "as an attribute"
&lt;bound method Test.method of &lt;__main__.Test instance at 0x10a970c68&gt;&gt;

&gt;&gt; t.method() # actually call the method
Hi, I am method
</code></pre>
<p>Therefore, the closest thing I could think of is this behavior:</p>
<p>Create a class A, such that:</p>
<ol>
<li>When we try to access an attribute / method, which already exists in that class, act normal and just return the requested attribute / method.</li>
<li>When we try to access something that doesn't exist in the class definition, treat it as a class method and have 1 global handler for all such methods. </li>
</ol>
<p>I will first write the class definition and then show how accessing a method that doesn't exist behaves exactly like accessing one that exists, whether you are just accessing it, or actually calling it.</p>
<p>Class definition:</p>
<pre><code>class A(object):
    def __init__(self):
        self.x = 1 # set some attribute

    def __getattr__(self,attr):
        try:
            return super(A, self).__getattr__(attr)
        except AttributeError:
            return self.__get_global_handler(attr)

    def __get_global_handler(self, name):
        # Do anything that you need to do before simulating the method call
        handler = self.__global_handler
        handler.im_func.func_name = name # Change the method's name
        return handler

    def __global_handler(self, *args, **kwargs):
        # Do something with these arguments
        print "I am an imaginary method with name %s" % self.__global_handler.im_func.func_name
        print "My arguments are: " + str(args)
        print "My keyword arguments are: " + str(kwargs)

    def real_method(self, *args, **kwargs):
        print "I am a method that you actually defined"
        print "My name is %s" % self.real_method.im_func.func_name
        print "My arguments are: " + str(args)
        print "My keyword arguments are: " + str(kwargs)
</code></pre>
<p>I added the method <code>real_method</code> just so I have something that actually exists in the class to compare its behavior with that of an 'imaginary method' </p>
<p>Here's the result:</p>
<pre><code>&gt;&gt; a = A() 
&gt;&gt; # First let's try simple access (no method call)
&gt;&gt; a.real_method # The method that is actually defined in the class
&lt;bound method A.real_method of &lt;test.A object at 0x10a9784d0&gt;&gt;

&gt;&gt; a.imaginary_method # Some method that is not defined
&lt;bound method A.imaginary_method of &lt;test.A object at 0x10a9784d0&gt;&gt;

&gt;&gt; # Now let's try to call each of these methods
&gt;&gt; a.real_method(1, 2, x=3, y=4)
I am a method that you actually defined
My name is real_method
My arguments are: (1, 2)
My keyword arguments are: {'y': 4, 'x': 3}

&gt;&gt; a.imaginary_method(1, 2, x=3, y=4)
I am an imaginary method with name imaginary_method
My arguments are: (1, 2)
My keyword arguments are: {'y': 4, 'x': 3}

&gt;&gt; # Now let's try to access the x attribute, just to make sure that 'regular' attribute access works fine as well
&gt;&gt; a.x
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.mock.html#the-mock-class" rel="noreferrer"><code>unittest.mock.Mock</code></a> does this by default.</p>
<pre><code>from unittest.mock import Mock

a = Mock()

a.arbitrary_method()                             # No error
a.arbitrary_method.called                        # True
a.new_method
a.new_method.called                              # False
a.new_method("some", "args")
a.new_method.called                              # True
a.new_method.assert_called_with("some", "args")  # No error
a.new_method_assert_called_with("other", "args") # AssertionError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Method calls aren't any different from attribute access. <a href="https://docs.python.org/2/reference/datamodel.html?highlight=__getattr__#object.__getattr__" rel="nofollow"><code>__getattr__()</code></a> or <a href="https://docs.python.org/2/reference/datamodel.html?highlight=__getattr__#object.__getattribute__" rel="nofollow"><code>__getattribute__()</code></a> is the way to respond to arbitrary attribute requests.</p>
<p>You cannot know if the access comes from "just retrieval" or "method call".</p>
<p>It works like this: first, attribute retrieval, then, call on the retrieved object (in Python, call is just another operator: anything can be called and will throw an exception if it isn't callable). One doesn't, and shouldn't, know about the other (well, you can analyze the code up the call stack, but that's totally not the thing to do here).</p>
<p>One of the reasons is - functions are first-class objects in Python, i.e. a function (or, rather, a reference to it) is no different from any other data type: I can get the reference, save it and pass it around. I.e. there's completely no difference between requesting a data field and a method.</p>
<p>Elaborate on what you need this for for us to suggest a better solution.</p>
<p>E.g., if you need the "method" to be able to be called with different signatures, <code>*args</code> and <code>**kwargs</code> is the way to go.</p>
</div>
<span class="comment-copy">Methods are handled no differently than any other attributes, you still need <code>__getattr__</code>/<code>__getattribute__</code>.</span>
<span class="comment-copy">@jonrsharpe mmh if i implement a class A with <code>__getattr__</code> and a print inside and do <code>a=A(); a.foo</code> it will print <code>foo</code> but if i call <code>a=A(); a.foo()</code> it  will raise a <code>TypeError: 'NoneType' object is not callable</code></span>
<span class="comment-copy"><code>__getattr__</code> will still have to <i>return</i> something callable, not <i>call</i> it, otherwise you get the default <code>None</code> back</span>
<span class="comment-copy">@jonrsharpe ah, ok thanks, i misunderstood the error. That fixes it, thank you!</span>
<span class="comment-copy">If you have answered your own question, please post an answer with your working code and mark it as accepted. This will help people in the future who have the same question.</span>
<span class="comment-copy">Thanks for your answer, gave me a deeper understanding of Python. The only thing I found: if i call <code>a.attribute_that_doesnt_exist</code> it will respond with nothing</span>
<span class="comment-copy">@Salo If you call <code>a.attribute_that_doesnt_exist</code> it shouldn't respond with nothing (<code>None</code>). It should actually return a "bound method" object.   So: <code>a.method</code> returns the method. If you add the parentheses <code>()</code> (with arguments,optionally) after the method call (<code>a.method()</code>) , it will be evaluated.  Open a python interpreter (<code>python</code>, ideally <code>ipython</code>), and type <code>a.attribute_that_doesnt_exist</code>. You should get sth like <code>&lt;bound method A.attribute_that_doesnt_exist of &lt;test.A object at 0x10974f490&gt;&gt;</code>  This is python's way of telling you that this is a class method, but you're not calling it.</span>
<span class="comment-copy">You're right, thanks again</span>
