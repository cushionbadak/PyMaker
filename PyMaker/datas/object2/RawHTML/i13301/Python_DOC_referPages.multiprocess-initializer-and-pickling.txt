<div class="post-text" itemprop="text">
<p>I've been playing around with <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool" rel="nofollow"><code>multiprocessing.Pool</code></a> and trying to understand how exactly the <code>initializer</code> argument works. From what I understand, the initializer function is called for each process, so I assumed the arguments to it (i.e. <code>initargs</code>) would have to be pickled across process boundaries. I know that the <code>map</code> method of a pool also uses pickling for its arguments, so I assumed that anything that works as an argument for the initializer should also work as an argument for mapping.</p>
<p>However, when I run the following piece of code, <code>initialize</code> gets called just fine, but then <code>map</code> throws an exception about not being able to pickle the module. (There's nothing special about using the current module as the argument; it was just the first non-pickleable object that came to mind.) Does anyone know what could be behind this difference?</p>
<pre><code>from __future__ import print_function
import multiprocessing
import sys


def get_pid():
    return multiprocessing.current_process().pid


def initialize(module):
    print('Got module {} in PID {}'.format(module, get_pid()))


def worker(module):
    print('Got module {} in PID {}'.format(module, get_pid()))


current_module = sys.modules[__name__]
work = [current_module]

print('Main process has PID {}'.format(get_pid()))
pool = multiprocessing.Pool(None, initialize, work)
pool.map(worker, work)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Initialize doesn't require pickling, but the <code>map</code> call does. Maybe this will shed some light…  (here I'm using <code>multiprocess</code> instead of <code>multiprocessing</code> to give better pickling and interactivity).</p>
<pre><code>&gt;&gt;&gt; from __future__ import print_function
&gt;&gt;&gt; import multiprocess as multiprocessing
&gt;&gt;&gt; import sys
&gt;&gt;&gt; 
&gt;&gt;&gt; def get_pid():
...     return multiprocessing.current_process().pid
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; def initialize(module):
...     print('Got module {} in PID {}'.format(module, get_pid()))
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; def worker(module):
...     print('Got module {} in PID {}'.format(module, get_pid()))
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; current_module = sys.modules[__name__]
&gt;&gt;&gt; work = [current_module]
&gt;&gt;&gt; 
&gt;&gt;&gt; print('Main process has PID {}'.format(get_pid()))
Main process has PID 34866
&gt;&gt;&gt; pool = multiprocessing.dummy.Pool(None, initialize, work)
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
&gt;&gt;&gt; pool.map(worker, work)
Got module &lt;module '__main__' (built-in)&gt; in PID 34866
[None]
</code></pre>
<p>Cool. The threading <code>pool</code> works… (because it doesn't need to pickle anything).  How about when we are shipping both <code>worker</code> and <code>work</code> using serialization?</p>
<pre><code>&gt;&gt;&gt; pool = multiprocessing.Pool(None, initialize, work)
Got module &lt;module '__main__' (built-in)&gt; in PID 34875
Got module &lt;module '__main__' (built-in)&gt; in PID 34876
Got module &lt;module '__main__' (built-in)&gt; in PID 34877
Got module &lt;module '__main__' (built-in)&gt; in PID 34878
Got module &lt;module '__main__' (built-in)&gt; in PID 34879
Got module &lt;module '__main__' (built-in)&gt; in PID 34880
Got module &lt;module '__main__' (built-in)&gt; in PID 34881
Got module &lt;module '__main__' (built-in)&gt; in PID 34882
&gt;&gt;&gt; pool.map(worker, work)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Users/mmckerns/lib/python2.7/site-packages/multiprocess-0.70.4.dev0-py2.7-macosx-10.8-x86_64.egg/multiprocess/pool.py", line 251, in map
    return self.map_async(func, iterable, chunksize).get()
  File "/Users/mmckerns/lib/python2.7/site-packages/multiprocess-0.70.4.dev0-py2.7-macosx-10.8-x86_64.egg/multiprocess/pool.py", line 567, in get
    raise self._value
NotImplementedError: pool objects cannot be passed between processes or pickled
&gt;&gt;&gt; 
</code></pre>
<p>So let's look at pickling <code>work</code>:</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; import sys            
&gt;&gt;&gt; pickle.dumps(sys.modules[__name__])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 1374, in dumps
    Pickler(file, protocol).dump(obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 224, in dump
    self.save(obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 306, in save
    rv = reduce(self.proto)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/copy_reg.py", line 70, in _reduce_ex
    raise TypeError, "can't pickle %s objects" % base.__name__
TypeError: can't pickle module objects
&gt;&gt;&gt; 
</code></pre>
<p>So, you can't pickle a module… ok, can we do better using <code>dill</code>?</p>
<pre><code>&gt;&gt;&gt; import dill
&gt;&gt;&gt; dill.detect.trace(True)
&gt;&gt;&gt; dill.pickles(work)
M1: &lt;module '__main__' (built-in)&gt;
F2: &lt;function _import_module at 0x10c017cf8&gt;
# F2
D2: &lt;dict object at 0x10d9a8168&gt;
M2: &lt;module 'dill' from '/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/__init__.pyc'&gt;
# M2
F1: &lt;function worker at 0x10c07fed8&gt;
F2: &lt;function _create_function at 0x10c017488&gt;
# F2
Co: &lt;code object worker at 0x10b053cb0, file "&lt;stdin&gt;", line 1&gt;
F2: &lt;function _unmarshal at 0x10c017320&gt;
# F2
# Co
D1: &lt;dict object at 0x10af68168&gt;
# D1
D2: &lt;dict object at 0x10c0e4a28&gt;
# D2
# F1
M2: &lt;module 'sys' (built-in)&gt;
# M2
F1: &lt;function initialize at 0x10c07fe60&gt;
Co: &lt;code object initialize at 0x10b241f30, file "&lt;stdin&gt;", line 1&gt;
# Co
D1: &lt;dict object at 0x10af68168&gt;
# D1
D2: &lt;dict object at 0x10c0ea398&gt;
# D2
# F1
M2: &lt;module 'pathos' from '/Users/mmckerns/lib/python2.7/site-packages/pathos-0.2a1.dev0-py2.7.egg/pathos/__init__.pyc'&gt;
# M2
C2: __future__._Feature
# C2
D2: &lt;dict object at 0x10b05b7f8&gt;
# D2
M2: &lt;module 'multiprocess' from '/Users/mmckerns/lib/python2.7/site-packages/multiprocess-0.70.4.dev0-py2.7-macosx-10.8-x86_64.egg/multiprocess/__init__.pyc'&gt;
# M2
T4: &lt;class 'pathos.threading.ThreadPool'&gt;
# T4
D2: &lt;dict object at 0x10c0ea5c8&gt;
# D2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/dill.py", line 1209, in pickles
    pik = copy(obj, **kwds)
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/dill.py", line 161, in copy
    return loads(dumps(obj, *args, **kwds))
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/dill.py", line 197, in dumps
    dump(obj, file, protocol, byref, fmode, recurse)#, strictio)
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/dill.py", line 190, in dump
    pik.dump(obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 224, in dump
    self.save(obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 600, in save_list
    self._batch_appends(iter(obj))
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 636, in _batch_appends
    save(tmp[0])
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/dill.py", line 1116, in save_module
    state=_main_dict)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 419, in save_reduce
    save(state)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.5.dev0-py2.7.egg/dill/dill.py", line 768, in save_module_dict
    StockPickler.save_dict(pickler, obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 649, in save_dict
    self._batch_setitems(obj.iteritems())
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 681, in _batch_setitems
    save(v)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 306, in save
    rv = reduce(self.proto)
  File "/Users/mmckerns/lib/python2.7/site-packages/multiprocess-0.70.4.dev0-py2.7-macosx-10.8-x86_64.egg/multiprocess/pool.py", line 452, in __reduce__
    'pool objects cannot be passed between processes or pickled'
NotImplementedError: pool objects cannot be passed between processes or pickled
&gt;&gt;&gt; 
</code></pre>
<p>The answer is <strong>yes</strong> -- the module starts to pickle, however, fails due to the contents in the module… so it looks like it works for everything in <code>__main__</code> except when there's an instance of a <code>pool</code> in <code>__main__</code> -- then it will fail.</p>
<p>So, if your last two lines of code were replaced with this one, it will work:</p>
<pre><code>&gt;&gt;&gt; multiprocessing.Pool(None, initialize, work).map(worker, work)
Got module &lt;module '__main__' (built-in)&gt; in PID 34922
Got module &lt;module '__main__' (built-in)&gt; in PID 34923
Got module &lt;module '__main__' (built-in)&gt; in PID 34924
Got module &lt;module '__main__' (built-in)&gt; in PID 34925
Got module &lt;module '__main__' (built-in)&gt; in PID 34926
Got module &lt;module '__main__' (built-in)&gt; in PID 34927
Got module &lt;module '__main__' (built-in)&gt; in PID 34928
Got module &lt;module '__main__' (built-in)&gt; in PID 34929
Got module &lt;module '__main__' (built-in)&gt; in PID 34922
[None]
&gt;&gt;&gt; 
</code></pre>
<p>That's using <code>multiprocess</code>, as it uses <code>dill</code> under the covers.  <code>pickle</code> will still fail to pickle here because <code>pickle</code> can't serialize a module.  Serialization is needed, as the object have to be sent to another python instance on another process. </p>
</div>
<span class="comment-copy">Thank you for the detailed response, and for introducing me to the <code>multiprocess</code> module :) Does the <code>initializer</code> argument not need to pickle because it can just access the original memory directly (since all the processes will be spawned via <code>fork</code>)?</span>
<span class="comment-copy">Just confirmed this by setting the <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">start method</a> to be <code>spawn</code>, which indeed requires the arguments to the initializer function to be pickleable. Thanks again!</span>
<span class="comment-copy">absolutely correct</span>
