<div class="post-text" itemprop="text">
<p>This is kind of confusing I suppose, but I have a CSV with 3 columns, </p>
<pre><code>Example:
name, product, type
John, car, new
Jim, truck, used
Jack, minivan, new
Jane, SUV, used
Jeff, car, used
</code></pre>
<p>First, I want to go through the CSV and remove all rows except for "new". Once that is done I want to remove all but the first column, and then save that list as a text file. </p>
<p>The code I have so far...</p>
<pre><code>import csv
input_file = 'example.csv'
output_file = 'namesonly.txt'

reader = csv.reader(open(input_file,'rb'), delimiter=',')

for line in reader:
    if "new" in line:
        print line
</code></pre>
<p>With the code I have it prints just what I want:</p>
<pre><code>John, car, new
Jack, minivan, new
</code></pre>
<p>Now that I have just the customers that bought "new" vehicles, I want to then cut the 2 columns on the right, leaving just a list of names. I then want to save that list of just names to a .txt file. This is where I am getting stuck, I don't know how to proceed from here. </p>
</div>
<div class="post-text" itemprop="text">
<p>This is no problem. Look at the following. </p>
<pre><code>f = open('namesonly.txt', 'w')
...
for line in reader:
    if "new" in line[2]:
        #line = line.split(',') #&lt;- you don't need this line because you are reading the input as a delimitd string already
        f.write(line[0] + '\n') # write the first thing before the first comma (your names)
f.close()
</code></pre>
<p>This is untested, but something similar should work. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv

with open('example.csv') as infile, open('namesonly.txt', 'w') as outfile:
    for name, _prod, condition in csv.reader(infile):
        if condition.lower() == 'new':
            continue
        outfile.write(name)
        outfile.write('\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While all approaches given until now work, they are all naive, and will perform poorly on large CSV files. The also require you to "manually" work with CSV files, and create for loops.<br/>
When ever you see files CSV files you should think of the two options: <a href="https://docs.python.org/3/library/sqlite3.html?highlight=sqlite#module-sqlite3" rel="nofollow">SQLite</a> or Python <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html" rel="nofollow">Pandas</a>. </p>
<p>SQLite, and it's built into your Python already. It uses SQL, so you need to learn some SQL ...
Pandas, uses a more Pythonic API to do the things you want to do, and it's not included (but it should not be complicated to install either...). </p>
<p>Here is how to what you wanted with Pandas:</p>
<pre><code>In [1]: import pandas as pd
In [2]: df = pd.read_csv('example.csv')
</code></pre>
<p>Get all the names (the first column):</p>
<pre><code>In [3]: df['name']
Out[3]: 
0    John
1     Jim
2    Jack
3    Jane
4    Jeff
Name: name, dtype: object
</code></pre>
<p>Find all new products:</p>
<pre><code>In [18]: df[df[' type'] == ' new']
Out[18]: 
   name   product  type
0  John       car   new
2  Jack   minivan   new
</code></pre>
<p>You can assign the result, and then save it to a csv file. </p>
<pre><code>In [19]: res = df[df[' type'] == ' used']

In [20]: res.to
res.to_clipboard  res.to_dict       res.to_hdf        res.to_latex      res.to_period     res.to_sparse     res.to_string     
res.to_csv        res.to_excel      res.to_html       res.to_msgpack    res.to_pickle     res.to_sql        res.to_timestamp  
res.to_dense      res.to_gbq        res.to_json       res.to_panel      res.to_records    res.to_stata      res.to_wide       

In [20]: res.to_c
res.to_clipboard  res.to_csv            
In [20]: res.to_csv('new_products.csv')
</code></pre>
<p>Also note that Pandas can handle CSV files very efficiently since it is written in C.</p>
<h3>About loading CSV with pandas</h3>
<p>The CSV reader has tons of options. Check them out! I loaded the file naively and hence the space in the column name. If you think it's ugly, I would agree. You can pass the following keyword to fix the situation:</p>
<pre><code>df = pd.read_csv('example.csv', delim_whitespace=True)
</code></pre>
<h3>To show how simple pandas is</h3>
<p>If you really want the names of those who have <code>new</code> products, as in the answer of Padraic Cunningham, you can simply concatenate methods:</p>
<pre><code>In [46]:  df[df['type'] == 'new'].name
Out[46]: 
0    John
2    Jack
Name: name, dtype: object

In [47]:  df[df['type'] == 'new'].name.to_csv('out.csv')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just unpack using a generator expression and keep the name when the type row entry is equal to new:</p>
<pre><code>import csv
with open("in.csv") as f, open("out.csv","w") as out:
    wr = csv.writer(out)
    wr.writerows((name,) for name, _, tpe in csv.reader(f) if tpe == "new")
</code></pre>
<p><code>in.csv</code>:</p>
<pre><code>name,product,type
John,car,new
Jim,truck,used
Jack,minivan,new
Jane,SUV,used
Jeff,car,used
</code></pre>
<p><code>out.csv</code>:</p>
<pre><code>John
Jack
</code></pre>
</div>
<span class="comment-copy">Do you know how to save a file in Python?</span>
<span class="comment-copy">we don't need  the split because the output from for is a list and you could use <code>with open context manager</code></span>
<span class="comment-copy">This will fail if someone is named <code>newton</code></span>
<span class="comment-copy">@inspectorG4dget is right. I corrected my solution to check only the third index in <code>line</code> for text <code>'new'</code>.</span>
<span class="comment-copy">This will fail if there is a car condition called "like-new", or any other string that contains (but is not exactly) <code>new</code></span>
<span class="comment-copy">@inspectorG4dget, I think that's up to OP to fine tune.</span>
<span class="comment-copy">I like pandas, just got it installed and running. With this code you have put, do I just copy and paste and it should run? Or are there gaps for me to fill in? You mention scaling, that is important to me as to start I will probably be handling CSVs with around 2-5k rows. And eventually growing larger than that. At what point does Pandas really excel over the others from a scale perspective? Might be hard to give a hard number, but at least a ball park?</span>
<span class="comment-copy">I think pandas only real overhead is that it requires you to learn some new syntax. Besides that it can be extremely fast for large files. A normal person can't tell the difference between 10 ms and a 100, so for small files (less than 500 lines) you won't see a difference. For all other cases, you should use pandas.</span>
