<div class="post-text" itemprop="text">
<p>The following is the code that tries to modify the input supplied by a user by using sockets:</p>
<pre><code>from socket import *

serverName = '127.0.0.1'
serverPort = 12000
clientSocket = socket(AF_INET, SOCK_DGRAM)
message = input('Input lowercase sentence:')
clientSocket.sendto(message,(serverName, serverPort))
modifiedMessage, serverAddress = clientSocket.recvfrom(2048)
print (modifiedMessage)
clientSocket.close()
</code></pre>
<p>When I execute it and supply input the following error occurs:</p>
<pre><code>Input lowercase sentence:fdsgfdf
Traceback (most recent call last):
  File "C:\srinath files\NETWORKS\UDPclient.py", line 6, in &lt;module&gt;
    clientSocket.sendto(message,(serverName, serverPort))
TypeError: a bytes-like object is required, not 'str'
</code></pre>
<p>What can I do to solve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This code is probably good for Python 2. But in Python 3, this will cause an issue, something related to bit encoding. I was trying to make a simple TCP server and encountered the same problem. Encoding worked for me. Try this with <code>sendto</code> command.</p>
<pre><code>clientSocket.sendto(message.encode(),(serverName, serverPort))
</code></pre>
<p>Similarly you would use <code>.decode()</code> to receive the data on the UDP server side, if you want to print it exactly as it was sent.</p>
</div>
<div class="post-text" itemprop="text">
<p>encoding and decoding can solve this in python 3:</p>
<p>Client Side:</p>
<pre><code>&gt;&gt;&gt; host='127.0.0.1'
&gt;&gt;&gt; port=1337
&gt;&gt;&gt; import socket
&gt;&gt;&gt; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
&gt;&gt;&gt; s.connect((host,port))
&gt;&gt;&gt; st='connection done'
&gt;&gt;&gt; byt=st.encode()
&gt;&gt;&gt; s.send(byt)
15
&gt;&gt;&gt;
</code></pre>
<p>Server Side:</p>
<pre><code>&gt;&gt;&gt; host=''
&gt;&gt;&gt; port=1337
&gt;&gt;&gt; import socket
&gt;&gt;&gt; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
&gt;&gt;&gt; s.bind((host,port))
&gt;&gt;&gt; s.listen(1)
&gt;&gt;&gt; conn ,addr=s.accept()
&gt;&gt;&gt; data=conn.recv(2000)
&gt;&gt;&gt; data.decode()
'connection done'
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A bit of encoding can solve this:</p>
<p>Client Side:</p>
<pre><code>message = input("-&gt;")
clientSocket.sendto(message.encode('utf-8'), (address, port))
</code></pre>
<p>Server Side:</p>
<pre><code>data = s.recv(1024)
modifiedMessage, serverAddress = clientSocket.recvfrom(message.decode('utf-8'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simply replace message parameter passed  in <code>clientSocket.sendto(message,(serverName, serverPort))</code> to <code>clientSocket.sendto(message.encode(),(serverName, serverPort))</code>. Then you would successfully run in in <em>python3</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you encounter an error with this message <em>use <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow noreferrer"><code>my_string.encode()</code></a></em>.</p>
<p><sup><sup>(where <code>my_string</code> is the string you're passing to a function/method).</sup></sup></p>
<p>The <code>encode</code> method of <code>str</code> objects returns the encoded version of the string as a <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow noreferrer"><code>bytes</code> object</a> which you can then use. 
In this specific instance, socket methods <a href="https://docs.python.org/3/library/socket.html#socket.socket.send" rel="nofollow noreferrer">such as <code>.send</code></a> <em>expect a bytes object</em> as the data to be sent, <em>not a string object</em>.</p>
<p>Since you have an object of type <code>str</code> and you're passing it to a function/method that expects an object of type <code>bytes</code>, an error is raised  that clearly explains that:</p>
<pre><code>TypeError: a bytes-like object is required, not 'str'
</code></pre>
<p>So the <code>encode</code> method of strings is needed, applied on a <code>str</code> value and returning a <code>bytes</code> value:</p>
<pre><code>&gt;&gt;&gt; s = "Hello world"
&gt;&gt;&gt; print(type(s))
&lt;class 'str'&gt;
&gt;&gt;&gt; byte_s = s.encode()
&gt;&gt;&gt; print(type(byte_s))
&lt;class 'bytes'&gt;
&gt;&gt;&gt; print(byte_s)
b"Hello world"
</code></pre>
<p>Here the prefix <code>b</code> in <code>b'Hello world'</code> denotes that this is indeed a bytes object. You can then pass it to whatever function is expecting it in order for it to run smoothly.</p>
</div>
<span class="comment-copy">The first argument (<code>message</code>) needs to be bytes, but you're passing a string.  You should encode it before sending e.g. <code>message.encode('utf-8')</code></span>
<span class="comment-copy">but the thing is i need to pass string to the server not byte</span>
<span class="comment-copy">from socket import * serverName = 'hostname' serverPort = 12000 clientSocket = socket(AF_INET, SOCK_DGRAM) message = input('Input lowercase sentence:') message.encode('utf-8') clientSocket.sendto(message,(serverName, serverPort)) modifiedMessage, serverAddress = clientSocket.recvfrom(2048) print (modifiedMessage) clientSocket.close()</span>
<span class="comment-copy">The thing that goes on the wire is <i>always</i> bytes.  The server needs to be able to make sense of those bytes somehow.</span>
<span class="comment-copy">That's because <code>message</code> is still a string.  You need something like <code>clientSocket.sendto(message.encode('utf-8'), ...)</code></span>
<span class="comment-copy">would encoding and decoding on both sides of the connection increase latency? If so would python2 actually be faster at sending data than python3</span>
<span class="comment-copy">In my opinion, this will not affect the performance such as latency etc. However, I haven't tried experimented with it myself so I can't be sure about that.</span>
<span class="comment-copy">Your client won't work: sendto requires 3 parameters, the message the server address and the related port</span>
<span class="comment-copy">@dlewin You are right, good catch. I updated it</span>
