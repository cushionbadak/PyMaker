<div class="post-text" itemprop="text">
<pre><code>['a', 'c','a','b','b'] -&gt; ['a', 'c', 'b']
</code></pre>
<p>Searching online didn't help.  I'm not sure whether this is even possible.</p>
<p>Preferably write solution in Python, but anything is fine.</p>
<p>=====</p>
<p><strong>Edit</strong>: I originally said O(1) space, but I don't think it's possible.</p>
<p>Changing the requirements:</p>
<p>No space requirements, but you must modify the input in-place and return it.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this? I think the time complexity and the space complexity are both <code>O(n)</code>.</p>
<pre><code>def unique(arr):
    index = 0
    s = set()
    for i in range(len(arr)):
        if arr[i] not in s:
            arr[index] = arr[i]
            index += 1
            s.add(arr[i])
    arr[index:] = []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think this is possible in O(n) time <em>and</em> O(1) space.  To get O(n) time you have to have a scratchpad (with O(1) insert and lookup, e.g. a <a href="https://docs.python.org/3.4/library/stdtypes.html#set-types-set-frozenset" rel="nofollow"><code>set</code></a>) recording all the elements you've already seen; that requires O(m) space (where m is the number of unique elements).  Conversely, to get O(1) space you have to rescan earlier elements in the array for each element, which is O(n<sup>2</sup>) time.</p>
<p>If you'll accept an O(m) scratchpad, this fulfills the "modify the array in place" requirement and runs in O(n) time.</p>
<pre><code>def remove_duplicates(arr):
    """Remove all duplicated elements from ARR in O(m) space and O(n) time.
       ARR is modified in place and is not returned (like `sort`)."""
    n = len(arr)
    if n &lt;= 1: return
    seen = set((arr[0],))
    i = 1
    j = 1
    while i &lt; n:
        if arr[i] not in seen:
           seen.add(arr[i])
           arr[j] = arr[i]
           j += 1
        i += 1
    del arr[j:i]
</code></pre>
<p>This would still be O(n<sup>2</sup>) time if I deleted elements from the array as I iterated over it, because <code>del arr[i]</code> is itself an O(n) operation: it has to slide everything after <code>i</code> down one.  <code>del arr[j:i]</code> where <code>i</code> is past the end of the array <em>should</em> be O(1), but if it really matters, you'd have to <a href="https://hg.python.org/cpython/file/ee8e9edb8aae/Objects/listobject.c#l572" rel="nofollow">check the implementation</a>.</p>
<p>And if you must have O(1) space, here's the O(n<sup>2</sup>) time algorithm:</p>
<pre><code>def remove_duplicates_quadratic(arr):
    """Remove all duplicated elements from ARR in O(1) space and O(n²) time.
       ARR is modified in place and is not returned (like `sort`)."""
    n = len(arr)
    i = 0
    while i &lt; n:
       for j in range(i):
           if arr[j] == arr[i]:
               del arr[i]
               n -= 1
               break
       else:
           i += 1
</code></pre>
<p>I'm doing manual array indexing in these because deleting elements from an array you're iterating over using any of the usual for..in constructs is unsafe.  You could use a for..in loop in the first one, but you'd lose <a href="https://en.wikipedia.org/wiki/Parallelism_%28grammar%29" rel="nofollow">parallel structure</a> so it would be less readable.</p>
<p>In case you haven't seen it before, <a href="https://docs.python.org/3/reference/compound_stmts.html#the-while-statement" rel="nofollow">an <code>else</code> clause on a loop</a> is executed only if the loop is <em>not</em> exited via <code>break</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import OrderedDict

OrderedDict.fromkeys(my_array).keys()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>pip install oset

import oset

ll = oset.oset(['a', 'c','a','b','b'])

print(ll)

OrderedSet(['a', 'c', 'b'])`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To keep the speed efficient, you need to use O(n) space to record records that already exist. If there are a large amount of duplicates it won't take much space. However, the del operation on a standard array is O(n) because it has to shift all the following elements.</p>
<pre><code>def uniquify(data):
    used = set()
    i = 0
    while i &lt; len(data):
        if data[i] in used:
            del data[i] # or data.pop(i)
        else:
            used.add(data[i])
            i += 1
    return data # not strictly necessary because array is modified in-place
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>O(n) time, O(n) space</strong></p>
<pre><code>uniqueList = []
index = 0
while index &lt; len(myList):
    item = myList[index]
    if item not in uniqueList: uniqueList.append(item)
    else: myList.pop(index)
    index += 1
</code></pre>
<p>Note: Do not modify a list you are iterating through like below:</p>
<pre><code>for index, item in enumerate(myListCopy):
    if item not in uniqueList: uniqueList.append(item)
    else: myList.pop(index)
</code></pre>
<p><strong>O(n^2) time, O(1) space</strong>
It certainly is bounded by n^2, but in reality it's less.</p>
<pre><code>index = 0
while index &lt; len(myList):
    subIndex = index + 1
    while subIndex &lt; len(myList):
        if myList[subIndex] == myList[index]: myList.pop(subIndex)
        subIndex += 1
    index += 1
</code></pre>
<p><strong>O(n) time, O(1) space</strong>
If your list is sorted and you don't mind removing the first duplicates.</p>
<pre><code>for item in myList:
    if myList.count(item) &gt; 1: myList.remove(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst1= ['a', 'c','a','b','b'] #-&gt; ['a', 'c', 'b']
lst2 = []

for l in lst1:
   if l not in lst2:
       lst2.append(l)
 print lst2
</code></pre>
</div>
<span class="comment-copy">You're going to have to show us what you've tried.  Stackoverflow isn't just a function that you put your problem into and it spits out an answer.</span>
<span class="comment-copy">It's not possible. Doable with O(n) space.</span>
<span class="comment-copy">If the array/data is sorted I think it can be done. (Like the reduce step in a map reduce word count <a href="http://www.michael-noll.com/tutorials/writing-an-hadoop-mapreduce-program-in-python/" rel="nofollow noreferrer">michael-noll.com/tutorials/…</a>)</span>
<span class="comment-copy">@viper yeah a reduce or accumulate call would work with sorted.</span>
<span class="comment-copy">@AidanGomez: Links to related material are welcome, but this is clearly not a dup.</span>
<span class="comment-copy">Looks like this satisfies both the I/O and requirements.  Pretty simple as well.</span>
<span class="comment-copy">I had to look at this for quite a while to convince my self it works as intended .... that said +1 since it meets the O(1) space requirement ...</span>
<span class="comment-copy">I think so far this is actually the only solution that meets OP's requirements ..</span>
<span class="comment-copy">Looks good for O(1) space.  Sorry that I initially had allegedly impossible requirements of O(1) space and O(n) time.  I chose <a href="http://stackoverflow.com/a/33028026/1661745">Paul's answer</a> because his last line <code>arr[index:] = []</code> looks more succint and I think it's O(1) time, versus O(i - j) for your <code>del arr[j:i]</code>.  Anyways +1.</span>
<span class="comment-copy"><code>del arr[j:i]</code> <i>ought</i> to be O(1) in this case, but I haven't actually read through the code I linked to, to find out whether that's true.</span>
<span class="comment-copy">im pretty sure ordereddict maintains order ...</span>
<span class="comment-copy">I think it does maintain order but O(n) space.</span>
<span class="comment-copy">oh I see now I guess</span>
<span class="comment-copy">@JoranBeasley: O(1) space is doable with an in-place algorithm. Kills the time requirement though...</span>
<span class="comment-copy"><code>oset</code> is not in the standard library, please give a link to PyPI or wherever.</span>
<span class="comment-copy"><code>del</code> is O(n) operation, so your algorithm is O(n^2) total.</span>
<span class="comment-copy">Too bad Python doesn't have a built in linked list (that I can find), but the function relies on the input anyway so that is already outside of its control.</span>
<span class="comment-copy">Never mind, a linked list would mess up the indexing speed.</span>
