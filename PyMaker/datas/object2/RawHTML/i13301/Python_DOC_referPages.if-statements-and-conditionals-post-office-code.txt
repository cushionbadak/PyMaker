<div class="post-text" itemprop="text">
<p>I want to write a code in Python that asks the user for the weight of a package and then how much it will cost to send it given we have the costs. </p>
<hr/>
<p>weight in kg:                             price per kg</p>
<p>up to 2 kg:                                30</p>
<p>from 2 kg up to 6 kg:                        28</p>
<p>from 6 kg up to 12 kg:                       25</p>
<p>from 12 kg and up:                           23</p>
<hr/>
<p>This is what I have written:</p>
<pre><code>vikt = float(input("Weight of package?:  "))

if vikt = 0:
    print("Please insert a weight")
elif vikt &lt; 2:
    print("The cost is", vikt*30, "kronor")
elif vikt &gt;= 2:
    print("The cost is", vikt*28, "kronor")
elif vikt &gt;= 6:
    print("The cost is", vikt*25, "kronor")
elif vikt &gt;= 12:
    print("The cost is", vikt*23, "kronor")
</code></pre>
<p>(vikt is the weight and kronor is the currency)</p>
<p>for some input weights this works fine but when I write e.g. 7.15 kg which should cost 178.75 I instead get 200.20000000000002. Which is incorrect and second is there any easy way to not make it display the cost with that many decimals? But perhaps if we make it display the correct cost we wont even have that issue. </p>
<p>Thankful for any help I may get! </p>
</div>
<div class="post-text" itemprop="text">
<p>I think it would be better to use function to retrieve cost of one weight unit:</p>
<pre><code>def get_price(weight):
   if weight &lt; 2:
       return 30
   elif 2 &lt;= weight &lt; 6:
       return 28
   elif 6 &lt;= weight &lt; 12:
       return 25
   else:
       return 23


vikt = float(input("Weight of package?:  "))
if vikt = 0:
    print("Please insert a weight")
else:
    print("The cost is", vikt*get_price(vikt), "kronor")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Eugene, thank you! I did it like this: </p>
<p>vikt = float(input("Weight of package?: ")) </p>
<pre><code>if vikt == 0: print("Please insert a weight") 

elif vikt &lt; 2: print("The cost is", vikt*30, "kronor")

elif 2 &lt;= vikt &lt;6: print("The cost is", vikt*28, "kronor") 

elif 6 &lt;= vikt &lt; 12: print("The cost is", vikt*25, "kronor") 

elif vikt &gt;= 12: print("The cost is", vikt*23, "kronor") 
</code></pre>
<p>And it seems to be working</p>
</div>
<div class="post-text" itemprop="text">
<p>Try evaluating your highest weight first:</p>
<pre><code>vikt = float(input("Weight of package?:  "))

if vikt &gt;= 12:
    print("The cost is", vikt*23, "kronor")
elif vikt &gt;= 6:
    print("The cost is", vikt*25, "kronor")
elif vikt &gt;= 2:
    print("The cost is", vikt*28, "kronor")
elif vikt &gt; 0:
    print("The cost is", vikt*30, "kronor")
else:
    print("Please insert a weight")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As with fairly much everything, Python actually has a standard library module that does this kind of thing for you quite easily. It's called <a href="https://docs.python.org/3.5/library/bisect.html" rel="nofollow"><code>bisect</code></a>, and one of the things it can do is a table lookup. To use it, you put your cutoffs into a list, and the associated multipliers into another list in the same order like this:</p>
<pre><code>weights = [2, 6, 12]
unit_prices = [30, 38, 25, 23]
</code></pre>
<p>Then finding the right multiplier given an arbitrary weight is one function call:</p>
<pre><code>from bisect import bisect
weight = float(input("Weight of package?: "))
total = weight * unit_prices[bisect(unit_prices, weight)]
print("The cost is", total, "kronor")
</code></pre>
<p>You will still need to special-case invalid inputs, but all the branches of your <code>if</code> that lead to calculating a total cost are consolidated into one.</p>
</div>
<div class="post-text" itemprop="text">
<p>To make it more pythonic, get rid of the multiple tests, insert the parameters in tuples and use a generator expression</p>
<pre><code>weights = (2, 6, 12)
vals = (30, 28, 25)

while True:
    vikt = float(input("Weight of package?:  "))
    if vikt &gt; 0.0:
        break

k = next((v for w,v in zip(weights, vals) if w &gt; vikt), 23)
print(round(k*vikt, 2))
</code></pre>
<p>produces the desired output.</p>
<p>Examples:</p>
<pre><code>vikt = 0.5
k = 30
k * vikt = 15.0

vikt = 7.15
k = 25
k * vikt = 178.75

vikt = 14.2
k = 23
k * vikt = 326.6
</code></pre>
<p><strong>EDIT:</strong>
as suggested by @lvc, using <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_right" rel="nofollow">bisect</a> would be even better</p>
<pre><code>import bisect

weights = (2, 6, 12)
vals = (30, 28, 25, 23)

while True:
    vikt = float(input("Weight of package?:  "))
    if vikt &gt; 0.0:
        break

k = vals[bisect.bisect(weights, vikt)]
print(round(k*vikt, 2))
</code></pre>
</div>
<span class="comment-copy">You may want to start with your highest weight and work down.</span>
<span class="comment-copy">Thanks Pynchia for editing it to look better, and jchamp, what exactly do you mean? what difference would that make? (I'm not saying that angrily)</span>
<span class="comment-copy"><code>elif vikt &gt;= 2:</code> wins and the other tests are ignored</span>
<span class="comment-copy">I want it to be like 2&lt;vikt&lt;6 but I don't know if there is any way to do that in Python</span>
<span class="comment-copy">With your current scheme, it you have a package that weighs 12 kg, it would get the price of a package that weighs between 2 and 6 kg.</span>
<span class="comment-copy">Doing this as a table lookup is nice, but that generator expression.. isn't. Use the stdlib <a href="https://docs.python.org/3.5/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> module instead.</span>
<span class="comment-copy">@lvc done, thank you</span>
