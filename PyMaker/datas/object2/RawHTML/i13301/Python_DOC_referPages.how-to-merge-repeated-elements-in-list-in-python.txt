<div class="post-text" itemprop="text">
<p>I have a list of coordinate like:</p>
<pre><code>list_coordinate =[(9,0),(9,1),(9,3) ... (53,0),(53,1),(53,3)...(54,0),(54,1)..]

value = []

 for m in range(0,len(list_coordinate)):    
    if m != len(list_coordinate)-1:
        if list_coordinate[m][0]==list_coordinate[m+1][0]:
            value.append(list_coordinate[m][0])`
</code></pre>
<p>Output of this code:</p>
<pre><code>value = [9,9 ,9,...,53,53,53,...,54,54,54,54...]
</code></pre>
<p>I want to merge this value list for similar element and want output as:</p>
<p><strong>Expected output:</strong></p>
<pre><code> [9,53,54]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you prefer one-liners, you can do it like this:</p>
<pre><code>list(set(map(lambda x: x[0], list_coordinate)))
</code></pre>
<p>It will output:</p>
<pre><code>[9, 53, 54]
</code></pre>
<p>Note: As set is being used in the code, ordering of the elements is not guaranteed here. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use an <code>OrderedDict</code> for both of your cases. Firstly for just the <code>x</code> coordinates:</p>
<pre><code>list_coords = [(9, 0), (9, 1), (9, 3), (53, 0), (53, 1), (53, 3), (54, 0), (54, 1)]
merged = OrderedDict()

for coord in list_coords:
    merged[coord[0]] = 1

print merged.keys()
</code></pre>
<p>Giving:</p>
<pre><code>[9, 53, 54]
</code></pre>
<p>Note, if for example <code>(9, 0)</code> was repeated later on, it would not change the output.</p>
<p>Secondly, for whole coordinates. Note, the data has <code>(10 ,0)</code> repeated 3 times:</p>
<pre><code>list_coords = [(9, 0), (9, 1), (9, 3), (10, 0), (10, 0), (10, 0), (53, 0), (53, 1), (53, 3), (54, 0), (54, 1)]
merged = OrderedDict()

for coord in list_coords:
    merged[coord] = 1

print merged.keys()
</code></pre>
<p>Giving:</p>
<pre><code>[(9, 0), (9, 1), (9, 3), (10, 0), (53, 0), (53, 1), (53, 3), (54, 0), (54, 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use <code>itertools.groupby</code></p>
<pre><code>from itertools import groupby
value = [9,9 ,9,53,53,53,54,54,54,54]
g = [k for k,_ in groupby(value)]
print(g)
</code></pre>
<p>which produces</p>
<pre><code>[9, 53, 54]
</code></pre>
<p>and it is guaranteed to be in the same order as the input list (if it matters).</p>
<p>Basically</p>
<pre><code>groupby(iterable[, keyfunc])
</code></pre>
<p>groups the elements in the iterable, passing to a new group when the key function changes.</p>
<p>If the key function is omitted, the identity function is assumed, and the key for the group will be each element encountered.</p>
<p>So as long as the elements in <code>value</code> stay the same, they will be grouped under the same key, which is the element itself.</p>
<p>Note: this works for contiguous repetitions only. In case you wanted to get rid of re-occurring duplicates, you should sort the list first (as groupby <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">docs</a> explains)</p>
<p>As per your comment below, in case you wanted to operate on the coordinates directly</p>
<pre><code>list_coordinate = [(9,0), (9,1), (9,3), (53,0), (53,1), (53,3), (54,0), (54,1)]
g = [k for k,_ in groupby(list_coordinate, lambda x: x[0])]
print(g)
</code></pre>
<p>produces the same output</p>
<pre><code>[9, 53, 54]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you use a set:</p>
<pre><code>{ k[0] for k in list_coordinate }
</code></pre>
</div>
<span class="comment-copy">why not set(value) but it does not give output in the input order</span>
<span class="comment-copy">Thank you salman!</span>
<span class="comment-copy">You should note this does not gurantee any order in the elements.</span>
<span class="comment-copy">I learnt the use of OrderedDict() with your method. Thanks. Basically the Y-coordinates of the lists are redundant. I want to just group x-coordinate and take average of x-coordinates which are in the specific range.</span>
<span class="comment-copy">Thanks a lot @Pynchia! I did come across the groupby but could not able to figure out how to use it. So can i do the same for the list_coordinate as well without extracting the first elements?</span>
<span class="comment-copy">what output would you like for the <code>list_coordinate</code>?</span>
<span class="comment-copy">@Pynchia That groupby in the comments is wrong, the argument to the <code>keyfunc</code> would be a single <code>tuple</code> , not two elements. You would need either of these for the lambda - <code>lambda (x,y):x</code> (Note this only works in Python 2.x)  - or - <code>lambda x: x[0]</code> .</span>
<span class="comment-copy">@AnandSKumar absolutely right you are, thank you. Will remove and re-post the comment. I had done it as<code>'x[0]</code> initially, then changed it! how wrong</span>
<span class="comment-copy">@user3118718 if <code>list_coordinate=[(9,0),(9,1),(9,3),(53,0),(53,1),(53,3),(54,0),(54,1)]</code> then <code>g=[k for k,_ in groupby(list_coordinate, lambda x: x[0])]</code> produces the same output <code>[9, 53, 54]</code></span>
