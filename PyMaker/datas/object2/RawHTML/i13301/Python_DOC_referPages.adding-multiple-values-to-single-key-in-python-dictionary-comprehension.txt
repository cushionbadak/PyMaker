<div class="post-text" itemprop="text">
<p>I wanted to learn how to use dictionary comprehension and decided to use one for the previously solved task. I need to assign multiple values to the same key. I was wondering if there's a better way to achieve what I'm trying to do than with the code I've written so far.</p>
<pre><code>graph = {(x1,y1): [(c,d) for a,b,c,d in data if a == x1 and b == y1] for x1 ,y1, x2, y2 in data}
</code></pre>
<p>For example I have this:</p>
<pre><code>data = {(1,2,1,5),(1,2,7,2),(1,5,4,7),(4,7,7,5)}
</code></pre>
<p>The first two values should create a key and the remaining two should be added as a value of a key.
With the given example I would like to return:</p>
<pre><code>{(1, 2): [(1, 5), (7, 2)], (1, 5): [(4, 7)], (4, 7): [(7, 5)]}
</code></pre>
<p>Is there an easier way to do it than iterate through the entire data just to find the matching values?</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, your dict comprehension is not an efficient way to do this.  It contains not one but <em>two</em> for loops over the same data set, unnecessarily.</p>
<p>It's more pythonic to just use a simple for loop here:</p>
<pre><code>from collections import defaultdict

data = {(1,2,1,5),(1,2,7,2),(1,5,4,7),(4,7,7,5)}
output = defaultdict(list)

for a, b, c, d in data:
    output[a, b].append((c, d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is neat but the time complexity is O(n^2), which can be reduced to O(n).</p>
<pre><code>data = {(1,2,1,5),(1,2,7,2),(1,5,4,7),(4,7,7,5)}
result = dict()
for item in data:
    key = (item[0],item[1])
    value = result.setdefault(key,[])
    value.append((item[2],item[3]))
    result[key] = value
print result
</code></pre>
<p>In my opinion, using a for loop can make codes more comprehensive</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't know if it is the best answer but I would do something like that :</p>
<pre><code>m_dict = {}
for val in data:
    key = (val[0],val[1])
    if key in m_dict:
        m_dict[key].append((val[2],val[3]))
    else:
        m_dict[key] = [(val[2],val[3])]
</code></pre>
<p>Or more concisely using <code>setdefault</code>:</p>
<pre><code>m_dict = {}
for val in data:
    key = (val[0],val[1])
    obj = m_dict.setdefault(key,[])
    obj.append((val[2],val[3]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this instance, I would use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>. For your example:</p>
<pre><code>dict(groupby(data, lambda t: (t[0], t[1])))
</code></pre>
<p>This will produce a dict with the keys equal to <code>(1, 2), (1, 5), and (4, 7)</code> and the values consisting of <code>(1, 2, 1, 5), (1, 2, 7, 2)...</code> which should be sufficient for most uses. You can also post-process the grouped list, if need be.</p>
<hr/>
<p>As noted in the comments below, <code>groupby</code> requires sorted data. As such, you will need to sort before grouping and will probably want to cast the iterator to a list:</p>
<pre><code>first_two = lambda tup: (tup[0], tup[1])
groups = groupby(sorted(data, key=first_two), first_two)
target = {k: list(g) for k, g in groups}
</code></pre>
</div>
<span class="comment-copy">instead doing all this you could use setdefault method of the dictionary</span>
<span class="comment-copy">@Vignesh Kalai thx</span>
<span class="comment-copy">this can be even more simplified remove all the things in for loop and write  <code>result.setdefault((item[0],item[1]),[]).append((item[2],item[3]))</code></span>
<span class="comment-copy">This is what I had before :) It does its job much better than the two loops I've in the above example, thanks for the answer! :)</span>
<span class="comment-copy">groupby requires sorted data</span>
<span class="comment-copy">the output return an iterator <code>{(1, 2): &lt;itertools._grouper at 0x747b430&gt;, </code> not a list</span>
<span class="comment-copy">Both of those are true. However, it solves the problem. I will amend my answer.</span>
