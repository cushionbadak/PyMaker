<div class="post-text" itemprop="text">
<p>I haven't been able to find any examples of return values from the <code>yield from</code> <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow">expression</a>. I have tried this simple code, without success:</p>
<pre><code>def return4():
    return 4


def yield_from():
    res = yield from range(4)
    res = yield from return4()


def test_yield_from():
    for x in yield_from():
        print(x)


test_yield_from()
</code></pre>
<p>Which produces:</p>
<pre><code>» python test.py 
0
1
2
3
Traceback (most recent call last):
  File "test.py", line 52, in &lt;module&gt;
    test_yield_from()
  File "test.py", line 48, in test_yield_from
    for x in yield_from():
  File "test.py", line 44, in yield_from
    res = yield from return4()
TypeError: 'int' object is not iterable
</code></pre>
<p>But I was expecting:</p>
<pre><code>» python test.py 
0
1
2
3
4
</code></pre>
<p>Because, as stated in the PEP:</p>
<blockquote>
<p>Furthermore, when the iterator is another generator, the subgenerator is allowed to execute a return statement with a value, and that value becomes the value of the yield from expression.</p>
</blockquote>
<p>Obviously, I am not getting this explanation. How does a <code>return</code> in a "subgenerator" work with regards to <code>yield from</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Generators can return a value when they are exhausted:</p>
<pre><code>def my_gen():
    yield 0
    return "done"

g = my_gen()
next(g)
next(g) # raises StopIteration: "done"
</code></pre>
<p>The returned value in a <code>yield from</code> statement will be this value. eg.</p>
<pre><code>def yield_from():
    res = yield from my_gen()
    assert res == "done"
</code></pre>
<p>By default this value is <code>None</code>. That is <code>res = yield from range(4)</code> will set <code>res</code> as <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>yield from generator</code> is short for </p>
<pre><code>for i in generator:
    yield i
</code></pre>
<p>well it's a bit more commplicated than that: <a href="https://www.python.org/dev/peps/pep-0380/#formal-semantics" rel="nofollow">https://www.python.org/dev/peps/pep-0380/#formal-semantics</a> .</p>
<p>this will not work well if <code>generator = 4</code>. (your <code>return4()</code> is not a <em>generator</em>. it's a <em>function</em>.)</p>
<p>in order to get what you wand you would just do this:</p>
<pre><code>def yield_from():
    yield from range(4)
    yield 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm posting a working example for your tests. </p>
<p>return4 function is now a generator. To achieve that, a yield must be present anywhere in the function (there is a new related feature in Python 3.5, but that's not important now).</p>
<p>As you quoted already:</p>
<blockquote>
<p>Furthermore, when the iterator is another generator, the subgenerator
  is allowed to execute a return statement with a value, and that value
  becomes the value of the yield from expression</p>
</blockquote>
<p>Summary: you will get a value. You could print it, for example:</p>
<pre><code>def yield_from():
    # ...
    val = yield from return4()
    print("value:", val)  # prints value: 4
</code></pre>
<p>But you want to yield it, not print. Here is the complete code:</p>
<pre><code>def return4():
    if False:
        yield None
    return 4

def yield_from():
    yield from range(4)
    yield (yield from return4())

def test_yield_from():
    for x in yield_from():
        print(x)

test_yield_from()
# prints numbers 0 to 4
</code></pre>
<p>You are probably asking yourself, what is it good for. There is almost no advantage when you are only receivng values from a generator. But <code>yield from</code> is a great feature when you are sending values to a generator. Try to find a good explanation of python coroutines. It's amazing.</p>
</div>
<span class="comment-copy">Did you really expect <code>yield from 4</code> to work?</span>
<span class="comment-copy">I don't know. I am trying it out because I haven't found any examples. That's  why I am asking here, obviously.</span>
<span class="comment-copy">ok, that seems more clear. What is the use case for this? Would I use this to refactor a normal function into a subgenerator, for example?</span>
<span class="comment-copy">Subgenerators and returning from a generator are used heavily in python's coroutine library. -- <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-task.html</a> . Here generators are used to create cooperative multithreading, rather to yield values.</span>
<span class="comment-copy">Sure. So, what do return statements in a subgenerator do? What is the meaning of: "the subgenerator is allowed to execute a return statement with a value, and that value becomes the value of the yield from expression"</span>
<span class="comment-copy">you call your function: <code>return4()</code>. at the point where <code>yield from</code> is executed this has already evalutated to <code>4</code>.</span>
<span class="comment-copy">@jeckyll2hide if you had <code>def range4(): return range(4)</code> you could then use <code>yield from range4()</code> even though <code>range4</code> is not a generator.</span>
<span class="comment-copy">@Trengot ...that probably answers the question better than  my attempt.</span>
<span class="comment-copy">@Trengot: no, this is not what I am (and the PEP) talking about. I am talking about returning <b>values</b> from the subgenerator, not returning a generator.</span>
