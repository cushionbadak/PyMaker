<div class="post-text" itemprop="text">
<pre><code>list1 = [1,3,5,7,9,11,13,15,17]
list2 = []
</code></pre>
<p>I want to add the three first elements to <code>list2[0]</code> and the next three to <code>list2[1]</code> and so on.</p>
<pre><code>1+3+5 is list2[0]
7+9+11 is list2[1]
13+15+17 is list2[2]
</code></pre>
<p>the result should be:</p>
<pre><code>list2 = [9,27,45]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The documentation for the standard <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow">itertools</a> module has this recipe for dividing a list into fixed-length groups:</p>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p>As a beginner, you might not understand how this works, but I did this to confirm that it does:</p>
<pre><code>import itertools as it

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return it.zip_longest(*args, fillvalue=fillvalue)

list1 = [1,3,5,7,9,11,13,15,17]
print(list(grouper(list1, 3)))
</code></pre>
<p>prints: <code>[(1, 3, 5), (7, 9, 11), (13, 15, 17)]</code>. So you have tuples of each three items, now you just need to add them up, which is what the builtin <code>sum</code> is for:</p>
<pre><code>list2 = [sum(group) for group in grouper(list1, 3)]
</code></pre>
<p>If your list is a length that isn't divisible by 3, this will break with an error like this:</p>
<pre><code>TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'
</code></pre>
<p>Which can be fixed in one of two ways: if you want to ignore the odd elements, change <code>grouper</code> to call <code>zip</code> where it currently calls <code>it.zip_longest</code>; on the other hand, if you want a final element in <code>list2</code> that is the sum of the odd elements, use a fill value of 0 like this:</p>
<pre><code>list2 = [sum(group) for group in grouper(list1, 3, 0)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try with</p>
<pre><code>gr = [iter(list1)]*3
list2 = [sum(el) for el in zip(*gr)]
# or as an alternative
# list2 = list(map(sum, zip(*gr)))
print(list2)
</code></pre>
<p>which produces</p>
<pre><code>[9, 27, 45]
</code></pre>
<p>That works if the number of elements in the input list is a multiple of 3.</p>
<p>In case you want to make it work for other lengths as well do</p>
<pre><code>from itertools import zip_longest
list1 = [1,3,5,7,9,11,13,15,17, 1,2]
gr=[iter(list1)]*3
list2 = [sum(el) for el in zip_longest(*gr, fillvalue=0)]
# or as an alternative
# list2 = list(map(sum, zip_longest(*gr, fillvalue=0)))

print(list2)
</code></pre>
<p>which produces</p>
<pre><code>[9, 27, 45, 3]
</code></pre>
<p><strong>EDIT</strong>: another solution is to use <code>itertools.groupby</code></p>
<pre><code>from itertools import groupby
g = groupby(enumerate(list1), lambda p, _: p//3)
list2 = [sum(v for p,v in t) for i, t in g]
print(list2)
</code></pre>
<p>which works for lists of any length (multiple of three or not)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here are a couple of other ways. Note that (as in most of the answers already submitted) a partial group of less than 3 items will be ignored by my first 2 methods, but the last one will handle such partial groups.</p>
<pre><code>list1 = [1,3,5,7,9,11,13,15,17, 30, 40]
print list1

list2 = [sum(t) for t in zip(*[iter(list1)]*3)]
print list2

list2 = [i + j + k for i,j,k in zip(list1[0::3], list1[1::3], list1[2::3])]
print list2

list2 = []
s = 0
for i, v in enumerate(list1, 1):
    s += v
    if i % 3 == 0:
        list2.append(s)
        s = 0
if s:
    list2.append(s)    
print list2
</code></pre>
<p><strong>output</strong></p>
<pre><code>[1, 3, 5, 7, 9, 11, 13, 15, 17, 30, 40]
[9, 27, 45]
[9, 27, 45]
[9, 27, 45, 70]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All you need to do is add the elements from 3*i to 3*(i+1)
where i is will be the index of the new list2</p>
<pre><code>&gt;&gt;&gt; list1 = [1,3,5,7,9,11,13,15,17]
&gt;&gt;&gt; list2=[]
&gt;&gt;&gt; for i in range(len(list1)/3):
    ...     list2.append(sum(list1[i*3:(i+1)*3]))
&gt;&gt;&gt; list2
[9, 27, 45]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list1 = [1,3,5,7,9,11,13,15,17]
# split list1 into 3 sublists
list2 = [list1[i:i + 3] for i in range(0, len(list1), 3)]
# map sum to sublists in list2
list2 = list(map(sum,list2))
print(list2)
[9, 27, 45]
</code></pre>
</div>
<span class="comment-copy">this will help: <a href="http://stackoverflow.com/questions/14680273/finding-every-nth-element-in-a-list" title="finding every nth element in a list">stackoverflow.com/questions/14680273/â€¦</a></span>
<span class="comment-copy">@smoggers Actually OP wants <i>add every third element to list2</i> like <code>1 + 3 + 5</code> is <code>9</code>, and <code>7 + 9 + 11</code> is <code>27</code>, etc.</span>
<span class="comment-copy">your question is a good one, but it does not follow the guidelines on how it should be asked. SO is not a code-writing service. Please edit your question and add the code you have tried so far</span>
<span class="comment-copy">@Pynchia: Fair comment; OTOH, the OP <i>is</i> a beginner, and may have been totally baffled as to how to tackle this task. Note that all the answers so far are using module functions and various fancy tricks that a raw beginner wouldn't even know exist. I was almost tempted to write a "raw" answer that just uses simple techniques, but it's <i>so</i> hard to go back to basics once you know the cool stuff. :) The closest I could come was with my code that uses <code>enumerate()</code>.</span>
<span class="comment-copy">There are <i>lots</i> of <a href="http://chat.stackoverflow.com/rooms?tab=all">SO Chat rooms</a>, but of course the Python one is the best. :)</span>
<span class="comment-copy">In case, please accept @Ivc's answer (upvoted). He beat me to it by a few mins. :)</span>
<span class="comment-copy">people are mean on this website, never coming back!  but thanks for the great answer tho :))</span>
<span class="comment-copy">PLEASE, accept lvc's anser instead. It would be fair. Otherwise I am going to delete my answer. PLEASE.</span>
<span class="comment-copy">i don't know why this matters but okay..</span>
<span class="comment-copy">Very cute. FWIW, it's a common convention to use <code>_</code> as the name for a <code>for</code> loop index that you don't access. Here's a minor variation on your latest solution. <code>g = groupby(enumerate(list1), lambda (x, _): x//3)</code> <code>list2 = [sum(zip(*t)[1]) for _, t in g]</code></span>
<span class="comment-copy">That works ok if the list length is divisible by 3, but you should use <code>//3</code> to guarantee integer division. Also, it's (in general) more efficient to use a step of 3 in the <code>range</code> (as in  LetzerWille's variation) rather than using those multiplications and divisions by 3.</span>
