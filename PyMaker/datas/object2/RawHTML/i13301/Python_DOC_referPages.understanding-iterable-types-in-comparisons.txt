<div class="post-text" itemprop="text">
<p>Recently I ran into cosmologicon's <a href="https://github.com/cosmologicon/pywat">pywats</a> and now try to understand part about fun with iterators:</p>
<pre><code>&gt;&gt;&gt; a = 2, 1, 3
&gt;&gt;&gt; sorted(a) == sorted(a)
True
&gt;&gt;&gt; reversed(a) == reversed(a)
False
</code></pre>
<p>Ok, <code>sorted(a)</code> returns a <code>list</code> and <code>sorted(a) == sorted(a)</code> becomes just a two lists comparision. But <code>reversed(a)</code> returns <code>reversed object</code>. So why these reversed objects are different? And id's comparision makes me even more confused:</p>
<pre><code>&gt;&gt;&gt; id(reversed(a)) == id(reversed(a))
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The basic reason why <code>id(reversed(a) == id(reversed(a)</code> returns <code>True</code> , whereas <code>reversed(a) == reversed(a)</code> returns <code>False</code> , can be seen from the below example using custom classes -</p>
<pre><code>&gt;&gt;&gt; class CA:
...     def __del__(self):
...             print('deleted', self)
...     def __init__(self):
...             print('inited', self)
...
&gt;&gt;&gt; CA() == CA()
inited &lt;__main__.CA object at 0x021B8050&gt;
inited &lt;__main__.CA object at 0x021B8110&gt;
deleted &lt;__main__.CA object at 0x021B8050&gt;
deleted &lt;__main__.CA object at 0x021B8110&gt;
False
&gt;&gt;&gt; id(CA()) == id(CA())
inited &lt;__main__.CA object at 0x021B80F0&gt;
deleted &lt;__main__.CA object at 0x021B80F0&gt;
inited &lt;__main__.CA object at 0x021B80F0&gt;
deleted &lt;__main__.CA object at 0x021B80F0&gt;
True
</code></pre>
<p>As you can see when you did <code>customobject == customobject</code> , the object that was created on the fly was not destroyed until after the comparison occurred, this is because that object was required for the comparison.</p>
<p>But in case of <code>id(co) == id(co)</code> , the custom object created was passed to <code>id()</code> function, and then only the result of <code>id</code> function is required for comparison , so the object that was created has no reference left, and hence the object was <em>garbage collected</em>, and then when the Python interpreter recreated a new object for the right side of <code>==</code> operation, it reused the space that was freed previously. Hence, the <code>id</code> for both came as same.</p>
<p>This above behavior is an implementation detail of CPython (it may/may not differ in other implementations of Python) . And you should never rely on the equality of <code>ids</code> . For example in the below case it gives the wrong result -</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; id(reversed(a)) == id(reversed(b))
True
</code></pre>
<p>The reason for this is again as explained above (garbage collection of the <code>reversed</code> object created for <code>reversed(a)</code> before creation of reversed object for <code>reversed(b)</code>).</p>
<hr/>
<p>If the lists are large, I think the most memory efficient and most probably the fastest method to compare equality for two iterators would be to use <a href="https://docs.python.org/2/library/functions.html#all" rel="noreferrer"><code>all()</code></a> built-in function along with <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip()</code></a> function for Python 3.x (or <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="noreferrer"><code>itertools.izip()</code></a> for Python 2.x).</p>
<p>Example for Python 3.x - </p>
<pre><code>all(x==y for x,y in zip(aiterator,biterator))
</code></pre>
<p>Example for Python 2.x -</p>
<pre><code>from itertools import izip
all(x==y for x,y in izip(aiterator,biterator))
</code></pre>
<p>This is because <code>all()</code> short circuits at the first False value is encounters, and `zip() in Python 3.x returns an iterator which yields out the corresponding elements from both the different iterators. This does not need to create a separate list in memory.</p>
<p>Demo -</p>
<pre><code>&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; all(x==y for x,y in zip(reversed(a),reversed(b)))
False
&gt;&gt;&gt; all(x==y for x,y in zip(reversed(a),reversed(a)))
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>sorted</code> returns a list, whereas <code>reversed</code> returns a <code>reversed</code> object and is a different object. If you were to cast the result of <code>reversed</code> to a list before comparison, they will be equal.</p>
<pre><code>In [8]: reversed(a)
Out[8]: &lt;reversed at 0x2c98d30&gt;

In [9]: reversed(a)
Out[9]: &lt;reversed at 0x2c989b0&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>reversed</code> returns an iterable that doesn't implement a specific <code>__eq__</code> operator and therefore is compared using identity.</p>
<p>The confusion about <code>id(reversed(a)) == id(reversed(a))</code> is because after evaluating the first <code>id(...)</code> call the iterable can be disposed (nothing references it) and the second iterable may be reallocated at the very same memory address when the second <code>id(...)</code> call is done. This is however just a coincidence.</p>
<p>Try</p>
<pre><code>ra1 = reversed(a)
ra2 = reversed(a)
</code></pre>
<p>and compare <code>id(ra1)</code> with <code>id(ra2)</code> and you will see they are different numbers (because in this case the iterable objects cannot be deallocated as they're referenced by <code>ra1</code>/<code>ra2</code> variables).</p>
</div>
<div class="post-text" itemprop="text">
<p>You may try <code>list(reversed(a)) ==list(reversed(a))</code>  will return <code>True</code></p>
<pre><code>list(reversed(a))
[3, 2, 1]
</code></pre>
<p>once try </p>
<pre><code>&gt;&gt;&gt; v = id(reversed(a))
&gt;&gt;&gt; n = id(reversed(a))
&gt;&gt;&gt; v == n
False
</code></pre>
<p>again </p>
<pre><code>&gt;&gt;&gt; v = id(reversed(a))
&gt;&gt;&gt; n = id(reversed(a))
&gt;&gt;&gt; n1 = id(reversed(a)) 
&gt;&gt;&gt; v == n1
True
</code></pre>
</div>
<span class="comment-copy">Iterators generally compare as False, because you can't know what you'll get from iterating over them until you do so.</span>
<span class="comment-copy">So comparison returns False because of reversed <code>__eq__</code> implementation?</span>
<span class="comment-copy"><code>sorted</code> returns a list.  A more fair comparison would be between <code>iter(a)</code> and <code>reversed(a)</code>.</span>
<span class="comment-copy">Comparing IDs this way is a classic mistake: <a href="http://stackoverflow.com/questions/3877230/why-does-id-id-and-id-id-in-cpython">Why does <code>id({}) == id({})</code> and <code>id([]) == id([])</code> in CPython?</a></span>
<span class="comment-copy">Alright! That explains why <code>x=reversed(a)</code> <code>y=reversed(a)</code> <code>id(x)==id(y)</code> gives <code>False</code>. Thank you.</span>
<span class="comment-copy">Now it definitely makes sense for me! So <code>reversed(a) == reversed(a)</code> is actually a comparison of two different objects!</span>
<span class="comment-copy">@valentjedi: note that the behavior for <code>id()</code> is CPython-specific. Don't rely on it if you want your code to be portable and compatible with future versions of CPython.</span>
<span class="comment-copy"><code>v == n1</code> ==&gt; <code>True</code> how? Your answer hardly explains anything.</span>
<span class="comment-copy">@AshwiniChaudhary try  <code>id(reversed(a))</code>  continuously for 5 to 10 times in python Shell. you will get some repeat of ID's</span>
<span class="comment-copy">That's because due to garbage collection of older objects CPython can re-use that memory space, if there are already reference(s) to an object then a new object will use some different ID.</span>
