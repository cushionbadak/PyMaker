<div class="post-text" itemprop="text">
<p>I have an arbitrarily deep set of nested dictionary:</p>
<pre><code>x = {'a': 1, 'b': {'c': 6, 'd': 7, 'g': {'h': 3, 'i': 9}}, 'e': {'f': 3}}
</code></pre>
<p>and I'd like to basically apply a function to all the integers in the dictionaries, so like <code>map</code>, I guess, but for nested dictionaries.</p>
<p>So: <code>map_nested_dicts(x, lambda v: v + 7)</code> would be the sort of goal.</p>
<p>I'm stuck as to the best way to perhaps store the layers of keys to then put the modified value back into its correct position.</p>
<p>What would the best way/approach to do this be?</p>
</div>
<div class="post-text" itemprop="text">
<p>Visit all nested values recursively:</p>
<pre><code>import collections

def map_nested_dicts(ob, func):
    if isinstance(ob, collections.Mapping):
        return {k: map_nested_dicts(v, func) for k, v in ob.iteritems()}
    else:
        return func(ob)

map_nested_dicts(x, lambda v: v + 7)
# Creates a new dict object:
#    {'a': 8, 'b': {'c': 13, 'g': {'h': 10, 'i': 16}, 'd': 14}, 'e': {'f': 10}}
</code></pre>
<p>In some cases it's desired to <em>modify</em> the original dict object (to avoid re-creating it):</p>
<pre><code>import collections

def map_nested_dicts_modify(ob, func):
    for k, v in ob.iteritems():
        if isinstance(v, collections.Mapping):
            map_nested_dicts_modify(v, func)
        else:
            ob[k] = func(v)

map_nested_dicts_modify(x, lambda v: v + 7)
# x is now
#    {'a': 8, 'b': {'c': 13, 'g': {'h': 10, 'i': 16}, 'd': 14}, 'e': {'f': 10}}
</code></pre>
<p>If you're using Python 3:</p>
<ul>
<li><p>replace <a href="https://docs.python.org/2/library/stdtypes.html#dict.iteritems" rel="noreferrer"><code>dict.iteritems</code></a> with <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="noreferrer"><code>dict.items</code></a></p></li>
<li><p>replace <code>import collections</code> with <code>import collections.abc</code></p></li>
<li><p>replace <code>collections.Mapping</code> with <code>collections.abc.Mapping</code></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Just to expand on vaultah's answer, if one of your elements can be a list, and you'd like to handle those too:</p>
<pre><code>import collections

def map_nested_dicts_modify(ob, func):
for k, v in ob.iteritems():
    if isinstance(v, collections.Mapping):
        map_nested_dicts_modify(v, func)
    elif isinstance(v, list):
        ob[k] = map(func, v)
    else:
        ob[k] = func(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you need it to work for both lists and dicts in arbitrary nesting:</p>
<pre><code>def apply_recursive(func, obj):
    if isinstance(obj, dict):  # if dict, apply to each key
        return {k: apply_recursive(func, v) for k, v in obj.items()}
    elif isinstance(obj, list):  # if list, apply to each element
        return [apply_recursive(func, elem) for elem in obj]
    else:
        return func(obj)
</code></pre>
</div>
<span class="comment-copy">A recursive solution might work.  Iterate over the items, if a value is an integer, change it, if the value is a dictionary, pass it in a recursive call.</span>
<span class="comment-copy">I was wondering if the <code>items</code> method in the first function might cause trouble but it looks like only mappings or mapping derivatives use this method - any thoughts?</span>
<span class="comment-copy">@wwii This is some sort of duck typing... Yes, it will work for <code>dict</code>s, <code>dict</code> subclasses, <code>ChainMap</code> and more mapping types.</span>
<span class="comment-copy">@wwii but you're probably right, I replaced the <code>try..except</code> block with <code>isinstance(ob, collections.Mapping)</code> check.</span>
