<div class="post-text" itemprop="text">
<p>Say I have a function in Python that uses a constant computed float value like 1/3.</p>
<pre><code>def div_by_3(x):
    return x * (1/3)
</code></pre>
<p>If I call the function repeatedly, will the value of 1/3 be automatically cached for efficiency? Or do I have to do something manually such as the following?</p>
<pre><code>def div_by_3(x, _ONE_THIRD=1/3):
    return x * _ONE_THIRD
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Find out for yourself! The <a href="https://docs.python.org/3/library/dis.html" rel="noreferrer">dis</a> module is great for inspecting this sort of stuff:</p>
<pre><code>&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; def div_by_3(x):
...     return x * (1/3.)
... 
&gt;&gt;&gt; dis(div_by_3)
  2           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (1)
              6 LOAD_CONST               2 (3.0)
              9 BINARY_DIVIDE       
             10 BINARY_MULTIPLY     
             11 RETURN_VALUE        
</code></pre>
<p>As you can see, the <code>1/3</code> calculation happens every time. (Note: I changed <code>3</code> to <code>3.</code> to force float division, otherwise it'd just be 0. You can also enable future-division, which actually changed the behavior, see edit section below). </p>
<p>And your second approach:</p>
<pre><code>&gt;&gt;&gt; def db3(x, _ONE_THIRD=1/3.):
...   return x * _ONE_THIRD
... 
&gt;&gt;&gt; dis(db3)
  2           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (_ONE_THIRD)
              6 BINARY_MULTIPLY     
              7 RETURN_VALUE        
</code></pre>
<p>More information on the second can be found by <a href="https://docs.python.org/3/library/inspect.html" rel="noreferrer">inspect</a>ing the function object:</p>
<pre><code>&gt;&gt;&gt; inspect.getargspec(db3)
ArgSpec(args=['x', '_ONE_THIRD'], varargs=None, keywords=None, defaults=(0.3333333333333333,))
</code></pre>
<p>You can see the default value is cached in there.</p>
<p><strong>EDIT</strong>: Turns out this is a little more interesting -- in Python 3 they do get cached (and also in Python 2.7 when you enable <code>from __future__ import division</code>):</p>
<pre><code>&gt;&gt;&gt; dis.dis(div_by_3)
  2           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               3 (0.3333333333333333)
              6 BINARY_MULTIPLY
              7 RETURN_VALUE
</code></pre>
<p>Switching to integer division (<code>//</code>) in either Python 3 or 2.7-with-future-division doesn't change this, it just alters the constant to be a <code>0</code> instead of <code>0.333..</code> Also, using integer division directly in 2.7 <em>without</em> future-division will cache the <code>0</code> as well. </p>
<p>Learned something new today!</p>
</div>
<span class="comment-copy">The latter, although you could keep the constant as a module level global variable instead of passing it the the function (unless you want to pass it as a parameter).</span>
<span class="comment-copy">I think doing it as a parameter is faster (avoids looking up the global name).</span>
<span class="comment-copy">Nope.  No difference in speed, and less clear to the user of the function if it is not a parameter.</span>
<span class="comment-copy">How can you explain second approach? Where is division?</span>
<span class="comment-copy">Is the default value for the keyword argument calculated every time the function is called?</span>
<span class="comment-copy">@Monkey No, default values are calculated once (on function definition) and stored on the created function object.</span>
<span class="comment-copy">@user3990145 The division happened during function definition and the resultant value was stored on the function object. When the function is called, all that's left to do is multiply that with <code>x</code>.</span>
<span class="comment-copy">Note that for Python 3, the peephole optimizer <i>does</i> precompute the <code>1/3</code> constant. (CPython specific, of course.)</span>
