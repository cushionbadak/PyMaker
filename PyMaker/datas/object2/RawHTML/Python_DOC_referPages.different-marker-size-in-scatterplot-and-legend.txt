<div class="post-text" itemprop="text">
<p>I'm making some scatter plots and I want to set the size of the points in the legend to a fixed, equal value.</p>
<p>Right now I have this:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np

def rand_data():
    return np.random.uniform(low=0., high=1., size=(100,))

# Generate data.
x1, y1 = [rand_data() for i in range(2)]
x2, y2 = [rand_data() for i in range(2)]


plt.figure()
plt.scatter(x1, y1, marker='o', label='first', s=20., c='b')
plt.scatter(x2, y2, marker='o', label='second', s=35., c='r')
# Plot legend.
plt.legend(loc="lower left", markerscale=2., scatterpoints=1, fontsize=10)
plt.show()
</code></pre>
<p>which produces this:</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/fAGgh.png"/></p>
<p>The sizes of the points in the legend are scaled but not the same. How can I fix the sizes of the points in the legend to an equal value without affecting the sizes in the <code>scatter</code> plot?</p>
</div>
<div class="post-text" itemprop="text">
<p>I had a look into the source code of <code>matplotlib</code>. Bad news is that there does not seem to be any simple way of setting equal sizes of points in the legend. It is especially difficult with scatter plots (<strong>wrong: see the update below</strong>). There are essentially two alternatives:</p>
<ol>
<li>Change the <code>maplotlib</code> code</li>
<li>Add a transform into the <code>PathCollection</code> objects representing the dots in the image. The transform (scaling) has to take the original size into account.</li>
</ol>
<p>Neither of these is very much fun, though #1 seems to be easier. The <code>scatter</code> plots are especially challenging in this respect.</p>
<p>However, I have a hack which does probably what you want:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np

def rand_data():
    return np.random.uniform(low=0., high=1., size=(100,))

# Generate data.
x1, y1 = [rand_data() for i in range(2)]
x2, y2 = [rand_data() for i in range(2)]

plt.figure()
plt.plot(x1, y1, 'o', label='first', markersize=np.sqrt(20.), c='b')
plt.plot(x2, y2, 'o', label='second', markersize=np.sqrt(35.), c='r')
# Plot legend.
lgnd = plt.legend(loc="lower left", numpoints=1, fontsize=10)

#change the marker size manually for both lines
lgnd.legendHandles[0]._legmarker.set_markersize(6)
lgnd.legendHandles[1]._legmarker.set_markersize(6)
plt.show()
</code></pre>
<p>This gives:</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/okdA6.png"/></p>
<p>Which seems to be what you wanted.</p>
<p>The changes:</p>
<ul>
<li><code>scatter</code> changed into a <code>plot</code>, which changes the marker scaling (hence the <code>sqrt</code>) and makes it impossible to use changing marker size (if that was intended)</li>
<li>the marker size changed manually to be 6 points for both markers in the legend</li>
</ul>
<p>As you can see, this utilizes hidden underscore properties (<code>_legmarker</code>) and is bug-ugly. It may break down at any update in <code>matplotlib</code>.</p>
<p><strong>Update</strong></p>
<p>Haa, I found it. A better hack:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np

def rand_data():
    return np.random.uniform(low=0., high=1., size=(100,))

# Generate data.
x1, y1 = [rand_data() for i in range(2)]
x2, y2 = [rand_data() for i in range(2)]

plt.figure()
plt.scatter(x1, y1, marker='o', label='first', s=20., c='b')
plt.scatter(x2, y2, marker='o', label='second', s=35., c='r')
# Plot legend.
lgnd = plt.legend(loc="lower left", scatterpoints=1, fontsize=10)
lgnd.legendHandles[0]._sizes = [30]
lgnd.legendHandles[1]._sizes = [30]
plt.show()
</code></pre>
<p>Now the <code>_sizes</code> (another underscore property) does the trick. No need to touch the source, even though this is quite a hack. But now you can use everything <code>scatter</code> offers.</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/3mX3o.png"/></p>
</div>
<div class="post-text" itemprop="text">
<p>Similarly to the answer, assuming you want all the markers with the same size:</p>
<pre><code>lgnd = plt.legend(loc="lower left", scatterpoints=1, fontsize=10)
for handle in lgnd.legendHandles:
    handle.set_sizes([6.0])
</code></pre>
<p>With MatPlotlib 2.0.0</p>
</div>
<div class="post-text" itemprop="text">
<p>I did not have much success using @DrV's solution though perhaps my use case is unique.  Because of the density of points, I am using the smallest marker size, i.e. <code>plt.plot(x, y, '.', ms=1, ...)</code>, and want the legend symbols larger.</p>
<p>I followed the recommendation I found on the <a href="http://matplotlib.1069221.n5.nabble.com/Normalizing-Marker-Size-in-Legend-tp42586p42590.html" rel="noreferrer">matplotlib forums</a>:</p>
<ol>
<li>plot the data (no labels)</li>
<li>record axes limit (<code>xlimits = plt.xlim()</code>)</li>
<li>plot fake data far away from real data with legend-appropriate symbol colors and sizes</li>
<li>restore axes limits (<code>plt.xlim(xlimits)</code>)</li>
<li>create legend</li>
</ol>
<p>Here is how it turned out (for this the dots are actually less important that the lines):
<a href="https://i.stack.imgur.com/dFMKU.jpg" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/dFMKU.jpg"/></a></p>
<p>Hope this helps someone else.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just another alternative here. This has the advantage that it would not use any "private" methods and works even with other objects than scatters present in the legend. The key is to map the scatter <code>PathCollection</code> to a <code>HandlerPathCollection</code> with an updating function being set to it. </p>
<pre><code>def update(handle, orig):
    handle.update_from(orig)
    handle.set_sizes([64])

plt.legend(handler_map={PathCollection : HandlerPathCollection(update_func=update)})
</code></pre>
<p>Complete code example:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np; np.random.seed(42)
from matplotlib.collections import PathCollection
from matplotlib.legend_handler import HandlerPathCollection

colors = ["limegreen", "crimson", "indigo"]
markers = ["o", "s", r"$\clubsuit$"]
labels = ["ABC", "DEF", "XYZ"]
plt.plot(np.linspace(0,1,8), np.random.rand(8), label="A line")
for i,(c,m,l) in enumerate(zip(colors,markers,labels)):
    plt.scatter(np.random.rand(8),np.random.rand(8), 
                c=c, marker=m, s=10+np.exp(i*2.9), label=l)

def update(handle, orig):
    handle.update_from(orig)
    handle.set_sizes([64])

plt.legend(handler_map={PathCollection : HandlerPathCollection(update_func=update)})

plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/Tg82C.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/Tg82C.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can make a Line2D object that resembles your chosen markers, except with a different marker size of your choosing, and use that to construct the legend. This is nice because it doesn't require placing an object in your axes (potentially triggering a resize event), and it doesn't require use of any hidden attributes. The only real downside is that you have to construct the legend explicitly from lists of objects and labels, but this is a well-documented matplotlib feature so it feels pretty safe to use.</p>
<pre><code>from matplotlib.lines import Line2D
import matplotlib.pyplot as plt
import numpy as np

def rand_data():
    return np.random.uniform(low=0., high=1., size=(100,))

# Generate data.
x1, y1 = [rand_data() for i in range(2)]
x2, y2 = [rand_data() for i in range(2)]

plt.figure()
plt.scatter(x1, y1, marker='o', label='first', s=20., c='b')
plt.scatter(x2, y2, marker='o', label='second', s=35., c='r')

# Create dummy Line2D objects for legend
h1 = Line2D([0], [0], marker='o', markersize=np.sqrt(20), color='b', linestyle='None')
h2 = Line2D([0], [0], marker='o', markersize=np.sqrt(20), color='r', linestyle='None')

# Set axes limits
plt.gca().set_xlim(-0.2, 1.2)
plt.gca().set_ylim(-0.2, 1.2)

# Plot legend.
plt.legend([h1, h2], ['first', 'second'], loc="lower left", markerscale=2,
           scatterpoints=1, fontsize=10)
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/Tw2gp.png" rel="nofollow noreferrer">Link to resulting figure</a></p>
</div>
<span class="comment-copy">blue is supposed to be smaller, but it should be straight forward to fix, +1</span>
<span class="comment-copy">Amazing answer DrV! Sorry I didn't comment sooner, I thought I had but apparently I never sent the cmmt.</span>
<span class="comment-copy">I just wanted to point out that the second hack doesn't work anymore, at least for me (<code>python 3.5</code>, <code>matplotlib 1.5.1</code>). Perhaps they changed something in the code of <code>matplotlib</code>. The first one does work though, thanks a lot for that.</span>
<span class="comment-copy">Thanks. I also needed to move my marker because it looked to be in a weird spot after it was resized: <code>lgnd.legendHandles[0]._offsets += np.array([[5,0]])</code></span>
<span class="comment-copy">Great tip. legendHandles method doesn't work for me on python 3.6. But first method still does.</span>
<span class="comment-copy">That's a beautiful plot</span>
