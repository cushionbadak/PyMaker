<div class="post-text" itemprop="text">
<p>If I define an abstract class with an abstract method:</p>
<pre><code>import abc


class A(abc.ABC):

    @classmethod
    @abc.abstractmethod
    def foo(cls):
        pass
</code></pre>
<p>I can't instantiate it (as expected):</p>
<pre><code>&gt;&gt;&gt; A()
TypeError: Can't instantiate abstract class A with abstract methods foo
</code></pre>
<p>But I can call its abstract method with no errors.</p>
<pre><code>&gt;&gt; A.foo()
</code></pre>
<p>Is this behavior documented somewhere ?</p>
<p>Tested on Python 3.6 and 3.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Nothing is explicit about that.</p>
<p>Simply the documentation of a the <code>abstractmethod</code> decorator says:</p>
<blockquote>
<p>A class that has a metaclass derived from ABCMeta cannot be instantiated unless all of its abstract methods and properties are overridden.</p>
</blockquote>
<p>And PEP 3119 says:</p>
<blockquote>
<p>A class containing at least one method declared with this decorator that hasn't been overridden yet cannot be instantiated.</p>
</blockquote>
<p>and later</p>
<blockquote>
<p><strong>Implementation</strong>: The <code>@abstractmethod</code> decorator sets the function attribute <code>__isabstractmethod__</code> to the value True. The <code>ABCMeta.__new__</code> method computes the type attribute <code>__abstractmethods__</code> as the set of all method names that have an <code>__isabstractmethod__</code> attribute whose value is true. It does this by combining the <code>__abstractmethods__</code> attributes of the base classes, adding the names of all methods in the new class dict that have a true <code>__isabstractmethod__</code> attribute, and removing the names of all methods in the new class dict that don't have a true <code>__isabstractmethod__</code> attribute. If the resulting <code>__abstractmethods__</code> set is non-empty, the class is considered abstract, and attempts to instantiate it will raise <code>TypeError</code>.</p>
</blockquote>
<p>My interpretation of the implementation part is that <code>@abstractmethod</code> never prevents the method to be called but only say that that class cannot be instantiated and that a subclass will still be abstract unless it overrides all of its abstract methods.</p>
<p>So I would not say that it is <em>by design</em>, but it is at least an assumed side effect.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>foo</code> is a <code>classmethod</code> and by <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer">property</a> a class method can be called directly by the class itself.<br/>
By doing   </p>
<pre><code>In [3]: A.foo()  
</code></pre>
<p>you are not instantiating the class <code>A</code>, rather you are just calling the function <code>foo</code> on class <code>A</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Subclassing <code>abc.ABC</code> indicates that class <code>A</code> cannot be instantiated directly.</p>
<p>The <code>@abc.abstractmethod</code> decorator forces a check on any subclass of <code>A</code> during type/name resolution. If <code>class subofA(A):</code> does not implement the decorated method, then an exception is raised.</p>
<p>Once type/name resolution is passed, the abstractmethod decorator does not prevent you from calling the method. After all, you aren't able to call the method without an instance, unless it is a class method.</p>
<p>By decorating <code>foo</code> with both <code>@classmethod</code> and <code>@abstractmethod</code> you, the developer, specify that <code>A.foo()</code> is safe to call without instantiating the class, but that anyone who subclasses <code>A</code> must implement an overriding method to preserve that behaviour.</p>
</div>
<span class="comment-copy">Official python docs about ABC: docs.python.org/3/library/abc.html Info: www.python-course.eu/python3_abstract_classes.php</span>
