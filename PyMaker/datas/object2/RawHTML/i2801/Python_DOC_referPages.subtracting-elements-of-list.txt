<div class="post-text" itemprop="text">
<p>I've a list of integers that I want to subtract from each other in consecutive order. I want to be able to use the code for any size list of integers, even if I don't know the number of integers.</p>
<p>What I've so far:</p>
<pre><code>a = [10, 9, 8]  # Example list with 3 integers
sub = 0
for i, n in enumerate(a):
    sub = a[i] - a[i+1]
print(sub)
</code></pre>
<p>My expected answer is -7 because:</p>
<p>10 - 9 = 1</p>
<p>Then 1 - 8 = -7</p>
<p>10 and 9 are the first and second element of the list <code>a</code>, respectively. I subtract them to get 1. I then take 1 and deduct 8 -- the third element of the list -- from it to get -7.</p>
<p>Instead, I get an error that the list index is out of range. I know why I'm getting this: because when <code>i</code> hits 2, <code>i+1</code> becomes 3, and there is no <code>a[3]</code> element in the list.</p>
<p>Yet for something so simple, I can't seem to figure out how to obtain consecutive indices like this, especially for a list where I wouldn't know the number of elements.</p>
<p>How can I fix this? Should I just use a <code>try-except</code> clause and <code>break</code> out of the loop when I get the <code>IndexError</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on your expected output of -7, you need to be subtracting from the running difference prior to the element you're currently on, rather than <code>a[i] - a[i+1]</code>. </p>
<p>In terms of the index issue, you can resolve it by adding in a logical check to make sure that you have remaining elements in the array by bounding the end point to be <code>len(a) - 1</code></p>
<pre><code>a = [10, 9, 8]  # Example list with 3 integers
sub = a[0]
for i, n in enumerate(a):
    if i &lt; (len(a) - 1):
        sub = sub - a[i + 1]
print(sub)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simpler and faster solution than explicit loops or <code>reduce</code>: Realizing that <code>a - b - c - ... - n</code> is equivalent to <code>a - (b + c + ... + n)</code>, so you can use the <code>sum</code> function (which is optimized at the C layer for sums that fit in a C <code>long</code>, only falling back to more expensive Python level <code>int</code>s if it overflows a C <code>long</code>).</p>
<pre><code>a = [10, 9, 8]  # Example list with 3 integers
sub = a[0] - sum(a[1:])
print(sub)
</code></pre>
<p>Note: This makes a shallow copy of most of <code>a</code>, and requires a sequence type (to support indexing/slicing), not any iterable. You can fix both issues with the slightly longer code:</p>
<pre><code>a = [10, 9, 8]  # Example list with 3 integers
aiter = iter(a)  # Make iterator from any iterable
sub = next(aiter) - sum(aiter)  # Pull first item from iterator, then pass rest to sum
print(sub)
</code></pre>
<p>This will be ever-so-slightly slower for small input <code>list</code>s (fixed overhead from <code>iter</code>/<code>next</code> being slightly greater than fixed overhead of indexing/slicing, though slicing has growing overhead of copy that <code>iter</code>/<code>next</code> lacks), but the savings on longer inputs would more than make up for it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> along with <a href="https://docs.python.org/3/library/operator.html#operator.sub" rel="nofollow noreferrer"><code>operator.sub</code></a></p>
<pre><code>from operator import sub
from functools import reduce

a = [10, 9, 8]

reduce(sub, a)
# -7
</code></pre>
<p>This is roughly equivalent to </p>
<pre><code>a = [10, 9, 8]

accumulator = a[0]
for x in a[1:]:
    accumulator -= x

print(accumulator)
# -7
</code></pre>
</div>
<span class="comment-copy">Yea I realized after I posted that my logic was wrong; I should've kept the <i>running</i> difference, not the <i>consecutive</i> difference. Your line with the <code>if</code> statement is also what I was searching for! Thanks!</span>
<span class="comment-copy">Note: Testing <code>i &lt; len(a) - 1</code> on every loop is optimizing for the uncommon case at the expense of the common case. Changing the loop to <code>for x in a[1:]: sub -= x</code> or <code>for i in range(1, len(a)): sub -= a[i]</code>, or even just wrapping the loop in <code>try/except IndexError: pass</code> would achieve the same effect (operating on all values except the first) with much lower overhead (Python level math, <code>len</code> checks, and indexing all have higher overhead than you might expect).</span>
<span class="comment-copy">I see your logic about <code>a - (b + c + ... + n)</code>, and that's definitely something I didn't consider. I did know about <code>sum()</code>, but wanted to avoid using that because I wanted to practice a bit with explicit iteration and loops (since I'm trying to learn C++, which I don't think has <code>sum()</code>).  I don't fully understand your point about "shallow copy of most of <code>a</code>" though. Do you mean that a new <code>list</code> object is created and stored in memory when I use <code>sum()</code>, and that's what you were trying to avoice with <code>iter()</code>?</span>
<span class="comment-copy">@WaterGuy: It's not the <code>sum</code> itself, it's the slice operation on <code>a</code>; <code>a[1:]</code> makes a new <code>list</code> containing all but the first element of <code>a</code>. As for "trying to learn C++", doing so in Python isn't exactly a useful start; different languages have different strengths and features, and trying to learn C++ via a language with very limited similarities won't get you very far. As for C++ and <code>sum</code>, <a href="https://en.cppreference.com/w/cpp/algorithm/reduce" rel="nofollow noreferrer">it's spelled <code>std::reduce</code> in C++17</a> (the default reduction function is addition, making it a <code>sum</code> function). :-)</span>
<span class="comment-copy">Very concise! I'd heard of <code>reduce()</code> but never used it before! Thanks for sharing.</span>
