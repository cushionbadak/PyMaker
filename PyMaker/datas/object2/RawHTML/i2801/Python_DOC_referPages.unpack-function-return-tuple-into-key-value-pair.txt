<div class="post-text" itemprop="text">
<p>Suppose I have a function that returns a tuple:</p>
<pre><code>def foo(x):
  return (x, x*100)
</code></pre>
<p>I have a list of values that I'd like to apply the function on and then turn the results into a dictionary:</p>
<pre><code>list_of_vals = [2, 4, 6]
result = {...magic comprehension...}
print(result)
# {2: 200, 4: 400, 6: 600}
</code></pre>
<p>I've come up with two ways to do this:</p>
<pre><code>{ k: v for k, v in map(foo, list_of_vals)}
{ k: v for k, v in (foo(val) for val in list_of_vals} # equivalently
</code></pre>
<p>or:</p>
<pre><code>def helper_bar(vals):
  for val in vals:
    yield(foo(val))

{k: v for k, v in helper_bar(vals)}
</code></pre>
<p>However, none of these is very readable. Furthermore, if the <code>list_of_vals</code> is humongous I don't want to create extra copies. Is there any better (efficient?) way to do this assuming I have very long list of values and <code>foo</code> is an expensive function?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow noreferrer"><code>dict</code> initializator</a> that takes an iterable of key-value <strong>tuples</strong>. So this would be perfect for your function that already returns a tuple:</p>
<pre><code>&gt;&gt;&gt; dict(map(foo, list_of_vals))
{2: 200, 4: 400, 6: 600}
</code></pre>
<p>In general though, having a function that returns a key-value tuple with the identical key seems somewhat rare. Most commonly, you would just have a function that returns the value. In those cases you would use a dictionary comprehension like this:</p>
<pre><code>{ x: foo(x) for x in list_of_vals }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just convert the result of <code>map</code> to <code>dict</code> directly</p>
<pre><code>&gt;&gt;&gt; list_of_vals = [2, 4, 6]
&gt;&gt;&gt; dict(map(foo, list_of_vals))
{2: 200, 4: 400, 6: 600}
</code></pre>
</div>
<span class="comment-copy">About your "in general": I'd say it's unusual that the function returns the original parameter, and in this (and only this) case would <code>x: foo(x)</code> work, but there are many other ways a function could return a key-value tuple.</span>
<span class="comment-copy">@tobias_k That’s a fair point, I’ve reworded that part a bit. Although even then you rarely really see that. It’s more common to have separate <code>foo</code>s for the key and the value then, so you do <code>foo(x): bar(x)</code>.</span>
<span class="comment-copy">Thank you, the first solution is what I needed. Is there, however, any way to modify the tuple beforehand? Basically, perform this <code>dict(map(lambda x : (bar1(x[0]), bar2(x[1])), map(foo, vals)))</code> for some functions <code>bar1</code> and <code>bar2</code> but in a nicer manner?</span>
<span class="comment-copy">If you have different functions for both key and value, then you’re better of with a dictionary compression again. You can do it like this though: <code>{ bar1(k): bar2(v) for k, v in map(foo, list_of_vals) }</code></span>
