<div class="post-text" itemprop="text">
<p>I have a feature in my data set that is a pandas timestamp object. It has (among many others) the following attributes: year, hour, dayofweek, month.</p>
<p>I can create new features based on these attributes using some brute force methods:</p>
<pre><code>df["year"] = df["timeStamp"].apply(lambda x : x.year)

df["hour"] = df["timeStamp"].apply(lambda x : x.hour)
</code></pre>
<p>. . .</p>
<p>However, I want to iterate over a list:</p>
<pre><code>nomtimes = ["year", "hour", "month", "dayofweek"]


for i in nomtimes:

  df[i] = df["timeStamp"].apply(lambda x : x.i)
</code></pre>
<p>I get the following AttributeError: 'Timestamp' object has no attribute 'i', and I get it and understand why I am having this error. </p>
<p>How can I get the quoted string to unquote so that I can pass it as an attribute?</p>
</div>
<div class="post-text" itemprop="text">
<p>You just need <code>getattr()</code>:</p>
<pre><code>df[i] = df["timeStamp"].apply(lambda x : getattr(x, i))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>.apply</code> here, pandas has various built-in utilities for handling datetime objects, use the <code>dt</code> attribute on the series objects:</p>
<pre><code>In [11]: start = datetime(2011, 1, 1)
    ...: end = datetime(2012, 1, 1)
    ...:

In [12]: df = pd.DataFrame({'data':pd.date_range(start, end)})

In [13]: df.dtypes
Out[13]:
data    datetime64[ns]
dtype: object

In [14]: df['year'] = df.data.dt.year

In [15]: df['hour'] = df.data.dt.hour

In [16]: df['month'] = df.data.dt.month

In [17]: df['dayofweek'] = df.data.dt.dayofweek

In [18]: df.head()
Out[18]:
        data  year  hour  month  dayofweek
0 2011-01-01  2011     0      1          5
1 2011-01-02  2011     0      1          6
2 2011-01-03  2011     0      1          0
3 2011-01-04  2011     0      1          1
4 2011-01-05  2011     0      1          2
</code></pre>
<p>Or, dynamically as you wanted using <code>getattr</code>:</p>
<pre><code>In [24]: df = pd.DataFrame({'data':pd.date_range(start, end)})

In [25]: nomtimes = ["year", "hour", "month", "dayofweek"]
    ...:

In [26]: df.head()
Out[26]:
        data
0 2011-01-01
1 2011-01-02
2 2011-01-03
3 2011-01-04
4 2011-01-05

In [27]: for t in nomtimes:
    ...:     df[t] = getattr(df.data.dt, t)
    ...:

In [28]: df.head()
Out[28]:
        data  year  hour  month  dayofweek
0 2011-01-01  2011     0      1          5
1 2011-01-02  2011     0      1          6
2 2011-01-03  2011     0      1          0
3 2011-01-04  2011     0      1          1
4 2011-01-05  2011     0      1          2
</code></pre>
<p>And if you must use a one-liner, go with:</p>
<pre><code>In [30]: df = pd.DataFrame({'data':pd.date_range(start, end)})

In [31]: df.head()
Out[31]:
        data
0 2011-01-01
1 2011-01-02
2 2011-01-03
3 2011-01-04
4 2011-01-05

In [32]: df = df.assign(**{t:getattr(df.data.dt,t) for t in nomtimes})

In [33]: df.head()
Out[33]:
        data  dayofweek  hour  month  year
0 2011-01-01          5     0      1  2011
1 2011-01-02          6     0      1  2011
2 2011-01-03          0     0      1  2011
3 2011-01-04          1     0      1  2011
4 2011-01-05          2     0      1  2011
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3><a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.attrgetter</code></a></h3>
<p>You can extract attributes in a loop:</p>
<pre><code>from operator import attrgetter

for i in nomtimes:
    df[i] = df['timeStamp'].apply(attrgetter(i))
</code></pre>
<p>Here's a complete example:</p>
<pre><code>df = pd.DataFrame({'timeStamp': ['2018-05-05 15:00', '2015-01-30 11:00']})
df['timeStamp'] = pd.to_datetime(df['timeStamp'])

nomtimes = ['year', 'hour', 'month', 'dayofweek']

for i in nomtimes:
    df[i] = df['timeStamp'].apply(attrgetter(i))

print(df)

            timeStamp  year  hour  month  dayofweek
0 2018-05-05 15:00:00  2018    15      5          5
1 2015-01-30 11:00:00  2015    11      1          4
</code></pre>
<p>Your code will not work because you are attempting to pass a string rather than extracting an attribute by name. Yet this isn't what's happening: the syntax does not feed the string but tries to access <code>i</code> directly, as demonstrated in your first example.</p>
<h3>Getting rid of the for loop</h3>
<p>You might ask if there's any way to extract all attributes from a <code>datetime</code> object in one go rather than sequentially. The benefit of <code>attrgetter</code> is you can specify multiple attributes directly to avoid a <code>for</code> loop altogether:</p>
<pre><code>attributes = df['timeStamp'].apply(attrgetter(*nomtimes))
df[nomtimes] = pd.DataFrame(attributes.values.tolist())
</code></pre>
<h3>Using dt accessor instead of apply</h3>
<p>But <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.apply.html" rel="nofollow noreferrer"><code>pd.Series.apply</code></a> is just a thinly veiled loop. Often, it's not necessary. Borrowing @juanpa.arrivillaga's idea, you an access attributes directly via the <a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.Series.dt.html" rel="nofollow noreferrer"><code>pd.Series.dt</code></a> accessor:</p>
<pre><code>attributes = pd.concat(attrgetter(*nomtimes)(df['timeStamp'].dt), axis=1, keys=nomtimes)
df = df.join(attributes)
</code></pre>
</div>
<span class="comment-copy">Thank you! This worked exactly as needed as well. Its great to see two different ways to accomplish this!</span>
<span class="comment-copy">Thank you! This worked exactly as needed!</span>
