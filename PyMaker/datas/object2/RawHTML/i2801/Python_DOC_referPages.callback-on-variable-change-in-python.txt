<div class="post-text" itemprop="text">
<p>I've searched around but didn't find anything like this. Let's say I have an army of threads, that keep reading and updating an integer variable <code>x</code>. I would like a callback for when <code>x</code> changes over a certain margin, let's say 500, to run the callback. </p>
<p>How can this be done without putting a heavy load on the system, like having a thread that has a <code>while true</code> and checks if the variable has changed?  Performance is critical. But so are ethics.</p>
<p>In plain code would be something like this:</p>
<pre><code>x = 10
def runMe():
    print('Its greater than 500!!') 

def whenToRun():
    return x &gt;= 500

triggers.event(runMe, whenToRun)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want to have a function (a  <em>"setter"</em>) which is called whenever the variable's value changes. A good way to do that is to define a <code>@property</code>. It will behave like a variable, but will have a <em>getter</em> function and a <em>setter</em> function.</p>
<p>Then, in the <em>setter</em>, call any callbacks you need, which will react to the change.</p>
<p>This should do the trick:</p>
<pre><code>class ObjectHoldingTheValue:
    def __init__(self, initial_value=0):
        self._value = initial_value
        self._callbacks = []

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, new_value):
        old_value = self._value
        self._value = new_value
        self._notify_observers(old_value, new_value)

    def _notify_observers(self, old_value, new_value):
        for callback in self._callbacks:
            callback(old_value, new_value)

    def register_callback(self, callback):
        self._callbacks.append(callback)
</code></pre>
<p>Then, you can do:</p>
<pre><code>def print_if_change_greater_than_500(old_value, new_value):
    if abs(old_value - new_value) &gt; 500:
        print(f'The value changed by more than 500 (from {old_value} to {new_value})')

holder = ObjectHoldingTheValue()
holder.register_callback(print_if_change_greater_than_500)
holder.value = 7    # nothing is printed
holder.value = 70   # nothing is printed
holder.value = 700  # a message is printed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>x</code> is an attribute of some object, rather than a global variable, this is very simple: add a <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code></a> method:</p>
<pre><code>class MyType:
    def __setattr__(self, name, value):
        if name == 'x':
            self.x_callback(value)
        super().__setattr__(name, value)
</code></pre>
<p>Obviously there are ways you can make this more flexible:</p>
<ul>
<li>Add a way to register conditions dynamically instead of just always calling <code>x_callback</code>.</li>
<li>Make it a mixin class that can be attached to any other class letting you <code>register(name, callback)</code> whatever you want.</li>
<li>Combine the above, so you can <code>register(name, condition, callback)</code>.</li>
<li><code>self.x_callback(oldval=self.x, newval=value)</code> so the callback can see old and new values.</li>
<li><code>if self.x_callback(value):</code> so the callback can accept or reject the change. </li>
<li><code>value = self.x_callback(value)</code> so the callback can override the change.</li>
</ul>
</div>
<span class="comment-copy">Does <code>x</code> have to be a global variable, or it can be, say, an attribute of some object?</span>
<span class="comment-copy">You can either "hide" the variable behind a setter which takes care of notifying the observers, or (if that is in no way doable), you can go for the suboptimal option of having a thread which constantly checks the value in the variable.</span>
<span class="comment-copy"><code>x</code> will be an attribute of some object</span>
<span class="comment-copy">@AndrasDeak Well, you <i>can</i> do. One way is through debugger hooks, which may be too slow. Alternatively, you can use your <code>__setitem__</code>-hooked container as a module dict, either in a hacky way, or with a nice import hook that gives all <code>.py</code> files your custom dict subclass. Maybe other ways as well.</span>
