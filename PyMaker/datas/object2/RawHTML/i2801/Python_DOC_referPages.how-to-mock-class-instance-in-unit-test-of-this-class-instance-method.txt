<div class="post-text" itemprop="text">
<p>Im trying to unittest <code>some_function</code> which is <code>MyClass</code> instance method that requires <code>someapi.api</code> instance . How do I patch <code>self.api.something1.something2(foo)</code> with some return value? </p>
<pre><code>import someapi

class MyClass(object):

  def __init__(self,a,b):
    self.a = a
    self.b = b
    self.api = someapi.api(self.a, self.b)

  def some_function(self, foo):
    result = self.api.something1.something2(foo)

    new_result = dosomething(result)
    return new_result
</code></pre>
<p>So really what I want is to mock response of this api so I can test that <code>dosomething(result)</code> does what I want.</p>
<pre><code>@mock.patch('self.api.something1.something2', side_effect='something')
def testGet_circuits(self,pymock):
    result = some_function('foobar')
    expected_result= 'something'
    self.assertEqual(result, 'expected_result')
</code></pre>
<p>I tried </p>
<pre><code>@mock.patch('someapi.api')
def testSome_function(self,someapi_mock):
    api = MyClass('a','b')
    result = api.some_function('foo')
    self.assertEqual(result,'newfoo')
</code></pre>
<p>What I'm strugling with is how to mock <code>self.api.something1.something2(foo)</code> inside some_function :(</p>
</div>
<div class="post-text" itemprop="text">
<p>You are not setting up your mock properly. I crafted an example using your code and managed to put together a test method that works. Ultimately, what is happening here is that you are not telling your mocks how to behave when the code runs. You start off probably mocking in the right place, but beyond that, the mock itself no longer has any of the attributes you are trying to access in order to allow the code to run. I'll go through the code to help illustrate: </p>
<pre><code>class TestStuff(unittest.TestCase):

    @mock.patch('real_code.someapi.api', autospec=True)
    def testSome_function(self, someapi_mock):

        someapi_mock.return_value.something1 = mock.Mock(spec=Something)

        someapi_mock.return_value.something1.something2.return_value = 'newfoo'

        api = MyClass('a', 'b')
        result = api.some_function('foo')
        self.assertEqual(result, 'newfoo')
</code></pre>
<p>First thing, notice that I'm mocking more with respect to where I am testing, which is important to keep in mind, and you should read about <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">here</a>.</p>
<p>For the mock configuration issue, I can only assume from your real code, <code>api.something1.something2</code> indicates that <code>something1</code> is holding the instance of some other class that gives you access to the <code>something2</code> method. So, the example is being illustrated with that assumption.</p>
<p>Now, as you can see within the first line of the method, what I'm doing is telling my mock to ensure it has the <code>something1</code> attribute. It is important to remember that when you are mocking, and even when you set the <a href="https://docs.python.org/3/library/unittest.mock.html#autospeccing" rel="nofollow noreferrer">spec and/or autospec</a> (as I have used in my example), you don't get access to the attributes created in your <code>__init__</code>. So you need to provide them in your mock per my example.</p>
<p>The second line now goes the next step to mock out the <code>something2</code> method behaviour you are trying to get a result from. With this done, when your real code is called, it should go through the expected behaviour you set up and return the expected <code>newfoo</code> value. </p>
<p>To further help, here is the exact code I used to help put together that functional test: </p>
<h1>real_code.py</h1>
<pre><code>import someapi


class MyClass(object):

  def __init__(self,a,b):
    self.a = a
    self.b = b
    self.api = someapi.api(self.a, self.b)

  def some_function(self, foo):
    result = self.api.something1.something2(foo)

    new_result = dosomething(result)
    return new_result


def dosomething(foo):
    return foo
</code></pre>
<h1>someapi.py</h1>
<pre><code>class api:
    def __init__(self, a, b):
        self.a = a
        self.b = b
        self.something1 = Something()


class Something:

    def something2(self, some_arg):
        return some_arg
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for all the answers definitely helped me 
I ended up doing below and worked like a charm . This whole mock thing looks like rabbit hole and i need to go deeper to fully understand.</p>
<pre><code>@mock.patch('someapi.api')
def testSome_function(self,someapi_mock):
    someapi_mock = return_value.something1.something2.return_value = 'mocked_value'
    api = MyClass('a','b')
    result = api.some_function('foo')
    self.assertEqual(result,'newfoo')
</code></pre>
</div>
<span class="comment-copy">What have you researched and/or tried so far? The <code>mock</code> library has quite extensive documentation how to do exactly what you want to do :)</span>
<span class="comment-copy">@mock.patch('someapi.api')     def testSome_function(self,someapi_mock):         api = MyClass('a','b')         result = api.some_function('foo')         self.assertEqual(result,'newfoo')  What im strugling with is how to mock self.api.something1.something2(foo) inside some_function :(</span>
<span class="comment-copy">So your last edit is on the right path, but you have to do something with the <code>someapi_mock</code> you get in your test function. For example <code>someapi_mock.that_function = Mock(return_value='wheeeeee')</code>.  But the structure of the api defines what you have to mock exactly :)</span>
<span class="comment-copy">OK i dont get it why when i do only @mock.patch('someapi.api') then i get &lt;MagicMock name='api().something1.something2()' id='4398546064'&gt; ? I tried someapi_mock.something1.something2 = return_value('foo') but this does not seem to work alwyas getting &lt;MagicMock name='api().something1.something2()' id='4398546064'&gt;  insteaqd of value</span>
