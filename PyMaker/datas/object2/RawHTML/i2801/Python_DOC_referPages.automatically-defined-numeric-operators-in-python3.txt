<div class="post-text" itemprop="text">
<p>I'm trying to create a custom class that behaves like an integral numeric type. The straightforward way to do that is to consult <a href="https://docs.python.org/3.5/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">Python3 documentation</a> on the matter, and then implement all the magic functions: both arithmetic <code>__add__, __radd__, __sub__, ...</code> and comparison <code>__le__, __lt__, ...</code> operators.</p>
<p>However, implementing them all by hand is tedious. I believe that in many cases, a good enough solution would be to implement them automatically based on the <code>__int__</code> magic function: we simply do the arithmetic with the object converted to int. Is this part of any commonly used library? What I'm looking for is something similar to <a href="https://docs.python.org/3.7/library/functools.html#functools.total_ordering" rel="nofollow noreferrer">@functools.total_ordering</a>, which automatically derives all comparison operators from only one of the operators.</p>
<p>If there is no such thing, then why? Would it be a bad idea to have such automatic conversion, or is it simply an issue one does not encounter too often?</p>
<p><strong>Edit:</strong> In case that the details of the custom class are relevant, I provide some of them here.</p>
<p>What I'm constructing is a counter whose value can change not only through arithmetic operations, but also other means. These can be very general: for example, we can tell the counter the following: "If anybody asks you what value you represent, return twice the normal value."</p>
<p>To illustrate, suppose you're playing a board game, for example, similar to Civilization. The game makes use of many parts, one of them is the counter that counts the military strength your civilization has. However, there may be an in-game effect which causes each point of strength to count twice.</p>
<p>Since the class is required to be mutable, I believe subclassing int is not an option (as int is immutable).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write your own mixin class or decorator that does this, similarly to the way <code>collections.abc.Sequence</code> implements a bunch of <code>Sequence</code> methods on top of a handful that you write manually, or <code>functools.total_ordering</code> implements a bunch of comparison methods for you. (If you're wondering how to decide which one to use: if the code has to examine your class before modifying it, as with <code>total_ordering</code>, your mixin would need a custom metaclass, so a decorator is easier. Otherwise, a mixin is usually simpler.)</p>
<p>There are dozens of implementations of this idea floating around PyPI and the ActiveState recipes and random blog posts and GitHub repos. But the problem isn't quite generalizable to turn a solution into a widely-used library.</p>
<p>As for the specific case you want—an object that acts like a mutable <code>int</code>, and implements it on the basis of its <code>__int__</code> method—I think that specific case just doesn't come up often enough that anyone has sat down and written it.</p>
<hr/>
<p>Anyway, getting all of this right—including things like <code>3.0 + x</code> and <code>x + 3.0</code>—is a bit of a pain.</p>
<p><a href="https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations" rel="nofollow noreferrer">Implementing the arithmetic operations</a> in the <code>numbers</code> documentation explains exactly what you want to do to get it right. </p>
<p>It also contains an explanation of the source code used by the <a href="https://docs.python.org/3/library/fractions.html" rel="nofollow noreferrer"><code>fractions</code></a> library to reduce the boilerplate and repetition of defining all of these methods on <code>fraction.Fraction</code>, which is very handy.</p>
<p>The only problem with all of that is that it's written for immutable numeric types, not mutable ones. So, if you want to use it, you'll need to modify it, with an <code>operator_fallback</code> function that builds and returns <code>forward, reverse, inplace</code> instead of just <code>forward, reverse</code>.</p>
<hr/>
<p>However, your case is simpler than <code>Fraction</code>, so you can simplify the operator-function-creating methods, like this:</p>
<pre><code>def _operator_fallbacks(op, sym):
    def forward(a, b):
        result = op(int(a), b)
        if isinstance(result, int): result = type(a)(result)
        return result
    forward.__name__ = '__' + op.__name__ + '__'
    forward.__doc__ = f"a {sym} b"

    def reverse(b, a):
        result = op(a, int(b))
        if isinstance(result, int): result = type(b)(result)
        return result
    reverse.__name__ = '__r' + op.__name__ + '__'
    reverse.__doc__ = f"a {sym} b"

    def inplace(a, b):
        # If you want to work via __int__ rather than by digging
        # into the internals, you can't delegate += to +=, you
        # have to implement it via some kind of set method.
        a.set(op(int(a), b))
        return a
    inplace.__name__ = '__i' + op.__name__ + '__'
    inplace.__doc__ = f'a {sym}= b'

    return forward, reverse, inplace

__add__, __radd__, __iadd__ = _operator_fallbacks(operator.add, '+')
__sub__, __rsub__, __isub__ = _operator_fallbacks(operator.sub, '-')
</code></pre>
<p>You might want to consider <code>isinstance(result, numbers.Integral)</code>. You might also want to make your class a subtype of <code>numbers.Integral</code>. If you do both, be careful about how you construct them, so you don't end up with an <code>Int(Int(Int(5)))</code> instead of an <code>Int(5)</code>.</p>
<p>If you wanted to generalize this into a mixin that can be used for mutable <code>int</code>, <code>float</code>, <code>complex</code>, <code>Decimal</code>, <code>Fraction</code>, etc. types, you could just add a <code>get</code> method that all of your types have to implement, instead of relying on <code>__int__</code>. Although you'd have to think through the conversion issues (<code>int</code> is easy, being on the base of the numeric tower).</p>
</div>
<span class="comment-copy">We need more details. What other functionality will your custom class have? Depending on that, we can offer suggestions.</span>
<span class="comment-copy">Maybe you could just subclass <code>int</code>?</span>
<span class="comment-copy">How about a mixin class that implements the operators once?</span>
<span class="comment-copy">Looked up mixin, looks like a good enough solution.  @Aran-Fey: The number that the class represents is not always the same, it changes based on the state (it is mutable). Thus, subclassing int is not an option.</span>
