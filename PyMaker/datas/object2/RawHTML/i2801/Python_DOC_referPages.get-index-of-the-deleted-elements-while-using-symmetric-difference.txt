<div class="post-text" itemprop="text">
<p><strong>There are two columns in a CSV file:</strong></p>
<pre><code>oldCol1 = [1, 2, 3, 4, 5]

oldCol2 = ['A', 'B', 'C', 'D', 'E']
</code></pre>
<p><strong>Now I update the csv and add a new row</strong></p>
<pre><code>newCol1 = [1, 2, 3, 4, 5, 6]

newCol2 = ['A', 'B', 'C', 'D', 'E', 'A']
</code></pre>
<p><strong>I want to get only the newly added element. So, I am trying this:</strong></p>
<pre><code>newListCol1 = list(set(oldCol1).symmetric_difference(newCol1))
</code></pre>
<p><strong>Now, my question is how to get the newly added element from column two?</strong> </p>
<pre><code>#Here, I want to get two lists: [6] and ['A']. 
</code></pre>
<p><strong>Thanks for your help!</strong></p>
<p><strong>Update:</strong><br/>
The newly added elements can be anywhere in the list (not just the end) -- sorry for the confusion! </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#if they can be anywhere

#mehtod 1
from collections import Counter 

oldCol1 = [1, 2, 3, 4, 5]

oldCol2 = ['A', 'B', 'C', 'D', 'E']

newCol1 = [1, 2, 3, 4, 5, 6]

newCol1_1 = [1, 2, 3, 4, 5, 6, 6, 7, 7] #different example

newCol2 = ['A', 'B', 'C', 'D', 'E', 'A']

print(list((Counter(newCol1) - Counter(oldCol1)))) # returns a list of unique value
print(list((Counter(newCol2) - Counter(oldCol2))))


new_item_added_dict = Counter(newCol1_1) - Counter(oldCol1)
print( list(new_item_added_dict.elements())) # elements() returns an iterator
# if you want all the new values even duplicates like in newCol1_1 
# ie if you want ans to be [6, 6, 7, 7] then use elements()

# else use list() if you just want unique value updates [6,7]
print( list(new_item_added_dict))

 # output
 # [6]
 # ['A']
 # [6, 6, 7, 7]
 # [6, 7]

#--------------------------------------------------------------------- 

#method 2
from collections import defaultdict
oldCol1 = [1, 2, 3, 4, 5]
newCol1 = [1, 2, 3, 4, 5, 6]  # --&gt;[6]
# [1, 2, 3, 4, 5, 6, 5] --&gt; [6,5]

new_item_list = []
oldlist_dict = defaultdict(lambda:0) #default value of key is 0 and with defualtdict you will not key error

for item in oldCol1:
    oldlist_dict[item] += 1

for item in newCol1:
    if item in oldlist_dict and oldlist_dict[item] &gt; 0:
        oldlist_dict[item] -=1
    else:
        # its a new item 
        new_item_list.append(item)

print(new_item_list)


#--------------------------------------------------------------------- 

#if new items are always appended ie added to end of old list
print(newCol1[len(oldCol1):])  

print(newCol2[len(oldCol2):])

print(newCol1_1[len(oldCol1):])  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you know that the "newly added elements" are always appended to the end of the list, then just slice from the length of the old list onward. i.e.</p>
<pre><code>old_til_here = len(oldCol1)
list_of_new_elements_col_1 = newCol1[old_til_here:]
list_of_new_elements_col_2 = newCol2[old_til_here:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You will need to get indexes that are not present in first one, so use just sets without <a href="https://kite.com/python/docs/__builtin__.set.symmetric_difference" rel="nofollow noreferrer">symmetric_difference</a>. Use <a href="https://kite.com/python/docs/builtins.enumerate" rel="nofollow noreferrer">enumerate()</a> to get indexes easier.</p>
<pre><code>oldCol1 = [1, 2, 3, 4, 5]

oldCol2 = ['A', 'B', 'C', 'D', 'E']

newCol1 = [1, 2, 3, 4, 5, 6]

newCol2 = ['A', 'B', 'C', 'D', 'E', 'A']

indexes = [i for i, v in enumerate(newCol1) if v not in set(oldCol1)]

resultCol1 = [newCol1[i] for i in indexes]
resultCol2 = [newCol2[i] for i in indexes]

print(resultCol1, resultCol2)
</code></pre>
</div>
<span class="comment-copy">Ill defined problem. What's the definition of "newly added element"? If <code>newcol1 = [1,1,2,3,4,5]</code> did you add the first or second <code>1</code>?</span>
<span class="comment-copy">If a new row is added, for example (6, 'A') -- there are two columns, then how would I get that? newListCol1 = list(set(oldCol1).symmetric_difference(newCol1)) gives me [6] -- that is correct. I don't know how to get ['A']. I hope that helps.</span>
<span class="comment-copy">@Julien...what? I added a 6 in the end.</span>
<span class="comment-copy">If you added <code>6</code> and <code>A</code> then the answer is <code>6</code> and <code>A</code>. If you want a program for the general case, you need to specify correctly the general case.</span>
<span class="comment-copy">The general case would be that any number of rows can be added. But that's not the point. How would you programmatically get ['A'] here? -- that's my question.</span>
<span class="comment-copy">Glad I could help :) read about Counter from docs <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.Counter</a></span>
<span class="comment-copy">Great idea but I can not guarantee that condition. Thanks for your help though!</span>
<span class="comment-copy">Sets don't work well when you have to know the exact count of repeated elements.</span>
<span class="comment-copy">I assume that column names are unique repeat because in case they do we are unable to distinguish if the columns were swapped and many problems arise :)</span>
<span class="comment-copy">I posted a clarification. Sorry about the confusion. @MadPhysicist</span>
