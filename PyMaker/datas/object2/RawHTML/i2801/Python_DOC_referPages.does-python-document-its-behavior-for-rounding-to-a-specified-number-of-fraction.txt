<div class="post-text" itemprop="text">
<p>Is the algorithm used for rounding a <code>float</code> in Python to a specified number of digits specified in any Python documentation? The semantics of <code>round</code> with zero fractional digits (i.e. rounding to an integer) are simple to understand, but it's not clear to me how the case where the number of digits is nonzero is implemented.</p>
<p>The most straightforward implementation of the function that I can think of (given the existence of <code>round</code> to zero fractional digits) would be:</p>
<pre><code>def round_impl(x, ndigits):
    return (10 ** -ndigits) * round(x * (10 ** ndigits))
</code></pre>
<p>I'm trying to write some C++ code that mimics the behavior of Python's <code>round()</code> function for all values of <code>ndigits</code>, and the above agrees with Python for the most part, when translated to equivalent C++ calls. However, there are some cases where it differs, e.g.:</p>
<pre><code>&gt;&gt;&gt; round(0.493125, 5)
0.49312
&gt;&gt;&gt; round_impl(0.493125, 5)
0.49313
</code></pre>
<p>There is clearly a difference that occurs when the value to be rounded is at or very near the exact midpoint between two potential output values. Therefore, it seems important that I try to use the same technique if I want similar results.</p>
<p>Is the specific means for performing the rounding specified by Python? I'm using CPython 2.7.15 in my tests, but I'm specifically targeting v2.7+.</p>
</div>
<div class="post-text" itemprop="text">
<p>Also refer to <a href="https://floating-point-gui.de/" rel="nofollow noreferrer">What Every Programmer Should Know About Floating-Point Arithmetic</a>, which has more detailed explanations for why this is happening as it is.</p>
<p>This is a mess. First of all, as far as <code>float</code> is concerned, there is no such number as 0.493125, when you write 0.493125 what you actually get is:</p>
<p>0.493124999999999980015985556747182272374629974365234375</p>
<p>So this number is not exactly between two decimals, it's actually closer to 0.49312 than it is to 0.49313, so it should definitely round to 0.49312, that much is clear.</p>
<p>The problem is that when you multiply by 10<sup>5</sup>, you get the exact number 49312.5. So what happened here is the multiplication gave you an <em>inexact result</em> which <em>by coincidence</em> canceled out the rounding error in the original number. Two rounding errors canceled each other out, yay! But the problem is that when you do this, the rounding is actually incorrect... at least if you want to round <em>up</em> at midpoints, but Python 3 and Python 2 behave differently. Python 2 rounds away from 0, and Python 3 rounds towards even least-significant digits.</p>
<p><a href="https://docs.python.org/2.7/library/functions.html#round" rel="nofollow noreferrer">Python 2</a></p>
<blockquote>
<p>if two multiples are equally close, rounding is done away from 0</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">Python 3</a></p>
<blockquote>
<p>...if two multiples are equally close, rounding is done toward the even choice...</p>
</blockquote>
<h2>Summary</h2>
<p>In Python 2,</p>
<pre><code>&gt;&gt;&gt; round(49312.5)
49313.0
&gt;&gt;&gt; round(0.493125, 5)
0.49312
</code></pre>
<p>In Python 3,</p>
<pre><code>&gt;&gt;&gt; round(49312.5)
49312
&gt;&gt;&gt; round(0.493125, 5)
0.49312
</code></pre>
<p>And in both cases, 0.493125 is <em>really</em> just a short way of writing 0.493124999999999980015985556747182272374629974365234375.</p>
<h2>So, how does it work?</h2>
<p>I see two plausible ways for <code>round()</code> to <em>actually</em> behave.</p>
<ol>
<li><p>Choose the closest decimal number with the specified number of digits, and then round that decimal number to <code>float</code> precision. This is hard to implement, because it requires doing calculations with more precision than you can get from a <code>float</code>.</p></li>
<li><p>Take the two closest decimal numbers with the specified number of digits, round them both to <code>float</code> precision, and return whichever is closer. This will give incorrect results, because it rounds numbers twice.</p></li>
</ol>
<p>And Python chooses... option #1! The exactly correct, but much harder to implement version. Refer to <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c#L927" rel="nofollow noreferrer">Objects/floatobject.c:927 double_round()</a>. It uses the following process:</p>
<ol>
<li><p>Write the floating-point number to a string in <em>decimal</em> format, using the requested precision.</p></li>
<li><p>Parse the string back in as a <code>float</code>.</p></li>
</ol>
<p>This uses code based on <a href="http://www.netlib.org/fp/dtoa.c" rel="nofollow noreferrer">David Gay's dtoa library</a>. If you want C++ code that gets the <em>actual correct result</em> like Python does, this is a good start. Fortunately you can just include <code>dtoa.c</code> in your program and call it, since its licensing is very permissive.</p>
</div>
<div class="post-text" itemprop="text">
<p>The Python documentation for  and <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow noreferrer">2.7</a> specifies the behaviour:</p>
<blockquote>
<p>Values are rounded to the closest multiple of 10 to the power minus
  ndigits; if two multiples are equally close, rounding is done away
  from 0.</p>
</blockquote>
<p>For <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">3.7</a>:</p>
<blockquote>
<p>For the built-in types supporting round(), values are rounded to the
  closest multiple of 10 to the power minus ndigits; if two multiples
  are equally close, rounding is done toward the even choice</p>
</blockquote>
<p>Update: </p>
<p>The (cpython) implementation <a href="https://github.com/python/cpython/search?q=float___round___impl&amp;unscoped_q=float___round___impl" rel="nofollow noreferrer">can be found</a> <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Objects/floatobject.c" rel="nofollow noreferrer">floatobjcet.c</a> in the function <code>float___round___impl</code>, which calls <code>round</code> if <code>ndigits</code> is not given, but <code>double_round</code> if it is.</p>
<p><code>double_round</code> has two implementations.
One converts the double to a string (aka decimal) and back to a double.
The other one does some floating point calculations, calls to <code>pow</code> and at its core calls <code>round</code>. It seems to have more potential problems with overflows, since it actually multiplies the input by <code>10**-ndigits</code>.</p>
<p>For the precise algorithm, look at the linked source file.</p>
</div>
<span class="comment-copy">maybe will this help <a href="https://docs.python.org/2.7/tutorial/floatingpoint.html" rel="nofollow noreferrer">docs.python.org/2.7/tutorial/floatingpoint.html</a></span>
<span class="comment-copy">I understand the intricacies of floating-point arithmetic; that's why it's so important to be careful when trying to make two separate pieces of software in different languages agree on the same result. However, what I'm trying to determine is whether the actual implementation of <code>round()</code> is specified tightly enough so that it can be reliably duplicated elsewhere.</span>
<span class="comment-copy">I believe the python 3 rounding behaviour is quite simple, all else equal it picks the even choice, the python 2 behavior is more complex and probably not something you want to emulate, see <a href="https://stackoverflow.com/a/22155830/6260170">stackoverflow.com/a/22155830/6260170</a></span>
<span class="comment-copy">In python Python/pymath.c it looks like it uses floor function. <a href="https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Python/pymath.c" rel="nofollow noreferrer">github.com/python/cpython/blob/â€¦</a></span>
<span class="comment-copy">@darc: That is a just a definition of the C function <code>round()</code>, the Python function <code>round()</code> for <code>float</code> is defined in <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/floatobject.c</a> and it is a bit more complicated so it can get the correct result.</span>
<span class="comment-copy">Great answer, thank you. It gives me a lot to think about. My main goal of making an independent implementation is to improve on the existing Python code speed-wise. I'd like to avoid float-&gt;string-&gt;float conversion if possible, but I understand that more work than the trivial implementation I suggested is required.</span>
<span class="comment-copy">@JasonR: The hard part about doing float-&gt;string or string-&gt;float correctly is maintaining the required level of precision to get the correct results for all inputs. This is actually very difficult, and rounding a number correctly involves most of the same difficulties. This suggests to me that if you try to avoid the float-&gt;string-&gt;float conversion you are likely to end up spending an enormous amount of effort duplicating work that's already been done, you may introduce subtle or hard to detect errors, and in the end your code may not be much faster.</span>
<span class="comment-copy">@JasonR: You can think of <code>dtoa</code> as formatting a number as a string, but really what it's doing is solving the problem "given a float, what is the closest decimal with the given precision" and its reverse is "given a decimal, what is the closest float." These are <i>exactly</i> the problems that you would need to solve to implement <code>round()</code> correctly, and if you need variable precision decimal numbers, it is convenient and efficient to store them in strings.</span>
<span class="comment-copy">This not only does not explain the behavior in the question, but it's also incorrect! If you actually read the documentation for Python 3.7 the behavior is <b>different.</b></span>
<span class="comment-copy">I understand that, but the example I gave above isn't consistent with that, assuming the naive implementation that I came up with. That's the essence of my question.</span>
<span class="comment-copy">@DietrichEpp You are right, 3 is not doing the "away from 0" rounding.</span>
<span class="comment-copy">@JasonR Did you read the note next to the documentation? It explains the 'weird' behaviour.</span>
<span class="comment-copy">@MegaIng: Yes, I understand that floating-point arithmetic is not exact. However, I would like to be able to produce calculations that agree with Python's <code>round()</code> function when <code>ndigits != 0</code>. In this case, due to the inexactness of floating-point arithmetic, exactly how it goes about performing the rounding is critical. That's what I'm trying to determine: is this behavior specified and/or consistent across interpreter versions/implementations?</span>
