<div class="post-text" itemprop="text">
<p>I stumbled across this behaviour, which suggests that you can use <code>getattr</code> to call methods on a class instance, as an alternative to the intuitively named <code>operator.methodcaller</code>:</p>
<pre><code>from operator import methodcaller

class Foo():
    def __init__(self, lst):
        self.lst = lst

    def summer(self):
        return sum(self.lst)

my_obj = Foo(range(11))

res1 = methodcaller('summer')(my_obj)  # 55
res2 = getattr(my_obj, 'summer')()     # 55

assert res1 == res2
</code></pre>
<p>I'd like to understand, internally, <em>why</em> this works. Is it because all methods are also attributes? This <em>seems</em> to be the case because <code>dir(Foo)</code> or <code>dir(my_obj)</code> includes <code>'summer'</code>. But I have never heard methods referred to as <em>attributes</em> of a class or class instance, e.g. this isn't mentioned in <a href="https://stackoverflow.com/questions/3786881/what-is-a-method-in-python">What is a “method” in Python?</a></p>
<p>There is an <a href="https://docs.python.org/3/tutorial/classes.html#method-objects" rel="nofollow noreferrer">explanation in the docs</a> which mentions differentiation between "data attributes" and "non-data attributes" which I failed to understand.</p>
<p><strong>Update:</strong> Comments by @Amadan have clarified most of the above. The only remaining bit I do not understand is this excerpt from the docs:</p>
<blockquote>
<p>If you still don’t understand how methods work, a look at the
  implementation can perhaps clarify matters. When a non-data attribute
  of an instance is referenced, the instance’s class is searched. If
  the name denotes <strong>a valid class attribute that is a function object</strong>, a
  method object is created by <strong>packing (pointers to) the instance object</strong>
  and the function object just found together in an <strong>abstract object</strong>:
  this is the method object.</p>
</blockquote>
<p>So is  a non-data attribute determined by checking whether it is callable, or is there some other way that's used to determine it's a function object? What does "packing pointers" to the instance object mean? What's an abstract object?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, methods are just attributes containing functions of appropriate form (they must accept at least one parameter, the receiver, usually called <code>self</code>).</p>
<p>Here's an example that explains the quoted paragraph:</p>
<pre><code>class Foo():
    def a(self):
        print("FOO")

foo = Foo()
foo.a()
# =&gt; FOO
</code></pre>
<p>So, <code>def</code> there actually attached an attribute <code>a</code> to <code>Foo</code> as an "unbound method" (as you can see when we inspect it - meaning, it doesn't know who is receiving it yet) in Python 2, or just a plain function value (in Python 3):</p>
<pre><code>Foo.a
# =&gt; &lt;unbound method Foo.a&gt;          (Python 2)
# =&gt; &lt;function Foo.a at 0x10919fea0&gt; (Python 3)
</code></pre>
<p>You can invoke it just like any function (... with one exception, in Python 2: the first argument <em>must be</em> of type <code>Foo</code>):</p>
<pre><code>Foo.a(foo)
# =&gt; FOO

Foo.a(42)
# =&gt; TypeError: unbound method a() must be called with Foo instance as first argument (got int instance instead) (Python 2)
# =&gt; 42 (Python 3)
</code></pre>
<p>However, if you try to find it on an instance ("instance attribute reference"), it is now reporting as a "bound method":</p>
<pre><code>foo.a
# =&gt; &lt;bound method Foo.a of &lt;__main__.Foo instance at 0x10ba11320&gt;&gt;
</code></pre>
<p>This can be said to be "packing (pointers to) the instance object and the function object together": there is a reference to the instance object, <code>&lt;__main__.Foo instance at 0x10ba11320&gt;</code> (a.k.a. <code>foo</code>), and a reference to the function object, <code>Foo.a</code>, in one package we call "bound method".</p>
<p>Unlike JavaScript, it's not purely a syntactic thing. In JavaScript, the difference between a method invocation and a function invocation is in the call itself: if it has a dot, it's a method invocation:</p>
<pre><code>// JavaScript
let foo = new Foo()
foo.a();                // method invocation: `a` is told that the receiver is `foo`
let z = foo.a; z()      // function invocation, `a` doesn't know about `foo`
</code></pre>
<p>In Python, the bound function carries its receiver inside it:</p>
<pre><code>// Back to Python
foo.a()                 // method invocation: `a` is told that the receiver is `foo`
z = foo.a; z()          // STILL method invocation; `z` knows both `foo` and `Foo.a`
</code></pre>
<p>How does this calling even work? The rest of the paragraph explains: </p>
<blockquote>
<p>When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.</p>
</blockquote>
<p>So, when we say</p>
<pre><code>foo.a()
</code></pre>
<p>it will unpack <code>foo.a</code> into <code>Foo.a</code> and <code>foo</code>; prepend <code>foo</code>, the receiver, to the list of the arguments (I have none here, so the argument list is <code>[foo] + []</code> for the final argument list of <code>[foo]</code>), and what ends up being called is <code>Foo.a(foo)</code>. Incidentally, that's exactly what you can do manually:</p>
<pre><code>Foo.a(foo)
# =&gt; FOO
</code></pre>
<p>Even with built-in objects:</p>
<pre><code>"-".join(["foo", "bar", "baz"])
# =&gt; 'foo-bar-baz'
str.join("-", ["foo", "bar", "baz"])
# =&gt; 'foo-bar-baz'
</code></pre>
<p>Here, <code>"-".join</code> is a bound method that packs together the receiver <code>"-"</code> and the function <code>str.join</code>; when we invoke the first line, the receiver <code>"-"</code> is prepended to the rest of the arguments <code>[["foo", "bar", "baz"]]</code> for the final argument list of <code>["-", ["foo", "bar", "baz"]]</code>, and that's sent to the function that is sitting in the <code>join</code> attribute of <code>str</code> (i.e. <code>str.join</code>). This gives us a clear translation between the first line and the second line.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, methods are attributes.</p>
<p>From <a href="https://docs.python.org/3/glossary.html#term-attribute" rel="nofollow noreferrer">the python glossary</a>:</p>
<blockquote>
<p><strong>attribute</strong></p>
<p>A value associated with an object which is referenced by name using dotted expressions. For example, if an object o has an attribute
  a it would be referenced as o.a.</p>
</blockquote>
<p>Clearly we <em>can</em> access methods like that, so consequently they must be attributes. They're just attributes that happen to be functions.</p>
<p>Further, there's this sentence in <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">the <code>getattr</code> documentation</a>:</p>
<blockquote>
<p><code>getattr(x, 'foobar')</code> is equivalent to <code>x.foobar</code></p>
</blockquote>
<p>As a direct consequence of that, <code>x.foobar()</code> is also equivalent to <code>getattr(x, 'foobar')()</code>. There is no reason to believe that methods are special in any way.</p>
<hr/>
<p>The reason why methods are rarely referred to as attributes in practice is, I think, two-fold:</p>
<ol>
<li>Methods serve a completely different purpose than other attributes. Methods are intended to be called, whereas other attributes are usually just data. It's the same reason why we don't refer to functions as "variables", even though they technically are.</li>
<li>"Method" is much easier to say than "callable class attribute".</li>
</ol>
<hr/>
<p>Lastly, regarding data attributes vs. non-data attributes: <a href="https://docs.python.org/3/tutorial/classes.html#instance-objects" rel="nofollow noreferrer">The documentation</a> makes a distinction between methods (i.e. callable attributes; "non-data attributes") and data attributes (i.e. everything else).</p>
<blockquote>
<p>There are two kinds of valid attribute names, data attributes and methods.</p>
</blockquote>
<blockquote>
<p>data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++.</p>
</blockquote>
<blockquote>
<p>The other kind of instance attribute reference is a method.</p>
</blockquote>
<p>The excerpt you posted is rather confusing, but I think it's trying to provide a basic explanation of the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, which is responsible for turning functions into methods. Let's see that again:</p>
<blockquote>
<p>When a non-data attribute of an instance is referenced, the instance’s
  class is searched. If the name denotes a valid class attribute that is
  a function object, a method object is created by packing (pointers to)
  the instance object and the function object just found together in an
  abstract object: this is the method object.</p>
</blockquote>
<p>In other words: When you do <code>some_object.some_method</code>, python grabs the <em>function</em>(!) <code>some_method</code> from <code>some_object</code>'s class and then turns it into a <em>bound method</em> where the <code>self</code> argument is implicitly included. Why they call it an "abstract object" is a mystery to me. Anyway, for more detail about this process, see <a href="https://stackoverflow.com/questions/2307653/how-does-assignment-of-a-function-as-a-class-attribute-become-a-method-in-python">How does assignment of a function as a class attribute become a method in Python?</a> or <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">the relevant section in the descriptor HowTo</a>.</p>
<p>(Warning: Python distinguishes between <strong>data descriptors</strong> and <strong>non-data descriptors</strong>. Don't confuse these with <strong>data <em>attributes</em></strong> and <strong>non-data <em>attributes</em></strong>! These are two entirely unrelated concepts.)</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/classes.html#instance-objects" rel="nofollow noreferrer">Here</a>: "The other kind of instance attribute reference is a method." pretty much explicitly says it: some attributes are just data, but some attributes are methods.</span>
<span class="comment-copy">See what docs say <a href="https://docs.python.org/3/library/operator.html#operator.methodcaller" rel="nofollow noreferrer"><code>methodcaller</code> is equivalent to</a> :)</span>
<span class="comment-copy">@Amadan, Thank you! The only remaining thing which I would want clarification about is the comment in the docs about data vs non-data attributes. I'll update my question in a moment.</span>
<span class="comment-copy">I just want to point out that unbound methods no longer exist in python 3. What used to be an "unbound method" in python 2 is now just a plain old function. As a consequence of that, <code>self</code> no longer has to be an instance of that class either - <code>Foo.a(42)</code> will print "FOO" in python 3.</span>
<span class="comment-copy">@Aran-Fey Ah derp. I knew I’d mess up <i>somewhere</i>. Thanks!</span>
