<div class="post-text" itemprop="text">
<p>I have the following point class:</p>
<pre><code>import math

class Point:
    """Two-Dimensional Point(x, y)"""
    def __init__(self, x=0, y=0):
        # Initialize the Point instance
        self.x = x
        self.y = y

   # def __iter__(self):
 #       return iter(int(self.x))
 #       return iter(int(self.y))
        return self

    @property
    def magnitude(self):
        # """Return the magnitude of vector from (0,0) to self."""
        return math.sqrt(self.x ** 2 + self.y ** 2)


    def distance(self, self2):
         return math.sqrt((self2.x - self.x) ** 2 + (self2.y - self.y) ** 2)

    def __str__(self):
        return 'Point at ({}, {})'.format(self.x, self.y)

    def __repr__(self):
        return "Point(x={},y={})".format(self.x, self.y)
</code></pre>
<p>I want to make 'points' iterable so that the following is possible:</p>
<pre><code>point = Point(2, 3)
x, y = point
print(x)
    2
print(y)
    3
</code></pre>
<p>If you see my commented code, that is what I attempted but it says TypeError: iter() returned non-iterator of type 'Point'. Any ideas on how to correctly do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>tl;dr:</p>
<pre><code>def __iter__(self):
    yield self.x
    yield self.y
</code></pre>
<hr/>
<p>To make something iterable, you need your <code>__iter__</code> method to return an iterator.</p>
<p>You can't just <code>return self</code>, unless <code>self</code> is already an iterator (which means it has a <code>__next__</code> method). But you don't want <code>points</code> to be an iterator, you want it to be iterable over and over.</p>
<p>You can't <code>return iter(int(self.x))</code> then <code>return iter(int(self.y))</code>, for two reasons. First, after you <code>return</code>, your function is done; any code that happens after that never gets run. Second, you can't call <code>iter</code> on an <code>int</code>. (Also, there's no reason to call <code>int</code> on an <code>int</code>.)</p>
<hr/>
<p>You could fix that last set of problems by creating an iterable out of each <code>int</code>, like a single-element list, iterating that iterable, and then delegating to it with <code>yield from</code> instead of <code>return</code>. Using <code>yield</code> or <code>yield from</code> in a function makes it a generator function, and the generators created by generated functions are iterators:</p>
<pre><code>yield from iter([self.x])
yield from iter([self.y])
</code></pre>
<p>â€¦ but this is kind of silly. Once we know we want a generator, we can just <code>yield</code> the values we want to be iterated. Hence the code at the top.</p>
<hr/>
<p>Alternatively, you could explicitly create a single-element iterables for both elements and chain them together and return that:</p>
<pre><code>def __iter__(self):
    return itertools.chain(iter([self.x]), iter([self.y]))
</code></pre>
<p>But that's also silly. Chaining two iterators over single-element lists is the same as just iterating a two-element list:</p>
<pre><code>def __iter__(self):
    return iter([self.x, self.y])
</code></pre>
<hr/>
<p>Finally, rather than relying on a generator, list iterator, <code>chain</code>, or other iterator type that comes with Python, you can always write one explicitly:</p>
<pre><code>class PointIterator:
    def __init__(self, point):
        self.values = [point.x, point.y]
    def __next__(self):
        try:
            return self.values.pop(0)
        except IndexError:
            raise StopIteration
    def __iter__(self):
        return self

class Point:
    # ... other code
    def __iter__(self):
        return PointIterator(self)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>yield</code>:</p>
<pre><code>class Point:
  def __init__(self, x=0, y=0):
    self.x = x
    self.y = y
  def __iter__(self):
    yield self.x
    yield self.y

a, b = Point(4, 5)
print([a, b])
</code></pre>
<p>Output:</p>
<pre><code>[4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should implement a special <code>__iter__(self)</code> method, which should return an <em>iterator</em>. Add something like</p>
<pre><code>def __iter__(self):
    return iter([self.x, self.y])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>__iter__</code> method should yield x and y values</p>
<pre><code>def __iter__(self):
    yield self.x
    yield self.y
</code></pre>
<p>With this, you get the following output</p>
<pre><code>&gt;&gt;&gt; point = Point(2, 3)
&gt;&gt;&gt; x, y = point
&gt;&gt;&gt; print (x)
2
&gt;&gt;&gt; print (y)
3
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">@YiFei No, that isn't an iterator.</span>
<span class="comment-copy">All of the below answers are correct. Is there a specific one which has the most advantages</span>
<span class="comment-copy">@user10200421 That's why I wrote explanations for how the different ways all work, instead of just giving you code. Generally, after you understand them all, it's obvious which one is simplest for a given case. I think in this case, the generator is the simplest, which is why I put it first (and presumably why Sunitha and Ajax gave the same thing, without explanation, as the whole answer), but you should try to understand all of them before deciding.</span>
<span class="comment-copy">As a side note: Do you want your <code>Point</code> objects to be mutable? Because, if not, this might be a great job for <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>namedtuple</code></a>. (In fact, it's the example in the <code>namedtuple</code> docs.) That way, you get iteration for free, and indexing (I think it makes sense for, e.g., <code>pt[1]</code> to be the <code>y</code> value), and <code>__init__</code> (actually <code>__new__</code>, but don't worry about that), and <code>__repr__</code>, comparison operators, errors that prevent you from accidentally mutating a <code>Point</code>, and a bunch of other stuff.</span>
<span class="comment-copy">I want to be able to mutate the points using multiple mathematical operations later.</span>
<span class="comment-copy">When I try this I get TypeError: iter() returned non-iterator of type 'list'</span>
<span class="comment-copy">@user10200421: sorry, typo. edited</span>
