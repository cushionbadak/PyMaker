<div class="post-text" itemprop="text">
<p>Knowing this will most likely end with a failure, I want to know how Python will treat such a scenario and whether or not my code actually "makes sense", at least in principle.
So here's my attempt, I'm pretty new to python (a few days ago), so I'm sure my code seems funny to those of you with more experience, but please bear with me.      </p>
<pre class="lang-python prettyprint-override"><code>def make_inf_lst(lst):
  lst = [0]
  while 1 == 1:
    for i in range(0, len(lst)):
      add = lst[i] + 1
      lst.append(add)
print(make_inf_lst([]))
</code></pre>
<p>This is the error I got in my DOS window trying to run the above: </p>
<pre><code>Traceback (most recent call last):
  File "break_python.py", line 7, in &lt;module&gt;
    print(make_inf_lst([]))
  File "break_python.py", line 6, in make_inf_lst
    lst.append(add)
MemoryError
</code></pre>
<p>Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Languages with "infinite" data structures are actually producing objects that produce their values lazily, or "on-demand". Rather than creating the entire list up front, they create an object that, when asked for a value, can create it at that time.</p>
<p>In Python, this is most easily managed using a generator.</p>
<pre><code>def make_inf_sequence():
    x = 0
    while True:
        yield x
        x = x + 1

# This returns immediately
naturals = make_inf_sequence()

# This loop runs forever
for i in naturals:
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's basically two things which will stop the infinite list from being printed (which seems like the final goal of your code):</p>
<ol>
<li>The computer will run out of memory.</li>
<li>The creation of the list will take infinite time, meaning it will never finish and the actual printing will never start.</li>
</ol>
<p>If you imagine an imaginary computer with infinite memory and infinite calculation speed, the list can be printed.</p>
<p>However, some languages support infinite lists by being "lazy", meaning they will only calculate the part of the list which they need at that certain point. Then you could define an infinite list and ask it to print out e.g. the first 100 values in it.</p>
<p>More about lazy computing: 
<a href="https://en.m.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow noreferrer">https://en.m.wikipedia.org/wiki/Lazy_evaluation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It cannot be infinite in the sense you immediately get access to all members in the universe. That would be impossible - infinite length means infinite memory needed. As you can see from the error you got, you do not have infinite memory. As the others note, you can trade speed for length:</p>
<pre><code>from copy import deepcopy
class infinite_ints:
    def __init__(self):
        self.list = []
        self.trans = lambda x: x;

    def __getitem__(self,at):
        try:
            return self.trans(self.list[at])
        except IndexError:
            self.list += [i for i in range(len(self.list),at+1)]
        return self.trans(self.list[at])

    def apply(self,function):
        new_list = deepcopy(self)
        new_list.trans = lambda x,f=function,p=self.trans: f(p(x))
        return new_list

&gt;&gt;&gt; x[2]
2
&gt;&gt;&gt; x[12]
12
&gt;&gt;&gt; x[43]
43
&gt;&gt;&gt; y = x.apply(lambda x: x+1)
&gt;&gt;&gt; y[59]
60
</code></pre>
<p>Here I combine both a regular list with on the fly extension if needed. I did not have to start with an empty list, I could have pre-made the first N elements if I preferred.</p>
<p>You could of course overload operators (+,- whatever). The point is everything is done one the fly. Working this way you can even add and subtract infinite lists.</p>
<p>You could even improve this using memory management, and deleting the start of the list if not viewed in a while, but that's out of scope I think. The more functional approach would be something holding the current number and the way to continue (I added a <code>prev</code> to be similar to the builtin <code>__next__</code>:</p>
<pre><code>def prev(x):
    return x.__prev__()

class infinity_functional:
    def __init__(self):
        self.n=0
    def __next__(self):
        Next   = infinity_functional()
        Next.n = self.n + 1
        return Next
    def __prev__(self):
        Prev   = infinity_functional()
        Prev.n = self.n - 1
        return Prev
    def __repr__(self):
        return str(self.n)

enter code here

&gt;&gt;&gt;x=infinity_functional()
&gt;&gt;&gt;x
0
&gt;&gt;&gt; next(next(next(x)))
3
&gt;&gt;&gt; y=next(next(next(x)))
&gt;&gt;&gt; prev(y)
2
</code></pre>
<p>Again, operators (not just the representation), or jumping more than one can easily be implemented.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your computer runs out of memory at some point while building the list, that's what causes the error you are seeing. It is not possible to have an infinite list, because memory is a limited resource.</p>
<p>Alternatively you may use an infinite iterator. The standard library provides a few infinite iterators. Based on your example, I think will be the most suitable for your situation is <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a>.</p>
<p>Sample usage:</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; it = count()
&gt;&gt;&gt; next(it)
0
&gt;&gt;&gt; next(it)
1
</code></pre>
<p>You can also specify a custom starting point:</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; it = count(5)
&gt;&gt;&gt; next(it)
5
&gt;&gt;&gt; next(it)
6
</code></pre>
<p>And a custom step:</p>
<pre><code>&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; it = count(5, 2)
&gt;&gt;&gt; next(it)
5
&gt;&gt;&gt; next(it)
7
&gt;&gt;&gt; next(it)
9
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Infinite data structures do make sense, but they <em>always</em> have to be lazily evaluated. That means that your data structure can't build all of its elements straight away, and then move itself around (like we would normally do with a <code>list</code> that fits in memory). Instead, your data structure needs to give you values as you demand them.</p>
<p>In Python, you can't have an infinite <code>list</code> because <code>list</code> is eager, not lazy (just like most things in Python, eager is the default). To be clear, I'm talking about the <code>list</code> type here w.r.t. Python terminology, not the abstract concept of some sequence (which some people <em>might</em> call a list).</p>
<p>The way that you can have lazy evaluation is by using something called a <code>generator</code>. If you want to generate the sequence <code>1,2,3,4,...</code>, you can do it with the following code:</p>
<pre><code>def gen_natural_numbers():
    cur = 1
    while True:
        yield cur
        cur += 1

natural_num_gen = gen_natural_numbers()
print("One: ", next(natural_num_gen))
print("Two: ", next(natural_num_gen))
print("Three: ", next(natural_num_gen))
</code></pre>
<p>this outputs:</p>
<pre><code>One:  1
Two:  2
Three:  3
</code></pre>
<p>Obviously, you don't have to stop at 3. You don't have to stop anywhere (except for when the <code>int</code> you've created doesn't actually fit into memory). If you keep calling <code>next</code>, the generator will keep returning values to you.</p>
<p>As you go along, the garbage collector can delete values from memory that no longer contain references. This is another topic entirely, but it should be noted that as long as you don't keep the references around forever, your program won't run out of memory when using generators either.</p>
</div>
<span class="comment-copy">I wanted to know if the code would work if the machine wouldn't run out of memory, i.e if the code works to some degree. Thanks for your reply.</span>
<span class="comment-copy">@FuzzyPixelz If the machine had an infinite amount of memory, the loop would run forever and the <code>print</code> statement would never be executed. I don't know whether that meets your criteria for working.</span>
<span class="comment-copy">Even if you had infinite memory, <code>make_inf_lst</code> would never terminate, because the loop would run forever and never actually return the list.</span>
<span class="comment-copy">I see. Can you specify at which point the machine runs out of memory? Or does it depend on my specifications?</span>
<span class="comment-copy">@FuzzyPixelz It depends on your specifications.. basically depends on how memory-costy is each object in your list, and how much free memory you have available</span>
