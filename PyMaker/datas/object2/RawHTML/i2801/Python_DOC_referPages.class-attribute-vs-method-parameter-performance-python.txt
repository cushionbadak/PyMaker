<div class="post-text" itemprop="text">
<p>Please ignore my calculation just want to wonder if there is any performance preference between using class attribute or method parameter since both of them pretty much works the same way just that class attribute can be called anywhere inside the class instead method parameter only stays in its own scope</p>
<pre><code>class Circle():
    def __init__(self, radius=1):
        self.pi = 3.14
        self.radius = 1

    # use class attribute pi
    def get_circum_self(self):
        return self.pi * self.radius * 2

    # use param for pi
    def get_circum_pi(self, pi, radius):
        return pi * radius * 2

nc = Circle()
print(nc.pi)
print(nc.radius)
print(nc.get_circum_self())  # use class attribute pi
print(nc.get_circum_pi(111, 1))  # use param for pi
</code></pre>
<p>Thanks in advance for any explanations</p>
</div>
<div class="post-text" itemprop="text">
<p>It's very rare that a performance difference will matter here.</p>
<p>But these are very different interfaces, that do different things, and that almost certainly <em>will</em> matter. </p>
<p>So, that's how you should decide which one to write: Do you want to ask a circle for its circumference, or do you want to ask a circle to compute the circumference of a completely different circle?</p>
<hr/>
<p>But if you <em>do</em> care about performance, the only way to get an answer is to test it. Python comes with a <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a> module specifically designed for benchmarking snippets of code like this. If you use IPython/Jupyter, it has an even nicer wrapper around this, called <code>%timeit</code>.</p>
<p>Here's what <code>%timeit</code> says on my machine, running 64-bit python.org CPython 3.7, with your sample data:</p>
<pre><code>In [417]: %timeit nc.get_circum_self()
323 ns ± 10.7 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
In [418]: %timeit nc.get_circum_pi(111, 1)
258 ns ± 6.55 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>This makes sense. Just passing integers around isn't quite free (they have to get pushed and popped from the stack, and, in CPython, their refcounts have to be twiddled), but it's very fast. Looking up attributes in an object by name is a bit more work on top of that. Apparently, it's about 70 nanoseconds of extra work.</p>
<hr/>
<p>But consider how you'd use this in a more realistic way. If you only want to calculate one circumference with hardcoded values in your source code, that's obviously only ever going to happen once, so who cares whether it's 323ns or 258ns? If you wanted to calculate zillions of them, the values would presumably be coming from some variable, right? So, let's compare that:</p>
<pre><code>In [419]: pi, rad = 111, 1
In [420]: %timeit nc.get_circum_pi(pi, rad)
319 ns ± 15.19 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<p>It looks like looking up a pair of global variables is just as expensive as looking up a pair of attributes. Which, again, is not too surprising—either way, we're looking up a name (a string whose hash value has already been pre-computed before we get here) in a namespace (which is just a plain old dict both for globals and for a normal class like the one you wrote), so it's about the same amount of work.</p>
<hr/>
<p>It's also worth noting that <code>get_circum_pi</code> doesn't do anything with <code>self</code>, and has no reason to be a method at all. So, if you're really trying to squeeze out the last few nanoseconds, why force yourself to look the <em>method</em> up as an attribute? Why not just make it a function?</p>
<pre><code>In [423]: def get_circum_pi(pi, radius):
     ...:     return pi * radius * 2
In [424]: %timeit get_circum_pi(111, 1)
180 ns ± 4.54 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
</code></pre>
<p>That saved us even more time. Which, again, makes sense, but only if you know a bit more about how methods work. Looking up a method requires looking up the function, not finding it in the object's own dictionary, falling back to the class's dictionary, and then calling a descriptor <code>__get__</code> on the function to bind it as a method. That's a whole lot of work. </p>
<p>Well, it's 78 nanoseconds worth of work, which still isn't very much.</p>
<hr/>
<p>It's worth having a sense of what all these things do, and how long they take, and what the alternatives are. For example, if you're computing a zillion circumferences, you can store the bound method in a variable instead of looking it up over and over again. You can move the whole loop inside a function, so the bound method and the global variables all become local variables (which are a bit faster). And so on. </p>
<p>It's rarely worth doing any of these things—but "rarely" isn't "never". For a real-life example, see the <code>unique_everseen</code> function in the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipes in the <code>itertools</code> docs</a>—that <code>seen_add = seen.add</code> is there because it turns out that it really does make a difference in some real-life programs using this recipe.</p>
</div>
<span class="comment-copy">It's very rare that a performance difference will matter here. But these are very different interfaces, that do different things, and that almost certainly <i>will</i> matter. So, that's how you should decide which one to do: Do you want to ask a circle for its circumference, or do you want to ask a circle to compute the circumference of a completely different circle?</span>
<span class="comment-copy">It all boils down to getting your hands on (testing). Take both, do the same task several million times (in both cases) then compare the times.</span>
<span class="comment-copy">Thanks a lot for the detailed explanation, I can quite understand when I am reading it even though honestly I am not sure if I am able to remember the flow deeply but sure would be somewhere in my back of my head remembering your nice answer.  Thank you</span>
