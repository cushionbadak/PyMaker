<div class="post-text" itemprop="text">
<p>trying to find a <code>python library</code> or to find the best way to find methods from <code>python code files</code></p>
<p>for example, <code>app.py</code> </p>
<pre><code>from django.conf.urls import url
from oscar.core.loading import get_class


class SearchApplication(Application):
    name = 'search'
    search_view = get_class('search.views', 'FacetedSearchView')
    search_form = get_class('search.forms', 'SearchForm')

    def get_urls(self):

        # The form class has to be passed to the __init__ method as that is how
        # Haystack works.  It's slightly different to normal CBVs.
        urlpatterns = [
            url(r'^$', search_view_factory(
                view_class=self.search_view,
                form_class=self.search_form,
                searchqueryset=self.get_sqs()),
                name='search'),
        ]
        return self.post_process_urls(urlpatterns)
</code></pre>
<p>and my aim is to write code that takes that file <code>app.py</code> as input as text or as file(either way is fine) and outputs something like this:</p>
<pre><code>{
   "methods": [
        {"name": "get_urls", "class": "SearchApplication", "line": 9, "args": [self], "kwargs": []}
     ],

  "classs": [
    {"name": "SearchApplication", "inherits_from": "Application", "line": 5}
  ]   
}
</code></pre>
<p>thanks. please ask if the intention is unclear or if the question is missing data.</p>
</div>
<div class="post-text" itemprop="text">
<p>used <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer">ast.parse</a></p>
<pre><code>    file_content = open('/path_to_file', 'r').read()
    parsed_result = ast.parse(self.file_content)
    for element in parsed_result.body:
        results = self.index_element(element)


def index_element(self, element, class_name=None):
    '''

        if element is relevant, meaning method -&gt; index
        if element is Class -&gt; recursively call it self

    :param element:
    :param class_name:
    :return: [{insert_result: &lt;db_insert_result&gt;, 'structured_data': &lt;method&gt; object}, ...]
    '''
    # find classes
        # find methods inside classes
    # find hanging functions

    # validation on element type
    if self.should_index_element(element):
        if self.is_class_definition(element):
            class_element = element
            indexed_items = []
            for inner_element in class_element.body:
                # recursive call
                results = self.index_element(inner_element, class_name=class_element.name)
                indexed_items += results

            return indexed_items
        else:
            structured_data = self.structure_method_into_an_object(element, class_name=class_name)
            result_graph = self.dal_client.methods_graph.insert_or_update(structured_data)
            return "WhatEver"

    return "WhatEver"
</code></pre>
<p><code>element</code> object has properties of the function/class. </p>
</div>
<span class="comment-copy">Take a look at <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer"><code>ast.parse</code></a>.</span>
<span class="comment-copy">If you're working only with "live" objects (i.e. active parts of the current program), then the Python <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect</a> package will likely serve your needs nicely.  "Live" in this case would mean that you had imported the package.</span>
<span class="comment-copy">@Aran-Fey i've used ast.parse thanks. Suggest it in an anwer, and i'll accept.</span>
<span class="comment-copy">I won't be posting an answer, because writing the code to extract all that information about all functions is non-trivial and I don't want to write it. You can post your own answer if you'd like.</span>
