<div class="post-text" itemprop="text">
<p>I'm having a hell of a hard time trying to figure out why my <code>print(Node(3).value)</code> is printing <code>0</code>. Any ideas?</p>
<p>When I run this code, I get</p>
<pre><code>First: 6 Value: 8 Children: [9]
First: 8 Value: 23 Children: [9]
First: 3 Value: 3 Children: [5]
First: 6 Value: 8 Children: [7]
First: 4 Value: 20 Children: [8]
First: 1 Value: 17 Children: [8]
First: 8 Value: 23 Children: [10]
First: 5 Value: 11 Children: [8]
First: 1 Value: 17 Children: [2]
0
</code></pre>
<p>Any ideas? I know I'm not saving the Nodes anywhere but my mind can't wrap around it.
Any help would be appreciated, thanks!</p>
<pre><code># Complete the primeQuery function below.
n = 10
first = [6, 8, 3, 6, 4, 1, 8, 5, 1]
second = [9, 9, 5, 7, 8, 8, 10, 8, 2]
values = [17, 29, 3, 20, 11, 8, 3, 23, 5, 15]
queries = [1, 8, 9, 6, 4, 3]


class Node(object):
    def __init__(self, data, value=0):
        self.data = data
        self.value = value
        self.children = []

    def addChild(self, child):
        self.children.append(child)

    def setValue(self, givenV):
        self.value = givenV


def primeQuery(n, first, second, values, queries):
    i = 0
    while i &lt; n - 1:
        f = Node(first[i], values[first[i] - 1])

        s = Node(second[i], values[second[i] - 1])

        f.addChild(s.data)

        print(f"First: {f.data} Value: {f.value} Children: {f.children}")

        i += 1

    print(Node(3).value)


primeQuery(n, first, second, values, queries)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Statement</p>
<pre><code>Node(3).value
</code></pre>
<p>creates <code>Node</code> object with <code>data</code> set to <code>3</code> &amp; <code>value</code> set to <code>0</code> (default argument), so when you're getting its <code>value</code> it returns <code>0</code>.</p>
<p>If you want to create <code>Node</code> objects and then re-use them -- you should store them in some sort of container.</p>
<p>Assuming that</p>
<ul>
<li><code>data</code> field is a hashable unique identifier of <code>Node</code>,</li>
<li>if <code>Node</code> has been created and we're passing different <code>value</code> -- old <code>value</code> persists</li>
</ul>
<p>I see at least 2 approaches here:</p>
<ul>
<li><p>Create container on the top level, explicitly add <code>Node</code>s to it upon creation and access them using it afterwards like</p>
<pre><code>def primeQuery(n, first, second, values, queries):
    i = 0
    # top-level container of ``Node``s
    nodes = {}

    def get_or_create_node(data, value):
        try:
            # trying to access already created ``Node``
            result = nodes[data]
        except KeyError:
            # no ``Node`` found, create it...
            result = Node(data, value)
            # ... and register
            nodes[data] = result
        return result

    while i &lt; n - 1:
        f = get_or_create_node(first[i], values[first[i] - 1])
        s = get_or_create_node(second[i], values[second[i] - 1])

        f.addChild(s.data)

        print(f"First: {f.data} Value: {f.value} Children: {f.children}")

        i += 1

    print(nodes[3].value)
    # we can return ``nodes`` here if we want to use them outside of given function
</code></pre>
<p>gives us</p>
<pre><code>First: 6 Value: 8 Children: [9]
First: 8 Value: 23 Children: [9]
First: 3 Value: 3 Children: [5]
First: 6 Value: 8 Children: [9, 7]
First: 4 Value: 20 Children: [8]
First: 1 Value: 17 Children: [8]
First: 8 Value: 23 Children: [9, 10]
First: 5 Value: 11 Children: [8]
First: 1 Value: 17 Children: [8, 2]
3
</code></pre></li>
<li><p>Extension of previous approach: restrict <code>Node</code>s creation using global function which caches already created ones:</p>
<pre><code># in module namespace
def get_or_create_node(data, value=0,
                       *,
                       # hack, see **note**
                       cache={}):
    # we've moved class definition inside of a function to restrict its instances creation
    class Node(object):
        def __init__(self, data, value):
            self.data = data
            self.value = value
            self.children = []

        def addChild(self, child):
            self.children.append(child)

        def setValue(self, givenV):
            self.value = givenV

    try:
        result = cache[data]
    except KeyError:
        result = Node(data, value)
        cache[data] = result
    return result
</code></pre>
<p>(<strong>note</strong>: here we're using "hack" with mutable default argument, more info may be found in <a href="https://stackoverflow.com/questions/9158294/good-uses-for-mutable-function-argument-default-values">this thread</a>)</p>
<p>Then everywhere when we need to create/access <code>Node</code> object -- we should use this function only like</p>
<pre><code>def primeQuery(n, first, second, values, queries):
    i = 0
    while i &lt; n - 1:
        f = get_or_create_node(first[i], values[first[i] - 1])
        s = get_or_create_node(second[i], values[second[i] - 1])

        f.addChild(s.data)

        print(f"First: {f.data} Value: {f.value} Children: {f.children}")

        i += 1

    print(get_or_create_node(3).value)
</code></pre>
<p>this will give us the same output as before.</p></li>
</ul>
<h1>Further improvements</h1>
<h2>changing <code>value</code></h2>
<p>If our assumption about <code>value</code> being persistent turns out to be wrong -- we can simply add changing of <code>value</code> if it was passed like:</p>
<ul>
<li><p>in first approach:</p>
<pre><code>def get_or_create_node(data, value):
    try:
        # trying to access already created ``Node``
        result = nodes[data]
    except KeyError:
        # no ``Node`` found, create it...
        result = Node(data, value)
        # ... and register
        nodes[data] = result
    # adding ``else``-clause
    else:
        result.setValue(value)
    return result
</code></pre></li>
<li><p>in second approach: set <code>value</code> parameter's default value to <code>None</code> and check if it was specified like</p>
<pre><code>def get_or_create_node(data, value=None,
                       *,
                       cache={}):
    class Node(object):
        def __init__(self, data, value):
            self.data = data
            self.value = value
            self.children = []

        def addChild(self, child):
            self.children.append(child)

        def setValue(self, givenV):
            self.value = givenV

    try:
        result = cache[data]
    except KeyError:
        if value is None:
            # default value
            value = 0
        result = Node(data, value)
        cache[data] = result
    else:
        if value is not None:
            result.setValue(value)
    return result
</code></pre></li>
</ul>
<h1>inheriting from <code>object</code></h1>
<p>If we're working in <strong>Python 3</strong> -- there is no need to specify <code>object</code> as base class, it will be set by default (see <a href="https://stackoverflow.com/questions/1238606/is-it-necessary-or-useful-to-inherit-from-pythons-object-in-python-3-x">this thread</a>), so instead of</p>
<pre><code>class Node(object):
    ...
</code></pre>
<p>we can simply write</p>
<pre><code>class Node:
    ...
</code></pre>
<h2>use <code>for</code>-loop instead of <code>while</code></h2>
<p>We don't need to use <code>while</code>-loop &amp; increment <code>i</code> by hand when we have <code>for</code>-loop and <code>range</code> objects, so instead of</p>
<pre><code>i = 0
while i &lt; n - 1:
    ...
    i += 1
</code></pre>
<p>we can write</p>
<pre><code>for i in range(n - 1):
    ...
</code></pre>
<p>also I think here is a typo, because we're skipping case with <code>i</code> equal to <code>n - 1</code>, so we can fix it:</p>
<pre><code>for i in range(n):
    ...
</code></pre>
<p>finally we can see that there is no need in <code>i</code> index when we can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code> built-in</a> &amp; iterate over pairs of <code>first</code> &amp; <code>second</code> <code>list</code>s elements like</p>
<pre><code>for first_data, second_data in zip(first, second):
    f = get_or_create_node(first_data, values[first_data - 1])
    s = get_or_create_node(second_data, values[second_data - 1])

    f.addChild(s.data)

    print(f"First: {f.data} Value: {f.value} Children: {f.children}")
</code></pre>
</div>
<span class="comment-copy">you are not saving your <code>Node</code> objects <code>f</code> &amp; <code>s</code></span>
<span class="comment-copy"><code>Node(3)</code> will create a <code>Node</code> with <code>value = 0</code>.</span>
<span class="comment-copy">@AzatIbrakov , Oh duh! Um, but I'm a little confused on how to actually save them?</span>
<span class="comment-copy">@KlausD. , Yeah, that makes sense seeing my code. But is there a sample snippet on how to save objects?</span>
<span class="comment-copy">it depends on what data structure you are trying to build</span>
