<div class="post-text" itemprop="text">
<p>I was taking a look into descriptors and how they are the mechanism used behind properties and functions. I'm a bit confused on how attributes are looked up when we're implementing a descriptor vs using properties.</p>
<pre><code>class NonDataDescriptor(object):
    def __get__(self, instance, owner):
        return 'non-data descriptor'

class DataDescriptor(object):
    def __get__(self, instance, owner):
        return 'data descriptor'
    def __set__(self, instance, value):
        pass

class MyClass(object):
    descriptor_one = NonDataDescriptor()
    descriptor_two = DataDescriptor()

    def __init__(self):
        self.descriptor_one = 'hello'
        self.descriptor_two = 'goodbye'


mc = MyClass()
print(mc.descriptor_one)
print(mc.descriptor_two)
</code></pre>
<p>The output is:</p>
<pre><code>hello
data descriptor
</code></pre>
<p>This makes sense because attribute lookup order is:</p>
<ol>
<li>data descriptors</li>
<li>instance attributes in <code>instance_obj.__dict__</code></li>
<li>non-data descriptors</li>
</ol>
<p>Since properties really just implement descriptors, I'm wondering why this order of attribute lookup doesn't seem to be respected. See the following:</p>
<pre><code>class MyClass(object):
    def __init__(self, fname, lname):
        self._fname = fname
        self._lname = lname

    @property
    def fullname(self):
        return '{} {}'.format(self._fname, self._lname)


mc = MyClass('Bob', 'John')
print(mc.fullname)
mc.__dict__['fullname'] = 'testing'
print(mc.__dict__)
print(mc.fullname)
</code></pre>
<p>The output is:</p>
<pre><code>Bob John
{'_fname': 'Bob', '_lname': 'John', 'fullname': 'testing'}
Bob John
</code></pre>
<p>I was expecting since the property object, <code>fullname</code>, is really just a non data descriptor, that the instance attribute <code>fullname</code>, would take precedence.</p>
<p>Also, functions are implemented as non-data descriptors as well, and this order of attribute lookup is respected:</p>
<pre><code>class Test:
    def __init__(self):
         self.display = 'display instance attribute'

    def display(self):
        print('display from instance method')

t = Test()
print(t.display)
</code></pre>
<p>The output is:</p>
<pre><code>display instance attribute
</code></pre>
<p>Can anyone explain why it's different with property objects?</p>
</div>
<div class="post-text" itemprop="text">
<p>The trick lies in the <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="nofollow noreferrer">descriptor protocol</a> here:</p>
<blockquote>
<ul>
<li>If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence.</li>
<li>If an instance’s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence.</li>
</ul>
</blockquote>
<pre><code>@property
def fullname(self):
    return '{} {}'.format(self._fname, self._lname)
</code></pre>
<p>This is a data descriptor, because the <code>property</code> object returned by the decorator always defines <code>__set__</code>, even if you don't define the setter (then <code>__set__</code> will raise an <code>AttributeError</code>, see <a href="https://github.com/python/cpython/blob/ac20e0f98d6727ba97a9575bfa2a11b2f6247c35/Objects/descrobject.c#L1382" rel="nofollow noreferrer">code here</a>).</p>
<pre><code>&gt;&gt;&gt; MyClass.fullname
&lt;property object at 0x7f30e3917958&gt;
&gt;&gt;&gt; MyClass.fullname.__set__
&lt;method-wrapper '__set__' of property object at 0x7f30e3917958&gt;
</code></pre>
<p>Thus, the data descriptor takes precedence.</p>
<p>Since the other examples already behave like you expect, this should be enough to complete your understanding.</p>
</div>
<div class="post-text" itemprop="text">
<p>@spectras already answered your question. I just want to give additional method to check on descriptor:</p>
<pre><code>In [517]: import inspect

In [518]: inspect.isdatadescriptor(type(mc).__dict__['fullname'])
Out[518]: True

In [519]: inspect.isdatadescriptor(MyClass.__dict__['fullname'])
Out[519]: True
</code></pre>
<p>So, @property always is data descriptor even you don't define <code>setter</code>. In that case, attribute assignment will raise <code>AttributeError: can't set attribute</code></p>
</div>
