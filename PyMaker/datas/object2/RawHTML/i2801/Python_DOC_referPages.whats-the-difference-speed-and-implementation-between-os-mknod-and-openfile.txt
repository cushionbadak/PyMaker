<div class="post-text" itemprop="text">
<h1>I want to create an empty file in python.</h1>
<p>Currently I am using <code>open('FILENAME', 'a').close()</code> but I've seen a lot of people use <code>os.mknod()</code>.</p>
<p>I did some research and it seems that <code>os.mknod()</code> uses tools from the OS you are using (hence its library name) and that <code>open()</code> is the "pythonic" way of creating an empty file.</p>
<blockquote>
<p>What is the difference, in terms of speed and implementation between these two methods?</p>
<p>Would you recommend any other, more reliable or faster method to create an empty file? </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>you probably want to create <em>regular files</em> with <code>mknod</code> like this:</p>
<pre><code>os.mknod(path, mode=0o600 | stat.S_IFREG)  # it seems that mode argument can be omitted for regular files
</code></pre>
<p>Well, don't since it's not portable (<a href="https://docs.python.org/3/library/os.html#os.mknod" rel="nofollow noreferrer">Unix only</a>). Stick to <code>open</code> when you can (even if <code>mknod</code> is probably called behind the scenes on unix when creating a file, the performance difference is very small)</p>
<p>You can check another Q&amp;A (<a href="https://stackoverflow.com/questions/26811662/creating-directory-with-mknod">Creating directory with mknod()</a>) where the answer hints at the non-portability of <code>os.mknod</code>.</p>
<p>Another possible difference (didn't check that point) is that if the file already exists, <code>mknod</code> may return an error/exception, while <code>open</code> happily opens the file if the permissions allow it.</p>
<p>Don't forget that methods from <code>os</code> package are OS dependent. Using them sometimes ties you up with the system you're running on (even if it's safe to assume that <code>os.remove</code> and <code>os.rename</code> are available, with - of course - implementation differences).</p>
<p>Also note that <code>open('FILENAME', 'a').close()</code> does not necessarily create an empty file. If the file exists and the permissions are right, it just does nothing (<code>a</code> is for <em>append</em>).</p>
<ul>
<li>To open with truncation and remain 100% portable, use <code>open('FILENAME', 'w').close()</code></li>
<li>A slightly faster way is to open in binary without buffering: <code>open('FILENAME', mode='wb', buffering=0).close()</code></li>
<li>For speed and reduced risks of non-portability: <code>os.open</code> is also an option since it's lower-level, and supported on all python environments that provide <code>open</code>: <code>os.close(os.open('FILENAME',os.O_CREAT|os.O_BINARY))</code></li>
</ul>
</div>
<span class="comment-copy">Your equivalence in semantics is wrong. I don’t know where you’ve seen mknod, but it is NOT for creating normal files. It’s for device files. So you are comparing apples to moonpies here.</span>
<span class="comment-copy">Thank you very much! :)</span>
<span class="comment-copy">Since the OP asked for "fast": It may be worth mentioning <code>open('FILENAME', mode='wb', buffering=0)</code> instead of <code>mode='w'</code>. For earlier 3.x (I can't remember if that means just 3.0, or 3.0-3.1), and for 2.x on systems with slow C stdio,  <code>os.open</code> will be even faster (fast enough for optimized C programs like <code>dd</code>), still without any of the problems of abusing <code>mknod</code>.</span>
<span class="comment-copy"><code>os.open</code>, yes. I'll edit, blatantly copying your good comment.</span>
