<div class="post-text" itemprop="text">
<p>I am using urllib to make a request and get some data returned:</p>
<pre><code>queryURL = "https://hazards.fema.gov/gis/nfhl/rest/services/CSLF/Prelim_CSLF/MapServer/3/query"
params = urllib.parse.urlencode({'f': 'json', 'geometryType': 'esriGeometryPolygon', 'outFields': 'OBJECTID, SHAPE, CSLF_ID, Area_SF', 'returnGeometry': 'false'})
</code></pre>
<p>I don't run into any problems until here:</p>
<pre><code>req = urllib.request.urlretrieve(queryURL, params)
</code></pre>
<p>then:</p>
<pre><code>urllib.request.urlopen(req)
</code></pre>
<p>At this point I get an error thrown - <code>AttributeError: 'tuple' object has no attribute 'timeout'.</code> I understand that it returning an immutable tuple because of the way I formatted the <code>params</code> variable. My question is, how do I get around it, so that I can start looking at my results?</p>
<pre><code>jsonResult = json.load(response)
</code></pre>
<p>As requested, here is the Traceback:</p>
<pre><code>AttributeError                            Traceback (most recent call last) &lt;ipython-input-68-cb3f46b2da76&gt; in &lt;module&gt;()
----&gt; 1 urllib.request.urlopen(req)

C:\Program Files\ArcGIS\Pro\bin\Python\envs\arcgispro-py3\lib\urllib\request.py in urlopen(url, data, timeout, cafile, capath, cadefault, context)
    221     else:
    222         opener = _opener
--&gt; 223     return opener.open(url, data, timeout)
    224 
    225 def install_opener(opener):

C:\Program Files\ArcGIS\Pro\bin\Python\envs\arcgispro-py3\lib\urllib\request.py in open(self, fullurl, data, timeout)
    515                 req.data = data
    516 
--&gt; 517         req.timeout = timeout
    518         protocol = req.type
    519 

AttributeError: 'tuple' object has no attribute 'timeout'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The core problem is that this code doesn't make any sense:</p>
<pre><code>req = urllib.request.urlretrieve(queryURL, params)
urllib.request.urlopen(req)
</code></pre>
<p><a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve" rel="nofollow noreferrer"><code>urlretrieve</code></a> makes the network request for you, saves the result in a local file, then returns "a tuple <code>(filename, headers)</code>".</p>
<p>You're trying to pass that <code>(filename, headers)</code> pair to <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen" rel="nofollow noreferrer"><code>urlopen</code></a>. But <code>urlopen</code> doesn't know what to do with that; it wants either a URL string or a <code>Request</code> object, and a <code>(filename, headers)</code> pair is neither of those.</p>
<p>Also, it's not clear what you'd even <em>want</em> it to do. You already fetched the request and saved the result in a file. Why would you want to fetch the same request again?</p>
<p>The simple answer is to just not use <code>urlretrieve</code> if you don't want it. (Especially since it's deprecated anyway…) Just do this:</p>
<pre><code>response = urllib.request.urlopen(queryURL, params)
</code></pre>
<p>Also, notice that I saved the result of <code>urlopen</code> in a variable. If you don't do that, you're just making a request and throwing away the response, which isn't very useful. And <code>jsonResult = json.load(response)</code> would have given you a <code>NameError</code>, because you never created anything named <code>response</code>.</p>
<hr/>
<p>However, there are still (at least) two other problems with your code.</p>
<p>First, as the docs for <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlencode" rel="nofollow noreferrer"><code>urlencode</code></a> say:</p>
<blockquote>
<p>If the resultant string is to be used as a data for POST … then it should be encoded to bytes, otherwise it would result in a <code>TypeError</code>.</p>
</blockquote>
<p>But you're not doing that.</p>
<p>Second, if you want to send url-encoded data as your POST body, you need to manually set the <code>Content-Type</code> header to say so.</p>
<p>Some servers will guess correctly even if you get this wrong, but that's really not something you should rely on.</p>
<hr/>
<p>Finally, all of this would be a whole lot easier if you just did what the top of the <a href="https://docs.python.org/3/library/urllib.request.html" rel="nofollow noreferrer"><code>urllib.request</code></a> docs suggest:</p>
<blockquote>
<p><strong>See also</strong>: The <a href="http://docs.python-requests.org/" rel="nofollow noreferrer">Requests package</a> is recommended for a higher-level HTTP client interface.</p>
</blockquote>
<p>With Requests, this whole thing becomes:</p>
<pre><code>queryURL = "https://hazards.fema.gov/gis/nfhl/rest/services/CSLF/Prelim_CSLF/MapServer/3/query"
params = {'f': 'json', 'geometryType': 'esriGeometryPolygon', 'outFields': 'OBJECTID, SHAPE, CSLF_ID, Area_SF', 'returnGeometry': 'false'}
jsonResult = requests.post(queryURL, data=params).json()
</code></pre>
</div>
<span class="comment-copy">Can you show us the traceback, rather than just the description of the error?</span>
<span class="comment-copy">OK, traceback added.</span>
<span class="comment-copy">That totally worked! I got into this problem looking at an example that was too dissimilar to my data. One last question: if I want to look at this data, what would be the best way to look at it? As there are potentially 1000's of rows (can't just <code>print(jsonResults)</code>), I was going to write to a file and do something like this: <code>file = open(path, 'w') for item in jsonResult: file.write(item + "\r\n")  file.close</code>. Is there a better way?</span>
<span class="comment-copy">@gwydion93 I’m not sure what the data look like, or what format you want. Is it just an array of strings (without any newlines in them) and you want a file of those strings, one per line? If so, what you’ve written will do that—but if you have or want something different, it won’t do something different.</span>
