<div class="post-text" itemprop="text">
<p>I'm new to python so I am building a simple program to parse YAML to JSON and JSON to YAML. </p>
<p>The <code>yaml2json</code> converts YAML to JSON on a single line, but a JSON validator says it is correct.</p>
<p>This is my code so far:</p>
<pre><code>def parseyaml(inFileType, outFileType):
   infile = input('Please enter a {} filename to parse: '.format(inFileType))
   outfile = input('Please enter a {} filename to output: '.format(outFileType))

   with open(infile, 'r') as stream:
       try:
           datamap = yaml.safe_load(stream)
           with open(outfile, 'w') as output:
               json.dump(datamap, output)
       except yaml.YAMLError as exc:
           print(exc)

    print('Your file has been parsed.\n\n')


def parsejson(inFileType, outFileType):
   infile = input('Please enter a {} filename to parse: '.format(inFileType))
   outfile = input('Please enter a {} filename to output: '.format(outFileType))

   with open(infile, 'r') as stream:
       try:
           datamap = json.load(stream)
           with open(outfile, 'w') as output:
               yaml.dump(datamap, output)
       except yaml.YAMLError as exc:
           print(exc)

   print('Your file has been parsed.\n\n')
</code></pre>
<p>An example of the original YAML vs. the new YAML</p>
<p>Original:</p>
<pre><code>inputs:
  webTierCpu:
    type: integer
    minimum: 2
    default: 2
    maximum: 5
    title: Web Server CPU Count
    description: The number of CPUs for the Web nodes
</code></pre>
<p>New:</p>
<pre><code>inputs:
  dbTierCpu: {default: 2, description: The number of CPUs for the DB node, maximum: 5,
    minimum: 2, title: DB Server CPU Count, type: integer}
</code></pre>
<p>It doesn't look like its decoding all of the JSON so I'm not sure where I should go next...</p>
</div>
<div class="post-text" itemprop="text">
<p>Your file is losing its formatting because the original <code>dump</code> routine
by default writes all leaf nodes in YAML flow-style, whereas your input is block style
all the way.</p>
<p>You are also losing the order of the keys, which is first because the JSON parser
uses dict, and second because <code>dump</code> sorts the output. </p>
<p>If you look at your intermediate JSON you already see that the key order is
gone at that point. To preserve that, use the new API to load your YAML
and have a special JSON encoder as a replacement for dump that can
handle the subclasses of <code>Mapping</code> in which the YAML is loaded similar to
<a href="https://docs.python.org/3/library/json.html#json.JSONEncoder.default" rel="nofollow noreferrer">this</a> example 
from the standard Python doc.</p>
<p>Assuming your YAML is stored in <code>input.yaml</code>:</p>
<pre><code>import sys
import json
from collections.abc import Mapping, Sequence
from collections import OrderedDict
import ruamel.yaml

# if you instantiate a YAML instance as yaml, you have to explicitly import the error
from ruamel.yaml.error import YAMLError


yaml = ruamel.yaml.YAML()  # this uses the new API
# if you have standard indentation, no need to use the following
yaml.indent(sequence=4, offset=2)

input_file = 'input.yaml'
intermediate_file = 'intermediate.json'
output_file = 'output.yaml'


class OrderlyJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Mapping):
            return OrderedDict(o)
        elif isinstance(o, Sequence):
            return list(o)
        return json.JSONEncoder.default(self, o)


def yaml_2_json(in_file, out_file):
    with open(in_file, 'r') as stream:
        try:
            datamap = yaml.load(stream)
            with open(out_file, 'w') as output:
                output.write(OrderlyJSONEncoder(indent=2).encode(datamap))
        except YAMLError as exc:
            print(exc)
            return False
    return True


yaml_2_json(input_file, intermediate_file)
with open(intermediate_file) as fp:
    sys.stdout.write(fp.read())
</code></pre>
<p>which gives:</p>
<pre><code>{
  "inputs": {
    "webTierCpu": {
      "type": "integer",
      "minimum": 2,
      "default": 2,
      "maximum": 5,
      "title": "Web Server CPU Count",
      "description": "The number of CPUs for the Web nodes"
    }
  }
}
</code></pre>
<p>You see that your JSON has the appropriate key order, which we also
need to preserve on loading. You can do that without subclassing
anything, by specifying the loading of JSON <em>objects</em> into the subclass of
<code>Mapping</code>, that the YAML parser is using internally, by providing<code>object_pairs_hook</code>.</p>
<pre><code>from ruamel.yaml.comments import CommentedMap


def json_2_yaml(in_file, out_file):
    with open(in_file, 'r') as stream:
        try:
            datamap = json.load(stream, object_pairs_hook=CommentedMap)
            # if you need to "restore" literal style scalars, etc.
            # walk_tree(datamap)
            with open(out_file, 'w') as output:
                yaml.dump(datamap, output)
        except yaml.YAMLError as exc:
            print(exc)
            return False
    return True


json_2_yaml(intermediate_file, output_file)
with open(output_file) as fp:
    sys.stdout.write(fp.read())
</code></pre>
<p>Which outputs:</p>
<pre><code>inputs:
  webTierCpu:
    type: integer
    minimum: 2
    default: 2
    maximum: 5
    title: Web Server CPU Count
    description: The number of CPUs for the Web nodes
</code></pre>
<p>And I hope that that is similar enough to your original input to be acceptable.</p>
<p>Notes:</p>
<ul>
<li><p>When using the new API I tend to use <code>yaml</code> as the name of the
instance of <code>ruamel.yaml.YAML()</code>, instead of <code>from ruamel import
yaml</code>. That however masks the use of <code>yaml.YAMLError</code> because the
error class is not an attribute of <code>YAML()</code></p></li>
<li><p>If you are developing this kind of stuff, I can recommend removing
at least the user input from the actual functionality. It should be
trivial to write your <code>parseyaml</code> and <code>parsejson</code> to call <code>yaml_2_json</code> resp.
<code>json_2_yaml</code>.</p></li>
<li><p>Any comments in your original YAML file will be lost, although
ruamel.yaml can load them. JSON originally did allow comments, but it is
not in the specification and no  parsers that I know can output comments.</p></li>
</ul>
<hr/>
<p>Since your real file has literal block scalars you have to use some magic to get those back.</p>
<p>Include the following functions that walk a tree, recursing into dict values and list elements and converting any line with an embedded newline to a type that gets output to YAML as a literal blocks style scalar in place (hence no return value):</p>
<pre><code>from ruamel.yaml.scalarstring import PreservedScalarString, SingleQuotedScalarString
from ruamel.yaml.compat import string_types, MutableMapping, MutableSequence

def preserve_literal(s):
    return PreservedScalarString(s.replace('\r\n', '\n').replace('\r', '\n'))

def walk_tree(base):
    if isinstance(base, MutableMapping):
        for k in base:
            v = base[k]  # type: Text
            if isinstance(v, string_types):
                if '\n' in v:
                    base[k] = preserve_literal(v)
                elif '${' in v or ':' in v:
                    base[k] = SingleQuotedScalarString(v)
            else:
                walk_tree(v)
    elif isinstance(base, MutableSequence):
        for idx, elem in enumerate(base):
            if isinstance(elem, string_types):
                if '\n' in elem:
                    base[idx] = preserve_literal(elem)
                elif '${' in elem or ':' in elem:
                    base[idx] = SingleQuotedScalarString(elem)
            else:
                walk_tree(elem)
</code></pre>
<p>And then do</p>
<pre><code>    walk_tree(datamap)
</code></pre>
<p>after you load the data from JSON. </p>
<p>With all of the above you should have only one line that differs in your <code>Wordpress.yaml</code> file.</p>
</div>
<span class="comment-copy">The parsed output looks like it contains all of the same data (barring different text in title and description, just contained within curly braces and in a different order.</span>
<span class="comment-copy">YAML is a superset of JSON. Or in other words: valid JSON is also valid YAML. (not the other way around)</span>
<span class="comment-copy">You cannot repoduce the original YAML, because linebreaks and order get lost when translating to JSON.</span>
<span class="comment-copy">There was an indentation error in your <code>parseyaml</code>, before the <code>except</code>.</span>
<span class="comment-copy">@Daniel I am not sure what you mean by 'linebreaks [...] get lost', but your conclusion seems to be invalid anyway. The intermediate JSON stream of course has an explicit order, just like the YAML source, and it is relatively simple to dump a Mapping with explicit order to JSON while preserving that order. Loading JSON preserving order is even more trivial.</span>
<span class="comment-copy">It is of course possible to load the JSON directly using the YAML parser as ruamel.yaml implements the YAML 1.2 specification. Then you only have to add <code>yaml.default_flow_style = False</code>, to get the block style output, as JSON input is always flow-style. You might consider doing that "cheating" though.</span>
<span class="comment-copy">Awesome! I have one issue though. I am using it to pass a config to the cloudconfig on an image. This is original.       cloudConfig: |         #cloud-config         hostname: wordpress-web         chpasswd:           list: |             ubuntu:VMware1!           expire: False  This is new with the conversion.       cloudConfig: "#cloud-config\nhostname: wordpress-web\nchpasswd:\n  list: |\n\         \    ubuntu:VMware1!\n  expire: False\nusers:\n  - name: ubuntu\n    passwd:\         \ \"$1$Lg35t2vk$MIw6mB5VSuZsztttRGlJe0\"\n    lock-passwd: False\n</span>
<span class="comment-copy">Link to the github:  <a href="https://github.com/tomburge/py-yaml-json-parser" rel="nofollow noreferrer">github.com/tomburge/py-yaml-json-parser</a></span>
<span class="comment-copy">I updated my answer</span>
<span class="comment-copy">Awesome. Thank you! Still learning so this is super helpful.</span>
