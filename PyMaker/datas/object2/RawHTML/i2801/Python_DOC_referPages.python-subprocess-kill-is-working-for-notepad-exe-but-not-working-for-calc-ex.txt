<div class="post-text" itemprop="text">
<p>OS: Windows 10
Python: 3.5.2
I am trying to open calc.exe do some actions and than close it.
Here is my code sample</p>
<pre><code>import subprocess, os, time
p = subprocess.Popen('calc.exe')
#Some actions
time.sleep(2)
p.kill()
</code></pre>
<p>So this is not working for calc.exe, it just opens the calculator, but does not close it, But same code is working fine for "notepad.exe".</p>
<p>I am guessing that there is a bug in subprocess lib for process kill method. so the notepad.exe process name in task manager is notepad.exe, but the calc.exe process name is calculator.exe, so I am guessing it is trying to kill by name and do not find it.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no bug in <code>subprocess.kill</code>. If you're really worried about that, just check <a href="https://github.com/python/cpython/blob/master/Lib/subprocess.py#L1747" rel="nofollow noreferrer">the source</a>, which is linked from <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">the docs</a>. The <code>kill</code> method just calls <code>send_signal</code>, which just calls <code>os.kill</code> unless the process is already done, and you can see <a href="https://github.com/python/cpython/blob/master/Modules/posixmodule.c#L6827" rel="nofollow noreferrer">the Windows implementation for that function</a>. In short: <code>subprocess.Process.kill</code> doesn't care what name the process has in the kernel's process table (or the Task Manager); it remembers the PID (process ID) of the process it started, and kills it that way.</p>
<p>The most likely problem is that, like many Windows apps, <code>calc.exe</code> has some special "single instance" code: when you launch it, if there's already a copy of <code>calc.exe</code> running in your session, it just tells that copy to come to the foreground (and open a window, if it doesn't have one), and then exits. So, by the time you try to <code>kill</code> it 2 seconds later, the process has already exited.</p>
<p>And if the actual running process is <code>calculator.exe</code>, that means <code>calc.exe</code> is just a launcher for the real program, so it <em>always</em> tells <code>calculator.exe</code> to come to the foreground, launching it if necessary, and then exits.</p>
<p>So, how can you kill the new calculator you started? Well, you can't, because you didn't start a new one. You can kill <em>all</em> <code>calc.exe</code> and/or <code>calculator.exe</code> processes (the easiest way to do this is with a third-party library like <a href="https://psutil.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>psutil</code></a>â€”see the examples on <a href="https://psutil.readthedocs.io/en/latest/#filtering-and-sorting-processes" rel="nofollow noreferrer">filtering</a> and then <code>kill</code> the process once you've found it), but that will kill any existing calculator process you had open before running your program, not just the new one you started. Since <code>calc.exe</code> makes it impossible to tell if you've started a new process or not, there's really no way around that.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one way to kill it, but it will close every open calculator.</p>
<p>It calls a no window command prompt and gives the command to close the Calculator.exe process.</p>
<pre><code>import subprocess, os, time
p = subprocess.Popen('calc.exe')
print(p)
#Some actions
time.sleep(2)
CREATE_NO_WINDOW = 0x08000000
subprocess.call('taskkill /F /IM Calculator.exe', creationflags=CREATE_NO_WINDOW)
</code></pre>
</div>
<span class="comment-copy">What are the <code>#Some actions</code> in your code? Are you talking to the calculator window via Windows messages (or <code>pyautogui</code> or something similar)? Or talking to a calculator instance via COM automation? If not, what do those actions have to do with the calculator window you just opened? If you can explain what you are trying to do, maybe we can explain a better way to do it.</span>
<span class="comment-copy">@abarnert I am doing automated testing of anti-malware system, and compiled a false positive signature for calc.exe, run the process, run the scan with my signature check that the process is marked as "malicious" than need to kill the process and do a rescan, so this is the whole story...</span>
<span class="comment-copy">I can confirm that multiple instances of calc.exe can run simultaneously, and this issue happens even when no instances of it are running before it begins the process in windows 10.</span>
<span class="comment-copy">@tgikal: Looking at the task manager, it looks like that's really one instance of calc.exe with multiple windows.</span>
<span class="comment-copy">That's what it is truly looking like is windows opens calc.exe as a new process "Calculator.exe" with the ability to run multiple calc.exe's in it.</span>
<span class="comment-copy">@tgikal On my Windows system (which isn't Windows 10), there's one <code>calc.exe</code> no matter how many windows it has open (and even if you close the last window, it doesn't always go away). Meanwhile, the OP reports that in his Windows 10 system, there is no <code>calc.exe</code> in the Task Manager, only <code>calculator.exe</code>. Either way, killing the process he started isn't going to do any good.</span>
<span class="comment-copy">Of course, it makes a simple task a pain.</span>
<span class="comment-copy">Here is another way with psutil.     import psutil     PROCNAME = "Calculator.exe"      for proc in psutil.process_iter():         # check whether the process name matches         if proc.name() == PROCNAME:             proc.kill()</span>
