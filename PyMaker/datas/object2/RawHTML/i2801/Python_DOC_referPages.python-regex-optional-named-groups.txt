<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/22937618/reference-what-does-this-regex-mean">Reference - What does this regex mean?</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm looking for a clean way to extract some data from a string using regex and the python <code>re</code> module. Each line of the string is of the form <code>key = value</code>. There are only certain keys that I'm interested in, but for some strings these keys may be missing. I can think of a few ways to do this by iterating over the string line by line, or by using <code>re.finditer()</code>, but what I'd really like to do is  use named groups and a single call to <code>re.match()</code>,  to end with a dictionary of groups using <code>.groupdict()</code> method of the returned match object. I can do that using named groups when all the groups are present, but it seems that if I make groups optional then they don't get matched even when present.</p>
<p>I'm probably missing something obvious, but is there a way to do this in a single regex or do I need a multistep process?</p>
<pre class="lang-py prettyprint-override"><code>import re

# trying to extract 'type', 'count' and 'destinations'.
# string1 has all keys and a single re.match works
# string2 is missing 'count'... any suggestions?

string1 = """
Name: default
type = Route
status = 0
count = 5
enabled = False
start_time = 18:00:00
end_time = 00:00:00
destinations = default
started = False
"""

string2 = """
Name: default
type = Route
status = 0
enabled = False
start_time = 18:00:00
end_time = 00:00:00
destinations = default
started = False
"""


pattern = re.compile(r"(?s).*type = (?P&lt;type&gt;\S*).*count = (?P&lt;count&gt;\S*).*destinations = (?P&lt;destinations&gt;\S*)")

m1 = re.match(pattern,string1)
# m1.groupdict() == {'type': 'Route', 'count': '5', 'destinations': 'default'}

m2 = re.match(pattern,string2)
# m2 == None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Check on this out.</p>
<pre><code>#python 3.5.2
import re

# trying to extract 'type', 'count' and 'destinations'.
# string1 has all keys and a single re.match works
# string2 is missing 'count'... any suggestions?

string1 = """
Name: default
type = Route
status = 0
count = 5
enabled = False
start_time = 18:00:00
end_time = 00:00:00
destinations = default
started = False
"""

string2 = """
Name: default
type = Route
status = 0
enabled = False
start_time = 18:00:00
end_time = 00:00:00
destinations = default
started = False
"""

pattern = re.compile(r"""
(?mx)\A
(?=(?:[\s\S]*?^\s*type\s*=\s*(?P&lt;type&gt;.*)$)?)
(?=(?:[\s\S]*?^\s*count\s*=\s*(?P&lt;count&gt;.*)$)?)
(?=(?:[\s\S]*?^\s*destinations\s*=\s*(?P&lt;destinations&gt;.*)$)?)
""")

m1 = re.match(pattern, string1)
print (m1.groupdict())

m2 = re.match(pattern, string2)
print (m2.groupdict())
</code></pre>
<p>To try it online, please click <a href="http://rextester.com/GRM47776" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could solve this with one line of simple regular expression.</p>
<pre><code>&gt;&gt; dict(re.findall(r'^(type|count|destinations) = (\S*)$', string1, re.MULTILINE))
{'count': '5', 'type': 'Route', 'destinations': 'default'}

&gt;&gt; dict(re.findall(r'^(type|count|destinations) = (\S*)$', string2, re.MULTILINE))
{'type': 'Route', 'destinations': 'default'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use something similar to the following dictionary comprehension, which splits and filters the key-value pairs based on an input tuple of desired field names:</p>
<pre><code>import re

def regexandgroup(instr: str, savekeys: tuple):
    exp = '^(\w+)[ \t:=]+([\w:]+)$'
    match = re.findall(exp, instr, re.MULTILINE)

    return {group[0]: group[1] for group in match if group[0] in savekeys}
</code></pre>
<p>Which gives us:</p>
<pre><code>&gt;&gt; print(regexandgroup(string1, ('type', 'count', 'destinations')))
{'type': 'Route', 'count': '5', 'destinations': 'default'}

&gt;&gt; print(regexandgroup(string2, ('type', 'count', 'destinations')))
{'type': 'Route', 'destinations': 'default'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You didn't really specify if any field can be missing or if count is the only field that could be missing. However, this pattern will match all 3 cases that you suggested and it will store them in named capture groups.</p>
<p><code>type = (?&lt;type&gt;\S*)|count = (?&lt;count&gt;\d+)|destinations = (?&lt;destinations&gt;\S*)</code></p>
<p><a href="https://regex101.com/r/B7PDCx/4" rel="nofollow noreferrer">Demo</a></p>
<p><code>|</code> just means or, so you're looking for <code>type = ...</code> OR <code>count = ...</code> OR <code>destinations = ...</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Just extract the key/value pairs, then you can either ignore the additional keys, or else add <code>â€¦ if x.split(' = ')[0] in wanted_keys</code> to filter them. Use <code>setdefault</code> if you want to fill in missing keys.</p>
<pre><code>&gt;&gt;&gt; dict(x.split(' = ') for x in string1.strip().splitlines()[1:])
{'status': '0', 'count': '5', 'started': 'False', 'start_time': '18:00:00', 'enabled': 'False', 'end_time': '00:00:00', 'type': 'Route', 'destinations': 'default'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not use <code>pandas</code> to do things all at once?  The following uses the regex from @andrei-odegov</p>
<pre><code>import pandas as pd


# create a Series object from your strings
s = pd.Series([string1, string2])

regex = r"""
    (?mx)\A
    (?=(?:[\s\S]*?^\s*type\s*=\s*(?P&lt;type&gt;.*)$)?)
    (?=(?:[\s\S]*?^\s*count\s*=\s*(?P&lt;count&gt;.*)$)?)
    (?=(?:[\s\S]*?^\s*destinations\s*=\s*(?P&lt;destinations&gt;.*)$)?)
"""

# return a DataFrame which contains your results
df = s.str.extract(regex, expand=True)

print(df)


    type count destinations
0  Route     5      default
1  Route   NaN      default
</code></pre>
</div>
<span class="comment-copy">Does it have to be a regex? Seems like it would be easier to split the lines with something like <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow noreferrer"><code>splitlines</code></a> and parse the resultant list into a dictionary.</span>
<span class="comment-copy">There's definitely a lot of ways it could be done, with iteration and <code>splitlines</code>, or something like <code>re.finditer(r'(?P&lt;key&gt;.*) = (?P&lt;value&gt;.*)',string)</code>,  I was really just interested in if theres a concise way to do it with a single regex to avoid extra work parsing it all to a dictionary.</span>
<span class="comment-copy">Putting together and maintaining an extremely long and/or delicate regex seems like more work than at most 9 lines of parsing the same string into a dictionary.</span>
<span class="comment-copy">It might end up being more complicated for sure, but I was thinking of a function to build up the required regex from a list of desired keys to keep it maintainable. Having spent a few hours trying to figure out the right regex, I kind of want to know for the sake of knowing if its possible at this point.</span>
<span class="comment-copy">So, can all of these keys be missing, i.e. are they all optional? If yes, then it makes sense to use the solution like below. Or, you may use something like <code>dict(re.findall(r'(key1|key2|keyN)\s*=\s*(.+)',s))</code></span>
<span class="comment-copy">why does this work?, what does "(?mx)\A" do?, why do you need "?="</span>
<span class="comment-copy">@jcr, an exhaustive explanation can be found here <a href="https://regex101.com/r/maviqZ/1" rel="nofollow noreferrer">regex101.com/r/maviqZ/1</a>.</span>
<span class="comment-copy">Thats a really nice solution to the extracting the values, thanks! I guess if savekeys was a set it'd be a little more efficient as the size of the required keys grows.</span>
<span class="comment-copy">@excaza: possibly worth noting that <code>[\s:=]+</code> will match a single newline character, so the pattern will match two consecutive lines with one word each. It might be better to use <code>[ \t:=]+</code>. (Also, <code>:</code> isn't in <code>\w</code>, but the time fields aren't in the list so I guess it doesn't matter.)</span>
<span class="comment-copy">@rici Shouldn't matter much in this context but I've incorporated the former, thanks! For the latter, <code>:</code> is already in the second capture group.</span>
<span class="comment-copy">@excaza: ah, so it is...</span>
