<div class="post-text" itemprop="text">
<p>Consider this code snippet:</p>
<pre><code>global open
print(open)
</code></pre>
<p>which gives the following result:</p>
<pre><code>&lt;built-in function open&gt;
</code></pre>
<p>My question is: Does the name <em>open</em> belong to the built-in or the global scope in this example? </p>
<p>I thought that the global declaration will force the name <em>open</em> to be mapped to the global scope (and, thus, will lead us to an error), which is not happening here. Why?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, the direct answer:</p>
<p>The name <code>open</code> belongs to the top-level namespace. Which essentially means "look up in globals, fallback to builtins; assign to globals". </p>
<p>Adding <code>global open</code> just forces it to belong to the top-level namespace, where it already was. (I'm assuming this is top-level code, not inside a function or class.)</p>
<p>Does that seem to contract what you read? Well, it's a bit more complicated.</p>
<hr/>
<p>According to <a href="https://docs.python.org/3/reference/simple_stmts.html#the-global-statement" rel="nofollow noreferrer">the reference docs</a>:</p>
<blockquote>
<p>The <code>global</code> statement is a declaration which holds for the entire current code block. It means that the listed identifiers are to be interpreted as globals. </p>
</blockquote>
<hr/>
<p>But, despite what other parts of the docs seem to imply, "interpreted as globals" doesn't actually mean "searched in the global namespace", but "searched in the top-level namespace", as documented in <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">Resolution of names</a>:</p>
<blockquote>
<p>Names are resolved in the top-level namespace by searching the global namespace, i.e. the namespace of the module containing the code block, and the builtins namespace, the namespace of the module <code>builtins</code>. The global namespace is searched first. If the name is not found there, the <code>builtins</code> namespace is searched.</p>
</blockquote>
<p>And "as globals" means "the same way that names in the global namespace are looked up", aka "in the top-level namespace".</p>
<p>And, of course, assignment to the top-level namespace always goes to globals, not builtins. (That's why you can shadow the builtin <code>open</code> with the global <code>open</code> in the first place.)</p>
<hr/>
<p>Also, notice that, as explained in the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer"><code>exec</code> and <code>eval</code></a> docs, even <em>this</em> isn't quite true for code run through <code>exec</code>:</p>
<blockquote>
<p>If the globals dictionary does not contain a value for the key <code>__builtins__</code>, a reference to the dictionary of the built-in module <code>builtins</code> is inserted under that key. That way you can control what builtins are available to the executed code by inserting your own <code>__builtins__</code> dictionary into globals before passing it to <code>exec()</code>.</p>
</blockquote>
<p>And <code>exec</code> is, ultimately, how modules and scripts get executed.</p>
<p>So, what <em>really</em> happens—at least by default—is that the global namespace is searched; if the name is not found, the global namespace is searched for a <code>__builtins__</code> value; if that's a module or a mapping, it's searched.</p>
<hr/>
<p>If you're curious how this works in CPython in particular:</p>
<ul>
<li>At compile time:

<ul>
<li>The compiler builds a symbol table for a function, separating names out into freevars (nonlocals), cellvars (locals that are used as nonlocals by nested functions), locals (any other locals) and globals (which of course technically means "top-level namespace" variables). This is where the <code>global</code> statement comes into play: it forces the name to be added to the global symbol table instead of a different one. </li>
<li>Then it compiles the code, and emits <code>LOAD_GLOBAL</code> instructions for the globals. (And it stores the various names in tuple members on the code object, like <code>co_names</code> for globals and <code>co_cellvars</code> for cellvars and so on.)</li>
</ul></li>
<li>At runtime:

<ul>
<li>When a function object gets created from compiled code, it gets <code>__globals__</code> attached to it as an attribute.</li>
<li>When a function gets called, its <code>__globals__</code> becomes the <code>f_globals</code> for the frame.</li>
<li>The interpreter's eval loop then handles each <code>LOAD_GLOBAL</code> instruction by doing exactly what you'd expect with that <code>f_globals</code>, including the fallback to <code>__builtins__</code> as described in the <code>exec</code> docs.</li>
</ul></li>
</ul>
</div>
<span class="comment-copy">The built-ins aren't really a separate scope that anything looks at specifically; it's more of an automatic fallback when a name isn't found in the current global scope.  The exact same bytecode is generated for a function accessing a built-in name as one accessing a global name.</span>
<span class="comment-copy">This is a good question, because, while the docs are clear about this if you know exactly where to look, almost nobody knows exactly where to look, and you can easily be misled by the wording in other parts…</span>
