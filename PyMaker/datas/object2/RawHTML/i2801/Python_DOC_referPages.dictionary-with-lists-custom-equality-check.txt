<div class="post-text" itemprop="text">
<p>Say, I have two lists:</p>
<p><code>a = [1,2,3]</code>
and <code>b = [2,3,1]</code></p>
<p>If I do a <code>a == b</code> it returns <code>False</code>,</p>
<p>If I check <code>sorted(a) == sorted(b)</code>, it returns <code>True</code>.</p>
<p>Now, I have two objects:</p>
<p><code>obj1 = {'a': 1, 'b': 2, 'c': [1, 2]}</code>
and <code>obj2 = {'b': 2, 'a': 1, 'c': [1, 2]}</code></p>
<p><code>obj1 == obj2</code> is True, irrespective of the order of keys.</p>
<p>But if <code>obj2 = {'b': 2, 'a': 1, 'c': [2, 1]}</code></p>
<p>how do I test the equality? Obviously, <code>obj1 == obj2</code> returns False. <code>sorted(obj1)</code> will have <code>['a', 'b', 'c']</code>, so <code>sorted(obj1) == sorted(obj2)</code> is kind of waste check. </p>
<p>I should have probably overridden the equality method for the object, or use some library. Is, is there any way to write idiomatic python code for deep equality?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>sort</code> each element in the dict if it is of type <code>list</code> and then compare</p>
<pre><code>&gt;&gt;&gt; def sorted_element_dict(d):
...     return {k:sorted(v) if isinstance(v, list) else v for k,v in d.items()}
...
&gt;&gt;&gt; sorted_element_dict(obj1) == sorted_element_dict(obj2)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are only interested in an equality check, consider using <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all</code></a>. You could just apply a custom comparator to all the dictionary values:</p>
<pre><code>def check_equal(d1, d2):
    if d1.keys() != d2.keys():
        return False
    return all(sorted(v) == sorted(d2[k]) if isinstance(v, list) else v == d2[k] for k, v in d1.items())
</code></pre>
<p>A more elegant way might be to factor out the comparator into a separate function and check against something more general, like <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" rel="nofollow noreferrer"><code>collections.abc.Sequence</code></a>:</p>
<pre><code>def check_equal(d1, d2):
    if d1.keys() != d2.keys():
        return False
    def cmp(v1, v2):
        if isinstance(v1, Sequence) and isinstance(v2, sequence):
            return sorted(v1) == sorted(v2)
        return v1 == v2
    return all(cmp(v, d2[k]) for k, v in d1.items())
</code></pre>
<p>This has the advantage of <em>not</em> storing all the intermediate sorted products. If, on the other hand, you need to do the comparison frequently, it may be better to transform your dictionaries before using regular <code>==</code>:</p>
<pre><code>def normalize(d):
    for k, v in d.items():
        if isinstance(v, Sequence):
            d[k] = sorted(v)
</code></pre>
<p>Notice that I used a loop instead of a comprehension here. That way, your dictionary is transformed in-place, rather than allocating a whole new hash table.</p>
</div>
<span class="comment-copy">so what is your definition of equality for this?</span>
<span class="comment-copy">I need <code>obj1 == obj2</code> return True, if <code>obj1 = {'a': 1, 'b': 2, 'c': [1, 2]}</code> and <code>obj2 = {'b': 2, 'a': 1, 'c': [2, 1]}</code></span>
<span class="comment-copy"><code>sorted(['a', 'b', 'c'])</code> isn't as wasteful as you might think since Python's timsort uses a clever hybrid sorting algorithm that performs well on already sorted (or almost sorted) data</span>
<span class="comment-copy">Also use <code>isinstance</code> instead of <code>type</code>.</span>
<span class="comment-copy">@timgeb. I would prefer <code>sorted</code> as the list may contain unhashable elements</span>
<span class="comment-copy">@timgeb And the list may contain duplicates (which sets cannot)</span>
<span class="comment-copy">@timgeb, convert to set is wrong because sets cannot have duplicates while list can do</span>
<span class="comment-copy">There is no reason to use <code>lambda</code> here, it should be <code>def</code></span>
