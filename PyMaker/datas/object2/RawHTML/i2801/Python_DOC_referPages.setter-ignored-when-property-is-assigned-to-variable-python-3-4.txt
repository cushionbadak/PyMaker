<div class="post-text" itemprop="text">
<p>I'm creating a Verdict class which will evaluate to true until it is set false after which it always evaluates false even if you set it to true. The only way I could think of to do that would be to have a property and a setter.</p>
<p>It works, but for simplicity rather than having:</p>
<pre><code>v = Verdict()
v.verdict = ...
v.verdict = ...
v.verdict = ...
</code></pre>
<p>I thought I could do:</p>
<pre><code>v = Verdict().verdict
v = ...
v = ...
v = ...
</code></pre>
<p>But it seems that v in the second case is the attribute directly, and is ignoring the setter.</p>
<pre><code>class Verdict():
    def __init__(self):
        self.__verdict = True

    @property
    def verdict(self):
        return self.__verdict

    @verdict.setter
    def verdict(self, value):
        if self.__verdict is True:
            self.__verdict = value

    def __bool__(self):
        return self.__verdict

class A():
    v = Verdict().verdict
    y = Verdict()

    def foo(cls):
        cls.y = False
        cls.y = True # Uses setter and stays false
        cls.v = False
        cls.v = True # should use setter and stay false but doesn't 
</code></pre>
<p>Is there a way to fix this, or a better method to achieve the Verdict?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't avoid using the <code>v.verdict = ...</code> syntax.</p>
<p>This is because properties require attribute access in order to work. Properties are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>, and the descriptor protocol only takes effect on attribute access.</p>
<p>If you store a property (or, more generally, a descriptor) in a variable, you've effectively robbed it of its functionality. Accessing a variable is just a name lookup, and assigning to a variable is just binding a value to a name. It's not possible to make an assignment like <code>v = ...</code> trigger your setter.</p>
</div>
<span class="comment-copy">Would you expect <code>y</code> to change if you did <code>x = y; x = 3</code>?</span>
<span class="comment-copy">Are you coming to Python from C++? If so, explaining why things are different is a bit more involved (unless you can just forget what you learned from C++ and think of this like a new programmer).</span>
<span class="comment-copy">Anyway,. <code>v = &lt;something&gt;</code> just says "make <code>v</code> a name for the value you get by evaluating <code>&lt;something&gt;</code>. This is done by asking the appropriate (local or global) namespace to store <code>&lt;something&gt;</code> under the name <code>v</code>. But <code>v.verdict = &lt;something&gt;</code> means "make <code>v.verdict</code> a name for the value you get by evaluating <code>&lt;something&gt;</code>", which can only be done by asking <code>v</code> to do it, which is done by calling <code>v.__setattr__('verdict', &lt;the value&gt;)</code>.</span>
<span class="comment-copy">@user2357112. IDK If x is a pointer and y is an address, then yes. Stuffs weird for a C++ programmer. I can assign a Python variable to a function, so is x then a variable or a function pointer? I was expecting that if I assigned x to a parameter then it would be a pointer to the parameter, and not the underlying attribute. But it seems not. I don't think I understand what a parameter actually is, I think I need to read about decorators.</span>
<span class="comment-copy">@abarnet My logic was:     <code>Verdict().verdict = True</code>    &lt;-calls the setter for verdict. So     <code>v = Verdict().verdict</code> <code>v = True</code>      &lt;- v evaluates to Verdict().verdict and calls the setter for verdict. But instead it seems    <code>v = True</code>      &lt;- v evaluates to Verdict().verdict and sets the attribute verdict</span>
<span class="comment-copy">Thanks. I need to read about what descriptors actually are.</span>
