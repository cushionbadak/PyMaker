<div class="post-text" itemprop="text">
<p>I have a list that looks like this:</p>
<pre><code>lst = [1,2,3, etc]
</code></pre>
<p>I can successfully iterate over this list and pass the IDs into an API. However the API breaks after certain point in regards to number of Ids I am passing. </p>
<p>I went ahead and broke the list into chunks of 50 using this code: </p>
<pre><code>def chunks(l, n):
    # For item i in a range that is a length of l,
    for i in range(0, len(l), n):
        # Create an index range for l of n items:
        yield l[i:i+n]

a = list(chunks(lst, 50))
</code></pre>
<p>The <code>a</code> variable is list of list that looks like this: </p>
<pre><code>[[1,2,3][4,5,6]]
</code></pre>
<p>How do I iterate over the list of list, passing individual Ids into the API code (below), while pausing the code for 10seconds after every chunk? </p>
<p>In addition, if the API breaks, is there anyway I can force the API to continue rest of the code ? Not a requirement for now, so this is optional. </p>
<p>API code: </p>
<pre><code>lst1=[]
for i in lst:
    #print (row)
    url = 'url/Id={}'.format(i)
    r = requests.get(url).text
    lst1.append(xml_data1)
    #time.sleep(1)
    print(xml_data1)
</code></pre>
<p>Thank you in advance. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a double <code>for</code> loop with use of the <code>sleep</code> function after execution of the inner loop. Here's an example:</p>
<pre><code>lst1 = []
for chunk in a:
    for id in chunk:
        url = 'url/Id={}'.format(id)
        xml_data = requests.get(url).text
        lst1.append(xml_data)
     sleep(10) # will pause execution for 10 seconds
</code></pre>
<p>To answer your second question about how to continue execution if the API throws an error, you can use <code>try/except</code>. Code that might throw an error goes in the <code>try</code> block and if an error is thrown, execution moves to the <code>except</code> block, which specifies how to proceed. If you wrap your code in a function this can be made a bit easier.</p>
<p>I find it helpful to track the number of times you've tried calling for a specific <code>id</code> with a keyword argument that can be used for exponential backoff -- where you wait for longer amounts of time depending on how many times you've tried.</p>
<p>Here is an example building on the above code:</p>
<pre><code>def get_data_on_id(id, try_num=1):
    url = 'url/Id={}'.format(id)
    try:
        return requests.get(url).text
    except:
        sleep(2**try_num) # exponential backoff
        return get_data_on_id(id, try_num=try_num + 1)

lst1 = []
for chunk in a:
    for id in chunk:
        xml_data = get_data_on_id(id)
        lst1.append(xml_data)
    sleep(10)
</code></pre>
<p>The code above is largely the same as the code before it, but the request logic is wrapped in the <code>get_data_on_id</code> function, which contains the <code>try/except</code> blocks. If an error is thrown when requesting the <code>url</code>, the function will wait for <code>2^try_num</code> seconds and then try again.</p>
<p>You might also want to <code>except</code> specific errors and handle them differently (or just to be explicit so you only <code>except</code> errors you are prepared to handle). Here are the docs on <code>try/except</code>: <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/errors.html</a></p>
</div>
<span class="comment-copy">this works! thank you very much!</span>
