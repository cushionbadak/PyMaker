<div class="post-text" itemprop="text">
<p>My problem is to redefine <code>+</code>-operator evaluating expression with ast.
I have a list of expressions and it simple to resolve with eval():</p>
<pre><code>&gt;&gt;&gt; expr = '1+2*3**4/5'
&gt;&gt;&gt; print(eval(expr))
33.4
</code></pre>
<p>But I like to redefine the <code>+</code>-operator (addition) for list and dict like this:</p>
<pre><code>expr = '[1,2,3]+[4,5,6]'
</code></pre>
<p>regular result with eval is </p>
<blockquote>
<p>[1, 2, 3, 4, 5, 6]</p>
</blockquote>
<p>but I'd like to have</p>
<blockquote>
<p>[5, 7, 9] </p>
</blockquote>
<p>like it is in R-language.</p>
<p>The same should work also for dictionaries like this:</p>
<pre><code>expr = "{'a':1, 'b':2} + {'a':3, 'b':4}"
</code></pre>
<p>I'd like to have</p>
<blockquote>
<p>{'a': 4, 'b': 6}</p>
</blockquote>
<p>In short words, I think to replace ordinary add function, that when operands are list or dict correct actions.</p>
<p>I tried to use <code>ast</code> and <code>NodeTransformer</code> but without success. Someone can help me?</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot overload the <code>__add__</code> methods of builtin classes (like <code>list</code> and <code>dict</code>), even with the <code>ast</code> module. You <em>can</em>, however, rewrite all additions like <code>x + y</code> to a function call like <code>your_custom_addition_function(x, y)</code>.</p>
<p>This is, in essence, a 3-step process:</p>
<ol>
<li>Parse the input expression with <a href="https://docs.python.org/3/library/ast.html#ast.parse" rel="nofollow noreferrer"><code>ast.parse</code></a>.</li>
<li>Use a <a href="https://docs.python.org/3/library/ast.html#ast.NodeTransformer" rel="nofollow noreferrer"><code>NodeTransformer</code></a> to rewrite all additions to function calls.</li>
<li>Parse the source code of your custom addition function and add it to the abstract syntax tree obtained in step 1.</li>
</ol>
<h1>Code</h1>
<pre><code>import ast


def overload_add(syntax_tree):
    # rewrite all additions to calls to our addition function
    class SumTransformer(ast.NodeTransformer):
        def visit_BinOp(self, node):
            lhs = self.visit(node.left)
            rhs = self.visit(node.right)

            if not isinstance(node.op, ast.Add):
                node.left = lhs
                node.right = rhs
                return node

            name = ast.Name('__custom_add', ast.Load())
            args = [lhs, rhs]
            kwargs = []
            return ast.Call(name, args, kwargs)

    syntax_tree = SumTransformer().visit(syntax_tree)
    syntax_tree = ast.fix_missing_locations(syntax_tree)

    # inject the custom addition function into the sytnax tree
    code = '''
def __custom_add(lhs, rhs):
    if isinstance(lhs, list) and isinstance(rhs, list):
        return [__custom_add(l, r) for l, r in zip(lhs, rhs)]

    if isinstance(lhs, dict) and isinstance(rhs, dict):
        keys = lhs.keys() | rhs.keys()
        return {key: __custom_add(lhs.get(key, 0), rhs.get(key, 0)) for key in keys}

    return lhs + rhs
    '''
    add_func = ast.parse(code).body[0]
    syntax_tree.body.insert(0, add_func)

    return syntax_tree

code = '''
print(1 + 2)
print([1, 2] + [3, 4])
print({'a': 1} + {'a': -2})
'''
syntax_tree = ast.parse(code)
syntax_tree = overload_add(syntax_tree)
codeobj = compile(syntax_tree, 'foo.py', 'exec')
exec(codeobj)

# output:
# 3
# [4, 6]
# {'a': -1}
</code></pre>
<h1>Caveats</h1>
<ul>
<li>The addition function will be added to the global scope with the name <code>__custom_add</code> - it is accessible like any other global function and can possibly be overwritten, shadowed, deleted, or otherwise tampered with.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Make your own list class and define the addition operator on it:</p>
<pre><code>class MyKindOfList(list):
    def __add__(self, other):
        return MyKindOfList(a + b for a, b in zip(self, other))
</code></pre>
<p>Then you can do this:</p>
<pre><code>x = MyKindOfList([1, 2, 3])
y = MyKindOfList([4, 5, 6])

print (x + y)  # prints [5, 7, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>starting from suggestion of Aran-Fey and reading something from <a href="http://www.dalkescientific.com/writings/diary/archive/2010/02/22/instrumenting_the_ast.html" rel="nofollow noreferrer">this link</a> I wrote a more readable code to resolve the problem</p>
<pre><code>import ast
from itertools import zip_longest

def __custom_add(lhs, rhs):
    if isinstance(lhs,list) and isinstance(rhs, list):
        return [__custom_add(l, r) for l, r in zip_longest(lhs, rhs, fillvalue=0)]

    if isinstance(lhs, dict) and isinstance(rhs, dict):
        keys = lhs.keys() | rhs.keys()
        return {key: __custom_add(lhs.get(key,0), rhs.get(key,0)) for key in keys}

    return lhs + rhs

class SumTransformer(ast.NodeTransformer):

    def visit_BinOp(self, node):
        if isinstance(node.op, ast.Add):
            new_node = ast.Call(func=ast.Name(id='__custom_add', ctx=ast.Load()),
                            args=[node.left, node.right],
                            keywords = [],
                            starargs = None, kwargs= None
                            )
            ast.copy_location(new_node, node)
            ast.fix_missing_locations(new_node)
            return new_node

        return node

expr = [
    '(2 + 3 * 4)/2',
    '[1, 2] + [3, 4]',
    "{'a': 1} + {'a': -2}"
    ]


for e in expr:
    syntax_tree = ast.parse(e, mode='eval')
    syntax_tree = SumTransformer().visit(syntax_tree)
    res = eval(compile(syntax_tree, '&lt;ast&gt;', 'eval'))
    print(res)

# results

# 7.0
# [4, 6]
# {'a': -1}
</code></pre>
<p>Thanks to all people helped me</p>
</div>
<span class="comment-copy">May I ask why? I wouldn't think it's a good idea to have your own variant of Python that's not interoperable with standard Python.</span>
<span class="comment-copy">I'd say you should subclass <code>list</code> and <code>dict</code> and overwrite the existing <code>__add__</code>.</span>
<span class="comment-copy">Thanks, this is the solution I'm searching for. I'll try to modify source to use compile to a   &lt;string&gt; and mode 'eval' because I will use only expressions.</span>
<span class="comment-copy">It's not exactly what I'm looking for. The problem is this: I have a file with a lot of expressions that I can solve with eval() function. The answer of Aran-Frey is the right way</span>
