<div class="post-text" itemprop="text">
<p>I'm using the asynchronous functionality of Python. After learn how to use it.</p>
<p>I updated my code to work with data analysis. It works fine in python3.5. 
However, when I updated from Python3.5 to Python3.6, there is Runtime Error. </p>
<p>My usage is very simple. </p>
<p>First, create an asynchronous usage in a file, named 'runner.py',like this:</p>
<pre><code>import asyncio as aio
def async_usage():
    loop = aio.get_event_loop()
    task = loop.create_task(some_task())
    loop.run_until_comeplete(task)
</code></pre>
<p>Then, import it from another file, named "main.py"</p>
<pre><code>import async_usage from runner
async_usage()
</code></pre>
<p>When I run main.py then Runtime Error occurrs. </p>
<blockquote>
<p>The error says that this event loop is already running.</p>
</blockquote>
<p>By the way, these code and running are finished in jupyter notebook </p>
<p>How can I avoid things like this?</p>
<p>I've tried to add code like <code>loop.stop();loop.close()</code> before I run it, however, it can't work.</p>
<p>I know that only one loop can exit simultaneously, however, I didn't run the loop in runner.py. </p>
<p>How can I solve this?</p>
<p>thx.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are running on windows platform.</p>
<p>loop = asyncio.get_event_loop() will create a _WindowsSelectorEventLoop object.</p>
<p>the running default is True. so you should remove "loop.run_until_complete(some_task())"</p>
<p>&lt;_WindowsSelectorEventLoop running=True closed=False debug=False&gt;</p>
<p>If you run on linux platform, you will get a _UnixSelectorEventLoop object.</p>
<p>&lt;_UnixSelectorEventLoop running=False closed=False debug=False&gt;</p>
<p>That will be ok.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks gays above who offer ur answer. And I figure it out.
There is nothing to do with my code, but to do with the notebook.
If u are using the notebook, run the code below, you will find out that the current loop is running.</p>
<pre><code>import asyncio as aio
default_loop = aio.get_event_loop()
if default_loop.is_running():
    print("The current loop is running!")
</code></pre>
<p>For further proving, if you then run the code below, your notebook will shutdown</p>
<pre><code>default_loop.stop()
</code></pre>
<p>Then the notebook shell would automatically restart, and what was in your current notebook in the memory is gone.</p>
<p>If u do this in the python shell, nothing would happen.</p>
<p>Therefor, what needed to do is not to use <code>run_until_complete</code> and the task will automatically run through the current loop.</p>
</div>
<span class="comment-copy">See <a href="https://docs.python.org/3/library/asyncio-task.html#task" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-task.html#task</a>. The task returned by <code>create_task</code> is already running and does not need to be handed over to a event loop.</span>
<span class="comment-copy">Thanks for ur replying. Please note that, <code>task</code> is created by the loop rather that asyncio module. Due to the doc, <code>task</code> created by loop can be used by the loop.See: <a href="https://docs.python.org/3/library/asyncio-eventloop.html#tasks" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-eventloop.html#tasks</a> .</span>
<span class="comment-copy">Both doc snippets say that the execution of the task is automatically scheduled, or in other words, that you don't have to be passed to <code>run_until_complete</code> because they are already running. You somehow also come to that bottom line in your own answer.</span>
<span class="comment-copy">Yes, actually, my further code need the result of other tasks and this is the reason why I want to use <code>run_until_complete</code> to wait for tasks to complete. Anyway, I solved this demand by <code>subprocess</code> and use a json file to transfer the result. The main process can wait for the subprocess. This is what I want.</span>
<span class="comment-copy">Thanks dude.Ur solution works. And I answer the question with more details.</span>
