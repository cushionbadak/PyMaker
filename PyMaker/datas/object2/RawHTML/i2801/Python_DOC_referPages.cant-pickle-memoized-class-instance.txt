<div class="post-text" itemprop="text">
<p>Here is the code I am using</p>
<pre><code>import funcy

@funcy.memoize
class mystery(object):

    def __init__(self, num):
        self.num = num

feat = mystery(1)

with open('num.pickle', 'wb') as f:
    pickle.dump(feat,f)
</code></pre>
<p>Which is giving me the following error:</p>
<pre><code>PicklingError: Can't pickle &lt;class '__main__.mystery'&gt;: it's not the 
same object as __main__.mystery
</code></pre>
<p>I am hoping to 1) understand why this is happening, and 2) find a solution that allows me to pickle the object (without removing the memoization). Ideally the solution would not change the call to pickle. </p>
<p>Running python 3.6 with funcy==1.10</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you've applied a decorator designed for functions to a class. The result is not a class, but a function that wraps up a call to the class. This causes a number of problems (e.g., as pointed out by Aran-Fey in the comments, you can't <code>isinstance(feat, mystery)</code>, because <code>mystery</code>). </p>
<p>But the particular problem you care about is that you can't pickle instances of inaccessible classes.</p>
<p>In fact, that's basically what the error message is telling you:</p>
<pre><code>PicklingError: Can't pickle &lt;class '__main__.mystery'&gt;: it's not the 
same object as __main__.mystery
</code></pre>
<p>Your <code>feat</code> thinks its type is <code>__main__.mystery</code>, but that isn't a type at all, it's the function returned by the decorator that wraps that type.</p>
<hr/>
<p>The easy way to fix this would be to find a class decorator meant that does what you want. It might be called something like <code>flyweight</code> instead of <code>memoize</code>, but I'm sure plenty of examples exist.</p>
<hr/>
<p>But you can build a flyweight class by just memoizing the constructor, instead of memoizing the class:</p>
<pre><code>class mystery:
    @funcy.memoize
    def __new__(cls, num):
        return super().__new__(cls)
    def __init__(self, num):
        self.num = num
</code></pre>
<p>… although you probably want to move the initialization into the constructor in that case. Otherwise, calling <code>mystery(1)</code> and then <code>mystery(1)</code> will return the same object as before, but also reinitialize it with <code>self.num = 1</code>, which is at best wasteful, and at worst incorrect. So:</p>
<pre><code>class mystery:
    @funcy.memoize
    def __new__(cls, num):
        self = super().__new__(cls)
        self.num = num
        return self
</code></pre>
<hr/>
<p>And now:</p>
<pre><code>&gt;&gt;&gt; feat = mystery(1)
&gt;&gt;&gt; feat
&lt;__main__.mystery at 0x10eeb1278&gt;
&gt;&gt;&gt; mystery(2)
&lt;__main__.mystery at 0x10eeb2c18&gt;
&gt;&gt;&gt; mystery(1)
&lt;__main__.mystery at 0x10eeb1278&gt;
</code></pre>
<p>And, because the type of <code>feat</code> is now a class that's accessible under the module-global name <code>mystery</code>, <code>pickle</code> will have no problem with it at all:</p>
<pre><code>&gt;&gt;&gt; pickle.dumps(feat)
b'\x80\x03c__main__\nmystery\nq\x00)\x81q\x01}q\x02X\x03\x00\x00\x00numq\x03K\x01sb.'
</code></pre>
<hr/>
<p>You <em>do</em> still want to think about how this class should play with pickling. In particular, do you want unpickling to go through the cache? By default, it doesn't:</p>
<pre><code>&gt;&gt;&gt; pickle.loads(pickle.dumps(feat)) is feat
False
</code></pre>
<p>What's happening is that it's using the default <a href="https://docs.python.org/3/library/pickle.html#object.__reduce_ex__" rel="nofollow noreferrer"><code>__reduce_ex__</code></a> for pickling, which defaults to doing the equivalent of (only slightly oversimplified):</p>
<pre><code>result = object.__new__(__main__.mystery)
result.__dict__.update({'num': 1})
</code></pre>
<p>If you want it to go through the cache, the simplest solution is this:</p>
<pre><code>class mystery:
    @funcy.memoize
    def __new__(cls, num):
        self = super().__new__(cls)
        self.num = num
        return self
    def __reduce__(self):
        return (type(self), (self.num,))
</code></pre>
<hr/>
<p>If you plan to do this a lot, you might think of writing your own class decorator:</p>
<pre><code>def memoclass(cls):
    @funcy.memoize
    def __new__(cls, *args, **kwargs):
        return super(cls, cls).__new__(cls)
    cls.__new__ = __new__
    return cls
</code></pre>
<p>But this:</p>
<ul>
<li>… is kind of ugly,</li>
<li>… only works with classes that don't need to pass constructor arguments to a base class,</li>
<li>… only works with classes that don't have an <code>__init__</code> (or, at least, that have an idempotent and fast <code>__init__</code> that's harmless to call repeatedly),</li>
<li>… doesn't provide an easy way to hook pickling, and</li>
<li>… doesn't document or test any of those restrictions.</li>
</ul>
<p>So, I think you're better off being explicit and just memoizing the <code>__new__</code> method, or writing (or finding) something a lot fancier that does the introspection needed to make memoizing a class this way fully general. (Or, alternatively, maybe write one that only works with some restricted set of classes—e.g., a <code>@memodataclass</code> that's just like <code>@dataclass</code> but with a memoized constructor would be a lot easier than a fully general <code>@memoclass</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach is</p>
<pre><code>class _mystery(object):

    def __init__(self, num):
        self.num = num

@funcy.memoize
def mystery(num):
    return _mystery(num)
</code></pre>
</div>
<span class="comment-copy">What should happen when you load a pickled instance? Should it be added to the memo?</span>
<span class="comment-copy">it doesnt really matter to me</span>
<span class="comment-copy">By the way, applying a function decorator to a class is a bad idea for a variety of reasons. Try <code>isinstance(feat, mystery)</code> - you might expect to get <code>True</code> as output, but it'll actually throw an error.</span>
<span class="comment-copy">Awesome answer! Thanks so much. answered all my questions... and more</span>
<span class="comment-copy">Just <code>mystery = funcy.memoize(_mystery)</code></span>
