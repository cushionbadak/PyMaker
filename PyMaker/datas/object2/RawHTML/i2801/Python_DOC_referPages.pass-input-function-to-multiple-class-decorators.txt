<div class="post-text" itemprop="text">
<p>I have a Timer decorator printing the time elapsed for a Memoize decorated function on screen. However, the decorator print statement prints the memoize class as the function name on screen rather than the function input to memoize. For instance, using this code:</p>
<pre><code>from memoization import Memoize


import time


import logging


from timer import Timer


@Timer
@Memoize
def pass_and_square_time(seconds):
    time.sleep(seconds)
    return seconds**2


def main():
    logging.getLogger().setLevel(logging.ERROR)

    print '\nFor pass_and_square_time({30}):'.format(n=num)
    print '\n\tThe initial call of pass_and_square_time(30) yields: {ret}'.format(ret=pass_and_square_time(30))
    print '\n\tThe second call of pass_and_square_time(30) yields: {ret}'.format(ret=pass_and_square_time(30))
</code></pre>
<p>returns the following:</p>
<pre><code>For pass_and_square_time(30):
    Timer Time Elapsed: 30.0 seconds

    &lt;memoization.Memoize object at 0x02E5BBD0&gt; 30.0 seconds

    The initial call of pass_and_square_time(30) yields: 900
    Timer Time Elapsed: 0.0 seconds

    &lt;memoization.Memoize object at 0x02E5BBD0&gt; 0.0 seconds

    The second call of pass_and_square_time(30) yields: 900
</code></pre>
<p>when I want that memoization.Memoize to be <code>pass_and_square_time</code>. I've tried a variety of different combinations of <code>self.__wrapper__</code>, <code>functools.wraps</code>, and <code>functools.update_wrapper()</code> to no avail.</p>
<p>My Timer class is implemented as follows:</p>
<pre><code>class Timer(object):
    def __init__(self, fcn=None, timer_name='Timer'):
        self._start_time = None
        self._last_timer_result = None
        self._display = 'seconds'
        self._fcn = fcn
        self._timer_name = timer_name

    def __call__(self, *args):
        self.start()
        fcn_res = self._fcn(*args)
        self.end()
        print '\n\t{func} {time} seconds'.format(func=self._fcn, time=self.last_timer_result)
        return fcn_res

    def __get__(self, obj, objtype):
        return partial(self.__call__, obj)

    '''
    start(), end(), and last_timer_result functions/properties implemented 
    below in order to set the start_time, set the end_time and calculate the 
    last_timer_result,  and return the last_timer_result. I can include more
    if you need it. I didn't include it just because I didn't want to make
    the post too long
    '''
</code></pre>
<p>My Memoize class is implemented as follows:</p>
<pre><code>from functools import update_wrapper, partial


class Memoize(object):
    def __init__(self, fcn):
        self._fcn = fcn
        self._memo = {}
        update_wrapper(self, fcn)

    def __call__(self, *args):
        if args not in self._memo:
            self._memo[args] = self._fcn(*args)

        return self._memo[args]

    def __get__(self, obj, objtype):
        return partial(self.__call__, obj)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a lot simpler using closures than classes.</p>
<pre><code>import functools
import time

def memoize(f):
    _memo = {}
    @functools.wraps(f)
    def _(*args):
        if args not in _memo:
            _memo[args] = f(*args)
        return _memo[args]
    return _                
</code></pre>
<p>I would similarly write <code>timer</code> as</p>
<pre><code>def timer(f):
    @functools.wraps(f)
    def _(*args):
        start = time.time()
        rv = f(*args)
        end = time.time()
        print '\n\t{func} {t} seconds'.format(func=f.__name__, t=end - start)
        return rv
    return _
</code></pre>
<p>Then</p>
<pre><code> @timer
 @memoize
 def pass_and_square_time(seconds):
     time.sleep(seconds)
     return seconds**2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both <code>Timer</code> and <code>Memoize</code> are implemented as classes, in such way that they return an instance of their own class when they decorate a function. Because of that, it is not possiblle to use <code>functools.wrap</code> or to set the <code>__name__</code> on the returned function (because there is no returned function).</p>
<p>Instead, I suggest implementing <a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="nofollow noreferrer"><code>__repr__</code></a> on <code>Timer</code> and <code>Memoize</code>, which will represent the decorated function better. That function will be called by Python interpreter when it needs to get the string representation of the object.</p>
<p>This is the current situation and the problem:</p>
<pre><code>def pass_and_square_time(seconds):
    time.sleep(seconds)
    return seconds**2

print(pass_and_square_time)         # &lt;function pass_and_square_time at 0x00000000029A1620&gt;
print(Memoize(pass_and_square_time))  # &lt;Memoize object at 0x000000000295BDA0&gt;
</code></pre>
<p>Now, if you add to <code>Memoize</code> this:</p>
<pre><code>class Memoize(object):
    ...
    def __repr__(self):
        return repr(self._fcn)
</code></pre>
<p>Then it works as expected:</p>
<pre><code>print(pass_and_square_time)         # &lt;function pass_and_square_time at 0x00000000029A1620&gt;
print(Memoize(pass_and_square_time))  # &lt;function pass_and_square_time at 0x00000000029A1620&gt;
</code></pre>
<p>Then do the same for <code>Memoize</code>, and even this will work:</p>
<pre><code>print(Timer(Memoize(pass_and_square_time)))  # &lt;function pass_and_square_time at 0x00000000029A1620&gt;
</code></pre>
<p>Note that <code>Timer(Memoize(pass_and_square_time))</code> is exactly what the decorators do here:</p>
<pre><code>@Timer
@Memoize
def pass_and_square_time(seconds):
    time.sleep(seconds)
    return seconds**2
</code></pre>
</div>
<span class="comment-copy">"I want that <code>memoization.Memoize</code> to be <code>pass_and_square_time</code>" Is that really what you want? Looks easy enough but I do not see how it makes any sense.</span>
<span class="comment-copy">I greatly appreciate your help, and if I could mark 2 correct answers I would, but I ended up going with changing memoize so that it wasn't a class since there wasn't really a reason for me to keep it as a class. Thanks though!</span>
<span class="comment-copy">@strwars That is fine. I'm glad you appreciate the answer. Anyway, you can <i>accept</i> only one answer, as you wrote, but you can give a +1 to as many answers as you like ;)</span>
<span class="comment-copy">When I get 15 reputation I'll be sure to circle back and give both a +1. I'm at a lowly 10 at the moment unfortunately lol @zvone</span>
<span class="comment-copy">@strwars Ah, I see :)</span>
<span class="comment-copy">If you happen to know anything about multiprocessing, I've been having a totally separate issue @zvone ... :D <a href="https://stackoverflow.com/questions/51922119/attempting-to-use-multiple-processes-in-python-but-only-one-works" title="attempting to use multiple processes in python but only one works">stackoverflow.com/questions/51922119/â€¦</a></span>
