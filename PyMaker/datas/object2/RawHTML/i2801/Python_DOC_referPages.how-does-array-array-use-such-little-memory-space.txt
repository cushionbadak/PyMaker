<div class="post-text" itemprop="text">
<p>I'm not sure why the <code>array.array()</code> class uses so little memory than reported by <code>sys.getsizeof</code>:</p>
<pre><code>from array import array
a = array('f')
for i in range(500000):
    a.append(float(i))
sys.getsizeof(a)
# 2100228
sum(sys.getsizeof(i) for i in a)
# 12000000 (makes sense, 24 bytes * 500K)
# 2100228 + 12000000 = 14100228
# 14100228 / 1000 = 14,100.228KB
# 14,100.228 / 1000 = 14.1MB
</code></pre>
<p>However, examining the process in the task manager, the programs memory only increases by 3MB. So how is the process only using 3MB more but the object takes up 14.1MB?</p>
</div>
<div class="post-text" itemprop="text">
<p>A Python <code>float</code> is a fully-featured object, which knows its type (so it has methods) and can be garbage collected and so on. In CPython (the Python implementation you’re probably using), this works by storing a pointer to the type object (8 bytes) and a reference count (8 more bytes) along with the actual IEEE float64 value (8 more bytes), so it’s at least 24 bytes long.</p>
<p>A <code>list</code> just stores references to Python objects. So, a <code>list</code> of a half million floats will take a bit over 4MB for the list itself (storing all those references), plus all those referenced <code>float</code> objects will take another 12MB in total.</p>
<p>An <code>array.array</code> doesn’t store <code>float</code> objects, it just stores the bits of the IEEE float64 value (8 bytes), and then creates those <code>float</code> objects on the fly whenever you ask for one with, e.g., <code>arr[0]</code>. This makes it a lot smaller—the whole thing only takes 4MB in memory—but also slower.<sup>1</sup></p>
<p>And of course you aren’t even storing an array of IEEE float64 (that’s <code>d</code>, not <code>f</code>), but float32. Half a million of those takes 2MB.</p>
<p>If you want the best of both worlds, the third-party library NumPy can store the bits the same way <code>array.array</code> does, and it can do calculations on those bits without having to create and destroy <code>float</code> objects all over the place, so it’s both smaller <em>and</em> faster.</p>
<hr/>
<p>So, when you ask for the size of an array of 500K <code>f</code> floats, that’s 2MB, because it stores only the 500K native IEEE float32 values (plus a few dozen bytes of fixed overhead).</p>
<p>But when you loop over that array, counting the size of each member, you’re actually creating 24-byte <code>float</code> objects on the fly. The total size of all of those temporary objects is 12MB. But they’re temporary—as soon as you check the size of each one, you forget about it, it becomes garbage and gets cleaned up, and the same 24 bytes can be reused for the next one.</p>
<hr/>
<p>As for why Task Manager shows your memory go up by 3MB:</p>
<p>Almost every program works by having a heap of memory, allocating out of that heap, and only asking the OS for more memory in large chunks when it needs more. (CPython makes this even more complicated by having two custom heaps on top of the basic one, but don’t worry about that.) </p>
<p>So, let’s say the interpreter has 2MB of space left over in its heap, and you ask it to allocate a 4MB object. It needs to go back to Windows and ask for at least 2MB more memory. It gets a little more than it needs (so it won’t immediately need to go back and ask for more), and that turns out to be about 3MB. Of course this is just one of many ways you could end up getting 3MB from the OS, and figuring out exactly which one happened requires complicated debugging (more complicated than doing more useful things, like just tracking the actual heap use of your program).</p>
<p>As you can see, this makes measuring memory usage by Task Manager pretty useless, except for very broad strokes. (And it’s actually even worse than that, once you get into questions like when Python returns free memory to Windows, what happens when memory is fragmented, whether the OS overcommits, when pages can and can’t be remapped in virtual memory, and all kinds of other complexities.)</p>
<hr/>
<p><sub>1. Although it’s not always slower. Sometimes being more compact in memory gives you so much advantage in caching or virtual memory that it more than makes up for the wasted time creating and destroying objects all over the place.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>a</code> array does not actually contain any of the objects produced by <code>for i in a</code>. Those objects are generated on access. <code>a</code> contains raw 32-bit floats, not float objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>As written in the <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer">docs</a>, "the <code>array</code> module defines an object type which can <em>compactly</em> represent an array of basic values: characters, integers, floating point numbers". That is <code>a[i]</code> will need to store the type info, while for the whole <code>a</code> array you need to store it only once.</p>
</div>
<span class="comment-copy">Task Manager is not a reliable way to measure heap allocations inside the process. Commit charge may not change at all when large objects are allocated; most likely the Python heap has lots of empty space that is not yet returned to the OS because it's partially fragmented.</span>
<span class="comment-copy">This is described at the top of <a href="https://docs.python.org/3/library/array.html" rel="nofollow noreferrer">the <code>array</code> module docs</a>: "This module defines an object type which can compactly represent an array of basic values ...   The actual representation of values is determined by the machine architecture (strictly speaking, by the C implementation). The actual size can be accessed through the <code>itemsize</code> attribute."</span>
<span class="comment-copy">You seem to have gotten your sizes a bit mixed up - sometimes you say the array is 8 MB, sometimes you say 4 MB, and in any case, <code>array('f')</code> stores 32-bit floats, not 64-bit.</span>
<span class="comment-copy">@user2357112 The first section is about a list of a million floats vs. an array of a million floats. The second section is answering a specific question about an array of half a million floats from a comment follow up. I think it’s pretty clear that “an array of 500K floats” is not the same thing as “a million floats”, and I can’t see how you could get confused by that. But it does jump around for no obvious reason, (even less obvious with the comments deleted), so I’ll try to rewrite it to be clearer when I get a chance.</span>
<span class="comment-copy">@user2357112 OK, I’ve edited to talk about the 500K array of <code>f</code> all throughout, instead of talking about a 1M array of <code>float</code> in the first section and then a 500K array of <code>f</code> in the second.</span>
<span class="comment-copy">The new version is definitely better.</span>
<span class="comment-copy">So each element of <code>a</code> is a 32-bit float (probably 64-bit on my system). It takes the "value" component of a float object and stores it as what, a double perhaps in the C code?</span>
<span class="comment-copy">@pstatix: No, 32-bit, because you picked <code>f</code> instead of <code>d</code>. It stores C floats.</span>
<span class="comment-copy">Awesome, good catch. I didn't realize it doesnt store them as objects. That would violate my thinking of "everything is an object in Python". Good to know though, much less overhead storing 32-bit floats as raw rather than their Py_Object compliment.</span>
