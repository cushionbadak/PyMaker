<div class="post-text" itemprop="text">
<p>I want to be able to keep the order of the list when it compares. Notice when I compare list1 with list2, it returns me 8 then 7 (reverse). How do I have it maintain the order?</p>
<pre><code>&gt;&gt;&gt; list1 = ['1','2','3','4','7','8'] 
&gt;&gt;&gt; list2 = ['1','2','3','4','5','6']
&gt;&gt;&gt; list(set(list2) - set(list1))    
['5', '6']
&gt;&gt;&gt; list(set(list1) - set(list2))    
['8', '7']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An <code>OrderedDict</code> makes a good substitute for an order-preserving set, since the keys views are set-like:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; list1 = ['1','2','3','4','7','8'] 
&gt;&gt;&gt; list2 = ['1','2','3','4','5','6']
&gt;&gt;&gt; OrderedDict.fromkeys(list1).keys() - OrderedDict.fromkeys(list2).keys()
{'7', '8'}
&gt;&gt;&gt; OrderedDict.fromkeys(list2).keys() - OrderedDict.fromkeys(list1).keys()
{'5', '6'}
</code></pre>
<p>Strictly speaking, that may be still using implementation detail of CPython.  But the list-comprehensions are not, and they're still O(n):</p>
<pre><code>&gt;&gt;&gt; od1 = OrderedDict.fromkeys(list1)
&gt;&gt;&gt; od2 = OrderedDict.fromkeys(list2)
&gt;&gt;&gt; [k for k in od1 if k not in od2]
['7', '8']
&gt;&gt;&gt; [k for k in od2 if k not in od1]
['5', '6']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a list comprehension:</p>
<pre><code>list1 = ['1','2','3','4','7','8'] 
list2 = ['1','2','3','4','5','6']

set1 = set(list1)  # convert to set for faster membership testing
result = [x for x in list2 if x not in set1]
# result: ['5', '6']
</code></pre>
<p>This will, however, include duplicate elements:</p>
<pre><code>&gt;&gt;&gt; list1 = [1]
&gt;&gt;&gt; list2 = [1, 2, 2]
&gt;&gt;&gt; set1 = set(list1)
&gt;&gt;&gt; [x for x in list2 if x not in set1]
[2, 2]
</code></pre>
<p>If duplicates aren't desired, simply transform the list comprehension into a loop and keep track of all elements that you've already encountered:</p>
<pre><code>list1 = [1] 
list2 = [1, 2, 2]

set1 = set(list1)
result = []

for x in list2:
    if x in set1:
        continue

    result.append(x)
    set1.add(x)

# result: [2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While this does not use the <code>-</code> operator for sets, it does preserve the order of the original list.</p>
<pre><code>list1 = ['1','2','3','4','7','8'] 
list2 = ['1','2','3','4','5','6']
set_list2 = set(list2)
result = []
for item in list1:
    if not item in set_list2:
        result.append(item)
        set_list2.add(item) # to avoid duplicates in result
print(result)
# ['7', '8']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A 'set' by definition is unordered. If you'd like to sort the elements, try using a list operation. You can use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.setdiff1d.html" rel="nofollow noreferrer">setdiff1d</a> from numpy, for example:</p>
<pre><code>import numpy as np
list1 = ['1','2','3','4','7','8'] 
list2 = ['1','2','3','4','5','6']
new_list_one = np.setdiff1d(list2, list1)
new_list_two = np.setdiff1d(list1, list2)

print(new_list_one) ['5' '6']
print(new_list_two) ['7' '8']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehension instead to find the difference. Here is how you do it:
<code>[x for x in list1 if x not in list2]</code> which will yield <code>['7', '8']</code> </p>
<p>And you can do <code>[x for x in list2 if x not in list1]</code> which will yeild <code>['5', '6']</code></p>
<p>And if original list contains duplicates, you can use <code>[x for x in list1 if x not in list2 and list1.count(x) == 1]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Probably the most naive approach:</p>
<pre><code>def ordered_diff(a, b):
    seen = set(b)
    result = []
    for ele in a:
        if ele not in seen:
            result.append(ele)
            seen.add(ele)

    return result     


list1 = ['1','2','3','4','7','8','7','8'] 
list2 = ['1','2','3','4','5','6','5','6']

print ordered_diff(list1, list2)
print ordered_diff(list2, list1)
</code></pre>
<p>Result:</p>
<pre><code>['7', '8']
['5', '6']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this case, just use a list comprehension:</p>
<pre><code>[x for x, y in zip(b, a) if x != y]
# ['5', '6']

[x for x, y in zip(a, b) if x != y]
# ['7', '8']
</code></pre>
<p>In general, consider <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest</code></a> (vs. <code>zip</code>), particularly with lists of differing lengths.</p>
</div>
<span class="comment-copy">Do you want the order as given in the list or do you want the result of the set difference sorted?</span>
<span class="comment-copy">Right, so I want the order to be maintained from the original list given. In other words, the expected output should be ['7', '8'] instead... However, I need to to be applied to strings as well (maintain order of list) and not "sorted" numerically.</span>
<span class="comment-copy">Related post <a href="https://stackoverflow.com/questions/47985297/how-to-xor-two-lists-in-python/47985524#47985524" title="how to xor two lists in python">stackoverflow.com/questions/47985297/â€¦</a></span>
<span class="comment-copy">in Python 3.6+, dict insertions are ordered, so you can use <code>dict.fromkeys()</code></span>
<span class="comment-copy">@pylang Not quite. Python 3.7+ or CPython 3.6+.</span>
<span class="comment-copy">The set difference solution doesn't work. The order of the result is random.</span>
<span class="comment-copy">@Aran-Fey  I couldn't find a Python version where the <code>odict_keys</code> view returned randomly (though it might be <i>unspecified</i>). Regardless, I don't present it as a full solution, just a demonstration that the views are set-like.</span>
<span class="comment-copy">@Aran-Fey.  True, but I believe that detail is a bit pedantic.  I suspect the <code>python</code> tag intrinsically refers to the CPython implementation.  Regardless, thanks.</span>
<span class="comment-copy">What if original lists contain duplicates?</span>
<span class="comment-copy">@Akavall You'll have to ask the OP what should happen in that case.</span>
<span class="comment-copy">It looks to me like OP wanted a set difference with order preserved.</span>
<span class="comment-copy">@Akavall  Then you do a similar thing with a <code>collections.Counter</code> instead of a set.</span>
<span class="comment-copy">@Akavall Answer updated to handle duplicates.</span>
<span class="comment-copy">I think updating <code>set_list2</code> to keep track of items added to <code>result</code>, and therefore not adding same element more then once is more in the spirit of OPs question.</span>
<span class="comment-copy">@Akavall good catch</span>
