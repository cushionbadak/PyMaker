<div class="post-text" itemprop="text">
<p>I am new to Python.</p>
<p>Over here, I am trying to scan through a file <code>helpme.txt</code>, and remove stop words that are in the <code>stopwords1.txt</code> file. I am tasked to use only 1 parameter. </p>
<p>I have came up with the following but I kept getting the error: <code>ValueError: list.remove(x): x not in list</code>.</p>
<p>Any kind souls please help me out.  </p>
<pre><code>thestop = open("stopwords1.txt", "r").readlines()


def remove_stop(stopwords):
    new = []
    new.append(open("helpme.txt","r").readlines())
    stop = []
    stop.append(stopwords)
    for word in stop[:]:
        new.remove(word)
        print(new)

remove_stop(thestop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are so many things that you can improve in your code...</p>
<pre><code>def remove_stop(stopwords):
    stopwords = set(stopwords) # It is faster to look up in a set!
    new = []
</code></pre>
<p>Open the file correctly and use it as an iterator:</p>
<pre><code>    with open("helpme.txt") as infile:
        for line in infile:
</code></pre>
<p>For each line in the file, break that line into words. Check if the words is not in stopwords, and combine the survivors into another line. Add the line to the list of the processed line. Beware that if you have any words followed by punctuation, then they will not be processed. Use NLTK to handle punctuation.</p>
<pre><code>            line = ' '.join([word for word in line.split() 
                               if word not in stopwords])
            new.append(line)
</code></pre>
<p>The latter five lines could be written as a <em>one-liner</em>, but you don't have to go that far. Do not forget to return the list of clean lines!</p>
<pre><code>    return new
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>in your code 'word' returns a list. your are trying to remove  an item not there in 'new'. so it is throwing error. replace your for loop with this</p>
<pre><code>for word in stop[:]: 
    for i in word:
        if i in new:
            new.remove(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try printing the <code>stop</code> variable in the <code>remove_stop</code> function it should look something like this <code>[['stop word 1\n', 'stop word 2\n'....]]</code>. (<code>readlines</code> doesn't remove the carriage return) </p>
<p>As such your for loop will only have one element being the list of stop words not the stop words them selves (same for <code>new</code>).</p>
<p>This can be solved as such, remove the <code>new</code> and <code>stop</code> variables and replace them as such.</p>
<p><code>stop = stopwords</code></p>
<p><code>new = open("helpme.txt","r").read().split('\n')</code></p>
<p>Also you will need to change <code>thestop</code> to <code>open("stopwords1.txt", "r").read().split('\n')</code> to remove any carriage return, or you can remove them after reading the file using <code>readlines</code>.</p>
<p>Finally you will need to have a nested loop because you want to remove stop words from each line as such your loop will be something like this.</p>
<pre><code>for i in range(0, len(new)):
    for j in range(0, len(stop)):
        new[i] = new[i].replace(stop[j], '')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nice effort. When you're stuck like this, it's a great time to exercise basic debugging and design principles.</p>
<p>Scale down complexity: approach your code in small chunks and make sure each component is working <em>before</em> increasing complexity. Removing stop words and reading input lists are totally different tasks and can be broken down and debugged in discrete chunks. </p>
<p>In terms of input, are the files being read as you planned? Instead of lists of words, you're getting a list of strings nested in a list with the file contents inside of it, which seems unintended. <code>print</code>ing your <code>new</code> list reveals <code>[["stack overflow is awesome, don't you think?\n"]]</code>. Removing the <code>.append</code> and doing a direct assignment on <code>new</code> will ensure you're only dealing with a 1d list of strings.</p>
<p>At this point, strings need breaking down into words. This can be a <a href="https://en.wikipedia.org/wiki/Regular_expression" rel="nofollow noreferrer">complex pattern matching task</a> depending on what you define as a word. For now, I recommend keeping it simple and using <code>split()</code> to break on whitespace, but know that you may have dangling commas, periods and quotation marks that will impact your output.</p>
<p>After settling your input routine, matters should be much clearer inside your <code>remove_stop</code> function, which was previously broken because it was crashing while attempting to remove strings from a list that didn't contain anything other than lists. An approach to this function I prefer is using a <a href="https://www.pythonforbeginners.com/lists/list-comprehensions-in-python/" rel="nofollow noreferrer">list comprehension</a> for terse but readable syntax and a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a> for fast, almost instantaneous lookups. <code>remove</code>, for contrast, is a slow approach that looks through every element of the input list one at a time to find the item to remove on every iteration.</p>
<p>Putting it all together, here's one approach:</p>
<pre><code>def remove_stop(text, stopwords):
    disallowed = set(stopwords)
    return [word for word in text if word not in disallowed]


text = open("helpme.txt","r").read().split()
stopwords = open("stopwords1.txt","r").read().split()
print(remove_stop(text, stopwords))
</code></pre>
<p>Given sample texts:
<code>helpme.txt</code>:</p>
<pre class="lang-none prettyprint-override"><code>stack overflow is awesome, don't you think?
</code></pre>
<p>and <code>stopwords1.txt</code>:
</p>
<pre><code>stack
overflow
</code></pre>
<p>Here's the output:</p>
<pre><code>['is', 'awesome,', "don't", 'you', 'think?']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work:  </p>
<pre><code>import re


def remove_stop(stopwords):
    with open("helpme.txt", "r") as text_file:
        words = text_file.read().split()
    with open("helpme_out.txt", "w+") as filtered_text_file:
        filtered_words = []
        for word in words:
            if re.sub('[^A-Za-z0-9]+', '', word) not in stopwords:
                filtered_words.append(word)
        filtered_text_file.write((" ").join(filtered_words))


if __name__ == "__main__":
    with open("stopwords1.txt", "r") as stopwords_file:
        remove_stop(
            list(map(lambda x: x.strip("\n").lower(), stopwords_file.readlines())))
</code></pre>
<p>I know it is complicated and not very helpful for you at the moment, however you can use the tips about debugging and design that other people here suggested to get to a similar answer yourself and use the code above as a reference.</p>
</div>
<span class="comment-copy">thank you so much @ggorlen! I got the output I want! but I have another issue. Is there any way to shuffle it around such that I only have one parameter, which is "stopwords"?   below is my attempt:        stopwords = open("stop1.txt","r").read().split()      def remove_stop(stopwords):         disallowed = set(stopwords)         text = open("yelp2.txt","r").read().split()         return [word for word in text if word not in disallowed]      print(remove_stop(stopwords))</span>
<span class="comment-copy">@JacquelynTan you can do that, sure, but you diminish functionality and reusability of <code>remove_stop</code>. It'd be more versatile if you could pass in any list whether from a text file of any name or not rather than having to be restricted to one specific text file.</span>
