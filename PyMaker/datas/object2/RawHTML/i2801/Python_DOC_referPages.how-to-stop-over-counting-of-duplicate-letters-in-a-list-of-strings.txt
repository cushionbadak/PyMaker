<div class="post-text" itemprop="text">
<p>I'm trying to count the number of times a duplicate letter shows up in the list element.</p>
<p>For example, given</p>
<pre><code>arr = ['capps','hat','haaah']
</code></pre>
<p>I out put a list and I get <code>['1','0','1']</code></p>
<pre><code>def myfunc(words):
    counter = 0 #counters dup letters in words
    len_ = len(words)-1
    for i in range(len_):
        if words[i] == words[i+1]: #if the letter ahead is the same add one
            counter+=1
    return counter

def minimalOperations(arr):
     return [*map(myfunc,arr)] #map fuc applies myfunc to element in words.
</code></pre>
<p>But my code would output [1,0,2]</p>
<p>I'm not sure why I am over counting.
Can anyone help me resolve this, thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>A more efficient solution using a regular expression:</p>
<pre><code>import re

def myfunc(words):
    reg_str = r"(\w)\1{1,}"
    return len(re.findall(reg_str, words))
</code></pre>
<p>This function will find the number of substrings of length 2 or more containing the same letter. Thus 'aaa' in your example will only be counted once.</p>
<p>For a string like </p>
<pre><code>'hhhhfafaahggaa'
</code></pre>
<p>the output will be 4 , since there are 4 maximal substrings of the same letter occuring at least twice : 'hhh' , 'ss', 'gg', 'aa'</p>
</div>
<div class="post-text" itemprop="text">
<p>You aren't accounting for situations where you have greater than 2 identical characters in succession. To do this, you can look back as well as forward:</p>
<pre><code>if (words[i] == words[i+1]) and (words[i] != words[i-1] if i != 0 else True)
    # as before
</code></pre>
<p>The ternary statement helps for the first iteration of the loop, to avoid comparing the last letter of a string with the first.</p>
<p>Another solution is to use <code>itertools.groupby</code> and count the number of instances where a group has a length greater than 1:</p>
<pre><code>arr = ['capps','hat','haaah']

from itertools import groupby

res = [sum(1 for _, j in groupby(el) if sum(1 for _ in j) &gt; 1) for el in arr]

print(res)

[1, 0, 1]
</code></pre>
<p>The <code>sum(1 for _ in j)</code> part is used to count the number items in a generator. It's also possible to use <code>len(list(j))</code>, though this requires list construction.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, your code counts the number of duplications, so what you observe is quite logical:  </p>
<ul>
<li>your input is <code>arr = ['capps','hat','haaah']</code></li>
<li>in 'capps', the letter <em>p</em> is duplicated 1 time =&gt; myfunc() returns 1</li>
<li>in 'hat', there is no duplicated letter =&gt; myfunc() returns 0</li>
<li>in 'haaah', the letter <em>a</em> is duplicated 2 times =&gt; myfunc() returns 2</li>
</ul>
<p>So finally you get [1,0,2].</p>
<p>For your purpose, I suggest you to use a regex to match and count the number of groups of duplicated letters in each word. I also replaced the usage of <code>map()</code> with a list comprehension that I find more readable:  </p>
<pre><code>import re

def myfunc(words):
    return len(re.findall(r'(\w)\1+', words))

def minimalOperations(arr):
    return [myfunc(a) for a in arr]

arr = ['capps','hat','haaah']
print(minimalOperations(arr))  # [1,0,1]

arr = ['cappsuul','hatppprrrrtyyy','haaah']
print(minimalOperations(arr))  # [2,3,1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to keep track of a little more state, specifically if you're looking at duplicates now.</p>
<pre><code>def myfunc(words):
    counter = 0 #counters dup letters in words
    seen = None
    len_ = len(words)-1
    for i in range(len_):
        if words[i] == words[i+1] and words[i+1] != seen: #if the letter ahead is the same add one and wasn't the first
            counter+=1
            seen = words[i]
    return counter
</code></pre>
<p>This gives you the following output</p>
<pre><code>&gt;&gt;&gt; arr = ['capps','hat','haaah']
&gt;&gt;&gt; map(myfunc, arr)
[1, 0, 1]
</code></pre>
<p>As others have pointed out, you could use a regular expression and trade clarity for performance. They key is to find a regular expression that means "two or more repeated characters" and may depend on what you consider to be characters (e.g. how do you treat duplicate punctuation?)</p>
<p>Note: the "regex" used for this is technically an extension on regular expressions because it requires memory.</p>
<p>The form will be <code>len(re.findall(regex, words))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I would break this kind of problem into smaller chunks. Starting by grouping duplicates.
<a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">The documentation for itertools</a> has groupby and recipes for this kind of things.</p>
<p>A slightly edited version of <code>unique_justseen</code> would look like this:</p>
<pre><code>duplicates = (len(sum(1 for _ in group) for _key, group in itertools.groupby("haaah")))
</code></pre>
<p>and yields values: 1, 3, 1. As soon as any of these values are greater than 1 you have a duplicate. So just count them:</p>
<pre><code>sum(n &gt; 1 for n in duplicates)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>re.findall</code> for matches of 2 or more letters</p>
<pre><code>&gt;&gt;&gt; arr = ['capps','hat','haaah']
&gt;&gt;&gt; [len(re.findall(r'(.)\1+', w)) for w in arr]
[1, 0, 1]
</code></pre>
</div>
<span class="comment-copy">'haaah' has two duplicate letters. h(aa)ah and ha(aa)h.</span>
<span class="comment-copy">when there two consecutive letters together that one. So "aa" is one "aaa" should be one as well</span>
<span class="comment-copy">I add this to the for loop if words[i] == words[i+1] and words[i] !=  words[i-1] doesn't this do the same? It seem like it workd</span>
<span class="comment-copy">What happens when <code>i = 0</code>? You get <code>words[-1]</code> compared to <code>words[0]</code>. But why would you compare the last letter with the first. Remember <code>-1</code> counts backwards from the end.</span>
<span class="comment-copy">The reason I ask because when I tried this arr =['ab','aab','abb','abab','abaaaba'] I get [0,0,1,0,1] when adding words[max(0, i-1)] but when I add words[i-1] I get out put is [0,1,1,0,1] which the right anwser.  And yes, I agree with you. When it i-1 on 0 it goes back works. My question is why it didn't work for this case?</span>
<span class="comment-copy">@CamiloSalazar, Good spot. See corrected logic.</span>
<span class="comment-copy">I guess what I'm trying to figure out is when I see a group of three letters how do I make it count as one? I tried to do words[i] == words[i+1] ==words[i+2] as a case. But It response to me string out of range. &gt;.&lt;</span>
<span class="comment-copy">This I can try to see if there's a group of the same three letters for example "aaa" and count it as 1</span>
<span class="comment-copy">It should work as you expect, doesn't it ?</span>
