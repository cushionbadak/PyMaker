<div class="post-text" itemprop="text">
<p>This is a piece of code I wrote to count how many even numbers there are in the first 1023 rows of the pascal triangle. However, I feel like it may need to be improved, especially the function next_row.</p>
<pre><code>def next_row(r):
    i = 0
    s = []
    while i &lt; len(r) -1:
        s.append(r[i] + r[i+1])
        i += 1
    s.insert(0, 1)
    s.append(1)
    return s

def count_even(r):
    counter = 0
    for item in r:
        if item % 2 == 0:
            counter += 1
    return counter

def results(i, t, e):
    print('In the first ' + str(i) + ' lines of the pascal triangle, there are ' + str(t) + ' entries. ' + 
        str(e) + ' of them are even.')

r = [1]
even = 0
total = 0
for i in range (0, 1023):
    even += count_even(r)
    total += len(r)
    r = next_row(r)
    results(i+1, total, even)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For starter you should avoid both a <code>while</code> loop and an iteration over indices while reading the content of an array. Watch the <a href="https://nedbatchelder.com/text/iter.html" rel="nofollow noreferrer">loop like a native</a> talk to get more insight. In your case, since you are interested in interating over consecutive values at once, you may have a look into the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>pairwise</code> recipe</a>.</p>
<p>Second, instead of patching your row <em>after</em> the computation of all central elements, you can provide a bigger row to start your computation from by adding 0 to both sides. And to avoid resizing lists in doing so, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain</code></a> for that.</p>
<p>Lastly, to get the 1023 first rows, you may want to provide a generator that gives an endless stream of rows from the pascal triangle and cut that generator short after 1023 rows using <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>.</p>
<p>Revised code:</p>
<pre><code>import itertools


def pairwise(iterable):
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)


def next_row(row):
    larger_row = itertools.chain([0], row, [0])
    return [a + b for a, b in pairwise(larger_row)]


def pascal_triangle():
    row = [1]
    while True:
        yield row
        row = next_row(row)


def count_even(iterable):
    return sum(item % 2 == 0 for item in iterable)


def main(limit):
    even = total = 0
    for index, row in enumerate(itertools.islice(pascal_triangle(), limit), 1):
        even += count_even(row)
        total += len(row)
        print('In the first', index, 'lines of the pascal triangle, '
              'there are', total, 'entries.', even, 'of them are even.')


if __name__ == '__main__':
    main(limit=1023)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>IMHO your code is OK, I would propose just using</p>
<pre><code>for i in range(len(r) -1):
    s.append(r[i] + r[i+1])
</code></pre>
<p>instead of </p>
<pre><code>while i &lt; len(r) -1:
    s.append(r[i] + r[i+1])
    i += 1
</code></pre>
<p>PS
If you instead use </p>
<pre><code>for i in range(len(r) -1):
    s.append(r[i] ^ r[i+1])
</code></pre>
<p>You'll see that the results do not change, as suggested by @John Coleman, it works. But the Pascal triangle degenerates into a collection of 0s and 1s, if you print it out.</p>
<p>In this case, you can simplify count_even:</p>
<pre><code>def count_even(r):
    return len(r)-sum(r)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just making your code (first two functions) slightly less verbose using list comprehensions. By doing so, you avoid the need of initializing <code>i=0</code> and an empty list <code>s=[]</code> and the <code>while</code> loop to keep track of the <code>i</code>. In your <code>count_even</code> function, you can also use the following <code>counter = len(r[r%2==0])</code> <em>provided</em> <code>r</code> is an array (In your code it's a list).</p>
<pre><code>def next_row(r):
    s = [r[i] + r[i+1] for i in range(len(r)-1)]
    s.insert(0, 1)
    s.append(1)
    return s

def count_even(r):
    counter =  len([i for i in r if i%2 == 0])
#   counter = len(r[r%2==0]) #  If 'r' is an array
    return counter
</code></pre>
<p>Rest I kept the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>To make the code more readable and also more compact, I suggest you the following solution with <strong>comments</strong>, <strong>f-strings</strong> and <strong>comprehensions</strong> (instead of classic for loops). The main idea is to store the content of each line, the total count of element in each line and the count of even elements in each line inside 3 lists. This way you keep all values of the Pascal triangle in a list, if needed later:  </p>
<pre><code># Initialize first line
lines  = [[1]]  # list of contents of each line (lists)
evens  = [0]    # list of counts of even elements in each line (integers)
totals = [1]    # list of total counts of elements in each line (integers)

# Build next lines
for i in range(1023):
    print(f'In the first {i+1} lines of the pascal triangle, there are {sum(totals)} entries. {sum(evens)} of them are even.')
    lines.append([1] + [lines[i][j] + lines[i][j+1] for j in range(len(lines[i])-1)] + [1])
    totals.append(len(lines[-1]))
    evens.append(len([v for v in lines[-1] if v%2 == 0]))
</code></pre>
</div>
<span class="comment-copy"><a href="https://codereview.stackexchange.com">Code Review</a></span>
<span class="comment-copy">If all you want is the count of the even numbers, why bother to even calculate the numbers? Work mod 2. Make a 0-1 triangle and use the fact that exclusive or (the operator <code>^</code>) corresponds to addition mod 2.</span>
<span class="comment-copy">John Coleman I don't see what you mean, looks to me you are not dealing with the problem.</span>
<span class="comment-copy">Maybe I catch it, you mean using only 0 or 1s instead of the full numbers? - Yes they are sufficient to get parity information.</span>
<span class="comment-copy">The 0-1 triangle that it "degenerates" to is actually rather interesting: it is essentially Sierpinski's triangle. In any event, good answer.</span>
<span class="comment-copy">I did not know... But you are right. <a href="https://en.wikipedia.org/wiki/Sierpinski_triangle#/media/File:Sierpinski_Pascal_triangle.svg" rel="nofollow noreferrer">en.wikipedia.org/wiki/Sierpinski_triangle#/media/â€¦</a></span>
<span class="comment-copy">making the code more compact does not necessarily increase its readability. In this case I think the original code is much more readable.</span>
<span class="comment-copy">@Lorenzo Of course compaction is not readability. Most often they are not compatible. However I think that the application here is simple enough to be coded as I did with enough readability, but it's only my opinion. I also added comments detailing the data structures used.</span>
