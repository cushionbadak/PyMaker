<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>def getdata(page, hed, limit):
    data = []
    print page
    datarALL = []
    url = 'http://...WithTotal=true&amp;cultureid=1&amp;offset={0}&amp;limit={1}'.format(value_offset, value_limit)
    print page
    print url
    responsedata = requests.get(url, data=data, headers=hed, verify=False)
    if responsedata.status_code == 200:  # 200 for successful call
        responsedata = responsedata.text
        jsondata = json.loads(responsedata)
        if "results" in jsondata:
            if jsondata["results"]:
                datarALL = datarALL + jsondata["results"]
    print "page {} finished".format(page)
    return data


def start(data, auth_token):
    # # ---  Get data from API --
    hed = {'Authorization': 'Bearer ' + auth_token, 'Accept': 'application/json'}

    urlApi = 'http://...WithTotal=true&amp;cultureid=1&amp;offset=0&amp;limit=1'
    responsedata = requests.get(urlApi, data=data, headers=hed, verify=False)
    num_of_records = int(math.ceil(responsedata.json()['total']))
    value_limit = 249  # Number of records per page.
    num_of_pages = num_of_records / value_limit
    print num_of_records
    print num_of_pages
    pages = [i for i in range(0, num_of_pages - 1)]
    from concurrent.futures import ThreadPoolExecutor, as_completed
    datarALL = []
    with ThreadPoolExecutor(max_workers=num_of_pages) as executor:
        futh = [executor.submit(getdata(page, hed, value_limit), page) for page in pages]
        for data in as_completed(futh):
            datarALL = datarALL + data.result()
    return datarALL
</code></pre>
<p>Basically <code>start()</code> create pages and <code>getdata()</code> runs per page.
The print shows me:</p>
<pre><code>0
http://...WithTotal=true&amp;cultureid=1&amp;&amp;offset=0&amp;limit=249
page 0 finished
1
http:/...WithTotal=true&amp;cultureid=1&amp;&amp;offset=249&amp;limit=249
page 1 finished
etc...
</code></pre>
<p>However I expected that all pages would be created on the same time then each one of them runs when the thread gets CPU time but what actually happens is that only when <code>getdata()</code> finishs The next page is created. Which means the threads are useless here. I should note that each <code>getdata()</code> call takes about 4-5 minutes to finish.</p>
<p>I suspect that the problem is here:</p>
<pre><code>futh = [executor.submit(getdata(page, hed, value_limit), page) for page in pages]
</code></pre>
<p>It waits for <code>getdata()</code> to finish before the next loop run.</p>
<p>How can I fix it and make it works with the threads?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you're not executing tasks in the executor at all. Instead, you're calling the 5-minute function, then trying to execute its <em>result</em> as a task:</p>
<pre><code>[executor.submit(getdata(page, hed, value_limit), page) for page in pages]
</code></pre>
<p>That <code>getdata(page, hed, value_limit)</code> is a function call: it calls <code>getdata</code> and waits for its return value.</p>
<p>What you need to do is pass the function itself to <code>submit</code>, like this:</p>
<pre><code>executor.submit(getdata, page, hed, value_limit)
</code></pre>
<p>I'm not sure what you're trying to do with the extra <code>, page</code>, but if you wanted a list of <code>(future, page)</code> tuples, that would be:</p>
<pre><code>[(executor.submit(getdata, page, hed, value_limit), page) for page in pages]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to submit a function (without actually calling it!) to <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.submit" rel="nofollow noreferrer"><code>executor.submit</code></a>. So in your particular case, you should fix the <code>hed</code> and <code>value_limit</code> arguments in the <code>getdata</code> function to make it a function with a single argument <code>page</code>.</p>
<p>The easiest solution may look like the following:</p>
<pre><code>getdata_partial = lambda page: getdata(page, hed, value_limit)
</code></pre>
<p>Then you could use it as shown below:</p>
<pre><code>futh = [executor.submit(getdata_partial, page) for page in pages]
</code></pre>
<p>Another possible solution is to use <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer">functools.partial</a>. You may find it even more elegant, but the idea is still the same.</p>
</div>
<span class="comment-copy">Is that 4-5 minutes mostly CPU-bound, running heavy computation? If so, in CPython, the Global Interpreter Lock (GIL) means only one of them can progress at a time. Threads are great when you have IO-bound computation (like waiting on network servers), but not very helpful for CPU-bound work. But if that's the issue, you can usually fix it by just changing the <code>ThreadPoolExecutor</code> to a <code>ProcessPoolExecutor</code>. As long as they don't need any shared data, and the arguments and return values are picklable types and not too huge, it just works.</span>
<span class="comment-copy">@abarnert The function makes API call there is no havey calculation there.. It mostly waiting for records to be fetched. The action that takes all time there is: <code>requests.get(uri, data=data, headers=hed, verify=False)</code>. There is no shared data between the threads.. each thread brings another chunk of 249 then I merge them all together.</span>
<span class="comment-copy">@abarnert see edit.. I added the full function code.</span>
<span class="comment-copy">I'm not sure I'm following. This is the first time I'm trying multithreading. This code is based on example I saw.. I passed the page argument just for the printing. It's not actually needed. The [(executor.submit(getdata, page, hed, value_limit), page) for page in pages] works great! I'm open to any further suggestion you have..</span>
<span class="comment-copy">@Programmer120 It's not about multithreading, If you want to pass a function to someone—whether it's as a task for <code>ThreadPoolExecutor</code>, or as a callback for a <code>tkinter.Button</code>, or whatever—you have to pass the function, not call the function and pass the result.</span>
<span class="comment-copy">You don't need to use <code>lambda</code> here; <code>execute.submit</code> takes a function, <code>*args</code>, and <code>**kwargs</code>. And you're already taking advantage of that by passing <code>page</code> as an argument, so there's no reason to treat the other arguments any differently.</span>
<span class="comment-copy">Also, I know people misuse the term all the time, but if you're going to use technical terms novices don't understand, you really should be careful to get them right. A curried function and a partially-applied function are not the same thing. A curried function is one that takes its arguments one at a time, returning a new function. If you actually had a curried <code>getdata</code> function, you'd call it as <code>getdata_curried(page)(hed)(value_limit)</code>.</span>
<span class="comment-copy">Completely agreed, thanks for your remarks! Will change <code>getdata_curried</code> to <code>getdata_partial</code> :)</span>
<span class="comment-copy">Regarding the usage of <code>lambda</code>, it's more of a personal preference to explicitly show that in the current context it's only the <code>page</code> argument that really matters and allows us to differentiate between the submitted tasks.</span>
