<div class="post-text" itemprop="text">
<p>I'm trying to run a .csv file through a python code in order to give me a new csv with better formatting. I could use help because the script that I have written is not working. I'm pretty new to this stuff.</p>
<p>I'm adding two photos to this message, one is an example input file and the other is an example of the desired output file. Obviously, the output file would be much easier to use, to make pivot table, graphs, etc in excel. </p>
<p>I think I'm getting stuck on the fields list, [0],<a href="https://i.stack.imgur.com/GrJ8T.png" rel="nofollow noreferrer">2</a>,<a href="https://i.stack.imgur.com/GrJ8T.png" rel="nofollow noreferrer">2</a>, etc. I'm also getting stuck on whether or not this should be a tab-delimited or comma-delimited file, because there are a lot of symbols in the document,randomly: ; , @ : - etc. </p>
<p><a href="https://i.stack.imgur.com/EnXOi.png" rel="nofollow noreferrer">input file</a>
<a href="https://i.stack.imgur.com/GrJ8T.png" rel="nofollow noreferrer">output file</a></p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>person_name = ''
birth_date = ''
sex = ''

def read_file(file_name,out_file):
    global person_name, birth_date, sex, date_loanrequest,    
     date_loanreturned, type, amount, days_returned
    with open(file_name, 'r+') as in_file:
        with open(out_file, 'w+') as out_file:
            for line in in_file:
                line = line.strip()
                if line == "":
                    continue
                fields = line.split('\t')
                print(fields[0])
                print(fields[1])
                print(fields[2])
                print(fields[3])
                print(fields[4])
                print(fields[5])
                print(len(fields))
                if line.find('Person Name') != -1:
                    patient_name, Birth Date =  fields[1], fields[2]
                elif line.find('Address') != -1:
                    sex = fields[3]
                elif line.find('Date LoanRequest') != -1:
                    date_loanrequest = fields[3]
                elif line.find('Date LoanReturned') != -1:
                    date_loanreturned = fields[3]
                     elif line.find('Type') != -1:
                    type = fields[3]
                     elif line.find('Amount') != -1:
                    amount = fields[3]
                    elif line.find('Days Returned') != -1:
                    days_returned = fields[3]
                else:
                    out_file.write('%s,%s,%s,%s,%s,%s,%s,%s,%s' %
                       (person_name, birth_date, sex,  
                        date_loanrequest, date_loanreturned, type,  
                        amount, days_returned  
                       fields[0], fields[1], fields[2],  fields[3],                        fields[4], fields[5] + '\n'))


if __name__=='__main__':
    '''file_name=sys.argv[1]
        out_file=sys.argv[2]'''
    file_name = 'file_name.csv'
    out_file = 'out_file.csv'
    read_file(file_name,out_file)</code></pre>
</div>
</div>
</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have recommended, there is a built in <a href="https://docs.python.org/2/library/csv.html" rel="nofollow noreferrer">CSV</a> library that is going to be your best bet.</p>
<p>There are a couple other things to point out though. First, there is a cleaner way to skip the header line. Instead of checking each time if the header titles are in the current line, just use this concept:</p>
<pre><code>firstLine = True
for line in file:
   if not firstLine:
      # do work
   else:
      firstLine = False
</code></pre>
<p>This makes it so the first line you read (the headers) will do nothing except flip the boolean flag, and then from there on you don't have to worry.</p>
<p>Also keep in mind csv files always have the delimiters even if the entries between them are blank, and split will always split on your delimiter regardless of whats in between. What this means is that <code>sex</code> will always be <code>fields[3]</code> no matter what, it just might be empty. To see what I'm talking about, run this:</p>
<pre><code> s = ",,,"
 s.split(',')
</code></pre>
<p>You'll get an array back with 4 empty elements. So to fix your issue with fields, don't bother worrying about what is and isn't filled in, just always assign each variable the same field index (and handle empty entries if you need to).</p>
<p>Finally, handling delimiters. You're on the right track, the easiest approach in my opinion is finding a character that is never used in the actual text. I recommend pipes or tildas (<code>| ~</code>) since these most likely will never come up in your fields. Another option is to preprocess the file and replace all commas with semi-colons, that way you can then use a regular comma as a delimiter. </p>
</div>
<span class="comment-copy">take a look at the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a></span>
<span class="comment-copy">I would strongly recommend using the <b>csv</b> module to perform read and write actions against CSV file types. You can find the documentation for this module <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">here</a>.</span>
<span class="comment-copy">There's an even cleaner way to skip the first line: just call <code>next(file)</code> before the <code>for</code> loop.</span>
