<div class="post-text" itemprop="text">
<p>I'm looking for a way to merge multiple dicts with each other, which contain nested dicts too. The number of nested dicts is not static but dynamic.</p>
<p>At the end the Final dict should contain all the dicts of dicts and the sum of their values:</p>
<pre><code>COUNTRY1 = {'a': {'X': 10, 'Y': 18, 'Z': 17}, 'b': {'AA':{'AAx':45,'AAy':22},'BB':{'BBx':45,'BBy':22}}, 'c': 100}
COUNTRY2 = {'a': {'U': 12, 'V': 34, 'W': 23}, 'b': {'AA':{'AAz':23,'AAa':26},'BB':{'BBz':11,'BBa':15}}, 'c': 115}
COUNTRY3 = {'a': {'Y': 15, 'Z': 14, 'X': 12}, 'b': {'AA':{'AAx':45,'AAz':22},'BB':{'BBy':45,'BBz':22}}, 'c': 232}

# After merging the dictionaries the result should look like:
ALL
&gt;&gt;&gt; {'a': {'X': 22, 'Y': 33, 'Z': 31, 'U': 12, 'V': 34, 'W': 23}, 'b': {'AA':{'AAx':90,'AAy':22,'AAz':45,'AAa':26},'BB':{'BBx':45,'BBy':67, 'BBz':33,'BBa':15}}, 'c': 447}
</code></pre>
<p>I tried the following code which allows nested dicts to a max of 3 nested dicts. Unfortunately the code doesn't do what I expected. Thereby it doesn't look very clean, I feel like this could be done with a recursive function, however I can't find a way to do it.</p>
<pre><code>COUNTRIES = ['COUNTRY1','COUNTRY2', 'COUNTRY3']
ALL = {}
for COUNTRY_CODE in COUNTRIES:

    COUNTRY = pickle.load(open(COUNTRY_CODE+".p", "rb"))
    keys = COUNTRY.keys()
    for key in keys:
        try:
            keys2 = COUNTRY[key].keys()
            print(key, keys2)

            for key2 in keys2:
                try:
                    keys3 = COUNTRY[key][key2].keys()
                    print(key2, keys3)

                    for key3 in keys3:
                        try:
                            keys4 = COUNTRY[key][key2][key3].keys()
                            print(key3, keys4)
                        except:
                            print(key3, "NO KEY3")
                            if not key3 in ALL[key][key2]:
                                ALL[key][key2][key3] = COUNTRY[key][key2][key3]
                            else:
                                ALL[key][key2][key3] =+ COUNTRY[key][key2][key3]

                except:
                    print(key2, "NO KEY2")
                    if not key2 in ALL[key]:
                        ALL[key][key2] = COUNTRY[key][key2]
                    else:
                        ALL[key][key2] =+ COUNTRY[key][key2]

        except:
            print(key, "NO KEY")
            if not key in ALL:
                ALL[key] = COUNTRY[key]
            else:
                ALL[key] =+ COUNTRY[key]

print(ALL)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make two functions like below:</p>
<pre><code>def cal_sum(lst):
    final_dict = dict()
    for l in lst:
        sum(final_dict,l)
    return final_dict

def sum(final_dict,iter_dict):
    for k, v in iter_dict.items():
        if isinstance(v, dict):
            sum(final_dict.setdefault(k, dict()), v)
        elif isinstance(v, int):
            final_dict[k] = final_dict.get(k, 0) + v
</code></pre>
<p>Calling the above code as follows produces the desired output:</p>
<pre><code>&gt;&gt;&gt; print(cal_sum([COUNTRY1, COUNTRY2, COUNTRY3]))
{'a': {'U': 12, 'W': 23, 'V': 34, 'Y': 33, 'X': 22, 'Z': 31}, 'c': 447, 'b': {'AA': {'AAa': 26, 'AAy': 22, 'AAx': 90, 'AAz': 45}, 'BB': {'BBa': 15, 'BBz': 33, 'BBy': 67, 'BBx': 45}}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that you need to determine what to do with a dictionary key based on the type of the value. The basic idea is:</p>
<ul>
<li>Input is a pair of dictionaries, output is the sum dictionary</li>
<li>Step along both input dictionaries</li>
<li>If a value is a dictionary, recurse</li>
<li>If a value is a number, add it to the other number</li>
</ul>
<p>This is fairly easy to implement with a comprehension:</p>
<pre><code>def add_dicts(d1, d2):
    def sum(v1, v2):
        if v2 is None:
            return v1
        try:
            return v1 + v2
        except TypeError:
            return add_dicts(v1, v2)
    result = d2.copy()
    result.update({k: sum(v, d2.get(k)) for k, v in d1.items()})
    return result
</code></pre>
<p>The copy ensures that any keys in <code>d2</code> that are not also in <code>d1</code> are simply copied over.</p>
<p>You can now sum as follows:</p>
<pre><code>ALL = add_dicts(add_dicts(COUNTRY1, COUNTRY2), COUNTRY3)
</code></pre>
<p>More generally, you can use <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer"><code>functools.reduce</code></a> to do this for an indefinite number of dictionaries:</p>
<pre><code>dicts = [COUNTRY1, COUNTRY2, COUNTRY3]
ALL = reduce(add_dicts, dicts)
</code></pre>
</div>
<span class="comment-copy">What you tried? Please paste something.</span>
<span class="comment-copy">I just added my code to the post.</span>
<span class="comment-copy">Where does your code fail? What does your current output look like?</span>
<span class="comment-copy">The code seems to work if the keys in different dicts are unique however if the keys are the same, the second dictionary will overwrite the first dictionary's value</span>
<span class="comment-copy">Another clean looking answer however this didn't work for me in Python 3.6. I think iteritems() is not allowed on dicts anymore in Python 3?</span>
<span class="comment-copy">@Sem Have updated the answer. Check if it works now?</span>
<span class="comment-copy">For some reason some nested dicts are empty after running this code. I'll stick to the code of @Mad Physicist now, however thanks for the effort!</span>
<span class="comment-copy">For the inputs in your question, it is working fine. Can you list the dicts for which it is causing the problem?</span>
<span class="comment-copy">I found out it was because some values in my dicts were floats instead of ints. I changed the last elif to:     elif isinstance(v, int) or isinstance(v, float): Which solved the problem. I like this solution as I can specify per type how to handle the data, this might be even more powerful than @Mad Physicist's solution.</span>
<span class="comment-copy">Thanks, seems to be working great!</span>
