<div class="post-text" itemprop="text">
<p>I want to execute a Python file from another Python file and show all <code>print()</code> outputs and error outputs without waiting (realtime).</p>
<p>The simplified version of my code is as follows and I would like to show "start" and an error message without waiting for "end" (the end of the script).</p>
<pre><code>def main():
    # Function that takes a long time (in my actual code)
    x += 1 # this raises an error

if __name__ == "main":
    print("start")
    main()
    print("end")
</code></pre>
<p>I also have <code>run.py</code>:</p>
<pre><code>import subprocess

def run():
    subprocess.run(["python", "main.py"])


if __name__ == '__main__':
    run()
</code></pre>
<p>I tried <a href="https://www.endpoint.com/blog/2015/01/28/getting-realtime-output-using-python" rel="nofollow noreferrer">this blog post</a> and several other similar answers on stackoverflow, but none of them worked, so I decided to put my original code here, which is above.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following seems to work for me (on Windows). It uses <code>subprocess.Popen()</code> to execute the other script because this gives more control over what goes on. It turns <code>buffering</code> off to eliminate any delays that might cause, plus it redirects stderr to stdout to so all output can be retrieved from a single source.. Also note it also includes the correction @Ketan Mukadam mentions is <a href="https://stackoverflow.com/a/51918439/355230">his answer</a> tregarding the value of <code>__name__</code> in your first script.</p>
<p><strong><code>main_script.py</code></strong>:</p>
<pre><code>def main():
    # Function that takes a long time (in my actual code)
    x += 1 # this raises an error

if __name__ == '__main__':
    print("start")
    main()
    print("end")
</code></pre>
<p><strong><code>run.py</code></strong>:</p>
<pre><code>import subprocess
import sys

def run():
    kwargs = dict(bufsize=0,  # No buffering.
                  stdout=subprocess.PIPE,
                  stderr=subprocess.STDOUT,  # Redirect stderr to stdout.
                  universal_newlines=True)
    args = [sys.executable, 'main_script.py']

    with subprocess.Popen(args, **kwargs).stdout as output:
        for line in output:
            print(line, end='')  # Process the output...

if __name__ == '__main__':
    run()
</code></pre>
<p>Output from executing <code>run.py</code>:</p>
<pre class="lang-none prettyprint-override"><code>start
Traceback (most recent call last):
  File "main_script.py", line 10, in &lt;module&gt;
    main()
  File "main_script.py", line 6, in main
    x += 1 # this raises an error
UnboundLocalError: local variable 'x' referenced before assignment
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this line a mistake?</p>
<pre><code>if __name__ == "main":
</code></pre>
<p>The symbol is <code>__main__</code> set by interpreter and not <code>main</code>. It is possible that because of this typo error no code is running from main script. Try first executing the main script directly on command shell. </p>
</div>
<span class="comment-copy">try using check_output() <a href="https://stackoverflow.com/a/8235171/546375">stackoverflow.com/a/8235171/546375</a></span>
<span class="comment-copy">What difficulties did you have implementing the blog post you linked? stdout is buffered so you might want to do <code>print('start', flush=True)</code> to force output so the listening process has something to retrieve...</span>
<span class="comment-copy">I do not think subprocess has a <code>run()</code> method, it should be <code>call()</code>, right?</span>
<span class="comment-copy">@KetanMukadam: <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer">It does in Python 3.5+.</a></span>
<span class="comment-copy"><i>Or</i>, just try changing it to <code>if __name__ == '__main__':</code> like it should be...</span>
