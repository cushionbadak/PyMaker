<div class="post-text" itemprop="text">
<p>I want to find the integer that occurs most commonly within a nested list, and return the integer along with its number of occurrences (and multiple integers and their occurrences where multiple integers occur the same number of times). The data is currently in the following form:</p>
<pre><code>list_of_lists = 
    [[11, 53],
     [2, 137],
     [2, 7, 31],
     [2, 2, 7, 31],
     [3, 3, 3, 29],
     [2, 2, 2, 3, 137],
     [2, 2, 7, 31],
     [11, 53]]
</code></pre>
<p>Therefore, the desired output would be <code>[[3, 3], [2, 3]]</code>, number 3 occurred 3 times in the fifth nested list, and number 2 occurred 3 times in the sixth nested list.</p>
<p>Neither the list nor the lists within the list are of fixed length. Therefore a program that solves this for variable lengths would be greatly appreciated!</p>
<p>I couldn't find a similar question directly on point.</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.Counter</code> to count the occurrence of elements in each list and then, sort the resulting list based on occurrence in reverse order, then group the results (using <code>itertools.groupby</code>) to get all results with same maximum value</p>
<pre><code>&gt;&gt;&gt; from itertools import chain, groupby
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; 
&gt;&gt;&gt; ll = [[11, 53], [2, 137], [2, 7, 31], [2, 2, 7, 31], [3, 3, 3, 29], [2, 2, 2, 3, 137], [2, 2, 7, 31], [11, 53]]
&gt;&gt;&gt;
&gt;&gt;&gt; f = lambda t: t[1]
&gt;&gt;&gt; list(next(groupby(sorted(chain(*(Counter(l).items() for l in ll)), key=f, reverse=True), f))[1])
[(3, 3), (2, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I used a slightly more complicated list for testing: some values repeated twice, some 3 times, appearing in the same and in different sublists.</p>
<p>We use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer">Counter</a> in each sublist, and keep a dictionary of the highest count we see for each value. At the end, we build the output list, keeping only the values that were repeated the highest number of times in each line.</p>
<pre><code>list_of_lists =[[11, 11, 53], # 11 is repeated 2 times, 
 [2, 137],                    # it shouldn't appear in the result
 [2, 7, 31],
 [2, 2, 7, 31],
 [3, 3, 3, 4, 4, 4, 5, 5, 5, 29],     # 3 times 3, 4 and 5
 [2, 2, 2, 3, 137],                   # and 3 times 2
 [2, 2, 7, 31],
 [11, 53]]

from collections import Counter, defaultdict

def maxcount(list_of_lists):
    out = defaultdict(int)
    max_repetitions = 0
    for sublist in list_of_lists:
        for value, count in Counter(sublist).items():
            if count &gt; 1 and count &gt; out[value]:
                out[value] = count
                if count &gt; max_repetitions:
                    max_repetitions = count


    return([[val, count] for val, count in out.items() if count == max_repetitions])

print(maxcount(list_of_lists))
# [[2, 3], [3, 3], [4, 3], [5, 3]]
</code></pre>
<hr/>
<p>I like <code>itertools</code>, so I was curious to compare @Sunitha's solution with this one.</p>
<p>This solution:</p>
<pre><code>*%timeit maxcount(list_of_lists)
# 65 µs ± 269 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p>@Sunitha's solution with more use of itertools:</p>
<pre><code>from itertools import chain, groupby
from collections import Counter

def maxcount_with_itertools(ll):
    f = lambda t: t[1]
    return list(next(groupby(sorted(chain(*(Counter(l).items() for l in ll)), key=f, reverse=True), f))[1])

%timeit maxcount_with_itertools(list_of_lists)
# 70.9 µs ± 1.39 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p>which is just a little bit slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're interested in doing it using pure Python, then there is the following way:</p>
<pre><code>list_of_lists = [[11, 53],[2, 137],[2, 7, 31],[2, 2, 7, 31],[3, 3, 3, 29],[2, 2, 2, 3, 137],[2, 2, 7, 31],[11, 53]]

maxOccurences = [max([[elem,sublist.count(elem),index] for elem in sublist], key=lambda i:sublist.count(i)) for index, sublist in enumerate(list_of_lists)]
maximum = max(maxOccurences, key=lambda i: i[1])
elements = [elem[:2] for elem in maxOccurences if elem[1]==maximum[1]]
print(elements)
</code></pre>
<p>Output:</p>
<pre><code>[[3, 3], [2, 3]]
</code></pre>
<p>Another suggestion would be the following:</p>
<pre><code>list_of_lists = [[11, 53],[2, 137],[2, 7, 31],[2, 2, 7, 31],[3, 3, 3, 29],[2, 2, 2, 3, 137],[2, 2, 7, 31],[11, 53]]

maximum = max([max([[elem,sublist.count(elem)] for elem in sublist], key=lambda i:sublist.count(i)) for sublist in list_of_lists], key=lambda i: i[1])
elements = [[elem,sublist.count(elem)] for sublist in list_of_lists for elem in set(sublist) if sublist.count(elem)==maximum[1]]
print(elements)
</code></pre>
<p>Output:</p>
<pre><code>[[3, 3], [2, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>collections.Counter</code>, split into 3 steps:</p>
<ol>
<li>Convert your lists into <code>Counter</code> objects via <code>map</code>.</li>
<li>Calculate the count of the most common value(s) via <code>max</code>.</li>
<li>Use a list comprehension to filter <code>Counter</code> objects derived from your sublists.</li>
</ol>
<p>Here's a demo.</p>
<pre><code>from collections import Counter

counters = list(map(Counter, list_of_lists))
most_common_count = max(i.most_common(1)[0][1] for i in counters)

res = [(k, v) for i in counters for k, v in i.items() if v == most_common_count]

print(res)

[(3, 3), (2, 3)]
</code></pre>
</div>
<span class="comment-copy">Improved formatting and punctuation</span>
