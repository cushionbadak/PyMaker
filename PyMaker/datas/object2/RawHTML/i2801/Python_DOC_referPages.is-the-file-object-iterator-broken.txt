<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="noreferrer">documentation</a>:</p>
<blockquote>
<p>Once an iterator’s <code>__next__()</code> method raises <code>StopIteration</code>, it must
  continue to do so on subsequent calls. Implementations that do not
  obey this property are deemed broken.</p>
</blockquote>
<p>However, for file-objects:</p>
<pre><code>&gt;&gt;&gt; f = open('test.txt')
&gt;&gt;&gt; list(f)
['a\n', 'b\n', 'c\n', '\n']
&gt;&gt;&gt; next(f)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
&gt;&gt;&gt; f.seek(0)
0
&gt;&gt;&gt; next(f)
'a\n'
</code></pre>
<p>Are file-object iterators broken? Is this just one of those things that can't be fixed because it would break too much existing code that relies one it?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is, if anything, a docs bug on that paragraph, not a bug in <code>io</code> objects. (And <code>io</code> object’s aren’t the only thing—most trivially, a <code>csv.reader</code> wrapper around a file is just as restartable as a file.)</p>
<p>If you just use an iterator as an iterator, once it raises it will keep on raising. But if you call methods outside of the iterator protocol, you’re not really using it as an iterator anymore, but as something more than an iterator. And in that case, it seems legal and even idiomatic for the object to be “refillable” if it makes sense. As long as it never refills itself while it’s quacking as an iterator, only when it’s quacking as some other type that goes beyond that.</p>
<p>In a similar situation in C++, the language committee might well declare that this breaks substitutability and therefore the iterator becomes invalid as an iterator once you call such a method on it, even if the language can’t enforce that. Or come up with a whole new protocol for refillable iterators. (Of course C++ iterators aren’t quite the same thing as Python iterators, but hopefully you get what I mean.)</p>
<p>But in Python, practicality beats purity. I’m pretty sure Guido intended this behavior from the start, and that an object is allowed to do this and still be considered an iterator, and the core devs continue to intend it, and it’s just that nobody has thought about how to write something sufficiently rigorous to explain it accurately because nobody has asked. </p>
<p>If you ask by filing a docs bug, I’ll bet that this paragraph gets a footnote, rather than the <code>io</code> and other refillable iterator objects being reclassified as not actually iterators.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, file iterators are "deemed broken" according to the section of the <a href="https://docs.python.org/3/library/stdtypes.html" rel="nofollow noreferrer">stdtypes documentation</a> quoted in the question. Both the Python 3 iterator <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>TextIOWrapper</code></a> and the Python 2 iterator <a href="https://docs.python.org/2/library/stdtypes.html#bltin-file-objects" rel="nofollow noreferrer"><code>file</code></a> are broken.</p>
<p>This is something worth keeping in mind if you're using code which assumes iterators are strictly adhering to the iterator protocol. To give one example, using the Python implementation of <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow noreferrer"><code>itertools.dropwhile</code></a> in combination with a file iterator is buggy. You might encounter issues by iterating a log file whilst another process is still appending lines to the log file.</p>
<p>There was a discussion about this question in the mailing lists.  Search the <a href="https://mail.python.org/pipermail/python-list/2008-September/thread.html" rel="nofollow noreferrer">September 2008 archives</a> for <em>Why are "broken iterators" broken?</em>  A couple of quotes:</p>
<p><a href="https://mail.python.org/pipermail/python-list/2008-September/479148.html" rel="nofollow noreferrer">Miles</a>:</p>
<blockquote>
<p>Strictly speaking, file objects are broken iterators.</p>
</blockquote>
<p><a href="https://mail.python.org/pipermail/python-list/2008-September/508322.html" rel="nofollow noreferrer">Fredrik Lundh</a>:</p>
<blockquote>
<p>It's a design guideline, not an absolute rule.</p>
</blockquote>
<p>And <a href="https://mail.python.org/pipermail/python-list/2008-September/487367.html" rel="nofollow noreferrer">Terry Reedy</a>:</p>
<blockquote>
<p>It is quite possible that a stream reader will return '' on one call and then something non-empty the next.  An iterator that reads a stream 
  and yields chunks of whatever size should either block until it gets 
  sufficient data or yield nulls as long as the stream is open and not 
  raise StopIteration until the steam is closed and it has yielded the 
  last chunk of data.</p>
<p>There is an important different between a store that is closed until the 
  next day and one that closed - out of business.  Similarly, there is a 
  difference between an item being out-of-stock until the next delivery 
  and out-of-stock and discontinued permanently, or between a road closed 
  for repairs versus removal for something else.  Using the same sign or 
  signal for temporary and permanent conditions is confusing and therefore 'broken'.</p>
</blockquote>
<p>I think this behavior is unlikely to change in the language ("Practicality beats purity"), but perhaps the language in the docs will be softened up. There is an existing open issue about that, if you want to follow it: <a href="https://bugs.python.org/issue23455" rel="nofollow noreferrer">issue23455</a></p>
</div>
<span class="comment-copy">I guess that` file.seek(0)` call <code>iter()</code> again on the file object and then call <code>next()</code> however many times you put in the <code>seek()</code> call</span>
<span class="comment-copy">But <code>iter(f) is f</code>, it's the same iterator object anyway. Even if it wasn't, it would have to magically rebind it to <code>f</code>.</span>
<span class="comment-copy">Which version of python is this?</span>
<span class="comment-copy">Python 3.6, but this works on other versions as well</span>
<span class="comment-copy">@coldspeed It’s definitely been true since 2.3. Probably 2.2 (when iterators and <code>file</code> objects were added), but I’m not positive on that. And the same thing will happen in Jython, etc.</span>
<span class="comment-copy">Practicality beats purity :)</span>
<span class="comment-copy">Does this need some ancient history archaeology, or quotes from discussions on the periodic proposals to add more concepts? (I vaguely remember Guido saying something like “Yes, it’s a real distinction, but one that no program and no programmer will ever want to make” in arguing against Nick Coghlan’s <code>Collection</code> for an iterable that always returns iterators over the same values when you call <code>iter</code> twice without mutating in between.)</span>
