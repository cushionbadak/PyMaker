<div class="post-text" itemprop="text">
<p>Is there a built-in function that works like zip(), but fills the results so that the length of the resulting list is the length of the longest input and fills the list <strong>from the left</strong> with e.g. <code>None</code>?</p>
<p>There is already an <a href="https://stackoverflow.com/a/1277311/2648551">answer</a> using <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">zip_longest</a> from <code>itertools</code> module and the corresponding <a href="https://stackoverflow.com/q/1277278/2648551">question</a> is very similar to this. But with <code>zip_longest</code> it seems that you can only fill missing data from the right.</p>
<p>Here might be a use case for that, assuming we have names stored only like this (it's just an example):</p>
<pre><code>header = ["title", "firstname", "lastname"]
person_1 = ["Dr.", "Joe", "Doe"]
person_2 = ["Mary", "Poppins"]
person_3 = ["Smith"]
</code></pre>
<p>There is no other permutation like (<code>["Poppins", "Mary"]</code>, <code>["Poppins", "Dr", "Mary"]</code>) and so on.</p>
<p>How can I get results like this using built-in functions?</p>
<pre><code>&gt;&gt;&gt; dict(magic_zip(header, person_1))
{'title': 'Dr.', 'lastname': 'Doe', 'firstname': 'Joe'}
&gt;&gt;&gt; dict(magic_zip(header, person_2))
{'title': None, 'lastname': 'Poppins', 'firstname': 'Mary'}
&gt;&gt;&gt; dict(magic_zip(header, person_3))
{'title': None, 'lastname': 'Smith', 'firstname': None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <strong><code>zip_longest</code></strong> but reverse lists.</p>
<p><strong>Example</strong>:</p>
<pre><code>from itertools import zip_longest

header = ["title", "firstname", "lastname"]
person_1 = ["Dr.", "Joe", "Doe"]
person_2 = ["Mary", "Poppins"]
person_3 = ["Smith"]

print(dict(zip_longest(reversed(header), reversed(person_2))))
# {'lastname': 'Poppins', 'firstname': 'Mary', 'title': None}
</code></pre>
<p>On your use cases:</p>
<pre><code>&gt;&gt;&gt; dict(zip_longest(reversed(header), reversed(person_1))) 
{'title': 'Dr.', 'lastname': 'Doe', 'firstname': 'Joe'}
&gt;&gt;&gt; dict(zip_longest(reversed(header), reversed(person_2)))
{'lastname': 'Poppins', 'firstname': 'Mary', 'title': None} 
&gt;&gt;&gt; dict(zip_longest(reversed(header), reversed(person_3))) 
{'lastname': 'Smith', 'firstname': None, 'title': None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simply use <code>zip_longest</code> and read the arguments in the reverse direction:</p>
<pre><code>In [20]: dict(zip_longest(header[::-1], person_1[::-1]))
Out[20]: {'lastname': 'Doe', 'firstname': 'Joe', 'title': 'Dr.'}

In [21]: dict(zip_longest(header[::-1], person_2[::-1]))
Out[21]: {'lastname': 'Poppins', 'firstname': 'Mary', 'title': None}

In [22]: dict(zip_longest(header[::-1], person_3[::-1]))
Out[22]: {'lastname': 'Smith', 'firstname': None, 'title': None}
</code></pre>
<p>Since the zip* functions need to be able to work on general iterables, they don't support filling "from the left", because you'd need to exhaust the iterable first.    Here we can just flip things ourselves.</p>
</div>
<div class="post-text" itemprop="text">
<p>The generic "magic zip" generator function with a variable number of args (which only uses lazy-evaluation functions and no python loops):</p>
<pre><code>import itertools

def magic_zip(*args):
    return itertools.zip_longest(*map(reversed,args))
</code></pre>
<p>testing (of course in the case of a dict build, only 2 params are needed):</p>
<pre><code>for p in (person_1,person_2,person_3):
    print(dict(magic_zip(header,p)))
</code></pre>
<p>result:</p>
<pre><code>{'lastname': 'Doe', 'title': 'Dr.', 'firstname': 'Joe'}
{'lastname': 'Poppins', 'title': None, 'firstname': 'Mary'}
{'lastname': 'Smith', 'title': None, 'firstname': None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def magic_zip(*lists):
    max_len = max(map(len, lists))
    return zip(*([None] * (max_len - len(l)) + l for l in lists))
</code></pre>
</div>
<span class="comment-copy">Great! This works without importing anything which is also nice to have!</span>
