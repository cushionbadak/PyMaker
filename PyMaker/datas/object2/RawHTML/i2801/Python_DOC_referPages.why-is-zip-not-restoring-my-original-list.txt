<div class="post-text" itemprop="text">
<p>I'm trying to understand what is happening:</p>
<pre><code>a = list('hello world')
b = [a[i::l]for i in range(8)]
</code></pre>
<p>I would then expect that:</p>
<pre><code>zip(*b) == a
</code></pre>
<p>However what I get is the following:</p>
<pre><code> [('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o')]
</code></pre>
<p>Maybe it's a failing on my part to understand what zip(*) doe but I thought it unpacks a list of list and makes a single list out of it. Where am I going wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You missed a detail specific to <code>zip()</code>, as <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">outlined in the documentation</a>:</p>
<blockquote>
<p>The iterator stops when the shortest input iterable is exhausted</p>
</blockquote>
<p><code>hello world</code> has 11 characters in it, a prime number, so apart from a list of 11 separate sequences with each one character, there is no way to produce a list of lists without at least one of those being shorter.</p>
<p>For example, if we presume that <code>l = 8</code> (anything 5 and over would produce the output you've shown), then <code>a</code> is set to:</p>
<pre><code>[['h', 'r'], ['e', 'l'], ['l', 'd'], ['l'], ['o'], [' '], ['w'], ['o']]
</code></pre>
<p>That's 8 lists, with the first containing 2 elements, the remainder have just one. So only the <em>first elements</em> of these are then used to produce combinations:</p>
<pre><code>&gt;&gt;&gt; [l[0] for l in b]
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o']
</code></pre>
<p>You only looped 8 times, so there only 8 top-level lists in <code>b</code> to take letters from. For different values of <code>l</code> of 5 or up you'll get a different distribution of the remaining letters but with only 3 more characters remaining there aren't many ways of distributing those remaining letters across the lists, and with <code>l</code> below <code>8</code>, you just add repeated letters (as <code>[0::l]</code> and <code>[7::l]</code> are guaranteed to overlap for any <code>l</code> equal to 7 or lower).</p>
<p>You'd have to loop up to 11 times and take every 11th character to get something that'll zip to the same sequence:</p>
<pre><code>&gt;&gt;&gt; b = [a[i::11]for i in range(11)]
&gt;&gt;&gt; b
[['h'], ['e'], ['l'], ['l'], ['o'], [' '], ['w'], ['o'], ['r'], ['l'], ['d']]
&gt;&gt;&gt; list(zip(*b))
[('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')]
</code></pre>
<p><em>This still isn't the same as <code>a</code></em>, because <code>zip()</code> produces sequence of sequences (here it's just one because there is only a single value in each nested list). You could use <code>next()</code> to get the first (and only) element:</p>
<pre><code>&gt;&gt;&gt; a == list(next(zip(*b)))
True
</code></pre>
<p>You can instead use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><code>itertools.zip_longest()</code></a> to continue iteration until the <em>longest</em> input iterable is exhausted, and add a default filler value to augment the shorter sequences. An empty string would work if you wanted to join the sequences back to whole strings again:</p>
<pre><code>try:
    # Python 3
    from itertools import zip_longest
except ImportError:
    # Python 2 has the same object, but with i prefixed
    from itertools import izip_longest as zip_longest

result = list(zip_longest(*b, fillvalue=''))
</code></pre>
<p>This however produces <strong>two</strong> tuples; there are two columns in the input, after all:</p>
<pre><code>&gt;&gt;&gt; from itertools import zip_longest
&gt;&gt;&gt; b = [a[i::8]for i in range(8)]
&gt;&gt;&gt; list(zip_longest(*b, fillvalue=''))
[('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o'), ('r', 'l', 'd', '', '', '', '', '')]
</code></pre>
<p>You'd have to chain them to re-combine them; <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>itertools.chain.from_iterable()</code></a> could do that:</p>
<pre><code>&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; ''.join(chain.from_iterable(zip_longest(*b, fillvalue='')))
'hello world'
</code></pre>
<p>This only works for <code>l = 8</code>, again, because of overlapping slices for lower values of <code>l</code>, For <code>l &gt; 8</code>, you start out missing characters from the end as none of the 8 <code>a[i::l]</code> slices include those characters</p>
<pre><code>&gt;&gt;&gt; for l in range(2, 12):
...     print(f'{l:&gt;2d}:', ''.join(chain.from_iterable(zip_longest(*[a[i::l] for i in range(8)], fillvalue=''))))
...
 2: hello wollo worlo worldworldrldd
 3: hello wolo worldworldld
 4: hello woo worldrld
 5: hello wo worldd
 6: hello woworld
 7: hello woorld
 8: hello world
 9: hello wold
10: hello wod
11: hello wo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code isn't so clear, and we don't know what the <code>l</code> really is! if u run it as it is, you will surely get an error saying that the l isn't defined.</p>
<p>However, for the zip function it stops at the shortest iterator, to force it keep going you should use <code>zip_longest</code>.</p>
<p>for more details on how zip function works check this : <a href="https://www.journaldev.com/15891/python-zip-function" rel="nofollow noreferrer">Python zip</a></p>
</div>
<span class="comment-copy">Because <code>zip()</code> stops <i>when shortest iterator</i> has run out.</span>
<span class="comment-copy">What is <code>l</code> in the <code>b</code> list comprehension?</span>
<span class="comment-copy">Since <code>zip</code> always returns an iterable of tuples, <code>zip(*b)</code> can't possibly be equal to <code>a</code> (which is a list of strings, not tuples).</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">documentation</a> is freely available. There's no need to guess.</span>
<span class="comment-copy">Silly me, my bad, makes absolute sense now, thanks!</span>
<span class="comment-copy">Surely there are better resources on <code>zip</code> than someone's personal blog?</span>
