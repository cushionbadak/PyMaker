<div class="post-text" itemprop="text">
<pre><code>import random as rd
q1 = rd.randint(1,10)    
print(dir(q1))
</code></pre>
<p>Output is: </p>
<pre><code>['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']
</code></pre>
<p>1. I want to know how to use (syntax) all these methods/attributes/functions for my given q1. (I don't know what is attribute/function/method? I just typed them for keyword match)</p>
<ol start="2">
<li><p>Here I observe two categories of methods: one with double underscore at both ends and other with none. Example, <code>__abs__</code> and <code>bit_length</code>. What is the basic different between these two subcategories? </p></li>
<li><p>I just want to know is there a general terminology that how to use these methods? For instance, do I have to use <code>.</code> for which methods? and how to use them? Please, give some examples. For example, <code>__eq__</code> is equal function. I want to check if  q1 is equal to 5. My code is:</p></li>
</ol>
<p><code>print(q1.eq(5))</code></p>
<p>Output is: </p>
<pre><code>AttributeError:'int' object has no attribute 'eq'
</code></pre>
<p>Looks like I didn't use it properly. Your answer going to help me to know how to use methods/attributes/functions defined under any given class.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I'll give a high level answer to your questions but I recommend to take a look at the <a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python documentation</a> to get a more in-depth answer.</p>
<p>1) There are essentially two types of attributes an object can have. Objects can have <code>instance attributes</code> that are assigned on a <strong>per object</strong> basis and <code>class attributes</code> that <strong>all</strong> instances of that object have access to.</p>
<pre><code>class Employee(object):
    has_benefits = True # class attribute

    def __init__(self, name, badge_number):
        self.name = name # instance attribute
        self.badge_number = badge_number # instance attribute


&gt;&gt; e1 = Employee('bob', 123)
&gt;&gt; e1.name
&gt;&gt; 'bob'
&gt;&gt; e1.has_benefits
&gt;&gt; True
&gt;&gt;
&gt;&gt; e2 = Employee('sarah', 456)
&gt;&gt; e2.name
&gt;&gt; 'sarah'
&gt;&gt; e2.has_benefits
&gt;&gt; True
</code></pre>
<p>In this example, every Employee instance created has instance attributes <code>name</code> and <code>badge_number</code> which are specific to that instance, but notice how every Employee instance has access to the class attribute <code>has_benefits</code> which is set to <code>True</code> for all Employees.</p>
<p>A <code>function</code> is some code that can be called by it's name, whereas a <code>method</code> is some code that can be called by it's name that is associated with an object. There is also an <code>instance method</code> which accepts the <code>self</code> argument as it's first parameter</p>
<pre><code>def show_something():
    print('Show something')

class MyClass(object):

    # method
    def display_something():
        print('Display something')

    # instance method
    def print_something(self):
        print('Print something')


&gt;&gt; show_something()
&gt;&gt; 'Show something'
&gt;&gt;
&gt;&gt; MyClass.display_something()
&gt;&gt; 'Display something'
&gt;&gt;
&gt;&gt; mc = MyClass()
&gt;&gt; mc.print_something()
&gt;&gt; 'Print something'
</code></pre>
<p>Notice how the function <code>show_something</code> is just some code that we could call by name. Also, notice how the method <code>display_something</code> is bound to our class object and the instance method <code>print_something</code> is bound to an instance of our object. <code>mc.print_something()</code> is the same as <code>MyClass.print_something(mc)</code></p>
<p>2) Running <code>dir()</code> on an object returns a list of all of the object's attributes. Some attributes are considered special attributes that are surrounded by double underscores. Some attributes are callable which we can determine by passing the attribute to the built-in function <code>callable()</code> which will return <code>True</code> if the attribute is callable, <code>False</code> otherwise.</p>
<p>Attributes without the surrounding double underscores are also attributes and methods can be attributes too. <code>__abs__</code> gets called when you run the <code>abs()</code> built-in function which returns the absolute value of the object passed-in. <code>bit_length</code> is a method that returns the number of bits which represent the passed-in object. And yes, you access these attributes with the . (dot) syntax.</p>
<pre><code>&gt;&gt; my_num = 5
&gt;&gt; my_num.real
&gt;&gt; 5
&gt;&gt; callable(my_num.bit_length)
&gt;&gt; True
&gt;&gt; my_num.bit_length()
&gt;&gt; 3
&gt;&gt; my_num.__class__
&gt;&gt; &lt;class 'int'&gt;
</code></pre>
<p>3) Lastly, we can define an object that implements some special methods that get used by Python when we run specific actions such as membership testing and getting the length of a collection. I'll show some basic examples:</p>
<pre><code>class MyCollection(object):
    def __init__(self, data):
        self.my_data = data

    def __contains__(self, item):
        return item in self.my_data

    def __len__(self):
        return len(self.my_data)

    def __iter__(self):
        for item in self.my_data:
            yield item

    def __add__(self, rhs):
        if not isinstance(rhs, MyCollection):
            return NotImplemented
        return self.my_data + rhs.my_data

    def __eq__(self, rhs):
        if not isinstance(rhs, MyCollection):
            return NotImplemented
        return self.my_data == rhs.my_data

    def __ne__(self, rhs):
        if not isinstance(rhs, MyCollection):
            return NotImplemented
        return self.my_data != rhs.my_data
</code></pre>
<p>Give it a try:</p>
<pre><code>&gt;&gt; mc1 = MyCollection([1,2,3,4,5])
&gt;&gt; mc2 = MyCollection([6,7,8,9])
&gt;&gt; mc3 = MyCollection([1,2,3,4,5])
&gt;&gt;
&gt;&gt; 3 in mc1 # calls __contains__
&gt;&gt; True
&gt;&gt;
&gt;&gt; len(mc1) # calls __len__
&gt;&gt; 5
&gt;&gt;
&gt;&gt; [item for item in mc1] # calls __iter__
&gt;&gt; [1,2,3,4,5]
&gt;&gt;
&gt;&gt; mc1 + mc2 # calls __add__
&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;
&gt;&gt; mc1 == mc2 # calls __eq__
&gt;&gt; False
&gt;&gt;
&gt;&gt; mc1 != mc2 # calls __ne__
&gt;&gt; True
&gt;&gt;
&gt;&gt; mc1 == mc3 # calls __eq__
&gt;&gt; True
</code></pre>
<p>I hope this helped!</p>
</div>
<span class="comment-copy">Try <code>print(q1.__eq__(5))</code></span>
<span class="comment-copy">Firstly, <code>type(q1)</code> wouldn't return that. That looks like the value of <code>dir(q1)</code>. In any event, those are the attribute names, so you access them using <i>those names</i>. However, most of the "dunder" methods, i.e. <code>__x__</code> are special hooks into things like operators and the like. You usually do not use those directly</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/1418825/where-is-the-python-documentation-for-the-special-methods-init-new">Where is the Python documentation for the special methods? (__init__, __new__, __len__, ...)</a></span>
<span class="comment-copy">All of your questions are answered <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">here</a>. Tl;dr: methods are class attributes that contain functions; instance methods can be called using <code>instance.method(arglist)</code> notation, which is identical to <code>klass.method(instance, arglist...)</code>. Double underscore methods are special, and typically implement non-method syntax such as operators. In particular, <code>q1.__eq__(5)</code> is what is invoked in the background when you do <code>q1 == 5</code>.</span>
<span class="comment-copy">Thanks a lot for helping me to understand the Python functions, methods and attributes. In your whole answer, what  I liked and expected is this: <code>explaining attributes with double-underscore at both ends and others'. I wanted to know, is there a general way to tell that we can use a </code>double_underscore' attribute in this way and a `non-underscore' attribute in this way. This answer helps me to understand each attribute. Moreover, I can enjoy applying these things to different functions.</span>
<span class="comment-copy">Attributes with double-underscores at both ends are considered "special" attributes that are used by underlying Python mechanisms like I showed in my answer above. Typically, we override these special attributes if we want to gain more control of our objects. You can access all attributes whether they are "special" attributes or not with the dot syntax and there is no general rule to tell when we should access each attribute. You access each attribute when you need to. It's as simple as that! If you liked the answer, maybe accept it so others may benefit as well? :)</span>
