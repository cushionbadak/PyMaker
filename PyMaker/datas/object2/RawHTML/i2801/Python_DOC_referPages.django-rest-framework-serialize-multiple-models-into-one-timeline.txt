<div class="post-text" itemprop="text">
<p>I have an abstract base "Post" model with multiple child models that have their own required fields.</p>
<p>I have serialized these different post types into something that looks like this</p>
<pre><code>"timeline": {
    "text": [
        {
            "id": 1,
            "heading": "Yea",
            "text": "hello world",
            "render": "&lt;p&gt;\n  Yea\n&lt;/p&gt;\n&lt;p&gt;\n  hello world\n&lt;/p&gt;\n",
            "created_on": "2018-08-18T16:05:45.910124Z"
        }
    ],
    "video": [],
    "image": []
}
</code></pre>
<p>What I'm trying to do is be able to display them chronologically on the front end. </p>
<p>What is the best way to implement this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understood you correctly, you could just sort the whole thing before sending it to the frontend. I assume you have a <code>list of dict</code> like above with</p>
<pre><code>posts = [{'timeline: { ... }}, {'timeline: { ... }}, ...]
</code></pre>
<p>like in your example, so <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="nofollow noreferrer">to sort it in-place</a>, it would be</p>
<pre><code>posts.sort(key=lambda t: t['timeline']['text'][0]['created_on'])
</code></pre>
<p>That would put all the objects in chronological order.</p>
</div>
<span class="comment-copy">can you post your models both Post and derived child models? What field do you want to use for ordering?</span>
<span class="comment-copy">Given that your base model has a datefield can't you just use the built in <code>.order_by('fieldname')</code> when fetching your data?</span>
<span class="comment-copy">Maybe worth noting; should probably do it via SQL if possible since this can create unwanted behaviour if using pagination when fetching all posts. And thus only sorting a part of all the posts</span>
