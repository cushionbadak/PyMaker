<div class="post-text" itemprop="text">
<p>The library I'm writing makes heavy use of metaclasses. As an example, here is a basic singleton implementation:</p>
<pre><code>class SingletonMeta(type):
    _instance = None

    def __call__(self, *args, **kwargs):
        if self._instance is None:
            self._instance = super().__call__(*args, **kwargs)

        return self._instance

class ExampleSingleton(metaclass=SingletonMeta):
    pass
</code></pre>
<p>This works perfectly fine, but problems arise when multiple inheritance is used and the other class also has a metaclass. Metaclasses are fairly common in the standard library; the most notable is <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta" rel="nofollow noreferrer"><code>abc.ABCMeta</code></a>. A naive attempt to make an abstract singleton fails:</p>
<pre><code>class AbstractSingleton(ExampleSingleton, abc.ABC):
    pass

Traceback (most recent call last):
  File "untitled.py", line 25, in &lt;module&gt;
    class AbstractSingleton(ExampleSingleton, abc.ABC):
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
</code></pre>
<p>The workaround is easy enough - create a new metaclass that inherits from <code>SingletonMeta</code> and <code>ABCMeta</code> - but it's really annoying for anyone who wants to use my library.</p>
<pre><code>class AbstractSingletonMeta(SingletonMeta, abc.ABCMeta):
    pass

class AbstractSingleton(metaclass=AbstractSingletonMeta):
    pass

# no metaclass conflict
</code></pre>
<p>What's the best way to deal with this problem?</p>
<p>Some of my ideas:</p>
<ol>
<li>Since abstract classes are fairly common, I could make <code>SingletonMeta</code> a subclass of <code>ABCMeta</code>.</li>
<li>I could implement <code>AbstractSingletonMeta</code> in my library for the user's convenience.</li>
<li>Since any callable can be used as a metaclass, I could implement a function that automatically merges the metaclasses of all parent classes. (The usage would be like <code>class AbstractSingleton(ExampleSingleton, abc.ABC, metaclass=auto_merge_metaclasses):</code>)</li>
<li>In the spirit of "explicit is better than implicit", I could do nothing and let the user sort out the metaclass conflicts.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Since all the information about the needed metaclasses and what needs to be combined is already present in the base classes, and those are passed to the metaclass call, it is possible to have a callable that will inspect all the bases and their used metaclasses, and dynamically create a combining metaclass. </p>
<p>The <code>types</code> module have some callables that otherwise make it easy to pick the correct metaclass for a set of base classes. So, the function bellow should suffice to your needs, if all your used metaclasses are combinable in an arbitrary order:</p>
<pre><code>from types import prepare_class

def combine_meta(name, bases, namespace, **kwargs):
    metaclasses = {prepare_class(name, (base,))[0] for base in bases}
    metaclasses.discard(type)

    if len(metaclasses) &gt; 1:
        meta_name = '_'.join(mcs.__name__ for mcs in metaclasses)
        metaclass = combine_meta(meta_name, tuple(metaclasses), {})
    elif len(metaclasses) == 1:
        metaclass = metaclasses.pop()
    else:
        metaclass = type
    return metaclass(name, bases, namespace, **kwargs)
</code></pre>
<p>I've tested this with this sequence in the interactive interpreter, and it worked that far:</p>
<pre><code>class M1(type): pass
class M2(type): pass
class A(metaclass=M1): pass
class B(metaclass=M2): pass
class C(A, B): pass  # This raises a metaclassconflict
class C(A, B, metaclass=combine_meta): pass
</code></pre>
</div>
<span class="comment-copy">Are you aware of this? <a href="http://code.activestate.com/recipes/204197-solving-the-metaclass-conflict/" rel="nofollow noreferrer">code.activestate.com/recipes/â€¦</a></span>
<span class="comment-copy">@cha0site Yes, that's where I got the idea to make a function that resolves the metaclass conflicts from. I'm not convinced it's the best solution though, hence my question. (You <i>can</i> post that as answer if you want though. It's definitely a useful approach, and the votes will decide which approach is the best.)</span>
<span class="comment-copy">I think class <code>C</code> needs to be defined like <code>class C(A, B, metaclass=combine_meta): pass</code>, right?</span>
<span class="comment-copy">Yes, of course. the history was missing the last, and most importante line.</span>
<span class="comment-copy">Okay, that makes sense now. I took the liberty to make your function recursive so that it doesn't crash if the metaclasses have conflicting metaclasses.</span>
