<div class="post-text" itemprop="text">
<p>I'm currently working on a Python wrapper for a C++ library for which I want to use SWIG. In my C++ library I have a method with the following signature:</p>
<pre><code>std::vector&lt;SomeClass&gt; getMembers();
</code></pre>
<p>Now I know that SWIG has built-in std::vector support but I want to explicitly convert std::vectors to Python Lists (I just think it is cleaner). For that I have the following typemap:</p>
<pre><code>template&lt;typename T&gt;
PyObject* toList(vector&lt;T&gt; vec){
    size_t size = vec.size();
    PyObject *o = PyList_New(size);
    for(size_t i = 0; i &lt; size; i++){
        PyList_SetItem(o, i, toPythonInstance&lt;T&gt;(vec[i]));
    }
    return o;
}

%define OUTPUT_VEC_TO_LIST(type)
%typemap (out) std::vector&lt;type&gt; {
    $result = toList&lt;type&gt;($1);
}
%enddef
</code></pre>
<p>Now the template method:</p>
<pre><code>template&lt;T&gt;
PyObject* toPythonInstance(T&amp; val){}
</code></pre>
<p>Can be specialized to add support for the necessary datatypes. The problem I'm facing now is the following:</p>
<p><strong>SomeClass</strong> is wrapped automatically by SWIG. So what I like to do is to reuse this wrapper in my vector type map, i.e. have the following:</p>
<pre><code>template&lt;&gt;
PyObject* toPythonInstance&lt;SomeClass&gt;(SomeClass&amp; val){
    //call some SWIG macro to automatically wrap the given instance to
    //a Python object
}
</code></pre>
<p>Inspecting the code generated by SWIG, I already found the following functions</p>
<pre><code>SWIG_NewPointerObj(...);
SWIG_ConvertPtr(...);
</code></pre>
<p>which seem to be responsible for doing exactly what I want. However, I do not want to interfere with any internals of SWIG. So if somebody knows how to achieve what I want with the "public" SWIG interface, I would be very glad!</p>
</div>
<div class="post-text" itemprop="text">
<p>SWIG actually makes a whole bunch of runtime information part of an external interface, see <a href="http://www.swig.org/Doc3.0/Modules.html#Modules_external_run_time" rel="nofollow noreferrer">http://www.swig.org/Doc3.0/Modules.html#Modules_external_run_time</a> for details. This includes the functions you're likely to want for your efforts.</p>
<p>I disagree with your assessment that mapping <code>std::vector</code> to list is cleaner in Python - you always end up copying and visiting every member of that vector to do this. In effect you make a copy of the original container and end up with two containers, so changes to the Python list won't be reflected back on the underlying C++ container. The Python supplied <code>std::vector</code> wrapping should implement the protocols you care about to enable pythonic syntax by default, and can support the <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">ABCs</a> correctly too.. (And if they don't I'm up for writing patches!)</p>
</div>
<span class="comment-copy">You might want to look at <a href="https://pybind11.readthedocs.io/en/stable/" rel="nofollow noreferrer">pybind11.readthedocs.io/en/stable</a>. It is similar to Swig, and as long as you can convert SomeClass to Python, it will automatically convert std::vector&lt;SomeClass&gt; to Python's lists.</span>
<span class="comment-copy">The functions you're looking at aren't private internals - see <a href="http://www.swig.org/Doc3.0/Modules.html#Modules_external_run_time" rel="nofollow noreferrer">swig.org/Doc3.0/Modules.html#Modules_external_run_time</a></span>
<span class="comment-copy">@Flexo: This is the answer to my question so if you want to write it up as one I'm glad to accept it! :)</span>
<span class="comment-copy">@sangrey: The PyBind11 suggestion is just perfect! I tried it out and decided to start using it instead of SWIG since it has everything I need but makes it much easier to use than SWIG - and since I only need a Python Interface, the ease of use is the deciding factor.</span>
