<div class="post-text" itemprop="text">
<p>I was trying to build this bytes object in Python 3:</p>
<p><code>b'3\r\n'</code></p>
<p>so I tried the obvious (for me), and found a weird behaviour:</p>
<pre><code>&gt;&gt;&gt; bytes(3) + b'\r\n'
b'\x00\x00\x00\r\n'
</code></pre>
<p>Apparently:</p>
<pre><code>&gt;&gt;&gt; bytes(10)
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
</code></pre>
<p>I've been unable to see any pointers on why the bytes conversion works this way reading the documentation. However, I did find some surprise messages in this Python issue about adding <code>format</code> to bytes (see also <a href="https://stackoverflow.com/q/15710515/554319">Python 3 bytes formatting</a>):</p>
<p><a href="http://bugs.python.org/issue3982" rel="noreferrer">http://bugs.python.org/issue3982</a></p>
<blockquote>
<p>This interacts even more poorly with oddities like bytes(int) returning zeroes now</p>
</blockquote>
<p>and:</p>
<blockquote>
<p>It would be much more convenient for me if bytes(int) returned the ASCIIfication of that int; but honestly, even an error would be better than this behavior.  (If I wanted this behavior - which I never have - I'd rather it be a classmethod, invoked like "bytes.zeroes(n)".)</p>
</blockquote>
<p>Can someone explain me where this behaviour comes from?</p>
</div>
<div class="post-text" itemprop="text">
<p>That's the way it was designed - and it makes sense because usually, you would call <code>bytes</code> on an iterable instead of a single integer:</p>
<pre><code>&gt;&gt;&gt; bytes([3])
b'\x03'
</code></pre>
<p>The <a href="http://docs.python.org/3.3/library/stdtypes.html#binaryseq">docs state this</a>, as well as the docstring for <code>bytes</code>:</p>
<pre><code> &gt;&gt;&gt; help(bytes)
 ...
 bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From python 3.2 you can do</p>
<pre><code>&gt;&gt;&gt; (1024).to_bytes(2, byteorder='big')
b'\x04\x00'
</code></pre>
<p><a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes">https://docs.python.org/3/library/stdtypes.html#int.to_bytes</a></p>
<pre><code>def int_to_bytes(x):
    return x.to_bytes((x.bit_length() + 7) // 8, 'big')

def int_from_bytes(xbytes):
    return int.from_bytes(xbytes, 'big')
</code></pre>
<p>Accordingly, <code>x == int_from_bytes(int_to_bytes(x))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/2/library/struct.html#struct.pack">struct's pack</a>:</p>
<pre><code>In [11]: struct.pack("&gt;I", 1)
Out[11]: '\x00\x00\x00\x01'
</code></pre>
<p>The "&gt;" is the <a href="https://docs.python.org/2/library/struct.html#byte-order-size-and-alignment">byte-order (big-endian)</a> and the "I" is the <a href="https://docs.python.org/2/library/struct.html#format-characters">format character</a>. So you can be specific if you want to do something else:</p>
<pre><code>In [12]: struct.pack("&lt;H", 1)
Out[12]: '\x01\x00'

In [13]: struct.pack("B", 1)
Out[13]: '\x01'
</code></pre>
<p><em>This works the same on both python 2 and <a href="https://docs.python.org/3/library/struct.html">python 3</a>.</em></p>
<p>Note: the inverse operation (bytes to int) can be done with <a href="https://docs.python.org/2/library/struct.html#struct.unpack">unpack</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.5/library/stdtypes.html#printf-style-bytes-formatting" rel="noreferrer">Python 3.5+ introduces %-interpolation (<code>printf</code>-style formatting) for bytes</a>:</p>
<pre><code>&gt;&gt;&gt; b'%d\r\n' % 3
b'3\r\n'
</code></pre>
<p>See <a href="https://www.python.org/dev/peps/pep-0461/" rel="noreferrer">PEP 0461 -- Adding % formatting to bytes and bytearray</a>.</p>
<p>On earlier versions, you could use <code>str</code> and <code>.encode('ascii')</code> the result:</p>
<pre><code>&gt;&gt;&gt; s = '%d\r\n' % 3
&gt;&gt;&gt; s.encode('ascii')
b'3\r\n'
</code></pre>
<p>Note: It is different from <a href="https://stackoverflow.com/q/846038/4279">what <code>int.to_bytes</code> produces</a>:</p>
<pre><code>&gt;&gt;&gt; n = 3
&gt;&gt;&gt; n.to_bytes((n.bit_length() + 7) // 8, 'big') or b'\0'
b'\x03'
&gt;&gt;&gt; b'3' == b'\x33' != '\x03'
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The documentation says:</p>
<pre><code>bytes(int) -&gt; bytes object of size given by the parameter
              initialized with null bytes
</code></pre>
<p>The sequence:</p>
<pre><code>b'3\r\n'
</code></pre>
<p>It is the character '3' (decimal 51) the character '\r' (13) and '\n' (10).</p>
<p>Therefore, the way would treat it as such, for example:</p>
<pre><code>&gt;&gt;&gt; bytes([51, 13, 10])
b'3\r\n'

&gt;&gt;&gt; bytes('3', 'utf8') + b'\r\n'
b'3\r\n'

&gt;&gt;&gt; n = 3
&gt;&gt;&gt; bytes(str(n), 'ascii') + b'\r\n'
b'3\r\n'
</code></pre>
<p>Tested on IPython 1.1.0 &amp; Python 3.2.3</p>
</div>
<div class="post-text" itemprop="text">
<p>The ASCIIfication of 3 is <code>"\x33"</code> not <code>"\x03"</code>!</p>
<p>That is what python does for <code>str(3)</code> but it would be totally wrong for bytes, as they should be considered arrays of binary data and not be abused as strings.</p>
<p>The most easy way to achieve what you want is <code>bytes((3,))</code>, which is better than <code>bytes([3])</code> because initializing a list is much more expensive, so never use lists when you can use tuples. You can convert bigger integers by using <code>int.to_bytes(3, "little")</code>.</p>
<p>Initializing bytes with a given length makes sense and is the most useful, as they are often used to create some type of buffer for which you need some memory of given size allocated. I often use this when initializing arrays or expanding some file by writing zeros to it.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>int</code> (including Python2's <code>long</code>) can be converted to <code>bytes</code> using following function:</p>
<pre><code>import codecs

def int2bytes(i):
    hex_value = '{0:x}'.format(i)
    # make length of hex_value a multiple of two
    hex_value = '0' * (len(hex_value) % 2) + hex_value
    return codecs.decode(hex_value, 'hex_codec')
</code></pre>
<p>The reverse conversion can be done by another one:</p>
<pre><code>import codecs
import six  # should be installed via 'pip install six'

long = six.integer_types[-1]

def bytes2int(b):
    return long(codecs.encode(b, 'hex_codec'), 16)
</code></pre>
<p>Both functions work on both Python2 and Python3.</p>
</div>
<div class="post-text" itemprop="text">
<p>The behaviour comes from the fact that in Python prior to version 3 <code>bytes</code> was just an alias for <code>str</code>. In Python3.x <code>bytes</code> is an immutable version of <code>bytearray</code> - completely new type, not backwards compatible.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://docs.python.org/3.1/library/functions.html#bytes" rel="nofollow">bytes docs</a>:</p>
<blockquote>
<p>Accordingly, constructor arguments are interpreted as for bytearray().</p>
</blockquote>
<p>Then, from <a href="http://docs.python.org/3.1/library/functions.html#bytearray" rel="nofollow">bytearray docs</a>:</p>
<blockquote>
<p>The optional source parameter can be used to initialize the array in a few different ways:</p>
<ul>
<li>If it is an integer, the array will have that size and will be initialized with null bytes.</li>
</ul>
</blockquote>
<p>Note, that differs from 2.x (where x &gt;= 6) behavior, where <code>bytes</code> is simply <code>str</code>:</p>
<pre><code>&gt;&gt;&gt; bytes is str
True
</code></pre>
<p><a href="http://docs.python.org/2/whatsnew/2.6.html#pep-3112-byte-literals" rel="nofollow">PEP 3112</a>:</p>
<blockquote>
<p>The 2.6 str differs from 3.0â€™s bytes type in various ways; most notably, the constructor is completely different. </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I was curious about performance of various methods for a single int in the range <code>[0, 255]</code>, so I decided to do some timing tests.</p>
<p>Based on the timings below, and from the general trend I observed from trying many different values and configurations, <code>struct.pack</code> seems to be the fastest, followed by <code>int.to_bytes</code>, <code>bytes</code>, and with <code>str.encode</code> (unsurprisingly) being the slowest. Note that the results show some more variation than is represented, and <code>int.to_bytes</code> and <code>bytes</code> sometimes switched speed ranking during testing, but <code>struct.pack</code> is clearly the fastest.</p>
<p>Results in CPython 3.7 on Windows:</p>
<pre><code>Testing with 63:
bytes_: 100000 loops, best of 5: 3.3 usec per loop
to_bytes: 100000 loops, best of 5: 2.72 usec per loop
struct_pack: 100000 loops, best of 5: 2.32 usec per loop
chr_encode: 50000 loops, best of 5: 3.66 usec per loop
</code></pre>
<p>Test module (named <code>int_to_byte.py</code>):</p>
<pre><code>"""Functions for converting a single int to a bytes object with that int's value."""

import random
import shlex
import struct
import timeit

def bytes_(i):
    """From Tim Pietzcker's answer:
    https://stackoverflow.com/a/21017834/8117067
    """
    return bytes([i])

def to_bytes(i):
    """From brunsgaard's answer:
    https://stackoverflow.com/a/30375198/8117067
    """
    return i.to_bytes(1, byteorder='big')

def struct_pack(i):
    """From Andy Hayden's answer:
    https://stackoverflow.com/a/26920966/8117067
    """
    return struct.pack('B', i)

# Originally, jfs's answer was considered for testing,
# but the result is not identical to the other methods
# https://stackoverflow.com/a/31761722/8117067

def chr_encode(i):
    """Another method, from Quuxplusone's answer here:
    https://codereview.stackexchange.com/a/210789/140921

    Similar to g10guang's answer:
    https://stackoverflow.com/a/51558790/8117067
    """
    return chr(i).encode('latin1')

converters = [bytes_, to_bytes, struct_pack, chr_encode]

def one_byte_equality_test():
    """Test that results are identical for ints in the range [0, 255]."""
    for i in range(256):
        results = [c(i) for c in converters]
        # Test that all results are equal
        start = results[0]
        if any(start != b for b in results):
            raise ValueError(results)

def timing_tests(value=None):
    """Test each of the functions with a random int."""
    if value is None:
        # random.randint takes more time than int to byte conversion
        # so it can't be a part of the timeit call
        value = random.randint(0, 255)
    print(f'Testing with {value}:')
    for c in converters:
        print(f'{c.__name__}: ', end='')
        # Uses technique borrowed from https://stackoverflow.com/q/19062202/8117067
        timeit.main(args=shlex.split(
            f"-s 'from int_to_byte import {c.__name__}; value = {value}' " +
            f"'{c.__name__}(value)'"
        ))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although the prior <a href="https://stackoverflow.com/a/30375198/832230">answer by brunsgaard</a> is an efficient encoding, it works only for unsigned integers. This one builds upon it to work for both signed and unsigned integers.</p>
<pre><code>def int_to_bytes(i: int, *, signed: bool = False) -&gt; bytes:
    length = (i.bit_length() + 7 + int(signed)) // 8
    return i.to_bytes(length, byteorder='big', signed=signed)

def bytes_to_int(b: bytes, *, signed: bool = False) -&gt; int:
    return int.from_bytes(b, byteorder='big', signed=signed)

# Test unsigned:
for i in range(1025):
    assert i == bytes_to_int(int_to_bytes(i))

# Test signed:
for i in range(-1024, 1025):
    assert i == bytes_to_int(int_to_bytes(i, signed=True), signed=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't care about the performance, you can convert an int to str first.</p>
<pre><code>number = 1024
str(number).encode()
</code></pre>
</div>
<span class="comment-copy">related to the title: <a href="http://stackoverflow.com/q/846038/4279"><code>3 .to_bytes</code></a></span>
<span class="comment-copy">It is unclear from your question if you want the integer value 3, or the value of the ASCII character representing number three (integer value 51).  The first is bytes([3]) == b'\x03'.  The latter is bytes([ord('3')]) == b'3'.</span>
<span class="comment-copy">Beware that the above works only with python 3. In python 2 <code>bytes</code> is just an alias for <code>str</code>, which means <code>bytes([3])</code> gives you <code>'[3]'</code>.</span>
<span class="comment-copy">Well, that's why the question is tagged python-3.x...</span>
<span class="comment-copy">you're right, sorry - I did not read the Q carefully</span>
<span class="comment-copy">@A-B-B: Not really surprising since a byte can only store values between 0 and 255.</span>
<span class="comment-copy">It should also be noted that <code>bytes([3])</code> is still different from what the OP wanted â€“ namely the byte value used to encode the digit "3" in ASCII, ie. <code>bytes([51])</code>, which is <code>b'3'</code>, not <code>b'\x03'</code>.</span>
<span class="comment-copy">While this answer is good, it works only for unsigned (non-negative) integers. I have adapted it write an <a href="https://stackoverflow.com/a/54141411/832230">answer</a> which also works for signed integers.</span>
<span class="comment-copy">@AndyHayden To clarify, since a struct has a standard size irrespective of the input, <code>I</code>, <code>H</code>, and <code>B</code> work till <code>2**k - 1</code> where k is 32, 16, and 8 respectively. For larger inputs they raise <code>struct.error</code>.</span>
<span class="comment-copy">Presumably down-voted as it doesn't answer the question: the OP wants to know how to generate <code>b'3\r\n'</code>, i.e. a byte-string containing the ASCII character "3" not the ASCII character "\x03"</span>
<span class="comment-copy">@DaveJones What makes you think that is what the OP wants? The <b>accepted answer</b> returns <code>\x03</code>, and the solution if you just want <code>b'3'</code> is trivial. The reason cited by A-B-B is much more plausible... or at least understandable.</span>
<span class="comment-copy">@DaveJones Also, the reason I added this answer was because Google takes you here when searching to do precisely this. So that's why it's here.</span>
<span class="comment-copy">Not only does this work the same in 2 and 3, but it's faster than both the <code>bytes([x])</code> and <code>(x).to_bytes()</code> methods in Python 3.5. That was unexpected.</span>
<span class="comment-copy">I ended up doing <code>bytes(str(n), 'ascii') + b'\r\n'</code> or <code>str(n).encode('ascii') + b'\r\n'</code>. Thanks! :)</span>
<span class="comment-copy">@Juanlu001, also <code>"{}\r\n".format(n).encode()</code> I don't think there is any harm done by using the default utf8 encoding</span>
<span class="comment-copy">There are several problems with this answer: (a) The escape notation of <code>b'3'</code>is <code>b'\x33'</code>, not <code>b'\x32'</code>. (b) <code>(3)</code> is not a tuple â€“ you have to add a comma. (c) The scenario of initialising a sequence with zeroes does not apply to <code>bytes</code> objects, as they are immutable (it makes sense for <code>bytearray</code>s, though).</span>
<span class="comment-copy">Thanks for your comment. I fixed those two obvious mistakes. In case of <code>bytes</code> and <code>bytearray</code>, I think it's mostly a matter of consistency. But it is also useful if you want to push some zeros into a buffer or file, in which case it is only used as a data source.</span>
<span class="comment-copy">'hex_value = '%x' % i' will not work under Python 3.4. You get a TypeError, so you'd have to use hex() instead.</span>
<span class="comment-copy">@bjmc replaced with str.format. This should work on Python 2.6+.</span>
<span class="comment-copy">Thanks, @renskiy. You might want to use 'hex_codec' instead of 'hex' because it seems like 'hex' alias is not available on all Python 3 releases see <a href="https://stackoverflow.com/a/12917604/845210">stackoverflow.com/a/12917604/845210</a></span>
<span class="comment-copy">@bjmc fixed. Thanks</span>
<span class="comment-copy">This fails on negative integers on python 3.6</span>
<span class="comment-copy">@A-B-B As mentioned in my first sentence, I'm only measuring this for a single int in the range <code>[0, 255]</code>. I assume by "wrong indicator" you mean my measurements weren't general enough to fit most situations? Or was my measuring methodology poor? If the latter, I would be interested to hear what you have to say, but if the former, I never claimed my measurements were generic to all use-cases. For my (perhaps niche) situation, I am only dealing with ints in the range <code>[0, 255]</code>, and that is the audience I intended to address with this answer. Was my answer unclear? I can edit it for clarity...</span>
<span class="comment-copy">What about the technique of just indexing a precomputed encoding for the range? The precomputation wouldn't be subject to timing, only the indexing would be.</span>
<span class="comment-copy">@A-B-B That's a good idea. That sounds like it will be faster than anything else. I'll do some timing and add it to this answer when I have some time.</span>
<span class="comment-copy">If you really want to time the bytes-from-iterable thing, you should use <code>bytes((i,))</code> instead of <code>bytes([i])</code> because list are more complex, use more memory and take long to initialize. In this case, for nothing.</span>
<span class="comment-copy">The is just plain wrong, here you get a byte representation of a string not and int.</span>
<span class="comment-copy">This will give b'1024' which is a string</span>
