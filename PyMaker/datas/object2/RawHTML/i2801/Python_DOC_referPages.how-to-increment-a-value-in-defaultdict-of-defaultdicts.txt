<div class="post-text" itemprop="text">
<p>How to increment <code>d['a']['b']['c'][1][2][3]</code> if <code>d</code> is <code>defaultdict</code> of <code>defaultdict</code> without code dublication?</p>
<pre><code>from collections import defaultdict
nested_dict_type = lambda: defaultdict(nested_dict_type)
nested_dict = nested_dict_type()

# incrementation
if type(nested_dict['a']['b']['c']['d'][1][2][3][4][5][6]) != int:
    nested_dict['a']['b']['c']['d'][1][2][3][4][5][6] = 0
nested_dict['a']['b']['c']['d'][1][2][3][4][5][6] += 1  # ok, now it contains 1
</code></pre>
<p>Here we can see that we duplicated (in the code) a chain of keys 3 times.</p>
<p><strong>Question:</strong> Is it possible to write a function <code>inc</code> that will take <code>nested_dict['a']['b']...[6]</code> and do the same job as above? So:</p>
<pre><code>def inc(x):
    if type(x) != int:
        x = 0
    x += 1
inc(nested_dict['a']['b']['c']['d'][1][2][3][4][5][6])  # ok, now it contains 1
</code></pre>
<p><strong>Update (20 Aug 2018):</strong></p>
<p>There is still no answer to the question. It's clear that there are options "how to do what I want", but the question is straightforward: there is "value", we pass it to a function, function modifies it. It looks that it's not possible.
Just a value, without any "additional keys", etc.
If it is so, can we make an answer more generic?</p>
<p><strong>Notes:</strong></p>
<ol>
<li><a href="https://stackoverflow.com/questions/19189274/defaultdict-of-defaultdict-nested/27809959">What is defaultdict of defaultdicts - SO.</a></li>
<li>This question is not about "storing of integers in a defaultdict", so I'm not looking for a hierarchy of defaultdicts with an int type at the leaves.</li>
<li>Assume that type (<code>int</code> in the examples) is known in advance / can be even parametrized (including the ability to perform <code>+=</code> operator) - the question is how to dereference the object, pass it for modification and store back <em>in the context of defaultdict of defaultdicts</em>.</li>
<li>Is the answer to this question related to the <a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">mutability</a>? See example below:</li>
</ol>
<p>Example:</p>
<pre><code>def inc(x):
    x += 1

d = {'a': int(0)}
inc(d['a'])  
# d['a'] == 0, immutable

d = {'a': Int(0)}
inc(d['a'])  
# d['a'] == 1, mutated
</code></pre>
<p>Where <code>Int</code> is:</p>
<pre><code>class Int:
    def __init__(self, value):
        self.value = value
    def __add__(self, v):
        self.value += v
        return self
    def __repr__(self):
        return str(self.value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not <em>exactly</em> abut mutability, more about how assignment performs name binding.</p>
<p>When you do <code>x = 0</code> in your <code>inc</code> function you bind a new object to the name <code>x</code>, and any connection between that name and the previous object bound to that name is lost. That doesn't depend on whether or not <code>x</code> is mutable.</p>
<p>But since <code>x</code> is an item in a mutable object we can achieve what you want by passing the parent mutable object to <code>inc</code> along with the key needed to access the desired item.</p>
<pre><code>from collections import defaultdict

nested_dict_type = lambda: defaultdict(nested_dict_type)
nested_dict = nested_dict_type()

# incrementation
def inc(ref, key):
    if not isinstance(ref[key], int):
        ref[key] = 0
    ref[key] += 1

d = nested_dict['a']['b']['c']['d'][1][2][3][4][5]
inc(d, 6)
print(d)
</code></pre>
<p><strong>output</strong></p>
<pre><code>defaultdict(&lt;function &lt;lambda&gt; at 0xb730553c&gt;, {6: 1})
</code></pre>
<p>Now we aren't binding a new object, we're merely mutating an existing one, so the original <code>d</code> object gets updated correctly.</p>
<hr/>
<p>BTW, that deeply nested dict is a bit painful to work with. Maybe there's a better way to organize your data... But anyway, one thing that can be handy when working with deep nesting is to use lists or tuples of keys. Eg,</p>
<pre><code>q = nested_dict
keys = 'a', 'b', 'c', 'd', 1, 2, 3, 4, 5
for k in keys:
    q = q[k]
</code></pre>
<p><code>q</code> now refers to <code>nested_dict['a']['b']['c']['d'][1][2][3][4][5]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can't have multiple default types with <code>defaultdict</code>. You have the following options:</p>
<ol>
<li>Nested <code>defaultdict</code> of <code>defaultdict</code> objects indefinitely;</li>
<li><code>defaultdict</code> of <code>int</code> objects, which likely won't suit your needs;</li>
<li><code>defaultdict</code> of <code>defaultdict</code> down to a specific level with <code>int</code> defined for the last level, e.g. <code>d = defaultdict(lambda: defaultdict(int))</code> for a single nesting;</li>
<li>Similar to (3), but for counting you can use <code>collections.Counter</code> instead, i.e. <code>d = defaultdict(Counter)</code>.</li>
</ol>
<p>I recommend the 3rd or 4th options if you are always going to go down to a set level. In other words, a scalar value will only be supplied at the <em>n</em>th level, where <em>n</em> is constant.</p>
<p>Otherwise, one manual option is to have a function perform the type-testing. In this case, <code>try</code> / <code>except</code> may be a good alternative. Here we also define a recursive algorithm to allow you to feed a list of keys rather than defining manual <code>__getitem__</code> calls.</p>
<pre><code>from collections import defaultdict
from functools import reduce
from operator import getitem

nested_dict_type = lambda: defaultdict(nested_dict_type)
d = nested_dict_type()

d[1][2] = 10

def inc(d_in, L):
    try:
        reduce(getitem, L[:-1], d_in)[L[-1]] += 1
    except TypeError:
        reduce(getitem, L[:-1], d_in)[L[-1]] = 1

inc(d, [1, 2])
inc(d, [1, 3])

print(d)

defaultdict({1: defaultdict({2: 11, 3: 1})})
</code></pre>
</div>
<span class="comment-copy">Please don't use both python-3 and python-2 tags on a question. Only use a version-specific tag if you're asking a version-specific question.</span>
<span class="comment-copy">I'm not sure why this question is so downvoted. It may be misguided, but that's all the more reason to provide a sensible answer. It seems pretty clear..Considering at least 2 answers have independently caught on to similar ideas.</span>
<span class="comment-copy">Please sorry for the mess and long long keys! I did it artificially for you to have a feeling how important it could be not to split all those “a”, “b”, “c” and etc through the code - see my comment below to one of the answers. (The answer is great, but still I’d be glad if you’d have any ideas how to do “exactly that function inc with only one place where they keys are mentioned”). Also sorry for the wrong tags if I’ve confused your regarding python versions!</span>
<span class="comment-copy">You may find this article helpful: <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">Facts and myths about Python names and values</a>, which was written by SO veteran Ned Batchelder.</span>
<span class="comment-copy">Thank you for the great answer and everyone please take my apologies if the example was messy, but there is a reason for that. In your example you artificially break the “chain of keys”. Imagine that we would have to inc data[planet][region][city]. In your case “first to keys” would go to “d” and the last key would go to second argument of inc. So the chain is split in two places in the code. How do you think: can we avoid it? And place the “final destination in data” just once in one place. Thank you in advance for the answer once again!</span>
<span class="comment-copy">@Pleeea The "chain" is only split in one place. And we <i>need</i> to split it like that because we want to <i>mutate</i> the object passed as the 1st arg of <code>inc</code>. There's no other (sane) way to do this in Python.</span>
<span class="comment-copy">I was also thinking about that! But why there is no way? I feel that I’m touching something strange, cause in other languages with memory management / pointers it could be totally straightforward. Maybe something with decorators could make the deal?</span>
<span class="comment-copy">@Pleeea Yes, it would be straight-forward if Python had pointers. But it doesn't, by design. :) Python's data model is quite different to that of C-like languages. It can be annoying at first when it won't let you do things the way you would in those languages, but gradually you'll come to appreciate the benefits of the Python way far outweigh the downsides. FWIW, I was coding in C for almost 30 years before I learned Python.</span>
<span class="comment-copy">Thank you! I would suggest us avoid moving the discussion to the questions of "appreciate" and "benefits". You mentioned that the model is quite different: how exactly? Could you please provide evidence that such things I'm asking are not possible? I'm not putting pressure here but would like to have a solid background under this question. For me, it sounds like "it's not pythonic / etc" right now. Can we prove that it's not possible to make a function <code>wrapper</code> that allows us to modify the data <i>by reference</i> in a call <code>inc(wrapper(nd['a']....[6]))</code>? What is the memory layout?</span>
