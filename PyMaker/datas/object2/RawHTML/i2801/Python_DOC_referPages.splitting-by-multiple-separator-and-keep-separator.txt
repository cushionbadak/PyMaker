<div class="post-text" itemprop="text">
<p>I have the following string inputs:</p>
<pre><code>"11A4B"
"5S6B"
</code></pre>
<p>And want the following outputs:</p>
<pre><code>["11A", "4B"]
["5S", "6B"]
</code></pre>
<p>Eg after each delimiter A, B or S split and keep the delimiter.</p>
<p>I can do with <code>split</code> from <code>re</code> (putting parenthesis on the delimiter pattern returns also the delimiter used):</p>
<pre><code>re.split("([ABS])", "11A4B")
#['11', 'A', '4', 'B', '']
</code></pre>
<p>And can play around to have the wanted solution but I wonder if there is a pure regex solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>A solution that will work in all Python versions will be the one based on PyPi <code>regex</code> module with <code>regex.split</code> and <code>regex.V1</code> flag:</p>
<pre><code>import regex
ss = ["11A4B","5S6B"]
delimiters = "ABS"
for s in ss:
    print(regex.split(r'(?&lt;=[{}])(?!$)'.format(regex.escape(delimiters)), s, flags=regex.V1))
</code></pre>
<p><a href="http://rextester.com/IXVDL37678" rel="nofollow noreferrer">Output</a>:</p>
<pre><code>['11A', '4B']
['5S', '6B']
</code></pre>
<p><strong>Details</strong></p>
<ul>
<li><code>(?&lt;=[ABS])</code> - a positive lookbehind that matches a location that is immediately preceded with <code>A</code> , <code>B</code> or <code>S</code></li>
<li><code>(?!$)</code> - and that is not immediately followed with the end of string (so, all locations at the end of the string are failed).</li>
</ul>
<p>The <code>regex.escape</code> is used just in case there may be special regex chars in the delimiter list, like <code>^</code>, <code>\</code>, <code>-</code> or <code>]</code>.</p>
<p>In <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer">Python 3.7, <code>re.split</code></a> also can split with zero-length matches, so, the following will work, too:</p>
<pre><code>re.split(r'(?&lt;=[{}])(?!$)'.format(re.escape(delimiters)), s)
</code></pre>
<p>Else, you may use workarounds, like</p>
<pre><code>re.findall(r'[^ABS]*[ABS]?', s) # May result in empty items, too
re.findall(r'(?s)(?=.)[^ABS]*[ABS]?', s) # no empty items due to the lookahead requiring at least 1 char
</code></pre>
<p>See the <a href="https://regex101.com/r/pGZQIU/2" rel="nofollow noreferrer">regex demo</a>.</p>
<p><strong>Details</strong></p>
<ul>
<li><code>(?s)</code> - <code>.</code> matches newlines, too</li>
<li><code>(?=.)</code> - one char should appear immediately to the right of the current location</li>
<li><code>[^ABS]*</code> - any 0+ chars other than <code>A</code>, <code>B</code> and <code>S</code></li>
<li><code>[ABS]?</code> - 1 or 0 (=optional) <code>A</code>, <code>B</code> or <code>S</code> char.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>re.findall</code> instead, and match digits followed by either <code>A</code>, <code>B</code>, or <code>S</code>:</p>
<pre><code>re.findall(r'\d+[ABS]', '11A4B')
</code></pre>
<p>Output:</p>
<pre><code>['11A', '4B']
</code></pre>
<p>If the input might have other alphabetical characters as well, then use a negated character set instead:</p>
<pre><code>re.findall(r'[^ABS]+[ABS]', 'ZZZAYYYSXXXB')
</code></pre>
<p>Output:</p>
<pre><code>['ZZZA', 'YYYS', 'XXXB']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use lookarounds:</p>
<pre><code>(?&lt;=[ABS])(?!$)
</code></pre>
<p>Se <a href="https://regex101.com/r/9g64oU/1" rel="nofollow noreferrer"><strong>a demo on regex101.com</strong></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>findall</code>:</p>
<pre><code>re.findall('(.*?(?:[ABS]|.$))', "11A4B5")
</code></pre>
</div>
<span class="comment-copy">What is the Python version? With PyPi regex module, you may do that with "pure" regex. Python 3.7 also has a fixed <code>re.split</code> method to be used with <code>(?&lt;=[ABS])(?!$)</code>.</span>
<span class="comment-copy">The version used is Python 3.6</span>
<span class="comment-copy">@WiktorStribi≈ºew: Saw your comment a bit too late.</span>
<span class="comment-copy">Then you need a workaround, e.g. <code>re.findall(r'(?=.)[^ABS]*[ABS]?', s)</code>.</span>
<span class="comment-copy">Well, if you do not mind empty elements, <a href="https://regex101.com/r/pGZQIU/1" rel="nofollow noreferrer"><code>re.findall(r'[^ABS]*[ABS]?', s)</code></a> will do.</span>
<span class="comment-copy">Since I have only digits it works! was the other way round , thanks :)</span>
<span class="comment-copy">So, it won't work with python 3.6 <code>re</code>. It will only work with <code>regex</code> module if you use a specific flag</span>
<span class="comment-copy">thank you for the link, very usefull.</span>
<span class="comment-copy">seems naughty, could you elaborate?</span>
<span class="comment-copy">@ColonelBeauvel: Problem with CertainPerformance's solution are consecutive delimiters and everything after the last delimiter. <code>.*?</code> takes zero or more characters up to the next delimiter, <code>|.$</code> takes everything after the last delimiter.</span>
