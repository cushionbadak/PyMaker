<div class="post-text" itemprop="text">
<p>There are many posts about relative/absolute imports issues, and most of them are about Python 2 and/or importing submodules. <strong>This is not my case</strong>: </p>
<ul>
<li>I am using Python 3, so absolute import is the default;</li>
<li>(I have also reproduced this issue with Python 2);</li>
<li>I am not trying to import a submodule from within another submodule, or any other complicated situation. I am just trying to <code>import numpy</code> in a script.</li>
</ul>
<p>My problem is simple:</p>
<pre><code>.
└── foo
    ├── a.py
    └── math.py

1 directory, 2 files
</code></pre>
<p>where <code>a.py</code> just contains <code>import nupmy</code>, and <code>math.py</code> contains <code>x++</code> (intentionally invalid).</p>
<p>In that case, running <code>python3 foo/a.py</code> causes an error, due to NumPy seemingly not being able to import the standard <code>math</code> module:</p>
<pre><code>Traceback (most recent call last):
  File "foo/a.py", line 1, in &lt;module&gt;
    import numpy
  File "/path/to/Anaconda3/lib/python3.6/site-packages/numpy/__init__.py", line 158, in &lt;module&gt;
    from . import add_newdocs
  File "/path/to/Anaconda3/lib/python3.6/site-packages/numpy/add_newdocs.py", line 13, in &lt;module&gt;
    from numpy.lib import add_newdoc
  File "/path/to/Anaconda3/lib/python3.6/site-packages/numpy/lib/__init__.py", line 3, in &lt;module&gt;
    import math
  File "/private/tmp/test-import/foo/math.py", line 1
    x++
      ^
SyntaxError: invalid syntax
</code></pre>
<p>I am relatively inexperienced with Python, but this looks like a bug to me. I thought statements like <code>import math</code> in Python 3 behaved as absolute imports; how can a local file conflict with a standard module? Am I doing something wrong?</p>
<p><strong>To clarify, what I find surprising is that NumPy is unable to load the standard math module with <code>import math</code>, because I have a file in my local folder named <code>math.py</code>.</strong> Note that I never try to import that module myself.</p>
<hr/>
<p><strong>EDIT</strong></p>
<p><strike>This seems to be an issue specific to <code>conda</code> (reproduced with both Anaconda and Miniconda). I am using Anaconda 5.2.0 (on OSX 10.13.6), and people in comments have been able to reproduce with different versions of python/anaconda, and different systems.</strike></p>
<p>I was able to reproduce this issue with:</p>
<ul>
<li>Anaconda3 v5.2.0, using python 3.4, 3.5, 3.6 and 3.7, within a <code>conda</code> environment, or simply using the default binaries (ie <code>/path/to/anaconda3/bin</code>).</li>
<li>Miniconda2, and Miniconda3 (manual install of <code>numpy</code> required), again either within or outside a <code>conda</code> environment.</li>
<li>A clean Homebrew install <code>brew install python</code>.</li>
</ul>
<p>In all cases, it looks like the builtin-modules might be incomplete:</p>
<pre><code>&gt; python3 -c "import sys; print(sys.builtin_module_names)"
('_ast', '_codecs', '_collections', '_functools', '_imp', '_io', '_locale', '_operator', '_signal', '_sre', '_stat', '_string', '_symtable', '_thread', '_tracemalloc', '_warnings', '_weakref', 'atexit', 'builtins', 'errno', 'faulthandler', 'gc', 'itertools', 'marshal', 'posix', 'pwd', 'sys', 'time', 'xxsubtype', 'zipimport')

&gt; python2 -c "import sys; print sys.builtin_module_names"
('__builtin__', '__main__', '_ast', '_codecs', '_sre', '_symtable', '_warnings', '_weakref', 'errno', 'exceptions', 'gc', 'imp', 'marshal', 'posix', 'pwd', 'signal', 'sys', 'thread', 'xxsubtype', 'zipimport')
</code></pre>
<hr/>
<p><strong>REPRODUCE THIS ISSUE</strong></p>
<p>Make sure you have a version of Python that can import numpy. Open a terminal and type:</p>
<pre><code>D=$(mktemp -d)                      # temporary folder
pushd "$D"                          # move there 
mkdir foo                           # create subfolder
echo 'import numpy' &gt;| foo/a.py     #   script a.py
echo 'x++' &gt;| foo/math.py           #   script math.py (invalid)
python foo/a.py                     # run a.py
popd                                # leave temp folder
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>"Absolute import" does not mean "standard library import". It means that <code>import math</code> always tries to import the <code>math</code> module, rather than the old behavior of trying <code>currentpackage.math</code> first if the import occurs inside a package. It does <em>not</em> mean that Python will skip non-stdlib entries on <code>sys.path</code> when figuring out where the <code>math</code> module is. In your situation, by the rules of the Python import system, your <code>math.py</code> is the <code>math</code> module.</p>
<hr/>
<p>The tutorial link you found with the line</p>
<blockquote>
<p>When a module named spam is imported, the interpreter first searches for a built-in module with that name.</p>
</blockquote>
<p>is referring to modules that are <em>directly compiled into the Python executable</em>, like <code>sys</code>. Such modules say <code>built-in</code> in their <code>repr</code>:</p>
<pre><code>&gt;&gt;&gt; sys
&lt;module 'sys' (built-in)&gt;
</code></pre>
<p>You can see the names of all such modules in <a href="https://docs.python.org/3/library/sys.html#sys.builtin_module_names" rel="nofollow noreferrer"><code>sys.builtin_module_names</code></a>. For me, those names are</p>
<pre><code>&gt;&gt;&gt; sys.builtin_module_names
('_ast', '_codecs', '_collections', '_functools', '_imp', '_io', '_locale', '_operator', '_signal', '_sre', '_stat', '_string', '_symtable', '_thread', '_tracemalloc', '_warnings', '_weakref', 'atexit', 'builtins', 'errno', 'faulthandler', 'gc', 'itertools', 'marshal', 'posix', 'pwd', 'sys', 'time', 'xxsubtype', 'zipimport')
</code></pre>
<p><code>math</code> isn't built-in in that sense.</p>
</div>
<span class="comment-copy">the Traceback doesn't have anything to do with imports, it's clearly saying <code>invalid syntax</code>, remove that <code>x++</code> and you should be good to go</span>
<span class="comment-copy">@Sheljohn that's not a restriction of the language, that's how the import mechanism works. There is no built-in list of stdlib modules. If you want module "math", Python will look through <code>sys.path</code> in order, and the first "math" it finds is your module.</span>
<span class="comment-copy">The documentation also states  "When a module named spam is imported, the interpreter first searches for a built-in module with that name" (<a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">docs.python.org/3/tutorial/modules.html#the-module-search-path</a>). So python should not import the local file, even though it seems to do so.</span>
<span class="comment-copy">@jdamp you're confusing "built-in module" with "standard library module". Built-in names are things like <code>open</code>, or, in this case, module <code>builtins</code>. These are part of the interpreter itself. But most of the library lives in its own files.</span>
<span class="comment-copy">@Sheljohn  I can reproduce the behavior you observe only with anaconda's python (both python 3.5 and 3.6), while it works fine for me with the builtin python3.5 on Ubuntu. So this issue might actually be anaconda specific.</span>
<span class="comment-copy">My modules are not packaged, and I am only importing numpy, not the math module. The fact that <i>NumPy</i> is unable to import the standard math module by writing <code>import math</code>, because I have a file named <code>math.py</code> in my local folder, is completely insane.</span>
<span class="comment-copy">@Sheljohn: There are certainly annoyances in the Python import system. (Personally, I've always hated how easy it is to wind up with three distinct modules created from the same file.) What you're seeing is a consequence of how local files get dumped into the same top-level module namespace as stdlib and installed modules. Python wasn't designed with the whole stdlib in a <code>std</code> package like C++'s <code>std</code> namespace, and there's no implicit package for local files or anything like that to keep local files out of top-level.</span>
<span class="comment-copy">I wish it was just a matter of annoyance, but this actually means we are constantly hacking the modules we load, by (potentially silently) hiding the modules that <i>they</i> load. If <code>sys</code> is a built-in though, does this mean it cannot be shadowed by local files, e.g. when writing: <code>import sys; sys.path = list(reversed(sys.path))</code> ?</span>
