<div class="post-text" itemprop="text">
<p>Is there any tool/library through which the list of methods/functions called within another methods/functions can be listed?</p>
<p>For example:
If that tool or library runs for below method</p>
<pre><code>def calculate(a: int, b: int, operator: Operator):
    if operator == Operator.add:
        add(a, b)
    elif operator == Operator.subtract
        subtract(a, b)
</code></pre>
<p>then it should return</p>
<pre><code>1. add
2. subtract
</code></pre>
<p>This question is almost same as <a href="https://stackoverflow.com/questions/13659042/how-to-find-all-methods-called-in-a-method">this one</a> but it's for Java. </p>
<p>This is basically same as what <code>PyCharm</code> does for <code>Find Usage</code>.
Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>This seems to do the work:</p>
<pre><code>import dis
def list_func_calls(fn):
    funcs = []
    bytecode = dis.Bytecode(fn)
    instrs = list(reversed([instr for instr in bytecode]))
    for (ix, instr) in enumerate(instrs):
        if instr.opname=="CALL_FUNCTION":
            load_func_instr = instrs[ix + instr.arg + 1]
            funcs.append(load_func_instr.argval)

    return ["%d. %s" % (ix, funcname) for (ix, funcname) in enumerate(reversed(funcs), 1)]
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; list_func_calls(calculate)
['1. add', '2. subtract']
</code></pre>
<p>What's happening here is:</p>
<ol>
<li>we make a Bytecode object of the function </li>
<li>we reverse the list of instructions, since the function name will
follow the function call</li>
<li><p>we step through the list, and for each CALL_FUNCTION instruction, </p></li>
<li><p>we use the instructions <code>arg</code> parameter to tell us how many
arguments    we're getting </p></li>
<li><p>we look one past that to find the instruction that loads the function
we're calling </p></li>
<li><p>we add that function's name (<code>instr.argval</code>) to a list which we then
reverse, enumerate, and return in the requested format</p></li>
</ol>
<p>Note that since Python 3.6, there are three <code>CALL_FUNCTION</code> instructions, so you'll have to check the documentation to extend this example to be fully functional with current python</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update:</strong> added compatibility for <code>Python2.7</code><br/>
Tested and confirmed working with <code>Python2.7</code>, <code>Python3.5</code> and <code>Python3.6</code></p>
<hr/>
<p><strong>Credit for pointing out <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> goes to <a href="https://stackoverflow.com/users/6779307/patrick-haugh">Patrick Haugh</a>¹</strong> <br/>Implementation (parsing of the <code>dis</code> output) is my own:</p>
<hr/>
<p><strong>Setup:</strong></p>
<pre><code>import dis
import sys
from contextlib import contextmanager

# setup test environment
def a(_,__):
    pass

def b(_,__,___):
    pass

def c(_):
    pass

def g():
    pass 

d = 4

def test(flag):
    e = c

    if flag:
        a(a(b,c), [l for l in g(1, x=2)])
    else:
        b(a, int(flag), c(e))

    d = d + 1


def calculate(a, b, operator):
    if operator == Operator.add:
        add(a, b)
    elif operator == Operator.subtract:
        subtract(a, b)

class Operator(object):
    add = "add"
    subtract = "subtract"
</code></pre>
<hr/>
<p><strong>Python 2/3 compatibility:</strong></p>
<pre><code>class AttrDict(dict):
    def __init__(self, *args, **kwargs):
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self

@contextmanager # https://stackoverflow.com/a/12111817/2422125
def captureStdOut(output):
    stdout = sys.stdout
    sys.stdout = output
    try:
        yield
    finally:
        sys.stdout = stdout


""" for Python &lt;3.4 """
def get_instructions(func):
    import StringIO

    out = StringIO.StringIO()
    with captureStdOut(out):
        dis.dis(func)

    return [AttrDict({
               'opname': i[16:36].strip(),
               'arg': int(i[37:42].strip() or 0),
               'argval': i[44:-1].strip()
           }) for i in out.getvalue().split("\n")]


if sys.version_info &lt; (3, 4):
    dis.get_instructions = get_instructions
    import __builtin__ as builtin
else:
    import builtins as builtin
</code></pre>
<p><strong>Code:</strong> </p>
<pre><code>def get_function_calls(func, built_ins=False):
    # the used instructions
    ins = list(dis.get_instructions(func))[::-1]

    # dict for function names (so they are unique)
    names = {}

    # go through call stack
    for i, inst in list(enumerate(ins))[::-1]:
        # find last CALL_FUNCTION
        if inst.opname[:13] == "CALL_FUNCTION":

            # function takes ins[i].arg number of arguments
            ep = i + inst.arg + (2 if inst.opname[13:16] == "_KW" else 1)

            # parse argument list (Python2)
            if inst.arg == 257:
                k = i+1
                while k &lt; len(ins) and ins[k].opname != "BUILD_LIST":
                    k += 1

                ep = k-1

            # LOAD that loaded this function
            entry = ins[ep]

            # ignore list comprehensions / ...
            name = str(entry.argval)
            if "." not in name and entry.opname == "LOAD_GLOBAL" and (built_ins or not hasattr(builtin, name)):
                # save name of this function
                names[name] = True

            # reduce this CALL_FUNCTION and all its paramters to one entry
            ins = ins[:i] + [entry] + ins[ep + 1:]

    return sorted(list(names.keys()))
</code></pre>
<hr/>
<p><strong>Output:</strong></p>
<pre><code>&gt; print(get_function_calls(test))
&gt; ['a', 'b', 'c', 'g']

&gt; print(get_function_calls(test, built_ins=True))
&gt; ['a', 'b', 'c', 'g', 'int']

&gt; print(get_function_calls(calculate))
&gt; ['add', 'subtract']
</code></pre>
<hr/>
<p><sup>¹As <a href="https://stackoverflow.com/users/6779307/patrick-haugh">Patrick Haugh</a>'s comment about <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> is over 2h old I consider this one <em>free for taking...</em></sup></p>
</div>
<span class="comment-copy">add and subtract are function calls rather than function definition @Stack</span>
<span class="comment-copy">@Stack still answering the wrong question</span>
<span class="comment-copy">@Stack Nope That answers who calls add rather than OP's question. So No.</span>
<span class="comment-copy">Try this <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">lib</a> for retrieving the interpreter stack.</span>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> to disassemble the function.  Look for the <code>CALL_FUNCTION</code> bytecodes.  You'll have to work backwards from them to get the function they're calling (which won't always be there).</span>
<span class="comment-copy">@FabianN's answer was posted as I was finishing this up, so I figured I'd go ahead and post it. Slightly different approach, which is interesting.</span>
<span class="comment-copy">This fails if you have nested function calls, try it out with my test cases but maybe the use case of the op is limited to simple calls.</span>
<span class="comment-copy">@FabianN. Good point. Let me see if I can improve on it a little. Thanks!</span>
<span class="comment-copy">I just found the next pitfall: list comprehension inside a function call, you can filter them with <code>"." not in entry.argval</code></span>
<span class="comment-copy">My friend, I am pleased that you're enjoying this code so much. Thanks for encouraging me to improve it!</span>
<span class="comment-copy">Nice approach, but will currently break on functions with keywoard arguments for Python 3.6+. They  introduced <code>CALL_FUNCTION_KW</code> (and <code>CALL_FUNCTION_EX</code>).  Worth noting may also be that it will also catch things like class instantiation and builtins like <code>dict()</code> and <code>tuple()</code>, <code>int()</code>... technically not wrong but probably not what the user might think of.</span>
<span class="comment-copy">@Darkonaut good point, I will add a switch to ignore class instantiation and the like, parsing <code>CALL_FUNCTION_EX</code> will get funny ... eta sometime today ... I think</span>
<span class="comment-copy">@Darkonaut I got keyword arguments working and added a flag to disable inbuilt functions but class constructors have to stay for now (no Idea on how to filter them without eval)</span>
<span class="comment-copy">@PaulRooney thanks for pointing that out but as my only input was  Patrick Haugh's comment "[...]You can use dis to disassemble the function[...]" I didn't see it appropriate. The main work was to parse the output, I just added a little note at the top as basic courtesy.</span>
<span class="comment-copy">Still needs some refinement. You didn't define <code>builtin</code> here before <code>hasattr(builtin, name)</code> so you get <code>NameError </code> when you set <code>built_ins=False</code>. If you set <code>built_ins=True</code> it won't include builtins with keywoard arguments, e.g. <code>enumerate([1,2], start=1)</code>.</span>
