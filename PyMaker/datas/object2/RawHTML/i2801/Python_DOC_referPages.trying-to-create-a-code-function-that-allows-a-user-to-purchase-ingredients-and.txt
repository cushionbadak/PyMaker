<div class="post-text" itemprop="text">
<p>I'm a beginner Python coder and I'm attempting to create a function that allows a user to purchase/buy 3 different ingredients ('apples','beets', and 'carrots') which are each $1. The function I've defined will take 2 arguments (the ingredient name and how many they want to purchase). The maximum amount of money that the user has is $20.</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>iinventory={}
iinventory['apple']=0
iinventory['beets']=0
iinventory['carrots']=0

def buyingredient(ingredient_name,number: int):
    total=20
    while total &gt; 0:
        if number &gt; total:
            break
        if number &lt; total:
            iinventory[ingredient_name] += number
            total = total + number
            iinventory.append(number))</code></pre>
</div>
</div>
</p>
<p>I'm having trouble on how to actually begin the code since first I have to make sure that the amount they are purchasing is not over their total amount of money ($20). Also, I'm not sure how to put the purchased amount of money into the inventory that is a dictionary. I thought I could use append but I think that's only for lists not dictionaries.</p>
<p>Then however many they buy of apples, beets, or carrots will be reflected on their total and will substract.
For example, if they bought 3 apples:</p>
<p>buyingredient('apple',3)</p>
<p>Then the inventory will say they have 3 apples and a total of $17 left.</p>
<p>iinventory={'apple':3,'beets':0,'carrots':0}
total=17</p>
<p>Not sure where to go from here for the code now....</p>
</div>
<div class="post-text" itemprop="text">
<p>Try keeping track of the amount you've spent as new ingredients are purchased, then you can avoid that loop:</p>
<pre><code>inventory = {
    "apple": 0,
    "beets": 0,
    "carrots": 0}

total_budget = 20
total_spent = 0

def buy_ingredient(name, number):
    if number + total_spent &gt; total_budget:
        raise ValueError("overspent!")
    inventory[name] += number
    total_spent += number
</code></pre>
<p>Let's try it out (bear with me, I'm going to take a bit of a tangent):</p>
<pre><code>&gt;&gt;&gt; buy_ingredient('apple', 2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in buy_ingredient
UnboundLocalError: local variable 'total_spent' referenced before assignment
</code></pre>
<p>Gah!</p>
<p>This fails because <code>total_spent</code> is defined outside the function. For that reason, it's generally considered bad practice to have functions update variables that "live" outside them - it's preferred to return something instead. (Yes, updating <code>iinventory</code> will work, but it's still considered bad style.)</p>
<p>In this case, you're creating something but then modifying it an unknown number of times - a perfect opportunity to take classes for a spin. Let's create a <code>GroceryBasket</code> that keeps track of your budget and the items you add:</p>
<pre><code>from collections import defaultdict

class GroceryBasket(object):
    def __init__(self, budget):
        self.items = defaultdict(int)
        self.budget = budget
        self.spent_so_far = 0

    def add_ingredient(self, name, number):  # note this is almost exactly the `buy_ingredient` function from above
        if number + self.spent_so_far &gt; self.budget:
            raise ValueError("overspent!")
        self.items[name] += number
        self.spent_so_far += number
</code></pre>
<p>Create an instance, specifying your budget:</p>
<pre><code>&gt;&gt;&gt; basket = GroceryBasket(budget=20)
&gt;&gt;&gt; basket.budget
20
&gt;&gt;&gt; basket.spent_so_far
0
</code></pre>
<p>Add 5 apples:</p>
<pre><code>&gt;&gt;&gt; basket.add_ingredient("apple", 5)
&gt;&gt;&gt;
&gt;&gt;&gt; basket.items
defaultdict(&lt;type 'int'&gt;, {'apple': 5})
&gt;&gt;&gt;
&gt;&gt;&gt; basket.spent_so_far
5
</code></pre>
<p>And now 100 beets:</p>
<pre><code>&gt;&gt;&gt; basket.add_ingredient('beets', 100)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 8, in add_ingredient
ValueError: overspent!
</code></pre>
<p>Anyway, that's probably more answer than you were looking for, but I wanted to tighten up your function while making the point that it should either return a value or update the state of an object passed in (in this case, <code>self</code>) without leaving you hanging. Hope this helps.</p>
<p>(Btw, if you're wondering what <code>defaultdict</code> is, take a look at the docs, they're quite good. There's an example that shows the use of <code>defaultdict(int)</code> with the <code>+=</code> operator not too far down: <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#collections.defaultdict</a>)</p>
</div>
<span class="comment-copy">thank you! so for the iinventory i made it as a dictionary and by modifying the amount of apples, beets, and carrots it would modify that in the dictionary. is that hard to do or bad?</span>
<span class="comment-copy">Welcome! That's fine, the <code>defaultdict</code> is just a special dictionary that saves you from checking whether an item exists before you try incrementing it - <code>self.items[name] += number</code> will fail the first time you encounter each ingredient.</span>
<span class="comment-copy">is there a way to add the bought ingredients into the dictionary iinventory={} ?</span>
<span class="comment-copy">That <code>while</code> loop will run forever right now because total can never be less than or equal to <code>0</code>, so you really need a bigger-picture refactor to get this working. <code>iinventory[ingredient_name] += number</code> is the correct syntax for adding items to <code>iinventory</code>, <code>iinventory.append(number))</code> needs to be removed. Once you've experimented a little bit, I'd recommend posting your code on codereview.stackexchange.com</span>
