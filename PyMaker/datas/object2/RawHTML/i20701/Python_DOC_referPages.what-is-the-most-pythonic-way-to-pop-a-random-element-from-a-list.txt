<div class="post-text" itemprop="text">
<p>Say I have a list <code>x</code> with unkown length from which I want to randomly pop one element so that the list does not contain the element afterwards. What is the most pythonic way to do this?</p>
<p>I can do it using a rather unhandy combincation of <code>pop</code>, <code>random.randint</code>, and <code>len</code> and would like to see shorter or nicer solutions:</p>
<pre><code>import random
x = [1,2,3,4,5,6]
x.pop(random.randint(0,len(x)-1))
</code></pre>
<p><strong>Edit:</strong> What I am trying to achieve is consecutively pop random elements from a list. (i.e., randomly pop one element and move it to a dictionary, randomly pop another element and move it to another dictionary, ...)</p>
<hr/>
<p>Note that I am using Python 2.6 and did not find any solutions via the search function.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you seem to be up to doesn't look very Pythonic in the first place. You shouldn't remove stuff from the middle of a list, because lists are implemented as arrays in all Python implementations I know of, so this is an <code>O(n)</code> operation.</p>
<p>If you really need this functionality as part of an algorithm, you should check out a data structure like the <a href="https://pypi.python.org/pypi/blist" rel="noreferrer"><code>blist</code></a> that supports efficient deletion from the middle.</p>
<p>In pure Python, what you can do if you don't need access to the remaining elements is just shuffle the list first and then iterate over it:</p>
<pre><code>lst = [1,2,3]
random.shuffle(lst)
for x in lst:
  # ...
</code></pre>
<p>If you <em>really need</em> the remainder (which is a bit of a code smell, IMHO), at least you can <code>pop()</code> from the end of the list now (which is fast!):</p>
<pre><code>while lst:
  x = lst.pop()
  # do something with the element      
</code></pre>
<p>In general, you can often express your programs more elegantly if you use a more functional style, instead of mutating state (like you do with the list).</p>
</div>
<div class="post-text" itemprop="text">
<p>You won't get much better than that, but here is a slight improvement:</p>
<pre><code>x.pop(random.randrange(len(x)))
</code></pre>
<p>Documentation on <a href="http://docs.python.org/library/random.html#random.randrange"><code>random.randrange()</code></a>:</p>
<blockquote>
<p>random.randrange([start], stop[, step])<br/>
  Return a randomly selected element from <code>range(start, stop, step)</code>. This is equivalent to <code>choice(range(start, stop, step))</code>, but doesnâ€™t actually build a range object.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Here's another alternative: why don't you shuffle the list <em>first</em>, and then start popping elements of it until no more elements remain? like this:</p>
<pre><code>import random

x = [1,2,3,4,5,6]
random.shuffle(x)

while x:
    p = x.pop()
    # do your stuff with p
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To remove a <em>single</em> element at random index from a list if the order of the rest of list elements doesn't matter:</p>
<pre><code>import random

L = [1,2,3,4,5,6]
i = random.randrange(len(L)) # get random index
L[i], L[-1] = L[-1], L[i]    # swap with the last element
x = L.pop()                  # pop last element O(1)
</code></pre>
<p>The swap is used to avoid O(n) behavior on deletion from a middle of a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to do it is:</p>
<pre><code>x.remove(random.choice(x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While not popping from the list, I encountered this question on Google while trying to get X random items from a list without duplicates. Here's what I eventually used:</p>
<pre><code>items = [1, 2, 3, 4, 5]
items_needed = 2
from random import shuffle
shuffle(items)
for item in items[:items_needed]:
    print(item)
</code></pre>
<p>This may be slightly inefficient as you're shuffling an entire list but only using a small portion of it, but I'm not an optimisation expert so I could be wrong.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer comes courtesy of <a href="https://stackoverflow.com/users/916657/niklas-b">@niklas-b</a>: </p>
<p>"<em>You probably want to use something like <a href="http://pypi.python.org/pypi/blist" rel="nofollow noreferrer">pypi.python.org/pypi/blist</a></em> "</p>
<p>To quote the <a href="http://pypi.python.org/pypi/blist" rel="nofollow noreferrer">PYPI page</a>:</p>
<blockquote>
<p>...a list-like type with better asymptotic performance and similar
  performance on small lists</p>
<p>The blist is a drop-in replacement for the Python list that provides
  better performance when modifying large lists. The blist package also
  provides sortedlist, sortedset, weaksortedlist, weaksortedset,
  sorteddict, and btuple types.</p>
</blockquote>
<p><strong><em>One would assume lowered performance on the random access/random run end</em></strong>, as it is a "copy on write" data structure. This violates many use case assumptions on Python lists, <strong><em>so use it with care</em></strong>.</p>
<p>HOWEVER, if your main use case is to do something weird and unnatural with a list (as in the forced example given by @OP, or my Python 2.6 FIFO queue-with-pass-over issue), then this will fit the bill nicely.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is an old question, but just for documentation's sake:</p>
<p>If you (the person googling the same question) are doing what I think you are doing, which is selecting k number of items randomly from a list (where k&lt;=len(yourlist)), but making sure each item is never selected more than one time (=sampling without replacement), you could use <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer">random.sample</a> like @j-f-sebastian suggests. But without knowing more about the use case, I don't know if this is what you need.</p>
</div>
<span class="comment-copy">I'm not much of a Pythonista, but that sure looks pretty good to me.</span>
<span class="comment-copy">So a better (faster) idea would be to use <code>random.shuffle(x)</code> and then <code>x.pop()</code>? I do not understand how to do this "functional"?</span>
<span class="comment-copy">@Henrik: If you have two collections (for example, a list of dictionaries and a list of random numbers) and you want to iterate them at the same time, you can <code>zip</code> them to get a list of (dict, number) pairs. You said something about multiple dictionaries of which you want to associate each with a random number. <code>zip</code> is perfect for this</span>
<span class="comment-copy">I'm supposed to add a post when I down-vote. There are times when you need to remove an item from the middle of a list...I have to do it right now. No choice: I have an ordered list, I have to remove an item in the middle. It sucks, but the only other choice is to do a heavy code refactoring for one semi-rare operation. The issue is one of implementation of [ ], which SHOULD be efficient for such operations, but is not.</span>
<span class="comment-copy">@NiklasB. The OP was using random as an example (frankly, it should have been left off, it clouded the issue). "Don't do that" is insufficient. A better answer would have been to suggest a Python data structure that DOES support such operations while providing SUFFICIENT access speed (clearly not as good as arra...er...list). In python 2, I could not find one. If I do, I will answer with that. Note that due to a browser mishap, I was unable to add that in to my original comment, I should have added a secondary comment. Thank you for keeping me honest :)</span>
<span class="comment-copy">@MarkGerolimatos There is no data structure with both efficient random access and insert/delete in the standard library. You probably want to use something like <a href="https://pypi.python.org/pypi/blist" rel="nofollow noreferrer">pypi.python.org/pypi/blist</a> I would still argue that in a lot of use cases this can be avoided</span>
<span class="comment-copy">Why not <code>for p in x</code>?</span>
<span class="comment-copy">@NiklasB. because we're removing elements from the list. If it's not absolutely necessary to remove elements, yes I agree with you: <code>[for p in x]</code></span>
<span class="comment-copy">Because it alters the list and if you just want to select half of the elements now and the other half later, you will have the remaining set later.</span>
<span class="comment-copy">@Henrik: Okay, that's why I asked you if you need the remaining list. You didn't answer that.</span>
<span class="comment-copy">This could get problematic if elements occur more the once.</span>
<span class="comment-copy">This will remove the leftmost element when there are duplicates, causing a not perfectly random result.</span>
<span class="comment-copy">With <code>pop</code> you can point a name at the removed element, with this you can't.</span>
<span class="comment-copy">Fair enough, I agree that this is not very random when elements occur more than once.</span>
<span class="comment-copy">Aside from the question of skewing your distribute, <code>remove</code> requires a linear scan of the list. That's terribly inefficient compared to looking up an index.</span>
<span class="comment-copy"><code>random.sample(items, items_needed)</code></span>
<span class="comment-copy">You're reading my mind, thanks! :)</span>
