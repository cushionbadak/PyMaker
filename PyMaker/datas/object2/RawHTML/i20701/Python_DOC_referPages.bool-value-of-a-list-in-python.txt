<div class="post-text" itemprop="text">
<p>what is the best way to turn a list into bool value? I am looking for something like:</p>
<pre><code>return eval_bool(my_list)
</code></pre>
<p>I have a custom container in which I implement the <code>__nonzero__</code> method which is supposed to work like this:</p>
<pre><code>if self.my_list:
    return True
return False
</code></pre>
<p>But is it pythonic enough? :) Anyway, I am curious how Python interprets the value of the list in the <code>if</code> statement because this code works differently:</p>
<pre><code>return my_list == True
</code></pre>
<p>J.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use:</p>
<pre><code>bool(my_list)
</code></pre>
<p>Which evaluates it as Python "truthiness" and returns a real Boolean.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>len(my_list) == 0</code> it is returned as <code>false</code>, otherwise it is <code>true</code>. It is completely pythonic to write:</p>
<pre><code>return len(my_list)
</code></pre>
<p>which although it is returned as an integer, evaluates as <code>true</code> for non zero lengths, and false otherwise.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use ternary "if" operator. Google says it supported since 2.5</p>
<pre><code>foo = True if your_list else False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>99.9% of the time, performance doesn't matter, so just use <code>bool(my_list)</code> as <a href="https://stackoverflow.com/a/9850253/364696">Keith suggests</a>.</p>
<p>In the cases where performance <em>does</em> matter though, the nature of <code>bool</code> means it's actually quite slow, at least on the CPython reference interpreter. It has to go through generalized function call paths, to generalized constructor paths, to generalized argument parsing for 0-1 arguments (and in <a href="https://bugs.python.org/issue29695" rel="nofollow noreferrer">all but the most recent versions of Python</a>, checking for keyword arguments), all to eventually just increment as reference count on a singleton and return it.</p>
<p>You can see how much this costs with <code>ipython</code> microbenchmarks (on my Windows x64 3.6.3 build):</p>
<pre><code>In [1]: %%timeit -r5 l = []
   ...: bool(l)
   ...:
118 ns ± 0.808 ns per loop (mean ± std. dev. of 5 runs, 10000000 loops each)
In [11]: %%timeit -r5 l = [1]
    ...: bool(l)
    ...:
117 ns ± 0.306 ns per loop (mean ± std. dev. of 5 runs, 10000000 loops each)
</code></pre>
<p>It may not be obvious, but even on my relatively weak laptop, 117-118 nanoseconds just to determine truthiness is a bit much. Luckily, there are a couple other options. One is to abuse syntax to go through a dedicated path for truthiness evaluation (from here on out, I'll just test the empty <code>list</code>, the timings are basically identical either way):</p>
<pre><code>In [3]: %%timeit -r5 l = []
   ...: not not l
   ...:
25 ns ± 0.289 ns per loop (mean ± std. dev. of 5 runs, 10000000 loops each)
</code></pre>
<p>That's a vast improvement; it takes roughly one fifth the time. On Python 3, using <code>True if l else False</code> also works with equal speed, but it's much slower than <code>not not</code> on Python 2, where <code>True</code> and <code>False</code> aren't protected literals, just built-in names that must be loaded dynamically each time.</p>
<p>Still, it's not perfect; sometimes you <em>need</em> a callable, e.g. to convert a lot of values to <code>bool</code> via a callback function (e.g. with <code>map</code>). Luckily, <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">the <code>operator</code> module</a> has you covered <a href="https://docs.python.org/3/library/operator.html#operator.truth" rel="nofollow noreferrer">with <code>operator.truth</code></a>; while it's still a callable with all the overhead that entails, it's not a constructor, it takes <em>exactly</em> one argument (not 0-1), and it doesn't allow keyword arguments, all of which cost a surprising amount on the CPython reference interpreter. So when you can't use implicit truthiness testing or syntax based conversion with <code>not not</code>, and you still need the speed, <code>operator.truth</code> has you covered:</p>
<pre><code>In [4]: from operator import truth

In [5]: %%timeit -r5 l = []
   ...: truth(l)
   ...:
52.1 ns ± 1.1 ns per loop (mean ± std. dev. of 5 runs, 10000000 loops each)
</code></pre>
<p>Twice as long as <code>not not</code>, but if you're using it with built-ins that call it repeatedly (like <code>map</code>) being able to push all the work to the C layer, avoiding byte code execution entirely, can still make it a win, and it's still well under half as costly as <code>bool()</code> itself.</p>
<p>Reiterating my earlier point though: <strong><em>99.9% of the time, performance doesn't matter</em>, so just use <code>bool(my_list)</code> as <a href="https://stackoverflow.com/a/9850253/364696">Keith suggests</a>.</strong> I only mention this because I once had a scenario where that boolean conversion really was the hottest point in my code (verified through profiling), and using implicit truthiness testing (not even converting, just returning the <code>list</code> with the caller doing <code>if myfunc():</code>) shaved 30% off the runtime, and returning <code>not not</code> of the <code>list</code> still got nearly a 20% savings.</p>
</div>
<span class="comment-copy">Wow, how easy! Thanks!</span>
<span class="comment-copy">While <code>bool</code> can be used, it's more Pythonic to just call <code>if my_list:</code> and let Python determine whether <code>my_list</code> should evaluate to <code>True</code> or <code>False</code>.</span>
<span class="comment-copy">@SimeonVisser: Why is <code>if my_list: return True\nreturn False</code> more pythonic than <code>return bool(my_list)</code>?</span>
<span class="comment-copy">It's just not common to write <code>if bool(my_list):</code> when you can also write <code>if my_list:</code>. In most cases, you only need to check whether the list is empty or not, you don't really need a boolean value. Python can see that you're evaluating an if statement and it calls <code>bool()</code> itself. If you really then a boolean value (for example, as output) then <code>bool(my_list)</code> is fine of course.</span>
<span class="comment-copy">@SimeonVisser the goal here is not to have conditional logic at all, but to <i>return</i> a boolean.</span>
<span class="comment-copy">That will return the integer value, however, and we want a boolean.</span>
<span class="comment-copy">it works but it violates pep 8: For sequences, (strings, lists, tuples), use the fact that empty sequences are false. Yes: if not seq: if seq: No: if len(seq) if not len(seq)</span>
<span class="comment-copy">Note: In Python 2, at least for the CPython reference interpreter, this is surprisingly slow, because both <code>True</code> and <code>False</code> are global built-ins that must be loaded from the built-in namespace (which involves a pair of dictionary lookups, one for globals, then a second in builtins when they're not found), not literal constants. In Python 3, they are literal constants, which only require a cheap <code>LOAD_CONST</code> instruction to load (which boils down to a single C level array lookup), so this is one of the two fastest ways to convert to a <code>bool</code> (the other being <code>not not your_list</code>).</span>
