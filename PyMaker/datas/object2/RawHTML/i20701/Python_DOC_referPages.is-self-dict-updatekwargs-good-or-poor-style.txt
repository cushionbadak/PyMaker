<div class="post-text" itemprop="text">
<p>In Python, say I have some class, Circle, that inherits from Shape. Shape needs x- and y-coordinates, and, in addition, Circle needs a radius. I want to be able to initialize Circle by doing something like,</p>
<pre><code>c = Circle(x=1., y=5., r=3.)
</code></pre>
<p>Circle inherits from shape, so I need to use named arguments to <code>__init__</code>, because different classes require different constructors. I could manually set x, y, and r.</p>
<pre><code>class Shape(object):
    def __init__(self, **kwargs):
        self.x = kwargs['x']
        self.y = kwargs['y']

class Circle(Shape):
    def __init__(self, **kwargs):
        super(Circle, self).__init__(**kwargs)
        self.r = kwargs['r']
</code></pre>
<p>or, I could have the attributes of my Circle set automatically using <code>self.__dict__.update(kwargs)</code></p>
<pre><code>class Shape(object):
    def __init__(self, **kwargs):
        self.__dict__.update(**kwargs)

class Circle(Shape):
    def __init__(self, **kwargs):
        super(Circle, self).__init__(**kwargs)
</code></pre>
<p>The advantage of this is that there's less code and I don't need to maintain boilerplate like <code>self.foo = kwargs['foo']</code>. The disadvantage is that it isn't obvious which arguments are needed for Circle. Is this considered a cheat or is this good style (as long as the interface to Circle is well-documented)?</p>
<hr/>
<p>Thanks, everyone, for your thoughtful responses. The <code>self.__dict__.update(**kwargs)</code> hack has been useful for me in experimenting with organizing my code, but I'll make sure that I replace that with properly passing arguments explicitly and doing clear error checking in production code.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Shape(object):
    def __init__(self, x=None, y=None):
        self.x = x
        self.y = y

class Circle(Shape):
    def __init__(self, r=None, **kwargs):
        super(Circle, self).__init__(**kwargs)
        self.r = r
</code></pre>
<p>And this is it.  Don't use <code>**kwargs</code> when you don't really need them.</p>
<blockquote>
<p>Is this considered a cheat or is this good style (as long as the
  interface to Circle is well-documented)?</p>
</blockquote>
<p>When you have a choice between writing a simple, understandable code and headache code + nice docstrings, you actually don't have any choices, you just go and write simple, self-documented code:)</p>
</div>
<div class="post-text" itemprop="text">
<p>I would say that the first method is definitely preferable, because <a href="http://www.python.org/dev/peps/pep-0020/" rel="noreferrer">explicit is better than implicit</a>.</p>
<p>Consider what would happen if you made a typo when initializing a Circle, something like <code>Circle(x=1., y=5., rr=3.)</code>.  You want to see this error immediately, which would not happen with <code>__dict__.update(kwargs)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you wish to assign automatically, I suggest the following approach:</p>
<pre><code>def __init__(self, **kwargs):
    for key, value in kwargs.iteritems():
        setattr(self, key, value)
</code></pre>
<p>which, in terms of style, is somewhere in between writing it explicitly and hacking it yourself using <code>self.__dict__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you wanted it to be more obvious you could have <code>Circle.__init__</code> perform some sanity checks on the arguments. Presumably you'd check to make sure all the arguments are there, and possibly raise errors for meaningless arguments.</p>
<p>You could probably even make a decorator or helper function in <code>Shape</code> to do this for you. Something like this:</p>
<pre><code>class Circle(Shape):
    def __init__(self, **kwargs):
        self.check(kwargs, 'x', 'y', 'r')
        super(Circle, self).__init__(**kwargs)
</code></pre>
<p><code>.check</code> would be implemented in <code>Shape</code> and essentially just verifies that all the arguments are in <code>kwargs</code>, and possibly that no extra ones are (sorry, no code for that one - you can figure it out on your own). You could even have subclasses overload it to check for optional arguments, which you may want to handle differently than other arguments (i.e. give them a default value that wouldn't otherwise be assigned in <code>Shape.__init__</code>.</p>
<p>Otherwise, if you document your interface, and it works the way it's documented, it's always alright. Anything else you do to make it work the way we "expect" it to (throwing exceptions for incorrect arguments) is a bonus.</p>
</div>
<span class="comment-copy">I think this would allow a caller to overload methods .... but if you are teh only person using the code and are not concerned about malicious behavior its probably alright.</span>
<span class="comment-copy">@JoranBeasley - Yes, but if you've done that you're essentially breaking the rules, and it's your own fault.</span>
<span class="comment-copy">You are missing <code>self</code>.</span>
<span class="comment-copy">Also see <a href="http://stackoverflow.com/a/9205029/2705757">Raymond Hettinger's answer to "Pythonic: use of __dict__ in the function self.__init__ of a class"</a></span>
<span class="comment-copy">there are plenty of perfectly reasonable times to use **whatever especially when you are overloading other classes</span>
<span class="comment-copy">@JoranBeasley - Click it again to undo it.</span>
<span class="comment-copy">Where is <code>self</code>?</span>
<span class="comment-copy">@StevenRumbalski Yeah, I had a filling that something is missed:)</span>
<span class="comment-copy">For this solution, be aware that all classes in this chain of inheritance will not have access to the keyword values that are stripped from <code>**kwargs</code> in this way (in the child classes).  For example, Shape cannot define an <code>r</code> parameter and expect to get it, without modifying the <code>__init__</code> method of Circle.</span>
<span class="comment-copy">I'd much rather see <code>self.__dict__.update(kwargs)</code> than this (probably less efficient and) longer way to achieve the same result.</span>
<span class="comment-copy">This would have the advantage of working with descriptors. Working directly with <code>__dict__</code> is a bad idea for that reason alone.</span>
<span class="comment-copy">Could you help me understand why this works better with descriptors?</span>
<span class="comment-copy">My understanding, after reading <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">docs.python.org/3/howto/descriptor.html</a> , is that Chris Morgan (~2) is promoting Simeon's answer because it would work better with classes BASED on your class which DO over-ride the default get/set methods and thus become data descriptors.  Using setattr would be compatible with their over-rides, while using the <b>dict</b> directly would bypass any such overrides.</span>
<span class="comment-copy">How do you know that "<code>.check</code> is implemented in <code>Shape</code>".  Are you the OP's teacher?</span>
<span class="comment-copy">@StevenRumbalski - I'd be the youngest computer science teacher ever if I was. What I meant was that the OP could implement <code>Shape.check</code> and then use it in all the subclasses. I'll clarify that.</span>
