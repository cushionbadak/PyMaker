<div class="post-text" itemprop="text">
<p>I'm trying to replicate <code>from foo.bar import object</code> using the <code>__import__</code> function and I seem to have hit a wall.</p>
<p><code>from glob import glob</code> is easy:
<code>glob = __import__("glob",glob)</code>or <code>glob = __import__("glob").glob</code></p>
<p>The problem I'm having is that I am importing from a package (i.e. bar) and I want the script in the package to be the source of the import.</p>
<p>So what I'd like is something like</p>
<pre><code>string_to_import = "bar"
object = __import__("foo",string_to_import).object
</code></pre>
<p>But this just imports the <code>__init__</code> in the foo package.</p>
<p>How can this be done?</p>
<p>EDIT:
When I use the obvious, only the <code>__init__</code> is called</p>
<pre><code>__import__("foo.bar")
&lt;module 'foo' from 'foo/__init__.pyc'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__import__</code> function will return the top level module of a package, unless you pass a nonempty <code>fromlist</code> argument:</p>
<pre><code>_temp = __import__('foo.bar', fromlist=['object']) 
object = _temp.object
</code></pre>
<p>See the Python docs on the <a href="http://docs.python.org/library/functions.html#__import__" rel="nofollow noreferrer"><code>__import__</code> function</a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>How to use python's <code>__import__()</code> function properly?</h1>
</blockquote>
<p>There are two kinds of uses: </p>
<ul>
<li>direct importing</li>
<li>a hook to alter import behavior</li>
</ul>
<p>For the most part, you don't really need to do either.</p>
<h2>For user-space importing</h2>
<p>Best practice is to use <code>importlib</code> instead. But if you insist:</p>
<p>Trivial usage:</p>
<pre><code>&gt;&gt;&gt; sys = __import__('sys')
&gt;&gt;&gt; sys
&lt;module 'sys' (built-in)&gt;
</code></pre>
<p>Complicated:</p>
<pre><code>&gt;&gt;&gt; os = __import__('os.path')
&gt;&gt;&gt; os
&lt;module 'os' from '/home/myuser/anaconda3/lib/python3.6/os.py'&gt;
&gt;&gt;&gt; os.path
&lt;module 'posixpath' from '/home/myuser/anaconda3/lib/python3.6/posixpath.py'&gt;
</code></pre>
<p>If you want the rightmost child module in the name, pass a nonempty list, e.g. <code>[None]</code>, to <code>fromlist</code>:</p>
<pre><code>&gt;&gt;&gt; path = __import__('os.path', fromlist=[None])
&gt;&gt;&gt; path
&lt;module 'posixpath' from '/home/myuser/anaconda3/lib/python3.6/posixpath.py'&gt;
</code></pre>
<p>Or, as the documentation declares, use <code>importlib.import_module</code>:</p>
<pre><code>&gt;&gt;&gt; importlib = __import__('importlib')
&gt;&gt;&gt; futures = importlib.import_module('concurrent.futures')
&gt;&gt;&gt; futures
&lt;module 'concurrent.futures' from '/home/myuser/anaconda3/lib/python3.6/concurrent/futures/__init__.py'&gt;
</code></pre>
<h3>Documentation</h3>
<p>The docs for <code>__import__</code> are the most confusing of the builtin functions. </p>
<pre><code>__import__(...)
    __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module

    Import a module. Because this function is meant for use by the Python
    interpreter and not for general use it is better to use
    importlib.import_module() to programmatically import a module.

    The globals argument is only used to determine the context;
    they are not modified.  The locals argument is unused.  The fromlist
    should be a list of names to emulate ``from name import ...'', or an
    empty list to emulate ``import name''.
    When importing a module from a package, note that __import__('A.B', ...)
    returns package A when fromlist is empty, but its submodule B when
    fromlist is not empty.  Level is used to determine whether to perform 
    absolute or relative imports. 0 is absolute while a positive number
    is the number of parent directories to search relative to the current module.
</code></pre>
<p>If you read it carefully, you get the sense that the API was originally intended to allow for lazy-loading of functions from modules. However, this is not how CPython works, and I am unaware if any other implementations of Python have managed to do this. </p>
<p>Instead, CPython executes all of the code in the module's namespace on its first import, after which the module is cached in <code>sys.modules</code>.</p>
<p><code>__import__</code> can still be useful. But understanding what it does based on the documentation is rather hard. </p>
<h3>Full Usage of <code>__import__</code></h3>
<p>To adapt the full functionality to demonstrate the current <code>__import__</code> API, here is a wrapper function with a cleaner, better documented, API.</p>
<pre><code>def importer(name, root_package=False, relative_globals=None, level=0):
    """ We only import modules, functions can be looked up on the module.
    Usage: 

    from foo.bar import baz
    &gt;&gt;&gt; baz = importer('foo.bar.baz')

    import foo.bar.baz
    &gt;&gt;&gt; foo = importer('foo.bar.baz', root_package=True)
    &gt;&gt;&gt; foo.bar.baz

    from .. import baz (level = number of dots)
    &gt;&gt;&gt; baz = importer('baz', relative_globals=globals(), level=2)
    """
    return __import__(name, locals=None, # locals has no use
                      globals=relative_globals, 
                      fromlist=[] if root_package else [None],
                      level=level)
</code></pre>
<p>To demonstrate, e.g. from a sister package to baz:</p>
<pre><code>baz = importer('foo.bar.baz')    
foo = importer('foo.bar.baz', root_package=True)
baz2 = importer('bar.baz', relative_globals=globals(), level=2)

assert foo.bar.baz is baz is baz2
</code></pre>
<h3>Dynamic access of names in the module</h3>
<p>To dynamically access globals by name from the baz module, use <code>getattr</code>. For example:</p>
<pre><code>for name in dir(baz):
    print(getattr(baz, name))
</code></pre>
<h2>Hook to alter import behavior</h2>
<p>You can use <code>__import__</code> to alter or intercept importing behavior. In this case, let's just print the arguments it gets to demonstrate we're intercepting it:</p>
<pre><code>old_import = __import__

def noisy_importer(name, locals, globals, fromlist, level):
    print(f'name: {name!r}')
    print(f'fromlist: {fromlist}')
    print(f'level: {level}')
    return old_import(name, locals, globals, fromlist, level)

import builtins
builtins.__import__ = noisy_importer
</code></pre>
<p>And now when you import you can see these important arguments.</p>
<pre><code>&gt;&gt;&gt; from os.path import join as opj
name: 'os.path'
fromlist: ('join',)
level: 0
&gt;&gt;&gt; opj
&lt;function join at 0x7fd08d882618&gt;
</code></pre>
<p>Perhaps in this context getting the globals or locals could be useful, but no specific uses for this immediately come to mind.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>importlib.import_module</code>, <code>__import__</code> is not advised outside the interpreter.</p>
<p>In <code>__import__</code>'s docstring:</p>
<blockquote>
<p>Import a module. Because this function is meant for use by the Python
  interpreter and not for general use it is better to use
  importlib.import_module() to programmatically import a module.</p>
</blockquote>
<p>It also supports <a href="https://docs.python.org/2.5/whatsnew/pep-328.html" rel="nofollow noreferrer">relative imports</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Rather than use the <code>__import__</code> function I would use the getattr function:</p>
<pre><code>model = getattr(module, model_s)
</code></pre>
<p>where module is the module to look in and and model_s is your model string.  The <code>__import__</code> function is not meant to be used loosely, where as this function will get you what you want.</p>
</div>
<span class="comment-copy">3 problems with this answer: <code>level=-1</code> allows for implicit relative importing in Python 2 - this was considered bad and removed from Python 3, so this code no longer works for Python 3. Also, <code>locals</code> does nothing, and <code>fromlist</code> only needs to be non-empty to return the target module instead of the root package. I fully explain in my answer below.</span>
<span class="comment-copy">WOW. This should be the accepted answer and have lots more upvotes. Thank you.</span>
<span class="comment-copy">The sentences you quoted from <code>__import__</code>'s documentation are no longer there; rather there is a statement that <code>__import__</code> is an advanced function and not for everyday usage but no mention of using it outside the interpreter.</span>
<span class="comment-copy">@RiccardoMurri, I took sentences from <code>__import__</code> docstring and it's always here.</span>
<span class="comment-copy">Documentation for <code>__import__</code> states: "Programmatic importing of modules should use import_module() instead of this function." Per <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">docs.python.org/3/library/importlib.html</a></span>
<span class="comment-copy">Actually, I've just realized that this only works after I've already imported using the normal method</span>
<span class="comment-copy">Hmm, you should be able to import foo (if you know it's value already and don't need to import it dynamically as a string value) with the normal import statement.  Once the module is imported you can import anything within its directory as a string using getattr. <code>import foo</code> <code>bar = getattr(foo, 'bar')</code> <code>object=bar.object</code></span>
<span class="comment-copy">But bar isn't an attribute, it's a script within the folder foo.</span>
<span class="comment-copy">Ok I see. <code>import sys</code>.  <code>bar = sys.modules['foo.bar']</code> <code>object=bar.object</code> or if 'object also needs to imported from string, <code>object=getattr(bar, 'object')</code></span>
<span class="comment-copy">This is the problem, until I import foo.bar, all I see is foo.init</span>
