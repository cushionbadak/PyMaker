<div class="post-text" itemprop="text">
<h2>Background</h2>
<p>I have a <code>list</code>. 
This <code>list</code> has many objects. Each object has an <code>id</code>. Now the objects are of different types.</p>
<pre><code>objects = [Aobject, Bobject, Cobject]
</code></pre>
<p>where </p>
<pre><code>&gt;&gt;&gt; Aobject != Bobject
True
&gt;&gt;&gt; Aobject.id ==  Bobject.id
True
</code></pre>
<h2>Problem</h2>
<p>I want a <code>list</code> of unique objects based on the <code>object.id</code>. </p>
<p>Something like this:</p>
<pre><code>set(objects, key=operator.attrgetter('id'))
</code></pre>
<p>(This does not work. But I want something like this)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>seen = set() 

# never use list as a variable name
[seen.add(obj.id) or obj for obj in mylist if obj.id not in seen]
</code></pre>
<p>This works because <code>set.add</code> returns <code>None</code>, so the expression in the list comprehension always yields <code>obj</code>, but only if <code>obj.id</code> has not already been added to <code>seen</code>. </p>
<p>(The expression could only evaluate to <code>None</code> if <code>obj is None</code>; in that case, <code>obj.id</code> would raise an exception. In case <code>mylist</code> contains <code>None</code> values, change the test to <code>if obj and (obj.id not in seen)</code>)</p>
<p>Note that this will give you the first object in the list which has a given id. @Abhijit's answer will give you the last such object.</p>
<p>Update:</p>
<p>Alternatively, an ordereddict could be a good choice:</p>
<pre><code>import collections
seen = collections.OrderedDict()

for obj in mylist:
    # eliminate this check if you want the last item
    if obj.id not in seen:
       seen[obj.id] = obj

list(seen.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about using <code>dict</code> (since its keys are unique)?</p>
<p>Assuming we have</p>
<pre><code>class Object:
    def __init__(self, id):
        self.id = id


Aobject = Object(1)
Bobject = Object(1)
Cobject = Object(2)
objects = [Aobject, Bobject, Cobject]
</code></pre>
<p>then <code>list</code> with <code>Object</code>s unique by <code>id</code> field can be generated using <code>dict</code> comprehension in <strong>Python 3</strong></p>
<pre><code>unique_objects = list({object_.id: object_ for object_ in objects}.values())
</code></pre>
<p>in <strong>Python 2.7</strong></p>
<pre><code>unique_objects = {object_.id: object_ for object_ in objects}.values()
</code></pre>
<p>and in <strong>Python &lt;2.7</strong></p>
<pre><code>unique_objects = dict([(object_.id, object_) for object_ in objects]).values()
</code></pre>
<p>Finally we can write function (<strong>Python 3</strong> version)</p>
<pre><code>def unique(elements, key):
    return list({key(element): element for element in elements}.values())
</code></pre>
<p>where <code>elements</code> may be any <code>iterable</code> and <code>key</code> is some <code>callable</code> which returns <code>hashable</code> objects from <code>elements</code> (<code>key</code> quals to <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>operator.attrgetter('id')</code></a> in our particular case).</p>
<p><a href="https://stackoverflow.com/a/10024750/5997596">Marcin's answer</a> works fine but don't look Pythonic to me since list comprehension mutates <code>seen</code> object from outer scope, also there is some magic behind using <code>set.add</code> method and comparison its result (which is <code>None</code>) with <code>obj</code>.</p>
<p>And final but not less important part:</p>
<h1>Benchmark</h1>
<pre><code>setup = '''
import random


class Object:
    def __init__(self, id):
        self.id = id


objects = [Object(random.randint(-100, 100))
           for i in range(1000)]
'''
solution = '''
seen = set()
result = [seen.add(object_.id) or object_
          for object_ in objects
          if object_.id not in seen]
'''
print('list comprehension + set: ',
      min(timeit.Timer(solution, setup).repeat(7, 1000)))
solution = '''
result = list({object_.id: object_
               for object_ in objects}.values())
'''
print('dict comprehension: ',
      min(timeit.Timer(solution, setup).repeat(7, 1000)))
</code></pre>
<p>on my machine gives</p>
<pre><code>list comprehension + set:  0.20700953400228173
dict comprehension:  0.1477799109998159
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given your list of object <code>somelist</code> be something like</p>
<pre><code>[(Object [A] [1]), (Object [B] [1]), (Object [C] [2]), (Object [D] [2]), (Object [E] [3])]
</code></pre>
<p>You can do something like this</p>
<pre><code>&gt;&gt;&gt; {e.id:e for e in somelist}.values()
[(Object [B] [1]), (Object [D] [2]), (Object [E] [3])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can change the class of the objects, you can add the appropriate methods which are used in set comparison:</p>
<pre><code># Assumption: this is the 'original' object
class OriginalExampleObject(object):
    def __init__(self, name, nid):
        self.name = name
        self.id = nid
    def __repr__(self):
        return "(OriginalExampleObject [%s] [%s])" % (self.name, self.id)

class SetExampleObj(OriginalExampleObject):
    def __init__(self, name, nid):
        super(SetExampleObj, self).__init__(name, nid)
    def __eq__(self, other):
        return self.id == other.id
    def __hash__(self):
        return self.id.__hash__()


AObject = SetExampleObj("A", 1)
BObject = SetExampleObj("B", 1)
CObject = SetExampleObj("C", 2)

s = set()
s.add(AObject)
s.add(CObject)
print(s)

s.add(BObject)
print(s)
</code></pre>
<p>Output:</p>
<pre><code>set([(OriginalExampleObject [A] [1]), (OriginalExampleObject [C] [2])])
set([(OriginalExampleObject [A] [1]), (OriginalExampleObject [C] [2])])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <code>unique_everseen</code> recipe available in the <code>itertools</code> <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">docs</a>. This is also available in 3rd party libraries, e.g. <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.unique" rel="nofollow noreferrer"><code>toolz.unique</code></a>. Note this method will keep the <em>first</em> instance of an object for a given attribute.</p>
<pre><code>from toolz import unique
from operator import attrgetter

res = list(unique(objects, key=attrgetter('id')))
</code></pre>
<p>If a lazy iterator is sufficient, you can omit <code>list</code> conversion.</p>
</div>
<div class="post-text" itemprop="text">
<p>A fairly simple way to do this would be</p>
<pre><code>for obj in mylist:
    if obj.id not in s:
        s.add(obj.id)
</code></pre>
<p>And this should add any id not seen. Time taken is linear on the size of the source list.</p>
</div>
<span class="comment-copy">You shouldn't overwrite the builtin <code>list</code>; name your variable <code>lst</code> or <code>list_</code> or something more meaningful instead.</span>
<span class="comment-copy">I like this idea although i'm not sure if the use of <code>or</code> is considered good practise in this case.</span>
<span class="comment-copy">@jamylak In what way is this not good practice?</span>
<span class="comment-copy">Not sure, if you think it is good practice then i will take your word for it :D</span>
<span class="comment-copy">Your criticism is well taken. Consider however, that your solution could be simplified by using an ordereddict</span>
<span class="comment-copy">This is cool. Note that it will give the last object with a given ID.</span>
<span class="comment-copy">@Marcin: I agree but I believe OP never mentioned about which element he wants</span>
<span class="comment-copy">Quite. It's not a criticism, just a note about its behaviour.</span>
<span class="comment-copy">You don't need to do <code>self.id.__hash__()</code>. You can just do <code>return id(self)</code> as it returns an integer which is already a hashable object.</span>
<span class="comment-copy">@AndreasFlorath It's a terrible choice, because it is almost exactly the same as <code>object</code>, which is a builtin. If you don't care about readers of your code, go ahead.</span>
<span class="comment-copy">@AndreasFlorath The need for a new-style class is that this code may be copied by the inexperienced. Don't spread bad techniques.</span>
<span class="comment-copy">@JoelCornett: No - it is not possible to use <code>return id(self)</code> here.</span>
<span class="comment-copy">@AndreasFlorath: How so? I just did it. Do you mean that <code>self.id != id(self)</code>?</span>
<span class="comment-copy">How does he get a set of the objects in <code>mylist</code>?</span>
