<div class="post-text" itemprop="text">
<p>Say I have a string that's of the same form a tuple should be, for example, <code>"(1,2,3,4,5)"</code>. What's the easiest way to convert that into an actual tuple? An example of what I want to do is:</p>
<pre><code>tup_string = "(1,2,3,4,5)"
tup = make_tuple(tup_string)
</code></pre>
<p>Just running <code>tuple()</code> on the string make the whole thing one big tuple, whereas what I'd like to do is comprehend the string as a tuple. I know I can use a regex for this, but I was hoping there's a less costly way. Ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>It <a href="http://docs.python.org/dev/library/ast.html#ast.literal_eval" rel="noreferrer">already exists</a>!</p>
<pre><code>&gt;&gt;&gt; from ast import literal_eval as make_tuple
&gt;&gt;&gt; make_tuple("(1,2,3,4,5)")
(1, 2, 3, 4, 5)
</code></pre>
<p>Be aware of the corner-case, though:</p>
<pre><code>&gt;&gt;&gt; make_tuple("(1)")
1
&gt;&gt;&gt; make_tuple("(1,)")
(1,)
</code></pre>
<p>If your input format works different than Python here, you need to handle that case separately or use another method like <code>tuple(int(x) for x in tup_string[1:-1].split(','))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can parse your string without <code>SyntaxError</code></p>
<pre><code>def parse_tuple(string):
    try:
        s = eval(string)
        if type(s) == tuple:
            return s
        return
    except:
        return
</code></pre>
<p>This function return the <code>Tuple</code> if parse is success. Otherwise return <code>None</code>.</p>
<pre><code>print parse_tuple("('A', 'B', 'C')")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>I would recommend using <code>literal_eval</code>.</strong></p>
<p><strong>If you are not comfortable with <code>literal_eval</code> or want to have more control on what gets converted</strong> you can also disassemble the string, convert the values and recreate the tuple. </p>
<p>Sounds more complicated than it is, really, it's a one-liner:</p>
<pre><code>eg = '(102,117,108)'
eg_tuple = map(int, eg.replace('(','').replace(')','').split(',')))
</code></pre>
<p>This would throw a <code>ValueError</code> if any element (string) in the tuple is not convertible to <code>int</code>, like, for example the <code>'1.2'</code> in the string: <code>'(1.2, 3, 4)'</code>.</p>
<hr/>
<p>The same can be achieved with <a href="https://docs.python.org/3/library/re.html#module-re" rel="nofollow noreferrer">regex</a>:</p>
<pre><code>import re
eg = '(102,117,108)'
et_tuple = tuple(map(int, re.findall(r'[0-9]+', eg)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We can also parse it by ourself.
Let's say we have tuple returned by Python like below:</p>
<pre><code>((2, 'C/C++', 0, 'clang_cpp'), (3, 'Python相关', 0, 'python'))
</code></pre>
<p>Here're how we do it</p>
<p>First, we keep reading the characters in the tuple string but stores the last left semicolon's position and how many semicolons we have meet (we can call it left semicolon level, as so for right semicolons), whenever we meet a right semicolon, we do things below:</p>
<ol>
<li>Take a substring from last semicolon to current right semicolon.(In
this substring, there is no more semicolons, we just split it into
array by ",". Let's say the new array is <code>M</code>)</li>
<li>Then we append <code>M</code> to our result array, which array will stores all<code>M</code>.</li>
<li>Thirdly, delete the substring we taken from the original string.
    Finally, do the same things like step 1 till the right and left
    semicolon's level comes to 0.</li>
</ol>
<p>JavaScript code is like below:</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function parseTuple(t){
    var lc = "(";
    var rc = ")";
    var lc_level = 0;
    var rc_level = 0;
    var last_lc = 0;
    var last_rc = 0;
    var result = [];
    for(i=0;i&lt;t.length;i++){
        if(t[i] == lc){
            lc_level++;
            last_lc = i;
        }else if(t[i] == rc){
            rc_level++;
            last_rc = i;
        }
        if(rc_level == 1){
            var substr = t.slice(last_lc+1,last_rc);
            var data = substr.split(",");
            result.push(data);
            lc_level--;
            rc_level--;
            i = 0;
            t = t.slice(0,last_lc) + t.substring(last_rc+1);
        }
        if(lc_level == rc_level &amp;&amp; lc_level==0){
            break;
        }
    }
    return result;
}</code></pre>
</div>
</div>
</p>
</div>
<span class="comment-copy">Where does the string come from?</span>
<span class="comment-copy">It's surprising how many questions on SO can be answered with ast.literal_eval, itertools.product, and only a handful of library functions..</span>
<span class="comment-copy">@DSM: I'm always glad if it's at least something interesting like <code>groupby</code> or <code>bisect</code> :)</span>
<span class="comment-copy">nice one! didn't know about that one XD</span>
<span class="comment-copy">in my case I could handle the corner-case for strings with: <code>not isinstance(make_tuple("('any-string')"), basestring)</code> and pad make_tuple's output with the extra comma when required.</span>
<span class="comment-copy">Since you know the parenthesis will be at both ends of the string, using strip() instead of replace(). Then it becomes <code>eg_tuple = eg.strip('()').split(',')</code></span>
