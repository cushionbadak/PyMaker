<div class="post-text" itemprop="text">
<p>I have a decorator and I want to assert that certain methods in my code are decorated with it.</p>
<pre><code>import functools

def decorator(func):
    def _check_something(*args, **kwargs):
        # some logic in here
        return func(*args, **kwargs)
    return functools.wraps(func)(_check_something)

class MyClass(object):

    @decorator
    def my_method(foo, bar):
        pass
</code></pre>
<p>How do I assert with unittest (unitttest2) that <code>my_method</code> has <code>@decorator</code> and no-one removed it, and it was not forgotten?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do that by relying on your decorator to mark the wrapper function with an attribute, that you then assert.</p>
<p>A good practice is to have the decorator set a <a href="https://docs.python.org/3/library/functools.html#functools.update_wrapper" rel="nofollow noreferrer">__wrapped__</a> attribute pointing to the original function on the returned wrapper.</p>
<p>thus:</p>
<pre><code>def decorator(func):
    @functools.wraps(func)
    def _check_something(*args, **kwargs):
        # some logic in here
        return func(*args, **kwargs)
    _check_something.__wrapped__ = func   # &lt;== add this
    return _check_something
</code></pre>
<p>and then, on your test code:</p>
<pre><code>assert getattr(MyClass.my_method, "__wrapped__").__name__ == 'my_method'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If for some reason you can't modify the decorator, you could also try checking for some characteristic of a closed variable.</p>
<p>In your example, you know that the original <code>my_method</code> is the only variable closed by the decorator, so you could:</p>
<pre><code>assert (my_method.__closure__ and 
           my_method.__closure__[0].cell_contents.__name__ == my_method.__name__)
</code></pre>
</div>
<span class="comment-copy">Do some checks that test if the function (it's not called a "method" in Python, btw) has the correct behaviour, raising the correct exceptions etc.  If it does, everything is fine.</span>
<span class="comment-copy">updated the example to have a real method instead of just a dangling module function.</span>
<span class="comment-copy">With unit tests, you only test if the function does the right thing. The whole point of this is that people can refactor the actual implementation as they want, as long as they don't break the functionality. What you're trying to do has nothing to do with unit testing.</span>
<span class="comment-copy">@NiklasB.: <a href="http://en.wikipedia.org/wiki/White-box_testing" rel="nofollow noreferrer">Not necessarily</a>, but in this case I wouldn't go that route.</span>
<span class="comment-copy">Thanks @Sven. You're right of course.</span>
<span class="comment-copy">The attribute holding the wrapped function should be called <a href="http://docs.python.org/py3k/library/functools.html#functools.update_wrapper" rel="nofollow noreferrer"><code>__wrapped__</code></a>.</span>
<span class="comment-copy">Evggeny: did you test the edits you made to my answer? retriveng hte method weithout the class <code>__dict__</code>, in Python 2.x, gives you a bound method - no the function object -  I don't think the bound method copies the <code>__wrapped__</code> attribute of the underlying function. Oh - I tested it now, indeed, the method object proxies the accesses tothe function object attributes - I did not know that.</span>
<span class="comment-copy"><a href="http://pastie.org/3728502" rel="nofollow noreferrer">pastie.org/3728502</a></span>
<span class="comment-copy">This would check for the presence of <i>some</i> decorator, but not necessarily the specific <code>decorator</code> function.  Is there a way of testing the presence of a <i>specific</i> decorator?</span>
