<div class="post-text" itemprop="text">
<p>How do I get the absolute paths of all the files in a directory that could have many sub-folders in Python?</p>
<p>I know <code>os.walk()</code> recursively gives me a list of directories and files, but that doesn't seem to get me what I want. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/os.path.html#os.path.abspath" rel="noreferrer"><code>os.path.abspath</code></a> makes sure a path is absolute. Use the following helper function:</p>
<pre><code>import os

def absoluteFilePaths(directory):
   for dirpath,_,filenames in os.walk(directory):
       for f in filenames:
           yield os.path.abspath(os.path.join(dirpath, f))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the argument given to <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>os.walk</code></a> is absolute, then the root dir names yielded during iteration will also be absolute. So, you only need to join them with the filenames:</p>
<pre><code>import os

for root, dirs, files in os.walk(os.path.abspath("../path/to/dir/")):
    for file in files:
        print(os.path.join(root, file))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>import os

for root, dirs, files in os.walk('.'):
    for file in files:
        p=os.path.join(root,file)
        print p
        print os.path.abspath(p)
        print
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have Python 3.4 or newer you can use <a href="https://docs.python.org/3/library/pathlib.html" rel="noreferrer"><code>pathlib</code></a> (or a third-party backport if you have an older Python version):</p>
<pre><code>import pathlib
for filepath in pathlib.Path(directory).glob('**/*'):
    print(filepath.absolute())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>os.path.abspath()</code> to turn relative paths into absolute paths:</p>
<pre><code>file_paths = []

for folder, subs, files in os.walk(rootdir):
  for filename in files:
    file_paths.append(os.path.abspath(os.path.join(folder, filename)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wanted to keep the subdirectory details and not the files and wanted only subdirs with one xml file in them. I can do it this way:</p>
<pre><code>for rootDirectory, subDirectories, files in os.walk(eventDirectory):
  for subDirectory in subDirectories:
    absSubDir = os.path.join(rootDirectory, subDirectory)
    if len(glob.glob(os.path.join(absSubDir, "*.xml"))) == 1:
      print "Parsing information in " + absSubDir
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>from glob import glob


def absolute_file_paths(directory):
    return glob(join(directory, "**"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for root, directories, filenames in os.walk(directory):
 for directory in directories:
         print os.path.join(root, directory)
 for filename in filenames:
     if filename.endswith(".JPG"):
        print filename
        print os.path.join(root,filename)
</code></pre>
</div>
<span class="comment-copy">Could you give an example of what input and output you expect</span>
<span class="comment-copy">I think it is nicer to do the abspath just once, on the <code>os.walk</code> line, than to do it N times inside the loop</span>
<span class="comment-copy">That works, but only by "accident". Reading <code>os.path.join</code>'s contract, I cannot find any place that guarantees that the result is absolute if one of the arguments is, although that's a sensible assumption.</span>
<span class="comment-copy">There is an excess parenthesis mark at the end. Should be yield os.path.abspath(os.path.join(dirpath, f))</span>
<span class="comment-copy">@jumbopap Thanks for the note, fixed.</span>
<span class="comment-copy">@phihag  That's reliable. It is not "accident", and the language is not so formal as to have any notion of "contracts" in the docs. It's documented that <i>if a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.</i> Python cannot invisibly transform into a relative path here, and it would be impossible to modify the behavior without a huge backwards breaking change. If still not convinced, you can even just read the source of <code>os.path.join</code>, which is short and simple.</span>
<span class="comment-copy">Okay, I see what you mean, just I didn't want the files, but wanted specific subdirs. I've posted the solution below.</span>
<span class="comment-copy">Anyway to do this without capturing hidden files?</span>
<span class="comment-copy">@MarcelMarino <code>if not file.startswith('.')</code></span>
<span class="comment-copy">This is very nice that it uses python 3, but it also shows directories.</span>
<span class="comment-copy">doesn't this join the <code>cwd</code> to <code>filename</code>, when you want to join the <code>folder</code>?!</span>
<span class="comment-copy">While this code might answer the question you still might consider adding a few explanatory sentences as this increases the value of your answer for other users.</span>
<span class="comment-copy">While this might answer the authors question, it lacks some explaining words and links to documentation. Raw code snippets are not very helpful without some phrases around it. You may also find <a href="https://stackoverflow.com/help/how-to-answer">how to write a good answer</a> very helpful. Please edit your answer.</span>
