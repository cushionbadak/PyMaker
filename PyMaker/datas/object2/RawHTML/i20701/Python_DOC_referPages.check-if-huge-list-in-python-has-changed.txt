<div class="post-text" itemprop="text">
<p>In short: what's the fasted way to check if a huge list in python has changed? <code>hashlib</code> needs a buffer, and building a string representation of that list is unfeasible.</p>
<p>In long: I've got a HUGE list of dictionaries representing data. I run a number of analyses on this data, but there are a few meta-data aspects that are required by all of the analyses, ie. the the set of subjects (each dict in the list has a subject key, and at times I just need a list of all subject who have data present in the data set.). So I'd like to implement the following:</p>
<pre><code>class Data:
    def __init__(self, ...):
        self.data = [{...}, {...}, ...] # long ass list of dicts
        self.subjects = set()
        self.hash = 0

    def get_subjects(self):
        # recalculate set of subjects only if necessary
        if self.has_changed():
            set(datum['subject'] for datum in self.data)

        return self.subjects

    def has_changed(self):
        # calculate hash of self.data
        hash = self.data.get_hash() # HOW TO DO THIS?
        changed = self.hash == hash
        self.hash = hash # reset last remembered hash
        return changed
</code></pre>
<p>The question is how to implement the <code>has_changed</code> method, or more specifically, <code>get_hash</code> (each object already has a <code>__hash__</code> method, but by default it just returns the object's <code>id</code>, which doesn't change when we e.g. append an element to a list).</p>
</div>
<div class="post-text" itemprop="text">
<p>A more sophisticated approach there would be to work with proxy data elements instead of native lists and dictionaries, which could flag any change to their attributes. To make it more flexible, you could even code a callback to be used in case of any changes.</p>
<p>So, assuming you only have to deal with lists and dictionaries on your data structure - we can work with classes inheriting from dict and list with a callback when any data changing method on the object is accessed The full list of methods is in <a href="http://docs.python.org/reference/datamodel.html" rel="nofollow noreferrer">http://docs.python.org/reference/datamodel.html</a></p>
<pre><code># -*- coding: utf-8 -*-
# String for doctests and  example:
"""
            &gt;&gt;&gt; a = NotifierList()
            &gt;&gt;&gt; flag.has_changed
            False
            &gt;&gt;&gt; a.append(NotifierDict())
            &gt;&gt;&gt; flag.has_changed
            True
            &gt;&gt;&gt; flag.clear()
            &gt;&gt;&gt; flag.has_changed
            False
            &gt;&gt;&gt; a[0]["status"]="new"
            &gt;&gt;&gt; flag.has_changed
            True
            &gt;&gt;&gt; 

"""


changer_methods = set("__setitem__ __setslice__ __delitem__ update append extend add insert pop popitem remove setdefault __iadd__".split())


def callback_getter(obj):
    def callback(name):
        obj.has_changed = True
    return callback

def proxy_decorator(func, callback):
    def wrapper(*args, **kw):
        callback(func.__name__)
        return func(*args, **kw)
    wrapper.__name__ = func.__name__
    return wrapper

def proxy_class_factory(cls, obj):
    new_dct = cls.__dict__.copy()
    for key, value in new_dct.items():
        if key in changer_methods:
            new_dct[key] = proxy_decorator(value, callback_getter(obj))
    return type("proxy_"+ cls.__name__, (cls,), new_dct)


class Flag(object):
    def __init__(self):
        self.clear()
    def clear(self):
        self.has_changed = False

flag = Flag()

NotifierList = proxy_class_factory(list, flag)
NotifierDict = proxy_class_factory(dict, flag)
</code></pre>
<h1>2017 update</h1>
<p>One does live and learn: native lists can be changed by native methods by calls that bypass the magic methods. The fool proof system is the same approach, but inheriting from <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc.MutableSequence</code></a> instead, nd keeping a native list as an internal attribute of your proxy object.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily get the string representation of any object using the pickle library, and then pass it to hashlib, as you said:</p>
<pre><code>import pickle
import hashlib

data = []
for i in xrange(100000):
    data.append({i:i})

print hashlib.md5(pickle.dumps(data))

data[0] = {0:1}
print hashlib.md5(pickle.dumps(data))
</code></pre>
<p>So, that's <em>a</em> way, I don't know if it's the <em>fastest</em> way. It will work for arbitrary objects. But, as agf said, in your case it would certainly be more efficient if you could use a variable <code>has_changed</code> that you modify each time you actually modify data.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>hashlib needs a buffer, and building a string representation of that
  list is unfeasible.</p>
</blockquote>
<p>You can <a href="http://docs.python.org/library/hashlib.html#hashlib.hash.update" rel="nofollow">update</a> hash in many steps:</p>
<pre><code>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; m = hashlib.md5()
&gt;&gt;&gt; m.update("Nobody inspects")
&gt;&gt;&gt; m.update(" the spammish repetition")
</code></pre>
<p>So, you don't need to convert all the list to a string representation. You just iterate over it, converting to string only one item and calling <code>update</code>.</p>
</div>
<span class="comment-copy">How does your <code>change_data</code> method look like? Also <code>self.subjects</code> can be built as <code>self.subjects = set(datum['subject'] for datum in self.data)</code>.</span>
<span class="comment-copy">I think you might need to give some more details. Do you have both old and new versions? Can you use frozendicts? Does order matter? Is your code creating the changes?</span>
<span class="comment-copy">Can you just have a <code>has_changed</code> instance variable you set whenever you change <code>data</code>? Otherwise, you probably need a proxy object to delegate everything but <code>has_changed</code> to the real <code>data</code>.</span>
<span class="comment-copy">Aside from the question: make your Data class inherit from "object"  or you will get subtle errors  and hard to identify when needing more support from Python OO mechanisms (which is exactly your case)</span>
<span class="comment-copy">More specifically - idetifying if a <i>list</i> has changed is relatively easy - it changes if the id of any object it contains do change.  You seem to need to be notified of any changes in all of the mutable nested elements on your list, is that right?</span>
<span class="comment-copy">I heartily second this approach. If detecting changes after the fact is too expensive (which your description indicates that is definitely the case), just track changes as they happen. The reason to use a hash fingerprint as Nkosinathi originally tried is if you need to keep multiple versions cached and need a way of uniquely identifying them. If all you're doing is detecting changes, this approach is much more suitable.</span>
<span class="comment-copy">That works indeed, but is pretty slow. The problem is that I don't always know whether an operation will alter the list (plus many of the analyses I use have been written by other people, and changing all of them isn't feasible). The function doesn't even have to be fully accurate, a quick <code>has_probably_changed</code> will do.</span>
