<div class="post-text" itemprop="text">
<p>Consider the following python code:</p>
<pre><code>def function():
    "Docstring"

    name = ???
    doc = ???

    return name, doc

&gt;&gt;&gt; function()
"function", "Docstring"
</code></pre>
<p>What do I need to replace the question marks with so that I get the name and the docstring of the function from inside the same function?</p>
<p>EDIT:
Most of the answers so far explicitly hardcode the name of the function inside its definition. Is it possible do something like below where a new function get_name_doc would access the function from the outer frame from which it is called, and return its name and doc?</p>
<pre><code>def get_name_doc():
    ???

def function():
    "Docstring"

    name, doc = get_name_doc()

    return name, doc

&gt;&gt;&gt; function()
"function", "Docstring"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is not possible to do cleanly in a consistent way because names can be changed and reassigned.</p>
<p>However, you can use this so long as the function isn't renamed or decorated.</p>
<pre><code>&gt;&gt;&gt; def test():
...     """test"""
...     doc = test.__doc__
...     name = test.__name__
...     return doc, name
... 
&gt;&gt;&gt; test()
('test', 'test')
&gt;&gt;&gt; 
</code></pre>
<p>It's not at all reliable. Here's an example of it going wrong.</p>
<pre><code>&gt;&gt;&gt; def dec(f):
...     def wrap():
...         """wrap"""
...         return f()
...     return wrap
... 
&gt;&gt;&gt; @dec
... def test():
...     """test"""
...     return test.__name__, test.__doc__
... 
&gt;&gt;&gt; test()
('wrap', 'wrap')
&gt;&gt;&gt; 
</code></pre>
<p>This is because the name <code>test</code> isn't defined at the time that the function is actually created and is a global reference in the function. It hence gets looked up in the global scope on every execution. So changes to the name in the global scope (such as decorators) will break your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code below solves the problem for the name of the function. However, it fails to detect the correct docstring for the example given by aaronasterling. I wonder if there is a way to get back to the abstract syntax tree associated with a bytecode object. Then it would be quite easy to read the docstring. </p>
<pre><code>import inspect

def get_name_doc():
    outerframe = inspect.currentframe().f_back
    name = outerframe.f_code.co_name
    doc = outerframe.f_back.f_globals[name].__doc__    
    return name, doc

if __name__ == "__main__":

    def function():
        "Docstring"

        name, doc = get_name_doc()

        return name, doc

    def dec(f):
        def wrap():
           """wrap"""
           return f()
        return wrap

    @dec
    def test():
        """test"""
        return get_name_doc()

    assert function() == ('function', "Docstring")
    #The assertion below fails:. It gives: ('test', 'wrap')
    #assert test() == ('test', 'test')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will find the name and the doc of a function calling get_doc.
In my sense, get_doc should have the function as argument (that would have made it really easier, but way less fun to achieve ;))</p>
<pre><code>import inspect

def get_doc():
    """ other doc
    """
    frame = inspect.currentframe()

    caller_frame = inspect.getouterframes(frame)[1][0]
    caller_name = inspect.getframeinfo(caller_frame).function
    caller_func = eval(caller_name)

    return caller_name, caller_func.__doc__


def func():
    """ doc string """
    print get_doc()
    pass


def foo():
    """ doc string v2 """
    func()

def bar():
    """ new caller """
    print get_doc()

func()
foo()
bar()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; def f():
...     """doc"""
...     name = inspect.getframeinfo(inspect.currentframe()).function
...     doc = eval(name + '.__doc__')
...     return name, doc
... 
&gt;&gt;&gt; f()
('f', 'doc')
&gt;&gt;&gt; class C:
...     def f(self):
...         """doc"""
...         name = inspect.getframeinfo(inspect.currentframe()).function
...         doc = eval(name + '.__doc__')
...         return name, doc
... 
&gt;&gt;&gt; C().f()
('f', 'doc')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For my personal projects, I developed function name and <strong>doc</strong> recovery techniques for functions and class methods.  These are implemented in an importable module (SelfDoc.py) which has its own self test in its <strong>main</strong>.  It is included below.  This code executes as is in Python 2.7.8 on linux and MacOS.  It is in active use.</p>
<pre><code>#!/usr/bin/env python

from inspect import (getframeinfo, currentframe, getouterframes)

class classSelfDoc(object):

    @property
    def frameName(self):
        frame = getframeinfo(currentframe().f_back)
        return str(frame.function)

    @property
    def frameDoc(self):
        frame = getframeinfo(currentframe().f_back)
        doc = eval('self.'+str(frame.function)+'.__doc__')
        return doc if doc else 'undocumented'

def frameName():
    return str(getframeinfo(currentframe().f_back).function)

def frameDoc():
    doc = eval(getframeinfo(currentframe().f_back).function).__doc__
    return doc if doc else 'undocumented'

if __name__ == "__main__":

    class aClass(classSelfDoc):
        "class documentation"

        def __init__(self):
            "ctor documentation"
            print self.frameName, self.frameDoc

        def __call__(self):
            "ftor documentation"
            print self.frameName, self.frameDoc

        def undocumented(self):
            print self.frameName, self.frameDoc

    def aDocumentedFunction():
        "function documentation"
        print frameName(), frameDoc()

    def anUndocumentedFunction():
        print frameName(), frameDoc()

    anInstance = aClass()
    anInstance()
    anInstance.undocumented()

    aDocumentedFunction()
    anUndocumentedFunction()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to use the name of the function to get it:</p>
<pre><code>def function():
    "Docstring"

    name = function.__name__
    doc = function.__doc__

    return name, doc
</code></pre>
<p>There is also a module called inspect:
<a href="http://docs.python.org/library/inspect.html" rel="nofollow">http://docs.python.org/library/inspect.html</a>.
This is useful to get further information about the function (or any python object).</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>import functools

def giveme(func):
    @functools.wraps(func)
    def decor(*args, **kwargs):
        return func(decor, *args, **kwargs)
    return decor

@giveme
def myfunc(me):
    "docstr"
    return (me.__name__, me.__doc__)

# prints ('myfunc', 'docstr')
print myfunc()
</code></pre>
<p>Shortly, the <code>giveme</code> decorator adds the (decorated) function object as the first argument. This way the function can access its own name and docstring when it is called.</p>
<p>Due to decoration, the original <code>myfunc</code> function is replaced by <code>decor</code>. To make the first argument be exactly the same as <code>myfunc</code>, what is passed into the function is <code>decor</code> and not <code>func</code>.</p>
<p>The <code>functools.wraps</code> decorator is used to give <code>decor</code> the properties (name, docstring, etc.) of the original <code>myfunc</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; def function():
        "Docstring"

        name = function.__name__
        doc = function.__doc__

        return name, doc

&gt;&gt;&gt; function()
('function', 'Docstring')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def function():
    "Docstring"

    name = function.__name__
    doc = function.__doc__

    return name, doc    
</code></pre>
<p>This should do it, use the function's name, in your case, <code>function</code>.</p>
<p>Here is a very nice tutorial that talks about it: <a href="http://epydoc.sourceforge.net/docstrings.html" rel="nofollow noreferrer">http://epydoc.sourceforge.net/docstrings.html</a></p>
<p>And of course: <a href="http://docs.python.org/tutorial/controlflow.html#documentation-strings" rel="nofollow noreferrer">http://docs.python.org/tutorial/controlflow.html#documentation-strings</a></p>
<p><strong>Edit:</strong> Refer to your edited version of the question, I think you might have to mess with <code>inspect.stack()</code> <a href="https://stackoverflow.com/questions/900392/getting-the-caller-function-name-inside-another-function-in-python">from this SO question</a>. Ayman Hourieh's answer gives a small example.</p>
</div>
<div class="post-text" itemprop="text">
<p>for a hard-coded version that works decently with 'well behaved' decorators.
It must be declared after function. if function gets rebound later the changes updated here.</p>
<pre><code>def get_name_doc():
    # global function # this is optional but makes your intent a bit more clear.
    return function.__name__, function.__doc__
</code></pre>
<p>This is a rather nasty hack, in that it abuses the way default args work. It will used whatever function is bound to at the time this function is 'initialized', and remember it even if the function gets rebound. Calling it with args is going to lead to interesting results. </p>
<pre><code>def get_name_doc(fn=function):
    return fn.__name__, fn.__doc__
</code></pre>
<p>and a dynamic one that still hard coded but does update on function getting called with an argument of True. Basically this version will only update when told to do so.</p>
<pre><code>def get_name_doc(update=False):
    global fn
    if update:
        fn = function
    return fn.__name__, fn.__doc__
</code></pre>
<p>Now of course there are decorator examples to this too.</p>
<pre><code>@decorator  # applying the decorator decorator to make it well behaved
def print_name_doc(fn, *args, **kwargs):
    def inner(*args, **kwargs):
         print(fn.__doc__, fn.__name__)  # im assuming you just want to print in this case
         return fn(*args, **kwargs)
return inner
</code></pre>
<p>you should read on the decorator decorator (atleast).
Look at NamedTuple source (from the collections module) as it involves noting being hard-coded. Sadly the named tuple code is rather weird. It is a string format used with eval rather then traditional code, but it works really neatly. This seems to be the most promising variant.
You might be able to do this with metaclasess too, which leads to neat code, but rather nasty stuff hidden behind the scenes, which you need to code. This id advise against</p>
<p>Im suspecting that there probably is an easier way than going into inspection/reflection/templates/metaclasess by simply adding the following line at the end of the module.</p>
<pre><code>help(&lt;module&gt;)
</code></pre>
<p>where  is the name of the module you are working on (a string). Or even the variable  __name__. This could be done in the __init__.py file too if working with multiple modules
or on individual classes too <em>i think</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As noted many times, using the function name inside the function is actually a dynamic lookup in the globals() of the current module. Using any kind of eval() is only a variation from it as its name resolution will work again with the globals() dictionary. Most of the examples will fail with a member function - you need to lookup the class name first from globals() and you can then access the member function from it. So actually</p>
<pre><code>def function():
    """ foo """
     doc = function.__doc__

class Class:
    def function():
        """ bar """
        doc = Class.function.__doc__
</code></pre>
<p>is equivalent to</p>
<pre><code>def function():
    """ foo """
     doc = globals()["function"].__doc__

class Class:
    def function():
        """ bar """
        doc = globals()["Class"].function.__doc__
</code></pre>
<p>In many cases this dynamic lookup will be enough. But actually you have to retype the function name inside the function. However if you write a helper function to find out the caller's doc string then you will face the fact that the helper function might live in a different module with a different globals() dictionary. So the only correct way would be to use the current frame info to find the function - but Python's frame object does not have a reference to the function object, it only carries a reference to the "f_code" code it uses. It needs to search through the referenced "f_globals" dictionary to find the mapping from f_code to the function object, for example like this:</p>
<pre><code>import inspect

def get_caller_doc():
    frame = inspect.currentframe().f_back.f_back
    for objref in frame.f_globals.values():
        if inspect.isfunction(objref):
            if objref.func_code == frame.f_code:
                return objref.__doc__
        elif inspect.isclass(objref):
            for name, member in inspect.getmembers(objref):
                if inspect.ismethod(member):
                    if member.im_func.func_code == frame.f_code:
                        return member.__doc__
</code></pre>
<p>It is named get_caller_doc() instead of get_my_doc() because in the vast majority of cases you do want to have the doc string to hand it down as an argument to some helper function. But the helper function can easily get the doc string from its caller - I am using this in my unittest scripts where a helper function can use the doc string of the test to post it into some log or to use it as actual test data. That's why the presented helper only looks for doc strings of test functions and test member functions.</p>
<pre><code>class MyTest:
    def test_101(self):
        """ some example test """
        self.createProject("A")
    def createProject(self, name):
        description = get_caller_doc()
        self.server.createProject(name, description)
</code></pre>
<p>It is left to the reader to expand the example for other use cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>Reference <a href="http://stefaanlippens.net/python_inspect" rel="nofollow">http://stefaanlippens.net/python_inspect</a></p>
<pre><code>import inspect
# functions
def whoami():
    return inspect.stack()[1][3]
def whocalledme():
    return inspect.stack()[2][3]
def foo():
    print "hello, I'm %s, daddy is %s" % (whoami(), whocalledme())
    bar()
def bar():
    print "hello, I'm %s, daddy is %s" % (whoami(), whocalledme())
johny = bar
# call them!
foo()
bar()
johny()
</code></pre>
<p><b>Output:</b></p>
<pre><code>hello, I'm foo, daddy is ?
hello, I'm bar, daddy is foo
hello, I'm bar, daddy is ?
hello, I'm bar, daddy is ?
</code></pre>
</div>
<span class="comment-copy">In that case, is there a way to get the <code>correct</code> doc string? Any work around solution to the problem?</span>
<span class="comment-copy">@George, see the bottom of my post for an idea. I've played around with stuff like that just hacking around but have never been able to get it working at a level that I regard as production ready.</span>
<span class="comment-copy">About the <code>inspect.stack()</code> on this link: <a href="http://stackoverflow.com/questions/900392/getting-the-caller-function-name-inside-another-function-in-python" title="getting the caller function name inside another function in python">stackoverflow.com/questions/900392/â€¦</a>, how does he know which index to access the stack? I assume that is not a guess right? I am interested if you can dynamically figure out which <code>stack[x][y]</code> to access?</span>
<span class="comment-copy">@George, The first frame is the frame of the one that calls it. It has index 0. The second frame is the frame that called the caller. That's index 1 which is what he goes for. Here, you'd use index 0. Then play around with the second index to see what you get or read the source.</span>
<span class="comment-copy">For what it's worth, if you use <code>@wraps</code> in your decorator (<a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer">docs.python.org/3/library/functools.html#functools.wraps</a>), you can preserve the docstring.</span>
<span class="comment-copy">need to test if the function calling is decorated, but should not be an issue as the decorator should be the next frame, and not the previous</span>
<span class="comment-copy">If you don't <code>del</code> frame, it creates a cycle.</span>
<span class="comment-copy">@also, it fails with decorators because you're just using <code>eval</code> to evaluate the name in the global scope. So this is the same answer as everyone else gave except you use <code>inspect</code> to get a name to <code>eval</code> in the global scope and assume that the function is even there and not, e.g, in a module.</span>
<span class="comment-copy">What if caller_name is not visible from inside the scope of get_doc?</span>
<span class="comment-copy">@aaronasterling true. And That is even more true as this kind of function would be in. It is frustrating the farm doesn't have the address of the function instead of its name.</span>
<span class="comment-copy">Is it possible to do it without using the name explicitly?</span>
<span class="comment-copy">Python is meant to be explicit.</span>
<span class="comment-copy">This answer is wrong and unreliable. Just try applying a decorator.</span>
<span class="comment-copy">You're passing the wrapped function the decorator as its first argument and not the function...</span>
<span class="comment-copy">Yes, I explained why.</span>
<span class="comment-copy">In your description, you claim to pass the function object.</span>
<span class="comment-copy">I changed the wording slightly.</span>
<span class="comment-copy">+1. Very clever!</span>
