<div class="post-text" itemprop="text">
<p>I know that we can use os.walk() to list all sub-directories or all files in a directory. However, I would like to list the full directory tree content:</p>
<ul>
<li>Subdirectory 1:
<ul>
<li>file11</li>
<li>file12</li>
<li>Sub-sub-directory 11:
<ul>
<li>file111</li>
<li>file112</li>
</ul></li>
</ul></li>
<li>Subdirectory 2:
<ul>
<li>file21</li>
<li>sub-sub-directory 21</li>
<li>sub-sub-directory 22<br/>
<ul>
<li>sub-sub-sub-directory 221
<ul>
<li>file 2211</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>How to best achieve this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a function to do that with formatting:</p>
<pre><code>import os

def list_files(startpath):
    for root, dirs, files in os.walk(startpath):
        level = root.replace(startpath, '').count(os.sep)
        indent = ' ' * 4 * (level)
        print('{}{}/'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            print('{}{}'.format(subindent, f))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution without your indentation:</p>
<pre><code>for path, dirs, files in os.walk(given_path):
  print path
  for f in files:
    print f
</code></pre>
<p>os.walk already does the top-down, depth-first walk you are looking for.</p>
<p>Ignoring the dirs list prevents the overlapping you mention.</p>
</div>
<div class="post-text" itemprop="text">
<p>I came here looking for the same thing and used dhobbs answer for me. As a way of thanking the community, I added some arguments to write to a file, as akshay asked, and made showing files optional so it is not so bit an output. Also made the indentation an optional argument so you can change it, as some like it to be 2 and others prefer 4. </p>
<p>Used different loops so the one not showing files doesn't check if it has to on each iteration.</p>
<p>Hope it helps someone else as dhobbs answer helped me. Thanks a lot.</p>
<pre><code>def showFolderTree(path,show_files=False,indentation=2,file_output=False):
"""
Shows the content of a folder in a tree structure.
path -(string)- path of the root folder we want to show.
show_files -(boolean)-  Whether or not we want to see files listed.
                        Defaults to False.
indentation -(int)- Indentation we want to use, defaults to 2.   
file_output -(string)-  Path (including the name) of the file where we want
                        to save the tree.
"""


tree = []

if not show_files:
    for root, dirs, files in os.walk(path):
        level = root.replace(path, '').count(os.sep)
        indent = ' '*indentation*(level)
        tree.append('{}{}/'.format(indent,os.path.basename(root)))

if show_files:
    for root, dirs, files in os.walk(path):
        level = root.replace(path, '').count(os.sep)
        indent = ' '*indentation*(level)
        tree.append('{}{}/'.format(indent,os.path.basename(root)))    
        for f in files:
            subindent=' ' * indentation * (level+1)
            tree.append('{}{}'.format(subindent,f))

if file_output:
    output_file = open(file_output,'w')
    for line in tree:
        output_file.write(line)
        output_file.write('\n')
else:
    # Default behaviour: print on screen.
    for line in tree:
        print line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on this fantastic post </p>
<p><a href="http://code.activestate.com/recipes/217212-treepy-graphically-displays-the-directory-structur/" rel="noreferrer">http://code.activestate.com/recipes/217212-treepy-graphically-displays-the-directory-structur/</a></p>
<p>Here es a refinement to behave exactly like </p>
<p><a href="http://linux.die.net/man/1/tree" rel="noreferrer">http://linux.die.net/man/1/tree</a></p>
<pre class="lang-python prettyprint-override">
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# tree.py
#
# Written by Doug Dahms
#
# Prints the tree structure for the path specified on the command line

from os import listdir, sep
from os.path import abspath, basename, isdir
from sys import argv

def tree(dir, padding, print_files=False, isLast=False, isFirst=False):
    if isFirst:
        print padding.decode('utf8')[:-1].encode('utf8') + dir
    else:
        if isLast:
            print padding.decode('utf8')[:-1].encode('utf8') + '└── ' + basename(abspath(dir))
        else:
            print padding.decode('utf8')[:-1].encode('utf8') + '├── ' + basename(abspath(dir))
    files = []
    if print_files:
        files = listdir(dir)
    else:
        files = [x for x in listdir(dir) if isdir(dir + sep + x)]
    if not isFirst:
        padding = padding + '   '
    files = sorted(files, key=lambda s: s.lower())
    count = 0
    last = len(files) - 1
    for i, file in enumerate(files):
        count += 1
        path = dir + sep + file
        isLast = i == last
        if isdir(path):
            if count == len(files):
                if isFirst:
                    tree(path, padding, print_files, isLast, False)
                else:
                    tree(path, padding + ' ', print_files, isLast, False)
            else:
                tree(path, padding + '│', print_files, isLast, False)
        else:
            if isLast:
                print padding + '└── ' + file
            else:
                print padding + '├── ' + file

def usage():
    return '''Usage: %s [-f] 
Print tree structure of path specified.
Options:
-f      Print files as well as directories
PATH    Path to process''' % basename(argv[0])

def main():
    if len(argv) == 1:
        print usage()
    elif len(argv) == 2:
        # print just directories
        path = argv[1]
        if isdir(path):
            tree(path, '', False, False, True)
        else:
            print 'ERROR: \'' + path + '\' is not a directory'
    elif len(argv) == 3 and argv[1] == '-f':
        # print directories and files
        path = argv[2]
        if isdir(path):
            tree(path, '', True, False, True)
        else:
            print 'ERROR: \'' + path + '\' is not a directory'
    else:
        print usage()

if __name__ == '__main__':
    main()


</pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar to answers above, but for python3, arguably readable and arguably extensible:</p>
<pre><code>from pathlib import Path

class DisplayablePath(object):
    display_filename_prefix_middle = '├──'
    display_filename_prefix_last = '└──'
    display_parent_prefix_middle = '    '
    display_parent_prefix_last = '│   '

    def __init__(self, path, parent_path, is_last):
        self.path = Path(str(path))
        self.parent = parent_path
        self.is_last = is_last
        if self.parent:
            self.depth = self.parent.depth + 1
        else:
            self.depth = 0

    @property
    def displayname(self):
        if self.path.is_dir():
            return self.path.name + '/'
        return self.path.name

    @classmethod
    def make_tree(cls, root, parent=None, is_last=False, criteria=None):
        root = Path(str(root))
        criteria = criteria or cls._default_criteria

        displayable_root = cls(root, parent, is_last)
        yield displayable_root

        children = sorted(list(path
                               for path in root.iterdir()
                               if criteria(path)),
                          key=lambda s: str(s).lower())
        count = 1
        for path in children:
            is_last = count == len(children)
            if path.is_dir():
                yield from cls.make_tree(path,
                                         parent=displayable_root,
                                         is_last=is_last,
                                         criteria=criteria)
            else:
                yield cls(path, displayable_root, is_last)
            count += 1

    @classmethod
    def _default_criteria(cls, path):
        return True

    @property
    def displayname(self):
        if self.path.is_dir():
            return self.path.name + '/'
        return self.path.name

    def displayable(self):
        if self.parent is None:
            return self.displayname

        _filename_prefix = (self.display_filename_prefix_last
                            if self.is_last
                            else self.display_filename_prefix_middle)

        parts = ['{!s} {!s}'.format(_filename_prefix,
                                    self.displayname)]

        parent = self.parent
        while parent and parent.parent is not None:
            parts.append(self.display_parent_prefix_middle
                         if parent.is_last
                         else self.display_parent_prefix_last)
            parent = parent.parent

        return ''.join(reversed(parts))
</code></pre>
<p>Example usage:</p>
<pre><code>paths = DisplayablePath.make_tree(Path('doc'))
for path in paths:
    print(path.displayable())
</code></pre>
<p>Example output:</p>
<pre><code>doc/
├── _static/
│   ├── embedded/
│   │   ├── deep_file
│   │   └── very/
│   │       └── deep/
│   │           └── folder/
│   │               └── very_deep_file
│   └── less_deep_file
├── about.rst
├── conf.py
└── index.rst
</code></pre>
<h3>Notes</h3>
<ul>
<li>This uses recursion. It will raise a <a href="https://docs.python.org/3/library/exceptions.html#RecursionError" rel="nofollow noreferrer" title="RecursionError">RecursionError</a> on really <strong>deep</strong> folder trees</li>
<li>The tree is lazily evaluated.  It should behave well on really <strong>wide</strong> folder trees.  Immediate children of a given folder are not lazily evaluated, though.</li>
</ul>
<h3>Edit:</h3>
<ul>
<li>Added bonus! criteria callback for filtering paths.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os

def fs_tree_to_dict(path_):
    file_token = ''
    for root, dirs, files in os.walk(path_):
        tree = {d: fs_tree_to_dict(os.path.join(root, d)) for d in dirs}
        tree.update({f: file_token for f in files})
        return tree  # note we discontinue iteration trough os.walk
</code></pre>
<p>If anybody is interested - that recursive function returns nested structure of dictionaries. Keys are <code>file system</code> names (of directories and files), values are either:</p>
<ul>
<li>sub dictionaries for directories</li>
<li>strings for files (see <code>file_token</code>)</li>
</ul>
<p>The strings designating files are empty in this example. They can also be e.g. given file contents or its owner info or privileges or whatever object different than a dict. Unless it's a dictionary it can be easily distinguished from a "directory type" in further operations.</p>
<p>Having such a tree in a filesystem:</p>
<pre><code># bash:
$ tree /tmp/ex
/tmp/ex
├── d_a
│   ├── d_a_a
│   ├── d_a_b
│   │   └── f1.txt
│   ├── d_a_c
│   └── fa.txt
├── d_b
│   ├── fb1.txt
│   └── fb2.txt
└── d_c
</code></pre>
<p>The result will be:</p>
<pre><code># python 2 or 3:
&gt;&gt;&gt; fs_tree_to_dict("/tmp/ex")
{
    'd_a': {
        'd_a_a': {},
        'd_a_b': {
            'f1.txt': ''
        },
        'd_a_c': {},
        'fa.txt': ''
    },
    'd_b': {
        'fb1.txt': '',
        'fb2.txt': ''
    },
    'd_c': {}
}
</code></pre>
<p>If you like that, I've already created a package (python 2 &amp; 3) with this stuff (and a nice <code>pyfakefs</code> helper):
<a href="https://pypi.org/project/fsforge/" rel="nofollow noreferrer">https://pypi.org/project/fsforge/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can execute 'tree' command of Linux shell.</p>
<p>Installation:</p>
<pre><code>   ~$sudo apt install tree
</code></pre>
<p>Using in python </p>
<pre><code>    &gt;&gt;&gt; import os
    &gt;&gt;&gt; os.system('tree &lt;desired path&gt;')
</code></pre>
<p>Example:</p>
<pre><code>    &gt;&gt;&gt; os.system('tree ~/Desktop/myproject')
</code></pre>
<p>This gives you a cleaner structure and is visually more comprehensive and easy to type.</p>
</div>
<div class="post-text" itemprop="text">
<p>On top of dhobbs answer above (<a href="https://stackoverflow.com/a/9728478/624597">https://stackoverflow.com/a/9728478/624597</a>), here is an extra functionality of storing results to a file (I personally use it to copy and paste to <a href="http://freemind.sourceforge.net/wiki/index.php/Main_Page" rel="nofollow noreferrer" title="FreeMind">FreeMind</a> to have a nice overview of the structure, therefore I used tabs instead of spaces for indentation):</p>
<pre><code>import os

def list_files(startpath):

    with open("folder_structure.txt", "w") as f_output:
        for root, dirs, files in os.walk(startpath):
            level = root.replace(startpath, '').count(os.sep)
            indent = '\t' * 1 * (level)
            output_string = '{}{}/'.format(indent, os.path.basename(root))
            print(output_string)
            f_output.write(output_string + '\n')
            subindent = '\t' * 1 * (level + 1)
            for f in files:
                output_string = '{}{}'.format(subindent, f)
                print(output_string)
                f_output.write(output_string + '\n')

list_files(".")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe faster than @ellockie ( Maybe ) </p>
<pre>
import os
def file_writer(text):
    with open("folder_structure.txt","a") as f_output:
        f_output.write(text)
def list_files(startpath):


    for root, dirs, files in os.walk(startpath):
        level = root.replace(startpath, '').count(os.sep)
        indent = '\t' * 1 * (level)
        output_string = '{}{}/ \n'.format(indent, os.path.basename(root))
        file_writer(output_string)
        subindent = '\t' * 1 * (level + 1)
        output_string = '%s %s \n' %(subindent,[f for f in files])
        file_writer(''.join(output_string))


list_files("/")

</pre>
<p>Test results in screenshot below:</p>
<p><a href="https://i.stack.imgur.com/blfaC.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/blfaC.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>This solution will only work if you have <code>tree</code> installed on your system.  However I'm leaving this solution here just in case it helps someone else out.</p>
<p>You can tell tree to output the tree structure as XML (<code>tree -X</code>) or JSON (<code>tree -J</code>).  JSON of course can be parsed directly with python and XML can easily be read with <code>lxml</code>.  </p>
<p>With the following directory structure as an example:</p>
<pre><code>[sri@localhost Projects]$ tree --charset=ascii bands
bands
|-- DreamTroll
|   |-- MattBaldwinson
|   |-- members.txt
|   |-- PaulCarter
|   |-- SimonBlakelock
|   `-- Rob Stringer
|-- KingsX
|   |-- DougPinnick
|   |-- JerryGaskill
|   |-- members.txt
|   `-- TyTabor
|-- Megadeth
|   |-- DaveMustaine
|   |-- DavidEllefson
|   |-- DirkVerbeuren
|   |-- KikoLoureiro
|   `-- members.txt
|-- Nightwish
|   |-- EmppuVuorinen
|   |-- FloorJansen
|   |-- JukkaNevalainen
|   |-- MarcoHietala
|   |-- members.txt
|   |-- TroyDonockley
|   `-- TuomasHolopainen
`-- Rush
    |-- AlexLifeson
    |-- GeddyLee
    `-- NeilPeart

5 directories, 25 files
</code></pre>
<p><strong>XML</strong></p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;tree&gt;
  &lt;directory name="bands"&gt;
    &lt;directory name="DreamTroll"&gt;
      &lt;file name="MattBaldwinson"&gt;&lt;/file&gt;
      &lt;file name="members.txt"&gt;&lt;/file&gt;
      &lt;file name="PaulCarter"&gt;&lt;/file&gt;
      &lt;file name="RobStringer"&gt;&lt;/file&gt;
      &lt;file name="SimonBlakelock"&gt;&lt;/file&gt;
    &lt;/directory&gt;
    &lt;directory name="KingsX"&gt;
      &lt;file name="DougPinnick"&gt;&lt;/file&gt;
      &lt;file name="JerryGaskill"&gt;&lt;/file&gt;
      &lt;file name="members.txt"&gt;&lt;/file&gt;
      &lt;file name="TyTabor"&gt;&lt;/file&gt;
    &lt;/directory&gt;
    &lt;directory name="Megadeth"&gt;
      &lt;file name="DaveMustaine"&gt;&lt;/file&gt;
      &lt;file name="DavidEllefson"&gt;&lt;/file&gt;
      &lt;file name="DirkVerbeuren"&gt;&lt;/file&gt;
      &lt;file name="KikoLoureiro"&gt;&lt;/file&gt;
      &lt;file name="members.txt"&gt;&lt;/file&gt;
    &lt;/directory&gt;
    &lt;directory name="Nightwish"&gt;
      &lt;file name="EmppuVuorinen"&gt;&lt;/file&gt;
      &lt;file name="FloorJansen"&gt;&lt;/file&gt;
      &lt;file name="JukkaNevalainen"&gt;&lt;/file&gt;
      &lt;file name="MarcoHietala"&gt;&lt;/file&gt;
      &lt;file name="members.txt"&gt;&lt;/file&gt;
      &lt;file name="TroyDonockley"&gt;&lt;/file&gt;
      &lt;file name="TuomasHolopainen"&gt;&lt;/file&gt;
    &lt;/directory&gt;
    &lt;directory name="Rush"&gt;
      &lt;file name="AlexLifeson"&gt;&lt;/file&gt;
      &lt;file name="GeddyLee"&gt;&lt;/file&gt;
      &lt;file name="NeilPeart"&gt;&lt;/file&gt;
    &lt;/directory&gt;
  &lt;/directory&gt;
  &lt;report&gt;
    &lt;directories&gt;5&lt;/directories&gt;
    &lt;files&gt;25&lt;/files&gt;
  &lt;/report&gt;
&lt;/tree&gt;
</code></pre>
<p><strong>JSON</strong></p>
<pre><code>[sri@localhost Projects]$ tree -J bands
[
  {"type":"directory","name":"bands","contents":[
    {"type":"directory","name":"DreamTroll","contents":[
      {"type":"file","name":"MattBaldwinson"},
      {"type":"file","name":"members.txt"},
      {"type":"file","name":"PaulCarter"},
      {"type":"file","name":"RobStringer"},
      {"type":"file","name":"SimonBlakelock"}
    ]},
    {"type":"directory","name":"KingsX","contents":[
      {"type":"file","name":"DougPinnick"},
      {"type":"file","name":"JerryGaskill"},
      {"type":"file","name":"members.txt"},
      {"type":"file","name":"TyTabor"}
    ]},
    {"type":"directory","name":"Megadeth","contents":[
      {"type":"file","name":"DaveMustaine"},
      {"type":"file","name":"DavidEllefson"},
      {"type":"file","name":"DirkVerbeuren"},
      {"type":"file","name":"KikoLoureiro"},
      {"type":"file","name":"members.txt"}
    ]},
    {"type":"directory","name":"Nightwish","contents":[
      {"type":"file","name":"EmppuVuorinen"},
      {"type":"file","name":"FloorJansen"},
      {"type":"file","name":"JukkaNevalainen"},
      {"type":"file","name":"MarcoHietala"},
      {"type":"file","name":"members.txt"},
      {"type":"file","name":"TroyDonockley"},
      {"type":"file","name":"TuomasHolopainen"}
    ]},
    {"type":"directory","name":"Rush","contents":[
      {"type":"file","name":"AlexLifeson"},
      {"type":"file","name":"GeddyLee"},
      {"type":"file","name":"NeilPeart"}
    ]}
  ]},
  {"type":"report","directories":5,"files":25}
]
</code></pre>
</div>
<span class="comment-copy">I would suggest using <code>os.walk()</code>, but it seems like you're already there... what have you tried?</span>
<span class="comment-copy">I guess it's because I don't fully understand tuple. I know how to list all the dirs and all the files separately, but I don't know how to list the files and sub-dirs of a dir without overlapping things.</span>
<span class="comment-copy">See the answer to <a href="http://stackoverflow.com/questions/120656/directory-listing-in-python">this question</a></span>
<span class="comment-copy">This worked very well, thank you.  Though most would know, still for the benefit of newcomers into python - please note that you would need to call the function at the end (assuming windows), so you might add a new line at the end with the content list_files ("D:\\")</span>
<span class="comment-copy">Worked well on python3. But on python2 <code>ValueError: zero length field name in format</code> gets thrown.</span>
<span class="comment-copy">Hi dhobbs, I tried to use your function. I wonder if there a way to return this directory tree in order to iterate through the directory tree from the last to a certain folder! I can post this as a question if you like.</span>
<span class="comment-copy">@SamirAlhejaj: I don't quite understand what you're looking to do, but it does sound like it should probably be a new question.</span>
<span class="comment-copy">Hi Dhobbss, I tried to run this in python 3 but do not get any output. Any suggestion?</span>
<span class="comment-copy">python says: <code>NameError: name 'path' is not defined</code></span>
<span class="comment-copy">@FrancescoMantovani "path" is the variable containing the directory you want to print, i.e. r"C:\Users\username\Documents\path"</span>
<span class="comment-copy">I feel this answer doesn't contribute to the already accepted answer. The only thing you are providing is additional fluff code to turn off features or not in the response.</span>
<span class="comment-copy">Your feeling is right, @jason-heine. The accepted answer is good enough, but some people asked how to do this fluff stuff and I wanted to give something to them. Downvote it or report my answer if you don't want to see this in SO, I thought it wouldn't hurt, but I might be wrong.</span>
<span class="comment-copy">It is useful indeed. Thanks a lot. I used it as it is.</span>
<span class="comment-copy">This is not very portable solution as this fails on Windows + relies on additional program</span>
