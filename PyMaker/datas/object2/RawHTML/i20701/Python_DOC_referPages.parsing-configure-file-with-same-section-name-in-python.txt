<div class="post-text" itemprop="text">
<p>I try to parse file like:</p>
<pre><code>[account]
User = first

[account]
User = second
</code></pre>
<p>I use ConfigParser in Python, but when i read file:</p>
<pre><code>Config = configparser.ConfigParser()
Config.read(file)
print (Config.sections())
</code></pre>
<p>I have error:</p>
<pre><code>While reading from ... : section 'account' already exists
</code></pre>
<p>How can i parse this file? Are any another library? (prefer for python3)</p>
</div>
<div class="post-text" itemprop="text">
<p>If what you want is to simply merge identically named sections (latest one wins), simply pass the <code>strict=False</code> option to the constructor (added in Python 3.2). 
You effectively get <code>dict.update()</code> behavior as the duplicate sections are merged in.</p>
<pre><code>Config = configparser.ConfigParser(strict=False)
</code></pre>
<p>However, it's clear from the OP's sample data that identically named sections need to be kept separate, to avoid loss of data. <code>ConfigParser</code> stores the sections it reads in a dictionary, so it can't handle multiple sections with the same name. Fortunately the constructor accepts a <code>dict_type</code> argument that allows you to specify a different dictionary-like object. You can use that to support identically named sections. Here's a crude solution that mangles the section names by appending a unique number whenever a section name has been seen before. </p>
<pre><code>from collections import OrderedDict

class multidict(OrderedDict):
    _unique = 0   # class variable

    def __setitem__(self, key, val):
        if isinstance(val, dict):
            self._unique += 1
            key += str(self._unique)
        OrderedDict.__setitem__(self, key, val)

Config = configparser.ConfigParser(defaults=None, dict_type=multidict, strict=False)
</code></pre>
<p>With a little work you should be able to construct a cleaner solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>On the latest python there is an option that may do what you want :
<code>ConfigParser(strict=True)</code></p>
<p>Cf : <a href="https://docs.python.org/3/library/configparser.html#configparser.ConfigParser" rel="nofollow noreferrer">https://docs.python.org/3/library/configparser.html#configparser.ConfigParser</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, the format of the provided ini file is not correct according standards. A section's name must be unique in the document.</p>
<p>If you can change the file-format (I already read that you cannot, but for completeness...), then a solution like this would be appropriate:</p>
<pre><code>[accounts]
keys= account1, account2

[account1]
User = first

[account2]
User = second
</code></pre>
<p>If you really can't alternate the file's format, then I fear that your only option is to parse manually the configuration file.</p>
</div>
<div class="post-text" itemprop="text">
<p>"
If you're deviating from an RFC standard and creating your own config format, you're going to have to write your own parser." This <a href="http://www.tek-tips.com/viewthread.cfm?qid=1110829" rel="nofollow noreferrer">http://www.tek-tips.com/viewthread.cfm?qid=1110829</a> worked for me.  I made a couple of small changes.  ** formatting did not come out correctly when posted</p>
<pre><code>def configToDict(file):
# open the file
file = open('settings.cfg')

# create an empty dict
sections = {}

for line in file.readlines():
    # get rid of the newline
    line = line[:-1]
    try:
        # this will break if you have whitespace on the "blank" lines
        if line:
            # skip comment lines
            if line[0] == '#': next
            # this assumes everything starts on the first column
            if line[0] == '[':
                # strip the brackets
                section = line[1:-1]
                # create a new section if it doesn't already exist
                if not sections.has_key(section):
                    sections[section] = {}
            else:
                # split on first the equal sign
                (key, val) = line.split('=', 1)
                # create the attribute as a list if it doesn't
                # exist under the current section, this will
                # break if there's no section set yet
                if not sections[section].has_key(key):
                    sections[section][key] = []
                # append the new value to the list
                sections[section][key].append(val)
    except Exception as e:
        print str(e) + "line:" +line
return sections
</code></pre>
</div>
<span class="comment-copy">Do you have control over the config file format?  If yes, change it to something <code>configparser</code> likes better.</span>
<span class="comment-copy">I can't change file format.</span>
<span class="comment-copy">I would suggest you write your own parser for it.</span>
<span class="comment-copy">A simple pre-processor would do. But a perfect answer has been given below by alexis.</span>
<span class="comment-copy">Nope, it doesn't-- at least it doesn't do what the OP was after, and accepted. <code>strict=True</code> is the default. Setting it to <code>False</code> permits multiple sections with the same name, but simply merges their options.</span>
