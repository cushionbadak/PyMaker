<div class="post-text" itemprop="text">
<p>As mentioned <a href="https://stackoverflow.com/questions/17585730/what-does-hash-do-in-python">here</a>,</p>
<p>Below code,</p>
<pre><code>class Person(object):
     def __init__(self, name, ssn, address):
         self.name = name
         self.ssn = ssn
         self.address = address
     def __hash__(self):
         print('in hash')
         return hash(self.ssn)
     def __eq__(self, other):
         print('in eq')
         return self.ssn == other.ssn

bob = Person('bob', '1111-222-333', None)

jim = Person('jim bo', '1111-222-333', 'sf bay area')


dmv_appointments = {}
print('calling hash')
dmv_appointments[bob] = 'tomorrow'
print('calling hash')
print(dmv_appointments[jim])
print('calling hash again')
print(dmv_appointments[bob])
</code></pre>
<hr/>
<p>Output:</p>
<pre><code>calling hash
in hash
calling hash
in hash
in eq
tomorrow
calling hash again
in hash
tomorrow
</code></pre>
<hr/>
<p><strong>Question:</strong></p>
<p>Why <code>__eq__</code> gets called on accessing <code>jim</code>but not on <code>bob</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short answer</strong>: a dictionary lookup <strong>first does a (cheap) reference equality check</strong> (<code>x is y</code>) when searching a bucket, and only if that fails, a (more expensive) equality check (<code>x == y</code>) is done.</p>
<h1>Scenario</h1>
<p>The <code>__hash__</code> function does <strong>not call</strong> <code>__eq__</code> internally. Given you construct <code>bob</code> and <code>jim</code>, no such methods are called.</p>
<p>Next you <strong>associate <code>bob</code> with <code>'tomorrow'</code></strong>. In order to know in which bucket of the dictionary, you have to store <code>bob</code>, you <strong>calculate the hash</strong>. Now once you have done that we store <code>bob</code> (and the value in the correct bucket).</p>
<p>Next we want to <strong>obtain <code>jim</code></strong>. In order to know in which bucket <code>jim</code> resides, we <strong>calculate the hash</strong>. Next we start searching in the bucket. The bucket will contain <code>bob</code>. We <strong>first perform a reference check</strong> (<code>jim is bob</code>) but that fails, so then we fallback on the <strong>equality check</strong>. That check succeeds, so we return the value corresponding with <code>bob</code>: <code>'tomorrow'</code>.</p>
<p>The same scenario happens when we want to look for <code>bob</code>: we <strong>calculate the hash</strong>, fetch the bucket. Perform a <strong>reference check</strong> on <code>bob is bob</code>, and that one succeeds. So we do not need a (probably more expensive equality check). We simply return the value <code>'tomorrow'</code>.</p>
<h1>Reference checks</h1>
<p>The fact that <strong>a reference check is done first</strong> can be proven with the following (unhealthy) code:</p>
<pre><code>class Person(object):
     def __init__(self, name, ssn, address):
         self.name = name
         self.ssn = ssn
         self.address = address
     def __hash__(self):
         print('in hash')
         return hash(self.ssn)
     <b>def __eq__(self, other):
         print('in eq')
         return False</b></code></pre>
<p>Here we return always <code>False</code> for equality. So even:</p>
<pre><code>&gt;&gt;&gt; bob == bob
in eq
False
&gt;&gt;&gt; bob is bob
True
</code></pre>
<p><code>bob</code> is not equal to itself (this is actually not good design, since for a dictionary, it is a contract that an object is equal to itself: a good <em>equality relation</em> is <em>reflexive</em>, <em>symmetrical</em> and <em>transitive</em>). Nevertheless, if we associate <code>bob</code> with <code>'tomorrow'</code>, we are still able to fetch the value associated with <code>bob</code>:</p>
<pre><code>&gt;&gt;&gt; dmv_appointments = {}
&gt;&gt;&gt; dmv_appointments[bob] = 'tomorrow'
in hash
&gt;&gt;&gt; dmv_appointments[bob]
in hash
'tomorrow'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To answer the title:</p>
<blockquote>
<p>When does <code>__eq__</code> gets called using hash()?</p>
</blockquote>
<p>Never. </p>
<hr/>
<p>The other question:</p>
<blockquote>
<p>Why <code>__eq__</code> gets called on accessing jim but not on bob?</p>
</blockquote>
<p>That's more complicated. To understand that you need to know how a dictionary is implemented. Assuming CPython it will be a table containing a <code>hash</code> column, a <code>key</code> column and a <code>value</code> column:</p>
<pre><code>hash     | key       | value
-----------------------------------------
    -    |      -    |        -
-----------------------------------------
    -    |      -    |        -
</code></pre>
<p>It will have a certain size but it won't be big enough to contain every possible <code>hash</code> value, so it will calculate the position based on the <code>hash</code>. For example if you add <code>bob</code> it could have (string hashes are randomized in certain CPython versions so the actual result will differ) a <code>hash</code> of <code>7475314405837642385</code>. Assuming the dictionary has an actual size of 2 (in reality it will be bigger, but that would unnecessarily waste space in the answer) it just takes the modulo, so it will place it in <code>7475314405837642385 % 2 == 1</code>:</p>
<pre><code>hash     | key       | value
-----------------------------------------
    -    |      -    |        -
-----------------------------------------
747...385|    bob    |    'tomorrow'
</code></pre>
<p>When you want to look up a key it</p>
<ul>
<li>always calculate the <code>hash</code> of the lookup</li>
<li>then it will calculate the position. </li>
<li>Then it compares the <code>hash</code> of the lookup to the <code>hash</code> saved in that position</li>
<li>if the <code>hash</code>es are equal then it will compare the lookup and the saved <code>key</code> with <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a>. That will:

<ul>
<li>first check for identity: <code>lookup is key</code></li>
<li>if that is <code>False</code> it will check <code>lookup == key</code></li>
</ul></li>
</ul>
<p>So in case you lookup <code>bob</code>:</p>
<ul>
<li>hash: <code>7475314405837642385</code></li>
<li>position: <code>7475314405837642385 % 2</code> -&gt; <code>1</code></li>
<li>found an entry, so compare the <code>hash</code>es: <code>7475314405837642385 == 7475314405837642385</code></li>
<li>that was equal so check for identity: <code>bob is bob</code> -&gt; <code>True</code></li>
</ul>
<p>So it returns <code>'tomorrow'</code> without an equality check. In the second case it checks for <code>jim</code>:</p>
<ul>
<li>hash: <code>7475314405837642385</code></li>
<li>position: <code>7475314405837642385 % 2</code> -&gt; <code>1</code></li>
<li>found an entry, so compare the <code>hash</code>es: <code>7475314405837642385 == 7475314405837642385</code></li>
<li>that was equal so check for identity: <code>jim is bob</code> -&gt; <code>False</code></li>
<li>check for equality <code>jim == bob</code> -&gt; <code>True</code></li>
</ul>
<p>So it returns <code>'tomorrow'</code>.</p>
<hr/>
<p>This is just an approximation of the actual implementation (it's missing some details). It gets more complicated if the <code>hash</code>es are not equal or the <code>lookup is not key and lookup != key</code> but these are not really important to understand the observed behavior you questioned.</p>
<p>However, I really need to say this: What you're doing is really dangerous because your class isn't immutable. You could accidentally make the saved dictionary entry unavailable to you:</p>
<pre><code>dmv_appointments = {bob: 1}
bob.ssn = '1'     # changing ssn changes the hash!
dmv_appointments[bob]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-35-3920ada7bab1&gt; in &lt;module&gt;()
     15 dmv_appointments = {bob: 1}
     16 bob.ssn = '1'
---&gt; 17 dmv_appointments[bob]

KeyError: &lt;__main__.Person object at 0x000001BD5DDCC470&gt;
</code></pre>
<p>(It could still work in case the new <code>hash</code> is equal to the "old" hash, but that would be rather accidental).</p>
<p>That's because while you alter the <code>hash</code> of your instance - the dictionary won't update the saved <code>hash</code> because it assumes all keys are <strong>immutable</strong>! So the dictionary would either assume it would be saved in another position or if the position would (miraculously) be the same then it would fail in the step where it contains the actual hashes.</p>
</div>
<span class="comment-copy">My guess is that it's first checking the hash, then <i>identity</i> (being faster), and only <i>then</i> equality. Thus, when you look up <code>bob</code> it does not have to check <code>__eq__</code> to see whether it's the right entry, but for <code>jim</code> it does.</span>
<span class="comment-copy">Related question: <a href="https://stackoverflow.com/q/40917986/1639625">stackoverflow.com/q/40917986/1639625</a> A comment says something about how it's done in the C implementation.</span>
<span class="comment-copy">@tobias_k: Yeah, that's a CPython (the Python reference interpreter) implementation detail due to <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer">using <code>PyObject_RichCompareBool</code> as the standard method for comparing objects at the C layer</a>. Using that function for equality checking is effectively equivalent to <code>return x is y or x == y</code> at the Python level.</span>
<span class="comment-copy">As an aside, your class uses <code>ssn</code> as identity as far as <code>__hash__</code> and <code>__eq__</code> are concerned so your test data using the same <code>ssn</code> for two objects is an error case. The <code>dict</code> cannot hold both of these objects at the same time. It would make sense to check for this in the constructor and error out.</span>
<span class="comment-copy">It's not generally required that all objects equal themselves. <code>float('nan')</code> and <code>decimal.Decimal('nan')</code> don't, for example, and those types come with Python. It <i>is</i> required that <code>==</code> is an equivalence relation for dict keys, so using one of those <code>Person</code> objects as a dict key breaks the contract for dict keys.</span>
<span class="comment-copy">@user2357112: yeah there are some exceptions, because usually the see <code>NaN</code> as a "corrupt" result. Two <code>nan</code>s that originate from different computations are usually not equal. But in general reflexivity, symmetry and transitivity are properties of a sound equality relation.</span>
