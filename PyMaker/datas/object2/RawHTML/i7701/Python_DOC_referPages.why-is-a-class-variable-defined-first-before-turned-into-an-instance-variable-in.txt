<div class="post-text" itemprop="text">
<p>when learning python property decorator in this <a href="https://www.programiz.com/python-programming/property" rel="nofollow noreferrer">link</a>, I stumbled upon following lines of code:</p>
<pre><code>class Celsius:
    def __init__(self, temperature = 0):
        self.temperature = temperature       

    def to_fahrenheit(self):
        return (self.temperature * 1.8) + 32

    def get_temperature(self):
        print("Getting value")
        return self._temperature

    def set_temperature(self, value):
        if value &lt; -273:
            raise ValueError("Temperature below -273 is not possible")
        print("Setting value")
        self._temperature = value

    temperature = property(get_temperature,set_temperature)
</code></pre>
<p>this code basically let you modify/add restraint to a <code>Celsius</code> object, without having anybody who inherited <code>Celsius</code> class refactor their code.</p>
<p>why does it define a class variable <code>temperature</code> first, rather than just let <code>self.temperature = property(get_temperature,set_temperature)</code> and done?</p>
<p>EDIT: Due to conflict opinions in comments, I will now restore the code to original state, regardless if there is a typo, to make it easy for people read this afterwards.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer lies in the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol and attribute lookup order</a>. If you did this: </p>
<pre><code>class Celsius:
    def __init__(self, temperature): 
        self.temperature = property(get_temperature,set_temperature)
        self.temperature = temperature
# etc etc
</code></pre>
<p>It will not behave the way you expect. At all. </p>
<pre><code>t = Celsius(100)
t.temperature = -500 # NO ERROR! BROKEN!
</code></pre>
<p>WHY? Because you overwrote the property object with the number that was provided to the initializer. Observe: </p>
<pre><code>get = lambda *args: None # dummy getter
set = lambda *args: None # dummy setter
p = property(get, set) # dummy property
</code></pre>
<p>A property should be an instance of <code>Property</code>:</p>
<pre><code>print(type(p).__name__)
# Property
</code></pre>
<p>But your temperature isn't a property anymore: </p>
<pre><code>print(type(t.temperature).__name__)
# int
</code></pre>
<p>You overwrote it with this line: </p>
<pre><code>self.temperature = temperature 
# note that temperature is an int or float
</code></pre>
<p>Sprinkle some <code>print</code> statements to see what is going on: </p>
<pre><code>class Celsius:
    def __init__(self, temperature): 
        self.temperature = property(get_temperature,set_temperature)
        print(type(self.temperature).__name__) # Property
        self.temperature = temperature
        print(type(self.temperature).__name__) # no longer a Property!
# etc etc
</code></pre>
<p>Therefore, the property object needs to be stored at the <em>class level</em> so it doesn't get overwritten at the <em>instance level</em>. When a <em>class level</em> property object is accessed at the instance level, the descriptor protocol is automatically invoked (a <code>Property</code> is a type of descriptor; descriptors have unusual behavior so go study them carefully). </p>
<p>Learn more about class level objects vs. instance level objects at this <a href="https://stackoverflow.com/questions/68645/static-class-variables-in-python/27568860#27568860">much more detailed answer</a>.</p>
<p>Also note that the temperature needs to be set <em>in the initializer</em> using the property. Do <strong>not</strong> do this:</p>
<pre><code>class Celsius: 
    def __init__(self, temperature):
        self._temperature = temperature
</code></pre>
<p>Using this code you could do this without an error, which is bad: <code>t=Celsius(-500)</code>. Typically the initializer should use the property to get or set the private variable just like any other method would: </p>
<pre><code>        self.temperature = temperature
</code></pre>
<p>Now an invalid initial temperature will cause an error, as expected. </p>
</div>
<div class="post-text" itemprop="text">
<p>In the snippet above there are two things addressed:</p>
<p><strong>1. Setting temperature during object creation using parameterized constructor.</strong></p>
<p><code>def __init__(self, temperature = 0):</code></p>
<p>In this case Celsius with temperature 8 will be created as:</p>
<pre><code>t = Celsius(8)
</code></pre>
<p><strong>2. Setting and retrieving temperature using object property using</strong></p>
<p><code>temperature = property(get_temperature,set_temperature)</code></p>
<p>In this case Celsius with temperature 8 will be created, set/retrieved as:</p>
<pre><code>t = Celsius()
t.set_temperature(8)
print t.get_temperature()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because methods <em>are</em> class properties. And <code>self</code> does not exist in that scope.</p>
<p>Note, that code is very out of date; you should use <code>property</code> as a decorator:</p>
<pre><code>@property
def temperature(self):
    print("Getting value")
    return self._temperature

@temperature.setter
def set_temperature(self, value):
    if value &lt; -273:
        raise ValueError("Temperature below -273 is not possible")
    print("Setting value")
    self._temperature = value
</code></pre>
</div>
<span class="comment-copy">should be 'self._tem...' in <code>__init__</code>? <code>_temperature</code> does not initialized at first</span>
<span class="comment-copy">And I remember that property only works with new style class and object.</span>
<span class="comment-copy">there is typo in in the above link you provided.  you need to update your code according to the last piece of code  . it should be <code>self._temperature...</code> in <code>__init__</code></span>
<span class="comment-copy">@Jacky That is not a typo. Note that with the above code you could do this without an error, which is bad: <code>t=Celsius(-500)</code>. Typically the initializer should use the property to get or set the private variable just like any other method would.</span>
<span class="comment-copy">@RickTeachey so are you saying the above code was not using the property approach correctly?</span>
<span class="comment-copy">to me, looks like there is indeed a typo, because after instantiate the class as c, doing c.temperature would only output "Setting Value" if it is self._temperature in <b>init</b> method.</span>
<span class="comment-copy">You are mistaken.</span>
<span class="comment-copy">in what sense, if I may ask?  in fact at this moment I am highly doubting this original code is idiomatic at all.</span>
<span class="comment-copy">It's obviously old. But only because it is not using the <code>@property</code> decorator.  You are mistaken because if you do not use the setter inside of the initializer,  you will be able to initialize with invalid values, ie, <code>Celsius(-500)</code>.</span>
<span class="comment-copy">is the correct way to use setter in initializer adding <code>self.set_temperature(temperature)</code> in <code>__init__</code> method?</span>
