<div class="post-text" itemprop="text">
<p>Inspecting the <code>slice</code> class in Python with <code>dir()</code>, I see that it has attributes <code>__le__</code> and <code>__lt__</code>. Indeed I saw that the following code works:</p>
<pre><code>slice(1, 2) &lt; slice(3, 4)
# True
</code></pre>
<p>However, I cannot see which logic is implemented for this comparison, nor its usecase. Can anyone point me to that?</p>
<p>I am not asking about tuple comparison. Even if slice and tuple are compared the same way, I don't think this makes my question a duplicate. What's more, I also asked for a possible usecase of slice comparison, which the suggested duplicate does not give.</p>
</div>
<div class="post-text" itemprop="text">
<p>Looking at the source code for <code>slice</code> reveals that the comparison is implemented by first converting the two objects into <code>(start, stop, step)</code> tuples, and then comparing those tuples:</p>
<p><a href="https://github.com/python/cpython/blob/6cca5c8459cc439cb050010ffa762a03859d3051/Objects/sliceobject.c#L598" rel="nofollow noreferrer">https://github.com/python/cpython/blob/6cca5c8459cc439cb050010ffa762a03859d3051/Objects/sliceobject.c#L598</a></p>
<p>As to the use cases, I am not sure of the authors' intent. I do note that there don't appear to be any comparison unit tests for anything other than equality:</p>
<p><a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/test/test_slice.py#L87" rel="nofollow noreferrer">https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Lib/test/test_slice.py#L87</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Comparing tuples : <code>(1, 2) &lt; (3, 4)</code> returns <code>True</code> because <code>(1, 2) comes before (3, 4)</code>.</p>
<p>However, <code>(1, 2) &lt; (0, 4)</code> returns <code>False</code> because <code>(1, 2) comes after (0, 4)</code>.</p>
<p><strong>NB:</strong> <code>&lt;</code> and <code>&gt;</code> doesn't mean <code>smaller than</code> or <code>greater than</code>, but <code>is before</code> and <code>is after</code>.</p>
<p>So, in other words, you're comapring which is coming before and which is coming after.</p>
<p><strong>Some "odd" cases (Or, misleading cases within <code>&lt;</code> and <code>&gt;</code>):</strong></p>
<p><code>(1, 2) &lt; (3, 4, 5)</code> returns <code>True</code> because the missing value of the first tuple will be equal to <code>nil</code> value of the operation which is zero in this case. Or you can think of it that <code>(1, 2) come before (3, 4, 5)</code>.</p>
<p>And:</p>
<p><code>(0, 1) &lt; (1, 0)</code> will returns <code>True</code> because <code>(0, 1) comes before (1, 0)</code></p>
<p>Another case:</p>
<p><code>(0, 1, 20000) &lt; (0, 3, 1)</code> will returns <code>True</code> because <code>(0, 1, 20000) comes before (0, 3, 1)</code>.</p>
<p>Same logic for <code>slice</code>, <code>list</code> and even <code>strings</code>.</p>
<p>For more informations, visit this <a href="https://stackoverflow.com/a/5292332/3926995">answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/datamodel.html#index-64" rel="nofollow noreferrer">Python data model</a> only mentions that slice objects have three read-only attributes and one method. It does not mention any other properties of slices.</p>
<p>As mentioned by @NPE, CPython implementation indeed <a href="https://github.com/python/cpython/blob/6cca5c8459cc439cb050010ffa762a03859d3051/Objects/sliceobject.c#L598" rel="nofollow noreferrer">provides</a> a comparison for slice objects, which simply treats <code>slice</code> as a tuple of <code>(start, end, step)</code>. I've checked it with a small Python program which confirmed that:</p>
<pre><code>vals = []
for a in range(-5, 5):
    for b in range(-5, 5):
        for c in range(-5, 5):
            vals.append((a, b, c))
for x in vals:
    for y in vals:
        assert (slice(*x) &lt; slice(*y)) == (x &lt; y)
</code></pre>
<p>However, that looks like a non-standard extension. For example, <a href="http://www.jython.org/" rel="nofollow noreferrer">Jython</a> also implements comparison for slices, but in a different way. Moreover, it looks like it <a href="https://bitbucket.org/jython/jython/src/91083509a11cdeadc9407b4d9a1ece2b8ffc45ce/src/org/python/core/PyObject.java?at=default&amp;fileviewer=file-view-default#PyObject.java-1407" rel="nofollow noreferrer">implements</a> comparison for all possible pairs of objects by comparing objects of the same type by their <code>id</code>s, which is propagated to slices.</p>
<p>So, order of slices in Jython is non-deterministic. For example, the following snippet prints <code>True True</code> on my system with Jython and <code>True False</code> with CPython:</p>
<pre><code>print(slice(1, 2) &lt; slice(1, 3))
print(slice(1, 3) &lt; slice(1, 2))
</code></pre>
<p>Summarizing: <code>__lt__</code> is implemented in CPython for some obscure reason, but it's not described anywhere in documentation and other implementations may behave not only differently, but "incorrectly" (in <a href="https://en.wikipedia.org/wiki/Total_order" rel="nofollow noreferrer">mathematical sense</a>). So, one should not compare slices for inequality.</p>
</div>
<span class="comment-copy">This is not a duplicate. I'm asking about slice, not tuple.</span>
<span class="comment-copy">Regarding your "smaller than" comment, I do believe that lt and le stand for Less Than and Less or Equal. Do you confirm?</span>
<span class="comment-copy">Yes i comfirm. <code>__lt__</code> will behave the same as <code>&lt;</code>. the same for <code>&lt;=</code> and <code>__le__</code>.</span>
<span class="comment-copy">and &lt; calls <code>__lt__</code>, so it indeed means "smaller than" (in python), no?</span>
<span class="comment-copy">For <code>tuples</code>, <code>strings</code> and <code>lists</code> think of it like <code>comes before or comes after</code> not <code>smaller and greater</code> otherwise you'll face some odd cases.  However, <code>&lt;</code> ccalls <code>__lt__</code> and this special method behaves differently with its data</span>
