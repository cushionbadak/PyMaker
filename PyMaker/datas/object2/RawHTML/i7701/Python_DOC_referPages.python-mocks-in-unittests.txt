<div class="post-text" itemprop="text">
<p>I have situation similar to:</p>
<pre><code>class BaseClient(object):
    def __init__(self, api_key):
        self.api_key = api_key
        # Doing some staff.

class ConcreteClient(BaseClient):
    def get_some_basic_data(self):
        # Doing something.

    def calculate(self):
        # some staff here
        self.get_some_basic_data(param)
        # some calculations
</code></pre>
<p>Then I want to test <code>calculate</code> function using mocking of <code>get_some_basic_data</code> function.</p>
<p>I'm doing something like this:</p>
<pre><code>import unittest
from my_module import ConcreteClient

def my_fake_data(param):
    return [{"key1": "val1"}, {"key2": "val2"}]

class ConcreteClientTest(unittest.TestCase):
    def setUp(self):
        self.client = Mock(ConcreteClient)

    def test_calculate(self):

        patch.object(ConcreteClient, 'get_some_basic_data',
                     return_value=my_fake_data).start()
        result = self.client.calculate(42)
</code></pre>
<p>But it doesn't work as I expect.. As I thought, <code>self.get_some_basic_data(param)</code> returns my list from <code>my_fake_data</code> function, but it looks like it's still an Mock object, which is not expected for me.</p>
<p>What is wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two main problems that you are facing here. The primary issue that is raising the current problem you are experiencing is because of <em>how</em> you are actually mocking. Now, since you are actually patching the <code>object</code> for <code>ConcreteClient</code>, you want to make sure that you are still using the <em>real</em> ConcreteClient but <em>mocking</em> the attributes of the <em>instance</em> that you want to mock when testing. You can actually see this illustration in the documentation. Unfortunately there is no explicit anchor for the exact line, but if you follow this link: </p>
<p><a href="https://docs.python.org/3/library/unittest.mock-examples.html" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock-examples.html</a></p>
<p>The section that states:</p>
<blockquote>
<p>Where you use patch() to create a mock for you, you can get a
  reference to the mock using the “as” form of the with statement:</p>
</blockquote>
<p>The code in reference is: </p>
<pre><code>class ProductionClass:
    def method(self):
        pass

with patch.object(ProductionClass, 'method') as mock_method:
    mock_method.return_value = None
    real = ProductionClass()
    real.method(1, 2, 3)

mock_method.assert_called_with(1, 2, 3)
</code></pre>
<p>The critical item to notice here is how the everything is being called. Notice that the real instance of the class is created. In your example, when you are doing this: </p>
<pre><code>self.client = Mock(ConcreteClient)
</code></pre>
<p>You are creating a <code>Mock</code> object that is <em>specced</em> on ConcreteClient. So, ultimately this is just a <code>Mock</code> object that holds the attributes for your <code>ConcreteClient</code>. You will not actually be holding the <em>real</em> instance of <code>ConcreteClient</code>. </p>
<p>To solve this problem. simply create a <em>real</em> instance after you patch your object. Also, to make your life easier so you don't have to manually start/stop your patch.object, use the context manager, it will save you a lot of hassle.</p>
<p>Finally, your second problem, is your <code>return_value</code>. Your <code>return_value</code> is actually returning the <em>uncalled</em> <code>my_fake_data</code> function. You actually want the data itself, so it needs to be the <em>return</em> of that function. You could just put the data itself as your <code>return_value</code>. </p>
<p>With these two corrections in mind, your test should now just look like this: </p>
<pre><code>class ConcreteClientTest(unittest.TestCase):

    def test_calculate(self):

        with patch.object(ConcreteClient, 'get_some_basic_data',
                     return_value=[{"key1": "val1"}, {"key2": "val2"}]):

            concrete_client = ConcreteClient(Mock())
            result = concrete_client.calculate()

        self.assertEqual(
            result,
            [{"key1": "val1"}, {"key2": "val2"}]
        )
</code></pre>
<p>I took the liberty of actually returning the result of <code>get_some_basic_data</code> in <code>calculate</code> just to have something to compare to. I'm not sure what your <em>real</em> code looks like. But, ultimately, the structure of your test in how you should be doing this, is illustrated above. </p>
</div>
