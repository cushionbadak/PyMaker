<div class="post-text" itemprop="text">
<pre><code>def worker(worker_comment):
    time.sleep(vote_delay)
    try:
        for (k, v) in enumerate(account):
            worker_steem = Steem(keys=posting_key)
            upvote_comment = worker_steem.get_content(worker_comment.identifier)

            # Checking if Post is flagged for Plagarism &amp; Spam
            names = ['blacklist', 'fubar-bdhr']
            if ('-' in str(upvote_comment['author_reputation'])):
                print("@%s %s ====&gt; Upvote Skipped - Author rep too low")
                return False
            for avote in upvote_comment['active_votes']:
                if (avote['voter'] in names and avote['percent'] &lt; 0):
                    print("@%s %s ====&gt; Upvote Skipped - Flagged by blacklist or Fubar-bdhr")
                    return False

            # Checking if there is markings from Cheetah or Steemcleaners:
            names = ['cheetah', 'steemcleaners']
            for avote in upvote_comment['active_votes']:
                if (avote['voter'] in names):
                    print("@%s %s ====&gt; Post Marked by SteemCleaners or Cheetah")
                    return False

            # Checking if the voting power is over 60%:
            if (mainaccount['voting_power'] &lt; 60):
                print("Not Enough Voting Power")
                return False

            # Checking if we already voted for this post:
            names = account[k]
            for avote in upvote_comment['active_votes']:
                if (avote['voter'] in names):
                    print("@%s %s ====&gt; Post Upvoted already by", account[k])
                    return False

            # UPVOTING THE POST
            upvote_comment.vote(100, voter=account[k])

            # Upvote has now been done and it will now print a message to your screen:
            print(upvote_comment, " ====&gt; UPVOTED by", account[k])
            print("Voting Power Left:", mainaccount['voting_power'])
            upvote_history.append(upvote_comment.identifier)
    except:
        print("ERROR - Upvoting failed for", account[k])
        print("We have probably already upvoted this post before the author edited it.")
        print(str(e))
</code></pre>
<p>Hi, 
I am working on a <code>voting bot</code> for a Reddit-like use. This bot controls 6 accounts. The problem I'm running into is when I run the section of code that checks if one of my accounts have already voted for the post.</p>
<p>Let's say account 5 has already voted for the post: </p>
<p>The current code stops the enumeration altogether, so account 6 never gets a chance to run through the checks. </p>
<p>If I change the <code>return False</code> to <code>continue</code>, account 5 attempts to vote and because it has already voted, the exception also stops the script altogether.</p>
<p>I have tried <code>break</code>, <code>pass</code>, etc. I'm thinking now that I may have an indentation problem. Surely it is an easy fix and I'm just missing something.</p>
</div>
<div class="post-text" itemprop="text">
<p>You might be looking for continue rather than break.
<a href="https://docs.python.org/3/reference/simple_stmts.html#continue" rel="nofollow noreferrer">https://docs.python.org/3/reference/simple_stmts.html#continue</a>
As continue only breaks out of the inner for, you might be able to re-structure the inner for as a generator.</p>
<pre><code> if account[k] in [avote['voter'] for avote in upvote_comment['active_votes']]:
    print("@%s %s ====&gt; Post Upvoted already by",  account[k])
    continue
</code></pre>
<p>I'm assuming that account[k] will only give one name here? </p>
</div>
<span class="comment-copy">4 spaces never killed anybody...</span>
<span class="comment-copy">not really sure what you're talking about</span>
<span class="comment-copy">I'm saying your code is a headache to read because you alternate between 1 and 2 spaces for indentation. Usually, 4 is explicitly recommended by the style guide for this reason.</span>
<span class="comment-copy">Oh, gotcha. I copied and pasted from my editor and I don't think it translated right. Any ideas on what I did wrong here (aside from spacing)?</span>
<span class="comment-copy">'# Checking if we already voted for this post:'             'names = account[k]'             for avote in upvote_comment['active_votes']:                 if (avote['voter'] in names):                     print("@%s %s ====&gt; Post Upvoted already by", account[k])                     return False  So in the instance above, I changed return False to continue, but continue just puts it into the for loop above the if loop, which leads it to the 'upvote_comment.vote(100, voter=account[k])'</span>
<span class="comment-copy">You're right, continue only continues with the innermost loop. I've added a differrent method of checking the voter account which might be what you're looking for.</span>
<span class="comment-copy">The problem I have is that if I 'return False', the enumeration stops and any iterations that have not run, won't run. I don't have a problem checking the voter account, it's just that I can't figure out a way to skip to the next enumeration when it comes back already voted.</span>
<span class="comment-copy">My bad, I meant to say continue. I've corrected the code above.</span>
<span class="comment-copy">By the way, this looks like it will vote with all (six) of the accounts (except any that have already voted). Is that what you wanted? (Just curious).</span>
