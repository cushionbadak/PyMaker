<div class="post-text" itemprop="text">
<p>Python's <code>id()</code> function returns the unique identifier for an object. So when in my terminal I do something like:</p>
<pre><code>&gt;&gt; a = 23
&gt;&gt; id(a)
28487496
</code></pre>
<p>Now, I know that python keeps track of all the objects created and number of references to that object and when the value reaches 0, the object is garbage collected.</p>
<p>What I want to know is that what happens when I do something like this:</p>
<pre><code>&gt;&gt; id(27)
28487498
</code></pre>
<p>I never created an object with value 27 i.e i never wrote <code>b=27</code> still somehow I get a unique identifier for this. Does this mean that an object was created in memory? If yes, even then there should be 0 references to this object and it should have been garbage collected.</p>
<p><strong>So, when is an Object actually created in Memory ?</strong></p>
<p>Please let me know if i am wrong somewhere.</p>
<p>Another interesting thing that I just found out is:</p>
<pre><code>&gt;&gt; a = 23
&gt;&gt; id(a)
28487496
&gt;&gt; id(20 + 3)
</code></pre>
<p>28487496</p>
<p>In this case Python remembers the reference to number 23 itself, how does Python do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Objects are created as needed, in different places.</p>
<p>To start, when you write</p>
<pre><code>b = 27
</code></pre>
<p><strong>two</strong> things happen. The <code>27</code> expression is evaluated, resulting in an integer object being pushed onto the stack, and then, as a separate step, the object is assigned to <code>b</code>. <strong>Assignment doesn't create objects</strong>.</p>
<p>If you did just this:</p>
<pre><code>27
</code></pre>
<p>The <code>27</code> expression is still evaluated. The object would be created<sup>*</sup>, then destroyed again as the reference count drops back to 0 again.</p>
<p>That's needed because you could pass that object to another function:</p>
<pre><code>id(27)
</code></pre>
<p>needs <em>something</em> to be passed to the <code>id()</code> function. So <code>27</code> is added to the stack so you can call the function.</p>
<p>I'll use a mutable object instead of an integer, to illustrate that a new object is created; so instead of <code>id(27)</code> I'll use <code>id([])</code> and ask the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a> to show me the bytecode that Python would execute:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(compile('id([])', '', 'exec'))
  1           0 LOAD_NAME                0 (id)
              2 BUILD_LIST               0
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE
</code></pre>
<p>The <a href="https://docs.python.org/3/library/dis.html#opcode-BUILD_LIST" rel="nofollow noreferrer"><code>BUILD_LIST 0</code> opcode</a> is used to create the empty list object and push it onto the stack, and <a href="https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION" rel="nofollow noreferrer"><code>CALL_FUNCTION 1</code></a> then calls <code>id</code> to passing in one value from the stack, which is that list.</p>
<p>I didn't use <code>id(27)</code> because <em>immutable objects</em> like integers and tuples and such are actually cached with the bytecode that is compiled; these are created when Python compiles the code (or when you load the <code>.pyc</code> bytecode cache from disk):</p>
<pre><code>&gt;&gt;&gt; dis.dis(compile('id(27)', '', 'exec'))
  1           0 LOAD_NAME                0 (id)
              2 LOAD_CONST               0 (27)
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
</code></pre>
<p>Note the <a href="https://docs.python.org/3/library/dis.html#opcode-LOAD_CONST" rel="nofollow noreferrer"><code>LOAD_CONST</code></a>, it loads the data from the <code>co_consts</code> structure:</p>
<pre><code>&gt;&gt;&gt; compile('id(27)', '', 'exec').co_consts
(27, None)
</code></pre>
<p>So objects can be created when compiling, or when execuning special opcodes for specific Python syntax.</p>
<p>There are more places:</p>
<ul>
<li>There are more opcodes, for creating lists, tuples, dictionaries, sets and strings, for example.</li>
<li>When you create an instance of a class, <code>type.__new__</code> will create an instance object on the heap. So <code>CustomClass(arg1, arg2)</code> creates an object with the right type.</li>
<li>The same applies to all built-in types; <code>int(somevalue)</code> creates an integer object on the heap.</li>
<li>Plenty of built-in functions will create new objects as needed, returning those from calls</li>
<li><code>class</code>, <code>def</code> statements and the <code>lambda</code> expression create objects (class objects, functions, and more functions, these are all objects too).</li>
</ul>
<hr/>
<p><sup>*</sup> Small integers are actually interned; for performance reasons, CPython keeps a single copy each of the integers between -5 and and 256, so these objects are actually created only once, and referenced everywhere you need one. See <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">"is" operator behaves unexpectedly with integers</a>. For the purposes of this answer I'm ignoring this.</p>
<p>And because they are interned, the result of <code>20 + 3</code> returns that single copy and the <code>id()</code> will still be the same as if you asked for <code>id(23)</code> directly.</p>
<p>There are more implementation details; there are many more. Some string objects are interned (see <a href="https://stackoverflow.com/questions/24245324/about-the-changing-id-of-an-immutable-string/24245514#24245514">my answer here</a>). Code evaluated in the interactive interpreter is compiled one top-level block at a time, but in a script compilation is done per scope instead. Because constants are attached to compiled code objects, that means that there are differences as to when constants are shared. Etc. etc.</p>
<p>The only objects you can rely on not being recreated all the time are explicitly documented in the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">datamodel documentation</a> as being singletons; <code>None</code> being the most prominent of these.</p>
</div>
<span class="comment-copy"><code>b = 27</code> does <b>two</b> things, it creates the object <i>and</i> assigns. <code>27</code> still creates the object.</span>
<span class="comment-copy">Now, for small integers, there is an exception: those are interned (one copy each is kept around, they are not created a-new, for performance and memory reasons), see <a href="//stackoverflow.com/q/306313">"is" operator behaves unexpectedly with integers</a></span>
<span class="comment-copy">It is important to note that making an assignment <i>is not</i> what creates an object.</span>
<span class="comment-copy">Integers from -5 to 256 (<i>Py27</i> specific) are cached, so they are singletones, so everytime you access one of them, it won't create a new object, but redirect to one from that cache.</span>
<span class="comment-copy"><i>"When you create an instance of a class, type.__new_</i> will create an instance object on the heap."_ - So would it be correct to say that <code>type.__new__()</code> is responsible for creating <i>all</i> objects in Python behind the scenes?</span>
<span class="comment-copy">@ChristianDean: it is responsible for all Python-defined types.</span>
<span class="comment-copy">@ChristianDean: For C objects, <code>type-&gt;tp_alloc()</code> is used.</span>
<span class="comment-copy">Alright, thanks for the clarification. I figured there was a difference between the Python and C level.</span>
<span class="comment-copy">@ChristianDean: under the covers, <code>type.__new__()</code> (the <code>type_new</code> C function) does use <code>type-&gt;tp_alloc()</code> somewhere, but there is a  lot of minutiae to take care of for Python types.</span>
