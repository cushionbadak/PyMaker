<div class="post-text" itemprop="text">
<p>I am adding different values to "repeated" with a loop:</p>
<pre><code>repeated=[]
for x in range(0,(length-1)):
    for y in range(1,(length)):
        if(x == y):
            pass
        else:    
            for i in path[0][x]:
                for j in path[0][y]:
                   if set(i) == set(j):
                       repeated.append((set(i),capacity[x]))
                       repeated.append((set(j),capacity[y]))
</code></pre>
<p>However, I am not sure which way is better to add them for the purpose I explain below:</p>
<pre><code>repeated.append((set(i),capacity[x]))
repeated.append([set(i),capacity[x]])
</code></pre>
<p>I am obtaining the following output:</p>
<pre><code>OUTPUT:
[({'H', 'B'}, 5), ({'H', 'B'}, 1), ({'C', 'B'}, 5), ({'C', 'B'}, 3), ({'B', 'A'}, 1), ({'B', 'A'}, 5), ({'B', 'A'}, 5), ({'B', 'A'}, 1)] 
</code></pre>
<p>I want to check now which values are the same (in this example {'H', 'B'} would be the same twice and {'C', 'B'} twice...) and add their numerical value to see which one is the maximum value (after the addition).</p>
<p>For this example, {'H', 'B'} = 6 (5+1), {'C', 'B'} = 8 (5+3) and {'B', 'A'} = 12 (1+5+5+1), so my output should be 12 (which is the maximum of the 3 values added up).</p>
<p>I do not know how to access "repeated" in order to do this.</p>
<p>Thank you so much!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> to group the elements and determine their total. The <code>Counter</code> also provides some functions for getting the most common elements. You have to convert the <code>set</code> to <code>frozenset</code>, though, so you can use them as keys in the dict.</p>
<pre><code>lst = [({'H', 'B'}, 5), ({'H', 'B'}, 1), ({'C', 'B'}, 5), ({'C', 'B'}, 3), ({'B', 'A'}, 1), ({'B', 'A'}, 5), ({'B', 'A'}, 5), ({'B', 'A'}, 1)] 

aggregated = collections.Counter()
for x, y in lst:
    aggregated[frozenset(x)] += y

print(aggregated)
# Counter({frozenset({'B', 'A'}): 12, frozenset({'B', 'C'}): 8, frozenset({'B', 'H'}): 6})
print(aggregated.most_common(1))
# [(frozenset({'B', 'A'}), 12)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is your data:</p>
<pre><code>repeated = [({'H', 'B'}, 5), ({'H', 'B'}, 1), ({'C', 'B'}, 5), ({'C', 'B'}, 3), ({'B', 'A'}, 1), ({'B', 'A'}, 5), ({'B', 'A'}, 5), ({'B', 'A'}, 1)]
</code></pre>
<p>The first task is to sum the corresponding values, as in  {'H', 'B'} = 6 (5+1).</p>
<pre><code>from collections import defaultdict
c = defaultdict(int)
for (k,v) in repeated:
    c[tuple(k)] += v
</code></pre>
<p>Now <code>c</code> looks like this:</p>
<pre><code>{('H', 'B'): 6, ('C', 'B'): 8, ('A', 'B'): 12}
</code></pre>
<p>And you want <code>max(6,8,12)</code>:</p>
<pre><code>print(max(c.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer by @tobias_k is great.
But if you prefer a solution without the use of Counters, then you can look at this:</p>
<pre><code>repeated = [({'H', 'B'}, 5), ({'H', 'B'}, 1), ({'C', 'B'}, 5), ({'C', 'B'}, 3), ({'B', 'A'}, 1), ({'B', 'A'}, 5), ({'B', 'A'}, 5), ({'B', 'A'}, 1)]
d = {}

for a, b in repeated:
    if d.get(frozenset(a)):
    d[frozenset(a)] = d[frozenset(a)] + b
else:
    d[frozenset(a)] = b
print (d)
# {frozenset({'B', 'H'}): 6, frozenset({'B', 'C'}): 8, frozenset({'B', 'A'}): 12}
</code></pre>
</div>
<span class="comment-copy">Hold on, you add a tuple and a list interleaved? Furthermore why does the capacity changes if you add the same element twice without changing <code>x</code>?</span>
<span class="comment-copy">Can you post the full <code>for</code> loop that you use to fill <code>repeated</code>? At least for me it's not quite clear, how the numerical values come about.</span>
<span class="comment-copy">I just edited and added the whole for loop!</span>
