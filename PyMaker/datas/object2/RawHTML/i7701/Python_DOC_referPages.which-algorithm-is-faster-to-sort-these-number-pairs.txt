<div class="post-text" itemprop="text">
<p>I wrote two solutions in python.. It is supposed to take a list of numbers and sort the ones that add up to a sum, both these return the same pairs, but which one is more efficient? I'm not sure if using python's count method does more work behind the scene making the second one longer</p>
<pre><code>numbers =  [1, 2, 4, 4, 4, 4, 5, 7, 7, 8, 8, 8, 9]

match = []
for i in range(len(numbers)):
    for j in range(len(numbers)):
        if (i!=j):
            if(numbers[i] + numbers[j] == sum):
                match.append([numbers[i], numbers[j]])


match2 = []

for i in range(len(numbers)):
    counterPart = abs(numbers[i] - sum)

    numberOfCounterParts = numbers.count(counterPart)

    if(numberOfCounterParts &gt;= 1):
        if(counterPart == numbers[i]):
            for j in range(numbers.count(counterPart)-1):
                match2.append([numbers[i], counterPart])
        else:
            for j in range(numbers.count(counterPart)):
                match2.append([numbers[i], counterPart])
</code></pre>
<p>Is there an even better solution that I'm missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>When comparing algorithms, you should compare their time complexities. Measuring the time is also a good idea, but heavily dependent on the input, which now is tiny.</p>
<hr/>
<p>The first algorithm takes:</p>
<blockquote>
<p>O(N<sup>2</sup>)</p>
</blockquote>
<p>because of the double for loop.</p>
<p>For the second algorithm, you should take into account that <code>count()</code> has a time complexity of <code>O(N)</code>. You have on for loop, and in its body <code>count()</code> will be called twice, once after <code>abs()</code> and once in whichever body of the if-else statement you go into. As a result the time complexity is <code>O(N) * 2 * O(N) = 2*O(N&lt;sup&gt;2&lt;/sup&gt;)</code>, which yields:</p>
<blockquote>
<p>O(N<sup>2</sup>)</p>
</blockquote>
<p>That means that both algorithm have the same time complexity. As a result it now has meaning to measure the performance, by running many experiments and taking the average of the time measurements, with big enough input to reflect performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's almost always useful to measure complexity of your algorithms.</p>
<p>Both of your algorithms has O(N^2) complexity, so there are almost  interchangeable in terms of performance. </p>
<p>You may improve your algorithm by keeping a mapping of value-index pairs.  It will reduce complexity to O(N), basically you'll have one loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can run test yourself using the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer"><code>timeit</code></a> module:</p>
<pre><code>t1 = timeit(setup='from __main__ import sort1, numbers',
            stmt='sort1(numbers)',
            number=1)
t2 = timeit(setup='from __main__ import sort2, numbers',
           stmt='sort2(numbers)',
           number=1)

print(t1)
print(t2)
</code></pre>
<p>also note that <code>sum</code> is a built-in and therefore not a good name for a variable...</p>
<p>there are way better algorithms for that! especially considering you have duplicates in your list.</p>
<hr/>
<p>here is a faster version that will only give you the matches but not the multiplicity of the matches:</p>
<pre><code>def sum_target(lst, target):
    # make list unique
    unique_set = set(lst)
    unique_list = list(unique_set)

    remainders = {number: target-number for number in unique_list}
    print(remainders)

    match = set()
    for a, b in remainders.items():
        if a == b and lst.count(a) &gt;= 2:
            match.add((a, b))
        else:
            if b in remainders:
                match.add(frozenset((a, b)))

    return match
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes there is better algorithm which can be used if you know <code>lower_bound</code> and <code>upper_bound</code> of the data. <code>Counting Sort</code> which takes <code>O(N)</code> time and space is not constant (which depends on the range of upper bound and lower bound).</p>
<p>Refer <a href="https://en.wikipedia.org/wiki/Counting_sort" rel="nofollow noreferrer">Counting Sort</a></p>
<p>PS: Counting Sort is not a comparison based sort algorithm. </p>
<p>Refer below sample code:</p>
<pre><code>def counting_sort(numbers, k):
    counter = [0] * (k + 1)
    for i in numbers:
        counter[i] += 1

    ndx = 0
    for i in range(len(counter)):
        while 0 &lt; counter[i]:
            numbers[ndx] = i
            ndx += 1
            counter[i] -= 1
</code></pre>
</div>
<span class="comment-copy">check it yourself, <a href="https://stackoverflow.com/a/7370824/3462319">stackoverflow.com/a/7370824/3462319</a></span>
<span class="comment-copy">Honestly, both of them are not efficient solutions, use dictionary is the way to go. Your algorithm is O(n^2).</span>
<span class="comment-copy">@Ding Would you suggest converting the list into a dict programmatically? Making the key the index?</span>
<span class="comment-copy">Loop through the list and for each number <code>x</code> use <code>sum-x</code> as the key and <code>x</code> as value. This way the you only need to go through the list once.</span>
<span class="comment-copy">@Ding are you sure this is the method I should take? Because I did some searching and found this <a href="https://stackoverflow.com/questions/3420937/algorithm-to-find-which-number-in-a-list-sum-up-to-a-certain-number" title="algorithm to find which number in a list sum up to a certain number">stackoverflow.com/questions/3420937/â€¦</a> which top answer uses a recursive function not using dicts</span>
<span class="comment-copy">Alright I figured that.. So how could I write a faster algorithm? Dict won't work because I need to check for duplicate values</span>
<span class="comment-copy">@joe that's another question. Accept an answer of the ones already posted, and if needed post a new question, or even better post in Code Review. ;)</span>
<span class="comment-copy">But then I won't be able to compare multiple duplicate values</span>
<span class="comment-copy">But I need duplicate values as well.. so making it unique isn't what I want.. some people are suggesting to use a dictonary</span>
<span class="comment-copy">getting the multiplicity back after you have the pairs that sum to your target value is fast &amp; easy.</span>
<span class="comment-copy">Wouldn't you then have to do another search to see how many times it appears though?</span>
<span class="comment-copy">that approach does not work! sorry. if the target is 12 and there are two 6es in the list the algorithm will not find it... i'll have another look at it.</span>
<span class="comment-copy">Could you edit your answer to use a clickable link instead of the url in a code block?</span>
<span class="comment-copy">How can that Counting Sort be applied in O(N) form to this problem?</span>
<span class="comment-copy">@barny numbers are in the range [1-9]</span>
<span class="comment-copy">What? I asked: please edit your answer with a precise explanation of how Counting Sort that you linked to can be applied to <i>this specific</i> problem and achieve O(N) performance? Bear in mind the comments on the question about how something that can in general produce O(N^2) results <i>can't</i> in general run in O(N) time.</span>
<span class="comment-copy">That code shows Counting Sort, but doesn't show how this can achieve &lt;O(N^2) on the question being asked.</span>
