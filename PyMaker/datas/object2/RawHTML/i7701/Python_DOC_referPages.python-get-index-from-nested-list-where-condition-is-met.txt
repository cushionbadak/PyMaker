<div class="post-text" itemprop="text">
<p>Please could someone help me with getting an index of an item in a nested list where a certain condition is met using Python 2.7?  I know that there are similar questions on StackOverflow about this but I can't seem to find good examples that deal with "nested" lists.</p>
<p>I have a list of data which is hundreds of thousands of lines long, in the format below:</p>
<pre><code>data =[
["","","","28.04.2015 09:34:38",1.52411,1.52428,17],
["","","","28.04.2015 09:34:40",1.52415,1.52433,18],
["","","","28.04.2015 09:34:42",1.52425,1.52444,19],
["","","","28.04.2015 09:34:44",1.52417,1.52435,18],
["","","","28.04.2015 09:34:46",1.52421,1.52440,19],
["","","","28.04.2015 09:34:48",1.52426,1.52446,20],
["","","","28.04.2015 09:34:50",1.52429,1.52444,15],
["","","","28.04.2015 09:34:58",1.52423,1.52441,18],
["","","","28.04.2015 09:35:00",1.52416,1.52434,18],
["","","","28.04.2015 09:35:02",1.52416,1.52433,17],
["","","","28.04.2015 09:35:04",1.52416,1.52434,18],
["","","","28.04.2015 09:35:06",1.52406,1.52422,16],
["","","","28.04.2015 09:35:10",1.52406,1.52421,15],
["","","","28.04.2015 09:35:14",1.52427,1.52444,17],
["","","","28.04.2015 09:35:16",1.52424,1.52443,19],
["","","","28.04.2015 09:35:18",1.52434,1.52453,19],
["","","","28.04.2015 09:35:20",1.52434,1.52451,17],
["","","","28.04.2015 09:35:22",1.52438,1.52456,18],
["","","","28.04.2015 09:35:24",1.52432,1.52451,19],
["","","","28.04.2015 09:35:28",1.52445,1.52464,19],
["","","","28.04.2015 09:35:34",1.52435,1.52451,16],
["","","","28.04.2015 09:35:36",1.52432,1.52449,17],
["","","","28.04.2015 09:35:38",1.52429,1.52448,19]]
</code></pre>
<p>For each row I want to compare the data in "column 5" (the first col of decimal numbers) to a certain value (lets use 1.52440 as an example) and return the index of the first row where the data is greater than my certain value.</p>
<p>I have made code that does this the 'traditional' way using a for-row-in-data type loop, but I would like to use a better (faster) method if possible and cannot seem to produce the expected result.</p>
<p>The rather poor attempt that I have made so far is:</p>
<pre><code>pricedata = [n[4] for n in data]
myindex = (x for x in enumerate(pricedata) if x &gt; 1.5440).next()
</code></pre>
<p>The first row extracts the price data col as a new list.  I am not sure this is really necessary but as my understanding of list comprehensions is poor I was trying to break things into steps I understand.</p>
<p>I dont really understand what the second line is doing, but it seems to return (0, 1.52411) - the first item in the list - regardless of what comparison value I enter.</p>
<p>I have also tried:</p>
<pre><code>myindex = [x for x in enumerate(pricedata) if x &gt; 1.5440][0]
</code></pre>
<p>and it seems to produce the same result.</p>
<p>I thought the comprehension was saying:</p>
<p>"Make a list of price's for each price you look at in the list-of-indexed-prices if the price-you-are-looking-at is greater than 1.5440", but it seems I am mistaken!</p>
<p>Please could someone point out the error of my ways and help me out?  Thank you for any assistance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Problem is, you're comparing a tuple with a float, since <a href="https://docs.python.org/3.6/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> returns tuples of the index and item, however, tuples are deemed <strong>greater</strong> than floats in Python 2:</p>
<pre><code>&gt;&gt;&gt; () &gt; 4.
True
</code></pre>
<p>Therefore, the first tuple produced by <code>enumerate</code> always yields a match.</p>
<hr/>
<p>To solve this, you should instead <em>unpack</em> the tuple first, and return the first matching index from your generator expression using <code>next</code>:</p>
<pre><code>next(i for i, x in enumerate(data) if x[4] &gt; 1.52415)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are misusing <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a>. It iterates over the sequence/iterator you provide it and yields index/value couples.</p>
<p>Try this instead:</p>
<pre><code>myindex = next(index for index, row in enumerate(data) if row[5] &gt; 1.52440)
</code></pre>
<p>The</p>
<pre><code>(i for i, row in enumerate(data) if row[4] &gt; 1.52440)
</code></pre>
<p>part is a generator, it yields indexes of rows meeting the condition.</p>
<p><code>next</code> iterates over this generator until the first row is returned.</p>
<p>Because his uses a generator rather than an intermediary list, you don't have to go through the whole list. The search stops after the first row is found that matches the condition. This can be important when the table has many rows, like yours.</p>
<p>Note that you'll get a <code>StopIteration</code> exception if no matching row is found. If you want to get a specific value in this case (e.g. <code>None</code>), you may pass it as a second argument to <code>next</code>:</p>
<pre><code>myindex = next((index for index, row in enumerate(data) if row[5] &gt; 1.52440), None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be achieved by splitting the enumrator into index and value:</p>
<pre><code>try:
    first_index = (index for index, data in enumerate(data)
                   if data[4] &gt; 1.52415).next()
except StopIteration:
    first_index = -1
</code></pre>
<p>The <code>StopIteration</code> section is executed when no item in the list matches the predicate.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>data=[[0,0,0,0,0,0],[1,0,0,0,0,0],[0,0,0,0,0,0],[1,0,0,0,0,0],[0,0,0,0,0,0],[1,0,0,0,0,0],[0,0,0,0,0,0]]
for index, value in enumerate(data):
    if value[0] &gt; 0:
        print(index)
        break
</code></pre>
</div>
<span class="comment-copy">your list doesn't seem to be sorted</span>
<span class="comment-copy">And maybe manage the "no matching row" case by passing a default value to next.</span>
<span class="comment-copy">@Jérôme Depends. They can silence the error if they want to by passing a default, however, an error is sometimes desirable.</span>
<span class="comment-copy">You're right. However, it might be worth mentioning StopIteration when introducing next, then. But I agree that the use of the default value does not have to be automatic.</span>
<span class="comment-copy">Thank you Moses and everyone else who has responded so quickly to my question.  The responses are great and have fixed the problem - I used a combination of Moses code above and the ", None)" exception catcher that Jerome suggested in his answer.  It's difficult to know whether to be more astounded by the fact that Python seems to be such a powerful language, or by the fact that there are programmers who know it so well.  I've been programming for a few weeks now, coming from a VBA (Excel) background and its possible to do so much in Python with so little code!  Thanks again for the responses!</span>
<span class="comment-copy">@Paul You're welcome. I coded Excel VBA macros back in the days too, so you're in good company :) <a href="https://docs.python.org/3/reference/index.html" rel="nofollow noreferrer">The Python docs</a>, more than the proficiency of coders or power of the language itself also make the language very desirable and highly useful. Be sure to pour over those.</span>
<span class="comment-copy">Using next((generator), None), you would provide next a default value and you wouldn't have to catch StopIteration.</span>
<span class="comment-copy">I meant next((generator), -1) in your case.</span>
<span class="comment-copy">You could at least break after the first good row is found.</span>
<span class="comment-copy">Yeah, I forgot the op asked only for the first match. Thank you</span>
<span class="comment-copy">While this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.</span>
