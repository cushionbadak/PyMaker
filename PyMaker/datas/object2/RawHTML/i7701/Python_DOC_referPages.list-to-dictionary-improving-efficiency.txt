<div class="post-text" itemprop="text">
<p>I am attempting to create a function that takes a 2 dimensional list and return a dictionary. I am wondering if there is a more efficient way instead of what I have written (e.g. list comprehension / itertools?) I am relatively new to python and have read some examples on list comprehension and itertools doc (<a href="http://(https://stackoverflow.com/questions/16548668/iterating-over-a-2-dimensional-python-list)" rel="nofollow noreferrer">https://stackoverflow.com/questions/16548668/iterating-over-a-2-dimensional-python-list</a>) but can't seem to implement it to this chunk of code.</p>
<p>Any help would be appreciated. Thank you!</p>
<pre><code>def listToDict(self, lstInputs):        
    dictOutput = dict()
    rows = len(lstInputs)
    cols = len(lstInputs[0])
    if rows == 2:
        for x in range(rows):
            if lstInputs[0][x] is not None:
                if lstInputs[1][x] is not None:
                    dictOutput[lstInputs[0][x].strip()] = lstInputs[1][x].strip()
                else:
                    dictOutput[lstInputs[0][x].strip()] = lstInputs[1][x]
    elif cols == 2:
        for x in range(rows):
            if lstInputs[x][0] is not None:
                if lstInputs[x][1] is not None:
                    dictOutput[lstInputs[x][0].strip()] = lstInputs[x][1].strip()
                else:
                    dictOutput[lstInputs[x][0].strip()] = lstInputs[x][1]
    else:
        pass

    return dictOutput
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your function is doing way too many things:</p>
<ol>
<li><p>Trying to find out if it's input is a sequence of key=&gt;value pairs or a pair of keys, values sequences. It's unreliable. Don't try to guess, it's the caller's duty to pass the right structure, because only the caller knows what data he wants to turn into a dict.</p></li>
<li><p>Cleaning (currently striping) keys and vals. Here again it only makes sense if both are strings, which is not garanteed to be the case (at least not from the function's name nor documention...). You could of course test if your keys and/or values are indeed strings but this adds quite some overhead. Here again it's the caller's duty to do the (eventual) cleaning.</p></li>
</ol>
<p>To make a long story short, your function should only expect a single data structure (either a sequence of key=&gt;value pairs or a pair of (keys, values) sequence, and not apply any cleanup, leaving on the caller the responsability to provide what's expected.</p>
<p>Actually, building a <code>dict</code> from a sequence (or any iterable) of pairs is actually so trivial that you don't need a special function, it's just a matter of passing the sequence to the <code>dict</code> constructor:</p>
<pre><code>&gt;&gt;&gt; lst_of_pairs = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
&gt;&gt;&gt; dict(lst_of_pairs) 
{0: 'a', 1: 'b', 2: 'c', 3: 'd'}
</code></pre>
<p>Or on more recent python versions using a dict comprehension which can faster:</p>
<pre><code>&gt;&gt;&gt; lst_of_pairs = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
&gt;&gt;&gt; {k:v for k, v in lst_of_pairs} 
{0: 'a', 1: 'b', 2: 'c', 3: 'd'}
</code></pre>
<p>So well, your first building block is builtin and dont need any special func.</p>
<p>Note that this works with any iterable as long as 1. it yields only pairs and 2. the keys (first items of the pairs) are uniques. So if you want to apply some cleaning before building the dict, you can do it with a generator function or expression, ie if the caller knows all the keys are strings and might need striping and all the values are either strings needing striping or <code>None</code>, you can pass a generator expression instead of the source list, ie:</p>
<pre><code>&gt;&gt;&gt; lst_of_pairs = [(" a ", "1 "), ("b ", None), ("c", " fooo ")]
&gt;&gt;&gt; {k.strip(): v if v is None else v.strip() for k, v in lst_of_pairs}
{'a': '1', 'c': 'fooo', 'b': None}
</code></pre>
<p>Finally, transposing a pair of keys, values sequences to a sequence of key=&gt;value pairs is what the builtin <code>zip()</code> and it's lazy version <code>itertools.izip()</code> are for:</p>
<pre><code>&gt;&gt;&gt; keys = [' a ', 'b ', 'c']
&gt;&gt;&gt; values = ['1 ', None, ' fooo ']
&gt;&gt;&gt; zip(keys, values)
[(' a ', '1 '), ('b ', None), ('c', ' fooo ')]
&gt;&gt;&gt; list(itertools.izip(keys, values))
[(' a ', '1 '), ('b ', None), ('c', ' fooo ')]
</code></pre>
<p>Putting it together, the most "devious" case (building a dict from a sequence of keys and a sequence of values, applying striping to keys and conditionnaly applying striping to values) can be expressed as:</p>
<pre><code>&gt;&gt;&gt; {k.strip(): v if v is None else v.strip() for k, v in itertools.izip(keys, values)}
{'a': '1', 'c': 'fooo', 'b': None}
</code></pre>
<p>If it's for a one-shot use, that actually all you need.</p>
<p>Now if you have a use case where you know you will have to apply this from different places in your code with always the same cleaning but either lists of pairs or pairs of lists, you of course want to factor it out as much as possible - but not more:</p>
<pre><code>def to_dict(pairs):
    return {
        k.strip(): v if v is None else v.strip()) 
        for k, v in lst_of_pairs
        }
</code></pre>
<p>and then leave it to the caller to apply <code>zip()</code> before if needed:</p>
<pre><code>def func1():
    keys = get_the_keys_from_somewhere()
    values = get_the_values_too()
    data = to_dict(itertools.izip(keys, values))
    do_something_with(data)


def func2()
   pairs = get_some_seqence_of_pairs()
    data = to_dict(pairs)
    do_something_with(data)
</code></pre>
<p>As to wether you want to use <code>zip()</code> or <code>itertools.izip()</code>, it mostly depends on your Python version and your inputs. </p>
<p>If you're using Python 2.x, <code>zip()</code> will build a new list in memory while <code>itertools.izip()</code> will build it lazily, so there's a slight performance overhead from using <code>itertools.izip()</code> but it will save a lot of memory if you're working large datasets.</p>
<p>If you're using Python3.x, <code>zip()</code> has been turned into an iterator, sus replacing <code>itertools.izip()</code> so the question becomes irrelevant ;)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = [[1,2,3],['a','b','c']]

def function(li):
    d = {}
    for num in zip(li[0],li[1]):
        d[num[0]] = num[1]
    print(d)
function(l)
out put:
{1: 'a', 2: 'b', 3: 'c'}
</code></pre>
</div>
<span class="comment-copy">Can you provide an example list?</span>
<span class="comment-copy">@JanZeiseweis hi! thanks for your reply! I have read some examples at <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.zip_longest</a> and <a href="http://jmduke.com/posts/a-gentle-introduction-to-itertools/" rel="nofollow noreferrer">jmduke.com/posts/a-gentle-introduction-to-itertools</a> but can't seem to find 1 that would help this. if i were to chain the list, I cant think of how to assign the key-value pair to the dictionary when looping</span>
<span class="comment-copy">Please show an example of input and output.</span>
<span class="comment-copy">I was actually asking for an example list that you'd like to convert to a dict.</span>
<span class="comment-copy">Here is a cross-reference where this is already answered. <a href="https://stackoverflow.com/questions/30387014/make-dictionary-from-2d-array-python" title="make dictionary from 2d array python">stackoverflow.com/questions/30387014/â€¦</a></span>
<span class="comment-copy">dict comprehension and generator expression...thank you so much for taking the time to answer this in details!</span>
<span class="comment-copy">can that idea work out for you</span>
<span class="comment-copy">would it be possible to demonstrate how to implement this with [ [1,'a'], [2, 'b'] ..] instead? apologies!</span>
