<div class="post-text" itemprop="text">
<p>According to <code>help(getattr)</code>, two or three arguments are accepted:</p>
<pre><code>getattr(...)
    getattr(object, name[, default]) -&gt; value
</code></pre>
<p>Doing some simple tests, we can confirm this:</p>
<pre><code>&gt;&gt;&gt; obj = {}
&gt;&gt;&gt; getattr(obj, 'get')
&lt;built-in method get of dict object at 0x7f6d4beaf168&gt;
&gt;&gt;&gt; getattr(obj, 'bad', 'with default')
'with default'
</code></pre>
<p>Too few/too many arguments also behave as expected:</p>
<pre><code>&gt;&gt;&gt; getattr()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: getattr expected at least 2 arguments, got 0
&gt;&gt;&gt; getattr(obj, 'get', 'with default', 'extra')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: getattr expected at most 3 arguments, got 4
</code></pre>
<p>The argument names specified in the help text do not seem to be accepted as keyword arguments:</p>
<pre><code>&gt;&gt;&gt; getattr(object=obj, name='get')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: getattr() takes no keyword arguments
</code></pre>
<p>The <code>inspect</code> module is no help here:</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; inspect.getargspec(getattr)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python2.7/inspect.py", line 816, in getargspec
    raise TypeError('{!r} is not a Python function'.format(func))
TypeError: &lt;built-in function getattr&gt; is not a Python function

(messaging is a little different in python3, but the gist is the same)
</code></pre>
<p>Now, the question: Is there a straightforward way to write my own Python function with a signature that behaves exactly like <code>getattr</code>'s signature? That is, keyword arguments are not allowed, and minumum/maximum number of arguments are enforced? The closest I've come is the following:</p>
<pre><code>def myfunc(*args):
    len_args = len(args)
    if len_args &lt; 2:
        raise TypeError('expected at least 2 arguments, got %d' % len_args)
    elif len_args &gt; 3:
        raise TypeError('expected at most 3 arguments, got %d' % len_args)
    ...
</code></pre>
<p>But now instead of meaningful argument names like <code>object</code> and <code>name</code> we get <code>args[0]</code> and <code>args[1]</code>. It's also a lot of boilerplate, and feels downright unpleasant. I know that, being a builtin, <code>getattr</code> must have vastly different implementation than typical Python code, and perhaps there's no way to perfectly emulate the way it behaves. But it's a curiosity I've had for a while.</p>
</div>
<div class="post-text" itemprop="text">
<p>This code ticks most of your requirements:</p>
<pre><code>def anonymise_args(fn):
    @functools.wraps(fn)
    def wrap(*args):
        return fn(*args)
    return wrap


@anonymise_args
def myfunc(obj, name, default=None):
    print obj, name, default
</code></pre>
<ul>
<li><p>keyword arguments are not allowed</p>
<pre><code>x.myfunc(obj=1, name=2)
TypeError: wrap() got an unexpected keyword argument 'obj'
</code></pre></li>
<li><p>A minumum/maximum number of arguments are enforced</p>
<pre><code>x.myfunc(1,2,3,4)
TypeError: myfunc() takes at most 3 arguments (4 given)
</code></pre></li>
<li><p>meaningful argument names</p></li>
<li><p>not a lot of boilerplate</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>These kinds of function signatures are particular to functions written in C, using the C-level <a href="https://docs.python.org/3/c-api/arg.html" rel="nofollow noreferrer"><code>PyArg_Parse*</code></a> family of functions and the <a href="https://docs.python.org/3/howto/clinic.html" rel="nofollow noreferrer">Argument Clinic</a> preprocessor. There's no built-in way to write that kind of signature in Python. The closest you can get is what you already came up with, using <code>*args</code>.</p>
<p>(As an aside, there <em>is</em> already syntax picked out in case they <em>do</em> decide to implement this functionality, described in <a href="https://www.python.org/dev/peps/pep-0457/" rel="nofollow noreferrer">PEP 457</a>, but for now, that syntax is only used in documentation, and a slight variant is used in Argument Clinic.)</p>
</div>
<span class="comment-copy">@Makoto: Not a duplicate; optional arguments are easy, but this question is specifically looking for positional-only argument behavior as well.</span>
<span class="comment-copy">Did you leave out <code>functools.wraps</code> in your tests? The first error message doesn't look right.</span>
<span class="comment-copy">Also, you should probably <code>return</code> in <code>wrap</code> to correctly pass through return values when wrapping functions with meaningful return values.</span>
<span class="comment-copy">1) I did include <code>functools.wraps</code> in my tests. I don't know why the error message includes <code>wrap()</code>. 2) Yes, <code>wrap</code> should include <code>return</code>.</span>
<span class="comment-copy"><a href="https://github.com/python/cpython/blob/4a8bcdf79cdb3684743fe1268de62ee88bada439/Python/ceval.c#L4014" rel="nofollow noreferrer">Apparently it's using the code object's <code>co_name</code> instead of the function object's <code>__name__</code>, so it still gets the original name.</a></span>
<span class="comment-copy">That reusability is nice. I especially like how I get to rely on the default value pattern, which is readable and familiar.</span>
<span class="comment-copy">But it can usually be done.</span>
<span class="comment-copy">@martineau: As far as I'm aware, the closest you can get is to parse <code>*args</code> manually, which is what the questioner already came up with.</span>
<span class="comment-copy">Yes, but the way they're doing it may not the simplest. For the particular example in their question, seems to me like a simple <code>def myfunc(obj, name, default=None):</code> would sufficeâ€”although they would need to replace the <code>None</code> with some sort of unique value if it was a legal argument value. This is also easy to do...</span>
<span class="comment-copy">@martineau: They're specifically looking to replicate positional-only argument behavior, not just optional arguments. Optional arguments are easy.</span>
<span class="comment-copy">In that case a <code>def myfunc(obj, name, *args):</code> with a check in the body to make sure the length of <code>args</code> was <code>1</code> would seem meet most of the OP's requirements.</span>
