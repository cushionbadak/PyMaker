<div class="post-text" itemprop="text">
<p>EDIT: </p>
<p>I have created a module (as a part of my pypi <code>parmatter</code> package) to provide this functionality. It has not been pushed to the package yet but can be obtained <a href="https://github.com/Ricyteach/parmatter/blob/master/src/parmatter/minilang.py" rel="nofollow noreferrer">here</a>. </p>
<h2>Original Question</h2>
<p>I need to be able to parse format strings (as specified by the <a href="https://docs.python.org/3.4/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">string format specification mini language</a>). A project I'm working on makes heavy use of the <a href="https://pypi.python.org/pypi/parse" rel="nofollow noreferrer"><code>parse</code></a> module for "unformatting" of strings. The module allows for creating customized format codes/formulas. My intent is to automatically parse certain kinds of format strings in a manner somewhat consistent with the existing string format specification mini language. </p>
<p>To clarify: by "format strings", I mean those strings that are used when using the <code>format</code> function and <code>format</code> method of <code>str</code> objects, e.g.: </p>
<pre><code>'{x!s: &gt;5s}'.format('foo') # the format string is ' &gt;5s'
</code></pre>
<p>I have taken a look at the <a href="https://github.com/python/cpython/blob/master/Lib/string.py" rel="nofollow noreferrer">cpython string module</a> and line # 166 looks to me like it is saying that parsing of the format string is handled in the <code>_string</code> module.  </p>
<pre><code># The overall parser is implemented in _string.formatter_parser.
</code></pre>
<p>This occurs at this line (# 278):</p>
<pre><code>return _string.formatter_parser(format_string)
</code></pre>
<p>I am pretty unfamiliar with the cPython code base and am not much of a C programmer, and I could not find the <code>_string</code> module. I am wondering if it is implemented at the C language level...? </p>
<p>Main question: is the format specification parsing implementation exposed somewhere for use? How can I get to it so I don't have to write my own? I am looking to get output something like this: </p>
<pre><code>&gt;&gt;&gt; parse_spec(' &gt;5.2f')
{'fill': ' ', 'align': '&gt;', 'sign': None, '#': None, '0': None, 'width': 5, ',': None, 'precision': 2, 'type': 'f'}
</code></pre>
<h2>EDIT</h2>
<p>Note that the comments say that, despite its name, <code>_string.formatter_parser</code> does not do what I am after. </p>
<pre><code># returns an iterable that contains tuples of the form:
# (literal_text, field_name, format_spec, conversion)
# literal_text can be zero length
# field_name can be None, in which case there's no
#  object to format and output
# if field_name is not None, it is looked up, formatted
#  with format_spec and conversion and then used
def parse(self, format_string):
    return _string.formatter_parser(format_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The format specification is specific to each object; it is parsed by the <a href="https://docs.python.org/3/reference/datamodel.html#object.__format__" rel="nofollow noreferrer"><code>__format__()</code> method</a> of an object. For example, for string objects, that method is implemented in C as the <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/unicodeobject.c#L13744-L13765" rel="nofollow noreferrer"><code>unicode__format__</code> function</a>.</p>
<p>A lot of the format is shared between object types, and so is the code to handle it. The <a href="https://github.com/python/cpython/blob/v3.6.1/Python/formatter_unicode.c" rel="nofollow noreferrer"><code>formatter_unicode.c</code> file</a> handles most format-string parsing. Within this file, the <a href="https://github.com/python/cpython/blob/v3.6.1/Python/formatter_unicode.c#L156-L324" rel="nofollow noreferrer"><code>parse_internal_render_format_spec()</code> function</a> does most of the parsing.</p>
<p>Unfortunately, this function is not exposed to Python code. Moreover, it is declared as <code>static</code>, so you can't access it externally (for instance, via a <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer"><code>ctypes</code> wrapper</a>), either. Your only options are to either re-implement it, or to re-compile your Python source code with the <code>static</code> keyword removed from the function, and then access it via the shared library.</p>
</div>
<div class="post-text" itemprop="text">
<p>For anyone else who comes upon this question needing to do this, here is a regex I came up with to match what I'm calling a format string (this <a href="https://www.youtube.com/watch?v=abrcJ9MpF60" rel="nofollow noreferrer">PyCon 2017 talk</a> was invaluable in my being able to come up with this so quickly!): </p>
<pre><code>r=r'([\s\S]?[&lt;&gt;=\^])?[\+\- ]?[#]?[0]?\d*[,]?(\.\d*)?[sbcdoxXneEfFgGn%]?'
import re
c=re.compile(r)
</code></pre>
<p>That should match any valid string as specified by the string format specification mini language. I have done some limited testing and it seems to work. </p>
<p>Now I need to take this and figure out how to parse out all the pieces of data I need. Will update when I figure out how to do that. </p>
<p>EDIT: </p>
<p>I've almost got it. The trick is to add group markers to the regex (i.e., parentheses) so you can access them later. This seems to work well: </p>
<pre><code>r=r'([\s\S]?[&lt;&gt;=\^])?([\+\- ])?([#])?([0])?(\d)*([,])?(\.\d*)?([sbcdoxXneEfFgGn%])?'

from collections import namedtuple as nt
FormatSpec = nt('FormatSpec', 'fill_align sign alt zero_padding width comma precision type')

import re
spec = FormatSpec(*re.search(r,'x&gt;5.2f').group(1,2,3,4,5,6,7,8))
</code></pre>
<p>This results in:</p>
<pre><code>FormatSpec(fill_align='x&gt;', sign=None, alt=None, zero_padding=None, width='5', comma=None, precision='.2', type='f')
</code></pre>
<p>I'd like to figure out how to access the fill and align characters separately, and to get rid of the decimal marker in the <code>precision</code> portion, but this is a good start. </p>
<p>EDIT: </p>
<p>Nested groups are created and accessed by just adding the additional parentheses; they are assigned a group number in the order they are encountered:</p>
<pre><code>r=r'(([\s\S])?([&lt;&gt;=\^]))?([\+\- ])?([#])?([0])?(\d)*([,])?((\.)(\d)*)?([sbcdoxXneEfFgGn%])?'

from collections import namedtuple as nt
FormatSpec = nt('FormatSpec', 'fill align sign alt zero_padding width comma precision type')

import re
spec = FormatSpec(*re.search(r,'x&gt;5.2f').group(2,3,4,5,6,7,8,11,12)) # skip groups not interested in
</code></pre>
<p>Results in this, which is exactly what I'm after:</p>
<pre><code>FormatSpec(fill='x', align='&gt;', sign=None, alt=None, zero_padding=None, width='5', comma=None, precision='2', type='f')
</code></pre>
<p>EDIT: </p>
<p>It seems to actually be better to <em>include</em> the decimal character in the <code>FormatSpec</code> tuple (separately) because the format specification can then be reconstructed directly: </p>
<pre><code>r=r'(([\s\S])?([&lt;&gt;=\^]))?([\+\- ])?([#])?([0])?(\d)*([,])?((\.)(\d)*)?([sbcdoxXneEfFgGn%])?'

from collections import namedtuple as nt
FormatSpec = nt('FormatSpec', 'fill align sign alt zero_padding width comma decimal precision type')

import re
spec = FormatSpec(*re.fullmatch(r,'x&gt;5.2f').group(2,3,4,5,6,7,8,10,11,12)) # skip groups not interested in
</code></pre>
<p>Additionally, I have changed to the <code>r.fullmatch</code> method (rather than <code>search</code> or <code>match</code>) so that the pattern has to be matched exactly. </p>
<p>Now we can do this to reconstruct the provided format spec: </p>
<pre><code>''.join(s for s in spec if s is not None)
# 'x&gt;5.2f'
</code></pre>
</div>
<span class="comment-copy">I'd just write the regex and be done with it. I'm pretty sure what you're looking for isn't exposed in any way.</span>
<span class="comment-copy">I don't know s--- about regex. Should probably finally get around to watching <a href="https://www.youtube.com/watch?v=abrcJ9MpF60" rel="nofollow noreferrer">this PyCon talk.</a></span>
<span class="comment-copy">This is what I was afraid of. Time to learn something new I guess.</span>
<span class="comment-copy">It's <code>static</code>, so I don't think ctypes can even get at it.</span>
<span class="comment-copy">@user2357112 But what if I want it bad enough?</span>
<span class="comment-copy">@user2357112: ah, indeed, <code>pythonapi.parse_internal_render_format_spec</code> raises <code>AttributeError: dlsym(RTLD_DEFAULT, parse_internal_render_format_spec): symbol not found</code>. Indeed, static functions are not exported.</span>
