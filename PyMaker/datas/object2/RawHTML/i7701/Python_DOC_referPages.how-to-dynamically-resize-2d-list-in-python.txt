<div class="post-text" itemprop="text">
<p>I am creating a large array of elements in python that I will print to an Excel spreadsheet. The order and the final dimensions are somewhat predictable, but hard-coding them in is inherently fragile. I want to find a way to dynamically resize the array if it's not big enough.</p>
<p>The order that elements will be added may not be sequential, so append doesn't work directly. I need to be able to assign any element in a 2D array, and have the array resized to handle it, like the following:</p>
<pre><code>data = magic_array()
data[3][5] = 35
</code></pre>
<p>Is there in-built functionality that will allow this behaviour? If not, can you recommend a good way to implement it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You <em>could</em> create a custom <code>DefaultList</code> class, similar to <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> in that it takes a <code>default_factory</code> argument:</p>
<pre><code>class DefaultList(list):

    def __init__(self, default_factory, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.default_factory = default_factory

    def _extend(self, index):
        while len(self) &lt;= index:
            self.append(self.default_factory())

    def __getitem__(self, index):
        self._extend(index)
        return super().__getitem__(index)

    def __setitem__(self, index, value):
        self._extend(index)
        super().__setitem__(index, value)
</code></pre>
<p>And to use it in your case, you create a two-dimensional instance, where the <code>default_factory</code> just creates another <code>DefaultList(int)</code>:</p>
<pre><code>&gt;&gt;&gt; L = DefaultList(lambda: DefaultList(int))
&gt;&gt;&gt; L[3][2] = 1
&gt;&gt;&gt; L
[[], [], [], [0, 0, 1]]
</code></pre>
<hr/>
<p>Although I prefer to use a <code>defaultdict</code> with 2D tuples as keys:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; d = collections.defaultdict(int)
&gt;&gt;&gt; d[2, 3] = 1
&gt;&gt;&gt; d[0, 0]
0
&gt;&gt;&gt; d[2, 3]
1
</code></pre>
<p>This takes way less memory than the <code>DefaultList</code>, and should be faster too, since it only creates the elements we actually access (as opposed to everything between index 0 and the one we're accessing). You just need to create a custom <code>__str__</code> method if you need to print it out as a 2D map, but I'll leave that to you.</p>
<p>Another upside of this approach is that you can have a point <code>P = (x, y)</code> and you don't have to do <code>L[P[1]][P[0]]</code> to access an element, but you can just do <code>d[P]</code> since the keys <em>are</em> the points. Oh, and because of this you access them in the natural order with <code>x</code> before <code>y</code>, so that:</p>
<pre><code>L[2][1] == d[1, 2]
</code></pre>
<p>Where <code>x=1</code> and <code>y=2</code></p>
</div>
<div class="post-text" itemprop="text">
<p>To add to the excellent answer of @MarkusMeskanen, it is fairly easy to convert from a default dict to a list of lists:</p>
<pre><code>def to_array(d):
    m = max(d.keys())[0]
    n = max(d.keys(),key = lambda x: x[1])[1]
    A = []
    for i in range(m+1):
        A.append([0]*(n+1))
    for i,j in d.keys():
        A[i][j] = d[i,j]
    return A
</code></pre>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; d[3,2] = 5
&gt;&gt;&gt; to_array(d)
[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 5]]
</code></pre>
<p>The advantages that he lists for default dicts outweigh the disadvantage of needing to use the above function when you are done loading the data, especially since you might need to do some conversion given the other approach since potentially some of the rows might be empty and need to be expanded.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to send data to a 2-dimensional sink. But that does not mean your program needs to use a 2-dimensional data structure. You have already discovered that a list of lists is unwieldy for what you want to do.</p>
<p>Abandon the 2-dimensional data structure and store your data internally as a <code>dict</code> with (x,y) tuples for keys.</p>
<pre><code>mydict = {}
mydict [(3,5)] = 35
</code></pre>
<p>At the point where you want to populate your Excel spreadsheet, loop through the <code>dict</code> </p>
<pre><code>for (row,col), data in mydict.items():
    # update Excel row 3, column 5 with 35
</code></pre>
<p>This will work just as well in the other direction.</p>
</div>
<span class="comment-copy">It's not clear what you are asking. Python lists do automatically resize if you append to them.</span>
<span class="comment-copy">arrays in python are dinamically resized. you just have to ".append()" to them</span>
<span class="comment-copy">The two-dimensional access here is confusingâ€¦ probably the simpler example would be <code>data = list(); data[42] = 35</code>, where <code>42</code> is unpredictable, correct?</span>
<span class="comment-copy">Yes he does, if it's a 2D list. @caot</span>
<span class="comment-copy">You could look into <code>numpy</code> arrays, which have a <code>resize()</code> method. Also -- if the final dimensions are somewhat predictable, why not initialize a sufficiently large array and then cut it down to size at the end?</span>
<span class="comment-copy">Thanks! I think that's exactly what I was looking for. Can you please explain how the default_factory part works?</span>
<span class="comment-copy">While this is nice (+1),  a slightly more useful class would have the first three rows in the final <code>L</code> look like <code>[0,0,0]</code> each.</span>
<span class="comment-copy">@JohnColeman Fair enough, but that's quite a lot of work and this should be enough to help OP to do the rest.. I think.</span>
<span class="comment-copy">@PProteus You give the list a callable as an argument, for example: <code>L = DefaultList(int)</code> and now when I access an "invalid" index like <code>L[2]</code>, it will fill all the indexes in between so that <code>L[0] = default_factory()</code> and <code>L[1] = default_factory()</code>, in this example <code>default_factory</code> was <code>int</code> so we'd end up with <code>L[0] = int()</code> and <code>L[1] = int()</code></span>
<span class="comment-copy">@MarkusMeskanen It would be a lot of work for something that probably isn't the most efficient way to go. In any event, I like your <code>defaultdict</code> idea better, especially because it is easy enough to convert such a thing into a list of lists before sending it to Excel.</span>
<span class="comment-copy">That might work in this example, however, the reason I'm storing the data in a 2D array instead of writing directly to Excel is because I want to reduce the number of time-consuming Excel calls that I make. I will print the array in one call at the conclusion of this part of the code.</span>
<span class="comment-copy">From "time-consuming Excel calls" I deduce you are using COM to talk to Excel. I did not know anyone still remembered how to do that. I'm afraid I assumed you would be using something fashionable from the <code>xlwt</code>/<code>xlswriter</code>/<code>xlwings</code> constellation.</span>
<span class="comment-copy">Don't care for fashion.</span>
