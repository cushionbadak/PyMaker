<div class="post-text" itemprop="text">
<p>i have this function</p>
<pre><code>def f(l):
    stack = []
    for i in range(len(l)):
        if i == 0:
            n0 = some_function(l[0], l[0])
            stack.append(n0)
        else:
            n = some_function(l[i], stack[-1])
            stack.append(n)
    return stack
</code></pre>
<p>where some_function takes 2 floats does some simple math operation and returns a float.
the problem is that the length of the argument of f is potentially big and i must loop n times over the result, i.e:</p>
<pre><code>l = [float_0, float_1, ..., float_m]
for i in range(n):
    l = f(l)
</code></pre>
<p>the question is, how to make this simple algorithm faster? i know that map improves "speed" a bit, but i dont know how to use it in this case. 
of corse any othre ideas are usefull.
thank you very much !!!</p>
<p>(if i have some lenguage mistake, be indulgent, english is not my native tongue)</p>
</div>
<div class="post-text" itemprop="text">
<p>Replacing a loop iteration with a map or list comprehension gives, at best a modest speed improvement - my guess is at best 2x.  But using the last calculated value with a comprehension or map is tricky (but not impossible).</p>
<p>Your function:</p>
<pre><code>def f0(ll, fun):
    stack = []
    for i in range(len(ll)):
        if i == 0:
           n0 = fun(ll[0],ll[0])
           stack.append(n0)
        else:
           n = fun(ll[i], stack[-1])
           stack.append(n)
    return stack
</code></pre>
<p>sample function:</p>
<pre><code>def foo(a,b):
    return a + b
</code></pre>
<p>streamlining your function:</p>
<pre><code>def f1(ll, fun, init):
    stack = []
    for l in ll:
        stack.append(fun(l, init))
        init = stack[-1]
    return stack

def f11(ll, fun, init):         # a bit better
    stack = []
    for l in ll:
        init = fun(l, init)
        stack.append(init)
    return stack
</code></pre>
<p>testing:</p>
<pre><code>In [784]: ll=list(range(10,20))
In [785]: f0(ll,foo)
Out[785]: [20, 31, 43, 56, 70, 85, 101, 118, 136, 155]
In [786]: f1(ll,foo,ll[0])
Out[786]: [20, 31, 43, 56, 70, 85, 101, 118, 136, 155]
In [818]: f11(ll,foo,ll[0])
Out[818]: [20, 31, 43, 56, 70, 85, 101, 118, 136, 155]
</code></pre>
<p>time tests:</p>
<pre><code>In [787]: llb=list(range(10,2000))
In [788]: timeit f0(llb,foo)
1000 loops, best of 3: 1 ms per loop
In [789]: timeit f1(llb,foo,llb[0])
1000 loops, best of 3: 744 µs per loop
In [819]: timeit f11(llb,foo,llb[0])
1000 loops, best of 3: 630 µs per loop
</code></pre>
<p>A generator approach:</p>
<pre><code>def g0(ll, fun, init):
    for l in ll:
        init = fun(l, init)
        yield init

In [804]: list(g0(ll, foo, ll[0]))
Out[804]: [20, 31, 43, 56, 70, 85, 101, 118, 136, 155]
In [805]: timeit list(g0(llb, foo, llb[0]))
1000 loops, best of 3: 509 µs per loop
</code></pre>
<p>With a preallocated result (also suggested by <code>@Alfe</code> in a comment):</p>
<pre><code>def f2(ll, fun, init):
    res=ll[:]
    res[0]=init
    for i,v in enumerate(ll):
        init=fun(v,init)
        res[i]=init
    return res
In [808]: f2(ll,foo,ll[0])
Out[808]: [20, 31, 43, 56, 70, 85, 101, 118, 136, 155]
In [809]: timeit f2(llb,foo,llb[0])
1000 loops, best of 3: 583 µs per loop
</code></pre>
<hr/>
<p>We can get a sense of the theoretically possible improvement by using <code>reduce</code></p>
<pre><code>In [790]: from functools import reduce   # needed for py3
In [791]: reduce(foo,ll,ll[0])
Out[791]: 155
In [792]: timeit reduce(foo,llb,llb[0])
1000 loops, best of 3: 394 µs per loop
</code></pre>
<p><code>reduce</code> performs this action, but only returns the last value.</p>
<p><a href="https://stackoverflow.com/questions/30676696/cumulative-sum-with-list-comprehension">Cumulative sum with list comprehension</a> tells us that Py3 <code>itertools</code> has an <code>accumulate</code> function:</p>
<pre><code>In [797]: list(itertools.accumulate(ll,foo))
Out[797]: [10, 21, 33, 46, 60, 75, 91, 108, 126, 145]
In [798]: timeit list(itertools.accumulate(llb,foo))
1000 loops, best of 3: 489 µs per loop
</code></pre>
<p>Unfortunately, <code>accumulate</code> does not take an initial value parameter (while <code>reduce</code> does).</p>
<p>Let's get a sense of what list comprehension and map can do for us, without trying to capture the accumulative action:</p>
<pre><code>In [799]: timeit [foo(a,0) for a in llb]
1000 loops, best of 3: 471 µs per loop
In [800]: timeit list(map(lambda a: foo(a,0), llb))
1000 loops, best of 3: 686 µs per loop
</code></pre>
<p>The generator approach looks pretty good.  It is correct, and its times are close to the <code>accumulate</code> and list comprehension ones.  Streamlining the function evaluation makes the biggest difference.  The method of collecting values in a list isn't so important.  </p>
<hr/>
<p>If you have <code>numpy</code>, you may be able to cast the problem as a <code>ufunc.accumulate</code> one.  For example with this simple summation:</p>
<pre><code>In [811]: np.cumsum(ll)
Out[811]: array([ 10,  21,  33,  46,  60,  75,  91, 108, 126, 145], dtype=int32)
In [812]: np.cumsum?
In [813]: timeit np.cumsum(llb)
1000 loops, best of 3: 211 µs per loop
</code></pre>
<hr/>
<p><a href="https://docs.python.org/3/library/itertools.html#itertool-functions" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertool-functions</a></p>
<blockquote>
<p>First-order recurrence relations can be modeled by supplying the initial value in the iterable and using only the accumulated total in func argument</p>
</blockquote>
<p>So:</p>
<pre><code>In [827]: list(itertools.accumulate([ll[0]]+ll,foo))[1:]
Out[827]: [20, 31, 43, 56, 70, 85, 101, 118, 136, 155]
In [828]: timeit list(itertools.accumulate([llb[0]]+llb,foo))[1:]
1000 loops, best of 3: 478 µs per loop
</code></pre>
<p>Though this does depend on <code>foo(a,0)</code> returning <code>a</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe using list comprehension :</p>
<pre><code>def f(l):
    last = l[-1]
    return [some_function(l[0], l[0])] + [some_function(x, last) for x in l[1:]]
</code></pre>
</div>
<span class="comment-copy">Looks like each result (<code>stack</code>) element is based on the one before (and the input).  Do you in the end  maybe only need the last element of your result?  Or is returning the complete list necessary?</span>
<span class="comment-copy">You might gain some speed by allocating the complete <code>stack</code> in the beginning; repeated appending might lead to remallocs which can be costly:  <code>stack = [ None ] * len(l)</code>.  You might consider <code>yield</code>ing each resulting element instead of storing it in a list; depending on your surrounding program this could improve performance.  But otherwise I don't think you can speed this thing up (by algorithmic changes).  It's too straight-forward already.  Of course, you can switch to C/C++ or similar.</span>
<span class="comment-copy">This doesn't update <code>last</code>; it is still the last of the input, not the last of <code>stack</code>.</span>
