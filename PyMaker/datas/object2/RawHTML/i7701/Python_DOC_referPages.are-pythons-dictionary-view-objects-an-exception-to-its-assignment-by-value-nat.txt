<div class="post-text" itemprop="text">
<p>As per <a href="https://stackoverflow.com/questions/9696495/python-when-is-a-variable-passed-by-reference-and-when-by-value">this question on Stack Overflow</a>, assignments in Python are always by value, hence you cannot change the original source. For example (from the same question),</p>
<pre><code>locs = [ [1], [2] ]
for loc in locs:
    loc = []

print locs
# prints =&gt; [ [1], [2] ]
</code></pre>
<p>However, dictionary view objects show an opposite behaviour </p>
<pre><code>bike = {"Manufacturer":"Honda","Model":"CBR","cc":250,"price":70,"mileage":74}

keys = bike.keys()
print(keys)

bike["tyres"] = 2
print(keys)
</code></pre>
<p>This is the output : </p>
<pre><code>dict_keys(['mileage', 'price', 'Model', 'Manufacturer', 'cc'])
dict_keys(['cc', 'Manufacturer', 'tyres', 'mileage', 'Model', 'price'])
</code></pre>
<p>Can they be treated as an exception to <em>assignment by value</em> nature? If yes, what are other such exceptions in Python3?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, this is not an exception. Nothing is assigned to the dictionary view. Views are explicitly <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">documented as being dynamic</a>:</p>
<blockquote>
<p>They provide a dynamic view on the dictionaryâ€™s entries, which means that when the dictionary changes, the view reflects these changes.</p>
</blockquote>
<p>That's because they only store a reference to the original dictionary and provide you with direct access to just the keys, or just the values, or to <code>(key, value)</code> pairs in ways that differ from the dictionary API.</p>
<p>You can build your own views onto objects if you wanted, but note that such an object still needs a reference to the original object(s):</p>
<pre><code>from collections.abc import Sequence

class ListReversedView(Sequence):
    def __init__(self, lst):
        self._lst = lst
    def __getitem__(self, idx):
        if idx &lt; 0:
            new = (-idx) - 1
        else:
            new = len(self) - idx - 1
            if new &lt; 0:
                raise IndexError(new)
        return self._lst[new]
    def __len__(self):
        return len(self._lst)
    def __repr__(self):
        return f"[{', '.join(map(repr, self))}]"
</code></pre>
<p>The above example gives you a different view on list contents; changes to the list are reflected in the 'view' this object provides. Nothing special needs to be done to Python's assignment model; assignments are still just references to objects, and the <code>_lst</code> attribute in this view object is no exception:</p>
<pre><code>&gt;&gt;&gt; foo = ['spam', 'ham', 'eggs']
&gt;&gt;&gt; view = ListReversedView(foo)
&gt;&gt;&gt; view
['eggs', 'ham', 'spam']
&gt;&gt;&gt; foo[-1] = 'bacon'
&gt;&gt;&gt; view
['bacon', 'ham', 'spam']
</code></pre>
<p>Circling back to your list loop; you can still assign back to the the list object itself; rebinding names may not work, but rebinding the indices works just fine:</p>
<pre><code>for index in range(len(locs)):
    locs[index] = []
</code></pre>
<p>In summary, Python objects all live on a heap, and names and attributes are just referencing to those objects. Multiple references can exist, and each such a reference will see changes made to the object (if permitted). Assignment changes only what a specific reference points to. Dict views are no exception here, they just continue to reference the dictionary from which they were created.</p>
<p>You may want to read up on the Python model; I strongly recommend the <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer"><em>Facts and myths about Python names and values</em> article by Ned Batchelder</a>.</p>
</div>
