<div class="post-text" itemprop="text">
<p>Python3.6 now <a href="https://docs.python.org/3/glossary.html#term-asynchronous-iterable" rel="nofollow noreferrer">asynchronous iterables</a>. Is there builtin way to transform a asynchronous iterable to a synchronous iterable. </p>
<p>I currently have this helper function, but it feels very un-pythonic. Is there a better way to do this?</p>
<pre><code>async def aiter_to_list(aiter):
    l = []
    async for i in aiter:
        l.append(i)
    return l
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://aiostream.readthedocs.io/en/latest/operators.html#aiostream.stream.list" rel="nofollow noreferrer">aiostream.stream.list</a>:</p>
<pre><code>from aiostream import stream

async def agen():
    yield 1
    yield 2
    yield 3

async def main():
    lst = await stream.list(agen())
    print(lst)  # prints [1, 2, 3]
</code></pre>
<p>More operators and examples in the <a href="http://aiostream.readthedocs.io/en/latest/" rel="nofollow noreferrer">documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your "asynchronous to synchronous" helper is itself asynchronous; not a big change at all. In general: no, you cannot make something asynchronous synchronous. An asynchronous value will be supplied "sometime later"; you cannot make that into "now" because the value doesn't exist "now" and you <em>will have to</em> wait for it, asynchronously.</p>
</div>
<div class="post-text" itemprop="text">
<p>These functions allow you to convert from / to <code>iterable</code> &lt;==&gt; <code>async iterable</code>, not just simple lists.</p>
<p>Basic imports</p>
<pre><code>import asyncio
import threading
import time

DONE = object()
TIMEOUT = 0.001
</code></pre>
<p>The function <code>to_sync_iterable</code> will convert any async iterable to a sync iterable:</p>
<pre><code>def to_sync_iterable(async_iterable, maxsize = 0):

    def sync_iterable():

        queue = asyncio.Queue(maxsize=maxsize)
        loop = asyncio.get_event_loop()

        t = threading.Thread(target=_run_coroutine, args=(loop, async_iterable, queue))
        t.daemon = True
        t.start()

        while True:
            if not queue.empty():
                x = queue.get_nowait()

                if x is DONE:
                    break
                else:
                    yield x
            else:
                time.sleep(utils.TIMEOUT)

        t.join()

    return sync_iterable()

def _run_coroutine(loop, async_iterable, queue):

    loop.run_until_complete(_consume_async_iterable(async_iterable, queue))

async def _consume_async_iterable(async_iterable, queue):

    async for x in async_iterable:
        await queue.put(x)

    await queue.put(DONE)
</code></pre>
<p>You can use it like this:</p>
<pre><code>async def slow_async_generator():
    yield 0

    await asyncio.sleep(1)
    yield 1

    await asyncio.sleep(1)
    yield 2

    await asyncio.sleep(1)
    yield 3


for x in to_sync_iterable(slow_async_generator()):
    print(x)
</code></pre>
<p>The function to_async_iterable will convert any sync iterable to an async iterable:</p>
<pre><code>def to_async_iterable(iterable, maxsize = 0):

    async def async_iterable():
        queue = asyncio.Queue(maxsize=maxsize)
        loop = asyncio.get_event_loop()
        task = loop.run_in_executor(None, lambda: _consume_iterable(loop, iterable, queue))

        while True:
            x = await queue.get()

            if x is DONE:
                break
            else:
                yield x

        await task


    return async_iterable()

def _consume_iterable(loop, iterable, queue):

    for x in iterable:
        while True:
            if not queue.full():
                loop.call_soon_threadsafe(queue.put_nowait, x)
                break
            else:
                time.sleep(TIMEOUT)

    while True:
        if not queue.full():
            loop.call_soon_threadsafe(queue.put_nowait, DONE)
            break
        else:
            time.sleep(TIMEOUT)
</code></pre>
<p>This one is specially useful for asyncio programs because it won't block the event loop even if the the sync iterable blocks. You can use it like this:</p>
<pre><code>def slow_sync_generator():
    yield 0

    time.sleep(1)
    yield 1

    time.sleep(1)
    yield 2

    time.sleep(1)
    yield 3

async def async_task():
    async for x in to_async_iterable(slow_sync_generator()):
        print(x)

asyncio.get_event_loop().run_until_complete(async_task())
</code></pre>
</div>
<span class="comment-copy">Thanks. Your answer help clarify my understand what I'm trying to do. I realize I only want to transform my asynchronous iterable into a list, not synchronous iterable.</span>
