<div class="post-text" itemprop="text">
<p>I have multiple (&gt;30) compiled regex's</p>
<pre><code>regex_1 = re.compile(...)
regex_2 = re.compile(...)
#... define multiple regex's
regex_n = re.compile(...)
</code></pre>
<p>I then have a function which takes a <code>text</code> and replaces some of its words using every one of the regex's above and the <code>re.sub</code> method as follows</p>
<pre><code>def sub_func(text):
    text = re.sub(regex_1, "string_1", text)
    # multiple subsitutions using all regex's ...
    text = re.sub(regex_n, "string_n", text)

    return text
</code></pre>
<p><strong>Question: Is there a more efficient way to make these replacements?</strong></p>
<p>The regex's cannot be generalized or simplified from their current form.</p>
<p>I feel like reassigning the value of <code>text</code> each time for every regex is quite slow, given that the function only replaces a word or two from the entirety of <code>text</code> for each reassignment. Also, given that I have to do this for multiple documents, that slows things down even more.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Reassigning a value takes constant time in Python. Unlike in languages like C, variables are more of a "name tag". So, changing what the name tag points to takes very little time.</p>
<p>If they are constant strings, I would collect them into a tuple:</p>
<pre><code>regexes = (
    (regex_1, 'string_1'),
    (regex_2, 'string_2'),
    (regex_3, 'string_3'),
    ...
)
</code></pre>
<p>And then in your function, just iterate over the list:</p>
<pre><code>def sub_func_2(text):
    for regex, sub in regexes:
        text = re.sub(regex, sub, text)
    return text
</code></pre>
<p>But if your regexes are actually named <code>regex_1</code>, <code>regex_2</code>, etc., they probably should be directly defined in a list of some sort.</p>
<p>Also note, if you are doing replacements like <code>'cat'</code> -&gt; <code>'dog'</code>, the <a href="https://docs.python.org/library/stdtypes.html#str.replace" rel="nofollow noreferrer"><code>str.replace()</code></a> method might be easier (<code>text = text.replace('cat', 'dog')</code>), and it will probably be faster.</p>
<hr/>
<p>If your strings are <em>very</em> long, and re-making it from scratch with the regexes might take very long. An implementation of <a href="https://stackoverflow.com/users/129570/oliver-charlesworth">@Oliver Charlesworth's</a> method that was mentioned in the comments could be:</p>
<pre><code># Instead of this:
regexes = (
   ('1(1)', '$1i'),
   ('2(2)(2)', '$1a$2'),
   ('(3)(3)3', '$1a$2')
)


# Merge the regexes:
regex = re.compile('(1(1))|(2(2)(2))|((3)(3)3)')
substitutions = (
    '{1}i', '{1}a{2}', '{1}a{2}'
)

# Keep track of how many groups are in each alternative
group_nos = (1, 2, 2)

cumulative = [1]
for i in group_nos:
    cumulative.append(cumulative[-1] + i + 1)
del i
cumulative = tuple(zip(substitutions, cumulative))

def _sub_func(match):
    iter_ = iter(cumulative)
    for sub, x in iter_:
        if match.group(x) is not None:
            return sub.format(*map(match.group, range(x, next(iter_)[1])))

def sub_func(text):
    return re.sub(regex, _sub_func, text)
</code></pre>
<p>But this breaks down if you have overlapping text that you need to substitute.</p>
</div>
<div class="post-text" itemprop="text">
<p>we can pass a function to <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> repl argument</p>
<p>simplify to 3 regex for easier understanding</p>
<p>assuming regex_1, regex_2, and regex_3 will be 111,222 and 333 respectively. Then, regex_replace will be the list holding string that will be use for replace follow the order of regex_1, regex_2 and regex_3.</p>
<ul>
<li>regex_1 will be replace will 'one'</li>
<li>regex_2 replace with 'two' and so on</li>
</ul>
<p>Not sure how much this will improve the runtime though, give it a try</p>
<pre><code>import re
regex_x = re.compile('(111)|(222)|(333)')
regex_replace = ['one', 'two', 'three']

def sub_func(text):
    return re.sub(regex_x, lambda x:regex_replace[x.lastindex-1], text)

&gt;&gt;&gt; sub_func('testing 111 222 333')
&gt;&gt;&gt; 'testing one two three'
</code></pre>
</div>
<span class="comment-copy">If these replacements are mutually exclusive, you <b>might</b> find it's faster to do <code>re.sub(re.compile("pattern1|pattern2|..."), function_that_handles_match, text)</code>.  (Untested hypothesis, of course :)</span>
<span class="comment-copy">@Pythonista that wouldn't work if he wanted to substitute a separate string in for each regex</span>
<span class="comment-copy">When you starting naming variables <code>xxx_1</code>, <code>xxx_2</code>, and so on, this is a sign that you really want to collect these into a list. Makes it much easier to add or reorder, and iterating over the list is simpler than copy/paste of <code>do_this_to(xxx_1); do_this_to(xxx_2); do_this_to(xxx_2a_which_i_needed_between_2_and_3_but_didnt_want_to_renumber_everything); do_this_to(xxx_3); etc.</code></span>
<span class="comment-copy">Do you see a degrade in performance with increasing number of regexes? (I.e. aren't you trying to prematurely optimize it?)</span>
<span class="comment-copy">1. It would help if you showed us some typical regexes and typical replacement strings. 2. How big are these documents? It may be more efficient to process your documents in sections (lines, paragraphs, pages) rather than performing multiple string replacements in a large document. Each replacement involves allocating a new string, and that gets expensive when you do multiple replacements on a large string.</span>
<span class="comment-copy">I don't think the OP is worried about the time taken to assign a reference; rather it's the time taken to perform 30 independent string replacements (which requires rebuilding the string 30 times).</span>
<span class="comment-copy">Thanks @Artyer , that really does clean my code up a lot as it saves me from having to duplicate code (defining the regexs and then also replacing words one by one in my function). The tuple-for loop approach is much neater. As the regex's pick out very specific entities, it wasnt possible to generalise them any further. Also, the string replacements are all different, so I cant replace them all with one string either. Thanks again!</span>
