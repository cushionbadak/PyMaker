<div class="post-text" itemprop="text">
<p>I have a <a href="https://stackoverflow.com/questions/24601722/how-can-i-use-functools-singledispatch-with-instance-methods">method dispatch decorator</a> with three registered functions. One dispatches on <code>int</code>, which works fine. The second dispatched on a custom type, also works fine. The third is also a custom type, but the Class is wrapped with the <code>lru_cache</code> decorator. </p>
<p>(To make things a little more complicated, the class is instantiated in a roundabout way via a methoddispatch on the <code>__call__</code> method of another class.)</p>
<pre><code>@lru_cache(maxsize=None, typed=True)
class QualifiedInterval:
    # stuff that works
</code></pre>
<p>Inside the Pitch class:</p>
<pre><code>@oph_utils.method_dispatch
def augmented(self, other):
    raise NotImplementedError

@augmented.register(int)
def _(self, other):
    return "works fine"


@augmented.register(Interval)
def _(self, other):
    return "works fine too"

@augmented.register(QualifiedInterval)
def _(self, other):
    return "only works if QualifiedInterval class does NOT have lru_cache"
</code></pre>
<p>(There's a lot more going on, but this is the bits that don't work.)</p>
<p>Basically - if I have lru_cache, and pass a QualifiedInterval into the function, it does not dispatch and raises NotImplementedError. If I comment out the cache decorator, it works. And manual type checking at the REPL shows the same type ("QualifiedInterval") either way. I've tried calling the command that created the QualifiedInterval several different ways, and tried assigning it to a variable. Still doesn't work. I've tried doing explicit typechecking in the Augmented function. The typecheck fails there as well, if caching is enabled.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Analysis of What is Going Wrong</h2>
<blockquote>
<p>Basically - if I have lru_cache, and pass a QualifiedInterval into the function, it does not dispatch </p>
</blockquote>
<p>The <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><em>lru_cache</em></a> is function that returns a <a href="https://docs.python.org/3/glossary.html#term-decorator" rel="nofollow noreferrer">decorator</a> that wraps any callable (including classes).  So when you apply the <em>lru_cache</em> to the <em>QualifiedInterval</em> class, that variable becomes assigned to the wrapper function rather than the class itself.</p>
<pre><code>&gt;&gt;&gt; @lru_cache(maxsize=None, typed=True)
class QualifiedInterval:
    pass

&gt;&gt;&gt; type(QualifiedInterval)
&lt;class 'functools._lru_cache_wrapper'&gt;
</code></pre>
<p><a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer">Single dispatch</a> works by matching the type of the first parameter to the appropriate method. However, when you pass in an instance of <em>QualifiedInterval</em>, its type doesn't match <em>functools._lru_cache_wrapper</em>, so single dispatch falls back to the base method(which raises <em>NotImplemented</em>.</p>
<h2>Solution</h2>
<p>Teach single dispatch to match on the actual original class (type) instead of the wrapped class:</p>
<pre><code>@augmented.register(QualifiedInterval.__wrapped__)
def _(self, other):
    return "show now work QualifiedInterval class has an lru_cache"
</code></pre>
<p>Note the addition of the <code>.__wrapped__</code> attribute which reaches through the wrapper function to get to the original unwrapped class.</p>
<p>Hope that clears it all up and shows the way forward :-)</p>
</div>
<span class="comment-copy">So this works. (Thanks!) But why does <code>type(instanceofQualifiedInterval)</code> return <code>QualifiedInterval</code> on the one hand, but on the other hand <code>type(instanceofQualifiedInterval) is QualifiedInterval</code> returns false.</span>
