<div class="post-text" itemprop="text">
<p>This is an unusual situation - most Django users want Django's test runner to find all of their tests.</p>
<p>I'm working on a python library with several test suites that are run with different configurations, so I don't want the discovery to find and run tests from the wrong configuration.  How do I disable discovery entirely and rely on the pre-1.6 behavior of only running the tests for apps explicitly declared in INSTALLED_APPS?</p>
<p>My library structure:</p>
<pre><code>library/    # django app used by others
tests/      # custom test suites here
  core/     # tests of core functionality
  custom/   # tests of a custom feature requiring separate config
  contrib/  # tests for assorted contrib features, also requiring separate config
  manage_core.py    # separate manage.py files for each "project"
  manage_custom.py  # these specify settings file to use.
  manage_contrib.py
  settings.py         # base settings for all tests
  settings_core.py    # settings for 'core' tests including unique INSTALLED_APPS
  settings_custom.py  # settings for 'custom' tests; different INSTALLED_APPS
  settings_contrib.py # settings for 'contrib' tests; different INSTALLED_APPS
</code></pre>
<p>The problem is that this command, which should only run tests for the 'contrib' test suite, is also finding and running tests for 'core':
<code>./manage_contrib.py test contrib.tests</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It's missing from the Django docs, but the command-line has an option, found via <code>./manage.py help test</code>:</p>
<pre><code>  -t TOP_LEVEL, --top-level-directory TOP_LEVEL
                    Top level of project for unittest discovery.
</code></pre>
<p>Confusingly, specifying the module to test doesn't appear to prevent test discovery, but specifying a sub-directory does, like this:</p>
<p><code>./manage_contrib.py test contrib.tests -t ./contrib/</code></p>
<p>That appears to prevent the discovery of tests located outside of <code>contrib</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Hmm I'm unfortunately not aware of a settings parameter that might let you tell unittest to only run from individual apps (a-la "settings.TEST_DIRECTORIES=settings.INSTALLED_APPS") but if you're able to give your tests a unique naming convention, you could use the --pattern= option when running the test suite.</p>
<p>For example, if you have</p>
<pre><code>/myapp/tests/test_a_models.py
/myapp/tests/test_b_models.py
</code></pre>
<p>You could only run a with <code>./manage.py test --pattern='*_a_*'</code> and then run b with <code>./manage.py test --pattern='*_b_*'</code></p>
<p>Definitely not ideal, but might get the job done depending on how much flexibility you have with the test naming conventions in your own app.</p>
</div>
<span class="comment-copy">You could <a href="https://docs.python.org/3/library/unittest.html#skipping-tests-and-expected-failures" rel="nofollow noreferrer">skip the test</a> if the necessary apps are not installed.</span>
