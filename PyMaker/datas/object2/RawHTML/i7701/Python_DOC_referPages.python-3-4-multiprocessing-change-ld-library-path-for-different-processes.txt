<div class="post-text" itemprop="text">
<p>I'm using python multiprocessing module to call a python function in separate process, and I want a different value for the environment variable <code>$LD_LIBRARY_PATH</code> for this processes.
Specifically, I need to append a string to the existing value before the process refers to it. An example code is shown below:</p>
<pre><code>import os
from multiprocessing import Process
import sys

orig_env = os.environ['LD_LIBRARY_PATH']

def startProc_A():
   a_env = orig_env + 'path/1'
   os.environ['LD_LIBRARY_PATH'] = a_env
   print(os.environ['LD_LIBRARY_PATH'])
   sys.path.append('path/1')
   new_proc = Process(target = func_A, args=(0,))
   new_proc.start()

def func_A():
   import module_A
</code></pre>
<p>In the print statement, I can see that <code>os.environ['LD_LIBRARY_PATH']</code> has been correctly updated, however, <strong>my process is still referring to the value that it had when python was started</strong>, meaning that module_A is still referring to the old <code>LD_LIBRARY_PATH</code></p>
<p>Is there a way to update this value dynamically within the script.</p>
<p>RSVP. Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/os.html?highlight=env#os.putenv" rel="nofollow noreferrer">documentation</a> for os.putenv() includes the text:</p>
<blockquote>
<p>"... Such changes to the environment affect subprocesses started with
  os.system(), popen() or fork() and execv()"</p>
</blockquote>
<p>So, you can do it like this:</p>
<pre><code>import os

def func_A():
    print os.environ['LANG']
    os._exit(0)  

orig_env = os.environ['LANG']
a_env = orig_env + 'something_else'
os.environ['LANG'] = a_env    

newpid = os.fork()
if newpid == 0:   # this is the child process
    func_A()
</code></pre>
<p>... or (maybe better) after the fork() call, like this:</p>
<pre><code>import os

def func_A():
    print os.environ['LANG']
    os._exit(0)  


newpid = os.fork()
if newpid == 0:   # this is the child process
    orig_env = os.environ['LANG']
    a_env = orig_env + 'something_else'
    os.environ['LANG'] = a_env    
    func_A()
</code></pre>
<p>(edit) Also the following does appear to work:</p>
<p>module_A.py:</p>
<pre><code>import os
import sys

def func_from_module_A():
    print os.environ['LANG']
    print sys.path
    os._exit(0)  
</code></pre>
<p>main.py:</p>
<pre><code>import os
import sys

def startProc_A():
    newpid = os.fork()
    if newpid == 0:   # this is the child process
        orig_env = os.environ['LANG']
        a_env = orig_env + 'something_else'
        os.environ['LANG'] = a_env
        sys.path.append("road_to_nowhere")
        func_A()

def func_A():
    import module_A
    module_A.func_from_module_A()

startProc_A()
</code></pre>
</div>
<span class="comment-copy">What does <code>print(multiprocessing.get_start_method())</code> print on stdout?</span>
<span class="comment-copy">thanks for the prompt answer, but it doesn't work for me. While the environment is being updated correctly, the import statements made in func_A() are still targeting the old environment</span>
<span class="comment-copy">@SaranshKejriwal OK I added another method which (I think) follows the import pattern you are using, and it does seem to work for me. If not for you, can you post a link to some non-working code and I'll take a look? AS</span>
