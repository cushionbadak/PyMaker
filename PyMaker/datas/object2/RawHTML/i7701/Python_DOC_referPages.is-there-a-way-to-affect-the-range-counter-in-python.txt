<div class="post-text" itemprop="text">
<p>I'm trying to run a python program with a for loop which has a variable i increased by 1 every time from 1 to the length of my list. In java, my code that I'm going for might look something like this:</p>
<pre><code>for (int i = 0; i &lt; array.length; i++) {
      //code goes here
      i += //the number i want it to go up by
}
</code></pre>
<p>This actually affects my counter the way intended and allows me to effectively skip numbers in my for loop and I want to try to run a similar program but in python. Is there any way to do this with python's built in functionality or do I have to just use a while loop and a counter to simulate this myself if I want python to work this way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll need a while loop for this:</p>
<pre><code>i = 0
while i &lt; len(myArray):
    # do stuff
    if special_case: i+= 1
    i += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>(Disclaimer: never use this code for any remotely serious purpose)</strong></p>
<p>The problem with modifying the value of <code>i</code> in your code is this: normally, assignments (including augmented assignment, <code>+=</code>) made to local immutable values are only visible in the local scope. The inside of <code>range</code> is not in the local scope. When you reassign <code>i</code>, the <code>range</code> implementation has no way of knowing this.</p>
<p>Normally.</p>
<p>But Python has a built-in module named <a href="https://docs.python.org/3.6/library/inspect.html" rel="nofollow noreferrer">inspect</a> that exposes all sorts of information about your program that you normally wouldn't be privy to at run-time. This includes the values of variables in frames which would otherwise be completely inaccessible.</p>
<p>In violation of good programming principles and the laws of nature, we can write a range-like function which pierces the veil of ignorance, and steals the value of <code>i</code> from the calling context, much like how Prometheus stole fire from the peak of Mount Olympus. (Note: recall what happens to Prometheus at the end of that story.)</p>
<pre><code>import inspect
import re

def mutable_range(max):
    x = 0
    while x &lt; max:
        yield x
        record = inspect.stack()[1]
        frame = record[0]
        source_lines = record[4]
        iterator_name = re.match(r"\s*for (\w+) in mutable_range", source_lines[0]).group(1)
        peek = frame.f_locals[iterator_name]
        if peek != x:
            x = peek
        else:
            x += 1

for i in mutable_range(10):
    print(i)
    if i == 3:
        i = -10
    if i == -8:
        i = 6
</code></pre>
<p>Result:</p>
<pre><code>0
1
2
3
-10
-9
-8
6
7
8
9
</code></pre>
<p><strong>(Disclaimer: author is not responsible for use of code and subsequent punishment of your hubris by eagles feeding on your liver for all eternity)</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You can't modify the step mid count, but if the stepping through is constant, you can specify it at the start:</p>
<pre><code># the default
&gt;&gt;&gt; range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]

# step 2
&gt;&gt;&gt; range(1, 10, 2)
[1, 3, 5, 7, 9]
</code></pre>
<p>You can also step backwards:</p>
<pre><code>&gt;&gt;&gt; range(10, 0, -1)
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
</code></pre>
<p>If your case is, sadly, not one where the step is constant throughout iterations, you'll certainly need a while loop as you rightly surmised.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python it is very similar with Java. You can dynamic increase your counter based on different conditions as :</p>
<pre><code>x = 1
while x &lt; 100:
   if condition1:
       x += 1
   elif condition2:
       x += 2
   else:
       x += 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, you can create one-way iterators with the built-in <a href="https://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter</code></a> function. With that, you can call <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> to effectively skip a step.</p>
<p>To do this with multiple steps, the itertools recipies defines a <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>consume</code></a> function:</p>
<pre><code>def consume(iterator, n):
    "Advance the iterator n-steps ahead. If n is none, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
</code></pre>
<p>In this case, we can do:</p>
<pre><code>import itertools

def skip(iterator, n):
    next(itertools.islice(iterator, n, n), None)

range_iter = iter(range(len(ls)))

for i in range_iter:
    # ...
    if custom_condition:
        skip(range_iter, 2)  # Or any number.
</code></pre>
<p>This also works directly iterating over lists:</p>
<pre><code>ls_iter = iter(ls)

for i in ls_iter:
    # ...
    if custom_condition:
        skip(ls_iter, 3)
</code></pre>
<p>These are super efficient as they use built-in types and functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>You'll be happier with the while loop.
You can do something like</p>
<pre><code>l = list(range(min_count,max_count))
for i in l:
</code></pre>
<p>and modify <code>l</code> during the loop.  But getting that right is hard.
You could also create an iteration  object with a <code>skip</code> method, and call that during the loop.  </p>
<pre><code>class SkipRange:

    def __init__(self, minc, maxc, step):
        self.count = minc
        self.maxc = maxc
        self.step = step

    def __iter__(self): return self

    def  __next__(self):
        if self.count &gt; self.maxc: raise StopIteration
        c = self.count
        self.count += self.step
        return c

    def skip(self, num = 1): self.count += num
</code></pre>
<p>Untested and entirely off the top of bmy head; debugging is left as an exercise to anyone annoyed at while loops enough to go that route.  I think it's more illustrative of what's going on under the covers.</p>
<pre><code>s = SkipRange(min_count,max_count)
for i in s:
    # do stuff
    s.skip(3) #skip next 3 items
</code></pre>
<p>But the while loop is more readable and in most cases easier.</p>
</div>
<span class="comment-copy">I think OP wants to dynamically affect the loop variable during execution - not statically change the loop structure</span>
<span class="comment-copy">@inspectorG4dget This is an option if the affectation was constant, though. Edited.</span>
