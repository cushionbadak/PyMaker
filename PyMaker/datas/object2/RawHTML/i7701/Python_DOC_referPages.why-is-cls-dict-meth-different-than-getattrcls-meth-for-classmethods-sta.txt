<div class="post-text" itemprop="text">
<p>I've never seen anything else work like this before. </p>
<p>Is there anything else that does this?</p>
<pre><code>&gt;&gt;&gt; class NothingSpecial:
     @classmethod
     def meth(cls): pass

&gt;&gt;&gt; NothingSpecial.meth
&lt;bound method classobj.meth of &lt;class __main__.NothingSpecial at 0x02C68C70&gt;&gt;
&gt;&gt;&gt; NothingSpecial.__dict__['meth']
&lt;classmethod object at 0x03F15FD0&gt;

&gt;&gt;&gt; getattr(NothingSpecial, 'meth')
&lt;bound method NothingSpecial.meth of &lt;class '__main__.NothingSpecial'&gt;&gt;

&gt;&gt;&gt; object.__getattribute__(NothingSpecial, 'meth')
&lt;classmethod object at 0x03FAFE90&gt;

&gt;&gt;&gt; type.__getattribute__(NothingSpecial, 'meth')
&lt;bound method NothingSpecial.meth of &lt;class '__main__.NothingSpecial'&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Getattr Uses Descriptor Logic</h2>
<p>The main difference is that the dictionary lookup does no extra processing while the attribute fetch incorporates extra logic (see my <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">Descriptor How-To Guide</a> for all the details).</p>
<h2>There Are Two Different Underlying Methods</h2>
<p>1) The call <code>NothingSpecial.__dict__['meth']</code> uses the square brackets operator which dispatches to <code>dict.__getitem__</code> which does a simple hash table lookup or raises <em>KeyError</em> if not found.</p>
<p>2) The call <code>NothingSpecial.meth</code> uses the dot operator which dispatches to <code>type.__getattribute__</code> which does a simple lookup followed by a special case for <a href="https://docs.python.org/3/glossary.html#term-descriptor" rel="nofollow noreferrer">descriptors</a>.  If the lookup fails, an <em>AttributeError</em> is raised.</p>
<h2>How It Works</h2>
<p>The overall logic is documented <a href="https://docs.python.org/3/reference/datamodel.html?highlight=descriptor#implementing-descriptors" rel="nofollow noreferrer">here</a> and <a href="https://docs.python.org/3/reference/datamodel.html?highlight=descriptor#invoking-descriptors" rel="nofollow noreferrer">here</a>.</p>
<blockquote>
<p>In general, a descriptor is an object attribute with “binding
  behavior”, one whose attribute access has been overridden by methods
  in the descriptor protocol: __get__(), __set__(), and/or __delete__(). If
  any of those methods are defined for an object, it is said to be a
  descriptor.</p>
<p>The default behavior for attribute access is to get, set, or delete
  the attribute from an object’s dictionary. For instance, a.x has a
  lookup chain starting with a.__dict__['x'], then
  type(a).__dict__['x'], and continuing through the base classes of
  type(a) excluding metaclasses.</p>
<p>However, if the looked-up value is an object defining one of the
  descriptor methods, then Python may override the default behavior and
  invoke the descriptor method instead. Where this occurs in the
  precedence chain depends on which descriptor methods were defined and
  how they were called</p>
</blockquote>
<p>Hope you've found all of this to be helpful.  The kind of exploring you're doing is a great way to learn about Python :-)</p>
<p>P.S.  You might also enjoy reading the original Whatsnew in Python 2.2 <a href="https://docs.python.org/3/whatsnew/2.2.html#descriptors" rel="nofollow noreferrer">entry for descriptors</a> or looking at <a href="https://www.python.org/dev/peps/pep-0252/" rel="nofollow noreferrer">PEP 252</a> where Guido van Rossum originally proposed the idea.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>object.__getattribute__(NothingSpecial, 'meth')
</code></pre>
<p>and</p>
<pre><code>NothingSpecial.__dict__['meth'] 
</code></pre>
<p>return the same object in this case. You can quickly check it by doing:</p>
<pre><code>NothingSpecial.__dict__['meth'] is object.__getattribute__(NothingSpecial, 'meth')

$True
</code></pre>
<p>Both of them points to the same <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor object</a></p>
<p>on the other hand:</p>
<pre><code>object.__getattribute__(NothingSpecial, 'meth') is getattr(NothingSpecial, 'meth')

$False
</code></pre>
<p>Basically, they aren't they are not the same object nand the same type:</p>
<pre><code>type(object.__getattribute__(NothingSpecial, 'meth'))
$&lt;class 'classmethod'&gt;

type(getattr(NothingSpecial, 'meth'))
$&lt;class 'method'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So the answer is that <code>getattr</code> will automagically invoke an object's <code>__get__</code> method if it has one, whereas <code>object.__getattribute__</code> and the objects <code>__dict__</code> lookup do not. The following function proves that:</p>
<pre><code>class Nothing:

    @classmethod
    def a(cls): 
        return cls()

    @staticmethod
    def b(): 
        return 'b'

    def c(self): 
        return 'c'

def gitter(obj, name):
    value = object.__getattribute__(obj, name)
    if hasattr(value, '__get__'):
        if isclass(obj):
            instance, cls = None, obj
        else:
            instance, cls = obj, type(obj)
        return value.__get__(instance, cls)
    return value

&gt;&gt;&gt; gitter(Nothing, 'a')()
&lt;__main__.Nothing object at 0x03E97930&gt;
&gt;&gt;&gt; gitter(Nothing, 'b')()
'b'
&gt;&gt;&gt; gitter(Nothing(), 'c')()
'c'
</code></pre>
<p>However, <code>gitter(Nothing(), 'b')</code> doesn't work currently because it's not detecting that the <code>objtype</code> default value is <code>None</code>, but this is enough.</p>
</div>
<span class="comment-copy">Because classmethods are descriptors.  Read up on descriptors.</span>
<span class="comment-copy">So I see that the pure python implementation of class method located on the descriptor how-to does the same thing. So I guess that means that <code>type.__getattribute__</code> is doing something special if it gets a descriptor. But I still can't figure out how to emulate that behavior.</span>
<span class="comment-copy"><code>type</code> is a metaclass, the default metaclass for all classes. It probably <i>is</i> doing something special.</span>
<span class="comment-copy">@bup: If you want to emulate it, you should ask a separate question about that (and maybe explain why you want to do that).</span>
<span class="comment-copy"><code>object.__getattribute__</code> will perform descriptor handling, but the descriptor handling will be <i>regular object</i> descriptor handling, not class object descriptor handling; for regular objects, descriptors in the object <code>__dict__</code> don't get descriptor methods invoked.</span>
