<div class="post-text" itemprop="text">
<p>I have a class method where I instantiate a configuration class and then call a method on that class:</p>
<pre><code>from config.ConfigB import ConfigB

class FileRunner(object):
  def runProcess(self, cfgA)
    cfgB = ConfigB(cfgA)
    print(cfgB.createvalue())
</code></pre>
<p>I have the following test class set up to try and test the method, but it isn't working:</p>
<pre><code>import unittest
import unittest.mock imort MagicMock
import mock
from FileRunner import FileRunner

class TestFileRunner(unittest.TestCase):
  @mock.patch('ConfigB.ConfigB.__init__')
  def test_methodscalled(self, cfgB):

    cfgA = MagicMock()

    fileRunner = FileRunner()

    cfgB.return_value = None
    cfgB.return_value.createValue.return_value = 17

    fileRunner.runProcess(cfgA)
</code></pre>
<p>But when I test the class I get the error:</p>
<pre><code>AttributeError: 'NoneType' object has no attribute 'createValue'
</code></pre>
<p>I also tried writing the test class like this:</p>
<pre><code>import unittest
import unittest.mock imort MagicMock
import mock
from FileRunner import FileRunner

class TestFileRunner(unittest.TestCase):
  @mock.patch('ConfigB.ConfigB.__init__')
  def test_methodscalled(self, cfgB):

    cfgA = MagicMock()

    fileRunner = FileRunner()

    cfgBMock = mock.Mock()
    cfgBMock.createValue.return_value = 17

    cfgB.return_value = cfgBMock

    fileRunner.runProcess(cfgA)
</code></pre>
<p>But when I try this I get the error:</p>
<pre><code>TypeError: __init__() should return None, not 'Mock'
</code></pre>
<p>What am I doing wrong? Is there a better way to test my class?</p>
<p>*Edit: Here is the solution based on comments below:</p>
<pre><code>import unittest
import unittest.mock imort MagicMock
import mock
from FileRunner import FileRunner

class TestFileRunner(unittest.TestCase):
  @mock.patch('ConfigB.ConfigB.__init__')
  @mock.patch('ConfigB.ConfigB.createValue')
  def test_methodscalled(self, createValue, cfgB):

    cfgA = MagicMock()

    fileRunner = FileRunner()


    createValue.return_value = 17

    cfgB.return_value = None

    fileRunner.runProcess(cfgA)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As per Don Kirby, I have put my solution as an answer to the question:</p>
<pre><code>import unittest
import unittest.mock imort MagicMock
import mock
from FileRunner import FileRunner

class TestFileRunner(unittest.TestCase):
  @mock.patch('ConfigB.ConfigB.__init__')
  @mock.patch('ConfigB.ConfigB.createValue')
  def test_methodscalled(self, createValue, cfgB):

    cfgA = MagicMock()

    fileRunner = FileRunner()


    createValue.return_value = 17

    cfgB.return_value = None

    fileRunner.runProcess(cfgA)
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/32349855/mock-parent-class-init-method">Mock parent class __init__ method</a></span>
<span class="comment-copy">Init <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer">may not return non-None value</a>, or a TypeError is raised – as you've observed. If you want to mock <code>ConfigB.createvalue</code>, should you not <code>@mock.patch('ConfigB.ConfigB.createvalue')</code>?</span>
<span class="comment-copy">@IljaEverilä that worked. I have added in my updated test method. Thanks.</span>
<span class="comment-copy">Please post your answer as an answer instead of part of the question. That way, the question won't look like it needs answering.</span>
