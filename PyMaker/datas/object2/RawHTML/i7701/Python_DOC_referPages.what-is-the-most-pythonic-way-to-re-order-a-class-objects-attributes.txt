<div class="post-text" itemprop="text">
<p>I'm in the process of creating a set of Python 2.7/3+ tools to programmatically modify the contents of XML files my team uses constantly. So far, I'm parsing the XML into meaningful class object attributes (via <code>**kwargs</code> and <code>.__dict__.update()</code> or <code>setattr()</code>), to which I've associated some fairly complex methods. I really love being able to define my automation in terms of method calls, e.g. <code>foo.do_complex_modification(x)</code>.</p>
<p>I am now at the point where I would like to write my modified data back into an XML file, to be used by the rest of our software. The contents of the file are just fine, but unfortunately our legacy tools only accepts the XML <em>with the order preserved</em>, something I can't count on Python object dictionaries to provide. I can read in the "proper" order when parsing the XML without a problem and store that somehow, but modifying the legacy systems is not an option.</p>
<p>Possibly related, there is also an XSD schema for the XML.</p>
<p><strong>Question</strong>: What is the most pythonic or elegant way to serialize my class attributes so that they <em>preserve their original order</em>? If appropriate, how would I go about writing, say, <code>.sort(key=ordering_function)</code> when reading back from the object's <code>__dict__</code>?</p>
<pre><code>class Foo(object):
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)
    def really_complex_method(self):
        pass


def attrs(cls):   
    return [(k, v) for k, v in cls.__dict__.items() if k[:1] != '_']

d = dict(bar=1, baz=2, quux=3)  # Need them back in this particular order
print(attrs(Foo(**d)))
</code></pre>
<p>Returns</p>
<pre><code>[('quux', 3), ('bar', 1), ('baz', 2)]
</code></pre>
<p>And is un-ordered on any version prior to Python 3.6.</p>
</div>
<div class="post-text" itemprop="text">
<p>The biggest problem is probably because you keep passing keyword arguments around, which doesn't preserve the order they in which they were defined. The other issue is that a <code>class.__dict__</code> is unordered. Here's a way to work around both these things (which doesn't assume you want the attributes alphabetically ordered by their name). The technique of replacing the class' special <code>__dict__</code> attribute is allowable because, as the <a href="https://docs.python.org/3/library/stdtypes.html#object.__dict__" rel="nofollow noreferrer">documentation</a> says, it can be a "dictionary or <em>other mapping object</em>" (emphasis mine). This true in both Python 2 and 3.</p>
<pre><code>from collections import OrderedDict
from operator import itemgetter

class Foo(object):
    def __init__(self, *keyvalues):
        self.__dict__ = OrderedDict(keyvalues)

    def really_complex_method(self):
        pass

def attrs(instance):
    """ Return a list of instance attributes sorted by their value. """
    return sorted(instance.__dict__.items(), key=itemgetter(1))

print(attrs(Foo(('bar', 1), ('baz', 2), ('quux', 3), ('question', -42))))
</code></pre>
<p>Output:</p>
<pre><code>[('question', -42), ('bar', 1), ('baz', 2), ('quux', 3)]
</code></pre>
<p>An alternative to using <code>OrderedDict</code> would be to create your own mapping class. Here's an <a href="https://www.python.org/dev/peps/pep-3115/#example" rel="nofollow noreferrer">example</a> takien from <a href="https://www.python.org/dev/peps/pep-3115/" rel="nofollow noreferrer">PEP 3115</a> (which is about metaclasses in Python 3, but the subject's not relevant). It also works in both Python 2 and 3):</p>
<pre><code>from operator import itemgetter

class MemberTable(dict):
    """ Custom dictionary that keeps track of the order members (keys) are added. """
    def __init__(self, *args, **kwargs):
        super(MemberTable, self).__init__(*args, **kwargs)
        self.member_names = []

    def __setitem__(self, key, value):
        # if the key is not already defined, add to the list of keys.
        if key not in self:
            self.member_names.append(key)
        super(MemberTable, self).__setitem__(self, key, value)

class Foo(object):
    def __init__(self, *keyvalues):
        self.__dict__ = MemberTable(keyvalues)

    def really_complex_method(self):
        pass

def attrs(instance):
    """ Return a list of instance attributes sorted their value. """
    return sorted(instance.__dict__.items(), key=itemgetter(1))

print(attrs(Foo(('bar', 1), ('baz', 2), ('quux', 3), ('question', -42))))
</code></pre>
<p>Yet another way to do it, that doesn't involve changing the instance's <code>__dict__</code>, would be to make the class keep track of the order attributes were added to it and then iterate them in that order:</p>
<pre><code>from operator import itemgetter

class Foo(object):
    def __init__(self, *keyvalues):
        self._sequence = []
        for (key, value) in keyvalues:
            setattr(self, key, value)
            self._sequence.append(key)  # keep track of order added

    def __iter__(self):
        for key in self._sequence:
            yield key, getattr(self, key)

    def really_complex_method(self):
        pass

def attrs(instance):
    """ Return a list of instance attributes sorted their value. """
    return sorted((item for item in instance), key=itemgetter(1))

print(attrs(Foo(('bar', 1), ('baz', 2), ('quux', 3), ('question', -42))))
</code></pre>
<p><strong>Note</strong> that in all of these implementations, if <code>sorted()</code> wasn't used the <code>attrs()</code> function the attributes would be accessed in the order they were added (which was the only thing you originally seemed to want before revising your question).</p>
</div>
<div class="post-text" itemprop="text">
<p>Even if you sort the class attributes, as soon as they are stored in a <code>dict</code> the order will change. The best way is to use an <code>OrderedDict</code> which will preserve the order from the <code>sorted()</code> method.</p>
<pre><code>from collections import OrderedDict

class Foo(object):
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)
    def really_complex_method(self):
        pass


def attrs(cls):
    return OrderedDict(sorted(cls.__dict__.items()))

d = dict(bar=1, baz=2, quux=3)
print(attrs(Foo(**d)))
</code></pre>
</div>
<span class="comment-copy">Can you privide your dict order ? In other words, can you catch the order you want before continuing the process ?</span>
<span class="comment-copy">@Chiheb Nexus: Absolutely. Will update question to reflect this.</span>
<span class="comment-copy">Well, as i see the whole problem is to find if the return dict has the same order of <code>d dict</code> or not. right ? if not return a dict with the same order</span>
<span class="comment-copy">In essence, yes. The actual <code>__dict__</code>s I use contain quite a few dozen elements, mind you. But every method I've hacked on seemed way too verbose, and un-pythonesque.</span>
<span class="comment-copy">I never even imagined you could re-cast the <code>__dict__</code> as an <code>OrderedDict</code>. That is very, very clever Mr. Martineau!</span>
<span class="comment-copy">Fran√ßois: Thank you. Python doesn't always let you do such things, but in the case of <code>__dict__</code> it does. <code>OrderedDict</code> is a subclass of the built-in <code>dict</code> class so it fits the bill exactly.</span>
<span class="comment-copy">Your answer is really appreciated the-realtom. I see I should use a list in my example: the un-ordering is actually taking place when setting the object's attribute's <code>__dict__</code>. Calling <code>OrderedDict</code> to read from it doesn't fix that probem, unfortunately. I've actually updated the question to highlight that now.</span>
