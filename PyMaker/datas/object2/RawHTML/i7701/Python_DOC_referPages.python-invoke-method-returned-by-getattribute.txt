<div class="post-text" itemprop="text">
<p><em>If this question has a duplicate, sorry, I didn't find it, I will erese the question if someone does.</em></p>
<p>I have this simple python class:</p>
<pre><code>class NothingSpecial:
     @classmethod
     def meth(cls): 
          print("hi!")
</code></pre>
<p>And trying to get the method with different ways I did:</p>
<pre><code>a = (object.__getattribute__(NothingSpecial, 'meth'))

b = (getattr(NothingSpecial, 'meth'))
</code></pre>
<p>The question is, if I do:</p>
<pre><code>b()
</code></pre>
<blockquote>
<p>$hi!</p>
</blockquote>
<p>Is return, but when I do:</p>
<pre><code>a()
</code></pre>
<blockquote>
<p>TypeError: 'classmethod' object is not callable</p>
</blockquote>
<p>How can I execute the <code>a</code> method?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are bypassing the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, and you have an unbound class method.</p>
<p>The solution is to invoke the protocol, if there is a <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>__get__</code> method</a> present:</p>
<pre><code>if hasattr(a, '__get__'):
    a = a.__get__(None, NothingSpecial)
a()
</code></pre>
<p>Now the classmethod is bound to the class and it works again:</p>
<pre><code>&gt;&gt;&gt; a.__get__(None, NothingSpecial)
&lt;bound method NothingSpecial.meth of &lt;class '__main__.NothingSpecial'&gt;&gt;
&gt;&gt;&gt; a.__get__(None, NothingSpecial)()
hi!
</code></pre>
<p>Alternatively, use the <em>correct</em> <code>__getattribute__</code>, one that actually knows how to apply the descriptor protocol to class attributes; classes do not use <code>object.__getattribute__</code>, but <code>type.__getattribute__</code>:</p>
<pre><code>&gt;&gt;&gt; type.__getattribute__(NothingSpecial, 'meth')
&lt;bound method NothingSpecial.meth of &lt;class '__main__.NothingSpecial'&gt;&gt;
</code></pre>
<p>You'd actually want to access <code>type(NothingSpecial).__getattribute__</code> to allow metaclasses to override the implementation of <code>__getattribute__</code> here.</p>
</div>
<span class="comment-copy">Why are you using <code>object.__getattribute__</code>, anyway? That's the wrong <code>__getattribute__</code>.</span>
<span class="comment-copy">@user2357112 I'm using it because I'm trying to fully understand how it works</span>
<span class="comment-copy">Why the first parameter is None? I mean, I tryed and it worked, but all of it is a little new to me, sorry if the question are a little basics</span>
<span class="comment-copy">So, why is <code>NothingSpecial.__getattribute__</code> inherited from <code>object</code> when <code>isinstance(NothingSpecial, type)</code>?</span>
<span class="comment-copy">@DamianLattenero: the first argument is for an <i>instance</i>, but you have a class here, not an instance.</span>
<span class="comment-copy">@juanpa.arrivillaga: that's the method used for instances. Special methods are always looked up on the type, see <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer"><i>Special Method Lookup</i></a>.</span>
<span class="comment-copy">@MartijnPieters I think I'm start understanding, thanks a lot, plus one for great answer. In a few minutes I will accept</span>
