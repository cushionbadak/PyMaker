<div class="post-text" itemprop="text">
<p>anyone know why I got the wrong result? I know the there is a mistake in the last line in the code which is f=p0*pn*p</p>
<pre><code>import numpy as np

def passage(n,i,j):
    # this function calculate the first time passage distribution after n 
    #steps starting at i and end at j.

    p=np.matrix([[0,1,0,0],[0.5,0,0.5,0],[0,.5,0,.5],[0,0,1,0]])

    p0=p[:]
    for k in range(len(p)): # let elements in column j be zeros
        p0[k,j]=0

    p1=p0[:]
    for k in range(len(p)): #let element in column j and row j be zeros 
        p1[j,k]=0

    pn=np.linalg.matrix_power(p1,n-2)


    f=p0*pn*p      # this line gives us wrong result. why


    return f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One potential source of problems:</p>
<pre><code>p0=p[:]
</code></pre>
<p>produce a <code>view</code>, not a <code>copy</code>.  That means that after those 2 loops (which probably can be written without looping), <code>p</code>, <code>p0</code> and <code>p1</code> have the same values.</p>
<p>Did you actually test this code line by line, making sure each step was correct?  When I write functions in Python, and especially <code>numpy</code> have test out all steps interactively.  </p>
<p>Another thing - unless you really need it, don't use <code>np.matrix</code>.  Stick with <code>np.array</code> when creating arrays, even 2d ones.  And use <code>np.dot</code> (or <code>@</code>) if you need matrix multiplication.</p>
<p>A quick rewrite of your function:</p>
<pre><code>def passage(n,i,j):
    p=np.array([[0,1,0,0],[0.5,0,0.5,0],[0,.5,0,.5],[0,0,1,0]])
    p0=p.copy()
    p0[:,j] = 0
    p1=p0.copy()
    p1[j,:] = 0
    pn=np.linalg.matrix_power(p1,n-2)
    f = p0@pn@p    # or p0.dot(pn.dot(p))
    return f

In [15]: passage(4,0,0)
Out[15]: 
array([[ 0.125 ,  0.    ,  0.375 ,  0.    ],
       [ 0.    ,  0.1875,  0.    ,  0.1875],
       [ 0.1875,  0.    ,  0.5625,  0.    ],
       [ 0.    ,  0.375 ,  0.    ,  0.375 ]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The solution is to use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.copy.html" rel="nofollow noreferrer">np.copy()</a> to copy your <code>p</code> matrix.</p>
<pre><code>p0 = np.copy(p)
p1 = np.copy(p0)
</code></pre>
<p>If you still don't get the expected answer, then you might want to have a look at <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" rel="nofollow noreferrer">np.dot()</a> and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.matmul.html" rel="nofollow noreferrer">np.matmul()</a>.</p>
<p>Also note that <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-465" rel="nofollow noreferrer">PEP465</a> introduced <code>@</code> as a matrix multiplication operator.</p>
</div>
<span class="comment-copy"><code>*</code> is <b>not</b> a matrix product, but the elementwise product.</span>
<span class="comment-copy">What is the right or wrong results?  This question is woefully incomplete.  It needs a MVC example, and explanation of what  you want.</span>
<span class="comment-copy">I compared the result from the code with analytic result and Mathematica calculation.</span>
<span class="comment-copy">@WillemVanOnsem not on the <code>np.matrix</code> class, which all of <code>p</code>, <code>p0</code>, and <code>pn</code> are instances of when multiplication to get <code>f</code>.</span>
<span class="comment-copy">for i=j=0 and n=4 , the expected output is f= [[0.125, 0, 0.357, 0], [0, 0.1875, 0, 0.1875],[0.1875, 0, 0.5625, 0],[0, 0.375, 0, 0.375]]  @h</span>
