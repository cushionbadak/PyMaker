<div class="post-text" itemprop="text">
<p>What I want is :<br/>
original string : <code>(#1 AND #12) OR #10</code><br/>
convert to : <code>(something AND another_something) OR something_another</code> </p>
<p>mean to say is, according to <code>#number</code> replace it by a unique string </p>
<p>What I did is : </p>
<pre><code>filter_string = "(#1 AND #12) OR #10"
for fltr in filters_array:
        index = fltr[0] #numbers coming from here
        replace_by = fltr[1] #this string will replace original one
        filter_string = re.sub(r'#'+str(index),replace_by,filter_string)
</code></pre>
<p>Output : </p>
<pre><code>(something AND something2) OR something0
</code></pre>
<p>The Problem : rather then replacing #1 it replaces #12 and #11 also because #12 also have #1.<br/>
I tried with <code>count = 1</code> in <code>re.sub()</code> function but it did not worked because my string can be '<code>(#12 AND #1)</code>' as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may convert the list of tuples into a dictionary and use a <code>re.sub</code> with a pattern capturing the digit part and then a lambda expression in the replacement argument to find the right value by key:</p>
<pre><code>import re
filter_string = "(#1 AND #12) OR #10"
filters_array = [(1,"something"),(10,"something_another"),(12,"another_something")]
dt = dict(filters_array)
filter_string = re.sub(r'#([0-9]+)', lambda x: dt[int(x.group(1))] if int(x.group(1)) in dt else x.group(), filter_string)
print(filter_string)
# =&gt; (something AND another_something) OR something_another
</code></pre>
<p>The <code>#([0-9]+)</code> pattern matches <code>#</code> and then matches and captures into Group 1 one or more digits. Then, inside the lambda, the numeric value is used to fetch the existing value. If it does not exist, the <code>#</code> + the number will be inserted back into the result.</p>
<p>See the <a href="https://ideone.com/4tIO7G" rel="nofollow noreferrer">Python demo</a>.</p>
<p>If you need to further process the match, you may want to use a <em>callback</em> method rather than a lamda in the replacement argument:</p>
<pre><code>import re

filters_array = [(1,"something"),(10,"something_another"),(12,"another_something")]
dt = dict(filters_array)

def repl(m):
    return dt[int(m.group(1))] if int(m.group(1)) in dt else m.group()

filter_string = re.sub(r'#([0-9]+)', repl, "(#1 AND #12) OR #10")
print(filter_string)
</code></pre>
<p>See <a href="https://ideone.com/LtgGZw" rel="nofollow noreferrer">another Python demo</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use word boundary <code>\\b</code> anchor to force an exact number matching:</p>
<pre><code>filter_string = "(#1 AND #12) OR #10"
filters_array = [(1,"something"),(10,"something_another"),(12,"another_somet‌​hing")]
for num,s in filters_array:
    filter_string = re.sub(r'#'+ str(num) +'\\b', s, filter_string)

print(filter_string)
</code></pre>
<p>The output:</p>
<pre><code>(something AND another_somet‌​hing) OR something_another
</code></pre>
<p><a href="http://www.regular-expressions.info/wordboundaries.html" rel="nofollow noreferrer">http://www.regular-expressions.info/wordboundaries.html</a></p>
</div>
<span class="comment-copy">What does your <code>filters_array</code> look like?</span>
<span class="comment-copy">its like [(1,"something"),(10,"something_another"),(12,"another_something")]</span>
<span class="comment-copy">Try <code>re.sub(r'#'+str(index)+'$',replace_by_filter_string)</code>. The <code>$</code> matches the end of strings. <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">See here</a></span>
<span class="comment-copy">no but its not end-of-string it can be (#12 AND #1) as well. so after #number as colsing brace ')' and similarly a space may exist.</span>
<span class="comment-copy">i tries this code,it worked. but is this approach efficient?</span>
<span class="comment-copy">@RajShah: Note that with this approach, the string is only replaced <i>once</i>. When you use a loop, you modify the string as many times as there are items in your <code>filters_array</code>. Another note: the regex may be <code>r'#([0-9]+)\b'</code> depending on the requirements.</span>
<span class="comment-copy">my string wil have unique numbers only.so no problem.</span>
<span class="comment-copy">@RajShah If you have 100 numbers, do you want to change your string 100 times, or only once? Surely, it is up to you.</span>
<span class="comment-copy">@RomanPerekhrest Then a callback is more appropriate than a lambda, still this approach is more efficient.</span>
<span class="comment-copy">oh yes this worked.</span>
