<div class="post-text" itemprop="text">
<p>In order to format the string properly, I was required to split it into different lengths of chunks. </p>
<p>As an example, This is a string - <code>25c319f75e3fbed5a9f0497750ea12992b30d565</code>, For splitting it in fixed length chunks, I would simply use steps and slicing:</p>
<pre><code>s = '25c319f75e3fbed5a9f0497750ea12992b30d565'
n = 2
print("-".join([s[i:i+n] for i in range(0, len(s), n)]))
</code></pre>
<p>However, What could i do if <code>n</code> was list of numbers to be split, As example:</p>
<pre><code>s = '25c319f75e3fbed5a9f0497750ea12992b30d565'
n = [8, 4, 4, 4, 4, 12] # edited for consistency - Coldspeed
</code></pre>
<p>Only solution i made was this:</p>
<pre><code>print("-".join([s[0:8], s[8:12], s[12:16], s[16:20], s[20:24], s[24:32]]))
</code></pre>
<p>Which is not pythonic and more necessarily not reliable length of string is large.</p>
<p>The output from the last example of code:</p>
<pre><code>25c319f7-5e3f-bed5-a9f0-4977-50ea1299
</code></pre>
<p>So can this be done in more pythonic one liner way? If not what are other more automatic ways for this to be done?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; s = '25c319f75e3fbed5a9f0497750ea12992b30d565'
&gt;&gt;&gt; n = [8, 4, 4, 4, 4, 12]
&gt;&gt;&gt; print '-'.join([s[sum(n[:i]) : sum(n[:i+1])] for i in range(len(n))  ])
</code></pre>
<p>Output</p>
<pre><code>25c319f7-5e3f-bed5-a9f0-4977-50ea12992b30
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create an iterator from the string and slice incrementally using <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>:</p>
<pre><code>from itertools import islice

s = '25c319f75e3fbed5a9f0497750ea12992b30d565'
it = iter(s)
n = [8, 4, 4, 12]

s = '-'.join(''.join(islice(it, None, x)) for x in n)
print(s)
# 25c319f7-5e3f-bed5-a9f0497750ea
</code></pre>
<p>Note that the trailing part of the string is lost if the total size of the slice(s) does not equal the length of the string; iterator is not completely exhausted.</p>
<p>You may append the trailing part (if needed) in a final preprocessing stage:</p>
<pre><code>s += '-' + ''.join(it)
print(s)
# 25c319f7-5e3f-bed5-a9f0497750ea-12992b30d565
</code></pre>
<hr/>
<p>Here's another approach that uses a for loop, slicing the string incrementally by increasing the start index:</p>
<pre><code>start = 0
d = []
for i in n:
   d.append(s[start:start+i])
   start += i
d.append(s[start:])
print('-'.join(d))
# 25c319f7-5e3f-bed5-a9f0497750ea-12992b30d565
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = '25c319f75e3fbed5a9f0497750ea12992b30d565'
n = [8, 4, 4, 12]

def make_chunks(s,n):
    result = []
    for length in n:
        result.append(s[:length])
        s = s[length:]
    if s:
        result.append(s)
    return '-'.join(result)

print(make_chunks(s,n))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not a one-linear I'm afraid, but from the top of my head:</p>
<pre><code>s = '25c319f75e3fbed5a9f0497750ea12992b30d565'
n = [8, 4, 4, 4, 4, 12]
res=[]
for split in n:
    temp=s[:split]
    s=s[split:]
    res.append(temp) 
print(res)
</code></pre>
<p>The output is an array with the respective strings that can be manipulated accordingly:</p>
<pre><code> ['25c319f7', '5e3f', 'bed5', 'a9f0', '4977', '50ea12992b30']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If we start from the listed data:</p>
<pre><code>string = '25c319f75e3fbed5a9f0497750ea12992b30d565'
lengths = [8, 4, 4, 12]
</code></pre>
<p>We can use a scan to find the beginnings or ends of each part:</p>
<pre><code>import itertools
ends = list(itertools.accumulate(lengths))
</code></pre>
<p>It appears <code>accumulate</code> is specific to Python 3, so we might need a workaround to do the scan in Python 2 (this one's slow at O(nÂ²)):</p>
<pre><code>starts = [sum(lengths[:i]) for i in range(len(lengths))]
</code></pre>
<p>And then we can use the combination to extract parts:</p>
<pre><code>dashed = '-'.join(string[end-length : end]
                  for end,length in zip(ends,lengths))
</code></pre>
<p>The advantage of all this length/index manipulation is that it doesn't create copies of the string, only its individual parts. Otherwise Sean's solution is very neat. </p>
</div>
<span class="comment-copy">Thanks for the answer. Output is - <code>---19f75e3f</code></span>
<span class="comment-copy">Now the output is - <code>--19f7-5e3</code></span>
<span class="comment-copy">@ShellRox A bit late but here's a 1 liner without itertools. Beware it is inefficient because it keeps calling sum. But it works.</span>
<span class="comment-copy">Thanks for the answer, It cannot be done without the help of the itertools correct?</span>
<span class="comment-copy">@ShellRox Any reason for not wanting to use itertools?</span>
<span class="comment-copy">@ShellRox I think you may want to take a break. I'm not going to comment any further. All the answers here provided do exactly what you've described in your question.</span>
<span class="comment-copy">@ShellRox I honestly think you should select this answer. It is clear, concise, very pythonic, and does exactly what your examples have dictated. If not, you should be more clear when explaining your problem to prevent wasting both yours and our time.</span>
<span class="comment-copy">@ShellRox Yeah. I've edited your question for consistency. Like I said, do be clear with your questions and you'll save everyone a lot of headache. Cheers.</span>
<span class="comment-copy">Thanks for the answer, Definitely useful but i'm trying to find solution which uses regular python only.</span>
<span class="comment-copy">How is this not regular Python? It's all standard library.</span>
<span class="comment-copy">Sorry for misunderstanding, I mean i'm trying to avoid using modules in this case since it is possible.</span>
<span class="comment-copy">It is always possible, but whether it's efficient or legible is another matter. An example of doing it without the itertools module is the Python 2 comprehension I showed.</span>
<span class="comment-copy">I am required to use the ends array which uses itertools accumulate which is Python 3 specific, Is there any alternative for python2?</span>
