<div class="post-text" itemprop="text">
<p>What is the easiest way to make sure this code runs only 8 threads at a time. I need it to keep running and reusing threads. If one thread finishes, it should start another in its place immediately.</p>
<pre><code>threads = []
for user in user_list:
    thread = threading.Thread(target=parse_func, args= self,user,thread_name,), name= thread_name)
    thread.start()
    threads.append(thread)
for t in threads:
    t.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may want to look into <a href="https://docs.python.org/2/library/threading.html#semaphore-objects" rel="nofollow noreferrer">semaphores</a> and use it like this:</p>
<pre><code>threading.BoundedSemaphore(maximumNumberOfThreads)
</code></pre>
<p>Taken from the documentation, semaphores are usually used to guard resources with limited capacity, for example, a database server.</p>
<p>Another example is the following, taken from the <a href="https://docs.python.org/2.4/lib/semaphore-examples.html" rel="nofollow noreferrer">documentation</a>:
Before spawning any worker threads, your main thread would initialize the semaphore:</p>
<pre><code>maxconnections = 5
...
pool_sema = BoundedSemaphore(value=maxconnections)
</code></pre>
<p>Once spawned, worker threads call the semaphore's acquire and release methods when they need to connect to the server:</p>
<pre><code>pool_sema.acquire()
conn = connectdb()
... use connection ...
conn.close()
pool_sema.release()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want a <em>thread pool</em>.</p>
<p>The idea of a thread pool, is that instead of creating new threads, your application code creates new <em>tasks</em>, and then it <em>submits</em> the tasks to the thread pool.  The pool consists of some number of threads (maybe a variable number, maybe a fixed number, depends how its implemented) and a blocking queue.</p>
<p>The client program puts tasks onto the blocking queue, while each of the pool threads sits in a loop, taking tasks from the queue and <em>performing</em> them.</p>
<p>A simplistic thread pool might have a fixed set of threads, and it might run forever.  A sophisticated thread pool might have means to spin up or shut down threads in response to changing demand and/or changing system load.</p>
<p>I don't have enough Python experience to know whether there is a standard thread pool interface that everybody uses or, to recommend any existing thread pool implementation.</p>
<p>You can always write your own.  A thread pool with eight fixed threads that run forever would not be hard to make.</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up spawning the exact number of threads I needed, let's say a 100:</p>
<pre><code>for i in range(100):
    Thread(target=get_url).start()
</code></pre>
<p>Since I wanted the threads to each keep alive and keep checking the processing queue, I used an infinite loop inside each thread, so that the 100 threads keep running. I could not use a thread pool since it would shutdown as soon as the queue was exhausted the first time - if I refilled the queue with more work an hour later, the thread pool would have already shut down at that point so I had to make sure to create a new pool etc. At this point it becomes easier to maintain my own pool. </p>
<pre><code>def get_url():
    while True:
        item = q_worker.get()
        #do work with item
        q_worker.task_done()
</code></pre>
</div>
<span class="comment-copy">The docs for the <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">queue module</a> contain an example.</span>
<span class="comment-copy">Your answer looks like a a way to limit the number of threads that are runnable, but I think the OP is looking for a way to limit the number of threads that <i>exist</i>.</span>
<span class="comment-copy">Ohhh, you may be right...thanks for the hint. Lets see if the OP can clear that up ;)</span>
