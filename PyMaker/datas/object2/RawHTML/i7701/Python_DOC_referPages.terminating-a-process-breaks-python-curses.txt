<div class="post-text" itemprop="text">
<p>Using python multiprocessing and curses, it appears that terminating a Process interferes with curses display.<br/>
For example, in the following code, why does terminating the process stops curses from displaying the text ? (pressing b after pressing a)<br/>
More precisely, it seems that not only the string "hello" is not displayed anymore but also the whole curses window.</p>
<pre><code>import curses
from multiprocessing import Process
from time import sleep

def display(stdscr):
    stdscr.clear()
    curses.newwin(0,0)
    stdscr.timeout(500)
    p = None
    while True:
        stdscr.addstr(1, 1, "hello")
        stdscr.refresh()
        key = stdscr.getch()
        if key == ord('a') and not p:
            p = Process(target = hang)
            p.start()
        elif key == ord('b') and p:
            p.terminate()

def hang():
    sleep(100)

if __name__ == '__main__':
    curses.wrapper(display)
</code></pre>
<p>I'm running python 3.6 under GNU/Linux.</p>
<p><strong>Edit :</strong><br/>
I'm still able to reproduce with this more stripped down version which doesn't call sleep(). Now just pressing "a" triggers the bug.</p>
<pre><code>import curses
from multiprocessing import Process

def display(stdscr):
    stdscr.clear()
    curses.newwin(0,0)
    stdscr.timeout(500)
    p = None
    while True:
        stdscr.addstr(1, 1, "hello")
        stdscr.refresh()
        key = stdscr.getch()
        if key == ord('a') and not p:
            p = Process(target = hang)
            p.start()
            p.terminate()

def hang():
    while True:
        temp = 1 + 1

if __name__ == '__main__':
    curses.wrapper(display)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following code works:</p>
<pre><code>import curses
from multiprocessing import Process

p = None
def display(stdscr):
    stdscr.clear()
    curses.newwin(0,0)
    stdscr.timeout(500)
    while True:
        stdscr.addstr(1, 1, "hello")
        stdscr.refresh()
        key = stdscr.getch()
        if key == ord('a') and not p:
            p.start()
            p.terminate()

def hang():
    while True:
        temp = 1 + 1

if __name__ == '__main__':
    p = Process(target = hang)
    curses.wrapper(display)
</code></pre>
<p>I created a new <code>Process</code> before initializing the UI using <code>curses.wrapper()</code>. Okay, why does this work? For this we must know how <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">Proccess</a> works and what exactly it does when you call <code>Process(target = hang)</code>:</p>
<blockquote>
<p>fork</p>
<p>The parent process uses os.fork() to fork the Python interpreter. The child process, when it begins, is effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a multithreaded process is problematic.</p>
<p>Available on Unix only. The default on Unix.</p>
</blockquote>
<p>Now, what does it tell us? You where creating a new <code>Processes</code> when you already created a <code>curses</code> screen. What does <a href="https://docs.python.org/3.3/library/curses.html#curses.wrapper" rel="nofollow noreferrer">curses.wrapper()</a> do?</p>
<blockquote>
<p>Before calling func, wrapper() turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.</p>
</blockquote>
<p>Okay, we have a newly created child process that has the exact same resources as its parent. When you call <code>terminate()</code> to kill the child, it frees all resources, including the curses wrapper. It restores the previous terminal settings and therefore breaks your UI.</p>
<p>To fix this you have to implement your program differently. Create a new process beforehand, use <a href="https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes" rel="nofollow noreferrer">IPC</a> to communicate with your process, use <a href="https://docs.python.org/3/library/multiprocessing.html#using-a-pool-of-workers" rel="nofollow noreferrer">Process Pools</a> if you need multiple processes, <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">Threading</a> or <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">Thread Pools</a> if you have IO bound tasks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you running this on Windows, perhaps?  One of the documented requirements of the multiprocessing module on that platform is that all top-level code (the <code>curses.wrapper(display)</code> in your case) MUST be inside an <code>if __name__ == '__main__':</code> block, so that it isn't accidentally executed in your spawned process.</p>
<p>I think what's happening here is that your spawned process is initializing curses itself (which involves setting up the console appropriately), and then reverts the console to normal when it terminates - thus undoing the setup done by the original program.</p>
</div>
<span class="comment-copy">According to the documentation, using <code>terminate()</code> can cause problems when the process uses a lock or semaphore: <code>Warning If this method is used when the associated process is using a pipe or queue then the pipe or queue is liable to become corrupted and may become unusable by other process. Similarly, if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock.</code> I'm not sure how <code>sleep</code> is implemented, but that might be the reason. <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">@amuttsch nice idea, but that's not it, see my edit.</span>
<span class="comment-copy">Thanks. Though I'm still unsure why freeing the ressources of the child process messes up the ressources of the parent ?</span>
<span class="comment-copy">Apart from that, in my actual code I really have an UI action that starts a process. To my understanding, using pools or creating processes beforehand would limit the number of uses of this action, which is problematic usability-wise. Would not relying on the wrapper and do the initialization by hand be an acceptable solution ?</span>
<span class="comment-copy">It doesn't mess up the resources of the parent, but since the curses screen was initilaized via <code>wrapper</code>, it resets the terminal settings. The parent doesn't know this.</span>
<span class="comment-copy">You can try not using wrapper. I don't know your exact code, so it's difficult to give good advice on what is the best solution to your use case. What do you want to execute in the child task? Remember: Parallel programming is hard, so you have to figure out the best way to solve your problem. Read the documentation about Processes and Threads, this should help you making a decision.</span>
<span class="comment-copy">You  could also try using <code>spawn</code> as start method, then not all resources are copied to the child process.</span>
<span class="comment-copy">Hi and thanks for answering, I edited my question to add platform infos and the required block, which I forgot while stripping down my actual code. It changes nothing to the issue, though ; are you not able to reproduce it ?</span>
<span class="comment-copy">Perhaps you could also clarify what you meant by "stops curses from displaying the text".  No additional text is displayed after you start or stop the process, and the "hello" that was displayed at the start is being continually refreshed, so I'm not sure what's actually happening (and I'm not able to try to reproduce at the moment).</span>
<span class="comment-copy">Edited to add precisions, but it should probably be seen rather than described. The refresh every 0.5s is intended, and what's actually happening is the question.</span>
