<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly">List of lists changes reflected across sublists unexpectedly</a>
<span class="question-originals-answer-count">
                    12 answers
                </span>
</li>
</ul>
</div>
<p>I need to initialize 2d array with list.<br/>
For example 2X3 array: <code>[[0,0,0], [0,0,0]]</code></p>
<p>First attempt:  </p>
<pre><code>In: a1 = [[0]*3]*2
In: a1[0][0] = 100
In: a1
Out: [[100,0,0], [100,0,0]]
</code></pre>
<p>This is strange. So I checked:</p>
<pre><code>In: a1 = [[0]*3]*2
In: id(a1[0][0])
Out: 4518461984
In: id(a1[1][0])
Out: 4518461984
</code></pre>
<p>Same address.</p>
<p>Second attempt:</p>
<pre><code>In: a2 =[[0]*3 for i in range(2)]
In: a2[0][0] = 100
In: a2
Out: [[100, 0, 0], [0, 0, 0]]
</code></pre>
<p>Right.</p>
<p>Let me check memory address again:</p>
<pre><code>In: a2 =[[0]*3 for i in range(2)]
In: id(a2[0][0])
Out: 4518461984
In: id(a2[1][0])
Out: 4518461984
</code></pre>
<p>Well, strange. Same address again. I expected different addresses. My initial guess is that the address returned is the address of pointer to value. Then how can I retrieve the address of the slot?</p>
<p>Is there anyone who can explain the workings of Python that caused this behavior? In Python, I think it's very hard to know which is pointer and which is value.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python the expression <code>[v] * n</code> is equivalent to <em>"append a reference to <code>v</code> to the outer list <code>n</code> times".</em></p>
<p>This is always fine for <code>f</code> being a literal:</p>
<pre><code>a = [1] * 4
id(a[0]) == id(a[2])    # True

a[0] = 15                
print(a)                # a == [15, 1, 1, 1]
</code></pre>
<p>However, the same mechanism applies for <code>f</code> being a mutable. A reference to <code>f</code> is inserted <code>n</code> times. </p>
<pre><code>a = [ [1, 2, 3] ] * 3
</code></pre>
<p>If you then modify any element of <code>a</code>, all the others will also be modified, since they are all references to the same list.</p>
<pre><code>a[0][0] = 2
print(a)        # [[2, 2, 3], [2, 2, 3], [2, 2, 3]]
</code></pre>
<p>You can learn more about this behavior by reading the docs on <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-common" rel="nofollow noreferrer">common sequence operations</a>.</p>
<p>The suggested way of creating a multidimensional list is:</p>
<pre><code>n = 5
mda = [[0] * 3 for _ in range(5)]
</code></pre>
<p>This works, because in each iteration of the loop a new list instance is created and then appended to the outer list.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're comparing the memory address of the values in the lists not the addresses of your lists.</p>
<p>The memory addresses of your lists differ:</p>
<pre><code>&gt;&gt;&gt; a2 =[[0]*3 for i in range(2)]
&gt;&gt;&gt; id(a2[0]) == id(a2[1])   # compare memory addresses of the sublists
False
</code></pre>
<p>But in your first example the "sub" lists are identical:</p>
<pre><code>&gt;&gt;&gt; a1 = [[0]*3]*2       
&gt;&gt;&gt; id(a1[0]) == id(a1[1])
True
</code></pre>
<p>The question why the values have the same memory adress is more complicated:</p>
<ul>
<li><p>Python reuses the integers -5 to 255 (<a href="https://stackoverflow.com/q/15171695/5393381">CPython at least</a>) so <code>0</code> will always have the same memory address.</p>
<pre><code>&gt;&gt;&gt; a = 0
&gt;&gt;&gt; b = 0
&gt;&gt;&gt; a is b  
True
</code></pre></li>
<li><p>literal numbers like <code>10000</code> have the same memory address if they are defined in the same block (used in the same function - maybe also same module - or in the same "line" when not in a function).</p>
<pre><code>&gt;&gt;&gt; a = 5000
&gt;&gt;&gt; b = 5000
&gt;&gt;&gt; a is b    # different "lines" and not in a function!
False

&gt;&gt;&gt; a, b = 5000, 5000
&gt;&gt;&gt; a is b    # defined on the same "line"
True
</code></pre></li>
<li><p>When you multiply a <code>list</code> the references are reused. In this case it doesn't matter because it's a literal number, so the reference is always reused. But in case it's not a literal number that may be important:</p>
<pre><code>&gt;&gt;&gt; l = [int('1000')]*3
&gt;&gt;&gt; l[0] is l[1]
True

&gt;&gt;&gt; l = [int('1000') for _ in range(3)]
&gt;&gt;&gt; l[0] is l[1]
False
</code></pre></li>
</ul>
<p>In your case you define the number in the same line and it's a small integers so they will always have the same memory address.</p>
</div>
<span class="comment-copy">I've read it, but it's different because, it is about when copy is generated depending on using * or range.</span>
<span class="comment-copy">This comment by @Coldspeed solved my question.  <code>As an added note, beware that, if using * with mutable structures, those references are reused as well. â€“ Coldspeed</code></span>
<span class="comment-copy">As an added note, beware that, if using * with mutable structures, those references are reused as well.</span>
<span class="comment-copy">@Coldspeed That's correct, but that only affects each sublist not if you compare different sublists. The reason why the first number in the first sublist has the same id as the first number in the second sublist is because of the "small integer cache".</span>
