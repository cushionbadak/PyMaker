<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/42071861/python-commutative-operator-override">Python commutative operator override</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I have a simple class that helps with mathematical operations on vectors (i.e. lists of numbers). My <code>Vector</code> can be multiplied by other instances of <code>Vector</code> <em>or</em> a scalar (<code>float</code> or <code>int</code>).</p>
<p>In other, more strongly typed, languages I would create a method to multiply two <code>vector</code>s and a separate method to multiply a <code>vector</code> by and <code>int</code>/<code>float</code>. I'm still pretty new to Python and am not sure how I would implement this. The only way I can think of doing it is override <code>__mul__()</code> and test the incoming parameter:</p>
<pre><code>class Vector(object):
  ...
 def __mul__(self, rhs):
  if isinstance(rhs, Vector):
     ...
  if isinstance(rhs, int) or isinstance(rhs, float):
    ...
</code></pre>
<p>Even if I do it that way I would be forced to multiply a <code>Vector</code> by a scalar like this:</p>
<pre><code>v = Vector([1,2,3])

result = v * 7
</code></pre>
<p>What if I wanted to reverse the order of the operands in the multiplication?</p>
<pre><code>result = 7 * v
</code></pre>
<p>What is the right way to do that in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You also need to implement <code>__rmul__</code>. When the initial call to <code>int.__mul__(7, v)</code> fails, Python will next try <code>type(v).__rmul__(v, 7)</code>.</p>
<pre><code>def __rmul__(self, lhs):
    return self * lhs  # Effectively, turn 7 * v into v * 7
</code></pre>
<p>As Rawing points out, you could simply write <code>__rmul__ = __mul__</code> for this definition. <code>__rmul__</code> exists to allow for non-commutative multiplication where simply deferring to <code>__mul__</code> with the operands reversed isn't sufficient.</p>
<p>For instance, if you were writing a <code>Matrix</code> class and wanted to support multiplication by a nested list, e.g.,</p>
<pre><code>m = Matrix(...)  # Some 2 x 2 matrix
n = [[1, 2], [3,4]]
p = n * m
</code></pre>
<p>Here, the <code>list</code> class wouldn't know how to multiple a list by a <code>Matrix</code> instance, so when <code>list.__mul__(n, m)</code> fails, Python would next try <code>Matrix.__rmul__(m, n)</code>. However, <code>n * m</code> and <code>m * n</code> are two different results in general, so <code>Matrix.__rmul__(m, n) != Matrix.__mul__(m, n)</code>; <code>__rmul__</code> has to do a little extra work to generate the right answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are <a href="https://docs.python.org/3/reference/datamodel.html#object.__radd__" rel="noreferrer">special methods for reversed operations</a>:</p>
<ul>
<li><code>__rmul__</code> for the reverse of <code>__mul__</code> </li>
<li>and <code>__radd__</code> for <code>__add__</code>,</li>
<li>...</li>
</ul>
<p>These are called when the left hand side operator returns <code>NotImplemented</code> for the normal operation (so the operation <code>2 + vector_instance</code> will first try: <code>(2).__add__(vector_instance)</code> but if this returns <code>NotImplemented</code> then <code>vector_instance.__radd__(2)</code> is called).</p>
<p>However I wouldn't use <code>isinstance</code> checks in the arithmetic special methods, that will lead to a lot of code repetition. </p>
<p>You could actually create a special case in <code>__init__</code> and implement a conversion from scalars to a <code>Vector</code> there:</p>
<pre><code>class Vector(object):
    def __init__(self, x, y=None, z=None):
        if y is None and z is None:
            if isinstance(x, Vector):
                self.x, self.y, self.z = x.x, x.y, x.z
            else:
                self.x, self.y, self.z = x, x, x
        elif y is None or z is None:
            raise ValueError('Either x, y and z must be given or only x')
        else:
            self.x, self.y, self.z = x, y, z

    def __mul__(self, other):
        other = Vector(other)
        return Vector(self.x*other.x, self.y*other.y, self.z*other.z)

    __rmul__ = __mul__   # commutative operation

    def __sub__(self, other):
        other = Vector(other)
        return Vector(self.x-other.x, self.y-other.y, self.z-other.z)

    def __rsub__(self, other):   # not commutative operation
        other = Vector(other)
        return other - self

    def __repr__(self):
        return 'Vector({self.x}, {self.y}, {self.z})'.format(self=self)
</code></pre>
<p>This should work as expected:</p>
<pre><code>&gt;&gt;&gt; 2 - Vector(1, 2, 3)
Vector(1, 0, -1)

&gt;&gt;&gt; Vector(1, 2, 3) - 2
Vector(-1, 0, 1)

&gt;&gt;&gt; Vector(1, 2, 3) * 2
Vector(2, 4, 6)

&gt;&gt;&gt; 2 * Vector(1, 2, 3)
Vector(2, 4, 6)
</code></pre>
<p>Note that this was a quick and dirty draft (that could have several bugs). I just wanted to present the "general idea" how it could be solved without special casing the type in each arithmetic operation.</p>
</div>
<span class="comment-copy">Personally I would just use <code>NumPy</code> arrays. They already support element-wise operations (with other arrays <b>and</b> scalars). It also includes inner and outer products and accumulation functions like <code>sum</code>. That makes the task almost trivial.</span>
<span class="comment-copy">I <i>knew</i> I was going to get that comment. ;-) This is a throw-away class I'm using to become familiar with Python. I am well aware of Numpy, Scipy, Pandas, etc.</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/42071861/python-commutative-operator-override" title="python commutative operator override">stackoverflow.com/questions/42071861/â€¦</a></span>
<span class="comment-copy">Strong vs. weak typing has no indication on whether a language has operator overloading. Scala and C++ both have operator overloading. It's only Java that doesn't.</span>
<span class="comment-copy">You almost certainly want to do <code>return self.__mul__(lhs)</code>, not <code>return self * lhs</code>; the latter implementation invokes the same "try left operator then right operator" machinery you're already running, so if <code>self.__mul__</code> returned <code>NotImplemented</code>, and <code>lhs</code> had the same broken <code>__rmul__</code> implementation, you end up with each <code>__rmul__</code> calling the other (after <code>__mul__</code> returns <code>NotImplemented</code> each time) back and forth, recursively, until you overflow the stack. Explicitly calling <code>__mul__</code> avoids that potential infinite recursion.</span>
<span class="comment-copy">Thank you for the ' <b>rmul</b> = __mul__` tip. I wouldn't have known that was possible in Python.</span>
