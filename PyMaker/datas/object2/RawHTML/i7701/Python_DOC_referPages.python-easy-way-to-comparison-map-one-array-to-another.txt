<div class="post-text" itemprop="text">
<p>I have an array <code>a = [1, 2, 3, 4, 5, 6]</code> and <code>b = [1, 3, 5]</code> and I'd like to map <code>a</code> such that for every element in <code>a</code> that's between an element in <code>b</code> it will get mapped to the index of <code>b</code> that is the upper range that <code>a</code> is contained in. Not the best explanation in words but here's an example</p>
<pre><code>a = 1 -&gt; 0 because a &lt;= first element of b
a = 2 -&gt; 1 because b[0] &lt; 2 &lt;= b[1] and b[1] = 3
a = 3 -&gt; 1 
a = 4 -&gt; 2 because b[1] &lt; 4 &lt;= b[2]
</code></pre>
<p>So the final product I want is <code>f(a, b) = [0, 1, 1, 2, 2, 2]</code></p>
<p>I know I can just loop and solve for it but I was wondering if there is a clever, fast (vectorized) way to do this in pandas/numpy</p>
</div>
<div class="post-text" itemprop="text">
<p>Use python's <code>bisect</code> module:</p>
<pre><code>from bisect import bisect_left

a = [1, 2, 3, 4, 5, 6]
b = [1, 3, 5]

def f(_a, _b):
  return [bisect_left(_b, i) for i in _a]

print(f(a, b))
</code></pre>
<blockquote>
<p><strong>bisect â€” Array bisection algorithm</strong></p>
<p>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</p>
<p>The following functions are provided:</p>
<p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code> </p>
<p>Locate the insertion point for <em>x</em> in <em>a</em> to maintain sorted order. The parameters <em>lo</em> and <em>hi</em> may be used to specify a subset of the list which should be considered; by default the entire list is used. If <em>x</em> is already present in <em>a</em>, the insertion point will be before (to the left of) any existing entries.
  The return value is suitable for use as the first parameter to <code>list.insert()</code> assuming that <em>a</em> is already sorted.</p>
<p>The returned insertion point <em>i</em> partitions the array <em>a</em> into two halves so that <code>all(val &lt; x for val in a[lo:i])</code> for the left side and <code>all(val &gt;= x for val in a[i:hi])</code> for the right side.</p>
</blockquote>
<p>Reference:
<a href="https://docs.python.org/3/library/bisect.html" rel="noreferrer">https://docs.python.org/3/library/bisect.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>bisect is faster: the solution assumes lists are sorted</p>
<pre><code>a = [1, 2, 3, 4, 5, 6]
b = [1, 3, 5]

inds=[min(bisect_left(b,x),len(b)-1) for x in a]
</code></pre>
<p>returns</p>
<pre><code>[0, 1, 1, 2, 2, 2]
</code></pre>
</div>
<span class="comment-copy">Are those arrays always ordered?</span>
<span class="comment-copy">Yes you can assume that they are ordered. Also can assume that every element of b is contained in a (a more general solution without this constraint would be fantastic, but i think it makes it easier)</span>
