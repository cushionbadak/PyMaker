<div class="post-text" itemprop="text">
<h1>Some Context</h1>
<p>I have the following django/python snippet:</p>
<pre><code>from rest_framework import serializers
from .models import Profile, Task

class Serializable():
    types = {}
    def __init__(self, objectid):
        self.object = self.types[objectid][0]
        self.serializer = self.types[objectid][1]

    def serialized(self):
        instances = self.object.objects.all()
        serialized = self.serializer(instances, many=True)
        return serialized


class ProfileSerializer(serializers.ModelSerializer):
    class Meta:
        oid = 'profile'
        model = Profile
        fields = ['login', 'status']
        Serializable.types[oid] = [model, &lt;class-reference&gt;]

class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        oid = 'task'
        model = Task
        fields = ['description', 'date', 'owner']
        Serializable.types[oid] = [model, &lt;class-reference&gt;]
</code></pre>
<p>I am using Django with the <code>rest_framework</code> library installed. One of the interesting features I am using is <code>ModelSerializers</code> (<a href="http://www.django-rest-framework.org/tutorial/1-serialization/#using-modelserializers" rel="nofollow noreferrer">ModelSerializers Documentation</a>), which save quite a lot of code repetition. I want <code>Serializable.types</code> variable to be populated on runtime (when all the serializer classes are declared). The whole point of this is that I will not have to update my views whens a new type of model is included. For example, I would print the json representation of my model instances like this:</p>
<pre><code>class QueryObject(APIView):
    permission_classes = (AllowAny,)

    def get(self, request, *args, **kwargs):
        oid = request.GET['oid']
        serializable= Serializable(oid)
        json = serializable.serialized
        return JsonResponse(json)
</code></pre>
<h1>The Problem</h1>
<p>The major problem is in the last line of each <code>Serializer</code> class.</p>
<pre><code>Serializable.types[oid] = [model, &lt;class-reference&gt;]
</code></pre>
<p>I've tried putting the name of the class, <code>ProfileSerializer</code> for example, to no avail. I've tried doing the same outside of the <code>Meta</code> class, such as:</p>
<pre><code>class ProfileSerializer(serializers.ModelSerializer):
    class Meta:
        oid = 'profile'
        model = Profile
        fields = ['login', 'status']

    Serializable.types[Meta.oid] = [Meta.model, ProfileSerializer]
</code></pre>
<p>also not successful. Not sure what else to do, which is why I'm hoping the community can help me on this one.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is actually a case for defining a metaclass.</p>
<p>I've never actually found a source of information which gives a complete, clear and satisfactory explanation as to what metaclasses are or how they work. I will try to enhance this answer with such information if required but for the time being I am going to stick to a solution for your present problem. I am assuming python 3.</p>
<p>Define an additional class, thus:</p>
<pre><code>class ModelSerializerMeta(serializers.SerializerMetaclass):

    def __init__(cls, class_name, base_classes, attributes):

        super(ModelSerialiserMeta, cls).__init__(class_name, base_classes, attributes)
        Serializer.types[cls.Meta.oid] = [cls.Meta.model, cls]
</code></pre>
<p>Then use this as the metaclass of your Serializers, e.g.</p>
<pre><code>class ProfileSerializer(serializers.ModelSerializer, metaclass=ModelSerializerMeta):

    class Meta:
        oid = 'profile'
        model = Profile
        fields = ['login', 'status']
</code></pre>
<p>Better yet, create some superclass for all your model serializers, assign the metaclass there, make all of your serializers inherit from that superclass which will then use the metaclass throughout.</p>
</div>
<div class="post-text" itemprop="text">
<p>Metaclasses are definitely the right answer unless your code can require python &gt;= 3.6.  Starting with 3.6 there is a new feature called the <a href="https://docs.python.org/3/whatsnew/3.6.html" rel="nofollow noreferrer"><code>__init_subclass__</code></a> hook.</p>
<p>So you can do something like</p>
<pre><code>class foo:

    @classmethod
    def __init_subclass__(cls, *args, **kwargs):
        Serializers.register_class(cls)
</code></pre>
<p>Whenever a child of <code>Foo</code> is defined, the <code>__init_subclass__</code> method on <code>Foo</code> will be called, passing in the child class reference as <code>cls</code>.</p>
</div>
<span class="comment-copy">Can you explain to me how my Serializable class will eventually be called? I can see that it's in the ModelSerializerMeta (cls.types), but where is cls actually defined?</span>
<span class="comment-copy">cls is defined by the Python interpreter. The one sentence reduction is that the ModelSerializerMeta code is executed when the interpreter encounters your class definition, which is then passed to the metaclass to manage the class creation.  If that is insufficient, I strongly recommend googling around for python metaclasses, as there's a lot of writing out there, but I don't really know how to explain it any better.</span>
<span class="comment-copy">You would call your Serializable class in the same way you would normally.</span>
<span class="comment-copy">@PhillipAdler, I used your solution, but changed cls.types[cls.Meta.oid] = [cls.Meta.model, cls] to Serializer.types[cls.Meta.oid] = [cls.Meta.model, cls], and it worked perfectly. Feel free to edit your answer, so I can put it as the solution.</span>
<span class="comment-copy">@jhc whoops! That was a silly mistake. Anyway, edited to fit.</span>
<span class="comment-copy">I am so looking forward to that feature.</span>
<span class="comment-copy">@SamHartman like I asked Philip, how does Serializable get called here?</span>
