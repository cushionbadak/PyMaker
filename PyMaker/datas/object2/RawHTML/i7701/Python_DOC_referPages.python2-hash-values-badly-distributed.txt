<div class="post-text" itemprop="text">
<p>When using Python's built in <code>hash()</code> function on strings, I was just playing with it when I noticed something odd. Typically, a normal hash function is supposed to be uncorrelated, in the sense that from <code>hash(A)</code>, <code>hash(B)</code> should be completely unrecognizable (for sufficient definitions of uncorrelated/unrecognizable).</p>
<p>However, this quick little script shows otherwise</p>
<pre><code>In [1]: for i in range(15):
...:     print hash('test{0}'.format(i))
...:
-5092793511388848639
-5092793511388848640
-5092793511388848637
-5092793511388848638
-5092793511388848635
-5092793511388848636
-5092793511388848633
-5092793511388848634
-5092793511388848631
-5092793511388848632
5207588497627702649
5207588497627702648
5207588497627702651
5207588497627702650
5207588497627702653
</code></pre>
<p>I understand Python's <code>hash()</code> function isn't supposed to be cryptographically secure by any stretch, and for that you would use the <code>hashlib</code> library, but why are the values of <code>testX</code> so regularly distributed? This seems to me like it could have poor collision behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>The hash is calculated one character after the other. That's why the hashes are so similar.</p>
<p>During the computation, <code>"test0"</code> and <code>"test1"</code> have the exact same hash up to <code>"test"</code>. There's only one bit difference, in the last character. In secure hashes, changing one bit anywhere should completely change the whole hash (e.g. thanks to multiple passes).</p>
<p>You can check this behaviour by calculating the hash of "0test" and "1test":</p>
<pre><code>&gt;&gt;&gt; for i in range(15):
...     print hash('{0}test'.format(i))
... 
-2218321119694330423
-198347807511608008
-8430555520134600289
1589425791872121742
-6642709920510870371
-4622800608552147860
8038463826323963107
2058173137418684322
-8620450647505857711
-6600477335291135136
8795071937164440413
4111679291630235372
-765820399655801141
2550858955145994266
6363120682850473265
</code></pre>
<p>This is the kind of widespread distribution you were expecting, right? By the way, Python 3 seems to have a different hash computation for strings.</p>
<p>For more information about Python2 string hash, take a look at <a href="http://effbot.org/zone/python-hash.htm" rel="nofollow noreferrer">"Python Hash Algorithms"</a>:</p>
<pre><code>class string:
    def __hash__(self):
        if not self:
            return 0 # empty
        value = ord(self[0]) &lt;&lt; 7
        for char in self:
            value = c_mul(1000003, value) ^ ord(char)
        value = value ^ len(self)
        if value == -1:
            value = -2
        return value
</code></pre>
<p>By the way, this problem isn't related to Python. In Java, <code>"Aa"</code> and <code>"BB"</code> share the same hash. </p>
</div>
<div class="post-text" itemprop="text">
<p>the python <code>hash</code> function is not a cryptographic hash (i.e. must not protect against collisions or show an avalanche effect etc.); its just a identifier (e.g. to be used as dictionary keys) for objects.</p>
<p>read more about <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a> and <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer">hash</a> in the documentation.</p>
<p>as stated there:</p>
<blockquote>
<p><code>dict. __hash__()</code> should return an integer. The only required property is that objects which compare equal have the same hash value</p>
</blockquote>
<p>and - as <a href="https://stackoverflow.com/users/6451573/jean-fran%c3%a7ois-fabre">Jean-François Fabre</a> pointed out in a comment - python hashes must be fast (i.e. to build dictionaries). cryptographic hashes are slow and therefore unusable for that.</p>
<p>by the way: in python 3 the distribution looks way more random.</p>
</div>
<div class="post-text" itemprop="text">
<p>The explanation can be found in the comments for the source code of Python2.7's Objects/dictobject.c:</p>
<blockquote>
<p>Major subtleties ahead:  Most hash schemes depend on having a "good"
  hash function, in the sense of simulating randomness.  Python doesn't:
  its most important hash functions (for strings and ints) are very
  regular in common cases:</p>
<pre><code>&gt;&gt;&gt; map(hash, (0, 1, 2, 3)) 
[0, 1, 2, 3]
&gt;&gt;&gt; map(hash, ("namea", "nameb", "namec", "named"))
[-1658398457, -1658398460, -1658398459, -1658398462]
</code></pre>
<p>This isn't necessarily bad!  To the contrary, in a table of size 2**i,
  taking the low-order i bits as the initial table index is extremely
  fast, and there are no collisions at all for dicts indexed by a
  contiguous range of ints. The same is approximately true when keys are
  "consecutive" strings.  So this gives better-than-random behavior in
  common cases, and that's very desirable.</p>
</blockquote>
</div>
<span class="comment-copy">Python 3 seems to have addressed the problem. Using Python 3 the spread is much wider.</span>
<span class="comment-copy">the hash function is used to be fast for dictionary/set indexing, not to protect against collisions like MD5 (which protects better but is more expensive to compute)</span>
<span class="comment-copy">@JohanL see <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__hash__</a></span>
<span class="comment-copy">@jonrsharpe Ah, an automatic salt to prevent DoS. Well, it still addresses the issue of strings being too similar.</span>
<span class="comment-copy">looks like <b>perfect</b> collision behavior to me. have you tried <code>for i in range(15): print(hash(i))</code>?</span>
<span class="comment-copy">I'm sure it's not unique. ex: <code>&gt;&gt;&gt; a = 449304920394029304920394029304203940293042 &gt;&gt;&gt; b = 449304920394029304920394029304203940293042 &gt;&gt;&gt; a is b False &gt;&gt;&gt; hash(a)==hash(b) True</code>. It depends on the contents of the object</span>
<span class="comment-copy">@Jean-FrançoisFabre : took that out. yup. you are right! and you can override anyway...</span>
<span class="comment-copy">at least now your answer isn't wrong. I would add (just a guess) that the hash needs to be sufficiently fast unlike "strong" hashes like MD5 which are costly. The aim isn't to avoid collisions but to be fast enough to hash keys, as you hinted.</span>
<span class="comment-copy">Indeed, it cannot be unique. There are many more possible objects and strings than 64bit integers.</span>
