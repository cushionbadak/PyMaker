<div class="post-text" itemprop="text">
<p>I have the following configuration class:</p>
<pre><code>class ConfigB(object):
  Id = None
  fileName = None

  def __init__(self, file):
    self.Id = self.searchForId(file)
    self.fileName = file
</code></pre>
<p>Which is instantiated multiple times in the following class and the properties accessed:</p>
<pre><code>from config.ConfigB import ConfigB

class FileRunner(object):
  def runProcess(self, cfgA)
    for file in cfgA.listFiles:
       cfgB = ConfigB(file)
       print(cfgB.Id)
       print(cfgB.fileName)
</code></pre>
<p>To test it I created the following test class where I mock ConfigB for the FileRunner class:</p>
<pre><code>import unittest
import unittest.mock imort MagicMock
import mock
from FileRunner import FileRunner

class TestFileRunner(unittest.TestCase):
  @mock.patch('FileRunner.ConfigB')
  def test_methodscalled(self, cfgB):

    cfgA = Mock()
    cfgA.listFiles = ['File1','File2']

    cfgB().Id.side_effect = [1,2]
    cfgB().fileName.side_effect = ['File1','File2']

    fileRunner = FileRunner()


    fileRunner.runProcess(cfgA)
</code></pre>
<p>I am trying to to get the mock for cfgB to return multiple values for both 'Id' and 'fileName'. If I use <code>cfgB().fileName = 'File1'</code>, I can get the mock for cfgB to return 'File1' twice, but I would prefer if I could iterate through multiple return values. Is something that can be done?    </p>
<p>*Edit: I would like to make clear that the above test does not work for returning specific values and instead I get the following output:</p>
<pre><code>&lt;MagicMock name='cfgB().Id' id='160833320'&gt;
&lt;MagicMock name='cfgB().fileName' id='160833320'&gt;
&lt;MagicMock name='cfgB().Id' id='160833320'&gt;
&lt;MagicMock name='cfgB().fileName' id='160833320'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that you are not actually using <code>side_effect</code> the way it is intended to be used. </p>
<p>Per the documentation <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="nofollow noreferrer">here</a>, the <code>side_effect</code> attribute states:</p>
<blockquote>
<p>A function to be called whenever the Mock is called. See the
  side_effect attribute. Useful for raising exceptions or dynamically
  changing return values. The function is called with the same arguments
  as the mock, and unless it returns DEFAULT, the return value of this
  function is used as the return value.</p>
</blockquote>
<p>The key thing to realize here is <em>function</em>. The expectation here is something that is actually <em>called</em>. You are actually testing attributes, and attributes are not being called like a function, so you are not actually configuring your test properly with how you are using those side_effect calls. </p>
<p>Based on what you are looking to test, you should take a slightly different approach. Looking at your code, you are looking to create a <code>ConfigB</code> object inside your loop as you iterate over <code>cfgA.listFiles</code>. So, this indicates that you are actually looking to control the <code>side_effect</code> of what happens when you call <code>ConfigB(file)</code> which you have mock patched as <code>cfgB</code> in your test. </p>
<p>Furthermore, you are passing what seems like the filenames from iterating over <code>cfgA.listFiles</code> to <code>configB</code>. Therefore, you can just set <code>listFiles</code> as a list of arbitrary filenames as: </p>
<pre><code>cfgA.listFiles = ['some_file_name_1', 'some_file_name_2']
</code></pre>
<p>Then, all you need to do, is then set your <code>cfgB</code> mock's side_effect to now return a <code>Mock</code> object containing the attributes of interest to properly proceed with your testing, as such:</p>
<pre><code>cfgB.side_effect = [
    Mock(Id="some_id_1", fileName="some_filename_1"),
    Mock(Id="some_id_2", fileName="some_filename_2")
]
</code></pre>
<p>Running with those modifications, will then yield the following results from your print statements you have in your code: </p>
<pre><code>some_id_1
some_filename_1
some_id_2
some_filename_2
</code></pre>
<p>So, as you can see, now we have successfully set up your iterable to hold the filenames you want to set up for your tests. Furthermore, the <code>side_effect</code> is now properly used on your mock of <code>ConfigB</code>, in order to now return the proper mocked config object holding the attributes that you can test with in each iteration.</p>
<p>Here is what the final test method looks like all put together:</p>
<pre><code>class TestFileRunner(unittest.TestCase):
  @mock.patch('FileRunner.ConfigB')
  def test_methodscalled(self, cfgB):

    cfgA = Mock()
    cfgA.listFiles = ['some_file_name_1', 'some_file_name_2']

    cfgB.side_effect = [
        Mock(Id="some_id_1", fileName="some_filename_1"),
        Mock(Id="some_id_2", fileName="some_filename_2")
    ]

    fileRunner = FileRunner()
    fileRunner.runProcess(cfgA)
</code></pre>
</div>
<span class="comment-copy">There are a couple of issues with your code: 1. the first method is <code>__init__</code> and not <code>__Init__</code>; 2. <code>Id</code> and <code>fileName</code> are class variables and can lead to unexpected results as described <a href="https://docs.python.org/3.6/tutorial/classes.html#class-and-instance-variables" rel="nofollow noreferrer">here</a>. You can simply remove them and leave just the assigment in the <code>__init__</code> method. This <b>might</b> solve your problem (I haven't tested and it might not be the solution)</span>
<span class="comment-copy">The <code>__init__</code> and <code>__Init__</code> was a typo that was not in my actual code, I fixed it in the above. I do not want to leave the <code>__init__</code> method functioning because the actual <code>__init__</code> method it my code is much more complicated so I would rather just mock the return values.</span>
<span class="comment-copy">This does most of what I want to do, but now I have one final question because this is causing an unexpected problem in my unit test. I have a function in the file runner class <code>foo(cfgB)</code> that I want to confirm was called with the right mock. If I do <code>foo.assert_called_with(cfgB())</code> I get an iterable error unless I add a third line to the side_effect iterable of <code>Mock(Id="some_id_3", fileName="some_filename_3")</code>. This throws an error because the mock id is now different on the assert_called_with statement. Is there anyway to reference the first two mocks to confirm they were called?</span>
