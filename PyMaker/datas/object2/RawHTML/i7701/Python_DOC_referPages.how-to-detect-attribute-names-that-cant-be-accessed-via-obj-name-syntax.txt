<div class="post-text" itemprop="text">
<p><code>setattr</code> will set names that cannot be used with regular attribute access i.e. <code>obj.name</code>.</p>
<pre><code>&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; my_instance = SimpleNamespace()
&gt;&gt;&gt; setattr(my_instance, 'from', 0)  # works
&gt;&gt;&gt; getattr(my_instance, 'from')
0
&gt;&gt;&gt; my_instance.from
SyntaxError: invalid syntax
</code></pre>
<p>How can I check for such names, to avoid using them?</p>
</div>
<div class="post-text" itemprop="text">
<p>On Python 3,</p>
<pre><code>import keyword

type(key) is str and key.isidentifier() and not keyword.iskeyword(key)
</code></pre>
<p>We check that the attribute name is a string, that it fits the format of a Python identifier, and that it's not a keyword. <code>isidentifier</code> doesn't exclude keywords, so the extra check is necessary.</p>
<p>(Yes, <code>isinstance</code> is a thing, but I don't really want to allow <code>str</code> subclasses.)</p>
</div>
<span class="comment-copy">The attribute name is not really illegal. It is only that <code>from</code> is a keyword.</span>
<span class="comment-copy">You can't do that; they're invalid as identifiers, but not as strings. Probably the best thing to do is check against a <a href="https://stackoverflow.com/questions/9642087/is-it-possible-to-get-a-list-of-keywords-in-python">list of keywords</a> and stop them being set in the first place. But maybe your approach is not a good one to start with?</span>
<span class="comment-copy">Don't mess with the <code>__dict__</code> directly, use <code>setattr</code> and <code>getattr</code> and cut the gordian knot.</span>
<span class="comment-copy">BTW, it seems you really just want <code>types.SimpleNamespace</code></span>
<span class="comment-copy">If invalid attribute names are "sneaking" in, then they shouldn't be attribute names in the first place - they are <i>data</i>, and they should be keys or values in a dict proper.  I think this is an XY problem.</span>
<span class="comment-copy">Confused why you attracted a down-vote here. I was just about to post a link to <a href="https://docs.python.org/3/library/keyword.html" rel="nofollow noreferrer">the <code>keyword</code> module</a> myself; that's exactly what it's there for. I mean, yes, you should try to avoid invalid strings as keyword/attribute names in general, but if you don't control your input enough, this mix of whitelisting (must be legal identifier <code>str</code>) and blacklisting (but not a <code>keyword</code>) is a decent option. My up-vote cancels it out I guess.</span>
<span class="comment-copy">Aye, that was me.  The code has false positives, i.e. it identifies strings which aren't necessarily invalid attribute names, and this answer fails to address details about that.  Here's <a href="https://mail.python.org/pipermail/python-dev/2012-March/117441.html" rel="nofollow noreferrer">Guido's take</a> on the matter.</span>
<span class="comment-copy">@wim: They're only false positives if your goal is to allow attribute names like <code>from</code>. If your goal is to only allow names that could be used with dot notation, as in the question, they're not false positives. You could just as easily argue that objects like <code>0</code> are false positives, and that any hashable should be accepted because any hashable can be used as a <code>__dict__</code> key.</span>
<span class="comment-copy">@wim: Ah, okay. I'm generally not a fan of allowing attributes that can't be used via <code>obj.name</code> syntax since working with them is such a pain (must use <code>getattr</code>/<code>setattr</code> or <code>operator.attrgetter</code>, which is both much slower and uglier); the only time I've ever considered it is when I need to interoperate with JSON using sigils or the like, but that is a valid use case on occasion. That said, I'd argue that your argument makes more sense as a response to the OP (who is trying to exclude valid names), not to this answer (which is doing what the OP asked).</span>
<span class="comment-copy">@wim: And I would point to the example of <code>namedtuple</code>, which <a href="https://github.com/python/cpython/blob/78d9e58f204ec4e90502b42c3e7d48dcd76ccb80/Lib/collections/__init__.py#L391" rel="nofollow noreferrer">also performs</a> an <code>isidentifier</code> and <code>iskeyword</code> check on the field names you give it. Excluding such names is an entirely valid design choice.</span>
