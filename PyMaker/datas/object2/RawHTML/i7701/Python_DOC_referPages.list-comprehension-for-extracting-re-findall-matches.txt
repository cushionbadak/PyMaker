<div class="post-text" itemprop="text">
<p>I have a regular expression with a single group, and I want to use it to map a list of strings to a filtered list of matches for strings that match. Currently, I'm using the following:</p>
<pre><code>matches = (re.findall(r'wh(at)ever', line) for line in lines)
matches = [m[0] for m in matches if m]
</code></pre>
<p>How can I do this more elegantly, using only filters, maps, and comprehensions? Obviously, I could use a for loop, but I wonder if it can be done purely by manipulating iterators.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no real advantage obfuscating your code with map, filter, or other functional tricks since a list comprehension is fast, simple and clear:</p>
<pre><code>import re

lines = ['wh1atever wh1btever', 'wh2atever', '', 'wh4atever wh4btever wh4ctever']

'''Since you only want the first item for each line,
   using re.findall is a waste of time, re.search is more appropriate'''

pat1 = re.compile(r'wh(..)tever')
res1 = [ m.group(1) for m in (pat1.search(line) for line in lines) if m ]

print(res1)
'''['1a', '2a', '4a']'''


'''or if there are few lines, you can join them and use re.findall this time,
   with a pattern that consumes the end of the line'''

pat2 = re.compile(r'wh(..)tever.*')
res2 = pat2.findall("\n".join(lines))

print(res2)
'''['1a', '2a', '4a']'''
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use maps and filters. Here's one way.</p>
<pre><code>matches = map(lambda x: x[0], filter(None, map(lambda x: re.findall(r'wh(at)ever', x), lines)))
</code></pre>
<p>If you're using python3, don't forget to tack on a <code>list(...)</code> at the end.</p>
<p>However, I don't see much of a need for more "elegance" here. What you're doing is perfectly fine.</p>
<hr/>
<p>An alternative courtesy @juanpa.arrivillaga:</p>
<pre><code>from functools import partial
list(map(itemgetter(0), filter(None, map(partial(re.findall, r'wh(at)ever'), lines))))
</code></pre>
</div>
<span class="comment-copy">You <i>are</i> only manipulating iterators here, are you just looking for a one-liner?</span>
<span class="comment-copy"><code>matches = [m[0] for m in (re.findall(r'wh(at)ever', line) for line in lines) if m]</code></span>
<span class="comment-copy">You can <code>from functools import partial</code> and <code>from operator import itemgetter</code> and have the very functional <code>list(map(itemgetter(0), filter(None, map(partial(re.findall, r'wh(at)ever'), lines))))</code> ... but I still think your original construction is more elegant.</span>
<span class="comment-copy">Why do you use <code>re.findall</code> if you only want the first item?</span>
<span class="comment-copy">@CasimiretHippolyte Is there a better alternative? If so please tell me :)</span>
<span class="comment-copy">I said "maps, filters, and comprehensions" :) I like this one best! I would put <code>m.group(1)</code> on one line, <code>for m in ()</code> on the next, and <code>if m</code> on a third.</span>
<span class="comment-copy">one line &gt;&gt;&gt;&gt;&gt;&gt; two lines</span>
<span class="comment-copy">I think you can do simply <code>None</code> instead of <code>lambda x:x</code> for <code>filter</code>, it's beeen ages since I've actually use filter instead of a comprehension though</span>
<span class="comment-copy">One line is often worse than two-lines. This is a great example.</span>
<span class="comment-copy">@Coldspeed Also, this doesn't work. The result will be a list of singleton lists of strings, not a list of strings.</span>
<span class="comment-copy">It <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer">partially applies the function</a>. But yes, it is all going to be basically the same way. Just dressed up differently, and made less readable than your original version in all likelyhood.</span>
