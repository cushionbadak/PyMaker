<div class="post-text" itemprop="text">
<p>I have an wrote a small app that takes a single .gif as an upload and it splits the gif into frames using Pillow. I'm saving the .gif through a <code>Document</code> model and the frames through <code>DocumentImage</code> model. Currently, the app saves the .gif object and creates one object for each frame. What I want is all the frames be saved into a single object and that object be linked to the gif object. Here's what I have so far:</p>
<p><strong>views.py</strong></p>
<pre><code>def create_gif(uploadedFile):
# create a folder if it doesn't exist
try:
    gif = Image.open('media/' + uploadedFile)
    print()
except:
    print('Not OK')

frames = [frame.copy() for frame in ImageSequence.Iterator(gif)]
i = 0
while (i &lt; len(frames)):
    buffer = BytesIO()
    frames[i].convert('RGB').save(fp=buffer, format='JPEG')
    finalImage = InMemoryUploadedFile(buffer, None, os.path.basename(uploadedFile)[:-4] + str(i) + '.png', 'image/jpeg', frames[i].tell, None)
    imageToSave = DocumentImage(imagefile=finalImage)
    imageToSave.save()
    i += 1


def list(request):
# Handle file upload
if request.method == 'POST':
    form = DocumentForm(request.POST, request.FILES)
    if form.is_valid():
        newdoc = Document(docfile=request.FILES['docfile'])
        if os.path.splitext(newdoc.docfile.name)[1].lower() != '.gif':
            messages.add_message(request, messages.INFO, "Please select a gif")
        else:
            newdoc.save()
            uploadedFile = newdoc.docfile.name
            create_gif(uploadedFile)
            messages.add_message(request, messages.INFO, "Saved")
            return HttpResponseRedirect(reverse('list'))
else:
    form = DocumentForm()  # A empty, unbound form

# Load documents for the list page
documents = Document.objects.all()

# Render list page with the documents and the form
return render(
    request,
    'list.html',
    {'documents': documents, 'form': form}
)
</code></pre>
<p><strong>models.py</strong> </p>
<pre><code>def content_file_name(instance, filename):
ext = ''.join(filename.split())[:-4]
foldername = "%s/%s" % (uuid.uuid4(), ext)
return '/'.join(['documents', str(foldername), filename])

class Document(models.Model):
     docfile = models.ImageField(upload_to=content_file_name)

class DocumentImage(models.Model):
     imagefile = models.ImageField(upload_to=content_file_name)
     image = models.ForeignKey(Document, related_name='Image', null=True, on_delete=models.CASCADE)
</code></pre>
<p>I'm new to Django and not sure if what I'm asking is even possible but it seems like a fundamental function. I've read the Django documentation on many-to-one relationships, but didn't quite understand how the foreign keys are linked. Thank you for your time.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What I want is all the frames be saved into a single object</p>
</blockquote>
<p>I assume you mean "each frame be saved into a distinct object" ? </p>
<blockquote>
<p>and that object be linked to the gif object. </p>
</blockquote>
<p>A bit OT but using proper naming really helps. Here you mention a "gif object" but your model name (the one with the uploaded gif file) is "Document", and the model for individual frames is "DocumentImage" - but those are created by a function named "create_gif" that neither create a gif not a <code>Document</code> but splits the gif into frames and creates <code>DocumentImage</code> instances... It can only leads to confusion. </p>
<p>Now back to your problem - which, from what I understand, is that <code>DocumentImage</code> instances are not linked to the matching <code>Document</code> instance. Actually you're almost there, all you need is to pass the <code>Document</code> instance to your <code>DocumentImage</code> instances. The simplest way is to pass it to your (very ill-named) <code>create_gif()</code> function and then to the <code>DocumentImage</code> constructor.</p>
<p>Now there are quite a few other problems with your code - not necessarily "blocking" problems (your code might work) but it's really not making the best use of Python and Django's feature -, and some comments are misleading at best (like "# create a folder if it doesn't exist" when you're actually opening an image file).</p>
<p>The first obvious issue is with using a form (which you didn't post) but doing extra validation in the view - validation is your form's first duty really. </p>
<p>The second issue is with relying on the file's extension for file-type validation - this is unreliable and unsafe. You may want to use something like <a href="https://docs.python.org/3/library/imghdr.html" rel="nofollow noreferrer">imghdr</a> instead.</p>
<p>The third issue is with creating your <code>Document</code> instance manually when you could use a <a href="https://docs.djangoproject.com/en/1.11/topics/forms/modelforms/" rel="nofollow noreferrer"><code>ModelForm</code></a> instead. </p>
<p>Then you have the files names / extensions / path handling code which is neither reliable nor portable, a bare except clause that not only hides usefull debugging stuff but also fails to properly handle the exception,  this "manual" while loop in <code>create_gif()</code> when you should be using a for loop and <code>enumerate</code> to get the index, and a function call within the loop that doesn't depend on the loop's variable (IOW: that will yield the same results on each iteration).</p>
<p>Here's a revised version of your code. <strong>It's totally untested</strong> (which means very certainly buggy), but it should help you both solve your problem and improve your code's quality. </p>
<p>models</p>
<pre><code>import os
import sys
import uuid

# etc - add missing imports here

def content_file_name(instance, filename):
    basename, _ext = os.path.splitext(filename)
    foldername = os.path.join(uuid.uuid4(), basename)
    return os.path.join('documents', foldername, filename)


class Document(models.Model):
     docfile = models.ImageField(upload_to=content_file_name)

     def create_documentfiles(self):
         if self.images.exists():
             # XXX should be using the `logging` module instead
             print &gt;&gt; sys.stderr, "Document {} ({}) already has images".format(self.pk, self.docfile.path)
             return

         gif = Image.open(self.docfile.path)
         frames = [frame.copy() for frame in ImageSequence.Iterator(gif)]
         basename, _ext = os.path.splitext(self.docfile.name)
         for index, frame in enumerate(frames):
             buffer = BytesIO()
             item.convert('RGB').save(fp=buffer, format='JPEG')
             destname = "{}{}.png".format(basename, index)
             imagefile = SimpleUploadedFile(buffer.read(), destname, 'image/jpeg')
             DocumentFile.objects.create(document=self, imagefile=imagefile)


class DocumentImage(models.Model):
     imagefile = models.ImageField(upload_to=content_file_name)
     document = models.ForeignKey(Document, related_name='images', on_delete=models.CASCADE)
</code></pre>
<p>forms</p>
<pre><code>import imghdr
from django import forms
from myapp.models import Document

class DocumentForm(forms.ModelForm):
    class meta:
        model = Document

    def validate_docfile(self):
        file = self.cleaned_data.get("docfile")
        if file:
            if imghdr.what(file.read()) != "gif":
                raise forms.ValidationError("Please upload a .gif file")
            file.seek(0)
        return file
</code></pre>
<p>views</p>
<pre><code># better not to name anything `list` - it would shadow the builtin
# `list` type    
def documentlist(request):
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES)
        if form.is_valid():
            newdoc = form.save()
            newdoc.create_documentfiles()
            messages.add_message(request, messages.INFO, "Saved")
            return HttpResponseRedirect(reverse('list'))
    else:
        form = DocumentForm()  

    documents = Document.objects.all()

    return render(
        request,
        'list.html',
        {'documents': documents, 'form': form}
    )
</code></pre>
<p>EDIT : you state in your comment that:</p>
<blockquote>
<p>I want to have multiple images under one single object. </p>
</blockquote>
<p>If you mean having all frames images as distinct fields of a same model instance, then no, you can't. Well, you <em>could</em> add thousands of <code>ImageField</code> to your model, but 1/ you'd still hit a limit someday no matter how many <code>ImageField</code> you add (there's AFAIK no theoretical limit on the number of frames in a gif, and if there's a technical one it's probably way too high for a rdbms to support it), 2/ it would be an awfull kludge to handle and 3/ you'd take a very severe perfomance hit due to the number of fields in the db table.</p>
<p>To make a long story short, what you did (a "master" <code>Document</code> model with 0-N related <code>DocumentImage</code> <code>slave</code> models) is the proper way to model your use case. Note that once you properly set the <code>Document</code> foreignkey in <code>DocumentImage</code> instances, gettings the frames for a given <code>Document</code> instance is as simple as <code>mydoc.images.all()</code> (nb using my corrected models), and a <code>DocumentImage</code> is garanteed to belong to one single <code>Document</code> (here again with my correct models code), so you are technically as close to "multiple images under one single object" as you can get. FWIW in plain Python (without rdbms and Django models) you'd still model this as one <code>Document</code> object having a collection (a <code>list</code> would be an obvious candidate) of <code>image</code> (frames) objects so it doesn't make that much difference.</p>
</div>
<span class="comment-copy">Yes, this is something i started to pass my time, so I did not concentrate on function naming and comments. Indeed create_gif is quite misleading, but it was what the function would have done. I changed my mind along the way. Now, the "each frame be saved into a distinct object" is how it works now. I want to have multiple images under one single object. Not sure if that's possible. As for the other issues you found, I'm just starting with Python, so your criticism is greatly appreciated.</span>
<span class="comment-copy">cf my edited answer.</span>
