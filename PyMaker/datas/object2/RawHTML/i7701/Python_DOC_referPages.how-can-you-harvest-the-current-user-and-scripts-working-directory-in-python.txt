<div class="post-text" itemprop="text">
<p>Currently, I am statically specifying a filepath for the source data for a script using the snippet below:</p>
<pre><code> def get_files():
     global thedir
     thedir = 'C:\\Users\\username\\Documents'
     list = os.listdir(thedir)
     for i in list:
         if i.endswith('.txt'):
             print("\n\n"+i)
             eat_file(thedir+'\\'+i)
</code></pre>
<p>The reason that I am statically assigning the location is that the script is failing to execute correctly when it is executed in a debugging environment such as Eclipse &amp; Visual Studio Code. These debuggers assume that the script is being ran from their working directories.</p>
<p>Since I'm unable to modify the local settings of every system that might be running this script, is there a recommended module to force the script to harvest either the active user (linux and windows) and/or the script's local directory pragmatically? </p>
</div>
<div class="post-text" itemprop="text">
<p>The new-ish <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code> module</a> (available in Python &gt;= 3.4) is great for working with path-like objects (both Windows and for other OSes). Use it. Don't bother with the outdated <code>os</code> module. And don't bother trying to use naked strings for representing path-like objects. </p>
<h2><a href="https://xkcd.com/1416/" rel="nofollow noreferrer">It's Paths - Paths all the way down</a></h2>
<p>To simplify: you can build up any path (directory and file path objects are treated exactly the same) as an object, which can be an <em>absolute path object</em> or a <em>relative path object</em>. </p>
<p>Simple displaying of some useful paths- such as the current working directory and the user home- works like this: </p>
<pre><code>from pathlib import Path

# Current directory (relative):
cwd = Path() # or Path('.')
print(cwd)

# Current directory (absolute):
cwd = Path.cwd()
print(cwd)

# User home directory:
home = Path.home()
print(home)

# Something inside the current directory
file_path = Path('some_file.txt') # relative path; or 
file_path = Path()/'some_file.txt' # also relative path
file_path = Path().resolve()/Path('some_file.txt') # absolute path
print(file_path)
</code></pre>
<p>To navigate down the file tree, you can do things like this. Note that the first object, <code>home</code>, is a <code>Path</code> and the rest are just strings: </p>
<pre><code>file_path = home/'Documents'/'project'/'data.txt' # or
file_path = home.join('Documents', 'project', 'data.txt')
</code></pre>
<p>To read a file located at a path, you can use its <code>open</code> method rather than the <code>open</code> function: </p>
<pre><code>with file_path.open() as f:
    dostuff(f)
</code></pre>
<p>But you can also just grab the text directly! </p>
<pre><code>contents = file_path.read_text()
content_lines = contents.split('\n')
</code></pre>
<p>...and WRITE text directly!</p>
<pre><code>data = '\n'.join(content_lines)
file_path.write_text(data) # overwrites existing file
</code></pre>
<p>Check to see if it is a file or a directory (and exists) this way: </p>
<pre><code>file_path.is_dir() # False
file_path.is_file() # True
</code></pre>
<p>Make a new, empty file without opening it like this (silently replaces any existing file): </p>
<pre><code>file_path.touch()
</code></pre>
<p>To make the file <em>only if it doesn't exist</em>, use <code>exist_ok=False</code>:</p>
<pre><code>try:
    file_path.touch(exist_ok=False)
except FileExistsError:
    # file exists
</code></pre>
<p>Make a new directory (under the current directory, <code>Path()</code>) like this: </p>
<pre><code>Path().mkdir('new/dir') # get errors if Path()/`new` doesn't exist
Path().mkdir('new/dir', parents=True) # will make Path()/`new` if it doesn't exist
Path().mkdir('new/dir', exist_ok=True) # errors ignored if `dir` already exists
</code></pre>
<p>Get the file extension or filename of a path this way:</p>
<pre><code>file_path.suffix # empty string if no extension
file_path.stem # note: works on directories too
</code></pre>
<p>Use <code>name</code> for the entire last part of the path (stem and extension if they are there):</p>
<pre><code>file_path.name # note: works on directories too
</code></pre>
<p>Rename a file using the <code>with_name</code> method (which returns the same path object but with a new filename):</p>
<pre><code>new_path = file_path.with_name('data.txt')
</code></pre>
<p>You can iterate through all the "stuff' in a directory like so using <code>iterdir</code>: </p>
<pre><code>all_the_things = list(Path().iterdir()) # returns a list of Path objects
</code></pre>
</div>
<span class="comment-copy">You can get the current working directory with <code>os.getcwd()</code>. As for the home directory, see <code>os.path.expanduser()</code></span>
<span class="comment-copy">The script path is either the main module's <code>__file__</code> or, for even a frozen executable, <code>sys.argv[0]</code>. The path may be relative to the startup working directory, so you have to capture it immediately before modifying the working directory. For example, <code>script_dir = os.path.abspath(os.path.dirname(sys.argv[0]))</code>.</span>
