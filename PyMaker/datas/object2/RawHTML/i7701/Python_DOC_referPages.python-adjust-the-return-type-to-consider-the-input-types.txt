<div class="post-text" itemprop="text">
<p>In C++ and C# and others, you can overload or adjust the return type to match the input types.  Using Python I find references that the return type should be consistent regardless.  <a href="https://stackoverflow.com/questions/1839289/why-should-functions-always-return-the-same-type">Like in this question</a></p>
<p>Now for my code that wants to match return type to param type</p>
<pre><code>def myUpper(what_is_this_thing):
    try:
        return what_is_this_thing.upper()  
    except AttributeError:  
        try:
            return {k:what_is_this_thing[k].upper() for k in what_is_this_thing} 
        except TypeError:
        return [x.upper() for x in what_is_this_thing] 

print myUpper('test') 
print myUpper(['test', 'and more'])
print myUpper({'one':'test', 'two': 'and more'})
print myUpper(['test', 1000])
</code></pre>
<p>output</p>
<pre><code>TEST
['TEST', 'AND MORE']
{'two': 'AND MORE', 'one': 'TEST'}
An exception is rased because the payload does not have a upper method
</code></pre>
<p>So how bad is this python sin?  I mostly still work in 2.7 I know 3.3 has type hints, learning that will need to wait for later in the summer.</p>
<p>Anyone have a less sinful way to achieve most of the benefits? or a coherent argument why this should not be done?</p>
<p>Addendum:<br/>
Other than the Python3 Moses which I like. I feel compelled to find if this question is best answered with something like in python 2.7</p>
<pre><code>def myUpper(s): 
    return s.upper() 
print myUpper('test') 
print [s.myUpper() for s in 'test', 'and more'] d = { 'one':'test', 'two': 'and more'} 
print {k:d[k].myUpper() for k in d}
</code></pre>
<p>In summary spread comprehension stuff out in the code even if is quite common.  Choose proliferation of comprehension over obscure return data types?</p>
<p>I suspect I would remove 400+ comprehension lines in the final code if I did it with adjusting return types.  But if that is too strange then so be it.</p>
<p>It comes down to readability ver violation of the unwritten rule about 1 function 1 return type.   </p>
</div>
<div class="post-text" itemprop="text">
<p>If you're looking to have some consistency of the return type with the argument (precisely, first argument), you can create overloaded implementations of your function with <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>functools.singledispatch</code></a>; one of the reasons I'll say you start moving to Python 3:</p>
<pre><code>from functools import singledispatch

@singledispatch
def my_upper(what_is_this_thing):
    return what_is_this_thing.upper()  

@my_upper.register(list)
def _(this_is_a_list):
    ...
    return this_is_also_a_list

@my_upper.register(dict)
def _(this_is_a_dict):
    ...
    return this_is_also_a_dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Putting my five cents there:</p>
<pre><code>hanlders = {
    str: (lambda what_is_this_thing: what_is_this_thing.upper()),
    dict: (lambda what_is_this_thing: {k:what_is_this_thing[k].upper() for k in what_is_this_thing}),
    list: (lambda what_is_this_thing: [x.upper() for x in what_is_this_thing]), 
}
print handlers[type(what_is_this_thing)](what_is_this_thing)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can actually check the type instead of relying on exceptions.</p>
<pre><code>v = 'one'
if type(v) == str:
    # Treat it as a string
elif type(v) == list:
    # Treat it as a list
elif type(v) == dict:
    # Treat is as a dict
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>isinstance</code> - and passing the keys / values of a dict as well as the items of a list recursively to the function will handle more types:</p>
<pre><code>def myUpper(o):
    if(isinstance(o, str)):
        return o.upper()
    elif(isinstance(o, list)):
        return [myUpper(x) for x in o]
    elif(isinstance(o, dict)):
        return {myUpper(k):myUpper(v) for k,v in o.items()}
    else:
        return o
</code></pre>
</div>
<span class="comment-copy">If you don't know enough about the argument to know whether to pass it to <code>strUpper</code>, <code>listUpper</code>, or <code>dictUpper</code>, you don't know what you are getting back from <code>myUpper</code> anyway.</span>
<span class="comment-copy">This is true.    And to lend focus I know all they ways I could test for input type.  I choose to get forgiveness rather than permission.  I can guess that string are more common the dicts and lists are the least expected.   My question is targeting common library inhouse functions.  I may even use a class to hide the type-specific versions it does not matter to me.  The question is how strong is the argument that a function should have only one return type.  In this case, you get back things related to what you passed in.</span>
<span class="comment-copy">There are Python functions that can return values of multiple types, but they tend to fall into two categories. 1) <code>f</code> will return a value of type <code>t</code>, or it will return <code>None</code>. 2) A function will return a value of type <code>t</code>, but any such type will support iteration/mapping/etc. Returning a value whose only identifying feature is to match the input type is just deferring the eventual need to figure out what type of value you got back....</span>
<span class="comment-copy">... That said, your example <i>could</i> be construed as following my second point; since you use each value as an argument to <code>print</code>, you might assume that <code>myUpper</code> returns a value that supports <code>__str__</code> (or at least <code>__repr__</code>). But I would strongly argue for clarity that a function should have a single, well-defined return type independent of its input type.</span>
<span class="comment-copy">You do not think that knowing the calling type would be sufficient to know the returned type?   That was kinda the whole point.  Wou think it is not sufficiently clear.   or that it is just too different to be used?</span>
<span class="comment-copy">Will this backport?  I have been checking and have not seen a way yet.</span>
<span class="comment-copy">I think I found a source I will be trying this out <a href="https://pkgs.org/download/python2.7(singledispatch)" rel="nofollow noreferrer">backport</a></span>
<span class="comment-copy">Worked via back port. Thanks to all!</span>
<span class="comment-copy">There's no need for <code>__name__</code>; you can use type objects as the key for <code>handlers</code>.</span>
<span class="comment-copy">makes sense, thanks</span>
<span class="comment-copy">This doesn't handle subclasses at all.</span>
<span class="comment-copy">I use the handlers pattern for case statements and like it.  In this case I agree that subclass problems make it too limiting + this is not the main question.</span>
<span class="comment-copy">could but that's not preferred in python.  My question is about the return types.</span>
<span class="comment-copy">You should use <code>isinstance</code> for type sniffing instead of comparing type objects. <code>if isinstance(v, str)</code> etc.</span>
<span class="comment-copy">again...   not my question.  If I am adjusting my return type in this way how big of a pythonic sin is it considering the return type is generally intended to be of a consistent type.</span>
<span class="comment-copy">@user2315423 then it pretty much depends on how you're going to use it. It's not much a question of "how sinful" it is, more like "is this going to cause trouble in the future?" thing. If you're going to be using it just for an internal function of another function, then no problem. If it's going to be widely used by many people then you should strive for clarity; in that case it's worth questioning the situation that led you to pass different types to the same function to start with.</span>
<span class="comment-copy">ok so considering that the function is intended to general use of many source data types it seems reasonable that this would be in a general lib inside a company.    So it is clear to you?  I could have written 3 functions all with different names.   Can anyone provide an argument for more namespace in favour of this kind of overloading?</span>
