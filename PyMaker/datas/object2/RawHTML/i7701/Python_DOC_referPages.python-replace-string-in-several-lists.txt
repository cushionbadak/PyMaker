<div class="post-text" itemprop="text">
<p>i want to replace a specific string in several lists according to another list.
Here is an example</p>
<pre><code>Diag2= [['09 2F 59', 'FC1'], ['09 0A 54', 'FC1'], ['09 10 74', 'FC4'], ['19 1E 19', 'FC5'], ['18 1E 4B', 'FC2'], ['19 1E 71', 'FC4']]

Data1=[['09 2F 59', '500.0', 'FC7', 'S6'], ['09 0A 54', '100.0','FC9'], ['09 10 74', '500.0','FC4', 'S99'], ['19 1E 19', '100.0','FC5', 'S1'], ['18 1E 4B','500.0', 'FC2', 'S1'],
       ['19 1E 71', '500.0','FC4', 'S6']]

for i in Data1:
    for j in Diag2:
            if(j[0] == i[0]):
                ??
</code></pre>
<p>I am comparing the first data and i want to replace the second string with the first string.</p>
<p>Output shall look:  <code>Data1=[['09 2F 59', '500.0', 'FC1', 'S6'], ['09 0A 54', '100.0','FC1']....</code> </p>
<p>But iam failing to replace existing data. I always get the old data.:(</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use a dictionary instead of a list for your <code>Diag2</code>, the problem becomes much easier :</p>
<pre><code>Diag2 = dict([['09 2F 59', 'FC1'], ['09 0A 54', 'FC1'], ['09 10 74', 'FC4'], ['19 1E 19', 'FC5'], ['18 1E 4B', 'FC2'], ['19 1E 71', 'FC4']])
# {'19 1E 71': 'FC4', '09 10 74': 'FC4', '09 2F 59': 'FC1', '09 0A 54': 'FC1', '19 1E 19': 'FC5', '18 1E 4B': 'FC2'}
</code></pre>
<p>You don't need to iterate on <code>Diag2</code> for each <code>Data1</code> element, then.</p>
<pre><code>Data1 = [
    ['09 2F 59', '500.0', 'FC7', 'S6'],
    ['09 0A 54', '100.0', 'FC9'],
    ['09 10 74', '500.0', 'FC4', 'S99'],
    ['19 1E 19', '100.0', 'FC5', 'S1'],
    ['18 1E 4B', '500.0', 'FC2', 'S1'],
    ['19 1E 71', '500.0', 'FC4', 'S6'],
    ['XX YY ZZ', '500.0', 'FC4', 'S6']]

print([l[:2] + [Diag2.get(l[0], l[2])] + l[3:] for l in Data1])
# [['09 2F 59', '500.0', 'FC1', 'S6'], ['09 0A 54', '100.0', 'FC1'], ['09 10 74', '500.0', 'FC4', 'S99'], ['19 1E 19', '100.0', 'FC5', 'S1'], ['18 1E 4B', '500.0', 'FC2', 'S1'], ['19 1E 71', '500.0', 'FC4', 'S6'], ['XX YY ZZ', '500.0', 'FC4', 'S6']]
</code></pre>
<p><code>l[:2] + [Diag2.get(l[0], l[2])] + l[3:]</code> means :</p>
<ul>
<li>2 first elements of <code>l</code></li>
<li>the corresponding value from <code>Diag2</code> for the key <code>l[0]</code>. If not present, use <code>l[2]</code> instead</li>
<li>elements of <code>l</code> after the 3 first ones, if present</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> to aggregate the elements from the lists, then build a new list for each pair:</p>
<pre><code>&gt;&gt;&gt; [[x[0], y[1], x[1], *y[3:]] for x, y in zip(Diag2, Data1)]
[['09 2F 59', '500.0', 'FC1', 'S6'], ['09 0A 54', '100.0', 'FC1'], ['09 10 74', '500.0', 'FC4', 'S99'], ['19 1E 19', '100.0', 'FC5', 'S1'], ['18 1E 4B', '500.0', 'FC2', 'S1'], ['19 1E 71', '500.0', 'FC4', 'S6']]
</code></pre>
<p>Note that this usage of the <code>*</code> unpacking operator is supported in Python 3.5+.</p>
</div>
<span class="comment-copy">I got confused by the equality test in the code. <code>zip</code> might indeed be the answer if the lists have the exact same length and always the same first element.</span>
