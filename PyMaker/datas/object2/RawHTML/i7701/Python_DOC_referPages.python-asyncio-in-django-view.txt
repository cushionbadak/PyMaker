<div class="post-text" itemprop="text">
<p>I would like to make two POST requests from an API on a Django view at the same time.</p>
<p>This is how I would do it outside of django.</p>
<pre><code>import asyncio
import speech_recognition as sr

async def main(language1, language2):
    loop = asyncio.get_event_loop()
    r = sr.Recognizer()
    with sr.AudioFile(path.join(os.getcwd(), "audio.wav")) as source:
        audio = r.record(source)
    def reco_ibm(lang):
        return(r.recognize_ibm(audio, key, secret language=lang, show_all=True))
    future1 = loop.run_in_executor(None, reco_ibm, str(language1))
    future2 = loop.run_in_executor(None, reco_ibm, str(language2))
    response1 = await future1
    response2 = await future2

loop = asyncio.get_even_loop()
loop.run_until_complete(main("en-US", "es-ES"))
</code></pre>
<p>I'm confused about the event loop. How can I do this inside my Django view? Do I need to use nested functions for this?</p>
<pre><code>def ibmaudio_ibm(request, language1, language2):
     #Asyncio code here
</code></pre>
<p>Edit: How is this even considered a duplicate? Parallel calls and schedulling with crontab are completely different things...</p>
</div>
<div class="post-text" itemprop="text">
<p>Solution was to nest the function inside another one.</p>
<pre><code>def djangoview(request, language1, language2):
    async def main(language1, language2):
        loop = asyncio.get_event_loop()
        r = sr.Recognizer()
        with sr.AudioFile(path.join(os.getcwd(), "audio.wav")) as source:
            audio = r.record(source)
        def reco_ibm(lang):
            return(r.recognize_ibm(audio, key, secret language=lang, show_all=True))
        future1 = loop.run_in_executor(None, reco_ibm, str(language1))
        future2 = loop.run_in_executor(None, reco_ibm, str(language2))
        response1 = await future1
        response2 = await future2
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(language1, language2))
    loop.close()
    return(HttpResponse)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>In this particular case</strong> you can simply use the <code>ThreadPoolExecutor</code>, asyncio is using it under the hood in <code>.run_in_executor</code> anyway (but also adds redundant lines of code / loop creation etc in your example).</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor, wait

# create the executor outisde of the view with the number of workers you may need
executor = ThreadPoolExecutor(max_workers=2)

def reco_ibm(lang):
    return(r.recognize_ibm(audio, key, secret language=str(lang), show_all=True))

def djangoview(request, language1, language2):
    r = sr.Recognizer()
    with sr.AudioFile(path.join(os.getcwd(), "audio.wav")) as source:
        audio = r.record(source)

        # then use it pretty trivially:
        futures = []
        for lang in [language1, language2]:
            futures.append(executor.submit(reco_ibm, lang)
        completed, pending = wait(futures)
        # `pending` will always be empty here (see the docs on wait)

        result1, result2 = [i.resut() for i in completed]

    # do whatever you want with results etc.
</code></pre>
<p>see <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="noreferrer">https://docs.python.org/3/library/concurrent.futures.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Django is a synchronous framework so you can't use any <code>async/await</code> in the views because of there no loop or something like that. </p>
<p>You really can use Django channels library for it, but it will make your views asynchronous under the hood by itself, you don't need to use <code>async</code> also, just connect the channels a go on coding as you do it before, without any async features.</p>
</div>
<span class="comment-copy"><a href="http://channels.readthedocs.io/en/stable/faqs.html#why-are-you-doing-this-rather-than-just-using-tornado-gevent-asyncio-etc" rel="nofollow noreferrer">channels.readthedocs.io/en/stable/â€¦</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/43838872/using-asyncio-to-do-periodic-task-in-django">using asyncio to do periodic task in django</a></span>
<span class="comment-copy">@e4c5 It has nothing to do with schedulling tasks, I want parallel calls... Not even close to a duplicate</span>
<span class="comment-copy">Don't be mislead by the title. The question and the answer are the same</span>
<span class="comment-copy">this is still blocking for the django request response cycle</span>
<span class="comment-copy">@AyushShanker Can you further explain this? i was able to reduce the running time of my project quite a lot using this approach, I was waiting to receive output from API</span>
<span class="comment-copy">@Juanvulcano it works faster because you run async requests  concurrently. However, <code>loop.run_until_complete(main(language1, language2))</code> blocks further execution until async actions are complete. That means django worker won't be able to serve other requests till this one is complete.</span>
<span class="comment-copy">What should i do to not block django while using the above approach? For example after receiving the request return the httpResponse and let the task run in background?</span>
<span class="comment-copy">This is wrong. If you don't use async/await (or the old yield from etc syntax) in the code it will always be synchronous as there will be no switch points (i.e. await expressions). Even with Channels, as the Channels library doesn't change the way python work (unless you use something like gevent / twisted etc).</span>
