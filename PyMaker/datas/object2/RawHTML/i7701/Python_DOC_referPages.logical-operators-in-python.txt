<div class="post-text" itemprop="text">
<p>While reading the Logical operators in python i came across with expressions :</p>
<pre><code>  5 and 1 
</code></pre>
<p>output : 1 </p>
<pre><code>  5 or 1 
</code></pre>
<p>output : 5 </p>
<p>Can anyone explain how is this working ?<br/>
I know that the <strong>operands</strong> of the <strong>logical</strong> operators are <strong>Boolean</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>that is <a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="nofollow noreferrer">well documented</a>:</p>
<pre><code>x or y      if x is false, then y, else x 
x and y     if x is false, then x, else y 
</code></pre>
<p>both short-circuit (e.g. <code>or</code> will not evaluate <code>y</code> if <code>x</code> is <em>truthy</em>).</p>
<p>the documentation also states <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">what is considered <em>falsy</em></a> (<code>False</code>, <code>0</code>, <code>None</code>, empty sequences/mappings, ...) - everything else is considered <em>truthy</em>.</p>
<p>a few examples:</p>
<pre><code>7 and 'a'             # -&gt; 'a'
[] or None            # -&gt; None
{'a': 1} or 'abc'[5]  # -&gt; {'a': 1}; no IndexError raised from 'abc'[5]
False and 'abc'[5]    # -&gt; False; no IndexError raised from 'abc'[5]
</code></pre>
<p>note how the last two show the short-circuit behavior: the second statement (that would raise an <code>IndexError</code>) is not executed.</p>
<p>your statement that the operands are boolean is a bit moot. python does have booleans (actually just 2 of them: <code>True</code> and <code>False</code>; they are <a href="https://docs.python.org/release/3.0.1/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">subtypes of int</a>). but logical operations in python just check if operands are <em>truthy</em> or <em>falsy</em>. the <a href="https://docs.python.org/release/3.0.1/library/functions.html#bool" rel="nofollow noreferrer"><code>bool</code> function</a> is not called on the operands.</p>
<hr/>
<p>the terms <em>truthy</em> and <em>falsy</em> seem not to be used in the official python documentation. but books teaching python and the community here do use these terms. there is a discussion about the terms on <a href="https://english.stackexchange.com/a/117363">english.stackexchange.com</a> and also a mention on <a href="https://en.wikipedia.org/wiki/JavaScript_syntax#Boolean" rel="nofollow noreferrer">wikipedia</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is because of the short-circuit evaluation method.</p>
<p>For the <code>and</code>, <em>all</em> of the clauses must be <code>True</code>, so all of them must be evaluated. Once a <code>False</code> is encountered, the whole thing evaluates to <code>False</code>, we don't even need to evaluate the next ones.</p>
<pre>
&gt;&gt;&gt; 1 and 2
2
&gt;&gt;&gt; 2 and 1
1
&gt;&gt;&gt; 1 and 2 and 3
3
&gt;&gt;&gt; 1 and 0 and 2
0
&gt;&gt;&gt; 0 and 1 and 2
0
</pre>
<p>But for <code>or</code>, <em>any</em> of the clauses being evaluated to <code>True</code> is enough for the whole thing to be <code>True</code>. So once it finds something to be <code>True</code>, the value of the whole thing is decided to be <code>True</code>, without even evaluating the subsequent clauses.</p>
<pre>
&gt;&gt;&gt; 0 or 1
1
&gt;&gt;&gt; 1 or 0
1
&gt;&gt;&gt; 1 or 2
1
&gt;&gt;&gt; 2 or 1
2
&gt;&gt;&gt; 0 or 0 or 1
1
&gt;&gt;&gt; 0 or 1 or 2
1
</pre>
</div>
<div class="post-text" itemprop="text">
<p>This is called short circuiting or lazy evaluation. Example, if you have "a or b" and a meets the criteria, then python will output it. Conversely, if you have "a and b" and "a" does not meet the criteria, then python will stop evaluating it since it cannot be satisfied.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first case when the and keyword is there, it is the second value that determines whether it is logically true or not, provided the first number is non-zero. Thus the second value is printed eventually.</p>
<p>In the second case, the keyword is or so when the first non-zero operand is encountered, since it makes the statement logically true, it is printed onto the output screen.</p>
<p>It is an example of lazy evaluation.</p>
</div>
<span class="comment-copy">Those are the same results are bitwise operations. Probably just a coincidence</span>
<span class="comment-copy">These are logical operators and you may just see them as logical entities. In this case, short circuiting happens. So in the event of or, 1 or 5 is 1. Doesn't check 5. In case of 5 or 1, result is 5(1 is not checked). In case of and, the later argument is returned. 1 and 5 = 5 while 5 and 1 = 1</span>
<span class="comment-copy">It is also worth trying <code>1 and 5</code> and <code>1 or 5</code> which return 5 &amp; 1 respectively and make it a little clearer that the condition is being evaluated rather than the bitwise result.</span>
<span class="comment-copy">To understand this even further, I suggest you do some light reading on Discrete Mathematics and Propositional Logic; <a href="http://www2.fiit.stuba.sk/~kvasnicka/Mathematics%20for%20Informatics/Rosen_Discrete_Mathematics_and_Its_Applications_7th_Edition.pdf" rel="nofollow noreferrer">this</a> is a good reference if you have the time.</span>
<span class="comment-copy">You should mention all values non zero are Truthy</span>
<span class="comment-copy">A pretty good answer with good examples. Thanks :-)</span>
<span class="comment-copy">Thank you , I got the concept .</span>
<span class="comment-copy">@ChihebNexus: thanks for the praise! this indeed is one of my better answers i have to (grudgingly) admit...</span>
<span class="comment-copy">@hiroprotagonist Yes ! And this answer is in my favourite ones :-) it's instructive.</span>
