<div class="post-text" itemprop="text">
<p>How to check if the string 'str1' contains the elements in the list 'lis'?</p>
<pre><code>str1 = "45892190"
lis = [89,90]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If no overlap is allowed, this problem becomes much harder than it looks at first.
As far as I can tell, no other answer is correct (see test cases at the end).</p>
<p>Recursion is needed because if a substring appears more than once, using one occurence instead of the other could prevent other substrings to be found.</p>
<p>This answer uses two functions. The first one finds every occurence of a substring in a string and returns an iterator of strings where the substring has been replaced by a character which shouldn't appear in any substring.</p>
<p>The second function recursively checks if there's any way to find all the numbers in the string:</p>
<pre><code>def find_each_and_replace_by(string, substring, separator='x'):
    """
    list(find_each_and_replace_by('8989', '89', 'x'))
    # ['x89', '89x']
    list(find_each_and_replace_by('9999', '99', 'x'))
    # ['x99', '9x9', '99x']
    list(find_each_and_replace_by('9999', '89', 'x'))
    # []
    """
    index = 0
    while True:
        index = string.find(substring, index)
        if index == -1:
            return
        yield string[:index] + separator + string[index + len(substring):]
        index += 1


def contains_all_without_overlap(string, numbers):
    """
    contains_all_without_overlap("45892190", [89, 90])
    # True
    contains_all_without_overlap("45892190", [89, 90, 4521])
    # False
    """
    if len(numbers) == 0:
        return True
    substrings = [str(number) for number in numbers]
    substring = substrings.pop()
    return any(contains_all_without_overlap(shorter_string, substrings)
               for shorter_string in find_each_and_replace_by(string, substring, 'x'))
</code></pre>
<p>Here are the test cases:</p>
<pre><code>tests = [
    ("45892190", [89, 90], True),
    ("8990189290", [89, 90, 8990], True),
    ("123451234", [1234, 2345], True),
    ("123451234", [2345, 1234], True),
    ("123451234", [1234, 2346], False),
    ("123451234", [2346, 1234], False),
    ("45892190", [89, 90, 4521], False),
    ("890", [89, 90], False),
    ("8989", [89, 90], False),
    ("8989", [12, 34], False)
]

for string, numbers, should in tests:
    result = contains_all_without_overlap(string, numbers)
    if result == should:
        print("Correct answer for %-12r and %-14r (%s)" % (string, numbers, result))
    else:
        print("ERROR : %r and %r should return %r, not %r" %
              (string, numbers, should, result))
</code></pre>
<p>And the corresponding output:</p>
<pre><code>Correct answer for '45892190'   and [89, 90]       (True)
Correct answer for '8990189290' and [89, 90, 8990] (True)
Correct answer for '123451234'  and [1234, 2345]   (True)
Correct answer for '123451234'  and [2345, 1234]   (True)
Correct answer for '123451234'  and [1234, 2346]   (False)
Correct answer for '123451234'  and [2346, 1234]   (False)
Correct answer for '45892190'   and [89, 90, 4521] (False)
Correct answer for '890'        and [89, 90]       (False)
Correct answer for '8989'       and [89, 90]       (False)
Correct answer for '8989'       and [12, 34]       (False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>str1 = "45892190"
lis = [89,90]

for i in lis:
    if str(i) in str1:
        print("The value " + str(i) + " is in the list")
</code></pre>
<blockquote>
<p>OUTPUT:</p>
<p>The value 89 is in the list</p>
<p>The value 90 is in the list</p>
</blockquote>
<p>If you want to check if all the values in lis are in str1, the code of cricket_007</p>
<pre><code>all(str(l) in str1 for l in lis)
out: True
</code></pre>
<p>is what you are looking for</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want non-overlapping matches I'd do it like this:</p>
<ul>
<li>create a copy of the initial string (as we'll modify it)</li>
<li>go through each element of the list and if we find the element in our string, we replace it with <code>x</code></li>
<li>at the same time, if we find the number in our string, we increment a counter</li>
<li>at the end, if the variable equals the length of the list, it means that all of its elements are there</li>
</ul>
<pre><code>str1 = "45890190"
lis1 = [89, 90]

copy, i = str1, 0
for el in lis1:
    if str(el) in copy:
        copy = copy.replace(str(el), 'x')
        i = i + 1

if i == len(lis1):
    print(True)
</code></pre>
<p>More, we don't really need a counter if we add an extra condition which will return <code>False</code> when an element isn't found in the string. That is, we get to the following, final solution:</p>
<pre><code>def all_matches(_list, _string):
    str_copy = _string
    for el in _list:
        if str(el) not in str_copy:
            return False
        str_copy = str_copy.replace(str(el), 'x')
    return True
</code></pre>
<p>Which you can test by writing:</p>
<blockquote>
<pre><code>str1 = "4589190"
lis1 = [89, 90]

print(all_matches(lis1, str1))

&gt; True
</code></pre>
</blockquote>
<p>This might not be the best solution for what you're looking, but I guess it serves the purpose.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all()</code></a> function</p>
<pre><code>In [1]: str1 = "45892190"
   ...: lis = [89,90]
   ...: all(str(l) in str1 for l in lis)
   ...:
Out[1]: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def contains(s, elems):
    for elem in elems:
        index = s.find(elem)
        if index == -1:
            return False
        s = s[:index] + s[index + len(elem) + 1:]
    return True
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; str1 = "45892190"
&gt;&gt;&gt; lis = [89,90]
&gt;&gt;&gt; contains(str1, (str(x) for x in lis))
True
&gt;&gt;&gt; contains("890", (str(x) for x in lis))
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the regular expression to search.</p>
<pre><code>import re
str1 = "45892190"
lis = [89,90]
for i in lis:
  x = re.search(str(i), str1)
  print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to implement this correctly using regular expressions. Generate all unique permutations of the input, for each permutation connect the terms with ".*" then connect all of the permutations with "|". For example, [89, 90, 8990] gets turned into 89.*8990.*90| 89.*90.*8990| 8990.*89.*90| 8990.*90.*89| 90.*89.*8990| 90.*8990.*89 , where I added a space after each "|" for clarity."</p>
<p>The following passes Eric Duminil's test suite.</p>
<pre><code>import itertools
import re

def create_numbers_regex(numbers):
    # Convert each into a string, and double-check that it's an integer
    numbers = ["%d" % number for number in numbers]

    # Convert to unique regular expression terms
    regex_terms = set(".*".join(permutation)
                            for permutation in itertools.permutations(numbers))
    # Create the regular expression. (Sorted so the order is invariant.)
    regex = "|".join(sorted(regex_terms))
    return regex

def contains_all_without_overlap(string, numbers):
    regex = create_numbers_regex(numbers)
    pat = re.compile(regex)
    m = pat.search(string)
    if m is None:
        return False
    return True
</code></pre>
<p>However, and this is a big however, the regular expression size, in the worst case, grows as the factorial of the number of numbers. Even with only 8 unique numbers, that's 40320 regex terms. It takes Python several seconds just to compile that regex.</p>
<p>The only time where this solution might be useful is if you have a handful of numbers and you wanted to search a lot of strings. In that case, you might also look into re2, which I believe could handle that regex without backtracking.</p>
</div>
<span class="comment-copy">All the elements? Or just one? What about overlap?</span>
<span class="comment-copy">@Willem All the elements in the list and no overlap</span>
<span class="comment-copy">What have you tried so far? Please show your work. We're not here to do your work for you.</span>
<span class="comment-copy">string = "45892190"     lis = [89,90,77,8]     for i in lis:         if str(i) in string:             lis.remove(i)             print(lis)      print(lis)</span>
<span class="comment-copy">@Soviut didn't work so far</span>
<span class="comment-copy">fails for <code>all_matches([89, 90, 8990], "8990189290")</code></span>
<span class="comment-copy">It looks like OP doesn't want any overlap.</span>
<span class="comment-copy">Sadly, this doesn't work at all. <code>+1</code> is wrong. Also, it returns True for <code>"45892190"</code> and <code>[89,90,4521]</code>. PS: I didn't downvote</span>
<span class="comment-copy">Improving this answer to work is actually trivial: instead of removing found numbers, replace them with a "placeholder" character (for example a space). Besides, the list should be first sorted in descending order, so that the longest numbers are matched first to avoid a problem illustrated by <code>contains("2302", [2, 23])</code>. Oh, and I am assuming the numbers in list are only positive integers.</span>
<span class="comment-copy">Wow this works brilliant!Didn't think regex would be so handy!</span>
<span class="comment-copy">@SouvikRay No it doesn't, please avoid accepting answers straight away without really looking into them. Try changing <code>str1</code> to <code>'890'</code> (instead of <code>'45892190'</code>) and <a href="https://pastebin.com/ViFeRxJt" rel="nofollow noreferrer">it still seems to work just fine</a>. This answer doesn't take into account your "<i>and no overlap</i>" requirement, which you said in the comments.</span>
<span class="comment-copy">If this answer really does work for you, and you don't actually care about overlap unlike you said in the comments (which makes this a duplicate question...), then I'd highly recommend using cricket_007 or Giovanni Gianni's answer instead, as they don't need to rely on regex.</span>
<span class="comment-copy">I do agree that this code does not consider overlapping.</span>
<span class="comment-copy">@EricDuminil Your answer looks perfect so far and accomplishes the objective as far as I have tested.</span>
