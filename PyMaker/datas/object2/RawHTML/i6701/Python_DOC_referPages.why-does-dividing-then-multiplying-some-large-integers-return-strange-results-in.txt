<div class="post-text" itemprop="text">
<p>I'm helping a friend on a homework assignment which requires a user to input an arbitrary number of seconds and display a string which represents that amount of time in terms of weeks, days, hours, minutes, and seconds.</p>
<p>I have a <code>TimeUnit</code> class that inherits from <code>int</code> and disallows the creation of negative units of time. I then have a <code>TimePeriod</code> class composed of <code>TimeUnits</code> that displays the string.</p>
<p>Specifically, it's this phenomenon that is confusing me:</p>
<pre><code>class TimeUnit(int):
    """A class that defines the semantics of a unit of time i.e. seconds, minutes, hours etc."""

    def __new__(cls, x):
        """Ensure no negative units are created."""
        if x &lt; 0:
            raise ValueError(f'Must be greater than zero')
        return super().__new__(cls, x)

    def __eq__(self, other):
        if isinstance(other, TimeUnit):
            return int(self.to_seconds()) == other.to_seconds()
        return super().__eq__(other)

    @classmethod
    def from_seconds(cls, seconds):
        raise NotImplementedError

    def to_seconds(self):
        raise NotImplementedError


class Seconds(TimeUnit):
    @classmethod
    def from_seconds(cls, seconds):
        return cls(seconds)

    def to_seconds(self):
        return self


class Weeks(TimeUnit):
    @classmethod
    def from_seconds(cls, seconds):
        return cls(seconds / 60 / 60 / 24 / 7)

    def to_seconds(self):
        return Seconds(self * 60 * 60 * 24 * 7)

x = 249129847219749821374782498

# Wat?
x - (Weeks.from_seconds(x).to_seconds()) # -&gt; -2491687902
</code></pre>
<p>How is <code>249129847219749821374782498 -
 (Weeks.from_seconds(249129847219749821374782498).to_seconds()) == -2491687902</code>? It ends up causing errors when I try to represent that number of seconds in string format with my <code>TimePeriod</code> class.</p>
<pre><code>class TimePeriod:
    def __init__(self, *units):
        self.seconds = Seconds(sum(unit.to_seconds() for unit in units))

    def __repr__(self):
        seconds = self.seconds

        weeks = Weeks.from_seconds(seconds)
        seconds -= weeks.to_seconds()

        days = Days.from_seconds(seconds)
        seconds -= days.to_seconds()

        hours = Hours.from_seconds(seconds)
        seconds -= hours.to_seconds()

        minutes = Minutes.from_seconds(seconds)
        seconds -= minutes.to_seconds()

        seconds = Seconds(seconds)

        return ' '.join(f'{unit} {unit.__class__.__name__}' for unit in (weeks, days, hours, minutes, seconds) if unit)

    def __str__(self):
        return repr(self)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is the fact that you divide in <code>from_seconds</code>, this will turn the integer to a floating point value. Floats have limited precision so you <em>may</em> lose some significant digits right there. However because you subclass <code>int</code> you just store integers (not floats) and the decimal part is simply discarded (see for example what <code>Weeks.from_seconds(x)</code> returns) which will make problems even if the integer value isn't that big - and what is eventually multiplied in <code>to_seconds</code> is just the integral part of the division.</p>
<p>Let's go through this step-by-step:</p>
<pre><code>&gt;&gt;&gt; 249129847219749821374782498 / (60*60*24*7)
4.119210436834488e+20

&gt;&gt;&gt; int(_)
411921043683448782848

&gt;&gt;&gt; _ * (60*60*24*7)
249129847219749823866470400
</code></pre>
<p>To make this work correctly you could, for example, subclass or simply use <code>fractions.Fraction</code>. There this conversion works correctly:</p>
<pre><code>&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; Fraction(x, 60*60*24*7) * 60 * 60 * 24 * 7
Fraction(249129847219749821374782498, 1)
&gt;&gt;&gt; int(_)
249129847219749821374782498
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your division is <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer">"true division"</a> that returns a <code>float</code>.  <code>int</code> is arbitrary-precision (in Python 3, which you're using), but <code>float</code> isn't, and it can't preserve that many digits (and rounds to a different <code>int</code>).</p>
</div>
<span class="comment-copy">Sounds like an epoch overflow.</span>
