<div class="post-text" itemprop="text">
<p>In my project, I'm using argprse to pass arguments and somewhere in script I'm using multiprocessing to do rest of the calculations. Script is working fine if I call it from command prompt 
for ex. </p>
<p>"<code>python complete_script.py --arg1=xy --arg2=yz</code>" .</p>
<p>But after converting it to exe using Pyinstaller using command "pyinstaller --onefile complete_script.py" it throws </p>
<p>error</p>
<blockquote>
<p>" error: unrecognized arguments: --multiprocessing-fork 1448"</p>
</blockquote>
<p>Any suggestions how could I make this work. Or any other alternative. My goal is to create an exe application which I can call in other system where Python is not installed. </p>
<p>Here are the details of my workstation:</p>
<pre><code>Platform: Windows 10
Python : 2.7.13 &lt;installed using Anaconda&gt;
multiprocessing : 0.70a1
argparse:   1.1
</code></pre>
<hr/>
<p>Copied from comment:</p>
<pre><code>def main():
     main_parser = argparse.ArgumentParser()
     &lt; added up arguments here&gt;
    all_inputs = main_parser.parse_args()
    wrap_function(all_inputs)


def wrap_function(all_inputs):
    &lt;Some calculation here &gt;
   distribute_function(&lt;input array for multiprocessing&gt;)

def distribute_function(&lt;input array&gt;):
    pool = Pool(process = cpu_count)
    jobs = [pool.apply_async(target_functions, args = (i,) for i in input_array)]
    pool.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>(A bit late but it can be useful for someone else in the future...)</p>
<p>I had the same problem, after some research I found <a href="https://github.com/pyinstaller/pyinstaller/wiki/Recipe-Multiprocessing" rel="nofollow noreferrer">this multiprocessing pyInstaller recipe</a> that states:</p>
<blockquote>
<p>When using the multiprocessing module, you must call</p>
<p><code>multiprocessing.freeze_support()</code></p>
<p>straight after the <code>if __name__ == '__main__':</code> line of the main module.</p>
<p>Please read the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.freeze_support" rel="nofollow noreferrer">Python library manual</a> about multiprocessing.freeze_support for more information.</p>
</blockquote>
<p>Adding that line of code solved the problem for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>I may be explaining the obvious, but you don't give us much information to work with.</p>
<pre><code>python complete_script.py --arg1=xy --arg2=yz
</code></pre>
<p>This sort of call tells me that your <code>parser</code> is setup to accept at least these 2 arguments, ones flagged with '--arg1' and '--arg2'.</p>
<p>The error tells me that this parser (or maybe some other) is also seeing this string:</p>
<pre><code>--multiprocessing-fork 1448
</code></pre>
<p>Possibly generated by the multiprocessing code.  It would be good to see the <code>usage</code> part of the error, just to confirm which parser is complaining.</p>
<p>One of my first open source contributions to Python was to enhance the warnings about multiprocessing on Windows.  </p>
<p><a href="https://docs.python.org/2/library/multiprocessing.html#windows" rel="nofollow noreferrer">https://docs.python.org/2/library/multiprocessing.html#windows</a></p>
<p>Is your parser protected by a <code>if __name__</code> block?  Should this particular parser be called when run in a fork?  You probably designed the parser to work when the program is called as a standalone script.  But when happens when it is imported?</p>
</div>
<span class="comment-copy">I've had numerous issues using Anaconda distributions + pyinstaller. I'm not sure pyinstaller is tested against Anaconda. My advice, if you're going to freeze a python app, make your life easier and use canonical python, not third-party distributions</span>
<span class="comment-copy">This might useful information to work for:   ['code'] def main(): main_parser = argparse.ArgumentParser() &lt; added up arguments here&gt; all_inputs = main_parser.parse_args() wrap_function(all_inputs)   def wrap_function(all_inputs): &lt;Some calculation here &gt; distribute_function(&lt;input array for multiprocessing&gt;)  def distribute_function(&lt;input array&gt;): pool = Pool(process = cpu_count) jobs = [pool.apply_async(target_functions, args = (i,) for i in input_array)] pool.close() ['code']</span>
<span class="comment-copy">When is <code>main</code> called?  On import or only by a <code>is __name__...</code> block?</span>
<span class="comment-copy">main() is called by  <b>name</b> ==  '<b>main</b>'  block</span>
