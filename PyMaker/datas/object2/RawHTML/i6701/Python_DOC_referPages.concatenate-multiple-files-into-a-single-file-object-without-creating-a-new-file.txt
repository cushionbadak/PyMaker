<div class="post-text" itemprop="text">
<p>This question is related to <a href="https://stackoverflow.com/questions/13613336/python-concatenate-text-files">Python concatenate text files</a></p>
<p>I have a list of <code>file_names</code>, like <code>['file1.txt', 'file2.txt', ...].</code> </p>
<p>I would like to open all the files into a single file object that I can read through line by line, but I don't want to create a new file in the process. Is that possible?</p>
<pre><code>with open(file_names, 'r') as file_obj:
   line = file_obj.readline()
   while line:
       ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/fileinput.html#fileinput.input" rel="noreferrer">input</a> from <a href="https://docs.python.org/3/library/fileinput.html" rel="noreferrer">fileinput</a> module. It reads from multiple files but makes it look like the strings are coming from a single file. (Lazy line iteration).</p>
<pre><code>import fileinput

files= ['F:/files/a.txt','F:/files/c.txt','F:/files/c.txt']

allfiles = fileinput.input(files)

for line in allfiles: # this will iterate over lines in all the files
    print(line)

# or read lines like this: allfiles.readline()
</code></pre>
<p>If you need all the text in one place use <code>StringIO</code></p>
<pre><code>import io

files= ['F:/files/a.txt','F:/files/c.txt','F:/files/c.txt']


lines = io.StringIO()   #file like object to store all lines

for file_dir in files:
    with open(file_dir, 'r') as file:
        lines.write(file.read())
        lines.write('\n')

lines.seek(0)        # now you can treat this like a file like object
print(lines.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try something along this lines:</p>
<pre><code>def read_files(*filenames):
    for filename in filenames:
        with open(filename,'r') as file_obj:
            for line in file_obj:
                yield line
</code></pre>
<p>you can call it with </p>
<pre><code>for line in read_files("f1.txt", "f2.txt", "f3.txt"):
    #... do whatever with the line
</code></pre>
<p>or </p>
<pre><code>filenames = ["f1.txt", "f2.txt", "f3.txt"]
for line in read_files(*filenames):
    #... do whatever with the line
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's say <code>multiple_files</code> is a list which contain all file names</p>
<pre><code>multiple_files = ["file1.txt", "file2.txt", "file3.txt", ...] # and so on...
</code></pre>
<p>Open the output file which will contain all </p>
<pre><code>f = open("multiple_files.txt", "w")
for _file in multiple_files:
    f.write(_file.read())
</code></pre>
<p>This way you don't have to read each and every line of your files.</p>
<p>Although the above method is simpler, You also have <strong>fileinput</strong> module as an alternative.</p>
<p><a href="https://docs.python.org/3/library/fileinput.html#module-fileinput" rel="nofollow noreferrer"><strong>fileinput docs</strong></a></p>
<p>You can use fileinput to access and process multiple files.  </p>
<p><strong>Example</strong>:</p>
<pre><code>with fileinput.input(files=('file1.txt', 'file2.txt')) as f:
    for line in f:
        process(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use fileinput package. This module implements a helper class and functions to quickly write a loop over a list of files </p>
<pre><code>import fileinput
with fileinput.input(files=('file1.txt', 'file2.txt', 'file3.txt')) as f:
    for line in f:
      #rest code
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of making python read multiple files, pipe the contents from the shell and read it from stdin. This will also make your program more flexible as you can pass in any set of files into your python program without changing your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>EDIT:</p>
<p>As pointed out in the comments, this solution probably would not be optimal for large files as it loads everything into memory. A solution using generators would be better if large files are involved. Thanks to LohmarASHAR for pointing that out!</p>
<p>You could just create on big list from all of the files by looping over the list of filenames. This wouldn't create a new file object, just a new list object:</p>
<pre><code>filenames = ["f1.txt", "f2.txt", "f3.txt"]

# list to store each line of the file
output = []

# iterate over list of filenames
for text_file in filenames:

    # open file
    with open(text_file) as f:

        # iterate over each line in the file and add to output
        for line in f.readlines():
            output.append(line)
</code></pre>
<p>Not that we are not explicitly calling <code>close()</code> on the file, this is because the <code>with...</code> statement will close the file for us as soon as it goes out of scope.</p>
<p>If you are able to use external libraries, pandas might be worth looking into for storing the file data in efficient, easy-to-use objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>Simplest way, is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">itertools.chain</a>,</p>
<p>which provide an easy way to read from multiple iterators.</p>
<blockquote>
<p>Make an iterator that returns elements from the first iterable until
  it is exhausted, then proceeds to the next iterable, until all of the
  iterables are exhausted. Used for treating consecutive sequences as a
  single sequence.</p>
</blockquote>
<p>Let's assume you have to files: <code>file1.txt</code> and <code>file2.txt</code>.</p>
<p><code>file1.txt</code> data is:</p>
<pre><code>file1 line1
file1 line2
</code></pre>
<p>and, the same way, <code>file2.txt</code> data is:</p>
<pre><code>file2 line1
file2 line2
</code></pre>
<p>This code:</p>
<pre><code> for f in chain(map(open, ['file1.txt', 'file2.txt'])):
     for line in f:
         print(line.strip())
</code></pre>
<p>will output this:</p>
<pre><code>file1 line1
file1 line2
file2 line1
file2 line2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using built-ins:</p>
<pre><code>product=[]
for File in ['file1.txt','file2.txt','file3.txt']:
    for line in open(File,'r').readlines():
        product.append(line)

for line in product:print(line)
</code></pre>
<p>file.readlines() outputs the contents to a list and the file is closed.</p>
<p>You could also write:</p>
<pre><code>product=[]
for File in ['file1.txt','file2.txt','file3.txt']:
    product+=open(File).readlines()
</code></pre>
<p>It's shorter and probably faster but I use the first because it reads better to me.</p>
<p>Cheers</p>
</div>
<span class="comment-copy">Yeah... put it in a function and call it.</span>
<span class="comment-copy">quite challenging approach promoting unix best practices. But using fileinput package allows for still having a file context for every line read - <a href="https://docs.python.org/3/library/fileinput.html#fileinput.filename" rel="nofollow noreferrer">docs.python.org/3/library/fileinput.html#fileinput.filename</a>  Depends on the use case which way to promote.</span>
<span class="comment-copy">The typical use is: This iterates over the lines of all files listed in sys.argv[1:], defaulting to sys.stdin if the list is empty. If a filename is '-', it is also replaced by sys.stdin.  <a href="https://docs.python.org/3/library/fileinput.html#module-fileinput" rel="nofollow noreferrer">docs.python.org/3/library/fileinput.html#module-fileinput</a></span>
<span class="comment-copy">watch out for long files, this way you are loading everything in the memory</span>
<span class="comment-copy">@LohmarASHAR thanks for pointing that out! Using generators would be better!</span>
<span class="comment-copy">Readability is not better than accepted answer. Maybe fileinput implementation is using itertools.chain</span>
