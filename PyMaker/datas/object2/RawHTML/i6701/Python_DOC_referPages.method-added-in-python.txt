<div class="post-text" itemprop="text">
<p>In Ruby, one can create callbacks for when methods are defined on an object:</p>
<pre><code>module Chatty
  def self.method_added(method_name)
    puts "Adding #{method_name.inspect}"
  end
  def self.some_class_method() end
  def some_instance_method() end
end
# =&gt; Adding :some_instance_method
</code></pre>
<p>Does Python have any similar callback?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, methods are just <em>attributes</em> that happen to be callable<sup>*</sup>. You'd have to hook in to attributes being set to see new methods being added to a class.</p>
<p>You'd have to use a <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer"><em>metaclass</em></a> to intercept new attributes being added to a class:</p>
<pre><code>import types

class NewMethodAlerter(type):
    def __setattr__(self, name, obj):
        if isinstance(obj, types.FunctionType):
            print(f'New method {name} added!')
        super().__setattr__(name, obj)


class Demo(metaclass=NewMethodAlerter):
    def existing_method(self):
        pass

def new_method(self): pass
Demo.new_method = new_method
</code></pre>
<p>which then looks like this:</p>
<pre><code>&gt;&gt;&gt; class Demo(metaclass=NewMethodAlerter):
...     def existing_method(self):
...         pass
...
&gt;&gt;&gt; def new_method(self): pass
&gt;&gt;&gt; Demo.new_method = new_method
New method new_method added!
</code></pre>
<p>If you wanted to know about the <em>initial</em> set of attributes, the result of executing the <code>class</code> body, then you have two options: use a metaclass, or in Python 3.6 and up, the <a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow noreferrer"><code>__init_subclass__</code> method</a>. Either one is called to create new classes, and can be used to inspect the attributes:</p>
<pre><code>class InitialMethodAlerter(type):
    def __new__(typ, name, bases, attrs):
        for name, obj in attrs.items():
            if isinstance(obj, types.FunctionType):
                print(f'Method {name} defined!')
        return super().__new__(typ, name, bases, attrs)

class Demo(metaclass=InitialMethodAlerter):
    def existing_method(self):
        pass
</code></pre>
<p>or the <code>__init_subclass__</code> method:</p>
<pre><code>class InitialMethodAlerter:
    @classmethod
    def __init_subclass__(cls, **kwargs):
        for name, obj in vars(cls).items():
            if isinstance(obj, types.FunctionType):
                print(f'Method {name} defined!')

class Demo(InitialMethodAlerter):
    def existing_method(self):
        pass
</code></pre>
<p>You may want to read up on metaclasses at <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python?</a></p>
<hr/>
<p><sup>*</sup>Well, the attributes are <em>functions</em> actually. Functions are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor objects</a>, which causes them to be bound when accessed via an instance. That binding process produces a method object, that when called takes the original function and passes in the instance to which it was bound.</p>
</div>
<span class="comment-copy">Not for methods added during class creation. Afterwards it's just <code>__setattr__</code> like any other attribute.</span>
<span class="comment-copy">You can do this with a metaclass.</span>
<span class="comment-copy">What is a good use case for this functionality? I think it would be cool if you provided some motivation too.</span>
<span class="comment-copy">So there's no way to intercept methods defined in the class definition?</span>
<span class="comment-copy">@faraz: what are you trying to achieve here? I may have misunderstood. The metaclass is <i>also</i> told about all the initial attributes for the class, as the class is created.</span>
<span class="comment-copy">I'd expect <code>New method existing_method added!</code> to appear after the class is defined.</span>
<span class="comment-copy">@faraz: your question was confusing me there, because of the terminology 'added'. I've updated the question, but it's more and more a duplicate of <a href="//stackoverflow.com/q/100003">What is a metaclass in Python?</a> now.</span>
<span class="comment-copy">@faraz One small clarification to help you understand why you are not seeing the message about the existing method: the <code>__setattr__</code> method isn't called when the class body is executed and all of the initial class members are created. There is a separate set of machinery invoked for class <i>creation</i>.</span>
