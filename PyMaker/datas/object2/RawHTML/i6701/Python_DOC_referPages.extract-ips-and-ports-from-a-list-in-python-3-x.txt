<div class="post-text" itemprop="text">
<p>I would like to extract an IP and Port from a returned list. I am currently using str(var).replace command to remove extra characters. This will/has cause problems when the string format changes making the .replace command through an error</p>
<pre><code>def discover_device():
    """ This function will look for available device on the local network and extract the IP from the result"""
    discover_device = '[&lt;Device: 192.168.222.123:8075&gt;]' # Actually: call to broadcasting device
    device_ip = str(discover_device).replace('[&lt;Device: ', '').replace(':8075&gt;]', '')
</code></pre>
<p>So the problem would come if:
    <code>[&lt;Device: xxx.xxx.xxx.xxx:xxxx&gt;]</code></p>
<p>Changed to this:
    <code>[&lt;now_what: xxx.xxx.xxx.xxx:xxxx&gt;]</code></p>
<p>The <code>dicovery_device()</code> would through and error.</p>
<p><strong>What is the best practise to identify an ip/port pattern and extract ip and port without having to rely on the integrity of surrounding characters?</strong> </p>
<p>From this: <code>[&lt;Device: 192.168.222.123:8075&gt;]</code></p>
<p>To this: <code>192.168.222.123:8075</code></p>
<p>and preferably: <code>[192.168.222.123, 8075]</code></p>
<p>Taking into consideration IP variances within dot blocks and largest port number based on 16-bit (normally 4 integers after the colon up to 5 integers)</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming an IPv4 address, try extracting numbers and critical punctuation.  Then slice the valid result when necessary. Also validating ip addresses may be a safer approach.  </p>
<p>In Python 3:</p>
<p><strong>Code</strong></p>
<pre><code>import string
import ipaddress


def validate_port(func):
    """Return the results or raise and exception for invalid ports."""
    def wrapper(arg):
        result = func(arg)
        if len(result) == 2 and not result[-1].isdigit():
            raise ValueError("Invalid port number.")
        return result
    return wrapper


@validate_port
def discover_device(device):
    """Return a list of ip and optional port number.  Raise exception for invalid ip."""
    result = "".join(i for i in device if i in (string.digits +".:")).strip(":").split(":")

    try:
        ipaddress.ip_address(result[0])
    except ValueError as e:
        # Numbers in the device name (index 0) or invalid ip
        try:
            ipaddress.ip_address(result[1])
        except IndexError:
            raise e
        else:
            return result[1:]
    else:
        return result
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>discover_device("[&lt;Device: 192.168.222.123&gt;]")
# ['192.168.222.123']

discover_device("[&lt;Device: 192.168.222.123:8075&gt;]")
# ['192.168.222.123', '8075']

discover_device("[&lt;Device.34: 192.168.222.123:8080&gt;]")
# ['192.168.222.123', '8080']

discover_device("[&lt;Device: 192.168.222123&gt;]")
# ValueError: '192.168.222123' does not appear to be an IPv4 or IPv6 address

discover_device("[&lt;Device21: 192.168.222123&gt;]")
# ValueError: '192.168.222123' does not appear to be an IPv4 or IPv6 address

discover_device("[&lt;device.451: 192.168.222.123:80.805&gt;]")
# ValueError: Invalid port number.
</code></pre>
<p><strong>Features</strong></p>
<ul>
<li>insensitive to surrounding characters</li>
<li>ip address validation (not IPv6) and exception handling</li>
<li>safeguard against numbers in the device name</li>
<li>validate port numbers (optional)</li>
</ul>
<hr/>
<p><strong>Details</strong></p>
<p>Typically <code>result</code> is a list comprising the ip and an optional port number.  However, in cases where numbers are in the device name, the first index of the result will include unwanted numbers.  Here are examples of <code>result</code>:</p>
<pre><code>    # ['192.168.222.123']                                  ip   
    # ['192.168.222.123', '8075']                          ip, port
    # ['192.168.222123']                                   invalid ip
    # ['.34', '192.168.222.123', '8080']                   device #, ip, port
    # ['192.168.222.123', '80.805']                        invalid port
</code></pre>
<p>The exception handling tests for numbers in the device name and validates ip addresses in the first or second indices.  If none are found, an exception is raised.</p>
<p>Although validating port numbers is outside the scope of the question, ports are assumed to be a number. A simple test was added to the <code>validate_port</code> decorator, which can be applied or updated as desired. The decorator screens the output from <code>discover_device()</code>.  If the port is not a pure number, an exception is raised.  See <a href="https://stackoverflow.com/questions/113224/what-is-the-largest-tcp-ip-network-port-number-allowable-for-ipv4">this post</a> for modifying restrictions.  See <a href="https://www.thecodeship.com/patterns/guide-to-python-function-decorators/" rel="nofollow noreferrer">this blog</a> for a great tutorial on Python decorators.</p>
<p><strong>Options</strong></p>
<p><em>If validation is not a concern</em>, the following code should suffice, provided <code>"."</code> is absent from the device name:</p>
<pre><code>def discover_device(device):
    result = "".join(i for i in device if i in (string.digits +".:")).strip(":").split(":")
    if "." not in result[0]:
        return result[1:]
    return result
</code></pre>
<p><em>If a non-decorator solution is preferred</em>, define the following function:</p>
<pre><code>def validate_port(result):
    """Return the results or raise and exception for invalid ports."""
        if len(result) == 2 and not result[-1].isdigit():
            raise ValueError("Invalid port number.")
        return result
</code></pre>
<p>Now pass the return values of <code>discover_device()</code> into the latter function, i.e.<code>return validate_port(result[1:])</code> and <code>return validate_port(result)</code>.</p>
<p>Regards to @coder for suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>No regex is needed for this. Use <code>str</code>'s builtin method <a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer"><code>split</code></a>.</p>
<pre><code>&gt;&gt;&gt; device = '[&lt;Device: 192.168.222.123:8075&gt;]'
&gt;&gt;&gt; _, ip, port = device.strip('[&lt;&gt;]').split(':')
&gt;&gt;&gt; print((ip.strip(), port))
('192.168.222.123', '8075')
</code></pre>
<p>If you <em>really</em> want to use a regex, I would use a simple one:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; ip, port = re.findall('([\d.]+)', device)
&gt;&gt;&gt; print((ip, port))
('192.168.222.123', '8075')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use a <a href="http://www.regular-expressions.info/ip.html" rel="nofollow noreferrer">regex</a> to find the IP address, independently from what's before.</p>
<p>For example this one :</p>
<pre><code>\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b
</code></pre>
<p>As a test :</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', '[&lt;Device: 192.168.222.123:8075&gt;]')
['192.168.222.123']
&gt;&gt;&gt; re.findall(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', '[&lt;SomethingElse: 192.168.222.123:8075&gt;]')
['192.168.222.123']
&gt;&gt;&gt; re.findall(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{,5}', '[&lt;SomethingElse: 192.168.222.123:8075&gt;]')
['192.168.222.123:8075']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think your best bet is to use regular expressions:</p>
<pre><code>import re

def discover_device(in_str):
    m = re.search('(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:\:\d{1,5})?)', in_str)
    if m:
        return m.group(0)
    else:
        return None
</code></pre>
<p>If your regex string is <code>(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:\:\d{1,5})?)</code>, then the breakdown is:</p>
<ul>
<li><code>\d{1,3}\.</code> looks for between 1 and 3 digits followed by a period</li>
<li><code>(?:\:\d{1,5})?</code> looks for one or zero occurrences of a semicolon followed by between 1 and 5 digits (the <code>?:</code> specifies that it's a non-capturing group so that it won't be present by itself in your result)</li>
</ul>
<hr/>
<p>If you wanted it to capture the port and IP separately, you could do</p>
<pre><code>def discover_device(in_str):
    m = re.search('(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?:\:(\d{1,5}))?', in_str)
    if m:
        return (m.group(1), m.group(2))
    else:
        return None
</code></pre>
<p><a href="https://regex101.com/r/qxXU14/1" rel="nofollow noreferrer">Here's</a> the regex if you want to play with it.</p>
</div>
<span class="comment-copy">So if your input is <code>'[&lt;Device: 192.168.222.123:8075&gt;]'</code> you'd like to extract the <code>192.168.222.123:8075</code> part?</span>
<span class="comment-copy">Yes,but ideally into two separate variables ip_var and port_var. I'll edit my question to reflect your comment. Thanks!</span>
<span class="comment-copy">Since this question is asking about future-proofing, it seems like the best answer would also include handling IPv6 addresses, as well, which will <i>really</i> cook things up, since they include <code>:</code> characters.</span>
<span class="comment-copy">I am relatively new here, this was my first question. I appreciate all the answers, I found them all very useful. Thank you!</span>
<span class="comment-copy">Is a space guaranteed after the device name?</span>
<span class="comment-copy">Thanks.  Now it works for ips and optional ports.</span>
<span class="comment-copy">Thx @coder.  The post has been improved given your edge case.</span>
<span class="comment-copy">I like how you think @coder.  Added ip validation using Python 3's <code>ipaddress</code> module.</span>
<span class="comment-copy">thx for considering my suggestions, I wish I could upvote more than once.</span>
<span class="comment-copy">@pylang Thank you for the comprehensive answer. I have a question, should it not though an error if I feed this <code>discover_device("[&lt;device.451: 192.168.222.123:80.805&gt;]")</code>, but in place of an error I get this <code>['192.168.222.123', '80.805']</code>. if I add a <b>coma</b> among the port numbers it recognize it, but not a <b>period</b>. is IP validation a function of  <code>ipaddress</code>?</span>
<span class="comment-copy">This relies on the first colon being present, though.  If the input were changed more drastically than in OP's example, you might have input like <code>'[&lt;Device:: 192.168.222.123:8075&gt;]'</code> or <code>'[&lt;Device 192.168.222.123:8075&gt;]'</code> or <code>'[(Device: 192.168.222.123:8075)]'</code> which would break in your example.</span>
<span class="comment-copy">@RagingRoosevelt: OP mentioned that the device name might change to the form <code>[&lt;now_what: xxx.xxx.xxx.xxx:xxxx&gt;]</code>. My answer works for this as well. An answer does not need to work for every case imaginable; it's for this specific question. If the OP expects to have a device name in another form, I'll change my answer.</span>
<span class="comment-copy">If you read the question again, OP never specified that device name was what changed about that string (in fact, that was an assumption you introduced).  OP only specified "This will/has cause problems when the string format changes making the .replace command through an error".  OP provided one example of <b>a</b> way the format could change.</span>
<span class="comment-copy">@RagingRoosevelt: According to OP: "So the problem would come if:  [&lt;Device: xxx.xxx.xxx.xxx:xxxx&gt;] Changed to this:  [&lt;now_what: xxx.xxx.xxx.xxx:xxxx&gt;]" (which I would consider a change in the device's name). Like I said, if OP has concessions about a specific form, he should state that in the question.</span>
<span class="comment-copy">@zachGates I do appreciate your answer, is compact but doesn't actually answer my questing, the one in bold, specifically ask for a solution  "without having to rely on the integrity of surrounding characters" so I am more inclined to use regex as some of the other users have suggested.</span>
<span class="comment-copy">a question, because a port can be 5 digits in length this "\d{,4}" could be "\d{,5}" would that mean from none to 5 ? - Thank you</span>
<span class="comment-copy">@EnriqueBruzual: Yes indeed</span>
