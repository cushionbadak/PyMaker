<div class="post-text" itemprop="text">
<p>I understand that I can use <code>combine_first</code> to merge two series:</p>
<pre><code>series1 = pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])
series2 = pd.Series([1,2,3,4,5],index=['f','g','h','i','j'])
series3 = pd.Series([1,2,3,4,5],index=['k','l','m','n','o'])

Combine1 = series1.combine_first(series2)
print(Combine1
</code></pre>
<p>Output:</p>
<pre><code>a    1.0
b    2.0
c    3.0
d    4.0
e    5.0
f    1.0
g    2.0
h    3.0
i    4.0
j    5.0
dtype: float64
</code></pre>
<p>What if I need to merge 3 or more series?</p>
<p>I understand that using the following code: <code>print(series1 + series2 + series3)</code>yields:</p>
<pre><code>a   NaN
b   NaN
c   NaN
d   NaN
e   NaN
f   NaN
...
dtype: float64
</code></pre>
<p>Can I merge multiple series efficiently without using <code>combine_first</code> multiple times?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on your edit, I believe you need a concatenation along the <em>first</em> axis, followed by a <code>sum</code> along the same axis. </p>
<pre><code>def combine_multi(ser_list):
    return pd.concat([series1, series2, series3], 1).fillna(0).sum(1)
</code></pre>
<hr/>
<p><strong>Example A</strong> (<em>different indices</em>)</p>
<pre><code>series1 = pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])
series2 = pd.Series([1,2,3,4,5],index=['f','g','h','i','j'])
series3 = pd.Series([1,2,3,4,5],index=['k','l','m','n','o'])

out = combine_multi([series1, series2, series3])
out

a     5.0
b    12.0
c    15.0
d     3.0
e     4.0
g     6.0
h     7.0
i     8.0
j     9.0
k    10.0
m    12.0
o    14.0
dtype: float64
</code></pre>
<p><strong>Example B</strong> (<em>overlapping indices</em>)</p>
<pre><code>series1 = pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])
series2 = pd.Series([1,2,3,4,5],index=['a','b','c','i','j'])
series3 = pd.Series([1,2,3,4,5],index=['k','b','m','d','f'])

out = combine_multi([series1, series2, series3])
out

a    2.0
b    6.0
c    6.0
d    8.0
e    5.0
f    5.0
i    4.0
j    5.0
k    1.0
m    3.0
dtype: float64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Presuming that you were using the behavior of <code>combine_first</code> to prioritize the values of the series in order as <code>combine_first</code> is meant for, you could succinctly make multiple calls to it with a lambda expression. </p>
<pre><code>from functools import reduce
l_series = [series1, series2, series3]
reduce(lambda s1, s2: s1.combine_first(s2), l_series)
</code></pre>
<p>Of course if the indices are unique as in your current example, you can simply use <code>pd.concat</code> instead. </p>
<p><strong>Demo</strong></p>
<pre><code>series1 = pd.Series(list(range(5)),index=['a','b','c','d','e'])
series2 = pd.Series(list(range(5, 10)),index=['a','g','h','i','j'])
series3 = pd.Series(list(range(10, 15)),index=['k','b','m','c','o'])

from functools import reduce
l_series = [series1, series2, series3]
print(reduce(lambda s1, s2: s1.combine_first(s2), l_series))

# a     0.0
# b     1.0
# c     2.0
# d     3.0
# e     4.0
# g     6.0
# h     7.0
# i     8.0
# j     9.0
# k    10.0
# m    12.0
# o    14.0
# dtype: float64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would use combine_first if you want one series's values prioritized over the other. Its usually used to fill the missing values in the first series. I am not sure whats the expected output in your example but looks like you can use concat</p>
<pre><code>pd.concat([series1, series2, series3])
</code></pre>
<p>You get</p>
<pre><code>a    1
b    2
c    3
d    4
e    5
f    1
g    2
h    3
i    4
j    5
k    1
l    2
m    3
n    4
o    5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Agree with what @codespeed has pointed out in his answer.</p>
<p>I think it will depend on user needs. If series index are confirmed with no overlapping, concat will be a better option. (as original question posted, there is no index overlapping, then concat will be a better option)</p>
<p>If there is index overlapping, you might need to consider how to handle overlapping, which value to be overwritten. (as example provided by codespeed, if index are matching to different values, need to be careful about combine_first)</p>
<p>i.e. (note series3 is same as series1, series2 is same as series4)</p>
<pre><code>import pandas as pd
import numpy as np


series1 = pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])
series2 = pd.Series([2,3,4,4,5],index=['a','b','c','i','j'])
series3 = pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])
series4 = pd.Series([2,3,4,4,5],index=['a','b','c','i','j'])


print(series1.combine_first(series2))



a    1.0
b    2.0
c    3.0
d    4.0
e    5.0
i    4.0
j    5.0
dtype: float64



print(series4.combine_first(series3))



a    2.0
b    3.0
c    4.0
d    4.0
e    5.0
i    4.0
j    5.0
dtype: float64
</code></pre>
</div>
<span class="comment-copy">I don't think you wanted "concat' when you said "merge". Look at <a href="https://stackoverflow.com/a/46271244/4909087">stackoverflow.com/a/46271244/4909087</a>, you seem not to have noticed the other answers.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/46249866/how-to-add-items-of-multiple-panda-dataseries-in-a-list-python/" title="how to add items of multiple panda dataseries in a list python">stackoverflow.com/questions/46249866/…</a></span>
<span class="comment-copy">@coldspeed To clarify, my intention was to merge, meaning to add up the values from different series that share the same index. I see now the confusion was caused because in my question, all the indexes from all the series are different.</span>
<span class="comment-copy">@KaneChew If your question had been a little more clear, you could have saved us all time...</span>
<span class="comment-copy">@KaneChew I've edited my answer to add the solution to your question. Next time, be more clear.</span>
<span class="comment-copy">While in principle, this is the same as my answer, the touch with reduce is quite nice!</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Ah cheers, yeah I didn't see yours when I posted.</span>
<span class="comment-copy">No worries my friend. You get a +1 from me.</span>
<span class="comment-copy">@Mitch I guess I have a lot to learn because I dun quite understand the objective/purpose of using 'reduce' in this instance</span>
<span class="comment-copy">@KaneChew We want to apply <code>combine_first </code> first to <code>series1</code> and <code>series2</code>, and then to that result and <code>series3</code>. <code>reduce</code> with a lambda works nicely for this - first try <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer">checking out the docs</a> with the addition example and hopefully it will make a bit more sense.</span>
<span class="comment-copy">look down for an identical answer...</span>
<span class="comment-copy">@vaishali Could you explain/elaborate what you meant by prioritized? Thanks.</span>
<span class="comment-copy">@Kane Chew, say you have two series, series1 = pd.Series([1,2,np.nan,np.nan,5],index=['a','b','c','d','e']) series2 = pd.Series([1,2,3,4,5],index=['f','g','h','i','j']), you use series1.combine_first(series2) to fill the missing values on the first with the second</span>
<span class="comment-copy">@vaishali I guess you meant when both series have the same index? 'series1 = pd.Series([1,2,np.nan,np.nan,5],index=['a','b','c','d','e'])  series2 = pd.Series([1,2,3,4,5],index=['a','b','c','d','e']) series3 = series1.combine_first(series2) print(series3) ' I am surprised that the values do not add up for the same index</span>
