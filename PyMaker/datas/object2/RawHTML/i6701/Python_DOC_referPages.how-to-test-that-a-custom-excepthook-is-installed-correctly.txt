<div class="post-text" itemprop="text">
<p>My app logs unhandled exceptions.  </p>
<pre><code># app.py
import logging
import sys

logger = logging.getLogger(__name__)

def excepthook(exc_type, exc_value, traceback):
    exc_info = exc_type, exc_value, traceback
    if not issubclass(exc_type, (KeyboardInterrupt, SystemExit)):
        logger.error('Unhandled exception', exc_info=exc_info)
    sys.__excepthook__(*exc_info)

sys.excepthook = excepthook

def potato():
    logger.warning('about to die...')
    errorerrorerror

if __name__ == '__main__':
    potato()
</code></pre>
<p>These tests pass OK:</p>
<pre><code># test_app.py
import app
import pytest
import sys
from logging import WARNING, ERROR

def test_potato_raises():
    with pytest.raises(NameError):
        app.potato()

def test_excepthook_is_set():
    assert sys.excepthook is app.excepthook

# for caplog plugin: pip install pytest-catchlog
def test_excepthook_logs(caplog):  
    try:
        whatever
    except NameError as err:
        exc_info = type(err), err, err.__traceback__
    app.excepthook(*exc_info)
    assert caplog.record_tuples == [('app', ERROR, 'Unhandled exception')]
    [record] = caplog.records
    assert record.exc_info == exc_info
</code></pre>
<p>But I couldn't get a test of unhandled exceptions logging working:</p>
<pre><code>def test_unhandled_exceptions_logged(caplog):
    try:
        app.potato()
    finally:
        assert caplog.record_tuples == [
            ('app', WARNING, 'about to die...'),
            ('app', ERROR, 'Unhandled exception'),
        ]
        return  # return eats exception
</code></pre>
<p>What's wrong here?  How can we actually trigger the <code>app.excepthook</code> from within a test?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python won't call <code>sys.excepthook</code> until an exception actually propagates all the way through the whole stack and no more code has an opportunity to catch it. It's one of the very last things that happen before Python shuts down in response to the exception.</p>
<p>As long as your test code is still on the stack, <code>sys.excepthook</code> won't fire. What little code actually can run after <code>sys.excepthook</code> probably isn't going to play well with your testing framework. For example, <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer"><code>atexit</code></a> handlers can still run, but the test is over by then. Also, your test framework is probably going to catch the exception itself if you don't, so <code>sys.excepthook</code> won't fire anyway.</p>
<p>If you don't want to call <code>sys.excepthook</code> yourself, your best bet may be to launch an entire subprocess with your <code>excepthook</code> installed and verify the subprocess's behavior.</p>
<pre><code>from subprocess import Popen, PIPE

def test_app():
    proc = Popen([sys.executable, 'app.py'], stdout=PIPE, stderr=PIPE)
    stdout, stderr = proc.communicate()
    assert proc.returncode == 1
    assert stdout == b''
    assert stderr.startswith(b'about to die...\nUnhandled exception')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>pytest</code> can check the exception message. You can do something like this:</p>
<pre><code>&gt;&gt;&gt; import pytest
&gt;&gt;&gt; def foo():
...  raise ValueError('Unhandled Exception')
...
&gt;&gt;&gt; with pytest.raises(ValueError) as exc:
...  foo()
...
&gt;&gt;&gt; 'Unhandled Exception' in str(exc)
True
&gt;&gt;&gt; str(exc)
'&lt;stdin&gt;:2: ValueError: Unhandled Exception'
&gt;&gt;&gt;
</code></pre>
<p>You can actually test the whole thing in one test. No need for multiple test functions.</p>
</div>
<span class="comment-copy">"But I couldn't get a test of unhandled exceptions logging working" - well, until the exception actually propagates all the way (which it won't), it's not really an unhandled exception, and the excepthook won't fire.</span>
<span class="comment-copy">Right, that's exactly the issue (the test runner catches the exception).  I was looking for a way to configure pytest to "get [further] out of the way" i.e. to allow <code>app.excepthook</code> to run, but not the <code>sys.__excepthook__</code>.  But maybe it's not possible.  Running in a subprocess was a workaround that I was hoping to avoid, because it's not clear how to get the coverage reporting cooperating in that situation.</span>
<span class="comment-copy">It looks like the low-level <code>thread</code> module might let you do this, although I'm not sure how to suppress the "Unhandled exception in thread started by..." message.</span>
<span class="comment-copy">Did you try it?  <code>AttributeError: 'ExceptionInfo' object has no attribute 'message'</code>.</span>
<span class="comment-copy">I have already tried it. Check out the updated answer</span>
<span class="comment-copy">Totally my bad. I had used pytest in the past. So that's why was confident that the exception text gets saved in <code>exc.message</code>. Went back and checked in my projects. I found it that it was <code>str(exc)</code> that has the error text. Updated the answer with the example and removing the other example related to <code>exc.message</code>.</span>
<span class="comment-copy">OK, so, this is not really answering the question.  I am not trying to check the text of the exception message.  I am trying to test that an unhandled exception in the app triggers the except hook to be called, which <i>logs</i> a message.  Do you have any ideas about that?</span>
<span class="comment-copy">Right, but I never raised an exception with "Unhandled Exception" as the message.  That message is only added in the logging call.  In your example you explicitly wrote the "Unhandled Exception" into the error message manually.</span>
