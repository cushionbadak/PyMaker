<div class="post-text" itemprop="text">
<p>I'm running the following code:</p>
<pre><code>from threading import Thread
from time import sleep

def file_write(file_input, num_lines):
    sleep(10)
    file = open("testfile.txt", "w")
    for line in num_lines:
        file.write("{}: {}".format(line, file_input))

    file.close()


if __name__ == '__main__':
    curr_thread = Thread(target=file_write, args=("Norah", range(5)))
    curr_thread.daemon = False
    curr_thread.start()
</code></pre>
<p>The expectation is the main thread will exit immediately, because I don't call join. But it doesn't. Do sleep calls block the main thread too?</p>
<p>EDIT: There is a similar question asked in this thread: <a href="https://stackoverflow.com/questions/92928/time-sleep-sleeps-thread-or-process">time.sleep -- sleeps thread or process?</a> but it's not the same.<br/>
I looked at the thread: it says that sleep doesn't cause child processes to block each other, but it doesn't say what happens to the main thread. When I ran the code from the accepted answer, the main thread did not exit immediately, as I thought it would.</p>
<p>UPDATE: Looks like multithreading won't solve my problem: the aim is to run a bunch of tasks in the background. I'm using the subprocess module instead now. </p>
</div>
<div class="post-text" itemprop="text">
<p>Sleep calls only block the thread in which they're called. Printing anything in the main thread immediately after the call to <code>curr_thread.start()</code> will prove this to you.</p>
<p>However, if you interrupt your code (Ctrl-C), you'll see a useful stack trace. The last call is inside the <code>threading</code> module's <code>_shutdown()</code> method, which appears to be waiting for all <em>non-daemon</em> threads to finish.</p>
<pre><code>t = _pickSomeNonDaemonThread()
while t:
    t.join()
    t = _pickSomeNonDaemonThread()
</code></pre>
<p>And reading <a href="https://docs.python.org/3/library/threading.html?highlight=threading#threading.Thread.daemon" rel="nofollow noreferrer">the documentation</a> for the threading module, you can see that: "The entire Python program exits when no alive non-daemon threads are left." So, because you've done <code>curr_thread.daemon = False</code>, you're forcing the main thread to wait for this thread to finish first.</p>
<p>I should point out, though, that threads inherit the "daemon-ness" of their parents. Since the main thread is never a daemon thread, you could have left off the <code>curr_thread.daemon = False</code>, and you'd get the same behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>Of course a sleep in a thread does not block the main thread.</p>
<p>This code demonstrates that main continues:</p>
<pre><code>from threading import Thread
from time import sleep

def file_write(file_input, num_lines):
    print('a')
    sleep(5)
    print('b')


if __name__ == '__main__':
    curr_thread = Thread(target=file_write, args=("Norah", range(5)))
    curr_thread.daemon = False
    curr_thread.start()
    for i in range(5):
        sleep(1)
        print(i)
</code></pre>
<p>Output:</p>
<pre><code>a
0
1
2
3
b
4
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/92928/time-sleep-sleeps-thread-or-process">time.sleep -- sleeps thread or process?</a></span>
<span class="comment-copy">I looked at the thread: it says that sleep doesn't cause child processes to block each other, but it doesn't say what happens to the main thread. When I ran the code from the accepted answer, the main thread did not exit immediately, as I thought it would.</span>
<span class="comment-copy">Are you doing <code>curr_thread.join()</code>? The main thread should exit immediately. Joining the thread will wait until the thread is finished before quitting.</span>
<span class="comment-copy">I am not making any join calls: I'm running only what I have pasted above.</span>
<span class="comment-copy">I just ran the code <a href="https://pastebin.com/97r4T3QF" rel="nofollow noreferrer">here</a>. Try it for yourself. You should see it print "a", "b", "d", "e", (main thread exit), "c". Edit: I ran your code as well, the main thread exits immediately as you expected.</span>
<span class="comment-copy">Thing is, if I set curr_thread.daemon = True, then the program exits immediately, but the child thread seems to be torn down in the process: the file-write calls do not execute.</span>
<span class="comment-copy">@NorahBorus Yes, the second thread will be terminated. This is because the whole process exits, because there are no non-daemon threads left. The main thread is the only non-daemon thread if you set <code>curr_thread.daemon = True</code>, right? So when it finishes (immediately, since you never <code>join()</code>), the whole process will exit.</span>
<span class="comment-copy">@NorahBorus This is starting to seem a bit like an XY problem. Why do you want to create a second thread at all? Or is this an exercise to understand the threading module?</span>
<span class="comment-copy">I was trying to use the threading module to run some tasks in the background, but it seems it's not the way to go about it. I'll use the subprocess module instead. Thanks for the clarification.</span>
<span class="comment-copy">See bnaeckner's comment and my code example: I specified that the question is about what happens when the main thread is exiting.</span>
