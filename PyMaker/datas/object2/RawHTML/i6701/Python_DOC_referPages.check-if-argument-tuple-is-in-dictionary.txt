<div class="post-text" itemprop="text">
<p>I'm really struggling on unpacking and iterating over the tuples in this dictionary.  Essentially, the function takes a two coordinate position (Wx, Wy) and checks to see if it is in one of the tuples located in either list, in the dictionary, bonuses.  I feel like I'm overthinking it, or am just way off.</p>
<p>Thanks :)</p>
<pre><code>bonuses = {1: [(3,3)], 2: [(1, 0), (0, 3), (2, 4), (5, 2)]}

def find_bonus(pos):
""" Check if position is valid"""

    bonus_info = dict.values(bonuses)

    for (Wx, Wy) in pos:
        if (Wx, Wy) in tuple(bonus_info):
            return pos
    else:
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer"><code>itertools.chain()</code></a> :</p>
<pre><code>from itertools import chain

def find_bonus(pos):
    return pos if pos in chain(*bonuses.values()) else False
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; bonuses = {1: [(3,3)], 2: [(1, 0), (0, 3), (2, 4), (5, 2)]}
&gt;&gt;&gt; find_bonus((100,10))
False
&gt;&gt;&gt; find_bonus((10,10))
False
&gt;&gt;&gt; find_bonus((1,0))
(1, 0)
&gt;&gt;&gt; find_bonus((3,3))
(3, 3)
&gt;&gt;&gt; find_bonus((5,2))
(5, 2)
</code></pre>
<p>This works because <code>chain()</code>, when combined with the <code>*</code> unpacking operator applied to <code>bonuses.values()</code>, effectively flattens the dictionary's values into a single list for which membership can easily be tested with <code>in</code>.</p>
<p>Your function can be simplified further if you have it return a boolean:</p>
<pre><code>def find_bonus(pos):
    return pos in chain(*bonuses.values())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can compare tuple to tuple directly:</p>
<p>1- iterate over the values of the dictionary.
2- check if <code>pos</code> is in the values, and return <code>True</code> if it is<br/>
3- if pos was not found anywhere, return <code>False</code></p>
<pre><code>bonuses = {1: [(3,3)], 2: [(1, 0), (0, 3), (2, 4), (5, 2)]}

def find_bonus(pos):
""" Check if position is valid"""

    for valid_pos in bonuses.values():
        if pos in valid_pos:
            return pos   # &lt;-- or return True, depending if pos can ever evaluate at False.
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just do this instead. (Assuming pos is a single tuple)</p>
<pre><code>bonus_info = set(i for i in j for j in bonuses.values())
def find_bonus(pos):
    if pos in bonus_info:
        return pos
    else:
        return None
</code></pre>
</div>
<span class="comment-copy">This will be painfully slow for many/long lists in the <code>dict</code>.  You need another structure (maybe a <code>set</code> of all the tuples) if you plan to search for many positions.</span>
