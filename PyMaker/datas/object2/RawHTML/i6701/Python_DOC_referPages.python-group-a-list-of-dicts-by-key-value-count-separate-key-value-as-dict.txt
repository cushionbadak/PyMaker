<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/42591383/group-by-multiple-keys-and-summarize-average-multiple-values-of-a-list-of-dictio">Group by multiple keys and summarize/average multiple values of a list of dictionaries</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm trying to group up the name key values here as a key for a dict value, and count the source value as a key for said parent key, and have the count value with as its value. </p>
<pre><code>data = [
{'name':'Gill', 'source':'foo'},
{'name':'Gill', 'source':'foo'},
{'name':'Gill', 'source':'foo'},
{'name':'Gill', 'source':'bar'},
{'name':'Gill', 'source':'bar'},
{'name':'Gill', 'source':'bar'},
{'name':'Gill', 'source':'bar'},
{'name':'Gill', 'source':'bar'},
{'name':'Dave', 'source':'foo'},
{'name':'Dave', 'source':'foo'},
{'name':'Dave', 'source':'foo'},
{'name':'Dave', 'source':'foo'},
{'name':'Dave', 'source':'egg'},
{'name':'Dave', 'source':'egg'},
{'name':'Dave', 'source':'egg'},
{'name':'Dave', 'source':'egg'},
{'name':'Dave', 'source':'egg'},
{'name':'Dave', 'source':'egg'},
{'name':'Dave', 'source':'egg'}
]
</code></pre>
<p>How do I achieve the below output?</p>
<p><code>{'Gill': {'foo':3, 'bar':5}, 'Dave': {'foo':4, 'egg':7}}</code></p>
<p>I think it may be possible with a 1 liner...</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to <em>group</em> by names, then <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> to <em>count</em> the source categories belonging to each name:</p>
<pre><code>from collections import Counter
from itertools import groupby

f = lambda x: x['name']
dct = {k: Counter(d['source'] for d in g) for k, g in groupby(data, f)}
print(dct)
# {'Gill': Counter({'bar': 5, 'foo': 3}), 'Dave': Counter({'egg': 7, 'foo': 4})}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is obviously not a one-liner, but is simple and pretty straight forward. Would work for any number of values.</p>
<pre class="lang-py prettyprint-override"><code>results = {}
key = 'name'
for line in data:
    tracked_key = line[key]
    results.setdefault(tracked_key, {})
    for k, v in line.iteritems():
        if k == key:
            continue
        results[tracked_key].setdefault(v, 0)
        results[tracked_key][v] += 1
</code></pre>
</div>
<span class="comment-copy">Have you tried searching this site first?</span>
<span class="comment-copy">Of course, this assumes that the data is sorted by the <code>'name'</code> key.</span>
<span class="comment-copy">Thank you, this is great. However for my actual dataset, it has a lot more keys than 'name' and 'source' which I haven't mentioned here (I thought it'd be fine), I may need to strip it down to just the two. But the groupby(data, f) seems to create problems with it, is there a way to make this work if a 3rd key was introduced, but have it disregard said key? (I am being picky)</span>
<span class="comment-copy">@Slopax I don't see how a third key would create a problem if you don't actually need it.</span>
<span class="comment-copy">@MosesKoledoye I am mistaken, having just 2 keys as shown here in my example seems to produce different results, very strange. That's a headache for tomorrow!</span>
