<div class="post-text" itemprop="text">
<p>The title might not be the best description of what I'm trying to do but I'm not sure what to call this. I came across various seemingly related concepts with names like "decorators", "descriptors", and "metaclasses" but I don't know which of those approaches (if any) I should investigate further!</p>
<p>Given the following classes:</p>
<pre><code>class AnimalGreeter(object):

    def __init__(self, greeting):
        self.greeting = greeting

    def greet(self, animal):
        print(self.greeting + ", " + animal + "!")

class MyGreeter(AnimalGreeter):

    animals = ['dog', 'parrot']
</code></pre>
<p>I'd like to be able to use an instance of <code>MyGreeter</code> like this:</p>
<pre><code>greeter = MyGreeter("What's up")
greeter.parrot
# "What's up, parrot!"
</code></pre>
<p>Effectively, I would like it to function as if I had defined <code>MyGreeter</code> like this instead:</p>
<pre><code>class MyGreeter(AnimalGreeter):

    @property
    def dog(self):
        self.greet('dog')

    @property
    def parrot(self):
        self.greet('parrot')
</code></pre>
<p>In other words, I want to dynamically define methods (<code>dog()</code>, etc.) with names derived from an attribute (<code>animals</code>) of the class (<code>MyGreeter</code>).</p>
<p>What is the best way to do this?  Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p>An easy way to do this would just be to implement <code>__getattr__()</code>, e.g.:</p>
<pre><code>class MyGreeter(AnimalGreeter):
    animals = {'dog', 'parrot'}

    def __getattr__(self, animal):
        if animal in self.animals:
            return self.greet(animal)
        raise AttributeError("'{}' object unknown animal '{}'".format(type(self).__name__, animal))

&gt;&gt;&gt; greeter = MyGreeter("What's up")
&gt;&gt;&gt; greeter.parrot
What's up, parrot!
&gt;&gt;&gt; greeter.cat
...
AttributeError: 'MyGreeter' object unknown animal 'cat'
</code></pre>
</div>
<span class="comment-copy">Just implement <code>__getattr__(self, animal)</code>.</span>
<span class="comment-copy">Cant help here, but I'm interested in your use case. Why do you need this behavior?</span>
<span class="comment-copy">@FabienP, In my case <code>AnimalGreeter</code> is a Django model and <code>MyGreeter</code> is a custom mixin that handles images with configurable filenames.  I want to have access to the image urls in Django's templates but Django's templating system does not permit passing arguments to instance methods. So I can't do the equivalent of <code>model.image_url('large')</code> in the template.  But I can access instance properties in the templates, e.g., <code>model.large_image_url</code>.</span>
<span class="comment-copy">@tino: nice to know, thanks for the explanation!</span>
<span class="comment-copy">Thanks! This was one of the suggestions I came across but was unsure if I should be concerned about overhead. <code>AnimalGreeter</code> has a lot of other attributes that are accessed frequently. Does this get executed every time I access any instance attribute?</span>
<span class="comment-copy">@tino No, <code>__getattr__</code> is only called if you access an attribute that "doesn't exist", i.e. it's called when an AttributeError would be thrown. <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer">Read the docs.</a></span>
<span class="comment-copy">@Rawing, Ah, that makes perfect sense. Thanks for the link and the explanation!</span>
