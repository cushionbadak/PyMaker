<div class="post-text" itemprop="text">
<p>Before this is flagged as a duplicate, I know this <a href="https://stackoverflow.com/questions/21812092/python-property-returning-property-object">question has been answered</a> before, but the solutions provided there don't seem to apply to my case. I'm trying to programmatically set class properties. I know I can use <code>property</code> for that, so I thought about doing this:</p>
<pre><code>class Foo:
    def __init__(self, x):
        self._x = x
        def getx(): return self._x
        def setx(y): self._x = y
        self.x = property(fget=getx, fset=setx)
</code></pre>
<p>However, when I run this interactively, I get:</p>
<pre><code>&gt;&gt;&gt; f = Foo(42)
&gt;&gt;&gt; f.x
&lt;property object at 0x0000000&gt;
&gt;&gt;&gt; f._x
42
&gt;&gt;&gt; f.x = 1
&gt;&gt;&gt; f.x
1
</code></pre>
<p>Is there any way to solve this?</p>
<p><em>Edit:</em></p>
<p>I feel I may have left out too much, so here's what I am actually trying to reach. I have a class with a class variable called <code>config</code>, which contains configuration values to set as properties. The class should be subclassed to implement the <code>config</code> variable:</p>
<pre><code>class _Base:
    config = ()

    def __init__(self, obj, **kwargs):
        self._obj = obj()
        for kwarg in kwargs:
            # Whatever magic happens here to make these properties

# Sample implementation
class Bar(_Base):
     config = (
         "x",
         "y"
     )

     def __init__(self, obj, x, y):
         super().__init__(obj, x=x, y=y)
</code></pre>
<p>Which now allows for manipulation:</p>
<pre><code>&gt;&gt;&gt; b = Bar(x=3, y=4)
&gt;&gt;&gt; b.x
3
&gt;&gt;&gt; # Etc.
</code></pre>
<p>I'm trying to keep this as DRY as possible because I have to subclass <code>_Base</code> a lot.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>property</code> objects are <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptors</a>, and descriptors are only invoked when defined on the class or metaclass. You can't put them directly on an instance; the <code>__getattribute__</code> implementation for classes simply don't invoke the binding behaviour needed.</p>
<p>You need to put the property on the class, not on each instance:</p>
<pre><code>class Foo:
    def __init__(self, x):
        self._x = x

    @property
    def x(self): return self._x

    @x.setter
    def x(self, y): self._x = y
</code></pre>
<p>If you have to have a property that only works on some instances, you'll have to alter your getter and setter methods to vary behaviour (like raise an <code>AttributeError</code> for when the state of the instance is such that the attribute should 'not exist').</p>
<pre><code>class Bar:
    def __init__(self, has_x_attribute=False):
        self._has_x_attribute = has_x_attribute
        self._x = None

    @property
    def x(self):
        if not self._has_x_attribute:
            raise AttributeError('x')
        return self._x

    @x.setter
    def x(self, y):
        if not self._has_x_attribute:
            raise AttributeError('x')
        self._x = y
</code></pre>
<p>The <code>property</code> object still exists and is bound, but behaves as if the attribute does not exist when a flag is set to false.</p>
</div>
<span class="comment-copy">You're not setting it on the class, you're setting it on the object. Descriptors don't work like that.</span>
<span class="comment-copy">I just now realized how stupid my attempt was. Thanks.</span>
