<div class="post-text" itemprop="text">
<p>I have a Python script that does multiple <code>os.system</code> calls. Asserting against the series of them as a list of strings will be easy (and relatively elegant).</p>
<p>What isn't so easy is intercepting (and blocking) the actual calls. In the script in question, I could abstract os.system in the SUT (*) like so:</p>
<pre><code>os_system = None

def main():
    return do_the_thing(os.system)

def do_the_thing(os_sys):
    global os_system
    os_system = os_sys

    # all other function should use os_system instead of os.system
</code></pre>
<p>My test invokes <code>my_script.do_the_thing()</code> instead of <code>my_script.main()</code> of course (leaving a tiny amount of untested code).</p>
<p><strong>Alternate option:</strong> I could leave the SUT untouched and replace <code>os.system</code> globally in the test method before invoking <code>main()</code> in the SUT.</p>
<p>That leaves me with new problems in that that's a global and lasting change. Fine, so I'd use a <code>try/finally</code> in the same test method, and replace the original before leaving the test method.  That'd work whether the test method passes or fails.</p>
<p>Is there a safe and <strong>elegant</strong> setup/teardown centric way of doing this for PyTest, though?</p>
<p>Additional complications: I want to do the same for stdout and stderr.  Yes, it really is a <code>main()</code> script that I am testing.</p>
<ul>
<li>SUT == System Under Test</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>The Python 3 (&gt;= 3.3) standard library has a <a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="nofollow noreferrer">great tutorial about Mock</a> in the official documentation. For Python 2, you  can use the backported library: <a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer">Mock</a> on PyPi.</p>
<p>Here is a sample usage. Say you want to mock the call to <code>os.system</code> in this function:</p>
<pre><code>import os


def my_function(src_dir):
    os.system('ls ' + src_dir)
</code></pre>
<p>To do that, you can use the <code>unittest.mock.patch</code> decorator, like this:</p>
<pre><code>import unittest.mock


@unittest.mock.patch('os.system')
def test_my_function(os_system):
    # type: (unittest.mock.Mock) -&gt; None
    my_function("/path/to/dir")
    os_system.assert_called_once_with('ls /path/to/dir')
</code></pre>
<p>This test function will patch the <code>os.system</code> call during its execution. <code>os.system</code> is restored at the end.</p>
<p>Then, there are several "assert" method to check the calls, the parameters, and the results. You can also check that an exception is raised in certain circonstances.</p>
</div>
<span class="comment-copy">Great. For PyTest and Python2 it is just @mock.patch('os.system') and I can confirm works quite well.</span>
