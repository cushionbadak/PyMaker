<div class="post-text" itemprop="text">
<p>Let: <code>a = 5</code>, <code>b = 10</code>, and <code>hello_world = 'Hello World'</code>.</p>
<p>To my understanding: Python allows us to utilize assignment operators to prevent us from having to repeat the left operand. For example, <code>a = a + b</code> can be rewritten as <code>a += b</code> where both would return <code>15</code>.</p>
<p>So with some Python objects it could be somewhat similar, depending on what the method being called returns.</p>
<p>With a string, <code>str</code>, or this case our string <code>hello_world</code> there are a multitude of methods for you to use to modify it in some way such as <code>hello_world.lower()</code> and sometimes I would call it to assign the variable the result of the method within. For example, <code>hello_world = hello_world.lower()</code> could be rewritten as something like <code>hello_world .= lower()</code> where both would return <code>hello world</code>.</p>
<p>Is there anything like this available in Python? Is this completely absurd or confusing to you? Curious what people think of this and/or if it exists already.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there anything like this available in Python?</p>
</blockquote>
<p>No</p>
<blockquote>
<p>Is this completely absurd or confusing to you?</p>
</blockquote>
<p>No.  That said, it would be somewhat different from the existing augmented assignment operators (like <code>+=</code>, <code>*=</code>, etc.).  For those operators, you can define a special magic method (<code>__iadd__</code>, <code>__imul__</code>, etc.) to implement them.  A key feature of these is that, because a separate method is called, they may update the object in place.  For instance, if <code>x</code> is a list, then <code>x += [1, 2, 3]</code> will actually mutate the object <code>x</code> rather than creating a new list.</p>
<p>For your proposed <code>.=</code> operator, it's not clear how this could work.  If there were an <code>__imeth__</code> operator for "augmented method assignment", what would it take as arguments?  If it took the name of the method as an argument, you would need a giant if-block inside <code>__imeth__</code> to decide what to do for various methods (i.e., <code>if method == 'lower'</code> to handle <code>.lower()</code> and so on).  If it didn't take the name of the method as an argument, how would it know what method is being called?</p>
<p>More importantly, though, a fundamental feature of the existing operators is that they accept an <em>expression</em> as their operands.  With your proposed <code>.=</code>, what would happen if you did <code>x .= 3</code>?  Or <code>x .= (foo+bar).blah()/7</code>?  Or even <code>x .= lower</code> (with no parentheses)?  It would seem that <code>.=</code> would require its right-hand argument to be <em>syntactically</em> restricted to just a single function call (which would be interpreted as a method call).  That is quite different from any existing Python operator.</p>
<p>It seems the only way to handle all of that would be to reduce the scope of the proposal so that it indeed only accepts a single function call on the right, and make it non-customizable, so that <code>x .= method(...)</code> is pure syntactic sugar for <code>x = x.method(...)</code>.  But, as described above, that is much weaker than what current augmented assignment allows, so I don't think it would be a big win.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are thinking about <a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow noreferrer">augmented assignments</a>, these are <em>statements</em>, and are not extensible. </p>
<p>Augmented assignments only cover <em>binary operators</em> (specifically the <a href="https://docs.python.org/3/reference/expressions.html#the-power-operator" rel="nofollow noreferrer">power</a>, <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer">binary arithmetic</a>, <a href="https://docs.python.org/3/reference/expressions.html#shifting-operations" rel="nofollow noreferrer">shifting</a> and <a href="https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations" rel="nofollow noreferrer">binary bitwise</a> operators). The <a href="https://docs.python.org/3/reference/expressions.html#attribute-references" rel="nofollow noreferrer">attribute reference syntax</a> is not an <em>operator</em>, binary or otherwise. As such there is no 'attribute-operator' augmented assignment.</p>
<p>Note that I didn't cover the <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer"><em>calling</em> syntax</a>; you are mostly talking about attributes; that you also call <code>str.lower()</code> is separate from the attribute lookup.</p>
<p>If you think this a feature sorely missed, I suggest you bring it to the <a href="https://mail.python.org/mailman/listinfo/python-ideas" rel="nofollow noreferrer">Python Ideas mailinglist</a>, where prospective new language features are discussed.</p>
<p>Take into account that the <em>point</em> of the augmented assignments is that they provide an opportunity to optimise in-place updates; they are not just syntactic sugar. For lists, for example, <code>listobj += iterable_of_values</code> is not the same thing as <code>listobj = listobj + iterable_of_values</code>, it actually executes <code>listobj.extend(iterable_of_values)</code> (and binds the name <code>listobj</code> back to <code>listobj</code>, which can lead to <a href="https://stackoverflow.com/questions/2347265/why-does-behave-unexpectedly-on-lists">suprising behaviour</a>. For attributes access, there is no such oppertunity; attributes return the referenced name, they <em>can't</em> update something in-place, unless you start abusing the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>, which hardly lends itself to intuitive augmentation.</p>
<p>You may want to read the <a href="https://www.python.org/dev/peps/pep-0203/" rel="nofollow noreferrer">original Python Enhancement Proposal</a> that introduced augmented assignments to the language; the rationale section especially would be required reading before you make this a proposal.</p>
</div>
<span class="comment-copy">no, that's not possible</span>
<span class="comment-copy">@ingvar explanation?</span>
<span class="comment-copy">Applying an operation and an assignment via <code>+=</code> is a <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="nofollow noreferrer">Syntactic sugar</a>. Numbers and strings behave differently and the <code>+</code> operator gets different meanings when applied in different contexts.</span>
<span class="comment-copy">@alfasin: it is much more than syntactic sugar. It is also an optimisation opportunity.</span>
<span class="comment-copy"><code>__igetattr__</code>?</span>
<span class="comment-copy">Great explanation, thank you.</span>
