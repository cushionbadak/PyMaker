<div class="post-text" itemprop="text">
<p>suppose I have a program called <code>myprog</code> that takes some filename as input, and I also want use command line args to set the open mode for each file.
For example</p>
<pre><code>myprog --input a.txt --mode r --input b.txt --input c.txt --mode a
</code></pre>
<p>Which means open file <code>a.txt</code> with mode <code>r</code>, file <code>b.txt</code> doesn't have a --mode arg, so open it with default mode <code>r</code>, and for the file <code>c.txt</code>, use the <code>a</code> mode to open it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a tricky problem because argparse doesn't give you any way to know which <code>--input</code> a particular <code>--mode</code> is associated with.  You <em>could</em> change the structure of the command so that the filename and the mode are separated by a sentinel character:</p>
<pre><code>myprog --input a.txt:r --input b.txt --input c.txt:a
</code></pre>
<p>Obviously this assumes you don't have files whose names end in <code>:&lt;mode&gt;</code> where <code>&lt;mode&gt;</code> is any acceptable file mode.  If this is an OK structure, then this becomes as simple as writing a custom action or type to parse the string and return a suitable object. e.g.</p>
<pre><code>def parse_fstr(s):
    filename, _, mode = s.rpartition(':')
    return (filename, mode or 'r')
</code></pre>
<p>Other solutions could involve using <code>nargs='*'</code> and then parsing out the list of arguments passed.</p>
<hr/>
<p>Finally, to implement what you've <em>actually</em> asked for without too much difficulty, we need to make an assumption.  The assumption is that <code>argparse</code> will parse items from left to right.  Given the functionality of the library, that is the only reasonable choice for implementation as far as I can tell...</p>
<p>Given that implementation, we can do this with a custom type and a custom <a href="https://docs.python.org/3/library/argparse.html#argparse.Action" rel="nofollow noreferrer">Action</a>.  The type is simply a structure to keep a <code>filename</code> and a <code>mode</code> grouped together.  We'll use <code>argparse</code> to construct a new instance of this type every time we hit an <code>--input</code> and append it to a list (This is supported out of the box by <code>argparse</code>).  Next, we'll write a custom action to update the <code>mode</code> of the last "file struct" in the list every time we encouter a <code>--mode</code> argument.</p>
<pre><code>import argparse


class FileInfo(object):
    def __init__(self, name, mode='r'):
        self.name = name
        self.mode = mode

    def __repr__(self):
        return 'FileInfo(name={!r}, mode={!r})'.format(self.name, self.mode)


class UpdateMode(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        try:
            last_file_info = namespace.input[-1]
        except IndexError:
            # No file-info added yet.  Error.
            parser.error('{} must come after an --input'.format(option_string or '--mode'))

        last_file_info.mode = values


parser = argparse.ArgumentParser()
parser.add_argument('--input', action='append', type=FileInfo)
parser.add_argument('--mode', action=UpdateMode)
print(parser.parse_args())
</code></pre>
<p>I've chosen to throw an error if <code>--mode</code> shows up before any <code>--input</code>, but if 2 <code>--mode</code> follow an <code>--input</code>, I'm just overwriting the previous value.  If you wanted to more error checking, it'd be a simple matter of writing a little more code in the <code>FileInfo</code> class to make sure that no mode has already been set when you go to update the mode.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the command line is like this:</p>
<pre><code>myprog --input a.txt --mode r --input c.txt --mode a --input b.txt
</code></pre>
<p>It's ok to add some code like this:</p>
<pre><code>import argparse

parser = argparser.ArgumentParser()
parser.add_argument('--input', action='append')
parser.add_argument('--mode', action='append')
args = parser.parse_args()
args_dict = vars(args)
</code></pre>
<p>Then you can parse the args object, <em>args_dict</em> variable.  The value is like this:</p>
<pre><code>$ python test.py --input test.txt --mode w --input test3.txt --input test2.txt --mode a
{'mode': ['w', 'a'], 'input': ['test.txt', 'test3.txt', 'test2.txt']}
</code></pre>
<p>You can iterate both <em>'input'</em> key and <em>'mode'</em> key in the <em>args_dict</em> variable, for the remain of input list(it's 'test2.txt' here), you can open it with 'r' mode.</p>
<p>But if your command line have to write something like:</p>
<pre><code>myprog --input a.txt --mode r --input b.txt --input c.txt --mode a
</code></pre>
<p>I don't think it's easy to parse the b.txt with 'r' mode, because argparse don't know which mode is bind to the relative input...</p>
<hr/>
<p>Get inspiration from @mgilson 's comment and answer, I have found another way to define Action subclass, and make the <em>'mode'</em> input useful.</p>
<pre><code>class ExtendReadOnlyAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        inputs = namespace.input
        modes = getattr(namespace, self.dest)
        if modes is None:
            modes = []
        modes.extend(['r' for i in range(len(inputs) - len(modes))])
        modes[-1] = values
        setattr(namespace, self.dest, modes)
</code></pre>
<p>And the client code can be something like this:</p>
<pre><code>import argparse

parser = argparser.ArgumentParser()
parser.add_argument('--input', action='append')
parser.add_argument('--mode', action=ExtendReadOnlyAction)
args = parser.parse_args()
args_dict = vars(args)
</code></pre>
<p>Then we can parse the args object, <em>args_dict</em> variable more easier.  If the command line is like this: </p>
<pre><code>$ python test.py --input test.txt --mode w --input test2.txt --input test3.txt --mode a
</code></pre>
<p>The result will be:</p>
<pre><code>{'mode': ['w', 'r', 'a'], 'input': ['test.txt', 'test2.txt', 'test3.txt']}
</code></pre>
<p>In the other special way, if the command line is like this:</p>
<pre><code>$ python test.py --input test.txt --mode w --input test2.txt --input test3.txt --input test4.txt
</code></pre>
<p>The result will be:</p>
<pre><code>{'input': ['test.txt', 'test2.txt', 'test3.txt', 'test4.txt'], 'mode': ['w']}
</code></pre>
<p>And then you can parse the dict more easier, the 'test2.txt ~ test4.txt' in the input argument will have the default 'r' mode :)</p>
</div>
<span class="comment-copy">If you are using pycharm you can specify command line arguments using settings.</span>
<span class="comment-copy">So, what is the question?</span>
<span class="comment-copy">Do you guarantee that for every <code>--input</code>, there is a corresponding <code>--mode</code>?  If so, then you could just use the <code>'append'</code> action on both <code>input</code> and <code>mode</code> and then <code>zip</code> the lists.  If not (which looks like the case based on your example), then things get a lot more difficult unless you're willing to restructure the commandline -- e.g. <code>myprog --input a.text r --input b.txt --input c.txt a ...</code></span>
<span class="comment-copy">Yes, <code>parse_args</code> iterates through <code>argv</code> (<code>sys.argv[1:]</code>), alternatively handling positionals and optionals.  The  respective <code>nargs</code> control how many strings are given to each <code>Action</code>.  So your custom Action classes should  work as advertised.</span>
<span class="comment-copy">This was my first thought too, but after thinking about it a little more, it's definitely possible (and surprisingly not even that hard).  Since <code>argparse</code> provides hooks to write your own actions, you can code up a state-machine via custom actions without too much difficulty.  See my answer :-)</span>
<span class="comment-copy">@mgilson Very appreciate for your comment :)It's clearly and good point to solve this..But it make the <i>'mode'</i> value of parse_args result useless.  But that's not a very big problem I think.</span>
