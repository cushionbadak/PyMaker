<div class="post-text" itemprop="text">
<p>Why does this not work (values are not swapped):</p>
<pre><code>lol = ["test","test2"]
lol[lol.index("test")], lol[lol.index("test2")] = lol[lol.index("test2")], lol[lol.index("test")]
</code></pre>
<p>But this works (values are swapped):</p>
<pre><code>i1 = lol.index("test")
i2 = lol.index("test2")
lol[i1], lol[i2] = lol[i2], lol[i1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason why the first example is not working is because you are calling <code>.index()</code> multiple times, and after each time, the values in the list are changing, so the indices found in the code are not representative of the actual locations of the elements. The second example works because you have stored the first indices in two variables, and use both in the swap.</p>
<p>Overview of first example:</p>
<pre><code>lol[lol.index("test")], lol[lol.index("test2")] = lol[lol.index("test2")], lol[lol.index("test")] 
</code></pre>
<p>First part: <code>lol[lol.index("test")]</code> stores <code>0</code></p>
<p>Second part: <code>lol[lol.index("test2")]</code> stores <code>1</code></p>
<p>Third part: <code>lol[lol.index("test2")]</code> still stores <code>1</code></p>
<p>This is when it gets interesting. The forth part of the example, <code>lol[lol.index("test")]</code>, finds the index of <code>test</code>, however, <code>test</code> was assigned <code>1</code> from the third segment of the code. Therefore, <code>lol[lol.index("test")]</code> is <code>1</code>, not <code>0</code>. Consequently, <code>lol[lol.index("test2")]</code> still stores <code>1</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Explanation</strong></p>
<p>It all comes down to understand properly how the <a href="https://docs.python.org/3/reference/expressions.html#evaluation-order" rel="nofollow noreferrer">evaluation order</a> works here, in particular the case <code>expr3, expr4 = expr1, expr2</code>.</p>
<p>If we step through the statement <code>lol[lol.index("test")], lol[lol.index("test2")] = lol[lol.index("test2")], lol[lol.index("test")]</code> we'd get something like this:</p>
<pre><code>r1=evaluate(expr1) --&gt; "test2"
r2=evaluate(expr2) --&gt; "test"
evaluate(expr3)=r1 --&gt; lol[0] = "test2" --&gt; lol = ["test2","test2"]
evaluate(expr4)=r2 --&gt; lol[0] = "test"  --&gt; lol = ["test", "test2"]
</code></pre>
<p>The other snippet is trivial:</p>
<pre><code>i1 = lol.index("test")
i2 = lol.index("test2")
lol[i1], lol[i2] = lol[i2], lol[i1]

it1) i1 = 0
it2) i2 = 1
it3) lol[i1], lol[i2] = "test2", lol[i1]
it4) lol[i1], lol[i2] = "test2", "test"
it5) lol[i1] = "test2"
it6) lol[i2] = "test"
</code></pre>
<p><strong>Oneliner alternatives</strong></p>
<p>Something like these ones should do:</p>
<pre><code>lol = lol[lol.index("test2")], lol[lol.index("test")]

lol[0], lol[1] = lol[1], lol[0]

lol[0], lol[1] = lol[lol.index("test2")], lol[lol.index("test")]
</code></pre>
<p><strong>Aditional notes</strong></p>
<p>If you really want to know more about how these functions are really interpreted, a very good way to do so is by using the module <a href="https://docs.python.org/2/library/dis.html" rel="nofollow noreferrer">dis</a>, for example:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def f():
...    lst[lst.index(str1)], lst[lst.index(str2)] = lst[lst.index(str2)], lst[lst.index(str1)]
...
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_GLOBAL              0 (lst)
              3 LOAD_GLOBAL              0 (lst)
              6 LOAD_ATTR                1 (index)
              9 LOAD_GLOBAL              2 (str2)
             12 CALL_FUNCTION            1
             15 BINARY_SUBSCR
             16 LOAD_GLOBAL              0 (lst)
             19 LOAD_GLOBAL              0 (lst)
             22 LOAD_ATTR                1 (index)
             25 LOAD_GLOBAL              3 (str1)
             28 CALL_FUNCTION            1
             31 BINARY_SUBSCR
             32 ROT_TWO
             33 LOAD_GLOBAL              0 (lst)
             36 LOAD_GLOBAL              0 (lst)
             39 LOAD_ATTR                1 (index)
             42 LOAD_GLOBAL              3 (str1)
             45 CALL_FUNCTION            1
             48 STORE_SUBSCR
             49 LOAD_GLOBAL              0 (lst)
             52 LOAD_GLOBAL              0 (lst)
             55 LOAD_ATTR                1 (index)
             58 LOAD_GLOBAL              2 (str2)
             61 CALL_FUNCTION            1
             64 STORE_SUBSCR
             65 LOAD_CONST               0 (None)
             68 RETURN_VALUE
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>X,Y="test","test2"</code> will get handled as <code>X="test";Y="test2"</code></p>
<pre><code>lol = ["test","test2"]
lol[lol.index("test")], lol[lol.index("test2")] = lol[lol.index("test2")], lol[lol.index("test")]
</code></pre>
<p>First the right handed side will get evaluated, so you get:</p>
<pre><code>lol[lol.index("test")], lol[lol.index("test2")] = "test2", "test"
</code></pre>
<p>which will have the same effect as the following lines:</p>
<pre><code>lol[lol.index("test")]="test2"
#   returns 0
# lol==["test2","test2"]
lol[lol.index("test2")]="test"
#  returns 0
</code></pre>
</div>
<span class="comment-copy">This gives the wrong impression that in a statement of <code>A,B=C,D</code> the evaluation order is <b>1.</b> A ; <b>2.</b> B ; <b>3.</b> C ; <b>4.</b> A=C ; <b>5.</b> D ; <b>6.</b> B=D. While the order of evaluation should be <b>1.</b> C ; <b>2.</b> D ; <b>3.</b> A ; <b>4.</b> B ; <b>5.</b> A=C ; <b>6.</b> B=D</span>
<span class="comment-copy">Although it is obvious can you state that RHS is evaluated first. As some might assume that the statements are split first and then evaluated later.</span>
<span class="comment-copy">@bulbus agreed, in fact I think the first line is rather misleading as it implies the order for these 2 operations is the same, which is not true of course</span>
