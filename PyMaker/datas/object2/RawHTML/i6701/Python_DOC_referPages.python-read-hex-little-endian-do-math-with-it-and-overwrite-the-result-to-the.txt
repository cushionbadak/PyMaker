<div class="post-text" itemprop="text">
<p>I'm new in programming and i need help
i have a hex file like this:</p>
<p>43 52 53 00 00 00 00 00 00 00 01 01 30 00 00 00</p>
<p>10 87 01 00 13 00 00 00 10 00 00 00 00 00 00 00</p>
<p>40 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
<p>i need the python code that let me read the little endian "10 87 01" do math , overwrite the result in the exact offset and save it</p>
<p>like  10 87 01 + 40 01 = 50 88 01</p>
<p>43 52 53 00 00 00 00 00 00 00 01 01 30 00 00 00 </p>
<p>50 88 01 00 13 00 00 00 10 00 00 00 00 00 00 00 </p>
<p>40 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>
<p>hope its clear</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use the struct library to handle little endian as shown in the doc at <a href="https://docs.python.org/3/library/struct.html#struct.pack_into" rel="nofollow noreferrer">https://docs.python.org/3/library/struct.html#struct.pack_into</a> </p>
<p>For your specific task, I don't know if I understood correctly, because you didn't specify what kind of data do you have in your binary file... let's assume we have signed 32 bit integers, my code would be something like this:</p>
<pre><code>import struct

# we are assuming you have 32 bit integers on your file
block_size = 4
filename = "prova.bin"


# function to do "some math... :)"
def do_some_math(my_hex_value):
    return my_hex_value + 1


# open and read the whole file
with open(filename, "r+b") as f:
    my_byte = f.read(block_size)
    while(len(my_byte) == block_size):

        # unpack the 4 bytes value read from file
        # "&lt;" stands for "little endian"
        # "i" stands for "integer"
        # more info on the struct library in the official doc
        my_hex_value = struct.unpack_from("&lt;i", my_byte)[0]

        print("Before math = " + str(my_hex_value))

        # let's do some math
        my_hex_value = do_some_math(my_hex_value)

        print("After math = " + str(my_hex_value))

        # let's repack the hex back
        my_byte = struct.pack("&lt;i", my_hex_value)

        # let's reposition the file pointer so as to overwrite
        # the bytes we have previously read 
        f.seek(f.tell() - block_size)

        # let's override the old bytes
        f.write(my_byte)

        # let's read another chunk to repeat till the eof
        my_byte = f.read(block_size)
</code></pre>
<p>Hope this helps<br/>
All the best<br/>
Dave</p>
</div>
<div class="post-text" itemprop="text">
<p>assuming you have your math function working to calculate the new pattern, you could use a function like this:</p>
<pre><code>def replace_pattern(old_pattern, new_pattern, occurrence):

with open('input_file.txt','r') as myfile:
    myline=""
    for line in myfile:
        myline += line

if occurrence == 0: # assume 0 is used to indicate all occurrences must be replaced
    if myline.find(old_pattern) == -1:
        print('pattern not found, exit')
        return
    else:
        newline = myline.replace(old_pattern, new_pattern)
else: #a particular occurrence has to be updated
    idx = 0
    offset=0
    nbmatch = 0
    while idx != -1:
        idx = myline.find(old_pattern, offset)
        if idx != -1:
            offset = idx+1
            nbmatch += 1
        if nbmatch == occurrence:
            # the index of the target occurrence has been reached
            break

    if nbmatch == 0:
        print('problem, at least one occurrence expected')
        return
    elif nbmatch == 1:
        print('problem, more than one occurrence expected, replace anyway')
        newline = myline.replace(old_pattern, new_pattern)
    else:
        # further processing on a part of the line
        sameline = myline[:idx]
        diffline = myline[idx:]
        # work on diffline substring
        diffline = diffline.replace(old_pattern,new_pattern,1)

        # rebuild line
        newline = sameline+diffline

with open('input_file.txt','w') as myfile:
    myfile.write(newline)
</code></pre>
<p>I may be not optimized but it should work as expected</p>
</div>
<span class="comment-copy">unfortunally its not what i m searching for</span>
<span class="comment-copy">your code do math every 4 byte of code , but i need to update a specific offset (not every single one) thanks anyway but it need some review i think</span>
<span class="comment-copy">Yes, it was just an example... you should adapt it to your needs. I thought that the "difficult" part could be the reading of the little endian hex binary file and I pointed out a possible solution for that...</span>
<span class="comment-copy">how to adapt it to edit a specified offset only? as i sayed  i m new in programming</span>
<span class="comment-copy">your code has some issue with the return</span>
<span class="comment-copy">which one ? have you got a sample input file that I could try ? For my testing I just repeated the pattern in your question. It may happen that the input reading provide a \n in the middle of the pattern, which is not handled by this solution yet ...</span>
