<div class="post-text" itemprop="text">
<p>I am new to Python and have a problem with lists. 
Namely, I'm asking user to fill 2 lists one for cars and one for the production year. Then I append both list to one. </p>
<pre><code>enter code here
carYear = []
carYear.append(cars)
carYear.append(year)
</code></pre>
<p>I have 2 questions: 
a) is there an elegant way to print those lists, so the element car and year are listed close to each other (for ex: Porsche, 1998)? 
b) Is it possible to access first list (cars) from carYear list and print it? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can zip the two lists together like so:</p>
<pre><code>cars = ["car1", "car2", "car3"]
years = ["2012", "2015", "2017"]
for c, y in zip(cars, years):
    print( "{0}, {1}".format(c, y) )
</code></pre>
<p>For each iteration you can print c and y. Which is the name and the year of the car.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest changing your data structure to use a <code>dict</code> instead of parallel <code>list</code> objects. Dictionaries (<code>dict</code>) are sometimes referred to as maps or associative arrays. They allow you to access data by associating it with a key value. The following example assumes that the elements of <code>cars</code> will serve as keys.</p>
<p>You can create a dictionary from your lists using <code>zip</code>, which transforms the given sequences into tuples.</p>
<pre><code>&gt;&gt;&gt; cars = ['civic', 'corvette', 'prius']
&gt;&gt;&gt; years = ['2009', '1979', '2017']
&gt;&gt;&gt; zip(cars, years)
[('civic', '2009'), ('corvette', '1979'), ('prius', '2017')]
</code></pre>
<p>A <code>list</code> of <code>tuple</code>s can be used to initialize a <code>dict</code> where first and second elements of each tuple are the key and value, respectively.</p>
<pre><code>&gt;&gt;&gt; carYear = dict(zip(cars, years))
&gt;&gt;&gt; carYear
{'corvette': '1979', 'prius': '2017', 'civic': '2009'}
</code></pre>
<p>Now, you can do this:</p>
<pre><code>&gt;&gt;&gt; carYear['corvette']
'1979'
</code></pre>
<p>For printing the contents of <code>dict</code> objects, I like to use the <code>.items()</code> method which breaks things apart into tuples again. Observe:</p>
<pre><code>for car, year in sorted(carYear.items()):
    print('Car: {} =&gt; {}'.format(car, year))
</code></pre>
<p>I am using <code>sorted</code> to ensure that output is consistent. Due to the implementation of <code>dict</code> objects, <code>.items()</code> will return data in random order each time you run. <code>sorted</code> addresses this problem, resulting in consistent output.</p>
<p>For more information about Python dictionaries see the Python docs here:
<a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#dictionaries</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can try <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">namedtuple</a> (It should be faster than <code>dict</code>) e.g:</p>
<pre class="lang-py prettyprint-override"><code>from collections import namedtuple


cars = []
Car = namedtuple('Car', ['type', 'year'])
cars.append(Car('Porsche', '1998'))

for car in cars:
    print('{0}, {1}'.format(car.type, car.year))
</code></pre>
<p>But be aware, namedtuples are immutable. i.e. you cannot do <code>car.type = 'BMW'</code></p>
</div>
<span class="comment-copy">Thanks for help!</span>
<span class="comment-copy">@Ewa you are welcome. If you have 50 min, you can have a look at Raymond Hettinger(core python dev) talk:  <a href="https://www.youtube.com/watch?v=OSGv2VnC0go&amp;t=799s" rel="nofollow noreferrer">youtube.com/watch?v=OSGv2VnC0go&amp;t=799s</a>   He talks about izip at 21:50. Izip is better then zip (but you need to import itertools. That is why Idid not talk about it in my answer).</span>
