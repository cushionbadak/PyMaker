<div class="post-text" itemprop="text">
<p>I want to generate one random combination out of all possible <a href="https://docs.python.org/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer"><code>combinations_with_replacement</code></a>. The tricky bit is that I want each of the possible outcomes to have the same probability without needing to generate (not even implicit) all the possible outcomes.</p>
<p>For example:</p>
<pre><code>import itertools
import random

random.choice(list(itertools.combinations_with_replacement(range(4), 2)))
</code></pre>
<p>That approach is way too slow (and memory expensive) because it needs to create all possible combinations whereas I only want one. </p>
<p>It's not so bad if I determine how many <code>combinations_with_replacement</code> there will be and use <code>random.randrange</code> together with <code>next</code> and <code>itertools.islice</code> on the <code>itertools.combinations_with_replacement</code>. That doesn't need to generate all possible combinations (except in the worst-case). But it's still too slow.</p>
<p>On the other hand the <a href="https://docs.python.org/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe mentioned in the <code>itertools</code> documentation</a> is fast but not each combination has the same probability.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, I'm in a bit of a dilemma, because I've found an algorithm that works, but I don't know why. So do what you want of if, maybe some mathematician in the room can work out the probabilities, but it does empirically work. The idea is to pick one element at a time, increasing the probability of the selected elements. I suspect the reasoning must be similar to that of <a href="https://en.wikipedia.org/wiki/Reservoir_sampling" rel="nofollow noreferrer">reservoir sampling</a>, but I didn't work it out.</p>
<pre><code>from random import choice
from itertools import combinations_with_replacement

population = ["A", "B", "C", "D"]
k = 3

def random_comb(population, k):
    idx = []
    indices = list(range(len(population)))
    for _ in range(k):
        idx.append(choice(indices))
        indices.append(idx[-1])
    return tuple(population[i] for i in sorted(idx))

combs = list(combinations_with_replacement(population, k))
counts = {c: 0 for c in combs}

for _ in range(100000):
    counts[random_comb(population, k)] += 1

for comb, count in sorted(counts.items()):
    print("".join(comb), count)
</code></pre>
<p>The output is the number of times each possibility has appeared after 100,000 runs:</p>
<pre><code>AAA 4913
AAB 4917
AAC 5132
AAD 4966
ABB 5027
ABC 4956
ABD 4959
ACC 5022
ACD 5088
ADD 4985
BBB 5060
BBC 5070
BBD 5056
BCC 4897
BCD 5049
BDD 5059
CCC 5024
CCD 5032
CDD 4859
DDD 4929
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you did not provide any estimates for the parameters in your task: here <strong>some approach for small k</strong>.</p>
<p>The basic idea: <strong>acceptance-rejection sampling with a full-restart if some partial-solution is infeasible</strong> (according to the sorted-characteristic). Of course the probability of not restarting is decreasing with <code>k!</code> (<a href="https://en.wikipedia.org/wiki/Bogosort" rel="nofollow noreferrer">compare with bogosort</a>). There is no extra memory used.</p>
<p>The following code compares this approach with the original, a wrong naive one, and a wrong one based on the other (now deleted) answer (which had an upvote). The code is pretty much garbage and just for demo-purporses:</p>
<p>Code:</p>
<pre><code>import itertools
import random
from time import perf_counter
from collections import deque
n = 30
k = 4
its = 100000  # monte-carlo analysis -&gt; will take some time with these values!

sample_space = itertools.combinations_with_replacement(range(n), k)
flat_map = {}  # for easier counting / analysis
for ind, i in enumerate(sample_space):
    flat_map[i] = ind

def a(n, k):
    """ Original slow approach """
    return random.choice(list(itertools.combinations_with_replacement(range(n), k)))

def b(n, k):
    """ Naive attempt -&gt; non-uniform """
    chosen = [random.choice(list(range(n))) for i in range(k)]
    return tuple(sorted(chosen))

def c(population, k):
  """ jdehesa solution (hopefully not broken by my modifications) """
  choices = [i for i in range(population) for _ in range(k)]
  return tuple([i for i in sorted(random.sample(choices, k))])

def d(n, k):
    """ Acceptance-rejection sampling with restart using python's list """
    chosen = []
    while True:
        if len(chosen) == k:
            return tuple(chosen)
        else:
            new_element = random.randint(0, n-1)
            if len(chosen) &gt; 0:
                if new_element &gt;= chosen[-1]:
                    chosen.append(new_element)
                else:
                    chosen = []
            else:
                chosen.append(new_element)
    return chosen

def d2(n, k):
    """ Acceptance-rejection sampling with restart using deque """

    chosen = deque()
    while True:
        if len(chosen) == k:
            return tuple(chosen)
        else:
            new_element = random.randint(0, n-1)
            if len(chosen) &gt; 0:
                if new_element &gt;= chosen[-1]:
                    chosen.append(new_element)
                else:
                    chosen = []
            else:
                chosen.append(new_element)
    return chosen

start = perf_counter()
a_result = [flat_map[a(n, k)] for i in range(its)]
print('s: ', perf_counter() - start)

start = perf_counter()
b_result = [flat_map[b(n, k)] for i in range(its)]
print('s: ', perf_counter() - start)

start = perf_counter()
c_result = [flat_map[c(n, k)] for i in range(its)]
print('s: ', perf_counter() - start)

start = perf_counter()
d_result = [flat_map[d(n, k)] for i in range(its)]
print('s: ', perf_counter() - start)

start = perf_counter()
d2_result = [flat_map[d2(n, k)] for i in range(its)]
print('s: ', perf_counter() - start)

import matplotlib.pyplot as plt

f, arr = plt.subplots(5, sharex=True, sharey=True)
arr[0].hist(a_result, label='original')
arr[1].hist(b_result, label='naive (non-uniform)')
arr[2].hist(c_result, label='jdehesa (non-uniform)')
arr[3].hist(d_result, label='Acceptance-rejection restart -&gt; list')
arr[4].hist(d2_result, label='Acceptance-rejection restart  -&gt; deque')

for i in range(5):
    arr[i].legend()

plt.show()
</code></pre>
<p>Output:</p>
<pre><code>s:  546.1523445801055
s:  1.272424016672062
s:  3.058098026099742
s:  12.665841491509354
s:  13.14264200539003
</code></pre>
<p><a href="https://i.stack.imgur.com/N7a9W.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/N7a9W.png"/></a></p>
<p>Yes, i put those labels in some sub-optimal position.</p>
<h3>Alternative timings:</h3>
<p>Only comparing original with deque-based AR-sampling. Also only relative-timings matter here.</p>
<p><code>n=100, k=3</code>:</p>
<pre><code>s:  22.6498539618067
s:  0.038274503506364965
</code></pre>
<p><code>n=100, k=4</code>:</p>
<pre><code>s:  7.047153613584993
s:  0.0009363589822841689
</code></pre>
<p><strong>Remark:</strong> one might argue that the original approach should re-use the sample-space (which will shift those benchmarks) if memory allows this storage at all.</p>
</div>
<span class="comment-copy">Maybe you need <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a>?</span>
<span class="comment-copy">@jdehesa I want to create a random tuple out of all combinations not a products. But if you have a solution using <code>choices</code> I would be glad if you could add it as answer :)</span>
<span class="comment-copy">But isn't that what <code>choices</code> does? Sample <code>k</code> elements with replacement from a population.</span>
<span class="comment-copy">No, <code>choices</code> samples <code>itertools.product</code> (with optional weights) but not <code>itertools.combinations_with_replacement</code>. At least that's what I understood.</span>
<span class="comment-copy">No, it creates "combinations" that aren't produced by <code>combinations_with_replacement</code>. Sticking to your example <code>BA</code> isn't a valid combination but it could be produced by <code>random.choices</code>.</span>
<span class="comment-copy">I've modified my answer... Can't tell if it's equivalent to yours, since I can't tell why it actually works at all :/... but feel free to compare it to your proposal.</span>
