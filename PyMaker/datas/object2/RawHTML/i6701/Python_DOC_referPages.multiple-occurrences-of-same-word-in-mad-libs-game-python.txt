<div class="post-text" itemprop="text">
<p>I'm trying to make a Mad Libs game where the user enters in words that occurs multiple times in the sentence. At the moment I'm finding that the user is required to type in these same words multiple times. </p>
<pre><code>sentence_a = """GENRE_OF_MUSIC was created by PERSON in Middle Earth.
                We only know because NUMBER years ago,
                MUSICIAN went on an epic quest with only a OBJECT for
                company. MUSICIAN had to steal GENRE_OF_MUSIC from PERSON
                and did this by playing a game of SPORT as a distraction."""

#Words to be replaced
parts_of_speech = ["MUSICIAN", "GENRE_OF_MUSIC", "NUMBER",
                    "OBJECT", "PAST_TENSE_VERB", "PERSON", "SPORT"]            

# Checks if a word in parts_of_speech is a substring of the word passed in.
def word_in_pos(word, parts_of_speech):
    for pos in parts_of_speech:
        if pos in word:
            return pos
    return None

def play_game(ml_string, parts_of_speech):    
    replaced = []
    ml_string = ml_string.split()
    for word in ml_string:
        replacement = word_in_pos(word, parts_of_speech)
        if replacement != None:
            user_input = raw_input("Type in a: " + replacement + " ")
            word = word.replace(replacement, user_input)
            replaced.append(word)
        else:
            replaced.append(word)
    replaced = " ".join(replaced)
    return replaced

print play_game(sentence_a, parts_of_speech)
</code></pre>
<p>When you run the code I want the user to only enter GENRE_OF_MUSIC once and for the Mad Libs sentence to use that entry only for each occurrence. </p>
</div>
<div class="post-text" itemprop="text">
<p>You're not tracking the replacements to handle duplicate keywords.</p>
<p>You could change the code to loop through your keywords:</p>
<pre><code>sentence_a = """GENRE_OF_MUSIC was created by PERSON in Middle Earth.
We only know because NUMBER years ago,
MUSICIAN went on an epic quest with only a OBJECT for
company. MUSICIAN had to steal GENRE_OF_MUSIC from PERSON
and did this by playing a game of SPORT as a distraction."""

#Words to be replaced
parts_of_speech = ["MUSICIAN", "GENRE_OF_MUSIC", "NUMBER",
                    "OBJECT", "PAST_TENSE_VERB", "PERSON", "SPORT"]            

def play_game(ml_string, parts_of_speech):    
    for word in parts_of_speech:
        if word in ml_string:
            user_input = raw_input("Type in a: " + word + " ")
            ml_string = ml_string.replace(word, user_input)
    return ml_string

print play_game(sentence_a, parts_of_speech)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're on the right track. What you're <strong>not</strong> doing is tracking what words you've already changed to what value.</p>
<p>I'd recommend checking out <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer">Dictionaries</a> in Python and using them. They work in key-value pairs, which is perfect for what you want.</p>
<p>For a working version of what you want, check these edits out:</p>
<pre><code>sentence_a = """GENRE_OF_MUSIC was created by PERSON in Middle Earth.
                We only know because NUMBER years ago,
                MUSICIAN went on an epic quest with only a OBJECT for
                company. MUSICIAN had to steal GENRE_OF_MUSIC from PERSON
                and did this by playing a game of SPORT as a distraction."""

#Words to be replaced
parts_of_speech = ["MUSICIAN", "GENRE_OF_MUSIC", "NUMBER",
                    "OBJECT", "PAST_TENSE_VERB", "PERSON", "SPORT"]

# DICTIONARY to hold replaced key-value pairs
replace_dictionary = {}

# Checks if a word in parts_of_speech is a substring of the word passed in.
def word_in_pos(word, parts_of_speech):
    for pos in parts_of_speech:
        if pos in word:
            return pos
    return None

def play_game(ml_string, parts_of_speech):    
    replaced = []
    ml_string = ml_string.split()
    for word in ml_string:
        replacement = word_in_pos(word, parts_of_speech)

        # See if the word is in our dictionary. If so, use that value
        if replacement in replace_dictionary.keys():
          word = word.replace(replacement, replace_dictionary[replacement])
          replaced.append(word)

        elif replacement != None and replacement not in replace_dictionary.keys():
            user_input = input("Type in a: " + replacement + " ")

            # This replacement is new, so we add it to Dictionary
            replace_dictionary[replacement] = user_input

            word = word.replace(replacement, user_input)
            replaced.append(word)
        else:
            replaced.append(word)
    replaced = " ".join(replaced)
    return replaced

print (play_game(sentence_a, parts_of_speech))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using string formatting instead of search-and-replace.</p>
<p>Here's how it could work:</p>
<pre><code>import string
from textwrap import dedent

FMT = string.Formatter()

def get_field_names(format_string):
    """
    Return a list of unique field names from the format string
    """
    return sorted(set(p[1] for p in FMT.parse(format_string) if p[1] is not None))

sentence_a = dedent("""
    {GENRE_OF_MUSIC} was created by {PERSON} in Middle Earth.
    We only know because {NUMBER} years ago, {MUSICIAN} went
    on an epic quest with only a {OBJECT} for company.
    {MUSICIAN} had to steal {GENRE_OF_MUSIC} from {PERSON}
    and did this by playing a game of {SPORT} as a distraction.
""")

parts_of_speech = get_field_names(sentence_a)
replace_dict = {pos:pos for pos in parts_of_speech}

# after getting input from player
replace_dict["MUSICIAN"] = "Chuck Berry"

# show result
print(sentence_a.format(**replace_dict))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is unnecessary too complex.</p>
<p>First, you can ask the user the parts of speech to replace. You can do that with a loop over <em>parts_of_speech</em> and store each user input into a mapping:</p>
<pre><code>parts = {}
for replacement in parts_of_speech:
    user_input = raw_input("Type in a " + replacement + ": ")
    parts[replacement] = user_input
</code></pre>
<p>Then you can split the sentence and replace each word by the user replacement, if it exist. If not, you keep the word:</p>
<pre><code>words = [parts.get(word, word)
         for word in ml_string.split()]
return " ".join(words)
</code></pre>
<p>You get:</p>
<pre><code>Type in a MUSICIAN: Bach
Type in a GENRE_OF_MUSIC: piano
Type in a NUMBER: 23
Type in a OBJECT: roller
Type in a PAST_TENSE_VERB: dig
Type in a PERSON: Mr president
Type in a SPORT: football
piano was created by Mr president in Middle Earth. We only know because 23 years ago, Bach went on an epic quest with only a roller for company. Bach had to steal piano from Mr president and did this by playing a game of football as a distraction.
</code></pre>
<p>Note: <em>word_in_pos</em> function is useless.</p>
</div>
<span class="comment-copy">Add the ones you've already done in a dict, and then check if they are in the dict</span>
<span class="comment-copy">See if this is what you are looking for : <a href="https://stackoverflow.com/questions/25631695/replace-all-the-occurrences-of-specific-words" title="replace all the occurrences of specific words">stackoverflow.com/questions/25631695/â€¦</a></span>
<span class="comment-copy">This one worked like a treat thanks Eric and thanks to everyone else I will experiment with the others and am sure to use them in future projects!</span>
<span class="comment-copy">Thanks, I tried to keep my answer as close to your original code so it'd be easier to follow. I would recommend understanding the other answers, I liked <a href="https://stackoverflow.com/a/46229561/7675174">Hugh's</a>.</span>
