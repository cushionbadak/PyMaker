<div class="post-text" itemprop="text">
<p>I've got a really useful python method like this:</p>
<pre><code>def stop_widget():
  original_widget = load_widget_from_file()
  if original_widget: 
    original_widget.close()
</code></pre>
<p>when I want to test it to make sure I called <code>close()</code>, I do:</p>
<pre><code>@patch('load_widget_from_file')
def test_stop_widget_with_original_widget(self, lwff_mock):
    mock_widget = create_autospec(Widget)
    lwff_mock.return_value = mock_widget
    stop_widget()
    mock_widget.close.assert_called_once_with()
</code></pre>
<p>but what do I do when I want to test <em>not</em> calling <code>close</code> when the return value of <code>load_widget_from_file</code> doesn't evaluate to True?</p>
<p>If I tried making another unit test with:</p>
<pre><code>@patch('load_widget_from_file')
def test_stop_widget_with_original_widget(self, lwff_mock):
    mock_widget = None
    lwff_mock.return_value = mock_widget
    stop_widget()
    mock_widget.close.assert_not_called()
</code></pre>
<p>this would blow up. </p>
</div>
<div class="post-text" itemprop="text">
<p>You need to create a second mock object (instead of setting <code>mock_widget = None</code>), but the widget needs to be falsey to prevent the function from entering the if condition.</p>
<p>In Python, an object is always "truthy" unless is has a zero-length, or it has a <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="nofollow noreferrer"><code>__bool__</code> method that returns <code>False</code></a>:</p>
<blockquote>
<p>object.__bool__(self)</p>
<p>Called to implement truth value testing and the built-in operation <code>bool()</code>; should return <code>False</code> or <code>True</code>. When this method is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p>
</blockquote>
<p>Probably the "right way" to add a <code>__bool__</code> method to your mock object would be to <a href="https://python.readthedocs.io/en/latest/library/unittest.mock.html#magicmock-and-magic-method-support" rel="nofollow noreferrer">use <code>MagicMock</code></a>, which comes with many of the Python "magic methods" pre-defined. But you'll also have to change the return value to <code>False</code>, like so:</p>
<pre><code>@patch('load_widget_from_file')
def test_stop_widget_with_original_widget(self, lwff_mock):
    mock_widget = MagicMock()
    mock_widget.__bool__.return_value = False
    lwff_mock.return_value = mock_widget
    stop_widget()
    mock_widget.close.assert_not_called()
</code></pre>
</div>
<span class="comment-copy">What about <code>assert_not_called</code>?</span>
<span class="comment-copy">@larsks, I don't have an object instantiated with a function to call that on.</span>
<span class="comment-copy">what happens if you just do <code>mock_widget = create_autospec(Widget)</code> in the second method, just like in the first method?</span>
<span class="comment-copy">@rick, that fails because close is called (this would make it identical to the first case)</span>
<span class="comment-copy">Yeah, the first way doesn't work - <b>bool</b> is not defined in the original class so I think create_autospec doesn't go in and make it (at least not the version I'm running Python 3.5.1, I looked at some changelogs for the unittest framework and it looked like someone implemented some magicmethod for <b>bool</b> a long time ago, but I don't see docs for it.</span>
<span class="comment-copy">Second way works like a champ though, thanks!</span>
<span class="comment-copy">yeah I didn't bother testing. deleted the first idea- not sure why it isn't working but whatever.</span>
