<div class="post-text" itemprop="text">
<p>The following data representation: </p>
<pre><code>[
 {u'0xbd4f1cc0da707c5712651b659b86766ec6f25af5e388fc82474523339dd1da37': u'90000'},
 {u'0x05a04a7bb2500087c14bc89eb6a49cd4c5afcac63270aff2d4508e610f606eed': u'40000'},
 {u'0xc3f68d46b9e462110e4897a41b573a10fef72747fd4c9e8413eb2e4cba0af9b5': u'21000'},
 {u'0x79dcc6ab82b2024a0d4135d4fa3a5cd62ab740f28fffa3fc4dfdb8b00430baab': u'158971'},
 {u'0x034c9e7f28f136188ebb2a2630c26183b3df90c387490159b411cf7326764341': u'21000'},
 {u'0xffda7269775dcd710565c5e0289a2254c195e006f34cafc80c4a3c89f479606e': u'1000000'},
 {u'0x90ca439b7daa648fafee829d145adefa1dc17c064f43db77f573da873b641f19': u'90000'},
 {u'0x7cba9f140ab0b3ec360e0a55c06f75b51c83b2e97662736523c26259a730007f': u'40000'},
 {u'0x92dedff7dab405220c473aefd12e2e41d260d2dff7816c26005f78d92254aba2': u'21000'},
 {u'0x0abe75e40a954d4d355e25e4498f3580e7d029769897d4187c323080a0be0fdd': u'21000'},
 {u'0x22c2b6490900b21d67ca56066e127fa57c0af973b5d166ca1a4bf52fcb6cf81c': u'90000'},
 {u'0x8570106b0385caf729a17593326db1afe0d75e3f8c6daef25cd4a0499a873a6f': u'90000'},
 {u'0x8adfe7fc3cf0eb34bb56c59fa3dc4fdd3ec3f3514c0100fef800f065219b7707': u'40000'},
 {u'0x8b0fe2b7727664a14406e7377732caed94315b026b37577e2d9d258253067553': u'21000'},
 {u'0x244b29b60c696f4ab07c36342344fe6116890f8056b4abc9f734f7a197c93341': u'50000'},
 {u'0xf2b5b8fb173e371cbb427625b0339f6023f8b4ec3701b7a5c691fa9cef9daf63': u'121000'},
 {u'0xf8f2a397b0f7bb1ff212b6bcc57e4a56ce3e27eb9f5839fef3e193c0252fab26': u'121000'}
]
</code></pre>
<p>Is generated from this loop: </p>
<pre><code>dict_hash_gas = list()
for line in inpt:
    resource = json.loads(line)
    dict_hash_gas.append({resource['first']:resource['second']})
</code></pre>
<p>Based on data that looks, <em>more or less</em>, like so: </p>
<pre><code>{"first":"A","second":"1","third":"2"} 
{"first":"B","second":"1","third":"2"} 
{"first":"C","second":"2","third":"2"} 
{"first":"D","second":"3","third":"2"} 
{"first":"E","second":"3","third":"2"} 
{"first":"F","second":"3","third":"2"} 
</code></pre>
<p>I've tried to find the maximum value of the second value in each dict, i.e.</p>
<pre><code>{"first":"A","second":"LOOKING_FOR_MAX"}
</code></pre>
<p>How can I access all of the second values (the ones that look like <code>u'90000'</code>) from that set of nested dictionaries, record and output the <code>max</code> and the <code>min</code>? </p>
<hr/>
<p>To precisely define terms: In the example up top, i.e.: </p>
<pre><code>{u'0xbd4f1cc0da707c5712651b659b86766ec6f25af5e388fc82474523339dd1da37': u'90000'},
{u'0x05a04a7bb2500087c14bc89eb6a49cd4c5afcac63270aff2d4508e610f606eed': u'40000'},
{u'0xc3f68d46b9e462110e4897a41b573a10fef72747fd4c9e8413eb2e4cba0af9b5': u'21000'},
</code></pre>
<p>I'd like to search on the basis of <code>u'90000'</code>, <code>u'40000'</code> and <code>u'21000'</code>- that's what I mean by "second" value. </p>
<p>The selection of <code>max</code> I'd like to make would be on the basis of the number alone, so in that case <code>u'90000'</code>. </p>
<hr/>
<p><strong>EDIT:</strong></p>
<p>Trying to call it in the following way, I generated the error reproduced below: </p>
<pre><code>def _main():

    with open('transactions000000000029.json', 'rb') as inpt:
        dict_hash_gas = list()
        for line in inpt:
            resource = json.loads(line)
            dict_hash_gas.append({resource['hash']:resource['gas']})

    pairs = list(_as_pairs(dict_hash_gas))
    if pairs:
        # Avoid a ValueError from min() and max() if the list is empty.
        print(min(pairs, key=lambda pair: pair.value))
        print(max(pairs, key=lambda pair: pair.value))
</code></pre>
<p><a href="https://i.stack.imgur.com/EZrTQ.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/EZrTQ.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Once you have your data in a tractable form, it's a one-liner.
In this case, since those dictionaries are obviously records of some sort, the ideal data type is either a custom class or a
<a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a>.
I went with the <code>namedtuple</code>, since all the values are atomic and immutable.
(Also, it comes with many handy features like decent <code>__str__</code> and <code>__hash__</code> methods, and it's more efficient too.)</p>
<p>All of the effort below is in <code>_as_pairs</code>, which generates immutable key-value pairs from that frustrating list of one-item dictionaries.
It also converts the stringified integers
(<code>value</code>)
into the <em>actual</em> integers you wish they were.
After that, using the data is easy.</p>
<pre><code>import collections

# FIXME:  Use more descriptive names than "Pair", "key", and "value".
Pair = collections.namedtuple('Pair', ['key', 'value'])

def _as_pairs(pairs):
    for pair in pairs:
        # TODO:  Verify the dict conatains exactly one item?
        for k, v in pair.items():
            # Should the `key` string also be an integer?
            #yield Pair(key=int(k, base=16), value=int(v))
            yield Pair(key=k, value=int(v))

def _main():
    # Abbreviated below, but conatains same inputs as your example.
    dict_hash_gas = [
      ...,
      {u'0xffda...606e': u'1000000'},
      {u'0x90ca...1f19': u'90000'},
      ...,
      ]
    pairs = list(_as_pairs(dict_hash_gas))
    if pairs:
        # Avoid a ValueError from min() and max() if the list is empty.
        print(min(pairs, key=lambda pair: pair.value))
        print(max(pairs, key=lambda pair: pair.value))

if '__main__' == __name__:
    _main()
</code></pre>
<p>Output (Python 3):</p>
<pre class="lang-none prettyprint-override"><code>Pair(key='0xc3f6...f9b5', value=21000)
Pair(key='0xffda...606e', value=1000000)
</code></pre>
<p>I've included a couple suggestions in the comments:</p>
<ul>
<li><p>Is it important that those dictionaries have exactly one item each?</p></li>
<li><p>Should those hexadecimal strings
(which I called <code>id</code>)
also be converted into integers?</p></li>
</ul>
<p>I can't tell what you're using this for, so I can't answer either of those questions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you constrained to using dictionaries here? A list of tuples might be simpler to use: </p>
<pre><code>dict_hash_gas = list()
for line in inpt:
    resource = json.loads(line)
    dict_hash_gas.append((resource['first'], resource['second']))

sorted_data = sorted(dict_hash_gas, key=lambda x: int(x[1]))
minimum = sorted_data[0]
maximum = sorted_data[-1]
</code></pre>
<p>yields:
<code>('0xc3f68d46b9e462110e4897a41b573a10fef72747fd4c9e8413eb2e4cba0af9b5', '21000')</code> for the minimum
and
<code>('0xffda7269775dcd710565c5e0289a2254c195e006f34cafc80c4a3c89f479606e',
 '1000000')</code> for the maximum</p>
<p>Edit to show example using <code>collections.namedtuple</code>:</p>
<pre><code>from collections import namedtuple

DataItem = namedtuple('DataItem', ['first', 'second'])

dict_hash_gas = list()
for line in inpt:
    resource = json.loads(line)
    dict_hash_gas.append(DataItem(resource['first'], resource['second']))
</code></pre>
<p>sorted(dict_hash_gas, key=lambda x: int(x.second))</p>
</div>
<span class="comment-copy">What have you tried, and what exactly is the problem with it?</span>
<span class="comment-copy">Do you know how to access the <code>'second'</code> value in a single <code>dict</code>? Do you know how to loop over the items in the list? This seems pretty straightforward...</span>
<span class="comment-copy">in this one ` {u'0xbd4f1cc0da707c5712651b659b86766ec6f25af5e388fc82474523339dd1da37': u'90000'}<code>, the second would be </code>u'90000'<code>, so I'd like to search on the basis of  </code>90000`</span>
<span class="comment-copy">@KevinJ.Chase so I just tried it out, but I got this error <code>pprint.pprint(sorted_x = sorted(dict_hash_gas.items(), key=operator.itemgetter(1))) AttributeError: 'list' object has no attribute 'items'</code></span>
<span class="comment-copy">definetly need the numerical value, that was a mistake</span>
<span class="comment-copy">cool- I definitely think this is the right approach. I published an update to the OP with the sorry results of my latest attempt- but when I wake up in the morning I'm gonna take another crack at it :)</span>
<span class="comment-copy">@s.matthew.english:  How did you define <code>Pair</code>?  Did you change the field names?  The keyword arguments must match the field names.</span>
<span class="comment-copy">yes, that's what I was thinking- so I tried to change every instance of <code>Pair(key=k, value=int(v))</code> to <code>Pair(hash=k, gas=int(v))</code>, is that the right way? That was my guess based on the error message I got when I tried to run it, i.e. <code>TypeError: __new__() got an unexpected keyword argument 'key'</code>, was looking for some info about it in the <a href="https://docs.python.org/2/library/collections.html" rel="nofollow noreferrer">python docs</a>, but as of yet haven't found a solution. that substitution I described ends up like this <code>print(min(pairs, hash=lambda pair: pair.gas)) TypeError: min() got an unexpected keyword argument</code></span>
<span class="comment-copy">@s.matthew.english:  Assuming you've named the fields <code>'hash'</code> and <code>'gas'</code>, yes.  See the third line in the "<a href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer">Basic Example</a>" (look for the comment "instantiate with positional or keyword arguments").</span>
<span class="comment-copy">@s.matthew.english: That second <code>key</code> is an argument to <a href="https://docs.python.org/3/library/functions.html#min" rel="nofollow noreferrer"><code>min</code></a> (or <code>max</code>).  It has nothing to do with the <code>namedtuple</code>.  Slow down and <i>read</i> the error messages...  The new error tells you it's coming from <code>min()</code>, not <code>Pair</code>.</span>
<span class="comment-copy">man I think I should stick to dict because this is just part of a larger codebase which is all based on dict, I tried the dict thing you suggested but I got the error <code>AttributeError: 'tuple' object has no attribute 'values'</code></span>
<span class="comment-copy">I agree, the list of 2-element dictionaries is making this far harder than it has to be.  @s.matthew.english:  If you use a <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a>, you will get the best of both worlds --- easy dotted-fieldname access along with easy sorting <i>and</i> much lower memory use.</span>
<span class="comment-copy">how would that look like?</span>
<span class="comment-copy">The key function for the dictionary would return <code>int(item.values()[0])</code> for the given <i>input</i>.  You could also show key function use for the <code>max</code> function.</span>
<span class="comment-copy">The only problem I see using the dictionary like that is unless you are using Python3.6+ (until the dict implementation changes again) there is no guarantee that the value you want will be at any particular index of <code>item.values()</code>. Its possible that you could use a separate key function instead of a lambda and find the correct value based upon some pattern that you know and we aren't privy to.</span>
