<div class="post-text" itemprop="text">
<p>When I was looking at meaning of the += operator in Python, I looked at the answers to a similar question: <a href="https://stackoverflow.com/questions/4841436/what-exactly-does-do-in-python">What exactly does += do in python?</a>. But in the below code excerpt:</p>
<pre><code>increments += arr[i-1] - arr[i]
</code></pre>
<p>There is a third variable used. If I understood the concept it subtracts <code>arr[i]</code> from <code>arr[i-1]</code> and adds it to <code>increments</code>'s value and the result is assigned to <code>increments</code>. To elaborate: is the above statement similar to </p>
<pre><code>increments = increments + (arr[i-1] - arr[i])
</code></pre>
<p>or is there more to it?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow noreferrer">the documentation</a>:</p>
<blockquote>
<p>An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target. The target is only evaluated once.</p>
<p>An augmented assignment expression like <code>x += 1</code> can be rewritten as <code>x = x + 1</code> to achieve a <strong>similar, but not exactly equal</strong> effect. In the augmented version, <code>x</code> is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.</p>
<p>Unlike normal assignments, augmented assignments evaluate the left-hand side before evaluating the right-hand side. For example, <code>a[i] += f(x)</code> first looks-up <code>a[i]</code>, then it evaluates <code>f(x)</code> and performs the addition, and lastly, it writes the result back to <code>a[i]</code>.</p>
<p>With the exception of assigning to tuples and multiple targets in a single statement, the assignment done by augmented assignment statements is handled the same way as normal assignments. Similarly, with the exception of the possible in-place behavior, the binary operation performed by augmented assignment is the same as the normal binary operations.</p>
<p>For targets which are attribute references, the same caveat about class and instance attributes applies as for regular assignments.</p>
</blockquote>
<p><em>(my emphasis in the second paragraph)</em></p>
<p>So yes, there's more to it than just <code>increments =  increments + (arr[i-1] - arr[i])</code>. The degree to which it matters depends on what you're applying the operator to.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>To elaborate: is the above statement similar to </p>
<p>increments = increments + (arr[i-1] - arr[i])</p>
</blockquote>
<p>That depends on the type of "increments".</p>
<p>With regards to the core built-in types (and other types that try to follow the pattern set by them) there are two at least two notable differences between + and +=.</p>
<ol>
<li>Where the type is mutable += performs the modification in-place while + creates a new object.</li>
<li>For lists += is more flexible than +, + will only accept another list but += will accept any iterable.</li>
</ol>
<p>Numbers are immutable, so for numbers the two statements behave the same. However it is interesting to see if we can figure out some cases where they do behave differently.</p>
<p>We are quite limited in what types we can use because relatively few types support both "+" and "-" and most types only support operations with the same type. A combination of making increments a list and making the elements of arr sets is one way to demonstrate a difference.</p>
<pre><code>increments=[]
i = 1 
arr=[{"foo","bar"},{"bar","baz"}]
increments += arr[i-1] - arr[i]
print(increments)
</code></pre>
<p>"Prints ['foo']"</p>
<pre><code>increments=[]
i = 1 
arr=[{"foo","bar"},{"bar","baz"}]
increments = increments + (arr[i-1] - arr[i])
print(increments)
</code></pre>
<p>Raises an exception "TypeError: can only concatenate list (not "set") to list"</p>
<p>But that is a rather contrived example, for something more realistic we want a type that is mutable and supports both "+" and "-". I don't think there are any such types among the core built-in types but one widely used type that does is the "array" type from numpy.</p>
<pre><code>from numpy import array
increments=array((1,2))
oldincrements=increments
i = 1 
arr=[array((3,4)),array((5,6))]
increments += arr[i-1] - arr[i]
print(repr(oldincrements)+' '+repr(increments))
</code></pre>
<p>Prints "array([-1,  0]) array([-1,  0])". The numpy array was modified in-place so both "oldincrements" and "increments" were affected.</p>
<pre><code>from numpy import array
increments=array((1,2))
oldincrements=increments
i = 1 
arr=[array((3,4)),array((5,6))]
increments = increments + (arr[i-1] - arr[i])
print(repr(oldincrements)+' '+repr(increments))
</code></pre>
<p>Prints "array([1, 2]) array([-1,  0])" the array pointed to by increments was not modified in-place, instead a new array was created and assigned to "increments". So "oldincrements" was not affected.</p>
</div>
<span class="comment-copy">Really, that's all it does. What more were you expecting?</span>
<span class="comment-copy">It depends on the types of <code>arr[i-1]</code>, <code>arr[i]</code> and <code>increments</code>. An <code>x += ...</code> is not always the same as <code>x = x + ...</code>. For lists for instance it is not. But for immutable objects, it is the same, so for <code>int</code>s, <code>str</code>ings, etc. there is no difference.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Thank you. What all I needed was an affirmation from an experienced programmer. You see I'm an amateur to Python. Sometimes re-affirmation of what I understood is all I need.</span>
<span class="comment-copy">@WillemVanOnsem arr is a array/list of numbers. In that case how does it vary from an Integer or a string?</span>
<span class="comment-copy">@SreedharDanturthi it matters for <code>arr</code>... but not <code>arr[x]</code></span>
