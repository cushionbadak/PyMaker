<div class="post-text" itemprop="text">
<p>I'm a beginner of python. I was learning meta-class but I did not quite understand how dictionary store methods and attributes? </p>
<pre><code>class ModelMetaclass(type):
    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==&gt; %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings
        attrs['__table__'] = name 
        return type.__new__(cls, name, bases, attrs)
</code></pre>
<p>I assume that attrs can store not only variables but methods. if it was doing so, what's keys and values in this dictionary, attrs? </p>
</div>
<div class="post-text" itemprop="text">
<p>All attributes of a class are indeed stored in a dictionary. Note that methods are <em>just attributes too</em>; they just happen to be callable. Python uses dictionaries in a lot of places; the global namespace of a module is a dictionary too, for example. It is usually the job of the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>object.__getattribute__</code> hook</a> to translate attribute access into a key lookup in the attribute dictionary.</p>
<p>The body of a class statement is executed like a function, and the resulting local namespace (the dictionary produced by calling <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer"><code>locals()</code></a>) is then handed the metaclass to produce the class object. That's what <code>attrs</code> is bound to in you example code.</p>
<p>See the <a href="https://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow noreferrer"><code>class</code> statement reference documentation</a>:</p>
<blockquote>
<p>The class’s suite is then executed in a new execution frame (see [Naming and binding](The class’s suite is then executed in a new execution frame (see Naming and binding), using a newly created local namespace and the original global namespace. (Usually, the suite contains mostly function definitions.) <strong>When the class’s suite finishes execution, its execution frame is discarded but its local namespace is saved</strong>. A class object is then created using the inheritance list for the base classes <strong>and the saved local namespace for the attribute dictionary</strong>.</p>
</blockquote>
<p>Bold emphasis mine.</p>
<p>You can find more detail in the <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer"><em>Metaclasses</em> section of the datamodel documentation</a>; quoting the <a href="https://docs.python.org/3/reference/datamodel.html#creating-the-class-object" rel="nofollow noreferrer"><em>Creating the class object</em> section</a>:</p>
<blockquote>
<p>Once the class namespace has been populated by executing the class body, the class object is created by calling <code>metaclass(name, bases, namespace, **kwds)</code></p>
</blockquote>
<p>The namespace dictionary is then attached to the newly-created class object by <code>type.__new__()</code>.</p>
<p>The <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">datamodel documentation</a> covers this as well, under the <em>Custom classes</em> section:</p>
<blockquote>
<p>A class has a namespace implemented by a dictionary object. Class attribute references are translated to lookups in this dictionary, e.g., <code>C.x</code> is translated to <code>C.__dict__["x"]</code> (although there are a number of hooks which allow for other means of locating attributes).</p>
</blockquote>
<p>You may want to read up on <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>descriptors</em></a> as well; methods are created by binding functions found in the class namespace to the instance on which you looked up the method name.</p>
</div>
<span class="comment-copy">Methods are just attributes that are callable. Object attributes are often stored in a dictionary, named <code>__dict__</code> (also an attribute, via a mechanism called 'slots').</span>
<span class="comment-copy">If you are a beginner, you can safely ignore metaclasses for a while.</span>
<span class="comment-copy">By the way, abbreviating "attributes" to "attrs" can create confusion because there is a popular Python library called <a href="https://www.attrs.org" rel="nofollow noreferrer"><code>attrs</code></a></span>
