<div class="post-text" itemprop="text">
<pre><code>I/P - (('1', (('2355', '5'), 'F')),
       ('1', (('2300', '4'), 'M')),
       ('1', (('2400', '5'), 'F')))
O/P - [['1','2355','5','F'],
       ['1','2300','4','M'],
       ['1','2400','5','F']]
</code></pre>
<p>I am able to get the first element but the other elements are still extracted as a tuple whereas I want all of them to come out as part of a list. Basically, I want every element to come out individually as part of a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>in 3.3+ there is a recursive idiom that can be modified to flatten nested tuples of 'any' depth (see: system recursion limit)</p>
<pre><code>def yielder(x):
    for y in x:
        if isinstance(y, tuple):
            yield from yielder(y)
        else:
            yield y
</code></pre>
<p>which can then be used in a list comprehension    </p>
<pre><code>[[*yielder(e)] for e in IP]
Out[48]: [['1', '2355', '5', 'F'], ['1', '2300', '4', 'M'], ['1', '2400', '5', 'F']]
</code></pre>
<p>I found the above by searching for 'python flatten', in the comments to <a href="https://jugad2.blogspot.in/2014/10/flattening-arbitrarily-nested-list-in.html" rel="nofollow noreferrer">https://jugad2.blogspot.in/2014/10/flattening-arbitrarily-nested-list-in.html</a></p>
<p>for 2/7 <a href="http://joedicastro.com/aplanar-listas-en-python.html" rel="nofollow noreferrer">http://joedicastro.com/aplanar-listas-en-python.html</a> has recipes, I modded: </p>
<pre><code>def flat_slice ( lst ):
    lst = list ( lst )
    for i , _ in enumerate ( lst ):
        while ( hasattr ( lst [ i ], "__iter__" ) and not isinstance ( lst [ i ], basestring )):
             lst [ i : i + 1 ] = lst [ i ]
    return lst
</code></pre>
<p>(I had to change basestring to str for 3+)</p>
<p>and it ran with the same result</p>
<pre><code>[[*flat_slice(e)] for e in IP]
Out[66]: [['1', '2355', '5', 'F'], ['1', '2300', '4', 'M'], ['1', '2400', '5', 'F']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def flaten(t,level=0):
   l = []
   for t1 in t:
     if type(t1) is tuple:
       if level == 0:
         l.append(flaten(t1,level+1))
       else:
         l.extend(flaten(t1,level+1))
     else:
       l.append(t1)
   return l

t = (('1', (('2355', '5'), 'F')), ('1', (('2300', '4'), 'M')), ('1', (('2400', '5'), 'F')))
l = flaten(t)
print(l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I kept it to a simple recursive routine that can also be used in a comprehension:</p>
<pre><code>def unpack(element, stack):
    if isinstance(element, basestring):
        stack.append(element)
    else:
        for i in element:
            unpack(i, stack)
    return stack

[unpack(row, []) for row in IP]
</code></pre>
<p>Output:</p>
<pre><code>[['1', '2355', '5', 'F'], ['1', '2300', '4', 'M'], ['1', '2400', '5', 'F']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Iterate each iterable, flatten all elements, then recast the iterable to a list.  Here are two approaches:</p>
<p><strong>Given</strong></p>
<pre><code>iterables = (
    ('1', (('2355', '5'), 'F')),
    ('1', (('2300', '4'), 'M')),
    ('1', (('2400', '5'), 'F'))
)

expected = [
    ['1','2355','5','F'],
    ['1','2300','4','M'],
    ['1','2400','5','F']
]
</code></pre>
<p><strong>Code</strong></p>
<p>A modified <code>flatten</code> from <a href="https://stackoverflow.com/a/40857703/4531270">this post</a> (Python 2/3 compatible):</p>
<pre><code># Approach 1
from collections import Iterable


def flatten(items):
    """Yield items from any nested iterable"""
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            for i in flatten(x):
                yield i
        else:
            yield x

actual = [list(flatten(i)) for i in iterables]
assert actual == expected
</code></pre>
<p>For a one-liner, consider <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse" rel="nofollow noreferrer"><code>more_itertools.collapse</code></a>, a tool that also flattens nested iterables:</p>
<pre><code># Approach 2
import more_itertools as mit


actual = [list(mit.collapse(i)) for i in iterables]
assert actual == expected
</code></pre>
<p><em>Note: <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library that implements several <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a> and useful tools. Install by <code>pip install more_itertools</code>.</em></p>
</div>
<span class="comment-copy">is there any other way? I am using Python 2.7 and cant upgrade.</span>
<span class="comment-copy">You should put the version in the tags if ti is important. Because otherwise, this is a very slick answer.</span>
