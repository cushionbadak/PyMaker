<div class="post-text" itemprop="text">
<p>Trying to understand oop in python I came into this situation that puzzles me, and I wasn't able to find a satisfactory explanation... 
I was building a Countable class, which has a counter attribute that counts how many instances of the class have been initialized. I want this counter to be increased also when a subclass (or subsubclass) of the given class is initialized. Here is my implementation:</p>
<pre><code>class Countable(object):
    counter = 0
    def __new__(cls, *args, **kwargs):
        cls.increment_counter()
        count(cls)
        return object.__new__(cls, *args, **kwargs)

    @classmethod
    def increment_counter(cls):
        cls.counter += 1
        if cls.__base__ is not object:
            cls.__base__.increment_counter()
</code></pre>
<p>where <code>count(cls)</code> is there for debugging purposes, and later i write it down.</p>
<p>Now, let's have some subclasses of this:</p>
<pre><code>class A(Countable):
    def __init__(self, a='a'):
        self.a = a

class B(Countable):
    def __init__(self, b='b'):
        self.b = b

class B2(B):
    def __init__(self, b2='b2'):
        self.b2 = b2

def count(cls):
    print('@{:&lt;5}  Countables: {}  As: {}  Bs: {}  B2s: {}'
          ''.format(cls.__name__, Countable.counter, A.counter, B.counter, B2.counter))
</code></pre>
<p>when I run a code like the following:</p>
<pre><code>a = A()
a = A()
a = A()
b = B()
b = B()
a = A()
b2 = B2()
b2 = B2()
</code></pre>
<p>I obtain the following output, which looks strange to me:</p>
<pre><code>@A      Countables:  1  As: 1  Bs: 1  B2s: 1
@A      Countables:  2  As: 2  Bs: 2  B2s: 2
@A      Countables:  3  As: 3  Bs: 3  B2s: 3
@B      Countables:  4  As: 3  Bs: 4  B2s: 4
@B      Countables:  5  As: 3  Bs: 5  B2s: 5
@A      Countables:  6  As: 4  Bs: 5  B2s: 5
@B2     Countables:  7  As: 4  Bs: 6  B2s: 6
@B2     Countables:  8  As: 4  Bs: 7  B2s: 7
</code></pre>
<p>Why at the beginning both the counter of A and B is incrementing, despite I am calling only <code>A()</code>? And why after the first time I call <code>B()</code> it behaves like expected?</p>
<p>I already found out that to have a behavior like I want it is sufficient to add <code>counter = 0</code> at each subclass, but I was not able to find an explanation of why it behaves like that.... Thank you!</p>
<hr/>
<p>I added few debug prints, and for simplicity limited class creation to two. This is pretty strange:</p>
<pre><code>&gt;&gt;&gt; a = A()
&lt;class '__main__.A'&gt; incrementing
increment parent of &lt;class '__main__.A'&gt; as well
&lt;class '__main__.Countable'&gt; incrementing
@A      Counters: 1  As: 1  Bs: 1  B2s: 1
&gt;&gt;&gt; B.counter
1
&gt;&gt;&gt; B.counter is A.counter
True
&gt;&gt;&gt; b = B()
&lt;class '__main__.B'&gt; incrementing
increment parent of &lt;class '__main__.B'&gt; as well
&lt;class '__main__.Countable'&gt; incrementing
@B      Counters: 2  As: 1  Bs: 2  B2s: 2
&gt;&gt;&gt; B.counter is A.counter
False
</code></pre>
<p>How come when B() is not initialized yet, it points to the same variable as A.counter but after creating single object it is a different one?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem with your code is that subclasses of <code>Countable</code> don't have their own <code>counter</code> attribute. They're merely inheriting it from <code>Countable</code>, so when <code>Countable</code>'s <code>counter</code> changes, it looks like the child class's <code>counter</code> changes as well.</p>
<p>Minimal example:</p>
<pre><code>class Countable:
    counter = 0

class A(Countable):
    pass # A does not have its own counter, it shares Countable's counter

print(Countable.counter) # 0
print(A.counter) # 0

Countable.counter += 1

print(Countable.counter) # 1
print(A.counter) # 1
</code></pre>
<p>If <code>A</code> had its own <code>counter</code> attribute, everything would work as expected:</p>
<pre><code>class Countable:
    counter = 0

class A(Countable):
    counter = 0 # A has its own counter now

print(Countable.counter) # 0
print(A.counter) # 0

Countable.counter += 1

print(Countable.counter) # 1
print(A.counter) # 0
</code></pre>
<p>But if all of these classes share the same <code>counter</code>, why do we see different numbers in the output? That's because you actually add the <code>counter</code> attribute to the child class later, with this code:</p>
<pre><code>cls.counter += 1
</code></pre>
<p>This is equivalent to <code>cls.counter = cls.counter + 1</code>. However, it's important to understand what <code>cls.counter</code> refers to. In <code>cls.counter + 1</code>, <code>cls</code> doesn't have its own <code>counter</code> attribute yet, so this actually gives you the parent class's <code>counter</code>. Then that value is incremented, and <code>cls.counter = ...</code> adds a <code>counter</code> attribute to the child class that hasn't existed until now. It's essentially equivalent to writing <code>cls.counter = cls.__base__.counter + 1</code>. You can see this in action here:</p>
<pre><code>class Countable:
    counter = 0

class A(Countable):
    pass

# Does A have its own counter attribute?
print('counter' in A.__dict__) # False

A.counter += 1

# Does A have its own counter attribute now?
print('counter' in A.__dict__) # True
</code></pre>
<hr/>
<p>So what's the solution to this problem? You need a <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">metaclass</a>. This gives you the possibility to give each <code>Countable</code> subclass its own <code>counter</code> attribute when it is created:</p>
<pre><code>class CountableMeta(type):
    def __init__(cls, name, bases, attrs):
        cls.counter = 0  # each class gets its own counter

class Countable:
    __metaclass__ = CountableMeta

# in python 3 Countable would be defined like this:
#
# class Countable(metaclass=CountableMeta):
#    pass

class A(Countable):
    pass

print(Countable.counter) # 0
print(A.counter) # 0

Countable.counter += 1

print(Countable.counter) # 1
print(A.counter) # 0
</code></pre>
</div>
<span class="comment-copy">I can't reproduce your output. My output for <code>B2s</code> is always the same as <code>Bs</code>.</span>
<span class="comment-copy">I edited your question with simplified example of the issue. This is an interesting question, hope someone can shed some light on the process</span>
<span class="comment-copy">@Rawing you are right, I pasted the output of another example... now I fix it!</span>
<span class="comment-copy">Are you aware that python  has <code>__subclasses__</code> which will give you the subclasses of a class? <a href="https://stackoverflow.com/a/3862957/7432">stackoverflow.com/a/3862957/7432</a></span>
<span class="comment-copy">I would just add that in Python3.6+, one can also use <a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation" rel="nofollow noreferrer"><code>__init_subclass__() hook</code></a> for the same purpose (adding a <code>counter</code> attribute to each subclass).</span>
<span class="comment-copy">Or (in Python 2.7.x+ and 3.x)  use a class decorator.</span>
<span class="comment-copy">however, after the creation of the first object is completed (<code>a = A()</code>), I get <code>id(Countable.counter) == id(A.counter)</code>. Why does this happen if the assignment creates a new class variable for class A??</span>
<span class="comment-copy">@blue_note ints are immutable, so it doesn't make much sense to check their id. What matters is not if both classes share the same int instance, it's whether <code>A</code> has its own attribute that shadows <code>Countable</code>'s. If ints were mutable, then both classes sharing the same int instance would be a problem, but they're not. See also <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">this question</a> for more info on comparing the ids of ints.</span>
<span class="comment-copy">@blue_note Yes, it (CPython) does that for ints between -5 and 256.</span>
