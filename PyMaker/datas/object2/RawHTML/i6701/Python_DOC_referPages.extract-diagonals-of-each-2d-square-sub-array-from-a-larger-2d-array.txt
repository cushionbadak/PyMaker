<div class="post-text" itemprop="text">
<p>This is my first programming class and I'm very excited to learn Python for Data Science. I cannot figure out how to write a loop that returns all diagonal numbers in the matrix. Below is the code, how close or far off am I? Thank you!</p>
<pre><code>import numpy as np
cols = 0

matrixA = np.array([[2,0,0], [0,3,0], [0,0,4], [6,0,0], [0,7,0], [0,0,8]])

for rows in range(6):
    if rows == cols:
        print(matrixA[rows, cols])
    cols = cols + 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your current solution does not work because it does not take into account the fact that <code>matrixA</code> is not square. You will have to take care that your indices do not run out of bounds. Running it gives:</p>
<pre><code>IndexError: index 3 is out of bounds for axis 1 with size 3
</code></pre>
<p>This is because the maximum value that <code>cols</code> is allowed to take here is <code>2</code>.</p>
<hr/>
<p>As an alternative, you could use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html" rel="nofollow noreferrer"><em><code>np.diag</code></em></a>:</p>
<pre><code>print(x)
array([[2, 0, 0],
       [0, 3, 0],
       [0, 0, 4],
       [6, 0, 0],
       [0, 7, 0],
       [0, 0, 8]])

res = np.array([np.diag(x, -offset) for offset in range(0, *x.shape)])

print(res)
array([[2, 3, 4],
       [6, 7, 8]])
</code></pre>
<p>If you want a 1D result, call <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" rel="nofollow noreferrer"><em><code>np.ravel</code></em></a>:</p>
<pre><code>print(res.ravel())
array([2, 3, 4, 6, 7, 8])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need heavy library like <a href="http://www.numpy.org/" rel="nofollow noreferrer"><code>numpy</code></a> to achieve this simple task. In plain python you can do it via using <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle(...)</code></a> as:</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle

&gt;&gt;&gt; my_list = [[2,0,0], [0,3,0], [0,0,4], [6,0,0], [0,7,0], [0,0,8]]
&gt;&gt;&gt; for i, j in zip(my_list, cycle(range(3))):
...     print(i[j])
...
2
3
4
6
7
8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why have cols at all? It's always the same as rows, right?</p>
<pre><code>for rows in range(6):
    print(matrixA[rows,rows])
</code></pre>
</div>
<span class="comment-copy">First, ask yourself "where do the elements 2, 3, 4, 6, 7, 8 occur?", that will help provide you with the insight into getting the elements</span>
<span class="comment-copy">@roganjosh This works thank you! Can you break down the res code section? Sorry for the number of questions, I'm new to Python and truly appreciate the amount of feedback I get on here! Thank you!</span>
<span class="comment-copy">@Brandon I've linked you to the docs. There is an <code>offset</code> parameter in <code>np.diag</code> that allows you to specify the row number from where to begin extracting diagonal elements. We want to move down the rows in steps of 3 (in this case), that's what <code>range</code> does.</span>
<span class="comment-copy"><code>range(0, *x.shape)</code> is pretty opaque code to give to a beginner, @cᴏʟᴅsᴘᴇᴇᴅ.  What he's doing is taking the <code>shape</code> (<code>(6, 3)</code> in this case) and appending it to the arguments of <code>range</code>, so that <code>range(0, *x.shape)</code> becomes <code>range(0, 6, 3) - &gt; [0, 3]</code>.  The <code>*</code> unpacks the tuple, so without it the result would be, <code>range(0, (6, 3))</code> which doesn't work.</span>
<span class="comment-copy">If <code>matrixA</code> was square,  but that isn't the case.</span>
