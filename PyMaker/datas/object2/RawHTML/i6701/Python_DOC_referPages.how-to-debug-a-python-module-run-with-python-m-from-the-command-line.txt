<div class="post-text" itemprop="text">
<p>I know that a Python script can be debugged from the command line with</p>
<pre><code>python -m pdb my_script.py
</code></pre>
<p>if <code>my_script.py</code> is a script intended to be run with <code>python my_script.py</code>.</p>
<p>However, a python module <code>my_module.py</code> should be run with <code>python -m my_module</code>.  Even scripts that contain relative imports should be run with <code>python -m</code>.  How can I run <code>python -m my_module</code> under <code>pdb</code>'s control?  The following <strong>does not work</strong>:</p>
<pre><code>python -m pdb -m my_module
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't do it now, because <code>-m</code> terminates option list</p>
<pre><code>python -h
...
-m mod : run library module as a script (terminates option list)
...
</code></pre>
<p>That means it's <strong>mod's</strong> job to interpret the rest of the arguments list and this behavior fully depends on how <strong>mod</strong> is designed internally and whether it support another <strong>-m</strong></p>
<p>Lets check out what's happening inside <a href="https://github.com/python/cpython/blob/2.7/Lib/pdb.py#L1314" rel="noreferrer">pdb</a> of <strong>python 2.x</strong>. Actually, nothing intereseting, it only expects a script name to be supplied:</p>
<pre><code>   if not sys.argv[1:] or sys.argv[1] in ("--help", "-h"):
        print "usage: pdb.py scriptfile [arg] ..."
        sys.exit(2)

    mainpyfile =  sys.argv[1]     # Get script filename
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    del sys.argv[0]         # Hide "pdb.py" from argument list

    # Replace pdb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    # Note on saving/restoring sys.argv: it's a good idea when sys.argv was
    # modified by the script being debugged. It's a bad idea when it was
    # changed by the user from the command line. There is a "restart" command
    # which allows explicit specification of command line arguments.
    pdb = Pdb()
    while True:
        try:
            pdb._runscript(mainpyfile)
</code></pre>
<p>Same for the currently released versions of <strong><a href="https://github.com/python/cpython/blob/3.6/Lib/pdb.py#L1667" rel="noreferrer">python 3.x</a></strong></p>
<h2>Good news</h2>
<p>The pull request that allows to do what you're asking has been <a href="https://github.com/python/cpython/pull/4752" rel="noreferrer">merged</a> 5 days ago. What a mysterious coincidence! Here's the <a href="https://github.com/python/cpython/blob/master/Lib/pdb.py#L1693" rel="noreferrer">code</a></p>
<p>So just wait a bit for the upcoming python 3.x versions to have this issue resolved )</p>
</div>
<div class="post-text" itemprop="text">
<p>The following script will run a module and break into post-mortem debugging if an exception occurs while running the module. It should work both with Python 2.7 and 3.x.</p>
<p><strong>Usage</strong>:</p>
<pre><code>mdb.py module_name [args ...]
</code></pre>
<p><strong>Known limitations</strong>:</p>
<ul>
<li>While running the module code, <code>sys.argv[0]</code> is preserved as the module name, instead of being resolved to the file path of the module.</li>
<li>If the target module is not found, the error is not reported any differently than if the error occurred during the execution of the module</li>
</ul>
<hr/>
<p><strong>mdb.py</strong></p>
<pre><code>#!/usr/bin/env python

from __future__ import print_function
import pdb
import runpy
import sys
import traceback

if len(sys.argv) == 0:
    print("Usage: mdb.py module_name [args ...]")
    exit(1)

modulename = sys.argv[1]
del sys.argv[0]

try:
    runpy.run_module(modulename, run_name='__main__')
except:
    traceback.print_exception(*sys.exc_info())
    print("")
    print("-" * 40)
    print("mdb: An exception occurred while executing module ", modulename)
    print("mdb: See the traceback above.")
    print("mdb: Entering post-mortem debugging.")
    print("-" * 40)
    pdb.post_mortem(sys.exc_info()[2])
</code></pre>
<hr/>
<p><strong>Demonstration</strong>:</p>
<pre><code>$ tree
.
├── mdb.py
└── mypackage
    ├── __init__.py
    ├── __main__.py
    └── mymodule.py

1 directory, 4 files

$ ###################### Examine the module code ###################
$ cat mypackage/mymodule.py 
from __future__ import print_function
import sys

print("mymodule loaded")

if __name__ == "__main__":
    print("mymodule executed")
    print("args:", sys.argv)

$ #################### Run the module through python ###############
$ python -m mypackage.mymodule abc defgh
mymodule loaded
mymodule executed
args: ['/home/leon/playground/mdb/mypackage/mymodule.py', 'abc', 'defgh']

$ #################### Run the module through mdb ##################
$ ./mdb.py mypackage.mymodule abc defgh
mymodule loaded
mymodule executed
args: ['mypackage.mymodule', 'abc', 'defgh']
$ ###   ^^^^^^^^^^^^^^^^^^
$ ### Note that sys.argv[0] is not resolved to the file path

$ ###################### Examine the module code ###################
$ cat mypackage/__main__.py 
from __future__ import print_function
import sys

print("mypackage loaded")

if __name__ == "__main__":
    print("mypackage executed")
    print("args:", sys.argv)
    print(x + y)

$ #################### Run the module through python ###############
$ python -m mypackage
mypackage loaded
mypackage executed
args: ['/home/leon/playground/mdb/mypackage/__main__.py']
Traceback (most recent call last):
  File "/usr/lib/python2.7/runpy.py", line 174, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "/usr/lib/python2.7/runpy.py", line 72, in _run_code
    exec code in run_globals
  File "/home/leon/playground/mdb/mypackage/__main__.py", line 9, in &lt;module&gt;
    print(x + y)
NameError: name 'x' is not defined

$ #################### Run the module through mdb ##################
$ ./mdb.py mypackage
mypackage loaded
mypackage executed
args: ['mypackage']
Traceback (most recent call last):
  File "./mdb.py", line 17, in &lt;module&gt;
    runpy.run_module(modulename, run_name='__main__')
  File "/usr/lib/python2.7/runpy.py", line 192, in run_module
    fname, loader, pkg_name)
  File "/usr/lib/python2.7/runpy.py", line 72, in _run_code
    exec code in run_globals
  File "/home/leon/playground/mdb/mypackage/__main__.py", line 9, in &lt;module&gt;
    print(x + y)
NameError: name 'x' is not defined

----------------------------------------
mdb: An exception occurred while executing module  mypackage
mdb: See the traceback above.
mdb: Entering post-mortem debugging.
----------------------------------------
&gt; /home/leon/playground/mdb/mypackage/__main__.py(9)&lt;module&gt;()
-&gt; print(x + y)
(Pdb) q
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can add <code>pdb.set_trace()</code> in your code for interactive debugging, before the code you want to debug.</p>
<pre><code>class C:    
    def __init__(self, x):
        self.x = x

    def inst_f(self):
        pass

a = C('this is a')
import pdb
pdb.set_trace()
b = C('this is b')

print a.x is b.x
</code></pre>
<p>Running this will output</p>
<pre><code>&gt; c:\python27\tests\test.py(11)&lt;module&gt;()
-&gt; b = C('this is b')
(Pdb) 
</code></pre>
<p>And let you use python debugger.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <code>python</code> command-line manpage the -m flag does the following:</p>
<blockquote>
<p>Searches  sys.path for the named module and runs the corresponding .py file as a script.</p>
</blockquote>
<p>Given this, I would feel confident debugging by running the .py file as per your first example. One thing to keep in mind is that -m searches <code>sys.path</code>. Luckily, python looks at the current working directory first, so as long as the .py you are debugging is in your cwd, <code>python -m module</code> and <code>python module.py</code> equivalent.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 3.7 adds that feature</strong></p>
<p>From <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">the docs</a>, it looks that your command:</p>
<pre><code>python -m pdb -m my_module
</code></pre>
<p>will start working on Python 3.7:</p>
<blockquote>
<p>New in version 3.7: pdb.py now accepts a -m option that execute modules similar to the way python3 -m does. As with a script, the debugger will pause execution just before the first line of the module.</p>
</blockquote>
</div>
<span class="comment-copy">I'm giving you the bounty for the reference for the merged code.Think @Leon would also deserve some of it but don't know how to split it. He did provide a solution for the previous versions.  It seems to be out of the question scope, but both of these solutions seem to be implying no CLI arguments for the new module.</span>
<span class="comment-copy">It implies a module without any cli arguments, right?</span>
<span class="comment-copy">@TheMeaningfulEngineer Yes, it did, but now it doesn't</span>
<span class="comment-copy">I am wondering if/how i could start the debugger from the command line, without editing the source.</span>
<span class="comment-copy">If a file contains relative imports, it will produce an error if run without <code>-m</code>.  In any case, i think the runtime environment is somewhat different when executing <code>python -m my_package</code> rather than <code>python my_package/__main__.py</code>.</span>
