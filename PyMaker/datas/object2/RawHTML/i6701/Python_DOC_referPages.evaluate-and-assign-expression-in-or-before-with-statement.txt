<div class="post-text" itemprop="text">
<p>If I am correct, <code>with</code> statement doesn't introduce a local scope for the <code>with</code> statement.</p>
<p>These are  examples from Learning Python:</p>
<pre><code>with open(r'C:\misc\data') as myfile:
    for line in myfile:
        print(line)
        ...more code here...
</code></pre>
<p>and</p>
<pre><code>lock = threading.Lock()                        # After: import threading
with lock:
    # critical section of code
    ...access shared resources...
</code></pre>
<p>Is the second example equivalent to the following rewritten in a way similar to the first example?</p>
<pre><code>with threading.Lock() as lock:
    # critical section of code
    ...access shared resources...
</code></pre>
<p>What are their differences?</p>
<p>Is the first example equivalent to the following rewritten in a way similar to the second example?</p>
<pre><code>myfile = open(r'C:\misc\data')
with myfile:
    for line in myfile:
        print(line)
        ...more code here...
</code></pre>
<p>What are their differences? </p>
</div>
<div class="post-text" itemprop="text">
<p>When <code>with</code> enters a context, it calls a hook on the context manager object, called <code>__enter__</code>, and the return value of that hook can optionally be assigned to a name using <code>as &lt;name&gt;</code>. Many context managers return <code>self</code> from their <code>__enter__</code> hook. If they do, then you can indeed take your pick between creating the context manager on a separate line or capturing the object with <code>as</code>.</p>
<p>Out of your two examples, only the file object returned from <code>open()</code> has an <code>__enter__</code> hook that returns <code>self</code>. For <code>threading.Lock()</code>, <code>__enter__</code> returns the same value as <a href="https://docs.python.org/3/library/threading.html#threading.Lock.acquire" rel="nofollow noreferrer"><code>Lock.acquire()</code></a>, so a <em>boolean</em>, not the lock object itself.</p>
<p>You'll need to look for explicit documentation that confirms this; this is not always that clear however. For <code>Lock</code> objects, the <a href="https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement" rel="nofollow noreferrer">relevant section of the documentation</a> states:</p>
<blockquote>
<p>All of the objects provided by this module that have <code>acquire()</code> and <code>release()</code> methods can be used as context managers for a <code>with</code> statement. <strong>The <code>acquire()</code> method will be called when the block is entered</strong>, and release() will be called when the block is exited.</p>
</blockquote>
<p>and for file objects, the <a href="https://docs.python.org/3/library/io.html#io.IOBase" rel="nofollow noreferrer"><code>IOBase</code> documentation</a> is rather on the vague side and you have to infer from the example that the file object is returned.</p>
<p>The main thing to take away is that <em>returning <code>self</code> is not mandatory</em>, nor is it always desired. Context managers are entirely free to return something else. For example, many database connection objects are context managers that let you manage the transaction (roll back or commit automatically, depending on whether or not there was an exception), where entering returns a new cursor object bound to the connection.</p>
<p>To be explicit:</p>
<ul>
<li><p>for your <code>open()</code> example, the two examples are for all intents and purposes exactly the same. Both call <code>open()</code>, and if that does not raise an exception, you end up with a reference to that file object named <code>myfile</code>. In both cases the file object will be closed after the <code>with</code> statement is done. The name continues to exist after the <code>with</code> statement is done.</p>
<p>There is a difference, but it is mostly technical. For <code>with open(...) as myfile:</code>, the file object is created, has it's <code>__enter__</code> method called and then <code>myfile</code> is bound. For the <code>myfile = open(...)</code> case, <code>myfile</code> is bound first, <code>__enter__</code> called later.</p></li>
<li><p>For your <code>with threading.Lock() as lock:</code> example, using <code>as lock</code> will set <code>lock</code> to a <code>True</code> (locking always either succeeds or blocks indefinitely this way).  This differs from the <code>lock = threading.Lock()</code> case, where <code>lock</code> is bound to the lock object.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://effbot.org/zone/python-with-statement.htm" rel="nofollow noreferrer">Here's a good explanation</a>.  I'll paraphrase the key part:</p>
<blockquote>
<p>The <code>with</code> statement could be thought of like this code:</p>
<pre><code>set things up
try:
    do something
finally:
    tear things down
</code></pre>
<p>Here, “set things up” could be opening a file, or acquiring some sort of external resource, and “tear things down” would then be closing the file, or releasing or removing the resource. The try-finally construct guarantees that the “tear things down” part is always executed, even if the code that does the work doesn’t finish.</p>
</blockquote>
</div>
<span class="comment-copy">Am I understanding this correctly?  Returning <code>self</code> is only a requirement for <code>with _____ as _____</code>?  If it doesn't return <code>self</code>, then you can still use <code>with ____:</code>?</span>
<span class="comment-copy">@RagingRoosevelt: you can still use <code>with ___</code> and ignore the return value. That return value can be <i>anything</i>; it is entirely dependent on the context manager what it'll return.</span>
<span class="comment-copy">@MartijnPieters I sincerely apologize for my comment on the other post being closed (now deleted).</span>
<span class="comment-copy">@Tim: no need to mention it. It was handled by another moderator, water under the bridge now. I appreciate the apology!</span>
