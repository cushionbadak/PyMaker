<div class="post-text" itemprop="text">
<p>I have the same question as was asked <a href="https://stackoverflow.com/questions/17223215">here</a> but erroneously closed
as a duplicate of <a href="https://stackoverflow.com/questions/2615414">another related question</a>:</p>
<p>How can a Python library raise an exception in such a way that its own
code it not exposed in the traceback? The motivation is to make it
clear that the library function was called incorrectly: the offending
line in the caller should appear to bear the blame, rather than the
line inside the library that (deliberately, and correctly) raised the
exception.</p>
<p>As pointed out in Ian's comment on the closed question, this is <strong>not</strong>
the same as asking how you can adjust the code <em>in the caller</em> to change
the way a traceback appears.</p>
<p>My failed attempt is below.
At the line marked <code>QUESTION</code>, I have tried modifying the attributes of
<code>tb</code>, e.g. <code>tb.tb_frame = tb.tb_frame.f_back</code> but this results in
<code>AttributeError: readonly attribute</code>. I have also attempted to create a
duck-typed object with the same attributes as <code>tb</code> but this fails during
<code>reraise()</code>, with <code>TypeError: __traceback__ must be a traceback or None</code>.
(My attempts to outwit this by subclassing <code>traceback</code> are met with <code>TypeError: type 'traceback' is not an acceptable base type</code>).</p>
<p>Tweaking the <code>traceback</code> object itself may in any case be the wrong Y for this X - perhaps there are other strategies?</p>
<p>Let's suppose Alice writes the following library:</p>
<pre><code>import sys

# home-made six-esque Python {2,3}-compatible reraise() definition
def reraise( cls, instance, tb=None ): # Python 3 definition
    raise ( cls() if instance is None else instance ).with_traceback( tb )
try: 
    Exception().with_traceback
except: # fall back to Python 2 definition
    exec( 'def reraise( cls, instance, tb=None ): raise cls, instance, tb' )
    # has to be wrapped in exec because this would be a syntax error in Python 3.0

def LibraryFunction( a ):
    if isinstance( a, (int, float) ):
        return a + 1
    else:
        err = TypeError( "expected int or float, got %r" % a )
        RaiseFromAbove( err )   # the traceback should NOT show this line
                                # because this function knows that it is operating
                                # correctly and that the caller is at fault

def RaiseFromAbove( exception, levels=1 ):
    # start by raising and immediately catching the exception
    # so that we can get a traceback from sys.exc_info()
    try:
        raise( exception )
    except:  
        cls, instance, tb = sys.exc_info()
        for i in range( levels + 1 ):
            pass # QUESTION: how can we manipulate tb here, to remove its deepest levels?
        reraise( cls, instance, tb )
</code></pre>
<p>Now, suppose Alice releases the library, and Bob downloads it.  Bob writes code that calls it as follows:</p>
<pre><code>from AlicesLibrary import LibraryFunction

def Foo():
    LibraryFunction( 'invalid input' )  # traceback should reach this line but go no deeper

Foo()
</code></pre>
<p>The point is that, as things stand without a working <code>RaiseFromAbove</code>, the traceback will show the exception as originating from line 17 of Alice's library.  Therefore, Bob (or a significant subpopulation of the Bobs out there) will email Alice saying "hey, your code is broken on line 17."  But in fact, <code>LibraryFunction()</code> knew exactly what it was doing in issuing the exception. Alice can try her best to re-word the exception to make it as clear as possible that the library was <em>called</em> wrongly, but the traceback <strong>draws attention away</strong> from this fact. The place where the mistake was actually made was line 4 of Bob's code. Furthermore, Alice's code <em>knows</em> this, and so it's not a misplacement of authority to allow Alice's code to assign the blame where it belongs. Therefore, for greatest possible transparency and to reduce the volume of support traffic, the traceback should go no deeper than line 4 of Bob's code, <em>without</em> Bob having to code this behavior himself.</p>
<p>mattbornski provides a "you shouldn't be wanting to do this" answer <a href="https://stackoverflow.com/a/17223494/3019689">here</a> which I think misses an important point. Sure, if you say "it's not my fault" and shift the blame, you don't know that you're necessarily shifting the blame to the right place.  But you <em>do</em> know that you (<code>LibraryFunction</code>) have gone to the effort of making an explicit type check on the input arguments you were handed, and that this check has succeeded (in the sense that the check itself did not raise an exception) with a negative result.  And sure, Bob's code may not be "at fault" in the sense that perhaps it did not generate the invalid input - maybe Bob is just passing that argument on from somewhere else.  But the difference is that he has passed it on <em>without</em> checking.  If Bob goes to the effort of checking, and the checking code itself doesn't raise an exception, then Bob should feel free to <code>RaiseFromAbove</code> too, thereby helping the users of his code.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could redefine the function <code>sys.excepthook</code> as in <a href="https://stackoverflow.com/questions/34175111/raise-an-exception-from-a-higher-level-a-la-warnings/35537640#35537640">this answer</a>:</p>
<pre><code>import os
import sys
import traceback

def RaiseFromAbove( exception ):
    sys.excepthook = print_traceback
    raise( exception )

def print_traceback(exc_type, exc_value, tb):
    for i, (frame, _) in enumerate(traceback.walk_tb(tb)):
        # for example:
        if os.path.basename(frame.f_code.co_filename) == 'AlicesLibrary.py':
            limit = i
            break
    else:
        limit = None
    traceback.print_exception(exc_type, exc_value, tb, limit=limit, chain=False)
</code></pre>
<p>This requires Python 3.5 for <a href="https://docs.python.org/3/library/traceback.html#traceback.walk_tb" rel="nofollow noreferrer"><code>walk_tb</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think the Pythonic Y to your X would be changing your code so that the exception is raised by the failure itself. In this case, rather than doing an explicit type check and then calling an exception raising method, practice EAFP and <em>just add 1</em> to whatever they pass in and let that raise an error if it doesn't work. If for some reason you need to explicitly limit to those two types, add <code>assert isinstance(a, (int, float)), "LibraryFunction() requires an int or float argument"</code> to the start of your function, and let type validation raise the error. If the line of code at the bottom of the stacktrace in Alice's library isn't the "real" source of the exception, don't try to hide that line of code, restructure the code itself so that the stacktrace tells you what actually went wrong. That will make Alice's code easier to maintain, and Bob can chase the stack back into his own code to see where his problem started.</p>
</div>
<div class="post-text" itemprop="text">
<p>There has been no good/direct/authoritative answer to the problem. I issued the bounty under the category "authoritative reference needed" and the closest thing to that have been Martijn's comments, i.e.:</p>
<ol>
<li>the way to do it definitively is to alter the traceback object or generate a new one;</li>
<li>this <em>cannot</em> be done in pure Python, but must be done by mucking about with unsupported API infrastructure;</li>
<li>this isn't worth it.</li>
</ol>
<p>I suspected as much. So unless/until anyone can actually provide the authoritative reference to the impossibility of this approach, I'll post it here as the "accepted" answer.</p>
<p>But I don't accept that it's not a worthwhile wish-list item for Python.  The question has generated a fair amount of "you shouldn't be wanting to do this" sentiment with which I still disagree:  </p>
<ul>
<li><p>Sure, Bob <em>should</em> learn to read tracebacks properly, but what's wrong with making it <em>easier</em> for him to do so - help Alice to help him direct his attention to the right place? The scenario of Bob being na√Øve enough to reach out to Alice and report a bug in her code was an exaggerated (albeit possible) example to make the point clear. More likely, he'll just have an unnecessary 2-second pause as he thinks "problem on line 17 of... oh wait, no, the caller is the problem".  But why not spare him that, and make the programming UX smoother?  Python's philosophy seems to me to have revolved around removing exactly this kind of friction.</p></li>
<li><p>Sure, any putative <code>RaiseFromAbove</code> <em>could</em> be used indiscriminately, or otherwise abused, by Alice, and hence could make things more confusing for Bob rather than less. To me that's a spurious argument since it would apply equally to any number of other unwise coding decisions Alice could make,  and indeed to many powerful features that already exist in Python and in other languages. The worth of a sharp tool should be judged on its value <em>when used correctly</em> in compliance with instructions and safety warnings.</p></li>
</ul>
<p>Anyway, the bounty deadline is approaching and if I do nothing I believe half the bounty goes to the highest-voted answer. Currently that's Tore's, but to me the idea of just adding 1 and letting Bob do the detective work is the opposite of what I'm driving at:  that makes it look <em>more</em> like there's a problem in Alice's code. Bob might become a better programmer from the intellectual exercise of tracing the problem, but he might be in a hurry, and anyway by that logic we'd all be programming on the bare metal.  So I'll award the bounty to yinnonsanders' answer, not because it's a full and satisfactory solution but because it's at least aligned with the spirit of the question and might work in some situations.</p>
</div>
<span class="comment-copy">IMO you can not. if you could manipulate how trackback printed, you could hide some frames, ref: <a href="https://mail.python.org/pipermail/python-list/2012-October/632386.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-list/2012-October/632386.html</a></span>
<span class="comment-copy">If you think this <i>might</i> be an X-Y problem, show an example of the traceback you feel is misleading. Someone might be able to suggest a simpler way to get the clarity you want.</span>
<span class="comment-copy">What exactly is wrong with the traceback reflecting the path into your library? How will you debug bugs in your own library code without the full traceback? If the caller passes in wrong data, you could just validate early and throw an exception <i>early</i>, but still within your library. But <b>don't resort to hacks just because you don't trust the developers using your library to know how to read a traceback.</b></span>
<span class="comment-copy">Exceptions shouldn't be about blame - there are many valid reasons to raise exceptions.  I don't think non-beginner Python developers generally think an exception = a bug in the library.  If you raise an informative exception, the developer should be able to understand.</span>
<span class="comment-copy">Why don't you just document properly your library? i mean, if bob wants to use an open source library and doesn't read neither the code nor the docs, it means that a problem exists between keyboard and chair. i don't think bob would blame alice if he reads something like "invalid input will raise exception".</span>
<span class="comment-copy">Hmm, I can see that that's a workable way forward for non-interactive single-threaded Python applications, where exceptions will be fatal to the entire process.  For other cases, there's the side-effect  of the lastingly, globally altered <code>sys.excepthook</code>.   That won't play nice with anybody else who has customized the hook (e.g. IPython).</span>
<span class="comment-copy">This is rather overkill, when you can just set a different traceback object.</span>
