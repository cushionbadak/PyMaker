<div class="post-text" itemprop="text">
<pre><code>import sys

num = long(raw_input("Enter the number for the factorial -&gt; "))
sys.setrecursionlimit(num + 1)


def fact(n):
    if n == 0 or n == 1:
        return 1
    else:
        return (n * fact(n - 1))


print fact(long(num))
</code></pre>
<p>Above is the code I used for finding factorial and since the maximum recursion limit depth is '997', I tried to change that using :- </p>
<blockquote>
<p>import sys <br/>
  sys.setrecursionlimit()</p>
</blockquote>
<p>But it still gives error. What else can I do ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The calling frame also counts. For <code>fact(10)</code>, you need <strong>11</strong> frames. Passing in a <code>long</code> integer causes some additional work further down the line, requiring another frame. Add two to the count:</p>
<pre><code>sys.setrecursionlimit(num + 2)
</code></pre>
<p>Add more if you have other frames calling the code calling the <code>fact()</code> function. Note that there really is no point in calling <code>long()</code> on the input first; Python will produce a <code>long</code> object if needed automatically.</p>
<p>That said, I'd not muck with the recursion limit. Set it to a high value <em>once</em>, perhaps, but don't keep adjusting it.</p>
<p>A better idea is to <em>not use recursion</em>:</p>
<pre><code>def fact(n):
    num = 1
    while n &gt; 1:
        num *= n
        n -= 1
    return num
</code></pre>
<p>or better still, don't re-invent the wheel and use <a href="https://docs.python.org/3/library/math.html#math.factorial" rel="nofollow noreferrer"><code>math.factorial()</code></a> instead. From Python 3.2 onwards, the Python implementation uses a <a href="http://www.luschny.de/math/factorial/binarysplitfact.html" rel="nofollow noreferrer">binary split factorial algorithm</a> (plus a table for the first 21 or so results).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import sys

num = long(raw_input("Enter the number for the factorial -&gt; "))
sys.setrecursionlimit(num + 1)


def fact(n):
    if n == 0 or n == 1:
        return 1
    else:
        return (n * fact(n - 1))


print
print "Factorial is -&gt; ", fact(int(num))
</code></pre>
<blockquote>
<p>This works perfectly and we can increase the limit  &gt; 997 </p>
</blockquote>
</div>
<span class="comment-copy">The recursion limit is not an exact science; there is more to the stack than just the Python function being executed. You would need to add an overhead.</span>
<span class="comment-copy">Use an <a href="https://stackoverflow.com/questions/5136447/function-for-factorial-in-python">iterative solution</a> instead</span>
<span class="comment-copy">To run the code in the example, you need one more frame for <code>long</code> (that's where the mystery frame was coming from).</span>
<span class="comment-copy">@JaredGoguen: No, because <code>long()</code> has already returned before <code>fact()</code> is invoked.</span>
<span class="comment-copy">@JaredGoguen: ah, but that does muck with the stack elsewhere as values are converted. I can reproduce with <code>long100 = 100L</code> then <code>sys.setrecursionlimit(101)</code> and <code>fact(long100)</code>.</span>
<span class="comment-copy">Sorry, you can only mark <i>one</i> of the answers as accepted, not both. It's fine if you feel your own post is the one that should have the accept mark, the choice is yours and yours alone.</span>
