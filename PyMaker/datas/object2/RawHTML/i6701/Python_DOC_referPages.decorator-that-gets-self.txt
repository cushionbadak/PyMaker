<div class="post-text" itemprop="text">
<p>I'm trying to write a decorator that can be added to instance methods and non-instance methods alike. I have reduced my code to a minimum example that demonstrates my point</p>
<pre><code>def call(fn):
    def _impl(*args, **kwargs):
        return fn(*args, **kwargs)

    fn.call = _impl

    return fn

class Foo(object):
    @call
    def bar(self):
        pass

Foo().bar.call()
</code></pre>
<p>This gives the beautiful error</p>
<pre><code>Traceback (most recent call last):
  File "/tmp/511749370/main.py", line 14, in &lt;module&gt;
    Foo().bar.call()
  File "/tmp/511749370/main.py", line 3, in _impl
    return fn(*args, **kwargs)
TypeError: bar() missing 1 required positional argument: 'self'
</code></pre>
<p>Is it possible to do something like this without resorting to</p>
<pre><code>Foo.bar.call(Foo())
</code></pre>
<p>Or is that my only option?</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to implement your decorator as a class and implement the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>. Basically, the descriptor <code>__get__</code> function is what's responsible for creating bound methods. By overriding this function, you get access to <code>self</code> and can create a bound copy of the <code>call</code> function.</p>
<p>The following implementation does exactly that. The <code>Foo</code> instance is saved in the <code>__self__</code> attribute. The decorator has a <code>__call__</code> method which calls the decorated function, and a <code>call</code> method which does the same thing.</p>
<pre><code>import inspect
import functools
from copy import copy

class call:
    def __init__(self, func):
        self.func = func
        self.__self__ = None # "__self__" is also used by bound methods

    def __call__(self, *args, **kwargs):
        # if bound to on object, pass it as the first argument
        if self.__self__ is not None:
            args = (self.__self__,) + args

        return self.func(*args, **kwargs)

    def call(self, *args, **kwargs):
        self(*args, **kwargs)

    def __get__(self, obj, cls):
        if obj is None:
            return self

        # create a bound copy of the decorator
        bound = copy(self)
        bound.__self__ = obj

        # update __doc__ and similar attributes
        functools.wraps(bound.func)(bound)
        bound.__signature__ = inspect.signature(bound.func)

        # add the bound instance to the object's dict so that
        # __get__ won't be called a 2nd time
        setattr(obj, self.func.__name__, bound)

        return bound
</code></pre>
<hr/>
<p>Test:</p>
<pre><code>class Foo(object):
    @call
    def bar(self):
        print('bar')

@call
def foo():
    print('foo')

Foo().bar.call() # output: bar
foo() # output: foo
</code></pre>
</div>
<span class="comment-copy">Look at the solution at: <a href="https://stackoverflow.com/questions/7590682/access-self-from-decorator" title="access self from decorator">stackoverflow.com/questions/7590682/access-self-from-decorator</a>. I know it is not the exact same problem but it might be helpful.</span>
<span class="comment-copy">@IdanMeyer I tried adding <code>self</code> as a parameter to <code>_impl</code>, but that just shifted the error to <code>_impl() missing 1 required positional argument: 'self'</code>, and I tried using <code>fn.__self__</code>, which raises an <code>AttributeError</code>.</span>
<span class="comment-copy">It's not especially pretty, but it works - thanks!</span>
