<div class="post-text" itemprop="text">
<p>Let's imagine I have a <strong>single</strong> class <code>X</code>. The purpose of <code>X</code> is to wrap a <code>list</code> or <code>dict</code> and provide event-listening capabilities. All works well.</p>
<pre><code>class X(object):
    def __init__(self, obj)
        self._obj = obj

    def __getattr__(self, name):
        # do stuff with self._obj

    def __getitem__(self, key):
        return self._obj[key]

    def __setitem__(self, key, val):
        self._obj[key] = val

    # rest of functionality ...
</code></pre>
<p>So this can be used to wrap a <code>dict</code> like so:</p>
<pre><code>x = X({
    'foo' : False
})

x.listen('foo', callback)

X['foo'] = True         # triggers event
X.update({
    'foo' : False       # triggers event
})
</code></pre>
<p>Or a <code>list</code>:</p>
<pre><code>x = X([1,2])

x.listen(callback)

X.append(1)        # triggers event
X[0] = 10          # triggers event
</code></pre>
<p>Great. Almost to what I wanted to accomplish ...</p>
<p>Now the current issue is that, because <code>X</code> is for both <code>list</code> and <code>dict</code> objects, it can't inherit from either. This means I don't have the magic class functions, such as <code>__contains__</code>.</p>
<p>Which leads code like this</p>
<pre><code>d = X({
        'foo' : True    
    })

    if 'foo' in d:
        print 'yahoo!'
</code></pre>
<p>Throwing a <code>KeyError</code>.</p>
<p>How can I work around this without defining every magic method I need inside of <code>X</code>. If I did it this way, for each of those definitions I would have to write two return values based off whether <code>self._obj</code> is a <code>list</code> or <code>dict</code>.</p>
<p>I thought I could do this with metaclasses at first but that doesn't seem to be a solution, since I need access to the values being passed to check whether it's a <code>dict</code> or <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>An easy way would be to use a proxy class, for example <a href="http://wrapt.readthedocs.io/en/latest/wrappers.html#proxies-and-wrappers" rel="noreferrer"><code>wrapt.ObjectProxy</code></a>. It will behave exactly like the "proxied" class except for the overridden methods. However instead of <code>self._obj</code> you can simply use <code>self.__wrapped__</code> to access the "unproxied" object.</p>
<pre><code>from wrapt import ObjectProxy

class Wrapper(ObjectProxy):
    def __getattr__(self, name):
        print('getattr')
        return getattr(self.__wrapped__, name)

    def __getitem__(self, key):
        print('getitem')
        return self.__wrapped__[key]

    def __setitem__(self, key, val):
        print('setitem')
        self.__wrapped__[key] = val

    def __repr__(self):
        return repr(self.__wrapped__)
</code></pre>
<p>This behaves like a dict if you wrap a dict:</p>
<pre><code>&gt;&gt;&gt; d = Wrapper({'foo': 10})
&gt;&gt;&gt; d['foo']
getitem
10
&gt;&gt;&gt; 'foo' in d   # "inherits" __contains__
True
</code></pre>
<p>and like a list, if a list is wrapped:</p>
<pre><code>&gt;&gt;&gt; d = Wrapper([1,2,3])
&gt;&gt;&gt; d[0]
getitem
1
&gt;&gt;&gt; for i in d:   # "inherits" __iter__
...     print(i)
1
2
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>UserList</code> or <code>UserDict</code> from <a href="https://docs.python.org/3/library/collections.html#collections.UserList" rel="nofollow noreferrer">collections</a></p>
<pre><code>from collections import UserList


class X(UserList):
    def __init__(self, obj):
        super().__init__()
        self.data = obj

    def __getattr__(self, name):
        pass
        # do stuff with self.data

    def __getitem__(self, key):
        return self.data[key]

    def __setitem__(self, key, val):
        self.data[key] = val


x0 = X([1, 2, 3])
x1 = X({1, 2, 3})
x2 = X({1: 1, 2: 2})

print(1 in x0)
print(1 in x1)
print(1 in x2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try something like </p>
<pre><code>def contains (self, item):
    If isinstance (self._obj, list):
        return list.contains (self._obj, item)
    If isinstance (self._obj, dict):
        return dict.contains (self._obj, item)
</code></pre>
<p>Or what ever method it is you want to inherit. When an instance method is called, the instance is auto-passed with self. But if you call the method from the class decleration you need to pass an object because self requires a value.</p>
<pre><code>Class Test:
    def print_cls (self):
        print self.__class__.__name__


t = Test ()

t.print_cls () # self is teat

Test.print_cls (5) 
# we replace self with another class object
# as long as the object you pass has the
# variables used in the method you call all should be good.
</code></pre>
<p>This will print out <code>Test</code> and <code>int</code></p>
</div>
<span class="comment-copy">Are you sure you need capabilities for both list and dict in your program? This sounds like a great place to split into two classes.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/9942536/how-to-fake-proxy-a-class-in-python" title="how to fake proxy a class in python">stackoverflow.com/questions/9942536/â€¦</a> <a href="https://stackoverflow.com/questions/26091833/proxy-object-in-python" title="proxy object in python">stackoverflow.com/questions/26091833/proxy-object-in-python</a></span>
<span class="comment-copy">@JoshLee Those don't address special methods.</span>
<span class="comment-copy">If you <i>inherit</i> them, they will access <code>self</code> rather than (the desired) <code>self._obj</code>.</span>
<span class="comment-copy">Magic methods are only looked up on the class, not the instance.  There is no way to dynamically select a magic method per instance.  Just define all the magic methods on your class.</span>
<span class="comment-copy">All <code>wrapt.ObjectProxy</code> does is provide all the special methods and attributes (the latter as <code>property</code> objects) and just proxy those to the wrapped object. So <code>def __contains__(self, value): return self.__wrapped__.__contains__(value)</code>.</span>
<span class="comment-copy">It looks like the goal is that an instance of <code>X</code> will look exactly like whatever object was passed to it, not that you have to call some special function like <code>contains()</code> rather than using the <code>in</code> operator. You also wouldn't want to special case particular classes like <code>list</code> and <code>dict</code>. I'm not sure what your snippet with the <code>Test</code> class is about, but it clearly doesn't have much to do with the question.</span>
