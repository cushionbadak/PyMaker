<div class="post-text" itemprop="text">
<p>I have a list of tuples like</p>
<pre><code>data = [
    ('di', 'c1', 'avg11'),
    ('di', 'c2', 'stdev12'),
    ('eng', 'c1', 'stdev21'),
    ('eng', 'c2', 'stdev22')
]
</code></pre>
<p>How do I get the <code>'di'</code> and <code>'eng'</code> items into a dictionary which looks like this :</p>
<pre><code>data1 = {'c1':'avg11','c2':'stdev12'}

data2 = {'c1':'stdev21','c2':'stdev22'}
</code></pre>
<p>using pandas or numpy or regular python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>Pandas</code> you could do</p>
<pre><code>In [660]: data1, data2 = pd.DataFrame(data).set_index([0, 1]).unstack()[2].to_dict('r')

In [661]: data1
Out[661]: {'c1': 'avg11', 'c2': 'stdev12'}

In [662]: data2
Out[662]: {'c1': 'stdev21', 'c2': 'stdev22'}

In [663]: pd.DataFrame(data).set_index([0, 1]).unstack()[2].to_dict('r')
Out[663]: [{'c1': 'avg11', 'c2': 'stdev12'}, {'c1': 'stdev21', 'c2': 'stdev22'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In pure Python, just build a top-level dictionary, using <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault()</code></a> to materialise the nested dictionary if still missing:</p>
<pre><code>result = {}
for outer, inner, value in data:
    result.setdefault(outer, {})[inner] = value
</code></pre>
<p>This is the simplest and more readable way of grouping your data.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; data = [
...     ('di', 'c1', 'avg11'),
...     ('di', 'c2', 'stdev12'),
...     ('eng', 'c1', 'stdev21'),
...     ('eng', 'c2', 'stdev22')
... ]
&gt;&gt;&gt; result = {}
&gt;&gt;&gt; for outer, inner, value in data:
...     result.setdefault(outer, {})[inner] = value
...
&gt;&gt;&gt; result
{'di': {'c1': 'avg11', 'c2': 'stdev12'}, 'eng': {'c1': 'stdev21', 'c2': 'stdev22'}}
</code></pre>
<p>If you <strong>must</strong> have <code>data1</code> and <code>data2</code> variables afterwards, just set those from the <code>'di'</code> and <code>'eng'</code> keys:</p>
<pre><code>data1 = result['di']
data2 = result['eng']
</code></pre>
<p>but this is rather inflexible if you have more or fewer or different outer keys.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using plain python you could do</p>
<pre><code> def process_data(data):
    res = {}

    for itm in data:
        if itm[0] not in res:
            res[itm[0]] = {}
        res[itm[0]][itm[1]] = itm[2] 
    return res
</code></pre>
<p>Example of use:</p>
<pre><code>&gt;&gt;&gt; d = [
...     ('di', 'c1', 'avg11'),
...     ('di', 'c2', 'stdev12'),
...     ('eng', 'c1', 'stdev21'),
...     ('eng', 'c2', 'stdev22')
... ]
&gt;&gt;&gt; print(process_data(d))
{'eng': {'c2': 'stdev22', 'c1': 'stdev21'}, 'di': {'c2': 'stdev12', 'c1': 'avg11'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <code>itertools.groupby()</code> function:</p>
<pre><code>import itertools

data = [
    ('di', 'c1', 'avg11'), ('di', 'c2', 'stdev12'),
    ('eng', 'c1', 'stdev21'), ('eng', 'c2', 'stdev22')
]
result = {k: {i[1]:i[2] for i in g}
           for k,g in itertools.groupby(sorted(data), key=lambda x: x[0])}
print(result)
</code></pre>
<p>The output:</p>
<pre><code>{'di': {'c1': 'avg11', 'c2': 'stdev12'}, 'eng': {'c1': 'stdev21', 'c2': 'stdev22'}}
</code></pre>
</div>
<span class="comment-copy">Why the separate variable names? Why not just a top-level dictionary with <code>'di'</code> and <code>'eng'</code> keys?</span>
<span class="comment-copy">I am assuming this is an alternative for <code>defaultdict(dict)</code>. Does it have an advantage over it?</span>
<span class="comment-copy">@ayhan: you get to control when a missing key produces a value; a <code>defaultdict(dict)</code> always uses the factory, while <code>dict.setdefault()</code> make it explicit.</span>
<span class="comment-copy">Don't use <code>dict.get()</code> to test for the presence of a key; that's just wasted cycles as you return the value or <code>None</code>, then drop it again. Just use <code>itm[0] in res</code>.</span>
<span class="comment-copy">you're right, thank you</span>
<span class="comment-copy">Better to use <code>itm[0] not in res</code> (yes, my mistake)</span>
<span class="comment-copy">What difference between <code>itm not in res</code> and <code>not itm in res</code>?</span>
<span class="comment-copy">The first is a single operator <code>not in</code>, the other is two <code>not (itm in res)</code>. Currently CPython (the standard Python implementation) will optimise the second to be the first, but that's an implementation detail. See <a href="//stackoverflow.com/q/17659303">What is more 'pythonic' for 'not'</a></span>
