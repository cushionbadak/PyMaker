<div class="post-text" itemprop="text">
<p>I want to convert a dictionary to a JSON string with boolean <code>True</code> values translated to the number <code>1</code> and boolean <code>False</code> values translated to the number <code>0</code>. I'm using a <code>JSONEncoder</code> subclass, but it seems to ignore booleans ...</p>
<pre><code>import json

class MyEncoder(json.JSONEncoder):

    def default(self, obj):
        if isinstance(obj, bool):
            return 1 if obj else 0
    return super().default(obj)

data = { 'key-a' : 'a', 'key-true' : True, 'key-false' : False }

jsondata = json.dumps(data, cls=MyEncoder)

print(jsondata)
</code></pre>
<p>I want this to be the result:</p>
<pre><code>{"key-true": 1, "key-a": "a", "key-false": 0}
</code></pre>
<p>However, this is what I get:</p>
<pre><code>{"key-true": true, "key-a": "a", "key-false": false}
</code></pre>
<p>I know I can programatically modify the data before passing it to <code>json.dumps</code>, but is there any way I can obtain my desired result via a <code>JSONEncoder</code> subclass?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>default()</code> method of <code>JSONEncoder</code> subclasses is called only when the encoder encounters an object it doesn't otherwise know how to serialize.</p>
<p>Unfortunately, the official <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" rel="noreferrer">documentation</a> doesn't make this very clear. It's mentioned, but in the "keyword arguments" section for the class constructor, rather than in the documentation for the method:</p>
<blockquote>
<p>If specified, <em>default</em> should be a function that gets called for objects that can’t otherwise be serialized. It should return a JSON encodable version of the object or raise a <code>TypeError</code>. If not specified, <code>TypeError</code> is raised.</p>
</blockquote>
<p>This behaviour can easily be verified:</p>
<pre><code>class MyEncoder(json.JSONEncoder):

    def default(self, obj):
        if isinstance(obj, bool):
            print('got bool')
            return 1 if obj else 0
        if isinstance(obj, Foo):
            print('got Foo')
            return {'__Foo__': id(obj)}
        print('got unknown')
        return super().default(obj)
</code></pre>
<p></p>
<pre><code>&gt;&gt;&gt; class Foo: pass
...
&gt;&gt;&gt; s = json.dumps({'a': False, 'b': True, 'c': Foo()}, cls=MyEncoder)
got Foo
&gt;&gt;&gt; s
'{"a": false, "c": {"__Foo__": 140636444256856}, "b": true}'
</code></pre>
<p><code>JSONEncoder</code> isn't designed to easily allow overriding the serialization of objects it already knows how to serialize (which is a good thing: the whole point of standards like JSON is that they're, well, <em>standard</em>) … so if you really want to encode booleans as though they were integers, the easiest way to do so is probably to preprocess data as suggested in your question.</p>
</div>
<span class="comment-copy">Answer accepted, with thanks.</span>
