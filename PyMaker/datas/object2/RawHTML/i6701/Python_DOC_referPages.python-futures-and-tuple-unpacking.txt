<div class="post-text" itemprop="text">
<p>What is an elagant/idiomatic way to achieve something like tuple unpacking with futures?</p>
<p>I have code like</p>
<pre><code>a, b, c = f(x)
y = g(a, b)
z = h(y, c)
</code></pre>
<p>and I would like to convert it to use futures.
Ideally I would like to write something like</p>
<pre><code>a, b, c = ex.submit(f, x)
y = ex.submit(g, a, b)
z = ex.submit(h, y, c)
</code></pre>
<p>The first line of that throws</p>
<pre><code>TypeError: 'Future' object is not iterable
</code></pre>
<p>though.
How can I get <code>a,b,c</code> without having to make 3 additional <code>ex.submit</code> calls? ie. I would like to avoid having to write this as:</p>
<pre><code>import operator as op
fut = ex.submit(f, x)
a = client.submit(op.getitem, fut, 0)
b = client.submit(op.getitem, fut, i)
c = client.submit(op.getitem, fut, 2)
y = ex.submit(g, a, b)
z = ex.submit(h, y, c)
</code></pre>
<hr/>
<p>I guess a potential solution is to write an <code>unpack</code> function like below,</p>
<pre><code>import operator as op
def unpack(fut, n):
    return [client.submit(op.getitem, fut, i) for i in range(n)]

a, b, c = unpack(ex.submit(f, x), 3)
y = ex.submit(g, a, b)
z = ex.submit(h, y, c)
</code></pre>
<p>which works: for example if you first define:</p>
<pre><code>def f(x):
    return range(x, x+3)
x = 5
g = op.add
h = op.mul
</code></pre>
<p>then you get</p>
<pre><code>z.result() #===&gt; 77
</code></pre>
<p>I thought something like this might already exist.</p>
<hr/>
<p>The above only works with <code>dask.distributed.Future</code>. It does not work for plain <code>concurrent.futures.Future</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A quick glance at:</p>
<p><a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer">https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future</a></p>
<p>suggests that you'll have to do something like</p>
<pre><code>afuture = ex.submit(f, x)
a,b,c = afuture.result()
...
</code></pre>
<p><code>submit</code> returns a <code>Future</code> object, not the result of running <code>f(x)</code>.</p>
<p>This SO answer indicates that chaining futures is not trivial:</p>
<p><a href="https://stackoverflow.com/questions/45922846/how-to-chain-futures-in-a-non-blocking-manner-that-is-how-to-use-one-future-as">How to chain futures in a non-blocking manner? That is, how to use one future as an input in another future without blocking?</a> </p>
</div>
<span class="comment-copy">"Throws an error."  WHAT ERROR?</span>
<span class="comment-copy">@JohnZwinck <code>TypeError: 'Future' object is not iterable</code></span>
<span class="comment-copy"><code>operator.itemgetter</code> can fetch multiple items.  But look at its code; it's a class that does an iteration.</span>
<span class="comment-copy">@hpaulj Thatnks! Iteration over the indexes is ok, it is iteration over the future that was the original problem. The above approach iterates over the indexes but the extacttion of the components is delayed through the <code>submit</code> call so it is ok.</span>
<span class="comment-copy">@hpaulj ah, but <code>itemgetter</code> will not work here because if I delay  the cal to it l I will still end up with a future for an iterable, but I need an iterable of futures. The <code>unpack</code> usiing <code>getitem</code> is turning a future for an iterable into an iterable of futures for the elements, which is what make the unpacking assignment work.</span>
<span class="comment-copy">The <code>afuture.result()</code> call will block an the call to <code>f</code>, which defeats the purpose of using futures.</span>
<span class="comment-copy">@DanielMahler, can you give us an example of the chaining without the unpacking?  Sounds like you've done some basic stuff with <code>futures</code>.  Enlighten us.  What are these 3 additional calls?</span>
