<div class="post-text" itemprop="text">
<p>Function a() and b() can throw an exception. This code does not handle while exception is throwing during the assignment "UnboundLocalError: Local variable 'x' referenced before assignment"
Code:</p>
<pre><code>def foo():
    try:
        x = a('test')
        b(x, 'test2')
    except Exception as ex:
        raise Exception('Message error: ' + str(x) + " " + str(ex)) #here could be UnboundLocalError: Local variable 'x' referenced before assignment
</code></pre>
<p>My solution is:</p>
<pre><code>def foo():
    try:
        x = a('test')
        try:
            b(x, 'test2')
        except Exception as ex:
            raise Exception('Message error: ' + str(x) + " " + str(ex))         
    except Exception as ex:
        raise Exception('Message error: ' + str(ex))
</code></pre>
<p>Is it possible to do it more tricky, elegant? Now I`m forced to use double try except template.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is probably one way you could do it:</p>
<pre><code>try:
    x = a('test')
    b(x, 'test2')
except Exception as ex:
    if not 'x' in locals():
        x = 'undefined'
    raise Exception('Message error: ' + str(x) + " " + str(ex))
</code></pre>
<p>Personally, I think catching both exceptions in separate try/except blocks is more elegant, as it shows the reader that a() did not successfully complete and disallows an UnboundLocalError which masks the real issue:</p>
<pre><code>try:
    x = a('test')
except Exception as ex:
   raise Exception('oh no, a() failed')
try:
    b(x, 'test2')
except Exception as ex:
    raise Exception('oops, b() failed')
</code></pre>
<p>Here is some documentation about <code>locals()</code>: <a href="https://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#locals</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <code>else</code> clause of <a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement" rel="nofollow noreferrer">[Python]: The try statement</a>:</p>
<pre><code>def foo():
    try:
        x = a("test")
    except Exception as ex:
        raise Exception("Message error (a): " + str(ex))
    else:
        try:
            b(x, "test2")
        except Exception as ex:
            raise Exception("Message error (b): " + str(x) + " " + str(ex))
</code></pre>
</div>
<span class="comment-copy">Why do you need to reference <code>x</code> in the exception message in the first place?</span>
<span class="comment-copy">Also, it's not a good idea to have two functions bundled into a catch-all exception like you wanted in first block (or use a blanket <code>except</code> in general). Did <code>x = a('test')</code> fail or <code>b(x, 'test2')</code>? Currently your way of deciphering that is by raising yet another exception that is uncaught.</span>
<span class="comment-copy">But the logic of the flow doesn't make sense. If <code>x = a('test')</code> fails then <code>b(x, 'test2')</code> is clearly impossible, so why have it in the same <code>try</code>? Just have two separate <code>try</code>/<code>except</code>, one for each, and have done with it. There's nothing fancy or pythonic about nesting exceptions like this...</span>
<span class="comment-copy">You're right, I wasn't clear in my response. This is what I meant by "catching both exceptions." Although, then an UnboundLocalError wouldn't even be raised. Edited with a better strategy.</span>
<span class="comment-copy">Much better :) Looks less impressive than nesting but makes a whole lot more sense!</span>
<span class="comment-copy">No, you should use the <code>try ... except ... else</code> clause.</span>
<span class="comment-copy">That works too. Then you still have something that looks like nested exceptions though, which the poster was trying to avoid.</span>
