<div class="post-text" itemprop="text">
<p>I'm trying to automate regression testing for basic html websites using selenium-webdriver using python. I wrote a function that will take input from an excel to determine the type of locator of an element on the webpage which goes like this:</p>
<pre><code>            if locator_type == "ID":
                web_element = self.__driver.find_element_by_id(element)
            elif locator_type == "NAME":
                web_element = self.__driver.find_element_by_name(element)
            elif locator_type == "XPATH":
                web_element = self.__driver.find_element_by_xpath(element)
            elif locator_type == "TAG_NAME":
                web_element = self.__driver.find_element_by_tag_name(element)
            elif locator_type == "LINK_TEXT":
                web_element = self.__driver.find_element_by_link_text(element)
            elif locator_type == "CLASS_NAME":
                web_element = self.__driver.find_element_by_class_name(element)
            elif locator_type == "PARTIAL_LINK_TEXT":
                web_element = self.__driver.find_element_by_partial_link_text(element)
</code></pre>
<p>This is so that the we could specify the locator type and give actual locator('element') so that selenium could try to find the web element on the web-page. Is there any way to reduce the elif statements or any other better way to write this part? </p>
<p><a href="https://stackoverflow.com/questions/31748617/too-many-if-statements">Too many if statements</a></p>
<p>I tried the method in the above link but it didn't help me. Kindly help me resolve this.</p>
<p><strong>EDIT</strong>
I tried create a dict like this</p>
<pre><code>locator_dict = {
'ID' : driver.find_element_by_id(element),
'NAME' : driver.find_element_by_name(element)}
</code></pre>
<p>then i received an error saying that element is not defined</p>
</div>
<div class="post-text" itemprop="text">
<p>You can construct the name of the function to call from the <code>locator_type</code>, and then call it:</p>
<pre><code>locator_type_lower = locator_type.lower()

find_function_name = 'find_element_by_{}'.format(locator_type_lower)

driver_function_to_call = getattr(self.__driver, find_function_name)

web_element = driver_function_to_call(element)
</code></pre>
<p>You should probably wrap this in some error checking - check if the function exists, check if it's callable, etc. </p>
<p>What this does:
converts the locator_type to lowercase, then builds what is hopefully the function name of an existing function in self.__driver, then calls it with your element. </p>
<p>This method has the advantage that you don't have to map strings to functions - if <code>self.__driver</code> has a function called <code>find_element_by_foo_bar_length</code>, then you can simply add <code>FOO_BAR_LENGTH</code> into your excel spreadsheet, and it will get called, no need to update your mapping dict. </p>
<p>Edit: updated for comments</p>
<p>To translate locator_type string into an attribute of the <code>By</code> class:</p>
<pre><code>locator_type = 'ID'
element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((getattr(By, locator_type), element)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The only difference between the bodies of the various clauses is which method you actually call. You can factor that out into a <code>dict</code>.</p>
<pre><code>d = {
    "ID": self.__driver.find_element_by_id,
    "NAME": self.__driver.find_element_by_name,
    # etc
}

if locator_type in d:
    web_element = d[locator_type](element)
else:
    # do something if you haven't defined a method for locator_type
</code></pre>
<p>You can also use <code>methodcaller</code>, although this first attempt makes <code>d</code> depend on <code>element</code>:</p>
<pre><code>from operator import methodcaller

methods = [
    ("ID", "find_element_by_id"),
    ("NAME", "find_element_by_name"),
    # etc
]
d = { tag: methodcaller(method, element) for tag, method in methods } 

if locator_type in d:
    web_element = d[locator_type](self.__driver)
</code></pre>
<p>To be completely independent of the driver or the element, use</p>
<pre><code>d = dict(methods)
if locator_type in d:
    web_element = methodcaller(d[locator_type], element)(self.__driver)
</code></pre>
</div>
<span class="comment-copy">Can you elaborate on why the answer you linked did not help you? It seems like a dict would do a lot to alleviate the multiple <code>if</code> and <code>elif</code> blocks in your example code. Are you just having difficulty figuring out how to hash a function call? That is, how to store a function in a hash.</span>
<span class="comment-copy">@MikeHolt i'm not able to understand how hashing a function call could help? Kindly give me some insight on it.</span>
<span class="comment-copy">Sorry, my wording was a little sloppy. I was referring to storing (references to) functions as values in a hash (a.k.a. a dict in Python), exactly as shown in chepner's answer.</span>
<span class="comment-copy">Hey Danielle, is there any way we can implement this for the following statement? """ WebDriverWait(driver, 10).until(         EC.presence_of_element_located((By.ID, "myDynamicElement"))) """. I have tried the following way: <code>driver.get('https://www.google.com/') locator_type= 'NAME' element = 'q'  exp_wait_str = "WebDriverWait({}, 10).until(EC.presence_of_element_located((By.{}, {})))".format(driver, locator_type, element)  fun = getattr(driver, exp_wait_str) web_element = fun(locator_type, element)</code></span>
<span class="comment-copy">I'm trying to understand the concept but i'm not able use the method you suggested for the above statement. Kindly look into this.</span>
<span class="comment-copy">Hi there! What you're trying to do is dynamically pull the locator_type from the By class. I'll update my answer above with how to do that.</span>
<span class="comment-copy">Thank you very much Danielle, it worked like a charm and you helped remove more than 30 lines of repetitve code.</span>
<span class="comment-copy">Thank you very much for clearing this up, i'll try this and update you.</span>
<span class="comment-copy">It's working , but a small question.. the driver object needs to be instantiated before calling the dictionary?</span>
<span class="comment-copy">As shown here, yes. I'll add a solution using <code>methodcaller</code>, which I omitted because it looks a bit more complicated, but makes <code>d</code> independent of the driver.</span>
<span class="comment-copy">Thanks chepner, that solved the problem</span>
<span class="comment-copy">chepner, can you help once more? How do i make method caller for explicit wait function in selenium. Example: """ WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, "myDynamicElement"))) """</span>
