<div class="post-text" itemprop="text">
<p>I have a class which is essentially a collection/list of things. But I want to add some extra functions to this list. What I would like, is the following: </p>
<ul>
<li>I have an instance <code>li = MyFancyList()</code>. Variable <code>li</code> should behave as it was a list whenever I use it as a list: <code>[e for e in li]</code>, <code>li.expand(...)</code>, <code>for e in li</code>. </li>
<li>Plus it should have some special functions like <code>li.fancyPrint()</code>, <code>li.getAMetric()</code>, <code>li.getName()</code>.</li>
</ul>
<p>I currently use the following approach:</p>
<pre><code>class MyFancyList:
  def __iter__(self): 
    return self.li 
  def fancyFunc(self):
    # do something fancy
</code></pre>
<p>This is ok for usage as iterator like <code>[e for e in li]</code>, but I do not have the full list behavior like <code>li.expand(...)</code>.</p>
<p>A first guess is to inherit <code>list</code> into <code>MyFancyList</code>. But is that the recommended pythonic way to do? If yes, what is to consider? If no, what would be a better approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want only part of the list behavior, use composition (i.e. your instances hold a reference to an actual list) and implement only the methods necessary for the behavior you desire. These methods should delegate the work to the actual list any instance of your class holds a reference to, for example:</p>
<pre><code>def __getitem__(self, item):
    return self.li[item] # delegate to li.__getitem__
</code></pre>
<p>Implementing <code>__getitem__</code> alone will give you a surprising amount of features, for example iteration and slicing.</p>
<pre><code>&gt;&gt;&gt; class WrappedList:
...     def __init__(self, lst):
...         self._lst = lst
...     def __getitem__(self, item):
...         return self._lst[item]
... 
&gt;&gt;&gt; w = WrappedList([1, 2, 3])
&gt;&gt;&gt; for x in w:
...     x
... 
1
2
3
&gt;&gt;&gt; w[1:]
[2, 3]
</code></pre>
<p>If you want the <em>full</em> behavior of a list, inherit from <a href="https://docs.python.org/3.2/library/collections.html#collections.UserList"><code>collections.UserList</code></a>. <code>UserList</code> is a full Python implementation of the list datatype. </p>
<p><em>So why not inherit from <code>list</code> directly?</em></p>
<p>One major problem with inheriting directly from <code>list</code> (or any other builtin written in C) is that the code of the builtins may or may not call special methods overridden in classes defined by the user. Here's a relevant excerpt from the <a href="http://pypy.readthedocs.org/en/latest/cpython_differences.html#subclasses-of-built-in-types">pypy docs</a>:</p>
<blockquote>
<p>Officially, CPython has no rule at all for when exactly overridden method of subclasses of built-in types get implicitly called or not. As an approximation, these methods are never called by other built-in methods of the same object. For example, an overridden <code>__getitem__</code> in a subclass of dict will not be called by e.g. the built-in <code>get</code> method.</p>
</blockquote>
<p>Another quote, from Luciano Ramalho's <a href="http://shop.oreilly.com/product/0636920032519.do">Fluent Python</a>, page 351:</p>
<blockquote>
<p>Subclassing built-in types like dict or list or str directly is error-
  prone because the built-in methods mostly ignore user-defined
  overrides. Instead of subclassing the built-ins, derive your classes
  from UserDict , UserList and UserString from the collections
  module, which are designed to be easily extended.</p>
</blockquote>
<p>... and more, page 370+:</p>
<blockquote>
<p>Misbehaving built-ins: bug or feature?
  The built-in dict , list and str types are essential building blocks of Python itself, so
  they must be fast — any performance issues in them would severely impact pretty much
  everything else. That’s why CPython adopted the shortcuts that cause their built-in
  methods to misbehave by not cooperating with methods overridden by subclasses.</p>
</blockquote>
<p>After playing around a bit, the issues with the <code>list</code> builtin seem to be less critical (I tried to break it in Python 3.4 for a while but did not find a really obvious unexpected behavior), but I still wanted to post a demonstration of what can happen in principle, so here's one with a <code>dict</code> and a <code>UserDict</code>:</p>
<pre><code>&gt;&gt;&gt; class MyDict(dict):
...     def __setitem__(self, key, value):
...         super().__setitem__(key, [value])
... 
&gt;&gt;&gt; d = MyDict(a=1)
&gt;&gt;&gt; d
{'a': 1}

&gt;&gt;&gt; class MyUserDict(UserDict):
...     def __setitem__(self, key, value):
...         super().__setitem__(key, [value])
... 
&gt;&gt;&gt; m = MyUserDict(a=1)
&gt;&gt;&gt; m
{'a': [1]}
</code></pre>
<p>As you can see, the <code>__init__</code> method from <code>dict</code> ignored the overridden <code>__setitem__</code> method, while the <code>__init__</code> method from our <code>UserDict</code> did not.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest solution here is to inherit from <code>list</code> class:</p>
<pre><code>class MyFancyList(list):
    def fancyFunc(self):
        # do something fancy
</code></pre>
<p>You can then use <code>MyFancyList</code> type as a list, and use its specific methods.</p>
<p>Inheritance introduces a strong coupling between your object and <code>list</code>. The approach you implement is basically a proxy object.
The way to use heavily depends of the way you will use the object. If it have to <strong>be</strong> a list, then inheritance is probably a good choice.</p>
<hr/>
<p>EDIT: as pointed out by @acdr, some methods returning list copy should be overriden in order to return a <code>MyFancyList</code> instead a <code>list</code>.</p>
<p>A simple way to implement that:</p>
<pre><code>class MyFancyList(list):
    def fancyFunc(self):
        # do something fancy
    def __add__(self, *args, **kwargs):
        return MyFancyList(super().__add__(*args, **kwargs))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to redefine every method of <code>list</code>, I suggest you the following approach:</p>
<pre><code>class MyList:
  def __init__(self, list_):
    self.li = list_
  def __getattr__(self, method):
    return getattr(self.li, method)
</code></pre>
<p>This would make methods like <code>append</code>, <code>extend</code> and so on, work out of the box. Beware, however, that magic methods (e.g. <code>__len__</code>, <code>__getitem__</code> etc.) are not going to work in this case, so you should at least redeclare them like this:</p>
<pre><code>class MyList:
  def __init__(self, list_):
    self.li = list_
  def __getattr__(self, method):
    return getattr(self.li, method)
  def __len__(self):
    return len(self.li)
  def __getitem__(self, item):
    return self.li[item]
  def fancyPrint(self):
    # do whatever you want...
</code></pre>
<p>Please note, that in this case if you want to override a method of <code>list</code> (<code>extend</code>, for instance), you can just declare your own so that the call won't pass through the <code>__getattr__</code> method. For instance:</p>
<pre><code>class MyList:
  def __init__(self, list_):
    self.li = list_
  def __getattr__(self, method):
    return getattr(self.li, method)
  def __len__(self):
    return len(self.li)
  def __getitem__(self, item):
    return self.li[item]
  def fancyPrint(self):
    # do whatever you want...
  def extend(self, list_):
    # your own version of extend
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on the two example methods you included in your post (<code>fancyPrint</code>, <code>findAMetric</code>), it doesn't seem that you need to store any extra <em>state</em> in your lists. If this is the case, you're best off simple declaring these as free functions and ignoring subtyping altogether; this completely avoids problems like <code>list</code> vs <code>UserList</code>, fragile edge cases like return types for <code>__add__</code>, unexpected Liskov issues, &amp;c. Instead, you can write your functions, write your unit tests for their output, and rest assured that everything will work exactly as intended.</p>
<p>As an added benefit, this means your functions will work with <em>any</em> iterable types (such as generator expressions) without any extra effort.</p>
</div>
<span class="comment-copy">You have 2 options: 1) add a list to class and simulate all the behaviour (or the part that you require) of a <code>list</code> externally, which is tedious 2) inherit from <code>list</code>. Most of the times the 2) one will be the way to go.</span>
<span class="comment-copy">@imaluengo or 3) use an <a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow noreferrer">abstract base class</a></span>
<span class="comment-copy">I see 4 close requests. Why is that? Sometimes I do not understand Stack Overflow... :-S</span>
<span class="comment-copy">Could you maybe explain why you would use <code>collections.UserList</code> and not <code>collections.abc.MutableSequence</code> or <code>collections.abc.Sequence</code>. I never know myself.</span>
<span class="comment-copy">@Gary: If you want the things that <code>list</code> does that aren't part of the <code>Sequence</code> and <code>MutableSequence</code> interface, then use <code>UserList</code>. For example <code>collections.UserList</code> provides lexical ordering like <code>list</code> does, but <code>collections.abc.Sequence</code> and <code>MutableSequence</code> don't, because comparison isn't part of the collections interfaces. Another example is <code>__add__</code> (although <code>MutableSequence</code> has <code>__iadd__</code>).</span>
<span class="comment-copy">For an example with <code>list</code> you could take, for example, a redefinition of <code>__add__</code> to allow <code>+</code> and show that <code>+=</code> doesn't use that method but requires that you esplicitly redefine <code>__iadd__</code>.  Or even more subtle: <code>[1] + my_list</code> requries <code>__radd__</code> to produce the correct result.</span>
<span class="comment-copy">@Gary: If you want to attach arbitrary metadata to a list.  For instance: <code>from collections import UserList; class metalist(UserList):   pass; myList = metalist(); myList.x = 7;</code></span>
<span class="comment-copy">@eadsjr creating the <code>metalist</code> class is redudant, you can set attributes on instances of <code>UserList</code>.</span>
<span class="comment-copy">Just remember that you may want to over-ride some methods that return copies of the list. E.g. in this case, <code>lst = MyFancyList()</code>, <code>lst + [1,2,3]</code> will return a plain list, rather than a fancy list. You'll need to override the <code>__add__</code> method for this to work.</span>
<span class="comment-copy">As the other answer points out, directly inheriting from <code>list</code> has its pitfalls. So I think after all, this is not a good answer to the question why I issued a downvote.</span>
<span class="comment-copy">This is fine as long as you inherit every single magic method.  Personally, I would recommend never to do this.  Inherit <code>Mapping</code> or <code>MutableMapping</code> or <code>UserDict</code>.</span>
<span class="comment-copy">It is true that the example functions were not choosen very wisely. In fact, the list-class actually has state associated to the object, a name for example.</span>
<span class="comment-copy">@Michael well that clears that :p I would have simply posed this as a question in a comment, but unfortunately I don't have enough rep to comment on this SE.</span>
