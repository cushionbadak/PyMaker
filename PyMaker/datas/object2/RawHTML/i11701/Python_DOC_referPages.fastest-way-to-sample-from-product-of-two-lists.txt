<div class="post-text" itemprop="text">
<p>I'd like to get <em>n</em> samples (without replacement) from the product of two lists. As shown below, I'm currently computing the entire product and then sampling from it, but this gets computationally unwieldy for long lists. Is there a way to optimize this process? That is, not having to compute the entire product but sampling more effectively?</p>
<p>Current naive approach (erroneously sampling with replacement, as noted below):</p>
<pre><code>from itertools import product
from random import choice

def get_sample(a,b,n):
"""return n samples from the product a and b"""
  D = list(product(a,b))
  D = [choice(D) for _ in range(n)]

  return D
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be fine if you just don't actually <strong>use <code>list</code></strong> if you don't <em>want</em> a <code>list</code>; a non-random sample can be found by</p>
<pre><code>from itertools import product

def get_first_n_sample(a,b,n):
"""return n samples from the product a and b"""
  D = product(a,b)
  D = [D.next() for _ in range(n)] ## if you're on Python2, use xrange!
  return D
</code></pre>
<p>now, if you just want random samples from some combinations of <code>a</code> and <code>b</code>, an iterator is clearly not the right approach, and hence, <code>itertools</code> aren't, either. Assuming <code>a</code> and <code>b</code> are fast on random access (e.g. <code>list</code>s, <code>tuple</code>s):</p>
<pre><code>from random import choice

def get_random_sample(a, b):
    return (choice(a), choice(b))
</code></pre>
<p>getting <code>n</code> <em>unique</em> samples is more complicated, though:</p>
<pre><code>from random import sample

def get_random_samples(a, b, n):
    n_prod = len(a) * len(b)
    indices = sample(range(n_prod), n)
    return [(a[idx % len(a)], b[idx // len(a)]) for idx in indices]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a sample with replacement, the way your code currently does it, you can take random elements of <code>product(a, b)</code> with <code>(choice(a), choice(b)</code>:</p>
<pre><code>sample = [(choice(a), choice(b)) for _ in xrange(n)]
</code></pre>
<p>If you want a sample without replacement, make a sample of random pairs of indices:</p>
<pre><code>sample = [(a[i // len(b)], b[i % len(b)])
          for i in random.sample(xrange(len(a)*len(b)), n)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately you cannot take a random sample from an iterator. An iterator (like <code>product</code>) means you know only 1 value at a time and you must know more than 1 value in order to provide randomness.</p>
<p>The naive approach can be more efficient though with <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow"><code>random.sample()</code></a> like so:</p>
<pre><code>from itertools import product
import random
def get_sample(a,b,n):
"""return n samples from the product a and b"""
  D = list(product(a,b))
  return random.sample(D, n)
</code></pre>
</div>
<span class="comment-copy">You've written a sample with replacement - i.e., your code can pick the same element twice. Is this deliberate? <code>random.sample</code> is a sample without replacement.</span>
<span class="comment-copy">Unless there's something your code is meant to do but isn't doing right now, this is the same as sampling from <code>a</code> and then sampling from <code>b</code> <code>n</code> times.  Right now, there's no need to materialize <code>D</code> at all.</span>
<span class="comment-copy">On replacement: That's a really good point. Sorry, I meant to sample without replacement.  @DSM: That's actually a very good idea and seems to be in line with what others are suggesting</span>
<span class="comment-copy">@Unayko: It only works for a sample with replacement, though. For a sample without replacement, the fact that you have to track duplicate <i>pairs</i> means that sampling from <code>a</code> and <code>b</code> separately will do the wrong thing.</span>
<span class="comment-copy">@Unayko: yeah, if you're sampling without replacement, you have to keep track of what you've already sampled (whether explicitly or implicitly.) Now that you've clarified that your code didn't do what you want, this entire comment thread is obsolete. :-)</span>
<span class="comment-copy">The <code>/</code> instead of <code>//</code> will cause problems in 3.</span>
<span class="comment-copy">@DSM true. will fix</span>
<span class="comment-copy">This is nice. Shouldn't  <i>a,b = a*n, b*n</i> before n_prod? Otherwise, if element <i>a[i]</i> is sampled once, it can't be sampled again. In contrast, if I computed the lists' product I'd have <i>n</i> pairs where <i>a[i]</i>  is the first element (conversely for all <i>b[i]</i>). Or am I missing something?</span>
