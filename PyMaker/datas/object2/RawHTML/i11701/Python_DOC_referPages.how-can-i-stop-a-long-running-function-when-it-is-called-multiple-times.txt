<div class="post-text" itemprop="text">
<p>Below I have an example program. When the button is pressed, it takes a second before it can calculate the value to show. If the user presses the button in rapid succession they end up waiting a long time to see the last answer, which is the only answer they care about. In the code, you can see that the <code>_dataCruncher</code> function needs to know <code>self._count</code>, but <code>self._count</code> does not depend on the output of <code>_dataCruncher</code>.</p>
<p>My question, therefore, is how can I interrupt the normal execution of <code>_dataCruncher</code> on subsequent calls in order to keep the GUI free to do other stuff, and to not waste processing time when it is not needed? I realize that I will likely need to use a thread to run <code>_dataCruncher</code> and some sort of Queue to get the appropriate <code>val</code> to display, but I do not understand how to put this all together.</p>
<pre><code>from PyQt4 import QtGui, QtCore
import sys
import time
import random
import random

class MainWindow(QtGui.QMainWindow):
    def __init__(self):
        self.app = QtGui.QApplication(sys.argv)
        super(MainWindow, self).__init__()
        self.count = 0
        self.initUI()

    def initUI(self):
        # Layouts
        central = QtGui.QWidget()
        layout = QtGui.QVBoxLayout()

        self.button = QtGui.QPushButton('Press Me')
        self.text = QtGui.QLabel('?')

        layout.addWidget(self.button)
        layout.addWidget(self.text)

        central.setLayout(layout)
        self.setCentralWidget(central)

        self.button.clicked.connect(self._buttonClicked)

    def _dataCruncher(self, val):
        time.sleep(1) # takes a long time to process data using val
        return val * random.randint(1,10)

    def _buttonClicked(self):
        self.count += 1
        val = self._dataCruncher(self.count)
        self.text.setText('Value {}'.format(val))

    def startup(self):
        self.show()
        result = self.app.exec_()
        sys.exit(result)

if __name__ == '__main__':
    random.seed()
    myWindow = MainWindow()
    myWindow.startup()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So, finding an answer to this was more complicated than I thought. As @MTset mentions in one of the comments, python does not offer any means by which to cancel the execution of a Thread. So, what I did was create a 'threadHandler' class that, well, handles thread. It keeps track of the last thread that was created and offers a means by which to get the result from the execution of the last thread.</p>
<p>I am posting an modified version of the test code from the original post as well as the threadHandler code in full in case anyone has use for it.</p>
<p>File 1 here</p>
<pre><code># tester.py, run this file

from PyQt4 import QtGui, QtCore
import random, sys, time
from threadHandler import MyThreadHandler

class MyModel(object):
    def dataCruncher(self, val):
        delay = random.randint(1,5)
        print('{} sleeping for {}'.format(val, delay))
        time.sleep(delay) # takes a long time to process data using val
        print('{} done sleeping'.format(val))
        return val

class MainWindow(QtGui.QMainWindow):
    def __init__(self, threadHandler):
        self.app = QtGui.QApplication(sys.argv)
        super(MainWindow, self).__init__()
        self.count = 0
        self.initUI()
        self.button_clicked_events = Event()
        self.threadHandler = threadHandler

    def initUI(self):
        # Layouts
        central = QtGui.QWidget()
        layout = QtGui.QVBoxLayout()

        self.button = QtGui.QPushButton('Press Me')
        self.text = QtGui.QLabel('?')

        layout.addWidget(self.button)
        layout.addWidget(self.text)

        central.setLayout(layout)
        self.setCentralWidget(central)

        self.button.clicked.connect(self._buttonClicked)

    def _buttonClicked(self):
        self.count += 1
        self.button_clicked_events(self.count)

    def setLabel(self, val):
        self.text.setText(str(val))

    def startup(self):
        self.show()
        result = self.app.exec_()
        return result


class Event(list):
    """Event subscription.

    A list of callable objects. Calling an instance of this will cause a
    call to each item in the list in ascending order by index.

    Example Usage:
    &gt;&gt;&gt; def f(x):
    ...     print 'f(%s)' % x
    &gt;&gt;&gt; def g(x):
    ...     print 'g(%s)' % x
    &gt;&gt;&gt; e = Event()
    &gt;&gt;&gt; e()
    &gt;&gt;&gt; e.append(f)
    &gt;&gt;&gt; e(123)
    f(123)
    &gt;&gt;&gt; e.remove(f)
    &gt;&gt;&gt; e()
    &gt;&gt;&gt; e += (f, g)
    &gt;&gt;&gt; e(10)
    f(10)
    g(10)
    &gt;&gt;&gt; del e[0]
    &gt;&gt;&gt; e(2)
    g(2)

    """
    def __init__(self):
        self.output = {}

    def __call__(self, *args, **kwargs):
        for f,key in self:
            output = f(*args, **kwargs)
            self.output[key] = output
        return self.output
    def __repr__(self):
        return "Event({})".format(list.__repr__(self))

if __name__ == '__main__':
    def checker(handler, window):
        if handler.isLastDone():
            val = handler.getLastResult()
            window.setLabel(val)
        else:
            window.setLabel('calculating...')

    random.seed()
    model = MyModel()
    threadHandler = MyThreadHandler()
    myWindow = MainWindow(threadHandler)

    threadHandler.createTimer(1, checker, threadHandler, myWindow)

    def getData(count):
        threadHandler.createOneShot(model.dataCruncher, count)

    myWindow.button_clicked_events.append((getData, 'dt'))

    result = myWindow.startup()
    print('ending')
    threadHandler.end()
    print('ended')
    sys.exit(result)
</code></pre>
<p>File 2 below</p>
<pre><code>#threadHandler.py, save this file in the same folder as tester.py

import threading, time

class MyThreadHandler(object):
    def __init__(self):
        self.oneShots = []
        self.timers = []
        self.oldOneShots = []
        self.latest = None
        self.cleaning = False

        self._startCleaner()

    def _startCleaner(self):
        print('-'*20+'Starting cleaner'+'-'*20)
        self.cleaner = self.createTimer(1, self._cleanupThreads)

    def _stopCleaner(self):
        print('-'*20+'Stopping cleaner'+'-'*20)
        self.cleaner.stop()

    def getNumThreads(self):
        return len(self.oneShots)

    def getNumOldThreads(self):
        return len(self.oldOneShots)

    def end(self):
        for i,timer in enumerate(self.timers):
            timer.stop()
            self.timers.pop(i)

    def createTimer(self, interval, func, *args, **kwargs):
        timer = myTimer(interval, func, args, kwargs)
        self.timers.append(timer)
        return timer

    def createOneShot(self, func, *args, **kwargs):
        oneshot = myOneShot(func, args, kwargs)
        self.oneShots.append(oneshot)
        self.latest = oneshot

    def isLastDone(self):
        if not self.latest is None:
            return not self.latest.running()
        else:
            return None

    def getLastResult(self):
        if self.latest is None:
            raise ValueError('There have not been any oneshots created.')
        while self.latest.running():
            pass
        result = self.latest.getResult()
        if len(self.oneShots) &gt; 0:
            self.oldOneShots.append(myOneShot(self._cleanAll, (self.oneShots,)))
        self.oneShots = []
        return result

    def _cleanAll(self, toClean):
        # loop through toClean and pop up anything that's done. this DOES lock
        while len(toClean) &gt; 0:
            toClean = self._cleanup(toClean)

    def _cleanup(self, toCleanup):
        while not self.cleaning:
            self.cleaning = True
            for i, thread in enumerate(toCleanup):
                if not thread.running():
                    toCleanup.pop(i)
        self.cleaning = False
        return toCleanup

    def _cleanupThreads(self):
        # check each of these lists and pop out any threads that are done. This
        # does not lock. This function should really only be called by the
        # cleaner, which is set up in __init__
        self.oneShots = self._cleanup(self.oneShots)
        self.timers = self._cleanup(self.timers)
        self.oldOneShots = self._cleanup(self.oldOneShots)

class myTimer(object):
    def __init__(self, delay, func, args=tuple(), kwargs={}):
        self.delay  = delay
        self.func   = func
        self.loop   = True
        self.args   = args
        self.kwargs = kwargs
        self.thread = threading.Thread(target=self.run, daemon=True)
        self.thread.start()
        self.output = None

    def run(self):
        while self.loop:
            self.output = self.func(*self.args, **self.kwargs)
            if self.delay &gt; 0.1:
                count = 0
                while count &lt;= self.delay:
                    count += 0.1
                    time.sleep(0.1)
            else:
                time.sleep(self.delay)

    def stop(self):
        self.loop = False

    def running(self):
        return self.loop

    def getResult(self):
        return self.output

class myOneShot(object):
    def __init__(self, func, args=tuple(), kwargs={}):
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.thread = threading.Thread(target=self.run, daemon=True)
        self.thread.start()
        self.output = None

    def run(self):
        self.output = self.func(*self.args, **self.kwargs)

    def running(self):
        return self.thread.is_alive()

    def getResult(self):
        return self.output

if __name__ == '__main__':
    import random
    random.seed()

    def longFunc(num):
        delay = random.randint(5,8)
        if num in (3, 6):
            delay = 2
        print('-'*30+'func {} has sleep {}'.format(num, delay))
        time.sleep(delay)
        print('-'*30+'func {} is done'.format(num))
        return num

    def checker(handler):
        if handler.isLastDone():
            return handler.getLastResult()
        else:
            return None

    myHandler = MyThreadHandler()

    # The 'checker' function simulates something in my program that uses the
    # data generated by the 'longFunc'. It waits until there are no more threads
    # in the threadHandler, as that would indicate that the user is done
    # switching back-and-forth between different values
    checkTimer = myHandler.createTimer(1, checker, myHandler)

    # create 10 one-shot threads that take a 'long' time. The delay is to keep
    # them in order, as this loop is meant to simulate a user switching between
    # items using a keyboard or mouse, which I imagine they couldn't do any
    # faster than every 1/10th of a second
    start = time.time()
    for i in range(4):
        myHandler.createOneShot(longFunc, i)
        time.sleep(0.1)

    # wait until there are no more threads executing
    last = myHandler.getLastResult()

    print('result from last = {}'.format(last))

    for i in range(4, 7):
        myHandler.createOneShot(longFunc, i)
        time.sleep(0.1)

    last = myHandler.getLastResult()
    print('result from last = {}'.format(last))

    while myHandler.getNumOldThreads() &gt;0 or myHandler.getNumThreads() &gt; 0:
        pass

    myHandler.end()
    print('done ending')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could disable the button after it's pressed until an answer is ready using:
    setEnabled(False)
Then reset it just before providing the result.</p>
</div>
<span class="comment-copy">perhaps I need to reword my question. the user wants the latest answer, so if the button is disabled while an answer is being processed, the user would want to interrupt that processing in order to calculate a different value</span>
<span class="comment-copy">As far as I can tell from <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">docs.python.org/3/library/threading.html</a> '...Python’s Thread class supports a subset of the behavior of Java’s Thread class; currently, there are no priorities, no thread groups, and threads cannot be destroyed, stopped, suspended, resumed, or interrupted...'  Possibly need another solution than multithreading.</span>
<span class="comment-copy">You may also want to have a look at this, which specifically uses QThread: <a href="https://nikolak.com/pyqt-threading-tutorial/" rel="nofollow noreferrer">nikolak.com/pyqt-threading-tutorial</a></span>
