<div class="post-text" itemprop="text">
<p>I want to create a countdown timer that counts down from 60 minutes until it hits 0. I don't need it to be exactly accurate. Just within like 10-15 seconds. Is time.sleep the correct task for the job?</p>
<pre><code>while(hour + minute != 0):

        if minute == 0:
                minute = 59
                hour = hour - 1
        else:
                minute = minute - 1
        time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you're overcomplicating this by making a distinction between minutes and seconds. Use a base unit (seconds), then loop backwards over the total and apply the delay there, eg:</p>
<pre><code>for remaining in range(60 * 60, 0, -1):
    mins, secs = divmod(remaining, 60)
    # Probably do something other than print that should take a 
    # trivial amount of time... if it takes 10 seconds then things
    # will start to look weird
    print('{}mins and {}secs remaining'.format(mins, secs))
    time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, <code>time.sleep()</code> does not provide reliable times. It can sleep to short if any kind of signal interrupts the sleep, but it can also be longer depending on your system load.</p>
<p>I would recommend you to store the current time when you start the countdown using e.g. <code>time.time()</code> (returns current time as floating point decimal in seconds since epoch):</p>
<pre class="lang-py prettyprint-override"><code>start_time = time.time() 
</code></pre>
<p>Then compute the time (also in seconds since epoch of course) when the countdown will be over:</p>
<pre class="lang-py prettyprint-override"><code>target_time = start_time + (hours * 60 + minutes) * 60 + seconds
</code></pre>
<p>Now you can start the <code>while</code> loop which checks whether the current time is lower than the <code>target_time</code>. If that's the case, you can use <code>time.sleep(RESOLUTION)</code> to save CPU time. Your countdown will be as exact as you chose <code>RESOLUTION</code>: the time it's running is always greater or equal to the desired time, but lower than the desired time plus <code>RESOLUTION</code>. I would chose a value between 0.1 and 1 seconds.</p>
<p>Here's the full code:</p>
<pre class="lang-py prettyprint-override"><code>start_time = time.time() 
target_time = start_time + (hours * 60 + minutes) * 60 + seconds

while target_time &lt; time.time():

    # do something, e.g. print the remaining time:
    remaining_time = target_time - time.time()
    print("Countdown: {}h {}min {}s remaining".format(
            remaining_time // 3600, remaining_time // 60, remaining_time % 60))

    # sleep a bit to save CPU resources
    time.sleep(0.5)
</code></pre>
<p>The advantage is that even if the system is highly loaded or the things you do inside the while loop take very long, the countdown still stays pretty accurate.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simple way is to use divmod. Idea is to reduce the counter after a second using sleep for 1 sec.</p>
<pre><code>def counter(total_seconds):
    for rem in range(total_seconds, 0, -1):
        mins, secs = divmod(rem, 60)
        print('{}mins and {}secs remaining'.format(mins, secs))
        time.sleep(1)
</code></pre>
</div>
<span class="comment-copy"><code>time.sleep</code> is ok for pausing the script, but otherwise it is very load-dependent. Better use something based on system time, i.e. <code>time.localtime()</code>.</span>
<span class="comment-copy">Umm... presumably it does something other than just the equivalent of <code>time.sleep(60 * 60)</code> otherwise you'd use that, right?</span>
<span class="comment-copy">If you want to go down this style of route, then you might as well build on <a href="https://docs.python.org/3/library/sched.html" rel="nofollow noreferrer">docs.python.org/3/library/sched.html</a></span>
