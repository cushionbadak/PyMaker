<div class="post-text" itemprop="text">
<p>I'm running a Python script which iterates two huge lists and finds the matching pairs.</p>
<p>However, it seems to take forever. How to speed up this script?</p>
<pre><code>import sys
import random
import itertools

def main(args):
    target_num = int(999999999)
    num_list = range(1, target_num)
    rand_list = []
    hit_list = []

    for _ in itertools.repeat(None, target_num):
        rand_list.append(random.randint(1, target_num))

    for num in num_list:
        for rand_num in rand_list:
            if num == rand_num:
                print "hit"

if __name__ == "__main__":
    main(sys.argv[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use sets</p>
<pre><code>import sys
import random
import itertools

def main(args):
    target_num = int(999999999)
    num_list = set(range(1, target_num))
    rand_list = []
    hit_list = []

    for _ in itertools.repeat(None, target_num):
        rand_list.append(random.randint(1, target_num))


    for num in rand_list:
        if num in num_list: # O(1)
            print "hit"

if __name__ == "__main__":
    main(sys.argv[1:])
</code></pre>
<p>Using a set for the first list, means that checking if the item is in that list is now reduced to an O(1)</p>
<hr/>
<p>As I am writing this, I realise you can even do better. The <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow"><strong>range</strong></a> function in python 3 returns a sequence, so you need python 3 for this next part</p>
<pre><code>import sys
import random
import itertools

def main(args):
    target_num = int(999999999)
    num_list = range(1, target_num) # this is a generator
    rand_list = []
    hit_list = []

    for _ in itertools.repeat(None, target_num):
        rand_list.append(random.randint(1, target_num))


    for num in rand_list:
        if num in num_list: # Stil O(1)
            print ("hit")

if __name__ == "__main__":
    main(sys.argv[1:])
</code></pre>
<p>Even better, using range and do the checking within the first loop?</p>
<pre><code>for _ in itertools.repeat(None, target_num):
    rand_num = random.randint(1, target_num)
    rand_list.append(rand_num)
    if rand_num in num_list:
        print ("hit")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If using Python 2, use xrange(), which returns a generator-like object.</p>
<pre><code># requires Python 2
import random

target_num = 99 # 999999999 are too much items for testing

# target_num random numbers in range 1 .. target_num-1
random_numbers = set(random.randint(1, target_num) for _ in xrange(target_num)) 

hits = set()
for num in xrange(1, target_num):  # check for all numbers in range 1 .. target_num-1
    if num in random_numbers:   # num in set() is O(1)
        hits.add(num)

if len(random_numbers - hits) == 0:
     print "all random numbers are hits!"

# so:
for num in random_numbers:
    print num
# is the same result
</code></pre>
</div>
<span class="comment-copy">Try not to use built-in names as variable names in your code, it has the potential to cause frustration. By this I am referring to your use of <code>list</code> as a variable name</span>
<span class="comment-copy">@Smac89 I was in a hurry to write a question, and made a mistake. I modified the variable name.</span>
<span class="comment-copy">Is that second nested loop supposed to be <code>read_list</code> or <code>rand_list</code>?</span>
<span class="comment-copy">@Smac89 It is supposed to be rand_list. Sorry for the confusion.</span>
<span class="comment-copy">Also consider a list comprehension (<code>rand_list = [random.randint(1, target_num) for _ in itertools.repeat(None, target_num)]</code>). They are more efficient than using for loops as you donâ€™t need to load the append attribute off of the list and call it as a function.</span>
<span class="comment-copy"><code>O(1)</code> membership testing is not a feature of <code>xrange</code>, it was only added to <code>range</code> in <a href="https://docs.python.org/3/library/stdtypes.html#range" rel="nofollow noreferrer">Python 3.2 when they finally finished implementing the Sequence ABC for <code>range</code></a>. <code>xrange</code> membership testing generates and tests values one at a time until it gets a hit. Also, neither <code>range</code> nor <code>xrange</code> are generators; they're more or less Sequence objects that can produce iterators, not iterators/generators themselves; if they were generators, iterating them once would exhaust them, but that's not how they behave.</span>
<span class="comment-copy">@ShadowRanger Yup you're right</span>
