<div class="post-text" itemprop="text">
<p>My problem could be summarised by the following example:</p>
<pre><code>from enum import Enum
import json

class FooBarType(Enum):
    standard = 0
    foo = 1
    bar = 2

dict = {'name': 'test', 'value': 'test', 'type': FooBarType.foo}

json.dumps(dict)

TypeError: &lt;FooBarType.foo: 1&gt; is not JSON serializable
</code></pre>
<p>I get a type error, because enums are not JSON serializable.</p>
<p>I primarily though of implementing a <code>JsonEncoder</code> and adding it to the <code>json.dumps()</code> call but I cannot change the line where <code>json.dumps()</code> call is made.</p>
<p><strong>So, my question is :</strong> 
Is it possible to dump an enum in json without passing an encoder to <code>json.dumps()</code>, but instead, by adding class method(s) in <code>FooBarType</code> enum ?</p>
<p>I expect to extract the following json:</p>
<pre><code>{'name': 'test', 'value': 'test', 'type': 'foo'}
</code></pre>
<p>or</p>
<pre><code>{'name': 'test', 'value': 'test', 'type': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there is a great way for this and you will loose features of the Enum.</p>
<p>Simplest option: Don't subclass Enum:</p>
<pre><code>class FooBarType:
    standard = 0
    foo = 1
    bar = 2

dict = {'type': FooBarType.foo}
json.dumps(dict)
</code></pre>
<p>What you could also do:</p>
<pre><code>class EnumIntValue(int):
    def __new__(cls, name, value):
        c = int.__new__(cls, int(value))
        c.name = name
        return c
    def __repr__(self):
        return self.name
    def __str__(self):
        return self.name

class FooBarType:
    standard = EnumIntValue('standard',0)
    foo = EnumIntValue('foo',0)
    bar = EnumIntValue('bar',2)

dict = {'type': FooBarType.foo}
json.dumps(dict)
</code></pre>
<p>This will actually give you </p>
<pre><code>{"type": foo}
</code></pre>
<p>And therefore not really be valid json, but you can play around with it to fit your needs!</p>
</div>
<div class="post-text" itemprop="text">
<p>Try:</p>
<pre><code>from enum import Enum

# class StrEnum(str, Enum):
#     """Enum where members are also (and must be) strs"""

class Color(str, Enum):
    RED = 'red'
    GREEN = 'green'
    BLUE = 'blue'


data = [
    {
        'name': 'car',
        'color': Color.RED,
    },
    {
        'name': 'dog',
        'color': Color.BLUE,
    },
]

import json
print(json.dumps(data))
</code></pre>
<p>Result:</p>
<pre><code>[
    {
        "name": "car",
        "color": "red"
    },
    {
        "name": "dog",
        "color": "blue"
    }
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sadly, there is no direct support for <code>Enum</code> in JSON.</p>
<p>The closest automatic support is to use <a href="https://docs.python.org/3/library/enum.html#enum.IntEnum" rel="nofollow"><code>IntEnum</code></a> (which <a href="https://pypi.python.org/pypi/enum34" rel="nofollow"><code>enum34</code></a> also supports), and then <code>json</code> will treat your <code>enum</code>s as <code>int</code>s; of course, decoding them will give you an <code>int</code> back, but that is as good it gets without specifying your encoder/decoder.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just adding method(s) to the <code>FooBarType</code> enum won't do what you want.</p>
<p>As I mentioned in my comment, you can however use part of my answer to the question <a href="https://stackoverflow.com/questions/18478287/making-object-json-serializable-with-regular-encoder">Making object JSON serializable with regular encoder</a> to monkey-patch the <code>json</code> module so it will return the name (or value) of <code>Enum</code> members. I'm assuming you're using the <a href="https://pypi.python.org/pypi/enum34/1.1.1" rel="nofollow noreferrer"><code>enums34</code></a> module by Ethan Furman et al, which was backported to Python 2.7 since that version doesn't come with it built-in — it became part of the <a href="https://docs.python.org/3/library/enum.html#module-enum" rel="nofollow noreferrer">standard library in Python 3.4</a>.</p>
<p>Note this will work even though you can't change the line where the <code>json.dumps()</code> call occurs as long as that happens <em>after</em> the patch is applied. This is because Python normally caches <code>import</code>ed modules in <code>sys.modules</code>, i.e. they aren't reloaded everytime they are used in separate scripts — so any changes made this to them are "sticky" and remain in effect.</p>
<p>So for what you want to do, first create your own module to make the patch. For example: <code>make_enum_json_serializable.py</code>.</p>
<pre><code>""" Module that monkey-patches the json module when it's imported so
JSONEncoder.default() automatically checks to see if the object being encoded
is an instance of an Enum type and, if so, returns its name.
"""
from enum import Enum
from json import JSONEncoder

_saved_default = JSONEncoder().default  # Save default method.

def _new_default(self, obj):
    if isinstance(obj, Enum):
        return obj.name  # Could also be obj.value
    else:
        return _saved_default

JSONEncoder.default = _new_default # Set new default method.
</code></pre>
<p>Then, in your own script, all you need to do is essentially add one line:</p>
<pre><code>from enum import Enum
import json
import make_enum_json_serializable  # ADDED

class FooBarType(Enum):
    standard = 0
    foo = 1
    bar = 2

a_dict = {'name': 'spam', 'value': 42, 'type': FooBarType.foo}

print(json.dumps(a_dict))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>{"type": "foo", "name": "spam", "value": 42}
</code></pre>
</div>
<span class="comment-copy">Even if you can't change the line where <code>json.dumps()</code> call is made you can monkeypatch the <code>dumps()</code> function in the <code>json</code> module after <code>import</code>ing it — which will then affect all uses of it from then on (in the script running). There's examples of patching the module in <a href="http://stackoverflow.com/questions/18478287/making-object-json-serializable-with-regular-encoder/18561055#18561055">this answer</a>,</span>
<span class="comment-copy">What do you want to output? Is it the enum "name" FooBarType.foo or is it the actual value "1" ?</span>
<span class="comment-copy">@NilsZiehn I prefer to get the enum name, but if it is not possible the corresponding value will be sufficient.</span>
<span class="comment-copy">Thanks Nils, your second suggestion seems to be the best answer ;)</span>
<span class="comment-copy">Very NICE! Thanks</span>
<span class="comment-copy">Nice.  Can you include the snippet for getting the enum back from the json?</span>
<span class="comment-copy">@Ethan: As it stands, I don't think there's any way to do that because of the information loss—the fact that the value originated from an <code>Enum</code> isn't preserved. Off-hand I don't know how it could be since the JSON standard only allows values to be a string, number, object, array, <b><code>true</code></b>, <b><code>false</code></b>, or <b><code>null</code></b>.</span>
<span class="comment-copy">@Ethan: The second part of <a href="http://stackoverflow.com/a/18561055/355230">my answer</a> to the question <a href="http://stackoverflow.com/questions/18478287/making-object-json-serializable-with-regular-encoder"><b><i>Making object JSON serializable with regular encoder</i></b></a> describes a way to store pickle data as the JSON value, which means the actual instance value and its type could be reconstructed. Note that it does require providing a custom <code>object_hook=</code> function argument on any <code>json.loads()</code> calls.</span>
<span class="comment-copy">Thanks.  I was looking for an easy way to make a json file that could be used to transfer data to other systems as well as back to Python, but I'm not seeing it.</span>
<span class="comment-copy">If going that route I'd just use <code>"EnumName.Member"</code> to make the parsing easier.  (And congrats on your badge. ;)</span>
