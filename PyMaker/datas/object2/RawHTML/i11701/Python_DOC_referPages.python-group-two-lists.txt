<div class="post-text" itemprop="text">
<p>I have two lists:</p>
<pre><code>             A = ['T', 'D', 'Q', 'D', 'D']
             sessionid = [1, 1, 1, 2, 2]
</code></pre>
<p>Is there anyway i could group items in A for the same sessionid, so that i could print out the following:</p>
<pre><code>              1: ["T", "D","Q"]
              2: ["D","D"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The itertools <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>groupby</code></a> function is designed to do this sort of thing. Some of the other answers here create a dictionary, which is very sensible, but if you don't actually want a <code>dict</code> then you can do this:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

A = ['T', 'D', 'Q', 'D', 'D']
sessionid = [1, 1, 1, 2, 2]    

for k, g in groupby(zip(sessionid, A), itemgetter(0)):
    print('{}: {}'.format(k, list(list(zip(*g))[1])))
</code></pre>
<p><strong>output</strong></p>
<pre><code>1: ['T', 'D', 'Q']
2: ['D', 'D']
</code></pre>
<p><a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow"><code>operator.itemgetter(0)</code></a> returns a callable that fetches the item at index 0 of whatever object you pass it; <code>groupby</code> uses this as the key function to determine what items can be grouped together.</p>
<p>Note that this and similar solutions assume that the <code>sessionid</code> indices are sorted. If they aren't then you need to sort the list of tuples returned by <code>zip(sessionid, A)</code> with the same key function before passing them to <code>groupby</code>.</p>
<hr/>
<p><strong>edited</strong> to work correctly on Python 2 and Python 3</p>
</div>
<div class="post-text" itemprop="text">
<p>Not using <code>itertools</code>, you can use a dictionary:</p>
<pre><code>index = 0
dict = {}
for i in sessionid:
    if not (i in dict):
        dict[i] = []
    else:
        dict[i].append(A[index])
    index += 1

print(dict) # {1: ['T', 'D', 'Q'], 2: ['D', 'D']}
</code></pre>
<p>And based on the remarks below:</p>
<pre><code>from collections import defaultdict
dict = defaultdict(list)
for i, item in enumerate(sessionid):
    dict[item].append(A[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary and <code>zip</code>:</p>
<pre><code>A = ['T', 'D', 'Q', 'D', 'D']
sessionid = [1, 1, 1, 2, 2]

result = {i:[] for i in sessionid}
for i,j in zip(sessionid,A):
    result[i].append(j)
</code></pre>
<p>Or you can use <code>defaultdict</code>:</p>
<pre><code>from collections import defaultdict
result = defaultdict(list)
for k, v in zip(sessionid, A):
   result[k].append(v)
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; result
{1: ['T', 'D', 'Q'], 2: ['D', 'D']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One liner</p>
<pre><code>{k: list(i for (i, _) in v) for k, v in itertools.groupby(zip(A, sessionid), operator.itemgetter(1))}
</code></pre>
<p>Without nested loop</p>
<pre><code>{k: list(map(operator.itemgetter(0), v)) for k, v in itertools.groupby(zip(A, sessionid), operator.itemgetter(1))}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>import pandas as pd

A = ['T', 'D', 'Q', 'D', 'D']
sessionid = [1, 1, 1, 2, 2]

pd.DataFrame({'A':A, 'id':sessionid}).groupby('id')['A'].apply(list).to_dict()

#Out[10]: {1: ['T', 'D', 'Q'], 2: ['D', 'D']}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also convert them into numpy arrays, and use the indices of the session ids you need with <code>np.where</code></p>
<pre><code>import numpy as np

A = np.asarray(['T', 'D', 'Q', 'D', 'D'])
sessionid = np.asarray([1, 1, 1, 2, 2])

Ind_1 = np.where(sessionid == 1)
Ind_2 = np.where(sessionid == 2)

print A[Ind_1]
</code></pre>
<p>should return  <code>['T' 'D' 'Q']</code></p>
<p>you could of course turn this into a function which takes N, the desired session and returns your A values.</p>
<p>Hope this helps!</p>
</div>
<span class="comment-copy">did you hear about <code>itertools.groupby</code>?</span>
<span class="comment-copy">thx for the code as i really dont want dict.  just testing ur code and it says "'zip' object is not subscriptable", any chance you know what happens?    i am using Python 3 on jupyter notebook</span>
<span class="comment-copy">thx!  now it working perfectly fine!</span>
<span class="comment-copy">actually it prints out the results in parenthesis  ("T", "D"), any chance i could print out the results in brackets (e.g: ["T","D"]      ) ?  thx!!!!!!</span>
<span class="comment-copy">thx again!!!!!!</span>
<span class="comment-copy">You could use <code>collections.defaultdict</code> to avoid the conditional check.</span>
<span class="comment-copy">You could use enumerate to avoid incrementing the index yourself.</span>
<span class="comment-copy">This overrides a keyword and includes unnecessary checks. A defaultdict avoids this.</span>
<span class="comment-copy">Ugh! <code>enumerate</code> isn't necessary at all. Use zip. See Farhan's solution.</span>
<span class="comment-copy">You still need to import itertools :)</span>
<span class="comment-copy">And operator too!</span>
<span class="comment-copy">One line but a nested loop.</span>
