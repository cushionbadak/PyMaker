<div class="post-text" itemprop="text">
<p>I have a tuple struct in my Python code that declares the following:</p>
<pre><code>match_entry = (util.frozendict(rule_match), priority, version)
</code></pre>
<p>When I print match_entry, I see the following:</p>
<pre><code>print match_entry
({'switch': 1, 'dstmac': 00:00:00:00:00:01, 'srcmac': 00:00:00:00:00:01}, 60000, 5)
</code></pre>
<p>I am searching for this particular tuple a dict of tuples, let's call it dict_of_tuples; the corresponding output for the dict is below.</p>
<pre><code>print dict_of_tuples

{({'switch': 5, 'dstmac': '00:00:00:00:00:00', 'srcmac': '00:00:00:00:00:01'}, 59999, 7): [CountBucket 140271056467472, CountBucket 140271056411280], ({'switch': 5, 'dstmac': '00:00:00:00:00:00', 'srcmac': '00:00:00:00:00:01'}, 59999, 5): [CountBucket 140271056467472, CountBucket 140271056411280], ({'switch': 1, 'dstmac': '00:00:00:00:00:01', 'srcmac': '00:00:00:00:00:01'}, 60000, 5): [CountBucket 140271057099664, CountBucket 140271056501008]}
</code></pre>
<p>However, when I check if the match entry is in the tuple:</p>
<pre><code>if match_entry in dict_of_tuples:
</code></pre>
<p>I do not see any results, even though the match_entry is clearly in dict_of_tuple. Any reason why this would be the case?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>        import frozendict as util
        from collections import defaultdict

        ### Create the first entry using hashable frozendict
        match = util.frozendict({'switch': 1, 'dstmac': '00:00:00:00:00:01', 'srcmac': '00:00:00:00:00:01'})
        match_array = tuple[match,60000,5]
        count_bucket2 = dict(CountBucket1 = 140271057099664, CountBucket2 = 140271056501008)

        ### Create the second entry using hashable frozendict
        match_entry = util.frozendict(switch= 5, dstmac= '00:00:00:00:00:00', srcmac= '00:00:00:00:00:01')
        match_array1 = tuple([match_entry, 59999, 7])

        count_bucket1 = dict(CountBucket1 = 140271056467472, CountBucket2 = 140271056411280)

        # Initialize the dictionary of tuples
        dict_of_tuples = ({tuple(match_array) : count_bucket2},{tuple(match_array1) : count_bucket1})

        ####### Your match entry
        match_entry = [{'switch': 1, 'dstmac': '00:00:00:00:00:01', 'srcmac': '00:00:00:00:00:01'},60000,5]                

    #Treating the final structure as a tuple. Each element of the tuple is a #dictionary.
        k = 0
        while k &lt; len(dict_of_tuples):
            key = dict_of_tuples[k].iterkeys()
            val = dict_of_tuples[k].itervalues()
            if key.next() == tuple(match_entry):
                print ('Has key','corresponding value',val.next())
            else:
                print "Key not present"
            k+= 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Dictionary is not hashable, so I think your structure may not be possible:</p>
<pre><code>&gt;&gt;&gt; {({1:2, 2:3}, 2, 3): [1,2,3]}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'dict'
</code></pre>
<p>Dictionary doesn't allow a dict exists in its keys. So make sure it's really a dict not something like string.</p>
<p><strong>Edit</strong>:</p>
<p>As <a href="https://stackoverflow.com/questions/2703599/what-would-a-frozen-dict-be">mentioned</a> in comment, a <em>frozen dict</em> (immutable dict) will be hashable therefore solves this problem. But you have to modify default dict type. Normally, you can modify a dict at runtime:</p>
<pre><code>d = {}
d["key"] = "val"
</code></pre>
<p>It's enabled with <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer">__setattr__</a> in <code>Object</code>. When we need immutable classes? Basically, immutable objects are more efficient on memory. Here is <a href="https://softwareengineering.stackexchange.com/questions/151733/if-immutable-objects-are-good-why-do-people-keep-creating-mutable-objects">a topic</a> about this.</p>
</div>
<span class="comment-copy">Sure they are dict &amp; tuples not string?</span>
<span class="comment-copy">The value associated with <code>'srcmac'</code> appears to be a string in one case and some sort of non-string object in the other case.</span>
<span class="comment-copy">Bdw, what is <code>00:00:00:00:00:01</code>? I know what <code>"00:00:00:00:00:01"</code> is but not the former one.</span>
<span class="comment-copy">The complete code would have been better. Its difficult to replicate the scenario otherwise</span>
<span class="comment-copy">Treating the final structure as a tuple. Each element of the tuple is a dictionary.</span>
<span class="comment-copy">The dict inside is a frozen dict. So it's hashable.</span>
<span class="comment-copy">@CPanda Ah, new knowledge. But I checked this: <a href="http://stackoverflow.com/questions/2703599/what-would-a-frozen-dict-be" title="what would a frozen dict be">stackoverflow.com/questions/2703599/what-would-a-frozen-dict-be</a> , and the test truly failed. I remembered frozen object can be created by manually modifying <code>__slot__</code>.</span>
<span class="comment-copy">Sorry mate, my bad. I have been thinking about frozen sets all along.</span>
<span class="comment-copy">Thanks, I didn't experience any TypeErrors because of the FrozenDicts. Turns out it was because the srcmac had been cast to a string in an earlier step.</span>
