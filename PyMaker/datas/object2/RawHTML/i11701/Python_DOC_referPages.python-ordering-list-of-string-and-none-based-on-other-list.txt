<div class="post-text" itemprop="text">
<p>I have two lists of equal length, one containing numbers, the other strings and <code>None</code>. I want to order them by descending numbers, keeping the other one in sync.</p>
<p>Before the second list could only contain string (so no <code>None</code> elements), and I used this code:</p>
<pre><code>weights, urls = zip(*sorted(zip(unordered_weights, unordered_urls), reverse=True))
</code></pre>
<p>The numbers are in the "weights" array, the strings in the "urls" array. This worked fine.</p>
<p>However, now that I allow <code>None</code> in my strings list, I get the following error:</p>
<pre><code>TypeError: unorderable types: str() &lt; NoneType()
</code></pre>
<p>For some reason it's also trying to sort the strings, I guess in case the weights are the same. How can I fix this?</p>
<p>I'm using Python 3, I read that in Python 2 <code>None</code> came before any string, but now it gives an error. The order of strings with the same weight doesn't matter.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorting tuples is done lexicographically - first the first elements are compared, if they are equal then the second, which in your case can be <code>None</code>. You can sort using only the weights by extracting it as the sorting key through the <a href="https://docs.python.org/3/library/functions.html?highlight=key#sorted" rel="nofollow"><code>key</code></a> argument to <code>sorted()</code>:</p>
<pre><code>weights, urls = zip(*sorted(zip(unordered_weights, unordered_urls), reverse=True, key=lambda x: x[0]))
</code></pre>
<p>Observe:</p>
<pre><code>In [1]: unordered_urls = ['b', 'a', None, 'c', None]
In [2]: unordered_weights = [1, 0, 0, 5, 2]  # the 'a' and None have the same weight
In [3]: weights, urls = zip(*sorted(zip(unordered_weights, unordered_urls), reverse=True))
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-3-61fb3631580a&gt; in &lt;module&gt;()
----&gt; 1 weights, urls = zip(*sorted(zip(unordered_weights, unordered_urls), reverse=True))

TypeError: unorderable types: str() &lt; NoneType()

In [4]: weights, urls = zip(*sorted(zip(unordered_weights, unordered_urls), reverse=True, key=lambda x: x[0]))
In [5]: weights
Out[5]: (5, 2, 1, 0, 0)
In [6]: urls
Out[6]: ('c', None, 'b', 'a', None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python will use the <em>second</em> element in each tuple (your string or <code>None</code> values) if first element is equal between two tuples:</p>
<pre><code>&gt;&gt;&gt; (42, 'foo') &lt; (42, None)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unorderable types: str() &lt; NoneType()
</code></pre>
<p>You could insert a tie-breaker:</p>
<pre><code>from itertools import count

weights, __, urls = zip(*sorted(zip(unordered_weights, count(), unordered_urls), reverse=True))
</code></pre>
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow"><code>count()</code> iterable object</a> will insert integers starting at <code>0</code>; when two weights are the same, Python will then compare those integers. Since they always differ, the elements in the 3rd position will never be compared against one another. Because the count increases monotonically, the sort remains stable otherwise, two elements with the same weight are kept in the same relative order.</p>
<p>Or you could tell <code>sorted()</code> to only look at the first element:</p>
<pre><code>from operator import itemgetter
weights, urls = zip(*sorted(zip(unordered_weights, unordered_urls), 
                            reverse=True, key=itemgetter(0)))
</code></pre>
<p>Now two equal weights are left in the same order too, because the Python sorting algorithm (TimSort) is stable by default.</p>
</div>
<span class="comment-copy">Very nice, thanks a lot!</span>
<span class="comment-copy">I'm trying to understand this code, could you explain what the <code>*</code> is doing here? I googled and found out it's the "splat" operator but I don't really understand it's purpose here</span>
<span class="comment-copy">@Racialz: it unpacks the list of <code>tuples</code> into separate arguments to the <code>zip()</code> function. So <code>[(42, 0, 'foo'), (42, 2, None), (24, 1, 'bar')]</code> is passed to <code>zip()</code> as if it was given 3 separate arguments. <code>zip()</code> then pairs up all the elements from each argument into new tuples; all the first together in one, all the second in another, etc. so you end up with a sequence of <code>(42, 42, 24), (0, 2, 1), ('foo', None, 'bar')</code>. In other words, a transposition of rows and columns.</span>
<span class="comment-copy">Thanks, that helps alot</span>
