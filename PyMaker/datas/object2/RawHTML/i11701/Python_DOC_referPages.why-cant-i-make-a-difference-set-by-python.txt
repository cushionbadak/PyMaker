<div class="post-text" itemprop="text">
<p>So I make couple of experience:</p>
<pre><code>&gt;&gt;&gt;{2,3} - {2}
{3}
</code></pre>
<p>This one works perfectly.</p>
<p>However, this one seems not work:</p>
<pre><code>&gt;&gt;&gt; {{2,3},{4,3}} - {{4,3}}
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'set'
</code></pre>
<p>I deem that it should work,</p>
<p>because I use one set contain two element, {2,3} and {4,3} to minus one element {4,3}.</p>
<p>Nonetheless, it just can't work. Why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>set</code>s are not hashable; cannot be member of set. Use <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow"><code>frozenset</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; {frozenset({2,3}), frozenset({4,3})} - {frozenset({4,3})}
set([frozenset([2, 3])])
</code></pre>
<hr/>
<p>According to <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow"><code>set</code> / <code>frozenset</code> documentation</a>:</p>
<blockquote>
<p>The elements of a set must be <strong>hashable</strong>. To represent sets of sets, the
  inner sets must be frozenset objects. If iterable is not specified, a
  new empty set is returned.</p>
</blockquote>
<hr/>
<blockquote>
<p><a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow"><strong>hashable</strong></a></p>
<p>An object is hashable if it has a hash value which never changes
  during its lifetime (it needs a <code>__hash__()</code> method), and can be
  compared to other objects (it needs an <code>__eq__()</code> method). Hashable
  objects which compare equal must have the same hash value.</p>
<p>Hashability makes an object usable as a dictionary key and a set
  member, because these data structures use the hash value internally.</p>
<p>All of Pythonâ€™s immutable built-in objects are hashable, while no
  mutable containers (such as lists or dictionaries) are. Objects which
  are instances of user-defined classes are hashable by default; they
  all compare unequal (except with themselves), and their hash value is
  derived from their id().</p>
</blockquote>
</div>
<span class="comment-copy">The right answer. Think about how a set or dictionary works. You need to hash the key and then find out if that hashed key is in the set. If the key is mutable then it is possible the key's hash could change after it was added to the set. Therefore freezing the set literally just makes the set immutable so we don't have to worry about the key being modified after it was added.</span>
<span class="comment-copy">I want to make sure my undersatanding is correct. So because set is not hashable, it can not be one of the elements of set?</span>
<span class="comment-copy">@MarsLee, You're right.</span>
<span class="comment-copy">Ok, I totally got it. I am really appreciate for what you have done for me. :)</span>
