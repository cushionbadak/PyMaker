<div class="post-text" itemprop="text">
<p>I am looking for a way to use a method of a class which is not defined in that class, but handled dynamically. What I would like to achieve, to take an example, is to move from</p>
<pre><code>class Hello:
    def aaa(self, msg=""):
        print("{msg} aaa".format(msg=msg))

    def bbb(self, msg=""):
        print("{msg} bbb".format(msg=msg))

if __name__ == "__main__":
    h = Hello()
    h.aaa("hello")
    h.bbb("hello")

# hello aaa
# hello bbb
</code></pre>
<p>to the possibility of using <code>aaa</code> and <code>bbb</code> (and others) within the class without the need to define them explicitly. For the example above that would be a construction which receives the name of the method used (<code>aaa</code> for instance) and format a message accordingly. </p>
<p>In other other words, a "wildcard method" which would itself handle its name and perform conditional actions depending on the name. In pseudocode (to replicate the example above)</p>
<pre><code>def *wildcard*(self, msg=""):
    method = __name__which__was__used__to__call__me__
    print("{msg} {method}".format(msg=msg, method=method))
</code></pre>
<p>Is such a construction possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could overload the class' <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__"><code>__getattr__</code></a> method:</p>
<pre><code>class Hello:
    def __getattr__(self, name):
        def f(msg=""):
            print("{} {}".format(msg, name))
        return f

if __name__ == "__main__":
    h = Hello()
    h.aaa("hello")
    h.bbb("hello")
</code></pre>
<p>Result:</p>
<pre><code>hello aaa
hello bbb
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you know the names of the methods in advance, you could do this with a decorator that adds all the methods for you. </p>
<pre><code>from functools import partial

def glue(f, names=[]):
    def wrapper(cls):
        method = getattr(cls,f)
        for name in names:
            setattr(cls, name, partial(method,name=name))
        return cls
    return wrapper
</code></pre>
<p>Use it like this: </p>
<pre><code>@glue(f = 'wildcard', names = ['aaa', 'bbb'])
class Hello():
    def wildcard(self, msg='', name=''):
        print("{} {}".format(msg, name))
</code></pre>
<p>If you are unfamiliar with decorators, the<code>@</code> syntax above is equivalent to doing this after the class definition:</p>
<pre><code>Hello = glue(f = 'wildcard', names = ['aaa', 'bbb'])(Hello)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found above answers a bit hard to comprehend so I do this.</p>
<p>Inspired by Django's code.</p>
<pre class="lang-py prettyprint-override"><code>class FuckingShit:
    def __init__(self, **kwargs):

        for arg in ('aaa', 'bbb'):
            # generate a new function based on the template function.
            setattr(self, f'make_{arg}', partialmethod(self._make_ARG, arg=arg))

    def _make_ARG(self, arg, **kwargs):
        value = getattr(self, arg)
        # override make_{ARG} function to generate an argument based on codex.
        return value
</code></pre>
</div>
<span class="comment-copy">This assumes <code>aaa</code> and <code>bbb</code> are known (which is not the case, it should handle any method name)</span>
