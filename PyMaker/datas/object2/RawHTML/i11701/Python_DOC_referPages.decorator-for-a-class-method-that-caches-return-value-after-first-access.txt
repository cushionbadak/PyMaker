<div class="post-text" itemprop="text">
<h1>My problem, and why</h1>
<p>I'm trying to write a decorator for a class method, <code>@cachedproperty</code>. I want it to behave so that when the method is first called, the method is replaced with its return value. I also want it to behave like <code>@property</code> so that it doesn't need to be explicitly called. Basically, it should be indistinguishable from <code>@property</code> except that <strong>it's faster, because it only calculates the value once and then stores it. My idea is that this would not slow down instantiation like defining it in <code>__init__</code> would.</strong> That's why I want to do this.</p>
<h1>What I tried</h1>
<p>First, I tried to override the <code>fget</code> method of the <code>property</code>, but it's read-only.</p>
<p>Next, I figured I'd try to implement a decorator that does needs to be called the first time but then caches the values. This isn't my final goal of a property-type decorator that never needs to be called, but I thought this would be a simpler problem to tackle first.Â In other words, this is a not-working solution to a slightly simpler problem.</p>
<p>I tried:</p>
<pre><code>def cachedproperty(func):
    """ Used on methods to convert them to methods that replace themselves 
        with their return value once they are called. """
    def cache(*args):
        self = args[0] # Reference to the class who owns the method
        funcname = inspect.stack()[0][3] # Name of the function, so that it can be overridden.
        setattr(self, funcname, func()) # Replace the function with its value
        return func() # Return the result of the function
    return cache
</code></pre>
<p>However, this doesn't seem work. I tested this with:</p>
<pre><code>&gt;&gt;&gt; class Test:
...     @cachedproperty
...     def test(self):
...             print "Execute"
...             return "Return"
... 
&gt;&gt;&gt; Test.test
&lt;unbound method Test.cache&gt;
&gt;&gt;&gt; Test.test()
</code></pre>
<p>but I get an error about how the class didn't pass itself to the method:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unbound method cache() must be called with Test instance as first argument (got nothing instead)
</code></pre>
<p>At this point, me and my limited knowledge of deep Python methods are very confused, and I have no idea where my code went wrong or how to fix it. (I've never tried to write a decorator before)</p>
<h1>The question</h1>
<p>How can I write a decorator that will return the result of calling a class method the first time it's accessed (like <code>@property</code> does), and be replaced with a cached value for all subsequent queries?</p>
<p>I hope this question isn't too confusing, I tried to explain it as well as I could.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all <code>Test</code> should be instantiated</p>
<pre><code>test = Test()
</code></pre>
<p>Second, there is no need for <code>inspect</code> cause we can get the property name from <code>func.__name__</code>
And third, we return <code>property(cache)</code> to make python to do all the magic.</p>
<pre><code>def cachedproperty(func):
    " Used on methods to convert them to methods that replace themselves\
        with their return value once they are called. "

    def cache(*args):
        self = args[0] # Reference to the class who owns the method
        funcname = func.__name__
        ret_value = func(self)
        setattr(self, funcname, ret_value) # Replace the function with its value
        return ret_value # Return the result of the function

    return property(cache)


class Test:
    @cachedproperty
    def test(self):
            print "Execute"
            return "Return"

&gt;&gt;&gt; test = Test()
&gt;&gt;&gt; test.test
Execute
'Return'
&gt;&gt;&gt; test.test
'Return'
&gt;&gt;&gt;
</code></pre>
<p>"""</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind alternative solutions, I'd recommend <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noreferrer"><code>lru_cache</code></a></p>
<p>for example</p>
<pre><code>from functools import lru_cache
class Test:
    @property
    @lru_cache(maxsize=None)
    def calc(self):
        print("Calculating")
        return 1
</code></pre>
<p>Expected output</p>
<pre><code>In [2]: t = Test()

In [3]: t.calc
Calculating
Out[3]: 1

In [4]: t.calc
Out[4]: 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you're better off with a custom descriptor, since this is exactly the kind of thing descriptors are for. Like so: </p>
<pre><code>class CachedProperty:
    def __init__(self, name, get_the_value):
        self.name = name
        self.get_the_value = get_the_value
    def __get__(self, obj, typ): 
        name = self.name
        while True:
            try:
                return getattr(obj, name)
            except AttributeError:
                get_the_value = self.get_the_value
                try:
                    # get_the_value can be a string which is the name of an obj method
                    value = getattr(obj, get_the_value)()
                except AttributeError:
                    # or it can be another external function
                    value = get_the_value()
                setattr(obj, name, value)
                continue
            break


class Mine:
    cached_property = CachedProperty("_cached_property ", get_cached_property_value)

# OR: 

class Mine:
    cached_property = CachedProperty("_cached_property", "get_cached_property_value")
    def get_cached_property_value(self):
        return "the_value"
</code></pre>
<p>EDIT: By the way, you don't even actually need a custom descriptor. You could just cache the value inside of your property function. E.g.: </p>
<pre><code>@property
def test(self):
    while True:
        try:
            return self._test
        except AttributeError:
            self._test = get_initial_value()
</code></pre>
<p>That's all there is to it. </p>
<p>However, many would consider this a bit of an abuse of <code>property</code>, and to be an unexpected way of using it. And unexpected usually means you should do it another, more explicit way. A custom <code>CachedProperty</code> descriptor is very explicit, so for that reason I would prefer it to the <code>property</code> approach, though it requires more code. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use something like this:</p>
<pre><code>def cached(timeout=None):
    def decorator(func):
        def wrapper(self, *args, **kwargs):
            value = None
            key = '_'.join([type(self).__name__, str(self.id) if hasattr(self, 'id') else '', func.__name__])

            if settings.CACHING_ENABLED:
                value = cache.get(key)

            if value is None:
                value = func(self, *args, **kwargs)

                if settings.CACHING_ENABLED:
                    # if timeout=None Django cache reads a global value from settings
                    cache.set(key, value, timeout=timeout)

            return value

        return wrapper

    return decorator
</code></pre>
<p>When adding to the cache dictionary it generates keys based on the convention  <code>class_id_function</code> in case you are caching entities and the property could possibly return a different value for each one.</p>
<p>It also checks a settings key <code>CACHING_ENABLED</code> in case you want to turn it off temporarily when doing benchmarks.</p>
<p>But it does not encapsulate the standard <code>property</code> decorator so you should still call it like a function, or you can use it like this (why restrict it to properties only):</p>
<pre><code>@cached
@property
def total_sales(self):
    # Some calculations here...
    pass
</code></pre>
<p>Also it may be worth noting that in case you are caching a result from lazy foreign key relationships, there are times depending on your data where it would be faster to simply run an aggregate function when doing your select query and fetching everything at once, than visiting the cache for every record in your result-set. So use some tool like <code>django-debug-toolbar</code> for your framework to compare what performs best in your scenario.</p>
</div>
<div class="post-text" itemprop="text">
<p>Django's version of this decorator does exactly what you describe and is simple, so besides my comment I'll just copy it here:</p>
<pre><code>class cached_property(object):
    """
    Decorator that converts a method with a single self argument into a
    property cached on the instance.

    Optional ``name`` argument allows you to make cached properties of other
    methods. (e.g.  url = cached_property(get_absolute_url, name='url') )
    """
    def __init__(self, func, name=None):
        self.func = func
        self.__doc__ = getattr(func, '__doc__')
        self.name = name or func.__name__

    def __get__(self, instance, type=None):
        if instance is None:
            return self
        res = instance.__dict__[self.name] = self.func(instance)
        return res
</code></pre>
<p>(<a href="https://docs.djangoproject.com/en/1.9/_modules/django/utils/functional/#cached_property" rel="nofollow">source</a>).</p>
<p>As you can see, it uses func.name to determine the name of the function (no need to fiddle with inspect.stack) and it replaces the method with its result by mutating <code>instance.__dict__</code>. So subsequent "calls" are just an attribute lookup and there is no need for any caches, et cetera.</p>
</div>
<span class="comment-copy">Why not just make a custom descriptor that returns the cached object...? A decorator will work, but it seems like the wrong tool for what you're trying to do.</span>
<span class="comment-copy">Do you want this to be an <i>instance</i> attribute, or a <i>class</i> attribute? <code>Test.test</code> would be the syntax for a class attribute, but it sounds like you want this to be an instance thing.</span>
<span class="comment-copy">Note that Django ships with such a decorator, its source is here: <a href="https://docs.djangoproject.com/en/1.9/_modules/django/utils/functional/#cached_property" rel="nofollow noreferrer">docs.djangoproject.com/en/1.9/_modules/django/utils/functional/â¦</a> . It overrides instance.__dict__ the first time get() is called so that the value can overwrite the property.</span>
<span class="comment-copy">FTR: this principle of caching method return values after the first call is called <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoization</a>.</span>
<span class="comment-copy">@oliver: but this goes a bit further than mere memoization, as the method is actually <i>replaced</i> by the value as an optimization. It also means that the method can't take any arguments, or it wouldn't work.</span>
<span class="comment-copy">Accepting this as it is close to my original code. This shows me what I did wrong rather than just an alternate solution. I definitely appreciate all the other answers, I'll keep them all close at hand.</span>
<span class="comment-copy">How can we adapt this for new-style classes? If I have Test derive from object, I get "AttributeError: can't set attribute" with the above code. I guess in new-style classes, the methods are read-only?</span>
<span class="comment-copy">Audrey "cookiecutter" Greenfeld's husband Danny "Two Scoops" has written a Python package to do just this: <a href="https://github.com/pydanny/cached-property" rel="nofollow noreferrer">github.com/pydanny/cached-property</a></span>
<span class="comment-copy">This is slower than what he described, this still calls a function and does a cache lookup each time the property is accessed after the first.</span>
<span class="comment-copy">@RemcoGerlich true, but typically that's premature optimization. The high cost of computing the attribute is usually the primary cost in performance, for instance if computing the property hits IO. The ability to do this with builtin python means you should almost always try this first to see if it solves your problem.</span>
<span class="comment-copy">You start your answer with "If it's just performance you're concerned with" even though your answer is slower than the solution OP describes (and more complicated, as it involves introducing a cache). Bit strange to call my comment "premature" imo, you simply don't answer the question.</span>
<span class="comment-copy">@RemcoGerlich OP is asking how to cache return value lazily. OP has <code>store return value as an attribute</code> as their attempted solution. <code>store return value as an attribute</code> is a fair answer, but so are other solutions, which solve OP's problem, and are relevant to the question <code>A decorator for a class method that caches the return after first run</code></span>
<span class="comment-copy">@RemcoGerlich but you're right about performance, so edited to remove "If it's just performance you're concerned with" because it is misleading.</span>
<span class="comment-copy">Off course he can, but why would he? That property should only have one responsibility and that is to return what is supposed to.</span>
<span class="comment-copy">@fips point taken. I'm not sure there's a right answer here but I definitely see the argument that a custom descriptor makes it clear what is trying to be done, whereas using <code>property</code> this way is a bit of an abuse/expansion of its purpose.</span>
<span class="comment-copy">True, a descriptor seems like the way to go especially if you need the instance to operate on or use inheritance to extend what it does in a reusable way.</span>
<span class="comment-copy">@fips yeah the inheritance issue probably makes a descriptor make even more sense.</span>
<span class="comment-copy">This is really good. Thanks for this. I didn't know Django implemented this kind of thing, I thought it was just web framework stuff. I'll keep the fact that Django has some useful functions in mind for future reference :)</span>
<span class="comment-copy">It turns out that while writing web framework stuff, you often need some handy utils :-)</span>
