<div class="post-text" itemprop="text">
<p>I have tried inheriting from both <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> and <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> like so:</p>
<pre><code>class OrderedDefaultDict(defaultdict, OrderedDict): pass
</code></pre>
<p>and like so:</p>
<pre><code>class OrderedDefaultDict(OrderedDict, defaultdict): pass
</code></pre>
<p>in order to created an ordered default dict (a class that should remember the order in which new default items were generated) but it seems to throw an error stating:</p>
<pre><code>TypeError: multiple bases have instance lay-out conflict
</code></pre>
<p>I have read <a href="https://stackoverflow.com/q/309129/1658617">here</a> that it's because they're both implemented in C. Upon disabling Python's C implementation of <code>OrderedDict</code> by commenting this section in the <code>collections</code> module:</p>
<pre><code>try:
    from _collections import OrderedDict
except ImportError:
    # Leave the pure Python version in place.
    pass
</code></pre>
<p>I have managed to inherit from both, but it does not seem to work as I expected. I have two questions then:</p>
<ol>
<li><strong>Why can't you inherit from two classes written in C?</strong> I would understand if you wouldn't be able to inherit from any class written in C but why can you inherit from one and not from 2?</li>
<li>Implementing my requested class would be easy by subclassing <code>OrderedDict</code> and overriding <code>__getitem__()</code> to match <code>defaultdict</code>'s behavior. <strong>Is there a better way (preferably within the standard library) to mimick the same behavior?</strong> Or is subclassing <code>OrderedDict</code> the most optimal? (subclassing <code>defaultdict</code> is possible too but implementing it is is probably easier using <code>OrderedDict</code>)</li>
</ol>
<p><strong>The first question is the important of the two</strong> as implementing it myself by subclassing <code>OrderedDict</code> shouldn't pose a problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>The functionality of <code>defaultdict</code> can be simply implemented by defining a <code>__missing__</code> method:</p>
<pre><code>class DefaultOrderedDict(OrderedDict):
    def __init__(self, default_factory=None, **kwargs):
        OrderedDict.__init__(self, **kwargs)
        self.default_factory = default_factory

    def __missing__(self, key):
        result = self[key] = self.default_factory()
        return result
</code></pre>
</div>
<span class="comment-copy">I think you'd be better off subclassing <code>OrderedDict</code> and defining a <a href="https://docs.python.org/2/reference/datamodel.html#object.__missing__" rel="nofollow noreferrer"><code>__missing__</code></a> method.</span>
<span class="comment-copy">I think if your edit is true wrt what "the important part" of your question is, then it's a duplicate. You've misread the answer you linked. The point isn't that they're implemented in C. The point is that they're internally incompatible (though the C implementation makes that more possible/likely) so there's no way for Python to automatically use them for multiple inheritance.</span>
<span class="comment-copy">@Two-BitAlchemist Why would they be internally incompatible? Classes in the STL usually talk with themselves nicely like <code>OrderedDict</code> and <code>Counter</code> for example.</span>
<span class="comment-copy">That's a better question for the Python mailing list than for me. Wild guess: they're both subsets of dict written in C and no effort was made to give them a similar API because they're not similar in function.</span>
<span class="comment-copy">See the <code>OrderedDefaultdict</code> class in <a href="http://stackoverflow.com/a/4127426/355230">this answer</a>.</span>
<span class="comment-copy">I think I'd want to make the <code>__init__</code> a little more robust than this. You're losing a lot of <code>dict</code> functionality this way.</span>
<span class="comment-copy">agreed. just use the <code>__init__</code> from defaultdict: <code>def __init__(self, default_factory=None, **kwargs):</code></span>
<span class="comment-copy">@acushner: agreed.</span>
<span class="comment-copy">@Daniel just on a side note, it's always funny when people use <code>**kwargs</code> with an <code>OrderedDict</code>, because those <code>kwargs</code> themselves aren't necessarily in any particular order. but it is still usable. nice update to the answer.</span>
