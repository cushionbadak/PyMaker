<div class="post-text" itemprop="text">
<p>I am trying to find a great way to produce a 32 digit hex sequence that is random and gets its randomness from a Big Number like 10*78.</p>
<p>For Python code I also found this:</p>
<pre><code>ran = random.randrange(10**80)
myhex = "%030x" % ran
</code></pre>
<p>This produces a 64 digit hex string, BUT sometimes the result is 63 or even 61 characters and I'm not sure why? I need it to return 64 exactly each time.</p>
<p>I need helping tweaking the above code so that it ALWAYS returns 64 only. I do not know enough about the how the "%030x" part works. </p>
<p>I've also tried producing a longer hex string and shortening it with:</p>
<pre><code>myhex = myhex[:64]
</code></pre>
<p>But I was still seeing strings that were less than 64 being returned.</p>
<p>In the end I just need exactly 64 hexadecimal string derived from a Big Number like 10*78, returned each time.</p>
<p><strong>Solution I went with</strong></p>
<pre><code>import random

ran = random.randrange(10**80)
myhex = "%064x" % ran

#limit string to 64 characters
myhex = myhex[:64]

print(myhex)
</code></pre>
<p>Seems @ScottMillers answer below was the key I needed to find the answer so I'm selecting his answer as the solution, but wanted to post my final code that worked for me here.</p>
<p>Thanks everyone</p>
</div>
<div class="post-text" itemprop="text">
<p><code>"%030x"</code> says to display the associated value with <em>at least</em> 30 digits, padding with 0's in front as necessary.  Since your numbers are almost always bigger than that, this isn't doing much for you.</p>
<p>It sounds like you need <code>"%064x"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The UUID module can return a 32 hexadecimal digits object:</p>
<pre><code>import uuid
uuid.uuid4().hex
# '7dccf8a43a6c4e018caadacdb2d0f6f0'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In modern Python distributions, the new library <code>secrets</code> makes it easy and might be what you need. From the docs:</p>
<blockquote>
<p>The secrets module is used for generating cryptographically strong random numbers suitable for managing data such as passwords, account authentication, security tokens, and related secrets.</p>
<p>In particularly, secrets should be used in preference to the default pseudo-random number generator in the random module, which is designed for modeling and simulation, not security or cryptography.</p>
</blockquote>
<p>For Python 3.6 and up, try this:</p>
<pre><code>import secrets
secrets.token_hex(32)
#'17450056b398cbeda1fa7e4fc25d4fb169ade2b1266892e2cecab56b12fb900b'
</code></pre>
<p><a href="https://docs.python.org/3/library/secrets.html#module-secrets" rel="nofollow noreferrer">https://docs.python.org/3/library/secrets.html#module-secrets</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>os.urandom</code> instead of hexdump. Python 2.7:</p>
<pre><code>import os
num_digits = 32
myhex = os.urandom(num_digits / 2).encode('hex')
</code></pre>
<p>Py3.4+:</p>
<pre><code>import os, codecs
num_digits = 32
myhex = codecs.encode(os.urandom(num_digits / 2), 'hex').decode()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no such things as "hex numbers"; there's only different representation of the same number (10 in decimal is 0xA in hex and is 0b1010 in binary, but it's still the same number).</p>
<blockquote>
<p>This produces a 64 digit hex string, BUT sometimes the result is 63 or even 61 characters and I'm not sure why? I need it to return 64 exactly each time.</p>
</blockquote>
<p>so: I ask you to give me a random number above 0 and below 1000; how many digits will that number have?</p>
<p>Right. It can have one, two or three digits, with three digits being the most likely case (there's 900 three-digit numbers below 1000, but only 90 two digit numbers and 9 one-digit numbers). </p>
<p>Obviously, you just have to pad with 0 in front!</p>
<blockquote>
<p>In the end I just need exactly 64 hexadecimal string derived from a Big Number like 10*78, returned each time.</p>
</blockquote>
<p>you need to think about what random means. If you're ok with every single digit being drawn from a uniform distribution in 0..F, then why don't just throw a sixteen-sided die 64 times and concatenate the result? Python makes that extremely easy</p>
<pre><code>import random
hexdigits = "0123456789ABCDEF"
random_digits = "".join([ hexdigits[random.randint(0,0xF)] for _ in range(64) ])
</code></pre>
<p><strong>EDIT:</strong></p>
<p>In the comments below, OP says he wants to use that random string to seed a bitcoin private key generation. </p>
<p><strong>Never</strong> build your own seeder unless you're really an expert in the field. So, although I believe these 1024 bit (really, that's what a 64 digit of Hex number are) of info are random, I <strong>will not claim this suffices for crypto purposes</strong>. </p>
<p>Don't implement crypto yourself, and don't meddle with seed generation lest you know your ways around stochastics, numerics, cryptography and RNG, computer security research and possible attack vectors. <strong>Simply don't</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would try something like this:</p>
<pre><code>mylist = [0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]
number = ""

def randomhex():
    global mylist, number
    while len(number) &lt; 32:
        number = number + random.choice(mylist)
</code></pre>
<p>And if you want it as number, not as string just use eval().</p>
</div>
<span class="comment-copy">Its Scott Hunter, not Scott Miller, but I've been called worse.</span>
<span class="comment-copy">Thanks. This was key in my final solution so I'm choosing it as my answer.</span>
<span class="comment-copy">thanks for clarifying why I was seeing shorter digits sometimes. It starts with a random number duh.  My question now is if rando.randint have enough entropy to support my big number poll requirement? Like up to 10**78. Would you say it does?</span>
<span class="comment-copy">and Marcus your answer does provide a consistent random 64 hex string as required. I have ran it millions of times in testing and always 64.</span>
<span class="comment-copy">@NormanBird unless you start defining what "random" means to you, there's no answer to that, obviously. But probably: The random number generator python uses is pretty good, so chances are that you won't see any patterns in your 1024 bits of randomness.</span>
<span class="comment-copy">notice that defining "random enough" is a hard problem, and there's books and books of math defining what "random" means under different aspects. I really don't know what you need your random digit string for, and you don't seem to be able to articulate that; my "guess" hence that yes, that string is random enough.</span>
<span class="comment-copy">I am attempting generate a script that produces the 32 random hex string needed to generate a Bitcoin private key. My understanding is that the proper entropy needs to come from a pool of at least 10^78 power or a 78 digit random number. That's why you see I start with random.randrange(10**78). I just noticed your solution did not use that part of my original code so I asked.</span>
<span class="comment-copy">you can directly use a string (see my answer), which is a sequence type, too, with random.choice.</span>
<span class="comment-copy">But: <b>never</b> use <code>global</code> without a good reason. Your function is a prime example of where one should use <code>return</code> instead. I think you should seriously increase your Python knowledge!</span>
<span class="comment-copy">Well, I'm 15 and have been programming for about a half year and why should I avoid using global variables in functions?</span>
<span class="comment-copy">because that's not how functions are supposed to work: transforming input to output that they <code>return</code>. I think it's a great thing to pursue porgamming, so keep up the work!</span>
<span class="comment-copy">Really, though, learn about python functions. I think the official tutorial on python.org explains them in a way that makes the whole input-&gt;return thing much more intuitive than the global thing. In general, you should avoid global as much as possible: It is a recipe for disaster, because you might change something on one end of your program that the other end did not foresee.</span>
