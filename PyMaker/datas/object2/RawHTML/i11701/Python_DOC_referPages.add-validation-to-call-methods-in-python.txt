<div class="post-text" itemprop="text">
<p>I have a large hierarchy of classes stemming from <code>Function</code> class (for example <code>SineFunction</code> would be a child), and all of them implement the <code>__call__</code> method, as well as other methods (for example derivation or more specialized numerical methods). </p>
<p>What is the cleanest way of adding common logic to each of these <code>__call__</code> methods based on the type of the input? Formally, I'd like to have something like </p>
<pre><code>def __call__(self,x):
    if isinstance(x,Distribution):
        return FunctionDistribution(x,self)
    else:
        # Go back to previous logic
</code></pre>
<p>for each child class of <code>Function</code>. I could add <code>super()</code> at each implementation of <code>__call__</code> but that would be painful. Anything easier to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>How about something like this?</p>
<pre><code>class BaseFunction(object):
    def __call__(self, x):
        if isinstance(x, BaseFunction):
            return self._call(x)
        else:
            print("Fallback logic goes here")

    def _call(self):
        raise NotImplementedError

class ChildFunction(BaseFunction):
    def _call(self, x):
        print("Child function executed on x")
</code></pre>
<p>The child classes each define <code>_call</code>, and the fallback logic resides in the parent class.</p>
<p>An example:</p>
<pre><code>&gt;&gt;&gt; a = BaseFunction()
&gt;&gt;&gt; b = ChildFunction()
&gt;&gt;&gt; c = 3
&gt;&gt;&gt; b(a)
Child function executed on x
&gt;&gt;&gt; b(c)
Fallback logic goes here
</code></pre>
<p><strong>Editorializing:</strong></p>
<p>As an aside, I don't know much about your particular use case, but my understanding is that <code>isinstance</code> is very often not the ideal choice, and it's better to do some sort of <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow">duck typing</a>. In which case, you'd probably want to replace the <code>if(isinstance(...</code> statement with a <code>try</code>/<code>except</code> block where you just use the interface <em>as if</em> <code>x</code> implements the <code>BaseFunction</code> interface.</p>
</div>
<span class="comment-copy">Is <code>FunctionDistribution</code> the same in every version? Or will it vary across different <code>__call__</code> methods? Is there always one argument?</span>
<span class="comment-copy">Not sure if it applies to your case, but you might want to look at <a href="https://docs.python.org/3/whatsnew/3.4.html#whatsnew-singledispatch" rel="nofollow noreferrer">single dispatch generic functions (introduced in 3.4)</a>, where you can define a global function with a generic implementation, plus specializations for specific types. It may or may not mesh well with your current "functor" based design, but I figure it's work checking.</span>
<span class="comment-copy">Yeah it could do, however it implies renaming <code>__call__</code> to <code>_call</code> for each implementation, which is annoying.</span>
<span class="comment-copy">@Literal I suppose you're actually physically renaming <code>__call__</code> if you already have an implementation using <code>__call__</code>, but in reality what you're doing is implementing an additional method <code>_call</code>, and the original <code>__call__</code> is inherited from <code>BaseFunction</code>, if that's not clear.</span>
<span class="comment-copy">Also, it seems like a pretty simple search-and-replace. Probably better to do it once, now, than to design some weird metaclass that just does something equivalent at runtime.</span>
