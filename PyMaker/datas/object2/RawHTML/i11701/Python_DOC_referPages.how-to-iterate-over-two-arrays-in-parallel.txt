<div class="post-text" itemprop="text">
<p>I am look like to be able to iterate over two arrays in parallel (or with only one for loop).</p>
<p>Here is my script I tried ...</p>
<pre><code>#!/usr/bin/env python

list1 = [ 'one', 'two', 'three' ]
list2 = [ 'I', 'II', 'III', 'IV', 'V' ]

for word in list1:
    print word + " from list1"

for roman in list2:
    print roman + " from list2"

for ( word, roman ) in (list1 list2):
         if word:
                 print word + " from list1"

    if roman:
        print roman + " from list2"
</code></pre>
<p>But is obviously incorrect as I get a syntax error:</p>
<pre><code>  File "./twoarr.py", line 12
    for ( word, roman ) in (list1 list2):
                                      ^
SyntaxError: invalid syntax
</code></pre>
<p>I am trying to get output that would look like this:</p>
<pre><code>one from list1
I from list2
two from list1
II from list2
three from list1
III from list2
IV from list2
V from list2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To iterate over multiple list you can use the built in function <code>zip</code>. According to the <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow">Documentation</a>, this function returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. So, applied to your particular example</p>
<pre><code>list1 = [ 'one', 'two', 'three' ]
list2 = [ 'I', 'II', 'III', 'IV', 'V' ]

for word in list1:
    print word + " from list1"

for roman in list2:
    print roman + " from list2"

for word, roman in zip(list1 list2):
    print word + " from list1"
    print roman + " from list2"
</code></pre>
<p>The only drawback of zip is that when your lists, as in this example, have not equal length, zip will return a list of tuples, each with dimension equal to the smaller one. To favour the longest one, and fill with None when necessary, just replace zip with <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow">itertools.izip_longest</a>:</p>
<pre><code>from itertools import izip_longest

list1 = [ 'one', 'two', 'three' ]
list2 = [ 'I', 'II', 'III', 'IV', 'V' ]

for word in list1:
    print word + " from list1"

for roman in list2:
    print roman + " from list2"

for word, roman in izip_longest(list1, list2):
    print word + " from list1"
    print roman + " from list2"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> to iterate over 2 list.</p>
<pre><code>&gt;&gt;&gt; list1 = [ 'one', 'two', 'three' ]
&gt;&gt;&gt; list2 = [ 'I', 'II', 'III', 'IV', 'V' ]
&gt;&gt;&gt; for (x, y) in zip(list1, list2):
...     print x + " from list1"
...     print y + " from list2"
... 
one from list1
I from list2
two from list1
II from list2
three from list1
III from list2
</code></pre>
<p><strong>Note</strong>:  <code>zip</code> will provide till the list which is small. So in your case, <code>list1</code> has 3 element and <code>list2</code> has 5 elements, so <code>zip</code> will give data till 3 elements only. you can use <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow"><code>izip_longest</code></a> to reach all element in <code>list2</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I have similar requirements, implemented by</p>
<pre><code>for i in range(len(list1)):
    print list1[i], list2[i]
</code></pre>
<p>needs more detection if lists do not have the same length, or to use some try/except statement to avoid invalid index</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want it to not just blend the two list but truly run in parallell use two threads: </p>
<pre><code>import _thread

def print_list(name, list):
    for word in list:
        print(word + " from " + name + "\r\n");

list1 = [ 'one', 'two', 'three' ]
list2 = [ 'I', 'II', 'III', 'IV', 'V' ]

_thread.start_new_thread( print_list, ("list1",list1) )
_thread.start_new_thread( print_list, ("list2",list2) )
</code></pre>
</div>
<span class="comment-copy">I suggest to change the title of this question. It seems to me that you are not looking to do it in parallel. You want to do it in a single loop. The title might suggest a different thing.</span>
<span class="comment-copy">Maybe so. But to me parallel does not always imply multitasking (forking, child parent processes etc.).  I meant "parallel" as opposed to processing the arrays serially (one after another).</span>
<span class="comment-copy">Thanks! That works great. Just one nit picky point. You left out the ',' in the izip_longest() call. I used <code>for word, roman in izip_longest(list1, list2):</code></span>
<span class="comment-copy">Yes, was a typo. I just fixed it.</span>
<span class="comment-copy"><b>Note:</b> what?</span>
<span class="comment-copy">Updated note :)</span>
<span class="comment-copy">might be worth mentioning izip_longest from itertools if op wants to not cut off at the shorter list length <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html#itertools.izip_longest</a></span>
<span class="comment-copy">@GarrettR, updated note with your suggestions. Thanks, for making StackOverflow better :)</span>
