<div class="post-text" itemprop="text">
<p>When starting two processes with the old school <code>subprocess.Popen()</code> API, I can easily connect <em>standard out</em> of one process to <em>standard in</em> of another process, creating a pipeline in the same way as a UNIX shell will do when connecting commands with <code>|</code>:</p>
<pre><code>from subprocess import Popen, PIPE

process_1 = Popen(['ls'], stdout = PIPE)
process_2 = Popen(['wc'], stdin = process_1.stdout)

process_1.wait()
process_2.wait()
</code></pre>
<p>How can I accomplish the same when using the asynchronous API from <code>asyncio.subprocess.create_subprocess_exec()</code> (or similar)? This is what I tried:</p>
<pre><code>from asyncio.events import get_event_loop
from asyncio.subprocess import PIPE, create_subprocess_exec

async def main():
    process_1 = await create_subprocess_exec('ls', stdout = PIPE)
    process_2 = await create_subprocess_exec('wc', stdin = process_1.stdout)

    await process_1.wait()
    await process_2.wait()

get_event_loop().run_until_complete(main())
</code></pre>
<p>But the second call to <code>create_subprocess_exec()</code> complains that the argument passed to <code>stdin</code> has no <code>fileno</code> (which is true):</p>
<pre><code>Traceback (most recent call last):
  File ".../test-async.py", line 11, in &lt;module&gt;
     get_event_loop().run_until_complete(main())
[...]
  File ".../test-async.py", line 6, in main
     process_2 = await create_subprocess_exec('wc', stdin = process_1.stdout)
[...]
  File "/opt/local/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/subprocess.py", line 1388, in _get_handles
     p2cread = stdin.fileno()
AttributeError: 'StreamReader' object has no attribute 'fileno'
</code></pre>
<p>How can I get the same result as in the synchronous example above?</p>
</div>
<div class="post-text" itemprop="text">
<p>In asyncio, <a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.stdout" rel="nofollow">process.stdout</a> is actually a <a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader" rel="nofollow">StreamReader</a>, not a file object. The file object can be accessed through <code>process._transport._proc.stdout</code>. Unfortunately, you won't be able to use it since it has already been registered in the event loop in order to provide the stream interface <code>process.stdout</code>.</p>
<p>One way to deal with the issue is to create your own pipe and pass the file descriptors to the subprocess: </p>
<pre><code>async def main():
    read, write = os.pipe()
    process_1 = await create_subprocess_exec('ls', stdout=write)
    os.close(write)
    process_2 = await create_subprocess_exec('wc', stdin=read, stdout=PIPE)
    os.close(read)
    return await process_2.stdout.read()
</code></pre>
<p>Note that the <code>write</code> file descriptor should be explicitly closed once the first subprocess is started (it is not automatically closed unless you use <code>subprocess.PIPE</code>). The <code>read</code> file descriptor also needs to be closed, as explained <a href="https://docs.python.org/3/library/subprocess.html#replacing-shell-pipeline" rel="nofollow">here</a>.</p>
</div>
<span class="comment-copy">unrelated: you should add <code>process_1.stdout.close()</code> after <code>Popen(['wc'],..)</code>. See <a href="http://stackoverflow.com/q/295459/4279">How do I use subprocess.Popen to connect multiple processes by pipes?</a></span>
<span class="comment-copy">could you provide a reference for the statement: <i>"it is closed automatically only if you use subprocess.PIPE"</i>? As I understand the reason you want <code>os.close(write)</code> in the parent is so that <code>ls</code> would get <code>SIGPIPE</code> and <code>EPIPE</code> if <code>wc</code> dies prematurely. It is the same for <code>subprocess.PIPE</code> (at least for ordinary <code>Popen()</code> as demonstrated by <a href="https://docs.python.org/3/library/subprocess.html#replacing-shell-pipeline" rel="nofollow noreferrer">the code example in the docs</a>)</span>
<span class="comment-copy">@J.F.Sebastian I noticed it by looking at <a href="https://github.com/python/cpython/blob/master/Lib/subprocess.py#L1501" rel="nofollow noreferrer">the code</a>, I don't know if it's documented somewhere. However, your example is about closing the reader, not the writer. In my example, the writer needs to be closed in order to set up the pipe properly (see <a href="http://stackoverflow.com/a/15512202/2846140">this answer</a>).</span>
<span class="comment-copy">You are right about the <code>write</code> end of the pipe (it is closed because it is unused in the parent—it would also explain why it is the responsibility of the code that creates the <code>subprocess.PIPE</code> pipe to close it—it is unrelated to <code>asyncio</code> and the corresponding <code>os.close()</code> call is in the <code>subprocess</code> module). The  example that I cited would correspond to <code>process_1.stdout.close()</code> above i.e, <code>os.close(read)</code> should be called.</span>
<span class="comment-copy">@J.F.Sebastian You're right, I didn't realize the reader also needs to be closed. Thanks for your insight, see my edit.</span>
