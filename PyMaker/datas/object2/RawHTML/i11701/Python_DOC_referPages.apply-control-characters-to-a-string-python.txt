<div class="post-text" itemprop="text">
<p>I'm trying to apply control characters, such as '\x08 \x08' that should remove the precedent char, to a string (move backwards, write space, move backwards)<br/>
For example when I type into python console :</p>
<pre><code>s = "test\x08 \x08"
print s
print repr(s)
</code></pre>
<p>I get in my terminal :<br/></p>
<pre><code>tes
'test\x08 \x08'
</code></pre>
<p>I'm looking for a function, let's says "function", that will 'apply' control characters to my string :</p>
<pre><code>v = function("test\x08 \x08")
sys.stdout.write(v)
sys.stdout.write(repr(v))
</code></pre>
<p>so I get a "clean", control-characters-free string:</p>
<pre><code>tes
tes
</code></pre>
<p>I understand that in a terminal, this part is handled by the client so maybe there is a way to get the <b>displayed</b> string, using core unix functions</p>
<pre><code>echo -e 'test\x08 \x08'
cat file.out # control char are here handled by the client
&gt;&gt; tes
cat -v file.out # which prints the "actual" content of the file
&gt;&gt; test^H ^H
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually, the answer was a bit more complicated than a simple formatting.</p>
<p>Every character sent by the process to the terminal can be seen as a transition in a Finite State Machine (FSM). This FSM's state roughly corresponds to the sentence displayed and the cursor position, but there are many other variables such as the dimensions of the terminal, the current control sequence being inputted*, the terminal mode (ex: VI mode / classic BASH console), etc.</p>
<p>An good implementation of this FSM can be seen in the <a href="https://github.com/noahspurrier/pexpect/blob/master/ANSI.py" rel="nofollow noreferrer">pexpect source code</a>.</p>
<p><strong>To answer my question</strong>, there is no core unix "function" that can format the string to what is displayed in the terminal, since such a function is specific to the terminal that renders process' output and you would have to rewrite a full terminal to handle every possible character and control sequence.</p>
<p>However we can implement a simple one ourselves. We need to define a FSM with an initial state :</p>
<ul>
<li>displayed string: "" (empty string)</li>
<li>position of the cursor: 0</li>
</ul>
<p>and transitions (input characters):</p>
<ul>
<li>any alphanumeric/space character: replaces the character at the cursor position by itself (or adds if there is none) and increments the cursor position</li>
<li><code>\x08</code> hex code: decrements the cursor position</li>
</ul>
<p>and feed it the string.</p>
<h2>Python solution</h2>
<pre><code>def decode(input_string):

    # Initial state
    # String is stored as a list because
    # python forbids the modification of
    # a string
    displayed_string = [] 
    cursor_position = 0

    # Loop on our input (transitions sequence)
    for character in input_string:

        # Alphanumeric transition
        if str.isalnum(character) or str.isspace(character):
            # Add the character to the string
            displayed_string[cursor_position:cursor_position+1] = character 
            # Move the cursor forward
            cursor_position += 1

        # Backward transition
        elif character == "\x08":
            # Move the cursor backward
            cursor_position -= 1
        else:
            print("{} is not handled by this function".format(repr(character)))

    # We transform our "list" string back to a real string
    return "".join(displayed_string)
</code></pre>
<p>And an example</p>
<pre><code>&gt;&gt;&gt; decode("test\x08 \x08")
tes 
</code></pre>
<h2>Note about control sequences</h2>
<p>An ANSI control sequence is a set of characters that act as a transition on the (display/cursor/terminal mode/...) state of the terminal. It can be seen as a refinement of our FSM state and transitions with more sub-states and sub-transitions.</p>
<p>For example: when you press the UP key in a classic Unix terminal (such as the VT100), you actually enter the control sequence: <code>ESC 0 A</code> where <code>ESC</code> is hex code <code>\x1b</code>. <code>ESC</code> transitions to ESCAPE mode, and it returns to normal mode after A.</p>
<p>Some processes interpret this sequence as a move of the vertical cursor position (VI), others as a move backward in the history (BASH) : it depends fully on the program that handles the input.</p>
<p>However, the same sequence can be used the output process but it will most likely move the cursor up in the screen : it depends on the terminal implementation.</p>
<p>A good list of ANSI control sequences is available <a href="http://vt100.net/docs/tp83/appendixb.html" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">You <i>could</i> process backspace as a <code>'\r'</code> (i.e. carriage return) and then write the preceding string, but that's going to be awkward, I think.</span>
<span class="comment-copy">The control characters are dependant on the terminal type, these are held in either the terminfo or termcap databases.  So python would have to use those databases to translate \x08 into whatever you think it means for your particular terminal type.  If yo are only using a small number of those characters then you could figure that out yourself.  Where is this data coming from?  See also <a href="https://docs.python.org/3/library/termios.html#module-termios" rel="nofollow noreferrer">docs.python.org/3/library/termios.html#module-termios</a></span>
<span class="comment-copy">Thanks for giving such a detailed answer to your own question. Helped me!</span>
