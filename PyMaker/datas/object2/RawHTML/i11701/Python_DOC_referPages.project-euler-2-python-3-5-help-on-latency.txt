<div class="post-text" itemprop="text">
<p>I'm new to coding and trying to do the project euler exercises to improve my knowledge on coding. I have come across several solutions with regards to Project Euler #2. </p>
<p>However, I would want to know why my code takes so much longer to compute as compared to a solution I found. </p>
<p>I would appreciate if anyone can guide me as to the differences between the two.</p>
<hr/>
<p>My code:</p>
<pre><code>def fib(n):
if n==0:
    return 0
elif n == 1:
    return 1
else:
    f=fib(n-1)+fib(n-2)
    return f

i=0
store=[]
while fib(i)&lt;=4000000:
    i += 1
    if fib(i)%2 == 0:
        store.append(fib(i))

print('The total is: '+str(sum(store)))
</code></pre>
<hr/>
<p>Online Solution I found:</p>
<pre><code>a = 1
b = 2
s = 0
while b &lt;= 4000000:
if not b % 2:
    s += b
a, b = b, a + b
print(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To calculated <code>fib(10)</code>, with your implementation:</p>
<pre><code>fib(10) = fib(9) + fib(8)
</code></pre>
<p>in which <code>fib(9)</code> is calculated recursively:</p>
<pre><code>fib(9) = fib(8) + fib(7)
</code></pre>
<p>See the problem? The result of <code>fib(8)</code> has to be calculated twice! To further expand the expression (e.g, to get the result of <code>fib(8)</code>), the redundant calculation is huge when the number is big.</p>
<hr/>
<p>Recursion itself isn't the problem, but you have to store the result of smaller fibonacci numbers rather than calculating the same expression on and on. One possible solution is to use a dictionary to store the intermediate result.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using recursive calls to a function where the other solution uses a plain iterative loop.</p>
<p>Making a function call is bound to some overhead for calling and returning from it. For bigger numbers of n you will have a lot of those function calls.</p>
<p>Appending to a list over and over and summing it up is probably also slower than doing this via an accumulator.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your solution calls a recursive function (with 2 recursions) each time it goes in your while loop. Then in the loop you run that same function again. 
The other solution only adds numbers and then does a permutation.
I guess you didn't really need the fibonacci, but if you insist on using it, run it only once and save the result, instead of re-runing it. 
Plus you store all your results and sum it at the end. That consumes a bit of time (not only) too, maybe you didn't need to store intermediate results.</p>
</div>
<div class="post-text" itemprop="text">
<p>As several other answers pointed out, the recursion causes your <code>fib()</code> function to be called very often, 111 561 532 times in fact. This is easily seen by adding a counter:</p>
<pre><code>count = 0

def fib(n):
    global count
    count += 1

    if n==0:

# the rest of your program

print(count)
</code></pre>
<p>There are two ways to fix this; rewrite your program to be iterative rather than recursive (like the other solution you posted), or cache intermediate results from <code>fib()</code>.</p>
<p>See, you call <code>fib(8)</code>, which in turn has to call <code>fib(7)</code> and <code>fib(6)</code>, etc, etc. Just calculating <code>fib(8)</code> takes 67 calls to <code>fib()</code>!</p>
<p>But later, when you call <code>fib(9)</code>, that <strong>also</strong> calls <code>fib(8)</code>, which has to do all the work over again (67 more calls to <code>fib()</code>). This gets out of hand quickly. It would be better, if <code>fib()</code> could remember that it already calculated <code>fib(8)</code> and remember the result. This is known as <em>caching</em> or <em>memoization</em>.</p>
<p>Luckily, Python's standard library has a decorator just for that purpose, <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">functools.lru_cache</a>:</p>
<pre><code>from functools import lru_cache

@lru_cache()
def fib(n):
    if n==0:

...
</code></pre>
<p>On my computer, your program execution goes from 111 561 532 invocations of <code>fib()</code> in 27 seconds to 35 invocations in 0.028 seconds.</p>
</div>
<span class="comment-copy">Not related to any answer, but you can make a further improvement to the iterative solution by jumping from even fibonacci to even fibonacci so you can get rid of the if statement. Every 3rd fibonacci number is even, so apply the rule 3 times in a row: <code>while b &lt; 4000000: s += b; a, b = a+2*b, 2*a+3*b</code>.</span>
<span class="comment-copy">Your program as you posted it is invalid; please fix your indentation.</span>
<span class="comment-copy">While an iterative approach is flat out better than a recursive one due to the overhead of call functions, like Yu Hao points out, recursion isn't the main problem. You can make it almost as fast as the iterative solution with memoization. But without it, you end up calculating the value of <code>fib(x)</code> millions/billions of times.</span>
