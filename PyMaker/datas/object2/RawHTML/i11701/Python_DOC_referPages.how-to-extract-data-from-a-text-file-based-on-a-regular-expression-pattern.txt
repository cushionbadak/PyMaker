<div class="post-text" itemprop="text">
<p>I need some help for a python program. I've tried so many things, for hours, but it doesn't work.</p>
<p>Anyone who can help me? </p>
<p>This is what I need:</p>
<ul>
<li>I have this file: <a href="http://www.filedropper.com" rel="nofollow">http://www.filedropper.com</a> which contains information about proteins.</li>
<li>I want to filter only the proteins which match the ...exists.</li>
<li>From these proteins, I need only the ... (the text of 6 tokens, after <code>&gt;sp|</code>, and the species (second line, between the [])</li>
<li>I want the .. and ..in a .., and eventually in a table.</li>
</ul>
<p><b></b></p>
<pre><code>....

Human                         AAA111
Mouse                         BBB222
Fruit fly                     CCC333
</code></pre>
<p>What I have so far:</p>
<pre><code>import re

def main():
    ReadFile()
    file = open ("file.txt", "r")
    FilterOnRegEx(file)

def ReadFile():
    try:
        file = open ("file.txt", "r")
    except IOError:
        print ("File not found!")
    except:
        print ("Something went wrong.")

def FilterOnRegEx(file):
    f = ("[AG].{4}GK[ST]")
    for line in file:
        if f in line:
            print (line)


main()
</code></pre>
<p>You're a hero if you help me out!        </p>
</div>
<div class="post-text" itemprop="text">
<p>My first recommendation is to use a <code>with</code> statement when opening files:</p>
<pre><code>with open("ploop.fa", "r") as file:
    FilterOnRegEx(file)
</code></pre>
<p>The problem with your <code>FilterOnRegEx</code> method is:  <code>if ploop in line</code>.  The <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow"><code>in</code></a> operator, with string arguments, searches the string <code>line</code> for the exact text in <code>ploop</code>.</p>
<p>Instead you need to <a href="https://docs.python.org/3/library/re.html#re.compile" rel="nofollow">compile</a> the text form to an re object, then <a href="https://docs.python.org/3/library/re.html#re.regex.search" rel="nofollow">search</a> for matches:</p>
<pre><code>def FilterOnRegEx(file):
    ploop = ("[AG].{4}GK[ST]")
    pattern = re.compile(ploop)
    for line in file:
        match = pattern.search(line)
        if match is not None:
            print (line)
</code></pre>
<p>This will help you to move forward.</p>
<p>As a next step, I would suggest learning about <a href="https://docs.python.org/3/tutorial/classes.html#generators" rel="nofollow">generators</a>.  Printing the lines that match is great, but that doesn't help you to do further operations with them.  I might change <code>print</code> to <code>yield</code> so that I could then process the data further such as extracting the parts you want and reformatting it for output.</p>
<p>As a simple demonstration:</p>
<pre><code>def FilterOnRegEx(file):
    ploop = ("[AG].{4}GK[ST]")
    pattern = re.compile(ploop)
    for line in file:
        match = pattern.search(line)
        if match is not None:
            yield line

with open("ploop.fa", "r") as file:
    for line in FilterOnRegEx(file):
        print(line)
</code></pre>
<hr/>
<hr/>
<p><em>Addendum:</em>   I ran the code I posted, above, using the sample of the data that you posted and it successfully prints some lines and not others.  In other words, the regular expression did match some of the lines and did not match others.  So far so good.  <em>However</em>, the data you need is not all on one line in the input!  That means that filtering individual lines on the pattern is insufficient.  (Unless, of course, that I don't see the correct line breaks in the question)  The way the data is in the question you'll need to implement a more robust parser with state to know when a record begins, when a record ends, and what any given line is in the middle of a record.</p>
</div>
<div class="post-text" itemprop="text">
<p>This seems to work on your sample text. I don't know if you can have more than one extract per file, and I'm out of time here, so you'll have to extend it if needed:</p>
<pre><code>#!python3
import re

Extract = {}

def match_notes(line):
    global _State
    pattern = r"^\s+(.*)$"
    m = re.match(pattern, line.rstrip())
    if m:
        if 'notes' not in Extract:
            Extract['notes'] = []

        Extract['notes'].append(m.group(1))
        return True
    else:
        _State = match_sp
        return False

def match_pattern(line):
    global _State
    pattern = r"^\s+Pattern: (.*)$"
    m = re.match(pattern, line.rstrip())
    if m:
        Extract['pattern'] = m.group(1)
        _State = match_notes
        return True
    return False

def match_sp(line):
    global _State
    pattern = r"&gt;sp\|([^|]+)\|(.*)$"
    m = re.match(pattern, line.rstrip())
    if m:
        if 'sp' not in Extract:
            Extract['sp'] = []
        spinfo = {
            'accession code': m.group(1),
            'other code': m.group(2),
        }
        Extract['sp'].append(spinfo)
        _State = match_sp_note
        return True
    return False

def match_sp_note(line):
    """Second line of &gt;sp paragraph"""
    global _State
    pattern = r"^([^[]*)\[([^]]+)\)"
    m = re.match(pattern, line.rstrip())
    if m:
        spinfo = Extract['sp'][-1]
        spinfo['note'] = m.group(1).strip()
        spinfo['species'] = m.group(2).strip()
        spinfo['sequence'] = ''
        _State = match_sp_sequence
        return True
    return False

def match_sp_range(line):
    """Last line of &gt;sp paragraph"""
    global _State
    pattern = r"^\s+(\d+) - (\d+):\s+(.*)"
    m = re.match(pattern, line.rstrip())
    if m:
        spinfo = Extract['sp'][-1]
        spinfo['range'] = (m.group(1), m.group(2))
        spinfo['flags'] = m.group(3)
        _State = match_sp
        return True
    return False

def match_sp_sequence(line):
    """Middle block of &gt;sp paragraph"""
    global _State

    spinfo = Extract['sp'][-1]

    if re.match("^\s", line):
        # End of sequence. Check for pattern, reset state for sp
        if re.match(r"[AG].{4}GK[ST]", spinfo['sequence']):
            spinfo['ag_4gkst'] = True
        else:
            spinfo['ag_4gkst'] = False

        _State = match_sp_range
        return False

    spinfo['sequence'] += line.rstrip()
    return True

def match_start(line):
    """Start of outer item"""
    global _State
    pattern = r"^Hits for ([A-Z]+\d+)|([^:]+) : (?:\[occurs (\w+)\])?"
    m = re.match(pattern, line.rstrip())
    if m:
        Extract['pattern_id'] = m.group(1)
        Extract['title'] = m.group(2)
        Extract['occurrence'] = m.group(3)
        _State = match_pattern
        return True
    return False

_State = match_start

def process_line(line):
    while True:
        state = _State
        if state(line):
            return True

        if _State is not state:
            continue

        if len(line) == 0:
            return False

        print("Unexpected line:", line)
        print("State was:", _State)
        return False

def process_file(filename):
    with open(filename, "r") as infile:
        for line in infile:
            process_line(line.rstrip())

process_file("ploop.fa")
import pprint
pprint.pprint(Extract)
</code></pre>
</div>
<span class="comment-copy">It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far, example input (if there is any), the expected output, and the output you actually get (console output, tracebacks, etc.). The more detail you provide, the more answers you are likely to receive. Check the <a href="https://stackoverflow.com/tour">FAQ</a> and <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a>.</span>
<span class="comment-copy">Hi, and welcome to SO. Please read <a href="http://stackoverflow.com/help/how-to-ask">stackoverflow.com/help/how-to-ask</a> :) You'll probably get downvoted, because people are not very welcoming sometimes, but don't worry too much about that. Update your question, or create a new one, with the best thing you've tried so far and what problem(s) you ran into. I'm sure you'll get help.</span>
<span class="comment-copy">It's edited. But I get stuck in the regular expression function, so I don't have much code. And it's not that I have tried nothing, I've tried so many things, for hours and hours, but it just don't work. But it's edited!</span>
<span class="comment-copy">Can you check the link to your data file? It doesn't seem to work - maybe it needs to be made "public"?</span>
<span class="comment-copy">As a brief note, you need to use <code>re.compile()</code> and <a href="https://docs.python.org/3/library/re.html#re.regex.search" rel="nofollow noreferrer"><code>re.search()</code></a> to search for a regular expression, not the <code>in</code> operator.</span>
<span class="comment-copy">Thanks for the good explanation! Indeed, this works. Never learned something at school about yield, but indeed, it's useful. Good to know that the regular expression works. But now the script must print all the lines belong to the lines that have a match with the RE. (So, if there is a match in the protein sequence, it must print all information from the file about these proteins). After that, I must take the accession code (<code>Q6GZX2</code> in the first protein), and the species (<code>Frog virus 3 (isolate Goorha) (FV-3)</code> in the first protein). 1/2</span>
<span class="comment-copy">Do you think it's a good idea to do this with a list in a list (a list of proteins, separated by each 2 newlines, containing lists of information, including the accession code and the species), or is there a better way?</span>
<span class="comment-copy">Personally, I would start with making a data structure for a single record, then make a parser for the file.  I find it easier to manage the code when I create a class for my data than to try and keep track of lists of lists and what each index means at each level.</span>
<span class="comment-copy">Is each group of lines ("record") separate by two newlines?  If so then that makes your life easier (since the entire file fits in memory at once).  For such a specific purpose program, I would just read the entire file at once (<a href="https://docs.python.org/3.5/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer"><code>.read()</code></a>, then <a href="https://docs.python.org/3.5/library/stdtypes.html#str.split" rel="nofollow noreferrer"><code>.split('\n\n')</code></a> to get a list of records.  Then apply the match and process the strings that match. In the "real world" I wouldn't do this so that I could handle larger amounts of data.</span>
<span class="comment-copy">Yeah, I already read something about classes when I googled it. But it looked a bit complicated. What's the base for a class for a script like this? Then maybe I can expand it.</span>
<span class="comment-copy">Thanks for the code! I've tried it, it's not the table I need, but I think I can use this for the final code! First I get some lines with an error (<a href="http://i63.tinypic.com/2621kpw.png" rel="nofollow noreferrer">i63.tinypic.com/2621kpw.png</a>), after that I get the proteins with their other data (<a href="http://i63.tinypic.com/312ehrp.png" rel="nofollow noreferrer">i63.tinypic.com/312ehrp.png</a>). But it's good to see that the data (accession code etc) are on an apart line, with a name! Thanks</span>
