<div class="post-text" itemprop="text">
<p>I have a python <code>set</code> that contains a collection of non-hashable python objects with uniform type which I want to process.</p>
<p>To improve efficiency of my algorithms, I would like to interface using ctypes with an external index implementation that accepts only <code>uint64</code> as data values.</p>
<p>I was hoping that I could to pass pointer references to the python object into this external library as <code>uint64</code>?</p>
<p>I tried <code>ctypes.cast(ctypes.py_object(my_python_object), ctypes.c_uint64)</code> but am getting <code>ctypes.ArgumentError: argument 1: &lt;class 'TypeError'&gt;: wrong type</code>.</p>
<p>Also, what about the reverse, getting a reference to a python object as <code>uint64</code> and turning it into a "real" python object?</p>
</div>
<div class="post-text" itemprop="text">
<p>Why wouldn't you simply use the <code>id()</code> function in CPython?</p>
<pre><code>&gt;&gt;&gt; x
&lt;object object at 0x7fd2fc742090&gt;
&gt;&gt;&gt; hex(id(x))
'0x7fd2fc742090'
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow">CPython documentation of <code>id()</code></a> says that </p>
<blockquote>
<p><code>id(object)</code></p>
<p>Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same <code>id()</code> value.</p>
<p>CPython implementation detail: <strong>This is the address of the object in memory.</strong></p>
</blockquote>
<hr/>
<p>You also need to mess with the reference counts and such, if you're to "convert" this <code>uint64_t</code> of yours back to a Python object. As far as I know, <code>ctypes</code> do not easily let one to increase/decrease the reference counts of Python</p>
</div>
<span class="comment-copy">Seriously, what's wrong with using <code>id()</code>?</span>
<span class="comment-copy">@AnttiHaapala Seriously nothing. :-) Just that I never realised it existed. Any chance of getting a python object from the <code>id()</code> value? If not, I could always convert my <code>set</code> into a <code>dict</code> with the ids as keys.</span>
<span class="comment-copy">The thing is... If your object is dead, you cannot get it back from the <code>id()</code> - instead you will crash your interperter :D</span>
<span class="comment-copy">Would tools like Cython or manually writing a small extension module to interface with the C code be an option?</span>
<span class="comment-copy">What you're doing seems dubious, but you haven't provided enough details to say one way or the other. Anyway, if you're working directly on Python objects using a C library, make sure to load it as a <code>PyDLL</code> instance that holds the GIL when calling functions. Then just set the function's <code>argtypes</code>, with the Python object parameter defined as <code>py_object</code>. The C function will handle this as a <code>uint64_t</code>. Passing the object directly increments the reference count during the call, so there's no danger of the object getting deallocated on another thread.</span>
<span class="comment-copy">Many thanks. But why the <code>hex()</code>?</span>
<span class="comment-copy">Strictly speaking, this implementation detail could change in the future.</span>
<span class="comment-copy">The very similar case of <code>object.__hash__</code> <a href="http://bugs.python.org/issue5186" rel="nofollow noreferrer">actually has changed</a> in the past; it no longer just returns <code>id(self)</code>. I wouldn't be entirely surprised if they ever decide to change <code>id</code>, for example, to reduce the same kind of bucket collisions that occurred with <code>object.__hash__</code>.</span>
