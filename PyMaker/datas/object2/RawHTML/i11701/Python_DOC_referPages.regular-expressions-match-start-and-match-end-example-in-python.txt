<div class="post-text" itemprop="text">
<p>Struggling to get a good grasp of <em>regular expressions</em> and especially of their <code>match.start()</code> and <code>match.end()</code> methods.</p>
<p>While playing with this code (found <a href="https://docs.python.org/3/library/re.html#writing-a-tokenizer" rel="nofollow">here</a>):</p>
<pre><code>Token = collections.namedtuple('Token', ['typ', 'value', 'line', 'column'])

def tokenize(code):
    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}
    token_specification = [
        ('NUMBER',  r'\d+(\.\d*)?'), # Integer or decimal number
        ('ASSIGN',  r':='),          # Assignment operator
        ('END',     r';'),           # Statement terminator
        ('ID',      r'[A-Za-z]+'),   # Identifiers
        ('OP',      r'[+\-*/]'),     # Arithmetic operators
        ('NEWLINE', r'\n'),          # Line endings
        ('SKIP',    r'[ \t]+'),      # Skip over spaces and tabs
        ('MISMATCH',r'.'),           # Any other character
    ]
    tok_regex = '|'.join('(?P&lt;%s&gt;%s)' % pair for pair in token_specification)
    line_num = 1
    line_start = 0
    for mo in re.finditer(tok_regex, code):
        kind = mo.lastgroup
        value = mo.group(kind)
        if kind == 'NEWLINE':
            line_start = mo.end()
            line_num += 1
        elif kind == 'SKIP':
            pass
        elif kind == 'MISMATCH':
            raise RuntimeError('%r unexpected on line %d' % (value, line_num))
        else:
            if kind == 'ID' and value in keywords:
                kind = value
            column = mo.start() - line_start
            yield Token(kind, value, line_num, column)

statements = '''
    IF quantity THEN
        total := total + price * quantity;
        tax := price * 0.05;
    ENDIF;
'''

for token in tokenize(statements):
    print(token)
</code></pre>
<p>I cannot understand the use and logic when computing the line and column using the <code>mo.end()</code> and <code>mo.start()</code>. <strong>For example</strong>, if I were to have the <code>NEWLINE</code> and the <code>SKIP</code> to also yield a <code>Token</code> output then the column indexes are messed up completely.
Tried re-calculating with the <code>mo.end()</code> the column indexes to accommodate for this case as mentioned in the example but failed.
Any ideas, example-code and/or explanations would be awesome.  </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/re.html#re.match.start" rel="nofollow"><code>mo.start</code></a> and <a href="https://docs.python.org/3/library/re.html#re.match.end" rel="nofollow"><code>mo.end</code></a> will return you the start and end indexes of the match so that <code>string[mo.start():mo.end()]</code> will return you the matched string. Every time your example matches <code>\n</code> it will increase the <code>line_num</code> that tracks current line and update <code>line_start</code> to contain the index of first character in current line. This allows the program to later calculate the column when token is matched: <code>column = mo.start() - line_start</code>.</p>
<p>To illustrate the line and column tracking behavior I've created a simple example that finds all the numbers in given string. For every number it will output the line and starting column:</p>
<pre><code>import re

PATTERN = '(?P&lt;NEWLINE&gt;\n)|(?P&lt;NUMBER&gt;\d+)'
s = '''word he12re 5 there
mo912re
another line 17
'''

line = 1
line_start = 0
for mo in re.finditer(PATTERN, s):
    if mo.lastgroup == 'NEWLINE':
        # Found new line, increase line number and change line_start to
        # contain index of first character on the line
        line += 1
        line_start = mo.end()
    elif mo.lastgroup == 'NUMBER':
        # Column: index of start of the match - index of first char on line
        column = mo.start() - line_start
        print('line {0}: {1} at column {2}'.format(line, mo.group(0), column))
</code></pre>
<p>Output:</p>
<pre><code>line 1: 12 at column 7
line 1: 5 at column 12
line 2: 912 at column 2
line 3: 17 at column 13
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's an implementation that I believe satisfies your criteria: if you could post what you've tried perhaps we could better understand the problems you're having.</p>
<pre><code>import collections
import re
Token = collections.namedtuple('Token', ['typ', 'value', 'line', 'column'])

def tokenize(code):
    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}
    token_specification = [
        ('NUMBER',  r'\d+(\.\d*)?'), # Integer or decimal number
        ('ASSIGN',  r':='),          # Assignment operator
        ('END',     r';'),           # Statement terminator
        ('ID',      r'[A-Za-z]+'),   # Identifiers
        ('OP',      r'[+\-*/]'),     # Arithmetic operators
        ('NEWLINE', r'\n'),          # Line endings
        ('SKIP',    r'[ \t]+'),      # Skip over spaces and tabs
        ('MISMATCH',r'.'),           # Any other character
    ]
    tok_regex = '|'.join('(?P&lt;%s&gt;%s)' % pair for pair in token_specification)
    line_num = 1
    line_start = 0
    for mo in re.finditer(tok_regex, code):
        kind = mo.lastgroup
        value = mo.group(kind)
        column = (mo.start() - line_start) + 1

        if kind == 'MISMATCH':
            raise RuntimeError('%r unexpected on line %d' % (value, line_num))
        else:
            if kind == 'ID' and value in keywords:
                kind = value
            yield Token(kind, value, line_num, column)
            if kind == 'NEWLINE':
                line_start = mo.end()
                line_num += 1


statements = '''
    IF quantity THEN 
        total := total + price * quantity;
        tax := price * 0.05;
    ENDIF;
'''

for token in tokenize(statements):
    print(token)
</code></pre>
<p>Output:</p>
<pre><code>Token(typ='NEWLINE', value='\n', line=1, column=1)
Token(typ='SKIP', value='    ', line=2, column=1)
Token(typ='IF', value='IF', line=2, column=5)
Token(typ='SKIP', value=' ', line=2, column=7)
Token(typ='ID', value='quantity', line=2, column=8)
Token(typ='SKIP', value=' ', line=2, column=16)
Token(typ='THEN', value='THEN', line=2, column=17)
Token(typ='SKIP', value=' ', line=2, column=21)
Token(typ='NEWLINE', value='\n', line=2, column=22)
Token(typ='SKIP', value='        ', line=3, column=1)
Token(typ='ID', value='total', line=3, column=9)
Token(typ='SKIP', value=' ', line=3, column=14)
Token(typ='ASSIGN', value=':=', line=3, column=15)
Token(typ='SKIP', value=' ', line=3, column=17)
Token(typ='ID', value='total', line=3, column=18)
Token(typ='SKIP', value=' ', line=3, column=23)
Token(typ='OP', value='+', line=3, column=24)
Token(typ='SKIP', value=' ', line=3, column=25)
Token(typ='ID', value='price', line=3, column=26)
Token(typ='SKIP', value=' ', line=3, column=31)
Token(typ='OP', value='*', line=3, column=32)
Token(typ='SKIP', value=' ', line=3, column=33)
Token(typ='ID', value='quantity', line=3, column=34)
Token(typ='END', value=';', line=3, column=42)
Token(typ='NEWLINE', value='\n', line=3, column=43)
Token(typ='SKIP', value='        ', line=4, column=1)
Token(typ='ID', value='tax', line=4, column=9)
Token(typ='SKIP', value=' ', line=4, column=12)
Token(typ='ASSIGN', value=':=', line=4, column=13)
Token(typ='SKIP', value=' ', line=4, column=15)
Token(typ='ID', value='price', line=4, column=16)
Token(typ='SKIP', value=' ', line=4, column=21)
Token(typ='OP', value='*', line=4, column=22)
Token(typ='SKIP', value=' ', line=4, column=23)
Token(typ='NUMBER', value='0.05', line=4, column=24)
Token(typ='END', value=';', line=4, column=28)
Token(typ='NEWLINE', value='\n', line=4, column=29)
Token(typ='SKIP', value='    ', line=5, column=1)
Token(typ='ENDIF', value='ENDIF', line=5, column=5)
Token(typ='END', value=';', line=5, column=10)
Token(typ='NEWLINE', value='\n', line=5, column=11)
</code></pre>
</div>
<span class="comment-copy">If you see at the <a href="https://docs.python.org/3/library/re.html#re.match.start" rel="nofollow noreferrer">docs</a> there a few examples (although I must say I don't understand much either).</span>
<span class="comment-copy">Thanks, I 've seen them but did not become any wiser in order to implement that example case I mention on the description :/</span>
<span class="comment-copy">I've updated the tokens to match the documentation so that the code you've provided runs correctly: please let me know if that was an intentional omission on your part</span>
<span class="comment-copy">Why is <code>column</code> 1 less than it should be? e.g. first <code>Token</code> should have column 1 not 0. Any ideas how can we fix that?</span>
<span class="comment-copy">@Karim because <code>match.start</code> uses <code>0</code> for the first "column", not <code>1</code>.  That's pretty normal in programming.  You can just add 1 when printing it out</span>
<span class="comment-copy">@Karim you'll notice this holds true of the original code as well: it's just not obvious because you never see something printing out at column "0".  But the <code>IF</code> is printed at column <code>4</code> not column <code>5</code> for example</span>
<span class="comment-copy">So right before each <code>yield</code> you increase by one the <code>column</code>?</span>
<span class="comment-copy">yes just <code>yield Token(kind, value, line_num, column+1)</code></span>
