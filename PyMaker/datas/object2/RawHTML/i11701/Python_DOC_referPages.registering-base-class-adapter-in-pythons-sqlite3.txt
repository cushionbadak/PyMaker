<div class="post-text" itemprop="text">
<p>Considering I have a dynamically created class:</p>
<pre><code>def create_dynamic_class(*args):
    class Dynamic:
        def __init__(self, args):
            self.args_string = str(args)
</code></pre>
<p>How can I register an adapter for <code>sqlite3</code> converting this class to an sqlite object such as text?</p>
<p>I have tried creating a base class like so:</p>
<pre><code>class BaseDynamic: pass
def create_dynamic_class(*args):
    class Dynamic(BaseDynamic):
        def __init__(self, args):
            self.args_string = str(args)
</code></pre>
<p>And registring an adapter using <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.register_adapter" rel="nofollow"><code>sqlite3.register_adapter</code></a> like so:</p>
<pre><code>import operator
sqlite3.register_adapter(BaseDynamic, operator.attrgetter("args_string"))
</code></pre>
<p>But it doesn't seem to work. How do I register the base class?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the python docs, you may implement a <a href="https://docs.python.org/3/library/sqlite3.html#letting-your-object-adapt-itself" rel="nofollow"><code>__conform__()</code></a> method on the base class which returns an <code>sqlite3</code> object. The method will be inherited by the child class and allow sqlite3 to work with the new dynamic type.</p>
<p>In your case, this is the code you need in order for it to work:</p>
<pre><code>class BaseDynamic:
    def __conform__(self, protocol):
        if protocol is sqlite3.PrepareProtocol:
            return self.args_string
</code></pre>
<p>It will return your string and allow it to exist in the sqlite database.</p>
</div>
