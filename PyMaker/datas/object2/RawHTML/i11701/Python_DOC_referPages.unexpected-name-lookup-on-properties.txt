<div class="post-text" itemprop="text">
<p>Consider this code:</p>
<pre><code>class Foo(object):
    @property
    def func(self):
        self.__dict__['func'] = 1 
        return 2

f = Foo()
print f.func
print f.func
</code></pre>
<p>It prints <code>2 2</code>. Why, the second time, does it not print <code>1</code>? </p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>f.func</code> where <code>f</code> is an instance of <code>Foo</code> and <code>func</code> is a <code>property</code> descriptor triggers</p>
<pre><code>Foo.func.__get__(f)
</code></pre>
<p>(see <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="nofollow"><em>Descriptor protocol</em></a>).</p>
<p><code>self.__dict__['func'] = 1</code> modifies the underlying dictionary of the <code>f</code> instance. It doesn't change the <code>func</code> attribute of the <code>Foo</code> class.</p>
<p><code>Foo.func</code> takes precedence over <code>f.func</code> (<em>= 1</em>, newly created instance variable) because</p>
<blockquote>
<p>If an instance’s dictionary has an entry with the same name as a data
  descriptor, the data descriptor takes precedence. </p>
</blockquote>
<p>(copied from the link above).</p>
<hr/>
<p>You'll have to assign something to <code>Foo.func</code> if you want to replace the property:</p>
<pre><code>class Foo(object):
    @property
    def func(self):
        Foo.func = 1 
        return 2

f = Foo()
print(f.func) # 2
print(f.func) # 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://stackoverflow.com/questions/11211233/how-python-attribute-lookup-process-works">this post</a>, the attribute lookup process goes in this order:</p>
<blockquote>
<ol>
<li>If attrname is a special (i.e. Python-provided) attribute for objectname, return it.</li>
<li>Check objectname.__class__.__dict__ for attrname. If it exists and is a data-descriptor, return the descriptor result. Search all
  bases of objectname.__class__ for the same case.</li>
<li>Check objectname.__dict__ for attrname, and return if found. If objectname is a class, search its bases too. If it is a class and a
  descriptor exists in it or its bases, return the descriptor result.</li>
<li>Check objectname.__class__.__dict__ for attrname. If it exists and is a non-data descriptor, return the descriptor result. If it
  exists, and is not a descriptor, just return it. If it exists and is a
  data descriptor, we shouldn't be here because we would have returned
  at point 2. Search all bases of objectname.__class__ for same case.</li>
<li>Raise AttributeError.</li>
</ol>
</blockquote>
<p>The property decorator adds a key-value pair to the object's class' <code>__dict__</code>, so it gets found in step 2. Names added to the object's <code>__dict__</code> are checked in step 3. So between the two, properties take precedence.</p>
</div>
<span class="comment-copy">Why would you expect it to print 1 the second time?</span>
<span class="comment-copy"><b>f.__dict__['func']</b> gives 1</span>
<span class="comment-copy">+1 for the link. "If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence" pretty much explains things.</span>
