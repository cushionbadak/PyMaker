<div class="post-text" itemprop="text">
<p>Full (non-working) code below</p>
<p>Full (working, w/o threading) code here: <a href="http://pastebin.com/KUYzNtT2" rel="nofollow">http://pastebin.com/KUYzNtT2</a></p>
<p>I've written a small script that does the following:</p>
<ol>
<li>Pull network information from a database</li>
<li>Ping each IP in a cidr (ie - 192.168.0.0/24); if it's up, test to see if a certain port is open</li>
<li>Display the results</li>
</ol>
<p>This is working fine, but I'd like to implement threading to make the script run faster; as is I have thousands of IPs to scan and it takes forever.</p>
<p>I've played around with threading tutorials but can't seem to grasp how to implement it in my script.</p>
<p>Any thoughts or suggestions are appreciated. </p>
<p><strong>EDIT: I went in a different direction based on this guide: <a href="http://chriskiehl.com/article/parallelism-in-one-line/" rel="nofollow">http://chriskiehl.com/article/parallelism-in-one-line/</a></strong></p>
<p>Now I run the program and get: <code>File "port_test.py", line 39, in display_results
    for (client, location, cidr) in results:
ValueError: too many values to unpack (expected 3)</code>
and I don't understand why. Thoughts?</p>
<p>**EDIT: I think I figured out why it failed, looks like pool.map expects only one data point. If I only query the DB for CIDRs instead of the other two columns, the program starts spitting out data (MUCH faster than before). So now I need to figure out how to add the other two columns to the results, then sort the results to they make sense (there's no order to the results, which I suppose makes sense)</p>
<pre><code>#! /usr/bin/python
# Import modules
import socket
import subprocess
import ipaddress
import mysql.connector
import configparser
import logging
import coloredlogs
from multiprocessing.dummy import Pool as ThreadPool

#logging.basicConfig(format='%(levelname)s:%(message)s',level=logging.INFO)


coloredlogs.install(level='DEBUG')
coloredlogs.DEFAULT_LOG_FORMAT = '%(asctime)s -- %(message)s'
# read from the config file
config = configparser.ConfigParser()
config.read('config.ini')
db=config['mysql']
net=config['network']
port = int(net['port'])

# create the connection, connect, and setup the query
cnx = mysql.connector.connect(user=db['user'], database=db['database'], password=db['password'])
cursor = cnx.cursor()

query = ("select fw.net_cidr as cidr "
        "from firewalls fw "
            "left join clients c on c.id = fw.client_id "
            "left join locations l on l.id = fw.location_id "
                "where fw.net_cidr &lt;&gt; '' and c.active = '1' and fw.active = '1'")

cursor.execute(query)
results = cursor.fetchall()

def display_results(results):
# execute and display the results
    for (cidr) in results:
            logging.info("{} --&gt; ".format(cidr))
            try:
                # Prompt the user to input a network address
                net_addr = str(cidr)

                # Create the network
                ip_net = ipaddress.ip_network(net_addr)

                 # Get all hosts on that network
                all_hosts = list(ip_net.hosts())
            except ValueError as e:
                logging.warning(e)
                continue

            # For each IP address in the subnet, test to see if port 3389 is open
            for i in range(len(all_hosts)):
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(.25)
                result = sock.connect_ex((str(all_hosts[i]),port))
                if result == 0:
                        logging.info(str(all_hosts[i]) + ": " + net['port'] + " is open")
            else:
                    logging.debug(str(all_hosts[i]) + ": " + net['port'] + " is not open")

# make a pool of workers
pool = ThreadPool(4)

# ping the cidrs in their own thread
pool.map(display_results, results)
pool.close()
pool.join()

# close the database connection
cursor.close()
cnx.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Grab all the data initially and store it in a <code>Queue</code>. </p>
<p>Create a function that runs continuously until the <code>Queue</code> is empty (i.e. <code>while my_queue.empty() is False</code>.</p>
<p>Grab the first object in the <code>Queue</code> with <code>Queue</code>'s <code>get()</code> method.</p>
<p>Then process it.</p>
<p>Initialize as many threads as you want, they will execute until the <code>Queue</code> is empty.</p>
</div>
<span class="comment-copy">See <a href="http://stackoverflow.com/a/35925129/1172714">this answer</a>.  You need your threads to use different data (they can't share a cursor to a single database query) to do different work. You have four threads calling a function that requires an argument with no argument Then you consume the cursor's results after trying to start the threads and then close the connection without waiting to see if the threads are finished. (but they are at this point because they failed to call the function with the wrong number of arguments)</span>
<span class="comment-copy">also, have a look to concurrent.futures module which has both ProcessPoolExecutor and ThreadPoolExecutor. They have nice examples in the docs. python 3: <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">docs.python.org/3/library/concurrent.futures.html</a> python 2.7: <a href="http://pythonhosted.org/futures/" rel="nofollow noreferrer">pythonhosted.org/futures</a></span>
<span class="comment-copy">Keep in mind that in CPython only one thread at a time can be executing Python bytecode because of the Global Interpreter Lock. Your gains with threading might not be as big as you expect. Try e.g. a <code>multiprocessing.Pool</code> instead.</span>
<span class="comment-copy">@jmd9qs By "use different data" I do mean you should split the results up between the threads. You could do it by loading all the data into a list, if it won't be too large for available memory. You could do it by opening separate connections to the database and running the query with LIMIT and OFFSET constraints. Or you could do it by creating a thread-safe queue (I would consider writing a generator function) that returns the items one at a time and have the threads take the data from the queue.</span>
<span class="comment-copy">@jmd9qs Now your code does this: for each row in the database do the following four times: scan the entire network and print the results then create a thread to do nothing.  You code does exactly what the question I linked to does which is call the function <i>before</i> creating the thread, which completely defeats the purpose and concept of threading.  Also, it still does not wait for the threads to finish before closing the database connection and exiting.</span>
