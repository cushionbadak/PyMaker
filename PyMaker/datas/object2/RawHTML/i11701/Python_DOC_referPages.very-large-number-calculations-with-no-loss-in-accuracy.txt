<div class="post-text" itemprop="text">
<p>Very Large number Calculations with No Loss in Accuracy ?</p>
<p>Given a 1700 digit number, we want to store the value and perform two functions on it
with NO loss of accuracy, its ok if calc time takes longer but better if faster.</p>
<p>Where <code>x</code> = a 1700 digit long numeric value</p>
<p>The two calcs to be computed with be ;</p>
<p><code>X</code> * (up to a four digit value )</p>
<p>then we take the modulus of this resultant of 400 ;</p>
<pre><code>( x % 400 )
</code></pre>
<p>If we cant multiply  [ <code>X</code> * (up to a four digit value ) ] and then take the modulus due to 
processing bottlenecks, ceilings - then can this be done where we first take the
modulus of the original <code>x</code> = 1700 digits and then multiply this by the four digit value
and then take the modulus of this after?  Ideally Id prefer to be able to do the
first scenario.</p>
<p>Constraints Im aware of regarding this to date ;</p>
<p>Firstly, Im only running on a WinXp 32 bit system and not able to upgrade currently.</p>
<p>Secondly, Ive been becoming aware of a lot of issues, bugs, errors with python, sympy,
etc.. in properly handling very large number calcs.  These problems seem to arise
out of data loss through use of floats and related.  Details on a number of different
approaches can be viewed here ;</p>
<p><a href="https://groups.google.com/forum/#!topic/sympy/eUfW6C_nHdI" rel="nofollow">https://groups.google.com/forum/#!topic/sympy/eUfW6C_nHdI</a>
<a href="https://groups.google.com/forum/#!topic/sympy/hgoQ74iZLkk" rel="nofollow">https://groups.google.com/forum/#!topic/sympy/hgoQ74iZLkk</a></p>
<p>My system will not properly handle "float128" floats, although Ive been told
by one person this would be able to handle wsuch a computation - altho the prob
is it seems that float128 is rarely actually a 128 float and certainly not on my system.
Also due to internal processing peculiarties it seems that most floats will lose
data on these kinds of computations.  If I understand correctly, one of the best 
candidates for getting the most accurate values returned involves the use
of arbitrary precision and representing the inputs as strings and not just straight numeroc
values?  Also, ideally, Id like the formula to be able to handle rationals without
accuracy loss.  So  "x" starts off as a whole number, but when I multiply it
by the four digit value, Id like that value to be any numeric value such as an integer,
whole number or rational like "2243.0456".</p>
<p>Structure of one of the methods Ive been experimenting with ;</p>
<pre><code>from sympy import mpmath
mpmath.mp.dps = 1700
x = (mpmath.mpf" INSERT 1700 DIGIT NUMBER HERE"
(x % 400)
</code></pre>
<p>An example with live data ;</p>
<pre><code>from sympy import mpmath
mpmath.mp.dps = 1700
x = (mpmath.mpf"4224837741562986738552195234618134569391350587851527986076117152972791626026988760293885754068768475423919991676816860701478996539715076968649431668262941552499272851934021744703799728797962346859481772141964720120813934781420732260156446701740408591264289745960985811289070246238359268267313892549883722768575435935465369820850766441187744058828599331364172396647692768693734233545999439071435129082764340446292057962343360114463696515950803159895238667237356887294549618489296157716384494295159851060500050371940523385701946860964162569067371175357615144192344763876540813882107379891591055307476597279137714860430053785074855035948744902479909111840444834198237419177418965268614345042634655648237818899253116247916585686713243193074635608527160273611309051938762676520507404815180792793701259216609316118483835216791263172902470123821111779223204735647931377027227055312940934756325611832463728974558417085791096461266371917752574370345933533929245534623041989305973992490523694190318284666464757159324866096861573704540654160644711274766759520501013633999706244117691235878123489694261724158073725644897527727473450037615295487637338687848351441331386946416003718795419822246935787682977520303924734875834943985619000970655639767984458204513958680501990182471695393372003272654902387493955849775308922901631024199011283441050881608686856746206012270890984260424834329551281249797545775091226433669036680463406283858413423722935297859778786945935751468048494081427689669730664660260908636113264573712854536295005312934569838992758429422872122606102877623867968067833225444280667381025371705347744037508121975424674439904984528128036994803804742198422695627759844248"
(x % 400)
</code></pre>
<p>But I have no idea if accurate results are being returned with this, would love to hear anyones suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/fractions.html" rel="nofollow">Fractions</a> can grow to a very large amount. Although less efficient, they might do what you want.</p>
</div>
<span class="comment-copy">Dunno, just assigning that huge number to a variable and doing modulus works fine for me on Mac OS. Pure Python can handle <i>very</i> big numbers out-of-the-box</span>
<span class="comment-copy">Are you just working with integers? Python already comes with arbitrary-precision exact integer arithmetic built-in. You don't need to bring in an arbitrary-precision floating-point library.</span>
<span class="comment-copy">Why not check the results in google, wolfram, or octave?</span>
<span class="comment-copy">Is <code>x</code> an integer? Is your first operation multiplication, or exponentiation? You've shown an integer and multiplication here, but in your linked newsgroup posts you're using a non-integer number and exponentiation. For integers and multiplication, using Python's builtin <code>int</code> and/or <code>long</code> types will work just fine <code>n=int(long_number_string); print(n*1234%400)</code>. For exponentiation, you'd want to use a better algorithm (though ordinary integers should still work). If your very long number is supposed to be a relatively small but very high precision decimal, you'd have a real question.</span>
<span class="comment-copy">Thanks for the feedback folks!  In this example, "x" will always be entered as an integer, however the value can be as high as 2000 digits.  My understanding is that long, longdouble, etc arent sufficient enough to store and manipulate this value.  In this case I wont be dealing with exponentiation, however if I want to multiply an integer by a 4 digit rational ( or decimal, fractional value ), this surely wont work as an integer when processing, also my understanding is that if i even just perform a modulus on this size of number most of the common approaches result in data loss....</span>
<span class="comment-copy">My understanding is that Fractions are limited to 15 digits of precision?  No where near enough for such a large number of 1700 to 2000 digits?</span>
<span class="comment-copy">Fractions have an effectively unlimited precision. As long as the calculation remains in the integer or rational domain, it is 100% accurate. When you convert the final rational value to a floating point type, then an approximation occurs. Instead of converting to a float, you can convert to a <code>Decimal</code>, <code>mpmath.mpf</code>, <code>gmpy2.mpfr</code>, or any other extended precision floating type and get whatever precision you need.</span>
