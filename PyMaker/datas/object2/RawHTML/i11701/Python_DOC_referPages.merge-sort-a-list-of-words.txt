<div class="post-text" itemprop="text">
<p>I have implemented the mergesort algorithm using a post on codereview. It's working nicely on a list of integers but I thought a more practical application is need. So I downloaded a text file with random english words and attempted to sort them.</p>
<p>However it does absolutely nothing.</p>
<pre><code>def merge_sort(seq):
    if len(seq) == 1:
        return seq
    else:
        # recursive step. Break the list into chunks of 1
        mid_index = len(seq) // 2
        left  = merge_sort( seq[:mid_index] )
        right = merge_sort( seq[mid_index:] )

    left_counter, right_counter, master_counter = 0, 0, 0

    while left_counter &lt; len(left) and right_counter &lt; len(right):
        if left[left_counter] &lt; right[right_counter]:
            seq[master_counter] = left[left_counter]
            left_counter += 1
        else:
            seq[master_counter] = right[right_counter]
            right_counter += 1

        master_counter += 1

    # Handle the remaining items in the remaining_list
    # Either left or right is done already, so only one of these two
    #    loops will execute

    while left_counter &lt; len(left):  # left list isn't done yet
        seq[master_counter] = left[left_counter]
        left_counter   += 1
        master_counter += 1

    while right_counter &lt; len(right):  # right list isn't done yet
        seq[master_counter] = right[right_counter]
        right_counter   += 1
        master_counter  += 1

    return seq
</code></pre>
<p>I think the problem is that it's handling a list of lists instead of a single list. Also the function has no way of knowing what's the basis of sorting. Is that correct?</p>
<p>Here is how I want to call it</p>
<pre><code>with open('words.txt') as f:
    list_of_words = f.read().splitlines()
    new = merge_sort(list_of_words)
    print(new == sorted(list_of_words, key=len))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you identified the problem is that <code>merge_sort</code> has no way of knowing the basis of sorting. You could change <code>merge_sort</code> to take in an additional parameter that returns the key for each element in the sequence just like <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow"><code>sorted</code></a> does:</p>
<pre><code>def merge_sort(seq, key=lambda x: x):
</code></pre>
<p>Then change the comparison to call passed function instead of comparing elements directly:</p>
<pre><code>if key(left[left_counter]) &lt; key(right[right_counter]):
    seq[master_counter] = left[left_counter]
    left_counter += 1
else:
    seq[master_counter] = right[right_counter]
    right_counter += 1
</code></pre>
<p>And finally pass key to recursive calls:</p>
<pre><code>left  = merge_sort( seq[:mid_index], key )
right = merge_sort( seq[mid_index:], key )
</code></pre>
<p>With these changes it will work as you expect:</p>
<pre><code>merge_sort([4, 6, 2, 1]) # [1, 2, 4, 6]
merge_sort(['foo', 'a', 'bar', 'foobar'], key=len) # ['a', 'bar', 'foo', 'foobar']
</code></pre>
<p>One thing to note though is that results are not identical with <code>sorted</code> since <code>merge_sort</code> is not <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" rel="nofollow">stable</a>:</p>
<pre><code>merge_sort(['foo', 'a', 'bar', 'foobar'], key=len) # ['a', 'bar', 'foo', 'foobar']
sorted(['foo', 'a', 'bar', 'foobar'], key=len) # ['a', 'foo', 'bar', 'foobar']
</code></pre>
</div>
<span class="comment-copy">Excellent. Thanks niemmi. Especially for the point on stability. It would've drove me crazy :)</span>
<span class="comment-copy">It does not work all the time niemmi. I tried running it with merge_sort( ['aa', 'b', 'aaaaaa', 'www'], key=len) ?!?!?</span>
<span class="comment-copy">@MAA: I forgot to pass the key to recursive calls, I've fixed the answer.</span>
<span class="comment-copy">it works. Thanx again ^_^</span>
<span class="comment-copy">Merge sort is stable, the issue is the key compare is using &lt; instead of &lt;=..</span>
