<div class="post-text" itemprop="text">
<p>I have recently started using the mock framework in python. It seems that if I patch a function, the actual code is not called - which means that the database changes etc that this actual function does is not implemented.
I have been trying to go around it by calling the function before hand and storing the return value and passing it as arg in patch(), but 
is there a better way to do it? Ideally, I would want a code that works as a <code>silent observer</code> and i can simply ask it if a certain <code>observed</code> function was called or not, how many times, and with what arguments</p>
<h2>My current code</h2>
<pre><code>return_val = funct()

# C: Now call me again and assert that these intensive computation functions are not called but taken from cache
with patch('funct', return_value=return_val) as mock_task:

    me_response = self.client.get(me_url, format='json')    #should fetch from cache
    assert not mock_task.called
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could set the <code>Mock#side_effect</code> attribute to your original function.</p>
<pre><code>orig = funct
funct = Mock(side_effect=orig)
</code></pre>
<p>I do find loganasherjones' answer more elegant.</p>
<p>Just adding another possibility for those who may need it.</p>
</div>
<div class="post-text" itemprop="text">
<p>To mock a method called, you should use the <a href="https://docs.python.org/3/library/unittest.mock.html#the-mock-class" rel="nofollow noreferrer"><code>wraps</code></a> keyword. Consider the following:</p>
<pre><code>class Foo(object):

    def do_thing(self, a):
        print("A: %s" % a)
        self._do_private_thing(a)

    def _do_private_thing(self, a):
        print("PRIVATE STUFF HAPPENING.")
        print("A: %s" % a)
</code></pre>
<p>Then In your test you would have something like:</p>
<pre><code>import mock
a = Foo()
with mock.patch.object(a, '_do_private_thing', wraps=a._do_private_thing) as private_mock:
    a.do_thing("lol")
    private_mock.assert_called_with("lol")
</code></pre>
<p>Hope this helps.</p>
</div>
<span class="comment-copy">You don't mock the function you are testing. You mock the methods inside the function you are testing, so you can test its expected behaviour. So, if you have a method <code>foo</code> you want to test, and inside <code>foo</code> you are making a call to some method <code>bar</code>, you want to mock <code>bar</code>.</span>
