<div class="post-text" itemprop="text">
<p>I am trying to analyze some binary files and assumed that Python's <code>read()</code> function returned a string from this <a href="https://stackoverflow.com/questions/16037390/whats-the-type-of-read-functions-return-value-in-python">article</a> and a Tutorials Point <a href="http://www.tutorialspoint.com/python/file_read.htm" rel="nofollow noreferrer">article</a>.</p>
<p>Yet when I messed around <code>read()</code> myself I got a something other than what I read.</p>
<pre><code>&gt;&gt;&gt; with gzip.open('RTLog_20150424T194428.gz') as f:
       a = f.read(3)
       print(a)
       type(a)


b'use'
&lt;class 'bytes'&gt;
&gt;&gt;&gt; a
b'use'
&gt;&gt;&gt; str(a)
"b'use'"
&gt;&gt;&gt; b = 'asdfasdfasdf'
&gt;&gt;&gt; type(b)
&lt;class 'str'&gt;
&gt;&gt;&gt; 
</code></pre>
<p>When tested on my own, the output of a <code>read()</code> call returned a <code>&lt;class 'bytes'&gt;</code> object, not a <code>&lt;class 'str'&gt;</code> object. </p>
<p>What am I not getting?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using Python 3.  You linked to information about Python 2.</p>
<p>The <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow">documentation</a> states:</p>
<blockquote>
<p>As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding. In text mode (the default, or when 't' is included in the mode argument), the contents of the file are returned as str, the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given.</p>
</blockquote>
<p>Python 3 is very deliberate about bytes versus characters (strings).  Python 2 is sloppy about it, which can cause many problems.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can open in <code>rb</code> or <code>rt</code> mode (the default is read binary, giving you bytes).  This is mentioned in the <code>gzip.open</code> docstring:  </p>
<blockquote>
<p>The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or "ab" for
  binary mode, or "rt", "wt", "xt" or "at" for text mode. The default mode is
  "rb", and the default compresslevel is 9.</p>
</blockquote>
<p>If you pass the keyword argument <code>mode="rt"</code> when opening (and you know the right encoding), then you should get a string returned when calling <code>read</code> method.  </p>
</div>
<span class="comment-copy">Most likely because <code>gzip.open</code> opens the file in binary mode.</span>
<span class="comment-copy">So the tutorials I've been reading assume that I've been opening text files, not binary files?</span>
<span class="comment-copy">Examples from pages you linked show that they use <code>open</code>, not <code>gzip.open</code>. These functions have different default values for the <code>mode</code> argument.</span>
<span class="comment-copy">Um ok I'll try with just open however, I do open files with the form <code>open('filename', 'rb')</code> and the output isn't a string either.</span>
<span class="comment-copy">Yes, because <code>b</code> means "open the file in binary mode"</span>
<span class="comment-copy">I have chosen this too be accepted since it answers my question. I guess I really need to be careful when reading documentation on older versions of python.</span>
<span class="comment-copy">Ok but if I'm reading a binary file will this mean that my output is type bytes?</span>
<span class="comment-copy">@Dzhao: Yes, as it should be. You might be getting confused by resources that assume Python 2, where <code>str</code> is the bytestring type.</span>
<span class="comment-copy">You can read any file as bytes or as text.  Whether you get garbage or not depends on what's in the file.</span>
<span class="comment-copy">@Dzhao Yes. If the sequence of bytes are not a valid sequence for the character encoding that you are using to decode them, then you will get an error as it fails.  This is no different from any other data format where some sequences of bytes are not meaningful and/or not valid.</span>
