<div class="post-text" itemprop="text">
<p>I have a list of some elements, e.g. <code>[1, 2, 3, 4]</code> and a single object, e.g. <code>'a'</code>. I want to produce a list of tuples with the elements of the list in the first position and the single object in the second position: <code>[(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a')]</code>.</p>
<p>I could do it with <code>zip</code> like this:</p>
<pre><code>def zip_with_scalar(l, o): # l - the list; o - the object
    return list(zip(l, [o] * len(l)))
</code></pre>
<p>However this gives me a feeling of creating and unnecessary list of repeating element.</p>
<p>Another possibility is</p>
<pre><code>def zip_with_scalar(l, o):
    return [(i, o) for i in l]
</code></pre>
<p>which is very clean and pythonic indeed, but here I do the whole thing "manually". In Haskell I would do something like</p>
<pre class="lang-hs prettyprint-override"><code>zipWithScalar l o = zip l $ repeat o
</code></pre>
<p>Is there any built-in function or trick, either for the zipping with scalar or for something that would enable me to use ordinary zip, i.e. sort-of infinite list?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the cloest to your Haskell solution:</p>
<pre><code>import itertools

def zip_with_scalar(l, o):
    return zip(l, itertools.repeat(o))
</code></pre>
<p>You could also use generators, which avoid creating a list like comprehensions do:</p>
<pre><code>def zip_with_scalar(l, o):
    return ((i, o) for i in l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the built-in <code>map</code> function:</p>
<pre><code>&gt;&gt;&gt; elements = [1, 2, 3, 4]
&gt;&gt;&gt; key = 'a'
&gt;&gt;&gt; map(lambda e: (e, key), elements)
[(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a perfect job for the <a href="https://docs.python.org/3.5/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle</code></a> class.</p>
<pre><code>from itertools import cycle


def zip_with_scalar(l, o):
    return zip(i, cycle(o))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; l = [1, 2, 3, 4]
&gt;&gt;&gt; list(zip(l, cycle('a')))
[(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also use <em>zip_longest</em> with a fillvalue of <code>o</code>:</p>
<pre><code>from itertools import zip_longest

def zip_with_scalar(l, o): # l - the list; o - the object
    return zip_longest(l, [o], fillvalue=o)

print(list(zip_with_scalar([1, 2, 3, 4] ,"a")))
</code></pre>
<p>Just be aware that any mutable values used for <code>o</code> won't be copied whether using zip_longest or repeat.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>lst = [1,2,3,4]
tups = [(itm, 'a') for itm in lst]
tups

&gt; [(1, 'a'), (2, 'a'), (3, 'a'), (4, 'a')]
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.repeat</a></span>
<span class="comment-copy">What jonrsharpe said, but also you probably want to rewrite that as a generator, rather than a regular function.</span>
<span class="comment-copy">@OmnipotentEntity as the OP is using 3.x they can just <code>return zip(l, repeat(o))</code>; it's an iterator, no need to <code>yield</code>.</span>
<span class="comment-copy">Good point, I missed the tag.</span>
<span class="comment-copy">Just be careful with mutable values for o or you may get some surprises</span>
<span class="comment-copy">The argument to <code>cycle</code> must be an iterable, doesn't it? It works with <code>'a'</code> as it is string, but not with an arbitrary object.</span>
<span class="comment-copy">@zegkljan yes it must be an iterable.</span>
<span class="comment-copy">Only if the object to map to is an iterable of length one, <code>cycle</code> gives the result this question is asking for. If you do the same for the string <code>'ab'</code> instead of <code>'a</code>' you get the following: <code>[(1, 'a'), (2, 'b'), (3, 'a'), (4, 'b')]</code></span>
<span class="comment-copy">string are iterable if you want to return the string indefinitely you should put this into a container. <code>list</code> will do fine. <code>list(zip(range(20), cycle(["ab"])))</code> @Swier</span>
