<div class="post-text" itemprop="text">
<p>I want to know if there's a more Pythonic way of doing the following:</p>
<pre><code>A = some list
i = 0
j = 1
for _ in range(1, len(A)):
    #some operation between A[i] and A[j]
    i += 1
    j += 1
</code></pre>
<p>I feel like this should/could be done differently. Ideas?</p>
<p>EDIT:
Since some are asking for requirements. I wanted a <strong>general-purpose</strong> answer. Maybe to check if A[i], A[j] are between a certain range, or if they're equal. Or maybe I wanted to do a "trickle-up" of elements. The more general, the better. </p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.5/library/functions.html#zip" rel="nofollow"><code>zip</code></a> lets you combine multiple iterators:</p>
<pre><code>for i,j in zip(range(0,len(A)-1), range(1,len(A))):
    #some operation between A[i] and A[j]
</code></pre>
<p>you can also use <a href="https://docs.python.org/3.5/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> on a range object:</p>
<pre><code>for i,j in enumerate(range(1,len(A)):
    #some operation between A[i] and A[j]
</code></pre>
<p>Note that unlike the other answers this gives you access to the <em>indices</em> of A not just the items, this is necessary if you want to use any <em>assignment</em> to <code>A[i]</code> or <code>A[j]</code>, for example here is a very basic bubble sort:</p>
<pre><code>A = list(range(10))
found1=True
while found1:
    found1=False
    for i,j in enumerate(range(1,len(A))):
        if A[i] &lt; A[j]:
            A[i],A[j] = A[j],A[i]
            found1=True
print(A)
</code></pre>
<p>this is <em>only</em> possible when you iterate over the <em>indices</em> of A.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a nice little recipe in <a href="https://docs.python.org/3/library/itertools.html" rel="noreferrer"><code>itertools</code></a> for doing this. As a bonus it works with any iterable, not just sequences.</p>
<pre><code>from itertools import tee

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

for current, next_ in pairwise(A):
    # do something
    pass
</code></pre>
<p>If you need the index as well then just <code>enumerate</code> the pairwise iterator.</p>
<pre><code>for current_index, (current, next_) in enumerate(pairwise(A)):
    # do something
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For operation '+':</p>
<pre><code>A = [A[i+1]+A[i] for i in range(len(A)-1)]
</code></pre>
<p>General:</p>
<pre><code>A = [operation(A[i], A[i+1]) for i in range(len(A)-1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do :</p>
<pre><code>A = some list
for Ai, Aj in zip(A, A[1:]):
    #some operation between A[i] and A[j]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import islice
A1 = iter(A)
A2 = islice(A,1)
for a1, a2 in zip(A1, A2):
    # do whatever with A[i], A[i+1]
</code></pre>
<p>You can use normal slice <code>A[1:]</code>, but that makes another list wasting memory. Now <code>zip()</code> emits values till the <code>shortest</code> iterator(<code>A2</code>) is exhausted. So no worries about the possible <code>IndexError</code>.</p>
</div>
<span class="comment-copy">do you need access to the indices of the list or would iterating over just the elements without the indices work for you?</span>
<span class="comment-copy">what are the return values for enumerate. grossly confused. is it index, value. How does enumerate know if it is index, value or value and nextvalue. ?</span>
<span class="comment-copy">@Whatever You can check the help for enumerate with <code>help(enumerate)</code> which details how enumerate works. It's always yields a sequence 2-tuples of <code>index, element_at_index</code>. However, I further unpack <code>element_at_index</code> into  <code>current</code> and <code>next_</code> (because that's what <code>pairwise</code> produces).</span>
<span class="comment-copy">you are no longer iterating over indices but the elements in A</span>
<span class="comment-copy">Yes but if the purpose is to do some operation between Ai and Aj, it seems to work.</span>
<span class="comment-copy"><code>zip</code> is a good idea here, assuming you don't need the indices of Ai and Aj. You can also shave off a few characters by doing <code>zip(A, A[1:])</code>. When <code>zip</code> receives two iterables of different lengths, it only iterates up to the end of the shorter one. So cutting the last element off using <code>A[:-1]</code> isn't strictly necessary.</span>
<span class="comment-copy">not if you want to switch the elements in <code>A[i]</code> with <code>A[j]</code></span>
<span class="comment-copy">Good point about omitting [:-1]. Noted</span>
