<div class="post-text" itemprop="text">
<p>Suppose I have a dictionary that is nested arbitrarily:</p>
<pre><code>d = {
    11: {
        21: {31: 'a', 32: 'b'},
        22: {31: 'a', 34: 'c'},
    },
    12: {
        1: {2: 3}
    }
}
</code></pre>
<p>And a list of keys whose position tells me which nested dictionary to look for every key in:</p>
<pre><code>keys = [11, 21, 31]
# keys = [11, 23, 44]
</code></pre>
<p>Is there a simple one liner to do this? I've looked at the questions listed below, and they are similar, but not really what I'm looking for. I have also attempted it myself and came up with this:</p>
<pre><code>from functools import reduce

def lookup(d, key):
    return d.get(key, {}) if d and isinstance(d, dict) else None

def fn(keys, d):
    return reduce(lookup, keys, d)

print(fn(keys, d)) # prints 'a'
</code></pre>
<p>The problem with this, is that in case of second list of keys (see commented out keys), it continues looking up nested keys further, even though the higher level key wasn't found, and continuing is pointless. How can I stop <code>reduce</code> as soon as I find a final match or fail (one of the questions listed below addresses it, but I can't really apply it in my use case... or can I?)? Any other ideas? Oh and I want to accomplish this using official python libraries only. So no <code>numpy</code>, <code>pandas</code> etc, but <code>functools</code>, <code>itertools</code> are fine</p>
<p><a href="https://stackoverflow.com/questions/36582893/python-convert-list-to-dict-keys-for-multidimensional-dict-with-exception-handl#36582893">Python: Convert list to dict keys for multidimensional dict with exception handling</a></p>
<p><a href="https://stackoverflow.com/questions/22787366/is-there-a-simple-one-liner-for-accessing-each-element-of-a-nested-dictioanry-in">Is there a simple one-liner for accessing each element of a nested dictioanry in Python?</a></p>
<p><a href="https://stackoverflow.com/questions/18982993/accessing-nested-values-in-nested-dictionaries-in-python-3-3">Accessing nested values in nested dictionaries in Python 3.3</a></p>
<p><a href="https://stackoverflow.com/questions/15636670/using-itertools-for-recursive-function-application">Using itertools for recursive function application</a></p>
<p><a href="https://stackoverflow.com/questions/3130352/stopping-a-reduce-operation-mid-way-functional-way-of-doing-partial-running-s">Stopping a Reduce() operation mid way. Functional way of doing partial running sum</a></p>
<p><a href="https://stackoverflow.com/questions/14962485/finding-a-key-recursively-in-a-dictionary">Finding a key recursively in a dictionary</a></p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce()</code></a>:</p>
<pre><code>from functools import reduce # In Python 2, don't import it. (It's a built-in)

print(reduce(dict.get, keys, d))

# 'a'
</code></pre>
<p>For the keys you mentioned, it goes like this:</p>
<ul>
<li>call <code>dict.get</code> with <code>d</code> (initial) and the first item of <code>keys</code> (<code>11</code>) to get <code>d[11]</code></li>
<li>call <code>dict.get</code> with the result (a dictionary) and the next item in <code>keys</code> (<code>21</code>) to get <code>{...}[21]</code></li>
<li>call <code>dict.get</code> ...<br/>
...</li>
</ul>
<p>until <code>keys</code> is "reduced" to the final value (<code>'a'</code>)</p>
<p><strong>Edit</strong>: As <code>dict.get</code> results in <code>None</code> if there is no such key, there might be undesired results.  If you want to have a <code>KeyError</code>, you can use <a href="https://docs.python.org/2/library/operator.html#operator.getitem" rel="nofollow"><code>operator.getitem</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution I came up with that also gives back useful information when given an invalid lookup path, and allows you to dig through arbitrary json, including nested list and dict structures. (Sorry it's not a one-liner).</p>
<pre><code>def get_furthest(s, path):
    '''
    Gets the furthest value along a given key path in a subscriptable structure.

    subscriptable, list -&gt; any
    :param s: the subscriptable structure to examine
    :param path: the lookup path to follow
    :return: a tuple of the value at the furthest valid key, and whether the full path is valid
    '''

    def step_key(acc, key):
        s = acc[0]
        if isinstance(s, str):
            return (s, False)
        try:
            return (s[key], acc[1])
        except LookupError:
            return (s, False)

    return reduce(step_key, path, (s, True))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = {
    11: {
        21: {
            31: 'a from dict'
        },
    },
}

l = [None] * 50
l[11] = [None] * 50
l[11][21] = [None] * 50
l[11][21][31] = 'a from list'

from functools import reduce

goodkeys = [11, 21, 31]
badkeys = [11, 12, 13]

print("Reducing dictionary (good):", reduce(lambda c,k: c.__getitem__(k), goodkeys, d))
try:
    print("Reducing dictionary (bad):", reduce(lambda c,k: c.__getitem__(k), badkeys, d))
except Exception as ex:
    print(type(ex), ex)

print("Reducing list (good):", reduce(lambda c,k: c.__getitem__(k), goodkeys, l))

try:
    print("Reducing list (bad):", reduce(lambda c,k: c.__getitem__(k), badkeys, l))
except Exception as ex:
    print(type(ex), ex)
</code></pre>
</div>
<span class="comment-copy">not sure i understand what you are trying to do, will this help? <code>d[keys[0]][keys[1]][keys[2]]</code> it will find a final match if exist or fail if not</span>
<span class="comment-copy">That's what I want, but I don't want to use indices because the list can be of arbitrary length too</span>
<span class="comment-copy">If you use <code>dict.__getitem__</code> as your function for <code>reduce</code>, it will raise an exception when either the type is wrong or the key is not found. I think this meets your need to stop early. Just wrap the <code>reduce</code> in a <code>try</code> block.</span>
<span class="comment-copy">You might replace the lambda with <code>dict.__getitem__</code>, I think.</span>
<span class="comment-copy">@Norman I was going to suggest that but wanted to check the method first and don't have python installed on this computer! But yeah, +1 for that suggestion.</span>
<span class="comment-copy"><code>print(reduce(dict.get, keys, d))</code></span>
<span class="comment-copy">@PadraicCunningham: Yes, thanks.  I prefer that to <code>dict.__getitem__</code></span>
<span class="comment-copy">That has the effect of returning <code>None</code> if the final key isn't found, I think, which may or may not be what you want. (<code>__getitem__</code> will throw <code>KeyError</code>.) Either would work depending on what you want.</span>
