<div class="post-text" itemprop="text">
<p>So what I want to do is create a class that wraps an int and allows some things not normally allowed with int types. I don't really care if its not pythonic or w/e I'm just looking for results. Here is my code:</p>
<pre><code>class tInt(int):
    def __add__(self, other):
        if type(other) == str:
            return str(self) + str(other)
        elif type(other) == int:
            return int(self) + other
        elif type(other) == float:
            return float(self) + float(other)
        else:
            return self + other
a = tInt(2)
print (a + "5")
print ("5" + a)
</code></pre>
<p>The output was.</p>
<pre><code>&gt;&gt; 25
Traceback (most recent call last):
  File "C:\example.py", line 14, in &lt;module&gt;
    print ("5" + a)
TypeError: Can't convert 'tInt' object to str implicitly
</code></pre>
<p>So, the first print statement ran nicely, and gave what I expected, but the second one gave an error. I think this is because the first one is using tInt's <strong>add</strong> function because a appeared before + "5" and the second one used the string "5"'s <strong>add</strong> function first because it appeared first. I know this but I don't really know how to either force a's <strong>add</strong> function or allow the tInt class to be represented as a string/int/etc.. when a normal type appears before it in an operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to implement an <code>__radd__</code> method to handle the case when an instance of your class is on the right hand side of the addition. </p>
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow">docs</a> say:</p>
<blockquote>
<p>These methods are called to implement the binary arithmetic operations
  (+, -, *, @, /, //, %, divmod(), pow(), **, &lt;&lt;, &gt;&gt;, &amp;, ^, |) with
  reflected (swapped) operands. These functions are only called if the
  left operand does not support the corresponding operation and the
  operands are of different types. <a href="https://docs.python.org/3/library/constants.html?highlight=notimplemented#NotImplemented" rel="nofollow">2</a> For instance, to evaluate the
  expression x - y, where y is an instance of a class that has an
  <strong>rsub</strong>() method, y.<strong>rsub</strong>(x) is called if x.<strong>sub</strong>(y) returns NotImplemented.</p>
</blockquote>
<p>Example:</p>
<pre><code>class tInt(int):

    def __add__(self, other):
        if isinstance(other, str):
            return str(self) + str(other)
        elif isinstance(other, int):
            return int(self) + other
        elif isinstance(other, float):
            return float(self) + float(other)
        else:
            return NotImplemented

    def __radd__(self, other):
        return self.__add__(other) 

a = tInt(2)
for x in ["5", 5, 5.0]:
    print (a + x)
    print (x + a)

25
25

7
7

7.0
7.0
</code></pre>
<p>As @chepner pointed out in the comments, returning <a href="https://docs.python.org/3/library/constants.html?highlight=notimplemented#NotImplemented" rel="nofollow">NotImplemented</a> for cases that your method doesn't handle will cause Python to try other ways of performing the operation, or raise a TypeError if there is no way to perform the requested operation.</p>
</div>
<span class="comment-copy">The <code>else</code> clause will cause infinite recursion. <code>self + other</code> will call <code>self.__add__(other)</code> again.</span>
<span class="comment-copy">Damn, I didn't think of that. So I should sort of "sanitize" all my other ones by making sure self is a different type?</span>
<span class="comment-copy">Use <code>return NotImplemented</code> instead. This will instruct Python to either try <code>tInt.__radd__(other)</code> if it is defined, or to try <code>type(other).__add__(self)</code> if not.</span>
