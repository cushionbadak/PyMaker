<div class="post-text" itemprop="text">
<p>I suck at Python regex and would love to see some <em>solved examples</em> to help me gain understanding. I am experimenting using <a href="http://pyregex.com/" rel="nofollow">http://pyregex.com/</a> which is great but need some 'good' examples to get me started.</p>
<p>I try to create a set of rules like so:</p>
<pre><code>rules = [('name', r'[a-z]+'),
         ('operator', r'[+-*\]']
</code></pre>
<p>which I have <a href="https://docs.python.org/3/library/re.html#writing-a-tokenizer" rel="nofollow">found</a> but not confident enough to create my own regexes for cases like the ones listed below:</p>
<ol>
<li>match only the <code>=</code> or <code>+=</code> or <code>*=</code> characters</li>
<li>match the <code>+</code> character (i.e the <code>operator</code> as seen above) separately from the <code>++</code> characters</li>
<li>match any one word <strong>after</strong> a specific keyword (e.g. <code>int</code>) and any number of space(s) and/or tabs. [edited - initially had followed which was wrong]</li>
</ol>
<p>For 1. I have tried <code>[\+=|=]</code>, for 2. I know the order in the rules is important and for 3. I am completely lost with the <code>[]</code> and on how I can generalize that case to work not just for <code>int</code>, but for <code>float</code> as well.</p>
<p>Any code examples will be greatly appreciated since I am only just starting with Python and coding!</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>match only the = or += or *= characters</p>
</blockquote>
<pre><code>r'[+*]?='
</code></pre>
<p>The <code>[+*]?=</code> consists of an optional atom, a character class <code>[+*]</code> that matches either a <code>+</code> or a <code>*</code>, <code>?</code> - one or zero times, and a literal <code>=</code> symbol. Why not <code>r'\+=|\*=|='</code>? Not only the optional character class solution is shorter, but also it is more efficient: when you use alternation, you always have more redundant backtracking involved. You also need to be attentive to place the alternatives in a correct order, so that the longest appears first (although that does not always guarantee that the longest will match (depends on the branch subpatterns), or the order does not matter if there are anchors on both sides of the alternation group).</p>
<blockquote>
<p>match the + character (i.e the operator as seen above) separately from the ++ characters</p>
</blockquote>
<pre><code>r'(?&lt;!\+)\+(?!\+)'
</code></pre>
<p>This pattern matches a literal <code>+</code> (as it is escaped) and only in case it is neither preceded with another plus (see the negative lookbehind <code>(?&lt;!\+)</code>) nor followed with another plus (see the positive lookahead <code>(?!\+)</code>). The lookarounds are non-consuming, i.e. the regex index remains right before a plus when it checks for a plus in front of it, and after the plus when it checks for a plus after it. The characters (or start/end of string positions) are not returned as part of the match (that is why they are called <em>zero-width</em>, <em>non-capturing</em> patterns).</p>
<blockquote>
<p>match any one word after a specific keyword (e.g. int) and any number of space(s) and/or tabs.</p>
</blockquote>
<pre><code>r'\bint\b(?=\s+\w+\s+)'
</code></pre>
<p>If you read the explanation above, you will recognize another zero-width assertion here: <code>(?=\s+\w+\s+)</code> is a positive lookahead that checks if a whole word <code>int</code> (as <code>\b</code> matches word boundary positions) is followed with 1+ whitespaces, then 1+ word characters, and then again 1+ whitespaces.</p>
</div>
<div class="post-text" itemprop="text">
<p>The examples provided in the documentation and in the previous answers should get you started in the right path. An additional consideration, since you said you are new to programming and Python, is that regular expressions are an <em>intermediate</em> to <em>advanced</em> topic (depending what you want to do with it) and should be tackled once you have a better grasp of good programming practices and Python's fundamentals.
In any case more information and examples can be found at:
<a href="https://docs.python.org/2/library/re.html" rel="nofollow">Python Regular Expressions module</a>.</p>
</div>
<span class="comment-copy">1) <code>r'[+*]?='</code>, 2) <code>r'(?&lt;!\+)\+(?!\+)'</code>, 2) <code>r'\b\w+\b(?=\s+int\s+)'</code>.</span>
<span class="comment-copy"><a href="https://regex101.com/r/oC4tX2/1" rel="nofollow noreferrer">First</a>, <a href="https://regex101.com/r/oC4tX2/2" rel="nofollow noreferrer">second</a> and <a href="https://regex101.com/r/oC4tX2/3" rel="nofollow noreferrer">third</a> requirement.</span>
<span class="comment-copy">You don't provide enough information. Need examples of usage, not just individual isolated parts. I'm guessing the actual usage is a lot more complex.</span>
<span class="comment-copy">@Jan Thanks, but the  <code>r[=*+]+</code> for the first one also matches <code>==</code>, <code>++</code>, <code>**</code> etc. whereas I want just to match the <code>=</code> or <code>+=</code> or <code>*=</code></span>
<span class="comment-copy">@WiktorStribizew Your answers appear to be what I want, thanks. However, in trying to understand them I have a few questions; instead of using <code>?</code> for the first one, could we not explicitly provide <code>++</code> and <code>**</code>? If so, how can put characters in a set when they are not single-chars (like <code>++</code>)?</span>
<span class="comment-copy">Great stuff, thank you for your time in explaining them so clearly. One small question:   for the 1st one, I understand your point about efficiency, is there a way to make sure that cases such as <code>+++++=</code> are not matched?</span>
<span class="comment-copy">@Karim: That depends on what the input is. Perhaps, the easiest will be to require whitespace to be on both sides of the expression: <a href="https://regex101.com/r/zS5rL2/1" rel="nofollow noreferrer"><code>(?&lt;!\S)[+*]?=(?!\S)</code></a>. Or you will be safer with the alternations then: <a href="https://regex101.com/r/zS5rL2/2" rel="nofollow noreferrer"><code>(?&lt;!\+)\+=(?!=)|(?&lt;!\*)\*=(?!=)|(?&lt;![=*+])=(?!=)</code></a>. Note it is just because Python re does not accept infinite width lookbehind.</span>
<span class="comment-copy">Great explanation ..+1.</span>
