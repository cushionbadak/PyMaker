<div class="post-text" itemprop="text">
<p>I'm trying out the python <code>timeit</code> function in my Python REPL.  It can time small pieces of code in two ways:  Either as a callable, or as a quoted expression.  I'd like to know why the following code produces different timing results.</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit("lambda *args: None")
0.058281898498535156
&gt;&gt;&gt; timeit.timeit(lambda *args: None)
0.0947730541229248
&gt;&gt;&gt;
</code></pre>
<p>My intuition tells me that there should be more 'overhead' associated with the quoted string variant because it requires interpretation, but this does not appear to be the case.  But apparently my intuition is mistaken..</p>
<p>Here's another code snippet. There does not appear a huge time difference between invoking the callable function vs. timing the quoted function statement:</p>
<pre><code>&gt;&gt;&gt; def costly_func():
...     return list(map(lambda x: x^2, range(10)))
... 
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit(costly_func)
2.421797037124634
&gt;&gt;&gt; timeit.timeit("list(map(lambda x: x^2, range(10)))")
2.3588619232177734
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Observe:</p>
<pre><code>&gt;&gt;&gt; def costly():
...  return list(map(str, list(range(1_000_000))))
...
&gt;&gt;&gt; timeit.timeit(costly, number=100)
30.65105245400082
&gt;&gt;&gt; timeit.timeit('costly', number=1_000_000_000, globals=globals())
27.45540758000061
</code></pre>
<p>Look at the <code>number</code> argument. It took 30 seconds to <em>execute the function</em> <code>costly</code> 100 times. It took almost 30 seconds to <em>execute the expression</em> <code>costly</code> 1'000'000'000 (!) times.</p>
<p>Why? Because the second code <em>does not</em> execute the function <code>costly</code>! The only thing it executes is the expression <code>costly</code>: notice the lack of parentheses, which means it's <em>not</em> a function call. The expression <code>costly</code> is basically a no-op (well, it just requires checking whether the name "costly" exists in the current scope, that's all), that's why it's so fast, and if Python was smart enough to optimise it away, the execution of the expression <code>costly</code> (<strong>not</strong> <code>costly()</code>!) would be instantaneous!</p>
<p>In your case, saying <code>lambda *args: None</code> is simply <em>defining</em> an anonymous function, right? When you execute <em>this exact code</em>, a new function is created, but not executed (in order to do that, you should <em>call</em> it: <code>(lambda *args: None)()</code>).</p>
<p>So, timing the <em>string</em> <code>"lambda *args: None"</code> with <code>timeit.timeit("lambda *args: None")</code> basically tests how fast Python can spit out new anonymous functions.</p>
<p>Timing <em>the function itself</em> with <code>timeit.timeit(lambda *args: None)</code> tests how fast Python can <em>execute</em> an <em>existing</em> function.</p>
<p>Spitting out newly created functions is a piece of cake, while actually <em>running them</em> can be really hard.</p>
<p>Take this code for example:</p>
<pre><code>def Ackermann(m, n):
    if m == 0:
        return n + 1
    if m &gt; 0:
        if n == 0:
            return Ackermann(m - 1, 1)
        elif n &gt; 0:
            return Ackermann(m - 1, Ackermann(m, n - 1))
</code></pre>
<p>If you put that exact code in a string and <code>timeit</code> it, you'll get something like this:</p>
<pre><code>&gt;&gt;&gt; code = """def Ackermann(m, n):
...     if m == 0:
...         return 0
...     if m &gt; 0:
...         if n == 0:
...             return Ackermann(m - 1, 1)
...         elif n &gt; 0:
...             return Ackermann(m - 1, Ackermann(m, n - 1))"""
&gt;&gt;&gt; timeit.timeit(code, number=1_000_000)
0.10481472999890684
</code></pre>
<p>Now try to <code>timeit</code> the function itself:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit(lambda : Ackermann(6, 4), number=1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/timeit.py", line 232, in timeit
    return Timer(stmt, setup, timer, globals).timeit(number)
  File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/timeit.py", line 176, in timeit
    timing = self.inner(it, self.timer)
  File "&lt;timeit-src&gt;", line 6, in inner
  File "&lt;stdin&gt;", line 1, in &lt;lambda&gt;
  File "&lt;stdin&gt;", line 8, in Ackermann
  File "&lt;stdin&gt;", line 8, in Ackermann
  File "&lt;stdin&gt;", line 8, in Ackermann
  [Previous line repeated 1 more time]
  File "&lt;stdin&gt;", line 6, in Ackermann
  File "&lt;stdin&gt;", line 8, in Ackermann
  File "&lt;stdin&gt;", line 6, in Ackermann
  File "&lt;stdin&gt;", line 8, in Ackermann
  File "&lt;stdin&gt;", line 8, in Ackermann
  File "&lt;stdin&gt;", line 8, in Ackermann
  [Previous line repeated 983 more times]
  File "&lt;stdin&gt;", line 6, in Ackermann
  File "&lt;stdin&gt;", line 2, in Ackermann
RecursionError: maximum recursion depth exceeded in comparison
</code></pre>
<p>See - you can't even run that! Actually, probably nobody can since it's so much recursion!</p>
<p>Why did the first call succeed, though? Because it didn't execute anything, it just spit out a lot of new functions and got rid of all of them shortly after.</p>
</div>
<span class="comment-copy">Because you are timing two different things. The first times the lambda expression, i.e. the creation of that function, the other times the result of <i>calling the function</i>.</span>
<span class="comment-copy">I'm not sure I understand.  For example if I define this simple function and then run timeit using a called function and its equivalent string expression, I get roughly similar time outputs.  If one were simply constructing a function as opposed to invoking it, wouldn't the times be substantially different? <code>&gt;&gt;&gt; def costly_func(): ...     return list(map(lambda x: x^2, range(10))) ...  &gt;&gt;&gt; timeit.timeit(costly_func) 2.421797037124634 &gt;&gt;&gt; timeit.timeit("list(map(lambda x: x^2, range(10)))") 2.3588619232177734 </code></span>
<span class="comment-copy">Passing a string vs passing a function does two different things. The former times the execution of the string as source code, the latter times the execution of the function. In this case, the times won't be very different because your function does practically nothing, but try it with <code>lambda : list(range(10000))</code> and the string <code>"lambda : list(range(10000))"</code></span>
<span class="comment-copy">In the sample you provide in the comments your string expression <i>does not define a function</i> it is now essentially the body of the function so of course they are practically the same</span>
<span class="comment-copy">Dude, I don't know how else to put this, <b>they aren't doing the same things</b>. When you pass a <i>function</i> to timeit, <b>it times the execution of the function</b>. When you pass a <i>string</i> it times the evaluation of that string as code. The function <code>lambda : list(range(10000))</code> when called materializes a list of length 10000. The <i>string</i> representing the expression <code>"lambda: list(range(10000))"</code> <i>simply creates an anonymous function</i>. The function is never called, and no list is created. And creating an anonymous function is cheap, much cheaper than materializing the list of that size.</span>
<span class="comment-copy">Ok it's making sense now.  The Ackerman is a good example that relates to my first code sample:  You are right I was just defining a function but not executing it.  But what about the second sample where in one case I'm timing a callable <code>costly_func</code> and an expression <code>"list(map(lambda x: x^2, range(10)))"</code> which are doing the same thing.  Am I actually not executing anything in the second case?</span>
<span class="comment-copy">@pio, you certainly are. Your code calls <code>range</code>, <code>map</code> and finally <code>list</code> both times. I’m the colors case - because you’re executing a function that calls all of these, and in the second case - because you’re evaluating an expression that does that. If you evaluated <code>"lambda: list(...)"</code>, Python would be just creating tons of new functions and not calling any of them.</span>
<span class="comment-copy">Cool-- so for my second example where I'm invoking the same <code>list(map...</code> functionality but doing it a) via callable and b) via statement expression, why does the statement expression cost slightly less time overall than the callable way?</span>
<span class="comment-copy">@pio, because calling the callable induces overhead</span>
<span class="comment-copy">that's what I thought too, but wouldn't a statement eval induce a similar overhead e.g. the cost of interpreting or eval?</span>
