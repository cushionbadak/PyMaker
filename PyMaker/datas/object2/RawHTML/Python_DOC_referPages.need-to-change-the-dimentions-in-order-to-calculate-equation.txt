<div class="post-text" itemprop="text">
<p>Input</p>
<pre><code>
def Gaussan_wave_packet():

    quantum_number = 500
    x = np.linspace(0,100,1000).astype(complex).reshape(1000,1)
    n = np.arange(1,quantum_number+1).reshape(1,500)
    x0 = 50, a = 5, l = 1, m = 0.511*10**6, L = x[-1], hbar = 6.58211951*10**(-16)
    A = (1/(4*a**2))**(1/4.0)

    psi_x0 = (np.exp((-(x - x0)**2)/(4*a**2))*np.exp(1j*l*x)).reshape(len(x),1)

    A = ( 1/(np.sqrt(np.trapz((np.conj(psi_x0[:,0])*psi_x0[:,0]), x[:,0]))))
        psi_x0_normalized = A*psi_x0[:,0].reshape(1000,1) #(1000,1)

    phi = ( np.sqrt( 2/L ) * np.sin( (n*x*np.pi) /L ) )  #(1000,500)

    En = ( ( np.power(n,2))*(np.pi**2)*(hbar**2))/(2*m*L**2) #(1,500)

    Cn = np.trapz( ( np.conj(phi)*psi_x0_normalized[:,0] ), x[:,0] )
</code></pre>
<p>Output</p>
<pre><code>
Scalar A: (0.28246850458110645+0j)
Psi0 Normalized: (1000, 1)
Phi: (1000, 500)
En: (1, 500)
/Gaussan_wave_packet", line 48, in Gaussan_wave_packet
Cn = np.trapz( ( np.conj(phi)*psi_x0_normalized[:,0] ), x[:,0] )# Needs to be (1,500)
ValueError: operands could not be broadcast together with shapes (1000,500) (1000,) 
</code></pre>
<h2>Thoughts</h2>
<p>I'm not sure what is going wrong here. All of my variables seem to have the correct dimensions and appropriate values. As shown in the output, the shapes are correct and so are the values. I'm moving over from programming problems in MATLAB to python and I'm not really sure where this value (1000,) is coming from, for it is very different from matlab. Am I not indexing right, element-wise multiplication, or do I need a for loop. I'm not sure where to go about this. I need Cn to be shape (1,500).</p>
</div>
<div class="post-text" itemprop="text">
<p>The array index had to be applied after both phi and psi_x0_normalized were multiplied together. I also used a for loop to get Cn to the correct shape and reshaped it to a vector with multiple columns as desired.</p>
<pre><code>Q = np.zeros((quantum_number,1))
Cn = np.zeros((quantum_number,1))

Q = (np.conj(phi)*psi_x0_normalized)

print("Q: " + str(Q.shape))
#print("Q: " + str(Q))
for i in range(0,quantum_number):
    Cn[i] = np.trapz( Q[:,i], x[:,0] )# Needs to be (1,500)

Cn = Cn.reshape(1,500)
print("Cn: " + str(Cn.shape))
</code></pre>
</div>
<span class="comment-copy">Try with <code>np.conj(phi).T.dot(psi_x0_normalized[:,0] ))</code></span>
<span class="comment-copy">Returned this error: ValueError: operands could not be broadcast together with shapes (999,) (499,)</span>
<span class="comment-copy">Then it must be when integrating, try <code>np.trapz( ( np.conj(phi)*psi_x0_normalized[:,0] ).T, x[:,0] )</code></span>
<span class="comment-copy">There are subtle differences in indexing. <code>X[:, 0]</code> for a 1000x1 <code>X</code> will give you a <b>1D</b> array in Python whereas in matlab I believe it should essentially give you back <code>X</code>. What happens if you omit the <code>[:, 0]</code>?</span>
<span class="comment-copy">In that case you could try <code>[:, 0, None]</code> this should work, though the result being empty might not be that interesting.</span>
