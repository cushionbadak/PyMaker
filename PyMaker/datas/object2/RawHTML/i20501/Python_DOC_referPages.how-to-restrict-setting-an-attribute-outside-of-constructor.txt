<div class="post-text" itemprop="text">
<p>I want to forbid further assignments on some attributes of a class after it was initialized. For instance; no one can explicitly assign any value to 'ssn' (social security number) property after the Person instance 'p' has been initialized. <strong>_<em>setattr</em>_</strong> is also being called while assigning the value inside <strong>_<em>init</em>_</strong> method, thus it is not what I want. I'd like to restrict only further assignments. How can I achieve that?</p>
<pre><code>class Person(object):
    def __init__(self, name, ssn):
        self.name = name
        self._ssn = ssn

    def __setattr__(self, name, value):
        if name == '_ssn':
            raise AttributeError('Denied.')
        else:
            object.__setattr__(self, name, value)

&gt;&gt; p = Person('Ozgur', '1234')
&gt;&gt; AttributeError: Denied.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The usual way is to use a "private" attribute starting with an underscore, and a read-only property for public access:</p>
<pre><code>import operator

class Person(object):
    def __init__(self, name, ssn):
        self.name = name
        self._ssn = ssn
    ssn = property(operator.attrgetter("_ssn"))
</code></pre>
<p>Note that this does not really hinder anybody to change the attribute <code>_ssn</code>, but the leading <code>_</code> documents that the attribute is private.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can bypass <strong>setattr</strong> by directly assigning to the instance dictionary in the constructor. Of course, this trick can always be used to spoof any other hoops you employ to make _ssn read-only (after an initial write)</p>
<pre><code> class Person(object): 
    def __init__(self, name, ssn):    
        self.name = name
        self.__dict__['_ssn'] = ssn 

    def __setattr__(self, name, value):
        if name == '_ssn':
            raise AttributeError('Denied.')
        else:
            object.__setattr__(self, name, value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python does not support private or protected attributes. You need to implement the descriptor protocol instead. The standard library provides decorators to do that succinctly.</p>
<p>Just declare the attribute with two underscores in front of it in the <strong>init</strong> method. It is called name mangling and prevents the attribute from being accessible via __ssn, although it can still be accessed and modified by _Person__ssn in this case. However, if you do not explicitly define a setter for it will raise an AttributeError.</p>
<p>Of course if someone has an intention to misuse the API that person can if he is very intent. But it will not happen by accident. </p>
<pre><code>import re

class Person:
    """Encapsulates the private data of a person."""

    _PATTERN = re.COMPILE(r'abcd-efgh-ssn')

    def __init__(self, name, ssn):
       """Initializes Person class with input name of person and
       his social security number (ssn).
       """
       # you can add some type and value checking here for defensive programming
       # or validation for the ssn using regex for example that raises an error
       if not self._PATTERN.match(ssn):
           raise ValueError('ssn is not valid')
       self.__name = name
       self.__ssn = snn

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, value):
        self.__name = value

    @property
    def ssn(self):
        return self.__ssn

&gt;&gt;&gt; p = Person('aname', 'abcd-efgh-ssn')
&gt;&gt;&gt; p.ssn
'abcd-efgh-ssn'
&gt;&gt;&gt; p.ssn = 'mistake'
AttributeError: 'can't set attribute'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just pointing out that we could still modify <code>_ssn</code>.</p>
<p>Objects have the special attribute, <code>__dict__</code> that is a dictionary that maps all instance attributes of the object with their corresponding values. We can add/update/delete instance attributes directly by modifying the <code>__dict__</code> attribute of an object.</p>
<p>We can still modify <code>_snn</code> like this:</p>
<pre><code>p = Person('Ozgur', '1234')

p.__dict__.get('_ssn') # returns '1234'

p.__dict__['_ssn'] = '4321'

p.__dict__.get('_ssn') # returns '4321'
</code></pre>
<p>As we can see, we were still able to change the value of <code>_ssn</code>. By design, there isn't a straight forward way, if any, to circumvent attribute access in Python in all cases.</p>
<p>I'll show a more common way to restrict attribute access using <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property()</a> as a decorator:</p>
<pre><code>class Person(object):
    def __init__(self, name, ssn):
        self.name = name
        self._ssn = ssn

    @property
    def ssn(self):
        return self._ssn

    @ssn.setter
    def ssn(self, value):
        raise AttributeError('Denied')


&gt;&gt; p = Person('Ozgur', '1234')
&gt;&gt; p.ssn
&gt;&gt; '1234'
&gt;&gt; p.ssn = '4321'
&gt;&gt; AttributeError: Denied
</code></pre>
<p>Hope this helps!</p>
</div>
<span class="comment-copy">Just because assignments in <code>__init__</code> also calls <code>__setattr__</code></span>
<span class="comment-copy">I think you may have to try with a metaclass</span>
<span class="comment-copy">FYI, this isn't really how Python's meant to work. Document your API to tell other developers not to change it.</span>
<span class="comment-copy">@detly: The usual philosophy in Python is to take measures to prevent an <i>accidental</i> breach of contract, but not to bother to prevent an <i>intentional</i> breach of contract.</span>
<span class="comment-copy">@SvenMarnach - true; it's up to the OP to apply the rule to his or her situation.</span>
<span class="comment-copy">+1. Python philosophy is that instead of having language-enforced "you can't touch this", you use attributes starting with <code>_</code> to signal implementation details - which means clients <i>can</i> try to fiddle with it, but they are no longer covered by any guarantees you make about backward/forward compatibility or class invariants.  So, they can fiddle, they can break things, but its their own damn fault.</span>
