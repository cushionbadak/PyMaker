<div class="post-text" itemprop="text">
<p>Consider a simple function like</p>
<pre><code>def increment(self):
    self.count += 1
</code></pre>
<p>which is run through Cython and compiled into an extension module.  Suppose now I'd like to make this function a method on a class.  For example:</p>
<pre><code>class Counter:
    def __init__(self):
        self.count = 0

from compiled_extension import increment
Counter.increment = increment
</code></pre>
<p>Now this will not work, as the calling convention at the C level will be broken. For example:</p>
<pre><code>&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; c.increment()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: increment() takes exactly one argument (0 given)
</code></pre>
<p>But in Python 2, we can convert the function to an unbound method by doing:</p>
<pre><code>Counter.increment = types.MethodType(increment, None, Counter)
</code></pre>
<p><strong>How can I accomplish this same thing in Python 3?</strong></p>
<p>One simple way is to use a slim wrapper:</p>
<pre><code>from functools import wraps
def method_wraper(f):
    def wrapper(*args, **kwargs):
        return f(*args, **kwargs)
    return wraps(f)(wrapper)

Counter.increment = method_wrapper(increment)
</code></pre>
<p>Is there a more efficient way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>First thing is getting the names correctly:</p>
<pre><code>&gt;&gt;&gt; def increment(obj):
...     obj.count += 1
...
&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.count = 0
...
&gt;&gt;&gt; o = A()
&gt;&gt;&gt; o.__init__
&lt;bound method A.__init__ of &lt;__main__.A object at 0x0000000002766EF0&gt;&gt;
&gt;&gt;&gt; increment
&lt;function increment at 0x00000000027797C8&gt;
</code></pre>
<p>So proper names are <strong>functions</strong> and <strong>bound methods</strong>. Now you can look for how to <a href="https://stackoverflow.com/a/1015405/1149736"><em>Bind an Unbound Method</em></a> and you will probably end up reading about <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>descriptors</em></a>:</p>
<blockquote>
<p>In general, a descriptor is an object attribute with "binding
  behavior", one whose attribute access has been overridden by methods
  in the descriptor protocol. Those methods are <code>__get__</code>, <code>__set__</code>, and
  <code>__delete__</code>. If any of those methods are defined for an object, it is said to be a descriptor.</p>
</blockquote>
<p>You can easily transform function to method by just using different invocation of <code>__get__</code></p>
<pre><code>&gt;&gt;&gt; increment.__get__(None, type(None))
&lt;function increment at 0x00000000027797C8&gt;
&gt;&gt;&gt; increment.__get__(o, type(o))
&lt;bound method A.increment of &lt;__main__.A object at 0x00000000027669B0&gt;&gt;
</code></pre>
<p>And it works like a charm:</p>
<pre><code>&gt;&gt;&gt; o = A()
&gt;&gt;&gt; increment.__get__(None, type(None))(o)
&gt;&gt;&gt; o.count
1
&gt;&gt;&gt; increment.__get__(o, type(o))()
&gt;&gt;&gt; o.count
2
</code></pre>
<p>You can easily add these <em>newly bounded methods</em> to objects:</p>
<pre><code>def increment(obj):
    obj.count += 1

def addition(obj, number):
    obj.count += number

class A(object):
    def __init__(self):
        self.count = 0

o = A()
o.inc = increment.__get__(o)
o.add = addition.__get__(o)
print(o.count) # 0
o.inc()
print(o.count) # 1
o.add(5)
print(o.count) # 6
</code></pre>
<p>Or create your own <em>descriptor</em> that will will convert <em>function</em> to <em>bound method</em>:</p>
<pre><code>class BoundMethod(object):
    def __init__(self, function):
        self.function = function

    def __get__(self, obj, objtype=None):
        print('Getting', obj, objtype)
        return self.function.__get__(obj, objtype)

class B(object):
    def __init__(self):
        self.count = 0

    inc = BoundMethod(increment)
    add = BoundMethod(addition)


o = B()
print(o.count) # 0
o.inc()
# Getting &lt;__main__.B object at 0x0000000002677978&gt; &lt;class '__main__.B'&gt;
print(o.count) # 1
o.add(5) 
# Getting &lt;__main__.B object at 0x0000000002677978&gt; &lt;class '__main__.B'&gt;
print(o.count) # 6
</code></pre>
<p>And you also can see that this is nicely consistent with <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer"><em>function</em>/<em>bound method</em> principles</a>:</p>
<blockquote>
<p>Class dictionaries store methods as functions. In a class definition, methods are written using def and lambda, the usual tools for creating functions. The only difference from regular functions is that the first argument is reserved for the object instance. By Python convention, the instance reference is called self but may be called this or any other variable name.</p>
<p>To support method calls, functions include the <code>__get__()</code> method for binding methods during attribute access. This means that all functions are non-data descriptors which return bound or unbound methods depending whether they are invoked from an object or a class.</p>
</blockquote>
<p>And <em>functions</em> becomes <em>bound method</em> during instance initialization:</p>
<pre><code>&gt;&gt;&gt; B.add
# Getting None &lt;class '__main__.B'&gt;
&lt;function addition at 0x00000000025859C8&gt;
&gt;&gt;&gt; o.add
# Getting &lt;__main__.B object at 0x00000000030B1128&gt; &lt;class '__main__.B'&gt;
&lt;bound method B.addition of &lt;__main__.B object at 0x00000000030B1128&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Import the extension like this:</p>
<pre><code>import compiled_extension
</code></pre>
<p>In your class you write:</p>
<pre><code>def increment: return compiled_extension.increment()
</code></pre>
<p>This seems more readable and might be more efficient.</p>
</div>
<span class="comment-copy">I had this problem trying to build a Heapq class using the ugly <code>heapq</code> module. Your solution is good. It can be done in one line, but has the same efficiency: <code>def method_wraper(f): return functools.wraps(f)(lambda *a, **kw: f(*a, **kw))</code></span>
<span class="comment-copy">...Interesting, the assignment seems to work fine if the function is defined within the same module (unbound method that gets assigned to a class and bound on instantiation). So it's only a problem with C extensions, or with functions in different modules? Anyway, you might want to check out <a href="http://stackoverflow.com/questions/7490879/python3-bind-method-to-class-instance-with-get-it-works-but-why" title="python3 bind method to class instance with get it works but why">stackoverflow.com/questions/7490879/…</a>, which could help you a little as well.</span>
<span class="comment-copy">Also, <a href="http://docs.python.org/py3k/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">docs.python.org/py3k/howto/…</a> "the actual C implementation of PyMethod_Type in Objects/classobject.c is a single object with two different representations depending on whether the im_self field is set or is NULL (the C equivalent of None)." Which makes it seem like this issue shouldn't be occurring at all, unless Python somehow doesn't update that field directly for an object's methods when instantiating the object.</span>
<span class="comment-copy">The problem is with that builtin functions and python functions are handled differently by the runtime, nothing to do with being in a different module.  The comment about PyMethod_Type doesn't really apply as it represents a method defined in python, not builtin functions/methods.</span>
<span class="comment-copy">Shouldn't it read "convert the function to a <i>bound</i> method" ?</span>
<span class="comment-copy">Normally a built-in type in CPython uses a <code>method_descriptor</code>, which gets bound as <code>builtin_function_or_method</code>, e.g. <code>str.upper.__get__('a').__self__ == 'a'</code>. The <code>builtin_function_or_method</code> itself is <i>not</i> a descriptor. The latter is what Cython creates, so the OP is looking for a way to wrap it in a descriptor such as <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow noreferrer"><code>partialmethod</code></a> (3.4+).</span>
<span class="comment-copy">I think your answer is not what OP wants.</span>
