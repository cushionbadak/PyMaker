<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3679694/a-weighted-version-of-random-choice">A weighted version of random.choice</a>
<span class="question-originals-answer-count">
                    20 answers
                </span>
</li>
</ul>
</div>
<p>If I have a collection of items in a list. I want to choose from that list according to another list of weights. </p>
<p>For example my collection is <code>['one', 'two', 'three']</code> and the weights are <code>[0.2, 0.3, 0.5]</code>, the I would expect the method to give me 'three' in about half of all draws.</p>
<p>What is the easiest way to do so ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <a class="post-tag" href="/questions/tagged/numpy" rel="tag" title="show questions tagged 'numpy'">numpy</a> version 1.7 you can use <a href="http://docs.scipy.org/doc/numpy-1.7.0/reference/generated/numpy.random.choice.html" rel="noreferrer"><code>numpy.random.choice()</code></a>:</p>
<pre><code>elements = ['one', 'two', 'three'] 
weights = [0.2, 0.3, 0.5]

from numpy.random import choice
print(choice(elements, p=weights))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.6, you can do weighted random choice (with replacement) using <a href="https://docs.python.org/3/library/random.html#random.choices" rel="noreferrer"><code>random.choices</code></a>.</p>
<blockquote>
<p>random.<strong>choices</strong>(<em>population, weights=None, *, cum_weights=None, k=1</em>)</p>
</blockquote>
<p>Example usage:</p>
<pre><code>import random
random.choices(['one', 'two', 'three'], [0.2, 0.3, 0.5], k=10)
# ['three', 'two', 'three', 'three', 'three',
#  'three', 'three', 'two', 'two', 'one']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This function takes two arguments: A list of weights and a list containing the objects to choose from:</p>
<pre><code>from numpy import cumsum
from numpy.random import rand
def weightedChoice(weights, objects):
    """Return a random item from objects, with the weighting defined by weights 
    (which must sum to 1)."""
    cs = cumsum(weights) #An array of the weights, cumulatively summed.
    idx = sum(cs &lt; rand()) #Find the index of the first weight over a random value.
    return objects[idx]
</code></pre>
<p>It does not use any python loops.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="http://en.wikipedia.org/wiki/Multinomial_distribution" rel="nofollow">multinomial distribution</a> (from numpy) to do what you want. E.g.</p>
<pre><code>elements = ['one', 'two', 'three'] 
weights = [0.2, 0.3, 0.5]


import numpy as np

indices = np.random.multinomial( 100, weights, 1)
#=&gt; array([[20, 32, 48]]), YMMV

results = [] #A list of the original items, repeated the correct number of times.
for i, count in enumerate(indices[0]):
    results.extend( [elements[i]]*count )
</code></pre>
<p>So the element in first position came up 20 times, the element in second position came up 32 times, and the element in third position came up 48 times, roughly what you would expect given the weights.</p>
<p>If you're having a hard time wrapping your head around the multinomial distribution, I found the <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.multinomial.html" rel="nofollow">documentation</a> really helpful.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you did not want to use <code>numpy</code>, you can follow the same method with something like this:</p>
<pre><code>from random import random
from itertools import takewhile

def accumulate(iterator):
    """Returns a cumulative sum of the elements.
    accumulate([1, 2, 3, 4, 5]) --&gt; 1 3 6 10 15"""
    current = 0
    for value in iterator:
        current += value
        yield current

def weightedChoice(weights, objects):
    """Return a random item from objects, with the weighting defined by weights 
    (which must sum to 1)."""
    limit = random()
    return objects[sum(takewhile(bool, (value &lt; limit for value in accumulate(weights))))]
</code></pre>
<p>We use <code>itertools.takewhile()</code> to avoid checking values once we reach the point we want to stop, otherwise, this is essentially the same idea as <a href="https://stackoverflow.com/a/10803136/722121">Mischa Obrecht's answer</a>, just without <code>numpy</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about just initializing your list to match your choices with the expected weights.
Here I'm make a list of 100 values representing your desired "pull" percentage.</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; elements = ['one', 'two', 'three'] 
&gt;&gt;&gt; weights = [0.2, 0.3, 0.5]
&gt;&gt;&gt;
&gt;&gt;&gt; # get "sum" of result list of lists (flattens list)
&gt;&gt;&gt; choices = sum([[element] * int(weight * 100)for element, weight in zip(elements, weights)], [])
&gt;&gt;&gt; random.choice(choices)
three
</code></pre>
<p>It's not cumulative, but it looks like it might be what your looking for.</p>
</div>
<div class="post-text" itemprop="text">
<p>To build upon <a href="https://stackoverflow.com/a/10803561/722121">Maus' answer</a>, which is great if you want to repeatedly get weighted random values, if you only wanted a single value, you can do this very simply by combining <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.multinomial.html" rel="nofollow noreferrer"><code>numpy.random.multinomial()</code></a> and <a href="http://docs.python.org/release/3.1.5/library/itertools.html#itertools.compress" rel="nofollow noreferrer"><code>itertools.compress()</code></a>: </p>
<pre><code>from itertools import compress
from numpy.random import multinomial

def weightedChoice(weights, objects):
    """Return a random item from objects, with the weighting defined by weights 
    (which must sum to 1)."""
    return next(compress(objects, multinomial(1, weights, 1)[0]))
</code></pre>
</div>
<span class="comment-copy">This answer should be validated.</span>
<span class="comment-copy">Perfect solution <code>l = [choice(elements, p=weights) for _ in range(1000)]</code> and <code>from collections import Counter; Counter(l)</code> delivers: <code>Counter({'three': 498, 'two': 281, 'one': 221})</code>.</span>
<span class="comment-copy">The comments appear to be misleading. <code>cumsum()</code> gives the the cumulative values, not boolean values. To be clear, this does work, but the comments don't match what is actually happening.</span>
<span class="comment-copy">I have edited to fix, and also put the docstring on one line, as recommended in <a href="http://www.python.org/dev/peps/pep-0257/#one-line-docstrings" rel="nofollow noreferrer">PEP 257</a>.</span>
<span class="comment-copy">Assuming the weights are positive, cs is a sorted list. Using numpy.searchsorted will result in a significant speed up for finding the index</span>
<span class="comment-copy">Note you can reduce your building of results to <code>itertools.chain.from_iterable([elements[i]]*count, for i, count in enumerate(indices[0]))</code>, which will be faster.</span>
<span class="comment-copy">In fact, you can improve it even further by replacing the list multiplication with <code>itertools.repeat(elements[i], count)</code> too.</span>
<span class="comment-copy">looks like it has the same effect, but allocating a 3*100 vector just to do a choice seems a bit of an overkill. Especially if I would use it in the context the problem first came up, which is a Monte Carlo simulation, where you want to be as fast as possible...</span>
<span class="comment-copy">You should add that info to the question.  But, your only allocating the list once, calling "random.choice()" will be fast.</span>
<span class="comment-copy">yes, but I'd say if there is a cheap way and an expensive way to achieve the same result, it goes without saying, that one chooses the cheap one. Judges ruling ? :)</span>
<span class="comment-copy">@aix Smashed your edit with my own by accident, rolled back to your (better) link.</span>
