<div class="post-text" itemprop="text">
<p>Suppose I have a simple python class definition in a file myClass.py</p>
<pre><code>class Test:
    A = []
</code></pre>
<p>And I also have two test scripts. The first script creates an object of type Test, populates the array A, and pickles the result to a file. It immediately unpickles it from the file and the array is still populated.
The second script just unpickles from the file, and <strong>the array is not populated (i.e. A == []). Why is this?</strong></p>
<p>test1.py</p>
<pre><code>import myClass
import pickle

x = myClass.Test()

for i in xrange(5):
    x.A.append(i)

f = open('data', 'w')
pickle.dump(x,f)
f.close()

f = open('data')
y = pickle.load(f)
f.close

print y.A
</code></pre>
<p>and test2.py</p>
<pre><code>import myClass
import pickle

f = open('data')
y = pickle.load(f)
f.close

print y.A
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is because you are setting <code>Test.A</code> as a class attribute instead of an instance attribute. Really what is happening is that with the test1.py, the object being read back from the pickle file is the same as test2.py, but its using the class in memory where you had originally assigned <code>x.A</code>. </p>
<p>When your data is being unpickled from the file, it creates a new instance of the class type, and then applies whatever instance data it needs to. But your only data was a class attribute. Its always referring back to the class thats in memory, which you modified in one, but not in another file.</p>
<p>Compare the differences in this example:</p>
<pre><code>class Test:
    A = []  # a class attribute
    def __init__(self):
        self.a = []  # an instance attribute
</code></pre>
<p>You will notice that the instance attribute <code>a</code> will be pickled and unpickled properly, while the class attribute <code>A</code> will simply refer to the class in memory.</p>
<pre><code>for i in xrange(5):
    x.A.append(i)
    x.a.append(i)  

with open('data', 'w') as f:
    pickle.dump(x,f)

with open('data') as f:
    y = pickle.load(f)

&gt;&gt;&gt; y.A
[0, 1, 2, 3, 4]
&gt;&gt;&gt; y.a
[0, 1, 2, 3, 4]
&gt;&gt;&gt; Test.A
[0, 1, 2, 3, 4]
&gt;&gt;&gt; Test.A = []  # resetting the class attribute
&gt;&gt;&gt; y.a 
[0, 1, 2, 3, 4]
&gt;&gt;&gt; y.A  # refers to the class attribute
[]
</code></pre>
</div>
<span class="comment-copy">Does this mean that if you had pickled the class itself, <code>pickle.dump(Test)</code>, and then unpickled the class, you would have gotten the correct list <code>A</code> back in both cases?</span>
<span class="comment-copy">@BallpointBen, no it wouldn't preserve the class attribute, as per <a href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="nofollow noreferrer">what-can-be-pickled-and-unpickled</a>: "classes are pickled by named reference, so the same restrictions in the unpickling environment apply. Note that none of the classâ€™s code or data is pickled"</span>
<span class="comment-copy">What if the class variable and the instance variable had the same name, would the pickle choose the class or instance variable?</span>
<span class="comment-copy">If you were to set an instance variable <code>A</code> then it would shadow the class variable <code>A</code>. At that point you have a value that is divorced from the class variable anyways. So the answer is that you get the instance variable values when you pickle/unpickle</span>
