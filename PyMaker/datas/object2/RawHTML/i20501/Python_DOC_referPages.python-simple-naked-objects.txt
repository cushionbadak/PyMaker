<div class="post-text" itemprop="text">
<p>What's the easiest way to create a naked object that I can assign attributes to?</p>
<p>The specific use case is: I'm doing various operations on a Django object instance, but sometimes the instance is None (there is on instance). In this case I'd like to create the simplest possible fake object such that I can assign values to its attributes (eg. <code>myobject.foo = 'bar'</code>).</p>
<p>Basically I'm looking for the Python equivalent of this piece of Javascript:</p>
<pre><code>myobject = {}
myobject.foo = 'bar'
</code></pre>
<p>I know I can use a mock object/library for this, but I'm hoping for a very simple solution (as simple as the Javascript above). Is there a way to create a naked object instance? Something like:</p>
<pre><code>myobject = object()
myobject.foo = 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to create a simple class first:</p>
<pre><code>class Foo(object):
    pass

myobject = Foo()
myobject.foo = 'bar'
</code></pre>
<p>You can make it a one-liner like this:</p>
<pre><code>myobject = type("Foo", (object,), {})()
myobject.foo = 'bar'
</code></pre>
<p>The call to <code>type</code> functions identically to the previous <code>class</code> statement.</p>
<p>If you want to be <em>really</em> minimal...</p>
<pre><code>myobject = type("", (), {})()
</code></pre>
<p>The key is that the built-in types (such as <code>list</code> and <code>object</code>) don't support user-defined attributes, so you need to create a type using either a <code>class</code> statement or a call to the 3-parameter version of <code>type</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://pypi.python.org/pypi/bunch" rel="noreferrer">Bunch</a> module:</p>
<pre><code>sudo pip install bunch
</code></pre>
<p>A bunch is a dictionary that allows to access its content via the <code>dict.key</code> syntax.</p>
<p>And then like that:</p>
<pre><code>from bunch import Bunch
b = Bunch()
b.foo = "Bar"


b["foo2"] = "Bar2"
print b
&gt;&gt; Bunch(foo='Bar', foo2='Bar2')
b["foo"] = "Baz"
print b
&gt;&gt; Bunch(foo='Baz', foo2='Bar2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python &gt;= 3.3 you could always use <strong><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">SimpleNamespace</a></strong>; which is included in the Python <code>types</code> module.</p>
<p><strong><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">SimpleNamespace</a></strong> is great because you also get a <code>repr</code> and equivalency testing for free; both of which might come in handy even for a minimalist object. </p>
<p>Translating the JavaScript in the OP’s question would look like:</p>
<pre><code>from types import SimpleNamespace

myobject = SimpleNamespace() # myobject = {}
myobject.foo = 'bar'
</code></pre>
<p>You can also use keyword arguments when instantiating <strong><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">SimpleNamespace</a></strong>.  These arguments will become attributes on the instantiated <strong><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">SimpleNamespace</a></strong>: </p>
<pre><code>p = SimpleNamespace(name='gary')
p.age = 32
p # =&gt; namespace(age=32, name='gary')
</code></pre>
<p>So a quick and easy way to turn a dictionary into a  <strong><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer">SimpleNamespace</a></strong> object  —provided the dictionary keys are proper identifiers—  is as simple as:</p>
<pre><code>d = {
    'name': 'gary',
    'age': 33 # had a birthday. 
}
p = SimpleNamespace(**d)
</code></pre>
<p>Python &gt;= 3.7 has <strong><a href="https://docs.python.org/3.7/library/dataclasses.html" rel="nofollow noreferrer">dataclasses</a></strong> which are basically “<strong><a href="https://youtu.be/T-TwcmT6Rcw" rel="nofollow noreferrer">mutable named tuples</a></strong>”.   This could be something you may want to use if you have a lot of data objects.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I'm coming here very late, but I'm surprised nobody has mentioned <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow"><code>namedtuples</code></a>, which accomplish this kind of thing:</p>
<pre><code>Foo = namedtuple('Foo', ['x'])
f = Foo(x='myattribute')
f.x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class NakedObject(object):
    pass

myobject = NakedObject()
myobject.foo = 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would need to subclass object first like this...</p>
<pre><code>class Myobject(object):
    pass

myobject1 = Myobject()
myobject1.foo = 'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3,</p>
<pre><code>class Obj: pass

o = Obj()
o.name = 'gary'
o.age = 32

o
# &lt;__main__.Obj at 0x17235ca65c0&gt;

o.__dict__
# {'name': 'gary', 'age': 32}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps you are looking for something like this:</p>
<pre><code>myobject={}
myobject['foo']='bar'
</code></pre>
<p>then it can be called like:</p>
<pre><code>print myobject['foo']
</code></pre>
<p>or you could use a class object for this:</p>
<pre><code>class holder(object):
    pass
</code></pre>
<p>then you can use something like this:</p>
<pre><code>hold=holder()
hold.myobject='bar'
print hold.myobject
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should probably just use a dict, as per @PsychicOak's answer.</p>
<p>However, if you really want an object you can manipulate, try:</p>
<pre><code>class FooClass(object): pass
</code></pre>
<p>You can then assign attributes on <code>FooClass</code> itself, or on instances, as you wish.</p>
</div>
<div class="post-text" itemprop="text">
<p>I usually prefer to create a <a href="http://en.wikipedia.org/wiki/Null_Object_pattern" rel="nofollow">null object</a> for my class:</p>
<pre><code>class User(Model):
    username = CharField()
    password = CharField()


NONE_USER = User(username='', password='')
</code></pre>
<p>Then I use it where I would use your naked object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Functions can have attributes in Python 3. Compared to a naked class, you can save one whole line of code.</p>
<pre><code>naked = lambda: None
naked.foo = 'bar'
</code></pre>
</div>
<span class="comment-copy">That seems pretty naked to me. What exactly is the threshold that you want to stay below?</span>
<span class="comment-copy">The python code above is pretty naked, but unfortunately it doesn't actually work.</span>
<span class="comment-copy">Yeah, that's what I get for commenting too quickly. Of course :)</span>
<span class="comment-copy">Nice, that is very minimal indeed. Unfortunately also quite unreadable, so I'll go with the first object method you recommend. If anyone has a minimal but readable version I'm still game...</span>
<span class="comment-copy">Doesn't in fact have to inherit from object: <code>class Dummy(): pass</code> will do fine.</span>
<span class="comment-copy">Probably. I shy away from old-style classes in Python 2 where possible.</span>
<span class="comment-copy">To use namedtuple, we should know the attributes in advance, which might not be the case here. You cannot add arbitrary attributes to the objects in this case.</span>
<span class="comment-copy">I'm looking specifically to use the dot notation for accessing the attributes so the same code that manipulates the django object instances can work on this - so I'd want myobject.foo instead of myobject['foo']</span>
<span class="comment-copy">That's a dict in python, not an object.</span>
