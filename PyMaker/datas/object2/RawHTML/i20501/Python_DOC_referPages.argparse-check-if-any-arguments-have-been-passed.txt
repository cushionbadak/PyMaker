<div class="post-text" itemprop="text">
<p>My script should start a demo mode, when the no parameters are given. I tried this:</p>
<pre><code>args = parser.parse_args()
if len(args) == 0:
    run_demo()
else:
    # evaluate args
</code></pre>
<p>Which gives a <code>*** TypeError: object of type 'Namespace' has no len()</code> as <code>args</code> is no list. </p>
<p>How would I achieve what I want?</p>
</div>
<div class="post-text" itemprop="text">
<p>If your goal is to detect when <strong>no argument</strong> has been given to the command, then doing this via <code>argparse</code> is the wrong approach (as Ben has nicely pointed out).</p>
<p>Think simple! :-) I believe that argparse does not depopulate <code>sys.argv</code>. So, <code>if not len(sys.argv) &gt; 1</code>, then no argument has been provided by the user.</p>
</div>
<div class="post-text" itemprop="text">
<p>argparse lets you set (inside a Namespace object) all the variables mentioned in the arguments you added to the parser, based on your specification and the command line being parsed. If you set a default, then those variables will have that default value if they weren't seen on the command line, they won't be absent from the Namespace object. And if you <em>don't</em> specify a default, then there is an implicit default of <code>None</code>. So checking the length of the Namespace object, however you manage to do it, doesn't make sense as a way to check whether any arguments were parsed; it should always have the same length.</p>
<p>Instead, if you know you've got a bunch of arguments with no defaults and you want to check whether any of them were set to any non-<code>None</code> value... do that. You can use a list comprehension and the <code>vars</code> function to loop over them without having to duplicate the list of names from the <code>add_argument</code> calls, as shown in Martijn's answer.</p>
<p>It gets a little trickier if some of your arguments have default values, and more so if they have default values that could be explicitly provided on the command line (e.g. a numeric argument that defaults to 0 makes it impossible to tell the default from the user providing 0). In that case I'm not sure that there's a general solution that always works without knowledge of what the arguments are.</p>
</div>
<div class="post-text" itemprop="text">
<p>If one really needs the argument number (for whatever reason).
I have found this code very helpful (but do not know how much optimised it is, and I'd appreciate any comment on it).</p>
<pre><code>args = parser.parse_args()
print( len( vars(args) ) )
</code></pre>
<p>This version counts only the -xx parameters and not any additional value passed.</p>
<p>If one wants everything (also the values passed), then just use <code>len(sys.argv)</code> as previously mentioned.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use argparse. Instead just use <code>sys.argv</code>. <code>argparse</code> creates a Namespace, so it will always give you a "dict" with their values, depending on what arguments you used when you called the script.</p>
<p>Here's what I've done in the past: </p>
<pre><code>args = parser.parse_args()
if len(sys.argv) == 1:
    parser.print_help()
    sys.exit()
return args
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let us assume the following example to extend Yours for completeness:</p>
<pre><code>#!/usr/bin/env python3

import argparse

...
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('input', nargs='?' action='store')
    parser.add_argument('-l', '--length', type=int, action='store')
    parser.add_argument('-v', '--verbose', action='store_true')
    args = parser.parse_args()
    if (args.input == None and args.length == None):
        parser.print_help()
    else:
        print(args)

if __name__ == '__main__':
    main()
</code></pre>
<p>Your Namespace object, mentioned by @Ben, in this example is <code>args</code>. From the strings in <code>parser.add_argument</code> a variable is created. You can access it through <code>args.input</code> or <code>args.length</code> or <code>args.verbose</code>. You can verify this by executing <code>print(args)</code> which will actually show something like this:</p>
<pre><code>Namespace(input=None, length=None, verbose=False)
</code></pre>
<p>since verbose is set to <code>True</code>, if present and input and length are just variables, which don't have to be instantiated (no arguments provided).</p>
<p>Also helpful can be <code>group = parser.add_mutually_exclusive_group()</code> if you want to ensure, two attributes cannot be provided simultaneously.</p>
<p>For further reference, please refer to:</p>
<ul>
<li><a href="https://docs.python.org/3/howto/argparse.html" rel="nofollow noreferrer">https://docs.python.org/3/howto/argparse.html</a>
Well structured HOWTO</li>
<li><a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html</a>
Argparse module documentation</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I expanded 2dvisio's concept to count non zero or None arguments:</p>
<pre><code>vm_opts = parser.parse_args()
v = vars(vm_opts)
n_args = sum([ 1 for a in v.values( ) if a])
</code></pre>
</div>
<span class="comment-copy">use try except to capture TypeError, so you know that nothing has been passed</span>
<span class="comment-copy">@avasal, <code>len(args)</code> always throws a TypeError.</span>
<span class="comment-copy">it works and it is probably the better/simpliest way to do it :D</span>
<span class="comment-copy">Accepted this answer, as it solves my problem, w/o me having to rethink things. =&gt; bad me ;)</span>
<span class="comment-copy">+1 Much more practical advice for the problem at hand than my suggestion to check <i>all</i> the options against <code>None</code>.</span>
<span class="comment-copy">+1! Sometimes you don't see the forest for the trees. ^^</span>
<span class="comment-copy">This nicely explains why you have a 'wrong problem' :)</span>
<span class="comment-copy">+1 for the insight</span>
<span class="comment-copy">Creative ðŸ˜‹. Liked the answer!</span>
<span class="comment-copy">This is useful if using unittest to test something with argparse, in that case the accepted answer can misbehave.</span>
