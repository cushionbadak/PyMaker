<div class="post-text" itemprop="text">
<p>So, there exists an easy way to calculate the intersection of two sets via set.intersection(). However, I have the following problem:</p>
<pre><code>class Person(Object):                    
    def __init__(self, name, age):                                                      
        self.name = name                                                                
        self.age = age                                                                  

l1 = [Person("Foo", 21), Person("Bar", 22)]                                             
l2 = [Person("Foo", 21), Person("Bar", 24)]                                             

union_list = list(set(l1).union(l2))                                           
# [Person("Foo", 21), Person("Bar", 22), Person("Bar", 24)]
</code></pre>
<p>(<code>Object</code> is a base-class provided by my ORM that implements basic <code>__hash__</code> and <code>__eq__</code> functionality, which essentially adds every member of the class to the hash. In other words, the <code>__hash__</code> returned will be a hash of every element of the class)</p>
<p>At this stage, I would like to run a set intersection operation by <code>.name</code> only, to find, say, <code>Person('Bar', -1).intersection(union_list) #= [Person("Bar", -1), Person("Bar", 22), Person("Bar", 24)]</code>. (the typical <code>.intersection()</code> at this point would not give me anything, I can't override <code>__hash__</code> or <code>__eq__</code> on the <code>Person</code> class, as this would override the original set union (I <em>think</em>)</p>
<p>What's the best way to do this in Python 2.x?</p>
<p>EDIT: Note that the solution doesn't <em>have</em> to rely on a <code>set</code>. However, I need to find unions and then intersections, so it feels like this is amenable to a set (but I'm willing to accept solutions that use whatever magic you deem worthy, so long as it solves my problem!)</p>
</div>
<div class="post-text" itemprop="text">
<p>Sounds like</p>
<pre><code>&gt;&gt;&gt; class Person:
...     def __init__(self, name, age):
...         self.name = name
...         self.age = age
...     def __eq__(self, other):
...         return self.name == other.name
...     def __hash__(self):
...         return hash(self.name)
...     def __str__(self):
...         return self.name
...
&gt;&gt;&gt; l1 = [Person("Foo", 21), Person("Bar", 22)]
&gt;&gt;&gt; l2 = [Person("Foo", 21), Person("Bar", 24)]
&gt;&gt;&gt; union_list = list(set(l1).union(l2))
&gt;&gt;&gt; [str(l) for l in union_list]
['Foo', 'Bar']
</code></pre>
<p>is what you want, since <code>name</code> is your unique key?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the <code>age</code> to be irrelevant with respect to comparing, you should override <code>__hash__()</code> and <code>__eq__()</code> in <code>Person</code> although you have it in your <code>Object</code>.</p>
<p>If you need this behaviour only in this (and similiar) contexts, you could create a wrapper object which contains the <code>Person</code> and behaves differently, such as</p>
<pre><code>class PersonWrapper(Object):
    def __init__(self, person):
        self.person = person
    def __eq__(self, other):
        if hasattr(other, 'person'):
            return self.person.name == other.person.name
        else:
            return self.person.name == other.name
    def __hash__(self):
        return hash(self.person.name)
</code></pre>
<p>and then do</p>
<pre><code>union_list = list(set(PersonWrapper(i) for i in l1).union(PersonWrapper(i) for i in l2))
# [Person("Foo", 21), Person("Bar", 22), Person("Bar", 24)]
</code></pre>
<p>(untested)</p>
</div>
<div class="post-text" itemprop="text">
<p>I hate answering my own questions, so I'll hold off on marking this as the 'answer' for a little while yet.</p>
<p>Turns out the way to do this is as follows:</p>
<pre><code>import types
p = Person("Bar", -1)
new_hash_method = lambda obj: hash(obj.name)
p.__hash__ = types.MethodType(new_hash_method, p)
for i in xrange(0, len(union_list)):
    union_list[i].__hash__ = types.MethodType(new_hash_method, union_list[i])
set(union_list).intersection(p)
</code></pre>
<p>It's certainly dirty and it relies on <code>types.MethodType</code>, but it's less intensive than the best solution proposed so far (glglgl's solution) as my actual <code>union_list</code> can contain potentially in the order of thousands of items, so this will save me re-creating objects every time I run this intersection procedure.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about:</p>
<pre><code>d1 = {p.name:p for p in l1}
d2 = {p.name:p for p in l2}

intersectnames = set(d1.keys()).intersection(d2.keys)
intersect = [d1[k] for k in intersectnames]
</code></pre>
<p>It might be faster to throw <code>intersectnames</code> at your ORM, in which case you wouldn't build dictionaries, just collect names in lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is clunky, but...</p>
<pre><code>set(p for p in union_list for q in l2 if p.name == q.name and p.age != q.age) | (set(p for p in l2 for q in union_list if p.name == q.name and p.age != q.age))
# {person(name='Bar', age=22), person(name='Bar', age=24)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You'll have to override <code>__hash__</code> and the comparision methods if you want to use sets like this.</p>
<p>If you don't, then</p>
<pre><code>Person("Foo", 21) == Person("Foo", 21)
</code></pre>
<p>will always be false.</p>
<p>If your objects are managed by an ORM, then you'll have to check how it compares objects.
Usually it only looks at the objects id and comparision only works if both objects are managed. If you try to compare an object you got from the ORM with an instance you created yourself before it's persisted to the db, then they are likely to be different. Anyway, an ORM shouldn't have problems with you supplying your own comparision logic.</p>
<p>But if for some reasons you can't override <code>__hash__</code> and <code>__eq__</code>, then you can't use sets for intersection and union with the original objects. You could:</p>
<ul>
<li>calculate the intersection/union yourself</li>
<li><p>create a wrapper class which is comparable:</p>
<pre><code>class Person:                    
    def __init__(self, name, age):                                                      
        self.name = name                                                                
        self.age = age                                                                  

l1 = [Person("Foo", 21), Person("Bar", 22)]                                             
l2 = [Person("Foo", 21), Person("Bar", 24)]                                             

class ComparablePerson:
    def __init__(self, person):
        self.person = person

    def __hash__(self):
        return hash(self.person.name) + 31*hash(self.person.age)

    def __eq__(self, other):
        return (self.person.name == other.person.name and
                self.person.age == other.person.age)
    def __repr__(self):
        return "&lt;%s - %d&gt;" % (self.person.name, self.person.age)

c1 = set(ComparablePerson(p) for p in l1)
c2 = set(ComparablePerson(p) for p in l2)

print c1
print c2
print c1.union(c2)
print c2.intersection(c1)
</code></pre></li>
</ul>
</div>
<span class="comment-copy">I don't understand your desired result.  Could you please <i>explain</i> what the result should contain?</span>
<span class="comment-copy">Err crap, that should be .union, not .intersection. I've updated the question -- let me know if this is clearer?</span>
<span class="comment-copy">Your other examples don't make sense either. The default intersection would not give <code>[Person("Bar", 24)]</code>, it would give <code>l2</code>. And I don't understand why you expect to get <code>[Person("Bar", 22), Person("Bar", 24)]</code> from your operation.</span>
<span class="comment-copy">But <i>why</i> would you expect that result? Why wouldn't <code>Person("Foo", 21)</code> be part of the result? I don't understand what your "intersect by name" operation means.</span>
<span class="comment-copy">Better, but now I don't see why <code>Person('Bar', -1)</code> is not part of the result..</span>
<span class="comment-copy">Ah, no, the ORM I'm using already provides a <b>eq</b> and <b>hash</b> method (and, as such, set.union() already produces 'sane' results). I'm looking for a way to do an intersection operation that <i>only</i> uses one of the class's members as the key, and as such can't override <code>__hash__</code> or <code>__eq__</code>.</span>
<span class="comment-copy">I see, then perhaps glglgl's solution would be suitable?</span>
<span class="comment-copy">The issue is I need the <code>__hash__</code> and <code>__eq__</code> methods the way they are, otherwise <code>.union()</code> won't work the way it does.</span>
<span class="comment-copy">Hmm, interesting. So there's no way to do this without reconstructing objects? I know C++ gives me the option to pass a custom comparator; Python doesn't have the same ability?</span>
<span class="comment-copy">There is a way to do so with functions like <code>sorted()</code> where you can give a <code>cmp</code> function as well as a <code>key</code> function, but not with <code>set</code>s, alas...</span>
<span class="comment-copy">Damn. I've added an edit to the question to point out that the solution doesn't <i>have</i> to rely on a set, however I get the feeling this isn't going to change anything and I'm still going to have to use list comprehensions or genexps or something.</span>
<span class="comment-copy">Does this actually work though? The documentation indicates that magic methods like <code>__hash__</code> are looked up on the class, not the instance. <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#special-lookup</a></span>
<span class="comment-copy">Actually, looks like it does work for old style classes, but not for new style classes: <a href="https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-old-style-classes" rel="nofollow noreferrer">docs.python.org/2/reference/…</a></span>
<span class="comment-copy">See my comment (on the original question); the override is already dealt with by an ORM. I'll update the question to reflect this.</span>
