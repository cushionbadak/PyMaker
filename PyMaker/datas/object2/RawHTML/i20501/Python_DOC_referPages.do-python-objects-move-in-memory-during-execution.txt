<div class="post-text" itemprop="text">
<p>If the same object is invoked multiple times in python, will the memory location always be the same when I print 'self'? </p>
</div>
<div class="post-text" itemprop="text">
<p>AFAIK, memory addresses in Cpython are - by design - static. The memory address of an object can be seen with <code>id()</code>. The name of the function is a tell-tale of the fact it doesn't change...</p>
<p>See however the comment below, where other SO users pointed out that <code>id()</code> being the memory address is a detail implementation of Cpython.</p>
<p>HTH!</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that, beeing a very high-level language, Python does not define "memory addresses" for objects.  Objects do however have an "identity" that can be queried using the <a href="http://docs.python.org/library/functions.html#id" rel="nofollow">built-in <code>id()</code> function</a>.  This identity is guaranteed not to change during an object's lifetime:</p>
<blockquote>
<p>Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.</p>
</blockquote>
<p>In CPython, this identity is the underlying memory address, but this is merely an implementation detail; it might be different in other implementations and may even change in future versions of CPython (although this is unlikely).</p>
</div>
<div class="post-text" itemprop="text">
<p>As <strong>mac</strong> noticed, <em>memory addresses in Cpython are - by design - static</em></p>
<p>But even on Cpython you can't relay on this if you are using some c extensions.
Some of them can move objects and manually drive garbage collector.<br/></p>
<p>And if you are using other Python implementations, as <strong>PyPy</strong>, you are certain not guaranteed that the objects memory location always be the same, and high probably the will move.</p>
</div>
<span class="comment-copy">You shouldn't have to care whether or not they move in memory; a reference will never change regardless.</span>
<span class="comment-copy">I'm trying to debug some code. I don't know if an object is being reinstantiated or not.</span>
<span class="comment-copy">So then use <code>is</code> to compare it to a stored reference.</span>
<span class="comment-copy">That <code>id()</code> relates to the location in memory is an implementation detail and should not be depended upon.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams - You are right. The fact objects don't move in memory - though - it's by design in Cpython, I believe...</span>
<span class="comment-copy">@mac I'd think it's more because the work to implement one of the better GC algorithms is way too much work to do in a crossplatform way for cpython (I think that's even mentioned somewhere in the dokumentation?). In practice though I'd assume that if cpython ever got a mark &amp; sweep GC, they'd implement <code>id()</code> similarly to <code>hashCode</code> in java. Static per instance, but not correlated to the memory address.</span>
<span class="comment-copy">@Voo: Don't confuse hashing with identity.  In Python, there already is an equivalent to Java's <code>hashCode()</code>: <code>__hash__()</code>.  There might be two distinct objects with the same hash code, but at any given time there are no two Python objects with the same identity.</span>
<span class="comment-copy">@Ferdinand Object in java has a native <code>hashCode</code> function which returns a value constant for an object throughout its lifetime (not unique because it's a 32bit value which means we can't guarantee uniqueness), which has to be implemented by the JVM because objects move around. (To be exact it's generated only on demand, i.e. when someone calls the native hashCode, and is part of the extended object header)</span>
<span class="comment-copy">Except the official Python Language Reference says "you may think of it as the object’s address in memory", so the object's address in memory is of concern, at least according to the documentation (<a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#basic-customization</a>). Or perhaps this statement is misleading and should be revised in the official doc.</span>
<span class="comment-copy">In CPython, you can (currently) rely on the fact that an object's memory address as returned by <code>id()</code> will not change.  This follows by the definition of the "object identity" returned by <code>id()</code>.  Moving an object to a different memory address in a C extension is totally pointless, to say the least.</span>
<span class="comment-copy">@FerdinandBeyer You don't understand my post. I explicitly say and agree with <i>mac</i> that  memory addresses in Cpython are - by design - static.  But this promise can break if someone uses weird C-extension. So id don't understand your -1.</span>
<span class="comment-copy">You cannot rely on <i>anything</i> if someone uses a "weird" destructive extension.  Can you name one extension that actually moves objects in memory?  AFAIK, it cannot be done in a reasonable way, since to move an object, an extension needs to update all places where the object is referenced.</span>
<span class="comment-copy">I just want to point out that this is possible. I'm not sure if there is some, which is used. I agree that normally it is destructive.</span>
<span class="comment-copy">Look, a Python object is a <code>PyObject*</code> in C.  If you write an extension function that takes a <code>PyObject*</code>, it already has a memory address, reference count and so on.  If you want to move this object in memory, you would have to somehow find all places where this pointer is stored and update them.  In theory, this is possible, but in practice, nobody would try to do that.  Plus, according to your statement, you cannot rely on <code>len(x)</code> returning the length of <code>x</code>, since it is possible that some Python (!) module runs code like <code>import __builtin__ as bi; bi.len = lambda x: 42</code>.</span>
