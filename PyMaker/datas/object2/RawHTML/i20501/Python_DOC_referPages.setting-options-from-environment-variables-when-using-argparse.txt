<div class="post-text" itemprop="text">
<p>I have a script which has certain options that can either be passed on the command line, or from environment variables. The CLI should take precedence if both are present, and an error occur if neither are set.</p>
<p>I could check that the option is assigned after parsing, but I prefer to let argparse to do the heavy lifting and be responsible for displaying the usage statement if parsing fails.</p>
<p>I have come up with a couple of alternative approaches to this (which I will post below as answers so they can be discussed separately) but they feel pretty kludgey to me and I think that I am missing something.</p>
<p>Is there an accepted "best" way of doing this?</p>
<p>(Edit to make the desired behaviour clear when both the CLI option and environment variable are unset)</p>
</div>
<div class="post-text" itemprop="text">
<p>I would just set the <code>default</code> variable when adding an argument to a get of os.environ with the Variable you want to grab. The 2nd Argument in the <code>.get()</code> call is the default value if <code>.get()</code> doesn't find an environment variable by that name.</p>
<pre><code>import argparse
import os

parser = argparse.ArgumentParser(description='test')
parser.add_argument('--url', default=os.environ.get('URL', None))

args = parser.parse_args()
if not args.url:
    exit(parser.print_usage())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use this pattern frequently enough that I have packaged a simple action class to handle it:</p>
<pre><code>import argparse
import os

class EnvDefault(argparse.Action):
    def __init__(self, envvar, required=True, default=None, **kwargs):
        if not default and envvar:
            if envvar in os.environ:
                default = os.environ[envvar]
        if required and default:
            required = False
        super(EnvDefault, self).__init__(default=default, required=required, 
                                         **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)
</code></pre>
<p>I can then call this from my code with:</p>
<pre><code>import argparse
from envdefault import EnvDefault

parser=argparse.ArgumentParser()
parser.add_argument(
    "-u", "--url", action=EnvDefault, envvar='URL', 
    help="Specify the URL to process (can also be specified using URL environment variable)")
args=parser.parse_args()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://pypi.python.org/pypi/ConfigArgParse/">ConfigArgParse</a> adds support for environment variables to argparse, so you can do things like:</p>
<pre><code>p = configargparse.ArgParser()
p.add('-m', '--moo', help='Path of cow', env_var='MOO_PATH') 
options = p.parse_args()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I usually have to do this for multiple arguments (authentication and API keys).. this is simple and straight forward.  Uses **kwargs.</p>
<pre><code>def environ_or_required(key):
    if os.environ.get(key):
        return {'default': os.environ.get(key)}
    else:
        return {'required': True}

parser.add_argument('--thing', **environ_or_required('THING'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The topic is quite old, but I had similar problem and I thought I would share my solution with you. Unfortunately custom action solution suggested by @Russell Heilling doesn't work for me for couple of reasons:</p>
<ul>
<li>It prevents me from using <a href="https://docs.python.org/dev/library/argparse.html#action" rel="nofollow">predefined actions</a> (like <code>store_true</code>)</li>
<li>I would rather like it to fallback to <code>default</code> when <code>envvar</code> is not in <code>os.environ</code> (that could be easily fixed)</li>
<li>I would like to have this behaviour for all of my arguments without specifying <code>action</code> or <code>envvar</code> (which should always be <code>action.dest.upper()</code>)</li>
</ul>
<p>Here's my solution (in Python 3):</p>
<pre><code>class CustomArgumentParser(argparse.ArgumentParser):
    class _CustomHelpFormatter(argparse.ArgumentDefaultsHelpFormatter):
        def _get_help_string(self, action):
            help = super()._get_help_string(action)
            if action.dest != 'help':
                help += ' [env: {}]'.format(action.dest.upper())
            return help

    def __init__(self, *, formatter_class=_CustomHelpFormatter, **kwargs):
        super().__init__(formatter_class=formatter_class, **kwargs)

    def _add_action(self, action):
        action.default = os.environ.get(action.dest.upper(), action.default)
        return super()._add_action(action)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One option is to check whether the environment variable is set, and to modify the calls to add_argument accordingly
e.g.</p>
<pre><code>import argparse
import os

parser=argparse.ArgumentParser()
if 'CVSWEB_URL' in os.environ:
    cvsopt = { 'default': os.environ['CVSWEB_URL'] }
else:
    cvsopt = { 'required': True }
parser.add_argument(
    "-u", "--cvsurl", help="Specify url (overrides CVSWEB_URL environment variable)", 
    **cvsopt)
args=parser.parse_args()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is an <a href="https://docs.python.org/3/library/collections.html#chainmap-examples-and-recipes" rel="nofollow noreferrer">example use-case for <code>ChainMap</code></a> where you merge together defaults, environment variables and command line arguments.</p>
<pre><code>import os, argparse

defaults = {'color': 'red', 'user': 'guest'}

parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = {k:v for k, v in vars(namespace).items() if v}

combined = ChainMap(command_line_args, os.environ, defaults)
</code></pre>
<p>Came to me from <a href="https://youtu.be/OSGv2VnC0go?t=29m11s" rel="nofollow noreferrer">a great talk</a> about <em>beautiful and idiomatic</em> python.</p>
<p>However, I'm not sure how to go about the difference of lower- and uppercase dictionary keys. In the case where both <code>-u foobar</code> is passed as an argument and environment is set to <code>USER=bazbaz</code>, the <code>combined</code> dictionary will look like <code>{'user': 'foobar', 'USER': 'bazbaz'}</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thought I'd post my solution as the original question/answer gave me a lot of help.</p>
<p>My problem is a little different to Russell's. I'm using OptionParser and instead of an environmental variable for each argument I have just one which simulates the command line.</p>
<p>i.e.</p>
<p>MY_ENVIRONMENT_ARGS = --arg1 "Maltese" --arg2 "Falcon" -r "1930" -h</p>
<p>Solution:</p>
<pre><code>def set_defaults_from_environment(oparser):

    if 'MY_ENVIRONMENT_ARGS' in os.environ:

        environmental_args = os.environ[ 'MY_ENVIRONMENT_ARGS' ].split()

        opts, _ = oparser.parse_args( environmental_args )

        oparser.defaults = opts.__dict__

oparser = optparse.OptionParser()
oparser.add_option('-a', '--arg1', action='store', default="Consider")
oparser.add_option('-b', '--arg2', action='store', default="Phlebas")
oparser.add_option('-r', '--release', action='store', default='1987')
oparser.add_option('-h', '--hardback', action='store_true', default=False)

set_defaults_from_environment(oparser)

options, _ = oparser.parse_args(sys.argv[1:])
</code></pre>
<p>Here I don't throw an error if an argument is not found. But if I wish to I could just do something like</p>
<pre><code>for key in options.__dict__:
    if options.__dict__[key] is None:
        # raise error/log problem/print to console/etc
</code></pre>
</div>
<span class="comment-copy">None is the default for .get(), so doesn't need to be explicitly stated like this.  I should probably have been more clear in the question - the option needs to be in at least one of the environment variable or the CLI.  If you set the default like this, then args.url may well end up as None, which is what I want to avoid...</span>
<span class="comment-copy">Ah, I see what you are looking for. I would honestly just use what I wrote and after parsing the args just check <code>if not args.url: exit(parser.print_usage())</code> and exit.</span>
<span class="comment-copy">A nice quick way of handling it.  I have packaged up my own action handler because I use this pattern a lot, but this would certainly be my fallback for a quick and simple script.</span>
<span class="comment-copy">In my eyes this looks like the more expressive way. If there is not a very specific reason to get more complex, this is just elegant and short. Therefore I think this should be the "correct" answer, although @RussellHeilling also proposed a good alternative.</span>
<span class="comment-copy">The way this answer proposes is bad UX. "default" means "default for the application", not "default in the current environment". People may look at --help, see a particular default, assume it's default forever, go to another machine/session, get kaboom.</span>
<span class="comment-copy">Should default this be edited to look up in os.environ? "if envvar in os.environ: default = envvar" --&gt; "if envvar in os.environ: default = os.environ[envvar]"</span>
<span class="comment-copy">Why do you only use the value specified by the envvar if there's no default? Shouldn't it override the default, as the caller has explicitly provided a value?</span>
<span class="comment-copy">This solution is great. However, it has a side-effect : depending on your environment (whether or not the env var is set), the usage text may differ.</span>
<span class="comment-copy">this fails for type=bool any ideas on how that can be made to work?</span>
<span class="comment-copy">@codebreach: I'm guessing you're hitting <a href="https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse">this problem</a>.</span>
