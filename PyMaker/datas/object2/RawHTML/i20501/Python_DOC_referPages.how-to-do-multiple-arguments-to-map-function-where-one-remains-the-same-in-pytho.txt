<div class="post-text" itemprop="text">
<p>Lets say we have a function add as follows</p>
<pre><code>def add(x, y):
    return x + y
</code></pre>
<p>we want to apply map function for an array </p>
<pre><code>map(add, [1, 2, 3], 2)
</code></pre>
<p>The semantics are I want to add 2 to the every element of the array. But the <code>map</code> function requires a list in the third argument as well.</p>
<p><strong>Note:</strong> I am putting the add example for simplicity. My original function is much more complicated. And of course option of setting the default value of <code>y</code> in add function is out of question as it will be changed for every call.</p>
</div>
<div class="post-text" itemprop="text">
<p>One option is a list comprehension:</p>
<pre><code>[add(x, 2) for x in [1, 2, 3]]
</code></pre>
<p>More options:</p>
<pre><code>a = [1, 2, 3]

import functools
map(functools.partial(add, y=2), a)

import itertools
map(add, a, itertools.repeat(2, len(a)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The docs explicitly suggest this is the main use for <code>itertools.repeat</code>:</p>
<blockquote>
<p>Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to <a href="https://docs.python.org/3/library/functions.html#map" rel="noreferrer"><code>map()</code></a> for invariant parameters to the called function. Also used with <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip()</code></a> to create an invariant part of a tuple record. </p>
</blockquote>
<p>And there's no reason for pass <code>len([1,2,3])</code> as the <code>times</code> argument; <code>map</code> stops as soon as the first iterable is consumed, so an infinite iterable is perfectly fine:</p>
<pre><code>&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; from itertools import repeat
&gt;&gt;&gt; list(map(add, [1,2,3], repeat(4)))
[5, 6, 7]
</code></pre>
<p>In fact, this is equivalent to the example for <code>repeat</code> in the docs:</p>
<pre><code>&gt;&gt;&gt; list(map(pow, range(10), repeat(2)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>This makes for a nice lazy-functional-language-y solution that's also perfectly readable in Python-iterator terms.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a list comprehension.</p>
<pre><code>[x + 2 for x in [1, 2, 3]]
</code></pre>
<p>If you <em>really</em>, <em>really</em>, <em>really</em> want to use <code>map</code>, give it an anonymous function as the first argument:</p>
<pre><code>map(lambda x: x + 2, [1,2,3])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have it available, I would consider using numpy. It's very fast for these types of operations:</p>
<pre><code>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; numpy.array([1,2,3]) + 2
array([3, 4, 5])
</code></pre>
<p>This is assuming your real application is doing mathematical operations (that can be vectorized).</p>
</div>
<div class="post-text" itemprop="text">
<p>Map can contain multiple arguments, the standard way is </p>
<pre><code>map(add, a, b)
</code></pre>
<p>In your question, it should be </p>
<pre><code>map(add, a, [2]*len(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes I resolved similar situations (such as using <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" rel="noreferrer">pandas.apply</a> method) using <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" rel="noreferrer">closures</a></p>
<p>In order to use them, you define a function which dynamically defines and returns a wrapper for your function, effectively making one of the parameters a constant.</p>
<p>Something like this:</p>
<pre><code>def add(x, y):
   return x + y

def add_constant(y):
    def f(x):
        return add(x, y)
    return f
</code></pre>
<p>Then, <code>add_constant(y)</code> returns a function which can be used to add <code>y</code> to any given value:</p>
<pre><code>&gt;&gt;&gt; add_constant(2)(3)
5
</code></pre>
<p>Which allows you to use it in any situation where parameters are given one at a time:</p>
<pre><code>&gt;&gt;&gt; map(add_constant(2), [1,2,3])
[3, 4, 5]
</code></pre>
<p><strong>edit</strong></p>
<p>If you do not want to have to write the closure function somewhere else, you always have the possibility to build it on the fly using a lambda function:</p>
<pre><code>&gt;&gt;&gt; map(lambda x: add(x, 2), [1, 2, 3])
[3, 4, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The correct answer is simpler than you think.
Simply do:</p>
<pre><code>map(add, [(x, 2) for x in [1,2,3]])
</code></pre>
<p>And change the implementation of add to take a tuple i.e</p>
<pre><code>def add(t):
   x, y = t
   return x+y
</code></pre>
<p>This can handle any complicated use case where both add parameters are dynamic.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really really need to use map function (like my class assignment here...), you could use a wrapper function with 1 argument, passing the rest to the original one in its body; i.e. :</p>
<pre><code>extraArguments = value
def myFunc(arg):
    # call the target function
    return Func(arg, extraArguments)


map(myFunc, itterable)
</code></pre>
<p>Dirty &amp; ugly, still does the trick</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe starmap is what you need:</p>
<pre><code>from itertools import starmap


def test(x, y, z):
    return x + y + z

list(startmap(test, [(1, 2, 3), (4, 5, 6)]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To pass multiple arguments to a <code>map</code> function.</p>
<pre><code>def q(x,y):
    return x*y

print map (q,range(0,10),range(10,20))
</code></pre>
<p>Here <strong>q</strong> is function with multiple argument that <strong>map()</strong> calls.
Make sure, the length of both the ranges i.e.</p>
<pre><code>len (range(a,a')) and len (range(b,b')) are equal.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>
def func(a, b, c, d):
 return a + b * c % d</code></p>
<p>map(lambda x: func(*x), [[1,2,3,4], [5,6,7,8]])
</p></div>
<div class="post-text" itemprop="text">
<p>Another option is:</p>
<pre><code>results = []
for x in [1,2,3]:
    z = add(x,2)
    ...
    results += [f(z,x,y)]
</code></pre>
<p>This format is very useful when calling multiple functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>In :<code>nums = [1, 2, 3]</code></p>
<p>In :<code>map(add, nums, [2]*len(nums))</code></p>
<p>Out:<code>[3, 4, 5]</code></p>
</div>
<span class="comment-copy">this is exactly the same as in Lisp: <code>map(add,[1,2,3],[2]*3)</code>  in general <code>map</code> takes in a function as its first argument, and if this function takes <b>K</b> argument, you have to follow up with <b>K</b> iterable: <code>addTriple(a,b,c) -&gt; map(addTriple,[...],[...],[...])</code></span>
<span class="comment-copy">yup, but how fast is it in comparison to map function?</span>
<span class="comment-copy">@Shan: Very similar, especially if <code>add()</code> is a non-trivial function</span>
<span class="comment-copy">@Shan: Take a look at NumPy in this case.  If this really is an issue for you, the speed difference between list comprehensions and <code>map()</code> won't help either way.</span>
<span class="comment-copy">@Shan: As I said before, have a look at NumPy.  It might help speeding up loops conderably, provided they can be vectorised.</span>
<span class="comment-copy">@abarnert: It's unclear whether the OP is using Python 2 or 3.  To make sure the example works in Python 2, I included the parameter. (Note that <code>map()</code> behaves like <code>zip_longest()</code> in Python 2, while it behaves like <code>zip()</code> in Python 3.)</span>
<span class="comment-copy">+1 This should be the accepted answer.  It extends to any number of parameters, of course, with some constant and others lists or generators. E.g.: <code>def f(x,y,z): \\  return '.'.join([x,y,z])</code> and then: <code>list(map(f, list('abc'), repeat('foo'), list('defgh')))</code> returns <code>['a.foo.d', 'b.foo.e', 'c.foo.f']</code>.</span>
<span class="comment-copy">In Python 2, it's necessary to provide the length argument to <code>repeat()</code>, since <code>map()</code> will run until the <i>longest</i> iterator is exhausted in that version of Python, filling in <code>None</code> for all missing values.  Saying that "there's not reason" to pass the parameter is wrong.</span>
<span class="comment-copy">@SvenMarnach 's comment is not minor: <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow noreferrer">Python 3</a> and <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer">Python 2</a> 's behaviour varies drastically!</span>
<span class="comment-copy">Not sure what his question meant to but i think add accept 2 value and those 2 are not fixed and should come from user like arg1 is coming. so in this case how we should call add(x, y) under map?</span>
<span class="comment-copy">A closure, I think this adds something, plus one. Similar to a partial function, as the accepted answer has.</span>
<span class="comment-copy"><code>myFunc</code> needs to <code>return Func(arg, extraArguments)</code></span>
<span class="comment-copy">I stand corrected @PM2Ring, that's true; updated the code.</span>
<span class="comment-copy">where is Func defined? because I am getting a name error for Func</span>
<span class="comment-copy"><code>Func</code> is the name of your original function - for OP tight would be <code>add</code> for example</span>
<span class="comment-copy">This does not provide an answer to the question. You can <a href="https://stackoverflow.com/search">search for similar questions</a>, or refer to the related and linked questions on the right-hand side of the page to find an answer. If you have a related but different question, <a href="https://stackoverflow.com/questions/ask">ask a new question</a>, and include a link to this one to help provide context. See: <a href="https://stackoverflow.com/tour">Ask questions, get answers, no distractions</a></span>
