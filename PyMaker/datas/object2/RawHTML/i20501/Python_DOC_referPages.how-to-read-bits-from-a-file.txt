<div class="post-text" itemprop="text">
<p>I know how to read bytes — <code>x.read(number_of_bytes)</code>, but how can I read bits in Python?</p>
<p>I have to read only 5 bits (not 8 bits [1 byte]) from a binary file</p>
<p>Any ideas or approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python can only read a byte at a time. You'd need to read in a full byte, then just extract the value you want from that byte, e.g.</p>
<pre><code>b = x.read(1)
firstfivebits = b &gt;&gt; 3
</code></pre>
<p>Or if you wanted the 5 least significant bits, rather than the 5 most significant bits:</p>
<pre><code>b = x.read(1)
lastfivebits = b &amp; 0b11111
</code></pre>
<p>Some other useful bit manipulation info can be found here: <a href="http://wiki.python.org/moin/BitManipulation">http://wiki.python.org/moin/BitManipulation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As the accepted answer states, standard Python I/O can only read and write whole byte(s) at a time. However you can simulate such a stream of bits using this recipe for <a href="http://rosettacode.org/wiki/Bitwise_IO#Python" rel="nofollow noreferrer">Bitwise I/O</a>.</p>
<p><strong>Updates</strong></p>
<p>After modifying the Rosetta Code's Python version to work in unchanged in both Python 2 &amp; 3, I incorporated those changes into this answer.</p>
<p>In addition to that, later, after being inspired by a comment made by @mhernandez, I further modified the Rosetta Code so it supports what's called the <a href="https://docs.python.org/3/glossary.html#term-context-manager" rel="nofollow noreferrer">context manager protocol</a> which allows instances of both of its two classes to be used in Python <a href="https://docs.python.org/3/reference/compound_stmts.html#with" rel="nofollow noreferrer"><code>with</code></a> statements. Latest version is shown below:</p>
<pre><code>class BitWriter(object):
    def __init__(self, f):
        self.accumulator = 0
        self.bcount = 0
        self.out = f

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.flush()

    def __del__(self):
        try:
            self.flush()
        except ValueError:   # I/O operation on closed file.
            pass

    def _writebit(self, bit):
        if self.bcount == 8:
            self.flush()
        if bit &gt; 0:
            self.accumulator |= 1 &lt;&lt; 7-self.bcount
        self.bcount += 1

    def writebits(self, bits, n):
        while n &gt; 0:
            self._writebit(bits &amp; 1 &lt;&lt; n-1)
            n -= 1

    def flush(self):
        self.out.write(bytearray([self.accumulator]))
        self.accumulator = 0
        self.bcount = 0


class BitReader(object):
    def __init__(self, f):
        self.input = f
        self.accumulator = 0
        self.bcount = 0
        self.read = 0

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass

    def _readbit(self):
        if not self.bcount:
            a = self.input.read(1)
            if a:
                self.accumulator = ord(a)
            self.bcount = 8
            self.read = len(a)
        rv = (self.accumulator &amp; (1 &lt;&lt; self.bcount-1)) &gt;&gt; self.bcount-1
        self.bcount -= 1
        return rv

    def readbits(self, n):
        v = 0
        while n &gt; 0:
            v = (v &lt;&lt; 1) | self._readbit()
            n -= 1
        return v

if __name__ == '__main__':
    import os
    import sys
    # Determine this module's name from it's file name and import it.
    module_name = os.path.splitext(os.path.basename(__file__))[0]
    bitio = __import__(module_name)

    with open('bitio_test.dat', 'wb') as outfile:
        with bitio.BitWriter(outfile) as writer:
            chars = '12345abcde'
            for ch in chars:
                writer.writebits(ord(ch), 7)

    with open('bitio_test.dat', 'rb') as infile:
        with bitio.BitReader(infile) as reader:
            chars = []
            while True:
                x = reader.readbits(7)
                if not reader.read:  # End-of-file?
                    break
                chars.append(chr(x))
            print(''.join(chars))
</code></pre>
<p>Another usage example showing how to "crunch" an 8-bit byte ASCII stream discarding the most significant "unused" bit...and read it back (however neither use it as a context manger).</p>
<pre><code>import sys
import bitio

o = bitio.BitWriter(sys.stdout)
c = sys.stdin.read(1)
while len(c) &gt; 0:
    o.writebits(ord(c), 7)
    c = sys.stdin.read(1)
o.flush()
</code></pre>
<p>...and to "decrunch" the same stream:</p>
<pre><code>import sys
import bitio

r = bitio.BitReader(sys.stdin)
while True:
    x = r.readbits(7)
    if not r.read:  # nothing read
        break
    sys.stdout.write(chr(x))
</code></pre>
</div>
<span class="comment-copy">Are those bits consecutive?  If so, the five most significant bits, or five least significant bits in the byte?</span>
<span class="comment-copy">when my reputations grows to 15, I'll give you thumbs up! (I'm new here) so, if I do this: b = x.read(1) firstfivebits = b &gt;&gt; 3 I'll get the first 5 bits... why not firstfivebits = b &gt;&gt; 5? y mean... why b &gt;&gt; 3?</span>
<span class="comment-copy">@HugoMedina if you don't know why <code>firstfivebits = b &gt;&gt; 3</code> you sure you should be fiddlin' with bits?  (You might go blind or something ;).</span>
<span class="comment-copy">now I get it, since 1 byte = 8 bits we'll apply right-shift operator 3 (like deleting those 3 least significant bits)  so we'll get the remaining 5 bits in the byte</span>
<span class="comment-copy">+1 for the self-contained snippet. Note that the main may not read what it's meant to because the writer may not be deleted when the reader attempts reading. A call to writer.flush() solves it.</span>
<span class="comment-copy">@mhernandez: Extending the <code>bitio</code> classes so they support the <a href="https://docs.python.org/3/glossary.html#term-context-manager" rel="nofollow noreferrer">context manager protocol</a> like the built-in <code>file</code> class does would probably be a very worthwhile endeavor—and an even better way to take care of the issue.</span>
<span class="comment-copy">Agreed, in fact that's exactly what I did. Thank you sir</span>
<span class="comment-copy">mhernandez: Glad to hear it helped. BTW I recently modified the Rosetta Code's Python version so it also supports the context manager protocol—and then updated my answer here accordingly. (It was done in that order because Rosetta Code's license on allows verbatim copies in a context like this.)</span>
