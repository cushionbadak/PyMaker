<div class="post-text" itemprop="text">
<pre><code>path = [[0, 1, 0, 0], 
       [0, 0, 1, 1], 
       [0, 0, 0, 1], 
       [1, 0, 0, 0]]
print [hex(id(path[0])),hex(id(path[1])), hex(id(path[2]))], id(path[1])-id(path[0]),id(path[2]) -id(path[1])
path[1] = [0,0, 0, 0]
print path
print [hex(id(path[0])),hex(id(path[1])), hex(id(path[2]))], id(path[1])-id(path[0]),id(path[2]) -id(path[1])
</code></pre>
<p>This is python 2.7, CPython. The example of the result:</p>
<blockquote>
<p>['0x107d05638', '0x107cefb90', '0x107cef7e8'] -88744 -936</p>
<p>[[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0]]</p>
<p>['0x107d05638', '0x107cef8c0', '0x107cef7e8'] -89464 -216</p>
</blockquote>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, some important notes.</p>
<ol>
<li><p>The <strong><code>id(..)</code> does not necessary refers to the address of the object</strong>. Indeed the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">documentation says</a>:</p>
<blockquote>
<p><strong><code>id(object)</code></strong></p>
<p>Return the "identity" of an object. This is an integer which is
  guaranteed to be unique and constant for this object during its
  lifetime. Two objects with non-overlapping lifetimes may have the same
  <code>id()</code> value.</p>
<p><strong>CPython implementation detail:</strong> This is the address of the object in memory.</p>
</blockquote>
<p>So only in CPython, it is guaranteed to be the case.</p></li>
<li><p>There is <strong>no such thing as a 2d list in Python</strong>. Python has only a very limited amount of fundamental datastructures: sets, dictionaries, ints, strings, lists,... But <strong>no 2d lists</strong>. A 2d list is a list of lists. That may look like a detail, but you can for instance declare: <code>[[1,0,1],2,'foobar']</code>. So this is only partially a 2d list. Python simply sees a list and one of the elements <em>happens</em> to be a list.</p>
<p>What does this mean? That in your question the list looks like:</p>
<pre><code>+---------------+
|      list     |
+---+---+---+---+
| o | o | o | o |
+-|-+-|-+-|-+-|-+
  |   |   |   \________________________________________________
  |   |   \________________________________                    \
  |   \______________                      \                    |
  |                  \                      |                   |
+-v-------------+  +--v------------+  +-----v---------+  +------v--------+
|      list     |  |      list     |  |      list     |  |      list     |
+---+---+---+---+  +---+---+---+---+  +---+---+---+---+  +---+---+---+---+
| o | o | o | o |  | o | o | o | o |  | o | o | o | o |  | o | o | o | o |
+-|-+---+---+---+  +-|-+-|-+-|-+-|-+  +-|-+-|-+-|-+-|-+  +-|-+-|-+-|-+-|-+
  v   v   v   v      v   v   v   v      v   v   v   v      v   v   v   v
  0   1   0   0      0   0   1   1      0   0   0   1      1   0   0   0
</code></pre>
<p>The <code>0</code>s and <code>1</code>s are also objects by the way, but these are references to the same object.</p></li>
<li><p>Usually the interpreter uses a heap and allocates <strong>on the heap</strong>. Now a heap can be fragmented because earlier objects have been allocated and deallocated on the heap. As a result, the interpreter aims to find a <em>hole</em> where the object to allocate can fit into.</p></li>
<li><p>Lists can <strong>share sublists</strong>. For instance:</p>
<pre><code>a = [1,0]
b = [[0,0],a,[0,1],[0,0]]
c = [a]
</code></pre>
<p>Now both <code>b</code> and <code>c</code> have an element that references the object <code>a</code>. So one cannot make both <code>b</code> and <code>c</code> contiguous.</p></li>
<li><p>If you perform:</p>
<pre><code>path[1] = [0,0, 0, 0]
</code></pre>
<p>you basically <strong>first construct a new list <code>[0,0,0,0]</code></strong>. Since the old list <code>path[1]</code> is <strong>still in memory</strong>, it cannot fill that hole. So a Python interpreter will have to find another place to locate that <code>[0,0,0,0]</code>. Then it sets a reference from <code>path[1]</code> to that list, and finally (usually after reference counting is updated), it will remove the old list for <code>path[1]</code> (this can also be delayed until memory should be freed) and thus marking the place that was once occupied back as vacant.</p></li>
</ol>
<p>These notes basically answer the question: there is no 2d list: all objects are allocated on the heap and because a lot of allocation/deallocation happens (for instance even when starting up and loading libraries). It is undetermined where an object will be allocated. Since an object can be shared the memory layout cannot be contiguous for all lists at the same time.</p>
<p>Finally note that Python usually assumes that <em>programmers convenience</em> is more important than <em>efficiency</em>. Python is rather inefficient: it is dynamically typed, has (for instance by using an MRO) inefficient way to resolve dynamic bindings, usually has a lot of <em>fallback</em> mechanisms in place that also cost computational effort. In <a class="post-tag" href="/questions/tagged/python-3.x" rel="tag" title="show questions tagged 'python-3.x'">python-3.x</a> they also introduced integers with arbitrary length, etc. These features all place a considerable burden on the CPU, but the philosophy of Python is usually that Programmers convenience is preferred above CPU efficiency since paying an additional programmer usually costs more than buying two new servers.</p>
</div>
<div class="post-text" itemprop="text">
<p>All memory for Python objects is managed in a private heap. The 2D list is a data structure and an example of a Python object (since everything from a primitive type to a class type is considered an 'object' in Python). </p>
<p>The Python memory manager, which manages the private heap, decides how to allocate memory to your 2D array object based off the distinct memory management policies that pertain to the 2D array type. Clearly, in this case, it is not favorable (possible for performance or overhead reasons) to ensure that memory for the entire array is allocated contiguously.</p>
<p>This illustrates the idea that pointer-math arithmetic is not required in a higher-level language. In C, a simple formula for A[x][y] is used to retrieve the value stored, but in Python, we can get more complex.</p>
</div>
<span class="comment-copy">are we sure that <code>id</code> is the object address?</span>
<span class="comment-copy">There is <b>no guarantee</b> that <code>id</code> represents a memory address. Afaik the only constraint is that an interpreter has to make it unique for unique objects and vice versa.</span>
<span class="comment-copy">Furthermore the objects are <b>not allocated</b> on the stack, but on the heap, and thus it is hard to guarantee contigous layouts on a heap.</span>
<span class="comment-copy">@WillemVanOnsem: CPython (which this question is probably about) does use the <a href="https://github.com/python/cpython/blob/c2cf12857187aa147c268651f10acd6da2c9cb74/Python/bltinmodule.c#L1103-L1108" rel="nofollow noreferrer">address of the object in memory</a>.</span>
<span class="comment-copy">Not having to worry about memory management and layout is one of the main strengths of Python.</span>
