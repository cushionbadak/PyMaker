<div class="post-text" itemprop="text">
<p>The purpose of <code>base64.b64encode()</code> is to convert binary data into ASCII-safe "text". However, the method returns an object of type bytes:</p>
<pre><code>&gt;&gt;&gt; import base64
&gt;&gt;&gt; base64.b64encode(b'abc')
b'YWJj'
</code></pre>
<p>It's easy to simply take that output and <code>decode()</code> it, but my question is: what is a significance of <code>base64.b64encode()</code> returning <code>bytes</code> rather than a <code>str</code>?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The purpose of the base64.b64encode() function is to convert binary data into ASCII-safe "text"</p>
</blockquote>
<p>Python disagrees with that - base64 has been intentionally classified as a <a href="https://docs.python.org/3/library/codecs.html#binary-transforms" rel="noreferrer">binary transform</a>.  </p>
<p>It was a design decision in Python 3 to force the separation of bytes and text and prohibit implicit transformations.  Python is now so strict about this that <code>bytes.encode</code> doesn't even exist, and so <code>b'abc'.encode('base64')</code> would raise an <code>AttributeError</code>.  </p>
<p>The opinion the language takes is that a bytestring object is <em>already</em> encoded.  A codec which encodes bytes into text does not fit into this paradigm, because when you want to go from the bytes domain to the text domain it's a <em>decode</em>.  Note that <code>rot13</code> encoding was also banished from the list of <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" rel="noreferrer">standard encodings</a> for the same reason - it didn't fit properly into the Python 3 paradigm.  </p>
<p>There also can be a performance argument to make:  suppose Python automatically handled decoding of the base64 output, which is an <em>ASCII-encoded binary representation</em> produced by C code from the <a href="https://docs.python.org/3/library/binascii.html#binascii.b2a_base64" rel="noreferrer"><code>binascii</code></a> module, into a Python object in the text domain.  If you actually wanted the bytes, you would just have to undo the decoding by encoding into ASCII again.  It would be a wasteful round-trip, an unnecessary double-negation.  Better to 'opt-in' for the decode-to-text step.  </p>
</div>
<div class="post-text" itemprop="text">
<p>It's impossible for <code>b64encode()</code> to know what you want to do with its output. </p>
<p>While in many cases you may want to treat the encoded value as text, in many others – for example, sending it over a network – you may instead want to treat it as bytes.</p>
<p>Since <code>b64encode()</code> can't know, it refuses to guess. And since the input is <code>bytes</code>, the output remains the same type, rather than being implicitly coerced to <code>str</code>.</p>
<p>As you point out, decoding the output to <code>str</code> is straightforward:</p>
<pre><code>base64.b64encode(b'abc').decode('ascii')
</code></pre>
<p>... as well as being explicit about the result.</p>
<p>As an aside, it's worth noting that although <code>base64.b64decode()</code> (note: <strong><em>de</em></strong>code</p></div>
<span class="comment-copy">I think "A codec which encodes bytes into text does not fit into this paradigm, because when you want to go from the bytes domain to the text domain it's a decode" explains it for me. So in isolation it might not make perfect sense but in spirit of making all encode()/decode() methods have uniform inputs/outputs it makes sense. I still think it is a bit weird :)</span>
<span class="comment-copy">I'd say that 99.99% of the time you want it as a string, and that should be the default. In the case that you'd care about performance or the other nuances you could call another function.</span>
<span class="comment-copy">Please let me know what problem with my answer caused the downvote, so that I can consider how to address it.</span>
<span class="comment-copy">I rather liked it.   Maybe, just add a one liner code example like <code>base64.b64encode(b'abc').decode('ascii')</code> so that people reaching here in a google search have what to copy/paste.</span>
<span class="comment-copy">@jsbueno Done, thanks :-)</span>
<span class="comment-copy">Note that there's no difference between "why not return a str then?" and "why not return a bytes object then?" ... it has to choose <i>something</i>, and <code>bytes</code> was considered most consistent with the principle that implicit coercion should be avoided.</span>
<span class="comment-copy">Note also that <code>str</code> is <i>definitely not</i> a subset of, or narrower than, <code>bytes</code>: the former consists of up to 1,114,112 different code points, whereas the latter can represent only 256 different states (which may be integers, characters, or something else). ASCII happens to be representable in a subset of both, as does the base64 alphabet, but there's no inherent reason to suppose that one is a more natural fit than the other.</span>
