<div class="post-text" itemprop="text">
<p>I'm going through the exercises in Coding the Matrix, and have gotten to this task: write a procedure all_3_digit_numbers(base, digits), where input is a positive integer base and digits is the set {0, 1,2, ..., base-1}, and the output is the set of all three-digit numbers where the base is <em>base.</em>
I was able to come up with one solution: </p>
<pre><code>def all_3_digit_numbers(base, digits): return {a+b+c for a in [d*base**2 for d    in digits] for b in [d*base**1 for d in digits] for c in [d*base**0 for d in digits]}
</code></pre>
<p>which fits in one line. But I thought the repetition of the expression d*base**exp could be consolidated. So I also have this solution: </p>
<pre><code>def all_3_digit_numbers(base, digits):
   [alist,blist,clist] = [[digit*base**exp for digit in digits] for exp in [0,1,2]]
   return {a+b+c for a in alist for b in blist for c in clist}
</code></pre>
<p>which is more elegant (I guess), but requires an extra expression. I was wondering if there's a way to get the best of both worlds - a comprehension that doesn't require variable assignment in a separate statement as it does the second solution, but where the list of digits to add is not repeated as it is in the first solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>These intermediate lists make the code really long. No need for that:</p>
<pre><code>def all_3_digit_numbers(base, digits): 
    return {a*base**2 + b*base + c for a in digits for b in digits for c in digits}
</code></pre>
<p>And if you want to be a little bit more fancy, use <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a>:</p>
<pre><code>from itertools import product

def all_3_digit_numbers2(base, digits): 
    return {a*base**2 + b*base + c for a, b, c in product(digits, repeat=3)}
</code></pre>
</div>
<span class="comment-copy">I take it you are unfamiliar with <a href="https://docs.python.org/3.6/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools</code></a> ?</span>
<span class="comment-copy">wait, can't you just do <code>return range(base ** digits)</code>? Or I guess <code>set(range(base ** digits))</code></span>
<span class="comment-copy">@TadhgMcDonald-Jensen <code>digits</code> is a (redundant) set, not a number (the same as base).  For instance, <code>2 ** {0, 1}</code> makes no sense.</span>
<span class="comment-copy">You need to specify whether '3-digit' number can or cannot have leading 0s.  To be extra helpful, list the desired answer for base 2.</span>
<span class="comment-copy">@TerryJanReedy ahh missed that, would explain why this seemed far too easy.</span>
<span class="comment-copy">that makes sense! thank you!</span>
