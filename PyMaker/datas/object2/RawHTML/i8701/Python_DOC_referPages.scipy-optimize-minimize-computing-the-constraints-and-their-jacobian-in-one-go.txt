<div class="post-text" itemprop="text">
<p>There is quite a bit of shared computation between the constraints I have on a minimization problem and their Jacobian, to the point where I get the Jacobian almost for free. Is there any way to share the computation?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since constraints and jacobians are probably not always evaluated together, you can only expect a smaller improvement. But if you can put the common calculations into a separate function/method, you can <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer">cache</a> its return values so that you don't need to recompute them later:</p>
<pre><code>import scipy.optimize as opt
from functools import lru_cache

# only for the dummy example:
import scipy as sp
from time import sleep

def cost(x):
    '''dummy cost function to minimize on [1,11]'''
    return sp.log(x)

@lru_cache(maxsize=None) # careful with this choice
def heavy_stuff(x):
    '''idle computation representing common work in constraint and jacobian'''
    sleep(0.1)
    return 0

def constraint(x):
    '''constraint for [1,11], with simulated idle work'''
    # the following only works for 1d arrays, needs more work for nd
    throwaway = heavy_stuff(tuple(x))  
    return 5 - abs(6 - x)  # non-negative between 1 and 11

def jacobian(x):
    '''return the jacobiam with the same simulated idle work'''
    throwaway = heavy_stuff(tuple(x))
    return 1/x

x0 = 11
tol = 0
opts = {'disp': True}
cons = {'type': 'ineq', 'fun': constraint}
kwargs = {'method':'SLSQP', 'constraints': cons,
          'jac': jacobian, 'tol': tol, 'options': opts}
res = opt.minimize(cost,x0,**kwargs)
print(heavy_stuff.cache_info())
</code></pre>
<p>The dummy example above attempts to minimize <code>log(x)</code> over the interval <code>[1,11]</code>. Instead of constant bounds I defined a constraint that gives us the interval, so that I can show what I mean regarding your question.</p>
<p>Both <code>constraint</code> and <code>jacobian</code> do the same work, this is what you want to spare in case multiple evaluations happen with the same argument. You have to put all these common calculations into a common function (here named <code>heavy_stuff</code>), and work with the return values in both <code>constraint</code> and <code>jacobian</code>.</p>
<p>My point is that you should use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a> to memoize the heavy stuff. By setting an appropriate cache size, multiple evaluations of <code>heavy_stuff</code> with the same <code>x</code> will give you the previously computed return value at once, without having to redo the calculation.</p>
<p>If my suspicion is correct, a <code>maxsize=1</code> would probably suffice inside the <code>lru_cache</code> decorator. Setting <code>maxsize=None</code> (no upper limit) poses the danger of losing too much memory for no good reason. You should experiment and see if multiple memoized values are necessary, or whether a few or just one is enough.</p>
<p>Note, however, that <code>lru_cache</code> uses a dict to look up previously computed results, in which keys are the input parameters of the decorated function. This means that the input arguments have to be hashable, which practically means that they should be immutable. Numpy arrays are very similar to lists, and they are similarly <em>not</em> hashable. This is why we call <code>heavy_stuff</code> with <code>tuple(x)</code>: the 1d array input is converted to a tuple. If <code>x</code> is a multidimensional array, then every level of nesting has to be converted to a tuple. What's worse, <code>heavy_stuff</code> almost certainly has to convert the tuples back to numpy ndarrays in order to do the heavy lifting. However, if computing the jacobian/constraint is really this CPU-intensive, then you're probably still better off overall.</p>
<p>If you want to assess the performance of your cache, you should take a closer look at <code>heavy_stuff.cache_info()</code> printed at the end. It will tell you how often cached values were used, and how many times new values had to be calculated.</p>
</div>
<span class="comment-copy">Could you add an example?</span>
