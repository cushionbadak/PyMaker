<div class="post-text" itemprop="text">
<p>I'm making a practice program in Python to calculate all the different weights I can put on the rack, with a given set of plates.</p>
<pre><code>def Weights(t=1,f=1,tn=1,tf=1,thf=1,ff=1,b=45):

  Max=b+5*t+10*f+20*tn+50*tf+70*thf+90*ff
  Poss=range(b,Max+1,5)

  ts=(list((i*5 for i in range(0,t+1))))
  fs=(list((i*10 for i in range(0,f+1))))
  tns=(list((i*20 for i in range(0,tn+1))))
  tfs=(list((i*50 for i in range(0,tf+1))))
  thfs=(list((i*70 for i in range(0,thf+1))))
  ffs=(list((i*90 for i in range(0,ff+1))))

Weights()
</code></pre>
<p>This leaves me with 6 lists.  To get all the combos, I need to add up one element of a list with one element of each other list.  At this point, it's clearly a linear algebra problem, I just don't know how to express this in Python, especially because I don't want to use plugins (No NumPy)</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>To get all the combos, I need to add up one element of a list with one element of each other list.</p>
</blockquote>
<p>It sounds like you want <code>itertools.product</code>. To simplify the example, let's just take three of your seven terms (but it's trivial to pass more, or fewer, arguments into <code>product</code>):</p>
<pre><code>import itertools

b = [45]  # I assume this represents the "bar" and that it's not optional
ts = [0, 5, 10, 15]
fs = [0, 10]

combos = itertools.product(b, ts, fs)
for combo in combos: print(list(combo))
</code></pre>
<p>prints the following:</p>
<pre><code>[45, 0, 0]
[45, 0, 10]
[45, 5, 0]
[45, 5, 10]
[45, 10, 0]
[45, 10, 10]
[45, 15, 0]
[45, 15, 10]
</code></pre>
<p>...which sounds like what you want when you refer to "all the combos".</p>
<p>To get the sum of each, it can all be done in one line:</p>
<pre><code>totals = [sum(combo) for combo in itertools.product(b, ts, fs)]
</code></pre>
<p>Here's a possible flexible way of parameterizing the function:</p>
<pre><code>import itertools

def PossibleWeights(*weights):
    return list(itertools.product(*[[weightset] if isinstance(weightset, (int, float)) else [sum(weightset[:i]) for i in range(len(weightset)+1)] for weightset in weights]))
</code></pre>
<p>When you call, say, <code>PossibleWeights( 45, [10]*2, [5]*3 )</code> the call itself makes it explicit (and readable) that there is one compulsory 45-pound weight, two possible 10-pound weights, and three possible 5-pound weights. You have complete flexibility as to how many such arguments you pass and what their values are.</p>
<p>You could then use a <code>dict</code> to associate each total weight with the combo used to achieve it (incidentally removing duplicate totals, where more than one combo adds up to the same total):</p>
<pre><code>d = {}
for combo in PossibleWeights( 45, [10]*2, [5]*3 ):
    d[sum(combo)] = combo
</code></pre>
<p>...and then pretty-print the result:</p>
<pre><code>for total, combo in sorted(d.items()):
    print('sum(%r) = %r' % (combo, total))
</code></pre>
<p>Output:</p>
<pre><code>sum((45, 0, 0)) = 45
sum((45, 0, 5)) = 50
sum((45, 10, 0)) = 55
sum((45, 10, 5)) = 60
sum((45, 20, 0)) = 65
sum((45, 20, 5)) = 70
sum((45, 20, 10)) = 75
sum((45, 20, 15)) = 80
</code></pre>
<p>BTW: if you want to achieve each total using the minimum number of plates, make sure you're passing heavier plates before lighter plates in your call to <code>PossibleWeights</code>, as in the example above.</p>
<p>Balancing both sides of the bar is left as an exercise for the reader <code>;-)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>I think your approach is wrong and also you signature is bad design: what if you have other than 7 different kinds of weights? I think input as list of tuples (weight, max_number) is more appropriate. And when you start thinking in such terms you understand that "cross-joining" 7 lists is also wrong approach. What you want is to have one list of all simple weights and than get the <a href="https://en.wikipedia.org/wiki/Power_set" rel="nofollow noreferrer">power set</a> i.e. all subsets. <a href="http://rosettacode.org/wiki/Power_set#Python" rel="nofollow noreferrer">Rosetta Code</a> has a few nice implementations of power set in Python. I particularly like this one because it doesn't force generation of whole power-set in memory which might be an issue:</p>
<pre class="lang-py prettyprint-override"><code>def powersequence(val):
    ''' Generate a 'powerset' for sequence types that are indexable by integers.
        Uses a binary count to enumerate the members and returns a list

        Examples:
            &gt;&gt;&gt; powersequence('STR')   # String
            ['', 'S', 'T', 'ST', 'R', 'SR', 'TR', 'STR']
            &gt;&gt;&gt; powersequence([0,1,2]) # List
            [[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2]]
            &gt;&gt;&gt; powersequence((3,4,5)) # Tuple
            [(), (3,), (4,), (3, 4), (5,), (3, 5), (4, 5), (3, 4, 5)]
            &gt;&gt;&gt; 
    '''
    vtype = type(val); vlen = len(val); vrange = range(vlen)
    return [ reduce( lambda x,y: x+y, (val[i:i+1] for i in vrange if 2**i &amp; n), vtype())
             for n in range(2**vlen) ]
</code></pre>
<p>Or you can build one using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools powerset recipe</a> which is in practice faster (thanks to umutto)</p>
<pre class="lang-py prettyprint-override"><code>def powersequence(val):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
</code></pre>
<p>So the algorithm is:</p>
<ol>
<li>Build single list of all simple weights (join of your <code>ts</code>, <code>fs</code>, ...)</li>
<li>Use <code>powersequence</code> to generate powerset</li>
<li>Sum all items in each sub-set</li>
<li>Push results to set to filter for uniqueness </li>
</ol>
<pre class="lang-py prettyprint-override"><code>def all_weights(ws):
    simpleWeights = [0] # add 0 just one time
    for (w, c) in ws:
        simpleWeights = simpleWeights + [w] * c
    allWeights = (sum(subset) for subset in powersequence(simpleWeights))
    return set(allWeights)  # filter uniqueness


all = all_weights([(1, 1), (5, 1), (10, 1), (20, 1), (50, 1), (70, 1), (90, 1)])
for w in all:
    print(w)
</code></pre>
<p>Note that uniqueness condition forces materialization of whole collection into memory so might be a limiting factor of the size of the problem this code can solve.</p>
<p><strong>Update</strong></p>
<p>Actually jez is right: doing product of lists by coins will be significantly faster then iterating through <code>powersequence</code> of joined lists </p>
<pre class="lang-py prettyprint-override"><code>def all_weights(ws):
    simpleWeights = []
    for (w, c) in ws:
        simpleWeights.append(list((i * w for i in range(0, c + 1))))

    allWeights = (sum(subset) for subset in itertools.product(*simpleWeights)) # note "*" before simpleWeights!
    return set(allWeights)  # filter uniqueness
</code></pre>
</div>
<span class="comment-copy">You use words like "rack" and "plates" when talking about your code and yet they appear nowhere in your code. It is therefore very hard to understand whatever you are talking about.</span>
<span class="comment-copy">You could shorten and probably optimize the powersequence function by using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools powerset recipe</a> (chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))</span>
<span class="comment-copy">@umutto, Yes, this is shorter, but I doubt that this is actually an optimization. I think generation of all subsets in their natural numbering order migth be faster than generating them in order of increasing size using <code>combinations</code> inside.</span>
<span class="comment-copy">@umutto, I did some tests and to my suprise itertools-based implementation is much faster (like an order of magnitude faster). Now I think this should mainly be because itertools are implemented in C. Thanks anyway for pointing this out.</span>
<span class="comment-copy">@SerGr yeah I was benchmarking them now, glad it was helpful.</span>
