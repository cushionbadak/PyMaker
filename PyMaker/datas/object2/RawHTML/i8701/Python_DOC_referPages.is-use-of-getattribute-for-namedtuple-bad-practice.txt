<div class="post-text" itemprop="text">
<p>I am exploring the  possibility of replacing very large numbers of small dictionaries with namedtuples instead.</p>
<p>Because dict keys (strings) have been mapped onto the field names of the namedtuples, I have to make use of the dundered getattribute method of the namedtuple to access the values.</p>
<p>This not only makes the code look kind of odd but I wonder also whether this is bad practice?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Because dict keys (strings) have been mapped onto the field names of the namedtuples, I have to make use of the dundered getattribute method of the namedtuple to access the values.</p>
</blockquote>
<p>That's the wrong tool. You should be using the <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr</code></a> built-in function, not the <code>__getattribute__</code> method:</p>
<pre><code>getattr(your_namedtuple, attribute_name)
</code></pre>
<p>That said, if you want to primarily access your data by name instead of index, calling <code>getattr</code> all the time is going to be awkward. You could subclass your <code>namedtuple</code> class and change how <code>__getitem__</code> works so you can still use indexing notation:</p>
<pre><code>class MyType(namedtuple(...)):
    __slots__ = () # avoid creating instance __dict__s
    def __getitem__(self, index):
        try:
            return super().__getitem__(index)
        except TypeError:
            return getattr(self, index)
</code></pre>
</div>
<span class="comment-copy">Almost certainly, it is <i>not</i> the right thing to do. I still don't understand why you <i>have</i> to use it. Can you show an example?</span>
<span class="comment-copy">why are you looking to replace dictionaries?</span>
<span class="comment-copy">@bobah it's often the case that when you have a bunch of dictionaries acting as a record, you really just want a <code>namedtuple</code>. It uses less memory and is faster, because it uses random-access without any hashing. Of course, whether this is the right way to go depends on the details.</span>
