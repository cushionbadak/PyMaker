<div class="post-text" itemprop="text">
<p>Here's a simple code in python. </p>
<pre><code>end = np.zeros((11,2))
alpha=0
while(alpha&lt;=1):
    end[int(10*alpha)] = alpha
    print(end[int(10*alpha)])
    alpha+=0.1
print('')
print(end)
</code></pre>
<p>and output:</p>
<pre><code>[ 0.  0.]
[ 0.1  0.1]
[ 0.2  0.2]
[ 0.3  0.3]
[ 0.4  0.4]
[ 0.5  0.5]
[ 0.6  0.6]
[ 0.7  0.7]
[ 0.8  0.8]
[ 0.9  0.9]
[ 1.  1.]

[[ 0.   0. ]
 [ 0.1  0.1]
 [ 0.2  0.2]
 [ 0.3  0.3]
 [ 0.4  0.4]
 [ 0.5  0.5]
 [ 0.6  0.6]
 [ 0.8  0.8]
 [ 0.   0. ]
 [ 1.   1. ]
 [ 0.   0. ]]
</code></pre>
<p>â€‹
It is easy to notice that 0.7 is missing and after 0.8 goes 0 instead of 0.9 etc... Why are these outputs differ?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's because of floating point errors. Run this:</p>
<pre><code>import numpy as np

end = np.zeros((11, 2))
alpha=0
while(alpha&lt;=1):
    print("alpha is ", alpha)
    end[int(10*alpha)] = alpha
    print(end[int(10*alpha)])
    alpha+=0.1
print('')
print(end)
</code></pre>
<p>and you will see that alpha is, successively:</p>
<pre><code>alpha is  0
alpha is  0.1
alpha is  0.2
alpha is  0.30000000000000004
alpha is  0.4
alpha is  0.5
alpha is  0.6
alpha is  0.7
alpha is  0.7999999999999999
alpha is  0.8999999999999999
alpha is  0.9999999999999999
</code></pre>
<p>Basically floating point numbers like 0.1 are stored <em>inexactly</em> on your computer. If you add 0.1 together say 8 times, you won't necessarily get 0.8 -- the small errors can accumulate and give you a different number, in this case 0.7999999999999999. Numpy arrays must take integers as indexes however, so it uses the <code>int</code> function to force this to round down to the nearest integer -- 7 -- which causes that row to be overwritten.</p>
<p>To solve this, you must rewrite your code so that you only ever use integers to index into an array. One slightly crude way would be to round the float to the nearest integer using the <code>round</code> function. But really you should rewrite your code so that it iterates over integers and coverts them into floats, rather than iterating over floats and converting them into integers.</p>
<p>You can read more about floating point numbers here:</p>
<p><a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/floatingpoint.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As @Denziloe pointed, this is due to floating point  errors.</p>
<p>If you look at the <a href="https://docs.python.org/2/library/functions.html#int" rel="nofollow noreferrer">definition</a> of <code>int()</code>: </p>
<pre><code>If x is floating point, the conversion truncates towards zero
</code></pre>
<p>To solve your problem use <code>round()</code> instead of <code>int()</code></p>
</div>
<span class="comment-copy">Yes, you can try <code>int(10*(0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1))</code> and it will give 7 instead of 8. Use <code>round()</code> instead of <code>int()</code> to solve the problem.</span>
<span class="comment-copy">Thanks, I have incorporated that into my answer.</span>
