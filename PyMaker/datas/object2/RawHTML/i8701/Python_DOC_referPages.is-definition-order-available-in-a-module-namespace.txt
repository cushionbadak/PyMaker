<div class="post-text" itemprop="text">
<p>It's documented that the <a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="nofollow noreferrer">definition order in classes is preserved</a> (see also <a href="https://www.python.org/dev/peps/pep-0520/" rel="nofollow noreferrer">PEP 520</a>):</p>
<blockquote>
<p>If the metaclass has no <code>__prepare__</code> attribute, then the class namespace is initialised as an empty ordered mapping.</p>
</blockquote>
<p>Is the definition order also preserved in module objects?  </p>
<pre><code># foo_bar.py

def foo():
    pass

def bar():
    pass
</code></pre>
<p>I've experimented with the module above (also swapping the ordering), and it did seem to be reliable:</p>
<pre><code>&gt;&gt;&gt; import foo_bar
&gt;&gt;&gt; for name in foo_bar.__dict__:
...     if not name.startswith('_'):
...         print(name)
... 
foo
bar
</code></pre>
<p>Presumably, the module namespace also uses a compact dict underneath, or perhaps it follows from the fact that the <code>type(foo_bar)</code> is a <code>&lt;class 'module'&gt;</code> that it must also respect definition order, like any other class.  However, I'm not sure if this is a feature guaranteed by Python, or just a CPython implementation detail.  <strong>Are the names in modules required to respect definition ordering?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Built-in classes, like the <code>module</code> class, don't go through the normal mechanism user-defined classes do<sup>*</sup> and, as such, don't make use of <code>metaclass.__prepare__</code>. <code>PEP 520</code> does not apply for them so the guarantees it extends cannot be applied here.</p>
<p>The ordering of the module namespace is currently preserved due to the dictionary being insertion ordered so, like the dictionary itself, is considered an implementation detail. </p>
<hr/>
<p><sup>*</sup> User defined classes first go through <code>build_class</code> (the function the <code>LOAD_BUILD_CLASS</code> bytecode loads when you <code>dis</code> a class statement) in <code>bltinmodule.c</code>. This is the only place where <a href="https://github.com/python/cpython/blob/c2cf12857187aa147c268651f10acd6da2c9cb74/Python/bltinmodule.c#L136" rel="nofollow noreferrer"><code>__prepare__</code> is invoked</a> (which <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L3195" rel="nofollow noreferrer">returns a <code>PyDict_New</code></a> from <code>type_prepare</code> if a custom meta with a <code>__prepare__</code> isn't defined).</p>
</div>
<span class="comment-copy">As far as I know, it's an implementation detail. It might be made an explicit guarantee later, or just an implicit one from the combination of how module-level name definition is specified and how dict order is specified once dict order is actually part of the spec.</span>
<span class="comment-copy">Note that <code>foo_bar</code> is not a class. You seem to have gotten mixed up by how <code>type(foo_bar)</code> has <code>class</code> in the output. The <code>class</code> in the output just means that <code>type(foo_bar)</code> is a class; it doesn't mean <code>foo_bar</code> itself is one.</span>
<span class="comment-copy">No, my suggestion is like this:  Class -&gt; instance=Class() -&gt; instance attributes respect ordering because the namespace uses compact dict.  ModuleType -&gt; module=ModuleType() -&gt; module attributes respect ordering (?) because namespace uses compact dict (?).</span>
<span class="comment-copy">i.e. A module is "just" an instance of the <code>ModuleType</code> class.</span>
<span class="comment-copy">The ordering guarantees haven't been extended to all instances of all classes whose instances have a <code>__dict__</code> yet. That's still an implementation detail.</span>
<span class="comment-copy">What type of storage backend does a module namespace use and where is it created?  I have heard it said somewhere that it's a special kind of dict optimized for string keys, but when I checked it in the REPL it seems just to be a normal dict and I was able to setitem with non-string keys no problem.</span>
<span class="comment-copy">I'm pretty sure it's created in the belly of the import mechanism but I'll have to look into that and get back at you @wim. The special kind of dict you're talking about might be <a href="http://stackoverflow.com/questions/42419011/why-is-the-dict-of-instances-so-small-in-python-3">the key-sharing one that exists for instances</a> but I don't really know if it is also used for modules.</span>
