<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/8297723/oop-getter-setter-methods">OOP: getter/setter methods [duplicate]</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>If I have a python class that looks like this: </p>
<pre><code>class MyClass(object):

    def __init__(self, path):
        self.path = path
</code></pre>
<p>I know I can change the path attribute in an instance of the object like this: </p>
<pre><code>my_example = MyClass("home/data")
my_example.path = "home/other_data"
</code></pre>
<p>However, I have seen some code where people use functions to set attributes like this: </p>
<pre><code>class MyClass(object):

    def __init__(self, path):
        self.path = path

    def setPath(self, path):
        self.path = path
</code></pre>
<p>If I want the user of an instance of the class to be able to change an attribute, it is best practice to have a function for this like in the second example, or to just let them change it manually like the first example?</p>
</div>
<div class="post-text" itemprop="text">
<p>This depends on the modularity you need in the application.  For overall systems design, it's better to make the user access all of the class attributes through class methods.  This adds a lot of bloat: get/set methods for each attribute, with further methods for actual manipulation.</p>
<p>In practical terms, you need to decide how much you can trust your user.  Python tends to code more directly: let the user make mistakes directly.  It's less code for you, and easier for most users.</p>
<p>However, consider the volatility of your design.  Do you need to hide the class representation from the user?  Do you need to change it once in a while?  These are excellent reasons to place the internal representation behind the shield of a simple, unchanging interface: that way, you can change the internals without breaking all of your users' implementations.</p>
</div>
<span class="comment-copy">If you're working with an attribute, just let the user work with the attribute (first example).  See <a href="https://docs.quantifiedcode.com/python-anti-patterns/correctness/implementing_java-style_getters_and_setters.html" rel="nofollow noreferrer">docs.quantifiedcode.com/python-anti-patterns/correctness/â€¦</a> for example. Note that the <code>@property</code> stuff might be a little confusing -- one use-case for <code>@property</code> is so you can change from using an attribute to function-based getters and setters without destroying your public API.</span>
<span class="comment-copy">If you want to control the getting/setting (for proxying, calculated attributes or validating new values) of the attribute than you can use a <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property</a> - otherwise you generally allow attributes to be modified as per your first example,</span>
<span class="comment-copy">yes, in Python, unlike Java, no need to create getters / setters, except for properties, to read / update attributes starting with _ (nothing private in python, but kinda understood like private by IDEs and developers). But it's common to have methods setting attributes, post init.</span>
<span class="comment-copy">I see now that the python code I saw that had setters/getters was written by a java developer! Will use pythonic way without them</span>
