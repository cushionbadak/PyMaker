<div class="post-text" itemprop="text">
<p>I have a dictionary with keys in it but no values:</p>
<pre><code>&gt; {'GROUP': '?', 'THREAD': '?', 'SEQUENCE': '?', 'BYTES': '?', 'BLOCKSIZE': '?'}
</code></pre>
<p>I do also have a loop which returns lists of values:</p>
<pre><code>for row in rng:
    result = [d[row] for d in inp]
    print(result)
&gt; ['1', '2', '3']
&gt; ['1', '1', '1']
&gt; ['346', '347', '348']
&gt; ['52428800', '52428800', '52428800']
&gt; ['512', '512', '512']
</code></pre>
<p>How could I assign the db.keys to db.values, so the output looks like this:</p>
<pre><code>{'GROUP': ['1', '2', '3'], THREAD': ['1', '1', '1'], 'SEQUENCE': ['1', '1', '1'], 'BYTES': ['52428800', '52428800', '52428800'], etc.}
</code></pre>
<p>Should I do values assignment in the loop directly?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since dictionaries are unordered (the keys you've defined are in random order, regardless of which order you define them in), there's no way to know which result list you want to assign to which key.</p>
<p>What I would do instead is create a list or a tuple of the keys to keep the order:</p>
<pre><code>keys = ('GROUP', 'THREAD', 'SEQUENCE', 'BYTES', 'BLOCKSIZE')
</code></pre>
<p>Then fetch all the values into another list (or better yet, a generator):</p>
<pre><code>values = ([d[row] for d in inp] for row in rng)
</code></pre>
<p>So now you have two iterables in the same order, one with keys and one with corresponding values. Here's what they'd look like as lists (<code>values</code> is a generator so we can't really print the values):</p>
<pre><code>&gt;&gt;&gt; print(keys)
['GROUP', 'THREAD', 'SEQUENCE', 'BYTES', 'BLOCKSIZE']
&gt;&gt;&gt; print(values)
[['1', '2', '3'], ['1', '1', '1'], ['346', '347', '348'], ['52428800', '52428800', '52428800'], ['512', '512', '512']]
</code></pre>
<p>Now it's easy to construct the final result dictionary with the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> function:</p>
<pre><code>data = dict(zip(keys, values))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the order of keys you want assign to is fixed, then build an iterator that spits out the keynames in whatever order you want.</p>
<pre><code>keynames = iter(['GROUP', 'THREAD', 'SEQUENCE', 'BYTES', ...])

for row in rng:
    # your code
    ...

    # new code
    key = next(keynames)
    d[key] = result
</code></pre>
<p>If you want to assign to the key <code>row</code> in each iteration, just do it:</p>
<pre><code>for row in rng:
    # your code
    ...

    # new code
    d[row] = result
</code></pre>
<p>(Assuming <code>d</code> is your dictionary you want to assign to, change as needed.)</p>
</div>
<div class="post-text" itemprop="text">
<p>To follow with the input structure you've shared in question, 
you can use dict comprehension.
That is,</p>
<pre><code>{k:result[index] for index, k in enumerate(yourdict.keys())}
</code></pre>
<p>yourdict is the dictionary that you've  given in your question.</p>
<p>Another solution is by following Markus answer. </p>
<pre><code>dict(zip(yourdict.keys(),result)
</code></pre>
<p>Hope this helps!</p>
</div>
<span class="comment-copy">Dictionaries are unordered, so you would need to impose some particular order on your dictionary before you could assign these values.</span>
<span class="comment-copy">Question is underspecified. Do you have a fixed order the results should be assigned, or do you want to assign to the key <code>row</code> in each iteration of the loop?</span>
<span class="comment-copy">Great! many thanks</span>
