<div class="post-text" itemprop="text">
<p>I am creating a number of slices <code>[-WINDOW-i:-i]</code> of a list, where <code>i</code> ranges between <code>32</code> and <code>0</code>:</p>
<pre><code>vals = []

for i in range(32, -1, -1):
    vals.append(other_list[-WINDOW-i:-i])
</code></pre>
<p>When <code>i == 0</code>, this returns a slice of length 0:</p>
<pre><code>other_list[-WINDOW-0:0]
</code></pre>
<p>I don't want to have to do this to solve it:</p>
<pre><code>vals = []

for i in range(32, -1, -1):
    if i == 0:
       vals.append(other_list[-WINDOW:])
    else:
       vals.append(other_list[-WINDOW-i:-i])
</code></pre>
<p>… because if I have many lists to append to <code>vals</code>, it gets messy.</p>
<p>Is there a clean way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>One workaround for this quirk in Python slicing is to take advantage of these facts:</p>
<ol>
<li><code>false_ish_value or other_value</code> always evaluates to <code>other_value</code></li>
<li><code>0</code> is the only integer that is <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noreferrer">false-ish</a> in a boolean context</li>
<li><code>s[n:None]</code> is equivalent to <code>s[n:]</code></li>
</ol>
<p>With those in mind, you can write your slice as:</p>
<pre><code>other_list[-WINDOW-i:(-i or None)]
</code></pre>
<p>… and the slice will be interpreted as <code>[-WINDOW-i:None]</code> (which is the same as <code>[-WINDOW-i:]</code>) only when <code>i</code> (and therefore <code>-i</code>) is <code>0</code>.</p>
</div>
<span class="comment-copy">can you add your input and expected output.</span>
