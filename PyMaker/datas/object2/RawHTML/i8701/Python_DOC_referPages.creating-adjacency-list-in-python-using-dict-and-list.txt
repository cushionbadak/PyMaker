<div class="post-text" itemprop="text">
<p>I wanted to create a data structure that can store the name of a vertex, vertices it is adjacent to along with the edge weight. I thought of creating a <code>dict</code> that maps a vertex to a <code>list</code> that further has <code>dict</code> to store vertices it is adjacent to with edge weight. </p>
<p>In other words:</p>
<pre><code>D = {
    vertex1: [
        {
            Adj_vertex1: edge weight
        }, 
        {
            Adj_vertex2:    edge weight
        } 
    ]
}
</code></pre>
<p>Is there an effective way to do this? Also, if I use the structure above how do I access <code>Adj_vertex2</code>? </p>
</div>
<div class="post-text" itemprop="text">
<p>Dictionary works fine unless you have more complex structure. But you are declaring a list of dictionaries for your vertices. You can simplify it like this;</p>
<pre><code>D = { vertex1: {Adj_vertex1: edge_weight, Adj_vertex2: edge_weight}}
</code></pre>
<p>And get adj_vertex2 weight like this;</p>
<pre><code>D[vertex1][Adj_vertex2]
</code></pre>
<p>Or if you want to get a default value if a vertex is not adjacent to another, thus not exists in the dictionary you can use this (thanks to Hossein's comment):</p>
<pre><code>D[vertex1].get(Adj_vertex2, 0)
</code></pre>
<p>And add a new vertex like this;</p>
<pre><code>D[new_vertex] = {Adj_vertex1: edge_weight, Adj_vertex2: edge_weight}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>d = {'vertex1': [ {'adj_vertex1': (edge, weight)}, {'adj_vertex2': (edge, weight)}]}
</code></pre>
<p>To access <code>adj_vertex2</code> you must do <code>d['vertex1'][1]['adj_vertex2']</code></p>
<p>This is not a very good way to work with graphs in python in my opinion. You should check some libraries out like <a href="https://pypi.python.org/pypi/python-graph" rel="nofollow noreferrer">python-graph</a> or you could use <a href="https://docs.python.org/2/library/sets.html" rel="nofollow noreferrer">sets</a>, sets are a good way to use graphs with python as far as I remember.</p>
<p>Note: <code>(this, is, a, tuple)</code>. On <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow noreferrer">tuples</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One efficient way that uses relatively standard tools would be to store adjacency as a sparse matrix. This would require you to use <code>scipy</code> and to number your vertices.</p>
<p>Assume you have the connected vertices as list of lists and the weights as another list of lists of the same structure</p>
<pre><code>inds = [[1,3], [], [0,2], [0,2,3]]
weights = [[0.1,0.2], [], [1,1], [2,0.5,-0.1]]

adj = sparse.lil_matrix((4,4))
for i, (j, w) in enumerate(zip(inds, weights)):
    adj[i, j] = w

adj
# &lt;4x4 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
        with 7 stored elements in LInked List format&gt;
adj.A # dense representation
# array([[ 0. ,  0.1,  0. ,  0.2],
         [ 0. ,  0. ,  0. ,  0. ],
         [ 1. ,  0. ,  1. ,  0. ],
         [ 2. ,  0. ,  0.5, -0.1]])

adj = adj.tocsr() # convert to more efficient format

# get vertices connected to vertex 3:
adj[3].nonzero()[1]
# array([0, 2, 3], dtype=int32)

# get corresponding weights:
adj[3].data
# array([ 2. ,  0.5, -0.1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a list of tuples to store the adjacencies and the weights makes more sense to me rather than storing it as dict. You can store it something like this,</p>
<pre><code>    d = {
         'v1': [ ('v2',w1), ('v3', w2) ]
         'v2': [ ('v1', w1) ]
         'v3': [ ('v1', w2) ]
        }
</code></pre>
</div>
<span class="comment-copy">Why have a list of dicts and not just a dict : <code>D = {vertex1: {Adj_vertex1: weight, Adj_vertex2: weight}}</code> then access is as simple as <code>D[vertex1][Adj_vertex2]</code> but is more likely to be used in a loop <code>for a_v, w in D[vertex1].items():</code></span>
<span class="comment-copy">I could do that but is that the most effective I can be? Also, how do I extract weight of vertex2? by writing: D[vertex][vertex2]? I needed this data structure to first: access the vertices adjacent to vertex1, and second: to access the edge weight.</span>
<span class="comment-copy">Use <code>D[vertex1].get(vertex2,0)</code> to obtain <code>weight=0</code> if <code>vertex2</code> is not adjacent to <code>vertex1</code></span>
<span class="comment-copy">yeah that's a good thing to add, thanks I'll edit my answer.</span>
<span class="comment-copy">Thank you! But is this the effective method? The idea I had was just something that came to me first. I wanted to learn the effective way of creating something that can hold adjacent vertex and weight.</span>
<span class="comment-copy">@BinamrataSharma I'm sure there are better ways (for readability and functionality) to represent this problem, dictionaries work in this case but for more check LaraChicharo's answer.</span>
<span class="comment-copy">Notice that I changed the name of the variables in your code, thats because they were not in line with pep-8 (<a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">python.org/dev/peps/pep-0008</a>)</span>
<span class="comment-copy">What if I have to change the value of edge weight a I go along? Doesn't tuple refrain me from changing the value inside it?</span>
