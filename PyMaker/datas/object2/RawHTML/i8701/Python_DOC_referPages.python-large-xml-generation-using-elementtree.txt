<div class="post-text" itemprop="text">
<p>I just started to look at using python for XML generation from a csv. I am trying to use ElementTree to do this. But, I am unable to get my desired format.</p>
<p><a href="https://www.dropbox.com/s/bq2mj5sft64l333/trip.csv?dl=0" rel="nofollow noreferrer">Here</a> is the sample csv data I am using. The original data has about 12 million rows and the full xml resulting from it would have about 38 million rows. Below is my code.</p>
<pre><code>import csv
import sys
from xml.etree.ElementTree import Element, SubElement, Comment, ElementTree, tostring
from xml.etree import ElementTree
from xml.dom import minidom

def prettify(elem):
    rough_string = tostring(elem, 'utf-8', method="xml")
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")

root = Element('plans')
sys.stdout = open('C:/Users/s/Desktop/xml6.xml', 'w')
print(prettify(root))

with open('C:/Users/s/Desktop/trip2.csv', 'rt') as f:
    current_group = None
    reader = csv.reader(f)
    for row in reader:
            personid, hno, pno, OXutmmtr, OYutmmtr, DXutmmtr, DYutmmtr, opcl, dpcl, depday, deptm, arrtm, newendacttma, dept, arr, newendacttmh, mode2, opurp2, dpurp2, dorp2 = row
            if current_group is None or personid != old1 :
            # Start a new group
             current_group = SubElement(root, 'person', {'id':personid})
             old1 = personid
             pln = SubElement(current_group, 'plan')
             activ = SubElement(pln, 'act', {'type':opurp2, 'x':OXutmmtr, 'y':OYutmmtr,})
             trvl = SubElement(pln, 'leg', {'mode': mode2,})
             activ = SubElement(pln, 'act',{'type': dpurp2, 'x': DXutmmtr, 'y': DYutmmtr,})

            elif personid == old1:
             trvl = SubElement(pln, 'leg', {'mode': mode2,})
             activ = SubElement(pln, 'act', {'type': dpurp2, 'x': DXutmmtr,'y': DYutmmtr,})
                if newendacttmh == "02:59:00":
                sys.stdout = open('C:/Users/s/Desktop/xml6.xml', 'a')
                print(prettify(current_group))
                root.clear()
</code></pre>
<p>I need a format like </p>
<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;plans&gt;


&lt;person id="101"&gt;
  &lt;plan&gt;
    &lt;act type="home" x="338471.624256" y="3114225.84531"/&gt;
    &lt;leg mode="sov"/&gt;
    &lt;act type="work" x="353108.46905" y="3086263.42028"/&gt;
    &lt;leg mode="sov"/&gt;
    &lt;act type="home" x="338471.624256" y="3114225.84531"/&gt;
  &lt;/plan&gt;
&lt;/person&gt;


&lt;person id="201"&gt;
  &lt;plan&gt;
    &lt;act type="home" x="338535.623855" y="3114558.14898"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="meal" x="338520.432083" y="3105225.60283"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="shop" x="333193.19769" y="3103842.61842"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="pers.bus" x="338148.26292" y="3083556.85073"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="home" x="338535.623855" y="3114558.14898"/&gt;
  &lt;/plan&gt;
&lt;/person&gt;

&lt;/plans&gt;
</code></pre>
<p>but am getting the format like</p>
<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;plans/&gt;

&lt;?xml version="1.0" ?&gt;
&lt;person id="101"&gt;
  &lt;plan&gt;
    &lt;act type="home" x="338471.624256" y="3114225.84531"/&gt;
    &lt;leg mode="sov"/&gt;
    &lt;act type="work" x="353108.46905" y="3086263.42028"/&gt;
    &lt;leg mode="sov"/&gt;
    &lt;act type="home" x="338471.624256" y="3114225.84531"/&gt;
  &lt;/plan&gt;
&lt;/person&gt;

&lt;?xml version="1.0" ?&gt;
&lt;person id="201"&gt;
  &lt;plan&gt;
    &lt;act type="home" x="338535.623855" y="3114558.14898"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="meal" x="338520.432083" y="3105225.60283"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="shop" x="333193.19769" y="3103842.61842"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="pers.bus" x="338148.26292" y="3083556.85073"/&gt;
    &lt;leg mode="hov3+"/&gt;
    &lt;act type="home" x="338535.623855" y="3114558.14898"/&gt;
  &lt;/plan&gt;
&lt;/person&gt;
</code></pre>
<p>Essentially, I am trying to append to the file when I reach the end of each person's record (indicated by the time string 02:59:00) because if I wait till the entire root tree is constructed then I am running into the memory error problem. Interestingly, the memory usage never goes above 2 gb and the program fails with the memory error issue even when there is still 12 gb of ram left. I have tried to follow the advice <a href="https://pymotw.com/2/xml/etree/ElementTree/create.html" rel="nofollow noreferrer">here</a> about serializing xml-stream using <code>ElementTree(top).write(sys.stdout)</code> but am unable to operationalize it. I know (kind of) that SAX parsers are better suited for large xml creation. But, I am a bit daunted by it at the moment. Any suggestions or advice will be useful for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>You've got the right idea, but I think you need to tweek your tools. XML DOM documents like ElementTree aren't intended to be written iteratively. When you did <code>print(prettify(root))</code>, you wrote the entire tree that existed at that point, which was just <code>&lt;plans/&gt;</code>. Instead, you can manually write the xml declaration and an open tag, then you can use a DOM to generate and write each <code>&lt;plan&gt;</code> as a separate document.</p>
<p><code>minidom</code> includes the xml declaration for each tree you write into the document, so you need to switch to a different tool. <code>lxml</code> has a pretty print that works well. You want to write xml to a binary file because the DOM will handle any encoding. I found the <code>sys.stdout</code> needlessly problematic and just write the file directly.</p>
<p>You didn't have the csv file mode quite right for python3, so I changed that while I was here.</p>
<p>I also fiddled with how you create each  which I think is a bit more clear.</p>
<pre><code>import csv
import sys
from lxml.etree import Element, SubElement, Comment, ElementTree

# note: I changed file paths for test

with open('xml6.xml', 'wb') as outxml:
    # write xml declaration and containing &lt;plans&gt; tag
    outxml.write(b"""&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;
&lt;plans&gt;
""")
    # process csv
    with open('trip.csv', 'r', newline='') as f:
        old1 = ''
        current_group = None
        reader = csv.reader(f)
        for row in reader:
            personid, hno, pno, OXutmmtr, OYutmmtr, DXutmmtr, DYutmmtr, opcl, dpcl, depday, deptm, arrtm, newendacttma, dept, arr, newendacttmh, mode2, opurp2, dpurp2, dorp2 = row
            if personid != old1 :
                # skip on first loop then write current group to file
                if old1:
                    outxml.write(b"\n")
                    ElementTree(current_group).write(outxml, encoding='utf-8',  method='xml',  pretty_print=True)
                # Start a new group
                current_group = Element('person', {'id':personid})
                old1 = personid
                pln = SubElement(current_group, 'plan')
                activ = SubElement(pln, 'act', {'type':opurp2, 'x':OXutmmtr, 'y':OYutmmtr,})
            # write data
            trvl = SubElement(pln, 'leg', {'mode': mode2,})
            activ = SubElement(pln, 'act',{'type': dpurp2, 'x': DXutmmtr, 'y': DYutmmtr,})

    # terminate outer tag and done
    outxml.write(b"""
&lt;/plans&gt;
""")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>.toprettyxml</code> prints what you give it as an XML <em>document</em>, so it includes the XML preamble.  You are printing a separate document for each "plan".  The first time, you print the empty <code>plans</code> node, so you get <code>&lt;plans/&gt;</code>.  On each iteration through the loop, you clear out the root, add one element to it, and then output the entire root.  So yes, you're outputting the <code>plans</code> element, in its entirety, repeatedly.  And each time it only has one <code>plan</code> in it.  When you use things like <code>tostring</code> and <code>toprettyxml</code>, you're outputting the entire element, not just the opening tag.</p>
<p>As you've surmised, you should look at using a SAX approach.  As the name of the <code>minidom</code> library suggests, it is a DOM library.  As <a href="https://docs.python.org/3.1/library/xml.etree.elementtree.html" rel="nofollow noreferrer">the docs</a> for ElementTree say, it is "designed to store hierarchical data structures in memory."  If you don't want to store your data structure in memory all at once, it may not be the best choice.  (It has some facilities for incremental <em>reading</em>, but not writing.)  You could take a look at the <a href="https://docs.python.org/3/library/xml.sax.html" rel="nofollow noreferrer">xml.sax</a> library.  But you should explore such solutions and ask a more specific question about how to use SAX if and when you have one.</p>
</div>
<span class="comment-copy">I don't see any difference between your two XML examples.  Are you just talking about the difference in whitespace?</span>
<span class="comment-copy">In the first (and correct ) version all the <code>person</code> elements are within the <code>plans</code> element. In the second version, the <code>plans</code> element starts and ends in the second line and the <code>person</code> elements are independent of <code>plans</code>. Additionally, in the second version xml preamble <code>&lt;?xml version="1.0" ?&gt;</code> repeats for every <code>person</code> element.</span>
<span class="comment-copy">Why are you doing things in that odd way, using <code>tostring</code> to output the XML, then just reading it back again with minidom?</span>
<span class="comment-copy">Supposedly, element tree doesn't indent the xml output. So, the prettify function does this. But more importantly, I am a complete novice with python and am repurposing the code I got from <a href="https://pymotw.com/2/xml/etree/ElementTree/create.html" rel="nofollow noreferrer">here</a> and so do not have a complete idea about this code.</span>
<span class="comment-copy">Thanks for taking the time to explain this and help me with a solution. I need to get a bit more thorough with python by learning it in a more structured way.</span>
