<div class="post-text" itemprop="text">
<p>I'm working on a trie data structure where each node is a list with entries containing a value and a reference to the child node corresponding to that value, but it appears that the references in the list are not being separated from each other-
So for example if "the" and "sin" are both in the trie my CONTAINS() function will return true for "she" because 's' is on the first level, 'h' is on the second level, and 'e' is on the third level even though those characters should be in different branches. I've read about python references and can't figure out why this is happening.</p>
<pre><code>class triepair:
    value = None
    next = None

    def __init__(self, value=None, next=None):
        self.value = value
        self.next = next

    def NEXT(self,next):
        self.next = next

    def GETNEXT(self):
        return self.next

class trienode:
    nodespace = []

    def __int__(self,nodespace=[]):
        self.nodespace = nodespace

    def APPEND(self,value):
        newnext = trienode()
        newpair = triepair(value,newnext)
        self.nodespace.append(newpair)

    def NEXT(self, value):
        for triepair in self.nodespace:
            if triepair.value == value:
                return triepair.GETNEXT()

        print("ERROR: value not found")
        return None

    def CONTAINS(self, value):
        for triepair in self.nodespace:
            if triepair.value == value:
                return True

        return False

    def INSERT(self, word):
        c = word[:1]
        rest = word[1:]

        if self.CONTAINS(c):
            if len(rest) &gt; 0:
                nextnode = self.NEXT(c)
                nextnode.INSERT(rest)

        else:
            self.APPEND(c)
            if len(rest) &gt; 0:
                nextnode = self.NEXT(c)
                nextnode.INSERT(rest)


    def TRACE(self, word):
        c = word[:1]
        rest = word[1:]
        if self.CONTAINS(c):
            print "found character ",c
            if self.NEXT(c) is not None and len(rest) &gt; 0:
                self.NEXT(c).TRACE(rest)
            else:
                print "trace complete"

    def HASWORD(self, word):
        c = word[:1]
        rest = word[1:]

        if self.CONTAINS(c):
            #print str(self)," contains ",c
            if len(rest) &gt; 0:
                return self.NEXT(c).HASWORD(rest)
            else:
                return True

        else:
            return False

class trie:
    root = trienode()

    def __init__(self):
        self.root = trienode()

    def INSERT(self,word):
        self.root.INSERT(word)

    def TRACE(self,word):
        if self.root is not None:
            self.root.TRACE(word)
        else:
            print("null trie")

    def CONTAINS(self, word):
        return self.root.HASWORD(word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lol, this took me a while to debug, but I found it.</p>
<p>Change this:</p>
<pre><code>class trienode:
    nodespace = []

    def __int__(self,nodespace=[]):
        self.nodespace = nodespace
</code></pre>
<p>To this:</p>
<pre><code>class trienode:
    nodespace = []

    def __init__(self):
        self.nodespace = []
</code></pre>
<p>Firstly, <code>__int__</code> isn't a thing, but that's only part of the issue.</p>
<p>Without knowing the full Pythonic details of exactly <em>why</em>, the root <code>nodespace</code> was getting re-used.</p>
<p>So when you create a new one in <code>APPEND()</code>, it doesn't actually happen,  and you get the same <code>nodespace</code> in the new "child".</p>
<p>Resultingly, everything is flat. All of the <code>value -&gt; trienode</code> pairs are at the same level, and the trienode reference is always to the same thing.</p>
<p>Anyway, with the above change you ensure that you start with a new empty <code>nodespace</code>, and thus <code>APPEND()</code> and <code>.NEXT().CONTAINS()</code> etc., will work more like you'd expect them to.</p>
</div>
<span class="comment-copy">Any variables defined inside the class (outside of <b>init</b> or other methods) belong to the class and not to the instance. Are you sure you want to have a global <code>nodespace</code> and global <code>value</code> and <code>next</code> variables for these classes, and not instance properties?</span>
<span class="comment-copy">Why the SHOUTY method names? You should follow the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">data model</a>.</span>
<span class="comment-copy">Can you add lines that reproduce the problem, and clarify your expected output and actual output</span>
<span class="comment-copy">This fixed it, thank you so much!</span>
