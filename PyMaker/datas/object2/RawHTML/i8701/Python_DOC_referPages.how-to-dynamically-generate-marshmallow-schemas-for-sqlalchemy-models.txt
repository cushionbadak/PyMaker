<div class="post-text" itemprop="text">
<p>I'm creating a Flask API using SQLAlchemy models.
I don't want to define a schema for every model I have, I don't want to do this every time:</p>
<pre><code>class EntrySchema(ma.ModelSchema):
    class Meta:
        model = Entry
</code></pre>
<p>I would like each model to have a schema, so it can easily dump itself.
Creating a default Schema and setting the Schema.Meta.model didn't work:</p>
<pre><code>class Entry(db.Model):
    __tablename__ = 'entries'

    id = db.Column(db.Integer, primary_key=True)
    started_at = db.Column(db.DateTime)
    ended_at = db.Column(db.DateTime)
    description = db.Column(db.Text())

    def __init__(self, data):
        for key in data:
            setattr(self, key, data[key])

        self.Schema = Schema
        self.Schema.Meta.model = self.__class__

    def dump(self):
        schema = self.Schema()
        result = schema.dump(self)
        return result


class Schema(ma.ModelSchema):
    class Meta:
        pass
</code></pre>
<p>Why is a generic Schema with the model overwritten different than a Schema with the model declared?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could create a class decorator that adds the <code>Schema</code> to your models:</p>
<pre><code>def add_schema(cls):
    class Schema(ma.ModelSchema):
        class Meta:
            model = cls
    cls.Schema = Schema
    return cls
</code></pre>
<p>and then</p>
<pre><code>@add_schema
class Entry(db.Model):
    ...
</code></pre>
<p>The schema will be available as the class attribute <code>Entry.Schema</code>.</p>
<p>The reason your original attempt fails is that marshmallow <code>Schema</code> classes are constructed using a <a href="https://github.com/marshmallow-code/marshmallow/blob/dev/marshmallow/schema.py#L74" rel="noreferrer">custom metaclass</a>, which inspects the namespace created from executing the class body and <a href="https://github.com/marshmallow-code/marshmallow-sqlalchemy/blob/dev/marshmallow_sqlalchemy/schema.py#L86" rel="noreferrer">does its thing</a>. When you modify the already constructed class, it is too late.</p>
<p>If you're unfamiliar with metaclasses in Python, read about them in the <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="noreferrer">language reference</a>. They are a tool that allows for great things and great misuse.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://marshmallow-sqlalchemy.readthedocs.io/en/latest/recipes.html" rel="nofollow noreferrer">marshmallow recipes</a> prescribe a couple of alternative options for throwing common schema options into a base class. Here's a quick example straight from the docs:</p>
<pre><code># myproject/schemas.py

from marshmallow_sqlalchemy import ModelSchema

from .db import Session

class BaseSchema(ModelSchema):
    class Meta:
        sqla_session = Session
</code></pre>
<p>and then extend the base schema:</p>
<pre><code># myproject/users/schemas.py

from ..schemas import BaseSchema
from .models import User

class UserSchema(BaseSchema):

    # Inherit BaseSchema's options
    class Meta(BaseSchema.Meta):
        model = User
</code></pre>
<p>The advantage of this approach is that you can add more de/serialization to specific models </p>
<p>More examples and recipes on the linked docs</p>
</div>
