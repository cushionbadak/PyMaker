<div class="post-text" itemprop="text">
<p>How would I dedupe a list of dictionaries in Python if a specific key, value (i.e. key: <code>x['src_ip']</code>) are present more than once? </p>
<pre><code>x = [{"_serial": "0", "src_ip": "5.5.5.5"}, 
     {"_serial": "1", "src_ip": "5.5.5.5"},
     {"_serial": "2", "src_ip": "1.1.1.2"}, 
     {"_serial": "3", "src_ip": "1.2.6.4"}]
</code></pre>
<p>I basically would want to have the following list as the final result:</p>
<pre><code>x = [{"_serial": "0", "src_ip": "5.5.5.5"},
     {"_serial": "2", "src_ip": "1.1.1.2"},
     {"_serial": "3", "src_ip": "1.2.6.4"}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For this specific input and required output you can try this:</p>
<pre><code>x = [{"_serial": "0", "src_ip": "5.5.5.5"}, 
 {"_serial": "1", "src_ip": "5.5.5.5"},
 {"_serial": "2", "src_ip": "1.1.1.2"}, 
 {"_serial": "3", "src_ip": "1.2.6.4"}]

values = []
new_x = []

for d in x:
    if not d['src_ip'] in values:
        new_x.append(d)
        values.append(d['src_ip'])

print(new_x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby()</code></a> and <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next()</code></a> to achieve this:</p>
<pre><code>from itertools import groupby

result = [next(v) for k, v in groupby(x, lambda d: d["src_ip"])]
</code></pre>
<p><strong><code>result</code></strong>:</p>
<pre><code>[{'_serial': '0', 'src_ip': '5.5.5.5'},
 {'_serial': '2', 'src_ip': '1.1.1.2'},
 {'_serial': '3', 'src_ip': '1.2.6.4'}]
</code></pre>
<p>As is, this only works if your list is already sorted on <code>d["src_ip"]</code>. If not, sort it first:</p>
<pre><code>def key(d):
    return d["src_ip"]

result = [next(v) for k, v in groupby(sorted(x, key=key), key)]
</code></pre>
</div>
<span class="comment-copy">It looks like you want us to write some code for you. While many users are willing to produce code for a coder in distress, they usually only help when the poster has already tried to solve the problem on their own. A good way to demonstrate this effort is to include the code you've written so far (forming a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>), example input (if there is any), the expected output, and the output you actually get (output, tracebacks, etc.). The more detail you provide, the more answers you are likely to receive. Check the <a href="https://stackoverflow.com/tour">tour</a> and <a href="https://stackoverflow.com/questions/how-to-ask">How to Ask</a>.</span>
<span class="comment-copy">This is a reasonable approach if <code>x</code> isn't too large. However, because <code>not d['src_ip'] in keys</code> has to scan <code>keys</code> for each item in <code>x</code>, its performance is O(nÂ²), which might be too slow for a very large input. You could improve that to O(n log n) by using <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a> to maintain <code>keys</code> in sorted order, at the expense of a little extra complexity.</span>
<span class="comment-copy">Make <code>keys</code> a <code>set</code> and this will work well.</span>
<span class="comment-copy">Thanks @ZeroPiraeus for such a useful knowledge. I am new in development so logic building w.r.t complexity is in learning phase for me. I just wrote the above code to generate the required output. Btw I will keep this thing mind to answer more general in future. Thanks again.</span>
<span class="comment-copy">@tdelaney Yes, in this specific case that would also work. In the general case, the key would have to be hashable for a set to be usable.</span>
<span class="comment-copy">oops, I guess I scanned that a bit quickly!</span>
