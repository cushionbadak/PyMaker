<div class="post-text" itemprop="text">
<p>Suppose I want to generate a bunch of binary number generators given the success probabilities. One concern I have is about the random seed. The random seeds for f1, f2, f3 are their creation time, right? And the seeds are fixed for each function regardless of the random seed in the global namespace, right?</p>
<pre><code>def f(p):
    import random, time
    random.seed(time.time())
    def g():
        return 1 if random.random() &lt; p else 0
    return g

f1 = f(0.05)
f2 = f(0.65)
f3 = f(0.25)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You pass in a seed to the <em>global random object</em> each time you call <code>f()</code>, because all top-level functions in the <code>random</code> module feed into a singleton object. This means that by the time <code>f3</code> is created, the seeds set in <code>f2</code> and <code>f1</code> have been superseded, the seeds are <em>not</em> independent from the global random object. Importing <code>random</code> again for each <code>f()</code> call does not give you a new state, as really only binds names anew each time once the module object itself is loaded (only on the first import).</p>
<p>If you want to have a seeded random generator <em>per function</em>, you need to create individual <code>random.Random()</code> instances:</p>
<pre><code>import random
import time

def f(p):
    seeded_random = random.Random(time.time())
    def g():
        return 1 if seeded_random.random() &lt; p else 0
    return g
</code></pre>
<p>From the <a href="https://docs.python.org/3/library/random.html#random.Random" rel="nofollow noreferrer"><code>random</code> module documentation</a>:</p>
<blockquote>
<p>The functions supplied by this module are actually bound methods of a hidden instance of the <code>random.Random</code> class. You can instantiate your own instances of <code>Random</code> to get generators that donâ€™t share state.</p>
</blockquote>
</div>
<span class="comment-copy">There's only one <code>random</code> module and therefore only one seed. You'll have to create a <code>random.Random(seed)</code> object for each function.</span>
<span class="comment-copy">Seeding a bunch of random number generators with the same seed is not very random.</span>
<span class="comment-copy">@rici That's exactly my concern.</span>
<span class="comment-copy">@Rawing That's why I'm importing random in the decorator, not out of it. No help?</span>
<span class="comment-copy">But why do you feel the need to have multiple PRNG streams? All your generators can happily share a single PRNG, no?</span>
<span class="comment-copy">Are you saying f1, f2, f3 have the same random seed at the end? Suppose I only return random.random() in function g, then I would see the same values from f1, f2 and f3? A bit confused, please help make further clarification. Thanks.</span>
<span class="comment-copy">@Maxareo: no, you won't see the same values. But in your code, <code>f1</code>, <code>f2</code> and <code>f3</code> all use a single global <code>Random()</code> object. You tell that one object to use a new seed three times, which simply means you discard whatever state was set for the first two calls.</span>
<span class="comment-copy">@Maxareo: after that, <code>f1</code>, <code>f2</code> and <code>f3</code> produce random numbers from that one global <code>Random()</code> object seeded to the last call. That means they'll produce values in the same sequence as if you used one <code>random.Random()</code> object with the same seed as that last <code>random.seed()</code> call.</span>
<span class="comment-copy">@Maxareo: those numbers are still pseudorandom. If you took a <code>foo = random.Random(seed_foo)</code> object, then called <code>foo.random()</code> a number of times, the values that that produces can be re-created exactly by using the exact same seed again in a different <code>random.Random()</code> object. Your <code>f1</code>, <code>f2</code> and <code>f3</code> simply draw from that sequence together, they are not backed by independent <code>random.Random()</code> objects. Their state is connected.</span>
<span class="comment-copy">Thanks for the replies. These are indeed helpful. The part that is puzzling me is the modules are imported inside the function and how is the random seed related to the function g? When f1, f2 and f3 are created, they don't have their own random seed? Besides, I tried a little example importing the random module inside a toy function, run the toy function and called random.random() in the global namespace, but didn't work.</span>
