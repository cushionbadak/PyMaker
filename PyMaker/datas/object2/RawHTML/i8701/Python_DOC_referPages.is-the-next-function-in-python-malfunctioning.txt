<div class="post-text" itemprop="text">
<p>As indicated in the <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">documentation</a>, the default value is returned if the iterator is exhausted. However, in the following program, the g(x) function is not exhausted, and I hope that the error from f(x) would not be processed in the next function. </p>
<pre><code>def f(x) :
    if 0 :  # to make sure that nothing is generated
        yield 10

def g(x) :
    yield next(f(x))

# list(g(3))
next(g(3), None)
</code></pre>
<p>What I expect: </p>
<pre><code>Traceback (most recent call last):
  File "a.py", line 9, in &lt;module&gt;
    next(g(3), None)
  File "a.py", line 6, in g
    yield next(f(x))
StopIteration
</code></pre>
<p>What I encountered is that the program was running successfully. 
Can I use an alternating approach to achieve the goal? Or can it be fixed in Python? </p>
<p>Edit: The program mentioned above may be modified like this in order to prevent ambiguation. </p>
<pre><code>def f(x) :
    if 0 :  # to make sure that nothing is generated
        yield 10

def g(x) :
    f(x).__next__()  # g(x) is not exhausted at this time
    yield 'something meaningful'
        # I hope that the next function will only catch this line

# list(g(3))
next(g(3), None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>next</code> with a default parameter catches the <code>StopIteration</code> no matter the source.</p>
<p>The behavior you're seeing is expected, and maybe better understood using this code:</p>
<pre><code>def justraise():
    yield next(iter([])) # raises StopIteration

next(justraise(), None) # None
next(justraise()) # raises StopIteration
</code></pre>
<p>Moving to your code - even though the inner use is of <code>next</code> without a default argument, the <code>StopIteration</code> it raised is caught in the outer <code>next</code> with the default argument.</p>
<p>If you have a meaningful exception to raise, you should raise a meaningful exception and not <code>StopIteration</code> which indicates the iteration ended (and not erroneously) - which is what <code>next</code> relies on.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>g(x)</code> is an iterator that always yields <code>f(x)</code>, which yields Nothing, and raises a <code>StopIteration</code> (in <code>f</code>)</p>
<p>You can check that <code>next(f(some_value))</code> does throw an exception when called itself. </p>
<p>As will </p>
<pre><code>def g(x):
    return next(f(x))
</code></pre>
<p>But, you've added the default <code>None</code>, so that <code>g(x)</code> will run, but simply return back <code>None</code> since the iterator is exhausted. </p>
<hr/>
<p>If you remove the <code>None</code>, then you see </p>
<pre><code>In [5]: next(g(3))
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-14-05eb86fce40b&gt; in &lt;module&gt;()
----&gt; 1 next(g(3))

&lt;ipython-input-13-a4323284f776&gt; in g(x)
      1 def g(x) :
----&gt; 2     yield next(f(x))
      3

StopIteration:
</code></pre>
</div>
<span class="comment-copy">You use <code>next(iterable, DEFAULT)</code> and expect <code>StopIteration</code>? Why? Remove the default.</span>
<span class="comment-copy">If a generator raises StopIteration, that means it's exhausted. (The handling <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer">changed</a> in Python 3.5 for how a StopIteration encountered inside a generator propagates to the outside, but you'll still never get a StopIteration exception from a <code>next</code> call with a default value.)</span>
<span class="comment-copy">If I understand correctly, OP is saying that <code>g</code> is not exhausted, <code>f</code> is. Therefore <code>StopIteration</code> is raised within <code>g</code>, and OP expects to see a corresponding traceback. It makes sense, really. If an exception is thrown during execution of a function, you'd expect to get a traceback. You wouldn't expect the thrown error to magically disappear.</span>
<span class="comment-copy">This is a good explanation, but you haven't really touched on OP's real question: <i>"Can I use an alternating approach to achieve the goal?"</i></span>
<span class="comment-copy">@Rawing good point, I will elaborate.</span>
<span class="comment-copy">@ReutSharabani Since the <code>next</code> function is catching something unexpected, should Python change its behavior? Or should the documentation mentioned in my question be modified?</span>
<span class="comment-copy">"g(x) is an iterator that always yields f(x), so you never exhaust g(x)" - you do, because it's trying to yield <code>next(f(x))</code>, not <code>f(x)</code>, and <code>next(f(x))</code> raises <code>StopIteration</code>.</span>
<span class="comment-copy">@user2357112 Is correct. When testing the OP's example without giving none as the <code>default</code> parameter it raised a <code>StopIteration</code>.</span>
<span class="comment-copy">@user2357112 It's not <code>g</code> that's exhausted. <code>f</code> is exhausted and throws an exception. It's not really the same thing.</span>
<span class="comment-copy">@Rawing <code>g</code> is exhausted also because it sources from <code>f(x)</code>, more like <code>yield from f(x)</code> in Python 3 (although not exactly the same)</span>
<span class="comment-copy">@Rawing: An exception propagating out of <code>g</code> means it's exhausted.</span>
