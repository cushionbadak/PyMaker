<div class="post-text" itemprop="text">
<p><strong>How to select the minimum no. from a list that is &gt; 0?</strong></p>
<p>I have tried:</p>
<ul>
<li>Using a list comprehension to weed out the non-positive </li>
<li>Then do a <code>min()</code> on the filter list</li>
</ul>
<p>I.e.</p>
<pre><code>&gt;&gt;&gt; x = (-3155, 611, 1284)
&gt;&gt;&gt; min_x_more_than_0 = min([i for i in x if i &gt; 0])
&gt;&gt;&gt; min_x_more_than_0
611
</code></pre>
<p>There must be a better/faster way to do this. Imagine the length of X is 1,000,000,000 looping through the list is rather inefficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>If the data is ordered, you can do this in O(log n) by using binary search.    Just <a href="https://docs.python.org/2/library/bisect.html#bisect.bisect_left" rel="noreferrer"><code>bisect</code></a> at 0 and index the neighboring element.  </p>
<p>If the data is unordered, you can not do better than O(n) because you will have to inspect every element regardless.  </p>
<p>You can push the entire computation into C code by using numpy:  </p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array(x)
&gt;&gt;&gt; a[a &gt; 0].min()
611
</code></pre>
</div>
<span class="comment-copy">"Imagine the length of X is 1,000,000,000 looping through the list is rather inefficient." - you'd have to do that anyway even without the positivity constraint. You can get rid of the temporary list with a genexp, and you could shove all the loops into C with some more work, but you can't get rid of the loops entirely without restructuring your data.</span>
<span class="comment-copy">Get rid of the <code>[</code> and <code>]</code>, which will convert the list comprehension into a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a>.  You won't have to build the entire list before you start searching it.  (You'll still have to search all of it eventually --- the least item could be one you skip.)</span>
<span class="comment-copy">min(i for i in x if i &gt; 0)</span>
<span class="comment-copy">There really can't be a <i>much</i> better way: you <i>do</i> have to examine each list element, so anything you do will be O(N).  The above method iterates twice through the list, building a temporary list.  You could save some trouble by writing your own loop and avoiding the intermediate list, but that's about all you're going to get.</span>
<span class="comment-copy">The faster way, would be to always keep track of the minimum value as the list grows. Another (more extreme) way could be to have a few threads each check a range of elements. Other than that, maybe black magic.</span>
