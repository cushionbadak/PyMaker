<div class="post-text" itemprop="text">
<p>I am trying to convert the following code written in python 2 to python 3. This python code does TCP port forwarding. It is from this page: <a href="http://code.activestate.com/recipes/483730-port-forwarding/" rel="nofollow noreferrer">http://code.activestate.com/recipes/483730-port-forwarding/</a></p>
<pre><code>import socket
import sys
import thread

def main(setup, error):
    sys.stderr = file(error, 'a')
    for settings in parse(setup):
        thread.start_new_thread(server, settings)
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()

def parse(setup):
    settings = list()
    for line in file(setup):
        parts = line.split()
        settings.append((parts[0], int(parts[1]), int(parts[2])))
    return settings

def server(*settings):
    try:
        dock_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        dock_socket.bind(('', settings[2]))
        dock_socket.listen(5)
        while True:
            client_socket = dock_socket.accept()[0]
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((settings[0], settings[1]))
            thread.start_new_thread(forward, (client_socket, server_socket))
            thread.start_new_thread(forward, (server_socket, client_socket))
    finally:
        thread.start_new_thread(server, settings)

def forward(source, destination):
    string = ' '
    while string:
        string = source.recv(1024)
        if string:
            destination.sendall(string)
        else:
            source.shutdown(socket.SHUT_RD)
            destination.shutdown(socket.SHUT_WR)

if __name__ == '__main__':
    main('proxy.ini', 'error.log')
</code></pre>
<p>Here is what I have:</p>
<pre><code>import socket
import sys
import threading
import time

def main(setup, error):
    # open file for error messages
    sys.stderr = open(error, 'a')
    # read settings for port forwarding

    threads = []

    for settings in parse(setup):
        #thread.start_new_thread(server, settings)
        t = threading.Thread(target=server, args=(settings))
        t.start()
        threads.append(t)

    for t in threads:
        t.join()

    # wait for &lt;ctrl-c&gt;
    while True:
        time.sleep(60)

def parse(setup):
    settings = list()
    file = open(setup)

    for line in iter(file):
        parts = line.split()
        settings.append((int(parts[0]), parts[1], int(parts[2])))

    return settings

def server(*settings):

    try:
        dock_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        dock_socket.bind(('', settings[0]))
        dock_socket.listen(5)
        while True:
            client_socket = dock_socket.accept()[0]
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((settings[1], settings[2]))

            Thread1 = threading.Thread(target=forward, args=(client_socket, server_socket))
            Thread1.start()

            Thread2 = threading.Thread(target=forward, args=(server_socket, client_socket))
            Thread2.start()

    finally:
        thread = threading.Thread(targer=server, args=settings)
        thread.start()

def forward(source, destination):
    string = ' '
    while string:
        string = source.recv(1024)
        if string:
            destination.sendall(string)
        else:
            source.shutdown(socket.SHUT_RD)
            destination.shutdown(socket.SHUT_WR)

if __name__ == '__main__':
    main('port-forward.config', 'error.log')
</code></pre>
<p>The python 3 version does seem to work. But I am not fully certain if it is written correctly. I am unclear about the threads portion of the code. The python 2 version is using the thread module while the python 3 version is using the threading module. Looking at the python 2 version, it uses locks in the main function. Do I need to use locks in the python 3 version? Another question is, should I be joining the two threads (thread 1 and thread 2) in the server function in the python 3 code?</p>
<p>Another question I have regardless of python version is the argument to the server function. I understand that the "settings" variable refers to a list. Why does there need to be a asterisk preceding the "settings" argument? I did take a look at the following page in python documentation <a href="https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists</a></p>
<p>But I don't understand why passing the settings list without the asterisk doesn't work.</p>
<p>Another question I have is regarding the thread locks in the python 2 code. Why is the lock being acquired twice? I tried removing one of the locks and the program ends immediately after being started.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could have saved yourself some work by using the commandline tool <code>2to3</code> to convert the code to Python 3, like this (from the <code>bash</code> or Windows command line):</p>
<pre><code>2to3 -w myscript.py
</code></pre>
<p>But let's answer your actual question: Why the star in the definition </p>
<pre><code>def server(*settings):
    ...
</code></pre>
<p>The function <code>thread.start_new_thread</code> will in effect launch your <code>server()</code> function like this:</p>
<pre><code>server(arg1, arg2, arg3)
</code></pre>
<p>where <code>arg1</code>, <code>arg2</code> etc. come from the second argument of <code>start_new_thread</code>. The declaration <code>def server(*settings)</code> collects these arguments back into a single list, <code>settings</code>, which your function goes on to use. If you write <code>def server(settings)</code> (no star), your function is declared to take one argument but will be called with several.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the 2to3 tool that come with python 3 as a standard module.  It does most of the conversations for you.</p>
<pre><code>$2to3 youpythonfile.py
</code></pre>
<p>You can use the <code>_thread</code> module in python 3 which is identical to <code>thread</code> in python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the futurize script which convert your py2 code into py3 </p>
<p>See : <a href="http://python-future.org/quickstart.html#quick-start-guide" rel="nofollow noreferrer">http://python-future.org/quickstart.html#quick-start-guide</a> for installation and <a href="http://python-future.org/quickstart.html#to-convert-existing-python-2-code" rel="nofollow noreferrer">http://python-future.org/quickstart.html#to-convert-existing-python-2-code</a> for example</p>
</div>
<div class="post-text" itemprop="text">
<p>As the author of the code that you referenced from the Python cookbook, it is my pleasure to rewrite the program for Python 3 and introduce you to another useful recipe. <a href="http://code.activestate.com/recipes/483730/" rel="nofollow noreferrer">Port Forwarding</a> is the older of the two recipes but was a complete program used as a college student at my first college. <a href="http://code.activestate.com/recipes/502204/" rel="nofollow noreferrer">Module For Running Simple Proxies</a> is a improved version of the original code and was designed for use in other programs rather than being a complete program by itself. The code that follows takes the idea of <em>Port Forwarding</em> and combines it with lessons learned in <em>Module For Running Simple Proxies</em> and lessons learned since then to provide a complete and hopefully easy-to-read program for your use and study:</p>
<pre><code>import argparse
import re
import select
import socket
import sys
import threading


SETUP_PATTERN = r'^(?P&lt;server_name&gt;\S+)' \
                r'\s+(?P&lt;server_port&gt;\d+)' \
                r'\s+(?P&lt;proxy_port&gt;\d+)'
SETUP_TYPES = dict(server_name=str, server_port=int, proxy_port=int)


def main():
    arguments = parse_arguments()
    sys.stderr = open(arguments.error, 'a')
    for settings in parse_configuration(arguments.setup):
        threading.Thread(target=handle_connections, kwargs=settings).start()


def parse_arguments():
    parser = argparse.ArgumentParser(description='Forward TCP traffic.')
    parser.add_argument('setup', type=str, help='file with forwarding rules')
    parser.add_argument('error', type=str, help='location for error reports')
    arguments = parser.parse_args()
    return arguments


def parse_configuration(setup):
    with open(setup) as file:
        for line in file:
            match = re.search(SETUP_PATTERN, line)
            if match:
                yield {key: SETUP_TYPES[key](value)
                       for key, value in match.groupdict().items()}


def handle_connections(server_name, server_port, proxy_port):
    proxy = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    proxy.bind((socket.gethostname(), proxy_port))
    proxy.listen(5)
    while True:
        client, address = proxy.accept()
        server = socket.create_connection((server_name, server_port))
        threading.Thread(target=handle_traffic, args=(client, server)).start()


def handle_traffic(client, server):
    pairs, empty = {client: server, server: client}, ()
    while pairs:
        read, write, error = select.select(pairs.keys(), empty, empty)
        for connection in read:
            try:
                data = connection.recv(1 &lt;&lt; 12)
            except ConnectionResetError:
                data = None
            if data:
                pairs[connection].sendall(data)
            else:
                connection.shutdown(socket.SHUT_RD)
                pairs.pop(connection).shutdown(socket.SHUT_WR)
    client.close()
    server.close()


if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">I have edited the post to add another question I had.</span>
<span class="comment-copy">Thanks Alexis for explaining the starred arguments.</span>
