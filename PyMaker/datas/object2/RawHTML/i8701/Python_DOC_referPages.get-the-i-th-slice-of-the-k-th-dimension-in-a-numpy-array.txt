<div class="post-text" itemprop="text">
<p>I have an <code>n</code>-dimensional numpy array, and I'd like to get the <code>i</code>-th slice of the <code>k</code>-th dimension. There must be something better than</p>
<pre><code># ... 
elif k == 5:
    b = a[:, :, :, :, :, i, ...]
# ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>b = a[(slice(None),) * k + (i,)]
</code></pre>
<p>Construct the indexing tuple manually.</p>
<p>As documented in the <a href="https://docs.python.org/3/reference/expressions.html#slicings" rel="noreferrer">Python language reference</a>, an expression of the form</p>
<pre><code>a[:, :, :, :, :, i]
</code></pre>
<p>is converted to</p>
<pre><code>a[(slice(None), slice(None), slice(None), slice(None), slice(None), i)]
</code></pre>
<p>We can achieve the same effect by building that tuple directly instead of using slicing notation. (There's the minor caveat that building the tuple directly produces <code>a[(i,)]</code> instead of <code>a[i]</code> for <code>k=0</code>, but NumPy handles these the same for scalar <code>i</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure if it will work for k dim but it does for 2 dim</p>
<pre><code>a.take(i,axis=k)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here is a late entry that can handle negative axis arguments without having to know the shape of its operand beforehand:</p>
<pre><code>def put_at(inds, axis=-1, slc=(slice(None),)):
    return (axis&lt;0)*(Ellipsis,) + axis*slc + (inds,) + (-1-axis)*slc
</code></pre>
<p>To be used as in</p>
<pre><code>a[put_at(ind_list,axis=axis)]
</code></pre>
<p><code>ind_list</code> can be a scalar as in your case or something more interesting as well.</p>
<p>Copied from <a href="https://stackoverflow.com/questions/42656930/numpy-assignment-like-numpy-take/42657219#comment72441626_42657219">this</a> comment of mine.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically, you want to be able to programmatically create the tuple <code>:, :, :, :, :, i, ...</code> in order to pass it in as the index of <code>a</code>. Unfortunately, you cannot simply use ordinary tuple multiplication on the colon operator directly (i.e., <code>(:,) * k</code> won't work to generate a tuple of <code>k</code> colon operators). You can, however, get an instance of a "colon slice" by using <code>colon = slice(None)</code>. You could then do <code>b = a[(colon,) * k + (i,)]</code>, which would effectively index <code>a</code> at the <code>i</code>th column of the <code>k</code>th dimension.</p>
<p>Wrapping this up in a function, you'd get:</p>
<pre><code>def nDimSlice(a, k, i):
    colon = slice(None)
    return a[(colon,) * k + (i,)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure if this approach would create an entire copy of the array*, but I would take a slice of the transposed matrix in order to get the kth axis:</p>
<pre><code>import numpy as np

def get_slice(arr, k, i):
    if k &gt;= arr.ndim: #we need at least k dimensions (0 indexed)
        raise ValueError("arr is of lower dimension than {}".format(k))

    axes_reorder = list(range(arr.ndim)) #order of axes for transpose
    axes_reorder.remove(k) #remove original position of k
    axes_reorder.insert(0,k) #insert k at beginning of order

    return arr.transpose(axes_reorder)[i] #k is first axis now
</code></pre>
<p>This also has the added bonus of easier checking of the number of dimensions before trying the slice.</p>
<p>* according to the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html" rel="nofollow noreferrer">docs</a>, a memory view is created whenever possible.</p>
</div>
<span class="comment-copy">Whoaw. I'll happily copy-&amp;-paste this, but a link to documentation would perhaps still be useful.</span>
<span class="comment-copy">slice notation, e.g. <code>a[&lt;something&gt;]</code> is just syntactic sugar for a call to <code>__getitem__</code> passing it a tuple, in this case, a tuple of slice objects (the <code>:</code> notation being syntactic suger for a <code>slice</code> object)</span>
<span class="comment-copy">You could also spell that <code>b[np.index_exp[:] * k + np.index_exp[i]]</code>, which is possibly a little more readable</span>
<span class="comment-copy">This has the disadvantage of creating a copy instead of a view.</span>
<span class="comment-copy">@user2357112: Huh, that's a little surprising</span>
<span class="comment-copy">extra slices after <code>i</code> are unnecessary as far as numpy is concerned</span>
<span class="comment-copy">@Aaron Thanks, I was unaware!</span>
