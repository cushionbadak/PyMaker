<div class="post-text" itemprop="text">
<p>I want to create a class hierarchy in which I have a class <code>Block</code> which can be instantiated by itself. Then I have a class <code>List</code> which inherits from <code>Block</code> and contains methods common to all lists, and finally I have classes <code>OrderedList</code>, <code>LableledList</code> etc that inherit from <code>List</code>. I want people to be able to instantiate <code>OrderedList</code> etc, but not <code>List</code>. </p>
<p>In other words, you can instantiate a plain <code>Block</code> and you can instantiate an <code>OrderedList</code> that inherits from <code>List</code> that inherits from <code>Block</code>, but you can't instantiate <code>List</code>. </p>
<p>All attempts to Google this lead to Abstract Base Classes, but none provides and example that fits this case and I am having trouble extrapolating. </p>
</div>
<div class="post-text" itemprop="text">
<p>The following conversation with the interpreter should show how this is possible. After inheriting from the Abstract Base Class with <code>Block</code>, you only need to mark the initializer on <code>List</code> as being an <code>abstractmethod</code>. This will prevent instantiation of the class without causing problems for child classes.</p>
<pre><code>&gt;&gt;&gt; import abc
&gt;&gt;&gt; class Block(abc.ABC):
    def __init__(self, data):
        self.data = data


&gt;&gt;&gt; class List(Block):
    @abc.abstractmethod
    def __init__(self, data, extra):
        super().__init__(data)
        self.extra = extra


&gt;&gt;&gt; class OrderedList(List):
    def __init__(self, data, extra, final):
        super().__init__(data, extra)
        self.final = final


&gt;&gt;&gt; instance = Block(None)
&gt;&gt;&gt; instance = List(None, None)
Traceback (most recent call last):
  File "&lt;pyshell#42&gt;", line 1, in &lt;module&gt;
    instance = List(None, None)
TypeError: Can't instantiate abstract class List with abstract methods __init__
&gt;&gt;&gt; instance = OrderedList(None, None, None)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Inherit from <code>ABC</code> located in the <code>abc</code> module and make methods that are implemented in base classes (that inherit from <code>List</code>) <code>@abstractmethod</code>s (a decorator located in <code>abc</code>):</p>
<pre><code>from abc import ABC, abstractmethod

class List(ABC, Block):

    @abstractmethod
    def size(self):
        return 0 
</code></pre>
<p>Having an ABC with <code>@abstractmethod</code>s defined forbids from instantiation. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your List class should have ABCMeta as a metaclass and make the init methods abstract.</p>
<pre><code>from abc import ABCMeta
class List(metaclass=ABCMeta):
    @abstractmethod
    __init__():
        pass
</code></pre>
<p><a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">https://docs.python.org/3/library/abc.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The "one and obvious" way to do this is to use ABCMeta and mark some methods as abstract as documented on other answers.</p>
<p>But if in your case you don't have a set of methods that one has to override in a mandatory way (let's suppose your <code>__init__</code> is reusable in some cases, and other of the list methods as well):</p>
<p>In that case you can create a <code>__new__</code> method that checks if the clas being istantiated is the own class, and raises.  To do that,  you have to use teh magic <code>__class__</code> variable that is documentend only in corners of Python docs - if you as much as use the <code>__class__</code> variable in any method body, it will automatically take the value of the class where it was declared, at run time. It is part of the parameterless  <code>super</code> mechanism of Python 3.</p>
<p>Thus:</p>
<pre><code>class List(Block):
    def __new__(cls, *args, **kw):
        if cls is __class__:
            raise TypeError(cls.__name__ + " can't be directly instantiated")
        return super().__new__(cls, *args, **kw)
</code></pre>
<p>Btw, you <em>should</em> give preference for the ABCMeta abstractmethods if your pattern allows it. Note that if your classes use a custom metaclass it will conflict with the ABCMeta as well - so you may need to resort to this as well</p>
<p>(If you don't further customize <code>__new__</code>, then you'd better not pass <code>args</code> and <code>kw</code> upstream on the <code>__new__</code> method: Python's <code>object.__new__</code> ignore extra args if <code>__init__</code> is defined but <code>__new__</code> is not in the subclasses - but if both are defined it raises an error)</p>
</div>
<span class="comment-copy">You specify <code>class List(metaclass=ABCMeta):</code> in the class declaration.</span>
<span class="comment-copy">Ah, that makes so much clear! So Block can inherit from ABC and still be instantiated. It is marking <code>init</code> as @abstractmethod that makes it impossible to instantiate the class. So no multiple inheritance needed.</span>
<span class="comment-copy">No, my list has nothing to do with python lists at all (its about textual lists). And I need List to inherit from <code>Block</code>, and I need several methods in <code>List</code> to not be abstract so that they can be inherited by <code>OrderedList</code>. It's that combination of things that I am having trouble figuring out.</span>
<span class="comment-copy">@MarkBaker you don't need to make <i>all methods</i> abstract; just those you need to re-implement. You can have "common" methods in <code>List</code> and use them without issue in any sub classes. All methods defined as <code>abstract</code> in <code>List</code> require to be implemented in sub classes, though.</span>
