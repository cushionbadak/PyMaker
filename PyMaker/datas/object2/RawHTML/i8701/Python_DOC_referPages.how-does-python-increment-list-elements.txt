<div class="post-text" itemprop="text">
<p>Can someone explain to me why the first code block doesn't change the list, but the second does.</p>
<pre><code>a = [1,2,3]
for el in a:
    el += 5
</code></pre>
<p>This leaves <code>a</code> as <code>[1,2,3]</code>. That said if I run</p>
<pre><code>a = [1,2,3]
for i in range(len(a)):
    a[i] += 5
</code></pre>
<p>then <code>a = [6,7,8]</code>. My guess is that in the first, when looping over the elements <code>el</code> is a temporary variable, and not actually the thing that references that element in the list. Not sure why incrementing it doesn't effect the list though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python integers are not mutable, but lists are.</p>
<p>In the first case <code>el</code> references immutable integers, so <code>+=</code> creates a new integer that only <code>el</code> refers to.</p>
<p>In the second case the list <code>a</code> is mutated directly, modifying its elements directly.  <code>a[0]</code> still references an immutable integer, so <code>+=</code> creates a new integer, but its reference is assigned directly to an element of the mutable list.</p>
<h3>Examples</h3>
<p>Here are examples showing the reference ids of list elements.  In the first case, new integers are created, but the original list references are unchanged.</p>
<pre><code>a = [1,2,3]
print [id(x) for x in a]
print a

for el in a:
    el += 5   # creates new integer, but only temp name references it

print [id(x) for x in a] # references are not changed.
print a
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[36615248, 36615236, 36615224]
[1, 2, 3]
[36615248, 36615236, 36615224]
[1, 2, 3]
</code></pre>
<p>In the second case, the list references are updated:</p>
<pre><code>a = [1,2,3]
print [id(x) for x in a]
print a

for i in range(len(a)):
    a[i] += 5      # creates new integer, but updates mutable list

print [id(x) for x in a] # references are changed.
print a
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[36615248, 36615236, 36615224]
[1, 2, 3]
[36615188, 36615176, 36615164]
[6, 7, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>=</code> (when the left-hand side is just an identifier) is purely a syntactic construct, which binds the name on the left to the object on the right.</p>
<p>All other assignments are short-hand for various method calls.</p>
<ul>
<li><code>a[i] = 3</code> is short for <code>a.__setitem__(i, 3)</code></li>
<li><code>a += 3</code> is  short for <code>a = a.__iadd__(3)</code></li>
<li><code>a[i] += 3</code> is short for <code>a.__setitem__(i, a[i]+3)</code></li>
</ul>
<p>The end result of each method call depends on how <code>type(a)</code> implements the method being called. The method might mutate its caller, or it might return a new object.</p>
</div>
<div class="post-text" itemprop="text">
<p>I first wrote this as a comment but I'd like to expand it a bit, especially to add the tuple example.</p>
<p><a href="https://stackoverflow.com/a/42749675/1256452">Mark Tolonen's answer</a> is correct (and upvoted) in that ordinary integers are immutable (cannot be changed) and lists are mutable (can have elements replaced), but does not mention another couple of key concepts, which show up in slightly scary examples:</p>
<ol>
<li><p><em>Objects</em> get <em>bound</em> to variables.</p>
<p>Ordinary variable assignment like <code>x = 3</code> simply binds the object on the right—which may be constructed on the spot if needed—to the name on the left.</p></li>
<li><p>"In-place" operators like <code>+=</code> attempt to invoke modifier functions, which allows mutable objects to capture them.  For instance, if <code>x</code> is bound to a class instance, writing <code>x += 3</code> will actually execute <code>x.__iadd__(3)</code>, if <code>x</code> has an <code>__iadd__</code>.<sup>1</sup>  If not, it runs <code>x = x + 3</code> instead, which invokes the <code>__add__</code> operator: <code>x = x.__add__(3)</code>.  See <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer">the operator documentation</a> for all the gory details.  In this case, the objects involved—ordinary integers—don't have modifier functions:</p>
<pre><code>&gt;&gt;&gt; (3).__add__
&lt;method-wrapper '__add__' of int object at 0x801c07f08&gt;
&gt;&gt;&gt; (3).__iadd__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'int' object has no attribute '__iadd__'
</code></pre>
<p>so this particular twist is irrelevant for <code>int</code>, but it's worth remembering.</p></li>
<li><p><em>Indexed</em> assignment, <code>x[i] = expression</code>, invokes the <code>__setitem__</code> method.  This is how mutable (modifiable) objects mutate themselves.  A list object implements <code>__setitem__</code>:</p>
<pre><code>&gt;&gt;&gt; [].__setitem__
&lt;method-wrapper '__setitem__' of list object at 0x8007767e8&gt;
</code></pre>
<p>For completeness, I will note that it also implements <code>__getitem__</code> to <em>retrieve</em> <code>x[i]</code>.</p>
<p>Hence, when you write <code>a[i] += 5</code>, you wind up calling:</p>
<pre><code>a.__setitem__(i, a.__getitem__(i) + 5)
</code></pre>
<p>which is how Python manages to add 5 to the i'th element of the list bound to <code>a</code>.</p></li>
</ol>
<p>Here's the slightly scary example.  A <em>tuple</em> object is <em>not</em> modifiable, but a <em>list</em> object is.  If we embed a list into a tuple:</p>
<pre><code>&gt;&gt;&gt; l = [0]
&gt;&gt;&gt; t = (l,)
</code></pre>
<p>we can then use <code>t[0]</code> to invoke <code>t.__getitem__</code> and <code>t.__setitem__</code>.  Meanwhile <code>t[0]</code> is bound to the same list object as <code>l</code>.  This part is obvious enough:</p>
<pre><code>&gt;&gt;&gt; t
([0],)
&gt;&gt;&gt; l.append(1)
&gt;&gt;&gt; t
([0, 1],)
</code></pre>
<p>We modified <code>l</code> in place, so <code>t[0]</code>, which names the same list as <code>l</code>, has been modified.  But now:</p>
<pre><code>&gt;&gt;&gt; t[0] += [2]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment
&gt;&gt;&gt; t
([0, 1, 2],)
</code></pre>
<p>What?!  How did <code>t</code> change when we got an error telling us that <code>t</code> can't change?</p>
<p>The answer is, <code>t</code> <em>didn't</em> change, but the <em>list</em> (which we can also access via <code>l</code>) <em>did</em> change.  Lists implement <code>__iadd__</code>, so the assignment:</p>
<pre><code>t[0] += [2]
</code></pre>
<p>"means":</p>
<pre><code>t.__setitem__(0, t.__getitem__(0).__iadd__([2]))
</code></pre>
<p>The <code>__getitem__</code> accessed the list and the <code>__iadd__</code> augmented the list:</p>
<pre><code>&gt;&gt;&gt; l
[0, 1, 2]
</code></pre>
<p>and then the <code>t.__setitem__(0, ...)</code> raised the <code>TypeError</code>, but the list was already augmented by then.</p>
<p>Note, by the way, the fact that tweaking the list object bound to <code>l</code> affects the tuple object bound to <code>t</code>, because <code>t[0]</code> <em>is</em> that list object.  This—the fact that variables are bound to objects, and elements within data structures like tuples, lists, and dictionaries, can refer to <em>other</em> objects—is critical in reading and writing Python code.  <strong>Understanding both the binding rules, and when objects get created, is the key to knowing why this is usually a bad idea:</strong></p>
<pre><code>def f(a=[]):
</code></pre>
<p>Specifically, the list object here is created at <code>def</code> time, i.e., just once.  Any time someone adds to the list inside <code>f</code>, with <code>a.append</code> for instance, it keeps adding to that original list!</p>
<hr/>
<p>See also <a href="https://stackoverflow.com/q/4292304/1256452">python: how binding works</a> for (way too) much more about additional binding rules. :-)</p>
<p><sup>1</sup>As <a href="https://stackoverflow.com/questions/42749644/how-does-python-increment-list-elements/42750263#comment72617788_42750245">Duncan points out in a comment</a> on <a href="https://stackoverflow.com/a/42750245/1256452">chepner's answer</a>, after invoking <code>__iadd__</code>, the returned result is re-bound to the object.  (All functions return a result; returning without an expression, or "falling off the end" of a function, is defined as returning <code>None</code>.)</p>
<p>Mutable objects <em>should</em> generally return themselves, and immutable objects don't need to implement <code>__iadd__</code> in the first place since implementing a mutation on a supposedly-immutable object just seems odd.  Nonetheless, we can abuse, and thereby expose, this behavior by writing a class that <em>pretends</em> to be immutable, but is not.  Here's an example.  This is not meant to be <em>useful</em>, just to illustrate one of the darker corners of Python.</p>
<pre><code>"""
demonstration of iadd behavior
"""
from __future__ import print_function

class Oddity(object):
    """
    A very odd class: like a singleton, but there can be
    more than one of them.  Each one is a list that just
    accumulates more items.  The __iadd___ (+=) operator
    augments the item, then advances to the next instance.

    Creating them is tricky as we want to create new ones
    up until we "freeze" the class, then start re-using
    the instances.  We use a __new__ operator a la immutable
    objects, plus a boolean in the class itself, even though
    each instance is mutable.
    """
    def __new__(cls):
        if not hasattr(cls, 'frozen'):
            cls.frozen = False
        if cls.frozen:
            whichone = cls.rotator
            cls.rotator = (whichone + 1) % len(cls.instances)
            return cls.instances[whichone]
        self = object.__new__(cls)
        if not hasattr(cls, 'instances'):
            cls.instances = []
        self.whichone = len(cls.instances)
        self.values = []
        cls.instances.append(self)
        print('created', self)
        return self

    def __str__(self):
        return '#{}, containing {}'.format(self.whichone, self.values)

    def __iadd__(self, value):
        print('iadd to', self)
        self.values.append(value)
        all_oddities = self.__class__.instances
        nextone = (self.whichone + 1) % len(all_oddities)
        return all_oddities[nextone]

    @classmethod
    def freeze(cls):
        if not hasattr(cls, 'frozen'):
            raise TypeError('need at least one instance to freeze')
        cls.frozen = True
        cls.rotator = 0

# Now make two instances, and freeze the rest so that
# we can cycle back and forth.
o0 = Oddity()
o1 = Oddity()
Oddity.freeze()

print('o0 is', o0)
o0 += 'first add to o0'
o0 += 'second add to o0'
o0 += 'third add to o0'
print('now o0 is', o0, 'and o1 is', o1)
print('the first object is', Oddity.instances[0])
</code></pre>
<p>Once we create the two objects and freeze the class, we invoke <code>__iadd__</code> three times on <code>o0</code>, so in the end, <code>o0</code> and <code>o1</code> are actually both bound to the <em>second</em> object.  The first object—findable only through the class's <code>cls.instances</code> field—has two items in its list-of-items.</p>
<p>As an exercise, try to predict what this will print out, before running it.</p>
<p>(Extra-advanced exercise: turn <code>Oddity</code> into a <em>metaclass</em> that can be applied to classes to turn them into freeze-able multi-singletons.  [Is there a term for "thing that is <em>like</em> a singleton but allows N of them"?]  See also <a href="https://code.google.com/archive/p/google-singleton-detector/wikis/WhySingletonsAreControversial.wiki" rel="nofollow noreferrer">Why Singletons Are Controversial</a>.)</p>
<p>[Edit: this had been bugging me: it turns out there <em>is</em> a name for fixed-set-of-singletons.  When the set has just two elements, it's a "doubleton".  In Python, <code>True</code> and <code>False</code> are the doubletons comprising the <code>bool</code> type.  The generalization to <em>n</em> objects is a <a href="https://en.wikipedia.org/wiki/Multiton_pattern" rel="nofollow noreferrer">multiton</a>, often instantiated / used as a fixed—at least, after "freeze" time—hash table.  Note that Python's doubleton boolean instances are immutable, as is Python's singleton <code>None</code>.]</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first code block, <code>e1</code> is a reference to one of the elements in <code>a</code> (depending on which iteration of the loop we're in).</p>
<p>When you do <code>e1 += 5</code> (or more clearly in this case, <code>e1 = e1 + 5</code>), what you are doing is <em>reassigning</em> <code>e1</code> to the value of <code>e1 + 5</code>. After this operation, <code>e1</code> no longer points to the first element of the list, but the new variable we created (<code>e1 + 5</code>). The list remains unchanged.</p>
<p>In the second code block, you are assigning something directly to an element of a list, as opposed to temporary reference <code>e1</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first example, <code>el</code> is a local variable, and it's completely unaware that it's part of a list.</p>
<p>In the second example, you are explicitly manipulating elements of the list.</p>
<p>The lesson here will be slightly more clear if we expand the <code>+=</code> shorthand, and if we use a list of mutable objects instead of immutable integers:</p>
<p>Iterator pattern:</p>
<pre><code>a = [[1], [2]]
for el in a:
    el = [3]
</code></pre>
<p>After this loop, <code>a</code> is unchanged:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; a
[[1], [2]]
</code></pre>
</blockquote>
<p>Counting loop pattern:</p>
<pre><code>for i in range(len(a)):
    a[i] = [3]
</code></pre>
<p>After this loop, <code>a</code> is changed:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; a
[[3], [3]]
</code></pre>
</blockquote>
<p>On the other hand, if you mutate <code>el</code> itself instead of reassigning it:</p>
<pre><code>a = [[1], [2]]
for el in a:
    el[0] = el[0] + 5
</code></pre>
<p>Note that here we are not reassigning <code>el</code>, we are mutating it without reassignment.</p>
<p>The change will be visible through the list too:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; a
[[6], [7]]
</code></pre>
</blockquote>
<p>In case of your original example with a list of integers,
this kind of mutation is not possible,
because integers are immutable.
So if you want to modify the values inside the list,
you must use the counting loop approach.</p>
</div>
<span class="comment-copy">Because el is a local variable that only exists within the for loop.</span>
<span class="comment-copy">@klutt Not quite; <code>for</code> loops do not establish a scope, so <code>el</code> still exists after the loop exits and refers to the last object it was bound to.</span>
<span class="comment-copy">@chepner True. Thanks for the clarification. My point was that el was a copy and not a reference to each element.</span>
<span class="comment-copy">It's not a copy; it <i>is</i> a reference to each individual element. The elements just aren't mutuable.</span>
<span class="comment-copy">Oh gee. Thanks.</span>
<span class="comment-copy"><code>a += 3</code> is short for <code>a = a.__iadd__(3)</code>. When <code>a</code> is mutable the <code>__iadd__</code> method returns the mutated object but the assignment still happens.  Likewise <code>a[i] += 3</code> is short for <code>a.__setitem__(i, a.__getitem__(i).__iadd__(3))</code> In both cases there is a call to <code>__iadd__</code> and in both cases there is an assignment back to the original.</span>
