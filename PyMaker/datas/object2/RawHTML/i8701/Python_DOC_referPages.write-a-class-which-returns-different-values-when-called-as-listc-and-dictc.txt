<div class="post-text" itemprop="text">
<p>I am trying to implement a custom class which returns a different value when called as <code>list(c)</code> or <code>dict(c)</code>. However, it is my impression that both <code>list(c)</code> and <code>dict(c)</code> use <code>c.__iter__()</code> under the hood? If that is the case, how can I get different behaviour calling <code>list(c)</code> and <code>dict(c)</code>? I know that it is possible because Python dictionaries and pandas DataFrames have different hevariours.</p>
<p>For example:</p>
<pre>
class Foo:
    def __init__(self):
        self._keys = ['a', 'b', 'd', 'd', 'e']
        self._data = [10, 20, 30, 40, 50]

    def __iter__(self):
        for key, value in zip(self._keys, self._data):
            yield key, value
</pre>
<p>Calling <code>dict(c)</code> I get what I want:</p>
<pre>
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; dict(f)
{'a': 10, 'b': 20, 'd': 40, 'e': 50}
</pre>
<p>However, I can't get <code>list(c)</code> to print out a list of keys (or values), but instead get both:</p>
<pre>
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; list(f)
[('a', 10), ('b', 20), ('d', 30), ('d', 40), ('e', 50)]
</pre>
<p>The equivalent code for a dictionary is much cleaner:</p>
<pre>
&gt;&gt;&gt; f = {'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': 50}
&gt;&gt;&gt; dict(f)
{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': 50}
&gt;&gt;&gt; list(f)
['a', 'b', 'c', 'd', 'e']
</pre>
</div>
<div class="post-text" itemprop="text">
<p>Obviously the <code>__iter__</code> must only return the <em>keys</em>, otherwise <code>list(f)</code> wouldn't work.</p>
<p>The Python documentation says the following of the <a href="https://docs.python.org/3/library/stdtypes.html#typesmapping" rel="nofollow noreferrer"><code>dict</code> constructor</a>:</p>
<blockquote>
<p>If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object.</p>
</blockquote>
<p>Now, the question is what is a "mapping" enough for the <code>dict</code> constructor? <code>DataFrame</code> doesn't inherit from any mapping class, neither is it registered against an abstract base class. It turns out we only need to support the <code>keys</code> method: If the object passed to <code>dict</code> constructor has a method called <code>keys</code>, this is called to provide an iterable of the keys <a href="https://github.com/python/cpython/blob/ce552e2d5c4ff90218fb41847e8ffb1fd3ba3b2d/Objects/dictobject.c" rel="nofollow noreferrer">[CPython source]</a>. For each key, the value is fetched by indexing.</p>
<p>I.e. the <code>dict</code> constructor does the logical equivalent of the following:</p>
<pre><code>if hasattr(source, 'keys'):
    for k in source.keys():
        self[k] = source[k]
else:
    self.update(iter(source))
</code></pre>
<p>Using this we get</p>
<pre><code>class Foo:
    def __init__(self):
        self._keys = ['a', 'b', 'd', 'd', 'e']
        self._data = [10, 20, 30, 40, 50]

    def __iter__(self):
        return iter(self.keys)

    def __getitem__(self, key):
        idx = self._keys.index(key)
        return self._data[idx]

    def keys(self):
        return self._keys
</code></pre>
<p>Testing:</p>
<pre><code>&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; list(f)
['a', 'b', 'd', 'd', 'e']

&gt;&gt;&gt; dict(f)
{'d': 30, 'e': 50, 'a': 10, 'b': 20}
</code></pre>
<p>(As you can see from the code above, there is no need to actually inherit from anything)</p>
<p>However, it is not guaranteed that <em>all</em> mapping constructors behave in the same way - some other might call <code>items</code> - thus the most compatible way would be to implement all of the methods required by <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="nofollow noreferrer"><code>collections.abc.Mapping</code></a> and inherit from it. I.e. it would be enough to do</p>
<pre><code>class Foo(collections.abc.Mapping):
    ...
    def __getitem__(self, key):
        idx = self._keys.index(key)
        return self._data[idx]

    def __iter__(self):
        return iter(self._keys)

    def __len__(self):
        return len(self._keys)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@mgilson's comment is correct, this can be accomplished by inheriting from the <code><a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping" rel="nofollow noreferrer">collections.abc.Mapping</a></code> class:</p>
<pre>
class Foo(collections.abc.Mapping):
    def __init__(self):
        self._keys = ['a', 'b', 'd', 'd', 'e']
        self._data = [10, 20, 30, 40, 50]

    def __iter__(self):
        for key in self._keys:
            yield key

    def __getitem__(self, value):
        return self._data[self._keys.index(value)]

    def __len__(self):
        return len(self._keys)
</pre>
<pre>
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; list(f)
['a', 'b', 'd', 'd', 'e']

&gt;&gt;&gt; dict(f)
{'a': 10, 'b': 20, 'd': 30, 'e': 50}
</pre>
</div>
<span class="comment-copy">This is because you yield tuples (key,value forms a tuple and the python list function just stores them all in a list).</span>
<span class="comment-copy">I know, but if I yield one value at a time, <code>dict(c)</code> does not work property.</span>
<span class="comment-copy"><code>list</code> and <code>dict</code> call the same magic methods; there is no way to make a class return something different depending on what called it. I'd suggest that you make <code>keys()</code> and <code>values()</code> methods to return lists.</span>
<span class="comment-copy">You need <code>f</code> to be a <code>Mapping</code> type in order to get that sort of behavior.  Inheriting from <code>collections.Mapping</code> <i>might</i> be helpful...</span>
<span class="comment-copy">def __iter__(self):         return iter(keys) <code>self.keys</code> probably</span>
<span class="comment-copy">@Marii thanks, fixed</span>
