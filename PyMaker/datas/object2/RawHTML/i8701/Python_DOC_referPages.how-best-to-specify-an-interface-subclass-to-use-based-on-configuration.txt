<div class="post-text" itemprop="text">
<p>I would like to create a single "interface" class (in interface.py) through which I can access an underlying class's functionality, where the class accessed is dependent on a xml config_file setting. 
Taking connection via ssh, or ftp as an example.</p>
<p>I'd have a variable set in my config file such as
<code>"INTERFACE": "ssh"</code></p>
<p>Then I'd expect to have code that looks something like this:</p>
<pre><code># file = interface.py
class Interface(?)
    def connect(self, *args, **kwargs):
        return self

# file = ssh.py
class SSH(?)
    def connect(self, *args, **kwargs):
        # Setup a connection
        connection = paramiko.SSHClient()
        return connection

#file = ftp.py
class FTP(?)
    def connect(self, *args, **kwargs):
        # Setup a connection
        return connection

# And in my calling code I would just like a generic call e.g.
from path.interface import Interface

foo = Interface()
foo.connect(bar)    # Where "INTERFACE" : "ssh"
</code></pre>
<p>Then the <code>SSH</code> class would (override?) execute its code defined in its version of <code>connect()</code>.
If I then change the config setting to config.INTERFACE = "ftp", the same call would "find its way" to the ftp class to establish an ftp connection.</p>
<p>Ideally I'd be able to flip between the different version of <code>connect()</code> with my code, simply by setting:</p>
<pre><code>config.INTERFACE = "ssh"
config.INTERFACE = "ftp"
</code></pre>
<p>I assume this isn't some unachievable thing? I don't even know what to google to find out how to do this! Is this overriding?
Any advice would be gratefully received. 
Just a topic to google would be a starting point. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>A standard pattern of doing this is something like this:</p>
<pre><code>from abc import abstractmethod, ABCMeta

class Interface(metaclass=ABCMeta):
    @abstractmethod
    def upload(self):
        raise NotImplementedError('Must implement upload in subclasses')

class SSH(Interface):

    def upload(self):
        # ssh implementation

class FTP(Interface):

    def upload(self):
        # ftp implementation

def InterfaceForConfigurationValue(interface_value):
    if interface_value == 'ssh':
        return SSH()

    if interface_value == 'ftp':
        return FTP()

    raise NotImplementedError('Interface not available for value %s' % (
        interface_value,))
</code></pre>
<ul>
<li><p><code>Interface</code> is the abstract base class defining the interface you want to use. Useless on its own, it needs concrete subclasses to implement it.</p>
<p>Note that for this to be a useful abstraction and worth the effort, you want to make this more tailored to you applications and provide higher level APIs, such as <code>upload()</code> or <code>get()</code>, or else it's a bit pointless, and you may find it's hard to generalize to different protocols.</p></li>
<li><code>SSH</code> and <code>FTP</code> both override the <code>upload()</code> method of their superclass (<code>Interface</code>) and so you can call <code>upload()</code> on your <code>Interface</code> instance without worrying about which particular subclass it is.</li>
<li><code>InterfaceForConfigurationValue</code> is a factory function that gives you the correct interface subclass based on the configuration option.</li>
</ul>
<p>In general the most important thing is to ensure that nothing about <code>Interface</code>, <code>SSH</code> or <code>FTP</code> knows or cares what is in the config file, because you may wish to use them elsewhere with a different config system. They just know what they need to do. You add a factory function which is small and contains the knowledge of how to translate your config into a subclass. </p>
<p>Note: your factory function doesn't have to be a global function. Often you'll find there are lots of similar bits of linking you need to do between your config system and your code, so you may want to use a class and have the factory as a method on the class. A subclass of <a href="https://docs.python.org/3/library/configparser.html#configparser.ConfigParser" rel="nofollow noreferrer"><code>ConfigParser</code></a> is often a good option.</p>
</div>
<span class="comment-copy">ssh and ftp are just examples not what I'm trying to code. It's the structure I'm trying to learn. The override or inheritance or ?</span>
<span class="comment-copy">I'm trying to understand the utility here... What's the significant difference between doing <code>config.INTERFACE = "ssh"</code> and <code>config = SSH()</code>?  It doesn't seem like having the interface does very much for you.</span>
<span class="comment-copy">"INTERFACE" : "ssh" Would be one of many lines in an XML config file.  The contents of which would end up in config. So to access the value for INTERFACE would be config.INTERFACE</span>
<span class="comment-copy">Ok ... It still seems like you should just use the value of <code>config.INTERFACE</code> to pick the proper class (<code>SSH</code> or <code>FTP</code>).</span>
<span class="comment-copy">How to do that is my question?</span>
<span class="comment-copy">Apologies for not coming back to this. The priority for me to do this dropped off a cliff and is slowly climbing back up again! I've not had chance to try the above but it look pretty convincing. :)  Thank you for your time/help all.</span>
