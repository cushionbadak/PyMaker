<div class="post-text" itemprop="text">
<p>With numpy arrays, I want to perform this operation:</p>
<ul>
<li>move <code>x[1],...,x[n-1]</code> to <code>x[0],...,x[n-2]</code> (left shift),</li>
<li>write a new value in the last index: <code>x[n-1] = newvalue</code>.</li>
</ul>
<p>This is similar to a <code>pop()</code>, <code>push(newvalue)</code> for a first-in last-out queue (only inverted).</p>
<p>A naive implementation is: <code>x[:-1] = x[1:]; x[-1] = newvalue</code>.</p>
<p>Another implementation, using <code>np.concatenate</code>, is slower: <code>np.concatenate((x[1:], np.array(newvalue).reshape(1,)), axis=0)</code>.</p>
<p>Is there a fastest way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>After some experiments, it is clear that:</p>
<ul>
<li>copying is required,</li>
<li>and the fastest and simplest way to do that, for <code>nparray</code> (numpy arrays) is a slicing and copying.</li>
</ul>
<p>So the solution is: <code>x[:-1] = x[1:]; x[-1] = newvalue</code>.</p>
<p>Here is a small benchmark:</p>
<pre><code>&gt;&gt;&gt; x = np.random.randint(0, 1e6, 10**8); newvalue = -100
&gt;&gt;&gt; %timeit x[:-1] = x[1:]; x[-1] = newvalue
1000 loops, best of 3: 73.6 ms per loop
&gt;&gt;&gt; %timeit np.concatenate((x[1:], np.array(newvalue).reshape(1,)), axis=0) 
1 loop, best of 3: 339 ms per loop
</code></pre>
<p>But if you don't need to have a fast access to all values in the array, but only the first or last ones, using a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noreferrer"><code>deque</code></a> is smarter.</p>
</div>
<span class="comment-copy">Note: this is <i>not</i> the same question as in <a href="https://stackoverflow.com/questions/30262736/fastest-way-to-shift-a-numpy-array" title="fastest way to shift a numpy array">stackoverflow.com/questions/30262736/…</a></span>
<span class="comment-copy">The 'naive' version looks good to me.  Why should there be something faster?  You have to copy values, either to a new array or itself.  When I test your code on <code>x=np.arange(100000)</code> I get times like <code>21.5 µs per loop</code>.  That looks fast to me.</span>
<span class="comment-copy">There's no way to do this without copying the contents of the array, so I don't think you can do better than the "naive" approach. If this is a bottleneck then you might want to consider using a different datastructure, e.g. a <a href="https://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a>, where the push-and-pop operation does not require a copy and can be done in constant time.</span>
<span class="comment-copy">OK, thanks for your replies, that was my intuition also. I am trying with a deque instead.</span>
<span class="comment-copy">Oh, in fact in the algorithm, not only <code>X[0]</code> and <code>X[1]</code> are needed, but also a value in the middle of the array, so a <code>deque</code> is useless. Sorry! Thanks anyway for your replies!</span>
