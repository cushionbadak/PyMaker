<div class="post-text" itemprop="text">
<p>I have two lists (listA, listB), each composed of many list of tuples. </p>
<p>E.g. </p>
<pre><code>listA = [ [(0,1), (1,2) ... ] , [(5,6), (6,10)] , ... ] # can have 5000 lists, each with 100+ tuples
listB = [...] # about the same structure
</code></pre>
<p>I want to loop over each list in listA, if it is not in listB, I append it to listB.</p>
<p>So it is something like this:</p>
<pre><code>for lst in listA:
    if lst not in listB: # membership checking
        listB.append(lst)
</code></pre>
<p>I have hundreds of thousands of such tasks to perform and it seems to be really slow when listA and listB get bigger. The membership checking seems to be the bottleneck here. I've tried using a string '0-1' instead of a tuple of ints, but it is not getting any faster. Does anyone know how to optimize the code? Is list membership checking really slow?</p>
<p>Any help is greatly appreciated. Thanks!</p>
<p>------------- EDIT: this is what I end up using -------------</p>
<p>Thank you, guys. Converting nested lists to tuples and using set works! But have to be careful when looping over listA, each nested list also has to be converted to a tuple (but just for membership checking!). I still need to append the nested list as a list to listB. That is:</p>
<pre><code># first convert listB to a set of tuples
listB_as_set = set([tuple(x) for x in listB]) # O(N)

for lst in listA:
    # convert the nested list to tuple
    lst_tuple = tuple(lst)
    # membership checking
    if lst_tuple in listB_as_set: # now O(1), originally O(N)
        listB.append(lst) # still appending as a list to listB
</code></pre>
<p>Assuming both lists have length N, and ignoring the time for converting lst to lst_tuple, and append lst to listB, we got an improvement from <code>O(N2)</code> to <code>O(N)</code>, if I'm not mistaken.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you would like store values in order to check for their existence,<strong>sets</strong> are significantly faster.
So you can try this,and then use the for loop,it will be faster than list.</p>
<pre><code>listAï¼ŒlistB = set(listA),set(listB)
</code></pre>
<p>That is becaus <code>set</code> uses a hash function to map to a bucket. Since Python implementations automatically resize that hash table, the speed can be constant <code>O(1)</code>.</p>
<p><code>Sets</code> are significantly faster when it comes to determining if an object i in a set , bu slower than <code>lists</code> when it comes to <strong>iterating</strong> over their contents.</p>
<hr/>
<p>If you're using nested list,you can try</p>
<pre><code>listA = [[(0, 1), (1, 2)], [(5, 6), (6, 10)]]
listA = { tuple(i) for i in listA}
</code></pre>
<p>Or </p>
<pre><code>listA = {frozenset(i) for i in listA} 
</code></pre>
<p><a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer">frozenset</a> type is immutable and hashable,so </p>
<pre><code>frozenset([(0, 1), (1, 2)]) = frozenset([(1,2),(0,1)])
</code></pre>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>The way you are doing it now, it's a O(N^2) operation because of the nature of lists. But if you use sets, it because approximate O(n+m) see here for details: <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">https://wiki.python.org/moin/TimeComplexity</a></p>
<p>So the approach is</p>
<pre><code>a = set(lista)
b = set(listb)

b.union(lista)
</code></pre>
<p>Just three lines of code and much faster too. A good poin raised by AChampion about uhashable lists. In that case</p>
<pre><code>a = set([ tuple(x) for x in listA ])
</code></pre>
<p>would work.</p>
</div>
<span class="comment-copy">List membership is <code>O(n)</code>, if you don't care about ordering, then considering converting the nested lists to <code>tuple</code> and using <code>set</code>s. Sets are <code>O(1)</code> for membership checks.</span>
<span class="comment-copy">@AChampion The ordering of the lists in listA/listB doesn't matter, but for each nested list, it has to be (0,1), (1,2), ... I see. So I'll try converting the nested lists into tuples and see the results. Thanks!</span>
<span class="comment-copy">You would only need to convert <code>listB</code>.</span>
<span class="comment-copy">That's true! but in the loop i still have to convert nested list to tuples for membership checking.</span>
<span class="comment-copy">Wouldn't you get unhashable type error, because of the nested lists.</span>
<span class="comment-copy">@McGrady Thanks! but when you do list comprehension, wouldn't it be [] not {}? Also it might be better if I only convert things in listA to a tuple while looping over it, as I added in the post.</span>
<span class="comment-copy"><code>{...}</code> is a set comprehension. You need it to be a <code>set</code> for the <code>O(1)</code> performance. Doing this to <code>listB</code> is required. Doing it to both allows you to use <code>set</code> operations, e.g. <code>union</code>.</span>
<span class="comment-copy">@AChampion Ah I see. My bad. Would union be faster than using the for loops?</span>
<span class="comment-copy">Wouldn't you get unhashable type error, because of the nested lists.</span>
<span class="comment-copy">Good point. I think the update addresses that</span>
<span class="comment-copy">This is clear and simple! I also changed the nested lists into tuples before this step so it's much faster now.</span>
<span class="comment-copy">Glad to know. The usual form here at stackoverflow is to accept one of the answers rather than editing your question to include content from the answers :-)</span>
