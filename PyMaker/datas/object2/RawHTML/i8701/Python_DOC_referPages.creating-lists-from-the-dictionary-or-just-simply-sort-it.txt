<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>import os
import pprint

file_path = input("Please, enter the path to the file: ")
if os.path.exists(file_path):
    worker_dict = {}
    k = 1
    for line in open(file_path,'r'):
        split_line = line.split()
        worker = 'worker{}'.format(k)
        worker_name = '{}_{}'.format(worker, 'name')
        worker_yob = '{}_{}'.format(worker, 'yob')
        worker_job = '{}_{}'.format(worker, 'job')
        worker_salary = '{}_{}'.format(worker, 'salary')
        worker_dict[worker_name] = ' '.join(split_line[0:2])
        worker_dict[worker_yob] = ' '.join(split_line[2:3])
        worker_dict[worker_job] = ' '.join(split_line[3:4])
        worker_dict[worker_salary] = ' '.join(split_line[4:5])
        k += 1
else:
    print('Error: Invalid file path')
</code></pre>
<p>File:</p>
<pre><code>John Snow 1967 CEO 3400$ 
Adam Brown 1954 engineer 1200$
</code></pre>
<p>Output from worker_dict:</p>
<pre><code>{
 'worker1_job': 'CEO',
 'worker1_name': 'John Snow',
 'worker1_salary': '3400$',
 'worker1_yob': '1967',
 'worker2_job': 'engineer',
 'worker2_name': 'Adam Brown',
 'worker2_salary': '1200$',
 'worker2_yob': '1954',
}
</code></pre>
<p>And I want to sort data by worker name and after that by salary. So my idea was to create a separate list with salaries and worker names to sort. But I have problems with filling it, maybe there is a more elegant way to solve my problem?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import pprint

file_path = input("Please, enter the path to the file: ")
if os.path.exists(file_path):
    worker_dict = {}
    k = 1
    with open(file_path,'r') as file:
        content=file.read().splitlines()
    res=[]
    for i in content:
        val = i.split()
        name = [" ".join([val[0],val[1]]),]#concatenate first name and last name
        i=name+val[2:] #prepend name
        res.append(i) #append modified value to new list
    res.sort(key=lambda x: x[3])#sort by salary
    print res
    res.sort(key=lambda x: x[0])#sort by name
    print res
</code></pre>
<p>Output:</p>
<pre><code>[['Adam Brown', '1954', 'engineer', '1200$'], ['John Snow', '1967', 'CEO', '3400$']]
[['Adam Brown', '1954', 'engineer', '1200$'], ['John Snow', '1967', 'CEO', '3400$']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d = {
 'worker1_job': 'CEO',
 'worker1_name': 'John Snow',
 'worker1_salary': '3400$',
 'worker1_yob': '1967',
 'worker2_job': 'engineer',
 'worker2_name': 'Adam Brown',
 'worker2_salary': '1200$',
 'worker2_yob': '1954',
}

from itertools import zip_longest

#re-group: 
def grouper(iterable, n, fillvalue=None):
      "Collect data into fixed-length chunks or blocks"
       # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
       args = [iter(iterable)] * n
       return zip_longest(*args, fillvalue=fillvalue)

#re-order: 
res = []
for group in list(grouper(d.values(), 4)):
          reorder = [1,2,0,3]
          res.append([ group[i] for i in reorder])

#sort:
res.sort(key=lambda x: (x[1], x[2]))
</code></pre>
<p>output: </p>
<pre><code>[['Adam Brown', '1200$', 'engineer', '1954'],
 ['John Snow', '3400$', 'CEO', '1967']]
</code></pre>
<p>Grouper is defined and explained in itertools. I've grouped your dictionary by records pertaining to each worker, returned it as a reordered list of lists. As lists, I sort them by the name and salary. This is solution is modular: it distinctly groups, re-orders and sorts.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend to store the workers in a different format, for example <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">.csv</a>, then you could use <code>csv.DictReader</code> and put it into a list of dictionaries (this would also allow you to use jobs, names, etc. with more words like "tomb raider"). </p>
<p>Note that you have to convert the year of birth and salary to ints or floats to sort them correctly, otherwise they would get sorted lexicographically as in a real world dictionary (book) because they are strings, e.g.:</p>
<pre><code>&gt;&gt;&gt; sorted(['100', '11', '1001'])
['100', '1001', '11']
</code></pre>
<p>To sort the list of dicts you can use <code>operator.itemgetter</code> as the key argument of <code>sorted</code>, instead of a lambda function, and just pass the desired key to itemgetter. </p>
<p>The <code>k</code> variable is useless, because it's just the <code>len</code> of the list. </p>
<p>The .csv file:</p>
<pre><code>"name","year of birth","job","salary"
John Snow,1967,CEO,3400$
Adam Brown,1954,engineer,1200$
Lara Croft,1984,tomb raider,5600$
</code></pre>
<p>The .py file:</p>
<pre><code>import os
import csv
from operator import itemgetter
from pprint import pprint


file_path = input('Please, enter the path to the file: ')
if os.path.exists(file_path):
    with open(file_path, 'r', newline='') as f:
        worker_list = list(csv.DictReader(f))
        for worker in worker_list:
            worker['salary'] = int(worker['salary'].strip('$'))
            worker['year of birth'] = int(worker['year of birth'])

    pprint(worker_list)
    pprint(sorted(worker_list, key=itemgetter('name')))
    pprint(sorted(worker_list, key=itemgetter('salary')))
    pprint(sorted(worker_list, key=itemgetter('year of birth')))
</code></pre>
<p>You still need some error handling, if a int conversion fails, or just let the program crash.</p>
</div>
<span class="comment-copy">Make a list of dicts with <code>{'job': 'CEO', 'name': â€¦}</code> instead? You can also use class instances instead of dicts.</span>
<span class="comment-copy">Also, take a look at <a href="http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/" rel="nofollow noreferrer">Falsehoods Programmers Believe About Names</a>. :)</span>
