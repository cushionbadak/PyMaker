<div class="post-text" itemprop="text">
<p>Trying to fix a friends code where the loop doesn't continue until a for loop is satisfied.  I feel it is something wrong with the readbuffer.  Basically, we want the while loop to loop continuously, but if the for loop is satisfied run that.  Is someone could help me understand what is happening in the readbuffer and temp, I'd be greatly thankful.</p>
<p>Here's the snippet: </p>
<pre><code>s = openSocket()
joinRoom(s)
readbuffer = ""
while True:
        readbuffer = readbuffer + s.recv(1024)
        temp = string.split(readbuffer, "\n")
        readbuffer = temp.pop()
        for line in temp:
            user = getUser(line)
            message = getMessage(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Base on my understanding to your question, you want to execute the for loop while continues to receive packets. </p>
<p>I'm not sure what you did in <code>getUser</code> and <code>getMessage</code>, if there are I/O operations (read/write files, DB I/O, send/recv ...) in them you can use <code>async</code> feature in python to write asynchronous programs. (See: <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-task.html</a>)</p>
<p>I assume, however, you are just extracting a single element from <code>line</code>, which involves no I/O operations. In that case, <code>async</code> won't help. If <code>getUser</code> and <code>getMessage</code> really take too much CPU time, you can put the for loop in a new thread, making string operations non-blocking. (See: <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">https://docs.python.org/3/library/threading.html</a>)</p>
<pre><code>from threading import Thread

def getUserProfile(lines, profiles, i):
    for line in lines:
        user = getUser(line)
        message = getMessage(line)
        profiles.append((user, message))


profiles = []
threads = []
s = openSocket()
joinRoom(s)

while True:
    readbuffer = s.recv(1024)
    lines = readbuffer.decode('utf-8').split('\n')
    t = Thread(target=getUserProfile, args=(lines, profiles, count))
    t.run()
    threads.append(t)



# If somehow the loop may be interrupted, 
# These two lines should be added to wait for all threads to finish
for th in threads:
  th.join() # will block main thread until all threads are terminated
</code></pre>
<hr/>
<p><strong>Update</strong></p>
<p>Of course this is not a typical way to solve this issue, it's just easier to understand for beginners, and for simple assignments.</p>
<p>One better way is to use something like <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer">Future</a>, making send/recv asynchronous, and pass a callback to it so that it can pass the received data to your callback. If you want to move heavy CPU workload to another thread create an endless loop(routine), just create a <code>Thread</code> in callback or somewhere else, depending on your architecture design.</p>
<p>I implemented a lightweight <a href="https://github.com/j0e1in/Distrpy/" rel="nofollow noreferrer">distributed computing framework</a> for my network programming course. And I wrote my own <a href="https://github.com/j0e1in/Distrpy/blob/master/src/distrpy/server/master.py#L276-L307" rel="nofollow noreferrer">future class</a> for the project if anyone is interested.</p>
</div>
<span class="comment-copy">Could you give us a context and the full code so we can better understand what you mean?</span>
<span class="comment-copy">If you want a line-buffered (and blocking) socket, thereâ€™s <a href="https://docs.python.org/3/library/socket.html#socket.socket.makefile" rel="nofollow noreferrer"><code>socket.makefile</code></a>.</span>
<span class="comment-copy">Just edited more into it.  Sorry I forgot some variables at the top</span>
<span class="comment-copy">Thanks for the answer J0e1in!  To the best of my knowledge, wouldn't this stop after reading 100 times?</span>
<span class="comment-copy">Yes, because it is required to give threads the exact memory position (reference) to store their data in a shared memory (the <code>profiles</code> list), you need to allocate a fixed-size list beforehand. So if the number of profiles exceeds the allocated memory size it should be stopped.</span>
<span class="comment-copy">@Dug I added some comment to the bottom of the post. Upvote if this helps, thank you.</span>
<span class="comment-copy">Hey @J0e1in     I tried your beginner solution and could not get it to take "lines" as an argument.  I also have another question:  So recv stops it from going until it receives something (right?), is there another receive function or method to make it use receive if something is sent? else, continue on with the loop?</span>
<span class="comment-copy">@Dug Sorry, I copied directly from your code without testing. I've done some tweak and tested it. And I discovered that in using python Thread class you can use <code>list.append</code>, which is unexpected for me. (I learned low-level threading programming in pure C.) This means you can store as many profiles as you like, and listen to the connection forever.</span>
