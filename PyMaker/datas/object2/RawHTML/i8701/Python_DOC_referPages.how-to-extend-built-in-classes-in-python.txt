<div class="post-text" itemprop="text">
<p>I'm writing some code for an esp8266 micro controller using micro-python and it has some different class as well as some additional methods in the standard built in classes.  To allow me to debug on my desktop I've built some helper classes so that the code will run.  However I've run into a snag with micro-pythons time function which has a time.sleep_ms method since the standard time.sleep method on micropython does not accept floats.  I tried using the following code to extend the built in time class but it fails to import properly.  Any thoughts?</p>
<pre><code>class time(time):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def sleep_ms(self, ms):
        super().sleep(ms/1000)
</code></pre>
<p>This code exists in a file time.py.  Secondly I know I'll have issues with having to import time.time that I would like to fix.  I also realize I could call this something else and put traps for it in my micro controller code however I would like to avoid any special functions in what's loaded into the controller to save space and cycles.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not trying to override a class, you're trying to monkey-patch a module.</p>
<p>First off, if your module is named <code>time.py</code>, it will never be loaded in preference to the built-in <code>time</code> module. Truly built-in (as in compiled into the interpreter core, not just C extension modules that ship with CPython) modules are special, <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">they are always loaded without checking <code>sys.path</code></a>, so you can't even attempt to shadow the <code>time</code> module, even if you wanted to (you generally don't, and doing so is incredibly ugly). In this case, the built-in <code>time</code> module shadows you; you can't import your module under the plain name <code>time</code> at all, because the built-in will be found without even looking at <code>sys.path</code>.</p>
<p>Secondly, assuming you use a different name and import it for the sole purpose of monkey-patching time (or do something terrible like adding the monkey patch to a <a href="https://docs.python.org/3/library/site.html" rel="nofollow noreferrer">custom <code>sitecustomize</code> module</a>, it's not trivial to make the function truly native to the monkey-patched module (defining it in any normal way gives it a scope of the module where it was defined, not the same scope as other functions from the <code>time</code> module). If you don't need it to be "truly" defined as part of <code>time</code>, the simplest approach is just:</p>
<pre><code>import time

def sleep_ms(ms):
    return time.sleep(ms / 1000)

time.sleep_ms = sleep_ms
</code></pre>
<p>Of course, as mentioned, <code>sleep_ms</code> is still part of your module, and carries your module's scope around with it (that's why you do <code>time.sleep</code>, not just <code>sleep</code>; you could do <code>from time import sleep</code> to avoid qualifying it, but it's still a local alias that might not match <code>time.sleep</code> if someone else monkey-patches <code>time.sleep</code> later).</p>
<p>If you want to make it behave like it's part of the <code>time</code> module, so you can reference arbitrary things in <code>time</code>'s namespace without qualification and always see the current function in <code>time</code>, you need to use <code>eval</code> to compile your code in <code>time</code>'s scope:</p>
<pre><code>import time

# Compile a string of the function's source to a code object that's not
# attached to any scope at all
# The filename argument is garbage, it's just for exception traceback
# reporting and the like
code = compile('def sleep_ms(ms): sleep(ms / 1000)', 'time.py', 'exec')

# eval the compiled code with a scope of the globals of the time module
# which both binds it to the time module's scope, and inserts the newly
# defined function directly into the time module's globals without
# defining it in your own module at all
eval(code, vars(time))

del code, time  # May as well leave your monkey-patch module completely empty
</code></pre>
</div>
<span class="comment-copy"><i>"This code exists in a file time.py"</i> - well there's one problem, you're shadowing the actual module you're trying to extend a class from. Give your class and module distinct names, to make it clear it's a custom version.</span>
<span class="comment-copy">The built-in <code>time</code> is a module, not a class. There is no class to inherit from.</span>
<span class="comment-copy">As the paragraph after the code states I don't want it to be distinct I want it to be ubiquitous with the time module</span>
<span class="comment-copy">I stand corrected its a module not a class.  Is there a way to do it though?</span>
<span class="comment-copy">@jonrsharpe: Actually, true built-in modules (stuff that's baked into the interpreter core exe or dll/so depending on how its built, not just C extension modules that ship with the interpreter, e.g. <code>time</code>, <code>sys</code>) are special; <a href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="nofollow noreferrer">they're not subject to name shadowing, because importing them bypasses <code>sys.path</code></a>. Of course, this means the built-in is shadowing the OP's <code>time.py</code>, so the end result is similar, just in reverse.</span>
<span class="comment-copy">So using your first set of code I placed that in a file called myTime.py and then placed <code>try: from myTime import time except ImportError: import time</code> which works I was just hoping to avoid having special hooks in my controller although from what you're saying it doesn't sound like there is another way.  In any case this isn't a terrible amount of overhead and only occurs once at startup.</span>
