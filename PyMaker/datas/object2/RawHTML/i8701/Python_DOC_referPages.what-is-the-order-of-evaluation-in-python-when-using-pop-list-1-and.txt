<div class="post-text" itemprop="text">
<pre><code>a = [1, 2, 3]
a[-1] += a.pop()
</code></pre>
<p>This results in <code>[1, 6]</code>.</p>
<pre><code>a = [1, 2, 3]
a[0] += a.pop()
</code></pre>
<p>This results in <code>[4, 2]</code>. What order of evaluation gives these two results?</p>
</div>
<div class="post-text" itemprop="text">
<p>RHS first and then LHS. And at any side, the evaluation order is left to right.</p>
<p><code>a[-1] += a.pop()</code> is same as, <code>a[-1] = a[-1] + a.pop()</code></p>
<pre><code>a = [1,2,3]
a[-1] = a[-1] + a.pop() # a = [1, 6]
</code></pre>
<p>See how the behavior changes when we change the order of the operations at RHS,</p>
<pre><code>a = [1,2,3]
a[-1] = a.pop() + a[-1] # a = [1, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The key insight is that <code>a[-1] += a.pop()</code> is syntactic sugar for <code>a[-1] = a[-1] + a.pop()</code>. This holds true because <code>+=</code> is being applied to an immutable object (an <code>int</code> here) rather than a mutable object (<a href="https://stackoverflow.com/questions/15376509/when-is-i-x-different-from-i-i-x-in-python">relevant question here</a>).</p>
<p>The right hand side (RHS) is evaluated first. On the RHS: equivalent syntax is <code>a[-1] + a.pop()</code>. First, <code>a[-1]</code> gets the last value <code>3</code>. Second, <code>a.pop()</code> <code>return</code>s <code>3</code>.
<code>3</code> + <code>3</code> is <code>6</code>.</p>
<p>On the Left hand side (LHS), <code>a</code> is now <code>[1,2]</code> due to the in-place mutation already applied by <code>list.pop()</code> and so the value of <code>a[-1]</code> is changed from <code>2</code> to <code>6</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's have a look at the output of <a href="https://docs.python.org/3/library/dis.html#dis.dis" rel="noreferrer"><code>dis.dis</code></a> for <code>a[-1] += a.pop()</code><sup>1)</sup>:</p>
<pre><code>3    15 LOAD_FAST            0 (a)                             # a,
     18 LOAD_CONST           5 (-1)                            # a, -1
     21 DUP_TOP_TWO                                            # a, -1, a, -1
     22 BINARY_SUBSCR                                          # a, -1, 3
     23 LOAD_FAST            0 (a)                             # a, -1, 3, a
     26 LOAD_ATTR            0 (pop)                           # a, -1, 3, a.pop
     29 CALL_FUNCTION        0 (0 positional, 0 keyword pair)  # a, -1, 3, 3
     32 INPLACE_ADD                                            # a, -1, 6
     33 ROT_THREE                                              # 6, a, -1
     34 STORE_SUBSCR                                           # (empty)
</code></pre>
<p>The meaning of the different instructions is listed <a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions" rel="noreferrer">here</a>.</p>
<p>First, <code>LOAD_FAST</code> and <code>LOAD_CONST</code> load <code>a</code> and <code>-1</code> onto the stack, and <code>DUP_TOP_TWO</code> duplicates the two, before <code>BINARY_SUBSCR</code> gets the subscript value, resulting in <code>a, -1, 3</code> on the stack. It then loads <code>a</code> again, and <code>LOAD_ATTR</code> loads the <code>pop</code> function, which is called with no arguments by <code>CALL_FUNCTION</code>. The stack is now <code>a, -1, 3, 3</code>, and <code>INPLACE_ADD</code> adds the top two values. Finally, <code>ROT_THREE</code> rotates the stack to <code>6, a, -1</code> to match the order expected by <code>STORE_SUBSCR</code> and the value is stored.</p>
<p>So, in short, the current value of <code>a[-1]</code> is evaluated before calling <code>a.pop()</code> and the result of the addition is then stored back to the new <code>a[-1]</code>, irrespective of its current value.</p>
<hr/>
<p><sup>1)</sup>  This is the disassembly for Python 3, slightly compressed to better fit on the page, with an added column showing the stack after <code># ...</code>; for Python 2 it looks a bit different, but similar.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using a thin wrapper around a list with debugging print-statements can be used to show the order of evaluation in your cases:</p>
<pre><code>class Test(object):
    def __init__(self, lst):
        self.lst = lst

    def __getitem__(self, item):
        print('in getitem', self.lst, item)
        return self.lst[item]

    def __setitem__(self, item, value):
        print('in setitem', self.lst, item, value)
        self.lst[item] = value

    def pop(self):
        item = self.lst.pop()
        print('in pop, returning', item)
        return item
</code></pre>
<p>When I now run your example:</p>
<pre><code>&gt;&gt;&gt; a = Test([1, 2, 3])
&gt;&gt;&gt; a[-1] += a.pop()
in getitem [1, 2, 3] -1
in pop, returning 3
in setitem [1, 2] -1 6
</code></pre>
<p>So it starts by getting the last item, which is 3, then pops the last item which is also 3, adds them and overwrites the last item of your list with <code>6</code>. So the final list will be <code>[1, 6]</code>.</p>
<p>And in your second case:</p>
<pre><code>&gt;&gt;&gt; a = Test([1, 2, 3])
&gt;&gt;&gt; a[0] += a.pop()
in getitem [1, 2, 3] 0
in pop, returning 3
in setitem [1, 2] 0 4
</code></pre>
<p>This now takes the first item (<code>1</code>) adds it to the popped value (<code>3</code>) and overwrites the first item with the sum: <code>[4, 2]</code>.</p>
<hr/>
<p>The general order of evaluation is already explained by <a href="https://stackoverflow.com/a/42762005/5393381"><code>@Fallen</code></a> and <a href="https://stackoverflow.com/a/42762281/5393381"><code>@tobias_k</code></a>. This answer just supplements the general principle mentioned there.</p>
</div>
<div class="post-text" itemprop="text">
<p>For you specific example</p>
<pre><code>a[-1] += a.pop() #is the same as 
a[-1] = a[-1] + a.pop() # a[-1] = 3 + 3
</code></pre>
<p>Order:</p>
<ol>
<li>evaluate <code>a[-1]</code> after <code>=</code></li>
<li><code>pop()</code>, decreasing the length of <code>a</code></li>
<li>addition</li>
<li>assignment</li>
</ol>
<p>The thing is, that <code>a[-1]</code> becomes the value of <code>a[1]</code> (was <code>a[2]</code>) after the <code>pop()</code>, but this happens before the assignment. </p>
<pre><code>a[0] = a[0] + a.pop() 
</code></pre>
<p>Works as expected</p>
<ol>
<li>evaluate <code>a[0]</code> after <code>=</code></li>
<li><code>pop()</code></li>
<li>addition</li>
<li>assignment</li>
</ol>
<p>This example shows, why you shouldn't manipulate a list while working on it (commonly said for loops). Always work on copys in this case.</p>
</div>
<span class="comment-copy">@tobias_k Take the first example. a.pop() returns 3 and changes a to [1,2]. Now evaluate a[-1] = a[-1] + 3 and you get 5, not 6.</span>
<span class="comment-copy">@felipa My guess it that Python first translates the <code>a[-1] += a.pop()</code> to <code>a[-1] = a[-1] + a.pop()</code>. That is why you get the <code>6</code>. <code>a[-1]</code> is evaluated before the <code>a.pop()</code>. If you change it to <code>a[-1] = a.pop() + a[-1]</code> you get <code>5</code></span>
<span class="comment-copy">Despite the multiple comments on this page appearing to suggest the contrary, please note that in general <code>a += b</code> is not the same as <code>a = a + b</code> and is not guaranteed to be translated as such by Python. Different methods are invoked. Whether or it boils down too the same thing depends on the types of the operands.</span>
<span class="comment-copy">@Chris_Rands: I tried to phrase my comment carefully to say that the two were not equivalent "in general" and that it depends on the objects: I agree it's reasonable enough here. (But on a another note, I'm not sure that the fact that  <code>+</code> and <code>+=</code> operators are equivalent for integers is key to answering this question: the general result would be the same if different objects were involved. I think the evaluation order is the main point.)</span>
<span class="comment-copy">PSA: <b>Never write code that relies on these kinds of details.</b> Even if it works, it's not good code. If you isolate side effects on their own line (This amounts approximately to one state modification per line.), reading and modifying your code will be a lot easier. In this case, you should do <code>a = [1, 2, 3]; temp = a.pop(); a[-1] = 2 * temp</code> or <code>a = [1, 2, 3]; temp = a.pop(); a[-1] += temp</code>, depending on what you meant to do. This makes your <i>intended</i> order of evaluation explicit, and it's easier to get right.</span>
<span class="comment-copy">"at the RHS, it's left to right" Fun fact: While the operators are of course evaluated w.r.t. operator precedence, the actual expressions apparently are not, e.g. in <code>f() + g() * h()</code>, the functions are evaluated in order f, then g, then h. For instance, <code>a.pop() + a.pop() * a.pop()</code> with <code>a = [3, 2, 1]</code> yields <code>7</code> (1 + 2 * 3)</span>
<span class="comment-copy">@tobias_k well, the * operator is evaluated before the + operator. It may be helpful to consider the function call to be another operator with higher precedence than *.</span>
<span class="comment-copy">@Random832 That part is clear; what stumped me was that in (a+(b+(c+(d+(...)))), a is evaluated first, then b, etc. But I guess that's just my "human" perspective, as I would visually parse the expression and determine the innermost part to evaluate that first, so I don't have to keep as much "in memory" (literally). A computer, of course, can just evaluate the expression left to right and push the intermediate results onto a stack. Still though this worth pointing out, as others might have the same wrong intuition.</span>
<span class="comment-copy">@tobias_k: Lots of languages <a href="https://blogs.msdn.microsoft.com/oldnewthing/20070814-00/?p=25593" rel="nofollow noreferrer">do this</a>, with the notable exception of C and C++.</span>
<span class="comment-copy">@Rob <code>a[-1]</code> is evaluated before the value is popped off, giving a value of <code>3</code>. Then the <code>pop</code> occurs also giving a value of <code>3</code>. Thus the math is <code>3+3</code>. This is because on the RHS we work left-to-right evaluating each part by itself then dealing with the math.</span>
<span class="comment-copy">a[-1] += a.pop() is shorthand for a[-1] = a[-1] + a.pop() is only true because <code>a</code> is a list of ints, I have now learned. It's worth mentioning.</span>
<span class="comment-copy">@felipa Ok, yes I've added an edit, note if <code>a</code> was a list of strings or tuples, it would also behave the same as the integer case (it's only different for mutable objects)</span>
<span class="comment-copy">Cool thing with <code>dis.dis</code>, didn't know this one!</span>
