<div class="post-text" itemprop="text">
<p>I'm learning about working with streams in Python and I noticed that the <a href="https://docs.python.org/3/library/io.html" rel="noreferrer">IO docs</a> say the following:</p>
<blockquote>
<p>The easiest way to create a binary stream is with open() with 'b' in the mode string:</p>
<p><code>f = open("myfile.jpg", "rb")</code></p>
<p>In-memory binary streams are also available as BytesIO objects:</p>
<p><code>f = io.BytesIO(b"some initial binary data: \x00\x01")</code></p>
</blockquote>
<p>What is the difference between <code>f</code> as defined by <code>open</code> and <code>f</code> as defined by <code>BytesIO</code>. In other words, what makes a "In-memory binary stream" and how is that different from what <code>open</code> does?</p>
</div>
<div class="post-text" itemprop="text">
<p>For simplicity's sake, let's consider writing instead of reading for now.</p>
<p>So when you use <code>open()</code> like say:</p>
<pre><code>with open("test.dat", "wb") as f:
    f.write(b"Hello World")
    f.write(b"Hello World")
    f.write(b"Hello World")
</code></pre>
<p>After executing that a file called <code>test.dat</code> will be created, containing <code>Hello World</code>. The data wont be kept in memory after it's written to the file (unless being kept by a name).</p>
<p>Now when you consider <code>io.BytesIO()</code> instead:</p>
<pre><code>with io.BytesIO() as f:
    f.write(b"Hello World")
    f.write(b"Hello World")
    f.write(b"Hello World")
</code></pre>
<p>Which instead of writing the contents to a file, it's written to an in memory buffer. In other words a chunk of RAM. Essentially writing the following would be the equivalent:</p>
<pre><code>buffer = b""
buffer += b"Hello World"
buffer += b"Hello World"
buffer += b"Hello World"
</code></pre>
<p><em>In relation to the example with the with statement, then at the end there would also be a <code>del buffer</code>.</em></p>
<p>The key difference here is optimization and performance. <code>io.BytesIO</code> is able to do some optimizations that makes it faster than simply concatenating all the <code>b"Hello World"</code> one by one.</p>
<p>Just to prove it here's a small benchmark:</p>
<ul>
<li>Concat:  1.3529 seconds</li>
<li>BytesIO: 0.0090 seconds</li>
</ul>
<p></p>
<pre><code>import io
import time

begin = time.time()
buffer = b""
for i in range(0, 50000):
    buffer += b"Hello World"
end = time.time()
seconds = end - begin
print("Concat:", seconds)

begin = time.time()
buffer = io.BytesIO()
for i in range(0, 50000):
    buffer.write(b"Hello World")
end = time.time()
seconds = end - begin
print("BytesIO:", seconds)
</code></pre>
<p>Besides the performance gain, using <code>BytesIO</code> instead of concatenating has the advantage that <code>BytesIO</code> can be used in place of a file object. So say you have a function that expects a file object to write to. Then you can give it that in-memory buffer instead of a file.</p>
<p>The difference is that <code>open("myfile.jpg", "rb")</code> simply loads and returns the contents of <code>myfile.jpg</code>; whereas, <code>BytesIO</code> again is just a buffer containing some data.</p>
<p>Since <code>BytesIO</code> is just a buffer - if you wanted to write the contents to a file later - you'd have to do:</p>
<pre><code>buffer = io.BytesIO()
# ...
with open("test.dat", "wb") as f:
    f.write(buffer.getvalue())
</code></pre>
<p><em>Also, you didn't mention a version; I'm using Python 3. Related to the examples: I'm using the with statement instead of calling <code>f.close()</code></em></p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>open</code> opens a file on your hard drive. Depending on what mode you use, you can read or write (or both) from the disk.</p>
<p>A <code>BytesIO</code> object isn't associated with any real file on the disk. It's just a chunk of memory that behaves like a file does. It has the same API as a file object returned from <code>open</code> (with mode <code>r+b</code>, allowing reading and writing of binary data).</p>
<p><code>BytesIO</code> (and it's close sibling <code>StringIO</code> which is always in text mode) can be useful when you need to pass data to or from an API that expect to be given a file object, but where you'd prefer to pass the data directly. You can load your input data you have into the <code>BytesIO</code> before giving it to the library. After it returns, you can get any data the library wrote to the file from the <code>BytesIO</code> using the <code>getvalue()</code> method. (Usually you'd only need to do one of those, of course.)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>f = open("myfile.jpg", "rb")
</code></pre>
<p>read bytes from file from disk disk and assign such value to object referenced as 'f' which is kept by Python in memory.</p>
<pre><code>f = io.BytesIO(b"some initial binary data: \x00\x01")
</code></pre>
<p>assign bytes stream value to object referenced as 'f' which is kept by Python in memory. </p>
</div>
<span class="comment-copy">Great answer; Question mentions <code>in memory stream</code> and you've referred to <code>in memory buffer</code>. Is there a difference in Python? It would be worth addressing briefly. From an English semantic perspective, <code>stream</code> implies a continuous flow of bits from source to sink (pushing from source), where buffer implies a cache of bits in the source ready for rapid fetching of chunks or pieces from the source (the sink pulling from the source).</span>
<span class="comment-copy">I ran the small benchmark on my machine and got similar result using Python3.5, however, when I use Python 2.7, the "Concat" and "BytesIO" takes similar time, "Concat" is even slightly better. Anything wrong? this makes me confused.</span>
<span class="comment-copy">@Vallentin, sorry, you are wrong when you said "open("myfile.jpg", "rb") simply loads and returns the contents of myfile.jpg", see rhis <code>import io f = open("myfile.jpg", "rb") &lt;class '_io.BufferedReader'&gt; &gt;&gt;&gt; isinstance(f, io.BufferedIOBase) True  </code></span>
