<div class="post-text" itemprop="text">
<p>Is there a data structure/function in Python where each value called is assigned an increasing "id" number</p>
<p>Specifically, the first value entered (e.g., "a") would get id value 0, the next (e.g., "b") would get id 1, and if an earlier one is used (e.g "a" again) it would get the original value (i.e. 0))</p>
<p>At the moment i use the following code, but wondered if it may be a built-in function for this. </p>
<pre><code>maximum_number, all_id_numbers = 0, {}
def return_increasing_id(word):
    global maximum_number
    try:
        return(all_id_numbers[word])
    except KeyError:
        all_id_numbers[word] = maximum_number
        maximum_number = maximum_number +1
        return(all_id_numbers[word])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use defaultdict with your own function passed to it to clean things up a bit.</p>
<p>EDIT thanks to @Rawing. It's very clean now!</p>
<p>EDIT2 thanks to @JonClements it is now a one-liner</p>
<p>CODE:</p>
<pre><code>from collections import defaultdict
from itertools import count

d = defaultdict(lambda n=count(): next(n))

print(d['a'])
print(d['b'])
print(d['c'])

print(d['a'])
print(d['b'])
print(d['c'])
</code></pre>
<p>OUTPUT:</p>
<pre><code>0
1
2
0
1
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use a simple list, and the index as the ID. That way the id is guaranteed to be unique and it's "increasing" like you wanted. I don't see why you'd give yourself headaches trying to make your own ID assignment logic, which could introduce more bugs into your code.</p>
<p>edit: lookup time for a list by index is actually O(1), see: <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">https://wiki.python.org/moin/TimeComplexity</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The Python 3 tutorial, <a href="https://docs.python.org/3/tutorial/introduction.html#lists" rel="nofollow noreferrer">section 3.1.3</a> introduces the List data type as:</p>
<blockquote>
<p>Python knows a number of compound data types, used to group together
  other values. The most versatile is the list, which can be written as
  a list of comma-separated values (items) between square brackets.</p>
</blockquote>
<p>When you create a list in your code what you add a value to a position in a sequence which acts as a key. The dictionary data type, what you are using in your question, lets you assign a key explicitly. </p>
<p>If you would like to create a dictionary of words with the count of appearances in a corpus of text see the example below. </p>
<pre><code>sentence = 'The quick brown fox jumps the brown log'
for word in sentence[i].split(" "):
            word_dict[word] += 1

word_dict = {
 'The': 1, 'quick': 1,  'brown': 2, 'fox': 1,
 'jumps': 1,  'the': 1, 'log': 1}
</code></pre>
<p>While creating a function to push words in a dictionary and increment the counter is a good start, you may want to check out a tutorial for <a href="https://www.kaggle.com/c/word2vec-nlp-tutorial/details/part-1-for-beginners-bag-of-words" rel="nofollow noreferrer">Bag of Words models on Kaggle</a>. The tutorial provides a great overview of other techniques to use when processing text.</p>
</div>
<span class="comment-copy">You mean like a list?</span>
<span class="comment-copy">@jonrsharpe A list wouldn't have a O(1) lookup time though.</span>
<span class="comment-copy">@Rawing not by word, no, but it does by index/id; I guess that's the trade off.</span>
<span class="comment-copy">You could remove the <code>maximum_number</code> variable and use <code>len(all_id_numers)</code> instead. (Assuming you never remove any items from the dict.) That should increase the legibility of this code by a significant bit.</span>
<span class="comment-copy">The short answer is no, that isn't built in as written. If you want <code>O(1)</code> lookup of ID by word, a dictionary is the way to do it. You could use <code>itertools.count</code> as the source of IDs, though, and maybe write a class implementing <code>MutableMapping</code> to make this more reusable.</span>
<span class="comment-copy">Alternatively, you can use <code>defaultdict(itertools.count().__next__)</code>.</span>
<span class="comment-copy">I'd go for: <code>d = defaultdict(lambda n=count(): next(n))</code> instead of <code>__next__</code> as depending on Python version, that might have to be <code>.next()</code> instead...</span>
<span class="comment-copy">@JonClements wow, that's awesome. You should make this into an answer to be accepted</span>
<span class="comment-copy">Lists can convert an index to an object in O(1) time, but <i>finding</i> the index of an object takes O(n) time.</span>
