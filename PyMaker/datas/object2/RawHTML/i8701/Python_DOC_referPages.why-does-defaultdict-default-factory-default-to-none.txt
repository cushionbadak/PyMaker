<div class="post-text" itemprop="text">
<p>You don't have to specify a default factory (but it's the same if you pass <code>None</code> explicitly)</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; defaultdict()
defaultdict(None, {})
&gt;&gt;&gt; defaultdict(None)
defaultdict(None, {})
</code></pre>
<p>Why <code>None</code> though?  Then we get this thing:</p>
<pre><code>&gt;&gt;&gt; dd = defaultdict()
&gt;&gt;&gt; dd[0]
# TypeError: 'NoneType' object is not callable  &lt;-- expected behaviour
# KeyError: 0                                   &lt;-- actual behaviour
</code></pre>
<p>It's even explicitly allowed, because if you try to make a default dict from some other object, <code>defaultdict(0)</code> say, there is a failing check </p>
<pre><code>TypeError: first argument must be callable or None
</code></pre>
<p>I thought something like <code>lambda: None</code> would be a better default factory.  Why is the <code>default_factory</code> optional?  I don't understand the use-case.  </p>
</div>
<div class="post-text" itemprop="text">
<p>When Guido van Rossum <a href="https://mail.python.org/pipermail/python-dev/2006-February/061169.html" rel="nofollow noreferrer">initially proposed a <code>DefaultDict</code></a> that had a <em>default value</em> (unlike the current <code>defaultdict</code> which uses a function rather than a value) that set at during construction and be read-only (also unlike <code>defaultdict</code>).</p>
<p>After some discussion <a href="https://mail.python.org/pipermail/python-dev/2006-February/061261.html" rel="nofollow noreferrer">Guidio revised the proposal</a>.  Here are the relevant highlights:</p>
<blockquote>
<p>Many, many people suggested to use a factory function instead of a
  default value. This is indeed a much better idea (although slightly
  more cumbersome for the simplest cases).</p>
<p>...</p>
<p>Let's add a generic missing-key handling method to the dict class, as
  well as a default_factory slot initialized to <code>None</code>.</p>
<p>...</p>
<p>[T]he default implementation is designed so that we can write</p>
<pre><code>d = {}
d.default_factory = list
</code></pre>
</blockquote>
<p>The important thing to note is that the new functionality no longer belongs to a subclass.  That means that setting the <code>default_factory</code> in the constructor would break existing code.  So by design setting the <code>default_factory</code> had to happen after the <code>dict</code> was created.  It's initial value is set to <code>None</code> and it's now a mutable attribute so that it can be meaningfully overwritten.</p>
<p>After yet more discussion, it was decided that maybe it would be best not to complicate the regular <code>dict</code> type with a <code>defaultdict</code> specialization.  </p>
<p>Steven Bethard then <a href="https://mail.python.org/pipermail/python-dev/2006-February/061532.html" rel="nofollow noreferrer">asked for clarification regarding the constructor</a>:</p>
<blockquote>
<p>Should default_factory be an argument to the constructor?  The three
  answers I see:</p>
<ul>
<li>"No."  I'm not a big fan of this answer.  Since the whole point of creating a defaultdict type is to provide a default, requiring two
  statements (the constructor call and the default_factory assignment)
  to initialize such a dictionary seems a little inconvenient.</li>
<li>"Yes and it should be followed by all the normal dict constructor arguments."  This is okay, but a few errors, like
  <code>defaultdict({1:2})</code> will pass silently (until you try to use the
  dict, of course).</li>
<li>"Yes and it should be the only constructor argument."  This is my favorite mainly because I think it's simple, and I couldn't think of
  good examples where I really wanted to do <code>defaultdict(list,
  some_dict_or_iterable)</code> or <code>defaultdict(list,
  **some_keyword_args)</code>.  It's also forward compatible if we need to add some of the dict constructor args in later.</li>
</ul>
</blockquote>
<p>Guido van Rossum <a href="https://mail.python.org/pipermail/python-dev/2006-February/061558.html" rel="nofollow noreferrer">decided that</a>:</p>
<blockquote>
<p>The defaultdict signature takes an optional positional argument which
  is the default_factory, defaulting to None. The remaining positional
  and all keyword arguments are passed to the dict constructor. IOW:</p>
<pre><code>d = defaultdict(list, [(1, 2)])
</code></pre>
<p>is equivalent to:</p>
<pre><code>d = defaultdict()  
d.default_factory = list  
d.update([(1, 2)])
</code></pre>
</blockquote>
<p>Note that the expanded code mirrors exactly how it worked when Guido was considering altering <code>dict</code> to provide the <code>defaultdict</code> behavior.</p>
<p>He also provides <a href="https://mail.python.org/pipermail/python-dev/2006-February/061485.html" rel="nofollow noreferrer">some justifications upthread</a>:</p>
<blockquote>
<p>Even if the default_factory were passed to the constructor, it still
  ought to be a writable attribute so it can be introspected and
  modified. A defaultdict that can't change its default factory after
  its creation is less useful.</p>
</blockquote>
<p>Bengt Richter <a href="https://mail.python.org/pipermail/python-dev/2006-February/061336.html" rel="nofollow noreferrer">explains why you might want a mutable default factory</a>: </p>
<blockquote>
<p>My guess is that realistically default_factory will be used to make
  clean code for filling a dict, and then turning the factory off if
  it's to be passed into unknown contexts. Those contexts can then use
  old code to do as above, or if worth it can temporarily set a factory
  to do some work. Tightly coupled code I guess could pass
  factory-enabled dicts between each other.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>My guess is that the design is intentional in order to make a <code>defaultdict</code> instance act like a normal dict, by default, whilst allowing the behaviour to be dynamically modified by simple attribute access later on.  </p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; d = defaultdict()
&gt;&gt;&gt; d['k']  # hey I'm just a plain old dict ;) 
KeyError: 'k'
&gt;&gt;&gt; d.default_factory = list
&gt;&gt;&gt; d['L']  # actually, I'm really a defaultdict(list)
[]
&gt;&gt;&gt; d.default_factory = int  # just kidding!  I'm a counter
&gt;&gt;&gt; d['i']
0
&gt;&gt;&gt; d
defaultdict(int, {'L': [], 'i': 0})
</code></pre>
<p>And we can reset it to something that looks like a vanilla dict (which will again raise <code>KeyError</code>), by setting the factory back to <code>None</code>.  </p>
<p>I have yet to find a pattern where this could be useful, but this usage wouldn't be possible if it was forced to instantiate default dict with one callable positional argument.  </p>
</div>
<span class="comment-copy">It seems like it works just like regular dict if you leave the argument as None. Seems reasonable.</span>
<span class="comment-copy">This behavior, including the <code>KeyError</code>, is <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">documented</a>.</span>
<span class="comment-copy">The documentation answers the question of "what happens when you give <code>None</code> to a defaultdict?" but it doesn't answer the question of "why was this behavior implemented in the first place?". I'm pretty puzzled why you would want a defaultdict to ever act like a regular dict. If you want a regular dict, just use <code>dict</code>. I believe OP is wondering the same thing.</span>
<span class="comment-copy">This seem to be related: <a href="http://bugs.python.org/issue1433928" rel="nofollow noreferrer">bugs.python.org/issue1433928</a></span>
<span class="comment-copy">Your guess is correct based on what I could find in python-dev.  See my answer for more.  (I worked way too hard for that useless bit of trivia.)</span>
