<div class="post-text" itemprop="text">
<p>I have made this code, but i don't think it's the best way.</p>
<pre><code>import re
notation = "41*(5.5+6-(8/2^3)-7)-1"
n2 = [x[0] for x in re.findall(r"(\d+(\.\d+)?)",notation)]
n2.reverse()
m = []
x = True

for z in notation:
    if z.isdigit() and x:
        m.append(n2.pop())
        x = False
    if not z.isdigit() and z != ".": 
        m.append(z)
        x = True
</code></pre>
<p>The expected output is:</p>
<blockquote>
<p>m = ['41', '*', '(', '5.5', '+', '6', '-', '(', '8', '/', '2', '^', '3', ')', '-', '7', ')', '-', '1']</p>
</blockquote>
<p>I think this code has a kind of hardcoding, my doubt is how would you make it in a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>using regex findall, you can get your desired result! </p>
<p><strong>Regex:</strong></p>
<pre><code>re.findall('[0-9.]+|.',m)
</code></pre>
<p>therefore,</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; notation  = '41*(5.5+6-(8/2^3)-7)-1'
&gt;&gt;&gt; m = re.findall('[0-9.]+|.',notation )
&gt;&gt;&gt; print m
['41', '*', '(', '5.5', '+', '6', '-', '(', '8', '/', '2', '^', '3', ')', '-', '7', ')', '-', '1']
</code></pre>
<p>If you are specific about your symbols <code>+\-*^/()</code> then you can use</p>
<pre><code>&gt;&gt;&gt; m = re.findall('[0-9.]+|[+\-*^/()]',notation)
&gt;&gt;&gt; print m
['41', '*', '(', '5.5', '+', '6', '-', '(', '8', '/', '2', '^', '3', ')', '-', '7', ')', '-', '1']
</code></pre>
<p>will give you the desired result!</p>
<p>Hope it helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one way to do it with <a href="https://docs.python.org/3/library/re.html#re.finditer" rel="nofollow noreferrer"><code>re.finditer</code></a>, with <a href="https://regex101.com/r/pSP2Kg/1" rel="nofollow noreferrer">this</a> <code>re</code> expression:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; m =[]
&gt;&gt;&gt; s = "41*(5.5+6-(8/2^3)-7)-1"
&gt;&gt;&gt; for match in re.finditer(r'[+\-*^/()]|[0-9.]+', s):
        if match:
            m.append(match.group(0))


&gt;&gt;&gt; m
['41', '*', '(', '5.5', '+', '6', '-', '(', '8', '/', '2', '^', '3', ')', '-', '7', ')', '-', '1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><em>re.findall</em></a> with a regex designed to find either <em>numbers</em> or <em>operators</em>.  </p>
<ul>
<li>The number pattern is <code>[0-9.]+</code> which gets all digits and decimal points.</li>
<li>An single-character operator pattern is <code>[*/+\-\^]</code> which gets multiplication, division, addition, subtraction (escaped because <code>-</code> is a special regex character), and exponentation (also escaped because <code>-</code> is a special regex character).</li>
</ul>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; notation = "41*(5.5+6-(8/2^3)-7)-1"
&gt;&gt;&gt; re.findall(r'[0-9.]+|[*/+\-\^]', notation)
['41', '*', '5.5', '+', '6', '-', '8', '/', '2', '^', '3', '-', '7', '-', '1']
</code></pre>
<p>The number pattern can be further refined to look for a maximum of a single decimal place. <code>(?:[0-9]+\.[0-9]+)|(?:[0-9]+\.)|(?:\.?[0-9]+)</code>.  This can parse the numbers in <code>3.14 + 42. + .707 + 6</code>.</p>
<p>To handle multi-character operators, put them first in a chain (to prevent the single character from matching first).  For example, <code>(?:\*\*|\*|/|\+|\-)</code> would parse the operators in <code>2 ** 5 / 6 + 7 * 3 - 1</code>.</p>
<p>Hope this helps you working your lexer experiments :-)</p>
</div>
<span class="comment-copy">The <code>.</code> in the regular expression will catch everything, even non-arithmetic characters, so if your string has for example <code>?</code> or <code>!</code> it will be caught, that's why I purposely made a character class <code>[+\-*^/()]</code>  instead of <code>.</code></span>
<span class="comment-copy">I've added the edit! In the first case, any notation and number will be matched to a list and in the second is restricted to match only the specified ones.</span>
<span class="comment-copy">Excellent answer! I think it looks better like this:  <code>m = [mt.group(0) for mt in re.finditer(r'[+\-*^/()]|([0-9.]+)', s)]</code></span>
<span class="comment-copy">@NapoleónCortés, up to you, I just put it simpler for your understanding, but I'm wondering about the downvote as I don't see any comments? :-O</span>
<span class="comment-copy">I put a +1 vote but my profile doesn't have the level for it to count, I don't know why you got that downvote :O</span>
<span class="comment-copy">thanks! Useful information, the only thing is that I needed also the "()" characters.</span>
<span class="comment-copy">@NapoleónCortés An upvote would be nice.</span>
