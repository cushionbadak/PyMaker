<div class="post-text" itemprop="text">
<p>Here's my code:</p>
<pre><code>def front_back(a, b):
  # +++your code here+++
  if len(a) % 2 == 0 &amp;&amp; len(b) % 2 == 0:
    return a[:(len(a)/2)] + b[:(len(b)/2)] + a[(len(a)/2):] + b[(len(b)/2):] 
  else:
    #todo! Not yet done. :P
  return
</code></pre>
<p>I'm getting an error in the IF conditional. What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You would want <code>and</code> instead of <code>&amp;&amp;</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python uses <code>and</code> and <code>or</code> conditionals.</p>
<p>i.e.</p>
<pre><code>if foo == 'abc' and bar == 'bac' or zoo == '123':
  # do something
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two comments:</p>
<ul>
<li>Use <code>and</code> and <code>or</code> for logical operations in Python.</li>
<li>Use 4 spaces to indent instead of 2.  You will thank yourself later because your code will look pretty much the same as everyone else's code.  See <a href="http://www.python.org/dev/peps/pep-0008/" rel="noreferrer">PEP 8</a> for more details.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I'm getting an error in the IF conditional. What am I doing wrong?</p>
</blockquote>
<p>There reason that you get a <code>SyntaxError</code> is that there is no <code>&amp;&amp;</code> operator in Python. Likewise <code>||</code> and <code>!</code> are <strong>not valid</strong> Python operators. </p>
<p>Some of the operators you may know from other languages have a different name in Python.
The logical operators <code>&amp;&amp;</code> and <code>||</code> are actually called <code>and</code> and <code>or</code>.
Likewise the logical negation operator <code>!</code> is called <code>not</code>.</p>
<p>So you could just write:</p>
<pre><code>if len(a) % 2 == 0 and len(b) % 2 == 0:
</code></pre>
<p>or even:</p>
<pre><code>if not (len(a) % 2 or len(b) % 2):
</code></pre>
<h1>Some additional information (that might come in handy):</h1>
<p>I summarized the operator "equivalents" in this table:</p>
<pre class="lang-none prettyprint-override"><code>+------------------------------+---------------------+
|  Operator (other languages)  |  Operator (Python)  |
+==============================+=====================+
|              &amp;&amp;              |         and         |
+------------------------------+---------------------+
|              ||              |         or          |
+------------------------------+---------------------+
|              !               |         not         |
+------------------------------+---------------------+
</code></pre>
<p>See also <a href="https://docs.python.org/reference/expressions.html#boolean-operations" rel="noreferrer">Python documentation: 6.11. Boolean operations</a>.</p>
<p>Besides the logical operators Python also has bitwise/binary operators:</p>
<pre class="lang-none prettyprint-override"><code>+--------------------+--------------------+
|  Logical operator  |  Bitwise operator  |
+====================+====================+
|        and         |         &amp;          |
+--------------------+--------------------+
|         or         |         |          |
+--------------------+--------------------+
</code></pre>
<p>There is no bitwise negation in Python (just the bitwise inverse operator <code>~</code> - but that is <strong>not</strong> equivalent to <code>not</code>).</p>
<p>See also <a href="https://docs.python.org/3/reference/expressions.html#unary-arithmetic-and-bitwise-operations" rel="noreferrer">6.6. Unary arithmetic and bitwise/binary operations</a> and <a href="https://docs.python.org/reference/expressions.html#binary-arithmetic-operations" rel="noreferrer">6.7. Binary arithmetic operations</a>.</p>
<p>The logical operators (like in many other languages) have the advantage that these are short-circuited.
That means if the first operand already defines the result, then the second operator isn't evaluated at all.</p>
<p>To show this I use a function that simply takes a value, prints it and returns it again. This is handy to see what is actually
evaluated because of the print statements:</p>
<pre><code>&gt;&gt;&gt; def print_and_return(value):
...     print(value)
...     return value

&gt;&gt;&gt; res = print_and_return(False) and print_and_return(True)
False
</code></pre>
<p>As you can see only one print statement is executed, so Python really didn't even look at the right operand.</p>
<p>This is not the case for the binary operators. Those always evaluate both operands:</p>
<pre><code>&gt;&gt;&gt; res = print_and_return(False) &amp; print_and_return(True);
False
True
</code></pre>
<p>But if the first operand isn't enough then, of course, the second operator is evaluated:</p>
<pre><code>&gt;&gt;&gt; res = print_and_return(True) and print_and_return(False);
True
False
</code></pre>
<p>To summarize this here is another Table:</p>
<pre class="lang-none prettyprint-override"><code>+-----------------+-------------------------+
|   Expression    |  Right side evaluated?  |
+=================+=========================+
| `True` and ...  |           Yes           |
+-----------------+-------------------------+
| `False` and ... |           No            |
+-----------------+-------------------------+
|  `True` or ...  |           No            |
+-----------------+-------------------------+
| `False` or ...  |           Yes           |
+-----------------+-------------------------+
</code></pre>
<p>The <code>True</code> and <code>False</code> represent what <code>bool(left-hand-side)</code> returns, they don't have to be <code>True</code> or <code>False</code>, they just need to return <code>True</code> or <code>False</code> when <code>bool</code> is called on them (1).</p>
<p>So in Pseudo-Code(!) the <code>and</code> and <code>or</code> functions work like these:</p>
<pre class="lang-none prettyprint-override"><code>def and(expr1, expr2):
    left = evaluate(expr1)
    if bool(left):
        return evaluate(expr2)
    else:
        return left

def or(expr1, expr2):
    left = evaluate(expr1)
    if bool(left):
        return left
    else:
        return evaluate(expr2)
</code></pre>
<p>Note that this is pseudo-code not Python code. In Python you cannot create functions called <code>and</code> or <code>or</code> because these are keywords. 
Also you should never use "evaluate" or <code>if bool(...)</code>.</p>
<h1>Customizing the behavior of your own classes</h1>
<p>This implicit <code>bool</code> call can be used to customize how your classes behave with <code>and</code>, <code>or</code> and <code>not</code>.</p>
<p>To show how this can be customized I use this class which again <code>print</code>s something to track what is happening:</p>
<pre><code>class Test(object):
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        print('__bool__ called on {!r}'.format(self))
        return bool(self.value)

    __nonzero__ = __bool__  # Python 2 compatibility

    def __repr__(self):
        return "{self.__class__.__name__}({self.value})".format(self=self)
</code></pre>
<p>So let's see what happens with that class in combination with these operators:</p>
<pre><code>&gt;&gt;&gt; if Test(True) and Test(False):
...     pass
__bool__ called on Test(True)
__bool__ called on Test(False)

&gt;&gt;&gt; if Test(False) or Test(False):
...     pass
__bool__ called on Test(False)
__bool__ called on Test(False)

&gt;&gt;&gt; if not Test(True):
...     pass
__bool__ called on Test(True)
</code></pre>
<p>If you don't have a <code>__bool__</code> method then Python also checks if the object has a <code>__len__</code> method and if it returns a value greater than zero. 
That might be useful to know in case you create a sequence container.</p>
<p>See also <a href="https://docs.python.org/library/stdtypes.html?highlight=truth%20value#truth-value-testing" rel="noreferrer">4.1. Truth Value Testing</a>.</p>
<h1>NumPy arrays and subclasses</h1>
<p>Probably a bit beyond the scope of the original question but in case you're dealing with NumPy arrays or subclasses (like Pandas Series or DataFrames) then the implicit <code>bool</code> call
will raise the dreaded <code>ValueError</code>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; arr = np.array([1,2,3])
&gt;&gt;&gt; bool(arr)
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
&gt;&gt;&gt; arr and arr
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()

&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; s = pd.Series([1,2,3])
&gt;&gt;&gt; bool(s)
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
&gt;&gt;&gt; s and s
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
</code></pre>
<p>In these cases you can use the logical and <em>function</em> from NumPy which performs an element-wise <code>and</code> (or <code>or</code>):</p>
<pre><code>&gt;&gt;&gt; np.logical_and(np.array([False,False,True,True]), np.array([True, False, True, False]))
array([False, False,  True, False])
&gt;&gt;&gt; np.logical_or(np.array([False,False,True,True]), np.array([True, False, True, False]))
array([ True, False,  True,  True])
</code></pre>
<p>If you're dealing just with <strong>boolean arrays</strong> you could also use the binary operators with NumPy, these do perform element-wise (but also binary) comparisons:</p>
<pre><code>&gt;&gt;&gt; np.array([False,False,True,True]) &amp; np.array([True, False, True, False])
array([False, False,  True, False])
&gt;&gt;&gt; np.array([False,False,True,True]) | np.array([True, False, True, False])
array([ True, False,  True,  True])
</code></pre>
<hr/>
<p>(1)</p>
<p>That the <code>bool</code> call on the operands has to return <code>True</code> or <code>False</code> isn't completely correct. It's just the first operand that needs to return a boolean in it's <code>__bool__</code> method:</p>
<pre><code>class Test(object):
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        return self.value

    __nonzero__ = __bool__  # Python 2 compatibility

    def __repr__(self):
        return "{self.__class__.__name__}({self.value})".format(self=self)

&gt;&gt;&gt; x = Test(10) and Test(10)
TypeError: __bool__ should return bool, returned int
&gt;&gt;&gt; x1 = Test(True) and Test(10)
&gt;&gt;&gt; x2 = Test(False) and Test(10)
</code></pre>
<p>That's because <code>and</code> actually returns the first operand if the first operand evaluates to <code>False</code> and if it evaluates to <code>True</code> then it returns the second operand:</p>
<pre><code>&gt;&gt;&gt; x1
Test(10)
&gt;&gt;&gt; x2
Test(False)
</code></pre>
<p>Similarly for <code>or</code> but just the other way around:</p>
<pre><code>&gt;&gt;&gt; Test(True) or Test(10)
Test(True)
&gt;&gt;&gt; Test(False) or Test(10)
Test(10)
</code></pre>
<p>However if you use them in an <code>if</code> statement the <code>if</code> will also implicitly call <code>bool</code> on the result. So these finer points may not be relevant for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>I went with a purlely mathematical solution:</p>
<pre><code>def front_back(a, b):
  return a[:(len(a)+1)//2]+b[:(len(b)+1)//2]+a[(len(a)+1)//2:]+b[(len(b)+1)//2:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You use <strong><code>and</code> and <code>or</code></strong> to perform logical operations like in C, C++. Like literally <strong><code>and</code> is <code>&amp;&amp;</code> and <code>or</code> is <code>||</code></strong>. </p>
<hr/>
<h3>Take a look at this fun example,</h3>
<p><em>Say you want to build Logic Gates in Python:</em> </p>
<pre><code>def AND(a,b):
    return (a and b) #using and operator

def OR(a,b):
    return (a or b)  #using or operator
</code></pre>
<p>Now try calling them: </p>
<pre><code>print AND(False, False)
print OR(True, False)
</code></pre>
<h3>This will output:</h3>
<pre><code>False
True
</code></pre>
<p><em>Hope this helps!</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Probably this is not best code for this task, but is working -</p>
<pre><code>def front_back(a, b):

 if len(a) % 2 == 0 and len(b) % 2 == 0:
    print a[:(len(a)/2)] + b[:(len(b)/2)] + a[(len(a)/2):] + b[(len(b)/2):]

 elif len(a) % 2 == 1 and len(b) % 2 == 0:
    print a[:(len(a)/2)+1] + b[:(len(b)/2)] + a[(len(a)/2)+1:] + b[(len(b)/2):] 

 elif len(a) % 2 == 0 and len(b) % 2 == 1:
     print a[:(len(a)/2)] + b[:(len(b)/2)+1] + a[(len(a)/2):] + b[(len(b)/2)+1:] 

 else :
     print a[:(len(a)/2)+1] + b[:(len(b)/2)+1] + a[(len(a)/2)+1:] + b[(len(b)/2)+1:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use of "and" in conditional. I often use this when importing in Jupyter Notebook:</p>
<pre><code>def find_local_py_scripts():
    import os # does not cost if already imported
    for entry in os.scandir('.'):
        # find files ending with .py
        if entry.is_file() and entry.name.endswith(".py") :
            print("- ", entry.name)
find_local_py_scripts()

-  googlenet_custom_layers.py
-  GoogLeNet_Inception_v1.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A single <code>&amp;</code> (not double <code>&amp;&amp;</code>) is enough or as the top answer suggests you can use 'and'.
I also found this in pandas </p>
<pre><code>cities['Is wide and has saint name'] = (cities['Population'] &gt; 1000000) 
&amp; cities['City name'].apply(lambda name: name.startswith('San'))
</code></pre>
<p>if we replace the "&amp;" with "and", it won't work.</p>
</div>
<div class="post-text" itemprop="text">
<p>maybe with &amp; instead % is more fast and mantain readibility</p>
<p>other tests even/odd</p>
<p>x is even ?   x % 2 == 0</p>
<p>x is odd  ?   not x % 2 == 0</p>
<p>maybe is more clear with bitwise and 1</p>
<p>x is odd  ?   x &amp; 1</p>
<p>x is even ?   not x &amp; 1    (not odd)</p>
<pre><code>def front_back(a, b):
    # +++your code here+++
    if not len(a) &amp; 1 and not len(b) &amp; 1:
        return a[:(len(a)/2)] + b[:(len(b)/2)] + a[(len(a)/2):] + b[(len(b)/2):] 
    else:
        #todo! Not yet done. :P
    return
</code></pre>
</div>
<span class="comment-copy">Clearly Sergio wanted to know why his code was broken, but I read a bit more into the title of the question. Why wouldn't &amp;&amp; be available anyway? == and != are available (but are different from is and is not, I know). Why not include this syntax? Personal preference?</span>
<span class="comment-copy">@vgm64: Why include redundant syntax that doesn’t improve a single aspect?</span>
<span class="comment-copy">It seems to me that the interpreter should, rather than print out a cryptic "SyntaxError: invalid syntax" - detect that the user has used <code>&amp;&amp;</code> and suggest to them that they might want to use the keyword <code>and</code> instead. Same goes for things like <code>++</code> and other common operators from other languages.</span>
<span class="comment-copy">@physicsmichael "there should be one, and preferably only one, obvious way to do it." <code>import this</code></span>
<span class="comment-copy">@KonradRudolph It absolutely improves aspects of the language. It is more consistent and intuitive for anyone who has ever used any other language. the fact that this question exists and has as much traffic as it does clearly highlights this issue as a common sticking point for people.</span>
<span class="comment-copy">what should i do for this: if x=='n' and y =='a' or y=='b': &lt;do something&gt; Will it work !? @ChristopheD</span>
<span class="comment-copy">@diffracteD: Use parentheses if you want to override standard operator precedence (which you can learn about here: <a href="http://www.ibiblio.org/g2swap/byteofpython/read/operator-precedence.html" rel="nofollow noreferrer">ibiblio.org/g2swap/byteofpython/read/operator-precedence.html</a>)</span>
<span class="comment-copy">I like that <a href="http://stackoverflow.com/users/243613/david-titarenco">David Titarenco</a> gave a cut-n-paste <a href="http://stackoverflow.com/a/2485473/1153645">example</a></span>
<span class="comment-copy">I arrived here after I typed both <code>&amp;&amp;</code> and <code>AND</code> and got an error (not expecting python to want the lowercase word <code>and</code>).</span>
<span class="comment-copy">I think you should use &amp; See: <a href="https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o" title="truth value of a series is ambiguous use a empty a bool a item a any o">stackoverflow.com/questions/36921951/…</a></span>
<span class="comment-copy">Don't forget that python also has not (well, and !)</span>
<span class="comment-copy">Does your example evaluate to "(if this and this) or that" OR "if this and (this or that)"?</span>
<span class="comment-copy">@Jeff Your first way. <code>and</code> <a href="https://docs.python.org/2/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">has higher precedence</a> than <code>or</code>.</span>
<span class="comment-copy">@Buge it looks like "or" is higher up in the table that you linked</span>
<span class="comment-copy">@Matt the table goes from lowest precedence to highest. It's easier to remember the precedence if you've studied boolean algebra; "or" is addition and "and" is multiplication.</span>
<span class="comment-copy">While this gives far more than just the answer to the question, this answer is extremely informative and helpful, even if you're a veteran programmer.</span>
<span class="comment-copy">I have been plagued by the <code>ValueError</code> myself. Let's see if np.logical_and can help.</span>
<span class="comment-copy">This isn't an answer to the actual question.</span>
<span class="comment-copy">This question was asked and answered almost 7 years ago.  What does your answer add to those answers that are already here?  In general, unless you have something startlingly new to say, you should not add a new answer to an old question — where old is measured as multiple years — when there are good answers already available.</span>
<span class="comment-copy">Single &amp; won't short-circuit the expression (meaning both they will be evaluated regardless of the return value of the first expression)</span>
