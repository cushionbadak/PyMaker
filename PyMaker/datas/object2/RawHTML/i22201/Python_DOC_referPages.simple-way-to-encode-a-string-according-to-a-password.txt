<div class="post-text" itemprop="text">
<p>Does Python have a built-in, simple way of encoding/decoding strings using a password?</p>
<p>Something like this:</p>
<pre><code>&gt;&gt;&gt; encode('John Doe', password = 'mypass')
'sjkl28cn2sx0'
&gt;&gt;&gt; decode('sjkl28cn2sx0', password = 'mypass')
'John Doe'
</code></pre>
<p>So the string "John Doe" gets encrypted as 'sjkl28cn2sx0'. To get the original string, I would "unlock" that string with the key 'mypass', which is a password in my source code. I'd like this to be the way I can encrypt/decrypt a Word document with a password.</p>
<p>I would like to use these encrypted strings as URL parameters. My goal is obfuscation, not strong security; nothing mission critical is being encoded. I realize I could use a database table to store keys and values, but am trying to be minimalist.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you are <em>only</em> looking for simple obfuscation that will obscure things from the <em>very</em> casual observer, and you aren't looking to use third party libraries. I'd recommend something like the Vigenere cipher. It is one of the strongest of the simple ancient ciphers.</p>
<p><a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher" rel="noreferrer">Vigenère cipher</a></p>
<p>It's quick and easy to implement. Something like:</p>
<pre><code>import base64

def encode(key, string):
    encoded_chars = []
    for i in xrange(len(string)):
        key_c = key[i % len(key)]
        encoded_c = chr(ord(string[i]) + ord(key_c) % 256)
        encoded_chars.append(encoded_c)
    encoded_string = "".join(encoded_chars)
    return base64.urlsafe_b64encode(encoded_string)
</code></pre>
<p>Decode is pretty much the same, except you subtract the key.</p>
<p>It is much harder to break if the strings you are encoding are short, and/or if it is hard to guess the length of the passphrase used. </p>
<p>If you are looking for something cryptographic, PyCrypto is probably your best bet, though previous answers overlook some details: ECB mode in PyCrypto requires your message to be a multiple of 16 characters in length. So, you must pad. Also, if you want to use them as URL parameters, use <code>base64.urlsafe_b64_encode()</code>, rather than the standard one. This replaces a few of the characters in the base64 alphabet with URL-safe characters (as it's name suggests).</p>
<p>However, you should be ABSOLUTELY certain that this <em>very</em> thin layer of obfuscation suffices for your needs before using this. The Wikipedia article I linked to provides detailed instructions for breaking the cipher, so anyone with a moderate amount of determination could easily break it.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you explicitly state that you want obscurity not security, we'll avoid reprimanding you for the weakness of what you suggest :)</p>
<p>So, using PyCrypto:</p>
<pre><code>from Crypto.Cipher import AES
import base64

msg_text = 'test some plain text here'.rjust(32)
secret_key = '1234567890123456' # create new &amp; store somewhere safe

cipher = AES.new(secret_key,AES.MODE_ECB) # never use ECB in strong systems obviously
encoded = base64.b64encode(cipher.encrypt(msg_text))
# ...
decoded = cipher.decrypt(base64.b64decode(encoded))
print decoded.strip()
</code></pre>
<p>If someone gets a hold of your database and your code base, they will be able to decode the encrypted data. Keep your secret_key safe!</p>
</div>
<div class="post-text" itemprop="text">
<p>The "encoded_c" mentioned in the @smehmood's Vigenere cipher answer should be "key_c".</p>
<p>Here are working encode/decode functions.</p>
<pre><code>import base64
def encode(key, clear):
    enc = []
    for i in range(len(clear)):
        key_c = key[i % len(key)]
        enc_c = chr((ord(clear[i]) + ord(key_c)) % 256)
        enc.append(enc_c)
    return base64.urlsafe_b64encode("".join(enc))

def decode(key, enc):
    dec = []
    enc = base64.urlsafe_b64decode(enc)
    for i in range(len(enc)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(enc[i]) - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a Python 3 version of the functions from @qneill 's <a href="https://stackoverflow.com/a/16321853/525169">answer</a>:</p>
<pre><code>import base64
def encode(key, clear):
    enc = []
    for i in range(len(clear)):
        key_c = key[i % len(key)]
        enc_c = chr((ord(clear[i]) + ord(key_c)) % 256)
        enc.append(enc_c)
    return base64.urlsafe_b64encode("".join(enc).encode()).decode()

def decode(key, enc):
    dec = []
    enc = base64.urlsafe_b64decode(enc).decode()
    for i in range(len(enc)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(enc[i]) - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec)
</code></pre>
<p>The extra encode/decodes are needed because Python 3 has split strings/byte arrays into two different concepts, and updated their APIs to reflect that..</p>
</div>
<div class="post-text" itemprop="text">
<p><em><strong>Disclaimer:</strong> As mentioned in the comments, this <strong>should not be used</strong> to protect data in a real application.</em></p>
<p><a href="https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption">What's wrong with XOR encryption?</a></p>
<p><a href="https://crypto.stackexchange.com/questions/56281/breaking-a-xor-cipher-of-known-key-length">https://crypto.stackexchange.com/questions/56281/breaking-a-xor-cipher-of-known-key-length</a></p>
<p><a href="https://github.com/hellman/xortool" rel="nofollow noreferrer">https://github.com/hellman/xortool</a></p>
<hr/>
<p>As has been mentioned the PyCrypto library contains a suite of ciphers. The XOR "cipher" can be used to do the dirty work if you don't want to do it yourself:</p>
<pre><code>from Crypto.Cipher import XOR
import base64

def encrypt(key, plaintext):
  cipher = XOR.new(key)
  return base64.b64encode(cipher.encrypt(plaintext))

def decrypt(key, ciphertext):
  cipher = XOR.new(key)
  return cipher.decrypt(base64.b64decode(ciphertext))
</code></pre>
<p>The cipher works as follows without having to pad the plaintext:</p>
<pre><code>&gt;&gt;&gt; encrypt('notsosecretkey', 'Attack at dawn!')
'LxsAEgwYRQIGRRAKEhdP'

&gt;&gt;&gt; decrypt('notsosecretkey', encrypt('notsosecretkey', 'Attack at dawn!'))
'Attack at dawn!'
</code></pre>
<p>Credit to <a href="https://stackoverflow.com/a/2490376/241294">https://stackoverflow.com/a/2490376/241294</a> for the base64 encode/decode functions (I'm a python newbie).</p>
</div>
<div class="post-text" itemprop="text">
<p>Python has no built-in encryption schemes, no. You also should take encrypted data storage serious; trivial encryption schemes that one developer understands to be insecure and a toy scheme may well be mistaken for a secure scheme by a less experienced developer. If you encrypt, encrypt properly. </p>
<p>You don’t need to do much work to implement a proper encryption scheme however. First of all, <em>don’t re-invent the cryptography wheel</em>, use a trusted cryptography library to handle this for you. For Python 3, that trusted library is <a href="https://cryptography.io/" rel="nofollow noreferrer"><code>cryptography</code></a>.</p>
<p>I also recommend that encryption and decryption applies to <em>bytes</em>; encode text messages to bytes first; <code>stringvalue.encode()</code> encodes to UTF8, easily reverted again using <code>bytesvalue.decode()</code>.</p>
<p>Last but not least, when encrypting and decrypting, we talk about <em>keys</em>, not passwords. A key should not be human memorable, it is something you store in a secret location but machine readable, whereas a password often can be human-readable and memorised. You <em>can</em> derive a key from a password, with a little care. </p>
<p>But for a web application or process running in a cluster without human attention to keep running it, you want to use a key. Passwords are for when only an end-user needs access to the specific information. Even then, you usually secure the application with a password, then exchange encrypted information using a key, perhaps one attached to the user account.</p>
<h1>Symmetric key encryption</h1>
<h2>Fernet – <em>AES CBC + HMAC, strongly recommended</em></h2>
<p>The <code>cryptography</code> library includes the <a href="https://cryptography.io/en/latest/fernet/" rel="nofollow noreferrer">Fernet recipe</a>, a best-practices recipe for using cryptography. Fernet is <a href="https://github.com/fernet/spec/blob/master/Spec.md" rel="nofollow noreferrer">an open standard</a>, 
 with ready implementations in a wide range of programming languages and it packages AES CBC encryption for you with version information, a timestamp and an HMAC signature to prevent message tampering. </p>
<p>Fernet makes it very easy to encrypt and decrypt messages <em>and</em> keep you secure. It is the ideal method for encrypting data with a secret.</p>
<p>I recommend you use <a href="https://cryptography.io/en/latest/fernet/#cryptography.fernet.Fernet.generate_key" rel="nofollow noreferrer"><code>Fernet.generate_key()</code></a> to generate a secure key. You can use a password too (next section), but a full 32-byte secret key (16 bytes to encrypt with, plus another 16 for the signature) is going to be more secure than most passwords you could think of.</p>
<p>The key that Fernet generates is a <code>bytes</code> object with URL and file safe base64 characters, so printable:</p>
<pre><code>from cryptography.fernet import Fernet

key = Fernet.generate_key()  # store in a secure location
print("Key:", key.decode())
</code></pre>
<p>To encrypt or decrypt messages, create a <code>Fernet()</code> instance with the given key, and call the <a href="https://cryptography.io/en/latest/fernet/#cryptography.fernet.Fernet.encrypt" rel="nofollow noreferrer"><code>Fernet.encrypt()</code></a> or <a href="https://cryptography.io/en/latest/fernet/#cryptography.fernet.Fernet.decrypt" rel="nofollow noreferrer"><code>Fernet.decrypt()</code></a>, both the plaintext message to encrypt and the encrypted token are <code>bytes</code> objects.</p>
<p><code>encrypt()</code> and <code>decrypt()</code> functions would look like:</p>
<pre><code>from cryptography.fernet import Fernet

def encrypt(message: bytes, key: bytes) -&gt; bytes:
    return Fernet(key).encrypt(message)

def decrypt(token: bytes, key: bytes) -&gt; bytes:
    return Fernet(key).decrypt(token)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; key = Fernet.generate_key()
&gt;&gt;&gt; print(key.decode())
GZWKEhHGNopxRdOHS4H4IyKhLQ8lwnyU7vRLrM3sebY=
&gt;&gt;&gt; message = 'John Doe'
&gt;&gt;&gt; encrypt(message.encode(), key)
'gAAAAABciT3pFbbSihD_HZBZ8kqfAj94UhknamBuirZWKivWOukgKQ03qE2mcuvpuwCSuZ-X_Xkud0uWQLZ5e-aOwLC0Ccnepg=='
&gt;&gt;&gt; token = _
&gt;&gt;&gt; decrypt(token, key).decode()
'John Doe'
</code></pre>
<h2>Fernet with password – <em>key derived from password, weakens the security somewhat</em></h2>
<p>You can use a password instead of a secret key, provided you <a href="https://cryptography.io/en/latest/fernet/#using-passwords-with-fernet" rel="nofollow noreferrer">use a strong key derivation method</a>. You do then have to include the salt and the HMAC iteration count in the message, so the encrypted value is not Fernet-compatible anymore without first separating salt, count and Fernet token:</p>
<pre><code>import secrets
from base64 import urlsafe_b64encode as b64e, urlsafe_b64decode as b64d

from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

backend = default_backend()
iterations = 100_000

def _derive_key(password: bytes, salt: bytes, iterations: int = iterations) -&gt; bytes:
    """Derive a secret key from a given password and salt"""
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(), length=32, salt=salt,
        iterations=iterations, backend=backend)
    return b64e(kdf.derive(password))

def password_encrypt(message: bytes, password: str, iterations: int = iterations) -&gt; bytes:
    salt = secrets.token_bytes(16)
    key = _derive_key(password.encode(), salt, iterations)
    return b64e(
        b'%b%b%b' % (
            salt,
            iterations.to_bytes(4, 'big'),
            b64d(Fernet(key).encrypt(message)),
        )
    )

def password_decrypt(token: bytes, password: str) -&gt; bytes:
    decoded = b64d(token)
    salt, iter, token = decoded[:16], decoded[16:20], b64e(decoded[20:])
    iterations = int.from_bytes(iter, 'big')
    key = _derive_key(password.encode(), salt, iterations)
    return Fernet(key).decrypt(token)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; message = 'John Doe'
&gt;&gt;&gt; password = 'mypass'
&gt;&gt;&gt; password_encrypt(message.encode(), password)
b'9Ljs-w8IRM3XT1NDBbSBuQABhqCAAAAAAFyJdhiCPXms2vQHO7o81xZJn5r8_PAtro8Qpw48kdKrq4vt-551BCUbcErb_GyYRz8SVsu8hxTXvvKOn9QdewRGDfwx'
&gt;&gt;&gt; token = _
&gt;&gt;&gt; password_decrypt(token, password).decode()
'John Doe'
</code></pre>
<p>Including the salt in the output makes it possible to use a random salt value, which in turn ensures the encrypted output is guaranteed to be fully random regardless of password reuse or message repetition. Including the iteration count ensures that you can adjust for CPU performance increases over time without losing the ability to decrypt older messages. </p>
<p>A password alone <em>can</em> be as safe as a Fernet 32-byte random key, provided you generate a properly random password from a similar size pool. 32 bytes gives you 256 ^ 32 number of keys, so if you use an alphabet of 74 characters (26 upper, 26 lower, 10 digits and 12 possible symbols), then your password should be at least <code>math.ceil(math.log(256 ** 32, 74))</code> == 42 characters long. However, a <a href="https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256">well-selected larger number of HMAC iterations</a> can mitigate the lack of entropy somewhat as this makes it much more expensive for an attacker to brute force their way in.</p>
<p>Just know that choosing a shorter but still reasonably secure password won’t cripple this scheme, it just reduces the number of possible values a brute-force attacker would have to search through; make sure to pick a <a href="https://en.wikipedia.org/wiki/Password_strength" rel="nofollow noreferrer">strong enough password for your security requirements</a>.</p>
<h1>Alternatives</h1>
<h2>Obscuring</h2>
<p>An alternative is <em>not to encrypt</em>. Don't be tempted to just use a low-security cipher, or a home-spun implementation of, say Vignere. There is no security in these approaches, but may give an inexperienced developer that is given the task to maintain your code in future the illusion of security, which is worse than no security at all.</p>
<p>If all you need is obscurity, just base64 the data; for URL-safe requirements, the <a href="https://docs.python.org/3/library/base64.html#base64.urlsafe_b64encode" rel="nofollow noreferrer"><code>base64.urlsafe_b64encode()</code> function</a> is fine. Don't use a password here, just encode and you are done. At most, add some compression (like <code>zlib</code>):</p>
<pre><code>import zlib
from base64 import urlsafe_b64encode as b64e, urlsafe_b64decode as b64d

def obscure(data: bytes) -&gt; bytes:
    return b64e(zlib.compress(data, 9))

def unobscure(obscured: bytes) -&gt; bytes:
    return zlib.decompress(b64d(obscured))
</code></pre>
<p>This turns <code>b'Hello world!'</code> into <code>b'eNrzSM3JyVcozy_KSVEEAB0JBF4='</code>.</p>
<h2>Integrity only</h2>
<p>If all you need is a way to make sure that the data can be trusted to be <em>unaltered</em> after having been sent to an untrusted client and received back, then you want to sign the data, you can use the <a href="https://docs.python.org/3/library/hmac.html" rel="nofollow noreferrer"><code>hmac</code> library</a> for this with SHA1 (still <a href="https://crypto.stackexchange.com/questions/26510/why-is-hmac-sha1-still-considered-secure">considered secure for HMAC signing</a>) or better:</p>
<pre><code>import hmac
import hashlib

def sign(data: bytes, key: bytes, algorithm=hashlib.sha256) -&gt; bytes:
    assert len(key) &gt;= algorithm().digest_size, (
        "Key must be at least as long as the digest size of the "
        "hashing algorithm"
    )
    return hmac.new(key, data, algorithm).digest()

def verify(signature: bytes, data: bytes, key: bytes, algorithm=hashlib.sha256) -&gt; bytes:
    expected = sign(data, key, algorithm)
    return hmac.compare_digest(expected, signature)
</code></pre>
<p>Use this to sign data, then attach the signature with the data and send that to the client. When you receive the data back, split data and signature and verify.  I've set the default algorithm to SHA256, so you'll need a 32-byte key:</p>
<pre><code>key = secrets.token_bytes(32)
</code></pre>
<p>You may want to look at the <a href="https://pythonhosted.org/itsdangerous/" rel="nofollow noreferrer"><code>itsdangerous</code> library</a>, which packages this all up with serialisation and de-serialisation in various formats.</p>
<h1>Using AES-GCM encryption to provide encryption and integrity</h1>
<p>Fernet builds on AEC-CBC with a HMAC signature to ensure integrity of the encrypted data; a malicious attacker can't feed your system nonsense data to keep your service busy running in circles with bad input, because the ciphertext is signed.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" rel="nofollow noreferrer">Galois / Counter mode block cipher</a> produces ciphertext and a <em>tag</em> to serve the same purpose, so can be used to serve the same purposes. The downside is that unlike Fernet there is no easy-to-use one-size-fits-all recipe to reuse on other platforms. AES-GCM also doesn't use padding, so this encryption ciphertext matches the length of the input message (whereas Fernet / AES-CBC encrypts messages to blocks of fixed length, obscuring the message length somewhat).</p>
<p>AES256-GCM takes the usual 32 byte secret as a key:</p>
<pre><code>key = secrets.token_bytes(32)
</code></pre>
<p>then use</p>
<pre><code>import binascii, time
from base64 import urlsafe_b64encode as b64e, urlsafe_b64decode as b64d

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.exceptions import InvalidTag

backend = default_backend()

def aes_gcm_encrypt(message: bytes, key: bytes) -&gt; bytes:
    current_time = int(time.time()).to_bytes(8, 'big')
    algorithm = algorithms.AES(key)
    iv = secrets.token_bytes(algorithm.block_size // 8)
    cipher = Cipher(algorithm, modes.GCM(iv), backend=backend)
    encryptor = cipher.encryptor()
    encryptor.authenticate_additional_data(current_time)
    ciphertext = encryptor.update(message) + encryptor.finalize()        
    return b64e(current_time + iv + ciphertext + encryptor.tag)

def aes_gcm_decrypt(token: bytes, key: bytes, ttl=None) -&gt; bytes:
    algorithm = algorithms.AES(key)
    try:
        data = b64d(token)
    except (TypeError, binascii.Error):
        raise InvalidToken
    timestamp, iv, tag = data[:8], data[8:algorithm.block_size // 8 + 8], data[-16:]
    if ttl is not None:
        current_time = int(time.time())
        time_encrypted, = int.from_bytes(data[:8], 'big')
        if time_encrypted + ttl &lt; current_time or current_time + 60 &lt; time_encrypted:
            # too old or created well before our current time + 1 h to account for clock skew
            raise InvalidToken
    cipher = Cipher(algorithm, modes.GCM(iv, tag), backend=backend)
    decryptor = cipher.decryptor()
    decryptor.authenticate_additional_data(timestamp)
    ciphertext = data[8 + len(iv):-16]
    return decryptor.update(ciphertext) + decryptor.finalize()
</code></pre>
<p>I've included a timestamp to support the same time-to-live use-cases that Fernet supports.</p>
<h1>Other approaches on this page, in Python 3</h1>
<h2>AES CFB - <em>like CBC but without the need to pad</em></h2>
<p>This is the approach that <a href="https://stackoverflow.com/a/42211975/100297">All Іѕ Vаиітy</a> follows, albeit incorrectly. This is the <code>cryptography</code> version, but note that I <em>include the IV in the ciphertext</em>, it should not be stored as a global (reusing an IV weakens the security of the key, and storing it as a module global means it'll be re-generated the next Python invocation, rendering all ciphertext undecryptable):</p>
<pre><code>import secrets
from base64 import urlsafe_b64encode as b64e, urlsafe_b64decode as b64d

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

backend = default_backend()

def aes_cfb_encrypt(message, key):
    algorithm = algorithms.AES(key)
    iv = secrets.token_bytes(algorithm.block_size // 8)
    cipher = Cipher(algorithm, modes.CFB(iv), backend=backend)
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(message) + encryptor.finalize()
    return b64e(iv + ciphertext)

def aes_cfb_decrypt(ciphertext, key):
    iv_ciphertext = b64d(ciphertext)
    algorithm = algorithms.AES(key)
    size = algorithm.block_size // 8
    iv, encrypted = iv_ciphertext[:size], iv_ciphertext[size:]
    cipher = Cipher(algorithm, modes.CFB(iv), backend=backend)
    decryptor = cipher.decryptor()
    return decryptor.update(encrypted) + decryptor.finalize()
</code></pre>
<p>This lacks the added armoring of an HMAC signature and there is no timestamp; you’d have to add those yourself.</p>
<p>The above also illustrates how easy it is to combine basic cryptography building blocks incorrectly; All Іѕ Vаиітy‘s incorrect handling of the IV value can lead to a data breach or all encrypted messages being unreadable because the IV is lost. Using Fernet instead protects you from such mistakes. </p>
<h2>AES ECB – <em>not secure</em></h2>
<p>If you previously implemented <a href="https://stackoverflow.com/a/2490376">AES ECB encryption</a> and need to still support this in Python 3, you can do so still with <code>cryptography</code> too. <strong>The same caveats apply, ECB is <a href="https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption">not secure enough for real-life applications</a></strong>. Re-implementing that answer for Python 3, adding automatic handling of padding:</p>
<pre><code>from base64 import urlsafe_b64encode as b64e, urlsafe_b64decode as b64d

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

backend = default_backend()

def aes_ecb_encrypt(message, key):
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
    encryptor = cipher.encryptor()
    padder = padding.PKCS7(cipher.algorithm.block_size).padder()
    padded = padder.update(msg_text.encode()) + padder.finalize()
    return b64e(encryptor.update(padded) + encryptor.finalize())

def aes_ecb_decrypt(ciphertext, key):
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
    decryptor = cipher.decryptor()
    unpadder = padding.PKCS7(cipher.algorithm.block_size).unpadder()
    padded = decryptor.update(b64d(ciphertext)) + decryptor.finalize()
    return unpadder.update(padded) + unpadder.finalize()
</code></pre>
<p>Again, this lacks the HMAC signature, and you shouldn’t use ECB anyway. The above is there merely to illustrate that <code>cryptography</code> can handle the common cryptographic building blocks, even the ones you shouldn’t actually use. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an implementation of URL Safe encryption and Decryption using AES(PyCrypto) and base64. </p>
<pre><code>import base64
from Crypto import Random
from Crypto.Cipher import AES

AKEY = 'mysixteenbytekey' # AES key must be either 16, 24, or 32 bytes long

iv = Random.new().read(AES.block_size)


def encode(message):
    obj = AES.new(AKEY, AES.MODE_CFB, iv)
    return base64.urlsafe_b64encode(obj.encrypt(message))


def decode(cipher):
    obj2 = AES.new(AKEY, AES.MODE_CFB, iv)
    return obj2.decrypt(base64.urlsafe_b64decode(cipher))
</code></pre>
<p>If you face some issue like this <a href="https://bugs.python.org/issue4329" rel="nofollow noreferrer">https://bugs.python.org/issue4329</a> ( TypeError: character mapping must return integer, None or unicode )
        use str(cipher) while decoding as follows</p>
<p>return obj2.decrypt(base64.urlsafe_b64decode(str(cipher)))</p>
<pre><code>In [13]: encode("Hello World")
Out[13]: b'67jjg-8_RyaJ-28='

In [14]: %timeit encode("Hello World")
100000 loops, best of 3: 13.9 µs per loop

In [15]: decode(b'67jjg-8_RyaJ-28=')
Out[15]: b'Hello World'

In [16]: %timeit decode(b'67jjg-8_RyaJ-28=')
100000 loops, best of 3: 15.2 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Working encode/decode functions in python3 (adapted very little from qneill's answer):</p>
<pre><code>def encode(key, clear):
    enc = []
    for i in range(len(clear)):
        key_c = key[i % len(key)]
        enc_c = (ord(clear[i]) + ord(key_c)) % 256
        enc.append(enc_c)
    return base64.urlsafe_b64encode(bytes(enc))

def decode(key, enc):
    dec = []
    enc = base64.urlsafe_b64decode(enc)
    for i in range(len(enc)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + enc[i] - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for some great answers. Nothing original to add, but here are some progressive rewrites of qneill's answer using some useful Python facilities. I hope you agree they simplify and clarify the code.</p>
<pre><code>import base64


def qneill_encode(key, clear):
    enc = []
    for i in range(len(clear)):
        key_c = key[i % len(key)]
        enc_c = chr((ord(clear[i]) + ord(key_c)) % 256)
        enc.append(enc_c)
    return base64.urlsafe_b64encode("".join(enc))


def qneill_decode(key, enc):
    dec = []
    enc = base64.urlsafe_b64decode(enc)
    for i in range(len(enc)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(enc[i]) - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec)
</code></pre>
<blockquote>
<p><code>enumerate()</code>-- pair the items in a list with their index</p>
<p>iterate over the characters in a string</p>
</blockquote>
<pre><code>def encode_enumerate(key, clear):
    enc = []
    for i, ch in enumerate(clear):
        key_c = key[i % len(key)]
        enc_c = chr((ord(ch) + ord(key_c)) % 256)
        enc.append(enc_c)
    return base64.urlsafe_b64encode("".join(enc))


def decode_enumerate(key, enc):
    dec = []
    enc = base64.urlsafe_b64decode(enc)
    for i, ch in enumerate(enc):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(ch) - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec)
</code></pre>
<blockquote>
<p>build lists using a list comprehension</p>
</blockquote>
<pre><code>def encode_comprehension(key, clear):
    enc = [chr((ord(clear_char) + ord(key[i % len(key)])) % 256)
                for i, clear_char in enumerate(clear)]
    return base64.urlsafe_b64encode("".join(enc))


def decode_comprehension(key, enc):
    enc = base64.urlsafe_b64decode(enc)
    dec = [chr((256 + ord(ch) - ord(key[i % len(key)])) % 256)
           for i, ch in enumerate(enc)]
    return "".join(dec)
</code></pre>
<blockquote>
<p>Often in Python there's no need for list indexes at all. Eliminate loop index variables entirely using zip and cycle:</p>
</blockquote>
<pre><code>from itertools import cycle


def encode_zip_cycle(key, clear):
    enc = [chr((ord(clear_char) + ord(key_char)) % 256)
                for clear_char, key_char in zip(clear, cycle(key))]
    return base64.urlsafe_b64encode("".join(enc))


def decode_zip_cycle(key, enc):
    enc = base64.urlsafe_b64decode(enc)
    dec = [chr((256 + ord(enc_char) - ord(key_char)) % 256)
                for enc_char, key_char in zip(enc, cycle(key))]
    return "".join(dec)
</code></pre>
<blockquote>
<p>and some tests...</p>
</blockquote>
<pre><code>msg = 'The quick brown fox jumps over the lazy dog.'
key = 'jMG6JV3QdtRh3EhCHWUi'
print('cleartext: {0}'.format(msg))
print('ciphertext: {0}'.format(encode_zip_cycle(key, msg)))

encoders = [qneill_encode, encode_enumerate, encode_comprehension, encode_zip_cycle]
decoders = [qneill_decode, decode_enumerate, decode_comprehension, decode_zip_cycle]

# round-trip check for each pair of implementations
matched_pairs = zip(encoders, decoders)
assert all([decode(key, encode(key, msg)) == msg for encode, decode in matched_pairs])
print('Round-trips for encoder-decoder pairs: all tests passed')

# round-trip applying each kind of decode to each kind of encode to prove equivalent
from itertools import product
all_combinations = product(encoders, decoders)
assert all(decode(key, encode(key, msg)) == msg for encode, decode in all_combinations)
print('Each encoder and decoder can be swapped with any other: all tests passed')

&gt;&gt;&gt; python crypt.py
cleartext: The quick brown fox jumps over the lazy dog.
ciphertext: vrWsVrvLnLTPlLTaorzWY67GzYnUwrSmvXaix8nmctybqoivqdHOic68rmQ=
Round-trips for encoder-decoder pairs: all tests passed
Each encoder and decoder can be swapped with any other: all tests passed
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to be safe, you can use Fernet, which is cryptographically sound. You can use a static "salt" if you don't want to store it separately - you will only lose dictionary and rainbow attack prevention. I chose it because I can pick long or short passwords´, which is not so easy with AES.</p>
<pre><code>from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

#set password
password = "mysecretpassword"
#set message
message = "secretmessage"

kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt="staticsalt", iterations=100000, backend=default_backend())
key = base64.urlsafe_b64encode(kdf.derive(password))
f = Fernet(key)

#encrypt
encrypted = f.encrypt(message)
print encrypted

#decrypt
decrypted = f.decrypt(encrypted)
print decrypted
</code></pre>
<p>If that's too complicated, someone suggested simplecrypt </p>
<pre><code>from simplecrypt import encrypt, decrypt
ciphertext = encrypt('password', plaintext)
plaintext = decrypt('password', ciphertext)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note: I had problems using Windows + Python 3.6 + all the answers involving <code>pycrypto</code> (not able to <code>pip install pycrypto</code> on Windows) or <code>pycryptodome</code> (the answers here with <code>from Crypto.Cipher import XOR</code> failed because <code>XOR</code> is not supported by this <code>pycrypto</code> fork ; and the solutions using <code>... AES</code> failed too with <code>TypeError: Object type &lt;class 'str'&gt; cannot be passed to C code</code>). Also, the library <a href="https://github.com/andrewcooke/simple-crypt" rel="nofollow noreferrer"><code>simple-crypt</code></a> has <code>pycrypto</code> as dependency, so it's not an option.</p>
<hr/>
<p>Here is a solution using the package <code>cryptography</code>, that you can install as usual with <code>pip install cryptography</code>:</p>
<pre><code>import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

def encrypt(plaintext, password):
    f = Fernet(base64.urlsafe_b64encode(PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=b'abcd', iterations=1000, backend=default_backend()).derive(password.encode())))
    return f.encrypt(plaintext.encode()).decode()

def decrypt(ciphertext, password):
    f = Fernet(base64.urlsafe_b64encode(PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=b'abcd', iterations=1000, backend=default_backend()).derive(password.encode())))
    return f.decrypt(ciphertext.encode()).decode()
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; encrypt('John Doe', password='mypass')
'gAAAAABciC64VNUoeLVoPKut7HxlPcsqJZTFf99EMYTmnR9jFkZBNMxklIDc5WZ6k3TxfcFSDO-4PRZUsOvywtGLSFwOzToO_g=='

&gt;&gt;&gt; decrypt('gAAAAABciC64VNUoeLVoPKut7HxlPcsqJZTFf99EMYTmnR9jFkZBNMxklIDc5WZ6k3TxfcFSDO-4PRZUsOvywtGLSFwOzToO_g==', password='mypass')
'John Doe'
</code></pre>
<p>Note: </p>
<ul>
<li><p>you can adapt with your own salt, iteration count, etc.</p></li>
<li><p>not very far from @HCLivess's answer but the goal is here to have ready-to-use <code>encrypt</code> and <code>decrypt</code> functions</p></li>
<li><p>Source: <a href="https://cryptography.io/en/latest/fernet/#using-passwords-with-fernet" rel="nofollow noreferrer">https://cryptography.io/en/latest/fernet/#using-passwords-with-fernet</a></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This works but password length should be exactly <code>8</code>. This is simple and requires <a href="http://twhiteman.netfirms.com/des.html" rel="nofollow noreferrer">pyDes</a>.</p>
<pre><code>from pyDes import *

def encode(data,password):
    k = des(password, CBC, "\0\0\0\0\0\0\0\0", pad=None, padmode=PAD_PKCS5)
    d = k.encrypt(data)
    return d

def decode(data,password):
    k = des(password, CBC, "\0\0\0\0\0\0\0\0", pad=None, padmode=PAD_PKCS5)
    d = k.decrypt(data)
    return d

x = encode('John Doe', 'mypass12')
y = decode(x,'mypass12')

print x
print y
</code></pre>
<p>OUTPUT:</p>
<pre><code>³.\Þ\åS¾+æÅ`;Ê
John Doe
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An other implementation of @qneill code which include CRC checksum of the original message, it throw an exception if the check fail:</p>
<pre><code>import hashlib
import struct
import zlib

def vigenere_encode(text, key):
    text = '{}{}'.format(text, struct.pack('i', zlib.crc32(text)))

    enc = []
    for i in range(len(text)):
        key_c = key[i % len(key)]
        enc_c = chr((ord(text[i]) + ord(key_c)) % 256)
        enc.append(enc_c)

    return base64.urlsafe_b64encode("".join(enc))


def vigenere_decode(encoded_text, key):
    dec = []
    encoded_text = base64.urlsafe_b64decode(encoded_text)
    for i in range(len(encoded_text)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(encoded_text[i]) - ord(key_c)) % 256)
        dec.append(dec_c)

    dec = "".join(dec)
    checksum = dec[-4:]
    dec = dec[:-4]

    assert zlib.crc32(dec) == struct.unpack('i', checksum)[0], 'Decode Checksum Error'

    return dec
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use AES to encrypt your string with a password. Though, you'll want to chose a strong enough password so people can't easily guess what it is (sorry I can't help it. I'm a wannabe security weenie).</p>
<p>AES is strong with a good key size, but it's also easy to use with PyCrypto.</p>
</div>
<div class="post-text" itemprop="text">
<p>External libraries provide secret-key encryption algorithms.</p>
<p>For example, the <a href="http://www.dlitz.net/software/pycrypto/apidoc/Crypto.Cipher-module.html" rel="nofollow noreferrer"><code>Cypher</code> module in PyCrypto</a> offers a selection of many encryption algorithms:</p>
<ul>
<li><code>Crypto.Cipher.AES</code></li>
<li><code>Crypto.Cipher.ARC2</code></li>
<li><code>Crypto.Cipher.ARC4</code></li>
<li><code>Crypto.Cipher.Blowfish</code></li>
<li><code>Crypto.Cipher.CAST</code></li>
<li><code>Crypto.Cipher.DES</code></li>
<li><code>Crypto.Cipher.DES3</code></li>
<li><code>Crypto.Cipher.IDEA</code></li>
<li><code>Crypto.Cipher.RC5</code></li>
<li><code>Crypto.Cipher.XOR</code></li>
</ul>
<p><a href="http://chandlerproject.org/Projects/MeTooCrypto" rel="nofollow noreferrer">MeTooCrypto</a> is a <code>Python</code> wrapper for <a href="http://www.openssl.org/" rel="nofollow noreferrer">OpenSSL</a>, and provides (among other functions) a full-strength general purpose cryptography library. Included are symmetric ciphers (like AES).</p>
</div>
<div class="post-text" itemprop="text">
<p>Whoever came here (and the bountier) seemed to be looking for one-liners with not much setup, which other answers don't provide. So I'm putting forward base64.</p>
<p>Now, keep in mind that this is basic obfuscation only, and is in <strong>**NO WAY OK FOR SECURITY**</strong>, but here are some one-liners:</p>
<pre class="lang-py prettyprint-override"><code>from base64 import urlsafe_b64encode, urlsafe_b64decode

def encode(data, key):
    return urlsafe_b64encode(bytes(key+data, 'utf-8'))

def decode(enc, key):
    return urlsafe_b64decode(enc)[len(key):].decode('utf-8')

print(encode('hi', 'there')) # b'dGhlcmVoaQ=='
print(decode(encode('hi', 'there'), 'there')) # 'hi'
</code></pre>
<p>A few things to note:</p>
<ul>
<li>you will want to deal with more/less byte-to-string encoding/decoding on your own, depending on your I/O. Look into <a href="https://www.programiz.com/python-programming/methods/built-in/bytes" rel="nofollow noreferrer"><code>bytes()</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow noreferrer"><code>bytes::decode()</code></a></li>
<li>base64 is easily recognizable by the types of characters used, and often ending with <code>=</code> characters. People like me absolutely go around decoding them in the javascript console when we see them on websites. It's as easy as <code>btoa(string)</code> (js)</li>
<li>the order is key+data, as in b64, what characters appear at the end depends on what characters are at the beginning (because of byte offsets. <a href="https://en.wikipedia.org/wiki/Base64#Examples" rel="nofollow noreferrer">Wikipedia</a> has some nice explanations). In this scenario, the beginning of the encoded string will be the same for everything encoded with that key. The plus is that the data will be more obfuscated. Doing it the other way around will result on the data part being exactly the same for everyone, regardless of key.</li>
</ul>
<p>Now, if what you wanted didn't even need a key of any kind, but just some obfuscation, you can yet again just use base64, without any kinds of key:</p>
<pre class="lang-py prettyprint-override"><code>from base64 import urlsafe_b64encode, urlsafe_b64decode

def encode(data):
    return urlsafe_b64encode(bytes(data, 'utf-8'))

def decode(enc):
    return urlsafe_b64decode(enc).decode()

print(encode('hi')) # b'aGk='
print(decode(encode('hi'))) # 'hi'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you want secure encryption:</p>
<p>for python 2, you should use keyczar <a href="http://www.keyczar.org/" rel="nofollow">http://www.keyczar.org/</a></p>
<p>for python 3, until keyczar is available, i have written simple-crypt <a href="http://pypi.python.org/pypi/simple-crypt" rel="nofollow">http://pypi.python.org/pypi/simple-crypt</a></p>
<p>both these will use key strengthening which makes them more secure than most other answers here.  and since they're so easy to use you might want to use them even when security is not critical...</p>
</div>
<div class="post-text" itemprop="text">
<p>So, as <strong>nothing mission critical is being encoded</strong>, and you just want to encrypt for <strong>obsfuscation</strong>.</p>
<p>Let me present <strong>caeser's cipher</strong></p>
<p><a href="https://i.stack.imgur.com/ZPNdH.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/ZPNdH.png"/></a> </p>
<p>Caesar's cipher or Caesar shift, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on.</p>
<p>Sample code for your reference : </p>
<pre><code>def encrypt(text,s): 
        result = "" 

        # traverse text 
        for i in range(len(text)): 
            char = text[i] 

            # Encrypt uppercase characters 
            if (char.isupper()): 
                result += chr((ord(char) + s-65) % 26 + 65) 

            # Encrypt lowercase characters 
            else: 
                result += chr((ord(char) + s - 97) % 26 + 97) 

        return result 

    def decrypt(text,s): 
        result = "" 

        # traverse text 
        for i in range(len(text)): 
            char = text[i] 

            # Encrypt uppercase characters 
            if (char.isupper()): 
                result += chr((ord(char) - s-65) % 26 + 65) 

            # Encrypt lowercase characters 
            else: 
                result += chr((ord(char) - s - 97) % 26 + 97) 

        return result 

    #check the above function 
    text = "ATTACKATONCE"
    s = 4
    print("Text  : " + text) 
    print("Shift : " + str(s)) 
    print("Cipher: " + encrypt(text,s))
    print("Original text: " + decrypt(encrypt(text,s),s))
</code></pre>
<p>Advantages : it meets your requirements and is simple and does the encoding thing'y'.</p>
<p>Disadvantage : can be cracked by simple brute force algorithms (highly unlikely anyone would attempt to go through all extra results).</p>
</div>
<span class="comment-copy">The term "password" here is inappropriate.  You're using this as a cryptographic KEY and you should use that terminology to avoid confusion in your questions as well as any docs, comments, specs, test plans, etc.</span>
<span class="comment-copy">"I'd like this to be the way I can encrypt/decrypt a Word document with a password.", <a href="https://support.office.com/en-gb/article/Password-protect-documents-workbooks-and-presentations-ef163677-3195-40ba-885a-d50fa2bb6b68" rel="nofollow noreferrer">Word already has a built in option to encrypt your documents</a> if you just need to encrypt word documents.</span>
<span class="comment-copy">Interestingly, according to <a href="https://net.cs.uni-bonn.de/fileadmin/user_upload/naiakshi/Naiakshina_Password_Study.pdf" rel="nofollow noreferrer">this research paper</a> on password storage pitfalls <a href="https://stackoverflow.com/q/2490334/9782169">like this</a>, developers who use Stack Overflow tend to produce less secure code. Gee, I wonder why?</span>
<span class="comment-copy">Also, one should read this answer from <a href="https://security.stackexchange.com/a/31846/86735">security.SE</a></span>
<span class="comment-copy">One does not simply implement encoding/decoding simply</span>
<span class="comment-copy">I fixed smehmood's script, and added the decoding function <a href="https://gist.github.com/ilogik/6f9431e4588015ecb194" rel="nofollow noreferrer">gist.github.com/ilogik/6f9431e4588015ecb194</a></span>
<span class="comment-copy">Attention! smehmood's code and Adrian Mester's fix both only work for strings with characters from the lower ascii range! See precedence of % operator, unicode input etc. See qneill's answer for working code</span>
<span class="comment-copy">@smehmood I'm getting the following error <code>'str' object cannot be interpreted as an integer</code></span>
<span class="comment-copy">"for i in xrange(string)"  might need to chang to "for i in xrange(len(string))"</span>
<span class="comment-copy">encoder and decoder for python 2 and 3: <a href="https://gist.github.com/gowhari/fea9c559f08a310e5cfd62978bc86a1a" rel="nofollow noreferrer">gist.github.com/gowhari/fea9c559f08a310e5cfd62978bc86a1a</a></span>
<span class="comment-copy">I don't think this will work unless msg_text is a multiple of 16 bytes in length, since AES encryption requires blocks that are multiples of 16 in length.  A working implementation for msg_text of arbitrary length would need to add padding to the string to get it to a multiple of 16 in length.</span>
<span class="comment-copy">An example with padding: <a href="http://paste.ubuntu.com/11024555/" rel="nofollow noreferrer">paste.ubuntu.com/11024555</a> It works with arbitrary password and message length.</span>
<span class="comment-copy">@Ethan no, this particular <code>encrypt</code> function is stateful <a href="https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt" rel="nofollow noreferrer">dlitz.net/software/pycrypto/api/current/…</a> so you should not try and reuse it.</span>
<span class="comment-copy">@Will +1 Thanks for the info and the link. Saved me from a very expensive bug fix in future.</span>
<span class="comment-copy">re - "never use ECB in strong systems obviously": I'm just experimenting with this for my own fun. but I saw the above comment in your code. for those of us with very minimal security/encryption/information-theory background, why the "never use"? maybe needs another question... or maybe there is a link on it.</span>
<span class="comment-copy">Very useful, thanks. I've posted a Python 3 version below (it looked ugly in the comments)</span>
<span class="comment-copy"><a href="https://www.schneier.com/blog/archives/2011/04/schneiers_law.html" rel="nofollow noreferrer">"Schneier's Law"</a>: Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can't break. Don't use this, it is not even close to secure.</span>
<span class="comment-copy">Great! This version works also for strings with accents, whereas @smehmood's version doesn't. Usage example: <code>encodedmsg = encode('mypassword', 'this is the message éçàèç"')</code> <code>print encodedmsg</code> <code>print decode('mypassword', encodedmsg)</code>, it works fine.</span>
<span class="comment-copy"><a href="https://gist.github.com/josephernest/ea79e7ef7ef652194d4db66d1ae17010" rel="nofollow noreferrer">Here is a Sublime text plugin</a> based on this code, allowing easy encoding / decoding of text with CTRL+SHIFT+P then "Eeencode" or "Dddecode".</span>
<span class="comment-copy">@basj Thank you for the example</span>
<span class="comment-copy">Thanks Ryan, fwiw you typo'd @qniell</span>
<span class="comment-copy">For those wondering, the differences are the <code>.encode()).decode()</code>. in the return of <code>encode()</code>, and <code>.decode()</code> in the second line in <code>decode()</code>.</span>
<span class="comment-copy">Hmm, the encoded code not really unique, I ran a test and it show every code key of 11,22,33,44,...,88,99,111,222,... always have another same code as before. But I appreciate it</span>
<span class="comment-copy">@Ryan Barrett, is it possible to check the correctness of the password when decoding. Let's say I send one an encoded string who know the key, what if he enter the key with a typo? The decode still gives him a "decoded" string, but it is not the right one, how he can tell?</span>
<span class="comment-copy">note: the Crypto module is installed in python3 by installed pycrptop, not Crypto. <code>sudo pip3 install pycrypto</code>.</span>
<span class="comment-copy">note: pycrypto failed to install on herokuapp at my end. I found this posting.. seems to tell that pycrypto package has been replaced with another one called pycryptodome insteal, and that XOR method has been deprecated : <a href="https://github.com/digitalocean/netbox/issues/1527" rel="nofollow noreferrer">github.com/digitalocean/netbox/issues/1527</a></span>
<span class="comment-copy"><b><i>Do not ever use this method</i></b>, note the description of this 'cipher' in the <a href="https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.XOR-module.html" rel="nofollow noreferrer">documentation</a>: <i>XOR toy cipher, XOR is one the simplest stream ciphers. Encryption and decryption are performed by XOR-ing data with a keystream made by contatenating the key. Do not use it for real applications!</i>.</span>
<span class="comment-copy">@MartijnPieters you're right. Hopefully my edit has made that point clear.</span>
<span class="comment-copy">Would you like to do an extra section on a secure AES-GCN encrypt/decrypt with a 256bit key?</span>
<span class="comment-copy">@citizen2077: I've relented and added that as an option anyway.</span>
<span class="comment-copy">Bug with Windows x64 + Python 3.6 + PyCryptodome (as pycrypto is deprecated): <code>TypeError: Object type &lt;class 'str'&gt; cannot be passed to C code</code>.</span>
<span class="comment-copy">@Basj aww sorry.. I don't use windows, so I can't make a fix.</span>
<span class="comment-copy">Do not generate the IV and store it at the module level, you need to <i>include</i> the IV in the ciphertext message returned! You now introduced two problems: restarting the Python process gives you a new IV making it impossible to decrypt previously encrypted messages, and in the meantime you are re-using the IV for multiple messages, which effectively reduces the security back to ECB level.</span>
<span class="comment-copy">Just generate a salt and include it in the encryption result so repeated passwords and messages still result in random output. Include the iterations value too to future-proof the algorithm but still be able to decrypt messages using a different iteration count.</span>
<span class="comment-copy">(Note: I spent hours on this, then started the bounty, then eventually found this working solution, but I think it's too late to cancel the bounty, so I keep it open, maybe some good other answers will appear!)</span>
<span class="comment-copy">You do not want to hardcode the salt and iteration counts; generate a random salt and make the iteration count configurable on encryption, include that information in the encryption result, and extract and use the values on decryption. The salt protects you from trivial recognition of reused passwords on a given message, the iteration count future-proofs the algorithm.</span>
<span class="comment-copy">Yes of course @MartijnPieters, but the goal is here to have a simple code for simple purposes, as requested by OP, <i>with two parameters</i> : plain text + password. Of course for more complex scenario (i.e. a database), you will use all these additional parameters.</span>
<span class="comment-copy">There is no need for additional parameters! I include that information encoded in the opaque return value of <code>password_encrypt()</code>.</span>
<span class="comment-copy">@MartijnPieters Nice solution indeed.</span>
<span class="comment-copy">Do not use a fixed IV! Randomise the IV and include it with the ciphertext instead. Otherwise you may as well use ECB mode; repeated plain text messages are otherwise trivial to recognise.</span>
<span class="comment-copy">Also, the pyDes project appears to be dead; the homepage is gone, and the last release on PyPI is now 9 years old.</span>
<span class="comment-copy">Thanks Alan. But for clarification, I am not encrypting the passwords themselves. In the above example, I am encrypting the string "John Doe" according to the password "mypass", which is a simple password I use in my source code. User passwords are not involved, neither is any other very sensitive information. I edited my question to clarify this.</span>
<span class="comment-copy">Updated my answer :)</span>
<span class="comment-copy">AES is great, if used correctly. It is easy to use it incorrectly however; there is at least one answer here that uses an insecure block cipher mode, another two that fumble handling the IV value.  Better to use a good library with a well-defined recipe like Fernet!</span>
<span class="comment-copy">Actually, that's a very astute observation. I've fumbled the IV once.</span>
<span class="comment-copy">Yes, if you are not fussed about security, then base64 is way better than to encrypt.</span>
<span class="comment-copy">About the other answers not being one-liners: that’s not the point of the question. They ask for two functions to call. And <code>Fernet(key).encrypt(message)</code> is just one expression just like your base64 call.</span>
<span class="comment-copy">And you should <i>remove</i> the <code>key</code> altogether. Loads of developers are going to copy and paste from Stack Overflow without paying attention and <b>will</b> assume the key to be secret. If you must include it, <i>then at the very least not use it</i> and warn or raise an exception if used anyway. Don’t underestimate the foolishness of the copy-and-paste culture and your responsibilities to deliver sane functions.</span>
<span class="comment-copy">From the <a href="https://github.com/google/keyczar" rel="nofollow noreferrer">Keyczar repository</a>: <i>Important note: Keyczar is deprecated. The Keyczar developers recommend <a href="https://github.com/google/tink" rel="nofollow noreferrer">Tink</a></i>, but there is no Python version of Tink.</span>
