<div class="post-text" itemprop="text">
<pre><code>d3 = dict(d1, **d2)
</code></pre>
<p>I understand that this merges the dictionary. But, is it unique? What if d1 has the same key as d2 but different value?  I would like d1 and d2 to be merged, but d1 has priority if there is duplicate key.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="http://docs.python.org/library/stdtypes.html#dict.update" rel="noreferrer"><code>.update()</code></a> method if you don't need the original <code>d2</code> any more:</p>
<blockquote>
<p>Update the dictionary with the key/value pairs from other, <strong>overwriting existing keys</strong>. Return <code>None</code>.</p>
</blockquote>
<p>E.g.:</p>
<pre><code>&gt;&gt;&gt; d1 = {'a': 1, 'b': 2} 
&gt;&gt;&gt; d2 = {'b': 1, 'c': 3}
&gt;&gt;&gt; d2.update(d1)
&gt;&gt;&gt; d2
{'a': 1, 'c': 3, 'b': 2}
</code></pre>
<p><strong>Update:</strong></p>
<p>Of course you can copy the dictionary first in order to create a new merged one. This might or might not be necessary. In case you have compound objects (objects that contain other objects, like lists or class instances) in your dictionary, <a href="http://docs.python.org/library/copy.html" rel="noreferrer"><code>copy.deepcopy</code></a> should also be considered.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python2,</p>
<pre><code>d1={'a':1,'b':2}
d2={'a':10,'c':3}
</code></pre>
<p>d1 overrides d2: </p>
<pre><code>dict(d2,**d1)
# {'a': 1, 'c': 3, 'b': 2}
</code></pre>
<p>d2 overrides d1:</p>
<pre><code>dict(d1,**d2)
# {'a': 10, 'c': 3, 'b': 2}
</code></pre>
<p>This behavior is not just a fluke of implementation; it is guaranteed <a href="http://docs.python.org/library/stdtypes.html#dict" rel="noreferrer">in the documentation</a>:</p>
<blockquote>
<p>If a key is specified both in the
  positional argument and as a keyword
  argument, the value associated with
  the keyword is retained in the
  dictionary.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you want <code>d1</code> to have priority in the conflicts, do:</p>
<pre><code>d3 = d2.copy()
d3.update(d1)
</code></pre>
<p>Otherwise, reverse <code>d2</code> and <code>d1</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution is to define a <em>merge</em> function. It's not sophisticated and just cost one line. Here's the code in Python 3.</p>
<pre><code>from functools import reduce
from operator import or_

def merge(*dicts):
    return { k: reduce(lambda d, x: x.get(k, d), dicts, None) for k in reduce(or_, map(lambda x: x.keys(), dicts), set()) }
</code></pre>
<p>Tests</p>
<pre><code>&gt;&gt;&gt; d = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
&gt;&gt;&gt; d_letters = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z', 26: 'A', 27: 'B', 28: 'C', 29: 'D', 30: 'E', 31: 'F', 32: 'G', 33: 'H', 34: 'I', 35: 'J', 36: 'K', 37: 'L', 38: 'M', 39: 'N', 40: 'O', 41: 'P', 42: 'Q', 43: 'R', 44: 'S', 45: 'T', 46: 'U', 47: 'V', 48: 'W', 49: 'X', 50: 'Y', 51: 'Z'}
&gt;&gt;&gt; merge(d, d_letters)
{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z', 26: 'A', 27: 'B', 28: 'C', 29: 'D', 30: 'E', 31: 'F', 32: 'G', 33: 'H', 34: 'I', 35: 'J', 36: 'K', 37: 'L', 38: 'M', 39: 'N', 40: 'O', 41: 'P', 42: 'Q', 43: 'R', 44: 'S', 45: 'T', 46: 'U', 47: 'V', 48: 'W', 49: 'X', 50: 'Y', 51: 'Z'}
&gt;&gt;&gt; merge(d_letters, d)
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z', 26: 'A', 27: 'B', 28: 'C', 29: 'D', 30: 'E', 31: 'F', 32: 'G', 33: 'H', 34: 'I', 35: 'J', 36: 'K', 37: 'L', 38: 'M', 39: 'N', 40: 'O', 41: 'P', 42: 'Q', 43: 'R', 44: 'S', 45: 'T', 46: 'U', 47: 'V', 48: 'W', 49: 'X', 50: 'Y', 51: 'Z'}
&gt;&gt;&gt; merge(d)
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
&gt;&gt;&gt; merge(d_letters)
{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z', 26: 'A', 27: 'B', 28: 'C', 29: 'D', 30: 'E', 31: 'F', 32: 'G', 33: 'H', 34: 'I', 35: 'J', 36: 'K', 37: 'L', 38: 'M', 39: 'N', 40: 'O', 41: 'P', 42: 'Q', 43: 'R', 44: 'S', 45: 'T', 46: 'U', 47: 'V', 48: 'W', 49: 'X', 50: 'Y', 51: 'Z'}
&gt;&gt;&gt; merge()
{}
</code></pre>
<p>It works for arbitrary number of dictionary arguments. Were there any duplicate keys in those dictionary, the key from the rightmost dictionary in the argument list wins.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://treyhunner.com/2016/02/how-to-merge-dictionaries-in-python/" rel="nofollow noreferrer">Trey Hunner has a nice blog post</a> outlining several options for merging multiple dictionaries, including (for python3.3+) <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer">ChainMap</a> and <a href="https://www.python.org/dev/peps/pep-0448/" rel="nofollow noreferrer">dictionary unpacking</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe that, as stated above, using <code>d2.update(d1)</code> is the best approach and that you can also copy <code>d2</code> first if you still need it.</p>
<p>Although, I want to point out that <code>dict(d1, **d2)</code> is actually a bad way to merge dictionnaries in general since keyword arguments need to be strings, thus it will fail if you have a <code>dict</code> such as:</p>
<pre><code>{
  1: 'foo',
  2: 'bar'
}
</code></pre>
</div>
<span class="comment-copy">Please be aware that this trick is considered an abuse of <code>**</code> keyword argument passing unless all keys of <code>d2</code> are strings.  If not all keys of <code>d2</code> are strings, this fails in Python 3.2, and in alternative implementations of Python like Jython, IronPython and PyPy.  See, for example, <a href="http://mail.python.org/pipermail/python-dev/2010-April/099459.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2010-April/099459.html</a> .</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/38987/how-can-i-merge-two-python-dictionaries-in-a-single-expression">How can I merge two Python dictionaries in a single expression?</a></span>
<span class="comment-copy">With this case d1 elements should correctly get priority if conflicting keys are found</span>
<span class="comment-copy">In case you still need it, just make a copy. d3 = d2.copy() d3.update(d1) but I would like to see d1 + d2 being added to the language.</span>
<span class="comment-copy">d1 + d2 is problematic because one dictionary has to have priority during conflicts, and it's not particularly obvious which one.</span>
<span class="comment-copy">d1 + d2 will only ever be implemented if Python gains a multimap, otherwise the ambiguity to the user is too confusing for the 8 byte typing gain.</span>
<span class="comment-copy">You have objects in the dictionary in this example: <code>isinstance(int, object) is True</code> yet <code>deepcopy</code> doesn't seem necessary.</span>
<span class="comment-copy">Your examples will fail (producing a TypeError) in Python 3.2, and in current versions of Jython, PyPy and IronPython:  for those versions of Python, when passing a dict with the <code>**</code> notation, all the keys of that dict should be strings.  See the python-dev thread starting at <a href="http://mail.python.org/pipermail/python-dev/2010-April/099427.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2010-April/099427.html</a> for more.</span>
<span class="comment-copy">@Mark: Thanks for the heads up. I've edited the code to make it compatible with non-CPython implementations.</span>
<span class="comment-copy">it fails if your keys are tuples of strings and numbers. for eg.   d1={(1,'a'):1, (1,'b'):0,} d2={(1,'a'):1, (2,'b'):2, (2,'a'):1,}</span>
<span class="comment-copy">Regarding the unpacking syntax, see <a href="http://stackoverflow.com/a/26853961/1959808">this post</a> for changes forthcoming in python 3.5.</span>
<span class="comment-copy">I was going to say that <code>d = dict(**d1, **d2)</code> works, but that's what @IoannisFilippidis references in their comment. Perhaps including the snippet here would've been clearer, so here it is.</span>
<span class="comment-copy">A simple loop with an <code>.update</code> call in it (<code>merged={}</code> followed by <code>for d in dict: merged.update(d)</code>) would be shorter, more readable and more efficient.</span>
<span class="comment-copy">Or if you really want to use <code>reduce</code> and <code>lambda</code>s, how about <code>return reduce(lambda x, y: x.update(y) or x, dicts, {})</code>?</span>
<span class="comment-copy">You can try out your code in the shell and see if it's correct. What I was trying to do is to write a function that can take various number of dictionary arguments with the same functionality. It's better not to use x.update(y) under the lambda, because it always returns <i>None</i>. And I am trying to write a more general function <i>merge_with</i> that take various number of dictionary argument and deal with duplicate keys with the supplied function. Once I am done, I'll post it in another thread where the solution is more relevant.</span>
<span class="comment-copy">Here's <a href="http://stackoverflow.com/questions/16560840/python-merge-dictionaries-with-custom-merge-function/28381494#28381494">link</a> where I wrote the more general solution. Welcome and have a look.</span>
