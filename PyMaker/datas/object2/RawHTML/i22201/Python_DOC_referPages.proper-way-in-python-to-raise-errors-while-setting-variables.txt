<div class="post-text" itemprop="text">
<p>What is the proper way to do error-checking in a class?  Raising exceptions?  Setting an instance variable dictionary "errors" that contains all the errors and returning it?  </p>
<p>Is it bad to print errors from a class?
Do I have to return False if I'm raising an exception?</p>
<p>Just want to make sure that I'm doing things right.  Below is some sample code:</p>
<pre><code>@property
def password(self):
    return self._password

@password.setter
def password(self,password):
    # Check that password has been completed
    try:
        # Check that password has a length of 6 characters
        if (len(password) &lt; 6):
            raise NameError('Your password must be greater \
                             than 6 characters')

    except NameError:
        print 'Please choose a password'
        return False

    except TypeError:
        print 'Please choose a password'
        return False                                                                                                                                

    #Set the password
    self._password = password

    #Encrypt the password
    password_md5 = md5.new()
    password_md5.update(password)
    self._password_md5 = password_md5.hexdigest()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code is out of a context so is not obvious the right choice. Following some tips:</p>
<ul>
<li><p>Don't use <code>NameError</code> exception, it is only used when a name, as the exception itself said, is not found in the local or global scope, use <code>ValueError</code> or <code>TypeError</code> if the exception concerns the value or the type of the parameter;</p></li>
<li><p>Don't print error messages. Raise meaningful exceptions with a meaningful error message:</p>
<pre><code>raise ValueError("password must be longer than 6 characters")
</code></pre></li>
<li><p>Returning a value from a setter is meaningless while assignment is not an expression, i.e. you cannot check the value of an assignment:</p>
<pre><code>if (user.password = 'short'): ...
</code></pre></li>
<li><p>Just raise an exception in the setter and let the code that set the property handle it.</p></li>
</ul>
<p>Example:</p>
<pre><code>class Test:

    minlen = 6

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, value):
        if not isinstance(value, basestring):
            raise TypeError("password must be a string")
        if len(value) &lt; self.minlen:
            raise ValueError("password must be at least %d character len" % \
                                 self.minlen)
        self._password = value
</code></pre>
<p>Look also at <a href="http://forms-project.pollenation.net/cgi-bin/trac.cgi/browser/trunk/formal/types.py#L16" rel="noreferrer">this forms handling library</a>, there the validators , <a href="http://forms-project.pollenation.net/cgi-bin/trac.cgi/browser/trunk/formal/validation.py#L60" rel="noreferrer">here an example</a>, are entities in their own: they can be set dynamically with higher control and less coupled code, but maybe this is much more than you need.</p>
</div>
<div class="post-text" itemprop="text">
<p>The standard way of signalling an error in python is to raise an exception and let the calling code handle it.  Either let the NameError &amp; TypeError carry on upwards, or catch them and raise an InvalidPassword exception that you define.  </p>
<p>While it is possible to return a success/fail flag or error code from the function as you have done, it is not recommended - it is easy for the caller to forget to check the return value and have errors get lost.  Besides you are returning a value from a property setter - this is meaningless in Python since assignments are not expressions and cannot return a value.</p>
<p>You should also never print a message for the user in your exception handling - what if you later want to use the function or class in a GUI program?  In that case your print statement will have nowhere to print to.  Logging an error to a logfile (using Python's logging module) is often helpful for debugging though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Generally, you should indicate errors that propagate by using exceptions. If you discover an error by something you just checked and you can deal with it immediately, there is no need to raise an exception. </p>
<p>In the particular case of a setter, of example, returning <code>False</code> or anything else won't help. Setting instance variables you have to check is very suboptimal, since then you could miss an error on accident.</p>
<p><code>print</code> is not usually a good response to an error. In this case, it sounds like you want to tell the end user they need to use a different password. It sounds like you should call a method that causes the webpage with the form to explain to the user what went wrong; you could call the method that does that in your class or raise an exception that will propagate and eventually be caught and used for that purpose. (This is general advice. I don't know enough about Pylons to tell you how it wants you to do this.)</p>
<p>You should not raise your own <code>NameError</code> exceptions. <code>NameError</code> prettymuch always indicates a typo in your program, and as such you usually do not want to catch it. By catching it, you introduce unnecessary uncertainty into a program. This looks like it might be something more like <code>ValueError</code> or a subclass thereof (<code>class InvalidPasswordError(ValueError): pass</code>).</p>
<p>I do not understand why you check <code>TypeError</code>. You should always understand what would have caused an exception you caught. If you do in this case, that's great; I can't figure out what error would raise <code>TypeError</code> that you could sanely deal with by prompting the user.</p>
<p>Your technique of receiving the password in plaintext and storing its md5 hash is not very secure. You should look into something like AuthKit that could make this process more secure and abstracted.</p>
</div>
<span class="comment-copy">Too many things named <code>password</code> in that code.  (the first function, the second function, and the argument to the second function.)  pyflakes will be your friend.</span>
<span class="comment-copy">@keturn: it is a pattern shown in the docs for <code>property()</code> function. Look at the <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">code example in the docs that uses <code>.setter</code> decorator</a>. Inside the setter method <code>password</code> is a local variable (parameter). Other names are in a different namespace (they belong to the class).</span>
<span class="comment-copy">This was really helpful.  Thank you.</span>
<span class="comment-copy">@mg, Great post (and great initials!) overall, but I'm concerned about the example at the end. You seem to have made up a <code>password</code> decorator, the usage of which is pretty odd; do you mean <code>@property</code> and to name the first method <code>password</code>? Also, you'll have to use new-style classes if you want to use properties, i.e. change the first line of the example to <code>class Test(object):</code> or inherit from some other new-style class. (Even if you weren't using properties yet, you should use new-style classes.)</span>
<span class="comment-copy">@Mike Graham: damn, tiredness could play bad jokes. you are right for the property naming, the exact form is the one used originally by ensare, i prefer the old good <code>password = property(...)</code> but i would be coherent with ensare without really knowing the new 2.6 syntax. The second observation is not true: properties can be used with old style classes</span>
<span class="comment-copy">@mg, Oops, I was remembering wrong the fact that classes that <i>implement</i> the descriptor protocol (like <code>property</code>) must be new-style classes. There are still other subtle advantages to using new-style classes whenever possible.</span>
<span class="comment-copy">NB for Python 3 <a href="http://stackoverflow.com/questions/34803467/unexpected-exception-name-basestring-is-not-defined-when-invoking-ansible2"><code>basestring</code> has been replaced by <code>str</code></a></span>
