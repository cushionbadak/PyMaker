<div class="post-text" itemprop="text">
<p>Is there a way to map a signal number (e.g. signal.SIGINT) to its respective name (i.e. "SIGINT")?</p>
<p>I'd like to be able to print the name of a signal in the log when I receive it, however I cannot find a map from signal numbers to names in Python, i.e.:</p>
<pre><code>import signal
def signal_handler(signum, frame):
    logging.debug("Received signal (%s)" % sig_names[signum])

signal.signal(signal.SIGINT, signal_handler)
</code></pre>
<p>For some dictionary sig_names, so when the process receives SIGINT it prints:</p>
<pre><code>Received signal (SIGINT)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is none, but if you don't mind a little hack, you can generate it like this:</p>
<pre><code>import signal
dict((k, v) for v, k in reversed(sorted(signal.__dict__.items()))
     if v.startswith('SIG') and not v.startswith('SIG_'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With the addition of the <a href="https://docs.python.org/3/library/signal.html" rel="noreferrer"><code>signal.Signals</code></a> <a href="https://docs.python.org/3/library/enum.html#enum.IntEnum" rel="noreferrer"><code>enum</code></a> in Python 3.5 this is now as easy as:</p>
<pre><code>&gt;&gt;&gt; import signal
&gt;&gt;&gt; signal.SIGINT.name
'SIGINT'
&gt;&gt;&gt; signal.SIGINT.value
2
&gt;&gt;&gt; signal.Signals(2).name
'SIGINT'
&gt;&gt;&gt; signal.Signals['SIGINT'].value
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python Standard Library By Example shows this function in the chapter on signals:</p>
<pre><code>SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n) \
    for n in dir(signal) if n.startswith('SIG') and '_' not in n )
</code></pre>
<p>You can then use it like this:</p>
<pre><code>print "Terminated by signal %s" % SIGNALS_TO_NAMES_DICT[signal_number]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this article when I was in the same situation and figured the handler is only handling one signal at a time, so I don't even need a whole dictionary, just the name of one signal:</p>
<pre><code>sig_name = tuple((v) for v, k in signal.__dict__.iteritems() if k == signum)[0]
</code></pre>
<p>there's probably a notation that doesn't need the tuple(...)[0] bit, but I can't seem to figure it out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, <code>help(signal)</code> says at the bottom:</p>
<pre><code>DATA
    NSIG = 23
    SIGABRT = 22
    SIGBREAK = 21
    SIGFPE = 8
    SIGILL = 4
    SIGINT = 2
    SIGSEGV = 11
    SIGTERM = 15
    SIG_DFL = 0
    SIG_IGN = 1
</code></pre>
<p>So this should work:</p>
<pre><code>sig_names = {23:"NSIG", 22:"SIGABRT", 21:"SIGBREAK", 8:"SIGFPE", 4:"SIGILL",
             2:"SIGINT", 11:"SIGSEGV", 15:"SIGTERM", 0:"SIG_DFL", 1:"SIG_IGN"}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Building on <a href="https://stackoverflow.com/a/35996948/2957469">another answer</a>:</p>
<pre><code>import signal

if hasattr(signal, "Signals"):
    def _signal_name(signum):
        try:
            return signal.Signals(signum).name
        except ValueError:
            pass
else:
    def _signal_name(signum):
        for n, v in sorted(signal.__dict__.items()):
            if v != signum:
                continue
            if n.startswith("SIG") and not n.startswith("SIG_"):
                return n

def signal_name(signum):
    if signal.SIGRTMIN &lt;= signum &lt;= signal.SIGRTMAX:
        return "SIGRTMIN+{}".format(signum - signal.SIGRTMIN)
    x = _signal_name(signum)
    if x is None:
        # raise ValueError for invalid signals
        signal.getsignal(signum)
        x = "&lt;signal {}&gt;".format(signum)
    return x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for <code>signal_value</code> of positive number (signal number), or negative value (return status from subprocess):</p>
<pre><code>import signal

signal_name = {
        getattr(signal, _signame): _signame
        for _signame in dir(signal)
        if _signame.startswith('SIG')
    }.get(abs(signal_value), 'Unknown')
</code></pre>
</div>
<span class="comment-copy">Strictly speaking this will map 1 to <code>SIG_IGN</code> and <code>SIGHUP</code> on most platforms, so I suppose the test should be if <code>v.startswith('SIG') and not v.startswith('SIG_')</code>.</span>
<span class="comment-copy">It also double-maps 6 to <code>SIGABRT</code> and <code>SIGIOT</code> on Mac OS X (though they could be used interchangeably, I suppose, unlike <code>SIG_IGN</code> - which isn't a signal).</span>
<span class="comment-copy">@Brian: very true... it's not a perfect solution by far. But it's atleast somewhat platform independent.</span>
<span class="comment-copy">No need to sort. The dict will store as it sees fit anyway.</span>
<span class="comment-copy">@tbc0: the sort is to give a consistent list of signals since there are duplicates in the list, so it's most certainly needed</span>
<span class="comment-copy">This is a great answer for Py3 users.</span>
<span class="comment-copy">This should be the accepted answer.</span>
<span class="comment-copy">or (perhaps slightly more preferable) <code>SIGNALS_TO_NAMES_DICT.get(signal_number, "Unnamed signal: %d" % signal_number)</code></span>
<span class="comment-copy">This is a better answer and should be accepted.</span>
<span class="comment-copy">As @Wolph points out in his answer, this solution doesn't guarantee a consistent name to duplicate signals.</span>
<span class="comment-copy">signame = [v for v, k in signal.__dict__.iteritems() if k == signum][0] works fine.</span>
<span class="comment-copy">"signame = next(v for v, k in signal.__dict__.iteritems() if k == signum)" stops when it finds it instead of continuing through the rest of the dict (also, it doesn't have the [0] that @ssc didn't like :D).</span>
<span class="comment-copy">If v, k are supposed to stand for keys and values, then the names should be reversed, e.g.   sig_name = tuple((k) for k, v in signal.__dict__.iteritems() if v == signum)[0]  But then there are other values in signal's dict whose value may match v, in which case, depending on the order iteritems() returns items, you may print a nonsense name.</span>
<span class="comment-copy">Unfortunately different platforms have different signal numbers, so this isn't portable. Thanks, though.</span>
<span class="comment-copy">For example, here's the Mac OS X <code>help(signal)</code>:     SIGABRT = 6     SIGALRM = 14     SIGBUS = 10     SIGCHLD = 20     SIGCONT = 19     SIGEMT = 7     SIGFPE = 8     SIGHUP = 1     SIGILL = 4     SIGINFO = 29     SIGINT = 2     SIGIO = 23     SIGIOT = 6     SIGKILL = 9     SIGPIPE = 13     SIGPROF = 27     SIGQUIT = 3     SIGSEGV = 11     SIGSTOP = 17     SIGSYS = 12     SIGTERM = 15     SIGTRAP = 5     SIGTSTP = 18     SIGTTIN = 21     SIGTTOU = 22     SIGURG = 16     SIGUSR1 = 30     SIGUSR2 = 31     SIGVTALRM = 26     SIGWINCH = 28     SIGXCPU = 24     SIGXFSZ = 25</span>
<span class="comment-copy">Ah - I really should have realized that, all things considered, especially since I've experienced how much different signals are on Windows and Linux. WoLpH's solution is cleaner anyway :)</span>
<span class="comment-copy">I wouldn't say my solution is cleaner. Yes, it works on every platform but if your solution is an option, than I'd definately use it and use my version as a fallback.</span>
