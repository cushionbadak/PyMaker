<div class="post-text" itemprop="text">
<p>I was writing a metaclass and accidentally did it like this:</p>
<pre><code>class MetaCls(type):
    def __new__(cls, name, bases, dict):
        return type(name, bases, dict)
</code></pre>
<p>...instead of like this:</p>
<pre><code>class MetaCls(type):
    def __new__(cls, name, bases, dict):
        return type.__new__(cls, name, bases, dict)
</code></pre>
<p>What exactly is the difference between these two metaclasses?  And more specifically, what caused the first one to not work properly (some classes weren't called into by the metaclass)?</p>
</div>
<div class="post-text" itemprop="text">
<p>In the first example you're creating a whole new class:</p>
<pre><code>&gt;&gt;&gt; class MetaA(type):
...     def __new__(cls, name, bases, dct):
...         print 'MetaA.__new__'
...         return type(name, bases, dct)
...     def __init__(cls, name, bases, dct):
...         print 'MetaA.__init__'
... 
&gt;&gt;&gt; class A(object):
...     __metaclass__ = MetaA
... 
MetaA.__new__
&gt;&gt;&gt; 
</code></pre>
<p>while in the second case you're calling parent's <code>__new__</code>:</p>
<pre><code>&gt;&gt;&gt; class MetaA(type):
...     def __new__(cls, name, bases, dct):
...         print 'MetaA.__new__'
...         return type.__new__(cls, name, bases, dct)
...     def __init__(cls, name, bases, dct):
...         print 'MetaA.__init__'
... 
&gt;&gt;&gt; class A(object):
...     __metaclass__ = MetaA
... 
MetaA.__new__
MetaA.__init__
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first thing you need to figure out is how <code>object.__new__()</code> works.</p>
<p>Here it is from the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p><code>object.__new__(cls[, ...])</code></p>
<p>Called to create a new instance of class <code>cls</code>. <code>__new__()</code> is a static
  method (special-cased so you need not declare it as such) that takes
  the class of which an instance was requested as its first argument.
  The remaining arguments are those passed to the object constructor
  expression (the call to the class). The return value of <code>__new__()</code>
  should be the new object instance (usually an instance of <code>cls</code>).</p>
<p>Typical implementations create a new instance of the class by invoking
  the superclass’s <code>__new__()</code> method using <code>super(currentclass, cls).__new__(cls[, ...])</code> with appropriate arguments and then modifying
  the newly-created instance as necessary before returning it.</p>
<p><strong>If <code>__new__()</code> returns an instance of <code>cls</code>, then the new instance’s <code>__init__()</code> method will be invoked like <code>__init__(self[, ...])</code>, where <code>self</code> is the new instance and the remaining arguments are the same as
  were passed to <code>__new__()</code>.</strong></p>
<p><strong>If <code>__new__()</code> does not return an instance of <code>cls</code>, then the new instance’s <code>__init__()</code> method will not be invoked.</strong></p>
<p><code>__new__()</code> is intended mainly to allow subclasses of <em>immutable</em> types (like <code>int</code>, <code>str</code>, or <code>tuple</code>) to customize instance creation. It is also
  commonly overridden in custom metaclasses in order to customize class
  creation.</p>
</blockquote>
<p>So in mg.'s <a href="https://stackoverflow.com/a/2609177/452102">answer</a>, the former doesn't call function <code>__init__</code> while the latter calls function <code>__init__</code> after calling <code>__new__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Please refer to the annotation below, hope this helpful.</p>
<pre><code>class MetaCls(type):
    def __new__(cls, name, bases, dict):
        # return a new type named "name",this type has nothing
        # to do with MetaCls,and MetaCl.__init__ won't be invoked
        return type(name, bases, dict)

class MetaCls(type):
    def __new__(cls, name, bases, dict):
        # return a new type named "name",the returned type 
        # is an instance of cls,and cls here is "MetaCls", so 
        # the next step can invoke MetaCls.__init__ 
        return type.__new__(cls, name, bases, dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>return type(name, bases, dict)
</code></pre>
<p>What you get back from this is a new <code>type</code>, and not a <code>MetaCls</code> instance at all. Consequently, your methods defined in <code>MetaCls</code> (including <code>__init__</code>) can't ever be called.</p>
<p><code>type.__new__</code> will be called as part of creating that new type, yes, but the value of <code>cls</code> going into that function is going to be <code>type</code> and not <code>MetaCls</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class MyMeta(type):
    def __new__(meta, cls, bases, attributes):
        print 'MyMeta.__new__'
        return type.__new__(meta, cls, bases, attributes)
    def __init__(clsobj, cls, bases, attributes):
        print 'MyMeta.__init__'

class MyClass(object):
  __metaclass__ = MyMeta
  foo = 'bar'
</code></pre>
<p>Another way to achieve the same result:</p>
<pre><code>cls = "MyClass"
bases = ()
attributes = {'foo': 'bar'}
MyClass = MyMeta(cls, bases, attributes)
</code></pre>
<p><code>MyMeta</code> is a callable so Python will use the special method <code>__call__</code>.</p>
<p>Python will look for <code>__call__</code> in the <code>MyMeta</code>'s type (which is <code>type</code> in our case)</p>
<blockquote>
<p>"For new-style classes, implicit invocations of special methods are
  only guaranteed to work correctly if defined on an object’s type, not
  in the object’s instance dictionary"</p>
</blockquote>
<p><code>MyClass = MyMeta(...)</code> is interpreted as:</p>
<pre><code>my_meta_type = type(MyMeta)
MyClass = my_meta_type.__call__(MyMeta, cls, bases, attributes)
</code></pre>
<p>Inside the <code>type.__call__()</code> I imagine something like this:</p>
<pre><code>MyClass = MyMeta.__new__(MyMeta, cls, bases, attributes)
meta_class = MyClass.__metaclass__
meta_class.__init__(MyClass, cls, bases, attributes)
return MyClass
</code></pre>
<p><code>MyMeta.__new__()</code> will decide how the <code>MyClass</code> is built:</p>
<p><code>type.__new__(meta, cls, bases, attributes)</code> will set the correct metaclass (which is <code>MyMeta</code>) for <code>MyClass</code></p>
<p><code>type(cls, bases, attributes)</code> will set the default metaclass (which is type) for <code>MyClass</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It's all described pretty well <a href="http://www.python.org/download/releases/2.2/descrintro/#__new__" rel="nofollow noreferrer">here</a>.</p>
<p>If you don't return the right type of object, there's no point to defining a custom metaclass. </p>
</div>
<span class="comment-copy">How is <code>type.__new__</code> related to <code>object.__new__</code>? I didn't get that part.</span>
<span class="comment-copy">OP asked about <code>type.__new__</code> (which creates a class), not <code>object.__new__</code> (which creates an instance of a class).</span>
<span class="comment-copy">But that's the question I'm getting at:  why doesn't <code>type</code> return the right kind of object?  I know that I have to use the subclass's <code>__new__</code> method, but how is that different from using <code>type</code>?</span>
<span class="comment-copy">How is type supposed to magically know what kind of object you want it to make?</span>
<span class="comment-copy">well, because I tell it.  I passed in name, bases and dict.  What other piece of information do I need to give it?</span>
