<div class="post-text" itemprop="text">
<p>While developing a largeish project (split in several files and folders) in Python with IPython, I run into the trouble of cached imported modules.</p>
<p>The problem is that instructions <code>import module</code> only reads the module once, even if that module has changed! So each time I change something in my package, I have to quit and restart IPython. Painful.</p>
<p>Is there any way to properly force reloading some modules? Or, better, to somehow prevent Python from caching them?</p>
<p>I tried several approaches, but none works. In particular I run into really, really weird bugs, like some modules or variables mysteriously becoming equal to <code>None</code>...</p>
<p>The only sensible resource I found is <a href="http://pyunit.sourceforge.net/notes/reloading.html" rel="noreferrer">Reloading Python modules</a>, from pyunit, but I have not checked it. I would like something like that.</p>
<p>A good alternative would be for IPython to restart, or restart the Python interpreter somehow.</p>
<p>So, if you develop in Python, what solution have you found to this problem?</p>
<p><strong>Edit</strong></p>
<p>To make things clear: obviously, I understand that some old variables depending on the previous state of the module may stick around. That's fine by me. By why is that so difficult in Python to force reload a module without having all sort of strange errors happening?</p>
<p>More specifically, if I have my whole module in <strong>one</strong> file <code>module.py</code> then the following works fine:</p>
<pre><code>import sys
try:
    del sys.modules['module']
except AttributeError:
    pass
import module

obj = module.my_class()
</code></pre>
<p>This piece of code works beautifully and I can develop without quitting IPython for months.</p>
<p><em>However</em>, whenever my module is made of several submodules, hell breaks loose:</p>
<pre><code>import os
for mod in ['module.submod1', 'module.submod2']:
    try:
        del sys.module[mod]
    except AttributeError:
        pass
# sometimes this works, sometimes not. WHY?
</code></pre>
<p>Why is that so different for Python whether I have my module in one big file or in several submodules? Why would that approach not work??</p>
</div>
<div class="post-text" itemprop="text">
<p>Quitting and restarting the interpreter is the best solution. Any sort of live reloading or no-caching strategy will not work seamlessly because objects from no-longer-existing modules can exist and because modules sometimes store state and because even if your use case really does allow hot reloading it's too complicated to think about to be worth it.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>import</code> checks to see if the module is in <code>sys.modules</code>, and if it is, it returns it. If you want import to load the module fresh from disk, you can delete the appropriate key in <code>sys.modules</code> first.</p>
<p>There is the <code>reload</code> builtin function which will, given a module object, reload it from disk and that will get placed in <code>sys.modules</code>. <em>Edit</em> -- actually, it will recompile the code from the file on the disk, and then re-evalute it in the existing module's <code>__dict__</code>. Something potentially very different than making a new module object.</p>
<p>Mike Graham is right though; getting reloading right if you have even a few live objects that reference the contents of the module you don't want anymore is hard. Existing objects will still reference the classes they were instantiated from is an obvious issue, but also all references created by means of <code>from module import symbol</code> will still point to whatever object from the old version of the module. Many subtly wrong things are possible.</p>
<p><strong>Edit:</strong> I agree with the consensus that restarting the interpreter is by far the most reliable thing. But for debugging purposes, I guess you could try something like the following. I'm certain that there are corner cases for which this wouldn't work, but if you aren't doing anything too crazy (otherwise) with module loading in <em>your</em> package, it might be useful.</p>
<pre><code>def reload_package(root_module):
    package_name = root_module.__name__

    # get a reference to each loaded module
    loaded_package_modules = dict([
        (key, value) for key, value in sys.modules.items() 
        if key.startswith(package_name) and isinstance(value, types.ModuleType)])

    # delete references to these loaded modules from sys.modules
    for key in loaded_package_modules:
        del sys.modules[key]

    # load each of the modules again; 
    # make old modules share state with new modules
    for key in loaded_package_modules:
        print 'loading %s' % key
        newmodule = __import__(key)
        oldmodule = loaded_package_modules[key]
        oldmodule.__dict__.clear()
        oldmodule.__dict__.update(newmodule.__dict__)
</code></pre>
<p>Which I very briefly tested like so:</p>
<pre><code>import email, email.mime, email.mime.application
reload_package(email)
</code></pre>
<p>printing:</p>
<pre><code>reloading email.iterators
reloading email.mime
reloading email.quoprimime
reloading email.encoders
reloading email.errors
reloading email
reloading email.charset
reloading email.mime.application
reloading email._parseaddr
reloading email.utils
reloading email.mime.base
reloading email.message
reloading email.mime.nonmultipart
reloading email.base64mime
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With IPython comes the <a href="http://ipython.org/ipython-doc/stable/config/extensions/autoreload.html" rel="noreferrer">autoreload extension</a> that automatically repeats an import before each function call. It works at least in simple cases, but don't rely too much on it: in my experience, an interpreter restart is still required from time to time, especially when code changes occur only on indirectly imported code.</p>
<p>Usage example from the linked page:</p>
<pre><code>In [1]: %load_ext autoreload

In [2]: %autoreload 2

In [3]: from foo import some_function

In [4]: some_function()
Out[4]: 42

In [5]: # open foo.py in an editor and change some_function to return 43

In [6]: some_function()
Out[6]: 43
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are some really good answers here already, but it is worth knowing about dreload, which is a function available in IPython which does as "deep reload". From the documentation:</p>
<blockquote>
<p>The IPython.lib.deepreload module allows you to recursively reload a
  module: changes made to any of its dependencies will be reloaded
  without having to exit. To start using it, do:</p>
</blockquote>
<p><a href="http://ipython.org/ipython-doc/dev/interactive/reference.html#dreload" rel="nofollow">http://ipython.org/ipython-doc/dev/interactive/reference.html#dreload</a></p>
<p>It is available as a "global" in IPython notebook (at least my version, which is running v2.0).</p>
<p>HTH</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use import hook machinery described in <a href="http://www.python.org/dev/peps/pep-0302/" rel="nofollow">PEP 302</a> to load not modules themself but some kind of proxy object that will allow you to do anything you want with underlying module object — reload it, drop reference to it etc.</p>
<p>Additional benefit is that your currently existing code will not require change and this additional module functionality can be torn off from a single point in code — where you actually add finder into <code>sys.meta_path</code>.</p>
<p>Some thoughts on implementing: create finder that will agree to find any module, except of builtin (you have nothing to do with builtin modules), then create loader that will return proxy object subclassed from <code>types.ModuleType</code> instead of real module object. Note that loader object are not forced to create explicit references to loaded modules into <code>sys.modules</code>, but it's strongly encouraged, because, as you have already seen, it may fail unexpectably. Proxy object should catch and forward all <code>__getattr__</code>, <code>__setattr__</code> and <code>__delattr__</code> to underlying real module it's keeping reference to. You will probably don't need to define <code>__getattribute__</code> because of you would not hide real module contents with your proxy methods. So, now you should communicate with proxy in some way — you can create some special method to drop underlying reference, then import module, extract reference from returned proxy, drop proxy and hold reference to reloaded module. Phew, looks scary, but should fix your problem without reloading Python each time.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am using PythonNet in my project. Fortunately, I found there is a command which can perfectly solve this problem.</p>
<pre><code>using (Py.GIL())
        {
            dynamic mod = Py.Import(this.moduleName);
            if (mod == null)
                throw new Exception( string.Format("Cannot find module {0}. Python script may not be complied successfully or module name is illegal.", this.moduleName));

            // This command works perfect for me!
            PythonEngine.ReloadModule(mod);

            dynamic instance = mod.ClassName();
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/2918916/785673">Think twice for quitting and restarting in production</a> </p>
<p>The easy solution without quitting &amp; restarting is by using the reload from imp </p>
<pre><code>import moduleA, moduleB
from imp import reload
reload (moduleB)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>For Python version 3.4 and above</h1>
<pre><code>import importlib 
importlib.reload(&lt;package_name&gt;) 
from &lt;package_name&gt; import &lt;method_name&gt;
</code></pre>
<p>Refer below <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="nofollow noreferrer">documentation</a> for details.</p>
</div>
<span class="comment-copy">This is actually a pretty popular question; pop up every month. The current consensus is to restart your interpreter, as Mike pointed out.</span>
<span class="comment-copy">First, I can't see why are you suppressing <i>AttributeError</i>. There is simply no way <code>del sys.modules[mod]</code> will raise AttributeError... except if you rebound <code>sys</code> to something other than builtin sys module. Could it be simply that in second code, you have <code>sys.module</code> (which <i>will</i> raise AttributeError with normal sys), and in the first, you have <code>sys.modules</code>? :-P</span>
<span class="comment-copy">Superstition! Hot reloading is achieved relatively elegantly even in such general cases as <a href="http://pyunit.sourceforge.net/notes/reloading.html" rel="nofollow noreferrer">in PyUnit</a>, but in specific cases setting it up doesn't take long and pays off very well. For example, in my scheme there is a lightweight main module containing a singleton that all my other instances hang off, and that only calls their methods, not functions. Reloading is by <code>for each i: del sys.modules[mymodule_i]</code>, <code>reload(..)</code>-ing them, then swapping the <code>__class__</code> of each instance from old to new.</span>
<span class="comment-copy">Debuggable, understandable code is plain and simple. Adding complexity in this way is not sensible or reasonable. I don't recommend doing anything remotely as slick as this ever.</span>
<span class="comment-copy">Except perhaps if the target environment cannot be restarted so easily. Blender, for example, requires an application restart to clear the interpreter state which is horrible user experience for add-ons that get toggled on and off (the add-on UI allows this) if the add-on is larger than one module.</span>
<span class="comment-copy">I tried those approaches, both by deleting the appropriate entry in <code>sys.modules</code>, and by using <code>reload</code>. It occasionally works, but sometimes create very, very subtle and strange bugs, where some variables suddenly become <code>None</code> for no reason at all.</span>
<span class="comment-copy">"Doctor, it hurts when I go like this", "Well, don't do that".  I've always looked at <code>reload</code> as merely a convenience while debugging and think it a documentation bug that it is prescribed for actual live loading given how bad the semantic errors that it affords can be.</span>
<span class="comment-copy">I found the <code>del sys.modules[key]</code> line of your answer useful for my scenario. I agree this doesn't prevent caching as the question asked, but these functions could help one to build a behaviour like expiring the python cache periodically.</span>
<span class="comment-copy">I found that while <code>%autoreload 2</code> does not work when there are deep hierarchies, this solution always works:<a href="http://stackoverflow.com/a/13096672/311567">stackoverflow.com/a/13096672/311567</a> which I hope will become the default in ipython</span>
<span class="comment-copy">I believe the question is about restarting python interpreter. You seem to be using C# and python engine within it. ? Proabaly not what the OP is looking for.</span>
<span class="comment-copy">@user7175781 the syntax isn't working on my system no matter what I try. I guess PythonNet is different syntax and API than ipython.  I was hoping to get your example to work but after many errors reported by the interpreter I finally realized you said PythonNet language.</span>
