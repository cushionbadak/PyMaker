<div class="post-text" itemprop="text">
<p>Unless I'm mistaken, creating a function in Python works like this:</p>
<pre><code>def my_func(param1, param2):
    # stuff
</code></pre>
<p>However, you don't actually give the types of those parameters. Also, if I remember, Python is a strongly typed language, as such, it seems like Python shouldn't let you pass in a parameter of a different type than the function creator expected.  However, how does Python know that the user of the function is passing in the proper types? Will the program just die if it's the wrong type, assuming the function actually uses the parameter? Do you have to specify the type?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is strongly typed because every object <em>has</em> a type, every object <em>knows</em> its type, it's impossible to accidentally or deliberately use an object of a type "as if" it was an object of a <em>different</em> type, and all elementary operations on the object are delegated to its type.</p>
<p>This has nothing to do with <strong>names</strong>.  A <em>name</em> in Python doesn't "have a type": if and when a name's defined, the name refers to an <em>object</em>, and the <em>object</em> does have a type (but that doesn't in fact force a type on the <em>name</em>: a name is a name).</p>
<p>A name in Python can perfectly well refer to different objects at different times (as in most programming languages, though not all) -- and there is no constraint on the name such that, if it has once referred to an object of type X, it's then forevermore constrained to refer only to other objects of type X.  Constraints on <strong>names</strong> are not part of the concept of "strong typing", though some enthusiasts of <strong>static</strong> typing (where names <em>do</em> get constrained, and in a static, AKA compile-time, fashion, too) do misuse the term this way.</p>
</div>
<div class="post-text" itemprop="text">
<p>The other answers have done a good job at explaining duck typing and <a href="https://stackoverflow.com/questions/2489669/function-parameter-types-in-python/21384492#comment2574436_2489692">the simple answer by tzot</a>:</p>
<blockquote>
<p>Python does not have variables, like other languages where variables have a type and a value; it has names pointing to objects, which know their type.</p>
</blockquote>
<p><strong>However</strong>, one interesting thing has changed since 2010 (when the question was first asked), namely the implementation of <a href="http://www.python.org/dev/peps/pep-3107/" rel="noreferrer">PEP 3107</a> (implemented in Python 3). You can now actually specify the type of a parameter and the type of the return type of a function like this:</p>
<pre><code>def pick(l: list, index: int) -&gt; int:
    return l[index]
</code></pre>
<p>We can here see that <code>pick</code> takes 2 parameters, a list <code>l</code> and an integer <code>index</code>. It should also return an integer.</p>
<p>So here it is implied that <code>l</code> is a list of integers which we can see without much effort, but for more complex functions it can be a bit confusing as to what the list should contain. We also want the default value of <code>index</code> to be 0. To solve this you may choose to write <code>pick</code> like this instead:</p>
<pre><code>def pick(l: "list of ints", index: int = 0) -&gt; int:
    return l[index]
</code></pre>
<p>Note that we now put in a string as the type of <code>l</code>, which is syntactically allowed, but it is not good for parsing programmatically (which we'll come back to later).</p>
<p>It is important to note that Python won't raise a <code>TypeError</code> if you pass a float into <code>index</code>, the reason for this is one of the main points in Python's design philosophy: <em>"We're all consenting adults here"</em>, which means you are expected to be aware of what you can pass to a function and what you can't. If you really want to write code that throws TypeErrors you can use the <code>isinstance</code> function to check that the passed argument is of the proper type or a subclass of it like this:</p>
<pre><code>def pick(l: list, index: int = 0) -&gt; int:
    if not isinstance(l, list):
        raise TypeError
    return l[index]
</code></pre>
<p>More on why you should rarely do this and what you should do instead is talked about in the next section and in the comments. </p>
<p><a href="http://www.python.org/dev/peps/pep-3107/" rel="noreferrer">PEP 3107</a> does not only improve code readability but also has several fitting use cases which you can read about <a href="http://www.python.org/dev/peps/pep-3107/#use-cases" rel="noreferrer"><strong>here</strong></a>.</p>
<hr/>
<p>Type annotation got a lot more attention in Python 3.5 with the introduction of <a href="https://www.python.org/dev/peps/pep-0484/" rel="noreferrer">PEP 484</a> which introduces a standard module for type hints.</p>
<p>These type hints came from the type checker <a href="http://mypy-lang.org/" rel="noreferrer">mypy</a> (<a href="https://github.com/JukkaL/mypy" rel="noreferrer">GitHub</a>), which is now <a href="https://www.python.org/dev/peps/pep-0484/" rel="noreferrer">PEP 484</a> compliant.</p>
<p>With the typing module comes with a pretty comprehensive collection of type hints, including:</p>
<ul>
<li><code>List</code>, <code>Tuple</code>, <code>Set</code>, <code>Map</code> - for <code>list</code>, <code>tuple</code>, <code>set</code> and <code>map</code> respectively.</li>
<li><code>Iterable</code> - useful for generators.</li>
<li><code>Any</code> - when it could be anything.</li>
<li><code>Union</code> - when it could be anything within a specified set of types, as opposed to <code>Any</code>.</li>
<li><code>Optional</code> - when it <strong>might</strong> be None. Shorthand for <code>Union[T, None]</code>.</li>
<li><code>TypeVar</code> - used with generics.</li>
<li><code>Callable</code> - used primarily for functions, but could be used for other callables.</li>
</ul>
<p>These are the most common type hints. A complete listing can be found in the <a href="https://docs.python.org/3/library/typing.html" rel="noreferrer">documentation for the typing module</a>.</p>
<p>Here is the old example using the annotation methods introduced in the typing module:</p>
<pre><code>from typing import List

def pick(l: List[int], index: int) -&gt; int:
    return l[index]
</code></pre>
<p>One powerful feature is the <code>Callable</code> which allows you to type annotate methods that take a function as an argument. For example:</p>
<pre><code>from typing import Callable, Any, Iterable

def imap(f: Callable[[Any], Any], l: Iterable[Any]) -&gt; List[Any]:
    """An immediate version of map, don't pass it any infinite iterables!"""
    return list(map(f, l))
</code></pre>
<p>The above example could become more precise with the usage of <code>TypeVar</code> instead of <code>Any</code>, but this has been left as an exercise to the reader since I believe I've already filled my answer with too much information about the wonderful new features enabled by type hinting.</p>
<hr/>
<p>Previously when one documented Python code with for example <a href="http://sphinx-doc.org/" rel="noreferrer">Sphinx</a> some of the above functionality could be obtained by writing docstrings formatted like this:</p>
<pre><code>def pick(l, index):
    """
    :param l: list of integers
    :type l: list
    :param index: index at which to pick an integer from *l*
    :type index: int
    :returns: integer at *index* in *l*
    :rtype: int
    """
    return l[index]
</code></pre>
<p>As you can see, this takes a number of extra lines (the exact number depends on how explicit you want to be and how you format your docstring). But it should now be clear to you how <a href="http://www.python.org/dev/peps/pep-3107/" rel="noreferrer">PEP 3107</a> provides an alternative that is in many (all?) ways superior. This is especially true in combination with <a href="https://www.python.org/dev/peps/pep-0484/" rel="noreferrer">PEP 484</a> which, as we have seen, provides a standard module that defines a syntax for these type hints/annotations that can be used in such a way that it is unambiguous and precise yet flexible, making for a powerful combination.</p>
<p>In my personal opinion, this is one of the greatest features in Python ever. I can't wait for people to start harnessing the power of it. Sorry for the long answer, but this is what happens when I get excited.</p>
<hr/>
<p>An example of Python code which heavily uses type hinting can be found <a href="https://github.com/ActivityWatch/aw-core/blob/master/aw_core/models.py" rel="noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't specify a type.  The method will only fail (at runtime) if it tries to access attributes that are not defined on the parameters that are passed in.</p>
<p>So this simple function:</p>
<pre><code>def no_op(param1, param2):
    pass
</code></pre>
<p>... will not fail no matter what two args are passed in.</p>
<p>However, this function:</p>
<pre><code>def call_quack(param1, param2):
    param1.quack()
    param2.quack()
</code></pre>
<p>... will fail at runtime if <code>param1</code> and <code>param2</code> do not both have callable attributes named <code>quack</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Many languages have variables, which are of a specific type and have a value. Python does not have variables; it has objects, and you use names to refer to these objects.</p>
<p>In other languages, when you say:</p>
<pre><code>a = 1
</code></pre>
<p>then a (typically integer) variable changes its contents to the value 1.</p>
<p>In Python,</p>
<pre><code>a = 1
</code></pre>
<p>means “use the name <em>a</em> to refer to the object <em>1</em>”. You can do the following in an interactive Python session:</p>
<pre><code>&gt;&gt;&gt; type(1)
&lt;type 'int'&gt;
</code></pre>
<p>The function <code>type</code> is called with the object <code>1</code>; since every object knows its type, it's easy for <code>type</code> to find out said type and return it.</p>
<p>Likewise, whenever you define a function</p>
<pre><code>def funcname(param1, param2):
</code></pre>
<p>the function receives two objects, and names them <code>param1</code> and <code>param2</code>, regardless of their types. If you want to make sure the objects received are of a specific type, code your function as if they are of the needed type(s) and catch the exceptions that are thrown if they aren't. The exceptions thrown are typically <code>TypeError</code> (you used an invalid operation) and <code>AttributeError</code> (you tried to access an inexistent member (methods are members too) ).</p>
</div>
<div class="post-text" itemprop="text">
<p>Python is not strongly typed in the sense of static or compile-time type checking.</p>
<p>Most Python code falls under so-called <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="noreferrer">"Duck Typing"</a> -- for example, you look for a method <code>read</code> on an object -- you don't care if the object is a file on disk or a socket, you just want to read N bytes from it.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/questions/1549801/differences-between-isinstance-and-type-in-python/1549854#1549854">Alex Martelli explains</a>,</p>
<blockquote>
<p>The normal, Pythonic, preferred solution is almost invariably "duck typing": try using the argument as if it was of a certain desired type, do it in a try/except statement catching all exceptions that could arise if the argument was not in fact of that type (or any other type nicely duck-mimicking it;-), and in the except clause, try something else (using the argument "as if" it was of some other type).</p>
</blockquote>
<p>Read the rest of his post for helpful information.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't care what you pass in to its functions. When you call <code>my_func(a,b)</code>, the param1 and param2 variables will then hold the values of a and b. Python doesn't know that you are calling the function with the proper types, and expects the programmer to take care of that. If your function will be called with different types of parameters, you can wrap code accessing them with try/except blocks and evaluate the parameters in whatever way you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>You never specify the type; Python has the concept of <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="nofollow noreferrer">duck typing</a>; basically the code that processes the parameters will make certain assumptions about them - perhaps by calling certain methods that a parameter is expected to implement. If the parameter is of the wrong type, then an exception will be thrown.</p>
<p>In general it is up to your code to ensure that you are passing around objects of the proper type - there is no compiler to enforce this ahead of time.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's one notorious exception from the duck-typing worth mentioning on this page.</p>
<p>When <code>str</code> function calls <code>__str__</code> class method it subtly сhecks its type:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...     def __str__(self):
...         return 'a','b'
...
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; print a.__str__()
('a', 'b')
&gt;&gt;&gt; print str(a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: __str__ returned non-string (type tuple)
</code></pre>
<p>As if Guido hints us which exception should a program raise if it encounters an unexpected type.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python everything has a type. A Python function will do anything it is asked to do if the type of arguments support it.</p>
<p>Example: <code>foo</code> will add everything that can be <code>__add__</code>ed ;) without worrying much about its type. So that means, to avoid failure, you should provide only those things that support addition.</p>
<pre><code>def foo(a,b):
    return a + b

class Bar(object):
    pass

class Zoo(object):
    def __add__(self, other):
        return 'zoom'

if __name__=='__main__':
    print foo(1, 2)
    print foo('james', 'bond')
    print foo(Zoo(), Zoo())
    print foo(Bar(), Bar()) # Should fail
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I didn't see this mentioned in other answers, so I'll add this to the pot.</p>
<p>As others have said, Python doesn't enforce type on function or method parameters. It is assumed that you know what you're doing, and that if you really need to know the type of something that was passed in, you will check it and decide what to do for yourself.</p>
<p>One of the main tools for doing this is the isinstance() function.</p>
<p>For example, if I write a method that expects to get raw binary text data, rather than the normal utf-8 encoded strings, I could check the type of the parameters on the way in and either adapt to what I find, or raise an exception to refuse.</p>
<pre><code>def process(data):
    if not isinstance(data, bytes) and not isinstance(data, bytearray):
        raise TypeError('Invalid type: data must be a byte string or bytearray, not %r' % type(data))
    # Do more stuff
</code></pre>
<p>Python also provides all kinds of tools to dig into objects. If you're brave, you can even use importlib to create your own objects of arbitrary classes, on the fly. I did this to recreate objects from JSON data. Such a thing would be a nightmare in a static language like C++.</p>
</div>
<span class="comment-copy">I think the accepted answer in this question should be updated to be more in-line with the <i>current</i> capabilities that Python offers. I think <a href="https://stackoverflow.com/a/21384492/4594973">this answer</a> does the job.</span>
<span class="comment-copy">So it seems strong typing is not so strong, in this particular case, it's weaker than static typing.IMHO, compile time typing constraint on name/variable/reference is actually quite important, thus I boldly claim python is not as good as static typing on this aspect. Please correct me if I'm wrong.</span>
<span class="comment-copy">@liang That's an opinion, so you cannot be right or wrong. It is certainly also my opinion, and I've tried many languages. The fact that I cannot use my IDE to find out the type (and thus members) of the parameters is a major drawback of python. If this drawback is more important than the advantages of duck typing depends on the person you ask.</span>
<span class="comment-copy">But this doesn't answer any of the questions: "However, how does Python know that the user of the function is passing in the proper types? Will the program just die if it's the wrong type, assuming the function actually uses the parameter? Do you have to specify the type?" or..</span>
<span class="comment-copy">@qPCR4vir, any object can be passed as an argument. The error (an exception, the program won't "die" if it's coded to catch it, see <code>try</code>/<code>except</code>) will occur when and if an operation is attempted that the object doesn't support. In Python 3.5 you can now optionally "specify types" of arguments, but no error occurs, per se, if the spec's violated; the typing notation is only meant to help separate tools that perform analysis etc, it does not alter the behavior of Python itself.</span>
<span class="comment-copy">@AlexMartelli. Thank! For me this is the right answer: "The error (an exception, the program won't "die" if it's coded to catch it, see try/except) .."</span>
<span class="comment-copy">@rickfoosusa: I suspect you are not running Python 3 in which the feature was added.</span>
<span class="comment-copy">Wait a minute! If defining parameter and return type does not raise a <code>TypeError</code>, what is the point of using <code>pick(l: list, index: int) -&gt; int</code> like one-line defining then? Or I got it wrong, I don't know.</span>
<span class="comment-copy">@Eray Erdin: That's a common misunderstanding and not at all a bad question. It can be used for documentation purposes, helps IDEs do better autocompletion and find errors ahead of runtime by using static analysis (just like mypy that I mentioned in the answer). There are hopes that the runtime could take advantage of the information and actually speed up programs but that's likely going to take very long to get implemented. You <i>might</i> also be able to create a decorator that throws the TypeErrors for you (the information is stored in the <code>__annotations__</code> attribute of the function object).</span>
<span class="comment-copy">@ErdinEray I should add that throwing TypeErrors is a bad idea (debugging is never fun, no matter how well intended exceptions are raised). But do not fear, the advantage of the new features described in my answer enables a better way: do not rely on any checking at runtime, do everything ahead of runtime with mypy or use an editor which does the static analysis for you such as PyCharm.</span>
<span class="comment-copy">This should definitely be the accepted answer.</span>
<span class="comment-copy">+1: The attributes and methods are not determined statically.  The concept of how would this "proper type" or "wrong type" are established by whether or not the type works properly in the function.</span>
<span class="comment-copy">Python <i>is</i> strongly typed.  It is also dynamically typed.</span>
<span class="comment-copy">But this doesn't answer any of the questions: "However, how does Python know that the user of the function is passing in the proper types? Will the program just die if it's the wrong type, assuming the function actually uses the parameter? Do you have to specify the type?" or..</span>
<span class="comment-copy">Python does not have variables, like other languages where variables have a type and a value; it has <i>names</i> pointing to <i>objects</i>, which know their type.</span>
