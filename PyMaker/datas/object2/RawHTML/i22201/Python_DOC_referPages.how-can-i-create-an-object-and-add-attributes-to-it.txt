<div class="post-text" itemprop="text">
<p>I want to create a dynamic object (inside another object) in Python and then add attributes to it.</p>
<p>I tried:</p>
<pre><code>obj = someobject
obj.a = object()
setattr(obj.a, 'somefield', 'somevalue')
</code></pre>
<p>but this didn't work.</p>
<p>Any ideas?</p>
<p><em>edit:</em></p>
<p>I am setting the attributes from a <code>for</code> loop which loops through a list of values, e.g.</p>
<pre><code>params = ['attr1', 'attr2', 'attr3']
obj = someobject
obj.a = object()

for p in params:
   obj.a.p # where p comes from for loop variable
</code></pre>
<p>In the above example I would get <code>obj.a.attr1</code>, <code>obj.a.attr2</code>, <code>obj.a.attr3</code>.  </p>
<p>I used the <code>setattr</code> function because I didn't know how to do <code>obj.a.NAME</code> from a <code>for</code> loop.</p>
<p>How would I set the attribute based on the value of <code>p</code> in the example above?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use my ancient <a href="http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/?in=user-97991" rel="noreferrer">Bunch</a> recipe, but if you don't want to make a "bunch class", a very simple one already exists in Python -- all functions can have arbitrary attributes (including lambda functions).  So, the following works:</p>
<pre><code>obj = someobject
obj.a = lambda: None
setattr(obj.a, 'somefield', 'somevalue')
</code></pre>
<p>Whether the loss of clarity compared to the venerable <code>Bunch</code> recipe is OK, is a style decision I will of course leave up to you.</p>
</div>
<div class="post-text" itemprop="text">
<p>The built-in <code>object</code> can be instantiated but can't have any attributes set on it.  (I wish it could, for this exact purpose.)  It doesn't have a <code>__dict__</code> to hold the attributes.</p>
<p>I generally just do this:</p>
<pre><code>class Object(object):
    pass

a = Object()
a.somefield = somevalue
</code></pre>
<p>When I can, I give the <code>Object</code> class a more meaningful name, depending on what kind of data I'm putting in it.</p>
<p>Some people do a different thing, where they use a sub-class of <code>dict</code> that allows attribute access to get at the keys. (<code>d.key</code> instead of <code>d['key']</code>)</p>
<p><strong>Edit</strong>: For the addition to your question, using <code>setattr</code> is fine.  You just can't use <code>setattr</code> on <code>object()</code> instances.</p>
<pre><code>params = ['attr1', 'attr2', 'attr3']
for p in params:
    setattr(obj.a, p, value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer"><code>types.SimpleNamespace</code> class in Python 3.3+</a>:</p>
<pre><code>obj = someobject
obj.a = SimpleNamespace()
for p in params:
    setattr(obj.a, p, value)
# obj.a.attr1
</code></pre>
<p><a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noreferrer"><code>collections.namedtuple</code></a>, <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="noreferrer"><code>typing.NamedTuple</code></a> could be used for immutable objects. <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">PEP 557 -- Data Classes</a>  suggests a mutable alternative.</p>
<p>For a richer functionality, you could <a href="https://pypi.python.org/pypi/attrs" rel="noreferrer">try <code>attrs</code> package</a>. See <a href="https://stackoverflow.com/a/42659500/4279">an example usage</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few ways to reach this goal.
Basically you need an object which is extendable.</p>
<pre><code>obj.a = type('Test', (object,), {})  
obj.a.b = 'fun'  

obj.b = lambda:None

class Test:
  pass
obj.c = Test()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Now you can do (not sure if it's the same answer as evilpie):</p>
<pre><code>MyObject = type('MyObject', (object,), {})
obj = MyObject()
obj.value = 42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>mock</code> module is basically made for that.</p>
<pre><code>import mock
obj = mock.Mock()
obj.a = 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try the code below:</p>
<pre><code>$ python
&gt;&gt;&gt; class Container(object):
...     pass 
...
&gt;&gt;&gt; x = Container()
&gt;&gt;&gt; x.a = 10
&gt;&gt;&gt; x.b = 20
&gt;&gt;&gt; x.banana = 100
&gt;&gt;&gt; x.a, x.b, x.banana
(10, 20, 100)
&gt;&gt;&gt; dir(x)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', 
'__getattribute__', '__hash__', '__init__', '__module__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__',     '__sizeof__', 
'__str__', '__subclasshook__', '__weakref__', 'a', 'b', 'banana']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use a class object directly; it creates a namespace:</p>
<pre class="lang-py prettyprint-override"><code>class a: pass
a.somefield1 = 'somevalue1'
setattr(a, 'somefield2', 'somevalue2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>as <a href="http://docs.python.org/py3k/library/functions.html#object" rel="noreferrer">docs say</a>:</p>
<blockquote>
<p><strong>Note</strong>: <code>object</code> does <em>not</em> have a <code>__dict__</code>, so you canâ€™t assign arbitrary attributes to an instance of the <code>object</code> class.</p>
</blockquote>
<p>You could just use dummy-class instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>These solutions are very helpful during testing. Building on everyone else's answers I do this in Python 2.7.9 (without staticmethod I get a TypeError (unbound method...):</p>
<pre><code>In [11]: auth = type('', (), {})
In [12]: auth.func = staticmethod(lambda i: i * 2)
In [13]: auth.func(2)
Out[13]: 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Which objects are you using? Just tried that with a sample class and it worked fine:</p>
<pre><code>class MyClass:
  i = 123456
  def f(self):
    return "hello world"

b = MyClass()
b.c = MyClass()
setattr(b.c, 'test', 123)
b.c.test
</code></pre>
<p>And I got <code>123</code> as the answer.</p>
<p>The only situation where I see this failing is if you're trying a <code>setattr</code> on a builtin object.</p>
<p>Update: From the comment this is a repetition of: <a href="https://stackoverflow.com/questions/1285269/why-cant-you-add-attributes-to-object-in-python">Why can't you add attributes to object in python?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Coming to this late in the day but here is my pennyworth with an object that just happens to hold some useful paths in an app but you can adapt it for anything where you want a sorta dict of information that you can access with getattr and dot notation (which is what I think this question is really about):</p>
<pre><code>import os

def x_path(path_name):
    return getattr(x_path, path_name)

x_path.root = '/home/x'
for name in ['repository', 'caches', 'projects']:
    setattr(x_path, name, os.path.join(x_path.root, name))
</code></pre>
<p>This is cool because now:</p>
<pre><code>In [1]: x_path.projects
Out[1]: '/home/x/projects'

In [2]: x_path('caches')
Out[2]: '/home/x/caches'
</code></pre>
<p>So this uses the function object like the above answers but uses the function to get the values (you can still use <code>(getattr, x_path, 'repository')</code> rather than <code>x_path('repository')</code> if you prefer).</p>
</div>
<div class="post-text" itemprop="text">
<p>If we can determine and aggregate all the attributes and values together before creating the nested object, then we could create a new class that takes a dictionary argument on creation.</p>
<pre><code># python 2.7

class NestedObject():
    def __init__(self, initial_attrs):
        for key in initial_attrs:
            setattr(self, key, initial_attrs[key])

obj = someobject
attributes = { 'attr1': 'val1', 'attr2': 'val2', 'attr3': 'val3' }
obj.a = NestedObject(attributes)
&gt;&gt;&gt; obj.a.attr1
'val1'
&gt;&gt;&gt; obj.a.attr2
'val2'
&gt;&gt;&gt; obj.a.attr3
'val3'
</code></pre>
<p>We can also allow keyword arguments. See <a href="https://stackoverflow.com/a/2466207/3446655">this post</a>. </p>
<pre><code>class NestedObject(object):
    def __init__(self, *initial_attrs, **kwargs):
        for dictionary in initial_attrs:
            for key in dictionary:
                setattr(self, key, dictionary[key])
        for key in kwargs:
            setattr(self, key, kwargs[key])


obj.a = NestedObject(attr1='val1', attr2='val2', attr3= 'val3')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>di = {}
for x in range(20):
    name = '_id%s' % x
    di[name] = type(name, (object), {})
    setattr(di[name], "attr", "value")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Other way i see, this way:</p>
<pre><code>import maya.cmds

def getData(objets=None, attrs=None):
    di = {}
    for obj in objets:
        name = str(obj)
        di[name]=[]
        for at in attrs:
            di[name].append(cmds.getAttr(name+'.'+at)[0])
    return di

acns=cmds.ls('L_vest_*_',type='aimConstraint')
attrs=['offset','aimVector','upVector','worldUpVector']

getData(acns,attrs)
</code></pre>
</div>
<span class="comment-copy">What do you mean by "didn't work"? I assume it raised an AttributeError exception, right?</span>
<span class="comment-copy">yeah. 'object' object has no attribute 'somefield'</span>
<span class="comment-copy">Why are you doing this?  A generic "object" has no actual <i>meaning</i>.  What is the <i>meaning</i> of the thing you are creating?  Why is it not a proper class or namedtuple?</span>
<span class="comment-copy">The example is not minimal and confusing for me or I just don't see why you don't work with some <code>a = object()</code> and you need <code>obj.a = object()</code>. Again I am talking about the example, in your actual code an object inside an object might be useful.</span>
<span class="comment-copy">I like the <code>Bunch</code> recipe, but I don't like the lambda hack.</span>
<span class="comment-copy">@FogleBird, a style decision, as I mentioned.  Some CS experts trained e.g. in Church's lambda calculus are used to thinking of functions (lambdas) as the fundamental type of all data (the integer 23, for example, can be seen as equivalent to <code>lambda: 23</code>), so to such experts using <code>lambda</code>s for this purpose would presumably feel nothing like "a hack". Personally, I don't like <code>lambda</code> <i>in Python</i> very much -- but that's very much an issue of personal taste.</span>
<span class="comment-copy">And in some cases, considering whether or not the <code>lambda</code> pattern fits for your use case may lead you to realize that something you'd originally thought of as data is actually more like a function anyway--or, in any case, a functor.</span>
<span class="comment-copy">@naught101, a function <b>is</b> an object, in Python, so your objection is unfathomable.</span>
<span class="comment-copy">@naught101, avoiding the creation of a new type (reusing an existing one) does not complicate, it simplifies.  Nowadays on might actually prefer <code>from argparse import Namespace</code> though I wish it lived elsewhere *e.g, <code>collection</code>) -- again reusing a now-existing type, just a better one, and still avoiding new-type creation.  But, it wasn't there then:-).</span>
<span class="comment-copy">it <i>can</i> be instantiated, just not used for anything useful once it has been done.  <code>foo = object()</code> works, but you just can't do much of anything with it</span>
<span class="comment-copy">Oh right, I'll update my answer.</span>
<span class="comment-copy">Hi. Thanks for the answer. I've updated my problem above. see the edit. do you know the answer to this?</span>
<span class="comment-copy">sorry I still want to set it on the object. see update above.</span>
<span class="comment-copy">The code I wrote does what you described.</span>
<span class="comment-copy">This is a great answer.</span>
<span class="comment-copy">This is The Anwer. Thanks. Did not know about this.   from types import SimpleNamespace ... obj = SimpleNamespace() obj.a = "foo"</span>
<span class="comment-copy">If you need something that works with Python 2.7, you can also try the <code>argparse.Namespace</code> class</span>
<span class="comment-copy">Amazing answer, should be the accepted.</span>
<span class="comment-copy">Agreed - I'd be curious if there is a downside here, but this is an incredibly handy python 3.3+ affordance.</span>
<span class="comment-copy"><code>obj.a = type('', (), {})</code></span>
<span class="comment-copy">@evilpie's answer sets attributes directly on MyObject (the class), not its instance like yours.</span>
<span class="comment-copy">Disadvantge is that's an external dependency</span>
<span class="comment-copy"><code>unittest.Mock</code> is a part of the standard library since Python 3.3 (<a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a>)</span>
<span class="comment-copy">Depends on the usage of your code I think. If it is production code, I would not want some <code>mock</code> in it. Just feels weird to me.</span>
<span class="comment-copy">Can you explain more of what this does? while the code may be useful for solving this problem, having it explained can go a lot further than just one problem.</span>
<span class="comment-copy">@DeadChex Clearly it creates a new Class(object) which is a empty class with object properties, and stores the attributes inside the class. This is even better than install more modules, or rely in lambdas.</span>
<span class="comment-copy">Not sure why this does not have more upvotes. Is there a reason not to use this for a basic container class? Seems to work fine in Python 2.7, 2.6, and 3.4</span>
<span class="comment-copy">b.c is set to object() not a defined class</span>
<span class="comment-copy">you can add in append the name attr this di[name].append([at,cmds.getAttr(name+'.'+at)[0]])</span>
<span class="comment-copy">This is adding a very big non-standard dependency while a simple <code>class a: pass</code> gives all the power required.</span>
