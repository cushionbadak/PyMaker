<div class="post-text" itemprop="text">
<p>Having a simple Python class like this:</p>
<pre><code>class Spam(object):
    __init__(self, description, value):
        self.description = description
        self.value = value
</code></pre>
<p>I would like to check the following constraints:</p>
<ul>
<li>"description cannot be empty"</li>
<li>"value must be greater than zero"</li>
</ul>
<p>Should I:<br/>
1. validate data before creating spam object ?<br/>
2. check data on <code>__init__</code> method ?<br/>
3. create an <code>is_valid</code> method  on Spam class and call it with spam.isValid() ?<br/>
4. create an <code>is_valid</code> static method on Spam class and call it with Spam.isValid(description, value) ?<br/>
5. check data on setters declaration ?<br/>
6. etc. </p>
<p>Could you recommend a well designed/Pythonic/not verbose (on class with many attributes)/elegant approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use Python <a href="http://docs.python.org/library/functions.html#property" rel="noreferrer">properties</a> to cleanly apply rules to each field separately, and enforce them even when client code tries to change the field:</p>
<pre><code>class Spam(object):
    def __init__(self, description, value):
        self.description = description
        self.value = value

    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, d):
        if not d: raise Exception("description cannot be empty")
        self._description = d

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v):
        if not (v &gt; 0): raise Exception("value must be greater than zero")
        self._value = v
</code></pre>
<p>An exception will be thrown on any attempt to violate the rules, even in the <code>__init__</code> function, in which case object construction will fail.</p>
<p><strong>UPDATE:</strong> Sometime between 2010 and now, I learned about <code>operator.attrgetter</code>:</p>
<pre><code>import operator

class Spam(object):
    def __init__(self, description, value):
        self.description = description
        self.value = value

    description = property(operator.attrgetter('_description'))

    @description.setter
    def description(self, d):
        if not d: raise Exception("description cannot be empty")
        self._description = d

    value = property(operator.attrgetter('_value'))

    @value.setter
    def value(self, v):
        if not (v &gt; 0): raise Exception("value must be greater than zero")
        self._value = v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you only want to validate the values when the object is created AND passing in invalid values is considered a programming error then I would use assertions:</p>
<pre><code>class Spam(object):
    def __init__(self, description, value):
        assert description != ""
        assert value &gt; 0
        self.description = description
        self.value = value
</code></pre>
<p>This is about as concise as you are going to get, and clearly documents that these are preconditions for creating the object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless you're hellbent on rolling your own, you can simply use <a href="http://formencode.org/" rel="noreferrer">formencode</a>. It really shines with many attributes and schemas (just subclass schemas) and has a lot of useful validators builtin. As you can see this is the "validate data before creating spam object" approach.</p>
<pre><code>from formencode import Schema, validators

class SpamSchema(Schema):
    description = validators.String(not_empty=True)
    value = validators.Int(min=0)

class Spam(object):
    def __init__(self, description, value):
        self.description = description
        self.value = value

## how you actually validate depends on your application
def validate_input( cls, schema, **input):
    data = schema.to_python(input) # validate `input` dict with the schema
    return cls(**data) # it validated here, else there was an exception

# returns a Spam object
validate_input( Spam, SpamSchema, description='this works', value=5) 

# raises an exception with all the invalid fields
validate_input( Spam, SpamSchema, description='', value=-1) 
</code></pre>
<p>You could do the checks during <code>__init__</code> too (and make them completely transparent with descriptors|decorators|metaclass), but I'm not a big fan of that. I like a clean barrier between user input and internal objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>if you want to only validate those values passed to the constructor, you could do:</p>
<pre><code>class Spam(object):
    def __init__(self, description, value):
        if not description or value &lt;=0:
            raise ValueError
        self.description = description
        self.value = value
</code></pre>
<p>This will of course will not prevent anyone from doing something like this:</p>
<pre><code>&gt;&gt;&gt; s = Spam('s', 5)
&gt;&gt;&gt; s.value = 0
&gt;&gt;&gt; s.value
0
</code></pre>
<p>So, correct approach depends on what you're trying to accomplish.</p>
</div>
<span class="comment-copy">+1 elegant solution thanks, dont' you think is a little bit verbose for a small class like that?</span>
<span class="comment-copy">Agreed, it isn't the prettiest solution. Python prefers free-range classes (think chickens), and the idea of properties controlling access was a bit of an afterthought. Having said that, this wouldn't be much more concise in any other language I can think of.</span>
<span class="comment-copy">@MarceloCantos I realize this is an old question, but based on the <a href="http://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">documentation</a> (albeit for Python 3), should <code>self.description = description</code> use an underscore, i.e. <code>self._description = description</code>, or does that not matter? Is this necessary or merely something similar to Python's version of "private" variables?</span>
<span class="comment-copy">@JohnBensin: Yes and no. <code>self.description = …</code> assigns through property, whereas <code>self._description = …</code> assigns directly to the underlying field. Which one to use during construction is a design choice, but it's usually safer to always assign through the property. For example, the above code will raise an exception if you call <code>Spam('', 1)</code>, as it should.</span>
<span class="comment-copy">I do not think it is too verbose. The alternative is for it to be possible to set the value to invalid values.</span>
<span class="comment-copy">thanks Dave, using assert, how do i specify to the client of that class what went wrong (description or value)? Don't you think that assertion should be used just to test conditions that should never happen?</span>
<span class="comment-copy">You can add a message to the assert statement e.g <code>assert value &gt; 0, "value attribute to Spam must be greater than zero"</code>. Assertions are really messages to the developer and should not be caught by client code, since they indicate a programming error.  If you want the client to catch and handle the error then explicitly raise an exception such as ValueError, as shown in the other answers.</span>
<span class="comment-copy">To answer your second question, yes asserts should be used to test conditions that should never happen - that is why I said "if passing in invalid values is considered a programming error...".  If that is not the case then don't use asserts.</span>
<span class="comment-copy"><code>def  </code>should be inserted prior to <code>__init__</code></span>
<span class="comment-copy">Thanks @datapug, fixed the typo.</span>
<span class="comment-copy">this is my actual approach; but i don't like it when attributes number raise and\or constraints checks are more sophisticated.It seems to clutter the init method too much.</span>
<span class="comment-copy">@system: you can separate validity check into its own method: there are not hard and fast rules about this situation.</span>
