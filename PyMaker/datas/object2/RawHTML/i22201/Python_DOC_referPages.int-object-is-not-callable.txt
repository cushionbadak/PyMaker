<div class="post-text" itemprop="text">
<p>I'm trying to define a simply <code>Fraction</code> class </p>
<p>And I'm getting this error:</p>
<pre><code>python fraction.py 
Traceback (most recent call last):
File "fraction.py", line 20, in &lt;module&gt;
   f.numerator(2)
TypeError: 'int' object is not callable
</code></pre>
<p>The code follows:</p>
<pre><code>class Fraction(object):
    def __init__( self,  n=0, d=0 ):
       self.numerator = n
       self.denominator = d
    def get_numerator(self):
        return self.numerator
    def get_denominator(self):
         return self.denominator

    def numerator(self, n):
         self.numerator = n
    def denominator( self, d ):
         self.denominator = d

    def prints( self ):
          print "%d/%d" %(self.numerator, self.denominator)

if __name__ == "__main__":
    f = Fraction()
    f.numerator(2)
    f.denominator(5)
    f.prints()
</code></pre>
<p>I thought it was because I had <code>numerator(self)</code> and <code>numerator(self, n)</code> but now I know Python doesn't have method overloading ( function overloading )  so I renamed to <code>get_numerator</code> but that's not the problems. </p>
<p>What could it be?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're using <code>numerator</code> as both a method name (<code>def numerator(...)</code>) and member variable name (<code>self.numerator = n</code>). Use <code>set_numerator</code> and <code>set_denominator</code> for the method names and it will work.</p>
<p>By the way, Python 2.6 has a built-in <a href="http://docs.python.org/library/fractions.html" rel="noreferrer">fraction class</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't overload the name <code>numerator</code> to refer to both the member variable and the method.  When you set <code>self.numerator = n</code>, you're overwriting the reference to the method, and so when you call <code>f.numerator(2)</code>, it's trying to do a method call on the member variable, which is an <code>int</code>, and Python doesn't let you do that.  It's like saying <code>x = 2; x(4)</code> -- it just doesn't make any sense.</p>
<p>You should rename the setter methods to <code>set_numerator</code> and <code>set_denominator</code> to remove this naming conflict.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li><p>You are using <code>numerator</code> as both a method name and a name for an instance attribute. Since methods are stored on the class, when you lookup that attribute you get the number, not the method. (Python will look up attributes on the instance before looking at the class.)</p>
<p>That is to say that on the line where you say <code>f.numerator(2)</code>, it looks up <code>f.numerator</code> and finds that it is <code>0</code>, then tries to call that <code>0</code>, which obviously shouldn't work.</p></li>
<li><p>If you have any practical purpose for this code, you can use the stdlib <code>fractions</code> module: <a href="http://docs.python.org/library/fractions.html" rel="noreferrer">http://docs.python.org/library/fractions.html</a></p>
<ul>
<li>This is new in Python 2.6. If I needed to represent fractions but was using an earlier version of Python, I'd probably use <a href="http://code.google.com/p/sympy/" rel="noreferrer">sympy</a>'s <code>Rational</code> type.</li>
</ul></li>
<li><p>A more practical default value for <code>denominator</code> is probably <code>1</code>.  (That way <code>Fraction(5)</code> would be five, not some undefined operation tending towards infinity.)</p></li>
<li><p>Rather than a <code>prints</code> method, it would be more typical to define <code>__str__</code> and just print your object.</p></li>
<li><p>Your methods are just getting and setting an attribute. In Python, we generally do not use getters and setters—we just let users set our attributes.</p>
<ul>
<li>You're coming from a Java background, where one of the basic rules is always to use getter and setter methods rather than let users access attributes. The rationale for this rule is that if, at some future date, you needed to do more than just get and set (you needed to process the data), it would require an API change. Since in Python we have properties, we would not need an API change in that instance so we can safely avoid the boilerplate and cruft of setters and getters.</li>
</ul></li>
<li><p>It wouldn't hurt to inherit <code>numbers.Rational</code> (Python 2.6 and up), which lets your class automatically do several things numbers are expected to. You will have to implement everything it needs you to, but then it will automatically make a lot more work. Check out Check out <a href="http://docs.python.org/library/numbers.html" rel="noreferrer">http://docs.python.org/library/numbers.html</a> to learn more.</p></li>
</ul>
<hr/>
<p>Spoiler alert:</p>
<pre><code>class Fraction(object):
    """Don't forget the docstring....."""

    def __init__(self, numerator=0, denominator=1):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return "%d / %d" % (self.numerator, self.denominator)

    # I probably want to implement a lot of arithmetic and stuff!

if __name__ == "__main__":
    f = Fraction(2, 5)
    # If I wanted to change the numerator or denominator at this point, 
    # I'd just do `f.numerator = 4` or whatever.
    print f
</code></pre>
</div>
<span class="comment-copy">As a beginner, you should learn, that in Python there is no need for getter and setter methods in these simple cases. Having just attributes for the numerator and denominator is just fine and accepted. And if you really want to be explicit about getter and setter <i>functions</i>, you should make your attributes protected with an underscore. Either way, your name-clashing problem won’t occur.</span>
<span class="comment-copy">Got it!, so, if my attribute is <code>numerator</code> I can't have any other method with that name, right? ( either a "setter" or "getter"  or any other )  Extra question, I had a syntax error when I tried to use the name "print" for my print method, so I had to name it <code>prints</code> is this because <code>print</code> is defined in object? or because it is global or something?</span>
<span class="comment-copy">About the fraction class thanks. I'm just learning, I'm doing some sort of <code>language showcase</code> with this class in Python, Ruby, Go, Java, Objective-C.</span>
<span class="comment-copy">@Oscar Reyes: In Python 2.x <code>print</code> is a keyword (used for the <code>print</code> statement), so you can't use it to name your methods or variables. In Python 3.x <code>print</code> is not a keyword anymore.</span>
<span class="comment-copy">Better than renaming the setter to <code>set_numerator</code> would be to use <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a> instead. Getters and setters are unpythonic.</span>
<span class="comment-copy">+1 Ahh no , just to learn the syntax. Actually this gave me a good idea: <a href="http://stackoverflow.com/questions/2702450/implement-a-simple-class-in-your-favorite-language" title="implement a simple class in your favorite language">stackoverflow.com/questions/2702450/…</a></span>
<span class="comment-copy">About the properties, it is also used ( in Java ) to keep the attributes private, so subclasses can't accesses them ( and probably  temper them ). I have always wondered: Can Python have private members? I see <code>__</code> everywhere, but I think that's just a naming convention isn't ?</span>
<span class="comment-copy">@Oscar, Keep in mind that programming languages (like natural languages) sometimes do not lend themselves to direct literal translation. In particular, things like using direct access to attributes (rather than getters and setters) is the right way to do it in Python even though it would be anathema in Java. This takes you all the way back to thinks like your UML diagrams which theoretically weren't supposed to have anything to do with the implementation language.</span>
<span class="comment-copy">@Oscar, Private attributes do not exist in Python. The convention for an attribute that is not part of a public API is to use a single leading underscore, like <code>_foo</code>. Double leading underscore (and no more than one trailing underscore) like <code>__foo</code> name-mangles the attribute; some people use them for fake private attributes, but it doesn't effectively provide that. I don't use or like <code>__foo</code>, which makes my code harder to subclass, test, and maintain, and it isn't too widely likely among Python people.</span>
<span class="comment-copy">In Python, properties (<a href="http://docs.python.org/library/functions.html#property" rel="nofollow noreferrer">docs.python.org/library/functions.html#property</a>) can be used to provide read-only attributes and sometimes are, but for the most part this is seen as misguided: if you don't want a user to modify an attribute, say not to in your documentation. It probably wouldn't make sense to anyway! If your use does anyhow, that isn't your fault; if it wasn't this, a sufficiently dumb user would find a way to use your code wrong anyhow. Trying to control what the user of your code does with it is a losing proposition. Besides, we're all consenting adults here.</span>
