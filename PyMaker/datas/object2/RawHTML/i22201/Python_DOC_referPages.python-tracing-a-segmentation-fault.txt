<div class="post-text" itemprop="text">
<p>I'm developing C extensions from python ad I obtain some segfaults (inevitable during the development...).</p>
<p>I'm searching a way to display at which line of code the segfault happens (an idea is like tracing every single line of code), how I can do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to output the filename and line number of every line of Python your code runs:</p>
<pre><code>import sys

def trace(frame, event, arg):
    print "%s, %s:%d" % (event, frame.f_code.co_filename, frame.f_lineno)
    return trace

def test():
    print "Line 8"
    print "Line 9"

sys.settrace(trace)
test()
</code></pre>
<p>Output:</p>
<pre><code>call, test.py:7
line, test.py:8
Line 8
line, test.py:9
Line 9
return, test.py:9
</code></pre>
<p>(You'd probably want to write the trace output to a file, of course.)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are on linux, run python under gdb</p>
<pre><code>gdb python
(gdb) run /path/to/script.py
## wait for segfault ##
(gdb) backtrace
## stack trace of the c code
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Segfaults from C extensions are very frequently a result of not incrementing a reference count when you create a new reference to an object. That makes them very hard to track down as the segfault occurs only after the last reference is removed from the object, and even then often only when some other object is being allocated.</p>
<p>You don't say how much C extension code you have written so far, but if you're just starting out consider whether you can use either ctypes or <a href="http://www.cython.org/" rel="noreferrer">Cython</a>. Ctypes may not be flexible enough for your needs, but you should be able to link to just about any C library with Cython and have all the reference counts maintained for you automatically.</p>
<p>That isn't always sufficient: if your Python objects and any underlying C objects have different lifetimes you can still get problems, but it does simplify things considerably.</p>
</div>
<div class="post-text" itemprop="text">
<p>I came here looking for a solution to the same problem, and none of the other answers helped me. What did help was <a href="https://docs.python.org/3/library/faulthandler.html" rel="noreferrer"><code>faulthandler</code></a>, and you can install it in Python 2.7 just using <code>pip install</code>.</p>
<p><code>faulthandler</code> was introduced to Python only in version 3.3, that was released in September 2012, which was after most other answers here were written.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are somewhat undocumented python extensions for gdb.</p>
<p>From the Python source grab <a href="https://hg.python.org/cpython/file/15c95b7d81dc/Tools/gdb/libpython.py" rel="nofollow"><code>Tools/gdb/libpython.py</code></a> (it is not included in a normal install). </p>
<p>Put this in <code>sys.path</code></p>
<p>Then:</p>
<pre><code># gdb /gps/python2.7_x64/bin/python coredump
...
Core was generated by `/usr/bin/python script.py'.
Program terminated with signal 11, Segmentation fault.
#0  call_function (oparg=&lt;optimized out&gt;, pp_stack=0x7f9084d15dc0) at Python/ceval.c:4037
...
(gdb) python
&gt;import libpython
&gt;
&gt;end
(gdb) bt
#0  call_function (oparg=&lt;optimized out&gt;, pp_stack=0x7f9084d15dc0) at Python/ceval.c:4037
#1  PyEval_EvalFrameEx (f=f@entry=
    Frame 0x7f9084d20ad0, 
    for file /usr/lib/python2.7/site-packages/librabbitmq/__init__.py, line 220, 
    in drain_events (self=&lt;Connection(channels={1: &lt;Channel(channel_id=1, connection=&lt;...&gt;, is_open=True, connect_timeout=4, _default_channel=&lt;....(truncated), throwflag=throwflag@entry=0) at Python/ceval.c:2681
...
(gdb) py-list
 218            else:
 219                timeout = float(timeout)
&gt;220            self._basic_recv(timeout)
 221
 222        def channel(self, channel_id=None):
</code></pre>
<p>As you can see we now have visibility into the Python stack corresponding with the CPython call chain.</p>
<p>Some caveats:</p>
<ul>
<li>Your version of gdb needs to be greater than 7 and it needs to have been compiled with <code>--with-python</code></li>
<li><code>gdb</code> embeds python (by linking to <code>libpython</code>), it doesn't run it in a subshell. This means that It may not necessarily match the version of python that is on <code>$PATH</code>. </li>
<li>You need to download <code>libpython.py</code> from whatever version of the Python source that matches whatever <code>gdb</code> is linked to. </li>
<li>You may have to run gdb as root - if so you may need to set up <code>sys.path</code> to match that of the code that you are debugging. </li>
</ul>
<p>If you cannot copy <code>libpython.py</code> into <code>sys.path</code> then you can add it's location to <code>sys.path</code> like this:</p>
<pre><code>(gdb) python
&gt;import sys
&gt;sys.path.append('/path/to/containing/dir/')
&gt;import libpython
&gt;
&gt;end
</code></pre>
<p>This is somewhat poorly documented in the <a href="https://docs.python.org/devguide/gdb.html" rel="nofollow">python dev docs</a>, <a href="https://fedoraproject.org/wiki/Features/EasierPythonDebugging" rel="nofollow">the fedora wiki</a> and <a href="https://wiki.python.org/moin/DebuggingWithGdb" rel="nofollow">the python wiki</a></p>
<p>If you have an older <code>gdb</code> or just can't get this working there is also a <a href="https://hg.python.org/cpython/file/15c95b7d81dc/Misc/gdbinit" rel="nofollow">gdbinit</a> in the Python source that you can copy to <code>~/.gdbinit</code> which add some similar functionality </p>
</div>
<span class="comment-copy">Does this work with C extensions?</span>
<span class="comment-copy">@MadPhysicist: It won't print the line numbers of your C code, if that's what you mean.  :-)  It will print the line numbers of the Python code that calls into your C code.</span>
<span class="comment-copy">That was what I meant. I found the original question interesting because I had the same problem. The segfault turned out to be because my C code was inserting a NULL element into a PyList_Object. It manifested itself on the Python side when I tried to iterate over the list. Not sure a python debugger would have helped much in that case.</span>
<span class="comment-copy">If you've got a core file already, you can use <code>gdb python core</code> (or whatever the core file is called). If you're on OSX, core dumps (not generated by default; see <code>ulimit -c</code>) are stored in the directory <code>/cores</code>.</span>
<span class="comment-copy">I really wish this was the first answer for me as reading all the others took considerable time I'd rather have spent running down my bug.</span>
<span class="comment-copy">If you get a segfault while running a Python unit test like <code>python -m unittest my.module.tests.mytest</code>, then the <code>-m</code> switch confuses <code>gdb</code>. Invoke using the <code>--args</code> option thusly: <code>gdb --args python -m unittest my.module.tests.mytest</code></span>
<span class="comment-copy">Also, putting NULLs in places where they don't belong.</span>
<span class="comment-copy">Nice! If you can read stdout of your Python program, usage is as easy as: <code>import faulthandler; faulthandler.enable()</code></span>
