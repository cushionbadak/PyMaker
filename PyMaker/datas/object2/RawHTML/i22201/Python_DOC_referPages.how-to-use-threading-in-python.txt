<div class="post-text" itemprop="text">
<p>I am trying to understand threading in Python. I've looked at the documentation and examples, but quite frankly, many examples are overly sophisticated and I'm having trouble understanding them.</p>
<p>How do you clearly show tasks being divided for multi-threading?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since this question was asked in 2010, there has been real simplification in how to do simple multithreading with python with <strong><a href="https://docs.python.org/2/library/functions.html#map" rel="noreferrer">map</a></strong> and <strong><a href="https://docs.python.org/2/library/multiprocessing.html" rel="noreferrer">pool</a></strong>.</p>
<p>The code below comes from an article/blog post that you should definitely check out (no affiliation) - <strong><a href="https://chriskiehl.com/article/parallelism-in-one-line" rel="noreferrer">Parallelism in one line:
A Better Model for Day to Day Threading Tasks</a></strong>.  I'll summarize below - it ends up being just a few lines of code:</p>
<pre><code>from multiprocessing.dummy import Pool as ThreadPool 
pool = ThreadPool(4) 
results = pool.map(my_function, my_array)
</code></pre>
<p>Which is the multithreaded version of:</p>
<pre><code>results = []
for item in my_array:
    results.append(my_function(item))
</code></pre>
<hr/>
<p><strong>Description</strong></p>
<blockquote>
<p>Map is a cool little function, and the key to easily injecting parallelism into your Python code. For those unfamiliar, map is something lifted from functional languages like Lisp. It is a function which maps another function over a sequence.</p>
<p>Map handles the iteration over the sequence for us, applies the function, and stores all of the results in a handy list at the end.</p>
</blockquote>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/Yq37m.png"/></p>
<hr/>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Parallel versions of the map function are provided by two libraries:multiprocessing, and also its little known, but equally fantastic step child:multiprocessing.dummy.</p>
</blockquote>
<p><code>multiprocessing.dummy</code> is exactly the same as multiprocessing module, <a href="https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.dummy" rel="noreferrer">but uses threads instead</a> (<em><a href="https://medium.com/@bfortuner/python-multithreading-vs-multiprocessing-73072ce5600b" rel="noreferrer">an important distinction</a> - use multiple processes for CPU-intensive tasks; threads for (and during) IO</em>):</p>
<blockquote>
<p>multiprocessing.dummy replicates the API of multiprocessing but is no more than a wrapper around the threading module.</p>
</blockquote>
<pre><code>import urllib2 
from multiprocessing.dummy import Pool as ThreadPool 

urls = [
  'http://www.python.org', 
  'http://www.python.org/about/',
  'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html',
  'http://www.python.org/doc/',
  'http://www.python.org/download/',
  'http://www.python.org/getit/',
  'http://www.python.org/community/',
  'https://wiki.python.org/moin/',
]

# make the Pool of workers
pool = ThreadPool(4) 

# open the urls in their own threads
# and return the results
results = pool.map(urllib2.urlopen, urls)

# close the pool and wait for the work to finish 
pool.close() 
pool.join() 
</code></pre>
<p>And the timing results:</p>
<pre><code>Single thread:   14.4 seconds
       4 Pool:   3.1 seconds
       8 Pool:   1.4 seconds
      13 Pool:   1.3 seconds
</code></pre>
<hr/>
<p><strong>Passing multiple arguments</strong> (works like this <a href="https://stackoverflow.com/a/28975239/2327328">only in Python 3.3 and later</a>):</p>
<p>To pass multiple arrays:</p>
<pre><code>results = pool.starmap(function, zip(list_a, list_b))
</code></pre>
<p>or to pass a constant and an array:</p>
<pre><code>results = pool.starmap(function, zip(itertools.repeat(constant), list_a))
</code></pre>
<p>If you are using an earlier version of Python, you can pass multiple arguments via <a href="https://stackoverflow.com/a/5443941/1893275">this workaround</a>.</p>
<p>(Thanks to <a href="https://stackoverflow.com/users/2441026/user136036">user136036</a> for the helpful comment)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple example: you need to try a few alternative URLs and return the contents of the first one to respond.</p>
<pre><code>import Queue
import threading
import urllib2

# called by each thread
def get_url(q, url):
    q.put(urllib2.urlopen(url).read())

theurls = ["http://google.com", "http://yahoo.com"]

q = Queue.Queue()

for u in theurls:
    t = threading.Thread(target=get_url, args = (q,u))
    t.daemon = True
    t.start()

s = q.get()
print s
</code></pre>
<p>This is a case where threading is used as a simple optimization: each subthread is waiting for a URL to resolve and respond, in order to put its contents on the queue; each thread is a daemon (won't keep the process up if main thread ends -- that's more common than not); the main thread starts all subthreads, does a <code>get</code> on the queue to wait until one of them has done a <code>put</code>, then emits the results and terminates (which takes down any subthreads that might still be running, since they're daemon threads).</p>
<p>Proper use of threads in Python is invariably connected to I/O operations (since CPython doesn't use multiple cores to run CPU-bound tasks anyway, the only reason for threading is not blocking the process while there's a wait for some I/O).  Queues are almost invariably the best way to farm out work to threads and/or collect the work's results, by the way, and they're intrinsically threadsafe so they save you from worrying about locks, conditions, events, semaphores, and other inter-thread coordination/communication concepts.</p>
</div>
<div class="post-text" itemprop="text">
<p><b>NOTE</b>: For actual parallelization in Python, you should use the <a href="https://docs.python.org/2/library/multiprocessing.html" rel="noreferrer">multiprocessing</a> module to fork multiple processes that execute in parallel (due to the global interpreter lock, Python threads provide interleaving but are in fact executed serially, not in parallel, and are only useful when interleaving I/O operations).</p>
<p>However, if you are merely looking for interleaving (or are doing I/O operations that can be parallelized despite the global interpreter lock), then the <a href="http://docs.python.org/library/threading.html" rel="noreferrer">threading</a> module is the place to start. As a really simple example, let's consider the problem of summing a large range by summing subranges in parallel:</p>
<pre><code>import threading

class SummingThread(threading.Thread):
     def __init__(self,low,high):
         super(SummingThread, self).__init__()
         self.low=low
         self.high=high
         self.total=0

     def run(self):
         for i in range(self.low,self.high):
             self.total+=i


thread1 = SummingThread(0,500000)
thread2 = SummingThread(500000,1000000)
thread1.start() # This actually causes the thread to run
thread2.start()
thread1.join()  # This waits until the thread has completed
thread2.join()  
# At this point, both threads have completed
result = thread1.total + thread2.total
print result
</code></pre>
<p>Note that the above is a very stupid example, as it does absolutely no I/O and will be executed serially albeit interleaved (with the added overhead of context switching) in CPython due to the global interpreter lock.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like others mentioned, CPython can use threads only for I\O waits due to GIL.
If you want to benefit from multiple cores for CPU-bound tasks, use <a href="http://docs.python.org/library/multiprocessing.html" rel="noreferrer">multiprocessing</a>:</p>
<pre><code>from multiprocessing import Process

def f(name):
    print 'hello', name

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just a note, Queue is not required for threading.</p>
<p>This is the simplest example I could imagine that shows 10 processes running concurrently.</p>
<pre><code>import threading
from random import randint
from time import sleep


def print_number(number):
    # Sleeps a random 1 to 10 seconds
    rand_int_var = randint(1, 10)
    sleep(rand_int_var)
    print "Thread " + str(number) + " slept for " + str(rand_int_var) + " seconds"

thread_list = []

for i in range(1, 10):
    # Instantiates the thread
    # (i) does not make a sequence, so (i,)
    t = threading.Thread(target=print_number, args=(i,))
    # Sticks the thread in a list so that it remains accessible
    thread_list.append(t)

# Starts threads
for thread in thread_list:
    thread.start()

# This blocks the calling thread until the thread whose join() method is called is terminated.
# From http://docs.python.org/2/library/threading.html#thread-objects
for thread in thread_list:
    thread.join()

# Demonstrates that the main process waited for threads to complete
print "Done"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer from Alex Martelli helped me, however here is modified version that I thought was more useful (at least to me).</p>
<p><strong>Updated:</strong> works in both python2 and python3</p>
<pre><code>try:
    # for python3
    import queue
    from urllib.request import urlopen
except:
    # for python2 
    import Queue as queue
    from urllib2 import urlopen

import threading

worker_data = ['http://google.com', 'http://yahoo.com', 'http://bing.com']

#load up a queue with your data, this will handle locking
q = queue.Queue()
for url in worker_data:
    q.put(url)

#define a worker function
def worker(url_queue):
    queue_full = True
    while queue_full:
        try:
            #get your data off the queue, and do some work
            url = url_queue.get(False)
            data = urlopen(url).read()
            print(len(data))

        except queue.Empty:
            queue_full = False

#create as many threads as you want
thread_count = 5
for i in range(thread_count):
    t = threading.Thread(target=worker, args = (q,))
    t.start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this very useful: create as many threads as cores and let them execute a (large) number of tasks (in this case, calling a shell program):</p>
<pre><code>import Queue
import threading
import multiprocessing
import subprocess

q = Queue.Queue()
for i in range(30): #put 30 tasks in the queue
    q.put(i)

def worker():
    while True:
        item = q.get()
        #execute a task: call a shell program and wait until it completes
        subprocess.call("echo "+str(item), shell=True) 
        q.task_done()

cpus=multiprocessing.cpu_count() #detect number of cores
print("Creating %d threads" % cpus)
for i in range(cpus):
     t = threading.Thread(target=worker)
     t.daemon = True
     t.start()

q.join() #block until all tasks are done
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given a function, <code>f</code>, thread it like this:</p>
<pre><code>import threading
threading.Thread(target=f).start()
</code></pre>
<p>To pass arguments to <code>f</code></p>
<pre><code>threading.Thread(target=f, args=(a,b,c)).start()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For me, the perfect example for Threading is monitoring Asynchronous events.  Look at this code.</p>
<pre><code># thread_test.py
import threading
import time 

class Monitor(threading.Thread):
    def __init__(self, mon):
        threading.Thread.__init__(self)
        self.mon = mon

    def run(self):
        while True:
            if self.mon[0] == 2:
                print "Mon = 2"
                self.mon[0] = 3;
</code></pre>
<p>You can play with this code by opening an IPython session and doing something like:</p>
<pre><code>&gt;&gt;&gt;from thread_test import Monitor
&gt;&gt;&gt;a = [0]
&gt;&gt;&gt;mon = Monitor(a)
&gt;&gt;&gt;mon.start()
&gt;&gt;&gt;a[0] = 2
Mon = 2
&gt;&gt;&gt;a[0] = 2
Mon = 2
</code></pre>
<p>Wait a few minutes</p>
<pre><code>&gt;&gt;&gt;a[0] = 2
Mon = 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 has the facility of <a href="https://docs.python.org/dev/library/concurrent.futures.html" rel="noreferrer">Launching parallel tasks</a>. This makes our work easier. </p>
<p>It has for <a href="https://docs.python.org/dev/library/concurrent.futures.html#threadpoolexecutor" rel="noreferrer">thread pooling</a> and <a href="https://docs.python.org/dev/library/concurrent.futures.html#processpoolexecutor" rel="noreferrer">Process pooling</a>. </p>
<p>The following gives an insight:</p>
<p><strong>ThreadPoolExecutor Example</strong></p>
<pre><code>import concurrent.futures
import urllib.request

URLS = ['http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://europe.wsj.com/',
        'http://www.bbc.co.uk/',
        'http://some-made-up-domain.com/']

# Retrieve a single page and report the URL and contents
def load_url(url, timeout):
    with urllib.request.urlopen(url, timeout=timeout) as conn:
        return conn.read()

# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
    for future in concurrent.futures.as_completed(future_to_url):
        url = future_to_url[future]
        try:
            data = future.result()
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))
</code></pre>
<p><strong>ProcessPoolExecutor</strong></p>
<pre><code>import concurrent.futures
import math

PRIMES = [
    112272535095293,
    112582705942171,
    112272535095293,
    115280095190773,
    115797848077099,
    1099726899285419]

def is_prime(n):
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

def main():
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
            print('%d is prime: %s' % (number, prime))

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the blazing new <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="noreferrer">concurrent.futures</a> module</p>
<pre><code>def sqr(val):
    import time
    time.sleep(0.1)
    return val * val

def process_result(result):
    print(result)

def process_these_asap(tasks):
    import concurrent.futures

    with concurrent.futures.ProcessPoolExecutor() as executor:
        futures = []
        for task in tasks:
            futures.append(executor.submit(sqr, task))

        for future in concurrent.futures.as_completed(futures):
            process_result(future.result())
        # Or instead of all this just do:
        # results = executor.map(sqr, tasks)
        # list(map(process_result, results))

def main():
    tasks = list(range(10))
    print('Processing {} tasks'.format(len(tasks)))
    process_these_asap(tasks)
    print('Done')
    return 0

if __name__ == '__main__':
    import sys
    sys.exit(main())
</code></pre>
<p>The executor approach might seem familiar to all those who have gotten their hands dirty with Java before.</p>
<p>Also on a side note: To keep the universe sane, don't forget to close your pools/executors if you don't use <code>with</code> context (which is so awesome that it does it for you)</p>
</div>
<div class="post-text" itemprop="text">
<p>Most documentations and tutorials use Python's <code>Threading</code> and <code>Queue</code> module they could seem overwhelming for beginners.</p>
<p>Perhaps consider the <code>concurrent.futures.ThreadPoolExecutor</code> module of python 3.
Combined with <code>with</code> clause and list comprehension it could be a real charm.</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed

def get_url(url):
    # Your actual program here. Using threading.Lock() if necessary
    return ""

# List of urls to fetch
urls = ["url1", "url2"]

with ThreadPoolExecutor(max_workers = 5) as executor:

    # Create threads 
    futures = {executor.submit(get_url, url) for url in urls}

    # as_completed() gives you the threads once finished
    for f in as_completed(futures):
        # Get the results 
        rs = f.result()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is the very simple example of CSV import using threading. [Library inclusion may differ for different purpose ]</p>
<p>Helper Functions:</p>
<pre><code>from threading import Thread
from project import app 
import csv


def import_handler(csv_file_name):
    thr = Thread(target=dump_async_csv_data, args=[csv_file_name])
    thr.start()

def dump_async_csv_data(csv_file_name):
    with app.app_context():
        with open(csv_file_name) as File:
            reader = csv.DictReader(File)
            for row in reader:
                #DB operation/query
</code></pre>
<p>Driver Function:</p>
<pre><code>import_handler(csv_file_name) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Multi threading with simple example which will be helpful. You can run it and understand easily how is multi thread working in python. I used lock for prevent to access other thread until previous threads finished their work. By the use of </p>
<blockquote>
<p>tLock = threading.BoundedSemaphore(value=4)</p>
</blockquote>
<p>this line of code you can allow numbers of process at a time and keep hold to rest of thread which will run later or after finished previous processes.</p>
<pre><code>import threading
import time

#tLock = threading.Lock()
tLock = threading.BoundedSemaphore(value=4)
def timer(name, delay, repeat):
    print  "\r\nTimer: ", name, " Started"
    tLock.acquire()
    print "\r\n", name, " has the acquired the lock"
    while repeat &gt; 0:
        time.sleep(delay)
        print "\r\n", name, ": ", str(time.ctime(time.time()))
        repeat -= 1

    print "\r\n", name, " is releaseing the lock"
    tLock.release()
    print "\r\nTimer: ", name, " Completed"

def Main():
    t1 = threading.Thread(target=timer, args=("Timer1", 2, 5))
    t2 = threading.Thread(target=timer, args=("Timer2", 3, 5))
    t3 = threading.Thread(target=timer, args=("Timer3", 4, 5))
    t4 = threading.Thread(target=timer, args=("Timer4", 5, 5))
    t5 = threading.Thread(target=timer, args=("Timer5", 0.1, 5))

    t1.start()
    t2.start()
    t3.start()
    t4.start()
    t5.start()

    print "\r\nMain Complete"

if __name__ == "__main__":
    Main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I saw a lot of examples here where no real work was being performed + they were mostly CPU bound. Here is an example of a CPU bound task that computes all prime numbers between 10 million and 10.05 million. I have used all 4 methods here</p>
<pre><code>import math
import timeit
import threading
import multiprocessing
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor


def time_stuff(fn):
    """
    Measure time of execution of a function
    """
    def wrapper(*args, **kwargs):
        t0 = timeit.default_timer()
        fn(*args, **kwargs)
        t1 = timeit.default_timer()
        print("{} seconds".format(t1 - t0))
    return wrapper

def find_primes_in(nmin, nmax):
    """
    Compute a list of prime numbers between the given minimum and maximum arguments
    """
    primes = []

    #Loop from minimum to maximum
    for current in range(nmin, nmax + 1):

        #Take the square root of the current number
        sqrt_n = int(math.sqrt(current))
        found = False

        #Check if the any number from 2 to the square root + 1 divides the current numnber under consideration
        for number in range(2, sqrt_n + 1):

            #If divisible we have found a factor, hence this is not a prime number, lets move to the next one
            if current % number == 0:
                found = True
                break

        #If not divisible, add this number to the list of primes that we have found so far
        if not found:
            primes.append(current)

    #I am merely printing the length of the array containing all the primes but feel free to do what you want
    print(len(primes))

@time_stuff
def sequential_prime_finder(nmin, nmax):
    """
    Use the main process and main thread to compute everything in this case
    """
    find_primes_in(nmin, nmax)

@time_stuff
def threading_prime_finder(nmin, nmax):
    """
    If the minimum is 1000 and the maximum is 2000 and we have 4 workers
    1000 - 1250 to worker 1
    1250 - 1500 to worker 2
    1500 - 1750 to worker 3
    1750 - 2000 to worker 4
    so lets split the min and max values according to the number of workers
    """
    nrange = nmax - nmin
    threads = []
    for i in range(8):
        start = int(nmin + i * nrange/8)
        end = int(nmin + (i + 1) * nrange/8)

        #Start the thrread with the min and max split up to compute
        #Parallel computation will not work here due to GIL since this is a CPU bound task
        t = threading.Thread(target = find_primes_in, args = (start, end))
        threads.append(t)
        t.start()

    #Dont forget to wait for the threads to finish
    for t in threads:
        t.join()

@time_stuff
def processing_prime_finder(nmin, nmax):
    """
    Split the min, max interval similar to the threading method above but use processes this time
    """
    nrange = nmax - nmin
    processes = []
    for i in range(8):
        start = int(nmin + i * nrange/8)
        end = int(nmin + (i + 1) * nrange/8)
        p = multiprocessing.Process(target = find_primes_in, args = (start, end))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()

@time_stuff
def thread_executor_prime_finder(nmin, nmax):
    """
    Split the min max interval similar to the threading method but use thread pool executor this time
    This method is slightly faster than using pure threading as the pools manage threads more efficiently
    This method is still slow due to the GIL limitations since we are doing a CPU bound task
    """
    nrange = nmax - nmin
    with ThreadPoolExecutor(max_workers = 8) as e:
        for i in range(8):
            start = int(nmin + i * nrange/8)
            end = int(nmin + (i + 1) * nrange/8)
            e.submit(find_primes_in, start, end)

@time_stuff
def process_executor_prime_finder(nmin, nmax):
    """
    Split the min max interval similar to the threading method but use the process pool executor
    This is the fastest method recorded so far as it manages process efficiently + overcomes GIL limitations
    RECOMMENDED METHOD FOR CPU BOUND TASKS
    """
    nrange = nmax - nmin
    with ProcessPoolExecutor(max_workers = 8) as e:
        for i in range(8):
            start = int(nmin + i * nrange/8)
            end = int(nmin + (i + 1) * nrange/8)
            e.submit(find_primes_in, start, end)

def main():
    nmin = int(1e7)
    nmax = int(1.05e7)
    print("Sequential Prime Finder Starting")
    sequential_prime_finder(nmin, nmax)
    print("Threading Prime Finder Starting")
    threading_prime_finder(nmin, nmax)
    print("Processing Prime Finder Starting")
    processing_prime_finder(nmin, nmax)
    print("Thread Executor Prime Finder Starting")
    thread_executor_prime_finder(nmin, nmax)
    print("Process Executor Finder Starting")
    process_executor_prime_finder(nmin, nmax)

main()
</code></pre>
<p>Here are the results on my Mac OSX 4 core machine</p>
<pre><code>Sequential Prime Finder Starting
9.708213827005238 seconds
Threading Prime Finder Starting
9.81836523200036 seconds
Processing Prime Finder Starting
3.2467174359990167 seconds
Thread Executor Prime Finder Starting
10.228896902000997 seconds
Process Executor Finder Starting
2.656402041000547 seconds
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>None of the above solutions actually used multiple cores on my GNU/Linux server (where I don't have admin rights). They just ran on a single core. I used the lower level <code>os.fork</code> interface to spawn multiple processes. This is the code that worked for me:</p>
<pre><code>from os import fork

values = ['different', 'values', 'for', 'threads']

for i in range(len(values)):
    p = fork()
    if p == 0:
        my_function(values[i])
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import threading
import requests

def send():

  r = requests.get('https://www.stackoverlow.com')

thread = []
t = threading.Thread(target=send())
thread.append(t)
t.start()
</code></pre>
</div>
<span class="comment-copy">A good general discussion around this topic can be found in  <a href="http://www.jeffknupp.com/blog/2012/03/31/pythons-hardest-problem/" rel="nofollow noreferrer">Python's Hardest Problem</a> by Jeff Knupp.  In summary, it seems threading is not for beginners.</span>
<span class="comment-copy">haha, I tend to think that threading is for everyone, but beginners are not for threading :)))))</span>
<span class="comment-copy">Just to flag that people should read all the answers as later ones are arguably better as new language features are taken advantage of...</span>
<span class="comment-copy">Remember to write your core logic in C and call it via ctypes to really take advantage of Python threading.</span>
<span class="comment-copy">I just wanted to add that <a href="http://pubsub.sourceforge.net/usage/usage_basic.html" rel="nofollow noreferrer">PyPubSub</a> is a great way to send and receive messages to control Thread flow</span>
<span class="comment-copy">This is only lacking votes because it is so freshly posted. This answer works beautifully and demonstrates the 'map' functionality which gives a much easier to understand syntax than the other answers here.</span>
<span class="comment-copy">Is this even threads and not processes? It seems like it attempts to multiprocess != multithread</span>
<span class="comment-copy">By the way, guys, you can write <code>with Pool(8) as p: p.map( *whatever* )</code> and get rid of bookkeeping lines too.</span>
<span class="comment-copy">@BarafuAlbino: Useful as that is, it's probably worth noting that this <a href="https://stackoverflow.com/questions/25968518/python-multiprocessing-lib-error-attributeerror-exit">only works in Python 3.3+</a>.</span>
<span class="comment-copy">How can you leave this answer and not mention that this is only useful for I/O operations? This only runs on a single thread which is useless for most cases, and is actually slower than just doing it the normal way</span>
<span class="comment-copy">Thanks again, MartelliBot. I've updated the example to wait for all to urls to respond:  import Queue, threading, urllib2  q = Queue.Queue()  urls = '''<a href="http://www.a.com" rel="nofollow noreferrer">a.com</a> <a href="http://www.b.com" rel="nofollow noreferrer">b.com</a> <a href="http://www.c.com'''.split()" rel="nofollow noreferrer">c.com'''.split()</a>  urls_received = 0   def get_url(q, url):   req = urllib2.Request(url)   resp = urllib2.urlopen(req)   q.put(resp.read())   global urls_received   urls_received +=1    print urls_received   for u in urls:   t = threading.Thread(target=get_url, args = (q,u))   t.daemon = True   t.start()  while q.empty() and urls_received &lt; len(urls):   s = q.get()   print s</span>
<span class="comment-copy">@JRM: if you look at the next answer below, I think that a better way to wait until the threads are finished would be to use the <code>join()</code> method, since that would make the main thread wait until they're done without consuming processor by constantly checking the value. @Alex: thanks, this is exactly what I needed to understand how to use threads.</span>
<span class="comment-copy">For python3, replace 'import urllib2' with 'import urllib.request as urllib2'. and put parentheses in the print statement.</span>
<span class="comment-copy">For python 3 replace <code>Queue</code> module name with <code>queue</code>. Method name is the same.</span>
<span class="comment-copy">I note that solution will only print out one of the pages. To print both pages from the queue simply run the command again: <code>s = q.get()</code> <code>print s</code>  @krs013 You don't need the <code>join</code> because Queue.get() is blocking.</span>
<span class="comment-copy">@Alex, I didn't say it was practical, but it does demonstrate how to define and spawn threads, which I think is what the OP wants.</span>
<span class="comment-copy">While this does show how to define and spawn threads, it actually does not sum the subranges in parallel. <code>thread1</code> runs until it's completed while the main thread blocks, then the same thing happens with <code>thread2</code>, then the main thread resumes and prints out the values they accumulated.</span>
<span class="comment-copy">Shouldn't that be <code>super(SummingThread, self).__init__()</code>? As in <a href="http://stackoverflow.com/a/2197625/806988">stackoverflow.com/a/2197625/806988</a></span>
<span class="comment-copy">@JamesAndres, assuming that no one inherits from "SummingThread", then either one works fine; in such a case super(SummingThread, self) is just a fancy way to look up the next class in the method resolution order (MRO), which is threading.Thread (and then subsequently calling <b>init</b> on that in both cases). You are right, though, in that using super() is better style for current Python. Super was relatively recent at the time that I provided this answer, hence calling directly to the super class rather than using super().  I'll update this to use super, though.</span>
<span class="comment-copy">WARNING: Don't use multithreading in tasks like this! As was shown by Dave Beazley: <a href="http://www.dabeaz.com/python/NewGIL.pdf" rel="nofollow noreferrer">dabeaz.com/python/NewGIL.pdf</a>, 2 python threads on 2 CPUs carry out a CPU-heavy task 2 times SLOWER than 1 thread on 1 CPU and 1.5 times SLOWER than 2 threads on 1 CPU. This bizarre behavior is due to mis-coordination of efforts between OS and Python. A real-life use case for threads is an I/O heavy task. E.g. when you perform read/writes over network, it makes sense to put a thread, waiting for data to be read/written, to background and switch CPU to another thread, which needs to process data.</span>
<span class="comment-copy">could you explain a little what this does?</span>
<span class="comment-copy">@pandita: the code creates a process, then starts it. So now there's two things happening at once: the main line of the program, and the process that's starting with the target, <code>f</code> function. In parallel, the main program now just waits for the process to exit, <code>join</code>ing up with it.  If the main part just exited, the subprocess might or might not run to completion, so doing a <code>join</code> is always recommended.</span>
<span class="comment-copy">An expanded answer that includes the <code>map</code> function is here: <a href="http://stackoverflow.com/a/28463266/2327328">stackoverflow.com/a/28463266/2327328</a></span>
<span class="comment-copy">@philshem Be careful b/c the link you posted is using a pool of threads (not processes) as mentioned here <a href="http://stackoverflow.com/questions/26432411/multiprocessing-dummy-in-python" title="multiprocessing dummy in python">stackoverflow.com/questions/26432411/â€¦</a>.  However, this answer is using a process.  I'm new to this stuff, but seems like (due to GIL) you will only get performance gains in specific situations when using multithreading in Python.  However, using a pool of processes can take advantage of a multicore processor by have more than 1 core work on a process.</span>
<span class="comment-copy">This is the best answer for actually doing something useful and taking advantage of multiple CPU cores</span>
<span class="comment-copy">Add the last quote to "Done to make it print "Done"</span>
<span class="comment-copy">I like this example better than Martelli's, it's easier to play with. However, I would recommend that printNumber do the following, to make it a little bit clearer what's going on: it should save the randint to a variable before sleeping on it, and then the print should be changed to say "Thread" + str(number) + " slept for " + theRandintVariable + " seconds"</span>
<span class="comment-copy">Is there a way to know when each thread has finished, as it finishes?</span>
<span class="comment-copy">@Matt There are a few ways to do something like that, but it would depend on your needs. One way would be to update a singleton or some other publicly accessible variable that's being watched in a while loop and updated at the end of the thread.</span>
<span class="comment-copy">No need for second <code>for</code> loop, you can call <code>thread.start()</code> in first loop.</span>
<span class="comment-copy">Why not just break on the exception?</span>
<span class="comment-copy">you could, just personal preference</span>
<span class="comment-copy">I haven't run the code, but don't you need to daemonize the threads? I think that after that last for-loop, your program might exit - at least it should because that's how threads should work. I think a better approach is not put the worker data in the queue, but put the output into a queue because then you could have a mainloop that not only <b>handles</b> information coming into the queue from the workers, but now it is also not threading, and you <i>know</i> it won't exit prematurely.</span>
<span class="comment-copy">@dylnmc, that's outside my use case (my input queue is predefined). If you want to go your route, I would suggest looking at <a href="http://www.celeryproject.org/" rel="nofollow noreferrer">celery</a></span>
<span class="comment-copy">@JimJty do you know why I'm getting this error:     <code>import Queue ModuleNotFoundError: No module named 'Queue'</code> I am running python 3.6.5 some posts mention that in python 3.6.5 it is <code>queue</code> but even after I change it, still does not work</span>
<span class="comment-copy">@shavenwarthog sure one can adjust the "cpus" variable depending on one's needs. Anyway, the subprocess call will spawn subprocesses and these will be allocated cpus by the OS (python's "parent process" does not mean "same CPU" for the subprocesses).</span>
<span class="comment-copy">you're correct, my comment about "threads are started on the same CPU as the parent process" is wrong.  Thanks for the reply!</span>
<span class="comment-copy">maybe worth noting that unlike multithreading which uses the same memory space, multiprocessing can not share variables / data as easily. +1 though.</span>
<span class="comment-copy">This is very straightforward.  How do you ensure that the threads close when you are done with them?</span>
<span class="comment-copy">As far as I understand it, when the function exits the <code>Thread</code> object cleans up. See <a href="https://docs.python.org/2/library/threading.html#thread-objects" rel="nofollow noreferrer">the docs</a>. There is an <code>is_alive()</code> method you can use to check a thread if you need to.</span>
<span class="comment-copy">I saw the <code>is_alive</code> method, but I couldn't figure out how to apply it to the thread.  I tried assigning <code>thread1=threading.Thread(target=f).start()</code> and then checking it with <code>thread1.is_alive()</code>, but <code>thread1</code> is populated with <code>None</code>, so no luck there.  Do you know if there is any other way to access the thread?</span>
<span class="comment-copy">You need to assign the thread object to a variable and then start it using that varaible: <code>thread1=threading.Thread(target=f)</code> followed by <code>thread1.start()</code>.  Then you can do <code>thread1.is_alive()</code>.</span>
<span class="comment-copy">That worked.  And yes, testing with <code>thread1.is_alive()</code> returns <code>False</code> as soon as the function exits.</span>
<span class="comment-copy">How do we stop the thread manually? @dvreed77</span>
<span class="comment-copy">AttributeError: 'Monitor' object has no attribute 'stop' ?</span>
<span class="comment-copy">Aren't you blasting away CPU cycles while waiting for your event to happen? Not always a very practical thing to do.</span>
<span class="comment-copy">Like mogul says, this will be constantly executing. At a minimum you could add in a short sleep, say sleep(0.1), which would probably significantly reduce cpu usage on a simple example like this.</span>
<span class="comment-copy">This is a horrible example, wasting one core. Add a sleep at the very least but the proper solution is to use some signaling-mechanism.</span>
<span class="comment-copy">So sequential better than threaded for CPU-bound tasks?</span>
<span class="comment-copy">@TheUnfunCat no process executor s far better than threading for cpu bound tasks</span>
<span class="comment-copy">Great answer dude. I can confirm that in Python 3.6 on Windows (at least) ThreadPoolExecutor does nothing good for CPU-heavy tasks. It's not utilizing cores for computation. Whereas ProcessPoolExecutor copies data into EVERY process it spawns, it's deadly for large matrices.</span>
<span class="comment-copy">What is the purpose of list <code>thread</code>?</span>
<span class="comment-copy">@sP_ I'm guessing because then you have thread objects so you can wait for them to finish.</span>
<span class="comment-copy">I would suggest using a ThreadPool for that</span>
<span class="comment-copy">t = threading.Thread(target=send()) should be t = threading.Thread(target=send)</span>
<span class="comment-copy">I'm downvoting this answer because it doesn't provide an explanation of how it improves upon existing answers, in addition to containing a serious inaccuracy.</span>
