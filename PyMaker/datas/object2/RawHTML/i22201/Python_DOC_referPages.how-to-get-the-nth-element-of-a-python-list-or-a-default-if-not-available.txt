<div class="post-text" itemprop="text">
<p>I'm looking for an equivalent in python of <code>dictionary.get(key, default)</code> for lists. Is there any one liner idiom to get the nth element of a list or a default value if not available?</p>
<p>For example, given a list myList I would like to get <code>myList[0]</code>, or 5 if<code>myList</code> is an empty list.</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>l[index] if index &lt; len(l) else default
</code></pre>
<p>To support negative indices we can use:</p>
<pre><code>l[index] if -len(l) &lt;= index &lt; len(l) else default
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>try:
   a = b[n]
except IndexError:
   a = default
</code></pre>
<p>Edit: I removed the check for TypeError - probably better to let the caller handle this.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>(a[n:]+[default])[0]
</code></pre>
<p>This is probably better as <code>a</code> gets larger </p>
<pre><code>(a[n:n+1]+[default])[0]
</code></pre>
<p>This works because if <code>a[n:]</code> is an empty list if <code>n =&gt; len(a)</code></p>
<p>Here is an example of how this works with <code>range(5)</code></p>
<pre><code>&gt;&gt;&gt; range(5)[3:4]
[3]
&gt;&gt;&gt; range(5)[4:5]
[4]
&gt;&gt;&gt; range(5)[5:6]
[]
&gt;&gt;&gt; range(5)[6:7]
[]
</code></pre>
<p>And the full expression</p>
<pre><code>&gt;&gt;&gt; (range(5)[3:4]+[999])[0]
3
&gt;&gt;&gt; (range(5)[4:5]+[999])[0]
4
&gt;&gt;&gt; (range(5)[5:6]+[999])[0]
999
&gt;&gt;&gt; (range(5)[6:7]+[999])[0]
999
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just discovered that : </p>
<pre><code>next(iter(myList), 5)
</code></pre>
<p><code>iter(l)</code> returns an iterator on <code>myList</code>, <code>next()</code> consumes the first element of the iterator, and raises a <code>StopIteration</code> error except if called with a default value, which is the case here, the second argument, <code>5</code></p>
<p>This only works when you want the 1st element, which is the case in your example, but not in the text of you question, so...</p>
<p>Additionally, it does not need to create temporary lists in memory and it works for any kind of iterable, even if it does not have a name (see Xiong Chiamiov's comment on gruszczy's answer)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>(L[n:n+1] or [somedefault])[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>... looking for an equivalent in python of <code>dict.get(key, default)</code> for lists</p>
</blockquote>
<p>There is an <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a> that does this for general iterables.  For convenience, you can <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>&gt; pip install more_itertools</code></a> and import this third-party library that implements such recipes for you:</p>
<p><strong>Code</strong></p>
<pre><code>import more_itertools as mit


mit.nth([1, 2, 3], 0)
# 1    

mit.nth([], 0, 5)
# 5    
</code></pre>
<hr/>
<p><strong>Detail</strong></p>
<p>Here is the implementation of the <code>nth</code> recipe:</p>
<pre><code>def nth(iterable, n, default=None):
    "Returns the nth item or a default value"
    return next(itertools.islice(iterable, n, None), default)
</code></pre>
<p>Like <code>dict.get()</code>, this tool returns a default for missing indices.  It applies to  general iterables:</p>
<pre><code>mit.nth((0, 1, 2), 1)                                      # tuple
# 1

mit.nth(range(3), 1)                                       # range generator (py3)
# 1

mit.nth(iter([0, 1, 2]), 1)                                # list iterator 
# 1  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Combining @Joachim's with the above, you could use</p>
<pre><code>next(iter(my_list[index:]), default)
</code></pre>
<p>Examples:</p>
<pre><code>next(iter(range(10)[8:]), 11)
8
&gt;&gt;&gt; next(iter(range(10)[12:]), 11)
11
</code></pre>
<hr/>
<p>Or, maybe more clear, but without the <code>len</code></p>
<pre><code>my_list[index] if my_list[index:] else default
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using Python 3.4's <code>contextlib.suppress(exceptions)</code> to build a <code>getitem()</code> method similar to <code>getattr()</code>.</p>
<pre><code>import contextlib

def getitem(iterable, index, default=None):
    """Return iterable[index] or default if IndexError is raised."""
    with contextlib.suppress(IndexError):
        return iterable[index]
    return default
</code></pre>
</div>
<span class="comment-copy">standard caveat: 2.5+ only</span>
<span class="comment-copy">You seem to forgot the case of negative index.  Eg. <code>index == -1000000</code> should return <code>default</code>.</span>
<span class="comment-copy">@nodakai, good point. I've sometimes been bitten by this. <code>x[index] if 0 &lt;= index &lt; len(x) else default</code> would be better if <code>index</code> can ever be negative.</span>
<span class="comment-copy">@nodakai wow - that is a great example of why it may be better to use try/except, than to try to correctly code the test so it never fails. I still don't like to rely on try/except, for a case that I know will happen, but this increases my willingness to consider it.</span>
<span class="comment-copy">@ToolmakerSteve: Your formula for <code>valid_index()</code> is incorrect. Negative indices <i>are</i> legal in Python - it should be <code>-len(l) &lt;= index &lt; len(l)</code>.</span>
<span class="comment-copy">I like this. Just wrap it around a function so that you can call it with an iterable as an argument. Easier to read.</span>
<span class="comment-copy">Would you write this in actual code without a comment to explain it?</span>
<span class="comment-copy">@Peter Hansen, only if I was golfing ;) However it does work on <i>all</i> versions of Python. The Accepted answer only works on 2.5+</span>
<span class="comment-copy">It invloves creating 3 temporary lists and accessing 2 indices in order to select an item, though.</span>
<span class="comment-copy">While I'd never do this in "real" code, it's a nice concise one-liner that I can easily use in a python REPL, so you get my upvote.</span>
<span class="comment-copy"><code>next(iter(lst[i:i+1]), default)</code> -- just another entry in the cryptic ugly one-liners competition.</span>
<span class="comment-copy">Combined with the other answers:  <code>next(iter(myList[n:n+1]), 5)</code>  Now it works for the <code>n</code>th element.</span>
<span class="comment-copy">That would not work with non lists. At this point, try:except-ing an IndexError reads like a better idea IMHO. Also, it creates a list in memory.</span>
<span class="comment-copy">The <code>try</code> variant isn't a one-liner (ask asked for by OP).  It only works for lists because <code>myList</code> is a list as specified by OP (to be precise, it is something indexable).  Creating a copy in memory isn't costly here because I'm creating a list of one single (or none) element here.  Sure, a little overhead, but not worth mentioning unless you do that millions of times in a loop.  Btw, I guess creating and catching an <code>IndexError</code> exception is probably more costly.</span>
<span class="comment-copy">readability counts :) If you're at the point where raising an IndexError has a significant cost, maybe you should be doing the whole thing in Python.</span>
<span class="comment-copy">+1 because this made me go learn what <code>[] or ...</code> did. However, I would personally just use the accepted solution, as it reads easily (for novices). Granted, wrapping it in a 'def' with comment would make that largely a non-issue.</span>
<span class="comment-copy">What if <code>L[n] == False</code> or <code>L[n] == None</code> or <code>L[n] == []</code> or more globally anything that evaluates to False ?</span>
<span class="comment-copy">@JoachimJablon: Still works. The slice returns a list, and <code>[False]</code> is true.</span>
<span class="comment-copy">Oh, didn't realised the list was checked and not the value, indeed.</span>
<span class="comment-copy">Why do you wrap this in a tuple? I think <code>myval = l[n:n+1] or [somedefault]</code> would work just fine?</span>
