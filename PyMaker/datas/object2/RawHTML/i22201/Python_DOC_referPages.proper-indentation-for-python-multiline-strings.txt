<div class="post-text" itemprop="text">
<p>What is the proper indentation for Python multiline strings within a function?</p>
<pre><code>    def method():
        string = """line one
line two
line three"""
</code></pre>
<p>or</p>
<pre><code>    def method():
        string = """line one
        line two
        line three"""
</code></pre>
<p>or something else?</p>
<p>It looks kind of weird to have the string hanging outside the function in the first example.</p>
</div>
<div class="post-text" itemprop="text">
<p>You probably want to line up with the <code>"""</code></p>
<pre><code>def foo():
    string = """line one
             line two
             line three"""
</code></pre>
<p>Since the newlines and spaces are included in the string itself, you will have to postprocess it. If you don't want to do that and you have a whole lot of text, you might want to store it separately in a text file. If a text file does not work well for your application and you don't want to postprocess, I'd probably go with</p>
<pre><code>def foo():
    string = ("this is an "
              "implicitly joined "
              "string")
</code></pre>
<p>If you want to postprocess a multiline string to trim out the parts you don't need, you should consider the <a href="http://docs.python.org/3/library/textwrap.html" rel="noreferrer"><code>textwrap</code></a> module or the technique for postprocessing docstrings presented in <a href="http://www.python.org/dev/peps/pep-0257/" rel="noreferrer">PEP 257</a>:</p>
<pre><code>def trim(docstring):
    if not docstring:
        return ''
    # Convert tabs to spaces (following the normal Python rules)
    # and split into a list of lines:
    lines = docstring.expandtabs().splitlines()
    # Determine minimum indentation (first line doesn't count):
    indent = sys.maxint
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    # Remove indentation (first line is special):
    trimmed = [lines[0].strip()]
    if indent &lt; sys.maxint:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())
    # Strip off trailing and leading blank lines:
    while trimmed and not trimmed[-1]:
        trimmed.pop()
    while trimmed and not trimmed[0]:
        trimmed.pop(0)
    # Return a single string:
    return '\n'.join(trimmed)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/library/textwrap.html#textwrap.dedent" rel="noreferrer"><code>textwrap.dedent</code></a> function allows one to start with <strong>correct indentation in the source</strong>, and then strip it from the text before use.</p>
<p>The trade-off, as noted by some others, is that this is an extra function call on the literal; take this into account when deciding where to place these literals in your code.</p>
<pre class="lang-python prettyprint-override"><code>import textwrap

def frobnicate(param):
    """ Frobnicate the scrognate param.

        The Weebly-Ruckford algorithm is employed to frobnicate
        the scrognate to within an inch of its life.

        """
    prepare_the_comfy_chair(param)
    log_message = textwrap.dedent("""\
            Prepare to frobnicate:
            Here it comes...
                Any moment now.
            And: Frobnicate!""")
    weebly(param, log_message)
    ruckford(param)
</code></pre>
<p>The trailing <code>\</code> in the log message literal is to ensure that line break isn't in the literal; that way, the literal doesn't start with a blank line, and instead starts with the next full line.</p>
<p>The return value from <code>textwrap.dedent</code> is the input string with <strong>all common leading whitespace indentation removed</strong> on each line of the string. So the above <code>log_message</code> value will be:</p>
<pre class="lang-none prettyprint-override"><code>Prepare to frobnicate:
Here it comes...
    Any moment now.
And: Frobnicate!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One option which seems to missing from the other answers (only mentioned deep down in a comment by naxa) is the following:</p>
<pre><code>def foo():
    string = ("line one\n"          # Add \n in the string
              "line two"  "\n"      # Add "\n" after the string
              "line three\n")
</code></pre>
<p>This will allow proper aligning, join the lines implicitly, and still keep the line shift which, for me, is one of the reasons why I would like to use multiline strings anyway.</p>
<p>It doesn't require any postprocessing, but you need to manually add the <code>\n</code> at any given place that you want the line to end. Either inline or as a separate string after. The latter is easier to copy-paste in.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/inspect.html#inspect.cleandoc" rel="noreferrer" title="inspect.cleandoc"><code>inspect.cleandoc</code></a> like so:</p>
<pre><code>def method():
    string = inspect.cleandoc("""
        line one
        line two
        line three""")
</code></pre>
<p>Relative indentation will be maintained as expected.</p>
<blockquote>
<p><strong>Note:</strong> It's good practice to indent logical blocks of code under its related context to clarify the structure. E.g. the multi-line string belonging to the variable <code>string</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Some more options.  In Ipython with pylab enabled, dedent is already in the namespace.  I checked and it is from matplotlib.  Or it can be imported with:</p>
<pre><code>from matplotlib.cbook import dedent
</code></pre>
<p>In documentation it states that it is faster than the textwrap equivalent one and in my tests in ipython it is indeed 3 times faster on average with my quick tests.   It also has the benefit that it discards any leading blank lines this allows you to be flexible in how you construct the string:</p>
<pre><code>"""
line 1 of string
line 2 of string
"""

"""\
line 1 of string
line 2 of string
"""

"""line 1 of string
line 2 of string
"""
</code></pre>
<p>Using the matplotlib dedent on these three examples will give the same sensible result.  The textwrap dedent function will have a leading blank line with 1st example.</p>
<p>Obvious disadvantage is that textwrap is in standard library while matplotlib is external module. </p>
<p>Some tradeoffs here... the dedent functions make your code more readable where the strings get defined, but require processing later to get the string in usable format.  In docstrings it is obvious that you should use correct indentation as most uses of the docstring will do the required processing.</p>
<p>When I need a non long string in my code I find the following admittedly ugly code where I let the long string drop out of the enclosing indentation.  Definitely fails on "Beautiful is better than ugly.", but one could argue that it is simpler and more explicit than the dedent alternative.</p>
<pre><code>def example():
    long_string = '''\
Lorem ipsum dolor sit amet, consectetur adipisicing
elit, sed do eiusmod tempor incididunt ut labore et
dolore magna aliqua. Ut enim ad minim veniam, quis
nostrud exercitation ullamco laboris nisi ut aliquip.\
'''
    return long_string

print example()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a quick&amp;easy solution and save yourself from typing newlines, you could opt for a list instead, e.g.:</p>
<pre><code>def func(*args, **kwargs):
    string = '\n'.join([
        'first line of very long string and',
        'second line of the same long thing and',
        'third line of ...',
        'and so on...',
        ])
    print(string)
    return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer</p>
<pre><code>    def method():
        string = \
"""\
line one
line two
line three\
"""
</code></pre>
<p>or</p>
<pre><code>    def method():
        string = """\
line one
line two
line three\
"""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My two cents, escape the end of line to get the indents:</p>
<pre><code>def foo():
    return "{}\n"\
           "freq: {}\n"\
           "temp: {}\n".format( time, freq, temp )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I came here looking for a simple 1-liner to <strong>remove/correct the identation level</strong> of the docstring for printing, <strong>without making it look untidy</strong>,  for example by making it "hang outside the function" within the script.</p>
<p>Here's what I ended up doing: </p>
<pre><code>import string
def myfunction():

    """
    line 1 of docstring
    line 2 of docstring
    line 3 of docstring"""

print str(string.replace(myfunction.__doc__,'\n\t','\n'))[1:] 
</code></pre>
<p>Obviously, if you're indenting with spaces (e.g. 4) rather than the tab key use something like this instead: </p>
<pre><code>print str(string.replace(myfunction.__doc__,'\n    ','\n'))[1:]
</code></pre>
<p>And you don't need to remove the first character if you like your docstrings to look like this instead:</p>
<pre><code>    """line 1 of docstring
    line 2 of docstring
    line 3 of docstring"""

print string.replace(myfunction.__doc__,'\n\t','\n') 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first option is the good one - with indentation included. 
It is in python style - provides readability for the code.</p>
<p>To display it properly:</p>
<pre><code>print string.lstrip()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It depends on how you want the text to display. If you want it all to be left-aligned then either format it as in the first snippet or iterate through the lines left-trimming all the space.</p>
</div>
<div class="post-text" itemprop="text">
<p>For strings you can just after process the string. For docstrings you need to after process the function instead. Here is a solution for both that is still readable.</p>
<pre><code>class Lstrip(object):
    def __rsub__(self, other):
        import re
        return re.sub('^\n', '', re.sub('\n$', '', re.sub('\n\s+', '\n', other)))

msg = '''
      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
      veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
      commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
      velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat
      cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
      est laborum.
      ''' - Lstrip()

print msg

def lstrip_docstring(func):
    func.__doc__ = func.__doc__ - Lstrip()
    return func

@lstrip_docstring
def foo():
    '''
    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
    tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
    veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
    commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
    velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat
    cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
    est laborum.
    '''
    pass


print foo.__doc__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I sometimes write multiline text as a list of strings then concatenate them...</p>
<pre><code>    part = "".join([
        "\x00\x00\x00\x00\x0C\x00\x00\x00\xFF\x00\x00\x00\x00\x00\x00\x00"
        "\x00\x00\x00\x00\x0C\x00\x00\x00\x00\xFF\x00\x00\x00\x00\x00\x00",
        "\x00\x00\x00\x00\x0C\x00\x00\x00\x00\x00\xFF\x00\x00\x00\x00\x00",
        "\x00\x00\x00\x00\x0C\x00\x00\x00\x00\x00\x00\xFF\x00\x00\x00\x00",
    ])
</code></pre>
<p>It's not the most efficient way but it is performant enough for most use cases and it doesn't mess with your indentation or require the first line to have a different indentation to the second like the triple quoted method.</p>
</div>
<span class="comment-copy">Docstrings are treated <a href="http://stackoverflow.com/questions/16534246/docstring-processing-tools-following-pep-257">specially</a>: any indent of the first line is removed; the smallest common indent taken over all other non-blank lines is removed from them all. Other than that, multiline string literals in Python are unfortunately what-you-see-is-what-you-get in terms of whitespace: all characters between the string delimiters become part of the string, including indentation that, with Python reading instincts, looks like it should be measured from the indent of the line where the literal starts.</span>
<span class="comment-copy">This is the ‘hanging indent’ style of line continuation. It is prescribed in PEP8 for purposes like function definitions and long if statements, though not mentioned for multiline strings. Personally this is one place I refuse to follow PEP8 (and use 4-space indenting instead), as I strongly dislike hanging indents, which for me obscure the proper structure of the program.</span>
<span class="comment-copy">@buffer, in 3.1.2 of the official tutorial ("Two string literals next to each other are automatically concatenated...") and in the language reference.</span>
<span class="comment-copy"><i>The second form with automatic string concatenation doesn't include newline</i> It's a feature.</span>
<span class="comment-copy">The <code>trim()</code> function as specified in PEP257 is implemented in the standard library as <a href="https://docs.python.org/2/library/inspect.html#inspect.cleandoc" rel="nofollow noreferrer"><code>inspect.cleandoc</code></a>.</span>
<span class="comment-copy">+1 to @bobince 's comment about rejecting "hanging indents" here... Especially because if you change the variable name from <code>string</code> to <code>text</code> or anything of a different length, then you now need to update the indentation of <i>literally every single line of the multiline string</i> just to get it to match up with the <code>"""</code> properly. Indentation strategy should not complicate future refactors/maintenance, and it's one of the places that PEP really fails</span>
<span class="comment-copy">While this is a reasonable solution and nice to know, doing something like this inside a frequently called function could prove to be a disaster.</span>
<span class="comment-copy">@haridsv Why would that be a disaster?</span>
<span class="comment-copy">@jtmoulia: A better description than disaster would be "inefficient" because the result of the <code>textwrap.dedent()</code> call is a constant value, just like its input argument.</span>
<span class="comment-copy">@haridsv the origin of that disaster/inefficiency is <i>definining</i> a constant string <b>inside</b> a frequently called function. Possible to trade the per-call constant definition for a per-call lookup. That way the <i>dedent</i> preprocessing would run <i>only once</i>. A relevant question may be <a href="http://stackoverflow.com/q/15495376/611007">stackoverflow.com/q/15495376/611007</a> It lists ideas to avoid defining the constant per each call. Albeit alternatives seems to require a lookup. Still, various ways to find the favorable place to store it are attempted. For example: <code>def foo: return foo.x</code> then next line <code>foo.x = textwrap.dedent("bar")</code>.</span>
<span class="comment-copy">I guess it would be inefficient if the string is intended for logging that is only enabled in debug mode, and goes unused otherwise. But then why log a multiline string literal anyway? So it's hard to find a real-life example where the above would be inefficient (i.e. where it slows down the program considerably), because whatever is consuming these strings is going to be slower.</span>
<span class="comment-copy">Note that this is an example of an implicitly joined string, not a multiline string.</span>
<span class="comment-copy">@trk, it's multiline in the sense that the string contains newlines (aka multiple lines), but yes it uses joining to circumvent the formatting issues the OP had.</span>
<span class="comment-copy">So confused why this answer didn't exist until now, <code>inspect.cleandoc</code> has existed ever since <a href="https://docs.python.org/2/library/inspect.html#inspect.cleandoc" rel="nofollow noreferrer">Python 2.6</a>, which was <a href="https://www.python.org/download/releases/2.6/" rel="nofollow noreferrer">2008</a>..? Absolutely the cleanest answer, especially because it doesn't use the hanging indent style, which just wastes an unnecessary amount of space</span>
<span class="comment-copy">While this isn't the best approach, I've used it from time to time. If you <i>do</i> use it, you should use a tuple instead of a list, since it's not going to be modified before being joined.</span>
<span class="comment-copy">This does not answer the question, because the question explicitly states that the indentation (within the function) matters.</span>
<span class="comment-copy">@bignose The question said "It looks kind of weird" not disallowed to use.</span>
<span class="comment-copy">how would i accomplish this without the ugly indentation?</span>
<span class="comment-copy">@lfender6445 well, maybe you can place all these strings to a separate file from other codes...</span>
<span class="comment-copy">This fails on class methods and nested classes.</span>
<span class="comment-copy">This seems like the simplest and cleanest way to format triple quote strings so you don't have the extra spaces due to indentation</span>
<span class="comment-copy">This will only delete leading spaces in the first line of a multiline string. It does not help with formatting following lines.</span>
<span class="comment-copy">The way docstring-processing tools work is to remove not <i>all</i> the space on the left, but <i>as much</i> as the first indented line. This strategy is a bit more sophisticated and allows for you to indent and have it respected in the postprocessed string.</span>
<span class="comment-copy">Processing docstrings must already process consistent indentation, as <a href="http://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation" rel="nofollow noreferrer">described in PEP 257</a>. There are already tools – e.g. <a href="https://docs.python.org/3/library/inspect.html#inspect.cleandoc" rel="nofollow noreferrer"><code>inspect.cleandoc</code></a> – which do this the right way.</span>
<span class="comment-copy">While this might answer the authors question, it lacks some explaining words and links to documentation. Raw code snippets are not very helpful without some phrases around it. You may also find <a href="https://stackoverflow.com/help/how-to-answer">how to write a good answer</a> very helpful. Please edit your answer.</span>
