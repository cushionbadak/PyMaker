<div class="post-text" itemprop="text">
<p>I found HTMLParser for sax and xml.minidom for xml. I have a pretty well formed html so I don't need a too strong parser - any suggestions?</p>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at <a href="http://www.crummy.com/software/BeautifulSoup/" rel="noreferrer">BeautifulSoup</a>. It's popular and excellent at parsing HTML.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend <a href="http://lxml.de/" rel="noreferrer">lxml</a>. I like BeautifulSoup, but there are maintenance issues generally and compatibility issues with the later releases. I've been happy using lxml.</p>
<hr/>
<p>Later: the best recommendations are to use lxml, html5lib, or BeautifulSoup 3.0.8. BeautifulSoup 3.1.x is meant for python 3.x and is known to have problems with earlier python versions, <a href="http://www.crummy.com/software/BeautifulSoup/3.1-problems.html" rel="noreferrer">as noted on the BeautifulSoup website</a>.</p>
<p>Ian Bicking has a <a href="http://blog.ianbicking.org/2008/12/10/lxml-an-underappreciated-web-scraping-library/" rel="noreferrer">good article</a> on using lxml.</p>
<p>ElementTree is a further recommendation, but I have never used it.</p>
<hr/>
<p>2012-01-18: someone has come by and decided to downvote me and Bartosz because we recommended python packages that are easily obtained but not part of the python distribution. So for the highly literal StackOverflowers: "You can use xml.dom.minidom, but no one will recommend this over the alternatives."</p>
</div>
<div class="post-text" itemprop="text">
<p>BeautifulSoup and lxml are great, but not appropriate answers here since the question is about builtins. Here is an example of using the builtin <a href="https://docs.python.org/3/library/xml.dom.minidom.html" rel="nofollow noreferrer">minidom</a> module to parse an HTML string. Tested with cPython 3.5.2:</p>
<pre><code>from xml.dom.minidom import parseString

html_string = """
&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;test&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
"""

# extract the text value of the document's &lt;p&gt; tag:
doc = parseString(html_string)
paragraph = doc.getElementsByTagName("p")[0]
content = paragraph.firstChild.data

print(content)
</code></pre>
<p>However, as indicated in Jesse Hogan's <a href="https://stackoverflow.com/questions/2782097/python-is-there-a-built-in-package-to-parse-html-into-dom/40749716?noredirect=1#comment87741967_40749716">comment</a>, this will fail on HTML entities not recognized by mindom. Here is an updated solution using the Python3 html.parser module:</p>
<pre><code>from html.parser import HTMLParser

html_string = """
&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&amp;nbsp;test&lt;/p&gt;&lt;div&gt;not in p&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
"""

class Parser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.in_p = []

    def handle_starttag(self, tag, attrs):
        if (tag == 'p'):
            self.in_p.append(tag)

    def handle_endtag(self, tag):
        if (tag == 'p'):
            self.in_p.pop()

    def handle_data(self, data):
        if self.in_p:
            print("&lt;p&gt; data :", data)

parser = Parser()
parser.feed(html_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To handle DOM objects, you can use <a href="http://thehtmldom.sourceforge.net/" rel="nofollow">HTMLDOM</a> for python.</p>
</div>
<span class="comment-copy">Could you accept velotron's answer please, since it's the one that solves the builtin requirement? <a href="https://meta.stackexchange.com/questions/120568/is-it-possible-to-change-the-chosen-answer?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" title="is it possible to change the chosen answer">meta.stackexchange.com/questions/120568/â€¦</a></span>
<span class="comment-copy">it's not built in if I'm not mistaken</span>
<span class="comment-copy">No, it's not built-in. But you can easily install it using easy_install or just download from the website and put into PYTHONPATH. Whole BeautifulSoup is contained in a single file, so it's not much of a burden.</span>
<span class="comment-copy">BeautifulSoup is supposed to parse dirty HTML not "pretty well formed" one.</span>
<span class="comment-copy">I have added a working example of using the builtin xml.dom.minidom, which answers the original question.</span>
<span class="comment-copy">for what it's worth, i tried to parse some HTML using both ElementTree and xml minidom, and they both choked with parse errors in script tags (javascript)!</span>
<span class="comment-copy">I just added an answer with a working example of xml.dom.minidom. In some situations, installing an external module is burdensome or impossible. Plus that is what the original question asked for.</span>
<span class="comment-copy">This would raise an exception on common HTML entities such as <code>&amp;nbsp;</code> or <code>&amp;reg;</code>.</span>
