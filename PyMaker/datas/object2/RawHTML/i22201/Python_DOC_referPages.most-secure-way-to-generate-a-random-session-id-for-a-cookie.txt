<div class="post-text" itemprop="text">
<p>I'm writing my own sessions controller that issues a unique id to a user once logged in, and then verifies and authenticates that unique id at every page load.  What is the most secure way to generate such an id?  Should the unique id be completely random?  Is there any downside to including the user id as part of the unique id?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the only information in the cookie is an identifier, essentially a label, the only attack you're trying to protect from is an attacker guessing what it is.  So use some random bytes.  Enough random bytes that it's "unguessable."</p>
<p>Then squish the random bytes into something that fits within the confines of which characters you can use in a HTTP cookie.  base64 works for this.  It's not absolutely optimal, because there are more than 64 cookie-safe characters and it tends to leave trailing <code>==</code> characters which add bytes to the header but not randomness, but that's fine.  It works and Python can probably do the base64 encoding faster than anything else we can come up with.</p>
<p>If you also want to prepend the user ID to it, that will make things easier to trace and debug, which will probably make your life easier, so go ahead.  It doesn't give an attacker any significant advantage.  (unless they manage to steal one without being able to otherwise determine what user they're stealing from, which seems unlikely.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Go buy Bruce Schneier's <a href="http://www.schneier.com/book-sandl.html" rel="noreferrer">Secrets and Lies</a> and his <a href="http://www.schneier.com/book-practical.html" rel="noreferrer">Practical Cryptography</a>.  Go ahead and order Ross Anderson's <a href="http://www.cl.cam.ac.uk/~rja14/book.html" rel="noreferrer">Security Engineering 2nd Ed.</a> while you're at it.  Now, read Secrets and Lies -- trust me, it's a fun read.  :)  Then read Practical Cryptography.  At that point you should have a better grounding in what you need to do when implementing software that needs some security.  Go ahead and do your rough-draft implementation.  Now that your copy of Security Engineering has arrived, read it... though that one you may want to digest a bit slower; it's a rather heavy tome.</p>
<p>There is also a <a href="http://pdos.csail.mit.edu/papers/webauth:sec10.pdf" rel="noreferrer">whitepaper on web authentication dos and don'ts</a> that is worth reading and a bit more directly applicable to what you're doing.  I still recommend the books above.</p>
<p>And <a href="http://lwn.net/SubscriberLink/380058/8cbe1b2a1ccd9440/" rel="noreferrer">another timely article from LWN.net</a> which lists a good number of pitfalls you need to work to avoid.  (BTW, <a href="http://lwn.net" rel="noreferrer">LWN.net</a> is well worth subscribing to, and I highly recommend it.  The above link allows free access to that article which otherwise would not be available to non-subscribers yet.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/library/uuid.html" rel="nofollow noreferrer">UUID</a> module in 2.5 and higher. This way they can't be guessed since they are not sequential. If you want them to be really secure you could salt them with the user's id and then SHA1 hash them, <a href="http://docs.python.org/library/base64.html?highlight=base64#module-base64" rel="nofollow noreferrer">Base64</a> encode the result and then use that as the value. That way you could verify on the server side that they really are your cookies and not just something that some spammer is generating and throwing at your server. And to make them even more secure make sure they only last for a set amount of time on the server as well as the client. Python 2.6.5 has an <a href="http://docs.python.org/library/hmac.html" rel="nofollow noreferrer">HMAC</a> implemenation built in that you could use on the generated UUID as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/library/os.html#os.urandom" rel="nofollow">os.urandom</a>:</p>
<blockquote>
<p>os.urandom(n)</p>
<p>Return a string of n random bytes suitable for cryptographic use.</p>
<p>This function returns random bytes from an OS-specific randomness source.
  The returned data should be unpredictable enough for cryptographic applications, though its exact quality depends on the OS
  implementation. On a UNIX-like system this will query /dev/urandom,
  and on Windows it will use CryptGenRandom. If a randomness source is
  not found, NotImplementedError will be raised.</p>
<p>New in version 2.4.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.6+, you can use the new library <a href="https://docs.python.org/3/library/secrets.html" rel="nofollow noreferrer">secrets</a>.</p>
<pre><code>from secrets import token_urlsafe

token = token_urlsafe(64)   # something like Drmhze6EPcv0fN_81Bj-nA....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/random.html" rel="nofollow">http://docs.python.org/2/library/random.html</a></p>
<p>"Warning: The pseudo-random generators of this [random] module should not be used for security purposes. Use os.urandom() or SystemRandom if you require a cryptographically secure pseudo-random number generator."</p>
<p>"os.urandom function returns random bytes from an OS-specific randomness source. The returned data should be unpredictable enough for cryptographic applications, though its exact quality depends on the OS implementation. On a UNIX-like system this will query /dev/urandom, and on Windows it will use CryptGenRandom(). If a randomness source is not found, NotImplementedError will be raised.</p>
<p>For an easy-to-use interface to the random number generator provided by your platform, please see random.SystemRandom."</p>
</div>
<div class="post-text" itemprop="text">
<p>I would avoid the random factor completely. What I've generally done is:</p>
<ul>
<li>Generate a sequential <code>session_id</code> (which I store locally).</li>
<li>When the user logs in, sign <code>session_id</code> with a private key (I use <code>itsdangerous</code> for this).</li>
<li>When I get a request, if the <code>session_id</code>'s signature is intact, I proceed, otherwise, 403 (400 would make sense too).</li>
</ul>
<p>Note that I store the <code>session_id</code> locally because I want to be able to expire end sessions prematurely.</p>
<p>If your sessions always last a fixed amount of time, and you don't need to end them prematurely, you can simply sign <code>user_id + datetime.now()</code>. This allows completely stateless session management.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way would be to <a href="http://docs.python.org/library/uuid.html" rel="nofollow noreferrer">generate a UUID</a>, using the <a href="http://docs.python.org/library/uuid.html#uuid.uuid1" rel="nofollow noreferrer"><code>uuid.uuid1</code></a> function:</p>
<blockquote>
<p>Generate a UUID from a host ID, sequence number, and the current time.</p>
</blockquote>
</div>
<span class="comment-copy">Using the user id as part of the unique ID takes away from the whole 'random' thing.  Even if it is not public, there will be more consistent numbers given to the same users, which is less secure.</span>
<span class="comment-copy">Make 100% certain that the cookie <i>never</i> goes over plain HTTP; if it can be intercepted, "unguessable" is no longer a factor.  Again, I recommend doing some real reading on the topic...</span>
<span class="comment-copy">Largely true.  But only a small fraction of the world is in a position to intercept packets.  Whereas you can use a whole botnet anywhere in the world to make guesses.  But, yeah, if you don't want to screw over anyone using a poorly secured wifi hotspot, get HTTPS and a valid cert.  None of that has any particular bearing on cookie generation, however.</span>
<span class="comment-copy">How do you do this server-side verification of the hash?  And what does that buy you again?  This seems a misleadingly complex way to come up with some random bytes.</span>
<span class="comment-copy">Using an HMAC allows the server to verify that it generated the random value without having to store that random value.  It can also include a timestamp to allow for expiration of the token, and the client can't modify that timestamp without invalidating the HMAC.  This <i>is</i> more complex, but allows you to validate that token without hitting a database.</span>
<span class="comment-copy">I should probably also mention that in the HMAC case, the random value only needs to be a nonce.  But that's what the books are for -- they cover this much better than I ever could. :)</span>
<span class="comment-copy">Note that this returns random <code>bytes</code>, not characters. You'll probably want to run the result by <a href="https://docs.python.org/3/library/base64.html#base64.b64encode" rel="nofollow noreferrer">base64.b64encode</a> and use that as a session id.</span>
<span class="comment-copy">Would this be the host ID of the machine on which the script is running?  Or of the connecting user?  How does the host id get specified?  Thanks.</span>
<span class="comment-copy">Having constant factors (like a host ID) or predictable factors (like a sequence number) is not what you want for this application.  uuid.uuid4 may be more suitable, depending on implementation.  Also, the UUID is a string expressed in hexadecimal, and you can more entropy-per-byte if you use a wider range of characters.</span>
