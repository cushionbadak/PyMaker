<div class="post-text" itemprop="text">
<p>In python is there an easy way to tell if something is not a sequence? I tried to just do:
<code>if x is not sequence</code> but python did not like that</p>
</div>
<div class="post-text" itemprop="text">
<p><code>iter(x)</code> will raise a <code>TypeError</code> if <code>x</code> cannot be iterated on -- but that check "accepts" sets and dictionaries, though it "rejects" other non-sequences such as <code>None</code> and numbers.</p>
<p>On the other hands, strings (which most applications want to consider "single items" rather than sequences) <em>are</em> in fact sequences (so, any test, unless specialcased for strings, is going to confirm that they are).  So, such simple checks are often not sufficient.</p>
<p>In Python 2.6 and better, <em>abstract base classes</em> were introduced, and among other powerful features they offer more good, systematic support for such "category checking".</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; isinstance([], collections.Sequence)
True
&gt;&gt;&gt; isinstance((), collections.Sequence)
True
&gt;&gt;&gt; isinstance(23, collections.Sequence)
False
&gt;&gt;&gt; isinstance('foo', collections.Sequence)
True
&gt;&gt;&gt; isinstance({}, collections.Sequence)
False
&gt;&gt;&gt; isinstance(set(), collections.Sequence)
False
</code></pre>
<p>You'll note strings are <em>still</em> considered "a sequence" (since they <em>are</em>), but at least you get dicts and sets out of the way.  If you want to exclude strings from your concept of "being sequences", you could use <code>collections.MutableSequence</code> (but that also excludes tuples, which, like strings, are sequences, but are not mutable), or do it explicitly:</p>
<pre><code>import collections

def issequenceforme(obj):
    if isinstance(obj, basestring):
        return False
    return isinstance(obj, collections.Sequence)
</code></pre>
<p>Season to taste, and serve hot!-)</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the below code snippet does what you want:</p>
<pre><code>def is_sequence(obj):
    return hasattr(type(obj), '__iter__')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/library/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange" rel="noreferrer">Python 2.6.5 documentation</a> describes the following sequence types: string, Unicode string, list, tuple, buffer, and xrange.</p>
<pre><code>def isSequence(obj):
    return type(obj) in [str, unicode, list, tuple, buffer, xrange]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since Python "adheres" duck typing, one of the approach is to check if an object has some member (method).</p>
<p>A sequence has length, has sequence of items, and support slicing [<a href="https://docs.python.org/3.5/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow noreferrer">doc</a>]. So, it would be like this:</p>
<pre><code>def is_sequence(obj):
    t = type(obj)
    return hasattr(t, '__len__') and hasattr(t, '__getitem__')
    # additionally: and hasattr(t, '__setitem__') and hasattr(t, '__delitem__')
</code></pre>
<p>They are all special methods, <code>__len__()</code> should return number of items, <code>__getitem__(i)</code> should return an item (in sequence it is <em>i</em>-th item, <strong>but</strong> not with mapping), <code>__getitem__(slice(start, stop, step))</code> should return subsequence, and <code>__setitem__</code> and <code>__delitem__</code> like you expect. This is such a contract, but whether the object really do these or not depends on whether the object adheres the contract or not.</p>
<p><strong>Note</strong> that, the function above will also return <code>True</code> for mapping, e.g. <code>dict</code>, since mapping also has these methods. To overcome this, you can do a <em>heavier</em> work:</p>
<pre><code>def is_sequence(obj):
    try:
        len(obj)
        obj[0:0]
        return True
    except TypeError:
        return False
</code></pre>
<p><strong>But</strong> most of the time you don't need this, just do what you want as if the object is a sequence and catch an exception if you wish. This is more pythonic.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why are you doing this? The normal way here is to require a certain type of thing (A sequence or a number or a file-like object, etc.) and then use it without checking anything. In Python, we don't typically use classes to carry semantic information but simply use the methods defined (this is called "duck typing"). We also prefer APIs where we know exactly what to expect; use keyword arguments, preprocessing, or defining another function if you want to change how a function works.</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3 and 2.6+, you can check if it's a subclass of <code>collections.Sequence</code>:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; isinstance(myObject, collections.Sequence)
True
</code></pre>
<p>In Python 3.7 you must use <code>collections.abc.Sequence</code> (<code>collections.Sequence</code> will be removed in Python 3.8):</p>
<pre><code>&gt;&gt;&gt; import collections.abc
&gt;&gt;&gt; isinstance(myObject, collections.abc.Sequence)
True
</code></pre>
<p>However, this won't work for duck-typed sequences which implement <code>__len__()</code> and <code>__getitem__()</code> but do not (as they should) subclass <code>collections.Sequence</code>. But it will work for all the built-in Python sequence types: lists, tuples, strings, etc.</p>
<p>While all sequences are iterables, not all iterables are sequences (for example, sets and dictionaries are iterable but not sequences). Checking <code>hasattr(type(obj), '__iter__')</code> will return <code>True</code> for dictionaries and sets.</p>
</div>
<div class="post-text" itemprop="text">
<p>why ask why</p>
<p>try getting a length and if exception return false</p>
<pre><code>def haslength(seq):
    try:
        len(seq)
    except:
        return False
    return True
</code></pre>
</div>
<span class="comment-copy">Related: In python, how do I determine if a variable is Iterable? <a href="http://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-a-variable-is-iterable/1952481#1952481" title="in python how do i determine if a variable is iterable">stackoverflow.com/questions/1952464/…</a></span>
<span class="comment-copy">Yep, but while all sequences are iterables not all iterables are sequences (sets and dicts are built-in iterable containers that are not sequences, for example).</span>
<span class="comment-copy">Note that this code example will return the wrong result for objects that implement the sequence protocol but do not involve the <code>collections.Sequence</code> ABC.</span>
<span class="comment-copy">Yep: differently from simpler ABCs, Sequence doesn't implement a <code>__subclasshook__</code> class method, so it will never automatically recognize a class that chose not to <code>register</code> with it (or inherit from it) -- it would be essentially impossible to tell by introspection whether a class's <code>__getitem__</code> accepts integers and slices, raises <code>IndexError</code> on wrong indices, etc -- all you need to rule out <code>dict</code> and <code>set</code>, essentially (that <i>do</i> seem to "implement the sequence protocol" if you just do introspection... but then turn out not to!-).</span>
<span class="comment-copy">Sets are pretty easy to rule out, since they don't have <code>__getitem__</code>, but mappings are much harder. The best check I've seen is probably to look for <code>keys</code>, like <code>dict.update</code> does, but that still leaves a lot to be desired.</span>
<span class="comment-copy">So for my custom type to be detected as a Sequence I have to subclass Sequence?</span>
<span class="comment-copy">Good example of the caveat mentioned is numpy arrays, which have all the required properties of a Sequence but fail to recognized as such by isinstance. If this doesn't even work for numpy arrays, seems pretty hopeless.</span>
<span class="comment-copy">Should be <code>hasattr(type(obj), '__iter__')</code>, see <a href="https://stackoverflow.com/questions/2937114/#comment71833903_31043360">this comment</a>.</span>
<span class="comment-copy">This is a quite universal variant as it is not related to inheriting from specific classes. It works for dictionary key sequences as well.</span>
<span class="comment-copy">The problem with this answer is that it won't detect sequences that aren't builtin types.  A Python "sequence" is any object that implements the methods necessary to respond to sequence operations.</span>
<span class="comment-copy">Also, use <code>isinstance</code> instead of <code>type</code> to support subclasses.</span>
<span class="comment-copy">The important point about dict is that if you treat it like a sequence you will just get the keys, not the values, and information will be lost.</span>
<span class="comment-copy">If using <code>hasattr()</code>, you need to check the type of the object for the magic methods, not the object itself.  See the <a href="https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-new-style-classes" rel="nofollow noreferrer">Python 2</a> and <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">Python 3</a> documentation on how special methods are looked up.</span>
<span class="comment-copy">@augurar Thanks man</span>
<span class="comment-copy"><code>__setitem__</code> and <code>__delitem__</code> would only apply to <i>mutable</i> sequences (e.g. not tuple or string)</span>
<span class="comment-copy">It's an assignment constraint. If the argument we are passed isn't an int, long or sequence we need to raise a <code>TypeError</code></span>
<span class="comment-copy">@nicotine, recognize that this assignment indicates a design that is usually nonidiomatic and fragile. Consider the normal case, where an object should be exactly one type of thing. If a parameter is supposed to be a sequence but you get an int, when you index or iterate over it you will already get a <code>TypeError</code>. Similarly, if you tried to do integer operations with a sequence you would.</span>
<span class="comment-copy">@MikeGraham To provide an example for where such a thing might be useful, I'm trying to write a function that can be given either a single object of one type or a list (or tuple) of such objects, and I need to be able to detect whether the caller gave me a sequence or just a single object. I know it's debatable whether or not this is good design, but at the moment I can't think of anything that speaks against it.</span>
<span class="comment-copy">Sometimes it's unavoidable.  I'm dealing with a situation where I'm processing JSON data where a particular value might be either a string, an integer, or a list of integers.  I can't change the JSON generator, so I have to handle the data as it comes to me.</span>
<span class="comment-copy">@MikeGraham Without checking you will indeed get a <code>TypeError</code> exception at some point, however this throws me out of my normal flow of my code. By checking I can mitigate this issue with much more control of what to do in this invalid situation. This is actually a discussion about wether or not to use exceptions as a error handling mechanism. I have always been against it, there are also multiple modern languages that don't support exceptions (any)more. Unfortunately, using exceptions is the Pythonic way, so idiomatically you are (unfortunately) right.</span>
<span class="comment-copy">A <code>set</code> has a length but isn’t a sequence.</span>
