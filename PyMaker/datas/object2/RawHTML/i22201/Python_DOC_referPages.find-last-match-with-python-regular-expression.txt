<div class="post-text" itemprop="text">
<p>I wanto to match the last occurence of a simple pattern in a string, e.g.</p>
<pre><code>list = re.findall(r"\w+ AAAA \w+", "foo bar AAAA foo2 AAAA bar2")
print "last match: ", list[len(list)-1]
</code></pre>
<p>however, if the string is <em>very</em> long, a huge list of matches is generated. Is there a more direct way to match the second occurence of "AAAA" or should I use this workaround?</p>
</div>
<div class="post-text" itemprop="text">
<p>you could use <code>$</code> that denotes end of the line character:</p>
<pre><code>&gt;&gt;&gt; s = """foo bar AAAA
foo2 AAAA bar2"""
&gt;&gt;&gt; re.findall(r"\w+ AAAA \w+$", s)
['foo2 AAAA bar2']
</code></pre>
<p>Also, note that <code>list</code> is a bad name for your variable, as it shadows built-in type. To access the last element of a list you could just use <code>[-1]</code> index:</p>
<pre><code>&gt;&gt;&gt; lst = [2, 3, 4]
&gt;&gt;&gt; lst[-1]
4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can avoid the building of a list just by iterating over all matches and keeping the last match:</p>
<pre><code>for match in re.finditer(r"\w+ AAAA \w+", "foo bar AAAA foo2 AAAA bar2"):
    pass
</code></pre>
<p>After this, <code>match</code> holds the last match, and works for all combinations of <em>pattern</em> and <em>searched string</em>. You might want to set <code>match</code> to <code>None</code> first, because if there's no match, <code>match</code> won't be set to any value.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wasn't sure if your original regex would give you what you wanted.
So sorry if I'm late to party.. But others may find this useful too.</p>
<pre><code>import re
p = r"AAAA(?=\s\w+)" #revised per comment from @Jerry
p2 =r"\w+ AAAA \w+"
s = "foo bar AAAA foo2 AAAA bar2"
l = re.findall(p, s)
l2 = re.findall(p2, s)
print('l: {l}'.format(l=l))

#print(f'l: {l}') is nicer, but online interpreters sometimes don't support it.
# https://www.onlinegdb.com/online_python_interpreter
#I'm using Python 3.

print('l2: {l}'.format(l=l2))
for m in re.finditer(p, s):
  print(m.span())
  #A span of (n,m) would really represent characters n to m-1 with zero based index
  #So.(8,12):
  # =&gt; (8,11: 0 based index)
  # =&gt; (9th to 12th characters conventional 1 based index)
print(re.findall(p, s)[-1])
</code></pre>
<p>Outputs:</p>
<pre><code>l: ['AAAA', 'AAAA']
l2: ['bar AAAA foo2']
(8, 12)
(18, 22)   
AAAA
</code></pre>
<p>The reason you get two results here instead of one in original is the <code>(?=)</code> special sauce.</p>
<p>It's called a <strong>positive lookahead.</strong> 
It does not '<em>consume</em>' (i.e. advance the cursor), when the match is found during the regex evaluation. So, it comes back after matching.</p>
<p>Although positive lookaheads are in parenthesis, they also act as a <em>non-capture group</em>. </p>
<p>So, although a pattern is matched, the results <strong>omit</strong> the surrounding sequence of alphanumeric characters represented by the <code>\w+</code> and the intervening spaces, <code>\s</code> in my example -representing <code>[ \t\n\r\f\v]</code>. (More <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">here</a>)</p>
<p>So I only get back AAAA each time.</p>
<p><code>p2</code> here, represents the original pattern of the code of @SDD, the person posing the question.</p>
<p><code>foo2</code> is <em>consumed</em>, with that pattern so second AAAA would not match, as the cursor had advanced too far, when the regex engine recommences on it's second iteration of matching.</p>
<hr/>
<p>I recommend taking a look at <strong>Moondra</strong>'s Youtube videos if you want to dig in deeper.</p>
<p>He has done a very thorough 17 part series  on Python Regex's, beginning <a href="https://www.youtube.com/watch?v=VU60rEXaOXk" rel="nofollow noreferrer">here</a> </p>
<hr/>
<p>Here's a <a href="https://www.onlinegdb.com/online_python_interpreter" rel="nofollow noreferrer">link</a> to an online Python Interpreter</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no built-in <code>re</code> library feature that supports right-to-left string parsing, the input string is only searched for a pattern from left to right.</p>
<p>There is a <a href="https://pypi.org/project/regex/" rel="nofollow noreferrer">PyPi regex module</a> that supports this feature, however. It is <code>regex.REVERSE</code> flag, or its inline variation, <code>(?r)</code>:</p>
<pre><code>s="foo bar AAAA foo2 AAAA bar2"
print(regex.search(r"(?r)\w+ AAAA \w+$", s).group())
# =&gt; foo2 AAAA bar2
</code></pre>
<p>With <code>re</code> module, there is a way to quickly get to the end of string using <code>^[\s\S]*</code> construct and let backtracking find the pattern that you'd like to caputure into a separate group. However, backtracking may gobble part of the match (as it will stop yielding more text once all subsequent patterns match), and in case the text is too large and there is no match, backtracking may become catastrophic. Only use this trick if your input string always matches, or if it is short and the custom pattern is not relying on backtracking much:</p>
<pre><code>print(re.search(r"(?:^[\s\S]*\W)?(\w+ AAAA \w+)$", s).group(1))
# =&gt; foo2 AAAA bar2
</code></pre>
<p>Here, <code>(?:^[\s\S]*\W)?</code> matches an optional sequence of a start of string, any 0 or more chars followed with a non-word char (<code>\W</code>). It is necessary to add <code>\W</code> to make backtracking get back to the non-word char, and it must be optional as the match might start at the start of the string.</p>
<p>See the <a href="https://rextester.com/NJDMT28419" rel="nofollow noreferrer">Python demo</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another fast way is using <code>search</code>, and <code>group</code>:</p>
<pre><code>&gt;&gt;&gt; re.search('\w+ AAAA \w+$',"foo bar AAAA foo2 AAAA bar2").group(0)
'foo2 AAAA bar2'
</code></pre>
<h3>What it does:</h3>
<ol>
<li><p>It uses the pattern of <code>\w+ AAAA \w+$</code>, which get's the last occurrence of <code>'AAAA'</code> with there be-siding words alongside of them, all using <code>\w+</code> (twice), and <code>$</code> (once).</p></li>
<li><p>After the process of the pattern matching, you will have to use the <code>_sre.SRE_Match.<strong>group</strong></code> method to get the belonging value of the <code>_sre.SRE_Match</code> object, and of course get the zeroth (first) group, as know that <code>search</code> only retains one match (the zeroth).</p></li>
</ol>
<h3>Here is the <a href="https://regex101.com/r/YuOBTd/1" rel="nofollow noreferrer">regex101</a> of it.</h3>
<h3>Here are the timings for all of the answers (except for JGFMK's answer, since it is hard):</h3>
<pre><code>&gt;&gt;&gt; timeit.timeit(lambda: re.findall(r"\w+ AAAA \w+$", s),number=1000000) # SilentGhost
5.783595023876842
&gt;&gt;&gt; timeit.timeit('import re\nfor match in re.finditer(r"\w+ AAAA \w+", "foo bar AAAA foo2 AAAA bar2"):pass',number=1000000) # tzot
5.329235373691631
&gt;&gt;&gt; timeit.timeit(lambda: re.search('\w+ AAAA \w+$',"foo bar AAAA foo2 AAAA bar2").group(0),number=1000000) # mine (U9-Forward)
5.441731174121287
&gt;&gt;&gt; 
</code></pre>
<p><sub>I am testing all the timings using <code>timeit</code> module, and also i am making <code>number=1000000</code> so it takes much longer.</sub></p>
</div>
<span class="comment-copy">Another option could be to reverse the string (<code>mystr[::-1]</code>) and search for the first occurence of the reverse of the pattern.</span>
<span class="comment-copy">@ChristopheD, Gross! Only thing harder to understand than a regex is a backwards one.</span>
<span class="comment-copy">None of the current answers address the "long string" problem.   <code>&gt;&gt;&gt; timeit.timeit(stmt = 'regex.search(long_string)', setup = "import re; regex=re.compile('b'); long_string='a'*int(10e8)+'b'; reverse_string=long_string[::-1]", number=10)</code> <code>8.432429309999861</code></span>
<span class="comment-copy"><code>&gt;&gt;&gt; timeit.timeit(stmt = 'regex.search(reverse_string)', setup = "import re; regex=re.compile('b'); long_string='a'*int(10e8)+'b'; reverse_string=long_string[::-1]", number=10)</code> <code>3.3803000405896455e-05</code></span>
<span class="comment-copy"><code>&gt;&gt;&gt; timeit.timeit(stmt = 'regex.search(long_string)', setup = "import re; regex=re.compile('b$'); long_string='a'*int(10e8)+'b'; reverse_string=long_string[::-1]", number=10)</code> <code>7.993536103000224</code></span>
<span class="comment-copy">what if I came across a multiline string?</span>
<span class="comment-copy">@SDD: it still would work fine</span>
<span class="comment-copy">This won't work for an input string like this: "foo bar AAAA foo2 AAAA bar2 bar3". Of course, we don't know if such a case is possible, we don't have enough information.</span>
<span class="comment-copy">This is very useful in a lot of usecases. You'd usually want to replace all occurrences of a pattern then custom process the last part of the input string.</span>
<span class="comment-copy">I don't quite understand why you have <code>(?=\w+\s)</code> in <code>(?=\w+\s)AAAA(?=\s\w+)</code>? I feel like it should actually be a positive <i>lookbehind</i>? i.e.<code>(?&lt;=\w+\s)AAAA(?=\s\w+)</code>. Also taking into consideration the long string mention of the OP, using <code>re.findall()</code> will likely make your solution slower.</span>
<span class="comment-copy">If you tried that you'd get look-behind requires fixed-width pattern. See <a href="https://stackoverflow.com/questions/20089922/python-regex-engine-look-behind-requires-fixed-width-pattern-error" title="python regex engine look behind requires fixed width pattern error">stackoverflow.com/questions/20089922/â€¦</a></span>
<span class="comment-copy">Exactly. Then what's the point of that lookahead? Looks like you could remove it entirely without altering the functionality</span>
<span class="comment-copy">As I indicated - "to not advance the cursor" - with a positive lookahead - not a positive lookbehind</span>
<span class="comment-copy">Ok let me rephrase it; what is a possible scenario where <code>AAAA(?=\s\w+)</code> would match something that <code>(?=\w+\s)AAAA(?=\s\w+)</code> will avoid matching?</span>
