<div class="post-text" itemprop="text">
<p>Suppose I was given a URL.<br/>
It might already have GET parameters (e.g. <code>http://example.com/search?q=question</code>) or it might not (e.g. <code>http://example.com/</code>).</p>
<p>And now I need to add some parameters to it like <code>{'lang':'en','tag':'python'}</code>. In the first case I'm going to have <code>http://example.com/search?q=question&amp;lang=en&amp;tag=python</code> and in the second — <code>http://example.com/search?lang=en&amp;tag=python</code>.</p>
<p>Is there any standard way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of quirks with the <code>urllib</code> and <code>urlparse</code> modules. Here's a working example:</p>
<pre><code>try:
    import urlparse
    from urllib import urlencode
except: # For Python 3
    import urllib.parse as urlparse
    from urllib.parse import urlencode

url = "http://stackoverflow.com/search?q=question"
params = {'lang':'en','tag':'python'}

url_parts = list(urlparse.urlparse(url))
query = dict(urlparse.parse_qsl(url_parts[4]))
query.update(params)

url_parts[4] = urlencode(query)

print(urlparse.urlunparse(url_parts))
</code></pre>
<p><code>ParseResult</code>, the result of <code>urlparse()</code>, <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlparse" rel="noreferrer">is read-only</a> and we need to convert it to a <code>list</code> before we can attempt to modify its data.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Why</h2>
<p>I've been not satisfied with all the solutions on this page (<em>come on, where is our favorite copy-paste thing?</em>) so I wrote my own based on answers here. It tries to be complete and more Pythonic. I've added a handler for <strong>dict</strong> and <strong>bool</strong> values in arguments to be more consumer-side (<em>JS</em>) friendly, but they are yet optional, you can drop them.</p>
<h2>How it works</h2>
<p><strong>Test 1:</strong> Adding new arguments, handling Arrays and Bool values:</p>
<pre><code>url = 'http://stackoverflow.com/test'
new_params = {'answers': False, 'data': ['some','values']}

add_url_params(url, new_params) == \
    'http://stackoverflow.com/test?data=some&amp;data=values&amp;answers=false'
</code></pre>
<p><strong>Test 2:</strong> Rewriting existing args, handling DICT values:</p>
<pre><code>url = 'http://stackoverflow.com/test/?question=false'
new_params = {'question': {'__X__':'__Y__'}}

add_url_params(url, new_params) == \
    'http://stackoverflow.com/test/?question=%7B%22__X__%22%3A+%22__Y__%22%7D'
</code></pre>
<h2>Talk is cheap. Show me the code.</h2>
<p>Code itself. I've tried to describe it in details:</p>
<pre><code>from json import dumps

try:
    from urllib import urlencode, unquote
    from urlparse import urlparse, parse_qsl, ParseResult
except ImportError:
    # Python 3 fallback
    from urllib.parse import (
        urlencode, unquote, urlparse, parse_qsl, ParseResult
    )


def add_url_params(url, params):
    """ Add GET params to provided URL being aware of existing.

    :param url: string of target URL
    :param params: dict containing requested params to be added
    :return: string with updated URL

    &gt;&gt; url = 'http://stackoverflow.com/test?answers=true'
    &gt;&gt; new_params = {'answers': False, 'data': ['some','values']}
    &gt;&gt; add_url_params(url, new_params)
    'http://stackoverflow.com/test?data=some&amp;data=values&amp;answers=false'
    """
    # Unquoting URL first so we don't loose existing args
    url = unquote(url)
    # Extracting url info
    parsed_url = urlparse(url)
    # Extracting URL arguments from parsed URL
    get_args = parsed_url.query
    # Converting URL arguments to dict
    parsed_get_args = dict(parse_qsl(get_args))
    # Merging URL arguments dict with new params
    parsed_get_args.update(params)

    # Bool and Dict values should be converted to json-friendly values
    # you may throw this part away if you don't like it :)
    parsed_get_args.update(
        {k: dumps(v) for k, v in parsed_get_args.items()
         if isinstance(v, (bool, dict))}
    )

    # Converting URL argument to proper query string
    encoded_get_args = urlencode(parsed_get_args, doseq=True)
    # Creating new parsed result object based on provided with new
    # URL arguments. Same thing happens inside of urlparse.
    new_url = ParseResult(
        parsed_url.scheme, parsed_url.netloc, parsed_url.path,
        parsed_url.params, encoded_get_args, parsed_url.fragment
    ).geturl()

    return new_url
</code></pre>
<p><em>Please be aware that there may be some issues, if you'll find one please let me know and we will make this thing better</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use URL encoding if the strings can have arbitrary data (for example, characters such as ampersands, slashes, etc. will need to be encoded).</p>
<p>Check out urllib.urlencode:</p>
<pre><code>&gt;&gt;&gt; import urllib
&gt;&gt;&gt; urllib.urlencode({'lang':'en','tag':'python'})
'lang=en&amp;tag=python'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the furl module <a href="https://github.com/gruns/furl">https://github.com/gruns/furl</a></p>
<pre><code>&gt;&gt;&gt; from furl import furl
&gt;&gt;&gt; print furl('http://example.com/search?q=question').add({'lang':'en','tag':'python'}).url
http://example.com/search?q=question&amp;lang=en&amp;tag=python
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes: use <a href="http://docs.python.org/library/urllib.html" rel="noreferrer">urllib</a>.</p>
<p>From the <a href="http://docs.python.org/library/urllib.html#examples" rel="noreferrer">examples</a> in the documentation:</p>
<pre><code>&gt;&gt;&gt; import urllib
&gt;&gt;&gt; params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
&gt;&gt;&gt; f = urllib.urlopen("http://www.musi-cal.com/cgi-bin/query?%s" % params)
&gt;&gt;&gt; print f.geturl() # Prints the final URL with parameters.
&gt;&gt;&gt; print f.read() # Prints the contents
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on <a href="https://stackoverflow.com/a/9538343/1113207">this</a> answer, one-liner for simple cases (Python 3 code):</p>
<pre><code>from urllib.parse import urlparse, urlencode


url = "https://stackoverflow.com/search?q=question"
params = {'lang':'en','tag':'python'}

url += ('&amp;' if urlparse(url).query else '?') + urlencode(params)
</code></pre>
<p>or:</p>
<pre><code>url += ('&amp;', '?')[urlparse(url).query == ''] + urlencode(params)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I liked Łukasz version, but since urllib and urllparse functions are somewhat awkward to use in this case, I think it's more straightforward to do something like this:</p>
<pre><code>params = urllib.urlencode(params)

if urlparse.urlparse(url)[4]:
    print url + '&amp;' + params
else:
    print url + '?' + params
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using the <a href="http://docs.python-requests.org/en/master/" rel="nofollow noreferrer">requests lib</a>:</p>
<pre><code>import requests
...
params = {'tag': 'python'}
requests.get(url, params=params)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Outsource it to the battle tested <a href="https://github.com/requests/requests/blob/master/requests/models.py#L347" rel="nofollow noreferrer">requests library</a>.</p>
<p>This is how I will do it:</p>
<pre><code>from requests.models import PreparedRequest
url = 'http://example.com/search?q=question'
params = {'lang':'en','tag':'python'}
req = PreparedRequest()
req.prepare_url(url, params)
print(req.url)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the various <a href="http://docs.python.org/library/urlparse.html" rel="nofollow noreferrer"><code>urlparse</code></a> functions to tear apart the existing URL, <a href="http://docs.python.org/library/urllib.html#urllib.urlencode" rel="nofollow noreferrer"><code>urllib.urlencode()</code></a> on the combined dictionary, then <code>urlparse.urlunparse()</code> to put it all back together again.</p>
<p>Or just take the result of <code>urllib.urlencode()</code> and concatenate it to the URL appropriately.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another answer:</p>
<pre><code>def addGetParameters(url, newParams):
    (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)
    queryList = urlparse.parse_qsl(query, keep_blank_values=True)
    for key in newParams:
        queryList.append((key, newParams[key]))
    return urlparse.urlunparse((scheme, netloc, path, params, urllib.urlencode(queryList), fragment))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I find this more elegant than the two top answers:</p>
<pre><code>from urllib.parse import urlencode, urlparse, parse_qs

def merge_url_query_params(url: str, additional_params: dict) -&gt; str:
    url_components = urlparse(url)
    original_params = parse_qs(url_components.query)
    # Before Python 3.5 you could update original_params with 
    # additional_params, but here all the variables are immutable.
    merged_params = {**original_params, **additional_params}
    updated_query = urlencode(merged_params, doseq=True)
    # _replace() is how you can create a new NamedTuple with a changed field
    return url_components._replace(query=updated_query).geturl()

assert merge_url_query_params(
    'http://example.com/search?q=question',
    {'lang':'en','tag':'python'},
) == 'http://example.com/search?q=question&amp;lang=en&amp;tag=python'
</code></pre>
<p>The most important things I dislike in the top answers (they are nevertheless good):</p>
<ul>
<li>Łukasz: having to remember the index at which the <code>query</code> is in the URL components</li>
<li>Sapphire64: the very verbose way of creating the updated <code>ParseResult</code></li>
</ul>
<p>What's bad about my response is the magically looking <code>dict</code> merge using unpacking, but I prefer that to updating an already existing dictionary because of my prejudice against mutability.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python 2.5</p>
<pre><code>import cgi
import urllib
import urlparse

def add_url_param(url, **params):
    n=3
    parts = list(urlparse.urlsplit(url))
    d = dict(cgi.parse_qsl(parts[n])) # use cgi.parse_qs for list values
    d.update(params)
    parts[n]=urllib.urlencode(d)
    return urlparse.urlunsplit(parts)

url = "http://stackoverflow.com/search?q=question"
add_url_param(url, lang='en') == "http://stackoverflow.com/search?q=question&amp;lang=en"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is how I implemented it.</p>
<pre><code>import urllib

params = urllib.urlencode({'lang':'en','tag':'python'})
url = ''
if request.GET:
   url = request.url + '&amp;' + params
else:
   url = request.url + '?' + params    
</code></pre>
<p>Worked like a charm. However, I would have liked a more cleaner way to implement this.</p>
<p>Another way of implementing the above is put it in a method.</p>
<pre><code>import urllib

def add_url_param(request, **params):
   new_url = ''
   _params = dict(**params)
   _params = urllib.urlencode(_params)

   if _params:
      if request.GET:
         new_url = request.url + '&amp;' + _params
      else:
         new_url = request.url + '?' + _params
   else:
      new_url = request.url

   return new_ur
</code></pre>
</div>
<span class="comment-copy">You probably want to use <code>urlparse.parse_qs</code> instead of <code>parse_qsl</code>. The latter returns a list whereas you want a dict. See <a href="http://docs.python.org/library/urlparse.html#urlparse.parse_qs" rel="nofollow noreferrer">docs.python.org/library/urlparse.html#urlparse.parse_qs</a>.</span>
<span class="comment-copy">@florian : At least in python 2.7 you then need to call <code>urlencode</code> as <code>urllib.urlencode(query, doseq=True)</code>. Otherwise, parameters that existed in the original url are not preserved correctly (because they are returned as tuples from @parse_qs@</span>
<span class="comment-copy">I've rewritten this to work in Python 3 as well. <a href="https://gist.github.com/rokcarl/20b5bf8dd9b1998880b7" rel="nofollow noreferrer">Code here</a>.</span>
<span class="comment-copy">The results of <code>urlparse()</code> and <code>urlsplit()</code> are actually <code>namedtuple</code> instances. Thus you can assign them directly to a variable and use <code>url_parts = url_parts._replace(query = …)</code> to update it.</span>
<span class="comment-copy">Caution - this implementation removes repeated query parameters that some RESTful services use. With a little modification this can be fixed. query = urlparse.parse_qsl(url_parts[4]) query += params.items() But then if you want to replace exiting query params using dict, takes a little more.</span>
<span class="comment-copy">Perhaps add a try except with from urllib.parse to include Python 3 support? Thanks for the snippet, very useful!</span>
<span class="comment-copy">@MattV thanks, I've updated to support Python 3 :)</span>
<span class="comment-copy">Maybe add imports too ?</span>
<span class="comment-copy">Thanks for the hint to furl. That is so much nicer than the urllib stuff!</span>
<span class="comment-copy">Can you please give some brief example?</span>
<span class="comment-copy">f.read() will show you the HTML page. To see the calling url, f.geturl()</span>
<span class="comment-copy">@ccheneson: Thanks, added.</span>
<span class="comment-copy">-1 for using a HTTP request for parsing a URL (which is actually basic string manipulation). Plus the actual problem is not considered, because you need to know how the URL looks like to be able to append the query string correctly.</span>
<span class="comment-copy">Either the author edited question either this answer is not related to it.</span>
<span class="comment-copy">I know you mentioned "simple cases", but to clarify: it won't work properly if there is an <code>?</code> in the anchor (<code>#?stuff</code>).</span>
<span class="comment-copy">How about .query instead of [4] ?</span>
