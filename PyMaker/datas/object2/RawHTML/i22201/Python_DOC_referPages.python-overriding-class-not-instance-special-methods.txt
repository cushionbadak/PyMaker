<div class="post-text" itemprop="text">
<p>How do I override a class special method?</p>
<p>I want to be able to call the <code>__str__()</code> method of the class without creating an instance. Example:</p>
<pre><code>class Foo:
    def __str__(self):
        return 'Bar'

class StaticFoo:
    @staticmethod
    def __str__():
        return 'StaticBar'

class ClassFoo:
    @classmethod
    def __str__(cls):
        return 'ClassBar'

if __name__ == '__main__':
    print(Foo)
    print(Foo())
    print(StaticFoo)
    print(StaticFoo())
    print(ClassFoo)
    print(ClassFoo())
</code></pre>
<p>produces:</p>
<pre class="lang-none prettyprint-override"><code>&lt;class '__main__.Foo'&gt;
Bar
&lt;class '__main__.StaticFoo'&gt;
StaticBar
&lt;class '__main__.ClassFoo'&gt;
ClassBar
</code></pre>
<p>should be:</p>
<pre class="lang-none prettyprint-override"><code>Bar
Bar
StaticBar
StaticBar
ClassBar
ClassBar
</code></pre>
<p>Even if I use the <code>@staticmethod</code> or <code>@classmethod</code> the <code>__str__</code> is still using the built-in Python definition for <code>__str__</code>. It's only working when it's <code>Foo().__str__()</code> instead of <code>Foo.__str__()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Special method <code>__str__</code> defined in a class works only for the instances of that class, to have the different behavior for class objects you will have to do it in a metaclass of that class e.g. (python 2.5)</p>
<pre><code>class Meta(type):
    def __str__(self):
        return "Klass"

class A(object):
    __metaclass__ = Meta

    def __str__(self):
        return "instance"

print A
print A()
</code></pre>
<p>output:</p>
<pre><code>Klass
instance
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why do you want to abuse the meaning of <code>__str__</code>? That method name (like <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">many dunder method names</a>) is special in Python, being an instance method with the meaning "return a string representation of <em>this instance</em> of the class".</p>
<p>If you want a function that just returns a static string, it would be better to have that as a separate function not inside a class.</p>
<p>If you want a constructor that returns a new string, name it something else so it's not clobbering the special <code>__str__</code> name.</p>
<p>If you want a method for printing a representation of the class, you should not use the name <code>__str__</code> for that. That name is – as the <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">dunder-style name implies</a> – expected to have <a href="https://docs.python.org/3/reference/datamodel.html#object.__str__" rel="nofollow noreferrer">particular behaviour as defined in the Python documentation</a>. Choose some (non-dunder) name which you can give your special meaning, and don't forget to make it a class method.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure what you are trying to do, exactly.   Let me just add a bit of random information.</p>
<p>First, add this class:</p>
<pre><code>class FooNew(object):
def __str__(self):
    return 'Fubar'
</code></pre>
<p>Print this instead:</p>
<pre><code>if __name__ == '__main__':
    print "You are calling type for an old style class"
    print(Foo)
    print(type.__str__(Foo))
    print(Foo())
    print("But my Python 2.6 didn't match your output for print(Foo)")
    print("You are calling object.str() for a new style class")
    print(FooNew)
    print(object.__str__(FooNew))
    print(FooNew())
    print("Why do you want to change this?")
</code></pre>
<p>To get this:</p>
<pre><code>You are calling type for an old style class
__main__.Foo
&lt;class __main__.Foo at 0xb73c9f5c&gt;
Bar
But my Python 2.6 didn't match your output for print(Foo)
You are calling object.str() for a new style class
&lt;class '__main__.FooNew'&gt;
&lt;class '__main__.FooNew'&gt;
Fubar
Why do you want to change this?
</code></pre>
<p>Are you absolutely sure you don't want to call a classmethod?</p>
</div>
<span class="comment-copy">-1: "call the <code>__str__()</code> method of the class without creating an instance".  Breaks every understanding anyone has of what an object is.  Please do not do this.  It makes the program absolutely violate our most fundamental expectations.</span>
<span class="comment-copy">I disagree. If you call str(MyClass) then there's no reason you would expect it to behave as though you just called str(myClassObject). That is, there are no fundamental expectations to begin with. I suspect he wants to create a static class and never intends to create any instances of it.</span>
<span class="comment-copy">I had to use the new py3 syntax of     class C(metaclass=M):         ... but it works!</span>
<span class="comment-copy">Could you update this answer for Python 3? Thanks!</span>
<span class="comment-copy">"That method is reserved for the meaning "return a string representation of this instance"" &lt;- the class is an <b>instance</b> itself, namely of <code>type</code>, so there's no conceptual problem with wanting to have a nice printout for a class. <code>class A(object): pass; isinstance(A, type)</code> -&gt; <code>True</code>.</span>
<span class="comment-copy">@timgeb: I've updated the answer to account for that, thanks.</span>
