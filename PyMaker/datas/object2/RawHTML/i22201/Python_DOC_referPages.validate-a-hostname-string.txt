<div class="post-text" itemprop="text">
<p>Following up to <a href="https://stackoverflow.com/questions/106179/regular-expression-to-match-hostname-or-ip-address">Regular expression to match hostname or IP Address?</a>
and using <a href="http://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names" rel="noreferrer">Restrictions on valid host names</a> as a reference, what is the most readable, concise way to match/validate a hostname/fqdn (fully qualified domain name) in Python?  I've answered with my attempt below, improvements welcome.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
def is_valid_hostname(hostname):
    if len(hostname) &gt; 255:
        return False
    if hostname[-1] == ".":
        hostname = hostname[:-1] # strip exactly one dot from the right, if present
    allowed = re.compile("(?!-)[A-Z\d-]{1,63}(?&lt;!-)$", re.IGNORECASE)
    return all(allowed.match(x) for x in hostname.split("."))
</code></pre>
<p>ensures that each segment</p>
<ul>
<li>contains at least one character and a maximum of 63 characters</li>
<li>consists only of allowed characters</li>
<li>doesn't begin or end with a hyphen.</li>
</ul>
<p>It also avoids double negatives (<code>not disallowed</code>), and if <code>hostname</code> ends in a <code>.</code>, that's OK, too. It will (and should) fail if <code>hostname</code> ends in more than one dot.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a bit stricter version of <a href="https://stackoverflow.com/a/2532344/244297">Tim Pietzcker's answer</a> with the following improvements:</p>
<ul>
<li>Limit the length of the hostname to 253 characters (after stripping the optional trailing dot).</li>
<li>Limit the character set to ASCII (i.e. use <code>[0-9]</code> instead of <code>\d</code>).</li>
<li>Check that the TLD is not all-numeric.</li>
</ul>
<pre><code>import re

def is_valid_hostname(hostname):
    if hostname[-1] == ".":
        # strip exactly one dot from the right, if present
        hostname = hostname[:-1]
    if len(hostname) &gt; 253:
        return False

    labels = hostname.split(".")

    # the TLD must be not all-numeric
    if re.match(r"[0-9]+$", labels[-1]):
        return False

    allowed = re.compile(r"(?!-)[a-z0-9-]{1,63}(?&lt;!-)$", re.IGNORECASE)
    return all(allowed.match(label) for label in labels)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Per <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/04/12/10292868.aspx" rel="nofollow">The Old New Thing</a>, the maximum length of a DNS name is 253 characters. (One is allowed up to 255 octets, but 2 of those are consumed by the encoding.)</p>
<pre><code>import re

def validate_fqdn(dn):
    if dn.endswith('.'):
        dn = dn[:-1]
    if len(dn) &lt; 1 or len(dn) &gt; 253:
        return False
    ldh_re = re.compile('^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$',
                        re.IGNORECASE)
    return all(ldh_re.match(x) for x in dn.split('.'))
</code></pre>
<p>One could argue for accepting empty domain names, or not, depending on one's purpose.</p>
</div>
<div class="post-text" itemprop="text">
<p>I like the thoroughness of Tim Pietzcker's answer, but I prefer to offload some of the logic from regular expressions for readability. Honestly, I had to look up the meaning of those <code>(?</code> "extension notation" parts. Additionally, I feel the "double-negative" approach is more obvious in that it limits the responsibility of the regular expression to just finding any invalid character. I do like that re.IGNORECASE allows the regex to be shortened.</p>
<p>So here's another shot; it's longer but it reads kind of like prose. I suppose "readable" is somewhat at odds with "concise". I believe all of the validation constraints mentioned in the thread so far are covered:</p>
<pre><code>
def isValidHostname(hostname):
    if len(hostname) &gt; 255:
        return False
    if hostname.endswith("."): # A single trailing dot is legal
        hostname = hostname[:-1] # strip exactly one dot from the right, if present
    disallowed = re.compile("[^A-Z\d-]", re.IGNORECASE)
    return all( # Split by labels and verify individually
        (label and len(label) &lt;= 63 # length is within proper range
         and not label.startswith("-") and not label.endswith("-") # no bordering hyphens
         and not disallowed.search(label)) # contains only legal characters
        for label in hostname.split("."))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Complimentary to the @TimPietzcker answer. 
Underscore is a valid hostname, double dash is common for IDN punycode. Port number should be stripped. This is the cleanup of the code.</p>
<pre><code>import re
def is_valid_hostname(hostname):
    if len(hostname) &gt; 255:
        return False
    hostname = hostname.rstrip(".")
    allowed = re.compile("(?!-)[A-Z\d\-\_]{1,63}(?&lt;!-)$", re.IGNORECASE)
    return all(allowed.match(x) for x in hostname.split("."))

# convert your unicode hostname to punycode (python 3 ) 
# Remove the port number from hostname
normalise_host = hostname.encode("idna").decode().split(":")[0]
is_valid_hostanme(normalise_host )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_valid_host(host):
    '''IDN compatible domain validator'''
    host = host.encode('idna').lower()
    if not hasattr(is_valid_host, '_re'):
        import re
        is_valid_host._re = re.compile(r'^([0-9a-z][-\w]*[0-9a-z]\.)+[a-z0-9\-]{2,15}$')
    return bool(is_valid_host._re.match(host))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This pure regex should meet all the parameters:
<code>
^(?=.{1,253}\.?$)(?!-)[A-Za-z0-9\-]{1,63}(\.[A-Za-z0-9\-]{1,63})*\.?(?&lt;!-)$
</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Process each DNS label individually by excluding invalid characters and ensuring nonzero length.</p>
<pre><code>
def isValidHostname(hostname):
    disallowed = re.compile("[^a-zA-Z\d\-]")
    return all(map(lambda x: len(x) and not disallowed.search(x), hostname.split(".")))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're looking to validate the name of an existing host, the best way is to try to resolve it. You'll never write a regular expression to provide that level of validation.</p>
</div>
<span class="comment-copy">Hostname labels should also not end with a hyphen.</span>
<span class="comment-copy">Right, thanks. Edited my answer.</span>
<span class="comment-copy">You're using <code>re.match</code> incorrectly - mind that <code>re.match("a+", "ab")</code> is a match whereas <code>re.match("a+$", "ab")</code> isn't. Your function also does not allow for a single dot at the end of the hostname.</span>
<span class="comment-copy">I had been under the impression that <code>re.match</code> needs to match the entire string, therefore making the end-of-string anchor unnecessary. But as I now found out (thanks!) it only binds the match to the start of the string. I corrected my regex accordingly. I don't get your second point, however. Is it legal to end a hostname in a dot? The Wikipedia article linked in the question appears to say no.</span>
<span class="comment-copy">@Tim Pietzcker Yes, a single dot at the end is legal.  It marks the name as a fully-qualified domain name, which lets the DNS system know that it shouldn't try appending the local domain to it.</span>
<span class="comment-copy">According to RFC 3936 ( <a href="https://tools.ietf.org/html/rfc3696#section-2" rel="nofollow noreferrer">tools.ietf.org/html/rfc3696#section-2</a> ), only TLD should not be numeric, so I'd say that the last condition should look like <code>if re.match(r"\.(\d+)$", hostname):</code></span>
<span class="comment-copy">You don't need the backslashes as line continuators - they are implicit in the enclosing parentheses.</span>
<span class="comment-copy">good to know. i've removed them.</span>
<span class="comment-copy">This returns <code>True</code> for "1.1.1.1" (and any other all-numeric hostname).</span>
<span class="comment-copy">What's this, obfuscated python? Why the magic with maybe making a regexp an attribute on the function?</span>
<span class="comment-copy">It's so the re.compile only has to be done once, instead of every time the function is called.  Probably only matters if you're calling this function many times per second.</span>
<span class="comment-copy">@imbolc +1 for implementing idna encoding.</span>
<span class="comment-copy">@btubbs Python already <a href="https://docs.python.org/3/library/re.html?highlight=re#re.compile" rel="nofollow noreferrer">caches results of <code>re.compile()</code></a>, unless you use are using a lot of different patterns. I agree with @kaleissin that this code is rather obfuscated. Just plug the compiled expression in a private variable in the same scope as <code>is_valid_host()</code>. You can still only calculate it on the first call and save it into the variable.</span>
<span class="comment-copy"><code>return all(x and not disallowed.search(x) for x in hostname.split("."))</code></span>
<span class="comment-copy">A trailing <code>.</code> on the end of a hostname is valid. Oh, and much more work to do if you want to support IDN, of course...</span>
<span class="comment-copy">And what if he wants to find out if a hostname that does not yet exist will be a legal one? The RFC appears to be quite straightforward, so I don't see why a regex wouldn't work.</span>
<span class="comment-copy">Depends on what you're trying to show. If the name doesn't resolve then who knows what it “means”; the true means of validation require information that a regular expression cannot have (i.e., access to DNS). It's easier to just try it and handle the failure. And when thinking about names that are potentially legal but not yet, the only people who actually need to care about that are the registrars. Everyone else should leave these things to the code that is designed to have genuine expertise in the area. As JWZ notes, applying an RE turns a problem into two problems. (Well, mostly…)</span>
<span class="comment-copy">i do not agree. there are two separate concerns, and both are valid concerns: (1)°argue whether a given string can serve, technically and plausibly, as a, say, valid email address, hostname, such things; (2)°demonstrate that a given name is taken, or likely free. (1) is purely a syntactical consideration. since (2) happens over the network, there is a modicum of doubt: a host that is up now can be down in a second, a domain i order now can be taken when my mail arrives.</span>
<span class="comment-copy">This approach has been proposed in a similar question (<a href="http://stackoverflow.com/questions/399932/can-i-improve-this-regex-check-for-valid-domain-names/401132#401132" title="can i improve this regex check for valid domain names">stackoverflow.com/questions/399932/…</a>), and there is even a Python project to facilitate this (<a href="http://code.google.com/p/python-public-suffix-list/" rel="nofollow noreferrer">code.google.com/p/python-public-suffix-list</a>). I've modified the question title slightly, since I'm not interested in a solution that requires network lookups.</span>
