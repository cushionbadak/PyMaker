<div class="post-text" itemprop="text">
<p>when using Python's stock XML tools such as <code>xml.dom.minidom</code> for XML writing, a file would always start off like</p>
<p><code>&lt;?xml version="1.0"?&gt;</code></p>
<p><code>[...]</code></p>
<p>While this is perfectly legal XML code, and it's even recommended to use the header, I'd like to get rid of it as one of the programs I'm working with has problems here.</p>
<p>I can't seem to find the appropriate option in <code>xml.dom.minidom</code>, so I wondered if there are other packages which do allow to neglect the header.</p>
<p>Cheers,</p>
<p>Nico</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately <code>minidom</code> does not give you the option to omit the XML Declaration.</p>
<p>But you can always serialise the document content yourself by calling <code>toxml()</code> on the document's root element instead of the <code>document</code>. Then you won't get an XML Declaration:</p>
<pre><code>xml= document.documentElement.toxml('utf-8')
</code></pre>
<p>...but then you also wouldn't get anything else outside the root element, such as the DOCTYPE, or any comments or processing instructions. If you need them, serialise each child of the document object one by one:</p>
<pre><code>xml= '\n'.join(node.toxml('utf-8') for node in document.childNodes)
</code></pre>
<blockquote>
<p>I wondered if there are other packages which do allow to neglect the header.</p>
</blockquote>
<p>DOM Level 3 LS <a href="http://www.w3.org/TR/DOM-Level-3-LS/load-save.html#parameter-xml-declaration" rel="noreferrer">defines</a> an <code>xml-declaration</code> config parameter you can use to suppress it. The only Python implementation I know of is <code>pxdom</code>, which is thorough on standards support, but not at all fast.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use minidom and maintain 'prettiness', how about this as a quick/hacky fix:</p>
<p><strong>xml_without_declaration.py</strong>:</p>
<pre><code>import xml.dom.minidom as xml

doc = xml.Document()

declaration = doc.toxml()

a = doc.createElement("A")
doc.appendChild(a)
b = doc.createElement("B")
a.appendChild(b)

xml = doc.toprettyxml()[len(declaration):]

print xml
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're set on using minidom, just scan back in the file and remove the first line after writing all the XML you need. </p>
</div>
<div class="post-text" itemprop="text">
<p>You might be able to use a custom file-like object which removes the first tag, e.g:</p>
<pre><code>class RemoveFirstLine:
    def __init__(self, f):
        self.f = f
        self.xmlTagFound = False

    def __getattr__(self, attr):
        return getattr(self, self.f)

    def write(self, s):
        if not self.xmlTagFound:
            x = 0 # just to be safe
            for x, c in enumerate(s):
                if c == '&gt;':
                    self.xmlTagFound = True
                    break
            self.f.write(s[x+1:])
        else:
            self.f.write(s)

...
f = RemoveFirstLine(open('path', 'wb'))
Node.writexml(f, encoding='UTF-8')
</code></pre>
<p>or something similar. This has the advantage the file doesn't have to be totally rewritten if the XML files are fairly large.</p>
</div>
<div class="post-text" itemprop="text">
<p>Purists may not like to hear this, but I have found using an XML parser to generate XML to be overkill. Just generate it directly as strings. This also lets you generate files larger than you can keep in memory, which you can't do with DOM. Reading XML is another story.</p>
</div>
<div class="post-text" itemprop="text">
<p>The header is print in <code>Document</code>. If you print the node directly, it won't print the header.</p>
<pre><code>root = doc.childNodes[0]
root.toprettyxml(encoding="utf-8")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Just replace the first line with blank:</strong></p>
<pre><code>import xml.dom.minidom as MD     
&lt;XML String&gt;.replace(MD.Document().toxml()+'\n', '') 
</code></pre>
</div>
<span class="comment-copy">You could always write to a StringIO object, strip off the header and save it. This is probably easier than picking a new library. <a href="http://docs.python.org/library/stringio.html" rel="nofollow noreferrer">docs.python.org/library/stringio.html</a></span>
<span class="comment-copy">For the record, the LXML and Python 2.7 ElementTree APIs accept <code>xml_declaration=False</code> on <code>.write()</code> and both LXML and cElementTree are very fast.</span>
<span class="comment-copy">Some news in 2018 to "no xml-declaration"?  XML seems abandoned in Python... Use Java instead? PS: <a href="https://docs.python.org/3/library/xml.dom.minidom.html" rel="nofollow noreferrer">none here</a>.</span>
<span class="comment-copy">This leaves a new line at the beginning of the string. Fix with <code>xml = doc.toprettyxml()[(len(declaration) + 1):]</code>.</span>
<span class="comment-copy">This is fraught with pitfalls. Serialising XML is easier than parsing it, but it still requires considerable care to get right. Stuff like whitespace escaping in attribute values (to avoid normalisation on parsing), the <code>]]&gt;</code> issue, splitting CDATA sections (especially if you need non-UTF-8 output), and above all the complexity of serialising namespaced DOMs. You <i>will</i> make mistakes and generate something that isn't well-formed XML. And then all the mean kids will laugh.</span>
