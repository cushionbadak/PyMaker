<div class="post-text" itemprop="text">
<p>Given a function object, how can I get its signature? For example, for:</p>
<pre><code>def myMethod(firt, second, third='something'):
    pass
</code></pre>
<p>I would like to get <code>"myMethod(firt, second, third='something')"</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import inspect

def foo(a, b, x='blah'):
    pass

print(inspect.getargspec(foo))
# ArgSpec(args=['a', 'b', 'x'], varargs=None, keywords=None, defaults=('blah',))
</code></pre>
<p>However, note that <code>inspect.getargspec()</code> is deprecated since Python 3.0.</p>
<p>Python 3.0--3.4 recommends <a href="https://docs.python.org/3.4/library/inspect.html#inspect.getfullargspec" rel="noreferrer"><code>inspect.getfullargspec()</code></a>.</p>
<p>Python 3.5+ recommends <a href="https://docs.python.org/3.5/library/inspect.html#inspect.signature" rel="noreferrer"><code>inspect.signature()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Arguably the easiest way to find the signature for a function would be <code>help(function)</code>:</p>
<pre><code>&gt;&gt;&gt; def function(arg1, arg2="foo", *args, **kwargs): pass
&gt;&gt;&gt; help(function)
Help on function function in module __main__:

function(arg1, arg2='foo', *args, **kwargs)
</code></pre>
<p>Also, in Python 3 a method was added to the <code>inspect</code> module called <code>signature</code>, which is designed to represent the <a href="https://docs.python.org/3/library/inspect.html#inspect.signature">signature of a callable object and its return annotation</a>:</p>
<pre><code>&gt;&gt;&gt; from inspect import signature
&gt;&gt;&gt; def foo(a, *, b:int, **kwargs):
...     pass

&gt;&gt;&gt; sig = signature(foo)

&gt;&gt;&gt; str(sig)
'(a, *, b:int, **kwargs)'

&gt;&gt;&gt; str(sig.parameters['b'])
'b:int'

&gt;&gt;&gt; sig.parameters['b'].annotation
&lt;class 'int'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>#! /usr/bin/env python

import inspect
from collections import namedtuple

DefaultArgSpec = namedtuple('DefaultArgSpec', 'has_default default_value')

def _get_default_arg(args, defaults, arg_index):
    """ Method that determines if an argument has default value or not,
    and if yes what is the default value for the argument

    :param args: array of arguments, eg: ['first_arg', 'second_arg', 'third_arg']
    :param defaults: array of default values, eg: (42, 'something')
    :param arg_index: index of the argument in the argument array for which,
    this function checks if a default value exists or not. And if default value
    exists it would return the default value. Example argument: 1
    :return: Tuple of whether there is a default or not, and if yes the default
    value, eg: for index 2 i.e. for "second_arg" this function returns (True, 42)
    """
    if not defaults:
        return DefaultArgSpec(False, None)

    args_with_no_defaults = len(args) - len(defaults)

    if arg_index &lt; args_with_no_defaults:
        return DefaultArgSpec(False, None)
    else:
        value = defaults[arg_index - args_with_no_defaults]
        if (type(value) is str):
            value = '"%s"' % value
        return DefaultArgSpec(True, value)

def get_method_sig(method):
    """ Given a function, it returns a string that pretty much looks how the
    function signature would be written in python.

    :param method: a python method
    :return: A string similar describing the pythong method signature.
    eg: "my_method(first_argArg, second_arg=42, third_arg='something')"
    """

    # The return value of ArgSpec is a bit weird, as the list of arguments and
    # list of defaults are returned in separate array.
    # eg: ArgSpec(args=['first_arg', 'second_arg', 'third_arg'],
    # varargs=None, keywords=None, defaults=(42, 'something'))
    argspec = inspect.getargspec(method)
    arg_index=0
    args = []

    # Use the args and defaults array returned by argspec and find out
    # which arguments has default
    for arg in argspec.args:
        default_arg = _get_default_arg(argspec.args, argspec.defaults, arg_index)
        if default_arg.has_default:
            args.append("%s=%s" % (arg, default_arg.default_value))
        else:
            args.append(arg)
        arg_index += 1
    return "%s(%s)" % (method.__name__, ", ".join(args))


if __name__ == '__main__':
    def my_method(first_arg, second_arg=42, third_arg='something'):
        pass

    print get_method_sig(my_method)
    # my_method(first_argArg, second_arg=42, third_arg="something")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try calling <code>help</code> on an object to find out about it.</p>
<pre><code>&gt;&gt;&gt; foo = [1, 2, 3]
&gt;&gt;&gt; help(foo.append)
Help on built-in function append:

append(...)
    L.append(object) -- append object to end
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe a bit late to the party, but if you also want to keep the order of the arguments <em>and their defaults</em>, then you can use the <a href="https://docs.python.org/2/library/ast.html" rel="noreferrer">Abstract Syntax Tree module (ast)</a>.</p>
<p>Here's a proof of concept (beware the code to sort the arguments and match them to their defaults can definitely be improved/made more clear):</p>
<pre><code>import ast

for class_ in [c for c in module.body if isinstance(c, ast.ClassDef)]:
    for method in [m for m in class_.body if isinstance(m, ast.FunctionDef)]:
        args = []
        if method.args.args:
            [args.append([a.col_offset, a.id]) for a in method.args.args]
        if method.args.defaults:
            [args.append([a.col_offset, '=' + a.id]) for a in method.args.defaults]
        sorted_args = sorted(args)
        for i, p in enumerate(sorted_args):
            if p[1].startswith('='):
                sorted_args[i-1][1] += p[1]
        sorted_args = [k[1] for k in sorted_args if not k[1].startswith('=')]

        if method.args.vararg:
            sorted_args.append('*' + method.args.vararg)
        if method.args.kwarg:
            sorted_args.append('**' + method.args.kwarg)

        signature = '(' + ', '.join(sorted_args) + ')'

        print method.name + signature
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If all you're trying to do is print the function then use pydoc.</p>
<pre><code>import pydoc    

def foo(arg1, arg2, *args, **kwargs):                                                                    
    '''Some foo fn'''                                                                                    
    pass                                                                                                 

&gt;&gt;&gt; print pydoc.render_doc(foo).splitlines()[2]
foo(arg1, arg2, *args, **kwargs)
</code></pre>
<p>If you're trying to actually analyze the function signature then use argspec of the inspection module. I had to do that when validating a user's hook script function into a general framework.</p>
</div>
<div class="post-text" itemprop="text">
<p>Example code:</p>
<pre><code>import inspect
from collections import OrderedDict


def get_signature(fn):
    params = inspect.signature(fn).parameters
    args = []
    kwargs = OrderedDict()
    for p in params.values():
        if p.default is p.empty:
            args.append(p.name)
        else:
            kwargs[p.name] = p.default
    return args, kwargs


def test_sig():
    def fn(a, b, c, d=3, e="abc"):
        pass

    assert get_signature(fn) == (
        ["a", "b", "c"], OrderedDict([("d", 3), ("e", "abc")])
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use %pdef in the command line (IPython), it will print only the signature.</p>
<p>e.g. <code>%pdef np.loadtxt</code></p>
<pre><code> np.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes')
</code></pre>
</div>
<span class="comment-copy">Can you please elaborate on your specific question and maybe give an example with the expected result?</span>
<span class="comment-copy">Presumably he's looking for functionality in Python or third-party libraries that will return a method's signature (names and types of parameters and return value) given the method's name.</span>
<span class="comment-copy">Signature as in how to call it and such?  Try <code>help(yourmethod)</code> e.g. <code>help(map)</code></span>
<span class="comment-copy">Just parameters: <a href="http://stackoverflow.com/questions/218616/getting-method-parameter-names-in-python" title="getting method parameter names in python">stackoverflow.com/questions/218616/â€¦</a></span>
<span class="comment-copy">AttributeError: 'module' object has no attribute 'getargspec'</span>
<span class="comment-copy">@Spi, you are calling <code>inspect.getargspec</code> on a module, not a function.</span>
<span class="comment-copy">Thanks, the problem was with Eclipse that did not see the inspect module</span>
<span class="comment-copy">If a function has argument annotations or keyword only arguments (= if you are using Python 3) you have to call <code>getfullargspec</code> instead. (<code>ValueError: Function has keyword-only arguments or annotations, use getfullargspec() API which can support them</code>)</span>
<span class="comment-copy">@darth_coder: In Python2, <code>getargspec</code> raises <code>TypeError</code> if the input is not recognized as a <i>Python</i> function -- that is, a function implemented in Python. In CPython, <code>Exception.__init__</code> is implemented in C, hence the <code>TypeError</code>. You'll have to check the source code to understand the call signature. In Python3, <code>getargspec</code> is implemented differently, and there <code>inspect.getargspec(Exception.__init__)</code> returns a <code>ArgSpec</code> instance.</span>
<span class="comment-copy">Perfect. All I really wanted was to dump out a human readable signature for a function.</span>
<span class="comment-copy"><code>inspect.signature</code> is also available for Python 2 via the <code>funcsigs</code> backport project: <a href="https://pypi.python.org/pypi/funcsigs" rel="nofollow noreferrer">pypi.python.org/pypi/funcsigs</a></span>
<span class="comment-copy">Any explanation at all as to what this is supposed to do?</span>
<span class="comment-copy">Added comments to the code sample, hope that helps.</span>
<span class="comment-copy">Thanks!  This is brilliant - I use it to generate documentation and it works perfectly</span>
<span class="comment-copy">Lovely stuff. Would be even better if you could adjust it to work with <code>def foo(a, *, b:int, **kwargs)</code> called with <code>foo(4, b=3.3)</code></span>
<span class="comment-copy">Note that <a href="https://stackoverflow.com/q/16932825/1143274">non-default arguments cannot follow default arguments</a>, so we can simply match them up from the tail?</span>
