<div class="post-text" itemprop="text">
<p>I am writing a program that categorizes a list of Python files by which modules they import. As such I need to scan the collection of .py files ad return a list of which modules they import. As an example, if one of the files I import has the following lines:</p>
<pre><code>import os
import sys, gtk
</code></pre>
<p>I would like it to return:</p>
<pre><code>["os", "sys", "gtk"]
</code></pre>
<p>I played with modulefinder and wrote:</p>
<pre><code>from modulefinder import ModuleFinder

finder = ModuleFinder()
finder.run_script('testscript.py')

print 'Loaded modules:'
for name, mod in finder.modules.iteritems():
    print '%s ' % name,
</code></pre>
<p>but this returns more than just the modules used in the script. As an example in a script which merely has:</p>
<pre><code>import os
print os.getenv('USERNAME')
</code></pre>
<p>The modules returned from the ModuleFinder script return:</p>
<pre><code>tokenize  heapq  __future__  copy_reg  sre_compile  _collections  cStringIO  _sre  functools  random  cPickle  __builtin__  subprocess  cmd  gc  __main__  operator  array  select  _heapq  _threading_local  abc  _bisect  posixpath  _random  os2emxpath  tempfile  errno  pprint  binascii  token  sre_constants  re  _abcoll  collections  ntpath  threading  opcode  _struct  _warnings  math  shlex  fcntl  genericpath  stat  string  warnings  UserDict  inspect  repr  struct  sys  pwd  imp  getopt  readline  copy  bdb  types  strop  _functools  keyword  thread  StringIO  bisect  pickle  signal  traceback  difflib  marshal  linecache  itertools  dummy_thread  posix  doctest  unittest  time  sre_parse  os  pdb  dis
</code></pre>
<p>...whereas I just want it to return 'os', as that was the module used in the script.</p>
<p>Can anyone help me achieve this?</p>
<p><strong>UPDATE</strong>: I just want to clarify that I would like to do this without running the Python file being analyzed, and just scanning the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>IMO the best way todo this is to use the <a href="http://furius.ca/snakefood/" rel="noreferrer">http://furius.ca/snakefood/</a> package.  The author has done all of the required work to get not only directly imported modules but it uses the AST to parse the code for runtime dependencies that a more static analysis would miss.</p>
<p>Worked up a command example to demonstrate:</p>
<pre><code>sfood ./example.py | sfood-cluster &gt; example.deps
</code></pre>
<p>That will generate a basic dependency file of each unique module.  For even more detail use:</p>
<pre><code>sfood -r -i ./example.py | sfood-cluster &gt; example.deps
</code></pre>
<p>To walk a tree and find all imports, you can also do this in code:
Please NOTE - The AST chunks of this routine were lifted from the snakefood source which has this copyright:  Copyright (C) 2001-2007 Martin Blais. All Rights Reserved.</p>
<pre><code> import os
 import compiler
 from compiler.ast import Discard, Const
 from compiler.visitor import ASTVisitor

 def pyfiles(startPath):
     r = []
     d = os.path.abspath(startPath)
     if os.path.exists(d) and os.path.isdir(d):
         for root, dirs, files in os.walk(d):
             for f in files:
                 n, ext = os.path.splitext(f)
                 if ext == '.py':
                     r.append([d, f])
     return r

 class ImportVisitor(object):
     def __init__(self):
         self.modules = []
         self.recent = []
     def visitImport(self, node):
         self.accept_imports()
         self.recent.extend((x[0], None, x[1] or x[0], node.lineno, 0)
                            for x in node.names)
     def visitFrom(self, node):
         self.accept_imports()
         modname = node.modname
         if modname == '__future__':
             return # Ignore these.
         for name, as_ in node.names:
             if name == '*':
                 # We really don't know...
                 mod = (modname, None, None, node.lineno, node.level)
             else:
                 mod = (modname, name, as_ or name, node.lineno, node.level)
             self.recent.append(mod)
     def default(self, node):
         pragma = None
         if self.recent:
             if isinstance(node, Discard):
                 children = node.getChildren()
                 if len(children) == 1 and isinstance(children[0], Const):
                     const_node = children[0]
                     pragma = const_node.value
         self.accept_imports(pragma)
     def accept_imports(self, pragma=None):
         self.modules.extend((m, r, l, n, lvl, pragma)
                             for (m, r, l, n, lvl) in self.recent)
         self.recent = []
     def finalize(self):
         self.accept_imports()
         return self.modules

 class ImportWalker(ASTVisitor):
     def __init__(self, visitor):
         ASTVisitor.__init__(self)
         self._visitor = visitor
     def default(self, node, *args):
         self._visitor.default(node)
         ASTVisitor.default(self, node, *args) 

 def parse_python_source(fn):
     contents = open(fn, 'rU').read()
     ast = compiler.parse(contents)
     vis = ImportVisitor() 

     compiler.walk(ast, vis, ImportWalker(vis))
     return vis.finalize()

 for d, f in pyfiles('/Users/bear/temp/foobar'):
     print d, f
     print parse_python_source(os.path.join(d, f)) 
</code></pre>
<p></p>
</div>
<div class="post-text" itemprop="text">
<p>It depends how thorough you want to be. Used modules is a turing complete problem: some python code uses lazy importing to only import things they actually use on a particular run, some generate things to import dynamically (e.g. plugin systems).</p>
<p>python -v will trace import statements - its arguably the simplest thing to check.</p>
</div>
<div class="post-text" itemprop="text">
<p>You might want to try <a href="https://docs.python.org/3/library/dis.html" rel="nofollow">dis</a> (pun intended): </p>
<pre><code>import dis
from collections import defaultdict
from pprint import pprint

statements = """
from __future__ import (absolute_import,
                        division)
import os
import collections, itertools
from math import *
from gzip import open as gzip_open
from subprocess import check_output, Popen
"""

instructions = dis.get_instructions(statements)
imports = [__ for __ in instructions if 'IMPORT' in __.opname]

grouped = defaultdict(list)
for instr in imports:
    grouped[instr.opname].append(instr.argval)

pprint(grouped)
</code></pre>
<p>outputs</p>
<pre><code>defaultdict(&lt;class 'list'&gt;,
            {'IMPORT_FROM': ['absolute_import',
                             'division',
                             'open',
                             'check_output',
                             'Popen'],
             'IMPORT_NAME': ['__future__',
                             'os',
                             'collections',
                             'itertools',
                             'math',
                             'gzip',
                             'subprocess'],
             'IMPORT_STAR': [None]})
</code></pre>
<p>Your imported modules are <code>grouped['IMPORT_NAME']</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, you could always write a simple script that searches the file for <code>import</code> statements. This one finds all imported modules and files, including those imported in functions or classes:</p>
<pre><code>def find_imports(toCheck):
    """
    Given a filename, returns a list of modules imported by the program.
    Only modules that can be imported from the current directory
    will be included. This program does not run the code, so import statements
    in if/else or try/except blocks will always be included.
    """
    import imp
    importedItems = []
    with open(toCheck, 'r') as pyFile:
        for line in pyFile:
            # ignore comments
            line = line.strip().partition("#")[0].partition("as")[0].split(' ')
            if line[0] == "import":
                for imported in line[1:]:
                    # remove commas (this doesn't check for commas if
                    # they're supposed to be there!
                    imported = imported.strip(", ")
                    try:
                        # check to see if the module can be imported
                        # (doesn't actually import - just finds it if it exists)
                        imp.find_module(imported)
                        # add to the list of items we imported
                        importedItems.append(imported)
                    except ImportError:
                        # ignore items that can't be imported
                        # (unless that isn't what you want?)
                        pass

    return importedItems

toCheck = raw_input("Which file should be checked: ")
print find_imports(toCheck)
</code></pre>
<p>This doesn't do anything for <code>from module import something</code> style imports, though that could easily be added, depending on how you want to deal with those. It also doesn't do any syntax checking, so if you have some funny business like <code>import sys gtk, os</code> it will think you've imported all three modules even though the line is an error. It also doesn't deal with <code>try</code>/<code>except</code> type statements with regards to import - if it could be imported, this function will list it. It also doesn't deal well with multiple imports per line if you use the <code>as</code> keyword. The real issue here is that I'd have to write a full parser to really do this correctly. The given code works in many cases, as long as you understand there are definite corner cases.</p>
<p>One issue is that relative imports will fail if this script isn't in the same directory as the given file. You may want to add the directory of the given script to <code>sys.path</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works - using importlib to actually import the module, and inspect to get the members :</p>
<pre><code>#! /usr/bin/env python
#
# test.py  
#
# Find Modules
#
import inspect, importlib as implib

if __name__ == "__main__":
    mod = implib.import_module( "example" )
    for i in inspect.getmembers(mod, inspect.ismodule ):
        print i[0]

#! /usr/bin/env python
#
# example.py
#
import sys 
from os import path

if __name__ == "__main__":
    print "Hello World !!!!"
</code></pre>
<p>Output : </p>
<pre><code>tony@laptop .../~:$ ./test.py
path
sys
</code></pre>
<p></p>
</div>
<div class="post-text" itemprop="text">
<p>I understand that this post is VERY old but I have found an ideal solution.
I came up with this idea:</p>
<pre><code>def find_modules(code):
    modules = []
    code = code.splitlines()
    for item in code:
        if item[:7] == "import " and ", " not in item:
            if " as " in item:
                modules.append(item[7:item.find(" as ")])
            else:
                modules.append(item[7:])
        elif item[:5] == "from ":
            modules.append(item[5:item.find(" import ")])

        elif ", " in item:
            item = item[7:].split(", ")
            modules = modules+item

        else:
            print(item)
    return modules

code = """
import foo
import bar
from baz import eggs
import mymodule as test
import hello, there, stack
"""
print(find_modules(code))
</code></pre>
<p>it does from, as, commas and normal import statements.
it requires no dependencies and works with other lines of code.</p>
<p>The above code prints:</p>
<pre><code>['foo', 'bar', 'baz', 'mymodule', 'hello', 'there', 'stack']
</code></pre>
<p>Just put your code in the find_modules function.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the majority of scripts which only import modules at the top level, it is quite sufficient to load the file as a module, and scan its members for modules:</p>
<pre><code>import sys,io,imp,types
scriptname = 'myfile.py'
with io.open(scriptname) as scriptfile:
    code = compile(scriptfile.readall(),scriptname,'exec')
newmodule = imp.new_module('__main__')
exec(codeobj,newmodule.__dict__)
scriptmodules = [name for name in dir(newmodule) if isinstance(newmodule.__dict__[name],types.ModuleType)]
</code></pre>
<p>This simulates the module being run as a script, by setting the module's name to <code>'__main__'</code>. It should therefore also capture funky dynamic module loading. The only modules it won't capture are those which are imported only into local scopes.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was looking for something similar and I found a gem in a package called <a href="https://pypi.python.org/pypi/PyScons" rel="nofollow">PyScons</a>. The Scanner does just what you want (in 7 lines), using an import_hook. Here is an abbreviated example:</p>
<pre><code>import modulefinder, sys

class SingleFileModuleFinder(modulefinder.ModuleFinder):

    def import_hook(self, name, caller, *arg, **kwarg):
        if caller.__file__ == self.name:
            # Only call the parent at the top level.
            return modulefinder.ModuleFinder.import_hook(self, name, caller, *arg, **kwarg)

    def __call__(self, node):

        self.name = str(node)

        self.run_script(self.name)

if __name__ == '__main__':
    # Example entry, run with './script.py filename'
    print 'looking for includes in %s' % sys.argv[1]

    mf = SingleFileModuleFinder()
    mf(sys.argv[1])

    print '\n'.join(mf.modules.keys())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's actually working quite good with</p>
<pre><code>print [key for key in locals().keys()
   if isinstance(locals()[key], type(sys)) and not key.startswith('__')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks Tony Suffolk for inspect, importlib samples ... I built this wee module and you're all welcome to use it if it helps you.  Giving back, yaaaay!</p>
<pre><code>import timeit
import os
import inspect, importlib as implib
import textwrap as twrap

def src_modules(filename):
    assert (len(filename)&gt;1)

    mod = implib.import_module(filename.split(".")[0])
    ml_alias = []
    ml_actual = []
    ml_together = []
    ml_final = []
    for i in inspect.getmembers(mod, inspect.ismodule):
        ml_alias.append(i[0])
        ml_actual.append((str(i[1]).split(" ")[1]))
        ml_together = zip(ml_actual, ml_alias)
    for t in ml_together:
        (a,b) = t
        ml_final.append(a+":="+b)

    return ml_final

def l_to_str(itr):
    assert(len(itr)&gt;0)

    itr.sort()
    r_str = ""
    for i in itr:
        r_str += i+"  "
    return r_str

def src_info(filename, start_time=timeit.default_timer()):
    assert (len(filename)&gt;1)

    filename_in = filename
    filename = filename_in.split(".")[0]

    if __name__ == filename:
        output_module = filename
    else:
        output_module = __name__

    print ("\n" + (80 * "#"))
    print (" runtime ~= {0} ms".format(round(((timeit.default_timer() - start_time)*1000),3)))
    print (" source file --&gt; '{0}'".format(filename_in))
    print (" output via --&gt; '{0}'".format(output_module))
    print (" modules used in '{0}':".format(filename))
    print ("  "+"\n  ".join(twrap.wrap(l_to_str(src_modules(filename)), 75)))
    print (80 * "#")

    return ""


if __name__ == "__main__":
    src_info(os.path.basename(__file__))


## how to use in X file:
#
# import print_src_info
# import os
#
# &lt; ... your code ... &gt;
#
# if __name__ == "__main__":
#     print_src_info.src_info(os.path.basename(__file__))


## example output:
#
# ################################################################################
#  runtime ~= 0.049 ms
#  source file --&gt; 'print_src_info.py'
#  output via --&gt; '__main__'
#  modules used in 'print_src_info':
#   'importlib':=implib  'inspect':=inspect  'os':=os  'textwrap':=twrap
#   'timeit':=timeit
# ################################################################################
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know this is old but I was also looking for such a solution like OP did.
So I wrote this code to find imported modules by scripts in a folder.
It works with <code>import abc</code> and <code>from abc import cde</code> format. I hope it helps someone else.</p>
<pre><code>import re
import os


def get_imported_modules(folder):
    files = [f for f in os.listdir(folder) if f.endswith(".py")]

    imports = []
    for file in files:
        with open(os.path.join(folder, file), mode="r") as f:
            lines = f.read()
            result = re.findall(r"(?&lt;!from)import (\w+)[\n.]|from\s+(\w+)\s+import", lines)
            for imp in result:
                for i in imp:
                    if len(i):
                        if i not in imports:
                            imports.append(i)

    return imports
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm editing my original answer to say this. This is doable with a code snippet like the one below, but parsing the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow">AST</a> may be the best way to go.</p>
<pre><code>def iter_imports(fd):
    """ Yield only lines that appear to be imports from an iterable.
        fd can be an open file, a list of lines, etc.
    """
    for line in fd:
        trimmed = line.strip()
        if trimmed.startswith('import '):
            yield trimmed
        elif trimmed.startswith('from ') and ('import ' in trimmed):
            yield trimmed

def main():
    # File name to read.
    filename = '/my/path/myfile.py'
    # Safely open the file, exit on error
    try:
        with open(filename) as f:
            # Iterate over the lines in this file, and generate a list of
            # lines that appear to be imports.
            import_lines = list(iter_imports(f))
    except (IOError, OSError) as exIO:
        print('Error opening file: {}\n{}'.format(filename, exIO))
        return 1
    else:
        # From here, import_lines should be a list of lines like this:
        #     from module import thing
        #     import os, sys
        #     from module import *
        # Do whatever you need to do with the import lines.
        print('\n'.join(import_lines))

    return 0

if __name__ == '__main__':
    sys.exit(main())
</code></pre>
<p>Further string parsing will be needed to grab just the module names. This does not catch cases where multi-line strings or doc strings contain the words 'import ' or 'from X import '. This is why I suggested parsing the AST.</p>
</div>
<span class="comment-copy">are any of those extra modules ever added manually with import statements? If not, could you not just make an empty module, run your module finder on that, and use the results by removing those modules from the result of every other module? ie. <code>modulefinder(some_module) - modulefinder(empty_module)</code>?</span>
<span class="comment-copy">This seems to be a third party tool for generated graphs, but not something I can use in my code other than using it with subprocess. Is this what you recommend?</span>
<span class="comment-copy">ah - your looking for something really basic to include - let me chew on that</span>
<span class="comment-copy">of course it would help if <i>run</i> my samples - working on an actual working version :/</span>
<span class="comment-copy">ok, modified my example to use the AST walking code from snakefood and wrapped it in some basic file walking code</span>
<span class="comment-copy">The current code works if and only if all *.py files are in the current directory.  If the pyfiles() function walks to a subdirectory it erroneously combines the file name with the directory where the walk started, leaving out all intermediate directory levels.  You can fix this by replacing one line: what is currently r.append([d, f]) should be r.append([root, f]). Cheers --</span>
<span class="comment-copy">I just tried this script; it found 9 of 27 import statements in an app.  That's not going to work.</span>
<span class="comment-copy">@Chelonian Could you be more specific here? you simply say "it doesn't work". What's so special about the imports the program doesn't find?</span>
<span class="comment-copy">@dm76 - I think your code only look for 'import' commands - and therefore misses 'from &lt;package&gt; import &lt;resource&gt;' commands - using inspect is the python way I think ...</span>
<span class="comment-copy">I get an error(<code>code = compile(scriptfile.readall(),scriptname,'exec') AttributeError: 'TextIOWrapper' object has no attribute 'readall'</code>) Changing <code>io.open</code> by <code>io.FileIO</code> solves but it can't open the user-defined modules...</span>
<span class="comment-copy">This fails to find any modules imported with the "from foo import bar" syntax.</span>
<span class="comment-copy">Can you provide some of the code in your answer?</span>
<span class="comment-copy">wow, stackoverflow murdered that code. What did I do wrong? Anyway it takes a little more than that but if you were only looking for imports the script would be small compared to what codecounter is right now.</span>
<span class="comment-copy">Edit the answer rather than adding the code as a comment and it will look fine.</span>
<span class="comment-copy">thanks, i updated the answer to reflect what I was trying to say in the previous comment (now deleted).</span>
