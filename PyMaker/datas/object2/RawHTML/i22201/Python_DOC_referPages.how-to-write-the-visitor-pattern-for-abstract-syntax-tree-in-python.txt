<div class="post-text" itemprop="text">
<p>My collegue suggested me to write a visitor pattern to navigate the AST. Can anyone tell me more how would I start writing it?</p>
<p>As far as I understand, each Node in AST would have <code>visit()</code> method (?) that would somehow get called (from where?). That about concludes my understanding.</p>
<p>To simplify everything, suppose I have nodes <code>Root</code>, <code>Expression</code>, <code>Number</code>, <code>Op</code> and the tree looks like this:</p>
<pre><code>       Root
        |
       Op(+)
      /   \
     /     \
 Number(5)  \
             Op(*)
             /   \
            /     \
           /       \
       Number(2)   Number(444)
</code></pre>
<p>Can anyone think of how the visitor pattern would visit this tree to produce output:</p>
<pre><code> 5 + 2 * 444
</code></pre>
<p>Thanks, Boda Cydo.</p>
</div>
<div class="post-text" itemprop="text">
<p>Wikipedia has a great overview of <a href="http://en.wikipedia.org/wiki/Visitor_pattern#Example" rel="noreferrer">how the Visitor pattern works</a>, although the sample implementation that they use is in Java. You can easily port that to Python, though, no?</p>
<p>Basically, you want to implement a mechanism for <a href="http://en.wikipedia.org/wiki/Double_dispatch" rel="noreferrer">double dispatch</a>. Each node in your AST would need to implement an <code>accept()</code> method (NOT a <code>visit()</code> method). The method takes, as an argument, a visitor object. In the implementation of this <code>accept()</code> method, you call a <code>visit()</code> method of the visitor object (there will be one for each AST node type; in Java, you'll use parameter overloading, in Python I suppose you can use different <code>visit_*()</code> methods). The correct visitor will then be dispatched with the correct Node type as argument.</p>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="http://docs.python.org/library/ast.html?highlight=ast#ast.NodeVisitor" rel="noreferrer">the docs</a> for <code>ast.NodeVisitor</code>, e.g. a crude possibility might be:</p>
<pre><code>import ast

class MyVisitor(ast.NodeVisitor):
  def visit_BinaryOp(self, node):
    self.visit(node.left)
    print node.op,
    self.visit(node.right)
  def visit_Num(self, node):
    print node.n,
</code></pre>
<p>of course this doesn't emit parentheses even where needed, etc, so there's actually more work done, but, it's a start;-).</p>
</div>
<div class="post-text" itemprop="text">
<p>The two variants to implement the Visitor pattern in Python that I encountered on the Internet most often:</p>
<ul>
<li>One-to-one translation of the example from the Desigh Patterns book by Gamma et al.</li>
<li>Using additional modules for double-dispatch</li>
</ul>
<h2>Translated Example from the Desigh Patterns Book</h2>
<p>This variant uses <code>accept()</code> methods in the data structure classes and corresponding <code>visit_Type()</code> methods in the visitors.</p>
<p><strong>The data structure</strong></p>
<pre><code>class Operation(object):
    def __init__(self, op, arg1, arg2):
        self.op = op
        self.arg1 = arg1
        self.arg2 = arg2
    def accept(self, visitor):
        visitor.visitOperation(self)

class Integer(object):
    def __init__(self, num):
        self.num = num
    def accept(self, visitor):
        visitor.visitInteger(self)

class Float(object):
    def __init__(self, num):
        self.num = num
    def accept(self, visitor):
        visitor.visitFloat(self)

expression = Operation('+', Integer('5'),
                            Operation('*', Integer('2'), Float('444.1')))
</code></pre>
<p><strong>Infix Print Visitor</strong></p>
<pre><code>class InfixPrintVisitor(object):
    def __init__(self):
        self.expression_string = ''
    def visitOperation(self, operation):
        operation.arg1.accept(self)
        self.expression_string += ' ' + operation.op + ' '
        operation.arg2.accept(self)
    def visitInteger(self, number):
        self.expression_string += number.num
    def visitFloat(self, number):
        self.expression_string += number.num
</code></pre>
<p><strong>Prefix Print Visitor</strong></p>
<pre><code>class PrefixPrintVisitor(object):
    def __init__(self):
        self.expression_string = ''
    def visitOperation(self, operation):
        self.expression_string  += operation.op + ' '
        operation.arg1.accept(self)
        self.expression_string  += ' '
        operation.arg2.accept(self)
    def visitInteger(self, number):
        self.expression_string += number.num
    def visitFloat(self, number):
        self.expression_string += number.num
</code></pre>
<p><strong>Test</strong></p>
<pre><code>infixPrintVisitor = InfixPrintVisitor()
expression.accept(infixPrintVisitor)
print(infixPrintVisitor.expression_string)
prefixPrintVisitor = PrefixPrintVisitor()
expression.accept(prefixPrintVisitor)
print(prefixPrintVisitor.expression_string)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>5 + 2 * 444.1
+ 5 * 2 444.1
</code></pre>
<h2>Using additional modules</h2>
<p>This variant uses <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>@functools.singledispatch()</code></a> decorator (available in the Python Standard Library since Python v3.4).</p>
<p><strong>The data structure</strong></p>
<pre><code>class Operation(object):
    def __init__(self, op, arg1, arg2):
        self.op = op
        self.arg1 = arg1
        self.arg2 = arg2

class Integer(object):
    def __init__(self, num):
        self.num = num

class Float(object):
    def __init__(self, num):
        self.num = num

expression = Operation('+', Integer('5'), 
                            Operation('*', Integer('2'), Float('444.1')))
</code></pre>
<p><strong>Infix Print Visitor</strong></p>
<pre><code>from functools import singledispatch

@singledispatch
def visitor_print_infix(obj):
    pass
@visitor_print_infix.register(Operation)
def __(operation):
    return visitor_print_infix(operation.arg1) + ' ' \
               + operation.op + ' ' \
               + visitor_print_infix(operation.arg2)
@visitor_print_infix.register(Integer)
@visitor_print_infix.register(Float)
def __(number):
    return number.num
</code></pre>
<p><strong>Prefix Print Visitor</strong></p>
<pre><code>from functools import singledispatch

@singledispatch
def visitor_print_prefix(obj):
    pass
@visitor_print_prefix.register(Operation)
def __(operation):
    return operation.op + ' ' \
               + visitor_print_prefix(operation.arg1) + ' ' \
               + visitor_print_prefix(operation.arg2)
@visitor_print_prefix.register(Integer)
@visitor_print_prefix.register(Float)
def __(number):
    return number.num
</code></pre>
<p><strong>Test</strong></p>
<pre><code>print(visitor_print_infix(expression))
print(visitor_print_prefix(expression))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>5 + 2 * 444.1
+ 5 * 2 444.1
</code></pre>
<p>The reason I prefer this variant is that it eliminates the <code>accept()</code> methods and completely separates the data structure from the operations implemented in the visitors. Extending the data structure with new elements does not require changing the visitors. The visitors ignore the unknown element types by default (see the definitions with the <code>pass</code> keyword). A drawback of this method is that <code>singledispatch</code> decorator cannot be used with instance methods directly, although, <a href="https://stackoverflow.com/questions/24601722/how-can-i-use-functools-singledispatch-with-instance-methods">there are ways to make it work</a>.</p>
<p>For Python before v3.4 <a href="https://pypi.python.org/pypi/multimethods" rel="nofollow noreferrer">multimethods</a> module can be used similar to the singledispatch decorator. One drawback of the multimethods module is that the visitor method that is applied to a given data-structure element is selected not only based on the element's type but also on the order in which the methods are declared. Keeping the method definitions in the right order can be cumbersome and error prone for data structures with a complex inheritance hierarchy.</p>
</div>
<span class="comment-copy">Added python tag</span>
