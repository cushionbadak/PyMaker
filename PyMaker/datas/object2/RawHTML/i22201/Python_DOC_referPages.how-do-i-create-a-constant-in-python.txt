<div class="post-text" itemprop="text">
<p>Is there a way to declare a constant in Python? In Java we can create constant values in this manner:</p>
<pre class="lang-java prettyprint-override"><code>public static final String CONST_NAME = "Name";
</code></pre>
<p>What is the equivalent of the above Java constant declaration in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>No there is not. You cannot declare a variable or value as constant in Python. Just don't change it.</p>
<p>If you are in a class, the equivalent would be:</p>
<pre><code>class Foo(object):
    CONST_NAME = "Name"
</code></pre>
<p>if not, it is just</p>
<pre><code>CONST_NAME = "Name"
</code></pre>
<p>But you might want to have a look at the code snippet <a href="http://code.activestate.com/recipes/65207-constants-in-python/?in=user-97991" rel="noreferrer">Constants in Python</a> by Alex Martelli.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no <code>const</code> keyword as in other languages, however it is possible to create a Property that <strong>has a "getter function"</strong> to read the data, but <strong>no "setter function"</strong> to re-write the data. <strong>This essentially protects the identifier from being changed.</strong></p>
<p>Here is an alternative implementation using class property:</p>
<p><em>Note that the code is far from easy for a reader wondering about constants. See explanation below</em></p>
<pre><code>def constant(f):
    def fset(self, value):
        raise TypeError
    def fget(self):
        return f()
    return property(fget, fset)

class _Const(object):
    @constant
    def FOO():
        return 0xBAADFACE
    @constant
    def BAR():
        return 0xDEADBEEF

CONST = _Const()

print CONST.FOO
##3131964110

CONST.FOO = 0
##Traceback (most recent call last):
##    ...
##    CONST.FOO = 0
##TypeError: None
</code></pre>
<p><strong>Code Explanation:</strong></p>
<ol>
<li>Define a function <code>constant</code> that takes an expression, and uses it to construct a "getter" - a function that solely returns the value of the expression.</li>
<li>The setter function raises a TypeError so it's read-only</li>
<li>Use the <code>constant</code> function we just created as a decoration to quickly define read-only properties.</li>
</ol>
<hr/>
<p>And in some other more old-fashioned way:</p>
<p><em>(The code is quite tricky, more explanations below)</em></p>
<pre><code>class _Const(object):
    @apply
    def FOO():
        def fset(self, value):
            raise TypeError
        def fget(self):
            return 0xBAADFACE
        return property(**locals())

CONST = _Const()

print CONST.FOO
##3131964110

CONST.FOO = 0
##Traceback (most recent call last):
##    ...
##    CONST.FOO = 0
##TypeError: None
</code></pre>
<p><em>Note that the @apply decorator seems to be deprecated.</em></p>
<ol>
<li>To define the identifier FOO, firs define two functions (fset, fget - the names are at my choice).</li>
<li>Then use the built-in <code>property</code> function to construct an object that can be "set" or "get".</li>
<li>Note hat the <code>property</code> function's first two parameters are named <code>fset</code> and <code>fget</code>. </li>
<li>Use the fact that we chose these very names for our own getter &amp; setter and create a keyword-dictionary using the ** (double asterisk) applied to all the local definitions of that scope to pass parameters to the <code>property</code> function</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>In Python instead of language enforcing something, people use naming conventions e.g <code>__method</code> for private methods and using <code>_method</code> for protected methods.</p>
<p>So in same manner you can simply declare the constant as all caps e.g.</p>
<pre><code>MY_CONSTANT = "one"
</code></pre>
<p>If you want that this constant never changes, you can hook into attribute access and do tricks, but a simpler approach is to declare a function</p>
<pre><code>def MY_CONSTANT():
    return "one"
</code></pre>
<p>Only problem is everywhere you will have to do MY_CONSTANT(), but again <code>MY_CONSTANT = "one"</code> is the correct way in python(usually).</p>
<p>You can also use <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="noreferrer">namedtuple</a> to create constants:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Constants = namedtuple('Constants', ['pi', 'e'])
&gt;&gt;&gt; constants = Constants(3.14, 2.718)
&gt;&gt;&gt; constants.pi
3.14
&gt;&gt;&gt; constants.pi = 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've recently found a very succinct update to this which automatically raises meaningful error messages and prevents access via <code>__dict__</code>:</p>
<pre><code>class CONST(object):
    __slots__ = ()
    FOO = 1234

CONST = CONST()

# ----------

print(CONST.FOO)    # 1234

CONST.FOO = 4321              # AttributeError: 'CONST' object attribute 'FOO' is read-only
CONST.__dict__['FOO'] = 4321  # AttributeError: 'CONST' object has no attribute '__dict__'
CONST.BAR = 5678              # AttributeError: 'CONST' object has no attribute 'BAR'
</code></pre>
<p>We define over ourselves as to make ourselves an instance and then use slots to ensure that no additional attributes can be added. This also removes the <code>__dict__</code> access route. Of course, the whole object can still be redefined.</p>
<p><strong>Edit - Original solution</strong></p>
<p>I'm probably missing a trick here, but this seems to work for me:</p>
<pre><code>class CONST(object):
    FOO = 1234

    def __setattr__(self, *_):
        pass

CONST = CONST()

#----------

print CONST.FOO    # 1234

CONST.FOO = 4321
CONST.BAR = 5678

print CONST.FOO    # Still 1234!
print CONST.BAR    # Oops AttributeError
</code></pre>
<p>Creating the instance allows the magic <code>__setattr__</code> method to kick in and intercept attempts to set the <code>FOO</code> variable. You could throw an exception here if you wanted to. Instantiating the instance over the class name prevents access directly via the class.</p>
<p>It's a total pain for one value, but you could attach lots to your <code>CONST</code> object. Having an upper class, class name also seems a bit grotty, but I think it's quite succinct overall.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you probably already know, Python doesn't have constants :(</p>
<p>Perhaps the easiest alternative is to define a function for it. E.g.
</p>
<pre><code>def MY_CONSTANT():
    return 42
</code></pre>
<p><code>MY_CONSTANT()</code> now has all the functionality of a constant (plus some annoying braces).</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the two top answers (just use variables with UPPERCASE names, or use properties to make the values read-only), I want to mention that it's possible to use metaclasses in order to implement <em>named</em> constants.  I provide a very simple solution using metaclasses at <a href="https://github.com/hmeine/named_constants">GitHub</a> which may be helpful if you want the values to be more informative about their type/name:</p>
<pre><code>&gt;&gt;&gt; from named_constants import Constants
&gt;&gt;&gt; class Colors(Constants):
...     black = 0
...     red = 1
...     white = 15
...
&gt;&gt;&gt; c = Colors.black
&gt;&gt;&gt; c == 0
True
&gt;&gt;&gt; c
Colors.black
&gt;&gt;&gt; c.name()
'black'
&gt;&gt;&gt; Colors(0) is c
True
</code></pre>
<p>This is slightly more advanced Python, but still very easy to use and handy.  (The module has some more features, including constants being read-only, see its README.)</p>
<p>There are similar solutions floating around in various repositories, but to the best of my knowledge they either lack one of the fundamental features that I would expect from constants (like being constant, or being of arbitrary type), or they have esoteric features added that make them less generally applicable.  But YMMV, I would be grateful for feedback. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Edit: Added sample code for Python 3</p>
<p>Note: <a href="https://stackoverflow.com/a/19306516/1858091">this other answer</a> looks like it provides a much more complete implementation similar to the following (with more features).</p>
<p>First, make a <a href="https://stackoverflow.com/a/100146/1858091">metaclass</a>:</p>
<pre class="lang-py prettyprint-override"><code>class MetaConst(type):
    def __getattr__(cls, key):
        return cls[key]

    def __setattr__(cls, key, value):
        raise TypeError
</code></pre>
<p>This prevents statics properties from being changed. Then make another class that uses that metaclass:</p>
<pre class="lang-py prettyprint-override"><code>class Const(object):
    __metaclass__ = MetaConst

    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        raise TypeError
</code></pre>
<p>Or, if you're using Python 3:</p>
<pre class="lang-py prettyprint-override"><code>class Const(object, metaclass=MetaConst):
    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        raise TypeError
</code></pre>
<p>This should prevent instance props from being changed. To use it, inherit:</p>
<pre class="lang-py prettyprint-override"><code>class MyConst(Const):
    A = 1
    B = 2
</code></pre>
<p>Now the props, accessed directly or via an instance, should be constant:</p>
<pre class="lang-py prettyprint-override"><code>MyConst.A
# 1
my_const = MyConst()
my_const.A
# 1

MyConst.A = 'changed'
# TypeError
my_const.A = 'changed'
# TypeError
</code></pre>
<p><a href="https://repl.it/BMwL" rel="noreferrer">Here's</a> an example of above in action. <a href="https://repl.it/BMwR" rel="noreferrer">Here's</a> another example for Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Properties are one way to create constants. You can do it by declaring a getter property, but ignoring the setter. For example:</p>
<pre><code>class MyFinalProperty(object):

    @property
    def name(self):
        return "John"
</code></pre>
<p>You can have a look at <a href="http://www.navedali.com/technology/python/property-in-python" rel="noreferrer">an article I've written</a> to find more ways to use Python properties.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an implementation of a "Constants" class, which creates instances with read-only (constant) attributes. E.g. can use <code>Nums.PI</code> to get a value that has been initialized as <code>3.14159</code>, and <code>Nums.PI = 22</code> raises an exception.</p>
<pre><code># ---------- Constants.py ----------
class Constants(object):
    """
    Create objects with read-only (constant) attributes.
    Example:
        Nums = Constants(ONE=1, PI=3.14159, DefaultWidth=100.0)
        print 10 + Nums.PI
        print '----- Following line is deliberate ValueError -----'
        Nums.PI = 22
    """

    def __init__(self, *args, **kwargs):
        self._d = dict(*args, **kwargs)

    def __iter__(self):
        return iter(self._d)

    def __len__(self):
        return len(self._d)

    # NOTE: This is only called if self lacks the attribute.
    # So it does not interfere with get of 'self._d', etc.
    def __getattr__(self, name):
        return self._d[name]

    # ASSUMES '_..' attribute is OK to set. Need this to initialize 'self._d', etc.
    #If use as keys, they won't be constant.
    def __setattr__(self, name, value):
        if (name[0] == '_'):
            super(Constants, self).__setattr__(name, value)
        else:
            raise ValueError("setattr while locked", self)

if (__name__ == "__main__"):
    # Usage example.
    Nums = Constants(ONE=1, PI=3.14159, DefaultWidth=100.0)
    print 10 + Nums.PI
    print '----- Following line is deliberate ValueError -----'
    Nums.PI = 22
</code></pre>
<p>Thanks to <a href="https://stackoverflow.com/a/2704866/199364">@MikeGraham 's FrozenDict</a>, which I used as a starting point. Changed, so instead of <code>Nums['ONE']</code> the usage syntax is <code>Nums.ONE</code>.</p>
<p>And thanks to @Raufio's answer, for idea to override __ setattr __.</p>
<p>Or for an implementation with more functionality, see @Hans_meine 's
<a href="https://github.com/hmeine/named_constants" rel="noreferrer">named_constants at GitHub</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would make a class that overrides the <code>__setattr__</code> method of the base object class and wrap my constants with that, note that I'm using python 2.7:</p>
<pre><code>class const(object):
    def __init__(self, val):
        super(const, self).__setattr__("value", val)
    def __setattr__(self, name, val):
        raise ValueError("Trying to change a constant value", self)
</code></pre>
<p>To wrap a string:</p>
<pre><code>&gt;&gt;&gt; constObj = const("Try to change me")
&gt;&gt;&gt; constObj.value
'Try to change me'
&gt;&gt;&gt; constObj.value = "Changed"
Traceback (most recent call last):
   ...
ValueError: Trying to change a constant value
&gt;&gt;&gt; constObj2 = const(" or not")
&gt;&gt;&gt; mutableObj = constObj.value + constObj2.value
&gt;&gt;&gt; mutableObj #just a string
'Try to change me or not'
</code></pre>
<p>It's pretty simple, but if you want to use your constants the same as you would a non-constant object (without using constObj.value), it will be a bit more intensive. It's possible that this could cause problems, so it might be best to keep the <code>.value</code> to show and know that you are doing operations with constants (maybe not the most 'pythonic' way though).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a namedtuple as a workaround to effectively create a constant that works the same way as a static final variable in Java (a Java "constant"). As workarounds go, it's sort of elegant. (A more elegant approach would be to simply improve the Python language --- what sort of language lets you redefine <code>math.pi</code>? -- but I digress.)</p>
<p>(As I write this, I realize another answer to this question mentioned namedtuple, but I'll continue here because I'll show a syntax that more closely parallels what you'd expect in Java, as there is no need to create a named <em>type</em> as namedtuple forces you to do.)</p>
<p>Following your example, you'll remember that in Java we must define the constant <em>inside some class</em>; because you didn't mention a class name, let's call it <code>Foo</code>. Here's the Java class:</p>
<pre><code>public class Foo {
  public static final String CONST_NAME = "Name";
}
</code></pre>
<p>Here's the equivalent Python.</p>
<pre><code>from collections import namedtuple
Foo = namedtuple('_Foo', 'CONST_NAME')('Name')
</code></pre>
<p>The key point I want to add here is that you don't need a separate <code>Foo</code> type (an "anonymous named tuple" would be nice, even though that sounds like an oxymoron), so we name our namedtuple <code>_Foo</code> so that hopefully it won't escape to importing modules.</p>
<p>The second point here is that we <em>immediately create an instance</em> of the nametuple, calling it <code>Foo</code>; there's no need to do this in a separate step (unless you want to). Now you can do what you can do in Java:</p>
<pre><code>&gt;&gt;&gt; Foo.CONST_NAME
'Name'
</code></pre>
<p>But you can't assign to it:</p>
<pre><code>&gt;&gt;&gt; Foo.CONST_NAME = 'bar'
…
AttributeError: can't set attribute
</code></pre>
<p>Acknowledgement: I thought I invented the namedtuple approach, but then I see that someone else gave a similar (although less compact) answer. Then I also noticed <a href="https://stackoverflow.com/q/2970608/421049">What are "named tuples" in Python?</a>, which points out that <a href="https://docs.python.org/3/library/sys.html#sys.version_info" rel="nofollow noreferrer"><code>sys.version_info</code></a> is now a namedtuple, so perhaps the Python standard library already came up with this idea much earlier.</p>
<p>Note that unfortunately (this still being Python), you can erase the entire <code>Foo</code> assignment altogether:</p>
<pre><code>&gt;&gt;&gt; Foo = 'bar'
</code></pre>
<p>(facepalm)</p>
<p>But at least we're preventing the <code>Foo.CONST_NAME</code> value from being changed, and that's better than nothing. Good luck.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately the Python has no constants so yet and it is shame. ES6 already added support constants to JavaScript (<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const" rel="noreferrer">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const</a>) since it is a very useful thing in any programming language.
As answered in other answers in Python community use the convention - user uppercase variable as constants, but it does not protect against arbitrary errors in code.
If you like, you may be found useful a single-file solution as next
(see docstrings how use it).</p>
<p><strong>file constants.py</strong></p>
<pre><code>import collections


__all__ = ('const', )


class Constant(object):
    """
    Implementation strict constants in Python 3.

    A constant can be set up, but can not be changed or deleted.
    Value of constant may any immutable type, as well as list or set.
    Besides if value of a constant is list or set, it will be converted in an immutable type as next:
        list -&gt; tuple
        set -&gt; frozenset
    Dict as value of a constant has no support.

    &gt;&gt;&gt; const = Constant()
    &gt;&gt;&gt; del const.temp
    Traceback (most recent call last):
    NameError: name 'temp' is not defined
    &gt;&gt;&gt; const.temp = 1
    &gt;&gt;&gt; const.temp = 88
    Traceback (most recent call last):
        ...
    TypeError: Constanst can not be changed
    &gt;&gt;&gt; del const.temp
    Traceback (most recent call last):
        ...
    TypeError: Constanst can not be deleted
    &gt;&gt;&gt; const.I = ['a', 1, 1.2]
    &gt;&gt;&gt; print(const.I)
    ('a', 1, 1.2)
    &gt;&gt;&gt; const.F = {1.2}
    &gt;&gt;&gt; print(const.F)
    frozenset([1.2])
    &gt;&gt;&gt; const.D = dict()
    Traceback (most recent call last):
        ...
    TypeError: dict can not be used as constant
    &gt;&gt;&gt; del const.UNDEFINED
    Traceback (most recent call last):
        ...
    NameError: name 'UNDEFINED' is not defined
    &gt;&gt;&gt; const()
    {'I': ('a', 1, 1.2), 'temp': 1, 'F': frozenset([1.2])}
    """

    def __setattr__(self, name, value):
        """Declaration a constant with value. If mutable - it will be converted to immutable, if possible.
        If the constant already exists, then made prevent againt change it."""

        if name in self.__dict__:
            raise TypeError('Constanst can not be changed')

        if not isinstance(value, collections.Hashable):
            if isinstance(value, list):
                value = tuple(value)
            elif isinstance(value, set):
                value = frozenset(value)
            elif isinstance(value, dict):
                raise TypeError('dict can not be used as constant')
            else:
                raise ValueError('Muttable or custom type is not supported')
        self.__dict__[name] = value

    def __delattr__(self, name):
        """Deny against deleting a declared constant."""

        if name in self.__dict__:
            raise TypeError('Constanst can not be deleted')
        raise NameError("name '%s' is not defined" % name)

    def __call__(self):
        """Return all constans."""

        return self.__dict__


const = Constant()


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</code></pre>
<p>If this is not enough, see full testcase for it.</p>
<pre><code>import decimal
import uuid
import datetime
import unittest

from ..constants import Constant


class TestConstant(unittest.TestCase):
    """
    Test for implementation constants in the Python
    """

    def setUp(self):

        self.const = Constant()

    def tearDown(self):

        del self.const

    def test_create_constant_with_different_variants_of_name(self):

        self.const.CONSTANT = 1
        self.assertEqual(self.const.CONSTANT, 1)
        self.const.Constant = 2
        self.assertEqual(self.const.Constant, 2)
        self.const.ConStAnT = 3
        self.assertEqual(self.const.ConStAnT, 3)
        self.const.constant = 4
        self.assertEqual(self.const.constant, 4)
        self.const.co_ns_ta_nt = 5
        self.assertEqual(self.const.co_ns_ta_nt, 5)
        self.const.constant1111 = 6
        self.assertEqual(self.const.constant1111, 6)

    def test_create_and_change_integer_constant(self):

        self.const.INT = 1234
        self.assertEqual(self.const.INT, 1234)
        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.INT = .211

    def test_create_and_change_float_constant(self):

        self.const.FLOAT = .1234
        self.assertEqual(self.const.FLOAT, .1234)
        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.FLOAT = .211

    def test_create_and_change_list_constant_but_saved_as_tuple(self):

        self.const.LIST = [1, .2, None, True, datetime.date.today(), [], {}]
        self.assertEqual(self.const.LIST, (1, .2, None, True, datetime.date.today(), [], {}))

        self.assertTrue(isinstance(self.const.LIST, tuple))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.LIST = .211

    def test_create_and_change_none_constant(self):

        self.const.NONE = None
        self.assertEqual(self.const.NONE, None)
        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.NONE = .211

    def test_create_and_change_boolean_constant(self):

        self.const.BOOLEAN = True
        self.assertEqual(self.const.BOOLEAN, True)
        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.BOOLEAN = False

    def test_create_and_change_string_constant(self):

        self.const.STRING = "Text"
        self.assertEqual(self.const.STRING, "Text")

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.STRING += '...'

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.STRING = 'TEst1'

    def test_create_dict_constant(self):

        with self.assertRaisesRegexp(TypeError, 'dict can not be used as constant'):
            self.const.DICT = {}

    def test_create_and_change_tuple_constant(self):

        self.const.TUPLE = (1, .2, None, True, datetime.date.today(), [], {})
        self.assertEqual(self.const.TUPLE, (1, .2, None, True, datetime.date.today(), [], {}))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.TUPLE = 'TEst1'

    def test_create_and_change_set_constant(self):

        self.const.SET = {1, .2, None, True, datetime.date.today()}
        self.assertEqual(self.const.SET, {1, .2, None, True, datetime.date.today()})

        self.assertTrue(isinstance(self.const.SET, frozenset))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.SET = 3212

    def test_create_and_change_frozenset_constant(self):

        self.const.FROZENSET = frozenset({1, .2, None, True, datetime.date.today()})
        self.assertEqual(self.const.FROZENSET, frozenset({1, .2, None, True, datetime.date.today()}))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.FROZENSET = True

    def test_create_and_change_date_constant(self):

        self.const.DATE = datetime.date(1111, 11, 11)
        self.assertEqual(self.const.DATE, datetime.date(1111, 11, 11))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.DATE = True

    def test_create_and_change_datetime_constant(self):

        self.const.DATETIME = datetime.datetime(2000, 10, 10, 10, 10)
        self.assertEqual(self.const.DATETIME, datetime.datetime(2000, 10, 10, 10, 10))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.DATETIME = None

    def test_create_and_change_decimal_constant(self):

        self.const.DECIMAL = decimal.Decimal(13123.12312312321)
        self.assertEqual(self.const.DECIMAL, decimal.Decimal(13123.12312312321))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.DECIMAL = None

    def test_create_and_change_timedelta_constant(self):

        self.const.TIMEDELTA = datetime.timedelta(days=45)
        self.assertEqual(self.const.TIMEDELTA, datetime.timedelta(days=45))

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.TIMEDELTA = 1

    def test_create_and_change_uuid_constant(self):

        value = uuid.uuid4()
        self.const.UUID = value
        self.assertEqual(self.const.UUID, value)

        with self.assertRaisesRegexp(TypeError, 'Constanst can not be changed'):
            self.const.UUID = []

    def test_try_delete_defined_const(self):

        self.const.VERSION = '0.0.1'
        with self.assertRaisesRegexp(TypeError, 'Constanst can not be deleted'):
            del self.const.VERSION

    def test_try_delete_undefined_const(self):

        with self.assertRaisesRegexp(NameError, "name 'UNDEFINED' is not defined"):
            del self.const.UNDEFINED

    def test_get_all_defined_constants(self):

        self.assertDictEqual(self.const(), {})

        self.const.A = 1
        self.assertDictEqual(self.const(), {'A': 1})

        self.const.B = "Text"
        self.assertDictEqual(self.const(), {'A': 1, 'B': "Text"})
</code></pre>
<p>Advantages:
 1. Access to all constants for whole project
 2. Strict control for values of constants</p>
<p>Lacks:
 1. Not support for custom types and the type 'dict'</p>
<p>Notes:</p>
<ol>
<li><p>Tested with Python3.4 and Python3.5 (I am use the 'tox' for it)</p></li>
<li><p>Testing environment:</p></li>
</ol>
<p>.</p>
<pre><code>$ uname -a
Linux wlysenko-Aspire 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A tuple technically qualifies as a constant, as a tuple will raise an error if you try to change one of its values. If you want to declare a tuple with one value, then place a comma after its only value, like this:</p>
<pre><code>my_tuple = (0 """Or any other value""",)
</code></pre>
<p>To check this variable's value, use something similar to this:  </p>
<pre><code>if my_tuple[0] == 0:
    #Code goes here
</code></pre>
<p>If you attempt to change this value, an error will be raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>The Pythonic way of declaring "constants" is basically a module level variable:</p>
<pre><code>RED = 1
GREEN = 2
BLUE = 3
</code></pre>
<p>And then write your classes or functions. Since constants are almost always integers, and they are also immutable in Python, you have a very little chance of altering it.</p>
<p>Unless, of course, if you explicitly set <code>RED = 2</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python dictionaries are mutable, so they don't seem like a good way to declare constants:</p>
<pre><code>&gt;&gt;&gt; constants = {"foo":1, "bar":2}
&gt;&gt;&gt; print constants
{'foo': 1, 'bar': 2}
&gt;&gt;&gt; constants["bar"] = 3
&gt;&gt;&gt; print constants
{'foo': 1, 'bar': 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python, a constant is simply a variable with a name in all capitals, with words separated by the underscore character,</p>
<p>e.g</p>
<p>DAYS_IN_WEEK = 7</p>
<p>The value is mutable, as in you can change it.  But given the rules for the name tell you is a constant, why would you?  I mean, it is your program after all!</p>
<p>This is the approach taken throughout python.  There is no <code>private</code> keyword for the same reason.  Prefix the name with an underscore and you know it is intended to be private.  Code can break the rule....just as a programmer could remove the private keyword anyway. </p>
<p>Python could have added a <code>const</code> keyword... but a programmer could remove keyword and then change the constant if they want to, but why do that?  If you want to break the rule, you could change the rule anyway.  But why bother to break the rule if the name makes the intention clear?</p>
<p>Maybe there is some unit test where it makes sense to apply a change to value? To see what happens for an 8 day week even though in the real world the number of days in the week cannot be changed.  If the language stopped you making an exception if there is just this one case you need to break the rule...you would then have to stop declaring it as a constant, even though it still is a constant in the application, and there is just this one test case that sees what happens if it is changed.</p>
<p>The all upper case name tells you it is intended to be a constant. That is what is important. Not a language forcing constraints on code you have the power to change anyway.</p>
<p>That is the philosophy of python. </p>
</div>
<div class="post-text" itemprop="text">
<p>There is a cleaner way to do this with namedtuple:</p>
<pre><code>from collections import namedtuple


def make_consts(name, **kwargs):
    return namedtuple(name, kwargs.keys())(**kwargs)
</code></pre>
<p>Usage Example</p>
<pre><code>CONSTS = make_consts("baz1",
                     foo=1,
                     bar=2)
</code></pre>
<p>With this exactly approach you can namespace your constants.</p>
</div>
<div class="post-text" itemprop="text">
<p>We can create a descriptor object.</p>
<pre><code>class Constant:
  def __init__(self,value=None):
    self.value = value
  def __get__(self,instance,owner):
    return self.value
  def __set__(self,instance,value):
    raise ValueError("You can't change a constant")
</code></pre>
<p>1) If we wanted to work with constants at the instance level then:</p>
<pre><code>class A:
  NULL = Constant()
  NUM = Constant(0xFF)

class B:
  NAME = Constant('bar')
  LISTA = Constant([0,1,'INFINITY'])

&gt;&gt;&gt; obj=A()
&gt;&gt;&gt; print(obj.NUM)  #=&gt; 255
&gt;&gt;&gt; obj.NUM =100

Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: You can't change a constant
</code></pre>
<p>2) if we wanted to create constants only at the class level, we could use a metaclass that serves as a container for our constants (our descriptor objects); all the classes that descend will inherit our constants (our descriptor objects) without any risk that can be modified.</p>
<pre><code># metaclass of my class Foo
class FooMeta(type): pass

# class Foo
class Foo(metaclass=FooMeta): pass

# I create constants in my metaclass
FooMeta.NUM = Constant(0xff)
FooMeta.NAME = Constant('FOO')

&gt;&gt;&gt; Foo.NUM   #=&gt; 255
&gt;&gt;&gt; Foo.NAME  #=&gt; 'FOO'
&gt;&gt;&gt; Foo.NUM = 0 #=&gt; ValueError: You can't change a constant
</code></pre>
<p>If I create a subclass of Foo, this class will inherit the constant without the possibility of modifying them</p>
<pre><code>class Bar(Foo): pass

&gt;&gt;&gt; Bar.NUM  #=&gt; 255
&gt;&gt;&gt; Bar.NUM = 0  #=&gt; ValueError: You can't change a constant
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use StringVar or IntVar, etc, your constant is <i><b>const_val</b></i></p></div>
<div class="post-text" itemprop="text">
<blockquote>
<p>In Python, constants do not exist. But you can indicate that a variable is a constant and must not be changed by adding <strong>' _CONSTANT '</strong> to the start of the variable name, naming the variable in BLOCK CAPITALS, and adding a comment using the hashtag <strong>(' # ')</strong> <strong><em>e.g. :</em></strong></p>
</blockquote>
<pre><code>    normal_variable = 0
    CONSTANT_variable = 1    # This is a constant - do not change its value!   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simply you can just:</p>
<pre><code>STRING_CONSTANT = "hi"
NUMBER_CONSTANT = 89
</code></pre>
<p>hope that makes everything much simpler </p>
</div>
<div class="post-text" itemprop="text">
<p>(This paragraph was meant to be a comment on those answers <a href="https://stackoverflow.com/a/2683099/728675">here</a> and <a href="https://stackoverflow.com/a/40029632/728675">there</a>, which mentioned <code>namedtuple</code>, but it is getting too long to be fit into a comment, so, here it goes.)</p>
<p>The namedtuple approach mentioned above is definitely innovative. For the sake of completeness, though, at the end of the NamedTuple section of <a href="https://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">its official documentation</a>, it reads:</p>
<blockquote>
<p>enumerated constants can be implemented with named tuples, but it is simpler and more efficient to use a simple class declaration:</p>
<pre><code>class Status:
    open, pending, closed = range(3)
</code></pre>
</blockquote>
<p>In other words, the official documentation kind of prefers to use a practical way, rather than actually implementing the read-only behavior. I guess it becomes yet another example of <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of Python</a>:</p>
<blockquote>
<p>Simple is better than complex.</p>
<p>practicality beats purity.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Maybe pconst library will help you (<a href="https://github.com/simon-ritchie/pconst" rel="nofollow noreferrer">github</a>).</p>
<p><code>$ pip install pconst</code></p>
<pre><code>from pconst import const
const.APPLE_PRICE = 100
const.APPLE_PRICE = 200
</code></pre>
<p><code>[Out] Constant value of "APPLE_PRICE" is not editable.</code></p>
</div>
<div class="post-text" itemprop="text">
<p>In my case, I needed immutable bytearrays for an implementation of a crypto library containing many literal numbers I wanted to ensure were constant.</p>
<p><a href="https://stackoverflow.com/a/2688086/2880685">This answer</a> works but attempted reassignment of bytearray elements does not raise an error.</p>
<pre><code>def const(func):
    '''implement const decorator'''
    def fset(self, val):
        '''attempting to set a const raises `ConstError`'''
        class ConstError(TypeError):
            '''special exception for const reassignment'''
            pass

        raise ConstError

    def fget(self):
        '''get a const'''
        return func()

    return property(fget, fset)


class Consts(object):
    '''contain all constants'''

    @const
    def C1():
        '''reassignment to C1 fails silently'''
        return bytearray.fromhex('deadbeef')

    @const
    def pi():
        '''is immutable'''
        return 3.141592653589793
</code></pre>
<p>Constants are immutable, but constant bytearray assignment fails silently:</p>
<pre><code>&gt;&gt;&gt; c = Consts()
&gt;&gt;&gt; c.pi = 6.283185307179586  # (https://en.wikipedia.org/wiki/Tau_(2%CF%80))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "consts.py", line 9, in fset
    raise ConstError
__main__.ConstError
&gt;&gt;&gt; c.C1[0] = 0
&gt;&gt;&gt; c.C1[0]
222
&gt;&gt;&gt; c.C1
bytearray(b'\xde\xad\xbe\xef')
</code></pre>
<p>A more powerful, simple, and perhaps even more 'pythonic' approach involves the use of memoryview objects (buffer objects in &lt;= python-2.6).</p>
<pre><code>import sys

PY_VER = sys.version.split()[0].split('.')

if int(PY_VER[0]) == 2:
    if int(PY_VER[1]) &lt; 6:
        raise NotImplementedError
    elif int(PY_VER[1]) == 6:
        memoryview = buffer

class ConstArray(object):
    '''represent a constant bytearray'''
    def __init__(self, init):
        '''
        create a hidden bytearray and expose a memoryview of that bytearray for
        read-only use
        '''
        if int(PY_VER[1]) == 6:
            self.__array = bytearray(init.decode('hex'))
        else:
            self.__array = bytearray.fromhex(init)

        self.array = memoryview(self.__array)

    def __str__(self):
        return str(self.__array)

    def __getitem__(self, *args, **kwargs):
       return self.array.__getitem__(*args, **kwargs)
</code></pre>
<p>ConstArray item assignment is a <code>TypeError</code>:</p>
<pre><code>&gt;&gt;&gt; C1 = ConstArray('deadbeef')
&gt;&gt;&gt; C1[0] = 0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'ConstArray' object does not support item assignment
&gt;&gt;&gt; C1[0]
222
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I write a util lib for python const:
<a href="https://pypi.python.org/pypi/kkconst" rel="nofollow"> kkconst - pypi </a>
support str, int, float, datetime </p>
<p>the const field instance will keep its base type behavior.</p>
<p>For example:</p>
<pre><code>from __future__ import print_function
from kkconst import (
    BaseConst,
    ConstFloatField,
)

class MathConst(BaseConst):
    PI = ConstFloatField(3.1415926, verbose_name=u"Pi")
    E = ConstFloatField(2.7182818284, verbose_name=u"mathematical constant")  # Euler's number"
    GOLDEN_RATIO = ConstFloatField(0.6180339887, verbose_name=u"Golden Ratio")

magic_num = MathConst.GOLDEN_RATIO
assert isinstance(magic_num, ConstFloatField)
assert isinstance(magic_num, float)

print(magic_num)  # 0.6180339887
print(magic_num.verbose_name)  # Golden Ratio
</code></pre>
<p>more details usage you can read the pypi url: 
<a href="https://pypi.python.org/pypi/kkconst" rel="nofollow"> pypi </a> or <a href="https://github.com/kaka19ace/kkconst" rel="nofollow"> github </a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can wrap a constant in a numpy array, flag it write only, and always call it by index zero.</p>
<pre><code>import numpy as np

# declare a constant
CONSTANT = 'hello'

# put constant in numpy and make read only
CONSTANT = np.array([CONSTANT])
CONSTANT.flags.writeable = False
# alternatively: CONSTANT.setflags(write=0)

# call our constant using 0 index    
print 'CONSTANT %s' % CONSTANT[0]

# attempt to modify our constant with try/except
new_value = 'goodbye'
try:
    CONSTANT[0] = new_value
except:
    print "cannot change CONSTANT to '%s' it's value '%s' is immutable" % (
        new_value, CONSTANT[0])

# attempt to modify our constant producing ValueError
CONSTANT[0] = new_value



&gt;&gt;&gt;
CONSTANT hello
cannot change CONSTANT to 'goodbye' it's value 'hello' is immutable
Traceback (most recent call last):
  File "shuffle_test.py", line 15, in &lt;module&gt;
    CONSTANT[0] = new_value
ValueError: assignment destination is read-only
</code></pre>
<p>of course this only protects the contents of the numpy, not the variable "CONSTANT" itself; you can still do:</p>
<pre><code>CONSTANT = 'foo'
</code></pre>
<p>and <code>CONSTANT</code> would change, however that would quickly throw an TypeError the first time <code>CONSTANT[0]</code> is later called in the script.</p>
<p>although... I suppose if you at some point changed it to </p>
<pre><code>CONSTANT = [1,2,3]
</code></pre>
<p>now you wouldn't get the TypeError anymore.  hmmmm....</p>
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setflags.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.setflags.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a trick if you want constants and don't care their values:</p>
<p><strong>Just define empty classes.</strong></p>
<p>e.g:</p>
<pre><code>class RED: 
    pass
class BLUE: 
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no perfect way to do this. As I understand it most programmers will just capitalize the identifier, so PI = 3.142 can be readily understood to be a constant.</p>
<p>On the otherhand, if you want something that actually acts like a constant, I'm not sure you'll find it. With anything you do there will always be some way of editing the "constant" so it won't really be a constant. Here's a very simple, dirty example:</p>
<pre><code>def define(name, value):
  if (name + str(id(name))) not in globals():
    globals()[name + str(id(name))] = value

def constant(name):
  return globals()[name + str(id(name))]

define("PI",3.142)

print(constant("PI"))
</code></pre>
<p>This looks like it will make a PHP-style constant.</p>
<p>In reality all it takes for someone to change the value is this:</p>
<pre><code>globals()["PI"+str(id("PI"))] = 3.1415
</code></pre>
<p>This is the same for all the other solutions you'll find on here - even the clever ones that make a class and redefine the set attribute method - there will always be a way around them. That's just how Python is.</p>
<p>My recommendation is to just avoid all the hassle and just capitalize your identifiers. It wouldn't really be a proper constant but then again nothing would.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with <code>collections.namedtuple</code> and <code>itertools</code>:</p>
<pre><code>import collections
import itertools
def Constants(Name, *Args, **Kwargs):
  t = collections.namedtuple(Name, itertools.chain(Args, Kwargs.keys()))
  return t(*itertools.chain(Args, Kwargs.values()))

&gt;&gt;&gt; myConstants = Constants('MyConstants', 'One', 'Two', Three = 'Four')
&gt;&gt;&gt; print myConstants.One
One
&gt;&gt;&gt; print myConstants.Two
Two
&gt;&gt;&gt; print myConstants.Three
Four
&gt;&gt;&gt; myConstants.One = 'Two'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending Raufio's answer, add a <strong>repr</strong> to return the value.</p>
<pre><code>class const(object):
    def __init__(self, val):
        super(const, self).__setattr__("value", val)
    def __setattr__(self, name, val):
        raise ValueError("Trying to change a constant value", self)
    def __repr__(self):
        return ('{0}'.format(self.value))

dt = const(float(0.01))
print dt
</code></pre>
<p>then the object behaves a little more like you might expect, you can access it directly rather then '.value'</p>
</div>
<span class="comment-copy">actually the way to make <i>read-only</i> variables is possible via python's <a href="https://docs.python.org/2/library/functions.html#property" rel="nofollow noreferrer">property</a> function/decorator. the <a href="http://stackoverflow.com/a/2688086/611007">answer</a> of <a href="http://stackoverflow.com/users/321237/inv">inv</a> is an example of a custom usage of that. property is more general-use than that, though, a good analysis of how it works is on Shalabh Chaturvedi's <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html" rel="nofollow noreferrer">Python Attributes and Methods</a>.</span>
<span class="comment-copy">IMHO, enforcing constancy is "not pythonic". In Python 2.7 you can even write <code>True=False</code>, and then <code>(2+2==4)==True</code> returns <code>False</code>.</span>
<span class="comment-copy">As other answers suggests there is no way or no need to declare constants. But you may read this <a href="http://legacy.python.org/dev/peps/pep-0008/#constants" rel="nofollow noreferrer">PEP</a> about conventions. e.g. THIS_IS_A_CONSTANT</span>
<span class="comment-copy">@osa: You can't do that in python 3 - <code>SyntaxError: can't assign to keyword</code>. This seems like a Good Thing.</span>
<span class="comment-copy">Rather then do what is in "Constants in Python," you should use the "property" function or decorator.</span>
<span class="comment-copy">People ask about the same feature in Perl.  There is an import module called "use constant", but (AFAIK) is it just a wrapper to create a tiny function that returns the value.  I do the same in Python.  Example: <code>def MY_CONST_VALUE(): return 123</code></span>
<span class="comment-copy">"No there is not." True, but building on other people's work, I have added an answer, far below, with a short and simple implementation of "Constants" for python 2.7 (which lacks "enum"). These are enum-like read-only <code>name.attribute</code>, and can contain any value. Declaration is easy <code>Nums = Constants(ONE=1, PI=3.14159, DefaultWidth=100.0)</code>, Usage is straightforward <code>print 10 + Nums.PI</code>, attempt to change results in exception <code>Nums.PI = 22</code> =&gt; ValueError(..).</span>
<span class="comment-copy"><b>Just don't change it.</b> you made my day</span>
<span class="comment-copy">"Just don't change it" isn't helpful at all. It doesn't answer the question and I would suggest that it is removed.</span>
<span class="comment-copy">Based on the documentation on <code>AttributeError</code> and <code>TypeError</code>, I think that the raised exception should be a new error, which I propose naming <code>ConstantError</code> or something like that, which is a subclass of <code>TypeError</code>. The section in the docs that makes me think that: <a href="https://docs.python.org/2/library/exceptions.html" rel="nofollow noreferrer">docs.python.org/2/library/exceptions.html</a></span>
<span class="comment-copy">I'm surprised with this code. Why FOO() and BAR() methods font have self as an argument? My IDE underlines the brackets on red ("compile" error). I tired to put self in it but then I get an error.</span>
<span class="comment-copy">Going to these lengths does outline a clear deficiency in the python language. Why did they not feel the need to add this in to Python 3. I can't believe no-one suggested it and I simply can not see the logic behind some committee going 'nah, constants? nah.'</span>
<span class="comment-copy">And your solution can still be modified by a determined python programmer by using <code>CONST.__dict__['FOO'] = 7</code></span>
<span class="comment-copy">@OscarSmith, I think it would improve the 'self documented code' design. When I make explicit into the code that some value cannot change, it is easier to understand than reading all source code and realizing that some value never changes. Also, it blocks the possibility of someone change a value that should be, well, constant. Remember: explicit is better than implicit.</span>
<span class="comment-copy">Doing <code>def MY_CONSTANT(): return "one"</code> will not stop someone, later in the code, doing <code>MY_CONSTANT = "two"</code> (or redeclaring the function).</span>
<span class="comment-copy">@MatthewSchinckel it is about convention, also changing MY_CONSTANT will not change usage MY_CONSTANT() but will throw error, and in python if you want you can change anything, no clever trick can protect you.</span>
<span class="comment-copy">+1 for namedtuple approach. Not sure I'll ever use it, but interesting idea.</span>
<span class="comment-copy">Thanks for bringing up the namedtuple approach. Definitely innovative. You might also find my <a href="https://stackoverflow.com/a/52194807/728675">"comment" here</a> relevant.</span>
<span class="comment-copy">This is the best and most clear answer, because it has the least "mechanism", but the most functionality.  Raising an exception is important though... not an option.</span>
<span class="comment-copy">I've worked out a shorter route that automatically produces meaningful errors but is much in the same style. I've left the original idea here for comparison.</span>
<span class="comment-copy">I just wanted to add this suggestion but fortunately I scrolled down to the low-rated answers. I hope it will be further upvoted and I fully agree that it has all the functionality of a constant and it is very simple and straightforward. Looking at the amount of boilerplate code in all the sophisticated solutions I find the braces relatively unannoying.</span>
<span class="comment-copy">I like your implementation over on GitHub.  I was almost ready to write a basic class which implemented the reverse lookup functionality, but I see you've done that and more!</span>
<span class="comment-copy">Thanks, @Kerr, it's the first feedback I got and made me happy. :-)</span>
<span class="comment-copy">Awesome. I just tried this out. Nice to have this as option. Though haven't decided if I care enough about the read-only aspect, to use this rather than simply doing <code>def enum(**enums):   return type('Enum', (), enums)</code>.  <code>Numbers = enum(ONE=1, TWO=2, THREE='three')</code>, as per <a href="http://stackoverflow.com/a/1695250/199364">stackoverflow.com/a/1695250/199364</a> , section "In earlier versions ..."</span>
<span class="comment-copy">Under valued solution.  I just implemented this after finding this page (not this answer) and circled back to add it if not already.  I wanted to underscore the usefulness of this answer.</span>
<span class="comment-copy">Python is a language of consenting adults. There is no protection against something like this. <code>Nums._d['PI'] = 22</code>  The language itself doesn't provide any way to mark things as non-mutables, I believe.</span>
<span class="comment-copy">+1 for interesting approach. Though not as clean as answers that had already been provided.  And even the simplest earlier suggested solution <code>def ONE():  return 1</code> is easier to use <code>ONE()</code> than this answer <code>ONE.value</code>.</span>
<span class="comment-copy">Thanks for bringing up the namedtuple approach. Definitely innovative. You might also find my <a href="https://stackoverflow.com/a/52194807/728675">"comment" here</a> relevant.</span>
<span class="comment-copy">Yes, but <b>blocking</b> the ability to "explicitly set <code>RED = 2</code>" is the entire benefit (in other languages) of being able to declare a variable name to be "constant"!</span>
<span class="comment-copy">Would benefit would you get from blocking that? The most useful thing about const is usually compiler optimizations which isn't really a thing in Python. Want something to be constant? Just don't change it. If you're worrying about someone else changing it, you could just put it outside of their scope, or just realize that, if someone is changing it, that's their problem and they need to deal with it, not you.</span>
<span class="comment-copy">@Kevin: "<i>Would benefit would you get...</i>", the benefit of <code>static</code> to have a single storage for the value for all instances of a class? Unless there is a possibility to declare a static/class variable indeed.</span>
<span class="comment-copy">The root issue is that some may see it as a value that is a source of truth, unable to be changed, and use it as the source of truth throughout their code instead of introducing magic values (which I see a lot of in Python) - and others may see it as something they're allowed to change at will. When someone changes a global variable, and you can't tell where it got changed, and the application crashes because RED="blue" instead of "red", you're introducing a totally unnecessary problem that has already been solved so simply and is universally understood.</span>
<span class="comment-copy">No. The result is not a constant. <code>dt = 5</code> is accepted without complaint. In Raufio's answer, while one can also overwrite it, the result will cause a complaint on the next usage <code>dt.value</code>. So is a less dangerous failure. You have nullified the benefit of his solution.</span>
