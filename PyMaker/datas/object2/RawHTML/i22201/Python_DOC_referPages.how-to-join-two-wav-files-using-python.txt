<div class="post-text" itemprop="text">
<p>I am using python programming language,I want to join to wav file one at the end of other wav file?
I have a Question in the forum which suggest how to merge two wav file i.e add the contents of one wav file at certain offset,but i want to join two wav file at the end of each other...</p>
<p>And also i had a prob playing the my own wav file,using winsound module..I was able to play the sound but using the time.sleep for certain time before playin any windows sound,disadvantage wit this is if i wanted to play a sound longer thn time.sleep(N),N sec also,the windows sound wil jst overlap after N sec play the winsound nd stop..</p>
<p>Can anyone help??please kindly suggest to how to solve these prob...</p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>audiolab</code>:</p>
<pre><code>import audiolab, scipy
a, fs, enc = audiolab.wavread('file1.wav')
b, fs, enc = audiolab.wavread('file2.wav')
c = scipy.vstack((a,b))
audiolab.wavwrite(c, 'file3.wav', fs, enc)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python ships with the <a href="http://docs.python.org/library/wave.html" rel="noreferrer">wave</a> module that will do what you need.  The example below works when the details of the files (mono or stereo, frame rates, etc) are the same:</p>
<pre><code>import wave

infiles = ["sound_1.wav", "sound_2.wav"]
outfile = "sounds.wav"

data= []
for infile in infiles:
    w = wave.open(infile, 'rb')
    data.append( [w.getparams(), w.readframes(w.getnframes())] )
    w.close()

output = wave.open(outfile, 'wb')
output.setparams(data[0][0])
output.writeframes(data[0][1])
output.writeframes(data[1][1])
output.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm the maintainer of <a href="http://pydub.com" rel="noreferrer">pydub</a>, which is designed to make this sort of thing easy.</p>
<pre><code>from pydub import AudioSegment

sound1 = AudioSegment.from_wav("/path/to/file1.wav")
sound2 = AudioSegment.from_wav("/path/to/file2.wav")

combined_sounds = sound1 + sound2
combined_sounds.export("/output/path.wav", format="wav")
</code></pre>
<p>note: pydub is a light wrapper around audioop. So behind the scenes, it's doing essentially what Tom10 mentioned</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to build on @tom10's answer:</p>
<pre><code>from contextlib import closing

with closing(wave.open(outfile, 'wb')) as output:

    # find sample rate from first file
    with closing(wave.open(wav_files[0])) as w:
        output.setparams(w.getparams())

    # write each file to output
    for infile in wav_files:
        with closing(wave.open(infile)) as w:
            output.writeframes(w.readframes(w.getnframes()))
</code></pre>
<p>Instead of storing all the data then writing it at the end in one go, it writes it bit by bit. It also uses contextlib.close so you don't have to close files.</p>
</div>
<div class="post-text" itemprop="text">
<p>I used <a href="https://github.com/rabitt/pysox" rel="nofollow noreferrer">pysox</a></p>
<p>The wave module and many others don't seem to support mu-law wavs.</p>
<p>pysox reqs that you install <a href="http://sox.sourceforge.net/" rel="nofollow noreferrer">SoX</a>
and update your PATH to include the directory it's installed to.</p>
<pre><code>import sox    
cbn=sox.Combiner()
sounds=[]
#PROCESS SOUND PATHS TO AN ARRAY
if len(sounds)&gt;=2:
    print(sounds)
    cbn.build(sounds,'outputfilepath.ext','concatenate')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i use the SOX [1] library and then call it like</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; sound_output_path = /tmp
&gt;&gt;&gt; sox_filenames = ['file.wav', 'file1.wav']
&gt;&gt;&gt; subprocess.call(['sox'] + sox_filenames + ['%s/out.wav' % sound_output_path])
</code></pre>
<p>[1] <a href="http://sox.sourceforge.net/" rel="nofollow noreferrer">http://sox.sourceforge.net/</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 solution:<br/>
We can do this with the standard library as shown by tom10 and eggbert's answers.<br/>
Below is a shorter version:</p>
<ol>
<li>Only write the parameters for the first wave file. We can test the wav_out file length to see if we haven't yet written to it. If we haven't write the wave parameters once only.</li>
<li><p>Then write frames to the wav_out as they are read from the wav_in.  </p>
<pre><code>with wave.open(outfile, 'wb') as wav_out:
    for wav_path in infiles:
        with wave.open(wav_path, 'rb') as wav_in:
            if not wav_out.getnframes():
                wav_out.setparams(wav_in.getparams())
            wav_out.writeframes(wav_in.readframes(wav_in.getnframes()))
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I would use <code>librosa.load</code> and <code>librosa.write_wav</code>.
Check out the doc <a href="https://librosa.github.io/librosa/generated/librosa.output.write_wav.html#librosa.output.write_wav" rel="nofollow noreferrer">here</a></p>
<pre><code>import librosa
import numpy as np
import librosa.display

example_audio = librosa.util.example_audio_file()
x, sr = librosa.load(example_audio, duration=5)
print('shape of x ==&gt; ' + str(x.shape))
y, sr = librosa.load(example_audio, duration=5)
print('shape of y ==&gt; ' + str(y.shape))
z = np.append(x,y)
print('shape of x+y = z ==&gt; ' + str(z.shape))
librosa.output.write_wav('joined_file.wav', z, sr)

z_loaded, sr = librosa.load('joined_file.wav')
print('shape of z loaded ==&gt; ' + str(z_loaded.shape))
</code></pre>
<blockquote>
<p>Output: </p>
<p>shape of x ==&gt; (110250,)</p>
<p>shape of y ==&gt; (110250,)</p>
<p>shape of x+y = z ==&gt; (220500,)</p>
<p>shape of z loaded ==&gt; (220500,)</p>
</blockquote>
</div>
<span class="comment-copy">do i need to install any package for using scipy...I am using a python2.6 can i get a compatible version for download if i have to..can u provide me the link please..i tried to frm scipy site itself bt faced sme prob..if ne there steps fot installation please suggest..Thank u for the answer.. Do u know how to play the sound,i mentioned my prob wit playin,any measure fr that??</span>
<span class="comment-copy">Python 2.6 is fine, and the Numpy/Scipy website should also be fine. I might let others answer your questions and provide further suggestions. Although my answer does work, there are probably more elegant, direct solutions.</span>
<span class="comment-copy">Ahh..thanks,ne ways my other prob about playin wav files are solved now..</span>
<span class="comment-copy">I tried installation of audiolab from scikits which is about a size of 1.4 mb and was succesfully installed,but when running ur code it says import error: no module named audiolab..i didnt install the 44mb scipy package is that the prob,do i need to instal that also or the audioalab download itself is incorrect</span>
<span class="comment-copy">I installed Scipy too but stil says import error..I am using window downloaded both and installed later..stil there prob what mmay b d reason..</span>
<span class="comment-copy">This is impressive! Thank you.</span>
<span class="comment-copy">In python3 it looks like we don't need the contextlib wrapper per: "The open() function may be used in a with statement. When the with block completes, the Wave_read.close() or Wave_write.close() method is called." <a href="https://docs.python.org/3/library/wave.html" rel="nofollow noreferrer">docs.python.org/3/library/wave.html</a></span>
<span class="comment-copy">I can't figure out from those docs how to do it.</span>
<span class="comment-copy">@Ryan updated the answer. You might be interested in more code samples here : <a href="https://github.com/gndps/vocal-training/blob/master/7_phrasedetection.ipynb" rel="nofollow noreferrer">github.com/gndps/vocal-training/blob/master/â€¦</a> not very easy to read doc though</span>
