<div class="post-text" itemprop="text">
<p>Suppose code like this:</p>
<pre><code>class Base:
    def start(self):
        pass
    def stop(self)
        pass

class A(Base):
    def start(self):
        ... do something for A
    def stop(self)
        .... do something for A

class B(Base):
    def start(self):

    def stop(self):

a1 = A(); a2 = A()
b1 = B(); b2 = B()

all = [a1, b1, b2, a2,.....]
</code></pre>
<p>Now I want to call methods start and stop (maybe also others) for each object in the list all. Is there any elegant way for doing this except of writing a bunch of functions like</p>
<pre><code>def start_all(all):
    for item in all:
        item.start()

def stop_all(all):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The *_all() functions are so simple that for a few methods I'd just write the functions. If you have lots of identical functions, you can write a generic function:</p>
<pre><code>def apply_on_all(seq, method, *args, **kwargs):
    for obj in seq:
         getattr(obj, method)(*args, **kwargs)
</code></pre>
<p>Or create a function factory:</p>
<pre><code>def create_all_applier(method, doc=None):
    def on_all(seq, *args, **kwargs):
        for obj in seq:
            getattr(obj, method)(*args, **kwargs)
    on_all.__doc__ = doc
    return on_all

start_all = create_all_applier('start', "Start all instances")
stop_all = create_all_applier('stop', "Stop all instances")
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>This will work</strong></p>
<pre><code>all = [a1, b1, b2, a2,.....]

map(lambda x: x.start(),all)    
</code></pre>
<p>simple example</p>
<pre><code>all = ["MILK","BREAD","EGGS"]
map(lambda x:x.lower(),all)
&gt;&gt;&gt;['milk','bread','eggs']
</code></pre>
<p>and in python3</p>
<pre><code>all = ["MILK","BREAD","EGGS"]
list(map(lambda x:x.lower(),all))
&gt;&gt;&gt;['milk','bread','eggs']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems like there would be a more Pythonic way of doing this, but I haven't found it yet.</p>
<p>I use "map" sometimes if I'm calling the same function (not a method) on a bunch of objects:</p>
<pre><code>map(do_something, a_list_of_objects)
</code></pre>
<p>This replaces a bunch of code that looks like this:</p>
<pre><code> do_something(a)
 do_something(b)
 do_something(c)
 ...
</code></pre>
<p>But can also be achieved with a pedestrian "for" loop:</p>
<pre><code>  for obj in a_list_of_objects:
       do_something(obj)
</code></pre>
<p>The downside is that a) you're creating a list as a return value from "map" that's just being throw out and b) it might be more confusing that just the simple loop variant.</p>
<p>You could also use a list comprehension, but that's a bit abusive as well (once again, creating a throw-away list):</p>
<pre><code>  [ do_something(x) for x in a_list_of_objects ]
</code></pre>
<p>For methods, I suppose either of these would work (with the same reservations):</p>
<pre><code>map(lambda x: x.method_call(), a_list_of_objects)
</code></pre>
<p>or</p>
<pre><code>[ x.method_call() for x in a_list_of_objects ]
</code></pre>
<p>So, in reality, I think the pedestrian (yet effective) "for" loop is probably your best bet.</p>
</div>
<div class="post-text" itemprop="text">
<p>The approach</p>
<pre><code>for item in all:
    item.start()
</code></pre>
<p>is simple, easy, readable, and concise. This is the main approach Python provides for this operation. You can certainly encapsulate it in a function if that helps something. Defining a special function for this for general use is likely to be less clear than just writing out the for loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>maybe <code>map</code>, but since you don't want to make a list, you can write your own...</p>
<pre><code>def call_for_all(f, seq):
    for i in seq:
        f(i)
</code></pre>
<p>then you can do:</p>
<pre><code>call_for_all(lamda x: x.start(), all)
call_for_all(lamda x: x.stop(), all)
</code></pre>
<p>by the way, all is a built in function, don't overwrite it ;-)</p>
</div>
<div class="post-text" itemprop="text">
<p>Taking @Ants Aasmas answer one step further, you can create a wrapper that takes any method call and forwards it to all elements of a given list:</p>
<pre><code>class AllOf:
    def __init__(self, elements):
        self.elements = elements
    def __getattr__(self, attr):
        def on_all(*args, **kwargs):
            for obj in self.elements:
                getattr(obj, attr)(*args, **kwargs)
        return on_all
</code></pre>
<p>That class can then be used like this:</p>
<pre><code>class Foo:
    def __init__(self, val="quux!"):
        self.val = val
    def foo(self):
        print "foo: " + self.val

a = [ Foo("foo"), Foo("bar"), Foo()]
AllOf(a).foo()
</code></pre>
<p>Which produces the following output:</p>
<pre>foo: foo
foo: bar
foo: quux!</pre>
<p>With some work and ingenuity it could probably be enhanced to handle attributes as well (returning a list of attribute values).</p>
</div>
<div class="post-text" itemprop="text">
<p>Starting in Python 2.6 there is a <a href="https://docs.python.org/3/library/operator.html#operator.methodcaller" rel="nofollow noreferrer">operator.methodcaller</a> function. </p>
<p>So you can get something more elegant (and fast):</p>
<pre><code>from operator import methodcaller

map(methodcaller('method_name'), list_of_objects)
</code></pre>
</div>
<span class="comment-copy">a bunch of function is two function?</span>
<span class="comment-copy">This is unrelated to your question, but there's no obvious reason in your example why you need that base class. Python will be very happy to let you have a list of unrelated objects and so long as they all have 'start' and 'stop' methods you can still iterate through them calling the methods.</span>
<span class="comment-copy">Your defining <code>Base</code> with useless methods and then defining behaviour in <code>A</code> and <code>B</code> reflects a poor design in Python. Rather than using an abstract base class, you can just define <code>A</code> and <code>B</code> and use them interchangeably insofar as they share an interface. Your current way of doing things creates a useless class, which is just extra stuff you don't need.</span>
<span class="comment-copy">This doesn't strike me as simpler than writing the for loop directly.</span>
<span class="comment-copy">In Python 3 map returns a map object, not a list like in Python 2.  I'm not sure of standard procedure, but I thought I should correct it, so I submitted an edit.  So the code should now work as expected and correctly in both Python 2 and Python 3.</span>
<span class="comment-copy">Also this feels like the more Pythonic answer, it should be the accepted one.  map is a good choice, and I've never used lambdas before now, so thanks.</span>
<span class="comment-copy">In Python 3 <code>map()</code> function call will be not enough. It will create a generator object but wont apply lambda on each list element. Lambda will be applied on iterating through the map() result. <code>list(map(...))</code> will fix the problem.</span>
<span class="comment-copy">@dreikanter or just do <code>[x.start() for x in all]</code>?</span>
<span class="comment-copy">Using a list and then throwing it away strikes me as un-Pythonic. Because the invoked method is imperative code with side effects, an explicit <code>for</code> loop is more idiomatic and less surprising to the reader. If you really must, you could write <code>def foreach(fun, gen): for i in gen: fun(gen)</code>.</span>
<span class="comment-copy">My first reaction was map(lambda x: x.member(), list). It felt like a pretty clear one liner</span>
<span class="comment-copy">What is the best approach for python3?</span>
<span class="comment-copy">@Neil this works in python3, the only different is that <code>map</code> returns an iterator in 3, not a list</span>
