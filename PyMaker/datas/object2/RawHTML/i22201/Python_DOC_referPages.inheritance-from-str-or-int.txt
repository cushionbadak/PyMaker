<div class="post-text" itemprop="text">
<p>Why I have problem creating a class inheriting from str (or also from int)</p>
<pre><code>class C(str):
   def __init__(self, a, b):
     str.__init__(self,a)
     self.b = b

C("a", "B")

TypeError: str() takes at most 1 argument (2 given)
</code></pre>
<p>tha same happens if I try to use <code>int</code> instead of <code>str</code>, but it works with custom classes. I need to use <code>__new__</code> instead of <code>__init__</code>? why?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; class C(str):
...     def __new__(cls, *args, **kw):
...         return str.__new__(cls, *args, **kw)
... 
&gt;&gt;&gt; c = C("hello world")
&gt;&gt;&gt; type(c)
&lt;class '__main__.C'&gt;

&gt;&gt;&gt; c.__class__.__mro__
(&lt;class '__main__.C'&gt;, &lt;type 'str'&gt;, &lt;type 'basestring'&gt;, &lt;type 'object'&gt;)
</code></pre>
<p>Since <code>__init__</code> is called after the object is constructed, it is too late to modify the value   for immutable types. Note that <code>__new__</code> is a classmethod, so I have called the first parameter <code>cls</code></p>
<p>See <a href="http://docs.python.org/reference/datamodel.html#basic-customization" rel="noreferrer">here</a> for more information</p>
<pre><code>&gt;&gt;&gt; class C(str):
...     def __new__(cls, value, meta):
...         obj = str.__new__(cls, value)
...         obj.meta = meta
...         return obj
... 
&gt;&gt;&gt; c = C("hello world", "meta")
&gt;&gt;&gt; c
'hello world'
&gt;&gt;&gt; c.meta
'meta'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Inheriting built-in types is very seldom worth while. You have to deal with several issues and you don't really get much benefit. </p>
<p>It is almost always better to use composition. Instead of inheriting <code>str</code>, you would keep a <code>str</code> object as an attribute.</p>
<pre><code>class EnhancedString(object):
     def __init__(self, *args, **kwargs):
         self.s = str(*args, **kwargs)
</code></pre>
<p>you can defer any methods you want to work on the underlying <code>str</code> <code>self.s</code> manually or automatically using <code>__getattr__</code>.</p>
<p>That being said, needing your own string type is something that should give you pause. There are many classes that should store a string as their main data, but you generally want to use <code>str</code> or <code>unicode</code> (the latter if you're representing text) for general representation of strings. (One common exception is if you have need to use a UI toolkit's string type.) If you want to add functionality to your strings, try if you can to use <em>functions that operate on strings</em> rather than <em>new objects to serve as strings</em>, which keeps your code simpler and more compatible with everyone else's programs.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you instantiate a class, the arguments that you pass in, are passed to both the <code>__new__</code> (constructor) and then to the <code>__init__</code> (initializer) methods of the class. So if you inherit from a class that has restrictions on number of arguments that may be supplied during instantiation, you must guarantee that neither its <code>__new__</code>, nor its <code>__init__</code> would get more arguments than they expect to get. So that is the problem that you have. You instantiate your class with <code>C("a", "B")</code>. The interpreter looks for <code>__new__</code> method in <code>C</code>. <code>C</code> doesn't have it, so python peeps into its base class <code>str</code>. And as it has one, that one is used and supplied with the both arguments. But <code>str.__new__</code> expects to get only one argument (besides its class object as the first argument). So <code>TypeError</code> is raised. That is why you must extend it in your child class similarly to what you do with <code>__init__</code>. But bear in mind that it must return class instance and that it is a <em>static</em> method (irrespective of whether it is defined with <code>@staticmethod</code> decorator or not) that counts if you use <code>super</code> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>__new__</code> in case of immutable types:</p>
<pre><code>class C(str):
    def __new__(cls, content, b):
        return str.__new__(cls, content)

    def __str__(self):
        return str.__str__(self)

a=C("hello", "world")
print a
</code></pre>
<p>print returns <code>hello</code>.</p>
<p>Python strings are immutable types. The function <code>__new__</code> is called to create a new instance of object <code>C</code>. The <a href="http://docs.python.org/reference/datamodel.html#basic-customization" rel="noreferrer">python <code>__new__</code></a> function is basically exists to allow inheritance from immutable types.</p>
</div>
<div class="post-text" itemprop="text">
<p>After carefully reading <a href="http://docs.python.org/2/reference/datamodel.html#object.__new__" rel="nofollow">this</a>, here is another attempt at subclassing str. The change from other answers is creating the instance in the correct class using <code>super(TitleText, cls).__new__</code> . This one seems to behave like a str whenever it's used, but has allowed me to override a method:</p>
<pre><code>class TitleText(str):
    title_text=""
    def __new__(cls,content,title_text):
        o=super(TitleText, cls).__new__(cls,content)
        o.title_text = title_text
        return o

    def title(self):
        return self.title_text

&gt;&gt;&gt; a=TitleText('name','A nice name')
&gt;&gt;&gt; a
'name'
&gt;&gt;&gt; a[0]
'n'
&gt;&gt;&gt; a[0:2]
'na'
&gt;&gt;&gt; a.title()
'A nice name'
</code></pre>
<p>This lets you do slicing and subscripting correctly. What's this for? For renaming the Django application in the admin index page.</p>
</div>
<span class="comment-copy">I used your answer to help answer my own SO question <a href="https://stackoverflow.com/a/54611993/471376">here</a>.  Thanks!</span>
<span class="comment-copy">@wise, To use <code>__getattr__</code> to defer otherwise undefined attributes to a specific attribute in composition is accomplished by code like <code>def __getattr__(self, name): return getattr(self.s, name)</code>. Note that this code isn't necessarily recommended, but can work well in some cases; it's often better to manually define the things you want in composition.</span>
<span class="comment-copy">&gt; "Inheriting built-in types is very seldom worth while."  That might be true, but not always. Sometimes it's useful to create a "tagged string" type, such as to produce distinct types of string-like tokens from a parser. The problem with it, however, is that (I think) you lose the short-string performance optimization.</span>
<span class="comment-copy">I'm not convinced. Can you point out why you think inheriting from str is a potential source of error? Because it's not idiomatic?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/collections.html#collections.UserString" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>  "The class, UserString acts as a wrapper around string objects. The need for this class has been partially supplanted by the ability to subclass directly from str;"  It's not that unidiomatic.</span>
<span class="comment-copy">@blais, Suppose you do <code>your_subclass[:5]</code> or <code>your_subclass.replace(x, y)</code>--what does it return? An instance of <code>str</code> or an instance of your subclass? This isn't even defined, but in practice it will return <code>str</code>. There is no guarantee any which way, and this sort of undefined behavior is a bad thing.</span>
<span class="comment-copy">To verify, try this at the prompt: <code>&gt;&gt;&gt; str.__init__('abc', 'def')</code>. This does nothing. However, <code>&gt;&gt;&gt; str.__new__(str, 'abc', 'def')</code> throws the exception: <code>TypeError: str() takes at most 1 argument (2 given)</code>. This is a bit confusing, because we called <code>str.__new__(..)</code> with 3 arguments, not 2. Does this mean that <code>str.__new__(..)</code> accepts any number of arguments, but then calls <code>str(..)</code>? Probably not, because <code>str(..)</code> is going to call <code>str.__new__(..)</code> in turn...</span>
<span class="comment-copy">@Evgeni: <code>str</code> class object doesn't implement <code>__init__</code> method at all. Nor does <code>basestring</code> (<code>str</code>'s base class). <code>__init__</code> is inherited directly from <code>object</code> and that one accepts any number of arguments. On the contrary <code>__new__</code> method is really implemented in <code>str</code> and it accepts at most 1 argument beside the first one that must be <code>str</code> or its subclass. Try expressions like <code>&gt;&gt;&gt; '__init__' in str.__dict__</code> and so on for <code>__new__</code>, <code>basestring</code> and <code>object</code>.</span>
<span class="comment-copy">That's a good way to check which methods are implemented. I'm still a bit confused why I write <code>str.__new__(str, 'abc', 'def')</code> and it says I supplied 2 arguments. I count three there. For the example <code>class C(object):\n @staticmethod \n def m(a): pass</code>, if I call it like <code>C.m(1, 2)</code>, it will say <code>TypeError: m() takes exactly 1 argument (2 given)</code> as expected. I guess <code>__new__</code> produces a confusing message because <code>__new__</code> is special (e.g. you don't need to add the <code>@staticmethod</code> when implementing it).</span>
<span class="comment-copy"><code>type(C("a", "B"))</code> -&gt; <code>NoneType</code></span>
<span class="comment-copy">do you try your answer? Now it return ''</span>
<span class="comment-copy">-1? Can you at least write a comment?</span>
<span class="comment-copy">I wrote 2 comments.</span>
<span class="comment-copy">And have you checked the updates of the post? It was updated according your request. You down-voted after the changes were made. Moreover, in your comment you expected functionality from my code which was not requested in your question (to get __str__() function work for the inherited class)!</span>
<span class="comment-copy">Yuck! The fact that your <code>repr</code> is deceptive leads to it being unclear that while <code>a</code> is a <code>TitleText</code>, <code>a[0]</code> and <code>a[0:2]</code> are str (today, in current versions, as an implementation detail). If you'd written a class without inheriting <code>str</code> you could make a much more useful and much less confusing and deceptive thing.</span>
