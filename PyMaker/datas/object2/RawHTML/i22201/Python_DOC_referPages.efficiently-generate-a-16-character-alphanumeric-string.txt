<div class="post-text" itemprop="text">
<p>I'm looking for a very quick way to generate an alphanumeric unique id for a primary key in a table.</p>
<p>Would something like this work?</p>
<pre><code>def genKey():
    hash = hashlib.md5(RANDOM_NUMBER).digest().encode("base64")
    alnum_hash = re.sub(r'[^a-zA-Z0-9]', "", hash)
    return alnum_hash[:16]
</code></pre>
<p>What would be a good way to generate random numbers?
If I base it on microtime, I have to account for the possibility of several calls of genKey() at the same time from different instances.</p>
<p>Or is there a better way to do all this?</p>
</div>
<div class="post-text" itemprop="text">
<p>As none of the answers provide you with a random string consisting of characters 0-9, a-z, A-Z: Here is a working solution which will give you approx. 4.5231285e+74 keys:</p>
<pre><code>import random, string
x = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))
print(x)
</code></pre>
<p>It is also very readable without knowing ASCII codes by heart.</p>
<p>There is an even shorter version since <code>python 3.6.2</code>:</p>
<pre><code>import random, string
x = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this:</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; ''.join(random.choice('0123456789ABCDEF') for i in range(16))
'E2C6B2E19E4A7777'
</code></pre>
<p>There is no guarantee that the keys generated will be unique so you should be ready to retry with a new key in the case the original insert fails. Also, you might want to consider using a deterministic algorithm to generate a string from an auto-incremented id instead of using random values, as this will guarantee you uniqueness (but it will also give predictable keys).</p>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at the <a href="http://docs.python.org/library/uuid.html" rel="noreferrer">uuid module</a> (Python 2.5+).</p>
<p>A quick example:</p>
<pre><code>&gt;&gt;&gt; import uuid
&gt;&gt;&gt; uid = uuid.uuid4()
&gt;&gt;&gt; uid.hex
'df008b2e24f947b1b873c94d8a3f2201'
</code></pre>
<p>Note that the OP asked for a 16-character alphanumeric string, but UUID4 strings are 32 characters long. You should not truncate this string, instead, use the complete 32 characters.</p>
</div>
<div class="post-text" itemprop="text">
<p>For random numbers a good source is <code>os.urandom</code>:</p>
<pre><code> &gt;&gt; import os
 &gt;&gt; import hashlib
 &gt;&gt; random_data = os.urandom(128)
 &gt;&gt; hashlib.md5(random_data).hexdigest()[:16]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; ''.join(random.sample(map(chr, range(48, 57) + range(65, 90) + range(97, 122)), 16))
'CDh0geq3NpKtcXfP'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This value is incremented by 1 on each call (it wraps around).  Deciding where the best place to store the value will depend on how you are using it.  You may find <a href="http://blogs.msdn.com/oldnewthing/archive/2008/06/27/8659071.aspx" rel="nofollow noreferrer">this</a> explanation of interest, as it discusses not only how Guids work but also how to make a smaller one.</p>
<p>The short answer is this:
Use some of those characters as a timestamp and the other characters as a "uniquifier," a value increments by 1 on each call to your uid generator.</p>
</div>
<div class="post-text" itemprop="text">
<p>simply use python inbuilt <strong>uuid</strong> : </p>
<pre><code>import uuid
print uuid.uuid4().hex[:16].upper()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.6, released in December 2016, the <code>secrets</code> module was introduced.</p>
<p>You can now generate a random token this way : </p>
<pre><code>import secrets

secrets.token_hex(16)
</code></pre>
<p>From the Python docs :</p>
<blockquote>
<p>The <code>secrets</code> module is used for generating cryptographically strong
  random numbers suitable for managing data such as passwords, account
  authentication, security tokens, and related secrets.</p>
<p>In particularly, <code>secrets</code> should be used in preference to the default
  pseudo-random number generator in the <code>random</code> module, which is designed
  for modelling and simulation, not security or cryptography.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/secrets.html" rel="nofollow noreferrer">https://docs.python.org/3/library/secrets.html</a></p>
</div>
<div class="post-text" itemprop="text">
<h1>Simply use python builtin uuid:</h1>
<p>If UUIDs are okay for your purposes use the built in <a href="http://docs.python.org/2/library/uuid.html" rel="nofollow">uuid</a> package.</p>
<h2>One Line Solution:</h2>
<pre><code>&gt;&gt;&gt; import uuid
&gt;&gt;&gt; str(uuid.uuid4().get_hex().upper()[0:16])
'40003A9B8C3045CA'
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python">Random string generation with upper case letters and digits in Python</a></span>
<span class="comment-copy">random is not random but pseudo-random according to the documentation. Please use os.urandom instead.</span>
<span class="comment-copy">@prometheus. is <code>os.urandom</code> not psuedo-random?</span>
<span class="comment-copy">I was responding to Mark Byers loose usage of the term "random values". <code>os.urandom</code> is still pseudo-random, but cryptographically secure pseudo-random, which makes it much more suitable for a wide range of use cases compared to <code>random</code>.</span>
<span class="comment-copy">@nikola its doesnt really matter if the keys are only pseudo random, they are used for indexing.</span>
<span class="comment-copy">Perhaps obvious, but 'deterministic' doesn't mean unique, you have to actually check that the algorithm has a very long repetition period. <code>get_key = lambda n: n % 10</code> is deterministic, but not unique for long.</span>
<span class="comment-copy">This is 32 characters, and truncation of Guids is unsafe.</span>
<span class="comment-copy">True (about the truncation). On the other hand: I'd just store 32 characters (unless you have a very specific reason to only store 16).</span>
<span class="comment-copy">@Brian Hi, I need to know why guids is not safe? do you have some reference?</span>
<span class="comment-copy">@AdiyatMubarak: Fundamentally, you don't need a reference.   Guids are documented as being unique.   Half of a Guid is not documented as being unique.   That said, <a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823" rel="nofollow noreferrer">blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823</a> runs through what happens when you truncate one particular GUID algorithm .</span>
<span class="comment-copy">I forgot the so much great urandom function :V and that's nice, better than adding charsets into a string then loop then. Builtin ;)</span>
<span class="comment-copy">this has been mentioned in other answers too, you should not truncate the md5 hash.</span>
<span class="comment-copy">@bman: I'm aware that there a serious issues truncating vertan UUIDs because the randomness is not linearly distributed. vor MD5 this should not be an issue.</span>
<span class="comment-copy">Your solution would omit characters 9, Z and z. Also, sample() chooses every character only once. So it would give you a lot less permutations. This would give you a string of 16 random digits and upper/lower case letters: <code>''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(6666))</code></span>
<span class="comment-copy">Is this correct then why minus votes...?</span>
<span class="comment-copy">UUID is 32 characters length, by using only characters from 0 to 15, you will get duplicates.</span>
<span class="comment-copy"><a href="https://blogs.msdn.microsoft.com/oldnewthing/20080627-00/?p=21823" rel="nofollow noreferrer">GUIDs are globally unique, but substrings of GUIDs aren't</a></span>
