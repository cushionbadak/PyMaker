<div class="post-text" itemprop="text">
<p>In Python 3, when defining a subclass, why do you need to use <code>cls</code> as the first argument of <code>__new__</code>, but not to use <code>self</code> as the first argument of <code>__init__</code>?</p>
<p>An example:</p>
<pre><code>class MyClass(object):
    def __new__(cls, *args, **kwargs):
        return super(MyClass, cls).__new__(cls, *args, **kwargs) # with `cls`
    def __init__(self, *args, **kwargs):
        return super(MyClass, self).__init__(*args, **kwargs) # without `self`
</code></pre>
<p>When I compared these functions I got more confused:</p>
<pre><code>&gt;&gt;&gt; cls = object
&gt;&gt;&gt; self = cls()
&gt;&gt;&gt; cls.__new__ is self.__new__
True
&gt;&gt;&gt; cls.__init__ is self.__init__
False
&gt;&gt;&gt; self.__init__()
&gt;&gt;&gt; cls.__init__()
Traceback (most recent call last): ...
</code></pre>
<p>So, what are the differences between <code>__new__</code> and <code>__init__</code> behind these results? Which methods are bound and which are free? Why are you able to call <code>self.__init__()</code> but not <code>cls.__init__()</code>? Is <code>cls.__init__</code> a method defined in <code>cls</code> itself or in its metaclass?</p>
</div>
<div class="post-text" itemprop="text">
<p>The biggest part of the picture you're probably missing is that <code>__new__</code> is a staticmethod, <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">special-cased</a> to be one even if you don't use the <code>@staticmethod</code> decorator.</p>
<p>When calling a method through <code>super()</code>, <code>super()</code> performs the same kind of argument binding that would be performed normally for that kind of method (using the <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor protocol</a>). For a staticmethod like <code>__new__</code>, that means no arguments are automatically bound, so <code>cls</code> has to be passed explicitly. For an instance method like <code>__init__</code>, that means <code>self</code> is bound automatically, which is why you don't have to pass <code>self</code> to <code>super().__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The main purpose of <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> is to allocate a new instance of the class, while <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer"><code>__init__</code></a>'s job is to set up an existing instance.</p>
<p>According to the docs:</p>
<blockquote>
<p><code>__new__()</code> is a static method (special-cased so you need not declare it as such)</p>
</blockquote>
<p><code>__init__</code> on the other hand, is a proper instance method. It can be called multiple times on the same instance, by the way.</p>
<p>That should be enough to explain your terminal session:</p>
<pre><code>&gt;&gt;&gt; cls = object
&gt;&gt;&gt; self = cls()
</code></pre>
<p>You just called <code>object.__call__</code>, which essentially does</p>
<pre><code>self = cls.__new__()
if isinstance(self, cls):
    cls.__init__(self)
return self
</code></pre>
<p>Notice that the return value of <code>__new__</code> is not required to be an instance of the class it belongs to, but <code>__init__</code> is called only if it is. In your case, it is.</p>
<pre><code>&gt;&gt;&gt; cls.__new__ is self.__new__
True
</code></pre>
<p><code>__new__</code> is a static method, so attempting to bind it to the instance does nothing: it stays a class method. This is the same reason that you have to pass <code>cls</code> explicitly when calling <code>super().__new__</code>: it's the same free function, unbound to either class or instance.</p>
<pre><code> &gt;&gt;&gt; cls.__init__ is self.__init__
 False
</code></pre>
<p>Not only are these not the same thing, but their types are different. <code>cls.__init__</code> is a regular function. <code>self.__init__</code> is a bound method which lacks the first parameter of <code>cls.__init__</code>.</p>
<pre><code>&gt;&gt;&gt; self.__init__()
</code></pre>
<p>This has already been called, but for <code>object</code>, it's a no-op you can call as many times as you like. Notice that the first parameter is not being passed in, being as it is a bound method.</p>
<pre><code>&gt;&gt;&gt; cls.__init__()
</code></pre>
<p>This is calling the raw <code>__init__</code> function, which requires that the <code>self</code> parameter be passed in. Since you don't do that, it raises. Try this instead:</p>
<pre><code>&gt;&gt;&gt; cls.__init__(self)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>cls</code> stands for class itself, while <code>self</code> stands for object itself. These are just conventions.<br/>
The <code>__new__</code> method is called <strong>before</strong> the object is created, in fact, <code>__new__</code>should create the object and return it. Therefore, it needs a <strong>class</strong> to create object. After that, the <code>__init__</code> is called to <strong>initialize</strong> the object, so it needs the object as the first argument.  </p>
<p>For example:</p>
<pre><code>class MyClass:
    def __new__(cls, *args, **kwargs):
        # cls == MyClass
        return super().__new__(cls, *args, **kwargs)
        # cls here is because __new__ is staticmethods so you have to pass the cls explicitly

        # You can't use cls() here because it will call this methods again and again
        # causing recusion error

    def __init__(self, *args, **kwargs):
        # Here self is the instance(or object) of MyClass
        # So you can initialize it by self.xxx
        self.xxx = 'xxx'
</code></pre>
<p><code>__new__</code> is static method, so the class and instance share the same <code>__new__</code> method. <code>__init__</code> is the method of instance. If you want to call it via class, you need to pass the instance as the first argument explicitly.</p>
<pre><code>cls.__init__(self)
</code></pre>
<p>Anything in Python is object, including the class itself. So for class, it has its own <code>__new__</code> and <code>__init__</code> which are used by <code>metaclass</code> to <strong>create</strong> class and <strong>initialize</strong> class.<br/>
These are meta programming of Python, I suggest to read the ninth chapter of Python Cookbook.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/35452178/what-can-init-do-that-new-cannot">What can `__init__` do that `__new__` cannot?</a></span>
<span class="comment-copy">@TheExorcist: Not a duplicate. This question is completely different.</span>
<span class="comment-copy">I also see you are using new and init as same, then how can you see the difference,.Dont use it for initalize rather change the way of initalize.</span>
<span class="comment-copy">Given that this is not a trivial subject, and you've made some effort to play with it and understand what's going on, +1</span>
<span class="comment-copy">I was wondering why <code>__new__</code> is made a static but not a class method, while you still have to pass a class argument.</span>
<span class="comment-copy">@Cyker: With a staticmethod, you can do stuff like <code>object.__new__(Whatever)</code>. It'd be a lot more awkward to replicate that functionality with a classmethod.</span>
<span class="comment-copy">But why <code>object.__new__(Whatever)</code> while you can <code>Whatever.__new__()</code>?</span>
<span class="comment-copy">@Cyker: Because you want to use <code>object</code>'s <code>__new__</code> method instead of <code>Whatever</code>'s.</span>
<span class="comment-copy">Then why don't you want to use <code>object</code>'s <code>__init__</code> method instead of <code>Whatever</code>'s?</span>
<span class="comment-copy">If <code>self.__init__()</code> invokes <code>__init__</code> method defined in <code>type(self)</code>, why wouldn't <code>cls.__init__()</code> invoke <code>__init__</code> method defined in <code>type(cls)</code>? Isn't a class object also an object?</span>
<span class="comment-copy">@Cyker. Interesting point. Because a method is a non-data descriptor, so any attribute on the instance with the same name will override it. If you do <code>self.__init__ = some_other_function</code>, you will see that the other function gets called when you do <code>self.__init__</code>. If you hadn't defined <code>__init__</code> in the class, it <i>would</i> use the one in the metaclass. It's interesting to note that you can't override dunder methods like that on the instance level because dunder methods are always called as <code>type(self).__dunder__(self, ...)</code> when used as operators.</span>
<span class="comment-copy">I think if I don't define <code>__init__</code> in the class, it would use the one in its superclass. Only if the superclass doesn't have this method it would use the one from its metaclass. But <code>object.__init__</code> always exists so the one in its metaclass won't be used.</span>
<span class="comment-copy">@Cyker correct. Object does not have a superclass, which simplifies that case though.</span>
