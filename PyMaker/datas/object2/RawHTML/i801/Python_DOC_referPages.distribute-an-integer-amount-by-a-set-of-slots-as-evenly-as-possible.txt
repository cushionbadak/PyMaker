<div class="post-text" itemprop="text">
<p>I am trying to figure an elegant way of implementing the distribution of an amount into a given set of slots in python.</p>
<p>For example:</p>
<p>7 oranges distributed onto 4 plates would return:</p>
<pre><code>[2, 2, 2, 1]
</code></pre>
<p>10 oranges across 4 plates would be:</p>
<pre><code>[3, 3, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Conceptually, what you want to do is compute <code>7 // 4 = 1</code> and <code>7 % 4 = 3</code>. This means that all the plates get 1 whole orange. The remainder of 3 tells you that three of the plates get an extra orange.</p>
<p>The <a href="https://docs.python.org/3/library/functions.html#divmod" rel="noreferrer"><code>divmod</code></a> builtin is a shortcut for getting both quantities simultaneously:</p>
<pre><code>def distribute(oranges, plates):
    base, extra = divmod(oranges, plates)
    return [base + (i &lt; extra) for i in range(plates)]
</code></pre>
<p>With your example:</p>
<pre><code>&gt;&gt;&gt; distribute(oranges=7, plates=4)
[2, 2, 2, 1]
</code></pre>
<p>For completeness, you'd probably want to check that <code>oranges</code> is non-negative and <code>plates</code> is positive. Given those conditions, here are some additional test cases:</p>
<pre><code>&gt;&gt;&gt; distribute(oranges=7, plates=1)
[7]

&gt;&gt;&gt; distribute(oranges=0, plates=4)
[0, 0, 0, 0]

&gt;&gt;&gt; distribute(oranges=20, plates=2)
[10, 10]

&gt;&gt;&gt; distribute(oranges=19, plates=4)
[5, 5, 5, 4]

&gt;&gt;&gt; distribute(oranges=10, plates=4)
[3, 3, 2, 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You want to look at <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" rel="noreferrer">Bresenham's algorithm</a> for drawing lines (i.e. distributing X pixels on a Y range as "straightly" as possible; the application of this to the distribution problem is straightforward).</p>
<p>This is an implementation I found <a href="http://www.roguebasin.com/index.php?title=Bresenham%27s_Line_Algorithm" rel="noreferrer">here</a>:</p>
<pre><code>def get_line(start, end):
    """Bresenham's Line Algorithm
    Produces a list of tuples from start and end

    &gt;&gt;&gt; points1 = get_line((0, 0), (3, 4))
    &gt;&gt;&gt; points2 = get_line((3, 4), (0, 0))
    &gt;&gt;&gt; assert(set(points1) == set(points2))
    &gt;&gt;&gt; print points1
    [(0, 0), (1, 1), (1, 2), (2, 3), (3, 4)]
    &gt;&gt;&gt; print points2
    [(3, 4), (2, 3), (1, 2), (1, 1), (0, 0)]
    """
    # Setup initial conditions
    x1, y1 = start
    x2, y2 = end
    dx = x2 - x1
    dy = y2 - y1

    # Determine how steep the line is
    is_steep = abs(dy) &gt; abs(dx)

    # Rotate line
    if is_steep:
        x1, y1 = y1, x1
        x2, y2 = y2, x2

    # Swap start and end points if necessary and store swap state
    swapped = False
    if x1 &gt; x2:
        x1, x2 = x2, x1
        y1, y2 = y2, y1
        swapped = True

    # Recalculate differentials
    dx = x2 - x1
    dy = y2 - y1

    # Calculate error
    error = int(dx / 2.0)
    ystep = 1 if y1 &lt; y2 else -1

    # Iterate over bounding box generating points between start and end
    y = y1
    points = []
    for x in range(x1, x2 + 1):
        coord = (y, x) if is_steep else (x, y)
        points.append(coord)
        error -= abs(dy)
        if error &lt; 0:
            y += ystep
            error += dx

    # Reverse the list if the coordinates were swapped
    if swapped:
        points.reverse()
    return points
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See also <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.distribute" rel="nofollow noreferrer"><code>more_itertools.distribute</code></a>, a third-party tool and its <a href="https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#distribute" rel="nofollow noreferrer">source code</a>.</p>
<p><strong>Code</strong></p>
<p>Here we distributes <code>m</code> items into <code>n</code> bins, one-by-one, and count each bin.</p>
<pre><code>import more_itertools as mit


def sum_distrib(m, n):
    """Return an iterable of m items distributed across n spaces."""
    return [sum(x) for x in mit.distribute(n, [1]*m)]
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>sum_distrib(10, 4)
# [3, 3, 2, 2]

sum_distrib(7, 4)
# [2, 2, 2, 1]

sum_distrib(23, 17)
# [2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
</code></pre>
<hr/>
<p><strong>Example</strong></p>
<p>This idea is akin to distributing a deck of cards among players.  Here is an initial game of <a href="https://en.wikipedia.org/wiki/Slapjack" rel="nofollow noreferrer">Slapjack</a></p>
<pre><code>import random
import itertools as it


players = 8
suits = list("♠♡♢♣")
ranks = list(range(2, 11)) + list("JQKA")
deck = list(it.product(ranks, suits))
random.shuffle(deck)

hands = [list(hand) for hand in mit.distribute(players, deck)]
hands
# [[('A', '♣'), (9, '♠'), ('K', '♣'), (7, '♢'), ('A', '♠'), (5, '♠'), (2, '♠')],
#  [(6, '♣'), ('Q', '♠'), (5, '♢'), (5, '♡'), (3, '♡'), (8, '♡'), (7, '♣')],
#  [(7, '♡'), (9, '♢'), (2, '♢'), (9, '♡'), (7, '♠'), ('K', '♠')],
#   ...]
</code></pre>
<p>where the cards are distributed "as equally as possible between all [8] players":</p>
<pre><code>[len(hand) for hand in hands]
# [7, 7, 7, 7, 6, 6, 6, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Mad Physicist answer is perfect. But if you want to distribute the oranges uniformley on the plates (eg. <code>2 3 2 3</code> vs <code>2 2 3 3</code> in the 7 oranges and 4 plates example), here's an simple idea.</p>
<h1>Easy case</h1>
<p>Take an example with 31 oranges and 7 plates for example.</p>
<p><em>Step 1</em>: You begin like Mad Physicist with an euclidian division: <code>31 = 4*7 + 3</code>. Put 4 oranges in each plate and keep the remaining 3. </p>
<pre><code>[4, 4, 4, 4, 4, 4, 4]
</code></pre>
<p><em>Step 2</em>: Now, you have more plates than oranges, and that's quite different: you have to distribute plates among oranges. You have 7 plates and 3 oranges left: <code>7 = 2*3 + 1</code>. You will have 2 plates per orange (you have a plate left, but it doesn't matter). Let's call this <code>2</code> the <code>leap</code>. Start at <code>leap/2</code> will be pretty :</p>
<pre><code>[4, 5, 4, 5, 4, 5, 4]
</code></pre>
<h1>Not so easy case</h1>
<p>That was the easy case. What happens with 34 oranges and 7 plates? </p>
<p><em>Step 1</em>: You still begin like Mad Physicist with an euclidian division: <code>34 = 4*7 + 6</code>. Put 4 oranges in each plate and keep the remaining 6. </p>
<pre><code>[4, 4, 4, 4, 4, 4, 4]
</code></pre>
<p><em>Step 2</em>: Now, you have 7 plates and 6 oranges left: <code>7 = 1*6 + 1</code>. You will have one plate per orange. But wait.. I don't have 7 oranges! Don't be afraid, I lend you an apple:</p>
<pre><code>[5, 5, 5, 5, 5, 5, 4+apple]
</code></pre>
<p>But if you want some uniformity, you have to place that apple elsewhere! Why not try distribute apples like oranges in the first case? 7 plates, 1 apple : <code>7 = 1*7 + 0</code>. The <code>leap</code> is 7, start at <code>leap/2</code>, that is 3:</p>
<pre><code>[5, 5, 5, 4+apple, 5, 5, 5]
</code></pre>
<p><em>Step 3</em>. You owe me an apple. Please give me back my apple :</p>
<pre><code>[5, 5, 5, 4, 5, 5, 5]
</code></pre>
<p>To summarize : if you have few oranges left, you distribute the peaks, else you distribute the valleys. (<em>Disclaimer: I'm the author of this "algorithm" and I hope it is correct, but please correct me if I'm wrong !</em>)</p>
<h1>The code</h1>
<p>Enough talk, the code:</p>
<pre><code>def distribute(oranges, plates):
    base, extra = divmod(oranges, plates) # extra &lt; plates
    if extra == 0:
        L = [base for _ in range(plates)]
    elif extra &lt;= plates//2:
        leap = plates // extra
        L = [base + (i%leap == leap//2) for i in range(plates)]
    else: # plates/2 &lt; extra &lt; plates
        leap = plates // (plates-extra) # plates - extra is the number of apples I lent you
        L = [base + (1 - (i%leap == leap//2)) for i in range(plates)]
    return L
</code></pre>
<p>Some tests:</p>
<pre><code>&gt;&gt;&gt; distribute(oranges=28, plates=7)
[4, 4, 4, 4, 4, 4, 4]
&gt;&gt;&gt; distribute(oranges=29, plates=7)
[4, 4, 4, 5, 4, 4, 4]
&gt;&gt;&gt; distribute(oranges=30, plates=7)
[4, 5, 4, 4, 5, 4, 4]
&gt;&gt;&gt; distribute(oranges=31, plates=7)
[4, 5, 4, 5, 4, 5, 4]
&gt;&gt;&gt; distribute(oranges=32, plates=7)
[5, 4, 5, 4, 5, 4, 5]
&gt;&gt;&gt; distribute(oranges=33, plates=7)
[5, 4, 5, 5, 4, 5, 5]
&gt;&gt;&gt; distribute(oranges=34, plates=7)
[5, 5, 5, 4, 5, 5, 5]
&gt;&gt;&gt; distribute(oranges=35, plates=7)
[5, 5, 5, 5, 5, 5, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure how this works. But it returns the exact same results </p>
<pre><code>a = 23
b = 17
s = pd.Series(pd.cut(mylist, b), index=mylist)
s.groupby(s).size().values
</code></pre>
</div>
<span class="comment-copy">@Lserni. This method guarantees that the difference between the maximum and minimum plate is at most 1. What additional criteria did you have for evenness?</span>
<span class="comment-copy">While I agree that the distribution of the remainder could be improved from "shoved to the left", OP does nothing to lead me to believe that that's something they want.</span>
<span class="comment-copy">Actually the OP's second example indicates that your solution - apart from simplicity - is the one yielding the expected results (hadn't noticed it before).</span>
<span class="comment-copy">For a more clearly specified problem, this would be the better answer.</span>
<span class="comment-copy">Mad Physicist: not sure I agree with you. Elegance is a bit subjective criterion, but for a layman this is not as elegant :)</span>
<span class="comment-copy">@gmagno. It's not just about elegance. This solution actually distributes the bins differently than mine. If there was an additional requirement to maintain as uniform a distribution across the peaks as possible, mine wouldn't cut it at all. But yes, this is more cumbersome and I'm guessing OP wanted the beginner version.</span>
