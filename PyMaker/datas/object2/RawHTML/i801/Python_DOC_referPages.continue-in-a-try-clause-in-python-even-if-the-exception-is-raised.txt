<div class="post-text" itemprop="text">
<p>Is there any way to continue code execution in a try clause, even when the exception is raised?</p>
<p>This is the code example.</p>
<pre><code>outer_margin = 0.125  # Default Amazon
safe_zone = 0.25  # Default Amazon
safe_spine = 0.0625  # Default Amazon
if custom_measure is not None:
    if isinstance(custom_measure, dict):
        try:
            outer_margin = custom_measure["outer_margin"]
            safe_zone = custom_measure["safe_zone"]
            safe_spine = custom_measure["safe_spine"]
        except KeyError as e:
            logger.warning("Key {} not found, default value used.".format(e))
</code></pre>
<p>All three values are optional, so the key <code>outer_margin</code> may not exist, but <code>safe_zone</code> may be present. I would like to reach <code>safe_zone</code> even if calling <code>outer_margin</code> raises an exception. Is there any way to do this in a single try/except block? Something like:</p>
<pre><code># Not valid syntax
try:
    outer_margin = custom_measure["outer_margin"]
try:
    safe_zone = custom_measure["safe_zone"]
except KeyError as e:
    pass
</code></pre>
<p>I already found a different solution to the case in the example, but now I am curious to know if there is a way to continue down one try/except block, even if the exception is raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get</code></a> instead of catching the <code>KeyError</code> exception.</p>
<pre><code>if isinstance(custom_measure, dict):
    outer_margin = custom_measure.get("outer_margin")
    safe_zone = custom_measure.get("safe_zone")
    safe_spine = custom_measure.get("safe_spine")
</code></pre>
<p>if <code>"outer_margin"</code> does not exist in <code>custom_measure</code> it will be set to <code>None</code>.</p>
<p>You can also set another default value than <code>None</code> like this.</p>
<pre><code>outer_margin = custom_measure.get("outer_margin", 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you really need the log, refactor the <code>try/except</code> out of there:</p>
<pre><code>def get_with_warning(data, key, default):
    if key in data:
        return data[key]
    else:
        logger.warning("Key {} not found, default value used.".format(key))
        return default

outer_margin = get_with_warning(custom_measure, "outer_margin", 0.125)
safe_zone = get_with_warning(custom_measure, "safe_zone", 0.25)
safe_spine = get_with_warning(custom_measure, "safe_spine", 0.0625)
</code></pre>
<p>If not, then it's as easy as this:</p>
<pre><code>outer_margin = custom_measure.get("outer_margin", 0.125)
safe_zone = custom_measure.get("safe_zone", 0.25)
safe_spine = custom_measure.get("safe_spine", 0.0625)
</code></pre>
</div>
<span class="comment-copy">To continue you either add code in <code>excpet</code> or <code>else</code> or <code>finally</code> block.</span>
<span class="comment-copy">Seems like it'd be much easier to just use <code>custom_measure.get</code>.</span>
<span class="comment-copy">Is not possible to put <code>safe_zone = custom_measure["safe_zone"]</code> before <code>outer_margin = custom_measure["outer_margin"]</code> so that the first got executed anyway?</span>
<span class="comment-copy">@CarlH: Off-topic nitpick, but: a <code>try</code> doesn't have to have an <code>except</code> if it has a <code>finally</code>.</span>
<span class="comment-copy">You can nest another <code>try</code> block in the <code>except</code> clause.</span>
