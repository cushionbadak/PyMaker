<div class="post-text" itemprop="text">
<p>I am trying to make the below code asynchronous:</p>
<pre><code>import asyncio
import random

async def count():
    l = []
    for i in range(10000000):
        l.append(i)
    return random.choice(l)

async def long_task1():
    print('Starting task 1...')
    task_output = await count()
    print('Task 1 output is {}'.format(task_output ))


async def long_task2():
    print('Starting task 2...')
    task_output = await count()
    print('Task 2 output is {}'.format(task_output ))

async def main():
    await asyncio.gather(long_task1(), long_task2())

if __name__ == '__main__':
    asyncio.get_event_loop().run_until_complete(main())
</code></pre>
<p>Currently it will work synchronously.</p>
<p>Is it because the <code>count</code> function is lacking <code>await</code> statement?</p>
<p>I have tried reworking the function to include <code>await</code>:</p>
<pre><code>async def count():
    l = []
    for i in range(10000000):
        l.append(i)
    choice = await random.choice(l)
    return choice
</code></pre>
<p>and it will start asynchronously (both <code>Starting task 1...</code> and <code>Starting task 2...</code> will get printed one after another), but then I get an error:</p>
<blockquote>
<p>TypeError: object int can't be used in 'await' expression</p>
</blockquote>
<p>I understand that the error happened because the result of <code>random.choice(l)</code> is not an awaitable (a coroutine), but I don't know how to fix this without running in circles. Do I need to somehow refactor the for loop into a couroutine on its own?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is it because the count function is lacking <code>await</code> statement?</p>
</blockquote>
<p>In short, yes, you have identified the issue correctly. To get parallel execution of tasks, you need not only to specify <code>async def</code>, but also to await something that suspends execution, thus returning control to the event loop. In asyncio that is typically the kind of call that would block a synchronous program, such as a sleep or a read from a socket that is not yet ready for reading.</p>
<p>To force a <a href="https://github.com/python/asyncio/issues/284" rel="nofollow noreferrer">temporary suspension</a>, you can add <code>await asyncio.sleep(0)</code> inside the loop in <code>count</code>. Adding <code>await</code> in front of an ordinary function such as <code>random.choice</code>, doesn't work because <code>await</code> requires an object that implements the awaitable interface, and in your code <code>random.choice</code> just returns an integer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code calls a <code>gather</code> that runs both <code>long_task1</code> and <code>long_task2</code> concurrently. Then you call an await on <code>count</code> in each function. But this will  <code>await</code> on that subroutine to finish. So the overall subroutine will still finish before the next subroutine begins. You need a function to suspend the entire task. I created two ways to circumvent this. Both involve creating new tasks. </p>
<p>Creating a new subroutine: </p>
<pre><code>async def count():
   l = []
   await asyncio.wait_for(loopProcess(l), timeout=1000000.0)
   return random.choice(l)

async def loopProcess(l):
   for i in range(10000000):
      l.append(i)
</code></pre>
<p>You could also keep your <code>count</code> function the same as the original code and change your <code>long_task(1/2)</code> like this to make <code>count()</code> a new task:</p>
<pre><code>async def long_task1():
   print('Starting task 1...')
   task_output = await asyncio.shield(count())
   print('Task 1 output is {}'.format(task_output ))


async def long_task2():
   print('Starting task 2...')
   task_output = await asyncio.shield(count())
   print('Task 2 output is {}'.format(task_output ))
</code></pre>
<p>You can also use <code>create_task</code> if you have python 3.7. </p>
<p>Source: <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">https://docs.python.org/3/library/asyncio-task.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>For asyncio to work properly, you should not have any cpu intensive task (tight big for loop) in the event loop. As there is no way to get out of the for loop. If you use an explicit <code>asyncio.sleep</code> inside the loop, you are just going in and out of the coroutine unnecessarily and slowing the entire thing. If your goal is just to see how asyncio works, it is fine. </p>
<p>But in real world, if you have a cpu intensive task, you have two options</p>
<ol>
<li>Use multiprocessing and delegate the task to a different process.</li>
<li>Use a native code binding that releases GIL and uses threads.</li>
</ol>
<p>As the name suggests, the library is for asynchronous io. <code>async"io"</code></p>
</div>
<span class="comment-copy">I assume the loop in <code>count</code> is just an example and not your actual code ?</span>
<span class="comment-copy">Well, this is an exercise I wrote for myself to get a grasp of asyncio. So actual code I guess:  a simulation of a long running task.</span>
<span class="comment-copy">@I Funball: yes, but I don't want the <code>asyncio.sleep</code> in my code, I want the for loop. The <code>asyncio.sleep</code> works because it is an awaitable. I am looking for a way to turn the for loop into an awaitable.</span>
<span class="comment-copy">@barciewicz see my edits. I added a way to not change your <code>count()</code> function at all as well as the way to refactor the for loop into a coroutine.</span>
<span class="comment-copy">@barciewicz <code>await asyncio.sleep(0)</code> <a href="https://github.com/python/asyncio/issues/284" rel="nofollow noreferrer"><b>is</b></a> the way to turn a <code>for</code> loop (or any long-running code in an <code>async def</code>) into an awaitable that actually suspends. If you never suspend, you're not giving asyncio a chance to do its job. Normal asyncio code tends to be network-oriented, so it never has a need to do this.</span>
<span class="comment-copy">Good answer, he explicitly said without using sleep() however. But the overall point is useful.</span>
<span class="comment-copy">@IFunball I didn't see that, but still, <code>sleep(0)</code> is kind of special in that it doesn't actually sleep, it just yields control to the event loop. See e.g. this old <a href="https://github.com/python/asyncio/issues/284" rel="nofollow noreferrer">github issue</a> or this <a href="https://bugs.python.org/issue34476" rel="nofollow noreferrer">doc issue</a>. If the code doesn't relinquish control to the event loop anywhere, one must either execute it with <code>run_in_executor</code> or insert explicit (fake) yield points, there's no way around that.</span>
<span class="comment-copy">Yes, I agree. I think it is the best solution. I only say it because I used sleep in my original solution and then he said he didn't want sleep. It's one of the comments under the original post.</span>
<span class="comment-copy">@barciewicz Yes, you will need to restructure your code to yield less often, or switch to a non-async function executed using <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow noreferrer"><code>run_in_executor</code></a>. Since your code is not solving a concrete problem, one cannot tell what would be the better approach.</span>
<span class="comment-copy">Regarding the second question, the linked code runs because it defines an <code>async def randint</code> - but that accomplishes nothing, since there is no <code>await</code> inside of it. If you look carefully, you will notice that its callers are always awaiting something in addition to <code>randint()</code>, such as <code>asyncio.sleep()</code> or <code>randsleep()</code>. Without it the author would face the same problem your code is facing.</span>
