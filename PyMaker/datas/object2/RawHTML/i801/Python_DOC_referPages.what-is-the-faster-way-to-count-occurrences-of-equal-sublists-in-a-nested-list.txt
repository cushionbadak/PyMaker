<div class="post-text" itemprop="text">
<p>I have a list of lists in Python and I want to (as fastly as possible : very important...) append to each sublist the number of time it appear into the nested list.</p>
<p>I have done that with some <code>pandas</code> data-frame, but this seems to be very slow and I need to run this lines on very very large scale. <em>I am completely willing to sacrifice nice-reading code to efficient one.</em> </p>
<p>So for instance my nested list is here:</p>
<pre><code>l = [[1, 3, 2], [1, 3, 2] ,[1, 3, 5]]
</code></pre>
<p>I need to have:</p>
<pre><code>res = [[1, 3, 2, 2], [1, 3, 5, 1]]
</code></pre>
<p><strong>EDIT</strong></p>
<p>Order in <code>res</code> does not matter at all.</p>
</div>
<div class="post-text" itemprop="text">
<p>If order does not matter you could use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noreferrer">collections.Counter</a> with <a href="https://www.python.org/dev/peps/pep-3132/" rel="noreferrer">extended iterable unpacking</a>, as a variant of @Chris_Rands solution:</p>
<pre><code>from collections import Counter

l = [[1, 3, 2], [1, 3, 2] ,[1, 3, 5]]

result = [[*t, count] for t, count in Counter(map(tuple, l)).items()]
print(result)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[1, 3, 5, 1], [1, 3, 2, 2]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is quite an odd output to <em>want</em> but it is of course possible. I suggest using <code>collections.Counter()</code>, no doubt others will make different suggestions and a <code>timeit</code> style comparison would reveal the fastest of course for particular data sets:</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; l = [[1, 3, 2], [1, 3, 2] ,[1, 3, 5]]
&gt;&gt;&gt; [list(k) + [v] for k, v in Counter(map(tuple,l)).items()]
[[1, 3, 2, 2], [1, 3, 5, 1]]
</code></pre>
<p>Note to preserve the insertion order prior to CPython 3.6 / Python 3.7, use <a href="https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes" rel="noreferrer">the <code>OrderedCounter</code> recipe</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If <code>numpy</code> is an option, you could use <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.unique.html" rel="nofollow noreferrer"><code>np.unique</code></a> setting axis to <code>0</code> and <code>return_counts</code> to <code>True</code>, and concatenate the unique rows and counts using <a href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.vstack.html" rel="nofollow noreferrer"><code>np.vstack</code></a>:</p>
<pre><code>l = np.array([[1, 3, 2], [1, 3, 2] ,[1, 3, 5]])
x, c = np.unique(l, axis=0, return_counts=True)
np.vstack([x.T,c]).T

array([[1, 3, 2, 2],
       [1, 3, 5, 1]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your items are mutable objects and you have to convert them to an immutable object to be used as a mapping key, an optimized approach is to use <code>defaultdict()</code> as following:</p>
<pre><code>In [5]: from collections import defaultdict

In [6]: d = defaultdict(int)

In [7]: for sub in l:
   ...:     d[tuple(sub)] += 1
   ...:     

In [8]: d
Out[8]: defaultdict(int, {(1, 3, 2): 2, (1, 3, 5): 1})
</code></pre>
<p>This will give you a dictionary of your sub-lists as the key and their counts as the value.</p>
<p>Another way is to create your own dictionary object:</p>
<pre><code> In [9]: class customdict(dict):
    ...:        
    ...:     def __getitem__(self, key):
    ...:         try:
    ...:             val = super(customdict, self).__getitem__(key)
    ...:         except KeyError:
    ...:             self[key] = [*key, 0]
    ...:         else:
    ...:             val[-1] += 1
    ...:             self[key] = val
    ...:             return val
    ...:         
    ...:    

 In [10]: m = customdict()

 In [11]: for sub in l:
     ...:     m[tuple(sub)]
     ...:     

 In [12]: 

 In [12]: m
 Out[12]: {(1, 3, 2): [1, 3, 2, 2], (1, 3, 5): [1, 3, 5, 1]}

 In [13]: m.values()
 Out[13]: dict_values([[1, 3, 2, 2], [1, 3, 5, 1]])
</code></pre>
</div>
<span class="comment-copy">This is a reasonable (although mostly cosmetic) variant of my solution, assuming Python 3 of course</span>
