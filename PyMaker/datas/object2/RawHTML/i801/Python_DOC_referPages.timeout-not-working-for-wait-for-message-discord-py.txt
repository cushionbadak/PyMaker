<div class="post-text" itemprop="text">
<p>The timeout for wait_for_message is not working. I even tried to use <code>timeout = time.time() + 60*15</code> <code>elif time.time() &gt; timeout:</code> instead of <code>elif guess is None:</code> and it still won't time out after 15 minutes. I figured if the while loop is broken by putting <code>winner = guess.author</code> that it would timeout and send the message and send another <code>safe_loop</code> to the channel. Does anyone have a suggestion?</p>
<pre><code>async def safe_loop():
    await client.wait_until_ready()
    channel = client.get_channel("538211206066995230")
    while not client.is_closed:
        x = client.get_all_members()
        for member in x:
            reset_guessesTaken(member, 0)
        answer1 = random.randint(10, 99)
        answer2 = random.randint(10, 99)
        answer3 = random.randint(10, 99)
        answer4 = random.randint(10, 99)
        answer5 = random.randint(10, 99)
        safedollars = random.randint(150, 300)
        safetokens = random.randint(50, 100)
        winner = ''
        await client.send_message(channel, "🏦 CRACK THE SAFE 🏦\n {}, {}, {}, {}, ?\nWhat is the last number?".format(answer1,  answer2, answer3, answer4))
        print(answer5) 
        def guess_check(m):
            return m.content.isdigit()
        while winner == '':
            guess = await client.wait_for_message(timeout=900, channel=channel, check=guess_check)
            if get_guessesTaken(guess.author) == 5:
                await client.send_message(channel, '{} you have already guessed 5 times! Try again in 15 minutes 😰'.format(guess.author.mention))
            elif int(guess.content) == answer5:
                await client.send_message(channel, '{} cracks the safe and finds ${} and {} tokens inside! 🤑🙌\nCheck back in 15 minutes to crack a new safe'.format(guess.author.mention, safedollars, safetokens))
                add_dollars(guess.author, safedollars)
                add_tokens(guess.author, safetokens)
                for member in x:
                    reset_guessesTaken(member, 0)
                winner = guess.author
            elif get_guessesTaken(guess.author) &lt; 5 and int(guess.content) &gt; answer5:
                add_guessesTaken(guess.author, 1)
                await client.send_message(channel, 'That number is too high {}, try again 😕'.format(guess.author.mention))
            elif get_guessesTaken(guess.author) &lt; 5 and int(guess.content) &lt; answer5:
                add_guessesTaken(guess.author, 1)
                await client.send_message(channel, 'That guess is incorrect {}, try again 😕'.format(guess.author.mention))
            else:
                if guess is None:
                    winner = guess.author
                    await client.send_message(channel, 'No one cracked the safe, the number was {}\nCheck back in 15 minutes for a new safe'.format(answer5))
                    for member in x:
                        reset_guessesTaken(member, 0)
        await asyncio.sleep(450)
        await client.send_message(channel, "7 more minutes until a new safe to crack ⏰")
        await asyncio.sleep(450)

client.loop.create_task(safe_loop())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't really do <code>elif int(guess.content) == answer5:</code> or <code>winner = guess.author</code> if <code>guess</code> is <code>None</code> (which is what <a href="https://discordpy.readthedocs.io/en/latest/api.html#discord.Client.wait_for_message" rel="nofollow noreferrer">Client.wait_for_message</a> returns if the message times out  </p>
<p>You have to check if the message timed out without anyone guessing before you check everything else  </p>
<pre><code>    while winner == '':
        guess = await client.wait_for_message(timeout=900, channel=channel, check=guess_check)
        if guess is None:
            #winner = guess.author #guess = None so you're trying to do None.author which doesn't work
            await client.send_message(channel,
                                      'No one cracked the safe, the number was {}\nCheck back in 15 minutes for a new safe'.format(
                                          answer5))
            for member in x:
                reset_guessesTaken(member, 0)

        elif get_guessesTaken(guess.author) == 5:
            await client.send_message(channel, '{} you have already guessed 5 times! Try again in 15 minutes 😰'.format(guess.author.mention))
#etc...
</code></pre>
</div>
<span class="comment-copy">Thanks for the suggestion Tristo. I tried this way as well but it still doesn't seem to ever "timeout" and send the message. The timeout is based on seconds correct? Do I need to break that while loop in order for it to timeout?</span>
<span class="comment-copy">Yes <a href="https://discordpy.readthedocs.io/en/latest/api.html#discord.Client.wait_for_message" rel="nofollow noreferrer">timeout</a> is in seconds, and after 900 seconds of not receiving a message it will return <code>None</code> to <code>guess</code>. What might be happening is since it's taking so long the Task might be getting canceled. Since it's based on <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait_for" rel="nofollow noreferrer">asyncio.wait_for</a> they noted that to avoid cancellation you can try wrapping it in a <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.shield" rel="nofollow noreferrer">shield()</a></span>
<span class="comment-copy">It would time out but wouldn't spit out another loop so i added <code>winner= None</code> under <code>if guess is None:</code> and it now works flawlessly. Thanks again for the suggestions</span>
