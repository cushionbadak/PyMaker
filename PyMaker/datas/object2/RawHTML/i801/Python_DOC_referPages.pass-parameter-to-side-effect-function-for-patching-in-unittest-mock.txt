<div class="post-text" itemprop="text">
<p>I'm using <code>patch</code> from <code>unittest.mock</code> to change the behavior of a remote API call in my test.</p>
<p>I have three different functions that return three different <code>json</code> files that represent the mock data to be returned from the API. For each mock api call, I am setting <code>side_effect</code> to be one of these functions. This pattern isn't DRY, but I don't know how to pass a parameter to a <code>side_effect</code> function.</p>
<p>The three mock api call functions look like this:</p>
<pre><code>def mock_api_call_1():
    with open('path/to/mock_1.json') as f:
        mock_data = json.load(f)
    return mock_data
</code></pre>
<p>Here's my test</p>
<pre><code>class MyTest(TestCase):

    def test_api(self):

        with patch('mymodule.utils.api_call', side_effect=mock_api_call_1):
            do_crud_operations()
            self.assertEqual(MyModel.objects.all().count(), 10)

        with patch('mymodule.utils.api_call', side_effect=mock_api_call_2):
            do_crud_operations()
            self.assertEqual(MyModel.objects.all().count(), 11)
</code></pre>
<p>How can I refactor this code to be able to pass a parameter to the <code>side_effect</code> (<code>mock_call(1)</code> instead of <code>mock_call_1</code>).</p>
<p>From the <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">unittest docs</a>, I see that:</p>
<blockquote>
<p>side_effect: A function to be called whenever the Mock is called. See
  the side_effect attribute. Useful for raising exceptions or
  dynamically changing return values. The function is called with the
  same arguments as the mock, and unless it returns DEFAULT, the return
  value of this function is used as the return value.</p>
</blockquote>
<p>I see that the function passed to <code>side_effect</code> takes the same arguments as the mock, but I'm still not sure how best to use mock to accomplish this. I'll eventually want to add more test cases, so I don't want to be hard-coding different <code>mock_api_call</code> functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a lambda function:</p>
<pre><code>from unittest import TestCase, main
from unittest.mock import Mock, patch
import sys

def mock_api_call(x):
    print(x)

class MyTest(TestCase):
    def test_api(self):
        with patch('sys.exit',
                    side_effect=lambda x: mock_api_call(x)) as m:
            m(0)
            sys.exit(0)

            m(1)
            sys.exit(1)


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the easiest way to do this is to set <code>side_effect</code> to a function that returns a function. </p>
<pre><code>def mock_call(num):
    def wrapper():
        with open("path/to/mock_{num}.json") as f:
            data = json.load(f)
        return data
    return wrapper
</code></pre>
<p>Now I can pass <code>mock_call(1)</code> to <code>side_effect</code> and it will behave as expected.</p>
</div>
