<div class="post-text" itemprop="text">
<p>In python one can handle very large integers (for instance <code>uuid.uuid4().int.bit_length()</code> gives 128), but the largest <code>int</code> datastructure the <a href="https://docs.python.org/3/c-api/long.html" rel="nofollow noreferrer">C-API documentation</a> offers is <code>long long</code>, and it is a <a href="https://en.wikipedia.org/wiki/C_data_types#Basic_types" rel="nofollow noreferrer">64-bit <code>int</code></a>.</p>
<p>I would love to be able to get a C <code>int128</code> from a <code>PyLong</code>, but it seems there is no tooling for this. <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_AsLongLong" rel="nofollow noreferrer">PyLong_AsLongLong</a> for instance cannot handle python integers biggers than <code>2**64</code>.</p>
<ul>
<li>Is there some documentation I missed, and it is actually possible?</li>
<li>Is there currently not possible, but some workaround exist? (I would love to use the tooling available in the python C-API for <code>long long</code> with int128, for instance a <code>PyLong_AsInt128AndOverflow</code> function).</li>
<li>Is it a planed feature in an forthcoming python release?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of different ways you can access the level of precision you want.</p>
<p>Systems with 64-bit <code>long</code>s often have 128-bit <code>long long</code>s. Notice that the article you link says "<strong>at least</strong> 64 bits". It's worth checking <code>sizeof(long long)</code> in case there's nothing further to do.</p>
<p>Assuming that is not what you are working with, you'll have to look closer at the raw <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longobject.h#L10" rel="nofollow noreferrer"><code>PyLongObject</code></a>, which is actually a <code>typedef</code> of the private <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longintrepr.h#L85" rel="nofollow noreferrer"><code>_longobject</code></a> structure.</p>
<p>The raw bits are accessible through the <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longintrepr.h#L87" rel="nofollow noreferrer"><code>ob_digit</code></a> field, with the length given by <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/object.h#L114" rel="nofollow noreferrer"><code>ob_size</code></a>. The data type of the digits, and the actual number of boots they hold is given by the <code>typedef</code> <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longintrepr.h#L45" rel="nofollow noreferrer"><code>digit</code></a> and the macro <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longintrepr.h#L44" rel="nofollow noreferrer"><code>PYLONG_BITS_IN_DIGIT</code></a>. The latter must be smaller than <code>8 * sizeof(digit)</code>, larger than 8, and a multiple of 5 (so 30 or 15, depending on how your build was done).</p>
<p>Luckily for you, there is an "undocumented" method in the C API that will copy the bytes of the number for you: <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longobject.h#L163" rel="nofollow noreferrer"><code>_PyLong_AsByteArray</code></a>. The comment in <a href="https://github.com/python/cpython/blob/47290e7642dd41d94437dd0e2c0f6bfceb0281b5/Include/longobject.h#L144" rel="nofollow noreferrer"><code>longobject.h</code></a> reads:</p>
<blockquote>
<pre><code>/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
   v to a base-256 integer, stored in array bytes.  Normally return 0,
   return -1 on error.
   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
   the LSB at bytes[n-1].
   If is_signed is 0/false, it's an error if v &lt; 0; else (v &gt;= 0) n bytes
   are filled and there's nothing special about bit 0x80 of the MSB.
   If is_signed is 1/true, bytes is filled with the 2's-complement
   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
   Error returns (-1):
   + is_signed is 0 and v &lt; 0.  TypeError is set in this case, and bytes
     isn't altered.
   + n isn't big enough to hold the full mathematical value of v.  For
     example, if is_signed is 0 and there are more digits in the v than
     fit in n; or if is_signed is 1, v &lt; 0, and n is just 1 bit shy of
     being large enough to hold a sign bit.  OverflowError is set in this
     case, but bytes holds the least-significant n bytes of the true value.
*/
</code></pre>
</blockquote>
<p>You should be able to get a UUID with something like</p>
<pre><code>PyLongObject *mylong;
unsigned char myuuid[16];

_PyLong_AsByteArray(mylong, myuuid, sizeof(myuuid), 1, 0);
</code></pre>
</div>
<span class="comment-copy">I think you're confusing python's arbitrary length integers with c's integer types.  Assuming that <code>uuid.uuid4().int.bit_length() == 128</code> (which is not always true), you could do something like <code>print((uuid.uuid4().int * 4).bit_length())</code> and you should get a number &lt;= 130.  That shouldn't suggest that Python is using "int130" -- only that Python supports arbitrary length integers.</span>
<span class="comment-copy">I edited my post so it is more accurate. The only thing I would like to do is to get a C <code>int128</code> from a python <code>PyLong</code>.</span>
