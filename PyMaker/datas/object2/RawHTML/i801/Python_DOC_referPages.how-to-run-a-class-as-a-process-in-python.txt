<div class="post-text" itemprop="text">
<p>I tried to open several serial ports in python at the same time. I think it makes sense that every port as a class process, then I can group the respective properties and methods within this. Ok, I thought multiprocessing could be fine, but I have struggled to get it to work.</p>
<ol>
<li><p>Why can't I initialize the serial port in the <code>init</code>.</p></li>
<li><p>When using <code>super(serialManager, self)</code> without the <code>init</code> the <code>loop_starter</code> is executed, but not as a process.</p></li>
<li><p><code>super(serialManager, self).__init__(target=self.loop_starter,args=(serial_port, baudrate, timeout))</code> isn't executed, why? </p></li>
</ol>
<p>how can I properly put all props in a class and process a method inside this class?</p>
<p>regards</p>
<pre><code>from multiprocessing import Process
import serial
import time

class serialManager(Process):
    def __init__(self, serial_port, baudrate=57200, timeout=1):
        self.light = False
        self.ser = serial.Serial(serial_port, baudrate=baudrate, timeout=timeout)  #1
        #super(serialManager, self)  #2
        #self.loop_starter(serial_port, baudrate, timeout) #2
        super(serialManager, self).__init__(target=self.loop_starter,args=(serial_port, baudrate, timeout))  #3

    def loop_starter( self, serial_port, baudrate, timeout):  
        print("loop_iterator init")
        ser = serial.Serial(serial_port, baudrate=baudrate, timeout=timeout)
        self.loop(ser)

    def loop(self, ser):  
        self.light = not (self.light)
        values = bytearray([2, 82, 49, 4])
        ser.write(values)
        print("loop")
        time.sleep(2)

    #def run(self):
        #print('run')

def main():
    print("main")

if __name__ == "__main__":

    msm = serialManager("COM7")
    print ("inited")
    try:
        msm.start()
        print ("started")

        #while True:
            #main()
    except KeyboardInterrupt:
        print("caught in main")
    finally:
        msm.join()

        while True:
            main()
            time.sleep (1)
</code></pre>
<p>ok, I also tried this little script without success. why isnt the run executed?</p>
<pre><code>from multiprocessing import Process

import time

class P(Process):
    def __init__(self):
        super(P, self).__init__()
    def run(self):
        print("run")
        #time.sleep(0.5)

def main():
    while True:
        print("main")
        time.sleep(2.5)

if __name__ == "__main__":
    p = P()
    p.start()
    p.join()
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your test script executes run() fine. Per the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process" rel="nofollow noreferrer">Process documentation</a>:</p>
<blockquote>
<p>If a subclass overrides the constructor, it must make sure it invokes
  the base class constructor (Process.<strong>init</strong>()) before doing anything
  else to the process.</p>
</blockquote>
<p>Your <code>serialManager</code> class is invoking <code>super()</code> at the end instead of the begining of <code>__init__</code></p>
</div>
<span class="comment-copy">your test script executes run for me under python 3.6</span>
<span class="comment-copy">I don't see any reason for you to be sub-classing <code>Process</code>. This could all be achieved with just <code>Process(target=loop_starter,args=(serial_port, baudrate, timeout))</code>. I noticed you modify, but do not use the variable <code>light</code>. Is there something you've not shown, perhaps about interprocess communication?</span>
<span class="comment-copy">@ dunes: ok, where shoud I put Process(target=loop_starter,args=(serial_port, baudrate, timeout)), inside the init? @manu in 3.4.3 there's no printed "run".</span>
<span class="comment-copy">I just tested on 3.4.3 and "run" is printed perfectly.</span>
<span class="comment-copy">but only one time, I thought it would executed all the time.</span>
