<div class="post-text" itemprop="text">
<p>Possibly a duplicate, but I couldn't find anything.</p>
<p>I have a very long iterator (10000 items) and I need to iterate over it ~500 items at a time. So if my iterator was <code>range(10000)</code>, it would look like this:</p>
<pre class="lang-none prettyprint-override"><code>Iteration #1: 0, 1, 2, ... 497, 498, 499
Iteration #2: 1, 2, 3, ... 498, 499, 500
Iteration #3: 2, 3, 4, ... 499, 500, 501
Iteration #4: 3, 4, 5, ... 500, 501, 502
...
Iteration #9500: 9499, 9500, 9501 ... 9996, 9997, 9998
Iteration #9501: 9500, 9501, 9502 ... 9997, 9998, 9999
</code></pre>
<p>and so on. There is this method:</p>
<pre><code>def nwise_slice(lst, n):
    for i in range(len(lst) - n + 1):
        yield lst[i:i + n]
</code></pre>
<p>However, this doesn't work with lazy iterators. I tried to create a solution using iterators and adapted from the <code>itertools</code> <code>pairwise</code> and <code>consume</code> recipes (see <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">here</a>) to create this:</p>
<pre><code>import itertools

def nwise_iter(lst, n):
    iters = itertools.tee(lst, n)
    for idx, itr in enumerate(iters):
        next(itertools.islice(itr, idx, idx), None)

    for group in zip(*iters):
        yield group
</code></pre>
<p>which does the same (albeit yielding a <code>tuple</code> rather than a <code>list</code>, which does not matter to me). I also believe it doesn't create a lot of unnecessary slices. This solution works on non-sliceable iterators, like files (which I plan to work with). However, the <code>itertools</code> solution was 2x slower:</p>
<pre><code>In [4]: %timeit list(nwise_slice(list(range(10000)), 500))
46.9 ms ± 729 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [5]: %timeit list(nwise_iter(list(range(10000)), 500))
102 ms ± 3.95 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</code></pre>
<p>I don't want to have to load all of my test data into memory to take advantage of the <code>slice</code> method. Is there a more efficient way to pull this off? </p>
</div>
<div class="post-text" itemprop="text">
<p>What about using a <a href="https://docs.python.org/3.7/library/collections.html#collections.deque" rel="nofollow noreferrer">deque</a> to "<a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memoize</a>" your items?</p>
<pre><code>from collections import deque

def nwise_slice(it, n):
    deq = deque((), n)
    for x in it:
        deq.append(x)
        if len(deq)==n: yield deq

my_range = range(8)
for sub in nwise_slice(my_range, 5):
    print(sub)
# =&gt;
# deque([0, 1, 2, 3, 4], maxlen=5)
# deque([1, 2, 3, 4, 5], maxlen=5)
# deque([2, 3, 4, 5, 6], maxlen=5)
# deque([3, 4, 5, 6, 7], maxlen=5)
</code></pre>
</div>
<span class="comment-copy">Check out the <code>grouper()</code> function in this <a href="https://stackoverflow.com/a/4356415/355230">answer</a> of mine.</span>
<span class="comment-copy">@martineau Thanks. Unfortunately, that iterates <code>(1, 2, 3), (4, 5, 6)</code> instead of <code>(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)</code></span>
<span class="comment-copy">Do you need the iterator’s results to remain valid when the iteration is advanced?  Do you need O(1) access by index to each subsequence?</span>
<span class="comment-copy">@DavisHerring No, all of that is unneeded. I can afford to "mess up" the original iterator.</span>
<span class="comment-copy">You can use a sliding window algorithm.  Not faster, but more succinct, look at the <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed" rel="nofollow noreferrer"><code>more_itertools</code> library</a> <code>list(more_itertools.windowed(range(10000), 500))</code>.</span>
<span class="comment-copy">Thanks for the answer. Fortunately, it's extremely fast. However, I'm getting incorrect results - it yields the same deque each time. (Also, <code>lst[0:n]</code> will fail on an iterator, but I think this can be fixed with <code>islice</code>?).</span>
<span class="comment-copy">I guess the main problem is that I'm somewhat of a beginner, with Python. Anyway, I added my test code, maybe you are able to figure out whether I'm using it incorrectly, or where the difference between my use case and yours lies.</span>
<span class="comment-copy">Interesting: iterating over it is fine, but calling <code>list(nwise_slice(my_range, 5))</code> breaks it. Hmm...</span>
<span class="comment-copy">well, <code>list()</code> wants a generator of items, not a generator of iterators like <code>nwise_slice()</code></span>
<span class="comment-copy">@WalterTross Without it <code>list(nwise_slice(x, 5))</code> would be a list of the same object. This is unexpected. One can get away with linear use of the result as with <code>itertools.groupby</code> but as with that you have to know that the generator does not return a copy and make one yourself <code>[(k, list(g)) for k,g in groupby(...)]</code> as the object or iterator is no longer valid in the next iteration. Instead of copying, one could wrap the return result in a invalidate-able proxy that would become invalid when control returns to the generator.</span>
