<div class="post-text" itemprop="text">
<p>I want to use f-string with my string variable, not with string defined with a string literal, <code>"..."</code>.</p>
<p>here is my code</p>
<pre><code>name=["deep","mahesh","nirbhay"]
user_input = r"certi_{element}" # this string i ask from user  

for element in name:
    print(f"{user_input}")
</code></pre>
<p>This code gives output:</p>
<pre><code>certi_{element}
certi_{element}
certi_{element}
</code></pre>
<p>But I want:</p>
<pre><code>certi_{deep}
certi_{mahesh}
certi_{nirbhay}
</code></pre>
<p>how can I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the user to have access to your namespace, you can do that, but the consequences are entirely on you. Instead of using f-strings, you can use the <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>format</code></a> method to interpolate dynamically, with a very similar syntax.</p>
<p>If you want the user to have access to only a small number of specific variables, you can do something like</p>
<pre><code>name=["deep", "mahesh", "nirbhay"]
user_input = "certi_{element}" # this string i ask from user  

for element in name:
    my_str = user_input.format(element=element)
    print(f"{my_str}")
</code></pre>
<p>You can of course rename the key that the user inputs vs the variable name that you use:</p>
<pre><code>my_str = user_input.format(element=some_other_variable)
</code></pre>
<p>And you can just go and let the user have access to your whole namespace (or at least most of it). Please don't do this, but be aware that you can:</p>
<pre><code>my_str = user_input.format(**locals(), **globals())
</code></pre>
<p>The reason that I went with <code>print(f'{my_str}')</code> instead of <code>print(my_str)</code> is to avoid the situation where literal braces get treated as further, erroneous expansions. For example, <code>user_input = 'certi_{{{element}}}'</code></p>
</div>
<div class="post-text" itemprop="text">
<p><code>f"..."</code> strings are great when interpolating expression results into a <em>literal</em>, but you don't have a literal, you have a template string in a separate variable.</p>
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>str.format()</code></a> to apply values to that template:</p>
<pre><code>name=["deep","mahesh","nirbhay"]
user_input = "certi_{element}" # this string i ask from user  

for value in name:
    print(user_input.format(element=value))
</code></pre>
<p>String formatting placeholders that use names (such as <code>{element}</code>) are not <em>variables</em>. You assign a value for each name in the keyword arguments of the <code>str.format()</code> call instead. In the above example, <code>element=value</code> passes in the value of the <code>value</code> variable to fill in the placeholder with the <code>element</code>.</p>
<p>Unlike <code>f</code>-strings, the <code>{...}</code> placeholders are <em>not</em> expressions and you can't use arbitrary Python expressions in the template. This is a good thing, you wouldn't want end-users to be able to execute arbitrary Python code in your program. See the <a href="https://docs.python.org/3/library/string.html#formatstrings" rel="nofollow noreferrer"><em>Format String Syntax</em> documenation</a> for details. </p>
<p>You can pass in any number of names; the string template doesn't <em>have</em> to use any of them. If you combine <code>str.format()</code> with the <code>**mapping</code> call convention, you can use any dictionary as the source of values:</p>
<pre><code>template_values = {
    'name': 'Ford Prefect',
    'number': 42,
    'company': 'Sirius Cybernetics Corporation',
    'element': 'Improbability Drive',
}

print(user_input.format(**template_values)
</code></pre>
<p>The above would let a user use any of the names in <code>template_values</code> in their template, any number of times they like.</p>
<p>While you can use <code>locals()</code> and <code>globals()</code> to produce dictionaries mapping variable names to values, I'd not recommend that approach. Use a dedicated namespace like the above to limit what names are available, and document those names for your end-users.</p>
</div>
<span class="comment-copy">You <b><i>do not want</i></b> users being able to execute arbitrary code.  Make it a dictionary lookup or something like that.</span>
<span class="comment-copy">@user3483203: where is the user stating that they expect to be able to use arbitrary variables? There is nothing here to say that just any name can be used.</span>
<span class="comment-copy">@MartijnPieters my comment has nothing to do with arbitrary variables.  I'm saying that they shouldn't want an expression inside a user's input to be evaluated.</span>
<span class="comment-copy">@user3483203: right, I don't know if the OP is expecting full expression support (or are even aware of that feature existing). They are asking for a variable, so <code>str.format()</code> more than suffices.</span>
<span class="comment-copy">Why the assumption that there the name <code>element</code> is <i>arbitrary</i>?</span>
<span class="comment-copy">@MartijnPieters. Fair point. I have updated.</span>
<span class="comment-copy">Thanks nice explanation</span>
<span class="comment-copy">What if I don't know what user give in { }. In our case : element.</span>
<span class="comment-copy">@DeepGhodasara: you'd still have to tell the user to use specific names. While you can <a href="https://stackoverflow.com/q/25996937/100297">parse out what names are used in a template</a>, you'd still have to map those names to values. I've added how you'd give someone access to multiple names that they can pick from.</span>
