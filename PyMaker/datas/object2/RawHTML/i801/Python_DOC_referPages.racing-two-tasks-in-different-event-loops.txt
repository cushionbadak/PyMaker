<div class="post-text" itemprop="text">
<p>I am using the Docker SDK, and I am trying to race a task that times out after some number of seconds against another task that waits on a Docker container to finish. In effect, I want to know if a given container finishes within the timeout I've set.</p>
<p>I have the following code to do it (adapted from <a href="https://stackoverflow.com/a/53967478/996249">this post</a>):</p>
<pre class="lang-py prettyprint-override"><code>container =  # ... create container with Docker SDK
timeout =  # ... some int
killed = None

# our tasks
async def __timeout():
  await asyncio.sleep(timeout)
  return True
async def __run():
  container.wait()
  return False

# loop and runner
wait_loop = asyncio.new_event_loop()
done, pending = wait_loop.run_until_complete(
  asyncio.wait({__run(), __timeout()}, return_when=asyncio.FIRST_COMPLETED)
)

# result extraction
for task in done:
  if killed is None:
    killed = task.result()
    # ... do something with result

# clean up
for task in pending:
  task.cancel()
  with contextlib.suppress(asyncio.CancelledError):
    wait_loop.run_until_complete(task)
wait_loop.close()
</code></pre>
<p>Unfortunately, I keep getting the following error:</p>
<pre><code>  File "/usr/lib/python3.5/asyncio/base_events.py", line 387, in run_until_complete
    return future.result()
  File "/usr/lib/python3.5/asyncio/futures.py", line 274, in result
    raise self._exception
  File "/usr/lib/python3.5/asyncio/tasks.py", line 241, in _step
    result = coro.throw(exc)
  File "/usr/lib/python3.5/asyncio/tasks.py", line 347, in wait
    return (yield from _wait(fs, timeout, return_when, loop))
  File "/usr/lib/python3.5/asyncio/tasks.py", line 430, in _wait
    yield from waiter
  File "/usr/lib/python3.5/asyncio/futures.py", line 361, in __iter__
    yield self  # This tells Task to wait for completion.
RuntimeError: Task &lt;Task pending coro=&lt;wait() running at /usr/lib/python3.5/asyncio/tasks.py:347&gt; cb=[_run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164]&gt; got Future &lt;Future&gt; pending&gt; attached to a different loop
</code></pre>
<p>It seems I can't race with the wait task because it belongs to a different loop. Is there any way I can get around this error so that I can determine which task finishes first?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is simple, there is one default loop in every thread. Which is set by <code>asyncio.set_event_loop(loop)</code>. Then you can get this loop by <code>loop = asyncio.get_event_loop()</code>.</p>
<p>So the problem is, mostly, some packages use <code>asyncio.get_event_loop()</code> by default to get current running loop. Take <code>aiohttp</code> as an example:</p>
<pre><code>class aiohttp.ClientSession(*, connector=None, loop=None, cookies=None, headers=None, skip_auto_headers=None, auth=None, json_serialize=json.dumps, version=aiohttp.HttpVersion11, cookie_jar=None, read_timeout=None, conn_timeout=None, timeout=sentinel, raise_for_status=False, connector_owner=True, auto_decompress=True, requote_redirect_url=False, trust_env=False, trace_configs=None)
</code></pre>
<p>As you can see, it accepts <code>loop</code> parameter to specify running loop. But You can also just leave it blank to use <code>asyncio.get_event_loop()</code> by default.</p>
<p>Your problem is you are launching coroutines in a new created loop. But you cannot confirm that all your interal operations are also using this new created one. As they may use <code>asyncio.get_event_loop()</code>, they will be attached into another loop which is the default loop in current thread.</p>
<hr/>
<p>As far as I think, you don't really need to create a new one, but let users do that. Just like the example above, you accept an argument <code>loop</code>, and if it is <code>None</code>, use the default one.</p>
<hr/>
<p>Or you need to carefully inspect your code to ensure that every possible coroutine is using the loop you create.</p>
</div>
<span class="comment-copy">Do you have <a href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="nofollow noreferrer">Debug Mode</a> ON, just to see what's going?</span>
<span class="comment-copy">I don't see a debug mode, just a profiler. Would that be helpful in solving asyncio problems like this?</span>
<span class="comment-copy">The docs mention about Debug mode. Usage: <code>asyncio.run(main(), debug=True)</code>. This is helpful, though profiling also helps.</span>
<span class="comment-copy">Why exactly are you creating a new event loop? Do you actually have two loops that you use at any point? (You probably shouldn't.) If you need to create the new event loop, then try to create it as early as possible and use <code>asyncio.set_event_loop(wait_loop)</code> to make asyncio aware of it.</span>
<span class="comment-copy">Ultimately I made a new event loop because I thought I needed to. I am trying to make this part of a module, so I couldn't say for sure that there won't be an event loop that the user of my module creates as well.</span>
<span class="comment-copy">Interesting, using the default loop does work exactly how I needed it to. I guess I thought I needed a new one to separate things, but that wasn't the case.</span>
<span class="comment-copy">@nmagerko I think mayb you misunderstand how it works. Are you thinking that you can run two different loops concurrently? Actually not :( There can be only one loop running at the same time. So there should be no concept about <code>separating things</code> as it is impossible.</span>
<span class="comment-copy">@Sraw It is technically possible to run separate loops in separate thread at the same time, but the two can't communicate (using asyncio synchronization primitives) and, more importantly, there is almost never a <i>reason</i> to attempt that.</span>
<span class="comment-copy">@user4815162342 Surely you are correct. But actually I mean in the same thread. We definitely can run things at the same time using threads.</span>
