<div class="post-text" itemprop="text">
<p>Considering a function below:</p>
<pre><code>import numpy as np

a = np.ones(16).reshape(4,4)

def fn(a):
    b = np.array(a)
    for i in range(b.shape[0]):
        for j in range(b.shape[1] - 1):
            b[i][j+1] += b[i][j]
    return b

print(fn(a))
</code></pre>
<p>That is, for a general function that calculates <code>t+1</code> based on <code>t</code> in an array, can I make this faster? I'm aware there's a <code>np.vectorize</code> but not seeming appropriate for this case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>cumsum</code> I think that would be helpful.</p>
<pre><code>import numpy as np
import pandas as pd
a = np.ones(16).reshape(4,4)
df =pd.DataFrame(a)
df.cumsum(axis=1)
</code></pre>
<p>Or you can use <code>np.cumsum()</code>:</p>
<pre><code>np.cumsum(a,axis=1)  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to reduce the two <code>for</code> loops to one <code>for</code> loop with little bit of copying overhead in addition.</p>
<pre><code>In [86]: a 
Out[86]: 
array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])

In [87]: b = a.copy() 

In [88]: for col in range(b.shape[1]-1): 
    ...:     b[:, col+1] = np.sum(a[:, :col+2], axis=1) 

In [89]: b
Out[89]: 
array([[1., 2., 3., 4.],
       [1., 2., 3., 4.],
       [1., 2., 3., 4.],
       [1., 2., 3., 4.]])
</code></pre>
<p>To make this work for a <em>generic function</em>, you can look for an equivalent function in numpy or implement one using numpy operations (vectorized one). For the example you provided, I just used <code>numpy.sum()</code> that does the job for us.</p>
<p>In terms of performance, this approach would be much better than operating using two <code>for</code> loops at the indices level, particularly for larger arrays. In the approach I used above, we work with slices of columns.</p>
<hr/>
<p>Here are the timings which suggest more than <strong>3X speedup</strong> over native python implementation.</p>
<hr/>
<p>Native Python:</p>
<pre><code>def fn(a):
    b = np.array(a)
    for i in range(b.shape[0]):
        for j in range(b.shape[1] - 1):
            b[i][j+1] += b[i][j]
    return b
</code></pre>
<hr/>
<p>Slightly vectorized:</p>
<pre><code>In [104]: def slightly_vectorized(b): 
     ...:     for col in range(b.shape[1]-1): 
     ...:         b[:, col+1] = np.sum(a[:, :col+2], axis=1) 
     ...:     return b 
</code></pre>
<hr/>
<pre><code>In [100]: a = np.ones(625).reshape(25, 25) 

In [101]: %timeit fn(a) 
303 µs ± 2.05 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

In [102]: b = a.copy() 

In [103]: %timeit slightly_vectorized(b) 
99.8 µs ± 501 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you're looking for is called <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">accumulate</a> here's an example:</p>
<pre><code>import numpy as np
from itertools import accumulate

def fn(a):
    acc = accumulate(a, lambda prev, row: prev + row)
    return np.array(list(acc))

a = np.arange(16).reshape(4, 4)
print(fn(a))
# [[ 0  1  2  3]
#  [ 4  6  8 10]
#  [12 15 18 21]
#  [24 28 32 36]]
</code></pre>
<p>There is no optimized accumulate function in numpy because it's not really possible to write accumulate in a way that's both performant &amp; general. The python implementation is general, but will perform much like a hand coded lok. </p>
<p>To get optimal performance you'll probably need to find or write a low level implementation of the specific accumulate function that you need. You've already mentioned numba and you could also look into cython.</p>
</div>
<span class="comment-copy"><code>vectorize</code> doesn't promise performance, even where it does work.</span>
<span class="comment-copy">@hpaulj I tested a for-loop on 2d array, 1. loop i,j for both dimensions and calculate in-place 2. define a vectorized function and call <code>v_fn(arr)</code>, the second solution is 2x faster.</span>
<span class="comment-copy">I was specifically referring to the <code>np.vectorize</code> function, not the general concept of <code>vectorization</code>.  Clearly in this case you don't need to iterate on the <code>i</code> dimension.  The <code>j</code> dimension needs something like a <code>ufunc.accumulate</code>, or <code>numba</code> to gain much speed.</span>
<span class="comment-copy">@hpaulj the "vectorized function" is implemented with <code>np.vectorize</code>. A dumb example is <code>fn = lambda x: x*x</code>, with <code>v_fn = np.vectorize(fn)</code>. It's indeed faster than an embedded loop. But I've got your idea.</span>
<span class="comment-copy">Is there a more general solution? If the function is not doing cumulative sum. I found <code>numba</code> looks like what I'm asking for but never used it.</span>
<span class="comment-copy">Not always you can find an equivalent function though.</span>
<span class="comment-copy">@knh190 I agree! But almost all functions can be implemented using basic numpy ufuncs. You can then apply this newly implemented function</span>
