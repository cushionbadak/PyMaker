<div class="post-text" itemprop="text">
<p>I have a list of tuples and need to delete tuples if its 1st item is matching with 1st item of other tuples in the list. 3rd item may or may not be same, so I cannot use set (I have seen this question - <a href="https://stackoverflow.com/questions/35975441/grab-unique-tuples-in-python-list-irrespective-of-order">Grab unique tuples in python list, irrespective of order</a> and this is not same as my issue)</p>
<p>For eg if I got <strong><em>a</em></strong> as:</p>
<blockquote>
<p>[(0, 13, 'order1'), (14, 27, 'order2'), (14, 27, 'order2.1'), (0, 13,
  'order1'), (28, 41, 'order3')]</p>
</blockquote>
<p>I want the output as:</p>
<blockquote>
<p>[(14, 27, 'order2'), (0, 13, 'order1'), (28, 41, 'order3')]</p>
</blockquote>
<p>I am getting the desired output using below code.</p>
<pre><code>for e, i in enumerate(a):
    r = [True if i[0] == k[0] and e != j else False for j, k in enumerate(a)]
    if any(r):
        a.pop(e)
pprint(a)
</code></pre>
<p>Is there a better or more pythonic way to achieve the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual way is keying a dict off whatever you want to dedupe by, for example:</p>
<pre><code>&gt;&gt;&gt; a = [(0, 13, 'order1'), (14, 27, 'order2'), (14, 27, 'order2.1'), (0, 13, 'order1'), (28, 41, 'order3')] 
&gt;&gt;&gt; print(*{tup[:2]: tup for tup in a}.values()) 
(0, 13, 'order1') (14, 27, 'order2.1') (28, 41, 'order3')
</code></pre>
<p>This is <em>O(n)</em> time complexity, superior to <em>O(n log n)</em> groupby based approaches.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can get the first element of each group in a grouped, sorted list:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

a = [(0, 13, 'order1'), (14, 27, 'order2'), (14, 27, 'order2.1'), (0, 13, 'order1'), (28, 41, 'order3')]

result = [list(g)[0] for k, g in groupby(sorted(a), key=itemgetter(0))]
print(result)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should avoid modifying your list in place while iterating over it. Instead, you can use the popular <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>unique_everseen</code> recipe</a>, also available in 3rd party <a href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.unique_everseen" rel="nofollow noreferrer"><code>more_itertools</code></a>. Just use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> in the <code>key</code> argument:</p>
<pre><code>from more_itertools import unique_everseen
from operator import itemgetter

res = list(unique_everseen(L, key=itemgetter(0, 1)))
</code></pre>
<p>This solution takes O(<em>n</em>) time, but is generally <em>less</em> efficient than a dictionary-based solution, although it is arguably clearer in its intention.</p>
</div>
<span class="comment-copy">If you find two duplicates, say ` (14, 27, 'order2')` and  <code>(14, 27, 'order2.1')</code>, how do you know which 3rd item to use, <code>'order2'</code> or <code>'order2.1'</code>?</span>
<span class="comment-copy">The 2nd item in the tuple doesn't matter?</span>
<span class="comment-copy">@JoePatten does not really matter, I can choose any one of them</span>
<span class="comment-copy">It's a generally <i>awful</i> idea to alter a list <i>while</i> you're iterating through it.</span>
<span class="comment-copy">@prune not really (would the solution be different if I would say yes?) and I agree/know its an <i>awfullest</i> of an idea to alter the list hence this post, looking for "better/more pythonic" solution.</span>
<span class="comment-copy">Nice! I was thinking of this, but for some reason I thought dict comps were introduced in Python 3...</span>
