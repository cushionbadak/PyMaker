<div class="post-text" itemprop="text">
<pre><code>for i in range(10):

for i in 0 .. 9:
</code></pre>
<p>How do I 'overload'?  '..' .</p>
<p>I find the <code>range()</code> object not concise or easy to read. The pascal notation/syntax (range (inclusive .. inclusive) <a href="http://rigaux.org/language-study/syntax-across-languages-per-language/Pascal.html" rel="nofollow noreferrer">http://rigaux.org/language-study/syntax-across-languages-per-language/Pascal.html</a> ) just so much easier to read.</p>
<p>I saw in the pathlib module <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer">https://docs.python.org/3/library/pathlib.html</a> that it overloads(?) the / character.</p>
</div>
<div class="post-text" itemprop="text">
<p>While <code>Python</code> does not have the <code>..</code> operator, you could define an infix operator like so:</p>
<pre><code>class Infix:
    def __init__(self, function):
        self.function = function
    def __ror__(self, other):
        return Infix(lambda x, self=self, other=other: self.function(other, x))
    def __or__(self, other):
        return self.function(other)
    def __rlshift__(self, other):
        return Infix(lambda x, self=self, other=other: self.function(other, x))
    def __rshift__(self, other):
        return self.function(other)
    def __call__(self, value1, value2):
        return self.function(value1, value2)
</code></pre>
<p>Now, choose a meaningful name like <code>until</code> and you're done:</p>
<pre><code>until = Infix(lambda x,y: range(x,y +1))
print(2 |until| 4)
# [2, 3, 4]
</code></pre>
<p>Or</p>
<pre><code>for i in (2 |until| 4):
    print(i)
</code></pre>
<p>Unfortunalety not my idea, see <a href="http://code.activestate.com/recipes/384122/" rel="nofollow noreferrer"><strong>this brilliant post for the original idea</strong></a>.</p>
</div>
<span class="comment-copy"><code>..</code> is not a valid python operator, so you cannot overload it.</span>
<span class="comment-copy">The best you could do is wrap the first number in a wrapper class, then have the class overload a operator to accept an end number, and have that return a range. Don't do that though. Just get used to <code>range</code> since that's what all code uses.</span>
<span class="comment-copy">Iâ€™d probably go with something simpler like <code>def irange(a, b): return range(a, b + 1)</code>. While interesting, this seems to go overboard and makes for very unpythonic code.</span>
<span class="comment-copy">@deceze: Completely agree. Kinda lispy though (without the parentheses, that is).</span>
<span class="comment-copy">Could you use |..|   ? So, for i in 0 |..| 9:   ? .. = Infix(lambda x,y: range(x,y +1))</span>
<span class="comment-copy">(You (can (always (add those) back (in (anyway))))))))))).</span>
<span class="comment-copy">@JoePythonKing: But that's as far as it will get, I'm afraid.</span>
