<div class="post-text" itemprop="text">
<p>I have some group of equals items that I want to combine.
I try to explain better with an example:</p>
<p>I have some group of people, every group have an ID.
So the situation is a list of 5 people like that</p>
<pre><code>['A','A','B','B','C']
</code></pre>
<p>I need to place everyone inside some room. Every person with the same code needs to be in the same room.
The rooms, for example, are 3: the first one has 2 desks, the second one has 3 desks and the last one has 2 desks again.</p>
<p>So finally I expect a list of combinations like that:</p>
<pre><code>[['A','A'],['B','B',None],['C',None]]
[['A','A'],['C',None,None],['B','B']]
[['A','A'],['B','B','C'],[None,None]]
[['B','B'],['A','A',None],['C',None]]
[['B','B'],['C',None,None],['A','A']]
[['B','B'],['A','A','C'],[None,None]]
[['C',None],['A','A',None],['B','B']]
[['C',None],['B','B',None],['A','A']]
</code></pre>
<p>"None" means an empty Desk.</p>
<p>I don't expect a final solution, I'll appreciate some help about the logic process to follow, because I'm really going crazy about that.</p>
<p>Thank you very much.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>peoples = ['A','A','B','B','C', "None", "None"]

import itertools

for x in itertools.permutations(peoples):
    rooma = x[:2]
    if rooma[0] == rooma[1] or "None" in rooma[:2]:
        roomb = x[2:5]
        if len(roomb) != len(set(roomb)):
            roomc = x[5:]
            if roomc[0] == roomc[1] or "None" in roomc[:2]:
                print([rooma,roomb,roomc])
</code></pre>
<p>this gets you 95% if the way there</p>
</div>
<div class="post-text" itemprop="text">
<p>I have created a sample how you could solve your problem:    </p>
<pre><code>import itertools
combs = ['AA','BB','C','X', 'X'] # i grouped AA becouse they are grouped and "X" = None

mylist = sorted(list(itertools.permutations(combs))) #create all possible permutations

#split the groups
tuppleSet = set()
for line in mylist:
    t = ()
    for string in line:
        string.split("\\")
        t = t + tuple(string)
    tuppleSet.add(t)

newlist = sorted(tuppleSet)
for line in newlist:
    if line[0] == "C" or line[0] == "X" and line[1] == "A" or line[1] == "B": #restricton with table size 
        continue
    elif line[6] == "X" or line[6] == "C" and line[4] == "A" or line[4] == "B": #restricton with table size 
        continue
    print(line)

Output:
('A', 'A', 'B', 'B', 'X', 'X', 'C')
('A', 'A', 'C', 'X', 'X', 'B', 'B')
('A', 'A', 'X', 'C', 'X', 'B', 'B')
('A', 'A', 'X', 'X', 'C', 'B', 'B')
('X', 'C', 'A', 'A', 'X', 'B', 'B')
('X', 'C', 'B', 'B', 'X', 'A', 'A')
('X', 'C', 'X', 'A', 'A', 'B', 'B')
('X', 'X', 'A', 'A', 'C', 'B', 'B')
('X', 'X', 'B', 'B', 'C', 'A', 'A')
('X', 'X', 'C', 'A', 'A', 'B', 'B')
</code></pre>
<p>I highly recommend to dive some deeper into <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">Itertools</a> i am not so deep in there ...</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import combinations,permutations,repeat,groupby,zip_longest
Peop = [["A001_B","A001_B"],["A004_A","A004_A"],["A003_A","A003_A","A003_A","A003_A","A003_A","A003_A"],["A002_A","A002_A","A002_A","A002_A"],["A001_C","A001_C"],["A001_A","A001_A","A001_A"],["A002_B","A002_B"]];
RPla = [4,10,2,4,8]
Comb = []
for r in RPla:
    out,out1,l1,s1 = [],[],[],[]
    for s in Peop:
        l = len(s)
        if l &gt; r:
            continue
        elif l == r:
            out.append(s)
        else:
            s1.append(s) # ======== new purged Peop
            l1.append(l) # ======== len same people Peop
    indL,tempC,diff = [],[],[]
    for z in range(2,len(l1)-1):
        for k,y in zip(combinations(range(len(l1)),z),combinations(l1,z)):
            indL.append(k)
            tempC.append(y)
            if sum(y) &gt; r:
                continue # &lt;&lt;&lt;&lt;&lt;==== WILL DO SOMETHING ======================
            elif sum(y) == r:
                tempL1 = []
                for h in k:
                    tempL1.append(s1[h])
                tempL1 = [item for sublist in tempL1 for item in sublist] #flatten
                out.append(tempL1)
            else:
                diff = r - sum(y)
                tempL1 = []
                for h in k:
                    tempL1.append(s1[h])
                tempL1 = [item for sublist in tempL1 for item in sublist] #flatten
                tempL1.extend(repeat("Empty Desk",diff))
                out.append(tempL1)
    s1.append(repeat("Empty Desk",r))
    tempL2 = [list(row) for row in zip_longest(*s1, fillvalue='Empty Desk')]
    tempL3 = [list(row) for row in zip_longest(*tempL2, fillvalue='')]
    #tempL3 = tempL3[:len(s1)-1]
    out.extend(tempL3)
    Comb.append(out)
print(Comb)
</code></pre>
<p>I want to show you my work-in-progress (above).</p>
<p>In this way, for each room, I find every possible optimized combination. The problem is that now I have to combine the combinations between rooms without repetitions.
I didn't find a way, so I asked you help by also changing mind.</p>
<p>As you can see peoples can change and also room places compared to the previous example.</p>
<p>This is a test with Python 3 though I use Python 2</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a much faster solution, based on Fabian's approach:</p>
<pre><code>import itertools, sys

# combs = ['AA','BB','C','X', 'X'] # i grouped AA becouse they are grouped and "X" = None
# rooms = [2, 3, 2]
combs = ['AA', 'BBB', 'C', 'X', 'X', 'X', 'X']
rooms = [2, 3, 2, 3]

mylist = sorted(list(itertools.permutations(combs))) #create all possible permutations

unique_assignments = []

# test if two assignemtns are equivalent
def equivalent_assignments(assignment1, assignment2):
    for i in range(0, len(assignment1)):
        if tuple(assignment1[i]) not in itertools.permutations(assignment2[i]):
            return False
    return True

# for every permutation
for line in mylist:
    fits = True
    rooms_ind = 0
    comb_ind = 0

    room = rooms[rooms_ind]
    comb = line[comb_ind]

    room_assignments = []
    room_assignment = []

    # see if this permutation will fit
    while True:
        if room &lt; len(comb):
            break
        elif room == len(comb):
            comb_ind += 1
            rooms_ind += 1
            room_assignment.append(comb)
            room_assignments.append(room_assignment)
            room_assignment = []
            try:
                room = rooms[rooms_ind]
                comb = line[comb_ind]
            except:

                break
        else: # room &gt; len(comb)
            room_assignment.append(comb)
            room -= len(comb)
            comb_ind += 1
            try:
                comb = line[comb_ind]
            except:
                break

    # if we have leftover people, they don't fit
    if comb_ind &lt; len(line) - 1:
        fits = False

    # check for same assignments
    if fits:
        same_assignments = [x for x in unique_assignments if equivalent_assignments(x, room_assignments)]
        if len(same_assignments) == 0:
            unique_assignments.append(room_assignments)

# print results
for line in unique_assignments:
    print line
</code></pre>
<p>Output:</p>
<pre><code>[['AA'], ['BBB'], ['C', 'X'], ['X', 'X', 'X']]
[['AA'], ['BBB'], ['X', 'X'], ['C', 'X', 'X']]
[['AA'], ['C', 'X', 'X'], ['X', 'X'], ['BBB']]
[['AA'], ['X', 'X', 'X'], ['C', 'X'], ['BBB']]
[['C', 'X'], ['AA', 'X'], ['X', 'X'], ['BBB']]
[['C', 'X'], ['BBB'], ['AA'], ['X', 'X', 'X']]
[['C', 'X'], ['BBB'], ['X', 'X'], ['AA', 'X']]
[['C', 'X'], ['X', 'X', 'X'], ['AA'], ['BBB']]
[['X', 'X'], ['AA', 'C'], ['X', 'X'], ['BBB']]
[['X', 'X'], ['AA', 'X'], ['C', 'X'], ['BBB']]
[['X', 'X'], ['BBB'], ['AA'], ['C', 'X', 'X']]
[['X', 'X'], ['BBB'], ['C', 'X'], ['AA', 'X']]
[['X', 'X'], ['BBB'], ['X', 'X'], ['AA', 'C']]
[['X', 'X'], ['C', 'X', 'X'], ['AA'], ['BBB']]
</code></pre>
<p>My old much-much more inefficient solution:</p>
<pre><code>import itertools, sys

people = ['A', 'A', 'B', 'B', 'C']
rooms = [2, 3, 2]
# people = ['A', 'A', 'B', 'B', 'B', 'C']
# rooms = [2, 3, 2, 3]
# people = ['A', 'A', 'B', 'B', 'C', 'C', 'C', 'C', 'C'] # takes absurdly long
# rooms = [2, 3, 2, 5]

total_room_space = sum(rooms)
print("total_room_space: " + str(total_room_space))

people_padded = people
for i in range(0, (total_room_space - len(people))):
    people_padded.append('None')
print('people_padded: ' + str(people_padded))

unique_assignments = []

for perm in itertools.permutations(people_padded):
    perm_index = 0

    room_assignments = []
    for room_size in rooms:
        room_assignment = []
        for i in range(0, room_size):
            room_assignment.append(perm[perm_index])
            perm_index += 1
        room_assignments.append(tuple(room_assignment))

    skipflag = False

    # check for multiple rooms
    for room_assignment in room_assignments:
        rest = [x for x in room_assignments if x is not room_assignment]
        for room_asgn in rest:
            for code in room_assignment:
                if code != 'None':
                    if code in room_asgn:
                        skipflag = True

    # skip if needed
    if skipflag:
        continue

    if room_assignments not in unique_assignments:
        unique_assignments.append(room_assignments)

# return true if two room assignments are the same
def same_assignment(assignment1, assignment2):
    for i in range(0, len(assignment1)):
        if assignment1[i] not in itertools.permutations(assignment2[i]):
            return False
    return True

# clean up same combinations in unique_assignments
indeces = range(0, len(unique_assignments))
delete_indeces = []
while indeces:
    curr_index = indeces.pop(0)
    equivalent_assignments = [x for x in indeces if same_assignment(unique_assignments[x], unique_assignments[curr_index])]
    for ind in equivalent_assignments:
        delete_indeces.append(ind)
    indeces = [x for x in indeces if x not in equivalent_assignments]

for index in reversed(sorted(delete_indeces)):
    del unique_assignments[index]

# print results
print("\n\nResults:")
for assignment in unique_assignments:
    print assignment
</code></pre>
</div>
<span class="comment-copy">How does your code know the rooms and desks inside each room? Are they stored in a list? How is this list?</span>
<span class="comment-copy">You have a list of 7 items kinda... list of 2, list of 3, list of 2... but lets say 7. Every possible combo is 7*7 Just try every possible combo check against the rules you have defined above... but as code, and if it meats the rules print and reformat so you have your list of sublists. Ill give it a go and once i get to it post to the answer, but i reckon would be good for you to also do so.</span>
<span class="comment-copy">I have a starting list of people ['A','A','B','B','C'] and then a list of room places [2,3,2], so I know I have 2 desks in room 0, 3 desks in room 1 and 2desks in room 2.</span>
<span class="comment-copy">Pretty cool!!! Thank you @ilamaaa. It's a nice strategy to add 2 times "None" to complete all desks. I'll try this way. The problem is that in this way I have a lot of repeated combinations. It could not seem a problem, I can purge, but my reals inputs are thousands of people and a hundred rooms. I need to optimize! Thank You</span>
<span class="comment-copy">That turns this into a big O problem, gotta use your rules to reduce the difficulty. Fabians suggestion of grouping the ID's is a good option, going room by room is also viable. etc etc.</span>
<span class="comment-copy">Thank you @Fabian. I have thousands of people, not just "A" "B" "C". I'll try this way by finding a way to make it more generic.</span>
<span class="comment-copy">@arpaqua then vote this as answer thanks :D if you need help to improve update the question or create a improved one and link them</span>
<span class="comment-copy">Thank you sdMarth. I tried with these inputs people = ['A', 'A', 'B', 'B', 'B', 'C'] rooms = [2, 3, 2, 3] and it splits the triple "B"</span>
<span class="comment-copy">Sorry about that, I have updated my post to fix that error in my code.</span>
<span class="comment-copy">It works perfectly!!! Thank you very much sdMarth. Now the problem is that Python stops working by adding some more rooms and people. MemoryError: Array dimensions exceeded supported range. Maybe I need to completely change my mind!!! Thank you again, I like very much your solution.</span>
<span class="comment-copy">My problem is here: mylist = sorted(list(itertools.permutations(combs)))</span>
<span class="comment-copy">From the comments you say that you are trying to compute this for thousands of people and hundreds of rooms. If you want every possible combination (including combinations with empty spots), there's no way to do this than by computing permutations. However, doing permutations for groups that large is crazy. If there are enough rooms and groups of people, nevermind memory, the number of permutations can quickly approach or exceed the number of atoms in the universe! It would take forever to compute that.</span>
