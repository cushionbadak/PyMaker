<div class="post-text" itemprop="text">
<p>While preparing for a test, I am solving tests from previous years.</p>
<p>Write the function <code>compress(lst)</code> that receives a non empty list of repetitive letters and returns a list of tuples, each tuple containing the letter and the number or subsequent repetitions. ( see example)</p>
<p>e.g.:</p>
<p>for:</p>
<pre><code>['a','a', 'b', 'b', 'b', 'c', 'a', 'a']
</code></pre>
<p>the function should return:</p>
<pre><code>[('a', 2), ('b', 3), ('c', 1), ('a', 2)]
</code></pre>
<p>Here's my code:</p>
<pre><code>def compress(lst):
    res = []
    i = 0
    for letter in lst:
        letter_count = 0
        while i &lt; len(lst) and lst[i] == letter:
            letter_count += 1
            i +=1
        res.append((letter, letter_count))
    return res
</code></pre>
<p>My function returns:</p>
<pre><code>[('a', 2), ('a', 0), ('b', 3), ('b', 0), ('b', 0), ('c', 1), ('a', 2), ('a', 0)]
</code></pre>
<p>I can see why it does that, but I cant see how to change <em>my</em> code to solve the problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>(Assuming you want to correct <em>your</em> code) </p>
<p>Save the <code>index</code> of the current analyzed letter and just sum to it how many times this letter repeats, so you skip already analyzed letters</p>
<pre><code>def compress(lst):
    res = []
    i = 0
    ind = 0
    while ind &lt; len(lst):
        letter_count = 0
        while i &lt; len(lst) and lst[i] == lst[ind]:
            letter_count += 1
            i +=1
        res.append((lst[ind], letter_count))
        ind += letter_count
    return res

&gt;&gt;&gt; compress(['a','a', 'b', 'b', 'b', 'c', 'a', 'a'])
[('a', 2), ('b', 3), ('c', 1), ('a', 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><strong><code>groupby</code></strong></a> from <code>itertools</code> module which perfectly fits here:</p>
<pre><code>from itertools import groupby

lst = ['a','a', 'b', 'b', 'b', 'c', 'a', 'a']

print([(k, len(list(v))) for k, v in groupby(lst)])
# [('a', 2), ('b', 3), ('c', 1), ('a', 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue is that the <code>while</code> loop correctly counts occurrences, the <code>for</code> loop marches on inexorably, one character at a time. Since you're already incrementing the index correctly in the <code>while</code> loop, the simplest thing would be to get rid of either the <code>for</code> or <code>while</code> loop entirely. The only purpose to having multiple loops here is to attempt to avoid an <code>if</code>, and as you see, that doesn't really work.</p>
<pre><code>res = []
prev = ''
for letter in lst:
    if prev == letter:
        letter_count += 1
    else:
        if prev:
            res.append((prev, letter_count))
        letter_count = 1
    prev = letter
</code></pre>
<p>This is similar to what you'd get from <code>itertools.groupby</code>:</p>
<pre><code>[(k, len(list(g))) for k, g in groupby(lst)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>groupby</code> is the pythonic way. If you want to emulate that, you can do it with <code>O(1)</code> with only one loop, no indexes (not very pythonic) and a variable to store the previous letter:</p>
<pre><code>def compress(lst):
    res = []
    previous_letter = None
    count = 0

    for letter in lst:
        if previous_letter is None:
            # first time
            count += 1
            previous_letter = letter
        elif previous_letter == letter:
            # same letter as before, count
            count += 1
        else:
            # different letter: store result, reset counter
            res.append((previous_letter,count))
            count = 1
            previous_letter = letter

     # last iteration doesn't append the last result, fix this
    res.append((previous_letter,count))
    return res
</code></pre>
<p>result:</p>
<pre><code>[('a', 2), ('b', 3), ('c', 1), ('a', 2)]
</code></pre>
</div>
<span class="comment-copy"><code>('b', 2)</code> ? sure?</span>
<span class="comment-copy">The <i>simplest</i> fix seems straightforward: add <code>if letter_count:</code> before you append.</span>
<span class="comment-copy">@Jean-Fran√ßoisFabre Corrected. Literally unbelievable, I took the answer from the solved tests they posted. This is a test from 2016, and amusingly the code they posted as their answer returns a wrong answer... Just my luck :)</span>
<span class="comment-copy">@Tegernako, The correct way to indicate a problem is "solved" is to accept an answer (green tick on left). No need to indicative "solved" in the question title.</span>
<span class="comment-copy">Not really something you would use in a test while writing the code on paper, but thanks anyway for the comment.</span>
<span class="comment-copy">No doubt itertools has insane functionality, but OP did ask how to modify <i>their</i> code...</span>
<span class="comment-copy">@dfundako, true that. Maybe helpful for readers. :)</span>
<span class="comment-copy">@Tegernako. I probably wouldn't write that on a test back when I was learning, but I totally would now.</span>
<span class="comment-copy">@MadPhysicist Agreed, yet this is my first course in programming with zero exprience in the field before I started studying, and therefore those answers are acceptable. Also, we did not learn the standard library as this is an Introduction to CS course using Python, But still a great answer, thanks.</span>
