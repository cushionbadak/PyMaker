<div class="post-text" itemprop="text">
<p>When reading source code of python logging module, I found code like this:</p>
<pre><code># next bit filched from 1.5.2's inspect.py
def currentframe():
    """Return the frame object for the caller's stack frame."""
    try:
        raise Exception
    except:
        return sys.exc_info()[2].tb_frame.f_back
</code></pre>
<p>why? Is it equals this?</p>
<pre><code>def currentframe():
    return sys.exc_info()[2].tb_frame.f_back
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Obvious - there is no <code>exc_info</code> (exception info) until some exception arises. So we need to rise exception to access its info and get call stack from it.</p>
<p>This seems to be the easiest way to access current call stack.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the official docs for <a href="https://docs.python.org/3.7/library/sys.html#sys.exc_info" rel="nofollow noreferrer"><code>sys.exc_info</code></a>, you need an exception in any stack frame to get a tuple of <code>(type, value, traceback)</code>. If there is no exception handled, you get a tuple with <code>None</code> values. The stack frame could be: the current stack, or the calling stack for a function or the caller(function) itself. In logging, we are concerned with the <code>traceback</code> for the current stack(notice <code>sys.exc_info()[2]</code>) only and therefore will have to raise an Exception in order to access the tuple values. Here's an excerpt from the docs:</p>
<blockquote>
<p>This function returns a tuple of three values that give information about the exception that is currently being handled. The information returned is specific both to the current thread and to the current stack frame. If the current stack frame is not handling an exception, the information is taken from the calling stack frame, or its caller, and so on until a stack frame is found that is handling an exception. Here, “handling an exception” is defined as “executing an except clause.” For any stack frame, only information about the exception being currently handled is accessible.</p>
<p>If no exception is being handled anywhere on the stack, a tuple
  containing three None values is returned. Otherwise, the values
  returned are (type, value, traceback). Their meaning is: type gets the
  type of the exception being handled (a subclass of BaseException);
  value gets the exception instance (an instance of the exception type);
  traceback gets a traceback object (see the Reference Manual) which
  encapsulates the call stack at the point where the exception
  originally occurred.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/sys.html#sys._getframe" rel="nofollow noreferrer">sys._getframe([depth])</a> returns the frame object from the call stack. If optional integer <em>depth</em> is given, return the frame object that many calls below the top of the stack. The default for depth is zero, returning the frame at the top of the call stack. </p>
<p>Another important point to consider is that <em>this function is not guaranteed to exist in all implementations of Python</em>. We know that CPython has it. The following piece of code from <code>logging/__init__.py</code> performs this check. Note that <code>currentframe()</code> is a lambda function.:</p>
<pre><code>if hasattr(sys, '_getframe'):
    currentframe = lambda: sys._getframe(3)
</code></pre>
<p>This means: <em>if sys._getframe() exists in the Python implementation, return the 3rd frame object from the top of the call stack</em>.  If <code>sys</code> does not have this function as an attribute, the <code>else</code> statement below raises an Exception to capture the frame object from the <code>Traceback</code>.</p>
<pre><code>else: #pragma: no cover
    def currentframe():
        """Return the frame object for the caller's stack frame."""
        try:
            raise Exception
        except Exception:
            return sys.exc_info()[2].tb_frame.f_back
</code></pre>
<p>To understand this concept better, I've used the above <code>if-else</code> code to frame an example(no pun intended). This is inspired by the excellent explanation <a href="http://farmdev.com/src/secrets/framehack/index.html" rel="nofollow noreferrer">here</a>. The following example contains 3 functions which were saved in a file called <code>main.py</code>.</p>
<pre><code>#main.py

def get_current_frame(x):    
    print("Reached get_current_frame")
    if hasattr(sys, '_getframe'):
        currentframe = lambda x: sys._getframe(x)    
    else: #pragma: no cover
        def currentframe():
            """Return the frame object for the caller's stack frame."""
            try:
                raise Exception
            except Exception:                    
                return sys.exc_info()[2].tb_frame.f_back
    return currentframe

def show_frame(num, frame):
    print("Reached show_frame")
    print(frame)
    print("  frame     = sys._getframe(%s)" % num)
    print("  function  = %s()" % frame(num).f_code.co_name)
    print("  file/line = %s:%s" % (frame(num).f_code.co_filename, frame(num).f_lineno))

def test():
    print("Reached test")
    for num in range(4):
        frame = get_current_frame(num)
        show_frame(num, frame)    

#function call
test()  
</code></pre>
<p>On running this code with <code>python main.py</code>, we get the following output:</p>
<pre><code>Reached test
Reached get_current_frame
Reached show_frame
&lt;function get_current_frame.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000002EB0AE8&gt;
  frame     = sys._getframe(0)
  function  = &lt;lambda&gt;()
  file/line = main.py:74
Reached get_current_frame
Reached show_frame
&lt;function get_current_frame.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000002EB0B70&gt;
  frame     = sys._getframe(1)
  function  = show_frame()
  file/line = main.py:96
Reached get_current_frame
Reached show_frame
&lt;function get_current_frame.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000002EB0AE8&gt;
  frame     = sys._getframe(2)
  function  = test()
  file/line = main.py:89
Reached get_current_frame
Reached show_frame
&lt;function get_current_frame.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000002EB0B70&gt;
  frame     = sys._getframe(3)
  function  = &lt;module&gt;()
  file/line = main.py:115
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li><p><strong>Function get_current_frame(x)</strong>: This function contains the same code from the <code>if-else</code> statement from <code>logging/__init__.py</code>. The only difference is that we are passing the <em>depth</em> argument <code>x</code> to the function which is used by the <code>lambda</code> function to grab the frame object at that <em>depth</em>: <code>currentframe = lambda: sys._getframe(x)</code>.</p></li>
<li><p><strong>Function show_frame(num, frame)</strong>: This function <code>print</code>s the <em>frame object</em>, the frame function call with its <em>depth</em>, <code>sys._getframe(num)</code>, the caller function name eg. <code>show_frame()</code>..etc. , the file name of the file that executes the calling function code along with the current line no. in the code of the calling function. <code>f_code</code> is an attribute of the frame object returned by <code>sys._getframe()</code> and is a code object. <code>co_name</code> is an attribute of this code object and returns the name with which the code object was defined(you can print <code>f_code</code> to check this). Similarly, <code>co_filename</code> retrieves the filename and <code>f_lineno</code> retrieves the current line no. You can find an explanation of these attributes in the <a href="https://docs.python.org/3.7/library/inspect.html#module-inspect" rel="nofollow noreferrer">inspect</a> docs which is also used to get frame objects interestingly. You can also write some isolated code to understand how these attributes work. For eg. the below code gets the current frame <code>frameobj</code>(i.e.: the frame object at the top of the stack, depth 0(default)) and prints the filename of the code object for that frame(I'm running this code in <code>main_module.py</code>). </p>
<pre><code>import sys
frameobj = sys._getframe()
print(frameobj.f_code.co_filename)
#output:
main_module.py
</code></pre>
<p>The calling stack is not too deep because there is just one function call to 
<code>_getframe()</code>. If we change the code to get the frame at depth 1, we get an 
error:</p>
<pre><code>    Traceback (most recent call last):
  File "main_module.py", line 3, in &lt;module&gt;
    frameobj = sys._getframe(1)
ValueError: call stack is not deep enough
</code></pre></li>
<li><p><strong>Function test()</strong>: This function gets the current frame object for depth <code>num</code> in some range and then calls <code>show_frame()</code> for that <code>num</code> and frame object.</p></li>
</ul>
<p>When <code>test()</code> is called, the calling stack is: <strong>test --&gt; get_current_frame --&gt; show_frame</strong>. In subsequent calls, the stack is <strong>get_current_frame ---&gt; show_frame</strong> until the <code>for</code> loop completes for the range(4) in <code>test()</code>. If we examine the output from the top, the frame at the top of the stack has depth 0: 
<code>frame     = sys._getframe(0)</code> and the calling function is the lambda function itself. The line no. 74 in <code>file/line = main.py:74</code> is the current line no. when this function was called(imagine it like the last cursor position for that frame). Finally, we look at the frame at the bottom of the stack. This is also the frame object(with depth 3) that is used in logging:</p>
<pre><code>Reached get_current_frame
Reached show_frame
&lt;function get_current_frame.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000002EB0B70&gt;
  frame     = sys._getframe(3)
  function  = &lt;module&gt;()
  file/line = main.py:115
</code></pre>
<p>In logging, we need a depth of 3 to reach the stack frame of the caller function. </p>
<p>We can also use our previous toy example to understand this concept. As the stack is not too deep, we get the current frame at <em>depth</em> 0.</p>
<pre><code>import sys
frameobj = sys._getframe()
print(frameobj.f_code.co_name)
#Output:
&lt;module&gt;
</code></pre>
<p>Now, what if my Python implementation does not have <code>_getframe()</code> attribute for <code>sys</code>? In this case, the code in <code>else</code> will execute and raise an Exception to get the current frame from the <code>traceback</code>. The following function does this and the calling function here is <code>&lt;module&gt;</code> again(notice the output):</p>
<pre><code>def currentframe():
            """Return the frame object for the caller's stack frame."""
            try:
                # test = 'x' + 1
                raise Exception
            except Exception:                    
                _type, _value, _traceback = sys.exc_info()
                print("Type: {}, Value:{}, Traceback:{}".format(_type, _value, _traceback))
                print("Calling function:{}, Calling file: {}".format(sys.exc_info()[2].tb_frame.f_back.f_code.co_name, sys.exc_info()[2].tb_frame.f_back.f_code.co_filename))
                return sys.exc_info()[2].tb_frame.f_back   
currentframe()    

#Output:
Type: &lt;class 'Exception'&gt;, Value:, Traceback:&lt;traceback object at 0x0000000002EFEB48&gt;
Calling function:&lt;module&gt;, Calling file: main.py
</code></pre>
<p><code>f_back</code> returns the frame object for the traceback frame <code>tb_frame</code> returned by the current Exception . We can check this by printing the return statement: <code>print(sys.exc_info()[2].tb_frame.f_back)</code> and we get something like: <code>&lt;frame object at 0x000000000049B2C8&gt;</code></p>
<p>This explains how the logging module captures the current frame.</p>
<p>So, where is <code>currentframe()</code> later used in the logging source code? You will find it here:</p>
<pre><code>def findCaller(self, stack_info=False):
    """
    Find the stack frame of the caller so that we can note the source
    file name, line number and function name.
    """
    f = currentframe()
    #&lt;----code----&gt;
</code></pre>
<p>The above function gets the current frame of the caller function and uses this information later to get the same attributes(file name etc.) that we accessed earlier.</p>
</div>
<span class="comment-copy">short and useful. I can be more careful.</span>
<span class="comment-copy">tks for your excellent answer. I got your word. And what's difference between sys._getframe() and sys.exc_info(). Can we get enough info from sys._getframe()?</span>
<span class="comment-copy">I just added some more details to my answer.</span>
