<div class="post-text" itemprop="text">
<p>I was experimenting with various ways of creating an infinite loop in Python (other than the usual <code>while True</code>), and came up with this idea:</p>
<pre><code>x = {0: None}

for i in x:
    del x[i]
    x[i+1] = None  # Value doesn't matter, so I set it to None
    print(i)
</code></pre>
<p>On paper, I traced out the way this would infinitely loop:</p>
<ol>
<li>I loop through the key's value in the dictionary</li>
<li>I delete that entry.</li>
<li>The current counter position in the loop <code>+ 1</code> will be the new key with value <code>None</code> which updates the dictionary.</li>
<li>I output the current counter.</li>
</ol>
<p>This, in my head, should output the natural numbers in a sort of infinite loop fashion:</p>
<pre><code>0
1
2
3
4
5
.
.
.
</code></pre>
<p>I thought this idea was clever, however when I run it on Python 3.6, it outputs:</p>
<pre><code>0
1
2
3
4
</code></pre>
<p>Yes, it somehow stopped after 5 iterations. Clearly, there is no base condition or sentinel value in the code block of the loop, so why is Python only running this code 5 times?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no guarantee that you will iterate over all your dict entries if you mutate it in your loop. From the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Iterating views while adding or deleting entries in the dictionary may
  raise a RuntimeError or fail to iterate over all entries.</p>
</blockquote>
<p>You could create an "enumerated" infinite loop similar to your initial attempt using <code>itertools.count()</code>. For example:</p>
<pre><code>from itertools import count

for i in count():
    print(i)
    # don't run this without some mechanism to break the loop, i.e.
    # if i == 10:
    #     break

# OUTPUT
# 0
# 1
# 2
# ...and so on
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this case, like @benvc wrote, this is not guaranteed to work. But in case you wonder why does it work in C-Python:</p>
<p>The C-Python implementation destroys the dict object after some inserts and copies it to a new space in memory. It does not care about deletions. So when this happens, the loop notices it and breaking with an exception.</p>
<p>Check out this link if you want to read more about this, and many other interesting  python internals here.</p>
<p><a href="https://github.com/satwikkansal/wtfpython#-modifying-a-dictionary-while-iterating-over-it" rel="noreferrer">https://github.com/satwikkansal/wtfpython#-modifying-a-dictionary-while-iterating-over-it</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I just tested your code in python2 and python3</p>
<pre><code>python3 output
0,1,2,3,4
python2
0,1,2,3,4,5,6,7
</code></pre>
<p>One thing comes to mind that could be going on. Either there is only a certain amount of memory being allocated in your dictionary when you create the first key value and when you delete the key value we do not allocate any memory or deallocate the memory you are just removing the value. Once all the allocated memory is used it exits. Because if you run without that del you will get this error</p>
<pre><code>RuntimeError: dictionary changed size during iteration
</code></pre>
<p>So python creates enough memory for that key value and a few more and once it is used up theres no more memory allocated for your dictionary. </p>
</div>
<div class="post-text" itemprop="text">
<p>As many pointed out, modifying a datastructure during iteration with a <code>for</code> loop is not a good idea. The <code>while</code> loop though does allow that as it re-evaluates its loop condition at each iteration (I'm impressed nobody suggested that as alternative yet). One just has to find the right loop condition. Your script would have to become:</p>
<pre><code>x = {0: None}
while x:
    i, _ = x.popitem()
    print(i)
    # to avoid infinite loop while testing
    # if i == 10:
    #     break
    x[i+1] = None
</code></pre>
<p>In Python, a dictionary is falsy when it is empty (see <a href="https://docs.python.org/3.7/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">docs</a>), so the loop will only stop if at the beginning of an iteration <code>x</code> is empty. 
Since the dictionary only has one key-value pair, <a href="https://docs.python.org/3/library/stdtypes.html#dict.popitem" rel="nofollow noreferrer"><code>popitem()</code></a> should be enough to get that pair and remove it from the dictionary. As the next integer is added right after the dictionary is emptied, the loop condition will never be false when evaluated thereby resulting in an infinite loop.</p>
</div>
<span class="comment-copy">Mutating an object that you're iterating over is pretty much guaranteed to give you unpredictable results.  In your specific case, I would guess that the <code>4</code> went into a hash bucket that had already been iterated over.</span>
<span class="comment-copy">@jasonharper: CPython 3.6 is when they introduced the new compact dict implementation, so bucket locations wouldn't have this effect on 3.6. This looks like the dict needed a rebuild after the <code>5</code> was inserted, which would have re-compacted the compact array of entries and shifted the entry for the <code>5</code> to the left of the iterator position.</span>
<span class="comment-copy">You are making unwarranted assumptions about the dictionary iterator. The only assumption that you <i>should</i> make is that it isn't guaranteed to work if you add/remove from the dictionary while iterating over it. What actually ends up happening will depend on various implementation details.</span>
<span class="comment-copy">Thanks for the tip on dictionaries, but the code below was sort of unnecessary. I didn't really want an infinite loop in my code, just a fun project of coming up with odd ways, but turns out mines didn't work. Thanks anyways.</span>
<span class="comment-copy">@SurajKothari - added the example in case someone else ends up looking at your question in an effort to generate an "enumerated" infinite loop (or more usefully an indefinite loop where the breakpoint is determined by some other operation at runtime) similar to your initial attempt.</span>
<span class="comment-copy">@SurajKothari you can make it work by using a <code>while</code> loop instead of a <code>for</code> loop. Check out <a href="https://stackoverflow.com/a/54325385/7170434">this answer</a> for more details.</span>
<span class="comment-copy">Are you sure Python 3 gives 8 iterations? Mines gave 5 (0 to 4) in Python 3.6.1</span>
<span class="comment-copy">I just tested it and perhaps you have the versions the other way around. Python 2.7 gives (0 to 7) and Python 3 gives (0 to 4)</span>
<span class="comment-copy">@SurajKothari This is implementation dependend.  Python 2.7 might also be Jython instead of CPython and even CPython might exhibit different behaviour for the same version, for instance when compiled for a 32 bit system or a 64 bit system.</span>
<span class="comment-copy"><code>while len(x):</code> ouch! Why not <code>while x:</code>?</span>
<span class="comment-copy">Thanks for pointing that out @Robin</span>
