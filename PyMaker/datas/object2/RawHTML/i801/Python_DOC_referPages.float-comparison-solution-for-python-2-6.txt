<div class="post-text" itemprop="text">
<p>I am doing a simple comparison between a string value and floats minValue and maxValue to check if value is outside of a certain range </p>
<pre><code>if float(value) &lt; minValue or float(value) &gt; maxValue:
    # show error and exit
</code></pre>
<p>It works fine unless value and minValue are the same. So when <code>value = -1.234</code> and <code>minValue = -1.234</code>, it goes inside the if statement because for some reason <code>-1.234 &lt; -1.234</code> evaluates to <code>True</code>.</p>
<p>My workaround is to use Decimal </p>
<pre><code>if Decimal(value) &lt; Decimal(str(minValue)) or Decimal(str(value) &gt; Decimal(maxValue):
    # show error and exit
</code></pre>
<p>But <code>Decimal(str(minValue))</code> looks a little messy so I'm wondering if there is a better way of comparing two floats that won't fail when they are the same value without having to do float to string to decimal conversion first.</p>
<p><strong>EDIT</strong></p>
<p><code>value</code> comes from a csv file, so there is no truncation there. What you see is what you get. <code>minValue</code> is, however, a result of a polynomial function, but I don't believe there is any truncation or rounding there.</p>
<p>Here's the function to calculate minValue</p>
<pre><code>f = numpy.poly1d(coefficients)
x = range(int(low), int(high), 1)
y = f(x)
minValue = min(y)
maxValue = max(y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note that in general, this isn't going to be solvable without <code>Decimal</code>; floating point math is inherently imprecise across many calculations, and what should logically arrive at <code>-1.234</code> can easily become <code>-1.2339999999999998</code> or <code>-1.2340000000000002</code> (only for illustration, your computer may differ, but those are the closest values to <code>-1.234</code> on either side on my machine that don't end up rounding off to the canonical representation of <code>-1.234</code>; your calculation might be that close, or it might be off by a bit more, but likely still an error of less than <code>0.00000000001</code>).</p>
<p>That said, if you happen to know, with certainty, that your values should never need more than <code>X</code> decimal places of precision, you can often get away with using the faster <code>float</code>, via <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">the <code>round</code> function</a>, to ensure your values are really the closest representable value to what they should be logically. Since it appears <code>minValue</code> and <code>maxValue</code> are computed once up front, just change the last step to round them off as well, e.g.:</p>
<pre><code>minValue = round(min(y), 3)
maxValue = round(max(y), 3)
</code></pre>
<p>which removes any spurious excess precision. Heck, if you're not sure how precise you need to be, just double your best guess; the imprecision you're likely to see in most cases is usually well past 10 digits past the decimal point, so if you only think you need three digits, but you're worried you might still remove valid data (e.g. maybe you've got a division by <code>8</code> that might leave an extra, valid <code>125</code> at the end), just go up a bit more, rounding to <code>6</code>, or even <code>9</code> decimal places.</p>
<p>Similarly, change the code that performs the comparison to normalize <code>value</code> as well, e.g.:</p>
<pre><code>if round(float(value), 3) &lt; minValue or round(float(value), 3) &gt; maxValue:
</code></pre>
<p>or even better (avoids doubling up the conversion code):</p>
<pre><code>if not minValue &lt;= round(float(value), 3) &lt;= maxValue:
</code></pre>
<p>which takes advantage of Python's chained comparison operators (it's equivalent to typing <code>if not (minValue &lt;= round(float(value), 3) and round(float(value), 3) &lt;= maxValue):</code>, except <code>round(float(value), 3)</code> is only computed once).</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason it is not working is becasue <code>-1.234</code> is not greater or less than <code>-1.234</code>. <code>-1.234 &gt; 1.234</code> is false and <code>-1.234 &lt; 1.234</code>is also false. If you want to also make it true if they are equal you would need to use <code>=&gt;</code> or <code>=&lt;</code> which means "greater then or equal to" </p>
<pre><code>&gt;&gt;&gt; value=-1.234
&gt;&gt;&gt; maxValue=-1.234
&gt;&gt;&gt; minValue=-1.234
&gt;&gt;&gt; float(value)
-1.234
&gt;&gt;&gt; float(value) &lt; minValue or float(value) &gt; maxValue
False
&gt;&gt;&gt; float(value) &lt;= minValue or float(value) &gt;= maxValue
True
</code></pre>
</div>
<span class="comment-copy">Without seeing how you get the values, it's hard to answer this question. See <a href="https://stackoverflow.com/q/588004/2988730">stackoverflow.com/q/588004/2988730</a></span>
<span class="comment-copy">Are you sure that <code>value</code> and <code>minValue</code> are both <i>exactly</i> <code>-1.234</code>? If you're thinking "yes, I know because I printed both of them", keep in mind that there are many float values which are only slightly larger or smaller than -1.234, and thus get printed as "-1.234" when some of their digits are truncated.</span>
<span class="comment-copy">Related: <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken" title="is floating point math broken">stackoverflow.com/questions/588004/…</a></span>
<span class="comment-copy">Also: <a href="https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison" title="how should i do floating point comparison">stackoverflow.com/questions/4915462/…</a> (yes, the code is in Java, but the underlying concepts are the same)</span>
<span class="comment-copy">Agreed with @Kevin. It's almost certain that you had a sequence of math operations to compute <code>minValue</code> and/or <code>value</code> that would logically arrive at <code>-1.234</code>, but in fact arrive at <code>-1.23400000000000000003</code> (for <code>value</code>) or <code>-1.2339999999999995</code> (for <code>minValue</code>) or the like.</span>
<span class="comment-copy">Thank you for the detailed response. I think you are right and it must be the nature of floating point calculations that is causing this issue. Rounding my min and max values to 5 decimal places fixed my problem and the comparison is working as intended. I have accepted your answer as correct.</span>
<span class="comment-copy">@Max: Glad it helped. If you can, please take the time to read a bit more about <a href="https://en.wikipedia.org/wiki/IEEE_754#Basic_and_interchange_formats" rel="nofollow noreferrer">IEEE 754 binary floating point</a> (the spec behind floating point math on most architectures and languages) and <a href="https://stackoverflow.com/q/4915462/364696">its</a> <a href="https://stackoverflow.com/q/588004/364696">pitfalls</a>, in particular <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow noreferrer">the <code>binary64</code> format</a> (aka C's <code>double</code>) that is the underlying type of Python's <code>float</code> object. When precision matters, it always lets you down.</span>
<span class="comment-copy">I appreciate the resource links, I will make sure to read up more on floating point.</span>
<span class="comment-copy">Just in case it ever comes up, so you know to be aware of the possibility: Not all architectures' floating point is IEEE 754 compliant. And even when it is, it might differ based on compiler settings (IEEE 754 has some strict rules on order of operations and the like that inhibit compiler optimizations, and some compilers will default to less strict rules to gain speed unless explicitly told not to). I've had a C calculation result in <code>16.00...001</code> on one machine, and <code>15.99...994</code> on another; the code being ported cast it to <code>int</code>, then multiplied; the final value was off by <i>100</i>. :-(</span>
<span class="comment-copy">Wow. Being off by 100 really shows how fast this can escalate from a minor rounding inconsistency to being completely out of range. So the moral of the story is that you can never trust a floating point number hahaha</span>
<span class="comment-copy">They want the statement to be false when they're equal. That is, <code>value</code> is allowed to be the <i>same</i> as <code>minValue</code>, just not <i>smaller</i>. The test is for out of bounds conditions that trigger an error, not in bounds conditions, and the bounds are inclusive bounds, not exclusive.</span>
