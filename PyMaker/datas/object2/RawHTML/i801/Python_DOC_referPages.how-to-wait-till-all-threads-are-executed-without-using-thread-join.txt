<div class="post-text" itemprop="text">
<p>I am working on a code where threads are generated in a recursive function. So its tedious to follow all threads. Thread.join() is not feasible. You can do it but with a lot of effort. What I want is to wait till all threads(child process) are completed, before printing result generated after running threads. I guess you can get the gist of the problem. All I want is to execute a statement just before exiting the main program.</p>
</div>
<div class="post-text" itemprop="text">
<p>Did you try using the <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer">concurrent.futures</a> package?</p>
<p>You can instantiate a <code>ThreadPoolExecutor</code> and start your threads by submitting to it.
Then call the executor's <code>shutdown(wait=True)</code> function to wait for all threads to complete.</p>
<p>Alternatively, use a <code>with ThreadPoolExecutor as e:</code> statement. When you exit the <code>with</code> block, all your threads are completed.</p>
</div>
<span class="comment-copy">Can't you resort to appending threads to a threads list and then <code>[thread.join() for thread in threads]</code>?</span>
<span class="comment-copy">Does <a href="https://stackoverflow.com/questions/11968689/python-multithreading-wait-till-all-threads-finished">this</a> answer helps?</span>
<span class="comment-copy">You want to wait for threads to die. That's what <code>join()</code> <i>does</i>.  How is it not "feasible?" Why can't you make a list? Every time you create a thread, add the <code>Thread</code> object to the list.  When it's time to wait for all of the threads to die, iterate over the list and <code>join()</code> each one.</span>
<span class="comment-copy">Or create a list of the threads and keep iterating over it until all are <code>not lst[i].is_alive()</code>. This is a bad practice called "busy waiting" however...</span>
<span class="comment-copy">Re, "...threads are generated in a recursive function..." That sounds <i>very</i> suspicious. What are those threads doing? Why aren't you using a <i><a href="https://en.wikipedia.org/wiki/Thread_pool" rel="nofollow noreferrer">thread pool</a></i>?  (as in, djoffe's answer, below)</span>
<span class="comment-copy">Note: This doesn't actually create a thread per task (it's a pool of thread workers). That said, you usually don't <i>want</i> a thread per task for a ton of small tasks, so this is likely better than the OP's proposed solution.</span>
<span class="comment-copy">Shadow ranger can you elaborate what you mentioned? Are you talking about djoffe answer?</span>
<span class="comment-copy">@KRISHNAI: Executors create a pool of workers (threads for <code>ThreadPoolExecutor</code>) immediately, all of which listen to a queue for work items. <code>submit</code> doesn't launch new threads, it just packages up the task and shoves it on the queue to be pulled by the first available worker. In practice, this is usually better than a thread per worker, since the cost of launching a thread is non-trivial, and for 1000+ work items, you might not be <i>able</i> to run that many threads simultaneously.</span>
<span class="comment-copy">Oh! Thanks ShadowRanger</span>
