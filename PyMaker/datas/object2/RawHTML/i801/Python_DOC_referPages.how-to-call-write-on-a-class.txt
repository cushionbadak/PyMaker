<div class="post-text" itemprop="text">
<p>I have a set of python classes that represent network data structures (and are also used for disk storage). I'd like to be able to call <code>write()</code> on the class and get its standard binary representation.</p>
<p>The classes can struct.pack themselves into a binary representation via a <code>pack()</code> method. I can overwrite the <code>__bytes__</code> method to call <code>self.pack()</code> so that <code>write(bytes(myobject))</code> will work, but not write (myobject):</p>
<pre><code>TypeError: a bytes-like object is required, not 'MyClassName'
</code></pre>
<p>Is there something I can override to make <code>write()</code> work without the explicit <code>bytes()</code> cast? Possibly my class would have to be a subclass of Bytes but ... I presume I'd still have to hook up the <code>pack()</code> method call somehow?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make the class a subclass of <code>bytearray</code> and make any methods that can alter the object's value update the bytearray's value via the <code>__setitem__</code> method (that is, using square brackets):</p>
<pre><code>class MyClassName(bytearray):
    def update(self):
        ''' a method that makes certain alterations to the object's value '''
        self[:] = self.pack()
</code></pre>
</div>
<span class="comment-copy">Maybe you could wrap the stream and adapt it to call bytes first.</span>
<span class="comment-copy">Are you just trying to save classes/objects to disk? Would pickle (<a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">docs.python.org/3/library/pickle.html</a>) work for you?</span>
<span class="comment-copy">What's so bad about calling <code>bytes</code>? This seems like the best solution. Explicit is better than implicit. Now, what <code>write</code> is really expecting is an object that supports the buffer protocol. Unfortunately, I believe you have to write a C-extension to support this in your custom class.</span>
<span class="comment-copy">Consider: <a href="https://jakevdp.github.io/blog/2014/05/05/introduction-to-the-python-buffer-protocol/" rel="nofollow noreferrer">jakevdp.github.io/blog/2014/05/05/â€¦</a></span>
<span class="comment-copy">Can't use pickle - it needs to match a predefined on disk format.  I looked at the buffer code, seems staggeringly complex for a very simple problem - I just have an OrderedDict of (name, typename) pairs that match a C struct. Adding new ones as a derived class of my base PackedStruct type this way is trivial, just write out the struct as an OrderedDict.</span>
<span class="comment-copy">You <i>could</i> do this, but that's probably not a good idea. Unless it makes sense for <code>MyClass</code> to <i>be</i> a bytearray. I'm not sure that this would work anyway, because what the <code>write</code> method is expecting is an object that supports the buffer protocol</span>
<span class="comment-copy">By subclassing <code>bytearray</code> this class will certainly support the buffer protocol so it would work as the OP intends it to. The main downside to this approach is that it may be wasteful/inefficient to have potentially multiple calls to methods that update the <code>bytearray</code> value for several times before a <code>write</code> is actually called on this object. Ideally the <code>pack</code> method should be called only when a <code>write</code> is actually called.</span>
<span class="comment-copy">yes, I skipped over the <code>self[:] = self.pack()</code>, but I still think that the major downside here is that <code>MyClass</code> shouldn't subclass <code>bytearray</code> unless it <i>is</i> a bytearray of sorts.</span>
<span class="comment-copy">Thanks, I'll try this and update when I find out. It is a bytearray of sorts, it's a fixed data format structure that matches a packed C struct either on disk or network to allow Python to store data efficiently and intercommunicate with the main C code.</span>
