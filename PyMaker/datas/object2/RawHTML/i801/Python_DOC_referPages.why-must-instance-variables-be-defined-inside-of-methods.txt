<div class="post-text" itemprop="text">
<p>Why must instance variables be defined inside of methods? In other words why must self only be used to define new variables inside of methods in a class. Why can't you define variables using self as part of the class, but outside of methods. </p>
<p>"Instance variables are those variables for which each class object has it's own copy of it" - this definition doesn't say anything about methods. So, given that the definition doesn't mention methods why can't I define an instance variable (in other words use self to define a new variable) inside of a class, but outside of a method? </p>
</div>
<div class="post-text" itemprop="text">
<p>Python requires the object reference (implicit or explicit <code>this</code> in Java, for example) to be explicit. Inside methods -- bound functions --  the first param in the function definition is the instance. (This is  conventionally called <code>self</code> but you can use any name.)</p>
<p>If you define </p>
<pre><code> class C:
      x = 1
</code></pre>
<p>there is no <code>self</code> reference, unlike, e.g. Java, where <code>this</code> is implicit. </p>
</div>
<div class="post-text" itemprop="text">
<p>Because the mechanism which Python uses to deal with OOP are very simple. There's no special syntax to define classes really, the <code>class</code> keyword is a very thin layer over what amounts to creating a <code>dict</code>. Everything you define inside a <code>class Foo:</code> block basically ends up as the contents of <code>Foo.__dict__</code>. So there's no syntax to define attributes of the instance resulting from calling <code>Foo()</code>. You add instance attributes simply by attaching them to the object you get from calling <code>Foo()</code>, which is <code>self</code> in <code>__init__</code> or other instance methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>For that to answer you need to know a little bit how the Python interpreter works.</p>
<p>In general every class and method definition are separate objects.
What you do when calling a method is that you pass the class instance as first parameter to the method. With that the method knows on what instance it is running on (and therefore where to allocate instance variables to).
This however only counts for instance methods.
Of course you can also create classmethods with <code>@classmethod</code> these take the class type as argument instead of an instance and can therefore not be used to create variables on the <code>self</code> context.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why must instance variables be defined inside of methods?</p>
</blockquote>
<p>They don't. You can define them from anywhere, <strong>as long as you have an instance</strong> (of a mutable type):</p>
<pre><code>class Foo(object):
    pass


f = Foo()
f.bar = 42
print(f.bar)
</code></pre>
<blockquote>
<p>In other words why must self only be used to define new variables inside of methods in a class. Why can't you define variables using self as part of the class, but outside of methods.</p>
</blockquote>
<p><code>self</code> (which is only a naming convention, <a href="https://wiki.python.org/moin/FromFunctionToMethod" rel="nofollow noreferrer">there's absolutely nothing magical here</a>) is used to represent the current instance. How could you use it at the class block's top-level where you don't have any instance at all (and not even the class itself FWIW) ?</p>
<p>Defining the class "members" at the class top-level is mostly a static languages thing, where "objects" are mainly (technically) structs (C style structs, or Pascal style records if you prefer) with a statically defined memory structure. </p>
<p>Python is a dynamic language, which instead uses <code>dicts</code> as supporting data structure, so <code>someobj.attribute</code> is usually (minus computed attributes etc) resolved as <code>someobj.__dict__["attribute"]</code> (and <code>someobj.attribute = value</code> as <code>someobj.__dict__["attribute"] = value</code>). </p>
<p>So 1/ it doesn't NEED to have a fixed, explicitely defined data structure, and 2/ yet it DOES need to have an instance at end to set an attribute on it.</p>
<p>Note that you can force a class to use a fixed memory structure (instead of a plain dict) <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer">using slots</a>, but you will still need to set the values from within a method (canonically the <code>__init__</code>, which exists for this very reason: initializing the instance's attributes).</p>
</div>
<span class="comment-copy">Why do you think you cant? What is your reason for believing that?</span>
<span class="comment-copy">Because inside the class <code>self</code> does not exist, it is passed in method calls.  Note that <code>self</code> is not a reserved word.</span>
<span class="comment-copy">checkout <a href="https://docs.python.org/3.7/tutorial/classes.html#class-objects" rel="nofollow noreferrer">docs.python.org/3.7/tutorial/classes.html#class-objects</a></span>
