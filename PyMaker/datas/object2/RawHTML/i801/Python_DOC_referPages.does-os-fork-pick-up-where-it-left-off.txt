<div class="post-text" itemprop="text">
<p>I have a function where certain data is being processed, and if the data meets a certain criteria, it's to be handled separate while the rest of the data is being processed. </p>
<p>As an arbitrary example if I'm scraping a web page and collecting all the attributes of an element, one of the elements is a form and just so happens to be hidden, I want to handle it separate, while the rest of the elements can continue being processed:</p>
<pre><code>def get_hidden_forms(element_att):
    if element_att == 'hidden':
        os.fork()
        # handle this seperate
    else:
        # continue handling any elements that are not hidden
    #join both processes
</code></pre>
<p>Can this be done with os.fork() or is it intended for another purpose?</p>
<p>I know that os.fork() copies everything about the object, but I could just change values before forking, as stated in <a href="https://stackoverflow.com/questions/13461548/how-to-pass-arguments-to-processes-created-by-fork">this post</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>fork</code> basically creates a clone of the process calling it with a new address space and new PID.</p>
<p>From that point on, both processes would continue running next instruction after the <code>fork()</code> call. For this purpose, you normally inspect it's return value and decide what is appropriate action. If it return <code>int</code> greater than <code>0</code>, it's the PID of child process and you know you are in its parent... you continue parents work. If it's equal to <code>0</code>, you are in a child process and should do child's work. Value less then <code>0</code> means <code>fork</code> has failed, Python would handle that and raise <code>OSError</code> which you should handle (you're still in and there only is a parent).</p>
<p>Now the absolute minimum you'd need to take care of having forked a child process is to also make sure you <code>wait()</code> for them and reap their return codes properly, otherwise you will (at least temporarily) create zombies. That actually means you may want to implement a <code>SICHLD</code> handler to reap your process' children remains as they are done with their execution.</p>
<p>In theory you could use it the way you've described, but it may be a bit too "low level" (and uncomfortable) for that and perhaps would be easier to do and read/understand if you had dedicated code for what you want to handle separately and use <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="nofollow noreferrer"><code>multiprocessing</code></a> to handle running this extra work in separate processes.</p>
</div>
<span class="comment-copy">Anything against using the <code>multiprocessing</code> module? Why go all the way down to <code>os.fork()</code>?</span>
<span class="comment-copy">@yorodm No, I have nothing against the multiprocessing module, I'm not sure what led you to think that, but after reading the docs on the module I just thought that os.fork() would probably suit my needs a little better.</span>
<span class="comment-copy">That's exactly what I meant by "anything against it" (a.k.a doesn't work for you)</span>
<span class="comment-copy">@aeaglez I'm with yorodm on this one; <code>os.fork</code> is really low-level by python standards, and it usually exists to fill a specific niche. <code>multiprocessing</code> offers a saner API built on top of the <code>fork</code> API.</span>
<span class="comment-copy">There is dedicated code for it, the only thing I'm contemplating is how they would join together in one process again. For multiprocessing I could just spawn a new process, keep my current one running, and before the critical section is over, join them? Would that suffice?</span>
<span class="comment-copy">Short version is yes. <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.join" rel="nofollow noreferrer"><code>.join()</code></a> would wait for the other process to finish (if it has not done so in the meanwhile). Unless you really need the low-level control, I'd prefer comfort of greater abstraction which should allow for simpler code.</span>
