<div class="post-text" itemprop="text">
<p>I'm trying to 'export' from an xml playlist to an html table for sharing. But the iTunes library file uses pairs of key values instead of more meaningful XML tags. Is there a simple way to also get the <code>&lt;value&gt;</code> in these key/value pairs?</p>
<p>This gets me as far as the value of the <code>&lt;key&gt;</code>, i.e. Track ID Name Artist Album Artist etc., but I can't seem to find a way to also get the value of the next key, i.e. <code>&lt;integer&gt;</code> 49924, or <code>&lt;string&gt;</code> Ep. 35 | What Do Your... Can (should) I do this with ElementTree or should I move along to Regular Expressions or some other library? Thanks!</p>
<pre><code>data = '''&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;Major Version&lt;/key&gt;&lt;integer&gt;1&lt;/integer&gt;
    &lt;key&gt;Minor Version&lt;/key&gt;&lt;integer&gt;1&lt;/integer&gt;
    &lt;key&gt;Date&lt;/key&gt;&lt;date&gt;2019-01-21T07:31:15Z&lt;/date&gt;
    &lt;key&gt;Application Version&lt;/key&gt;&lt;string&gt;12.8.0.150&lt;/string&gt;
    &lt;key&gt;Features&lt;/key&gt;&lt;integer&gt;5&lt;/integer&gt;
    &lt;key&gt;Show Content Ratings&lt;/key&gt;&lt;true/&gt;
    &lt;key&gt;Music Folder&lt;/key&gt;&lt;string&gt;file:///Users/Music/iTunes/iTunes%20Media/&lt;/string&gt;
    &lt;key&gt;Library Persistent ID&lt;/key&gt;&lt;string&gt;75E62CF156F5AE1B&lt;/string&gt;
    &lt;key&gt;Tracks&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;49924&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Track ID&lt;/key&gt;&lt;integer&gt;49924&lt;/integer&gt;
            &lt;key&gt;Name&lt;/key&gt;&lt;string&gt;Ep. 35 | What Do Your Morals Taste Like? | Guest: Jonathan Haidt&lt;/string&gt;
            &lt;key&gt;Artist&lt;/key&gt;&lt;string&gt;Blaze Podcast Network&lt;/string&gt;
            &lt;key&gt;Album Artist&lt;/key&gt;&lt;string&gt;Blaze Podcast Network&lt;/string&gt;
            &lt;key&gt;Album&lt;/key&gt;&lt;string&gt;Something's Off with Andrew Heaton&lt;/string&gt;
            &lt;key&gt;Genre&lt;/key&gt;&lt;string&gt;News &amp;#38; Politics&lt;/string&gt;
            &lt;key&gt;Kind&lt;/key&gt;&lt;string&gt;MPEG audio file&lt;/string&gt;
            &lt;key&gt;Size&lt;/key&gt;&lt;integer&gt;48123940&lt;/integer&gt;
            &lt;key&gt;Total Time&lt;/key&gt;&lt;integer&gt;3004133&lt;/integer&gt;
            &lt;key&gt;Year&lt;/key&gt;&lt;integer&gt;2019&lt;/integer&gt;
            &lt;key&gt;Date Modified&lt;/key&gt;&lt;date&gt;2019-01-13T01:10:30Z&lt;/date&gt;
            &lt;key&gt;Date Added&lt;/key&gt;&lt;date&gt;2019-01-13T01:10:30Z&lt;/date&gt;
            &lt;key&gt;Bit Rate&lt;/key&gt;&lt;integer&gt;128&lt;/integer&gt;
            &lt;key&gt;Sample Rate&lt;/key&gt;&lt;integer&gt;44100&lt;/integer&gt;
            &lt;key&gt;Release Date&lt;/key&gt;&lt;date&gt;2019-01-11T12:00:00Z&lt;/date&gt;
            &lt;key&gt;Artwork Count&lt;/key&gt;&lt;integer&gt;1&lt;/integer&gt;
            &lt;key&gt;Persistent ID&lt;/key&gt;&lt;string&gt;5FAE7186A09E5D3E&lt;/string&gt;
            &lt;key&gt;Disabled&lt;/key&gt;&lt;true/&gt;
            &lt;key&gt;Track Type&lt;/key&gt;&lt;string&gt;File&lt;/string&gt;
            &lt;key&gt;Purchased&lt;/key&gt;&lt;true/&gt;
            &lt;key&gt;Podcast&lt;/key&gt;&lt;true/&gt;
            &lt;key&gt;Unplayed&lt;/key&gt;&lt;true/&gt;
            &lt;key&gt;Location&lt;/key&gt;&lt;string&gt;file:///Users/Music/iTunes/iTunes%20Media/Podcasts/Something's%20Off%20with%20Andrew%20Heaton/Ep.%2035%20_%20What%20Do%20Your%20Morals%20Taste%20Like_%20_%20Guest_%20Jonathan%20Haidt.mp3&lt;/string&gt;
            &lt;key&gt;File Folder Count&lt;/key&gt;&lt;integer&gt;4&lt;/integer&gt;
            &lt;key&gt;Library Folder Count&lt;/key&gt;&lt;integer&gt;1&lt;/integer&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;'''
from xml.etree import ElementTree as ET
xml = ET.fromstring(data)
lst = xml.findall('dict/dict/dict/key')
for item in lst:
    print(item.text)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Question</strong>: How to access value element in iTunes xml</p>
</blockquote>
<p>The following solution using <code>lxml.etree.iterparse</code> appends a <code>&lt;key&gt;</code> tag with the following <code>&lt;value&gt;</code> tag to build a Python <code>dict {key:value}</code>.</p>
<p>Used <strong>module</strong> and <strong>built-in functions</strong>:  </p>
<ul>
<li><a href="https://lxml.de/3.1/api/private/lxml.etree.iterparse-class.html" rel="nofollow noreferrer"><code>lxml.etree.iterparse</code></a> </li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer"><code>object.__iter__(self)</code></a> </li>
<li><a href="https://docs.python.org/3/reference/simple_stmts.html#index-26" rel="nofollow noreferrer">The yield statement</a></li>
</ul>
<hr/>
<pre><code>from lxml import etree
import io

class Playlist:
    def __init__(self, fh):
        """
        Initialize 'iterparse' to generate 'start' and 'end' events on all tags

        :param fh: File Handle from the XML File to parse
        """
        self.context = etree.iterparse(fh, events=("start", "end",))

    def _parse(self):
        """
        Yield only at 'end' event, except 'start' from tag 'dict'
        :return: yield current Element
        """
        for event, elem in self.context:
            if elem.tag == 'plist' or \
                    (event == 'start' and not elem.tag == 'dict'):
                continue
            yield elem

    def _parse_key_value(self, key=None):
        _dict = {}
        for elem in self._parse():
            if elem.tag == 'key':
                key = elem.text
                continue

            if elem.tag in ['integer', 'string', 'date']:
                if not key is None:
                    _dict[key] = elem.text
                    key = None
                else:
                    print('Missing key for value {}'.format(elem.text))

            elif elem.tag in ['true', 'false']:
                _dict[key] = elem.tag == 'true'

            elif elem.tag == 'dict':
                if not key is None:
                    _dict[key] = self._parse_dict(key)
                    key = None
                else:
                    return elem, _dict
            else:
                print('Unknow tag {}'.format(elem.tag))

    def _parse_dict(self, key=None):
        elem = next(self._parse())
        elem, _dict = self._parse_key_value(elem.text)
        return _dict

    def __iter__(self):
        for elem in self._parse():
            if elem.tag == 'dict':
                yield self._parse_dict()
            else:
                print('Unknow tag {}'.format(elem.tag))

if __name__ == "__main__":

    data = b'''&lt;?xml...'''

    with io.BytesIO(data) as in_xml:
        for record in Playlist(in_xml):
            print("record:{}".format(record))

            for key, value in record.items():
                print("{}:{}".format(key, value))
</code></pre>
<blockquote>
<p><strong>Output</strong>:</p>
<pre><code>record:{'Major Version': '1', 'Minor Version': '1'... (omitted for brevity)
    Major Version:1
    Minor Version:1
    Date:2019-01-24T10:31:15Z
    Tracks:{'99244': {'Track ID': '99244', 'Artist': 'Blaze Podcast Network', ... (omitted for brevity)}}
</code></pre>
</blockquote>
<p><strong><em>Tested with Python: 3.5</em></strong></p>
</div>
<span class="comment-copy">With lxml, you could use <code>getnext()</code> to get the following sibling. <a href="https://lxml.de/api/lxml.etree._Element-class.html#getnext" rel="nofollow noreferrer">lxml.de/api/lxml.etree._Element-class.html#getnext</a></span>
<span class="comment-copy"><code>for elem in tree.iter():     if elem.text == 'Name':         name = (elem.getnext().text).encode("utf-8")</code>  Thanks @mzjn  getnext() with lxml got me to it...</span>
