<div class="post-text" itemprop="text">
<p>I am using the following code based on this <a href="http://www.obeythetestinggoat.com/how-to-get-selenium-to-wait-for-page-load-after-a-click.html" rel="nofollow noreferrer">blogpost</a> (last section): </p>
<pre class="lang-py prettyprint-override"><code>from selenium.webdriver.support.expected_conditions import staleness_of
from selenium.webdriver.support.ui import WebDriverWait

@contextmanager
def wait_for_page_load(self, timeout=15):
    old_page = self.driver.find_element_by_tag_name('html')
    yield
    WebDriverWait(self.driver, timeout).until(staleness_of(old_page))
</code></pre>
<p>where <code>self.driver</code> is a selenium webdriver object.<br/>
This context manager can then be used in a <code>with</code> block:</p>
<pre class="lang-py prettyprint-override"><code>def click_on_the_link():
    with self.wait_for_page_load():
        self.driver.find_element_by_link_text('a link')
</code></pre>
<p>The way I understood it is that the old page is stored and in case the new page hasn't loaded yet it, a WebDriverWait object is created, which waits for the site to be loaded before continuing. Then the actions on the new page are executed, e.g. clicking a link.</p>
<p>However, the code doesn't make sense to me. According to the <a href="https://docs.python.org/3/library/contextlib.html" rel="nofollow noreferrer">documentation</a>:</p>
<blockquote>
<p>At the point where the generator yields, the block nested in the with statement is executed. The generator is then resumed after the block is exited.</p>
</blockquote>
<p>Assuming the code in the blogpost is correct, how can the method possibly wait for the site to be loaded if the code inside the <code>with</code> statement is executed first?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because it uses an <a href="https://selenium-python.readthedocs.io/waits.html" rel="nofollow noreferrer">explicit wait</a>.</p>
<pre><code>WebDriverWait(self.driver, timeout).until(staleness_of(old_page))
</code></pre>
<p>This will wait until the contition <code>staleness_of</code> succeeds or throws an exception if the timeout is reached. Since this code is executed after the <code>yield</code>, any operation with the driver will be caught by this.</p>
<p><strong>UPDATE</strong></p>
<p>If you just want your driver to wait for the element <code>a link</code> you can use <code>WebDriverWait</code> directly</p>
<pre class="lang-py prettyprint-override"><code>def click_on_the_link(self):
    wait = WebDriverWait(self.driver, 10)
    wait.until(element_to_be_clickable('a link'))
    self.driver.find_element_by_link_text('a link')
</code></pre>
</div>
<span class="comment-copy">Then what could I change to achieve what I want?</span>
<span class="comment-copy">Sorry, but I don't understand your question. Didn't you wanted to know how the decorator worked?</span>
<span class="comment-copy">Yes exactly, but maybe this didn't become clear in my question. The given code doesn't do what it should do because I only want the code in <code>click_on_the_link</code> to be executed after loading. So I want to know a way to achieve this</span>
<span class="comment-copy">Thanks for the update. I have used your suggested method before, however it has some flaws which is why I searched for an alternative way. With <code>wait.until()</code> there is no way to stop waiting before the maximum time is reached. I need a way to exit if a certain element on the site cannot be found. But I can only check this condition once the site has fully loaded.</span>
