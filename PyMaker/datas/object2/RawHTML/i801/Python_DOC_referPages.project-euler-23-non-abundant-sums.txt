<div class="post-text" itemprop="text">
<p>This is the task:</p>
<blockquote>
<p>Problem 23</p>
<p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.</p>
<p>A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.</p>
<p>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis &gt;even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.</p>
<p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p>
</blockquote>
<p>This is my code:</p>
<pre><code>import time
import math
start = time.time()

abundant_num_list = []

def checkAbundant():

    for n in range(1, 28123):

        factor_sum = 0
        other_pair_factor = 0

        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:         
                if math.floor(math.sqrt(n)) == math.sqrt(n):
                    other_pair_factor = 0
                else:
                    other_pair_factor = n // i

                factor_sum += (i + other_pair_factor + 1)

        if n &lt; factor_sum :
            abundant_num_list.append(n)

def NonAbundantSums():

    abundant_sum_list = []
    all_num_list = []
    non_abun_list = []
    non_abun_sum = 0

    for i in range(len(abundant_num_list)):
        for j in range(i, len(abundant_num_list)):
            if abundant_num_list[i] + abundant_num_list[j] &lt;= 28123:
                abundant_sum_list.append(abundant_num_list[i] + abundant_num_list[j])

    for i in range(1, 28124):
        all_num_list.append(i)

    non_abun_list = [int(a) for a in (set(all_num_list) - set(abundant_sum_list))]

    for i in range(len(non_abun_list)):
        non_abun_sum += non_abun_list[i]

    print(non_abun_sum)

checkAbundant()
NonAbundantSums()

end = time.time() - start
print("Done in", end, "seconds")
</code></pre>
<p>If it looks inefficient, i know, I'm new to coding. Python is my first programming language. I noticed a weird problem for my non_abun_list, where when retrieving the difference for set(all_num_list) and set(abundant_sum_list), the first and second index of abundant_sum_list is 2 and 30, so in my mind, non_abun_list shoud look like</p>
<blockquote>
<p>[1, 2, 3, 4... ,22, 23, 25, 26, 27, 28, 29, 31, 32]</p>
</blockquote>
<p>instead i got this</p>
<blockquote>
<p>[1, 2, 3, 4... ,22, 23, 8209 ,25, 26, 27, 28, 29, 8219, 31, 32]</p>
</blockquote>
<p>and i don't know how I got this list instead.
Can someone explain to me what's wrong with my code?
My result is 4352518 in ~25 seconds
Answer is 4179871</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>This is not an answer</strong><br/>
(OP cannot participate in chat due to rep requirement)</p>
<p>You should consider your coding style. If you write concise functions to <em>perform a task</em> and have those functions return a value(s) then you can easily test those functions to see if they work. This makes it easier to determine what IS working.</p>
<p>For example when checking for <em>abundancy</em> you have to do two things: find the divisors of a number and compare their sum to that number.</p>
<pre><code>def divisors(n):
    '''return divisors of n'''
    d = [1]
    for i in range(2, int(pow(n,.5))+1):
        if (n % i) == 0:
            other = n // i
            if other == i:
                pair = [i]
            else:
                pair = [i,other]
            d.extend(pair)
    return d

def check(n):
    '''return True if abundant'''
    return sum(divisors(n)) &gt; n
</code></pre>
<p>Now you can easily test both functions against <em>known</em> inputs and outputs if you start having problems. Once you know they work you don't have to consider them as a source of errors.</p>
<p>usage:</p>
<pre><code>abundant_numbers = []
for n in range(12,28124):
    if check(n):
        abundant_numbers.append(n)
</code></pre>
<hr/>
<p>Test a couple of numbers:</p>
<pre><code>&gt;&gt;&gt; divisors(16)
[1, 2, 8, 4]
&gt;&gt;&gt; divisors(1056)
[1, 2, 528, 3, 352, 4, 264, 6, 176, 8, 132, 11, 96, 12, 88, 16, 66, 22, 48, 24, 44, 32, 33]
&gt;&gt;&gt; check(16)
False
&gt;&gt;&gt; check(1056)
True
&gt;&gt;&gt; 
</code></pre>
<p>Yep, that looks right :).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:         
            if math.floor(math.sqrt(n)) == math.sqrt(n) == i:
                other_pair_factor = 0
            else:
                other_pair_factor = n // i

            factor_sum += (i + other_pair_factor)

    factor_sum += 1
</code></pre>
<p>For this specific part of checkAbundant(), i should include "== i " at line 3 because I only want the factor that will repeat twice to only count once for square numbers</p>
<p>For example, the pair factor as I would like to call for 36 is 1 x 36, 2 x 18, 3, 12, 4 x 9, 6 x 6.</p>
<p>For efficiency, I only find the first half of the factor pair, the other half is obtained through n // i. So in order to have the sum of proper factors of a number, I can't have repeated factors.</p>
<p>Without adding " ==i " I have made it so that for any square abundant numbers, their other half of the factor is not accounted for when summing the total factors up.</p>
<p>Another mistake i fixed in checkAbundant() is in line 8, where factor_sum += (i + other_pair_factor + 1)</p>
<p>This resulted in for every loop, factor_sum would have an additional 1, which will ruin the result. To fix that, i added 1 after the for loop</p>
<p>Overall, I would say it was a pretty rookie mistake. &gt;.&lt;</p>
</div>
<span class="comment-copy">Have you narrowed it down at all? - printing things at various locations can help a lot. Do you know which parts work? <a href="https://ericlippert.com/2014/03/05/how-to-debug-small-programs/" rel="nofollow noreferrer">How to debug small programs</a></span>
<span class="comment-copy">Any chance you can whittle that down to a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>? emphasis on minimal? I like <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/video-lectures/lecture-11/" rel="nofollow noreferrer">this video lecture</a> on testing and debugging.</span>
<span class="comment-copy">yes i did, i dont think the problem comes from checkAbundant(), rather it is somewhere in NonAbundantSum(), but i checked if everything in it work but I could not find the problem except where i got weird values in non_abun_list</span>
<span class="comment-copy">my all_num_list = [1, 2, 3..., 28123] which is what i wanted and my abundant_sum_list = [24, 30,...] which seems fine too, so my idea is that i will make them into sets and compare with each other and get the difference from the first set (all_num_list), but the "difference" that was accounted for turn into weird values?</span>
<span class="comment-copy">You realize that <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">sets are unordered</a> so a valid number may not <i>appear</i> in the order you expect.  Have you tested those <i>wierd</i> values to see if they are valid?</span>
<span class="comment-copy">Thank you for the feedback. I will try my best to put your advice in mind.</span>
