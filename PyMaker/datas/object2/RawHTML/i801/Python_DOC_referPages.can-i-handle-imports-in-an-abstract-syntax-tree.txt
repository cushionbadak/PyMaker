<div class="post-text" itemprop="text">
<p>I want to parse and check <code>config.py</code> for admissible nodes.
<code>config.py</code> can import other config files, which also must be checked.</p>
<p>Is there any functionality in the <code>ast</code> module to parse <code>ast.Import</code> and <code>ast.ImportFrom</code> objects to <code>ast.Module</code> objects?</p>
<p>Here is a code example, I am checking a configuration file (<code>path_to_config</code>), but I want to also check any files that it imports:</p>
<pre><code>with open(path_to_config) as config_file:
    ast_tree = ast.parse(config_file.read())
    for script_object in ast_tree.body:
        if isinstance(script_object, ast.Import):
            # Imported file must be checked too
        elif isinstance(script_object, ast.ImportFrom):
            # Imported file must be checked too
        elif not _is_admissible_node(script_object):
            raise Exception("Config file '%s' contains unacceptable statements" % path_to_config)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a little more complex than you think. <code>from foo import name</code> is a valid way of importing both an object defined in the <code>foo</code> module, and the <code>foo.name</code> module, so you may have to try <em>both</em> forms to see if they resolve to a file. Python also allows for aliases, where code can import <code>foo.bar</code>, but the actual module is really defined as <code>foo._bar_implementation</code> and made available as an attribute of the <code>foo</code> package. You can't detect all of these cases purely by looking at <code>Import</code> and <code>ImportFrom</code> nodes.</p>
<p>If you ignore those cases and only look at the <code>from</code> name, then you'll still have to turn the module name into a filename, then parse the source from the file, for each import.</p>
<p>In Python 2 you can use <a href="https://docs.python.org/2/library/imp.html#imp.find_module" rel="nofollow noreferrer"><code>imp.find_module</code></a> to get an open file object for the module <sup>(*)</sup>. You want to keep the full module name around when parsing each module, because you'll need it to help you figure out package-relative imports later on. <code>imp.find_module()</code> can't handle package imports so I created a wrapper function:</p>
<pre><code>import imp

_package_paths = {}
def find_module(module):
    # imp.find_module can't handle package paths, so we need to do this ourselves
    # returns an open file object, the filename, and a flag indicating if this
    # is a package directory with __init__.py file.
    path = None
    if '.' in module:
        # resolve the package path first
        parts = module.split('.')
        module = parts.pop()
        for i, part in enumerate(parts, 1):
            name = '.'.join(parts[:i])
            if name in _package_paths:
                path = [_package_paths[name]]
            else:
                _, filename, (_, _, type_) = imp.find_module(part, path)
                if type_ is not imp.PKG_DIRECTORY:
                    # no Python source code for this package, abort search
                    return None, None
                _package_paths[name] = filename
                path = [filename]
    source, filename, (_, _, type_) = imp.find_module(module, path)
    is_package = False
    if type_ is imp.PKG_DIRECTORY:
        # load __init__ file in package
        source, filename, (_, _, type_) = imp.find_module('__init__', [filename])
        is_package = True
    if type_ is not imp.PY_SOURCE:
        return None, None, False
    return source, filename, is_package
</code></pre>
<p>I'd also track what module names you already imported so you don't process them twice; use the name from the <code>spec</code> object to make sure you track their canonical names.</p>
<p>Use a stack to process all the modules:</p>
<pre><code>with open(path_to_config) as config_file:
    # stack consists of (modulename, ast) tuples
    stack = [('', ast.parse(config_file.read()))]

seen = {}
while stack:
    modulename, ast_tree = stack.pop()
    for script_object in ast_tree.body:
        if isinstance(script_object, (ast.Import, ast.ImportFrom)):
            names = [a.name for a in script_object.names]
            from_names = []
            if hasattr(script_object, 'level'):  # ImportFrom
                from_names = names
                name = script_object.module
                if script_object.level:
                    package = modulename.rsplit('.', script_object.level - 1)[0]
                    if script_object.module:
                        name = "{}.{}".format(name, script_object.module)
                    else:
                        name = package
                names = [name]
            for name in names:
                if name in seen:
                    continue
                seen.add(name)
                source, filename, is_package = find_module(name)
                if source is None:
                    continue
                if is_package and from_names:
                    # importing from a package, assume the imported names
                    # are modules
                    names += ('{}.{}'.format(name, fn) for fn in from_names)
                    continue
                with source:
                    module_ast = ast.parse(source.read(), filename)
                queue.append((name, module_ast))

        elif not _is_admissible_node(script_object):
            raise Exception("Config file '%s' contains unacceptable statements" % path_to_config)
</code></pre>
<p>In case of <code>from foo import bar</code> imports, if <code>foo</code> is a package then <code>foo/__init__.py</code>  is skipped and it is assumed that <code>bar</code> will be a module.</p>
<hr/>
<p><sup>(*)</sup> <code>imp.find_module()</code> is deprecated for Python 3 code. On Python 3 you would use <a href="https://docs.python.org/3/library/importlib.html#importlib.util.find_spec" rel="nofollow noreferrer"><code>importlib.util.find_spec()</code></a> to get the module loader spec, and then use the <a href="https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec.origin" rel="nofollow noreferrer"><code>ModuleSpec.origin</code> attribute</a> to get the filename. <code>importlib.util.find_spec()</code> knows how to handle packages.</p>
</div>
<span class="comment-copy">take a look at <a href="https://docs.python.org/3/library/ast.html#ast.NodeTransformer" rel="nofollow noreferrer"><code>ast.NodeTransformer</code> class</a></span>
<span class="comment-copy">the problem is that i do not know how to import ast.Import obj with ast lib :(    I have an instance of "ast.Import" but i do not know how to parse it.</span>
<span class="comment-copy">what do you want to do with it? find source file location (it's not always presented, e.g. for <code>C</code> extensions or dynamically created module)? or import it (may lead to undesired side-effects like removing files)?</span>
<span class="comment-copy">Config file can import another config file. I need to check if config consists of admissible nodes. (Admissible in my case is ast.Import, ast.ImportFrom, ast.Assign, ast.If ) But config file may import another config file. and i need to check if imported file consists of admissible nodes. and so on. In my example i can check only one file "path_to_config", but i want to check files which main cfg imports too.</span>
<span class="comment-copy">maybe there is another library for these task?</span>
<span class="comment-copy">Thanks, mate, you've been a great help.</span>
