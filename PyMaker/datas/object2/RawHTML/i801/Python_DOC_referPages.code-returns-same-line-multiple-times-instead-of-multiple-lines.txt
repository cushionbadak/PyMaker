<div class="post-text" itemprop="text">
<p>What I'm trying to do is to open two CSV files and print only the lines in which the content of a column in file 1 and file 2 match. I already know that I should end up with 14 results, but instead the first line of the CSV file I'm working with gets printed 14 times. Where did I go wrong?</p>
<pre><code>file1 = open("../dir/file1.csv", "r")
for line in file1:
    file1splitted = line.strip().split(",")

    file2 = open("../dir/file2.csv", "r")
    for line in file2:
        file2splitted = line.strip().split(",")

        for line in file1:
            if file1splitted[0] == file2splitted [2]:
                print (file1splitted[0],file1splitted[1], file2splitted[6], file2splitted[10], file2splitted[12])

file1.close()
file2.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be using the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a> for reading these files because splitting on commas is not reliable; it's fine for a single CSV column to contain values that themselves include commas.</p>
<p>I've added a couple of things to try make this cleaner and to help you move forward in your learning:</p>
<ol>
<li>I've used the <code>with</code> <em>context manager</em> that automatically closes a file once you're done reading it. No need for <code>.close()</code></li>
<li>I've packaged the csv reading code into a function. Now we only need to write that part once and we can call the function with any file.</li>
<li>I've used the <code>csv</code> module to read the file. This will return a nested list of rows, each inner list representing a single row.</li>
<li>I've used a <em>list comprehension</em> which is a neater way of writing a <code>for</code> loop that creates a list. In this case, it's a list of all the items in the first column of file_1.</li>
<li>I've converted the list in Point 4 into a <em>set</em>. When we iterate through file_2, we can very quickly check whether a row value has been seen in file_1 (<code>set</code> lookup is O(1) rather than having to iterate through file_1 every single time).</li>
</ol>
<p>The indices I print are from my own test files, you will need to adapt them to your own use-case.</p>
<pre><code>import csv

def read_csv(file_name):
    with open(file_name) as infile: # Context manager to auto-close files at end
        reader = csv.reader(infile)
        #next(reader) remove the hash if you want to drop the headers
        return list(reader)


file_1 = read_csv('file_1.csv')
file_2 = read_csv('file_2.csv')

# Make a set of file_1 column 0 with a list comprehension
file_1_vals = set([item[0] for item in file_1])

# Now iterate through file_2
for row in file_2:
    if row[2] in file_1_vals:
        print(row[1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>file1 = open("../dir/file1.csv", "r")
file2 = open("../dir/file2.csv", "r")
for line in file1:
    file1splitted = line.strip().split(",")
    for line in file2:
        file2splitted = line.strip().split(",")
        if file1splitted[0] == file2splitted [2]:
            print (file1splitted[0],file1splitted[1], file2splitted[6], file2splitted[10], file2splitted[12])

file1.close()
file2.close()
</code></pre>
<p>if you provide your csv files then I can help you more.</p>
</div>
<span class="comment-copy">You're trampling over your <code>line</code> loop variable within your nested loops. Whether that is the cause of the issue, I'm not sure, but I suggest using different names for clarity</span>
<span class="comment-copy">Be carefull while opening files inside for loops. It might cause you some troubles. (Not sure if this is the problem there)</span>
<span class="comment-copy">I prefer using <code>open</code> with a <code>with</code> statement so that I know it will close even if an error occurs: <code>with open("../dir/file1.csv", "r") as file1:</code></span>
<span class="comment-copy">This isn't a good way to read CSV files. We have the csv module for this task</span>
<span class="comment-copy">@roganjosh you are very correct, my focus was on logic , why MacRupp was getting wrong result</span>
