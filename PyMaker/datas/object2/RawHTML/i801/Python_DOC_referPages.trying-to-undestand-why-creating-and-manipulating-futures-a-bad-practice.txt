<div class="post-text" itemprop="text">
<p>I'm trying to understand futures in Python by reading the <a href="https://pymotw.com/3/index.html" rel="nofollow noreferrer">PyMotW</a> guide.</p>
<p>I asked a <a href="https://stackoverflow.com/a/54274557/10597450">question</a> yesterday, and in the comments, it was stated that:</p>
<blockquote>
<p>A more serious issue with the guide is that creating and manipulating
  raw futures is considered bad style in modern async programming.</p>
</blockquote>
<p>I tried searching for more information, but the closest I found was in the <a href="https://docs.python.org/3/library/asyncio-future.html#future-object" rel="nofollow noreferrer">Python guide about Future</a>:</p>
<blockquote>
<p>The rule of thumb is to never expose Future objects in user-facing
  APIs, and the recommended way to create a Future object is to call
  loop.create_future(). This way alternative event loop implementations
  can inject their own optimized implementations of a Future object.</p>
</blockquote>
<p><strong>Question:</strong></p>
<p>Why is it considered bad practice to create and manipulate futures? Are the reasons documented somewhere?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to @user4815162342, for providing a link to the async/await <a href="http://speakerdeck.com/1st1/asyncio-today-and-tomorrow" rel="nofollow noreferrer">presentation</a> by Yury Selivanov.</p>
<p>I managed to reach out and ask him. Here is what he said.</p>
<blockquote>
<p>The warning is there because Future is a low-level API.  You should
  use it to build async/await facade around existing callbacks-based
  code.  But if you are writing async/await code from scratch, there are
  higher-level builtin async/await APIs in asyncio that are just easier
  to use (and less error prone).</p>
</blockquote>
</div>
<span class="comment-copy">There's absolutely <b>nothing</b> wrong in creating and manipulating futures. It is just a low level object tied to an underlying event loop. So extra care is needed. That's all. Also note that I've spent lots of time with asyncio and I probably had no more then 10 situations when I had to work with futures directly. Most of your problems can be solved without them (typically you wrap "callback style" functions with futures). But that doesn't make them a bad practice.</span>
<span class="comment-copy">@freakish For the record, I agree with your comment 100%, and I wrote the answer the OP is referring to. The answer was written in context of a beginner text which introduced asyncio to beginners through <code>call_soon</code> and explicitly passing future objects to callbacks in places where a simple coroutine would be much more appropriate. As you wrote, futures are low-level objects and there is a time and place for them.</span>
<span class="comment-copy">@EmilyScott If you're looking for a reference, see e.g. <a href="https://speakerdeck.com/1st1/asyncio-today-and-tomorrow?slide=19" rel="nofollow noreferrer">this presentation</a> by the current maintainer of asyncio, which explicitly warns against (over)use of futures, <code>call_soon</code>, transports, protocols, and the event loop machinery.</span>
<span class="comment-copy">@user4815162342 - Exactly what you stated in your comment, is what he said. I e-mailed and reached out to him. Below is his answer.</span>
<span class="comment-copy">I've removed the <code>concurrent.futures</code> tag because my comment was completely unrelated to the futures defined by that module. The futures referred to in the quote are the ones defined in asyncio.</span>
