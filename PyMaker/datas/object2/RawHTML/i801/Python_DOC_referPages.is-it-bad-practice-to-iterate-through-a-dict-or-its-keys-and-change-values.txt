<div class="post-text" itemprop="text">
<p>In python 2 I used:</p>
<pre><code>d = {'a': 1, 'b': 2, 'c': 3}
for k in d.keys():
    d[k] = d[k] * 2
print(d)
# {'a': 2, 'b': 4, 'c': 6}
</code></pre>
<p>In python 3 I use:</p>
<pre><code>d = {'a': 1, 'b': 2, 'c': 3}
for k in d:
    d[k] = d[k] * 2
print(d)
# {'a': 2, 'b': 4, 'c': 6}
</code></pre>
<p>This new syntax gives me the feeling I'm iterating over something (the dict) and modifying it, which is bad. But in truth I'm only iterating over the keys, so this should not bring any trouble, right?</p>
</div>
<div class="post-text" itemprop="text">
<p>Iterating over a dictionary and modifying values is perfectly fine. Each time you call <code>dict.__getitem__</code> / <code>dict.__setitem__</code>, or respectively its syntactic sugar <code>dict[]</code> / <code>dict[] = ...</code>, the value for a key is retrieved. You can overwrite values for keys as you iterate items, as changing values does not change key hashes and therefore does not impact the iterator.</p>
<p>What's <em>not</em> fine is adding or removing keys as you iterate over a view of a dictionary. The reason why this is problematic is <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">given in the docs</a>:</p>
<blockquote>
<p>The objects returned by <code>dict.keys()</code>, <code>dict.values()</code> and <code>dict.items()</code>
  are view objects. They provide a dynamic view on the dictionaryâ€™s
  entries, which means that when the dictionary changes, the view
  reflects these changes.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I don't see a reason why it should be bad practice if you do not change the set of keys of the dictionary.  Your examples do not do that, so they are just fine.</p>
<p>The things starts getting messy if your <em>changing</em> involves adding or removing elements:</p>
<pre><code>d = {}
k = d.keys()
i = iter(k)
d[42] = 23
next(i)
</code></pre>
<p>This will raise an exception:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: dictionary changed size during iteration
</code></pre>
<p>And your example can probably be improved a little by iterating over the items instead of the keys alone:</p>
<pre><code>d = dict(a=1, b=2, c=3)
for k, v in d.items():
    d[k] = v * 2
</code></pre>
<p>or in the special case of your "just doubling":</p>
<pre><code>for k in d.keys():
    d[k] *= 2
</code></pre>
<p>But I guess your real use case is probably more complex.</p>
<p>EDIT: Be aware that if you are still using Python2, you should use <code>.iteritems()</code> and <code>.iterkeys()</code> instead of <code>.items()</code> and <code>.keys()</code>.</p>
</div>
<span class="comment-copy">but.. in the first example you were also modifying that dict.</span>
<span class="comment-copy">Since you are just iterating the keys, I think this is somewhat equivalent to <code>for i in range(len(lst)): lst[i] = lst[i] * 2</code>. So this should not be a problem, as the keys (and the keys' hashed) stay the same.</span>
<span class="comment-copy">@matiit yes nothing has changed except the way it's written, that gets me wondering if I'm violating the "don't modify something you're iterating through rule"</span>
<span class="comment-copy">The "for key in dict" syntax works just as well with Python 2 (it's been there for years, really), and is the recommanded way to iterate over a dict's keys...</span>
<span class="comment-copy">@brunodesthuilliers Indeed! I did not know it at the time I was using Python 2 it seems :)</span>
<span class="comment-copy">I think that quotation is irrelevant to the question. OP already knows that. Do you have a definite proof for the first part, i.e. that assigning new values to existing keys does never mess up iteration order?</span>
<span class="comment-copy">@tobias_k, I would not necessarily assume that, otherwise this question would not be asked! But I've added some information.</span>
<span class="comment-copy">@tobias_k updating the dict's <i>values</i> during iteration doesn't affect the iterator (since it iterates on keys, which we're not touching here), so it IS safe. The problem is when you change something that does affect the iterator itself.</span>
<span class="comment-copy">@tobias_k It's hard to prove a statement which involves the universal quantifier.  On the other hand, there is no good reason to assume that changing the values of a dictionary (without changing the keys) raises any problem in terms of iterating the keys.</span>
<span class="comment-copy">@All I totally agree that it's most likely not a problem (never experienced a problem with it myself), but I can imagine how one might wonder if it really is safe. Couldn't it be that when <code>__set__</code> is called, the currently active iterator is reset or something like that? Also, please note that I added that comment when the answer was literally "no, that is fine" and no other explanation.</span>
<span class="comment-copy">@brunodesthuilliers I prefer the explicit <code>d.keys()</code>.  (I had a mistake there for just some seconds, maybe you refer to that; if you remove your comment, I'll remove mine to keep the chatter low.)</span>
<span class="comment-copy">I've already seen the snippet using .items() suggested, but doesn't it mean I would indeed be modifying what I'm iterating over ? Jpp's quote from the docs seems to imply that the view returned by .items() would be modified as a result of modifying the dict, right?</span>
<span class="comment-copy">@Alfe <code>dict.keys()</code> - in python2 at least - creates a list of the dict's keys, so it has a higher cost for no good reason, and the fact that dicts are themselves iterators on their keys is well documented, so <code>for k in dict</code> IS explicit.</span>
<span class="comment-copy">@brunodesthuilliers You are right, in Python2.  The switch to Python3 is not so hard, it has been ages since I last stumbled across a library which hadn't been ported to Python3 yet, and the advantages of the new version are immense.  So I would just recommend to switch to the current flavor of Python (and to keep answers concise, I don't mention all older versions of Python anymore).  If someone needs to stick to Python2, though, they should use the <code>.iteritems()</code> and <code>.iterkeys()</code> instead of <code>.items()</code> or <code>.keys()</code>.  Using <code>for i in d:</code> is <i>not</i> explicit (by the definition of "explicit").</span>
<span class="comment-copy">Not everybody can switch to Python3 so easily - lots of us have to maintain legacy code. And I maintain that <code>for key in dict:</code> is just as explicit as <code>for item in list</code> since dicts are explicitely documented as being iterators on their own keys. "explicit" doesn't mean "verbose" (and of course requires you know your language's features). Or would you write <code>if (len(somelist) == 0) == True</code> instead of <code>if not somelist</code> ?-)</span>
