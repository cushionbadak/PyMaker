<div class="post-text" itemprop="text">
<p>Have an ordered dict which has duplicate key, value pairings. Want to make those duplicate values unique.
For eg. 4244158 &amp; 4244159 combination exist twice
I want to keep one of them.</p>
<p>Now the code mentioned below was fine with python2 since ordered dict can be mutated but not with python3 so i made a copy of the ordered dict and compare it with original ordered dict</p>
<pre><code>ordered_parkstop_dict = OrderedDict([('4244162', []),
                                     ('4244158', ['4244159']), 
                                     ('4244159', ['4244158']), 
                                     ('4244157', ['4244160', '4244161']),
                                     ('4244160', ['4244157', '4244161']),        
                                     ('4244161', ['4244157', '4244160'])])
new_ordered_parkstop_dict = ordered_parkstop_dict.copy()
for key, value in ordered_parkstop_dict.items():
    for k,v in ordered_parkstop_dict.items():
        klist = []
        keylist = []
        if value and v:
            if len(v)==1 and len(value)==1:
                klist.append(k), keylist.append(key)
            if (keylist == v) and (klist == value and len(value) == 1):
                new_ordered_parkstop_dict.pop(key)
</code></pre>
<p>To clarify, I only want to remove a duplicate of the type <code>x -&gt; [y], y -&gt; [x]</code>, i.e. lists with one item.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you wish to remove duplicates where you have a <strong>single</strong> list item, you can adapt the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>unique_eveseen</code> recipe</a>. The idea is to maintain a <code>set</code> of <code>frozenset</code> items, and add to it only when you meet a list with one item.</p>
<pre><code>from collections import OrderedDict

def unique_everseen(iterable):
    seen = set()
    seen_add = seen.add
    for key, value in iterable:
        if len(value) != 1:
            yield key, value
        else:
            if frozenset((value[0], key)) not in seen:
                seen_add(frozenset((value[0], key)))
                yield key, value

res = OrderedDict(unique_everseen(dd_input.items()))
</code></pre>
<p>In Python3, you should <em>under no circumstances</em> iterate over a view such as <code>dict.items</code> while adding / removing items.</p>
<p>Result:</p>
<pre><code>print(res)

OrderedDict([('4244162', []),
             ('4244158', ['4244159']),
             ('4244157', ['4244160', '4244161']),
             ('4244160', ['4244157', '4244161']),
             ('4244161', ['4244157', '4244160'])])
</code></pre>
</div>
<span class="comment-copy">Can you define precisely which combinations are considered duplicates? Do you only want to remove a duplicate of the type <code>x -&gt; [y], y -&gt; [x]</code>, i.e. lists with one item?</span>
<span class="comment-copy">@jpp yes i only want to remove the the type x -&gt; [y], y -&gt; [x] from new_ordered_parkstop_dict</span>
<span class="comment-copy">Thanks for helping out. Precisely what i was looking for. Already came up with a solution but yours looks much cleaner</span>
