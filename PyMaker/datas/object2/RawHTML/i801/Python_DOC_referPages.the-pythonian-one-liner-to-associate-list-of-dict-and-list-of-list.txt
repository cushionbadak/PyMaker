<div class="post-text" itemprop="text">
<p>Given a list of items [musicians] and a list of dictionaries [instrumets] how would one make the association between them in a <strong>pythonic way?</strong></p>
<p>So to <strong>simplify</strong> my real scenario consider the followings:</p>
<pre><code>musicians  = [[700,"James","Hetfield", "jh@metallica.com","N/A"],
              [701,"Lars","Ulrich","lu@metallica.com","N/A"],
              [702,"Kirk","Hammett","kh@metallica.com","N/A"],
              [703,"Robert","Trujillo", "rt@metallica.com","N/A"]]

instruments= ({700:"guitar"},{701:"drums"})
</code></pre>
<p>My objective is to replace the N/A is musicians with the instrument in instruments. </p>
<p>the code below will do the trick (but the intuition comes from java/c++) </p>
<pre><code>for m in musicians:
    for i in instruments:
        if m[0] in i:
            m[4]=i[m[0]]
</code></pre>
<p>and the correct desired result would be:</p>
<pre><code>[[700, 'James', 'Hetfield', 'jh@metallica.com', 'guitar'], [701, 'Lars', 'Ulrich', 'lu@metallica.com', 'drums'], [702, 'Kirk', 'Hammett', 'kh@metallica.com', 'N/A'], [703, 'Robert', 'Trujillo', 'rt@metallica.com', 'N/A']]
</code></pre>
<p>Q: Is there a classic way to do it in python? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="noreferrer"><code>collections.ChainMap</code></a> to combine your instrument mappings, then use a list comprehension:</p>
<pre><code>from collections import ChainMap

cm = ChainMap(*instruments)
musicians = [[*x[:-1], cm.get(x[0], x[-1])] for x in musicians]

print(musicians)

# [[700, 'James', 'Hetfield', 'jh@metallica.com', 'guitar'],
#  [701, 'Lars', 'Ulrich', 'lu@metallica.com', 'drums'],
#  [702, 'Kirk', 'Hammett', 'kh@metallica.com', 'N/A'],
#  [703, 'Robert', 'Trujillo', 'rt@metallica.com', 'N/A']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If there are no duplicate keys in list of dicts then merge those</p>
<pre><code>musicians = [[700, "James", "Hetfield", "jh@metallica.com", "N/A"],
             [701, "Lars", "Ulrich", "lu@metallica.com", "N/A"],
             [702, "Kirk", "Hammett", "kh@metallica.com", "N/A"],
             [703, "Robert", "Trujillo", "rt@metallica.com", "N/A"]]

instrumets = ({700: "guitar"}, {701: "drums"})

instruments_dict = {}
for d in instrumets:
    instruments_dict.update(d)
for m in musicians:
    m[-1] = instruments_dict.get(m[0], m[-1]) # thanks to  Ev. Kounis 
</code></pre>
</div>
<span class="comment-copy">why are <code>instrumets</code> a tuple of dicts and not a dict?</span>
<span class="comment-copy">yes make <code>instrumets</code> a single dict then you can do something like <code>[m[:3] + [instrumets.get(m[0],m[4])] for m in musicians]</code></span>
<span class="comment-copy">@Ev. Kounis good question! I'm oversimplifying a real scenario where I'm given a list of dictionaries</span>
<span class="comment-copy">Are there duplicate keys in those dicts?</span>
<span class="comment-copy">@Mr_and_Mrs_D consider no dups.</span>
<span class="comment-copy">You might want to change the last line into <code>m[-1] = instruments_dict.get(m[0], m[-1])</code>. It is obvious from the example that not all instrument codes (702, etc) exist.</span>
<span class="comment-copy">Thanks - I kind of supposed there should be a key for all <code>m[0]</code>s but hey...</span>
<span class="comment-copy">Btw provided there are no duplicates constructing the instruments_dict could be a one liner as in <code>dict(itertools.chain.from_iterable(d.items() for d in instrumets))</code></span>
<span class="comment-copy">Why does this depend on the existence of duplicates?</span>
<span class="comment-copy">A very confusing alternative would also be <code>dict(*zip(*map(lambda x: x.items(), instrumets)))</code></span>
