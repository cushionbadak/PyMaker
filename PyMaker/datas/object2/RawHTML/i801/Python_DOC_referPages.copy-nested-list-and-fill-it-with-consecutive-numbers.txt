<div class="post-text" itemprop="text">
<p>Given this nested list:</p>
<pre><code>foo = [["apple", "cherry"], ["banana"], ["pear", "raspberry", "pineapple"]]
</code></pre>
<p>I want to keep the structure and replace all items by consecutive numbers. My desired output is:</p>
<pre><code>[[0, 1], [2], [3, 4, 5]]
</code></pre>
<p>I was hoping for a simple one-liner, but the shortest working solution I came up with was:</p>
<pre><code>foo_numbers = []
count = 0

for i, sublist in enumerate(foo):
    foo_numbers.append([])
    for item in sublist:
        foo_numbers[i].append(count)
        count += 1
</code></pre>
<p>Usually these manual iterators indicate that there is a more pythonic way to achieve the same thing. If this is to be done with list comprehension, I couldn't see how to make up a "shared counter" for both loops, so it wouldn't start from zero for every <code>sublist</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer"><code>itertools.count</code></a> with a nested list comprehension:</p>
<pre><code>from itertools import count

foo = [["apple", "cherry"], ["banana"], ["pear", "raspberry", "pineapple"]]

c = count()  # 0 start is default, e.g. count(1) will start from 1
res = [[next(c) for _ in lst] for lst in foo]

print(res)
# [[0, 1], [2], [3, 4, 5]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>, instead of the inner loop:</p>
<pre><code>foo = [["apple", "cherry"], ["banana"], ["pear", "raspberry", "pineapple"]]

foo_numbers = []
count = 0

for i, sublist in enumerate(foo):
    foo_numbers.append([j for j in range(count, len(sublist) + count)])
    count += len(sublist)

print(foo_numbers)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[0, 1], [2], [3, 4, 5]]
</code></pre>
<p>In general list comprehensions are faster than loops for list creation. As an alternative you could convert the range object to a list, like this:</p>
<pre><code>foo_numbers.append(list(range(count, len(sublist) + count)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Comparing these solutions:</p>
<pre><code>import itertools

def f1(foo):
    """original version in question"""
    foo_numbers = []
    count = 0
    for i, sublist in enumerate(foo):
        foo_numbers.append([])
        for item in sublist:
            foo_numbers[i].append(count)
            count += 1
    return foo_numbers

def f2(foo):
    """@jpp answer"""
    c = itertools.count()
    return [[next(c) for _ in range(len(lst))] for lst in foo]

def f3(foo):
    """@DanielMesejo answer"""
    foo_numbers = []
    count = 0
    for i, sublist in enumerate(foo):
        foo_numbers.append([j for j in range(count, len(sublist) + count)])
        count += len(sublist)
    return foo_numbers
</code></pre>
<p>Gives us this:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt;
&gt;&gt;&gt; timeit.timeit('f(foo)', 'from __main__ import f1 as f, foo')
1.2990377170499414
&gt;&gt;&gt; timeit.timeit('f(foo)', 'from __main__ import f2 as f, foo')
2.260929798008874
&gt;&gt;&gt; timeit.timeit('f(foo)', 'from __main__ import f3 as f, foo')
2.1552230638917536
</code></pre>
<p>It seems the original version is faster (by a factor of 2).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use below given solution if you really <a href="https://stackoverflow.com/questions/54328027/copy-nested-list-and-fill-it-with-consecutive-numbers/54328487#comment95474209_54328079"><strong>do not</strong></a> want to import anything:                    </p>
<pre><code>foo = [["apple", "cherry"], ["banana"], ["pear", "raspberry", "pineapple"]]

count = -1

def indexer(fruits):
    global count
    count += 1
    return count


foo_new = list(map(lambda fruits: list(map(indexer, fruits)), foo))

print(foo_new)              
</code></pre>
<h3>Outputs:</h3>
<pre><code>[[0, 1], [2], [3, 4, 5]]
</code></pre>
</div>
<span class="comment-copy">That's neat! By default I don't import itertools and I usually prefer plain python, but it's definitely better than my bulky solution</span>
<span class="comment-copy">Just note: using <code>timeit</code>seems to indicate that this solution is slower than your original code</span>
<span class="comment-copy"><code>range(count, len(sublist) + count)</code> was kind of a missing puzzle piece missing to make up this solution on my own. Thanks for clearing my vision there</span>
<span class="comment-copy">Just a note: See <a href="https://stackoverflow.com/a/54328251/9225671">my answer</a>; it seems that this version is also slower as the original code</span>
<span class="comment-copy">Thanks for pointing this out! In fact time is not the issue. My list isn't really that much bigger than the example code and it's only called once. But these for-loops leave me puzzled when I come back to the code a year later and wonder what they do. So I was looking for something slim</span>
<span class="comment-copy">How come two nested <code>for loop</code>s are quicker than <code>list comprehension</code>?</span>
<span class="comment-copy">@offeltoffel I don't know either, why for loops are faster than list comprehension in this case. I just made the timing tests and was surprised myself.</span>
<span class="comment-copy">This answer has some nice ideas in it. I am not really restricted, it is more some personal preference. Thanks!</span>
