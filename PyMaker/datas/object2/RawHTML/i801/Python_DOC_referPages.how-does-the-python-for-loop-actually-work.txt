<div class="post-text" itemprop="text">
<p>I am curious to understand how Python <code>for</code> loops work under the hood. I tried to implement it somewhat like the following code snippet, is that how the for loop has been implemented?</p>
<pre><code>my_list = [1, 2, 3, 4, 5]

# list itself is iterable but not iterator. Make it an iterator
iter_list = iter(my_list)

while True:
    try:
       print(next(iter_list))
    except StopIteration:
       break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, that's a good approximation of how the <code>for</code> loop construct is implemented. It certainly matches the <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer"><code>for</code> loop statement documentation</a>:</p>
<blockquote>
<p>The expression list is evaluated once; it should yield an iterable object. An iterator is created for the result of the <code>expression_list</code>. The suite is then executed once for each item provided by the iterator, in the order returned by the iterator. Each item in turn is assigned to the target list using the standard rules for assignments (see Assignment statements), and then the suite is executed. When the items are exhausted (which is immediately when the sequence is empty or an iterator raises a <code>StopIteration</code> exception), the suite in the <code>else</code> clause, if present, is executed, and the loop terminates.</p>
</blockquote>
<p>You only missed the <em>assigned to the target list using the standard rules for assignments</em> part; you'd have to use <code>i = next(iter_list)</code> and <code>print(i)</code> rather than print the result of the <code>next()</code> call directly.</p>
<p>Python source code is compiled to <em>bytecode</em>, which the interpreter loop then executes. You can look at the bytecode for a <code>for</code> loop by using the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('for i in mylist: pass')
  1           0 SETUP_LOOP              12 (to 14)
              2 LOAD_NAME                0 (mylist)
              4 GET_ITER
        &gt;&gt;    6 FOR_ITER                 4 (to 12)
              8 STORE_NAME               1 (i)
             10 JUMP_ABSOLUTE            6
        &gt;&gt;   12 POP_BLOCK
        &gt;&gt;   14 LOAD_CONST               0 (None)
             16 RETURN_VALUE
</code></pre>
<p>The various opcodes named are documented in the same <code>dis</code> module, and their implementation can be found in the <a href="https://github.com/python/cpython/blob/b2b023c657ba8c3f4a24d0c847d10fe8e2a73d44/Python/ceval.c#L930-L3490" rel="nofollow noreferrer">CPython evaluation loop</a> (look for the <code>TARGET(&lt;opcode&gt;)</code> switch targets); the above opcodes break down to:</p>
<ul>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-SETUP_LOOP" rel="nofollow noreferrer"><code>SETUP_LOOP 12</code></a> marks the start of the <em>suite</em>, a block of statements, so the interpreter knows where to jump to in case of a <code>break</code>, and what cleanup needs to be done in case of an exception or <code>return</code> statement; the clean-up opcode is located 12 bytes of bytecode after this opcode (so <code>POP_BLOCK</code> here).</li>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-LOAD_NAME" rel="nofollow noreferrer"><code>LOAD_NAME 0 (mylist)</code></a> loads the <code>mylist</code> variable value, putting it on the top of the stack (<em>TOS</em> in opcode descriptions).</li>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-GET_ITER" rel="nofollow noreferrer"><code>GET_ITER</code></a> calls <code>iter()</code> on the object on the TOS, then replaces the TOS with the result.</li>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-FOR_ITER" rel="nofollow noreferrer"><code>FOR_ITER 4</code></a> calls <code>next()</code> on the TOS iterator. If that gives a result, then that's pushed to the TOS. If there is a <code>StopIteration</code> exception, then the iterator is removed from TOS, and 4 bytes of bytecode are skipped to the <code>POP_BLOCK</code> opcode.</li>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-STORE_NAME" rel="nofollow noreferrer"><code>STORE_NAME 1</code></a> takes the TOS and puts it in the named variable, here that's <code>i</code>.</li>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-JUMP_ABSOLUTE" rel="nofollow noreferrer"><code>JUMP_ABSOLUTE 6</code></a> marks the end of the loop body; it tells the interpreter to go back up to bytecode offset 6, to the <code>FOR_ITER</code> instruction above. If we did something interesting in the loop, then that would happen after <code>STORE_NAME</code>, before the <code>JUMP_ABSOLUTE</code>.</li>
<li><a href="https://docs.python.org/3/library/dis.html#opcode-POP_BLOCK" rel="nofollow noreferrer"><code>POP_BLOCK</code></a> removes the block bookkeeping set up by <code>SETUP_LOOP</code> and removes the iterator from the stack.</li>
</ul>
<p>The <code>&gt;&gt;</code> markers are jump targets, there as visual cues to make it easier to spot those when reading the opcode line that jumps to them.</p>
</div>
