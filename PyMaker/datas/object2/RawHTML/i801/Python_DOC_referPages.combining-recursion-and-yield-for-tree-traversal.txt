<div class="post-text" itemprop="text">
<p>I'm trying to combine recursion and yield to in-order traverse a tree</p>
<p>This is what I'm currently having. However, when I try to traverse the tree, it seems to only traverse the root node</p>
<pre><code>class Tree:
    ...
    def post_order(self, node: TreeNode):
        """Yield next node in post order from node"""
        for child in node.get_children():
            self.post_order(child)
        yield node


if __name__ == '__main__':
    root = TreeNode('root')
    depth1a = TreeNode('1a')
    depth1b = TreeNode('1b')
    root.add_children(depth1a, depth1b)
    tree = Tree(root)
    for node in tree.post_order(root):
        print(node.get_element())
</code></pre>
<p>When I run the code, it only prints out</p>
<pre><code>root
</code></pre>
<p>which is the element of the first node, not what I want which is</p>
<pre><code>1a
1b
root
</code></pre>
<p>Does anyone have an idea what I did wrong?</p>
<p>Thanks everyone</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to <a href="https://stackoverflow.com/users/4411558/%E5%BC%A0%E5%AE%9E%E5%94%AF">张实唯</a>, turns out I have to use <code>yield from</code>. Calling a generator function <strong>does not</strong> yield from it:</p>
<pre><code>class Tree:
    ...
    def post_order(self, node: TreeNode):
        """Yield next node in post order from node"""
        for child in node.get_children():
            yield from self.post_order(child)
        yield node
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Mike Pham's answer is great but I wanted to share a back-tracking approach that helps us understand how we can manually build the desired sequence using direct recursion instead of <code>for</code> loops. It's not a better program; it's an exercise to check your mastery of generators -</p>
<pre><code>from functools import reduce

def empty ():
  yield from ()

def postorder (node, backtrack = empty(), visit = False):
  if visit:
    yield node.data
    yield from backtrack
  elif node.children:
    yield from reduce \
      ( lambda it, child: postorder (child, it)
      , node.children[::-1]
      , postorder (node, backtrack, True)
      )
  else:
    yield from postorder (node, backtrack, True)
</code></pre>
<p>Test it out -</p>
<pre><code>class node:
  def __init__ (self, data, *children):
    self.data = data
    self.children = children

tree = \
  node("a",
    node("b",
      node("e"),
      node("f",
        node("k"))),
    node("c"),
    node("d",
      node("g"),
      node("h"),
      node("i"),
      node("j")))

print(list(postorder(tree)))
# [ 'e', 'k', 'f', 'b', 'c', 'g', 'h', 'i', 'j', 'd', 'a' ]
</code></pre>
<p>This might help give you an appreciation for what <code>yield</code> actually does for you. Here's the same program without it. Minor differences in <strong>bold</strong> -</p>
<pre><code>def empty ():
  return []

def postorder (node, backtrack = empty, visit = False):
  <b>def gen ():</b>
    if visit:
      return <b>[</b> node.data <b>] + backtrack()</b>
    elif node.children:
      return reduce \
        ( lambda it, child: postorder (child, it)
        , node.children[::-1]
        , postorder (node, backtrack, True)
        ) <b>()</b>
    else:
      return postorder (node, backtrack, True) <b>()</b>
  <b>return gen</b>

<b>def run (gen):
  return gen ()</b>

print(<b>run</b>(postorder(tree)))
# [ 'e', 'k', 'f', 'b', 'c', 'g', 'h', 'i', 'j', 'd', 'a' ]</code></pre>
</div>
<span class="comment-copy">you need to also yield the recursion call using <code>yield from</code>。 see <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer">docs.python.org/3/whatsnew/3.3.html#pep-380</a></span>
