<div class="post-text" itemprop="text">
<p>I have a bunch of context managers that I want to chain. On the first glance, <code>contextlib.nested</code> looked like a fitting solution. However, this method is flagged as deprecated in the documentation which also states that the latest <code>with</code> statement allows this directly:</p>
<blockquote>
<p>Deprecated since version 2.7: The with-statement now supports this
  functionality directly (without the confusing error prone quirks).</p>
</blockquote>
<p>However I could not get Python 3.4.3 to use a dynamic iterable of context managers:</p>
<pre><code>class Foo():
    def __enter__(self):
        print('entering:', self.name)
        return self
    def __exit__(self, *_):
        pass
    def __init__(self, name):
        self.name = name

foo = Foo('foo')
bar = Foo('bar')
</code></pre>
<p>whether chaining:</p>
<pre><code>from itertools import chain
m = chain([foo], [bar])
with m:
     pass

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: __exit__
m = [foo, bar]
</code></pre>
<p>providing the list directly:</p>
<pre><code>with m:
     pass

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: __exit__
</code></pre>
<p>or unpacking:</p>
<pre><code>with (*m):
    pass

  File "&lt;stdin&gt;", line 1
SyntaxError: can use starred expression only as assignment target
</code></pre>
<p>So, how do I properly chain a dynamic amount of context managers in a <code>with</code> statement correctly?</p>
</div>
<div class="post-text" itemprop="text">
<p>You misunderstood that line. The <code>with</code> statement takes more than one context manager, separated by commas, but <em>not</em> an iterable:</p>
<pre><code>with foo, bar:
</code></pre>
<p>works.</p>
<p>Use a <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow"><code>contextlib.ExitStack()</code> object</a> if you need to support a <em>dynamic</em> set of context managers:</p>
<pre><code>from contextlib import ExitStack

with ExitStack() as stack:
    for cm in (foo, bar):
        stack.enter_context(cm)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <em>"multiple manager form of the <code>with</code> statement"</em>, as shown in <a href="https://docs.python.org/2/reference/compound_stmts.html#with" rel="nofollow">the statement's documentation</a>, would be:</p>
<pre><code>with foo, bar:
</code></pre>
<p>i.e. it <em>doesn't</em> support a dynamic number of managers. As <a href="https://docs.python.org/2/library/contextlib.html" rel="nofollow">the documentation for <code>contextlib.nested</code></a> notes:</p>
<blockquote>
<p>Developers that need to support nesting of a variable number of
  context managers can either use the <code>warnings</code> module to suppress the
  <code>DeprecationWarning</code> raised by this function or else use this function
  as a model for an application specific implementation.</p>
</blockquote>
</div>
<span class="comment-copy"><code>with</code> doesn't take an iterable, no. <code>with</code> takes <i>multiple contextmanagers</i>, but not as a list.</span>
<span class="comment-copy">@MartijnPieters That's bad news. So I would need to write a chaining class on my own?</span>
<span class="comment-copy">Confirmed. This works fine. Thank you.</span>
<span class="comment-copy"><b>Brilliant.</b> The ineptly named <code>ExitStack</code> saves the day from yet another caffeine-injected all nighter. Thanks, Martijn!</span>
<span class="comment-copy">@CecilCurry: it maintains a stack of context managers (and callback hooks) that are called in reverse order when the context is exited. I think the name covers this pretty well, actually! Glad my answer was helpful ;-)</span>
