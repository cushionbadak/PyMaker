<div class="post-text" itemprop="text">
<p>I run a python script on a server that has the following basic structure (pseudocode):</p>
<pre><code>for data_item in data_items:
    processed_result=process_data(data_item); #this takes time T0
    upload_result_to_site(processed_result) #this takes time T1
</code></pre>
<p>The basic constraints are:</p>
<ol>
<li><code>data_items</code> is a (big) list of data</li>
<li><code>process_data()</code> uses a lot of cpu.</li>
<li><code>upload_result_to_site()</code> takes very little cpu.</li>
<li><code>T0</code> = <code>5*T1</code> (approx.)</li>
</ol>
<p>Now, I have limited server time, and I would like to use all of it for the cpu-intensive <code>process_data()</code>, rather than on <code>upload_result()</code>. Unfortunately
<code>upload_result_to_site()</code> is necessary.</p>
<p>One solution would be to run:</p>
<pre><code>upload_result_to_site(processed_result)
</code></pre>
<p>in the 'background' in  the same way processes can be run in the background on unix.</p>
<p>I can run the whole script in the background (via <code>os.popen3</code> or <code>subprocess</code>) or I can use a daemon. But I want the simplest solution to this problem. I could not find a way to use subprocess to call only part of a script (a single function)</p>
<p><code>multiprocessing.Pool.map()</code> can  be used, but the process created by it has to be joined and terminated at some point, else the number of subprocesses will keep growing).</p>
<p>Is there a simple way to do this?</p>
<p><strong>Update:</strong> Currently I'm using this workaround:</p>
<pre><code>for data_item in data_items:
    processed_result=process_data(data_item); #this takes time T0
    os.system("myscript.py upload_result_to_site processed_result &amp;")
</code></pre>
<p>where <code>myscript.py</code> is the name of the script and the appropriate handlers are present in <code>__name__==__main__</code>.
The (theoretical) disadvantage is this probably only works on unix. Since my server runs unix, this is fine for me. If someone has a better solution, please answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>The really long term simply solution is to create yourself the elemental building blocks that you need. Your script is doing two very different things. </p>
<p>The "natural" solution would be to turn your script into a module, that simply offers different services. </p>
<p>Then you can write one or more scripts that import that module, and then you could use popen3/subprocess to simply call a small script that only does <em>upload</em> a single result for example.  </p>
</div>
<div class="post-text" itemprop="text">
<p>why not just do something like this?</p>
<pre><code>from multiprocessing import Pool

with Pool() as pool:
  for result in pool.imap_unordered(process_data, data_items)
    upload_result_to_site(result)
</code></pre>
<p>this will cause a number of processes to be launched (Python makes a guess based on how many cores you have) and <code>process_data</code> to be executed in child processes.  results are then returned to the main process where results are uploaded as processing finishes</p>
<p>also note that the "data" is <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer"><code>pickled</code></a> when sent to and retrieved from child jobs, so need to be compatible with this</p>
</div>
<span class="comment-copy">can you not break it into two different scripts and then just call the script in first step and ask it to write results?</span>
<span class="comment-copy">Using <code>multiprocessing.Pool.map()</code> will prevent the number of processes from growing unbounded because they're sized. In my opinion, your best option is to do the uploads in separate processes—even if that means after doing all the CPU-intensive stuff the <code>pool</code> will need to be <code>join()</code>ed to ensure all the upload to finish.</span>
<span class="comment-copy">Would'nt the process started by <code>os.system("myscript.py upload_result_to_site processed_result &amp;")</code> terminate after the upload is successful ? ( by default <code>upload_result_to_site()</code> returns after success ). In that case would the number of processes still grow unbounded?</span>
<span class="comment-copy">I appreciate the quick accept!</span>
<span class="comment-copy">Well, this works and I did mention this solution in the main question. For example, is the script is called myscripy.py, simply doing os.popen3("myscript.py upload_result_to_site pickled_result_file") would do this (assuming appropritate handler in <b>name__==__main</b> and if process_data() writes to pickle). I wanted to see if an alternate way is possible.</span>
<span class="comment-copy">I am currently doing something similar as your answer (see edit to question). If no one suggest s anything better, I'll accept this as the correct answer.</span>
<span class="comment-copy">Sure. And for the record, you can always show additional appreciation for good answers by up voting them :-)</span>
<span class="comment-copy">This is correct, but note that this does'nt solve the cpu issue. cpu usage of upload_result_to_site() is extremely low (only uses bandwitdth really). So what this does is use 100% cpu when doing the process_data() loop and using (nearly) 0% in the pool.map(). This is still better (faser) than doing upload_result_to _site() as part of the loop, but only somewhat better</span>
<span class="comment-copy">I thought you said that the upload was the slow part…  hence you can do lots of these in parallel while leaving most of the CPU time free for the processing</span>
<span class="comment-copy">T0=5*T1. T0 is time for processing, T1 is for uploading. Your solution would work if upload was the slow part. Also note that simply reversing this (pool.map for process, serial for upload) would not give any speedup, since a single process_data() already uses 100% cpu. Infact if thats done, it might actually be slower (because of overhead of creating and joining processes in pool.map)</span>
<span class="comment-copy">sorry, not sure how I misinterpreted that!  you can easily flip things around then.  will update</span>
<span class="comment-copy">I'm not sure this gives any speedup. note the previous comment.</span>
