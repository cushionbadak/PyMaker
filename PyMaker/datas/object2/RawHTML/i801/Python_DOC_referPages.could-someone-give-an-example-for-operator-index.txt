<div class="post-text" itemprop="text">
<p>I understand the operation as converting sth., which is not an integer, to integer. do I understand it correctly?</p>
<p>my attempt to implement the function "operator.index ()":</p>
<pre><code>import operator
a = float (1.0)
print (a)
print (type (a))
print (type (operator.index (a)))
</code></pre>
<p>I have expected:</p>
<pre><code>1.0
&lt;class 'float'&gt;
&lt;class 'integer'&gt;
</code></pre>
<p>actual output:</p>
<pre><code>1.0
&lt;class 'float'&gt;
TypeError: 'float' object can not be interpreted as an integer
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__index__</code> can only be used to <em>losslessly</em> interpret an object as an integer index value. From the <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" rel="nofollow noreferrer">documentation for the hook</a>:</p>
<blockquote>
<p>Called to implement <code>operator.index()</code>, and whenever Python needs to losslessly convert the numeric object to an integer object (such as in slicing, or in the built-in <code>bin()</code>, <code>hex()</code> and <code>oct()</code> functions). Presence of this method indicates that the numeric object is an integer type. Must return an integer.</p>
</blockquote>
<p>A <code>float</code> is <strong>not</strong> an integer type, even if a subset of float values are whole numbers.</p>
<p>In the standard library, only the <code>int</code> and <code>bool</code> types currently implement that hook. The hook exists for custom classes in your own code or defined in 3rd-party libraries to be useable when indexing sequences.</p>
<p>It is distinct from <code>__int__</code> because that hook does allow for lossy conversion; <code>int(3.9)</code> gives you <code>3</code>, but you would not expect <code>listobject[3.9]</code> to work (what should that return, the element at index <code>3</code> or <code>4</code>?). You can't use <code>int()</code> to coerce floats into integers when indexing, or only accept whole floats (that'd be inconsistent and confusing).</p>
<p>You'd only use <code>operator.index()</code> if you need to support arbitrary int-like types in your own Python code:</p>
<pre><code>class SequenceObject:
    # ...
    def __getitem__(self, idx):
        idx = operator.index(idx)  # convert to a valid integer index value
        # ...
</code></pre>
<p>The <code>__index__</code> special method was added to Python with <a href="https://www.python.org/dev/peps/pep-0357/" rel="nofollow noreferrer">PEP 357</a>, so you can use the <code>numpy</code> project integers (which are a different type) in slicing and indexing, so this works:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; number1 = np.int8(1)
&gt;&gt;&gt; type(number1)
&lt;class 'numpy.int8'&gt;
&gt;&gt;&gt; type(operator.index(number1))
&lt;class 'int'&gt;
&gt;&gt;&gt; l = [17, 42, 81]
&gt;&gt;&gt; l[number1]
42
</code></pre>
<p>and <code>__index__</code> to allow your class to be used in indexing:</p>
<pre><code>&gt;&gt;&gt; class EnglishNumber:
...     # lets pretend this is a number that automatically shows
...     # as the English name, like the https://pypi.org/p/inflect would
...     def __init__(self, name, value):
...         self._value = value
...         self._name = name
...     def __repr__(self): return f"&lt;EnglishNumber {self._name}&gt;"
...     def __str__(self): return self._name
...     def __index__(self): return self._value
...
&gt;&gt;&gt; number2 = EnglishNumber("two", 2)
&gt;&gt;&gt; number2
&lt;EnglishNumber two&gt;
&gt;&gt;&gt; operator.index(number2)
2
&gt;&gt;&gt; l[number2]
81
</code></pre>
</div>
