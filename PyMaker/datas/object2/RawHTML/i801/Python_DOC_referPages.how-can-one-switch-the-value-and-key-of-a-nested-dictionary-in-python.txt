<div class="post-text" itemprop="text">
<p>I am writing a deferred acceptance algorithm for doctors and hospitals, but before getting there I need my dictionaries to be presented in a correct manner.</p>
<p>Currently, I have a dictionary of doctors containing a nested dictionary with their rankings of hospitals:</p>
<pre><code>{'Doctor_7': {'Hospital_6': 4.0, 'Hospital_3': 8.0, 'Hospital_1': 10.0, 'Hospital_8': 1.0, 'Hospital_2': 9.0, 'Hospital_10': 5.5, 'Hospital_5': 5.5, 'Hospital_7': 2.0, 'Hospital_4': 7.0, 'Hospital_9': 3.0}
</code></pre>
<p>Here 'Hospital_6' indicates the hospital and 4.0 indicates its ranking by this specific doctor (4 out of 10 in this case)</p>
<p>Due to the DataFrame from which I made this dictionary it is represented in its current form. However, I want the placement of 'Hospital_6' and 4.0 to switch. Hence, I want 4.0 to be a key and hospital_6 to be its value (of the nested dictionary).</p>
<p>However, I do not quite know how to switch these two. If anyone could help me, that would be extremely appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can user dict Comprehension to achieve this:</p>
<pre><code>dict_ ={'Doctor_7': {'Hospital_6': 4.0, 'Hospital_3': 8.0, 'Hospital_1': 10.0, 'Hospital_8': 1.0, 'Hospital_2': 9.0, 'Hospital_10': 5.5, 'Hospital_5': 5.5, 'Hospital_7': 2.0, 'Hospital_4': 7.0, 'Hospital_9': 3.0 }}
new_dict = {key:{v:k for k,v in value.items()} for key, value in dict_.items()}
print(new_dict)
</code></pre>
<p>To learn more about Dict Comprehension: <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">Follow this</a></p>
<blockquote>
<p>NOTE: It will override duplicate keys, which were values in the previous dict. If you have Two hospitals with the same rating, you will get only one.</p>
</blockquote>
<hr/>
<h3>Output:</h3>
<pre><code>{'Doctor_7': {4.0: 'Hospital_6',
  8.0: 'Hospital_3',
  10.0: 'Hospital_1',
  1.0: 'Hospital_8',
  9.0: 'Hospital_2',
  5.5: 'Hospital_5',
  2.0: 'Hospital_7',
  7.0: 'Hospital_4',
  3.0: 'Hospital_9'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>old_dict = {'Doctor_7': {'Hospital_6': 4.0, 'Hospital_3': 8.0, 'Hospital_1': 10.0, 'Hospital_8': 1.0, 'Hospital_2': 9.0, 'Hospital_10': 5.5, 'Hospital_5': 5.5, 'Hospital_7': 2.0, 'Hospital_4': 7.0, 'Hospital_9': 3.0}

new_dict = {doctor: OrderedDict(sorted(((value, hospital) for hospital, value in values.items()), 
            key=lambda p: p[0])) 
            for doctor, values in old_dict.items()}
</code></pre>
<p>Outputs</p>
<pre><code>{'Doctor_7': OrderedDict([(1.0, 'Hospital_8'),
              (2.0, 'Hospital_7'),
              (3.0, 'Hospital_9'),
              (4.0, 'Hospital_6'),
              (5.5, 'Hospital_5'),
              (7.0, 'Hospital_4'),
              (8.0, 'Hospital_3'),
              (9.0, 'Hospital_2'),
              (10.0, 'Hospital_1')])}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the two solutions so far neglect taking care of duplicate keys (the same rating given to multiple hospitals), here is a solution that does.</p>
<p>It has the disadvantage that every rating points to a list of hospitals with that rating, instead of to the name directly, even if that list has a length of one.</p>
<pre><code>from collections import defaultdict

d = {'Doctor_7': {'Hospital_6': 4.0,
                  'Hospital_3': 8.0,
                  'Hospital_1': 10.0,
                  'Hospital_8': 1.0,
                  'Hospital_2': 9.0,
                  'Hospital_10': 5.5,
                  'Hospital_5': 5.5,
                  'Hospital_7': 2.0,
                  'Hospital_4': 7.0,
                  'Hospital_9': 3.0}}

new_d = {}
for doctor, ratings in d.items():
    ratings_inverse = defaultdict(list)
    for hospital, rating in ratings.items():
        ratings_inverse[rating].append(hospital)
    new_d[doctor] = dict(ratings_inverse)

print(new_d)
# {'Doctor_7': {1.0: ['Hospital_8'],
#   2.0: ['Hospital_7'],
#   3.0: ['Hospital_9'],
#   4.0: ['Hospital_6'],
#   5.5: ['Hospital_10', 'Hospital_5'],
#   7.0: ['Hospital_4'],
#   8.0: ['Hospital_3'],
#   9.0: ['Hospital_2'],
#   10.0: ['Hospital_1']}}
</code></pre>
<hr/>
<p>But since you mention a dataframe, if this is a <code>pandas.DataFrame</code> that looked like this:</p>
<pre><code>#                Doctor_1  Doctor_7
# Hospital_1          1.0      10.0
# Hospital_10         8.0       5.5
# Hospital_2          3.0       9.0
# Hospital_3         10.0       8.0
# Hospital_4          6.0       7.0
# Hospital_5          8.0       5.5
# Hospital_6          4.0       4.0
# Hospital_7          4.0       2.0
# Hospital_8          9.0       1.0
# Hospital_9          3.0       3.0
</code></pre>
<p>You can do something like this:</p>
<pre><code>df.apply(lambda col: col.reset_index()\
                        .groupby(col.name)["index"]\
                        .apply(lambda x: x.tolist()))
#                        Doctor_1                   Doctor_7
# 1.0                [Hospital_1]               [Hospital_8]
# 2.0                         NaN               [Hospital_7]
# 3.0    [Hospital_2, Hospital_9]               [Hospital_9]
# 4.0    [Hospital_6, Hospital_7]               [Hospital_6]
# 5.5                         NaN  [Hospital_10, Hospital_5]
# 6.0                [Hospital_4]                        NaN
# 7.0                         NaN               [Hospital_4]
# 8.0   [Hospital_10, Hospital_5]               [Hospital_3]
# 9.0                [Hospital_8]               [Hospital_2]
# 10.0               [Hospital_3]               [Hospital_1]
</code></pre>
</div>
<span class="comment-copy">Hint: dictionary comprehension. Hint 2: ordinary dictionaries cannot be sorted.</span>
<span class="comment-copy">How do you deal with the fact that a Doctor can give the same rating to multiple hospitals?</span>
<span class="comment-copy">Duplicate rankings is definitely an issue that I will look into. Preferably hospitals should not be dropped.</span>
<span class="comment-copy">Thanks for your answer Rajan! I will also look into your link on Dictionary Comprehension. Much appreciated!</span>
<span class="comment-copy">This silently drops hospitals with the same rating (Hospital_10 and Hospital_5). And which one is kept is not even the same across Python sub-versions.</span>
<span class="comment-copy">Thank you for your answer FHTMitchell! I will look into the problem of hospitals being dropped.</span>
