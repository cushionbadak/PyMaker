<div class="post-text" itemprop="text">
<p>I have a set of file names in a list in different folders as shown below:</p>
<p><strong>Input files</strong></p>
<pre><code>['ABC.dat',
'ABC10.dat',
'ABC956.dat',
'ABC_DEF_1.dat',
'ABC_DEF_2.dat',
'ABC_DEF_3.dat',
'ABC10_DEF_1.dat',
'ABC10_DEF_2.dat',
'ABC10_DEF_3.dat',
'ABC956_DEF_1.dat',
'ABC956_DEF_2.dat',
'ABC956_DEF_3.dat',
'XYZ_ABC_1.dat',
'XYZ_ABC_2.dat',
'XYZ10_ABC_1.dat',
'XYZ10_ABC_2.dat',
'XYZ956_ABC_1.dat',
'XYZ956_ABC_2.dat',
'XYZ_PQR_JKL.dat',
'XYZ_PQR_JKL_1.dat',
'XYZ_PQR10_JKL.dat',
'XYZ_PQR10_JKL_1.dat',
'XYZ_PQR956_JKL.dat',
'XYZ_PQR956_JKL_1.dat'] 
</code></pre>
<p>I would like to group the files as follows:</p>
<p><strong>Output list</strong></p>
<pre><code>[['ABC.dat', 'ABC10.dat', 'ABC956.dat'],
['ABC_DEF_1.dat', 'ABC10_DEF_1.dat.dat', 'ABC956_DEF_1.dat'],
['ABC_DEF_2.dat', 'ABC10_DEF_2.dat.dat', 'ABC956_DEF_2.dat'],
['ABC_DEF_3.dat', 'ABC10_DEF_3.dat.dat', 'ABC956_DEF_3.dat'],
['XYZ_ABC_1.dat', 'XYZ10_ABC_1.dat', 'XYZ956_ABC_1.dat'],
['XYZ_ABC_2.dat', 'XYZ10_ABC_2.dat', 'XYZ956_ABC_2.dat'],
['XYZ_PQR_JKL.dat', 'XYZ_PQR10_JKL.dat', 'XYZ_PQR956_JKL.dat'],
['XYZ_PQR_JKL_1.dat', 'XYZ_PQR10_JKL_1.dat', 'XYZ_PQR956_JKL_1.dat']]
</code></pre>
<p>That is to say the files should be grouped based on the pattern of files. Note DEF_1 and DEF_2 have to be grouped separately. The numbers 10, 956 are random, i.e., they are not known before hand. A MWE is given below, which groups based on first few letters as obtained from <a href="https://gis.stackexchange.com/a/206053">OP</a>, how can I extend it to the other letters that is DEF.</p>
<p><strong>MWE</strong></p>
<pre><code>import os
import random
import errno
import itertools
from itertools import repeat

#--------------------------------------
# Main rename code
for root, dirs, files in os.walk('./input_folder'):
    for dir in dirs: 
        print (dir)
        output_files = [s for s in os.listdir(os.path.join(root,dir)) if s.endswith('.dat')]
        groups =  [list(g) for _, g in itertools.groupby(sorted(output_files), lambda x: x[0:2])]    # obtained from Aaron's answer https://gis.stackexchange.com/a/206053
        print (groups)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use recursion:</p>
<pre><code>import re
def is_match(a, b):
  a, b = re.sub('\s\w+\.dat$', '', a).split(), re.sub('\s\w+\.dat$', '', b).split()
  if len(a) != len(b):
     return False
  return all(c == d if not c.isdigit() and not d.isdigit() else c.isdigit() and d.isdigit() for c, d in zip(a, b))

def group_vals(d, _current = []):
  if _current:
    yield _current
  if d:
    _start, *_d = d
    yield from group_vals([i for i in _d if not is_match(_start, i)], [_start, *[i for i in _d if is_match(_start, i)]])
</code></pre>
<hr/>
<pre><code>files = list(filter(None, _input.split('\n')))
print(list(group_vals(files)))
</code></pre>
<p>Output:</p>
<pre><code>[['ABC 956.dat', 'ABC 114.dat', 'ABC 577.dat', 'ABC 782.dat'], 
 ['ABC DEF 10.dat', 'ABC DEF 23.dat', 'ABC DEF 27.dat', 'ABC DEF 54.dat'], 
  ['XYZ-ABC 158.dat', 'XYZ-ABC 221.dat', 'XYZ-ABC 668.dat', 'XYZ-ABC 919.dat'], 
  ['ABC 127 JKL.dat', 'ABC 272 JKL.dat', 'ABC 462 JKL.dat', 'ABC 707 JKL.dat'], 
  ['ABC 137 XYZ 97.dat', 'ABC 164 XYZ 25.dat', 'ABC 418 XYZ 13.dat', 'ABC 913 XYZ 11.dat'], 
  ['ABC 258 PQR0 0.dat', 'ABC 551 PQR0 3.dat', 'ABC 606 PQR0 5.dat', 'ABC 654 PQR0 2.dat'], 
  ['ABC 542 PQR1 4.dat', 'ABC 234 PQR1 2.dat', 'ABC 432 PQR1 7.dat', 'ABC 766 PQR1 5.dat']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You probably should try Regular Expression in Python (re library).</p>
<blockquote>
<p><strong>re.findall</strong>(pattern, string, flags=0)<br/>
  Return all non-overlapping matches of pattern in string, as a list of strings.</p>
</blockquote>
<pre><code># suppose files is a string holds all your file names (you could join your file names together)
files = """ABC 956.dat
ABC DEF 10.dat
ABC DEF 23.dat
ABC DEF 27.dat
ABC DEF 54.dat
XYZ-ABC 158.dat
XYZ-ABC 221.dat
XYZ-ABC 668.dat
XYZ-ABC 919.dat"""

# use re to find the names with certain pattern.
import re
g1 = re.findall('ABC \d{3}.dat', files)
# ['ABC 956.dat', 'ABC 158.dat', 'ABC 221.dat', 'ABC 668.dat', 'ABC 919.dat']
g2 = re.findall('ABC DEF \d{2}.dat', files)
# ['ABC DEF 10.dat', 'ABC DEF 23.dat', 'ABC DEF 27.dat', 'ABC DEF 54.dat']

# more groups to go with similar settings
</code></pre>
<p>In the code example, \d represents one digit and {n} represents the number of occurrence of the previous pattern. Thus \d{3} means 3 digits.</p>
<p>You could get more information about regular expression <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is based on Ajax1234's answer. It avoids that answer's redundant computation. Rather than doing a recursive partition by an equivalence relation. This does discrimination. This reduces the cost from <code>N**2/2</code> calls to <code>is_match</code> to only <code>N</code> calls to <code>key</code>. <code>key</code> uses <code>None</code> as a wildcard for the parts of the filename that are digits.</p>
<pre><code>import re
from collections import defaultdict

def key(v):
    return tuple(None if p.isdigit() else p for p in re.sub('.dat$', '', v).split())

def partition(l, key=None):
    d = defaultdict(list)
    for e in l:
        k = key(e) if key is not None else e
        d[k].append(e)
    return [d[k] for k in sorted(d)]

partition(filter(None, _input.split('\n')), key=key)
</code></pre>
<p>This results in:</p>
<pre><code>[['ABC 956.dat', 'ABC 114.dat', 'ABC 577.dat', 'ABC 782.dat'],
 ['ABC 127 JKL.dat', 'ABC 272 JKL.dat', 'ABC 462 JKL.dat', 'ABC 707 JKL.dat'],
 ['ABC 258 PQR0 0.dat', 'ABC 551 PQR0 3.dat', 'ABC 606 PQR0 5.dat', 'ABC 654 PQR0 2.dat'],
 ['ABC 542 PQR1 4.dat', 'ABC 234 PQR1 2.dat', 'ABC 432 PQR1 7.dat', 'ABC 766 PQR1 5.dat'],
 ['ABC 137 XYZ 97.dat', 'ABC 164 XYZ 25.dat', 'ABC 418 XYZ 13.dat', 'ABC 913 XYZ 11.dat'],
 ['ABC DEF 10.dat', 'ABC DEF 23.dat', 'ABC DEF 27.dat', 'ABC DEF 54.dat'],
 ['XYZ-ABC 158.dat', 'XYZ-ABC 221.dat', 'XYZ-ABC 668.dat', 'XYZ-ABC 919.dat']]
</code></pre>
<hr/>
<p>It seems I wasn't clear enough on where to make the changes:</p>
<pre><code>def key(v):
    return tuple(None if p.isdigit() else p for p in re.sub('.dat$', '', v).split('_'))

partition(filter(None, input_list), key=key)
</code></pre>
</div>
<span class="comment-copy">Please describe the pattern in the output you are seeking.</span>
<span class="comment-copy">The input files/names are in a list.</span>
<span class="comment-copy">@TomKurushingal I was going by the other answer. Replace <code>_input.split('\n')</code> with the name of your input list.</span>
<span class="comment-copy">I made some modifications to the question.</span>
<span class="comment-copy">@TomKurushingal So rather than spliting on spaces, you need to split on <code>_</code>. To do that replace <code>.split()</code> in <code>key</code> with <code>.split('_')</code>.</span>
<span class="comment-copy">I tried your corrections, but this is the error I get: TypeError: filter() does not take keyword arguments</span>
