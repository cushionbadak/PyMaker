<div class="post-text" itemprop="text">
<p>I'm trying to output "chunks" of x and y values that are smaller parts of a larger grid.</p>
<p>So for example, I want a first batch to have x values from 0-250 and y values from 0-250. Then the next batch would be x = 0-250 and y = 250-500. The another batch would be x = 250-500 and y = 250-500. And lastly, x = 250-500 and y = 0-250.</p>
<p>So every call to grab a batch with the DataLoader class would grab a small 2D chunk of a larger 2D grid.</p>
<p>This is what I have so far..</p>
<pre><code>class inputDataset(Dataset):

  def __init__(self):
    self.z = 
    torch.Tensor([0.234,0.123,0.831,0.456,0.910,0.356,0.276,0.081])
    self.xmax = 1000
    self.xmin = 0
    self.ymax = 1000
    self.ymin = 0

    self.x = torch.linspace(self.xmin,self.xmax-1,self.xmax)
    self.y = torch.linspace(self.ymin,self.ymax-1,self.ymax)
    self.r = torch.sqrt(torch.mul(self.x,self.x) + /
    torch.mul(self.y,self.y))


  def __len__(self):
    return self.xmax**2 *  (len(self.z) + 3)

  def __getitem__(self, idx):

    out = /
    torch.cat((torch.cat((self.z,self.x[idx].unsqueeze(dim=0)/
    )),torch.cat((self.y[idx].unsqueeze(dim=0)/
    ,self.r[idx].unsqueeze(dim=0)))))

    return out
</code></pre>
<p>Right now I can get x and y to output but they are the same numbers and not chunks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I let myself remove most of the extraneous parts of your code, such as <code>z</code> and <code>r</code>. A minimal data loader which returns consecutive areas of a 2d grid, as you defined it, is below</p>
<pre><code>import torch

class GridDataset:
    def __init__(self):
        self.chunk_size = 250

        self.x = torch.arange(500)
        self.y = torch.arange(500)

    def chunks_x(self):
        return self.x.size(0) // self.chunk_size

    def chunks_y(self):
        return self.y.size(0) // self.chunk_size

    def __len__(self):
        return self.chunks_x() * self.chunks_y()

    def __getitem__(self, idx):
        # integer division to get the id along the first axis
        x_idx = idx // self.chunks_x()
        # modulo division to get the id along the other axis
        y_idx = idx % self.chunks_x()

        cs = self.chunk_size # to make lines shorter

        # grab the actual slices using the computed values of x_idx and y_idx
        x_chunk = self.x[cs * x_idx:cs * (1+x_idx)]
        y_chunk = self.y[cs * y_idx:cs * (1+y_idx)]

        return x_chunk, y_chunk
</code></pre>
<p>Note that I do not exactly understand the purpose of the concatenation in your <code>__getitem__</code> - I just return two tensors with the chunks from <code>x</code> and <code>y</code>. Please let me know if that approach solves your problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's what I've come up with so far...</p>
<pre><code>class GridDataset:
    def __init__(self):
        self.chunk_size = 5

        self.x = torch.arange(100)
        self.y = torch.arange(100)
        self.z = torch.tensor([0.22,0.22,0.45,0.788,0.013])

    def chunks_x(self):
        return self.x.size(0) // self.chunk_size

    def chunks_y(self):
        return self.y.size(0) // self.chunk_size

    def __len__(self):
        return self.chunks_x() * self.chunks_y()

    def __getitem__(self, idx):
        if idx &gt;= len(self): raise IndexError()
        # integer division to get the id along the first axis
        x_idx = idx // self.chunks_x()
        # modulo division to get the id along the other axis
        y_idx = idx % self.chunks_x()

        cs = self.chunk_size # to make lines shorter

        # grab the actual slices using the computed values of x_idx and y_idx
        x_chunk = self.x[cs * x_idx:cs * (1+x_idx)]
        y_chunk = self.y[cs * y_idx:cs * (1+y_idx)]
        print(x_chunk.shape)

        x_chunk = x_chunk.unsqueeze(dim=1).double()
        y_chunk = y_chunk.unsqueeze(dim=1).double()

        xytotal = torch.cat((x_chunk,y_chunk),dim=1)
        r = torch.sqrt(x_chunk**2 + y_chunk**2).float()
        new = torch.zeros((len(xytotal),len(xytotal[0]) + len(self.z)))
        for i in range(len(xytotal)):
          new[i] = torch.cat((xytotal[i].double(),self.z.double()))
        new = torch.cat((new,r),dim=1)


        return new
</code></pre>
<p>If I display one value it outputs:</p>
<pre><code>torch.Size([5])
tensor([[0.0000, 5.0000, 0.2200, 0.2200, 0.4500, 0.7880, 0.0130, 5.0000],
        [1.0000, 6.0000, 0.2200, 0.2200, 0.4500, 0.7880, 0.0130, 6.0828],
        [2.0000, 7.0000, 0.2200, 0.2200, 0.4500, 0.7880, 0.0130, 7.2801],
        [3.0000, 8.0000, 0.2200, 0.2200, 0.4500, 0.7880, 0.0130, 8.5440],
        [4.0000, 9.0000, 0.2200, 0.2200, 0.4500, 0.7880, 0.0130, 9.8489]])
</code></pre>
</div>
<span class="comment-copy">If I do something like: ins = Griddataset      for i , sample in enumerate(ins):     print(i)      it goes on for a long time past what len(ins) is.</span>
<span class="comment-copy">This is because <code>enumerate</code> calls <code>__iter__</code> under the hood, which has a default implementation for objects with <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a> defined. You can avoid this by adding <code>if idx &gt;= len(self): raise IndexError()</code> at the beginning of <code>__getitem__</code>.</span>
<span class="comment-copy">Alright that works!   So I want to now concatenate each separate x and y value, and r value with the z tensor. So I'd have batches of this:  item = z.cat(x).cat(y).cat(r)  Would look like: [0.234,0.167,1,2,5] Where the first two numbers would be the z vector, the next two would be the corresponding x and y values and the last would be r. I'd want a batch of these total vectors which would give me a 3D matrix with z staying constant and x,y and r varying along the first two dimensions. How would I do this?</span>
<span class="comment-copy">To clarify why I want to do this, I want to run this total vector through a forward pass of a neural network which then gives me one pixel intensity value. I want to use batches so I can run multiple total vectors through this network at once.</span>
<span class="comment-copy">Regarding <code>r</code>, you can calculate this on the fly (<code>x_chunk ** 2 + y_chunk **2</code>). For <code>z</code> - I don't understand how you want to concatenate it. <code>z</code> is of length 8. How do you pick the two values which are supposed to go with each of the 1000 values in x and y?</span>
