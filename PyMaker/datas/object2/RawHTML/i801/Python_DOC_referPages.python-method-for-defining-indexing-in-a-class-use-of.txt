<div class="post-text" itemprop="text">
<p>I understand that <code>__add__</code> can be used to define the use of <code>+</code> for a new class. What is the equivalent for defining the use of <code>[]</code>?</p>
<p>I would like to create a class <code>Parent</code> that contains a dictionary <code>codes</code>, and I would like <code>Parent[key]</code> to return <code>Parent.codes[key]</code></p>
<p>I understand that I could probably just use <code>Parent.codes[key]</code>, but this seems needlessly verbose if methods can be used to avoid similar issues with things like <code>+</code> and <code>==</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have a number of options. If you what your class to quack like a <code>dict</code>, your best The best bet is probably just to extend <code>dict</code> instead of referencing one and attempting to redirect all the methods:</p>
<pre><code>class Parent(dict):
    # probably do something with the constructor, maybe
</code></pre>
<p>This will allow you to index right into <code>Parent</code>, list the keys, iterate over the values, etc. At the same time, you can add whatever additional attributes, properties and methods your heart desires.</p>
<p>The literal answer to your question is <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a>, <a href="https://docs.python.org/3/reference/datamodel.html#object.__setitem__" rel="nofollow noreferrer"><code>__setitem__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__delitem__" rel="nofollow noreferrer"><code>__delitem__</code></a>. You can implement the three use-cases of the indexing operator with these methods:</p>
<pre><code>class Parent:
    def __init__(self, *args, **kwargs):
        self.codes = dict(*args, **kwargs)

    def __getitem__(self, key):
         return self.codes[key]

    def __setitem__(self, key, value):
         self.codes[key] = value

    def __delitem__(self, key):
         del self.codes[key]
</code></pre>
<p>The methods are invoked on an instance of <code>Parent</code> in exactly the same way that <code>Parent</code> redirects them to <code>dict</code>.</p>
<p>For future reference, the methods shown here (including your example of <code>__add__</code>) are called magic, special or dunder methods. All dunder (double underscore) attributes are reserved by the interpreter. They serve many purposes, including operator overloading in custom objects. The (nearly) complete spec of existing names is available in the documentation of the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Python Data Model</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you are looking for is:</p>
<pre><code>def __getitem__(self, key):
</code></pre>
<p>edit:</p>
<p>more specifically, what you want is:</p>
<pre><code>def __getitem__(self, key):
   return self.Codes[key]
</code></pre>
<p>edit2: delete some irrelevant text on <code>__iter__</code> and <code>__next__</code> (see comments)</p>
</div>
<span class="comment-copy"><code>__getitem__</code>. Also <code>__setitem__</code> and <code>__delitem__</code> if you need that.</span>
<span class="comment-copy">The complete list (other than library-specific ones) is at: <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#special-method-names</a></span>
<span class="comment-copy">@o11c. But that's what inheritance is really for.</span>
<span class="comment-copy">@MadPhysicist Sort of. It is almost always the case that composition is both more flexible and intuitive than inheritance. The requirements on inheritance are pretty strict: and it's difficult to tell with this limited information that it's the right tool for the job.</span>
<span class="comment-copy">@Matt. While generally true, I've found Python inheritance to be much more flexible and less restrictive than most other languages I'm familiar with. The lack of true privacy leans me in favor of inheritance as well, since you can't hide any part of the API anyway.</span>
<span class="comment-copy">Do not call <code>__iter__</code> yourself, instead, use <code>yield from Codes</code>. As for <code>__next__</code>, op is not implementing an iterator and a <code>__dict__</code> does not have a <code>__next__</code> method.</span>
<span class="comment-copy">@Olivier. Or better yet, just <code>return iter(codes)</code>.</span>
<span class="comment-copy">Thanks, I removed those parts from the text</span>
