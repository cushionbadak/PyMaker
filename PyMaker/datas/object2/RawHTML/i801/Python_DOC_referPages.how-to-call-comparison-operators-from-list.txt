<div class="post-text" itemprop="text">
<p>Hi I want to install some kind of adjustable comparer where an element from a list <strong>a</strong> is compared to an element of a list <strong>Values</strong> with an operator which is read from a list <strong>Operators</strong></p>
<pre><code>a = [1,2,3,4] # This should be variable
Val = [0.5,1,10,7] # This should have the same length as a
Op = ['&lt;','&gt;','&lt;&gt;','&lt;']

for i in range(len(a)):
    print(a[i]Op[i]Val[i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>eval</code> even in some situation it is unstable, but if only consider your case , it work as expected and better solution is  <code>sympy</code></p>
<pre><code>a = [1,2,3,4] # This should be variable
Val = [0.5,1,10,7] # This should have the same length as a
Op = ['&lt;','&gt;','!=','&lt;']

for i in range(len(a)):
    parse_expr(str(a[i])+Op[i]+str(Val[i]))# or change to eval(str(a[i])+Op[i]+str(Val[i]))

False
True
True
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of comparison symbols, use the function from <a href="https://docs.python.org/2/library/operator.html#module-operator" rel="nofollow noreferrer">operators</a>.</p>
<p>May be this can help!</p>
<pre><code>from operator import lt, gt, ne, le,eq
a = [1,2,3,4] # This should be variable
val = [0.5,1,10,7] # This should have the same length as a
operation = {'&lt;': lt, '&gt;': gt, '&lt;&gt;': ne, '=': eq}


op = ['&lt;','&gt;','&lt;&gt;','&lt;']

for i,o,j in zip(a,op,val):
    print(operation[o](i,j))

False
True
True
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems that you need programmatic way to call comparison operators, <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer"><code>operator</code></a> module will do the work. Either construct list of operator functions or make signs to operator mapping via <code>dict</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [1,2,3,4] # This should be variable
b = [0.5,1,10,7] # This should have the same length as a
c = ['&lt;','&gt;','&lt;&gt;','&lt;']
</code></pre>
<p>use </p>
<pre><code>for i in range(len(a)):
    eval(str(a[i])+b[i]+str(c[i]))
</code></pre>
</div>
<span class="comment-copy">Ok, so you're asking us to write it for you? You've not shown any attempt to implement this.</span>
<span class="comment-copy">and you have unbalanced brackets...</span>
<span class="comment-copy">Have you taken a look at <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer"><code>eval</code></a>?</span>
<span class="comment-copy">@Scratch'N'Purr have you taken a look at <a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow noreferrer">eval really is dangerous</a>?</span>
<span class="comment-copy">@Scratch'N'Purr sure, but a) this could be a contrived example, we don't know where those values actually come from in the real program and b) this post may come up in a search from any person solving any problem in future.</span>
<span class="comment-copy">I'm really surprised you suggested <code>eval</code> here rather than mapping the operations to the <code>operator</code> module or suggesting <code>sympy</code> or.... literally anything but eval</span>
<span class="comment-copy">@roganjosh I notice that too, just need some time to find out what I used before</span>
<span class="comment-copy">That is certainly the best way to do it. It could also work with the original <code>['&lt;','&gt;','&lt;&gt;','&lt;']</code> as input, with a simple mapping <code>{'&lt;': lt, '&gt;': gt, '&lt;&gt;': ne, '=': eq}</code></span>
<span class="comment-copy">Thanks. Updated my solution.</span>
