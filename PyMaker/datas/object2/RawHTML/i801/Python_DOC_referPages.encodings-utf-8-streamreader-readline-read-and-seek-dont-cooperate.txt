<div class="post-text" itemprop="text">
<p>Consider this very simple example. </p>
<pre><code>import codecs
from io import BytesIO

string = b"""# test comment
Some line without comment
# another comment
"""

reader = codecs.getreader("UTF-8")
stream = reader(BytesIO(string))

lines = []
while True:
    # get current position
    position = stream.tell()

    # read first character
    char = stream.read(1)

    # return cursor to start
    stream.seek(position, 0)

    # end of stream
    if char == "":
        break

    # line is not comment
    if char != "#":
        lines.append(stream.readline())
        continue

    # line is comment. Skip it.
    stream.readline()

print(lines)
assert lines == ["Some line without comment\n"]
</code></pre>
<p>I am trying to read line by line from StreamReader and if the line starts with <code>#</code> I skip it otherwise I store it in a list. But there is some strange behaviour when I use <code>seek()</code> method. It seems like <code>seek()</code> and <code>readline()</code> don't cooperate and move cursor somewhere far away. The result list is empty. </p>
<p>Of course I could do it in different way. But as I wrote above this is a very simple example and it helps me understand how things work together.</p>
<p>I use Python 3.5.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't want to use <code>codecs</code> stream readers. They are an older, outdated attempt at implementing layered I/O to handled encoding and decoding of text, since superseded by the <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer"><code>io</code> module</a>, a much more robust and <em>faster</em> implementation. There have been <a href="https://www.python.org/dev/peps/pep-0400/" rel="nofollow noreferrer">serious calls for the stream readers to be deprecated</a>.</p>
<p>You really want to replace your use of <code>codecs.getreader()</code> with the <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow noreferrer"><code>io.TextIOWrapper()</code> object</a>:</p>
<pre><code>import codecs
from io import BytesIO, TextIOWrapper

string = b"""# test comment
Some line without comment
# another comment
"""

stream = TextIOWrapper(BytesIO(string))
</code></pre>
<p>at which point the <code>while</code> loop works and <code>lines</code> ends up as <code>['Some line without comment\n']</code>.</p>
<p>You also don't need to use seeking or <code>tell()</code> here. You could just loop directly over a file object (including a <code>TextIOWrapper()</code> object):</p>
<pre><code>lines = []
for line in stream:
    if not line.startswith('#'):
        lines.append(line)
</code></pre>
<p>or even:</p>
<pre><code>lines = [l for l in stream if not l.startswith('#')]
</code></pre>
<p>If you are concerned about the <code>TextIOWrapper()</code> wrapper object closing the underlying stream when you no longer need the wrapper, just <em>detach</em> the wrapper first:</p>
<pre><code>stream.detach()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code will work if you simply swap </p>
<pre><code>reader = codecs.getreader("UTF-8")
stream = reader(BytesIO(string))
</code></pre>
<p>with</p>
<pre><code>stream = BytesIO(string)
</code></pre>
<p>EDIT: If you want to use StreamReader, you can get rid of the repositioning with <code>tell()</code>, as <code>stream.read()</code> and <code>stream.readline()</code> are sufficient for repositioning. In other words, with your current code you are repositioning twice.</p>
<p>The changed code in the loop:</p>
<pre><code>    # read first character
    char = stream.read(1)

    # end of stream
    if char == "":
        break

    # line is not comment
    if char != "#":
        lines.append(char + stream.readline())
        continue

    # line is comment. Skip it.
    stream.readline()
</code></pre>
<p>Note the change to <code>lines.append()</code></p>
</div>
<span class="comment-copy">I would suggest to always judt read the line in the first place and afterwards check the first char of the resulting string in oder to decide whether to append the line to your list or not.</span>
<span class="comment-copy">This seems to be a <a href="https://www.python.org/dev/peps/pep-0400/#read-and-seek-0" rel="nofollow noreferrer">known issue</a>. If you insists on using <code>StreamReader</code> then I encourage you to read the whole PEP, at least you will know what to expect. My opinion is that the writing is on the wall and you really should find another way.</span>
<span class="comment-copy">TextIOWrapper is a great solution but I cannot use it since it's garbage collected too early and it closes the stream. <a href="https://stackoverflow.com/questions/30993816/prevent-textiowrapper-from-closing-on-gc-in-a-py2-py3-compatible-way" title="prevent textiowrapper from closing on gc in a py2 py3 compatible way">stackoverflow.com/questions/30993816/â€¦</a> .</span>
<span class="comment-copy">@Joozty I think you have a much better chance to overcome <code>TextIOWrapper</code> issues than <code>StreamReader</code> issues. But it is hard to provide heplpful advice without seeing a realistic example of what you are trying to do, which the code in the question seems not to be.</span>
<span class="comment-copy">@Joozty The accepted answer to the linked question explains how to avoid <code>TextIOWrapper</code> closing the stream. If that does not solve your issue you should explain why in the question.</span>
<span class="comment-copy">@Joozty: you can trivially avoid that by disconnecting the <code>TextIOWrapper</code> object again; call <code>stream.detach()</code> and it'll no longer close the underlying stream as it is no longer associated with it. I've added an answer to that question, there is absolutely no need to go to those lengths just because the wrapper goes out of scope.</span>
<span class="comment-copy">@Joozty: just a heads-up: the OP of the question you linked has now marked my answer as accepted.</span>
<span class="comment-copy">Yeah, that's true, but it is important to use reader. This is only simple example - Minimal Working Example</span>
