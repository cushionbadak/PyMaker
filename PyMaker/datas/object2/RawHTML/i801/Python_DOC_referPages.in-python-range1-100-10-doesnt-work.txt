<div class="post-text" itemprop="text">
<p>I have a problem with <code>range()</code> or the for loop.</p>
<p>in C++, the for loop can be used like this:</p>
<pre><code>for(int i=1;i&lt;=100;i*=10){
 //lala
}
</code></pre>
<p>My Python script that causes the error looks like this:</p>
<pre><code>li = [x for x in range(100, 0, /10)]

print(li)
</code></pre>
<p>I hope to get <code>li = [100, 10, 1]</code></p>
<p>How can I achieve this without the use of <code>li.append ( 100, 10, 1 )</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use a generator expression, like</p>
<pre><code>for i in (10 ** x for x in range(2, -1, -1)):
    print(i)
# 100
# 10
# 1
</code></pre>
<p>Or, if you want your "power range" to be a reusable function, you can create your own, i.e.</p>
<pre><code>def powrange(*args, base=10):
    for i in range(*args):
        yield base ** i


for i in powrange(2, -1, -1, base=10):
    print(i)
# 100
# 10
# 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't use <code>range</code> for this. The third argument for range is a fixed step used to increment the value: it can't be used to multiply or divide the previous value.</p>
<p>Instead, use a <code>while</code> loop:</p>
<pre><code>i = 1
while i &lt; 100:
   ...
   i *= 10  # or i /= 10 depending on what you want.
</code></pre>
<p>If you <em>really</em> want to use a list comprehension, you can do as suggested by Albin Paul:</p>
<pre><code>li = [10**x for x in range(3) ]  # [1, 10, 100]
li = [10**x for x in range(2, -1, -1)  # [100, 10, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The built-in range is not meant to be used this way. It takes three arguments: <code>range(start, stop, step)</code> and goes from <code>start</code> to <code>stop</code> with a constant stepsize.</p>
<p>If you want to use a single function, you could use numpy's <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.logspace.html" rel="nofollow noreferrer">logspace</a></p>
<p>It looks like this:</p>
<pre><code>import numpy
li = numpy.logspace(0, 2, base=10, dtype = int)
# li is [1, 10, 100]
# goes from base^0 to base^2, so from 1 to 100
</code></pre>
<p>If you don't want to rely on numpy, the solution with a while loop seems very pythonic to me.</p>
<p><strong>Benchmark time :D</strong></p>
<p>A comment pointed out that this solution might be:</p>
<ul>
<li>non obvious</li>
<li>slow</li>
</ul>
<p>The first point is a matter of taste, but I disagree on performance:</p>
<pre><code>reps = 100000
list_elems = 100

start = time.perf_counter()
for i in range(reps):
    np.logspace(0, list_elems, base=2, dtype=int)
end = time.perf_counter()
numpy_time = end - start


start = time.perf_counter()
for i in range(reps):
    [2**x for x in range(list_elems)]
end = time.perf_counter()
python_time = end - start

# reps = 100000
# list_elems = 100
# numpy took 1.70, python took 2.86

# reps = 100000
# list_elems = 10
# numpy took 1.65, python took 0.242
</code></pre>
<p>Of course, this depends a lot on the number of list elements that you want to produce. Numpy introduces overhead but scales better. So for shorter lists, python wins.</p>
</div>
<div class="post-text" itemprop="text">
<p>To change make a <code>log(n)</code> time complexity loop you need the log function or use while loops to do the job </p>
<pre><code>In [10]: import math
In [9]:  [10**x for x in range( 0,int(math.log10(1000)))]
Out[9]: [1, 10, 100]
</code></pre>
<p>I still think while loops are the way to go</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#ranges" rel="nofollow noreferrer">The arguments for <code>range</code></a> are: start, stop and step, where the step is int. 
Maybe you want to see the result as this:</p>
<pre><code>li = [10**x for x in range(0, 3, 1)]
print(li)
</code></pre>
<blockquote>
<p>[1, 10, 100]</p>
</blockquote>
<p>Overall take a look at a nice learning course, for example, "Automate the Boring Stuff with Python":</p>
<ul>
<li><a href="https://youtu.be/HFQGxh1jY3g" rel="nofollow noreferrer">Here is the video right about loops</a> </li>
<li><a href="https://automatetheboringstuff.com/#toc" rel="nofollow noreferrer">And here is the whole
course (available online for free)</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>When you use the for loop as 
<code>with x in range(start,stop,step)</code> </p>
<p>The way it takes place is that first</p>
<p>Edit: The first part is explanation why it won't work</p>
<ol>
<li><p>You get a list generated by the range function(Not since python3 though), now it only returns a function range and its current state, this can be of float or int, so using <code>/10 as step</code> there will do nothing other than Invalid syntax, because range only accepts integers.</p></li>
<li><p>Only after this does x gets initialized and starts taking values present in the dictionary in an indexed way.</p></li>
</ol>
<p>You can however use</p>
<p><code>for y in range(2,-1,-1):
     x = (10**y)</code> </p>
<p>Welcome to python and happy coding.</p>
<p>Thanks to @GPhilo for pointing out the errors.</p>
</div>
<span class="comment-copy">A lot of incorrect information in this post: You can use <code>range()</code> for this (you yourself are doing it), and if you do, you shouldn't use list comprehensions, but generator expressions, i.e. <code>(10**x for x in range(3))</code></span>
<span class="comment-copy">@NilsWerner no, what the OP wanted is a use of range with some "operator-parameters" (forgive the made up term) that control how the step is updated. That's what people meant when saying "you can't use range for this". Of course, transforming a range in order to obtain the desired output is the way to go, but it takes a different approach than just passing the correct parameters to a builtin function</span>
<span class="comment-copy">Using <code>numpy.logspace</code> for a loop variable is certainly not the most efficient and obvious way...</span>
<span class="comment-copy">@NilsWerner, hm, I don't think I agree with you here. If you use numpy, the logspace function is a very obvious way to do it. And since I specified dtype = int, I'm not sure about the performance. For three elements it probably doesn't matter. But as soon as you want such a list with a few more items (probably not base 10 then :P ), numpy could be much more efficient ...</span>
<span class="comment-copy">I dont understand why the downvote?</span>
<span class="comment-copy">This is just plain wrong. Firstly, ever since python 3 <code>range</code> does not return a list of values. Secondly, <code>range</code> takes <i>integers</i> for all its parameters so passing <code>1/10</code> for anything won't work either. Lastly, your loop is never terminating because you'll never get 0 from iterating divisions.</span>
<span class="comment-copy">And after your edit, the code is <i>still</i> wrong. If you were to try and run it you'd realize the syntax is wrong (you can't use <code>10**x</code> as the index of a for loop)</span>
<span class="comment-copy">@GPhilo My bad, thanks for the suggests, made edits accordingly.</span>
