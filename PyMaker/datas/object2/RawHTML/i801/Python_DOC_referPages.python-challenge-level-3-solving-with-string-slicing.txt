<div class="post-text" itemprop="text">
<p>apologies to posting the question, as has been answered in other questions as well. However, couldn't figure out what's wrong with this solution. The question requires to find the lower-cased characters bordered by 3 upper-cased characters on each side.  The code i've writting:</p>
<pre><code>q = ''
for i in range(4,len(x)-4):
    if x[i].islower() and x[i-4].islower() and x[i+4].islower() and x[i-3:i].isupper() and x[i+1:i+4].isupper()  :
        q+=x[i]


print(q)
</code></pre>
<p>The string i'm getting is </p>
<blockquote>
<p>'lgvcaaginbkvsoezhtlnldslyitlooqfgiksudtm' 
  vs 'linkedlist'</p>
</blockquote>
<p>Thanks for the help. </p>
<p>Edit: for some reason the following code seems to work:</p>
<pre><code>q = ''
for i in range(4,len(x)-4):
    if x[i].islower() and x[i-4].islower() and  x[i-3:i].isupper() and x[i+1:i+4].isupper() and x[i+4].islower():
        q+=x[i]

print(q)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are trying to do is match a pattern : Not Upper, Upper, Upper, Upper, Not Upper, Upper, Upper, Upper, Not Upper. This is easier to catch if you use a signature for your string:</p>
<pre><code>&gt;&gt;&gt; t = "This is some TEXtTHAt will result in one true result"
&gt;&gt;&gt; sig = "".join("U" if c.isupper() else "l" for c in t)
&gt;&gt;&gt; sig
'UllllllllllllUUUlUUUllllllllllllllllllllllllllllllll'
</code></pre>
<p>You are looking for the <code>lUUUlUUUl</code> substrings in the <code>sig</code> string. Python has no builtin for <code>findall</code>, but you can to iterate over the results of <code>find</code>:</p>
<pre><code>&gt;&gt;&gt; result = ""
&gt;&gt;&gt; i = sig.find("lUUUlUUUl")
&gt;&gt;&gt; while i != -1: # find != -1 means that the substring wasn't found
...     result += t[i+4] # the center `l` 
...     i = sig.find("lUUUlUUUl", i+4) # we can start the next search at the center `l`
... 
&gt;&gt;&gt; print( result )
t
</code></pre>
<p>You may also use <code>re.finditer</code> with a regex pattern, but is more complicated.</p>
</div>
<div class="post-text" itemprop="text">
<p>This would be a slicing solution:</p>
<pre><code>t = "This is some TEXtTHAt will result in one true result"

def notupper(x): 
    return not x.isupper()

yep = []
# lookup function to execute inside all()
terms = {0:notupper, 8:notupper, 4:notupper}

for part in (t[i:i+9] for i in range(len(t)-7)):
    if len(part)&lt;9:  # fix for XXXxXXX at end of string
      part = (part+"  ")[:9]
    if all(terms.get(index,str.isupper)(ch) for index,ch in enumerate(part)):
        print("Statisfies all terms: ", part)
</code></pre>
<p>It slices the text into parts of 9 characters (you need 9 to assure not to have XXXXyXXXX - you need exactly three uppers around your lowers.</p>
<p>It checks the sliced text for <code>notupper</code> on positions 0,8 and 4:</p>
<pre><code>XXXXxXXXX
012345678
lUUUlUUUl   # must statisfy: l=notupper and U=isupper
</code></pre>
<p>by pulling this function from the <code>terms</code>-dictionary. All indexes of <code>part</code> that have no matching key in <code>terms</code> are tested with <code>str.isupper</code> using the default param of <code>terms.get(index,str.isupper)</code></p>
<p><code>all()</code> makes sure all tests need to evaluate to true to enter the if-condition.</p>
<p>Spaces evaluate to <code>False</code> for isupper and islower().</p>
<p>Readup:</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer">all()</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">dict.get(key,default)</a> and <a href="https://stackoverflow.com/questions/11041405/why-dict-getkey-instead-of-dictkey">Why dict.get(key) instead of dict[key]?</a></li>
<li><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer">enumerate(iterable)</a></li>
</ul>
<hr/>
<p>You can replace the <code>dict/all</code> part by:</p>
<pre><code># the ( .. ) are needed to enable line breaking - you could use \ as well
if notupper(part[0]) and notupper(part[8]) and notupper(part[4]) and (
    part[1].isupper() and part[2].isupper() and part[3].isupper() and
    part[5].isupper() and part[6].isupper() and part[7].isupper()):
    print("Statisfies all terms: ", part)
</code></pre>
<p>if that is too complicated for your current level of python.</p>
</div>
<span class="comment-copy">your test string has no uppers in it ... kindof a bad test case - isn't it?</span>
<span class="comment-copy">have the upper cases in the end, that what you meant? Also removed the 'True'</span>
<span class="comment-copy">you only have lower case characters: <code>'lgvcaaginbkvsoezhtlnldslyitlooqfgiksudtm' vs 'linkedlist'</code> - not a single <code>'UPPER CASE CHARACTER'</code> in it ...</span>
<span class="comment-copy">Regex solution could be more appropriate?</span>
<span class="comment-copy">@Austin : <code>'THISwOULD qualify'</code> - although it is not correct spelled</span>
<span class="comment-copy">i'm trying to wrap my head around the solution, it didn't work for the given string.</span>
<span class="comment-copy">to only return the lowercase letter use <code>part[4]</code></span>
<span class="comment-copy">@pyt and this one works .. if you replace <code>print("Statisfies all terms: ", part)</code> by <code>print("Statisfies all terms: ", part[4])</code> and use as <code>t</code>:  <code>t ="""&lt;!-- kAewtloYgcFQaJNhHVGxXDiQmzjfcpYbzxlWrVcqsmUbCun.....PNeKsTXruMUumRRPQJzvSzJkKbtSipiqBd --&gt; """.replace("\n","")</code>  you get <code>linkedlist</code> as result...</span>
