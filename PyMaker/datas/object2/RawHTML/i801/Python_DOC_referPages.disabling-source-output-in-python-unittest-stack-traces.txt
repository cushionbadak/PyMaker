<div class="post-text" itemprop="text">
<p>The unittest framework in python outputs a stack trace when you encounter an exception. Each line of the stack trace is accompanied by source code in the output. This causes the stack trace to be hundreds of lines of scrolling and, in my opinion, very hard to read.</p>
<p>Is there a way to run a python unittest so that when an exception is caught the stack trace output is in a shortened form? I'd like just the source lines, excluding all the extra source.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is the job of <a href="https://docs.python.org/3/library/unittest.html#unittest.TestResult.addError" rel="nofollow noreferrer"><code>TestResult.addError()</code></a> to format exceptions:</p>
<blockquote>
<p>Called when the test case <em>test</em> raises an unexpected exception. <em>err</em> is a tuple of the form returned by <code>sys.exc_info()</code>: <code>(type, value, traceback)</code>.</p>
<p>The default implementation appends a tuple <code>(test, formatted_err)</code> to the instanceâ€™s <code>errors</code> attribute, where <em>formatted_err</em> is a formatted traceback derived from <em>err</em>.</p>
</blockquote>
<p>If you want to format your tracebacks differently, this is where you'd step in to change them. You have two options:</p>
<ul>
<li>Write your own traceback formatter (to replace the <a href="https://github.com/python/cpython/blob/09b66e027bdd4d7af6921fa2a2c9536f9cf5eebe/Lib/unittest/result.py#L173-L200" rel="nofollow noreferrer">current implementation</a>)</li>
<li>Post-process the <code>formatted_err</code> value that the base implementation adds.</li>
</ul>
<p>The latter might be simpler; just delete any further indented lines following a line that starts with <code>'  File'</code>:</p>
<pre><code>import re
import unittest
from functools import partial

# traceback `File` lines are followed by an optional source line, and if
# locals are included, by &lt;name&gt; = &lt;value&gt; lines:
_tb_file_line = re.compile(
        r'(  File "[^"]*", line \d+, in [^\n]+\n)'
        r'    [^ ].*\n'
        r'(?:    \w+ = .*\n)*'
)
_clear_source_and_locals = partial(_tb_file_line.sub, r'\1')

class NoSourceTracebackResult(unittest.TextTestResult):
    def addError(self, test, err):
        super().addError(test, err)
        # remove error, format, then put it back again
        t, formatted_err = self.errors.pop()
        formatted_err = _clear_source_and_locals(formatted_err)
        self.errors.append((test, formatted_err))

class NoSourceTracebackRunner(unittest.TextTestRunner):
    resultclass = NoSourceTracebackResult
</code></pre>
<p>then use that as your test runner; if you run with <code>unittest.main()</code> in a <code>__main__</code> guard, then use it like this:</p>
<pre><code>if __name__ == '__main__':
    unittest.main(testRunner=NoSourceTracebackRunner)(
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/33555891/make-python-unittest-show-assertionerror-but-no-traceback">this one</a></span>
