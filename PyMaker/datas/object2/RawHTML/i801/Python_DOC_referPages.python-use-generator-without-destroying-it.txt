<div class="post-text" itemprop="text">
<p>Hi I have a generator object.
I want to count how many of each element there are in it. Without destroying the generator/changing (i want to use it again later).</p>
<p>Here is an example. </p>
<pre><code>def create(n):
    items = ["a", "b", "c"]
    for i in range(n):
        yield items[random.randint(0,2)]

def countEach(gen):
    r = []
    for a in gen:
        add = True
        for i in range(len(r)):
            if a == r[i][0]:
                r[i][1] += 1
                add = False
        if add:
            r.append([a,0])
    return r

gen_list = create(100)
print (countEach(gen_list))
for b in gen_list:
    print (b)
</code></pre>
<p><em>output</em></p>
<pre><code>[['b', 33345], ['c', 33298], ['a', 33354]]
[Finished in 0.6s]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unless I am fundamentally misunderstanding how Python generators work, this isn't possible and you should return in your create method rather than yield a generator.</p>
<pre><code>def create(n):
    items = ["a", "b", "c"]
    return [items[random.randint(0,2)] for i in range(n)]
</code></pre>
<p>The above list comprehension will create a list rather than use a generator. For a better understanding of generators I'd suggest reading through <a href="https://stackoverflow.com/questions/1756096/understanding-generators-in-python">this excellent post</a>.</p>
<p>EDIT: Out of curiosity I timed the list(create(n)) method suggested by Tomothy32 against mine which returns a list. As expected, it's marginally slower to return the generator then store the list via comprehension (averaged 130 microseconds vs 125 microseconds). However you may prefer to leave the original method untouched and have the simple option of saving specific generator calls as lists rather than redefining it and always returning a list object.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no need to change the <code>create</code> generator. Just do:</p>
<pre><code>gen_list = list(create(100))
</code></pre>
<p>You can reuse this as much as you want.</p>
</div>
<span class="comment-copy">Not possible without creating a permanent data structure, like a <code>list</code>.</span>
<span class="comment-copy">I noticed that when using yield code after is also executed. Is it possible to yield and return somehow?</span>
<span class="comment-copy">You could also use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a> to make <code>n</code> independent iterators from a single iterable.</span>
<span class="comment-copy">You could append to a list, then return it at the end, but you can't mix <code>return</code> and <code>yield</code>. But <code>list(create(100))</code> will do the job much easier. You can reuse this list as much as you want.</span>
<span class="comment-copy">@AbdulNiyasPM But the resulting iterators may yield different values.</span>
<span class="comment-copy">I know i can make a list of it. But if i have a bigger list I will get a memory error.</span>
<span class="comment-copy">@Staked In that case, I apologize, but it is impossible. See <a href="https://stackoverflow.com/questions/3345785/getting-number-of-elements-in-an-iterator-in-python" title="getting number of elements in an iterator in python">stackoverflow.com/questions/3345785/â€¦</a></span>
