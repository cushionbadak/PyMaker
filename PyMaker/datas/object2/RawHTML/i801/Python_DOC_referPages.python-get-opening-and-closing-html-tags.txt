<div class="post-text" itemprop="text">
<p><strong>Question:</strong></p>
<p>How can I find the text for all opening and closing HTML tags with python (3.6).
This needs to be the exact text, keeping spaces and potentially illegal html:</p>
<pre><code># input
html = """&lt;p&gt;This &lt;a href="book"&gt; book &lt;/a  &gt; will help you&lt;/p attr="e"&gt;"""

# desired output
output = ['&lt;p&gt;', '&lt;a href="book"&gt;', '&lt;/a  &gt;', '&lt;/p attr="e"&gt;']
</code></pre>
<p><strong>Attempt at solution:</strong></p>
<p>Apparently this is not possible in Beautifulsoup, this question: <a href="https://stackoverflow.com/questions/41597854/how-to-get-the-opening-and-closing-tag-in-beautiful-soup-from-html-string">How to get the opening and closing tag in beautiful soup from HTML string?</a> links to <a href="https://docs.python.org/3.4/library/html.parser.html#example-html-parser-application" rel="nofollow noreferrer">html.parser</a></p>
<p>Implementing a custom parser is easy. You can use <a href="https://docs.python.org/3.4/library/html.parser.html#html.parser.HTMLParser.get_starttag_text" rel="nofollow noreferrer"><code>self.get_starttag_text()</code></a> to get the text corresponding to the last opened tag. But for some reason, there is no analogous method <code>get_endtag_text()</code>.</p>
<p>Which means that my parser produces this output:</p>
<pre><code>class MyHTMLParser(HTMLParser):
    def __init__(self):
        super().__init__()
        self.tags = []

    def reset_stored_tags(self):
        self.tags = []
    def handle_starttag(self, tag, attrs):
        self.tags.append(self.get_starttag_text())

    def handle_endtag(self, tag):
        self.tags.append(self.get_endtag_text())

    def handle_startendtag(self, data):
        self.tags.append(self.get_starttag_text())
# input
input_doc = """&lt;p&gt;This &lt;a href="book"&gt; book &lt;/a&gt; will help you&lt;/p&gt;"""

parser = MyHTMLParser()
parser.feed(input_doc)

print(parser.tags)
# ['&lt;p&gt;', '&lt;a href="book"&gt;', '&lt;a href="book"&gt;', '&lt;a href="book"&gt;']
</code></pre>
<p>The <code>tag</code> argument of the <code>handle_endtag</code> is just a string <code>"a"</code> or <code>"p"</code>, not some custom datatype that can provide the whole tag.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use recursion and iterate over the <code>soup.contents</code> attribute:</p>
<pre><code>from bs4 import BeautifulSoup as soup

html = """&lt;p&gt;This &lt;a href="book"&gt; book &lt;/a&gt; will help you&lt;/p&gt;"""

def attrs(_d):
  if _d.name != '[document]':
    _attrs = ' '.join(f'{a}="{b}"' for a, b in getattr(_d, 'attrs', {}).items())
    yield f'&lt;{_d.name}&gt;' if not _attrs else f'&lt;{_d.name} {_attrs}&gt;'
  for i in _d.contents:
    if not isinstance(i, str):
       yield from attrs(i)
  if _d.name != '[document]':
    yield f'&lt;/{_d.name}&gt;'

print(list(attrs(soup(html, 'html.parser'))))
</code></pre>
<p>Output:</p>
<pre><code>['&lt;p&gt;', '&lt;a href="book"&gt;', '&lt;/a&gt;', '&lt;/p&gt;']
</code></pre>
<p>Edit: for the invalid HTML, you can use <code>re</code>:</p>
<pre><code>import re
html = """&lt;p&gt;This &lt;a href="book"&gt; book &lt;/a  &gt; will help you&lt;/p attr="e"&gt;"""
new_results = re.findall('\&lt;[a-zA-Z]+.*?\&gt;|\&lt;/[a-zA-Z]+.*?\&gt;', html)
</code></pre>
<p>Output:</p>
<pre><code>['&lt;p&gt;', '&lt;a href="book"&gt;', '&lt;/a  &gt;', '&lt;/p attr="e"&gt;']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While the answer from @Ajax1234 contains some nice python + beautifulsoup, I found it to be very unstable. Mostly because I need the exact string of the html tag. <strong>Each tag found by the method must be present in the html text.</strong> This leads to the following problems:</p>
<ul>
<li><p>It parses the tag names and attributes from HTML and plugs them
together to form the string of the tag <code>yield f'&lt;{_d.name}&gt;' if not _attrs else f'&lt;{_d.name} {_attrs}&gt;'</code>. This gets rid of extra whitespace in the tag: <code>&lt;p &gt;</code> becomes <code>&lt;p&gt;</code></p></li>
<li><p>It always generates a closing tag, even if there is none in the markup</p></li>
<li><p>It fails for attributes that are lists: <code>&lt;p class="a b"&gt;</code> becomes <code>&lt;p class="[a, b]"&gt;</code></p></li>
</ul>
<p>The whitespace problem can be partially solved by cleaning the HTML prior to processing it. I used <a href="https://pypi.org/project/bleach/" rel="nofollow noreferrer">bleach</a>, but that can be too aggressive. Notably, you have to specify a list of accepted tags before you use it.</p>
<p>A better approach is a thin wrapper around <a href="https://docs.python.org/3/library/html.parser.html#module-html.parser" rel="nofollow noreferrer">html.parser.HTMLParser</a>.
This is something I already started in my question, the difference here is that I automatically add generate a closing tag.</p>
<pre><code>from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
    def __init__(self):
        super().__init__()
        self.tags = []

    def handle_starttag(self, tag, attrs):
        self.tags.append(self.get_starttag_text())

    def handle_endtag(self, tag):
        self.tags.append(f"&lt;/{tag}&gt;")

parser = MyHTMLParser();
parser.feed("""&lt;p &gt; Argh, whitespace and p is not closed &lt;/a&gt;""")
parser.tags # ['&lt;p &gt;', '&lt;/a&gt;']
</code></pre>
<p>This solved the problems mentioned above, but it has one shortcoming, it doesn't look at the actual text for the closing tag. If there are extra arguments or whitespace in the closing tag, the parsing will not show them.</p>
</div>
<span class="comment-copy">What Python version are you using?</span>
<span class="comment-copy">@DanielMesejo version 3.6</span>
<span class="comment-copy">oh lala, fancy :D unfortunately, I need the exact text of the tag. For example "&lt;/p  &gt;" should keep the two spaces.</span>
<span class="comment-copy">@lhk What is the source and purpose of the HTML data? I am not sure this can easily be accomplished in <code>bs4</code>. You may need to utilize Regex instead.</span>
<span class="comment-copy">I would like to get the text contained in the HTML, run it through a language processing pipeline, change parts of it, and insert the changed text back in the HTML markup. To do that, I need to remove the HTML tags and insert them back in.  If I know the exact text of the tags, I can replace all of them with something like "THISISHTML", then tokenize it with spacy, remove the "THISISHTML" tokens but keep their indices. After processing, at each index, I add the html tag back in. But that means identifying the tags properly. I have a regex solution, but it has problems &lt; with text like &gt; this</span>
<span class="comment-copy">So instead of a regex, I would like to get the html tags from a robust html parser. Surprisingly, I haven't found a framework which does this easily. Beautifulsoup just gives you all the tag with its content, bleach can remove the tags but doesn't tell you what it has removed, html.parser has this weird missing get_end_tag method, ...</span>
<span class="comment-copy">I thought I had found a nice way: Cleaning the html with bleach and then using your code. But bleach seems very inconsistent.</span>
