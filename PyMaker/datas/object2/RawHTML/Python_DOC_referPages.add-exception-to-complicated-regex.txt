<div class="post-text" itemprop="text">
<p>There is a very complex regular expression.</p>
<p>But I have a problem with it. The <code>#</code> and <code>++</code> characters are removed if there are letters after them.</p>
<p><strong>Question</strong>: How to add an exception to current regex for (C++ and C# tokens)?</p>
<p>I've used the next regex:</p>
<pre><code>import re

text = 'Must-have skills: -.Net programming experience; -2 years experience in C++; C#/.Net, C++/.Net, C./.Net.'
text = re.sub(r'[!,.:;—](?= |$)', ' ', text)
print(re.sub(r'(?i)(?:(?!\.net\b|\b-\b)[^\w\s])+(?=[^\w\s]*\b)', ' ', text))
</code></pre>
<p>And I've had the next result:</p>
<pre><code>'Must-have skills   .Net programming experience   2 years experience in C++  C .Net  C .Net  C .Net '
</code></pre>
<p><strong>Desired result:</strong></p>
<pre><code>'Must-have skills   .Net programming experience   2 years experience in C++  C# .Net  C++ .Net  C .Net '
</code></pre>
<p><strong>Current regex details</strong></p>
<ul>
<li><code>(?i)</code> - case insensitive mode on</li>
<li><code>(?:(?!\.net\b|\b-\b)[^\w\s])+</code> - any punctuation char (<code>[^\w\s]</code>), 1 or more occurrences, as many as possible, that does not start any of the sequences:

<ul>
<li><code>\.net\b</code> - <code>.net</code> as whole word</li>
<li><code>|</code> - or </li>
<li><code>\b-\b</code> - a hyphen enclosed with word chars</li>
</ul></li>
<li><code>(?=[^\w\s]*\b)</code> - a positive lookahead that requires 0+ punctuation chars followed with a word boundary position immediately to the right of the current location.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit</strong></p>
<p><strong>#1</strong></p>
<p><strong>Same as below but much shorter, I'm defining the characters that must precede the captured ones all in one set</strong></p>
<pre><code>&gt;&gt;&gt; import re

&gt;&gt;&gt; text = 'Must-have skills: -.Net programming experience; -2 years experience in C++; C#/.Net, C++/.Net, C./.Net.'

&gt;&gt;&gt; re.sub('(?:(?&lt;!\S)|(?&lt;=[\s\+\.C#]))[\-!,.:;—/]|[\-!,.:;—/](?=\s|$)', ' ', text)


#Output
'Must-have skills   .Net programming experience   2 years experience in C++  C# .Net  C++ .Net  C  .Net '
</code></pre>
<p>.</p>
<p><strong>Explanation</strong></p>
<ul>
<li>The answer here is effectively the same as the one that follows below but instead of declaring the characters that must precede the captured set that will be acted upon one by one, this I defines them all in one set.</li>
</ul>
<p>.</p>
<p><strong>#2</strong></p>
<p><strong>Kind of a really dirty solution but</strong></p>
<p><strong>Will post an explanation later; might even refine it for better readability</strong></p>
<pre><code>&gt;&gt;&gt; import re

&gt;&gt;&gt; text = 'Must-have skills: -.Net programming experience; -2 years experience in C++; C#/.Net, C++/.Net, C./.Net.'

&gt;&gt;&gt; re.sub('(?:(?&lt;!\S)|(?&lt;=\s)|(?&lt;=\+)|(?&lt;=\.)|(?&lt;=C)|(?&lt;=#))[\-!,.:;—/]|[\-!,.:;—/](?=\s|$)', ' ', text)


#Output
'Must-have skills   .Net programming experience   2 years experience in C++  C# .Net  C++ .Net  C  .Net '
</code></pre>
<p>.</p>
<p><strong>Edit: Explanation</strong></p>
<ul>
<li>So by opening with <code>(?:</code> I am opening by saying the query that I want to capture should in this case be preceded by the capture set which contains whatever is defined immediately behind <code>(?:</code>.</li>
<li>The key here is that the lookaheads which start with <code>(?&lt;!</code> and <code>(?&lt;=</code> cannot be set to ignore a range of values so I have to first start with <code>(?:</code> and then give multiple <code>(?&lt;!</code>'s and <code>(?&lt;=</code>'s to say what's captured <em>should or should NOT be preceded by this character, and NOT be preceded by this other character, and so on and so forth</em></li>
<li>So having opened with <code>(?:</code> I am now able to set the values that what is captured should be or should not be preceded by </li>
<li>Starting with <code>(?&lt;!\S)</code> it really is unneeded but I included it because it casts a safety net. It basically says the range <code>[\-!,.:;—/]</code> <em>should NOT be captured/acted on if it is preceded by any random non-whitespace character</em></li>
<li>With <code>|(?&lt;=\s)</code> I am saying *OR <code>[\-!,.:;—/]</code> should be captured/acted on if it is preceded by any single whitespace character</li>
<li>With <code>|(?&lt;=\+)|(?&lt;=\.)|(?&lt;=C)</code> I'm saying <em>OR <code>[\-!,.:;—/]</code> should be captured/acted on if it is preceded by +, ., or C,</em> so the <code>\. OR just . [a period]</code> in <code>[\-!,.:;—/]</code> will be capture/acted upon if it is preceded by <code>C</code> like in your string (remember <code>(?&lt;=C)</code>); and <code>;</code> in <code>[\-!,.:;—/]</code> will be captured/acted upon if it is preceded by <code>+</code> (remember <code>(?&lt;=\+)</code>). </li>
<li>The final <code>)</code> before the <code>|</code> closes the <code>(?:</code>.</li>
<li><code>|</code> as you know is OR, and because I can't make the statement an all in one, I have to redefine <code>[\-!,.:;—/]</code> then make a lookahead to say, <em>Capture/act on <code>[\-!,.:;—/]</code> if it is followed by whitespace or the end of the string.</em> With lookaheads, you're  able to define regular single string type 'ranges' so you can actually use <code>OR statements</code> within them but you cannot when you use lookaheads</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>It's not quite the same as your output but I was able to do this with only a difference of white space by reversing the order of the two <code>re.sub</code>s and adding a negative lookbehind.</p>
<pre><code>text = 'Must-have skills: -.Net programming experience; -2 years experience in C++; C#/.Net, C++/.Net, C./.Net.'
text = re.sub(r'(?i)(?:(?!\.net\b|\b-\b)(?&lt;!C)(?&lt;!C\+)[^\w\s])+(?=[^\w\s]*\b)', ' ', text)
text = re.sub('[!,.:;—](?= |$)', ' ', text)
</code></pre>
<p>Output:</p>
<pre><code>print(text)
Must-have skills   .Net programming experience   2 years experience in C++  C# .Net  C++ .Net  C  .Net 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a single replacement by capturing in a group what you want to keep and remove what you don't want using an <a href="https://www.regular-expressions.info/alternation.html" rel="nofollow noreferrer">alternation</a>.</p>
<p>That way you can extend the pattern with cases that you want to keep or want to remove. In the replacement you use the capturing group. Instead of using an inline modifier <code>(?i)</code> you could also use <code>re.IGNORECASE</code> in the code.</p>
<pre><code>(c(?:\+{2}|#)|\.net\b)|[!,.:;/—]|-(?=[\d.])
</code></pre>
<p>That will match:</p>
<ul>
<li><code>(</code> Capture group

<ul>
<li><code>c(?:\+{2}|#)|\.net\b</code> Match c++ or c# or .net</li>
</ul></li>
<li><code>)</code> Close capture group</li>
<li><code>|</code> Or</li>
<li><code>[!,.:;/—]</code> Match any listed in the character class</li>
<li><code>|</code> Or</li>
<li><code>-(?=[\d.])</code> Match a hyphen asserting what is directly on the right is a digit or a dot</li>
</ul>
<p><a href="https://regex101.com/r/P12tuu/1" rel="nofollow noreferrer">Regex demo</a> | <a href="https://ideone.com/yKMKGu" rel="nofollow noreferrer">Python demo</a></p>
<p>For example</p>
<pre><code>import re
regex = r"(c(?:\+{2}|#)|\.net\b)|[!,.:;/—]|-(?=[\d.])"
text = 'Must-have skills: -.Net programming experience; -2 years experience in C++; C#/.Net, C++/.Net, C./.Net.'
text = re.sub(regex, r"\1 ", text, 0, re.IGNORECASE)

if text:
    print (text)

# Must-have skills   .Net  programming experience   2 years experience in C++   C#  .Net   C++  .Net   C  .Net 
</code></pre>
</div>
<span class="comment-copy">I'm impressed you were able to get it all on same line and we posted within a minute of each other. The output is similar to mine where there are two spaces between 'C  .Net' at the end of the line.</span>
<span class="comment-copy">I think your solution might ultimately be better. It's more true to form and looks to be more scalable. I actually didn't see that extra space in mine so I'll see if I can come up with an update. Haha. Both for different scenarios I guess.</span>
<span class="comment-copy">@CT Hal, thank you for your answer. It's really impressive. Also, I should have said that the number of spaces does not matter. The main thing to deal with punctuation marks.</span>
<span class="comment-copy">@lemon, do you want me to post an explanation (which will be painful, but I will on request), or is it readable enough that it doesn't need one?</span>
<span class="comment-copy">@FailSafe, That'll be great!</span>
