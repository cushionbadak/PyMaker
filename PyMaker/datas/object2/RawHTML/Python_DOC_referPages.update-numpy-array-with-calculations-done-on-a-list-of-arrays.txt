<div class="post-text" itemprop="text">
<p>I have a list of length 50 filled with arrays of length 5. I am trying to calculate the distance between each array in the list and update a numpy array with the values.</p>
<p>The distance calculation is just taking the square root of the sum of the squared distance between each element in the arrays.</p>
<p>When I try:</p>
<pre><code>primaryCustomer = np.zeros(shape = (50,50))

for customer in range(0,50):
  for pair in range(0,50):
    thisCustomer = [0 for i in range(51)]
    if customer == pair:
      thisCustomer[pair] = 999
    else:

      calculateScores = (((Customer[customer][0]-Customer[pair][0])**2 
                            + (Customer[customer][1]-Customer[pair][1])**2 
                            + (Customer[customer][2]-Customer[pair][2])**2 
                            + (Customer[customer][3]-Customer[pair][3])**2 
                            + (Customer[customer][4]-Customer[pair][4])**2 )**(0.5))
      thisCustomer[pair] = calculateScores
  np.append(primaryCustomer, thisCustomer)
</code></pre>
<p>a couple of things happen:</p>
<ul>
<li>The final iteration of thisCustomer returns a list of all zeros, except the final element of 999 (corresponding to the 'if' portion of the statement above). So, I know it <em>can</em> update the list, but it doesn't do it in the 'else' portion. </li>
<li>I want the 'primaryCustomer' array to update with the Customer as the index and all of the calculated scores with each pair as the row values, but it doesn't seem to update at all</li>
</ul>
<p>Any changes I make, like trying to treat thisCustomer in the loop as an array instead of a list and append to it, end up fixing one area but screwing up other ones even worse.</p>
<p>Here's how I'm getting the Customer data:</p>
<pre><code>Customer = [[0,0,0,0,0] for i in range(51)]

for n in range(51):
  Customer[n] = np.ones(5)
  Customer[n][randint(2,4):5] = 0
  np.random.shuffle(Customer[n])
</code></pre>
<p>I know there might be packaged ways to do this, but I'm trying to understand how things like KNN work in the background, so I'd like to keep to figuring out the logic in loops like above. Beyond that, any help would be greatly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>I <em>think</em> this is what you are going for, but correct me if I'm wrong:</p>
<pre><code>import numpy as np
from random import randint

Customer = [[0, 0, 0, 0, 0] for i in range(51)]

for n in range(51):
    Customer[n] = np.ones(5)
    Customer[n][randint(2, 4):5] = 0
    np.random.shuffle(Customer[n])

primaryCustomer = np.zeros(shape=(50, 50))

for customer in range(0, 50):
    thisCustomer = [0 for i in range(51)]
    for pair in range(0, 50):
        if customer == pair:
            primaryCustomer[customer][pair] = 999
        else:
            calculateScores = (((Customer[customer][0] - Customer[pair][0]) ** 2
                                  + (Customer[customer][1] - Customer[pair][1]) ** 2
                                  + (Customer[customer][2] - Customer[pair][2]) ** 2
                                  + (Customer[customer][3] - Customer[pair][3]) ** 2
                                  + (Customer[customer][4] - Customer[pair][4]) ** 2) ** 0.5)
            primaryCustomer[customer][pair] = calculateScores

print(primaryCustomer)
</code></pre>
<p>I think the main issue I found with your loops was the location of <code>thisCustomer = [0 for i in range(51)]</code>, I think you meant to have it up one more level like in mine. I don't see any need for this line though and altered <code>thisCustomer[pair]</code> to directly write to <code>primaryCustomer[customer][pair]</code> instead, thereby negating the need for <code>thisCustomer = [0 for i in range(51)]</code> every loop, which would speed up your program and improve memory usage by taking the line out entirely.</p>
<p>Sample output:</p>
<blockquote>
<p>[[999.           2.23606798   1.         ...   2.           0.
      1.73205081]
   [  2.23606798 999.           2.         ...   1.           2.23606798
      1.41421356]
   [  1.           2.         999.         ...   1.73205081   1.
      2.        ]
   ...
   [  2.           1.           1.73205081 ... 999.           2.
      1.73205081]
   [  0.           2.23606798   1.         ...   2.         999.
      1.73205081]
   [  1.73205081   1.41421356   2.         ...   1.73205081   1.73205081
    999.        ]]</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>A couple things to notice at first.</p>
<ul>
<li><code>primaryCustomer[a][b] = primaryCustomer[b][a]</code> because you are using a distance metric. This means that the ranges on your two for loops can be reset:</li>
</ul>
<pre><code>    numCustomers = 51
    primaryCustomer = np.zeros(shape = (numCustomers, numCustomers))
    for customerA in range(numCustomers-1):
        for customerB in range(customerA+1, numCustomers):
            primaryCustomer[customerA][customerB] = dist(customerA,customerB)
    primaryCustomer += np.transpose(primaryCustomer)
</code></pre>
<p>Note* you can change the second for loop's range to also start from 0 to keep your original loop structure, but then you will need to remove the transposition line. You can also have 
<code>primaryCustomer[a][b] = primaryCustomer[b][a] = dist(a,b)</code> if you'd rather not use the transposition but still avoid unnecessary calculations.</p>
<ul>
<li><code>primaryCustomer = np.zeros(shape = (50,50))</code> I'm assuming is meant to store the distance between two customers. However, it looks like you have 51 customers, not 50? </li>
<li>You should think about calculating the distances in a more general way. i.e. how could you make the distance calculation work independent of the list size?</li>
<li>Why are you creating an initial 2D array of 0s to store the distance, and then appending to it? The creation of the <code>thisCustomer</code> list doesn't seem necessary and in fact the solution posted by Reedinationer initializes it but never even uses it. Also, as someone stated alreadyd, that's not how <code>np.append</code> works. You're best off modifying the distance matrix you create originally directly.</li>
<li>Why is <code>primaryCustomer[a][a] = 999</code>?  Shouldn't the distance between a list and itself be 0? If you really do want to have it be 999, I encourage you to figure out how to modify the code block above to account for that.</li>
</ul>
</div>
<span class="comment-copy">That's not how you use <code>np.append</code>.  Read the docs, and then stay away from this poorly named function.  You have already allocated the space for those values in the array.  Assign them with normal array indexing.  You show that you already know how to assign values to a list element.</span>
<span class="comment-copy">@datahappy: If I understand your post correct, you <b>do not want</b> an efficient (numpy-ish) solution. You just want to stick to your loops and just fix them to make them work. Is this understanding correct?</span>
<span class="comment-copy">@fountainhead I think so. That's the way I'm reading it at least</span>
<span class="comment-copy"><code>primaryCustomer[customer, pair] = calculateScores</code> is more idiomatic.</span>
<span class="comment-copy">@hpaulj Thanks for that! I'll leave it to the OP what implementation he/she chooses to be more readable. I usually prefer double indexing like in my post because I can visualize one as row and one as column, but that's a neat trick to know.</span>
<span class="comment-copy">The double indexing works fine when using scalar indices.  The first index selects a row, the second selects an element from that row.  But it doesn't work if you use slices or lists, which would return multiple rows.</span>
<span class="comment-copy">@hpaulj So you are saying you can do slice notation with your method? Something like <code>primaryCustomer[[0:customer], [0:pair]] = someArray</code> and you cannot rewrite this to <code>primaryCustomer[0:customer][0:pair] = someArray</code>?</span>
<span class="comment-copy">Thank you. This was very helpful</span>
