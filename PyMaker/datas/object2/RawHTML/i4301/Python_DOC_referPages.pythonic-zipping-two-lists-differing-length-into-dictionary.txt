<div class="post-text" itemprop="text">
<p>I have two lists of strings with different lengths: </p>
<pre><code>k = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
v = ['z', 'y', 'x', 'w',]
dict = {}
</code></pre>
<p>I want to have the following output:</p>
<pre><code>{'a': ['z', 'y', 'x', 'w',], 'b': ['z', 'y', 'x', 'w',], 'c': ['z', 'y', 'x', 'w',], 'd': ['z', 'y', 'x', 'w',], 'e': ['z', 'y', 'x', 'w',], 'f': ['z', 'y', 'x', 'w',], 'g': ['z', 'y', 'x', 'w',]}    
</code></pre>
<p>The closest I have gotten is this: </p>
<pre><code>{key: [key, value] for key, value in zip(k, v)}
</code></pre>
<p>and</p>
<pre><code>(kvalue,vvalue) for kkey, kvalue in enumerate(k) for vkey, vvalue in enumerate(v)
</code></pre>
<p>The ultimate goal with this is to use the key, value pairs to insert the contained strings into a string in a separate for loop. I'm using Python 3.6.</p>
<p>Pseudocode:</p>
<pre><code>for filenames in directory:
    var = 'some string' + each key/value pairing
    print(var)

&gt;&gt;&gt; some string a z
&gt;&gt;&gt; some string a y
&gt;&gt;&gt; some string a x
&gt;&gt;&gt; some string a w
&gt;&gt;&gt; some string b z
&gt;&gt;&gt; some string b y
&gt;&gt;&gt; some string b x
&gt;&gt;&gt; some string b w
&gt;&gt;&gt; some string c z
&gt;&gt;&gt; some string c y
&gt;&gt;&gt; some string c x
&gt;&gt;&gt; some string c w
&gt;&gt;&gt; some string d z
&gt;&gt;&gt; some string d y
&gt;&gt;&gt; some string d x
&gt;&gt;&gt; some string d w
&gt;&gt;&gt; some string e z
&gt;&gt;&gt; some string e y
&gt;&gt;&gt; some string e x
&gt;&gt;&gt; some string e w
&gt;&gt;&gt; some string f z
&gt;&gt;&gt; some string f y
&gt;&gt;&gt; some string f x
&gt;&gt;&gt; some string f w
&gt;&gt;&gt; some string g z
&gt;&gt;&gt; some string g y
&gt;&gt;&gt; some string g x
&gt;&gt;&gt; some string g w
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the first part of your question, use <a href="https://docs.python.org/3/library/stdtypes.html#dict.fromkeys" rel="nofollow noreferrer">dict.fromkeys()</a> :</p>
<pre><code>k = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
v = ['z', 'y', 'x', 'w',]
d = dict.fromkeys(k, v)
</code></pre>
<p>output: </p>
<pre><code>{'a': ['z', 'y', 'x', 'w'],
 'b': ['z', 'y', 'x', 'w'],
 'c': ['z', 'y', 'x', 'w'],
 'd': ['z', 'y', 'x', 'w'],
 'e': ['z', 'y', 'x', 'w'],
 'f': ['z', 'y', 'x', 'w'],
 'g': ['z', 'y', 'x', 'w']}
</code></pre>
<p>For the second part, you actually don't need the first, use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">itertools.product</a>:</p>
<pre><code>from itertools import product

k = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
v = ['z', 'y', 'x', 'w',]

out = ['some string {} {}'.format(key, val) for key, val in product(k, v)]
</code></pre>
<p>output:</p>
<pre><code>['some string a z',
 'some string a y',
 'some string a x',
 'some string a w',
 'some string b z',
 'some string b y',
 'some string b x',
 'some string b w',
 'some string c z',
 'some string c y',
 'some string c x',
 'some string c w',
 'some string d z',
 'some string d y',
 'some string d x',
 'some string d w',
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a dictionary-comprehension:</p>
<pre><code>result = {x: v for x in k}
print(result)
{'a': ['z', 'y', 'x', 'w'], 'b': ['z', 'y', 'x', 'w'], 'c': ['z', 'y', 'x', 'w'], 'd': ['z', 'y', 'x', 'w'], 'e': ['z', 'y', 'x', 'w'], 'f': ['z', 'y', 'x', 'w'], 'g': ['z', 'y', 'x', 'w']}
</code></pre>
<p>This creates a dictionary with keys <code>x</code> from <code>k</code> and values <code>v</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A dictionary comprehension would do:</p>
<pre><code>k = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
v = ['z', 'y', 'x', 'w',]
print({key: v for key in k})

# {'a': ['z', 'y', 'x', 'w',], 'b': ['z', 'y', 'x', 'w',], 'c': ['z', 'y', 'x', 'w',], 'd': ['z', 'y', 'x', 'w',], 'e': ['z', 'y', 'x', 'w',], 'f': ['z', 'y', 'x', 'w',], 'g': ['z', 'y', 'x', 'w',]} 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're using the wrong method altogether: <code>zip</code> is for corresponding pairs only, giving you <code>(a z) (b y) (c x)</code> and so on, without providing the other pairings.</p>
<p>Is there some reason you need to generate this more than once?  If not, this is a job for <code>itertools.product</code>, not <code>zip</code>.</p>
<pre><code>from itertools import product

k = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
v = ['z', 'y', 'x', 'w',]

for pair in product(k, v):
    print("some string " + ' '.join(pair))
</code></pre>
<p>Output:</p>
<pre><code>some string a z
some string a y
some string a x
some string a w
some string b z
some string b y
some string b x
some string b w
...
some string g x
some string g w
</code></pre>
</div>
<span class="comment-copy">Please never call your variables the names of standard objects, like <code>dict</code> or <code>list</code>. You will shadow them, and this may lead to mind-boggling bugs were obviously correct code does not work.</span>
<span class="comment-copy">Please note that each key shares the same list as a value, so <i>updating</i> <code>result['a']</code> will update the value for every other key. One could do <code>{x: v[:] ...}</code> to make defensive copies.</span>
<span class="comment-copy">Thanks for that (and the edit). I didn't know that copying is as easy as using <code>v[:]</code>.</span>
<span class="comment-copy">Frankly, <code>[:]</code>, which is a list slice with all parameters set to default, is a shallow copy; for more difficult cases, module <code>copy</code> exists with <code>deepcopy</code> function. (Treating structures as immutable is generally even better.)</span>
