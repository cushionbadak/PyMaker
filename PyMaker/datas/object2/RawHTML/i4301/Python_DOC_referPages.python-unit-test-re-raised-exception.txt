<div class="post-text" itemprop="text">
<p>How does one write a unittest that fails only if a function doesn't throw an expected exception?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/library/unittest.html#unittest.TestCase.assertRaises" rel="noreferrer"><code>TestCase.assertRaises</code></a> (or <code>TestCase.failUnlessRaises</code>) from the unittest module, for example:</p>
<pre><code>import mymod

class MyTestCase(unittest.TestCase):
    def test1(self):
        self.assertRaises(SomeCoolException, mymod.myfunc)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 2.7 you can use context manager to get ahold of the actual Exception object thrown:</p>
<pre><code>import unittest

def broken_function():
    raise Exception('This is broken')

class MyTestCase(unittest.TestCase):
    def test(self):
        with self.assertRaises(Exception) as context:
            broken_function()

        self.assertTrue('This is broken' in context.exception)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p><a href="http://docs.python.org/dev/library/unittest.html#unittest.TestCase.assertRaises" rel="noreferrer">http://docs.python.org/dev/library/unittest.html#unittest.TestCase.assertRaises</a></p>
<hr/>
<p>In <strong>Python 3.5</strong>, you have to wrap <code>context.exception</code> in <code>str</code>, otherwise you'll get a <code>TypeError</code></p>
<pre><code>self.assertTrue('This is broken' in str(context.exception))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code in my previous answer can be simplified to:</p>
<pre><code>def test_afunction_throws_exception(self):
    self.assertRaises(ExpectedException, afunction)
</code></pre>
<p>And if afunction takes arguments, just pass them into assertRaises like this:</p>
<pre><code>def test_afunction_throws_exception(self):
    self.assertRaises(ExpectedException, afunction, arg1, arg2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>How do you test that a Python function throws an exception?</strong></p>
<p>How does one write a test that fails only if a function doesn't throw
  an expected exception?</p>
</blockquote>
<h1>Short Answer:</h1>
<p>Use the <code>self.assertRaises</code> method as a context manager:</p>
<pre><code>    def test_1_cannot_add_int_and_str(self):
        with self.assertRaises(TypeError):
            1 + '1'
</code></pre>
<h1>Demonstration</h1>
<p>The best practice approach is fairly easy to demonstrate in a Python shell. </p>
<p><strong>The <code>unittest</code> library</strong></p>
<p>In Python 2.7 or 3:</p>
<pre><code>import unittest
</code></pre>
<p>In Python 2.6, you can install a backport of 2.7's <code>unittest</code> library, called <a href="https://pypi.python.org/pypi/unittest2" rel="noreferrer">unittest2</a>, and just alias that as <code>unittest</code>:</p>
<pre><code>import unittest2 as unittest
</code></pre>
<h1>Example tests</h1>
<p>Now, paste into your Python shell the following test of Python's type-safety:</p>
<pre><code>class MyTestCase(unittest.TestCase):
    def test_1_cannot_add_int_and_str(self):
        with self.assertRaises(TypeError):
            1 + '1'
    def test_2_cannot_add_int_and_str(self):
        import operator
        self.assertRaises(TypeError, operator.add, 1, '1')
</code></pre>
<p>Test one uses <code>assertRaises</code> as a context manager, which ensures that the error is properly caught and cleaned up, while recorded. </p>
<p>We could also write it <em>without</em> the context manager, see test two. The first argument would be the error type you expect to raise, the second argument, the function you are testing, and the remaining args and keyword args will be passed to that function. </p>
<p>I think it's far more simple, readable, and maintainable to just to use the context manager.</p>
<h1>Running the tests</h1>
<p>To run the tests:</p>
<pre><code>unittest.main(exit=False)
</code></pre>
<p>In Python 2.6, you'll probably <a href="https://stackoverflow.com/a/21262077/541136">need the following</a>:</p>
<pre><code>unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(MyTestCase))
</code></pre>
<p>And your terminal should output the following:</p>
<pre><code>..
----------------------------------------------------------------------
Ran 2 tests in 0.007s

OK
&lt;unittest2.runner.TextTestResult run=2 errors=0 failures=0&gt;
</code></pre>
<p>And we see that as we expect, attempting to add a <code>1</code> and a <code>'1'</code> result in a <code>TypeError</code>.</p>
<hr/>
<p>For more verbose output, try this:</p>
<pre><code>unittest.TextTestRunner(verbosity=2).run(unittest.TestLoader().loadTestsFromTestCase(MyTestCase))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code should follow this pattern (this is a unittest module style test):</p>
<pre><code>def test_afunction_throws_exception(self):
    try:
        afunction()
    except ExpectedException:
        pass
    except Exception as e:
       self.fail('Unexpected exception raised:', e)
    else:
       self.fail('ExpectedException not raised')
</code></pre>
<p>On Python &lt; 2.7 this construct is useful for checking for specific values in the expected exception. The unittest function <code>assertRaises</code> only checks if an exception was raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>from: <a href="http://www.lengrand.fr/2011/12/pythonunittest-assertraises-raises-error/" rel="noreferrer">http://www.lengrand.fr/2011/12/pythonunittest-assertraises-raises-error/</a></p>
<p>First, here is the corresponding (still dum :p) function in file dum_function.py :</p>
<pre><code>def square_value(a):
   """
   Returns the square value of a.
   """
   try:
       out = a*a
   except TypeError:
       raise TypeError("Input should be a string:")

   return out
</code></pre>
<p>Here is the test to be performed (only this test is inserted):</p>
<pre><code>import dum_function as df # import function module
import unittest
class Test(unittest.TestCase):
   """
      The class inherits from unittest
      """
   def setUp(self):
       """
       This method is called before each test
       """
       self.false_int = "A"

   def tearDown(self):
       """
       This method is called after each test
       """
       pass
      #---
         ## TESTS
   def test_square_value(self):
       # assertRaises(excClass, callableObj) prototype
       self.assertRaises(TypeError, df.square_value(self.false_int))

   if __name__ == "__main__":
       unittest.main()
</code></pre>
<p>We are now ready to test our function! Here is what happens when trying to run the test :</p>
<pre><code>======================================================================
ERROR: test_square_value (__main__.Test)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_dum_function.py", line 22, in test_square_value
    self.assertRaises(TypeError, df.square_value(self.false_int))
  File "/home/jlengrand/Desktop/function.py", line 8, in square_value
    raise TypeError("Input should be a string:")
TypeError: Input should be a string:

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
</code></pre>
<p>The TypeError is actullay raised, and generates a test failure. The problem is that this is exactly the behavior we wanted :s.</p>
<p>To avoid this error, simply run the function using lambda in the test call :</p>
<pre><code>self.assertRaises(TypeError, lambda: df.square_value(self.false_int))
</code></pre>
<p>The final output :</p>
<pre><code>----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>Perfect !</p>
<p>... and for me is perfect too!!</p>
<p>Thansk a lot Mr. Julien Lengrand-Lambert</p>
</div>
<div class="post-text" itemprop="text">
<p>I use <strong>doctest</strong>[1] almost everywhere because I like the fact that I document and test my functions at the same time.</p>
<p>Have a look at this code:</p>
<pre><code>def throw_up(something, gowrong=False):
    """
    &gt;&gt;&gt; throw_up('Fish n Chips')
    Traceback (most recent call last):
    ...
    Exception: Fish n Chips

    &gt;&gt;&gt; throw_up('Fish n Chips', gowrong=True)
    'I feel fine!'
    """
    if gowrong:
        return "I feel fine!"
    raise Exception(something)

if __name__ == '__main__':
    import doctest
    doctest.testmod()
</code></pre>
<p>If you put this example in a module and run it from the command line both test cases are evaluated and checked.</p>
<p>[1] <a href="http://docs.python.org/lib/module-doctest.html" rel="noreferrer">Python documentation: 23.2 doctest -- Test interactive Python examples</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can build your own <code>contextmanager</code> to check if the exception was raised.</p>
<pre><code>import contextlib

@contextlib.contextmanager
def raises(exception):
    try:
        yield 
    except exception as e:
        assert True
    else:
        assert False
</code></pre>
<p>And then you can use <code>raises</code> like this:</p>
<pre><code>with raises(Exception):
    print "Hola"  # Calls assert False

with raises(Exception):
    raise Exception  # Calls assert True
</code></pre>
<p>If you are using <code>pytest</code>, this thing is implemented already. You can do <code>pytest.raises(Exception)</code>:</p>
<p>Example:</p>
<pre><code>def test_div_zero():
    with pytest.raises(ZeroDivisionError):
        1/0
</code></pre>
<p>And the result:</p>
<pre><code>pigueiras@pigueiras$ py.test
================= test session starts =================
platform linux2 -- Python 2.6.6 -- py-1.4.20 -- pytest-2.5.2 -- /usr/bin/python
collected 1 items 

tests/test_div_zero.py:6: test_div_zero PASSED
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at the <a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertRaises" rel="noreferrer">assertRaises</a> method of the <code>unittest</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>I just discovered that the <a href="http://www.voidspace.org.uk/python/mock.html" rel="noreferrer">Mock library</a> provides an assertRaisesWithMessage() method (in its unittest.TestCase subclass), which will check not only that the expected exception is raised, but also that it is raised with the expected message:</p>
<pre><code>from testcase import TestCase

import mymod

class MyTestCase(TestCase):
    def test1(self):
        self.assertRaisesWithMessage(SomeCoolException,
                                     'expected message',
                                     mymod.myfunc)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use assertRaises from the unittest module</p>
<pre><code>import unittest

class TestClass():
  def raises_exception(self):
    raise Exception("test")

class MyTestCase(unittest.TestCase):
  def test_if_method_raises_correct_exception(self):
    test_class = TestClass()
    # note that you dont use () when passing the method to assertRaises
    self.assertRaises(Exception, test_class.raises_exception)
</code></pre>
</div>
<span class="comment-copy">is there a way to do the opposite of this? Like it fails only if the function does throw the exception?</span>
<span class="comment-copy">@BUInvent, yes, there is: <a href="https://stackoverflow.com/a/4319870/3405140">stackoverflow.com/a/4319870/3405140</a></span>
<span class="comment-copy">Note that to pass arguments to <code>myfunc</code> you need to add them as arguments to the assertRaises call. See Daryl Spitzer's answer.</span>
<span class="comment-copy">is there a way to allow for multiple exception types?</span>
<span class="comment-copy">You can use Python's Built-in Exceptions to quickly test the assertion; using @Moe's answer above for example: <code>self.assertRaises(TypeError, mymod.myfunc)</code>. You can find a full list of the Built-in Exceptions here: <a href="https://docs.python.org/3/library/exceptions.html#bltin-exceptions" rel="nofollow noreferrer">docs.python.org/3/library/exceptions.html#bltin-exceptions</a></span>
<span class="comment-copy">I'm using Python 2.7.10, and the above doesn't work; <code>context.exception</code> does not give the message; it is a type.</span>
<span class="comment-copy">Also in Python 2.7 (at least in my 2.7.6) using <code>import unittest2</code>, you need to use <code>str()</code>, i.e. <code>self.assertTrue('This is broken' in str(context.exception))</code>.</span>
<span class="comment-copy">Two things:  1. You can use assertIn instead of assertTrue.  E.g. self.assertIn('This is broken', context.exception)  2. In my case, using 2.7.10, context.exception appears to be an array of characters.  Using str doesn't work.  I ended up doing this: ''.join(context.exception)  So, put together: self.assertIn('This is broken', ''.join(context.exception))</span>
<span class="comment-copy">Is it normal that your method clogs up the test console with the exception's Traceback? How do I prevent that from happening?</span>
<span class="comment-copy">later I found another way to get the message as str of the exception, it is err = context.exception.message. And then can use also use self.assertEqual(err, 'This is broken') to do the test.</span>
<span class="comment-copy">The second snipped about what to do when argument is passed was really helpful.</span>
<span class="comment-copy">I'm using <code>2.7.15</code>. If <code>afunction</code> in <code>self.assertRaises(ExpectedException, afunction, arg1, arg2)</code> is the class initializer, you need to pass <code>self</code> as the first argument e.g.,  <code>self.assertRaises(ExpectedException, Class, self, arg1, arg2)</code></span>
<span class="comment-copy">and method self.fail takes only one argument</span>
<span class="comment-copy">This seems overly complicated for testing if a function throws an exception.  Since any exception other than that exception will error the test and not throwing an exception will fail the test, it seems like the only difference is that if you get a different exception with <code>assertRaises</code> you will get an ERROR instead of a FAIL.</span>
<span class="comment-copy">Just a note, you don't need the lambda. The line <code>self.assertRaises(TypeError, df.square_value(self.false_int))</code> calls the method and returns the result. What you want is to pass the method and any arguments and let the unittest to call it: <code>self.assertRaises(TypeError, df.square_value, self.false_int)</code></span>
<span class="comment-copy">I love doctest, but I find it supplements rather than replaces unittest.</span>
<span class="comment-copy">Is doctest less likely to play nice with automated refactoring?  I suppose a refactoring tool designed for python <i>should</i> be aware of docstrings.  Can anyone comment from their experience?</span>
<span class="comment-copy">Thanks for posting an answer that doesn't require the <code>unittest</code> module!</span>
<span class="comment-copy">Unfortunately, it doesn't provide it anymore.. But the above answer of @Art (<a href="http://stackoverflow.com/a/3166985/1504046">stackoverflow.com/a/3166985/1504046</a>) gives the same result</span>
