<div class="post-text" itemprop="text">
<p>I have a list of ~1,000,000 ip address strings. I want to get the set of these ip addresses that are in  three cidrs (each cidr is a string like this: "1.0.0.0/25"). What is the fastest way to do this?</p>
<p>A) Convert the three cidrs into sets containing all ip addresses contained in the cidrs. For each ip address in my list, I check if the ip address is in the wanted ip address set.</p>
<p>B) Convert each cidr into min &amp; max ip address. Convert each ip address into a tuple of ints and check if ip &gt; min and ip &lt; max.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're on Python 3.3 or higher, a decent solution is to use <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer">the <code>ipaddress</code> module</a>. Convert your CIDRs to network objects with <code>ipaddress.ip_network</code> up front, then convert your addresses to address objects (with <code>ipaddress.ip_address</code> if they might be IPv4 or IPv6, or just <code>ipaddress.IPv4Address</code>/<code>ipaddress.IPv6Address</code> directly if they are of known type (skips a layer of wrapping).</p>
<p>You can test for membership relatively cheaply with the <code>in</code> operator, e.g. if you stored your networks in a sequence (e.g. <code>list</code>/<code>tuple</code>) you could do:</p>
<pre><code>for address in map(ipaddress.ip_address, stream_of_string_addresses):
    if any(address in network for network in networks):
        ... got a match ...
</code></pre>
<p>There are more efficient solutions (particularly if you're talking about many networks, not just three), but this is straightforward, relatively memory efficient, and leaves you with a useful object (not just the raw address string) for further processing. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you have only 3 CIDRs, just write three ad-hoc functions like:</p>
<pre><code>def test_cidr1(ipstr):
    # example for 192.168.128.0/18 (i.e. netmask 255.255.192.0)
    if not ipstr.startswith('192.168.'):
        return False
    ip0, ip1, ip2, ip3 = ipstr.split('.')
    return int(ip2) &amp; 192 == 128
</code></pre>
</div>
<span class="comment-copy">Can you provide what you have done so far? Your code attempt?</span>
<span class="comment-copy">Try them both and compare.</span>
<span class="comment-copy">Short answer: Store them in a more efficient way. Just sorting them numerically will do -- then you can bisect the list to find the first and last entries within each span and spool between those pointers.</span>
<span class="comment-copy">Possible duplicate of (though no answers received upvotes) <a href="https://stackoverflow.com/q/44262437/364696">How to efficiently check if a given IP Address belong to an IP subnetwork in Python?</a></span>
<span class="comment-copy">This looks to me like it's O(n*m), where n=address count and m=network count. Am I reading wrong? That's pretty unfortunate, insofar as requiring sorted inputs could make this far, far cheaper.</span>
<span class="comment-copy">@CharlesDuffy: It's <code>O(n*m)</code>, where <code>n</code> is number of addresses and <code>m</code> is number of CIDRs. That said, <code>m</code> in this case is fixed at three, so it's not that critical to optimize further. If <code>m</code> was of arbitrarily large size, then yes, you'd want to look at other approaches.</span>
<span class="comment-copy">It's the <code>n</code>, not the <code>m</code>, that's large -- so I'd want to avoid the <code>O(n)</code> aspect. If we could bisect to find start and end points for each CIDR and stream between them, there we are -- the only linear cost is that of the actual output. Which is to say, like in most things programming-related, better to think about getting the data structures right rather than getting the code right. :)</span>
<span class="comment-copy">@CharlesDuffy: Yes, if you can force sorted inputs, then there are much faster ways to do this. For example, using the <code>bisect</code> module to bisect an array of <code>int</code> converted addresses with a lower bound of <code>int(network.network_address)</code> and an upper bound of <code>int(network.broadcast_address)</code> (which is what the <code>__contains__</code> check of ipaddress's network base class is checking) would get you down to <code>O(m * log n)</code> (converting to <code>int</code> would be <code>O(n)</code> in the first place though, since <code>bisect</code> doesn't allow <code>key</code> functions).</span>
