<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/480214/how-do-you-remove-duplicates-from-a-list-whilst-preserving-order">How do you remove duplicates from a list whilst preserving order?</a>
<span class="question-originals-answer-count">
                    24 answers
                </span>
</li>
</ul>
</div>
<p>I want to remove those tuples which had same values at index 0 except the first occurance. I looked at other similar questions but did not get a particular answer I am looking for. Can somebody please help me?
Below is what I tried.</p>
<pre><code>from itertools import groupby
import random
Newlist = []

abc = [(1,2,3), (2,3,4), (1,0,3),(0,2,0), (2,4,5),(5,4,3), (0,4,1)]

Newlist = [random.choice(tuple(g)) for _, g in groupby(abc, key=lambda x: x[0])]
print Newlist
</code></pre>
<p>my expected output : <code>[(1,2,3), (2,3,4), (0,2,0), (5,4,3)]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>A simple way is to loop over the list and keep track of which elements you've already found:</p>
<pre><code>abc = [(1,2,3), (2,3,4), (1,0,3),(0,2,0), (2,4,5),(5,4,3), (0,4,1)]
found = set()
NewList = []
for a in abc:
    if a[0] not in found:
        NewList.append(a)
    found.add(a[0])
print(NewList)
#[(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
</code></pre>
<p><code>found</code> is a <code>set</code>. At each iteration we check if the first element in the tuple is already in <code>found</code>. If not, we append the whole tuple to <code>NewList</code>. At the end of each iteration we add the first element of the tuple to <code>found</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a> (Python 2: <a href="https://docs.python.org/2.7/library/itertools.html#recipes" rel="nofollow noreferrer">itertools recipes</a>, but basically no difference in this case) contains a recipe for this, which is a bit more general than the <a href="https://stackoverflow.com/a/49880587/4042267">implementation</a> by <a href="https://stackoverflow.com/users/5858851/pault">@pault</a>. It also uses a <code>set</code>:</p>
<p>Python 2:</p>
<pre><code>from itertools import ifilterfalse as filterfalse
</code></pre>
<p>Python 3:</p>
<pre><code>from itertools import filterfalse
</code></pre>
<blockquote>
<pre><code>def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element
</code></pre>
</blockquote>
<p>Use it with:</p>
<pre><code>abc = [(1,2,3), (2,3,4), (1,0,3),(0,2,0), (2,4,5),(5,4,3), (0,4,1)]
Newlist = list(unique_everseen(abc, key=lambda x: x[0]))
print Newlist
# [(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
</code></pre>
<p>This should be slightly faster because of the caching of the <code>set.add</code> method (only really relevant if your <code>abc</code> is large) and should also be more general because it makes the <code>key</code> function a parameter. </p>
<p>Apart from that, the same limitation I already mentioned in a comment applies: this only works if the first element of the tuple is actually hashable (which numbers, like in the given example, are, of course).</p>
</div>
<div class="post-text" itemprop="text">
<p>A better alternative using <a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" rel="nofollow noreferrer"><code>OrderedDict</code></a>:</p>
<pre><code>from collections import OrderedDict

abc = [(1,2,3), (2,3,4), (1,0,3), (0,2,0), (2,4,5),(5,4,3), (0,4,1)]
d = OrderedDict()
for t in abc:
    d.setdefault(t[0], t)
abc_unique = list(d.values())
print(abc_unique)
</code></pre>
<p>Output:</p>
<pre><code>[(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
</code></pre>
<hr/>
<p>Simple although not very efficient:</p>
<pre><code>abc = [(1,2,3), (2,3,4), (1,0,3), (0,2,0), (2,4,5),(5,4,3), (0,4,1)]
abc_unique = [t for i, t in enumerate(abc) if not any(t[0] == p[0] for p in abc[:i])]
print(abc_unique)
</code></pre>
<p>Output:</p>
<pre><code>[(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@PatrickHaugh claims:</p>
<blockquote>
<p>but the question is explicitly about maintaining the order of the
  tuples. I don't think there's a solution using groupby</p>
</blockquote>
<p>I never miss an opportunity to (ab)use <code>groupby()</code>.  Here's my solution sans sorting (once or twice):</p>
<pre><code>from itertools import groupby, chain

abc = [(1, 2, 3), (2, 3, 4), (1, 0, 3), (0, 2, 0), (2, 4, 5), (5, 4, 3), (0, 4, 1)]

Newlist = list((lambda s: chain.from_iterable(g for f, g in groupby(abc, lambda k: s.get(k[0]) != s.setdefault(k[0], True)) if f))({}))

print(Newlist)
</code></pre>
<p><strong>OUTPUT</strong></p>
<pre><code>% python3 test.py
[(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
%
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a> correctly, the sequence must be sorted:</p>
<pre><code>&gt;&gt;&gt; [next(g) for k,g in groupby(sorted(abc, key=lambda x:x[0]), key=lambda x:x[0])]
[(0, 2, 0), (1, 2, 3), (2, 3, 4), (5, 4, 3)]
</code></pre>
<p>or if you need that very exact order of your example (i.e. maintaining original order):</p>
<pre><code>&gt;&gt;&gt; [t[2:] for t in sorted([next(g) for k,g in groupby(sorted([(t[0], i)+t for i,t in enumerate(abc)]), lambda x:x[0])], key=lambda x:x[1])]
[(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
</code></pre>
<p>the trick here is to add one field for keeping the original order to restore after the groupby() step.</p>
<p>Edit: even a bit shorter:</p>
<pre><code>&gt;&gt;&gt; [t[1:] for t in sorted([next(g)[1:] for k,g in groupby(sorted([(t[0], i)+t for i,t in enumerate(abc)]), lambda x:x[0])])]
[(1, 2, 3), (2, 3, 4), (0, 2, 0), (5, 4, 3)]
</code></pre>
</div>
<span class="comment-copy">With the <code>random.choice</code>, how can your attempt guarantee that it only keeps the first occurence?</span>
<span class="comment-copy">One caveat is that this only works if the first element of the tuple is hashable (which numbers, like in the given example, are, of course).</span>
<span class="comment-copy">A slight improvement: only add <code>a[0]</code> to <code>found</code> if it is not already in there (i.e. increase the indentation by one level for <code>found.add(a[0])</code>).</span>
<span class="comment-copy">it will be better to <code>continue</code> if <code>a[0]</code> in <code>found</code> &amp; append/add otherwise (no indentation problem as @JackTaylor stated)</span>
<span class="comment-copy">Thank you @pault: I am using this solution on my code.</span>
<span class="comment-copy">@A.S Fixed. In Python 2 it was called <code>ifilterfalse</code>. It still worked because in this case the <code>key</code> function was defined.</span>
<span class="comment-copy">Thank you for the update.</span>
<span class="comment-copy">@ jdehesa: Thank you, it works.</span>
<span class="comment-copy">That's true, but the question is explicitly about maintaining the order of the tuples. I don't think there's a solution using <code>groupby</code></span>
<span class="comment-copy">@fferri: I need the order of tuple as shown in expected output.</span>
<span class="comment-copy">@A.S I updated my answer</span>
<span class="comment-copy">@PatrickHaugh: there's always a solution with any tool =P</span>
<span class="comment-copy">@fferri: Thank you for the extra effort. It works now.</span>
