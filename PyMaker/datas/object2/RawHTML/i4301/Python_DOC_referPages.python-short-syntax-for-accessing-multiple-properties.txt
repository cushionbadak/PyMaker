<div class="post-text" itemprop="text">
<p>I have a Python object with a lot of properties (say, twenty). I want to put about half of them in a tuple. I'll write:</p>
<pre class="lang-python prettyprint-override"><code># Sample property names
myTuple = (myObj['one'], myObj['five'], myObj['six'],
    myObj['seven'], myObj['nine'], myObj['ten'],
    myObj['eleven'], myObj['fifteen'], myObj['twenty'])
</code></pre>
<p>Problem is, I have to repeat the name of the source object numerous times. Is there a more terse syntax? I would love something similar to this:</p>
<pre class="lang-python prettyprint-override"><code># Sample property names
myTuple = myObj[('one', 'five', 'six', 'seven', 'nine',
    'ten', 'eleven', 'fifteen', 'twenty')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the <a href="https://docs.python.org/3/library/operator.html" rel="nofollow noreferrer"><code>operator</code></a> module to extract elements from an object or a dictionary. For an object use <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter" rel="nofollow noreferrer"><code>attrgetter</code></a>, for a <code>dict</code> use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>itemgetter</code></a>. It returns a function, so you still have to invoke the function it returns passing the object from which you need to extract the values.</p>
<pre><code>from operator import attrgetter, itemgetter

class X:
    def __init__(self, one, two, three):
        self.one = one
        self.two = two
        self.three = three

# for object
x = X(1,2,3)
print(attrgetter('one', 'two')(x))

# for dict
y = {'one': 1, 'two':2, 'three': 3}
print(itemgetter('one', 'two')(y))
</code></pre>
<p>The good thing about it returning a function is that you can store the function and invoke it multiple times on as many objects as you want.</p>
<p>If you wished to keep the getter function then simply assign it to a variable</p>
<p>e.g.</p>
<pre><code>fn = itemgetter('one', 'two')
fn(y)
# invoke on other dict(s) here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, look a bit into list comprehension. It's very handy for stuff like this. You could also write a method for your class, which takes in a list of properties and returns them in a tuple, which would even be a nicer solution in my opinion.</p>
<pre><code>mytup = tuple([myObj[x] for x in ['one', 'five', 'six', 'seven', 'nine',
'ten', 'eleven', 'fifteen', 'twenty']])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can override the <code>__getitem__</code> method of an object to implement this alternative behavior:</p>
<pre><code>class dict2(dict):
    def __getitem__(self, k):
        if isinstance(k, tuple):
            return tuple(self[x] for x in k)
        return dict.__getitem__(self, k)
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; d=dict2(a=1, b=2, c=4, d=8)
&gt;&gt;&gt; d['a']
1
&gt;&gt;&gt; d['a', 'd']
(1, 8)
&gt;&gt;&gt; d['a', 'b', 'c', 'd']
(1, 2, 4, 8)
</code></pre>
<p>Note that this will prevent you from using tuples as keys.</p>
</div>
<span class="comment-copy">Just to be clear is your input an object i.e <code>myObj.one</code> or a dict i.e. <code>myObj['one']</code>?</span>
<span class="comment-copy">Note that parentheses are not needed in <code>myObj[('one', 'five', 'six', 'seven', 'nine', 'ten', 'eleven', 'fifteen', 'twenty')]</code></span>
<span class="comment-copy">For a mapping, it would be <code>itemgetter</code>, not <code>attrgetter</code>.</span>
<span class="comment-copy">@chepner yep. It was because the OP used the word <code>object</code> that I suggested `attrgetter. I guess there is some terminology confusion.</span>
<span class="comment-copy">Hi, I see you're new to SO. If you feel an answer solved the problem, please <a href="https://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work/5235#5235">mark it as 'acceptedâ€™</a> by clicking the green check mark. This helps keep the focus on older SO which still don't have answers.</span>
<span class="comment-copy">To avoid writing lots of quotes and commas, I would write <code>'one fix six ...'.split()</code></span>
<span class="comment-copy">I think that makes the code slightly less readable, and might cause problems if the key or whatever <code>__getitem__</code> might be using has spaces in it. But that's just a personal preference.</span>
<span class="comment-copy">Also, if you ,for some reason, need them returned as nested tuples this is the way to go. <code>print(d['a', ('b', 'c')])</code> -&gt; <code>(1, (2, 4))</code></span>
