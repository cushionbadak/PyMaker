<div class="post-text" itemprop="text">
<p>I tried to combine blocking tasks and non-blocking (I/O bound) tasks using <code>ProcessPoolExecutor</code> and found it's behavior pretty unexpected.</p>
<pre><code>class BlockingQueueListener(BaseBlockingListener):
    def run(self):
        # Continioulsy listening a queue
        blocking_listen()

class NonBlockingListener(BaseNonBlocking):
    def non_blocking_listen(self):
        while True:
           await self.get_message()


def run(blocking):
    blocking.run()


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    executor = ProcessPoolExecutor()
    blocking = BlockingQueueListener()
    non_blocking = NonBlockingListener()
    future = loop.run_in_executor(executor, run(blocking))
    loop.run_until_complete(
        asyncio.gather(
            non_blocking.main(),
            future
        )
    )
</code></pre>
<p>I was expecting that both tasks will have control concurrently, but blocking task started in <code>ProcessPoolExecutor</code> blocks and never return control. How could it happen? What the proper way to combine normal coroutines and futures started in multiprocessing executor?</p>
</div>
<div class="post-text" itemprop="text">
<p>This line:</p>
<pre><code>future = loop.run_in_executor(executor, run(blocking))
</code></pre>
<p>Will actually run the blocking function and give its result to the executor.</p>
<p>According to the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="nofollow noreferrer">documentation</a>, you need to pass the function explicitly followed by its arguments.</p>
<pre><code> future = loop.run_in_executor(executor, run, blocking)
</code></pre>
</div>
