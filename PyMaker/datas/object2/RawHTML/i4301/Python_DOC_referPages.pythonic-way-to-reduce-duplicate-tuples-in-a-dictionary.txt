<div class="post-text" itemprop="text">
<p>I have a dictionary of tuples such as:</p>
<pre><code>my_dict = {('A','B'): 3, ('A','C'): 4, ('B','A'): 5}
</code></pre>
<p>and the goal is to combine keys (regardless of ordering) and add their respective values, such that the result would look something like</p>
<pre><code>my_dict = {('A','B'): 8, ('A','C'): 4}
</code></pre>
<p>I'm pretty sure I can do this with the following:</p>
<pre><code>new_dict = {}
items = my_dict.copy().items()
for k, _ in items:
    to_add = my_dict.pop(k)
    for key, val in my_dict.items():
        if set(k) == set(key):
            new_dict[key] = val + to_add
    if (k not in new_dict) and ((k[1],k[0]) not in new_dict):
        new_dict[k] = to_add
</code></pre>
<p>However, I'm not very happy with this solution. I created another dictionary rather than maintaining the original, I have nested loops (though I don't think it's quite O(N**2) because the length of the second loop is always decreasing), and I have a feeling there's a more elegant solution.</p>
<p>Is there a more pythonic or generally more elegant way of accomplishing this task?</p>
<p>EDIT:</p>
<p>For clarity, here are a few conditions that hold -- all tuples have exactly 2 elements, but the elements are not guaranteed to be comparable, as in we may have <code>('A', None)</code>. There do not exist any duplicate tuples, like <code>('A', 'A')</code>, and the final order of the tuples is unimportant. This means that a result</p>
<pre><code>my_dict = {('A','B'): 8, ('A','C'): 4}
</code></pre>
<p>is no better or worse than </p>
<pre><code>my_dict = {('B','A'): 8, ('A','C'): 4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you care about neither order nor duplicates within the tuples (that is, if your code converts <code>('A', 'B')</code> into <code>('B', 'A')</code>, and <code>('A', 'A')</code> into <code>('A',)</code>, that's fine), you can use frozensets instead of tuples.</p>
<p>If you care about duplicates but not order, sorted tuples will work. (Although if your tuple elements aren’t comparable, you’d need to come up with a comparison key—maybe just <code>lambda x: type(x).__name__, x</code> a la Python 2, but maybe something more complicated.)</p>
<p>Either way, rather than building a dict, and then building another dict that sums up duplicates, just build a <code>Counter</code> in the first place:</p>
<pre><code>import collections
c = collections.Counter()
for key, value in &lt;wherever they come from&gt;:
    c[frozenset(key)] += value

import collections
c = collections.Counter()
for key, value in &lt;wherever they come from&gt;:
    c[tuple(sorted(key))] += value
</code></pre>
<p>If you need to preserve but ignore order (the same way, e.g., some filesystems preserve but ignores case), you will need to do a bit more work. (You also need to decide whether you want to preserve the first or last of a matching set of keys.) One option is to use a "key-transforming dict" that wraps a dict, using the transformed key as the underlying key and the original key as an extra value in the values. Without a wrapper, it would look like this:</p>
<pre><code>c = {}
for key, value in &lt;wherever they come from&gt;:
    skey = frozenset(key)
    if skey not in c:
        c[skey] = [key, 0]
    c[skey][1] += value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a more pythonic solution, use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> or a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a>:</p>
<pre><code>import collections

new_dict = collections.defaultdict(int)
# alternatively: new_dict = collections.Counter()

for key, value in my_dict.items():
    # converting the tuples to frozensets removes the order and makes
    # them hashable
    key = frozenset(key)
    new_dict[key] += value

# turn the defaultdict with frozensets back into a normal dict with tuples
new_dict = {tuple(key): value for key, value in new_dict.items()}
</code></pre>
<p>Result:</p>
<pre><code>{('A', 'B'): 8, ('A', 'C'): 4}
</code></pre>
<p>Keep in mind that this only works if the values in your tuples are unique. If there was a tuple like <code>('A', 'A')</code> in the dict, calling <code>frozenset</code> on it would collapse it to <code>{'A'}</code> and produce incorrect output. If this is a concern, you can replace the line</p>
<pre><code>key = frozenset(key)
</code></pre>
<p>with </p>
<pre><code>key = tuple(sorted(key))
</code></pre>
<p>to make it work correctly.</p>
</div>
<span class="comment-copy">Are your tuples always pairs, or can they be longer? Are the tuple elements guaranteed to be comparable to each other with <code>&lt;</code>?</span>
<span class="comment-copy">Do you care about preserving the order for the tuples at all? And do you care about duplicate values, like <code>('A', 'A')</code>? If no to both: why not use frozensets instead of tuples? <code>frozenset(('A', 'B'))</code> and <code>frozenset(('B', 'A'))</code> are the same set, so you won't get duplicates in the first place.</span>
<span class="comment-copy">@abarnert: You need to be careful about tuples like <code>('A', 'A')</code>, though, and if you can have longer tuples, you need to be careful about the difference between <code>('A', 'A', 'B')</code> and <code>('A', 'B', 'B')</code>.</span>
<span class="comment-copy">@user2357112 Yes the tuples are always pairs, and no, the tuple elements are not guaranteed to be comparable. There are some tuples that are like <code>('A',None)</code></span>
<span class="comment-copy">@abarnert I don't care about preserving the order at all, and there are no such tuples as <code>('A', 'A')</code>, as the logic that creates them only creates a tuple if <code>some_element != some_other_element</code>. I like the <code>frozenset</code> idea, but if I can't alter the way this dictionary is generated, then I can't do that, can I?</span>
<span class="comment-copy">Marked as correct as it definitely does answer my question. I think that <code>c = []</code> should be a <code>c = {}</code> in that last answer though, right?</span>
<span class="comment-copy">@Curtis Thanks; fixed. I don’t expect anyone to use that code without wrapping it up with a key-transforming dict class (which you can find by searching instead of writing it yourself), but yeah, a demonstration that doesn’t actually work isn’t very useful…</span>
<span class="comment-copy">This fails for keys like <code>('A', 'A')</code>.</span>
<span class="comment-copy">Why build a <code>dict</code> and then build a <code>defaultdict</code> to copy things into rather than just using a <code>Counter</code> in the first place?</span>
<span class="comment-copy">@user2357112 Good point; I've updated the answer.</span>
<span class="comment-copy">@abarnert I don't see the benefit of using a Counter instead of defaultdict here. There's no particular reason why I used a defaultdict; is there something wrong with it?</span>
<span class="comment-copy">@Aran-Fey The advantage of using a <code>Counter</code> over a <code>defaultdict</code> is pretty much the same as the advantage of using a <code>defaultdict</code> over a plain <code>dict</code>: If what you're doing here is keeping track of an integer count for each value, why not use a type that signals that, and makes it harder to use it incorrectly?</span>
