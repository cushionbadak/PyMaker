<div class="post-text" itemprop="text">
<p>When using <code>subprocess.Popen(args, shell=True)</code> to run "<code>gcc --version</code>" (just as an example), on Windows we get this:</p>
<pre><code>&gt;&gt;&gt; from subprocess import Popen
&gt;&gt;&gt; Popen(['gcc', '--version'], shell=True)
gcc (GCC) 3.4.5 (mingw-vista special r3) ...
</code></pre>
<p>So it's nicely printing out the version as I expect. But on Linux we get this:</p>
<pre><code>&gt;&gt;&gt; from subprocess import Popen
&gt;&gt;&gt; Popen(['gcc', '--version'], shell=True)
gcc: no input files
</code></pre>
<p>Because gcc hasn't received the <code>--version</code> option.</p>
<p>The docs don't specify exactly what should happen to the args under Windows, but it does say, on Unix, <em>"If args is a sequence, the first item specifies the command string, and any additional items will be treated as additional shell arguments."</em> IMHO the Windows way is better, because it allows you to treat <code>Popen(arglist)</code> calls the same as <code>Popen(arglist, shell=True)</code> ones.</p>
<p><strong>Why the difference between Windows and Linux here?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>Actually on Windows, it does use <code>cmd.exe</code> when <code>shell=True</code> - it prepends <code>cmd.exe /c</code> (it actually looks up the <code>COMSPEC</code> environment variable but defaults to <code>cmd.exe</code> if not present) to the shell arguments. (On Windows 95/98 it uses the intermediate <code>w9xpopen</code> program to actually launch the command).</p>
<p>So the strange implementation is actually the <code>UNIX</code> one, which does the following (where each space separates a different argument):</p>
<pre><code>/bin/sh -c gcc --version
</code></pre>
<p>It looks like the correct implementation (at least on Linux) would be:</p>
<pre><code>/bin/sh -c "gcc --version" gcc --version
</code></pre>
<p>Since this would set the command string from the quoted parameters, and pass the other parameters successfully.</p>
<p>From the <code>sh</code> man page section for <code>-c</code>:</p>
<blockquote>
<p><code>Read commands from the command_string operand instead of from the standard input.  Special parameter 0 will be set from the command_name operand and the positional parameters ($1, $2, etc.)  set from the remaining argument operands.</code></p>
</blockquote>
<p>This patch seems to fairly simply do the trick:</p>
<pre><code>--- subprocess.py.orig  2009-04-19 04:43:42.000000000 +0200
+++ subprocess.py       2009-08-10 13:08:48.000000000 +0200
@@ -990,7 +990,7 @@
                 args = list(args)

             if shell:
-                args = ["/bin/sh", "-c"] + args
+                args = ["/bin/sh", "-c"] + [" ".join(args)] + args

             if executable is None:
                 executable = args[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the subprocess.py source:</p>
<blockquote>
<p>On UNIX, with shell=True: If args is a string, it specifies the
  command string to execute through the shell.  If args is a sequence,
  the first item specifies the command string, and any additional items
  will be treated as additional shell arguments.</p>
<p>On Windows: the Popen class uses CreateProcess() to execute the child
  program, which operates on strings.  If args is a sequence, it will be
  converted to a string using the list2cmdline method.  Please note that
  not all MS Windows applications interpret the command line the same
  way: The list2cmdline is designed for applications using the same
  rules as the MS C runtime.</p>
</blockquote>
<p>That doesn't answer why, just clarifies that you are seeing the expected behavior.</p>
<p>The "why" is probably that on UNIX-like systems, command arguments are actually passed through to applications (using the <code>exec*</code> family of calls) as an array of strings. In other words, the calling process decides what goes into EACH command line argument. Whereas when you tell it to use a shell, the calling process actually only gets the chance to pass a single command line argument to the shell to execute: The entire command line that you want executed, executable name and arguments, as a single string.</p>
<p>But on Windows, the entire command line (according to the above documentation) is passed as a single string to the child process. If you look at the <a href="http://msdn.microsoft.com/en-us/library/ms682425%28VS.85%29.aspx" rel="nofollow noreferrer">CreateProcess</a> API documentation, you will notice that it expects all of the command line arguments to be concatenated together into a big string (hence the call to <code>list2cmdline</code>).</p>
<p>Plus there is the fact that on UNIX-like systems there actually <em>is</em> a shell that can do useful things, so I suspect that the other reason for the difference is that on Windows, <code>shell=True</code> does nothing, which is why it is working the way you are seeing. The only way to make the two systems act identically would be for it to simply drop all of the command line arguments when <code>shell=True</code> on Windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason for the UNIX behaviour of <code>shell=True</code> is to do with quoting. When we write a shell command, it will be split at spaces, so we have to quote some arguments:</p>
<pre><code>cp "My File" "New Location"
</code></pre>
<p>This leads to problems when our arguments <em>contain</em> quotes, which requires escaping:</p>
<pre><code>grep -r "\"hello\"" .
</code></pre>
<p>Sometimes we can get <a href="http://en.wikipedia.org/wiki/Leaning_toothpick_syndrome" rel="nofollow">awful situations</a> where <code>\</code> must be escaped too!</p>
<p>Of course, the real problem is that we're trying to use <em>one</em> string to specify <em>multiple</em> strings. When calling system commands, most programming languages avoid this by allowing us to send multiple strings in the first place, hence:</p>
<pre><code>Popen(['cp', 'My File', 'New Location'])
Popen(['grep', '-r', '"hello"'])
</code></pre>
<p>Sometimes it can be nice to run "raw" shell commands; for example, if we're copy-pasting something from a shell script or a Web site, and we don't want to convert all of the horrible escaping manually. That's why the <code>shell=True</code> option exists:</p>
<pre><code>Popen(['cp "My File" "New Location"'], shell=True)
Popen(['grep -r "\"hello\"" .'], shell=True)
</code></pre>
<p>I'm not familiar with Windows so I don't know how or why it behaves differently.</p>
</div>
<span class="comment-copy">It usually is a good idea to include version of Python you are using or at least if it is line 2 or 3.</span>
<span class="comment-copy">That's great, thanks David. I agree about the correct implementation and your patch looks good. Are you in a (better) position than I to submit a Python bug report -- in other words, have you done that before, or shall I look into it?</span>
<span class="comment-copy">Added <a href="http://bugs.python.org/issue6689" rel="nofollow noreferrer">bugs.python.org/issue6689</a> - would be good if you could follow it, comment there etc</span>
<span class="comment-copy">Thanks! I've added myself to the nosy list.</span>
<span class="comment-copy">For reference, the patch was rejected. It may be an idea to look at whether the documentation needs to be amended instead - I'll leave that up to an interested party</span>
<span class="comment-copy">There is a shell on Windows too (normally <code>cmd.exe</code>), but the comment you quoted above indicates that Python does not actually use it when shell=True (instead, it uses <code>CreateProcess()</code> directly).</span>
<span class="comment-copy">Thanks -- as Greg mentioned, there definitely is a shell on Windows (cmd.exe or the one in COMSPEC). And it is used by Popen (though via CreateProcess) -- see the subprocess.py source. So it still definitely seems to me that subprocess should make them work the same way, to avoid portability pitfalls...</span>
<span class="comment-copy">note: <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">the docs has been updated since 2010</a></span>
