<div class="post-text" itemprop="text">
<p>I am creating a cryptocurrency exchange API client using Python3.5 and Tkinter. I have several displays that I want to update asynchronously every 10 seconds. I am able to update the displays every 10 seconds using <code>Tk.after()</code> like in this example</p>
<pre><code>def updateLoans():
    offers = dd.loanOffers()
    demands = dd.loanDemands()
    w.LoanOfferView.delete(1.0, END)
    w.LoanDemandView.delete(1.0, END)
    w.LoanOfferView.insert(END, offers)
    w.LoanDemandView.insert(END, demands)
    print('loans refreshed')

    root.after(10000, updateLoans)
</code></pre>
<p>In order for the <code>after</code> method to continue to update continuously every 10 seconds the function <code>updateLoans()</code> needs to be passed as a callable into <code>after()</code> inside of the function.</p>
<p>Now the part that is stumping me, when I make this function asynchronous with python's new async and await keywords</p>
<pre><code>async def updateLoans():
    offers = await dd.loanOffers()
    demands = await dd.loanDemands()
    w.LoanOfferView.delete(1.0, END)
    w.LoanDemandView.delete(1.0, END)
    w.LoanOfferView.insert(END, offers)
    w.LoanDemandView.insert(END, demands)
    print('loans refreshed')

    root.after(10000, updateLoans)
</code></pre>
<p>The problem here is that I can not await a callable inside of the parameters for the <code>after</code> method. So I get a runtime warning. <code>RuntimeWarning: coroutine 'updateLoans' was never awaited</code>.</p>
<p>My initial function call <strong>IS</strong> placed inside of an event loop.</p>
<pre><code>loop = asyncio.get_event_loop()
loop.run_until_complete(updateLoans())
loop.close()
</code></pre>
<p>The display populates just fine initially but never updates.</p>
<p>How can I use <code>Tk.after</code> to continuously update a tkinter display asynchronously?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>tk.after</code> accepts a normal function, not a coroutine. To run the coroutine to completion, you can use <code>run_until_complete</code>, just as you did the first time:</p>
<pre><code>loop = asyncio.get_event_loop()
root.after(10000, lambda: loop.run_until_complete(updateLoans()))
</code></pre>
<p>Also, don't call <code>loop.close()</code>, since you'll need the loop again.
<hr/>
The above quick fix will work fine for many use cases. The fact is, however, that it will render the GUI completely unresponsive if <code>updateLoans()</code> takes a long time due to slow network or a problem with the remote service. A good GUI app will want to avoid this.</p>
<p>While Tkinter and asyncio <a href="https://bugs.python.org/issue27546" rel="nofollow noreferrer">cannot share an event loop yet</a>, it is perfectly possible to run the asyncio event loop in a separate thread. The main thread then runs the GUI, while a dedicated asyncio thread runs all asyncio coroutines. When the event loop needs to notify the GUI to refresh something, it can use a queue <a href="http://effbot.org/zone/tkinter-threads.htm" rel="nofollow noreferrer">as shown here</a>. On the other hand, if the GUI needs to tell the event loop to do something, it can call <a href="https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading" rel="nofollow noreferrer"><code>call_soon_threadsafe</code> or <code>run_coroutine_threadsafe</code></a>.</p>
<p>Example code (untested):</p>
<pre><code>gui_queue = queue.Queue()

async def updateLoans():
    while True:
        offers = await dd.loanOffers()
        demands = await dd.loanDemands()
        print('loans obtained')
        gui_queue.put(lambda: updateLoansGui(offers, demands))
        await asyncio.sleep(10)

def updateLoansGui(offers, demands):
    w.LoanOfferView.delete(1.0, END)
    w.LoanDemandView.delete(1.0, END)
    w.LoanOfferView.insert(END, offers)
    w.LoanDemandView.insert(END, demands)
    print('loans GUI refreshed')

# http://effbot.org/zone/tkinter-threads.htm
def periodicGuiUpdate():
    while True:
        try:
            fn = gui_queue.get_nowait()
        except queue.Empty:
            break
        fn()
    root.after(100, periodicGuiUpdate)

# Run the asyncio event loop in a worker thread.
def start_loop():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.create_task(updateLoans())
    loop.run_forever()
threading.Thread(target=start_loop).start()

# Run the GUI main loop in the main thread.
periodicGuiUpdate()
root.mainloop()

# To stop the event loop, call loop.call_soon_threadsafe(loop.stop).
# To start a coroutine from the GUI, call asyncio.run_coroutine_threadsafe.
</code></pre>
</div>
<span class="comment-copy">One of the most clear and thorough answers I've received on stack overflow. Thanks this helped a lot</span>
<span class="comment-copy">So trying to implement your second solution, I keep getting this error. <code>RuntimeError: There is no current event loop in thread 'Thread-1'</code></span>
<span class="comment-copy">@RileyHughes Ok, in Python 3.5 you will need to additionally set the event loop for the new thread. I've now amended the answer.</span>
