<div class="post-text" itemprop="text">
<p>I am using a modified version of <a href="http://scikit-image.org/docs/dev/auto_examples/edges/plot_contours.html" rel="nofollow noreferrer">this scikit-image demo</a> to create contours from the edges resulting from watershed segmentation of an image. In this result, each level has one contour only, made of row-column index pairs.</p>
<p>It is easy to display contours as in the demo. But what I'd like to do is use the <code>enumerate</code> loop to append each vertex of each contour to a Pandas DataFrame, separating the row and column index, and then add a level/contour index in a separate column. </p>
<p>To illustrate I will start with a small toy example where each contour has one index only. With this code:</p>
<pre><code>np.random.seed(131)
test = np.random.randint(50, size=5)
n_list = []
t_list = []
for n, t in enumerate(test):
    n_list.append(n)
    t_list.append(t)
contours_df = pd.DataFrame({'contour': n_list, 'contour': t_list})
contours_df 
</code></pre>
<p>I get this DataFrame:</p>
<p><a href="https://i.stack.imgur.com/wkLrn.png" rel="nofollow noreferrer"><img alt="test" src="https://i.stack.imgur.com/wkLrn.png"/></a></p>
<p>A more representative example would be something like this:</p>
<pre><code>np.random.seed(131)
test1 = np.random.randint(50, size=(5, 2,  2))
n_list1 = []
t_list1 = []
for n1, t1 in enumerate(test1):
    n_list1.append(n1)
    t_list1.append(t1)
contours_df1 = pd.DataFrame({'contour': n_list1, 'points': t_list1})
contours_df1
</code></pre>
<p>which gives me this DataFrame:</p>
<p><a href="https://i.stack.imgur.com/zTlJR.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/zTlJR.png"/></a></p>
<p>I can export this to an Excel file using <code>XlsxWriter</code>, like this:</p>
<pre><code># using XlsxWriter documentation example
writer = pd.ExcelWriter('contours_df1.xlsx', engine='xlsxwriter')
contours_df1.to_excel(writer, sheet_name='Sheet1')
writer.save()
</code></pre>
<p>To get this:</p>
<p><a href="https://i.stack.imgur.com/UEkgk.png" rel="nofollow noreferrer"><img alt="Excel 1" src="https://i.stack.imgur.com/UEkgk.png"/></a></p>
<p>But what I would really like is to split the contours so as to get something like this as a final Excel output:</p>
<p><a href="https://i.stack.imgur.com/XHZlw.png" rel="nofollow noreferrer"><img alt="Excel 2" src="https://i.stack.imgur.com/XHZlw.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I would use pandas concatenation. For reasonably-sized data, it's a matter of taste whether you build up a list per column (though you would need a second nested loop to allow for arbitrary-sized contours). For larger data, I think this method should be faster because it makes use of NumPy/pandas vectorization where possible.</p>
<p>Here's an example:</p>
<pre><code>import numpy as np
import pandas as pd

contours = [np.random.random((i, 2)
            for i in np.random.randint(3, 10, size=5)]

dataframes = []
for contour_id, contour in enumerate(contours):
    current_dataframe = pd.DataFrame(contour, columns=['row', 'column'])
    current_dataframe['contour'] = contour_id
    dataframes.append(current_dataframe)
contours_data = pd.concat(dataframes)

contours_data.to_excel('filename.xlsx', sheet_name='Sheet1')
</code></pre>
<p>Side note: you don't need to create an ExcelWriter if you are only writing a single sheet.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are almost at your goal, you just need to play around a bit:</p>
<p>The <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> method works as intended. When we enumerate an iterable python object, we get a <code>1-1</code> correlation between the object's elements and a "pointer" which ranges from <code>0</code> to <code>len(iterable_object)-1</code>.<br/>
Have a look at this example from the documentations:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; seasons = ['Spring', 'Summer', 'Fall', 'Winter']
&gt;&gt;&gt; list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
</code></pre>
</blockquote>
<p>Now one way to achieve what you are showing us here, would be to use the pointer generated from <code>enumerate</code> 2 times and split the contents of each <code>test</code> elements accordingly:</p>
<pre><code>np.random.seed(131)
test1 = np.random.randint(50, size=(5, 2,  2))
contour_lst = []
row_lst = []
column_lst = []
for n, t_elem in enumerate(test1):
    # First square coordinates for this contour.
    contour_lst.append(n)
    row_lst.append(t_elem[0][0])
    column_lst.append(t_elem[0][1])
    # Second square coordinates for this contour.
    contour_lst.append(n)
    row_lst.append(t_elem[1][0])
    column_lst.append(t_elem[1][1])

contours_df1 = pd.DataFrame({
    'contour': contour_lst, 
    'row': row_lst,
    'column': column_lst,
})
</code></pre>
</div>
<span class="comment-copy">+1 for a good answer and extra bits on <code>enumerate</code>. I could really choose either question received so far. I am picking Juan's because it works directly on arbitrary-sized contours (most general case), even though it was not specified in my question, shown in examples.</span>
<span class="comment-copy">@MyCarta As long as it works for you mate! :)</span>
