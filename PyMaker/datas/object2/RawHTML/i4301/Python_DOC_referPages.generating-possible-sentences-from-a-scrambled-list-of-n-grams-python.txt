<div class="post-text" itemprop="text">
<p>Sample input stream: <code>[ ('t','h'), ('h','e'), ('e', ' '), (' ','f') , ('f','o'), ('o','x'), ('x',' '), (' ','a'), ('a','t'), ('t','e'), ('e', &lt;p&gt;) ]</code></p>
<hr/>
<p>Suppose you have a sentence <code>{ABCABA}</code>, where each letter is either a character or word, depending on tokenization.</p>
<p>Then your bag-of-bigrams is <code>{(AB), (BC), (CA), (AB), (BA)}</code>.</p>
<p>From here, I need an algorithm to list all the possible permutations of sentences with the same length as the original sentence, given these bigrams. Here, <code>{ABCABA}</code> (the original sequence) and <code>(ABABCA)</code> are both valid, possible sentences, but <code>{ACBABA}</code> is not. This example is for bigrams, but I also need this to work for any <code>$n$</code>. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>Build a directed graph and then use recursion to enumerate all possible paths of length k. To wit,</p>
<pre><code>def buildgraph(input, n):
    # n-1-gram to tokens that follow it
    graph = {
        tuple(input[i:(i + n - 1)]): set()
        for i in range(len(input) - n + 1)
    }
    for i in range(len(input) - n + 1):
        graph[tuple(input[i:(i + n - 1)])].add(input[i + n - 1])
    return graph


def continuations(graph, n, k, pathsofar):
    if len(pathsofar) == k:
        yield pathsofar
    elif len(pathsofar) &lt; k:
        for token in graph[pathsofar[-(n - 1):]]:
            yield from continuations(graph, n, k, pathsofar + (token, ))


def allsentences(input, n, k):
    graph = buildgraph(input, n)
    for ngram in graph:
        yield from continuations(graph, n, k, ngram)


for sent in allsentences('abcaba', 2, 6):
    print(''.join(sent))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a very straightforward solution. First, compute all n-grams; second, get all possible sublists of these n-grams and get all permutations of those sublists.</p>
<h1>The n-grams (may be optional, given your sample input stream)</h1>
<p>You can use a comprehension list. Take <code>n</code> times the list with a start from indices <code>0</code> to <code>n-1</code>: <code>[sentence[k:] for k in range(n)]</code>. For <code>ABCABA</code> and <code>3</code>, you get <code>[ABCABA, BCABA, CABA]</code>. You just have to zip the lists and join the resulting tuples (note the star to unpack the arguments):</p>
<pre><code>def ngrams(sentence, n): return ["".join(t) for t in zip(*[sentence[k:] for k in range(n)])]
</code></pre>
<p>This gives:</p>
<pre><code>&gt;&gt;&gt; ng = ngrams("ABCABA", 2)
&gt;&gt;&gt; ng
['AB', 'BC', 'CA', 'AB', 'BA']
</code></pre>
<h1>List sentences</h1>
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools</code></a>, specifically <code>combinations</code> and <code>permutations</code>. The <code>combinations</code> function gives the "r length subsequences of elements from the input iterable":</p>
<pre><code>&gt;&gt;&gt; list(itertools.combinations(ng, 2))
[('AB', 'BC'), ('AB', 'CA'), ('AB', 'AB'), ('AB', 'BA'), ('BC', 'CA'), ('BC', 'AB'), ('BC', 'BA'), ('CA', 'AB'), ('CA', 'BA'), ('AB', 'BA')]
</code></pre>
<p>You have to take the combinations for every possible length. The <code>permutations</code> function will permute all this subsequences:</p>
<pre><code>def sentences(sentence, n):
    ng = ngrams(sentence, n)
    for k in range(len(ng)):
        for c in itertools.combinations(ng, k):
            for p in itertools.permutations(c):
                yield("".join(p))
</code></pre>
<p>Or with a generator comprehension:</p>
<pre><code>def sentences(sentence, n):
    ng = ngrams(sentence, n)
    return ("".join(p) for k in range(len(ng)) for c in itertools.combinations(ng, k) for p in itertools.permutations(c))
</code></pre>
<p>This gives 206 possibilities:</p>
<pre><code>&gt;&gt;&gt; list(sentences("ABCABA", 2))
['', 'AB', 'BC', 'CA', 'AB', 'BA', 'ABBC', 'BCAB', ..., 'ABBACABC', 'BABCCAAB', 'BABCABCA', 'BACABCAB', 'BACAABBC', 'BAABBCCA', 'BAABCABC']
</code></pre>
</div>
