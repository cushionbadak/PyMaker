<div class="post-text" itemprop="text">
<p>I have to make a StarCraft-like game in a really simplistic way with pyton.</p>
<p>One of the task I have to do is to create a little farming algorithm in order to make the ships compute the distance separating them from the asteroid, choose the closest one sand go mine on it.</p>
<p>All of the game data is contained in a dictionary, here's a sample :</p>
<pre><code>database = {
    'player1': {
        'type': 'player',
        'ships': {
            'shipOne': {
                'life': 3,
                'type': 'excavator-M',
                'taille': 5,
                'tonnage': 4,
                'remaining_tonnage': 4,
                'status': 'unlock',
                'portée': 0,
                'position': [20, 3],
                'attack': 0,
                'cost': 2
            },
            'shipTwo': {
                'life': 3,
                'type': 'excavator-M',
                'taille': 5,
                'tonnage': 4,
                'remaining_tonnage': 4,
                'status': 'unlock',
                'portée': 0,
                'position': [20, 3],
                'attack': 0,
                'cost': 2
            }
        },
        'actions': {
            'purchases': {},
            'moves': {},
            'mining': {},
            'attacks': {},
            '(un)lock': {}},
            'ores': 995},
            'parameters': {
                'turn_count': 19,
                'columns': 41,
                'lines': 40},
                'asteroids': {
                    '10 14': {
                        'capacity': 12,
                        'pos': [10, 14],
                        'farm_rate': 1
                    },
                    '5 21': {
                        'capacity': 12,
                        'pos': [5, 21],
                        'farm_rate': 2
                    },
                    '20 6': {
                        'capacity': 12,
                        'pos': [20, 6],
                        'farm_rate': 2
                    }
                }
            }
</code></pre>
<p>I tried to proceed like this : </p>
<p>1° Create a copy of the dictionary['asteroids], that way I'll be able to virtually decrease the amount of ores contained in an asteroid and not send to much ships on the same asteroid.</p>
<p>2° Use a loop to create a dictionary 'ships_dest' in which I add each ships name as a key, the future element to associate to this key is the destination of the closest non-empty asteroid.</p>
<p>3° For each ship, I compute the distance separating it from all of the asteroids. And add this value in the dictionary samp_asteroids associated with the key 'distance'.</p>
<p>4° I create a list named 'priority_list' containing each asteroid name, it will be used to compare the distances in pairs and delete the farthest asteroid. </p>
<p>The the idea is to choose the closest asteroid with the highest farm rate and associate it with the correct ship in the dictionary ships_dest.</p>
<p>Here's what I tried :</p>
<pre><code>ships_dest = dict()
samp_asteroids = copy.deepcopy(database['asteroids'])

priority_list = list()

for ship in database['player1']['ships']:
    ships_dest.update({ship:''})

    for asteroid in samp_asteroids:
        priority_list.append(asteroid)
        distance = abs(database['player1']['ships'][ship]['position'][0] - database['asteroids'][asteroid]['pos'][0]) + abs(database['player1']['ships'][ship]['position'][1] - database['asteroids'][asteroid]['pos'][1])
        samp_asteroids[asteroid].update({'distance':distance})

for ship in database['player1']['ships']:  

    for asteroid in samp_asteroids:

            if database['asteroids'][asteroid]['capacity'] != 0:

                if samp_asteroids[asteroid]['capacity'] != 0:

                    ships_dest.update({ship:database['asteroids'][best_ast(samp_asteroids,priority_list)]['pos']})

                    samp_asteroids[best_ast(samp_asteroids,priority_list)]['capacity'] -= database['player1']['ships'][ship]['tonnage']
</code></pre>
<p>Here's the function I use to choose the closest asteroid with the best farming rate : </p>
<pre><code>def best_ast(samp_asteroids,priority_list): 
    """
    Browse a list containing each asteroids name and return the closest asteroid to the considered ship.

    Parameters
    ----------

    - samp_asteroids : dictionary containing the data about the asteroids on the board. (dict)

    - priority_list : list containing the name of each asteroid. (list)

    Return
    ------

    - The name of the closest asteroid with the best farming rate. (str)

    """

    if len(priority_list) == 1:
        return priority_list[0]

    else:
        if samp_asteroids[priority_list[0]]['distance'] &gt; samp_asteroids[priority_list[1]]['distance']: # on garde la plus petite distance
            priority_list.remove(priority_list[0])

        elif samp_asteroids[priority_list[0]]['distance'] &lt; samp_asteroids[priority_list[1]]['distance']: # on garde la plus petite distance
            priority_list.remove(priority_list[1])

        else:
            if samp_asteroids[priority_list[0]]['farm_rate'] &lt; samp_asteroids[priority_list[1]]['farm_rate']:
                priority_list.remove(priority_list[0])

            elif samp_asteroids[priority_list[1]]['farm_rate'] &lt; samp_asteroids[priority_list[0]]['farm_rate']:
                priority_list.remove(priority_list[1])

        return(best_ast(samp_asteroids,priority_list)) 
</code></pre>
<p>Does anyone has an idea to compare the distances separating ship and asteroid without using a list ? Or simply a smarter way of doing so because I end up with a RecursionError : </p>
<pre><code>RecursionError                            Traceback (most recent call last)
&lt;ipython-input-18-0fa8dfeb9b6e&gt; in &lt;module&gt;()
     19                 if samp_asteroids[asteroid]['capacity'] != 0:
     20 
---&gt; 21                     ships_dest.update({ship:database['asteroids'][best_ast(samp_asteroids,priority_list)]['pos']})
     22 
     23                     samp_asteroids[best_ast(samp_asteroids,priority_list)]['capacity'] -= database['player1']['ships'][ship]['tonnage']

&lt;ipython-input-10-9786ab7c168e&gt; in best_ast(samp_asteroids, asts)
     20                 asts.remove(asts[1])
     21 
---&gt; 22         return(best_ast(samp_asteroids,asts))

... last 1 frames repeated, from the frame below ...

&lt;ipython-input-10-9786ab7c168e&gt; in best_ast(samp_asteroids, asts)
     20                 asts.remove(asts[1])
     21 
---&gt; 22         return(best_ast(samp_asteroids,asts))

RecursionError: maximum recursion depth exceeded in comparison
</code></pre>
<p>Thank you !</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow noreferrer">Sort</a> <code>priority_list</code> items on <code>distance</code> (<em>increasing</em>) and <code>farm_rate</code> (<em>decreasing</em>) then choose the best one.</p>
<p>Assuming <code>priority_list</code> items are similar to this, and the values are numeric:</p>
<pre><code>p_list = [{'distance': 65, 'farm_rate': 0.9006277325425915},
          {'distance': 8, 'farm_rate': 0.12482252401403537},
          {'distance': 63, 'farm_rate': 0.6915596366818075},
          {'distance': 8, 'farm_rate': 0.50761770347844},
          {'distance': 43, 'farm_rate': 0.8675896228329137},
          {'distance': 43, 'farm_rate': 0.22372360159878157},
          {'distance': 67, 'farm_rate': 0.6110535887580553},
          {'distance': 8, 'farm_rate': 0.2520264185913459},
          {'distance': 99, 'farm_rate': 0.31742690900315873},
          {'distance': 76, 'farm_rate': 0.3747398299123208}]
</code></pre>
<p>Write a function that returns the distance and (negative) farm rate.</p>
<pre><code>from operator import itemgetter
both = itemgetter('distance', 'farm_rate')
def f(d):
    d, r = both(d)
    return (d,-r)
</code></pre>
<p>Use the function as the sort key:</p>
<pre><code>p_list.sort(key=f)

&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(p_list)
[{'distance': 8, 'farm_rate': 0.50761770347844},
 {'distance': 8, 'farm_rate': 0.2520264185913459},
 {'distance': 8, 'farm_rate': 0.12482252401403537},
 {'distance': 43, 'farm_rate': 0.8675896228329137},
 {'distance': 43, 'farm_rate': 0.22372360159878157},
 {'distance': 63, 'farm_rate': 0.6915596366818075},
 {'distance': 65, 'farm_rate': 0.9006277325425915},
 {'distance': 67, 'farm_rate': 0.6110535887580553},
 {'distance': 76, 'farm_rate': 0.3747398299123208},
 {'distance': 99, 'farm_rate': 0.31742690900315873}]
</code></pre>
<p>The asteroid with the smallest distance and the highest farm rate should be the first one.</p>
<pre><code>&gt;&gt;&gt; p_list[0]
{'distance': 8, 'farm_rate': 0.50761770347844}
&gt;&gt;&gt;
</code></pre>
<p>Or just use the key function with <code>min()</code>:</p>
<pre><code>&gt;&gt;&gt; min(p_list, key=f)
{'distance': 8, 'farm_rate': 0.50761770347844}
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can almost always re-implement a recursive as a non-recursive function:</p>
<pre><code>def best_ast(samp_asteroids,priority_list):
    best = samp_asteroids[priority_list[0]]
    for p in priority_list:
        if best['distance'] &gt; samp_asteroids[p]['distance']:
            best = p
        elif best['distance'] == samp_asteroids[p]['distance']:
            if best['farm_rate'] &lt; samp_asteroids[p]['farm_rate']:
                best = p
    return best
</code></pre>
</div>
<span class="comment-copy">Please reduce your problem to a <a href="https://stackoverflow.com/help/mcve">Minimal verifyable complete example</a>.</span>
<span class="comment-copy">It seems it's possible to go through <code>best_ast</code> without removing anything. Then it will call itself with the same arguments and will never stop doing so, until the stack runs out.</span>
<span class="comment-copy">How many asteroids are there?</span>
<span class="comment-copy">You really need to create a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> with a minimal example of the data you are operating on.  Sometimes just doing this (reducing the code to a minimum that reproduces the symptom) illuminates the problem for you.</span>
<span class="comment-copy">Thanks for pointing that out. I edited the code.</span>
