<div class="post-text" itemprop="text">
<p>I have this one model where I have fetch <code>published count</code> , <code>under process count</code>, <code>rejected count</code>, <code>received count</code> on monthly basis</p>
<pre><code>class PreData(models.Model):

    status=models.CharField(max_length=200,default=None,null=True)

    receivedon=models.DateField(default=None,blank=False,null=True)

    publishedon = models.DateField(default=None, blank=True, null=True)
</code></pre>
<p><code>received count</code> is based on monthly count of <code>receivedon</code> <code>DateField</code> in model, <code>published count</code> is based on monthly count of <code>publishedon</code> <code>DateField</code> in model, <code>rejected count</code> and <code>under process count</code> is based on count of specific <code>status</code> value of <code>CharField</code> in model.</p>
<p>I'm struggling after writing below queries,I'm clueless as to how fetch data to fill the columns(see figure). I'm not sure queries I wrote will help.</p>
<p>The problem comes when I want to zip <code>received_monthly_data</code> and  <code>published_monthly_data</code> but  <code>received_monthly_data</code> has data from April month and <code>published_monthly_data</code> didn't have April month. when i zip , results will loose April month. I am not able to figure how to do this. </p>
<pre><code>received_monthly_data = PreData.objects.filter(journaluser=request.user.username).\
                annotate(month=TruncMonth('receivedon'),year=TruncYear('receivedon')).values('month','year').\
                annotate(c=Count('id')).order_by('-month')

published_monthly_data = PreData.objects.filter(Q(journaluser=request.user.username)&amp;~Q(pdfsenton=None)). \
                annotate(month=TruncMonth('publishedon'), year=TruncYear('publishedon')).values('month', 'year'). \
                annotate(c=Count('id')).order_by('-month')


underproc_data= PreData.objects.filter(Q(journaluser=request.user.username)&amp;~Q(status="[Published]"))
</code></pre>
<p><a href="https://i.stack.imgur.com/OJFfd.png" rel="nofollow noreferrer">I need the data to fill these columns</a></p>
<p>Any help is highly appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps you could use <code>itertools.zip_longest</code> which will zip the longest sequence and will substitute <code>None</code> for the missing values in the shorter sequence. That way you won't lose the April data. </p>
<p>If you wish to use a value other than <code>None</code>, specify the <code>fillvalue</code> argument.</p>
<p>From <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">https://docs.python.org/3/library/itertools.html#itertools.zip_longest</a></p>
<blockquote>
<p>itertools.zip_longest(*iterables, fillvalue=None)</p>
<p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are
  filled-in with fillvalue. Iteration continues until the longest
  iterable is exhausted.</p>
</blockquote>
<p>Note that the function is called <code>itertools.izip_longest</code> in Python 2.</p>
</div>
<span class="comment-copy">That Worked! Thank you very much @Will Keeling.</span>
<span class="comment-copy">How do I access <code>fillvalue</code> arguments value in django templates?</span>
<span class="comment-copy">It would be better to perform the zip in the view before handing the resulting list of data to the template. That way you wouldn't have to deal with the <code>fillvalue</code> in the template itself.</span>
<span class="comment-copy">Yea I have done it the same way, however I couldn't get solution to my problem as zipping and iterating in template is making lot of for loop iterations in template and there's also other problem. So I kinda wanted to know if I can write my own dictionary to populate with only fields I wanted by iterating for loop for like 100 times in view it self? Will this be good?</span>
<span class="comment-copy">Yes that sounds like a reasonable approach. It is always a good idea to keep the logic in the template simple by preprocessing the data in the view.</span>
