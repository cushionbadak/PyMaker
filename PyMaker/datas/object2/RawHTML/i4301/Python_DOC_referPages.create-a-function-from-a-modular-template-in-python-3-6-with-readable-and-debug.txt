<div class="post-text" itemprop="text">
<p>Do you have an idea how to dynamically create a function from a modular template, where the template code is readable, collected in one place and the resulting function code contains only what's needed and shows correctly in the traceback?</p>
<h2>Background</h2>
<p>In the context of a simulation framework I want to dynamically create a function that is <em>called very often</em> (lets say more than a million times) during runtime. The function implements a mathematical expression that is to be evaluated and <em>multiple instances</em> of the function may exist <em>with variations</em> to the actual mathematics and thus function code. An example would be the expression <code>a + b*c</code>, with variations <code>a</code> and <code>a + b</code>, but possibly also <code>a**c</code> instead. The actual equation is more complex and can have more disruptive variations.</p>
<p>The different function instances are defined at initialisation of the simulation and all of them are called in each time step. I thus whish to to minimize the code executed in each function at runtime and not carry around unneccessary luggage. At the same time, I would like to have all variations in one template instead of duplicating the same code with slight variations multiple times. I do not want to need to check every single duplicate if I am making changes to the code. </p>
<p>Lets assume for simplicity, that <code>a, b, c</code> are defined in some outer scope and don't need to be passed explicitly.</p>
<h2>A few example of how I don't want to solve the problem</h2>
<p>1: Always evaluate the maximal equation</p>
<pre><code>def full_equation():
    return a + b*c
</code></pre>
<p>With this solution I have to look up a, b and c in every time step and calculate the summation and product, even if b and c are not needed at all (i.e. set to 0 and 1, respectively). This is extra computation that I would like to avoid. Also, this way the alternative equation <code>a**c</code> is not covered and needs to be implemented in a different function.</p>
<hr/>
<p>2: Implement every possible variation explicitly</p>
<pre><code>def variant_1():
    return a + b*c

def variant_2():
    return a + b

def variant_3():
    return a + b*c

def variant_4():
    return a**c
</code></pre>
<p>Next I would implement a chooser function that checks under which conditions which version of the function needs to be used. This solution minimizes the computational effort at runtime but blows up the codebase considerably for more complex expressions and variations with conditional dependencies between them. If I want to do a minor change to the core expression, I have to track down every single variant and check it individually - which may very easily go wrong. That is why I would like to avoid this solution.</p>
<hr/>
<p>3: Check all conditions at runtime</p>
<pre><code>def function_with_lots_of_ifs(cond_a, cond_b, cond_c):

    if condition_a:
        return a
    else:
        if condition_b:
            return a + b
        elif condition_c:
            return a + b*c
        else: 
            return a**c
</code></pre>
<p>This solution is computationally inefficient, since all conditions need to be checked in every time step. I would like to avoid any <code>if</code>'s in the simulation runtime outside initialisation.</p>
<hr/>
<h2>My current solution that screws up debugging</h2>
<p>What I have resorted to for now is <em>string execution</em>:</p>
<pre><code>def template_builder(cond_a, cond_b, cond_c):

    second_part = ""
    sum_snippet = ""
    product_snippet  = ""

    if not cond_a:
        if cond_b:
            sum_snippet = " + b"
            if cond_c:
                product_snippet = "*c"
            second_part = f"{sum_snippet}{product_snippet}"
        else: 
            second_part = "**c"

    template = f"""
def run_func():
    a{second_part}"""
    return template

print(template_builder(False, True, False))
</code></pre>
<p>This returns <code>'\ndef run_func():\n    a + b'</code>, which can be executed using <code>exec</code> to define the function <code>run_func</code>. So far so good, all code is in one place and the resulting function includes only the code necessary. The code may be rearranged a bit to improve readability, but the main problem with this solution is debugging it, e.g.:</p>
<pre><code>a = "s"
b = 2
c = 3
run_func()
</code></pre>
<p>returns</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-68-6a3db6ea9fbb&gt; in &lt;module&gt;()
      1 a = "s"
----&gt; 2 run_func()

&lt;string&gt; in run_func()

TypeError: must be str, not int
</code></pre>
<p>I can see that some <code>string</code> collided with some <code>int</code> where it shouldn't and that it happened inside my <code>run_func</code>. But I don't know which variant of the function caused the problem and where exactly the error occured (again, imagine the code may be a lot more complex). Does anyone have a suggestion, how to get a proper display of the code in the traceback as you would expect in any of the first three solutions - without their respective issues? Also, I have read in a comment to <a href="https://stackoverflow.com/a/19205645/9674076">this answer</a> that </p>
<blockquote>
<p>Any time you think "I could use exec…" you're almost certainly doing it wrong. </p>
</blockquote>
<p>I am open for suggestions how to do it differently. I have thought about decorators, but couldn't see a way to solve the problem. Also note that nested function calls would be computationally inefficient.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Any time you think "I could use exec…" you're almost certainly doing it wrong.</p>
</blockquote>
<p><em>Almost</em> certainly. String <a href="https://en.wikipedia.org/wiki/Metaprogramming" rel="nofollow noreferrer">metaprogramming</a> is one of those times that it's appropriate to use <code>eval</code> or <code>exec</code>. Even the standard library does this. (See the <a href="https://github.com/python/cpython/blob/b1c70d0ffbb235def1deab62a744ffd9b5253924/Lib/collections/__init__.py#L429" rel="nofollow noreferrer">namedtuple implementation</a>.)</p>
<p>But there are various other ways to do metaprogramming in Python. Given what your concerns are (performance, debugging), you'll want to use the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow noreferrer">ast module</a>.</p>
<p>Using <code>ast</code> correctly is more difficult than metaprogramming with strings. There's a lot of incidental complexity you'd have to figure out. So I'd recommend using a library that abstracts this away.</p>
<p>One of the best ast-based Python metaprogramming libraries I know of is <a href="https://github.com/hylang/hy" rel="nofollow noreferrer">Hy</a>. With Hy macros you can build arbitrary functions at compile time using a fairly simple syntax based on <a href="https://en.wikipedia.org/wiki/S-expression" rel="nofollow noreferrer">s-expressions</a>, a syntax that maps very naturally onto abstract syntax trees.</p>
<p>Here's an example of using Hy macros.</p>
<pre><code>=&gt; (defmacro template-builder [func-name &amp;rest args]
...  `(defn ~func-name[]
...    ~(.format "generated func named {}" func-name)
...    (-&gt; a ~@args)))
from hy import HyExpression, HyList, HySymbol
import hy
hy.macros.macro('template-builder')(lambda hyx_XampersandXname, func_name,
    *args: HyExpression([] + [HySymbol('defn')] + [func_name] + [HyList([])
    ] + ['generated func named {}'.format(func_name)] + [HyExpression([] +
    [HySymbol('-&gt;')] + [HySymbol('a')] + list(args or []))]))

&lt;function &lt;lambda&gt; at 0x00000245B90B5400&gt;
=&gt; (template-builder foo)
def foo():
    """generated func named foo"""
    return a


None

=&gt; (template-builder bar (+ b))
def bar():
    """generated func named bar"""
    return a + b


None

=&gt; (template-builder baz (+ b) (* c))
def baz():
    """generated func named baz"""
    return (a + b) * c


None

=&gt; (template-builder quux (+ b) (** c))
def quux():
    """generated func named quux"""
    return (a + b) ** c


None

=&gt;
</code></pre>
<hr/>
<blockquote>
<p>Thank a lot for your answer! I went a bit through the docs and tried your examples. Seems like a lot of fun. Do I understand correctly, that Hy is meant to be used with it's own lisp-based syntax?</p>
</blockquote>
<p>Yes, although this all ultimately translates to Python (ast), it's not always pretty. You could (in principle) use Hy's models from the Python language to implement macros, without writing s-expressions at all, not that I recommend this. <code>$ hy2py foo.hy</code> will show you the Python translation, and <code>$ hy --spy</code> will do it interactively.</p>
<p>Furthermore, only the ast-manipulation part needs to be written in Hy. Hy compiles to Python ast, which CPython then compiles to its own bytecode, so it has transparent interop with Python. You can import and use modules written in Hy from Python code, just like any other Python module. The end user need not even know it is written in Hy.</p>
<blockquote>
<p>Either way it seems to me, that generating code with Hy is in itself not very readable (in the Python sense). Is that observation correct?</p>
</blockquote>
<p>Lisp is different than Python. Like any language, you have to get used to it, and it's possible to write clear or obfuscated code.</p>
<blockquote>
<p>If yes, it would make it more difficult to maintain the resulting library.</p>
</blockquote>
<p>Not for the reasons you might think. Python's ast is accessible to the end user via the ast module, but it is considered an implementation detail that is subject to change with every Python version. If you do the ast manipulation yourself, you'll have to keep up with this. This is a major advantage of just using <code>exec</code> with strings.</p>
<p>Hy, on the other hand, guarantees ast compatibility will all of Hy's supported Python versions simultaneously. But Hy itself has been going through changes and does not have a completely stable API yet. If you upgrade your Hy version (which may be necessary to keep up with Python) you may have to adapt your Hy code too. This is probably still easier than writing the ast manipulation yourself.</p>
<blockquote>
<p>Since I am working in a scientific context, simplicity/readability of syntax is a rather important feat.</p>
</blockquote>
<p>Lisp's syntax is actually <em>much</em> simpler than Python. That's why it's easier to write macros with. There's no statement/expression distinction. No operator precedence. No indentation levels to keep track of. Everything is a generalized function call with just a little syntactic sugar that expands to these (e.g. <code>'foo</code> expands to <code>(quote foo)</code>, and you can use the latter in a macro definition if it's easier. There's also quasiquote <code>`</code>, which allows unquote <code>~</code> and splicing unquote <code>~@</code> inside, which is the easy way to make macro templates.)</p>
<p>S-expressions absolutely must be indented properly to be human readable--so you know which arguments go with which function even when they're nested deeply. (Play with <a href="https://shaunlebron.github.io/parinfer/" rel="nofollow noreferrer">parinfer</a> until you get it.) The rest is just basic familiarity.</p>
<p>You can already read Python's function call syntax <code>spam(eggs, ham, bacon)</code>. In Lisp you drop the commas (the grammar is simple enough that spaces are sufficient) <code>spam(eggs ham bacon)</code> then move the opening parenthesis one step earlier <code>(spam eggs ham bacon)</code>. That's basically it. Simpler, isn't it?</p>
<p>Hy adds a little more sugar than most other Lisps, like Clojure does, for other data structure types--<code>[1 2 3]</code> for lists <code>{"a" 1  "b" 2}</code> for dicts--using the same bracket types as Python would. And <code>#{1 2 3}</code> for sets.</p>
<p>There is a semantic distinction between a real function/method which evaluates its arguments first, and a macro/special form which may not. But they're all written the same way, like a function call. The rest is just vocabulary, same as importing any other library.</p>
<hr/>
<p>All that said, Hy is not the <em>only</em> ast manipulation library. Try searching PyPI for "ast" to find others.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short answer, I plan to expand when I have more time: </p>
<p>Regarding the original question, I ended up not creating the functions, but rather define a domain specific language (DSL, as suggested by @Gabriel) and parse it into a simple version of an abstract syntax tree (AST, similar to answer by @gilch). The equations are in the end parsed into a tensorflow dataflow graph for computational efficiency. All additional info in the DSL is used to configure the dataflow graph. Dataflow graphs can be visualised for debugging using tensorboard. It takes a bit of time to wrap your head around, but as an interactive graphical representation of all your operations, it already helps a lot. </p>
<p>For now tensorflow is the only implemented backend, but we might also implement a backend based on numpy - which might mean, that we need to create the functions as originally planned. Gabriels suggestion for that was to write the functions to file and then load them, so they can easily be inspected and debugged. Gilch's answer using Hy might also work for that. </p>
</div>
<span class="comment-copy">A million calls isn't that much. An average computer can do a billion simple operations per second. I don't see it anywhere in the post, but are you basing your performance claims on profiler data?</span>
<span class="comment-copy">But anyway, usually "performance" and "debug" are mutually exclusive, which is why there are dev and prod builds for many tools and libraries.</span>
<span class="comment-copy">Wellcome at Stackoverflow! This is a nice first question. I removed some of the "I am new" text, so it focusses on the question. But maybe you want to edit it yourself to move the question part on the top and then go into the details.</span>
<span class="comment-copy">You may be interested in creating an external DSL (domain specific language) for your equations and emit readable Python code from it.</span>
<span class="comment-copy">Yes, that's it. With a DSL you reach a greater level of freedom/flexibility, so you can generate valid Python code with as many information as you wish (things to help you with debugging etc) from an especialized language (you can make the syntax and the semantics of this DSL to be as rich for your usecase as you need it to be!). You'll have a lot more work (you have to create a parser and emit Python code from the generated AST) but I think it's worth it in your case. Long story short: Make a language to express the specific problem domain you're working on. Good luck!</span>
<span class="comment-copy">Thank a lot for your answer! I went a bit through the docs and tried your examples. Seems like a lot of fun. Do I understand correctly, that Hy is meant to be used with it's own lisp-based syntax? Either way it seems to me, that generating code with Hy is in itself not very readable (in the Python sense). Is that observation correct? If yes, it would make it more difficult to maintain the resulting library. Since I am working in a scientific context, simplicity/readability of syntax is a rather important feat.</span>
