<div class="post-text" itemprop="text">
<p>Given a list of data, I'm trying to create a new list in which the value at position <code>i</code> is the length of the longest run starting from position <code>i</code> in the original list. For instance, given</p>
<pre><code>x_list = [1, 1, 2, 3, 3, 3]
</code></pre>
<p>Should return:</p>
<pre><code>run_list = [2, 1, 1, 3, 2, 1]
</code></pre>
<p>My solution: </p>
<pre><code>freq_list = []
current = x_list[0]
count = 0
for num in x_list:
    if num == current:
        count += 1
    else:
        freq_list.append((current,count))
        current = num
        count = 1
freq_list.append((current,count))

run_list = []
for i in freq_list:
    z = i[1]
    while z &gt; 0:
        run_list.append(z)
        z -= 1 
</code></pre>
<p>Firstly I create a list <code>freq_list</code> of tuples, where every tuple's first element is the element from <code>x_list</code>, and where the second element is the number of the total run.  </p>
<p>In this case:</p>
<pre><code>freq_list = [(1, 2), (2, 1), (3, 3)]
</code></pre>
<p>Having this, I create a new list and append appropriate values.</p>
<p>However, I was wondering if there is a shorter way/another way to do this? </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple solution that iterates over the list backwards and increments a counter each time a number is repeated:</p>
<pre><code>last_num = None
result = []
for num in reversed(x_list):
    if num != last_num:
        # if the number changed, reset the counter to 1
        counter = 1
        last_num = num
    else:
        # if the number is the same, increment the counter
        counter += 1

    result.append(counter)

# reverse the result
result = list(reversed(result))
</code></pre>
<p>Result:</p>
<pre><code>[2, 1, 1, 3, 2, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is possible using <code>itertools</code>:</p>
<pre><code>from itertools import groupby, chain

x_list = [1, 1, 2, 3, 3, 3]

gen = (range(len(list(j)), 0, -1) for _, j in groupby(x_list))
res = list(chain.from_iterable(gen))
</code></pre>
<p><strong>Result</strong></p>
<pre><code>[2, 1, 1, 3, 2, 1]
</code></pre>
<p><strong>Explanation</strong></p>
<ul>
<li>First use <code>itertools.groupby</code> to group identical items in your list.</li>
<li>For each item in your <code>groupby</code>, create a <code>range</code> object which counts backwards from the length of the number of consecutive items to 1.</li>
<li>Turn this all into a generator to avoid building a list of lists.</li>
<li>Use <code>itertools.chain</code> to chain the ranges from the generator.</li>
</ul>
<p><strong>Performance note</strong></p>
<p>Performance will be <em>inferior</em> to <a href="https://stackoverflow.com/users/1222951/aran-fey">@Aran-Fey's solution</a>. Although <code>itertools.groupby</code> is O(n), it makes heavy use of expensive <code>__next__</code> calls. These do not scale as well as iteration in simple <code>for</code> loops. See <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools docs</a> for <code>groupby</code> pseudo-code.</p>
<p>If performance is your main concern, stick with the <code>for</code> loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are performing a reverse cumulative count on contiguous groups.  We can create a Numpy cumulative count function with</p>
<pre><code>import numpy as np

def cumcount(a):
    a = np.asarray(a)
    b = np.append(False, a[:-1] != a[1:])
    c = b.cumsum()
    r = np.arange(len(a))
    return r - np.append(0, np.flatnonzero(b))[c] + 1
</code></pre>
<p>and then generate our result with</p>
<pre><code>a = np.array(x_list)

cumcount(a[::-1])[::-1]

array([2, 1, 1, 3, 2, 1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use a generator for this kind of task because it avoids building the resulting list incrementally and can be used lazily if one wanted:</p>
<pre><code>def gen(iterable):  # you have to think about a better name :-)
    iterable = iter(iterable)
    # Get the first element, in case that fails
    # we can stop right now.
    try:
        last_seen = next(iterable)
    except StopIteration:
        return
    count = 1

    # Go through the remaining items
    for item in iterable:
        if item == last_seen:
            count += 1
        else:
            # The consecutive run finished, return the
            # desired values for the run and then reset
            # counter and the new item for the next run.
            yield from range(count, 0, -1)
            count = 1
            last_seen = item
    # Return the result for the last run
    yield from range(count, 0, -1)
</code></pre>
<p>This will also work if the input cannot be <code>reversed</code> (certain generators/iterators cannot be reversed):</p>
<pre><code>&gt;&gt;&gt; x_list = (i for i in range(10))  # it's a generator despite the variable name :-)
&gt;&gt;&gt; ... arans solution ...
TypeError: 'generator' object is not reversible

&gt;&gt;&gt; list(gen((i for i in range(10))))
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
</code></pre>
<p>And it works for your input:</p>
<pre><code>&gt;&gt;&gt; x_list = [1, 1, 2, 3, 3, 3]
&gt;&gt;&gt; list(gen(x_list))
[2, 1, 1, 3, 2, 1]
</code></pre>
<p>This can actually be made simpler by using <code>itertools.groupby</code>:</p>
<pre><code>import itertools

def gen(iterable):
    for _, group in itertools.groupby(iterable):
        length = sum(1 for _ in group)  # or len(list(group))
        yield from range(length, 0, -1)

&gt;&gt;&gt; x_list = [1, 1, 2, 3, 3, 3]
&gt;&gt;&gt; list(gen(x_list))
[2, 1, 1, 3, 2, 1]
</code></pre>
<p>I also did some benchmarks and according to these Aran-Feys solution is the fastest except for long lists where piRSquareds solution wins:</p>
<p><a href="https://i.stack.imgur.com/RnNfS.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/RnNfS.png"/></a></p>
<p>This was my benchmarking setup if you want to confirm the results:</p>
<pre><code>from itertools import groupby, chain
import numpy as np

def gen1(iterable):
    iterable = iter(iterable)
    try:
        last_seen = next(iterable)
    except StopIteration:
        return
    count = 1
    for item in iterable:
        if item == last_seen:
            count += 1
        else:
            yield from range(count, 0, -1)
            count = 1
            last_seen = item
    yield from range(count, 0, -1)

def gen2(iterable):
    for _, group in groupby(iterable):
        length = sum(1 for _ in group)
        yield from range(length, 0, -1)

def mseifert1(iterable):
    return list(gen1(iterable))

def mseifert2(iterable):
    return list(gen2(iterable))

def aran(x_list):
    last_num = None
    result = []
    for num in reversed(x_list):
        if num != last_num:
            counter = 1
            last_num = num
        else:
            counter += 1
        result.append(counter)
    return list(reversed(result))

def jpp(x_list):
    gen = (range(len(list(j)), 0, -1) for _, j in groupby(x_list))
    res = list(chain.from_iterable(gen))
    return res

def cumcount(a):
    a = np.asarray(a)
    b = np.append(False, a[:-1] != a[1:])
    c = b.cumsum()
    r = np.arange(len(a))
    return r - np.append(0, np.flatnonzero(b))[c] + 1

def pirsquared(x_list):
    a = np.array(x_list)
    return cumcount(a[::-1])[::-1]

from simple_benchmark import benchmark
import random

funcs = [mseifert1, mseifert2, aran, jpp, pirsquared]
args = {2**i: [random.randint(0, 5) for _ in range(2**i)] for i in range(1, 20)}

bench = benchmark(funcs, args, "list size")

%matplotlib notebook
bench.plot()
</code></pre>
<p>Python 3.6.5, NumPy 1.14</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple iterative approach to achieve it using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><strong><code>collections.Counter</code></strong></a>:</p>
<pre><code>from collections import Counter

x_list = [1, 1, 2, 3, 3, 3]
x_counter, run_list = Counter(x_list), []

for x in x_list:
    run_list.append(x_counter[x])
    x_counter[x] -= 1
</code></pre>
<p>which will return you <code>run_list</code> as:</p>
<pre><code>[2, 1, 1, 3, 2, 1]
</code></pre>
<hr/>
<p>As an alternative, here's one-liner to achieve this <strong>using <em>list comprehension</em></strong> with <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> but it is not performance efficient due to iterative usage of <code>list.index(..)</code>:</p>
<pre><code>&gt;&gt;&gt; [x_list[i:].count(x) for i, x in enumerate(x_list)]
[2, 1, 1, 3, 2, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can count the consecutive equal items and then add a countdown from count-of-items to 1 to the result:</p>
<pre><code>def runs(p):
    old = p[0]
    n = 0
    q = []
    for x in p:
        if x == old:
            n += 1
        else:
            q.extend(range(n, 0, -1))
            n = 1
            old = x

    q.extend(range(n, 0, -1))

    return q
</code></pre>
<p>(A couple of minutes later) Oh, that's the same as <a href="https://stackoverflow.com/a/49955110/1115360">MSeifert's code</a> but without the iterable aspect. This version seems to be almost as fast as the <a href="https://stackoverflow.com/a/49949931/1115360">method shown by Aran-Fey</a>.</p>
</div>
<span class="comment-copy">Hint: try going through <code>x_list</code> <i>backwards</i>. Do you notice any clear patterns? :)</span>
<span class="comment-copy">I like this answer because a) native python, b) O(n) run time, and c) easy to read/understand</span>
<span class="comment-copy">Could you comment on the Big-O complexity of this approach versus something like @Aran-Fey's answer? My tests using <code>timeit</code> show that this solution takes 5.93 seconds for 1 million evaluation for a list of length 5 whereas @Aran-Fey's answer takes 2.998 seconds (best of 3). For a list of length 10000, your answer takes around 10.54 seconds vs the other answer takes 0.92 seconds for 1000 evaluations. Is groupby followed by iterating on its result making this approach is so expensive?</span>
<span class="comment-copy">@ParagS.Chandakkar, see update.</span>
