<div class="post-text" itemprop="text">
<p>When creating a simple object hierarchy in Python, I'd like to be able to invoke methods of the parent class from a derived class.  In Perl and Java, there is a keyword for this (<a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" rel="noreferrer"><code>super</code></a>).  In Perl, I might do this:</p>
<pre><code>package Foo;

sub frotz {
    return "Bamf";
}

package Bar;
@ISA = qw(Foo);

sub frotz {
   my $str = SUPER::frotz();
   return uc($str);
}
</code></pre>
<p>In python, it appears that I have to name the parent class explicitly from the child.
In the example above, I'd have to do something like <code>Foo::frotz()</code>.  </p>
<p>This doesn't seem right, since this behavior makes it hard to make deep hierarchies.  If children need to know what class defined an inherited method, then all sorts of information pain is created.  </p>
<p>Is this an actual limitation in python, a gap in my understanding or both?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, but only with <a href="http://docs.python.org/glossary.html#term-new-style-class" rel="noreferrer">new-style classes</a>.  Use the <a href="http://docs.python.org/library/functions.html#super" rel="noreferrer"><code>super()</code></a> function:</p>
<pre><code>class Foo(Bar):
    def baz(self, arg):
        return super(Foo, self).baz(arg)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python also has <a href="http://docs.python.org/library/functions.html" rel="noreferrer">super</a> as well: </p>
<p><code><strong>super</strong>(type[, object-or-type])</code></p>
<blockquote>
<p>Return a proxy object that delegates method calls to a parent or sibling class of type.
  This is useful for accessing inherited methods that have been overridden in a class. 
  The search order is same as that used by getattr() except that the type itself is skipped.</p>
</blockquote>
<p>Example: </p>
<pre><code>class A(object):     # deriving from 'object' declares A as a 'new-style-class'
    def foo(self):
        print "foo"

class B(A):
    def foo(self):
        super(B, self).foo()   # calls 'A.foo()'

myB = B()
myB.foo()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>ImmediateParentClass.frotz(self)
</code></pre>
<p>will be just fine, whether the immediate parent class defined <code>frotz</code> itself or inherited it.  <code>super</code> is only needed for proper support of <em>multiple</em> inheritance (and then it only works if every class uses it properly).  In general, <code>AnyClass.whatever</code> is going to look up <code>whatever</code> in <code>AnyClass</code>'s ancestors if <code>AnyClass</code> doesn't define/override it, and this holds true for "child class calling parent's method" as for any other occurrence!</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python 3</strong> has a different and simpler syntax for calling parent method.</p>
<p>If <code>Foo</code> class inherits from <code>Bar</code>, then from <code>Bar.__init__</code> can be invoked from <code>Foo</code> via <code>super().__init__()</code>:</p>
<pre><code>class Foo(Bar):

    def __init__(self, *args, **kwargs):
        # invoke Bar.__init__
        super().__init__(*args, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Many answers have explained how to call a method from the parent which has been overridden in the child.</p>
<p>However </p>
<blockquote>
<p>"how do you call a parent class's method from child class?"</p>
</blockquote>
<p>could also just mean:</p>
<blockquote>
<p>"how do you call inherited methods?" </p>
</blockquote>
<p>You can call methods inherited from a parent class just as if they were methods of the child class, as long as they haven't been overwritten.</p>
<p>e.g. in python 3:</p>
<pre><code>class A():
  def bar(self, string):
    print("Hi, I'm bar, inherited from A"+string)

class B(A):
  def baz(self):
    self.bar(" - called by baz in B")

B().baz() # prints out "Hi, I'm bar, inherited from A - called by baz in B"
</code></pre>
<p>yes, this may be fairly obvious, but I feel that without pointing this out people may leave this thread with the impression you have to jump through ridiculous hoops just to access inherited methods in python. Especially as this question rates highly in searches for "how to access a parent class's method in Python", and the OP is written from the perspective of someone new to python.</p>
<p>I found:
<a href="https://docs.python.org/3/tutorial/classes.html#inheritance" rel="noreferrer">https://docs.python.org/3/tutorial/classes.html#inheritance</a>
to be useful in understanding how you access inherited methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example of using <strong>super()</strong>:</p>
<pre><code>#New-style classes inherit from object, or from another new-style class
class Dog(object):

    name = ''
    moves = []

    def __init__(self, name):
        self.name = name

    def moves_setup(self):
        self.moves.append('walk')
        self.moves.append('run')

    def get_moves(self):
        return self.moves

class Superdog(Dog):

    #Let's try to append new fly ability to our Superdog
    def moves_setup(self):
        #Set default moves by calling method of parent class
        super(Superdog, self).moves_setup()
        self.moves.append('fly')

dog = Superdog('Freddy')
print dog.name # Freddy
dog.moves_setup()
print dog.get_moves() # ['walk', 'run', 'fly']. 
#As you can see our Superdog has all moves defined in the base Dog class
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's a super() in Python too. It's a bit wonky, because of Python's old- and new-style classes, but is quite commonly used e.g. in constructors:</p>
<pre><code>class Foo(Bar):
    def __init__(self):
        super(Foo, self).__init__()
        self.baz = 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would recommend using <code>CLASS.__bases__</code>
something like this</p>
<pre><code>class A:
   def __init__(self):
        print "I am Class %s"%self.__class__.__name__
        for parentClass in self.__class__.__bases__:
              print "   I am inherited from:",parentClass.__name__
              #parentClass.foo(self) &lt;- call parents function with self as first param
class B(A):pass
class C(B):pass
a,b,c = A(),B(),C()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't know how many arguments you might get, and want to pass them all through to the child as well:</p>
<pre><code>class Foo(bar)
    def baz(self, arg, *args, **kwargs):
        # ... Do your thing
        return super(Foo, self).baz(arg, *args, **kwargs)
</code></pre>
<p>(From: <a href="https://stackoverflow.com/questions/5031711/python-cleanest-way-to-override-init-where-an-optional-kwarg-must-be-used">Python - Cleanest way to override __init__ where an optional kwarg must be used after the super() call?</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a super() in python also.</p>
<p>Example for how a super class method is called from a sub class method</p>
<pre><code>class Dog(object):
    name = ''
    moves = []

    def __init__(self, name):
        self.name = name

    def moves_setup(self,x):
        self.moves.append('walk')
        self.moves.append('run')
        self.moves.append(x)
    def get_moves(self):
        return self.moves

class Superdog(Dog):

    #Let's try to append new fly ability to our Superdog
    def moves_setup(self):
        #Set default moves by calling method of parent class
        super().moves_setup("hello world")
        self.moves.append('fly')
dog = Superdog('Freddy')
print (dog.name)
dog.moves_setup()
print (dog.get_moves()) 
</code></pre>
<p>This example is similar to the one explained above.However there is one difference that super doesn't have any arguments passed to it.This above code is executable in python 3.4 version. </p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, I didn't have a lot luck with super().  I used the answer from 
jimifiki on this SO thread <a href="https://stackoverflow.com/questions/9347406/how-to-refer-to-a-parent-method-in-python">how to refer to a parent method in python?</a>.
Then, I added my own little twist to it, which I think is an improvement in usability (Especially if you have long class names).</p>
<p>Define the base class in one module:</p>
<pre><code> # myA.py

class A():     
    def foo( self ):
        print "foo"
</code></pre>
<p>Then import the class into another modules <code>as parent</code>:</p>
<pre><code># myB.py

from myA import A as parent

class B( parent ):
    def foo( self ):
        parent.foo( self )   # calls 'A.foo()'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>in this example cafec_param is a base class (parent class) and abc is a child class. abc calls the AWC method in the base class.</p>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>class cafec_param:

    def __init__(self,precip,pe,awc,nmonths):

        self.precip = precip
        self.pe = pe
        self.awc = awc
        self.nmonths = nmonths

    def AWC(self):

        if self.awc&lt;254:
            Ss = self.awc
            Su = 0
            self.Ss=Ss
        else:
            Ss = 254; Su = self.awc-254
            self.Ss=Ss + Su   
        AWC = Ss + Su
        return self.Ss
         

    def test(self):
        return self.Ss
        #return self.Ss*4

class abc(cafec_param):
    def rr(self):
        return self.AWC()


ee=cafec_param('re',34,56,2)
dd=abc('re',34,56,2)
print(dd.rr())
print(ee.AWC())
print(ee.test())</code></pre>
</div>
</div>
</p>
<p><strong>Output</strong></p>
<p>56</p>
<p>56</p>
<p>56</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class department:
    campus_name="attock"
    def printer(self):
        print(self.campus_name)

class CS_dept(department):
    def overr_CS(self):
        department.printer(self)
        print("i am child class1")

c=CS_dept()
c.overr_CS()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class a(object):
    def my_hello(self):
        print "hello ravi"

class b(a):
    def my_hello(self):
    super(b,self).my_hello()
    print "hi"

obj = b()
obj.my_hello()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a more abstract method:</p>
<pre class="lang-py prettyprint-override"><code>super(self.__class__,self).baz(arg)
</code></pre>
</div>
<span class="comment-copy">I think the naming of the parent class isn't such a bad idea. It can help when the child class inherits from more than one parent, since you explicitly name the parent class.</span>
<span class="comment-copy">While an option to name a class is not a bad idea, being forced to do so certainly is.</span>
<span class="comment-copy">Be aware of the changes in super handling between Python 2 and Python 3 <a href="https://www.python.org/dev/peps/pep-3135/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-3135/</a>. Naming the class is no longer required (although may still be a god idea, at least sometimes).</span>
<span class="comment-copy">Can you not also do "return Bar.baz(self, arg)"? If so, which would be better?</span>
<span class="comment-copy">Yes, you can, but the OP was asking how to do it without explicitly naming the superclass at the call site (Bar, in this case).</span>
<span class="comment-copy">super() is weird with multiple inheritance. It calls to the "next" class. That might be the parent class, or might be some completely unrelated class which appears elsewhere in the hierarchy.</span>
<span class="comment-copy">I use Python 2.x, and I get "Error: must be type, not classobj" when I do this</span>
<span class="comment-copy">The syntax <code>super(Foo, self)</code> is for Python 2.x correct? In Python 3.x, the <code>super()</code> is preferred correct?</span>
<span class="comment-copy">Better example than Adam's because you demonstrated using a new-style class with the object base class. Just missing the link to new-style classes.</span>
<span class="comment-copy">This mandates that the ImmediateParentClass be also present in scope for this statement to be executed. Just having the object imported from a module will not help.</span>
<span class="comment-copy">what if its a class method?</span>
<span class="comment-copy">Good to hear python 3 has a better solution. The question comes from python 2.X.  Thanks for the suggestion though.</span>
<span class="comment-copy">This is what exactly I want to know. Thanks :)</span>
<span class="comment-copy">@gizzmole in what situation does this not work? I'm happy to add any caveats or warnings which are relevant, but I couldn't figure out how the link you posted was relevant to this answer.</span>
<span class="comment-copy">@Ben Sorry, I did not read your answer carefully enough. This answer does not answer the question on how to overload functions, but answers a different question. I deleted my initial comment.</span>
<span class="comment-copy">@gizzmole ah, no worries. I realise that this answer does not apply to overloading functions, however the question does not explicitly mention overloading (though the perl example given does show a case of overloading). The vast majority of other answers cover overloading - this one is here for those people who don't need it.</span>
<span class="comment-copy">@Ben what if I want to call B().baz() from another class named 'C' using vars defined in C?. I tried doing B().baz() in class C, where self.string is another val. It gave me none, when I executed</span>
<span class="comment-copy">Isn't this a bad example? I believe it's not really safe to use Super unless your whole hierarchy is "new style" classes and properly calling Super().init()</span>
<span class="comment-copy">I think you mean: 'super(Foo, self).__init__()'</span>
<span class="comment-copy">oops... indeed i did</span>
<span class="comment-copy">I was looking for something to say me the bases classes. Found here. Thanks!</span>
<span class="comment-copy">Bear in mind that, as you can tell from the volume of references to <b>super</b> here, that folks are really loath to use <b>bases</b> unless you are doing something really deep.  If you don't like <b>super</b>, look at <b>mro</b>.  Taking the first entry in <b>mro</b> is safer than tracking  which entry in <b>bases</b> to use.  Multiple inheritance in Python scans certain things backward and others forward, so letting the language unwind the process is safest.</span>
<span class="comment-copy">You have to use  <code>class A(object):</code>  instead of  <code>class A():</code>   Then super() will work</span>
<span class="comment-copy">I'm not sure I follow.  Do you mean in the definition of the class?  Obviously, you have to indicate a class has a parent somehow in order to think you could to refer to a parent! Since, I posted this 9 months ago, I'm a bit fuzzy n the details, but I think I meant the examples from Arun Ghosh, lawrence, kkk, etc. are not applicable in Py 2.x. Instead, here's a method that works and an easy way to refer to the parent so it's a bit more clear what you're doing. (like using super)</span>
<span class="comment-copy">Welcome to stackoverflow. This question has already been answered in details almost ten years ago now, the answer accepted and largely upvoted, and your answer doesn't add anything new. You may want to try and answer more recent (and preferably unanswered) questions instead. As a side note, there's a button in the editor to apply proper code formatting.</span>
<span class="comment-copy">self.__class__ doesn't work right with super as self is always the instance and its <b>class</b> is always the instance's class.  This means if you use super(self.__class__.. in a class and that class is inherited from, it won't work anymore.</span>
<span class="comment-copy">Just to emphasize, DO NOT USE THIS CODE. It defeats the entire purpose of super(), which is to correctly traverse the MRO.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/19257335/419348">stackoverflow.com/a/19257335/419348</a> said why not call <code>super(self.__class__, self).baz(arg)</code>.</span>
