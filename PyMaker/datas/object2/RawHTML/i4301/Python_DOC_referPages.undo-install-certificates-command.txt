<div class="post-text" itemprop="text">
<p>In Python 3.6+ on Mac, various SSL-related operations will fail (typically with a cryptic <code>SSL: CERTIFICATE_VERIFY_FAILED</code> error) until you run <code>/Applications/Python\ 3.6/Install\ Certificates.command</code> to install root certificates. After encountering such an error, I Googled, eventually discovered this solution (which is noted at, e.g. <a href="https://bugs.python.org/issue29065#msg283984" rel="noreferrer">https://bugs.python.org/issue29065#msg283984</a>), did it, and it worked.</p>
<p>But now I'd like to tweak my code to catch the error I was seeing before and show a helpful error message explaining to the user that they need to run <code>/Applications/Python\ 3.6/Install\ Certificates.command</code>. I can't easily test this error-handling code, though, since, having run the command, I no longer get the SSL error that I want to catch.</p>
<p>How can I <em>uninstall</em> the certificates that were installed by <code>Install Certificates.command</code> in order to perform such testing?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>.command</code> file is (generally) just a shell script that gets special handling if double-clicked in the Finder because of its extension. So, if you want to know what one does, just read it. In this case, it's actually a bare wrapper around a Python script, which makes it even easier (since you presumably know Python even better than sh).</p>
<p>The key part is this:</p>
<pre><code>openssl_dir, openssl_cafile = os.path.split(
    ssl.get_default_verify_paths().openssl_cafile)
# ...
os.symlink(relpath_to_certifi_cafile, openssl_cafile)
</code></pre>
<hr/>
<p>Now that you know it's using <a href="https://docs.python.org/3/library/ssl.html#ssl.get_default_verify_paths" rel="noreferrer"><code>get_default_verify_paths</code></a>, it's obvious why this is relevant, and how to check the same path. The default path is <code>/Library/Frameworks/Python.framework/Versions/3.6/etc/openssl/cert.pem</code>, but that doesn't matter; the <code>ssl</code> module and the setup tool both just use the function to get the path, and you can too.</p>
<p>And to uninstall, just delete that cert:</p>
<pre><code>os.remove(openssl_cafile)
</code></pre>
<p>â€¦ or, maybe, just rename it, so you can go back and forth between "installed" and "uninstalled" state as you're testing.</p>
<hr/>
<p>Meanwhile, it's not <em>quite</em> as simple as it seems to test for this situation usefully, because there are <em>four</em> possibilities, not just two:</p>
<ol>
<li>No <code>cert.pem</code>.</li>
<li><code>cert.pem</code> linked to a file from the <code>certifi</code> package directory because the user used this command correctly.</li>
<li><code>cert.pem</code> not linked to that file, but still correct, because the user fixed it manually (or because the user is running your program in 2021, and things have changed about how Python installs SSL CAs).</li>
<li><code>cert.pem</code> not linked to that file, and incorrect, because the user tried to fix it manually but got it wrong.</li>
</ol>
<p>For a LBYL validation of the user's setup, I'd just check for existence to avoid choking on case 3:</p>
<pre><code>cafile = ssl.get_default_verify_paths().openssl_cafile
assert os.path.exists(cafile)
</code></pre>
<p>On the other hand, after you get SSL failures, and you want to EAFP-diagnose the setup to help the user, you can do something like this:</p>
<pre><code>cafile = ssl.get_default_verify_paths().openssl_cafile
catarget = os.readlink(cafile)
cadir = os.path.basename(os.path.dirname(catarget))
assert cadir == 'certifi'
</code></pre>
<p>(Either way, you obviously want better error handling than this.)</p>
</div>
