<div class="post-text" itemprop="text">
<p>I have the following simplified scheme:</p>
<pre><code>class NetworkAnalyzer(object):
    def __init__(self):
       print('is _score_funct implemented?')

    @staticmethod
    def _score_funct(network):
        raise NotImplementedError

class LS(NetworkAnalyzer):
    @staticmethod
    def _score_funct(network):
        return network
</code></pre>
<p>and I am looking for what I should use instead of <code>print('is _score_funct implemented?')</code> in order to figure out if a subclass has already implemented <code>_score_funct(network)</code> or not. </p>
<p><em>Note: If there is a more pythonic/conventional way of structuring the code, I would also appreciate its mention. The reason I defined it this way is, some NetworkAnalyzer subclasses have _score_funct in their definition, and the ones that dont have it will have different initialization of variables although they will have the same structure</em></p>
</div>
<div class="post-text" itemprop="text">
<p>Use an abstract base class and you won't be able to instantiate the class unless it implements all of the abstract methods:</p>
<pre><code>import abc

class NetworkAnalyzerInterface(abc.ABC):
    @staticmethod
    @abc.abstractmethod
    def _score_funct(network):
        pass

class NetworkAnalyzer(NetworkAnalyzerInterface):
    def __init__(self):
        pass

class LS(NetworkAnalyzer):
    @staticmethod
    def _score_funct(network):
        return network

class Bad(NetworkAnalyzer):
    pass

ls = LS()   # Ok
b = Bad()   # raises TypeError: Can't instantiate abstract class Bad with abstract methods _score_funct
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not a metaclass/class specialist but here's a method that works in your simple case (not sure it works as-is in a complex/nested class namespace):</p>
<p>To check if the method was overridden, you could try a <code>getattr</code> on the function name, then check the qualified name (class part is enough using string partitionning):</p>
<pre><code>class NetworkAnalyzer(object):
    def __init__(self):
        funcname = "_score_funct"
        d = getattr(self,funcname)
        print(d.__qualname__.partition(".")[0] == self.__class__.__name__)
</code></pre>
<p>if <code>_score_funct</code> is defined in <code>LS</code>, <code>d.__qualname__</code> is <code>LS._score_funct</code>, else it's <code>NetworkAnalyzer._score_funct</code>.</p>
<p>That works if the method is implemented at <code>LS</code> class level. Else you could replace by:</p>
<pre><code>d.__qualname__.partition(".")[0] != "NetworkAnalyzer"
</code></pre>
<p>Of course if the method is overridden with some code which raises an <code>NotImplementedError</code>, that won't work... This method doesn't inspect methods code (which is hazardous anyway)</p>
</div>
<span class="comment-copy">abstract methods? <a href="https://stackoverflow.com/questions/4382945/abstract-methods-in-python" title="abstract methods in python">stackoverflow.com/questions/4382945/abstract-methods-in-python</a></span>
<span class="comment-copy">Well you could take a look at the AST and look if there is only a single raise statement and the only constant is <code>NotImplementedError</code>.</span>
<span class="comment-copy">I would suggest you figure out the minimal behavior for each subclass and turn that into an abstract base class. See <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">the abc docs</a> . Research <a href="https://stackoverflow.com/q/56860/2958070">Liskov Substitution Principle</a> .</span>
<span class="comment-copy">Why not just <i>not</i> implement the function in the base class and in <code>__init__</code> use <code>getattr()</code> and <code>callable()</code> to check if it exists and can be called?</span>
<span class="comment-copy">I havent used abstract methods as I had little understanding of metaclasses. I will read the documentation to have it more conventional. By then, I have tried @Jean-Fran√ßoisFabre's answer and it works</span>
<span class="comment-copy">Do I need the NetworkAnalyzerInterface in this example by any conventional reason or can I just bypass it by <code>NetworkAnalyzer(abc.ABC)</code></span>
<span class="comment-copy">You can probably just make NetworkAnalyzer itself the abstract class in this case. I would just prefer to keep interface and implementation code separate although in the example I ended up with there's no implementation code.</span>
