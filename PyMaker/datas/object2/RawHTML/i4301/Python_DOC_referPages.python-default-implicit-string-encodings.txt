<div class="post-text" itemprop="text">
<p>When, where and how does Python implicitly apply encodings to strings or does implicit transcodings (conversions)?</p>
<p>And what those "default" (i.e. implied) encodings are?</p>
<p>For example, what are the encodings:</p>
<ul>
<li><p>of string literals?</p>
<pre><code>s = "Byte string with national characters"
us = u"Unicode string with national characters"
</code></pre></li>
<li><p>of byte strings when type-converted to and from Unicode?</p>
<pre><code>data = unicode(random_byte_string)
</code></pre></li>
<li><p>when byte- and Unicode strings are written to/from a file or a terminal?</p>
<pre><code>print(open("The full text of War and Peace.txt").read())
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>There are multiple parts of Python's functionality involved here: <strong>reading the source code and parsing the string literals</strong>, <strong>transcoding</strong>, and <strong>printing</strong>. Each has its own conventions.</p>
<p>Short answer:</p>
<ul>
<li>For the purpose of code parsing:

<ul>
<li><code>str</code>(Py2) -- not applicable, raw bytes from the file are taken</li>
<li><code>unicode</code>(Py2)/<code>str</code>(Py3) -- "source encoding", defaults are <code>ascii</code>(Py2) and <code>utf-8</code>(Py3)</li>
<li><code>bytes</code>(Py3) -- none, non-ascii characters are prohibited in the literal</li>
</ul></li>
<li>For the purpose of transcoding:

<ul>
<li>both(Py2) -- <code>sys.getdefaultencoding()</code> (<code>ascii</code> almost always)

<ul>
<li>there are implicit conversions which often result in a <code>UnicodeDecodeError</code>/<code>UnicodeEncodeError</code></li>
</ul></li>
<li>both(Py3) -- none, must specify encoding explicitly when converting</li>
</ul></li>
<li>For the purpose of I/O:

<ul>
<li><code>unicode</code>(Py2) -- <code>&lt;file&gt;.encoding</code> if set, otherwise <code>sys.getdefaultencoding()</code></li>
<li><code>str</code>(Py2) -- not applicable, raw bytes are written</li>
<li><code>str</code>(Py3) -- <code>&lt;file&gt;.encoding</code>, always set and defaults to <code>locale.getpreferredencoding()</code></li>
<li><code>bytes</code>(Py3) -- none, <code>print</code>ing produces its <code>repr()</code> instead</li>
</ul></li>
</ul>
<hr/>
<p>First of all, some terminology clarification so that you understand the rest correctly. <strong>Decoding</strong> is translation from <em>bytes</em> to <em>characters (Unicode or otherwise)</em>, and <strong>encoding</strong> (as a process) is the reverse. See <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/" rel="nofollow noreferrer">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) – Joel on Software</a> to get the distinction.</p>
<p>Now...</p>
<h1>Reading the source and parsing string literals</h1>
<p><a href="https://www.python.org/dev/peps/pep-0263/" rel="nofollow noreferrer">At the start of a source file, you can specify the file's "source encoding"</a> (its exact effect is decribed later). If not specified, the default is <code>ascii</code> for Python 2 and <code>utf-8</code> for Python 3. A UTF-8 BOM has the same effect as a <code>utf-8</code> encoding declaration.</p>
<h2>Python 2</h2>
<p>Python 2 reads the source as raw bytes. It only uses the "source encoding" to parse a Unicode literal when it sees one. (<a href="https://github.com/python/cpython/blob/2.7/Parser/tokenizer.c#L507" rel="nofollow noreferrer">It's more complicated than that under the hood</a> but this is the net effect.)</p>
<pre><code>&gt; type t.py
#encoding: cp1251
s = "абвгд"
us = u"абвгд"
print repr(s), repr(us)
&gt; py -2 t.py
'\xe0\xe1\xe2\xe3\xe4' u'\u0430\u0431\u0432\u0433\u0434'

&lt;change encoding declaration in the file to cp866, do not change the contents&gt;
&gt; py -2 t.py
'\xe0\xe1\xe2\xe3\xe4' u'\u0440\u0441\u0442\u0443\u0444'

&lt;transcode the file to utf-8, update declaration or replace with BOM&gt;
&gt; py -2 t.py
'\xd0\xb0\xd0\xb1\xd0\xb2\xd0\xb3\xd0\xb4' u'\u0430\u0431\u0432\u0433\u0434'    
</code></pre>
<p>So, <strong>regular strings will contain the exact bytes that are in the file.</strong> And <strong>Unicode strings will contain the result of decoding the file's bytes with the "source encoding".</strong></p>
<p>If the decoding fails, you will get a <code>SyntaxError</code>. Same if there is a non-ascii character in the file when there's no encoding specified. Finally, if <a href="https://docs.python.org/2/library/__future__.html?highlight=unicode_literals" rel="nofollow noreferrer"><code>unicode_literals</code> future</a> is used, any regular string literals (<a href="https://docs.python.org/2/reference/simple_stmts.html#future-statements" rel="nofollow noreferrer">in that file only</a>) are treated as Unicode literals when parsing, with all what that means.</p>
<h2>Python 3</h2>
<p>Python 3 decodes the entire source file with the "source encoding" into a sequence of Unicode characters. Any parsing is done after that. (In particular, this makes it possible to have Unicode in identifiers.) Since all string literals are now Unicode, no additional transcoding is needed. In byte literals, non-ascii characters are prohibited (such bytes must be specified with escape sequences), evading the issue altogether.</p>
<h1>Transcoding</h1>
<p>As per the clarification at the start:</p>
<ul>
<li><code>str</code> -- <em>bytes</em> =&gt; can only be <code>decode</code>d <sub>(directly, that is; details follow)</sub></li>
<li><code>unicode</code> -- <em>characters</em> =&gt; can only be <code>encode</code>d</li>
</ul>
<h2>Python 2</h2>
<p>In both cases, if the encoding is not specified, <code>sys.getdefaultencoding()</code> is used. It is <code>ascii</code> <sub>(unless you uncomment a code chunk in <code>site.py</code>, <a href="https://stackoverflow.com/questions/2276200/changing-default-encoding-of-python">or do some other hacks</a> which <a href="https://stackoverflow.com/questions/3828723/why-should-we-not-use-sys-setdefaultencodingutf-8-in-a-py-script?noredirect=1&amp;lq=1">are a recipe for disaster</a>)</sub>. So, <strong>for the purpose of transcoding, <code>sys.getdefaultencoding()</code> is the "string's default encoding".</strong></p>
<p>Now, here's a caveat:</p>
<ul>
<li><p><strong>a <code>decode()</code> and <code>encode()</code> -- with the default encoding -- is done implicitly when converting <code>str&lt;-&gt;unicode</code>:</strong></p>
<ul>
<li>in string formatting (a third of <code>UnicodeDecodeError</code>/<code>UnicodeEncodeError</code> questions on SO are about this)</li>
<li>when trying to <code>encode()</code> a <code>str</code> or <code>decode()</code> a <code>unicode</code> (the 2nd third of the SO questions)</li>
</ul></li>
</ul>
<h2>Python 3</h2>
<p>There's no "default encoding" at all: implicit conversion between <code>str</code> and <code>bytes</code> is now prohibited.<br/>
(As the number of SO questions from confused users testify, it proved to be more trouble than it's worth.)</p>
<ul>
<li><code>bytes</code> can only be <code>decode</code>d and <code>str</code> -- <code>encode</code>d, and the <code>encoding</code> argument is mandatory.</li>
<li>converting <code>bytes-&gt;str</code> (incl. implicitly) produces its <code>repr()</code> instead (which is only useful for printing), evading the encoding issue entirely</li>
<li>converting <code>str-&gt;bytes</code> is prohibited</li>
</ul>
<h1>Printing</h1>
<p><a href="https://stackoverflow.com/questions/2596714/why-does-python-print-unicode-characters-when-the-default-encoding-is-ascii">This matter</a> is unrelated to a variable's value but related to what you would see on the screen when it's <code>print</code>ed -- and whether you will get a <code>UnicodeEncodeError</code> when <code>print</code>ing.</p>
<h2>Python 2</h2>
<ul>
<li>A <code>unicode</code> is <code>encode</code>d with <code>&lt;file&gt;.encoding</code> if set; otherwise, it's implicitly converted to <code>str</code> as per the above. (The final third of the <code>UnicodeEncodeError</code> SO questions fall into here.)

<ul>
<li>For standard streams, the stream's encoding is guessed at startup from various environment-specific sources, and can be overridden with the <code>PYTHONIOENCODING</code> envvar.</li>
</ul></li>
<li><code>str</code>'s bytes are sent to the OS stream as-is. What specific characters you will see on the screen depends on your terminal's encoding (if it's something like UTF-8, you may see nothing at all if you print a byte sequence that is invalid UTF-8).</li>
</ul>
<h2>Python 3</h2>
<p>The changes are:</p>
<ul>
<li>Now <code>file</code>s opened with text vs binary <code>mode</code> natively accept <code>str</code> or <code>bytes</code>, correspondingly, and outright refuse to process the wrong type. Text-mode files always have an <code>encoding</code> set, <a href="https://docs.python.org/3/library/functions.html?highlight=open#open" rel="nofollow noreferrer"><code>locale.getpreferredencoding(False)</code> being the default</a>.</li>
<li><code>print</code> for text streams still implicitly converts everything to <code>str</code>, which in the case of <code>bytes</code> prints its <code>repr()</code> as per the above, evading the encoding issue altogether</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><em>Implicit encoding</em> as <em>internal format to store strings/arrays</em>: you should not care about the encoding. In fact Python <em>decodes</em> characters in Python internal way.  It is mostly transparent. Just image that it is a Unicode text, or a sequence of bytes, in abstract way.</p>
<p>The internal coding on Python 3.x varies according the "larger" character. It could be UTF-8/ASCII (for ASCII strings), UTF-16 or UTF-32. When you are using strings, it is like you have a Unicode String (so abstract, not a real encoding). If you do not program in C or you use some special functions (memory view), you will never be able to see the internal encoding.</p>
<p>Bytes are just a view of actual memory. Python interprets is as <code>unsigned char</code>. But again, often you should just think about what the sequence it is, not on internal encoding.</p>
<p>Python2 has bytes and string as unsigned char, and unicode as UCS-2 (so code points above 65535 will be coded with 2 characters (UCS2) in Python2, and just one character (UTF-32) in Python3)</p>
</div>
<span class="comment-copy">Do you really need to know about both Python 2.x and 3.x? Because the answers are very different—and a lot simpler, for 3.x, and even simpler for 3.7+.</span>
<span class="comment-copy"><a href="https://meta.stackoverflow.com/questions/366346/canonical-answer-about-python-string-default-implicit-encodings-conversions">This is meant as a canonical answer on this topic</a> -- so yes, I do.</span>
<span class="comment-copy">Speaking of 3.7+, I do not know anything about that, so you're welcome to add the differences.</span>
<span class="comment-copy">Wouldn’t it be better to have separate canonical answers (linked to each other at the top) for 2.x and 3.x? That way, people who have problems with 3.x who aren’t porting or writing cross-version code don’t need to slog through a whole bunch of stuff that’s confusing and irrelevant to them just to find the part that does matter for their code.</span>
<span class="comment-copy">That's better discussed in the meta topic. So far, I've received nothing but support for the post as it is.</span>
