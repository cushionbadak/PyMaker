<div class="post-text" itemprop="text">
<p>I'm trying to practice Python exercises, but using list comprehension to solve problems rather than the beginner style loops shown in the book. There is one example where it asks for a list of numbers to be put into a list of even numbers only, BUT they must be in sublists so that if the numbers follow after one another without being interrupted by an odd number, they should be put into a sublist together:</p>
<pre><code>my_list = [2,3,5,7,8,9,10,12,14,15,17,25,31,32]
desired_output = [[2],[8],[10,12,14],[32]]
</code></pre>
<p>So you can see in the desired output above, 10,12,14 are evens that follow on from one another without being interrupted by an odd, so they get put into a sublist together. 8 has an odd on either side of it, so it gets put into a sublist alone after the odds are removed.</p>
<p>I can put together an evens list easily using list comprehension like this below, but I have no idea how to get it into sublists like the desired output shows. Could someone please suggest an idea for this using list comprehension (or generators, I don't mind which as I'm trying to learn both at the moment). Thanks!</p>
<pre><code>evens = [x for x in my_list if x%2==0]
print(evens)
[2, 8, 10, 12, 14, 32]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As explained in the comments, list comprehensions should not be deemed "for beginners" - first focus on writing your logic using simple <code>for</code> loops.</p>
<p>When you're ready, you can look at comprehension-based methods. Here's one:</p>
<pre><code>from itertools import groupby

my_list = [2,3,5,7,8,9,10,12,14,15,17,25,31,32]

condition = lambda x: all(i%2==0 for i in x)
grouper = (list(j) for _, j in groupby(my_list, key=lambda x: x%2))

res = filter(condition, grouper)

print(list(res))

# [[2], [8], [10, 12, 14], [32]]
</code></pre>
<p>The main point to note in this solution is nothing is computed until you call <code>list(res)</code>. This is because <code>filter</code> and generator comprehensions are lazy.</p>
</div>
<div class="post-text" itemprop="text">
<p>You mentioned also wanting to learn generators, so here is a version that's also a bit more readable, imho.</p>
<pre><code>from itertools import groupby


def is_even(n):
    return n%2 == 0


def runs(lst):
    for even, run in groupby(lst, key=is_even):
        if even:
            yield list(run)


if __name__ == '__main__':
    lst = [2, 3, 5, 7, 8, 9, 10, 12, 14, 15, 17, 25, 31, 32]
    res = list(runs(lst))
    print(res)
</code></pre>
<p>Incidentally, if you absolutely, positively want to implement it as a list comprehension, this solutions falls out of the above quite naturally:</p>
<pre><code>[list(run) for even, run in groupby(lst, key=is_even) if even]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use itertools, there's another way to do it with list comprehensions. </p>
<p>First, take the indices of the odd elements:</p>
<pre><code>[i for i,x in enumerate(my_list) if x%2==1]
</code></pre>
<p>And add two sentinels: <code>[-1]</code> before and <code>[len(my_list)]</code> after:</p>
<pre><code>odd_indices = [-1]+[i for i,x in enumerate(my_list) if x%2==1]+[len(my_list)]
# [-1, 1, 2, 3, 5, 9, 10, 11, 12, 14]
</code></pre>
<p>You have now something like that:</p>
<pre><code> [2,3,5,7,8,9,10,12,14,15,17,25,31,32]
^---^-^-^---^-----------^--^--^--^----^
</code></pre>
<p>You can see your sequences. Now, take the elements between those indices. To do that, zip <code>odd_indices</code> with itself to get the intervals as tuples:</p>
<pre><code>zip(odd_indices, odd_indices[1:])
# [(-1, 1), (1, 2), (2, 3), (3, 5), (5, 9), (9, 10), (10, 11), (11, 12), (12, 14)]    

even_groups = [my_list[a+1:b] for a,b in zip(odd_indices, odd_indices[1:])]
# [[2], [], [], [8], [10, 12, 14], [], [], [], [32]]
</code></pre>
<p>You just have to filter the non empty lists:</p>
<pre><code>even_groups = [my_list[a+1:b] for a,b in zip(odd_indices, odd_indices[1:]) if a+1&lt;b]
# [[2], [8], [10, 12, 14], [32]]
</code></pre>
<p>You can merge the two steps into one comprehension list, but that is a bit unreadable:</p>
<pre><code>&gt;&gt;&gt; my_list = [2,3,5,7,8,9,10,12,14,15,17,25,31,32]
&gt;&gt;&gt; [my_list[a+1:b] for l1 in [[-1]+[i for i,x in enumerate(my_list) if x%2==1]+[len(my_list)]] for a,b in zip(l1, l1[1:]) if b&gt;a+1]
[[2], [8], [10, 12, 14], [32]]
</code></pre>
<p>As pointed by @jpp, prefer basic loops until you feel comfortable. And maybe avoid those nested list comprehensions forever... </p>
</div>
<span class="comment-copy">there is nothing "beginner style" about for-loops. for this particular problem, use <code>itertools.groupby()</code></span>
<span class="comment-copy">I would recommend learning the old loops first, it's the base. (Assuming you started right with the Comprehensions)</span>
<span class="comment-copy">Thanks very much for adding this solution. My book introduces list comprehension in Chapt 4, so I viewed it as being still quite beginner compared to the scarier topics in the back of the book (and I have a bit of beginner impatience also). The book has covered lambda already and keys, but I haven't seen groupby yet (although I'm used to using groupby in SQL).</span>
<span class="comment-copy">@Shaken_not_stirred, You might find the <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">docs</a> on <code>itertools.groupby</code> useful.</span>
<span class="comment-copy">That's a good alternative too. I understand the concept of defining functions and yield. I'll just have to read up on <i>name</i> and <i>main</i> again (I have seen them, I just haven't used them yet).</span>
<span class="comment-copy">Thanks for breaking it down into easily digestible chunks. It makes it much easier to understand.</span>
