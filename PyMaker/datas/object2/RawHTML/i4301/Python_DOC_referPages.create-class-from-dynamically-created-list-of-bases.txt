<div class="post-text" itemprop="text">
<p>Is there any way to create a class from a dynamic list of base classes?</p>
<pre><code>def dynamic_class_creator(base, base2):
    class Derived(base, base2):
        pass
    return Derived

class Mixin1(object):
    def greet(self):
        print ("Howdy!")

class Mixin1a(object):
    def insult(self):
        print ("You have a lot to learn.")

class Mixin2(object):
    def insult(self):
        print ("Idiot!")

polite = dynamic_class_creator(Mixin1, Mixin1a)()
polite.greet()
polite.insult()

complex = dynamic_class_creator(Mixin1, Mixin2)()
complex.greet()
complex.insult()
</code></pre>
<p>This works as expected:</p>
<pre><code>Howdy!                    
You have a lot to learn.  
Howdy!                    
Idiot!
</code></pre>
<p>But I can't figure out how to assign these bases from a list of arbitrary length:</p>
<pre><code>def dynamic_class_creator(*bases):
    class Derived(*bases):
        pass
    return Derived
(...)
</code></pre>
<p>gives:</p>
<pre><code>  File "../test2.py", line 4
    class Derived(*bases):  
                  ^         
SyntaxError: invalid syntax 
</code></pre>
<p><strong>EDIT</strong></p>
<p>One suggested solution:</p>
<pre><code>def dynamic_class_creator(*bases):
    class Derived(bases):
        pass
    return Derived
(...)
</code></pre>
<p>Gives:</p>
<pre><code>Traceback (most recent call last):
  File "../test2.py", line 20, in &lt;module&gt;
    polite = dynamic_class_creator(Mixin1, Mixin1a)()
  File "../test2.py", line 4, in dynamic_class_creator
    class Derived(bases):
TypeError: Error when calling the metaclass bases
    tuple() takes at most 1 argument (3 given)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the three-argument form of the <code>type()</code> constructor. Quoting <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow noreferrer">the documentation</a>, "<em>With three arguments, return a new type object. This is essentially a dynamic form of the <code>class</code> statement.</em>"</p>
<pre><code># TESTED with Python3
def dynamic_class_creator(*bases):
    return type('Derived', bases, {})
</code></pre>
<p>The problem with the above is that you lose the <code>class</code> syntax. This makes it difficult, for example, to add methods to <code>Derived</code>.</p>
<p>You can keep the nice syntax of class declaration, and <em>still</em> modify the call to <code>type()</code> by using a <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">metaclass</a>.</p>
<p>Here is a complete example, demonstrating the use of <code>metaclass=</code>, <code>type()</code>, and both regular and mix-in base classes.</p>
<pre><code># TESTED with Python3
def dynamic_class_creator(*mixins):
    def metaclass(name, bases, members):
        return type(name, bases + mixins, members)

    class Derived(BaseClass, metaclass=metaclass):
        def praise(self):
            print("Good job!")

    return Derived

class BaseClass(object):
    def goodbye(self):
        print("Goodbye!")

class Mixin1(object):
    def greet(self):
        print("Howdy!")

class Mixin1a(object):
    def insult(self):
        print("You have a lot to learn.")

class Mixin2(object):
    def insult(self):
        print("Idiot!")

polite = dynamic_class_creator(Mixin1, Mixin1a)()
polite.greet()
polite.insult()
polite.praise()
polite.goodbye()

complex = dynamic_class_creator(Mixin1, Mixin2)()
complex.greet()
complex.insult()
</code></pre>
<p>You can pass arbitrary keywords to the metaclass function. Consider this example:</p>
<pre><code># TESTED with Python3
def mixin_metaclass(name, bases, members, mixins):
    return type(name, bases+mixins, members)

def dynamic_class_creator(*mixins):
    class Derived(metaclass=mixin_metaclass, mixins=mixins):
        pass
    return Derived
</code></pre>
<p>Finally, note that all of the above examples are tested with Python3. Here is a Python2 version:</p>
<pre><code># TESTED with Python2
def dynamic_class_creator(*mixins):
    def metaclass(name, bases, members):
        return type(name, mixins+bases, members)
    class Derived(object):
        __metaclass__ = metaclass
        def praise(self):
            print("Good job!")
    return Derived
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of completeness, here is a solution based on Robáµ©'s if you are already using another metaclass (as I am):</p>
<p><strong>Python 3</strong></p>
<pre><code>def mixin_metaclass(name, bases, members, mixins, super_meta=type):
    return super_meta(name, bases + mixins, members)

def dynamic_class_creator(*mixins):
    class Derived(metaclass=mixin_metaclass, mixins=mixins, super_meta=MyMeta):
        pass
    return Derived
</code></pre>
<p><strong>Python 2</strong></p>
<pre><code>def mixin_meta(super_meta, *mixins):
    def _meta(name, bases, members):
        return super_meta(name, mixins + bases, members)
    return _meta

def dynamic_class_creator(*mixins):
    class Derived(object):
        __metaclass__ = mixin_meta(MyMeta, *mixins)
    return Derived
</code></pre>
</div>
<span class="comment-copy">Thanks! The only thing is that I am coding for python 2 (internal limitation). So I have to do <code>__metaclass__ = metaclass</code>. Also, if I want to make sure <code>Derived</code> is a subclass of <code>object</code>, it needs to be <code>... tuple(mixins) + bases...</code>, otherwise then MRO fails. But this totally works.</span>
<span class="comment-copy">Thanks for your comment. I've added a Python2 example.</span>
