<div class="post-text" itemprop="text">
<p>I have multiple data frames that I saved in a concatenated list like below. Each df represents a matrix.</p>
<pre><code>my_df = pd.concat([df1, df2, df3, .....])
</code></pre>
<p>How do I sum all these dfs (matrices) into one df (matrix)? </p>
<p>I found a <a href="https://stackoverflow.com/questions/11106823/adding-two-pandas-dataframes">discussion here</a>, but it only answers how to add two data frames, by using code like below.</p>
<pre><code>df_x.add(df_y, fill_value=0)
</code></pre>
<p>Should I use the code above in a loop, or is there a more concise way?</p>
<p>I tried to do <code>print(my_df.sum())</code> but got a very confusing result (it's suddenly turned into a one row instead of two-dimensional matrix).</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>One method is to use <code>sum</code> with a list of arrays. The output here will be an array rather than a dataframe.</p>
<p>This assumes you need to replace <code>np.nan</code> with 0:</p>
<pre><code>res = sum([x.fillna(0).values for x in [df1, df2, df3]])
</code></pre>
<p>Alternatively, you can use <code>numpy</code> directly in a couple of different ways:</p>
<pre><code>res_np1 = np.add.reduce([x.fillna(0).values for x in [df1, df2, df3]])

res_np2 = np.nansum([x.values for x in [df1, df2, df3]], axis=0)
</code></pre>
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.nansum.html" rel="nofollow noreferrer"><code>numpy.nansum</code></a> assumes <code>np.nan</code> equals zero for summing purposes.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe need <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce</code></a> if each <code>DataFrame</code> in <code>list</code> have same index and columns values:</p>
<pre><code>np.random.seed(2018)

df1 = pd.DataFrame(np.random.choice([1,np.nan,2], size=(3,3)), columns=list('abc'))
df2 = pd.DataFrame(np.random.choice([1,np.nan,3], size=(3,3)), columns=list('abc'))
df3 = pd.DataFrame(np.random.choice([1,np.nan,4], size=(3,3)), columns=list('abc'))
print (df1)
     a    b    c
0  2.0  2.0  2.0
1  NaN  NaN  1.0
2  1.0  2.0  NaN

print (df2)
     a    b    c
0  NaN  NaN  1.0
1  3.0  3.0  3.0
2  NaN  1.0  3.0

print (df3)
     a    b    c
0  4.0  NaN  NaN
1  4.0  1.0  1.0
2  4.0  NaN  1.0

from functools import reduce

my_df = [df1,df2, df3]

df = reduce(lambda x, y: x.add(y, fill_value=0), my_df)
print (df)
     a    b    c
0  6.0  2.0  3.0
1  7.0  4.0  5.0
2  5.0  3.0  4.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I believe the idiomatic solution to this is to preserve the information about different DataFrames with the help of the <code>keys</code> parameter and then use sum on the innermost level:</p>
<pre><code>dfs = [df1, df2, df3]
my_df = pd.concat(dfs, keys=['df{}'.format(i+1) for i in range(len(dfs))])
my_df.sum(level=1)
</code></pre>
<p>which yields</p>
<pre><code>     a    b    c
0  6.0  2.0  3.0
1  7.0  4.0  5.0
2  5.0  3.0  4.0
</code></pre>
<p>with jezrael's sample DataFrames.</p>
</div>
<span class="comment-copy">Can you add some data sample and expected output?</span>
<span class="comment-copy">My data are integers (and none of them are nan, so it gets an error). Should I still use the <code>fillna(0)</code> part if there's no nan?</span>
<span class="comment-copy">@AnnaRG, In this case, it's not necessary to use <code>fillna</code> or <code>nansum</code>. I recommend <code>np.sum([x.values for x in [df1, df2, df3]], axis=0)</code> for readability.</span>
<span class="comment-copy">Thanks. So, your answer doesn't require the dfs to be concatenated first, unlike @ayhan answer. May I know, why is it so?</span>
<span class="comment-copy">My answer drops down to <code>numpy</code>, while ayhan's answer sticks to <code>pandas</code>. There is more than one solution to this problem. If performance is not an issue, <i>use what makes most sense to you</i>.</span>
<span class="comment-copy">@AnnaRG, I expect a <code>numpy</code> solution to be fastest. But you should test this with your data.</span>
<span class="comment-copy">Interesting, never heard about <code>reduce</code>. Thank you</span>
