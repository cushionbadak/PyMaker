<div class="post-text" itemprop="text">
<p>Given some arbitrary dictionary </p>
<pre><code>mydict = {
    'first': {
        'second': {
            'third': {
                'fourth': 'the end'
             }
         }
     }
}
</code></pre>
<p>I've written a small routine to flatten it in the process of <a href="https://stackoverflow.com/a/49946181/4909087">writing an answer</a> to another question.</p>
<pre><code>def recursive_flatten(mydict):
    d = {}
    for k, v in mydict.items():
        if isinstance(v, dict):
            for k2, v2 in recursive_flatten(v).items():
                d[k + '.' + k2] = v2 
        else:
            d[k] = v
    return d
</code></pre>
<p>It works, giving me what I want:</p>
<pre><code>new_dict = recursive_flatten(mydict)

print(new_dict)
{'first.second.third.fourth': 'the end'}
</code></pre>
<p>And <em>should</em> work for just about any arbitrarily structured dictionary. Unfortunately, it does not:</p>
<pre><code>mydict['new_key'] = mydict
</code></pre>
<p>Now <code>recursive_flatten(mydict)</code> will run until I run out of stack space. I'm trying to figure out how to gracefully handle self-references (basically, ignore  or remove them). To complicate matters, self-references may occur for any sub-dictionary... not just the top level. How would I handle self-references elegantly? I can think of a mutable default argument, but there <em>should</em> be a better way... right? </p>
<p>Pointers appreciated, thanks for reading. I welcome any other suggestions/improvements to <code>recursive_flatten</code> if you have them. </p>
</div>
<div class="post-text" itemprop="text">
<p>One way you can do it using <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer"><code>set</code></a> and <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer"><code>id</code></a>. Note this solution also uses generators which means we can start using our flattened dict <em>before</em> the entire result is computed</p>
<pre><code>def recursive_flatten (mydict):
  def loop (seen, path, value):

    # if we've seen this value, skip it
    if id(value) in seen:
      return

    # if we haven't seen this value, now we have
    else:
      seen.add(id(value))

    # if this value is a dict...
    if isinstance (value, dict):
      for (k, v) in value.items ():
        yield from loop(seen, path + [k], v)

    # base case
    else:
      yield (".".join(path), value)

  # init the loop    
  yield from loop (set(), [], mydict)
</code></pre>
<p>Program demo</p>
<pre><code>mydict = {
    'first': {
        'second': {
            'third': {
                'fourth': 'the end'
             }
         }
     }
}

for (k,v) in recursive_flatten (mydict):
  print (k, v)

# first.second.third.fourth the end

mydict['new_key'] = mydict

for (k,v) in recursive_flatten (mydict):
  print (k, v)

# first.second.third.fourth the end
</code></pre>
<p>We can make a slight modification if you would like to see output for self-referential values</p>
<pre><code># if we've seen this value, skip it
if (id(value) in seen):
  # this is the new line
  yield (".".join(path), "*self-reference* %d" % id(value))
  return
</code></pre>
<p>Now the output of the program will be</p>
<pre><code>first.second.third.fourth the end
first.second.third.fourth the end
new_key *self-reference* 139700111853032
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure what your definition of "graceful" is, but this can be done with some bookkeeping of what has been seen before in a <code>set</code> of object ids:</p>
<pre><code>class RecursiveFlatten:
    def __init__(self):
        self.seen = set()

    def __call__(self, mydict):
        self.seen.add(id(mydict))
        d = {}
        for k, v in mydict.items():
            if isinstance(v, dict):
                if id(v) not in self.seen:
                    self.seen.add(id(v))
                    for k2, v2 in self(v).items():
                        d[k + '.' + k2] = v2
            else:
                d[k] = v
        return d

def recursive_flatten(mydict):
    return RecursiveFlatten()(mydict)
</code></pre>
<p>Testing it out gives me what I expect</p>
<pre><code>mydict = {
    'first': {
        'second': {
            'third': {
                'fourth': 'the end'
             }
         },
        'second2': {
            'third2': 'the end2'
        }
     }
}

mydict['first']['second']['new_key'] = mydict
mydict['new_key'] = mydict
print(recursive_flatten(mydict))
</code></pre>
<p>Out:</p>
<pre><code>{'first.second2.third2': 'the end2', 'first.second.third.fourth': 'the end'}
</code></pre>
</div>
<span class="comment-copy">One way is to put everything you encounter in a dictionary and check as you go that you haven't seen the thing before. Another way is to keep two pointers and let one of them go two steps as the other goes one. If they ever coincide, you have a loop. The question is also what you do then - abort or return something well-defined.</span>
<span class="comment-copy">Is it common to use classes like this in Python? Overkill to localize one private binding, isn't it?</span>
<span class="comment-copy">I've done it before, idk if I'd say it was overkill but thinking about it more, the same effect could likely be achieved from a nested function. That's what I get for living in C++ for 3 years. In any case your approach is certainly better</span>
<span class="comment-copy">No worries. I'm new to Python myself so I don't know what the community considers idiomatic. It's neat to see a solution that works with minimal modification to the OP's original code!</span>
