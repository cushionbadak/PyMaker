<div class="post-text" itemprop="text">
<p>I'm using python 3.6.
My goal is to make a base class that would be able to somehow access through polymorphism - one of the child class variables.
I know it sounds somewhat 'not oop', so if what im describing can't be done with python - I would like to know what is the best practice for this case.</p>
<p>Following wikipedia's example:</p>
<pre><code>class Animal:
    def __init__(self, name):    # Constructor of the class
        self.name = name
    def talk(self):              # Abstract method, defined by convention only
        raise NotImplementedError("Subclass must implement abstract method")

class Cat(Animal):
    def talk(self):
        return 'Meow!'

class Dog(Animal):
    def talk(self):
        return 'Woof! Woof!'

animals = [Cat('Missy'),
           Cat('Mr. Mistoffelees'),
           Dog('Lassie')]

for animal in animals:
    print animal.name + ': ' + animal.talk()
</code></pre>
<p>Prints the following:</p>
<pre class="lang-none prettyprint-override"><code>Missy: Meow!
Mr. Mistoffelees: Meow!
Lassie: Woof! Woof!
</code></pre>
<p>I would like to achieve the exactly same output - using
variable overloading (is that a thing?) instead of method overloading.
The reason is that in the programm im working on - <code>dog</code>, <code>cat</code>, and every other kind of <code>animal</code> will <code>talk</code> exactly the same way - influenced only by the data member, such as:</p>
<pre><code>class Animal:
    def __init__(self, name):    # Constructor of the class
        self.name = name
        self.vocabulary = []     # so called abstract data member
    def talk(self):              # Non Abstract method, all animals would talk
        for word in self.vocabulary: print (word)

class Cat(Animal):
    vocabulary = ["Meow", "Muuuew", "Maow"]

class Dog(Animal):
    vocabulary = ["Woof", "Waf", "Haw"]

animals = [Cat('Missy'),
           Cat('Mr. Mistoffelees'),
           Dog('Lassie')]

for animal in animals:
    print animal.name + ': ' + animal.talk()
</code></pre>
<p>Prints the following:</p>
<pre class="lang-none prettyprint-override"><code>Missy: Meow Muuuew Maow
Mr. Mistoffelees: Meow Muuuew Maow
Lassie: Woof Waf Haw
</code></pre>
<p>Clearly, this won't work since vocabulary will be empty, as it is in the base class.
I tried to find a solution using <code>super</code>, e.g:</p>
<pre><code>class Cat(Animal):
    vocabulary = ["Meow", "Muuuew", "Maow"]
    def talk(self):
        super(Animal,Cat).talk()
</code></pre>
<p>But the result would be <code>AttributeError: 'super' object has no attribute 'talk'</code></p>
<p>Am I using <code>super</code> wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few unresolved issues in your code, but since python is so dynamic, it will find the subclass instance attribute through normal lookup:</p>
<pre><code>class Animal:
    def __init__(self, name):
        self.name = name

    def talk(self):
        for word in self.vocabulary: print (word)

class Cat(Animal):
    def __init__(self, name):
      super().__init__(name)
      self.vocabulary = ["Meow", "Muuuew", "Maow"]

class Dog(Animal):
  def __init__(self, name):
      super().__init__(name)
      self.vocabulary = ["Woof", "Waf", "Haw"]

animals = [Cat('Missy'),
           Cat('Mr. Mistoffelees'),
           Dog('Lassie')]

for animal in animals:
    print(animal.name, end=': ')
    animal.talk()
</code></pre>
<p>If you want something to enforce this requirement more explicitly in the code, you can make <code>Animal</code> an <em>abstract base class</em> and make an abstruct property named <code>vocabulary</code>:</p>
<pre><code>import abc

class Animal(abc.ABC):
    def __init__(self, name):
        self.name = name

    @property
    @abc.abstractmethod
    def vocabulary(self):
      ...

    def talk(self):
        for word in self.vocabulary: print (word)

class Cat(Animal):
    @property
    def vocabulary(self):
      return ["Meow", "Muuuew", "Maow"]
</code></pre>
<p><a href="https://repl.it/@RyanHaining1/abstractproperty-2" rel="nofollow noreferrer">here is a live link</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python is dynamically typed. There is no need to somehow declare an "abstract data member" in <code>Animal</code> for <code>Animal</code> methods to refer to <code>self.vocabulary</code>; in fact, your attempts to declare an "abstract data member" are causing your problems.</p>
<p>Just remove <code>self.vocabulary = []</code>, and <code>talk</code> will automatically find the subclass <code>vocabulary</code> when it tries to access <code>self.vocabulary</code>.</p>
</div>
<span class="comment-copy">In your example, <code>vocabulary</code> is an instance attribute of <code>Animal</code> but is a class attribute of <code>Dog</code> and <code>Cat</code>. Where should it actually live?</span>
<span class="comment-copy">Thank you for your comment, vocabulary should by a class attribute, not an instance variable.</span>
<span class="comment-copy">Your edit changed the nature of the question too much; I've reverted it. If you want a method that operates on the class instead of the instance, look up <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a>.</span>
<span class="comment-copy"><code>abstractproperty</code> is deprecated. The recommended way is now to do <code>@property</code> <code>@abstractmethod</code> in that order (which is a pretty annoying API, since you have to memorize the order).</span>
<span class="comment-copy">@user2357112 that is lame. updated</span>
<span class="comment-copy">This is helpfull, but can you apply this for working with class variables?</span>
<span class="comment-copy">Thank you, my question wasnt clear enough, I have edited it so show that my goal is to use instance variables, no any 'self'.</span>
