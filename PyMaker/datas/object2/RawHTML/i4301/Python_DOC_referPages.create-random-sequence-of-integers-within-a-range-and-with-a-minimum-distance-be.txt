<div class="post-text" itemprop="text">
<p>What is the fastest way to generate a specific nr of integers of random value uniformly distributed within a specific range and with a minimum distance between each element?</p>
<p>For example, given a sequence range between 0 and 20, we want to create 5 elements with at least 3 points distance between each element, the result could be something like this <code>[0,5,11,14,19]</code> or  <code>[2,5,9,13,18]</code></p>
<p>I created a loop that achieves this but it is very slow when i want to create ranges in the order of millions. </p>
</div>
<div class="post-text" itemprop="text">
<p>How about the following recipe: If you want a gap of 3 between your 5 adjacent elements, but want a total range of 20, then you effectively have <code>20 - (5-1)*3</code> steps of "slack" that you can randomly distribute in the gaps between your elements. Suppose we generate a number in that range, and scatter it between the elements, then we end up with code something like the following:</p>
<pre><code>import numpy, random

n = 5
limit = 20
mingap = 3

slack = 20 - mingap * (n - 1)

def generate():
    steps = random.randint(0, slack)

    increments = numpy.hstack([numpy.ones((steps,)), numpy.zeros((n,))])
    numpy.random.shuffle(increments)

    locs = numpy.argwhere(increments == 0).flatten()
    return numpy.cumsum(increments)[locs] + mingap * numpy.arange(0, n)
</code></pre>
<p>If you then invoke this <code>generate()</code> function ten times, you get a collection of vectors something like the following:</p>
<pre><code>[  0.   3.   6.   9.  12.]
[  0.   3.   6.  10.  13.]
[  2.   5.   8.  12.  15.]
[  1.   4.   7.  12.  16.]
[  0.   4.   7.  10.  13.]
[  0.   3.   6.   9.  12.]
[  1.   4.   9.  12.  16.]
[  0.   7.  10.  13.  16.]
[  0.   5.   8.  11.  14.]
[  1.   4.   8.  11.  17.]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This:</p>
<pre><code>np.cumsum(np.ones((5,), np.int) * 3 + np.random.randint(0, maxn, (5,))) - 3
</code></pre>
<p>will give you 5 random numbers spaced by at least 3 points.</p>
<p>You have to tweak <code>maxn</code> to get the correct maximum value of the random numbers. Perhaps you may want to have a slightly bigger <code>maxn</code> and the reject samples whose elements exceed your maximum value (20).</p>
<p>Note: you didn't say what final distribution you are looking for, e.g. if you want the resulting samples <em>uniformly distributed</em> over the space of the valid samples, or anything else, if that matters.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer is a followup to the comments on my previous answer.</p>
<p>You said you want uniformly distributed numbers, but that of course is not possible to have while respecting the condition that the numbers must be spaced by at least 3 points.</p>
<p>So, I provide you a different definition of uniformly randomness: suppose you can enumerate <strong>all</strong> the valid vectors respecting your condition. I wrote a function to do so:</p>
<pre><code>def space_gen(xmin, xmax, len, min_dist, result=[]):
    if len:
        for x in range(xmin, xmax - (len - 1) * min_dist):
            yield from space_gen(x + min_dist, xmax, len - 1, min_dist, result + [x])
    else:
        yield result
</code></pre>
<p>Let's consider a smaller instance of the problem. Suppose you want vectors of 3 random numbers from 0 to 10 (excluded), spaced by at least 4 points:</p>
<pre><code>&gt;&gt;&gt; list(space_gen(0,10,3,4))
[[0, 4, 8], [0, 4, 9], [0, 5, 9], [1, 5, 9]]
</code></pre>
<p>that list is the complete enumeration of all valid results according to that rule.</p>
<p>Now you can uniformly sample from this list (see for example <a href="https://docs.python.org/3/library/random.html#random.choice" rel="nofollow noreferrer">random.choice</a>).</p>
<p>Now it's possible that your problem size (i.e. the range, or the vector size) make the problem instance too big to be exhaustively enumerated.</p>
<p>But you can still use this "brute force" enumeration to check if a method generates truly uniformly distributed samples.</p>
<p>For the problem instance of your question (0-20 range, 5 length, 3 min. dist) it's still doable:</p>
<pre><code>&gt;&gt;&gt; len(list(space_gen(0,21,5,3)))
1287
</code></pre>
<p>For example, we can check if rwp's recipe generates uniformly distributed samples (according to this definition):</p>
<pre><code>space = list(space_gen(0, 21, 5, 3))
counter = {tuple(x): 0 for x in space}
for _ in range(200000):
    x = tuple(map(int,generate()))
    counter[x] += 1
import matplotlib.pyplot as plt
a = np.array(sorted(counter.values()))
plt.hist(a, bins=len(space))
plt.show()
</code></pre>
<p>and we observe this distribution of counts:</p>
<p><a href="https://i.stack.imgur.com/qXwtJ.png" rel="nofollow noreferrer"><img alt="histogram plot" src="https://i.stack.imgur.com/qXwtJ.png"/></a></p>
<p>Clearly there are some vectors occurring way more often than other vectors.</p>
<p>We can also check the first solution I proposed:</p>
<pre><code>def generate1():
    maxn=15
    while 1:
        x = np.cumsum(np.ones((5,), np.int) * 3 + np.random.randint(0, maxn, (5,))) - 3
        if x[-1] &lt;= 20:
            return x
</code></pre>
<p>even with <code>maxn</code>=15 and using rejection sampling, it's still a bit skew and not perfectly uniform. Using the same benchmark/plot code as before:</p>
<p><a href="https://i.stack.imgur.com/ElViO.png" rel="nofollow noreferrer"><img alt="histogram plot" src="https://i.stack.imgur.com/ElViO.png"/></a></p>
</div>
<span class="comment-copy">what is the condition for starting point and how you define the step between them?!!</span>
<span class="comment-copy">starting point can be anything close to the min distance, in this case, it could be, 0,1,2,3,4,5,6. The step between them is min distance plus random distance, but not big enough so that the other numbers won't fit inÂ¨</span>
<span class="comment-copy">why this value exactly, how did you calculate the min distance?</span>
<span class="comment-copy">well min distance is just a part of the condition, it is given. For example, the min distance will never be bigger so that the elements won't fit in the given sequence</span>
<span class="comment-copy">Do you want uniformly distributed, or do you want to enforce the minimum distance? You can't have both.</span>
<span class="comment-copy">well, thank you @rwp, this looks really interesting, i will do a bit more testing with this, but so far looks like what i was looking for</span>
<span class="comment-copy">with a bit of tweaking this is what i was looking for. I just added some filters on top and it works perfectly. Thank you</span>
<span class="comment-copy">It's not obvious that you can choose a fixed <code>maxn</code> that will guarantee that the largest value in the sequence is no bigger than 20. Setting a larger value of <code>maxn</code> will probably skew the distribution of values away from zero, which may not be what the OP intended.</span>
<span class="comment-copy">hmmm, i tried it now with different settings and i don't see how i can get the sequence i am looking for</span>
<span class="comment-copy">@rwp: please clarify. do you mean if doing that <i>and</i> rejection sampling? because with high value of <code>maxn</code> you would have to reject lots of samples, which is what the OP wanted to avoid in the first place, if I understood correctly.</span>
<span class="comment-copy">@RaduS: with <code>maxn</code>=3 you get more or less what you are looking for. with <code>maxn</code>=10 is more "fair" altough you have to reject samples whose last number exceeds 20. Is the final distribution of the numbers relevant in some way?</span>
<span class="comment-copy">you can't have the resulting numbers <i>uniformly distributed</i> and at the same time respect the condition of the minimum distance, as that is going to remove some combinations, such as [0,0,0,0,0] or [0,2,4,6,8], hence each distribution cannot be uniformly random. But, if you enumerate the valid configurations, then you can uniformly sample from that. I'll add another answer to provide an example of this, if that works for you...</span>
