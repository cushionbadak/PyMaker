<div class="post-text" itemprop="text">
<p>I'm writing a set of Python modules that are essentially utility modules for other code that is contained in dynamic libraries. To make packaging and use easier, what I'd like to do is bundle them inside the library (on Windows as a string resource, on Linux I'm not sure yet - probably export a function that returns the string). Now I'm wondering if there is a way to import a Python module as a string literal of its source code. So essentially the equivalent of</p>
<pre><code>mymod = "def func():\n    return 1"
import(mymod)
</code></pre>
<p>Any imports in the imported module itself should also work. Ideally I'm thinking of some way of providing a callback function that is passed the name of a module and returns a string with its contents, so that I can recursively have my modules be loaded; but as a backup I can also live with the situation where upon doing the import of the main module, I would do the same thing in the <strong>init</strong> in python (i.e. dynamically load any dependencies manually - of course I don't like doing things manually, hence why this is a fallback :) )</p>
<p>Oh and I'd like this to work in Python 2.7 and 3, if that makes a difference...</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for a way to <code>exec</code>ute code from a string (which is not recommended, you might be better off going through the whole process of <a href="https://docs.python.org/2/distutils/setupscript.html" rel="nofollow noreferrer">setup.py</a> to make your library installable) you can use the <code>exec</code> statement as follows</p>
<pre><code>exec(mymod)
</code></pre>
<p>This will parse the string as it would normal Python source and execute it, leaving you with it's side effects (such as defining functions and variables). This will work in both Python 2.7 and 3.x. See the documentation <a href="https://docs.python.org/2/reference/simple_stmts.html#exec" rel="nofollow noreferrer">here</a> and <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">here</a> for more details.</p>
<p>Alternatively, in Python 2.7 only, <code>execfile</code> does the same thing as <code>exec</code> but for a text file</p>
<pre><code>execfile("path/to/my/mod")
</code></pre>
<p>The <a href="https://docs.python.org/2/library/functions.html#execfile" rel="nofollow noreferrer">documentation</a> explains what it does and doesn't do.</p>
</div>
<span class="comment-copy">Any reason why youâ€™re not using the standard Python way for packaging dependencies, which is well-established, standardised, easy, and has tons of tool support?</span>
<span class="comment-copy">have you seen <a href="https://stackoverflow.com/q/5362771/6779307">this question?</a> I'd be skeptical that this is really the simplest solution (or even a practical one).   I'd encourage you to write a question that describes more fully the problem you're facing.  There is very likely a more stable and easy to deal with solution.</span>
<span class="comment-copy">This is basically <code>exec</code>, but it's a terrible idea for the described use-case and I'll downvote anyone that posts it as answer.  What you really want is to read the <a href="https://packaging.python.org/" rel="nofollow noreferrer">PyPA packaging guide</a>.</span>
<span class="comment-copy">Because this is for a niche product in which the Python stuff is tangential to the main product; and needs to interface with a Python installation that is provided by yet another product, which I don't want to interfere with. So I can't make public packages for this, nor install a package server myself. Also versioning - it's much easier to just compile whatever is 'current' into the library and I know it'll work, instead of having to sync two projects. Lastly users of these packages only do so indirectly, they generally wouldn't even know what Python is (apart from the slithering variety).</span>
<span class="comment-copy">That doesn't matter, if you have a Python installation then you have (or can easily create) a site-packages directory in <code>sys.path</code>. It is trivial to install/uninstall packages even without any network access (you can even use <code>pip</code> if you wanted). You do need packaging, but you don't need a package server and you don't need "public" packages.</span>
