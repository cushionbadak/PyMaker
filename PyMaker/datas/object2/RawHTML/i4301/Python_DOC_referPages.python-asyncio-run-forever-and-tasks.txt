<div class="post-text" itemprop="text">
<p>I adapted this code for using Google Cloud PubSub in Async Python: <a href="https://github.com/cloudfind/google-pubsub-asyncio" rel="nofollow noreferrer">https://github.com/cloudfind/google-pubsub-asyncio</a></p>
<pre><code>import asyncio
import datetime
import functools
import os

from google.cloud import pubsub
from google.gax.errors import RetryError
from grpc import StatusCode

async def message_producer():
    """ Publish messages which consist of the current datetime """
    while True:
        await asyncio.sleep(0.1)


async def proc_message(message):
    await asyncio.sleep(0.1)
    print(message)
    message.ack()


def main():
    """ Main program """
    loop = asyncio.get_event_loop()

    topic = "projects/{project_id}/topics/{topic}".format(
        project_id=PROJECT, topic=TOPIC)
    subscription_name = "projects/{project_id}/subscriptions/{subscription}".format(
        project_id=PROJECT, subscription=SUBSCRIPTION)

    subscription = make_subscription(
        topic, subscription_name)

    def create_proc_message_task(message):
        """ Callback handler for the subscription; schedule a task on the event loop """
        print("Task created!")
        task = loop.create_task(proc_message(message))

    subscription.open(create_proc_message_task)
    # Produce some messages to consume

    loop.create_task(message_producer())

    print("Subscribed, let's do this!")
    loop.run_forever()


def make_subscription(topic, subscription_name):
    """ Make a publisher and subscriber client, and create the necessary resources """
    subscriber = pubsub.SubscriberClient()
    try:
        subscriber.create_subscription(subscription_name, topic)
    except:
        pass
    subscription = subscriber.subscribe(subscription_name)

    return subscription


if __name__ == "__main__":
    main()
</code></pre>
<p>I basically removed the publishing code and only use the subscription code.
However, initially I did not include the <code>loop.create_task(message_producer())</code> line. I figured that tasks were created as they were supposed to however they never actually run themselves. Only if I add said line the code properly executes and all created Tasks run. What causes this behaviour? </p>
</div>
<div class="post-text" itemprop="text">
<p>PubSub is calling the <code>create_proc_message_task</code> callback from a different thread. Since <code>create_task</code> is <a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading" rel="nofollow noreferrer">not thread-safe</a>, it must only be called from the thread that runs the event loop (typically the main thread). To correct the issue, replace <code>loop.create_task(proc_message(message))</code> with <code>asyncio.run_coroutine_threadsafe(proc_message(message), loop)</code> and <code>message_producer</code> will no longer be needed. </p>
<p>As for why <code>message_producer</code> appeared to fix the code, consider that <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe" rel="nofollow noreferrer"><code>run_coroutine_threadsafe</code></a> does two additional things compared to <code>create_task</code>:</p>
<ul>
<li>It operates in a thread-safe fashion, so the event loop data structures are not corrupted when this is done concurrently.</li>
<li>It ensures that the event loop wakes up at the soonest possible opportunity, so that it can process the new task.</li>
</ul>
<p>In your case <code>create_task</code> added the task to the loop's runnable queue (without any locking), but failed to ensure the wakeup, because that is not needed when running in the event loop thread. The <code>message_producer</code> then served to force the loop to wake up in regular intervals, which is when it also checks and executes the runnable tasks.</p>
</div>
<span class="comment-copy">It sounds like PubSub is calling the <code>create_proc_message_task</code> callback from a different thread. Replace <code>loop.create_task(proc_message(message))</code> with <code>asyncio.run_coroutine_threadsafe(proc_message(message), loop)</code> and things should work without spawning the <code>message_producer</code>.</span>
<span class="comment-copy">That does the trick! Thank you. Could you elaborate what is happening here? Given your assumption is right, why would the message_producer fix the situation?</span>
<span class="comment-copy">I've now posted an answer with a more detailed explanation. Inadvertently calling asyncio stuff from a different thread is a really common mistake.</span>
