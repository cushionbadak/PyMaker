<div class="post-text" itemprop="text">
<p>Say for a list comprehension like this:</p>
<pre><code>foo = [_.strip().split() for _ in foo[10:]]
</code></pre>
<p>what are the exact steps that Python is taking to evaluate the right hand expression and assign it to <code>foo</code>? Between 2.x and 3.x ... is the internal logic to handle something like this varying between the two?</p>
<p>I would imagine that from a procedural perspective, Python is first performing <code>foo[10:]</code> then starting to iterate over the resulting list stripping the elements and then splitting them then appending the result a new list and finally pointing to that last list as <code>foo</code>.</p>
<p>Is it internally allocating a new list for each operation? (One list for the resulting <code>foo[10:]</code>, then another list for the result of <code>strip</code>, etc.?</p>
<p>Thank you for any insight.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x, your list comprehension is compiled into something much like this:</p>
<pre><code>def _comp(it):
    result = []
    for _ in it:
        result.append(_.strip().split())
    return result
foo = _comp(iter(foo[10:]))
</code></pre>
<p>There are a few minor differences—the compiler can use something a bit faster than <code>result.append</code> because <code>result</code> isn't accessible; <code>_comp</code> is actually named something that isn't a valid identifier so you can't accidentally call it; etc. But that's basically it.<sup>1</sup></p>
<p>For full details, see <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer">Displays for lists, sets, and dictionaries</a> in the reference documentation.</p>
<p>That <code>foo[10:]</code> just calls <code>foo.__getitem__(slice(None, 10, 10))</code>. If <code>foo</code> is a <code>list</code>, that's handled by creating a new list with the elements from 10 through the end of <code>foo</code>. But if <code>foo</code> were, say, a numpy array, it might be a view into the same memory of <code>foo</code>, and if it were an instance of some crazy class you created just to see how you could screw with things, it could be anything you wanted, like the string <code>'abc'</code>.</p>
<p>Similarly, if the elements of <code>foo</code> are strings (or <code>bytes</code>), the <code>strip</code> method returns a new string with all of the characters but the stripped-off whitespace copied, and the <code>split</code> method returns a new list of copied strings.</p>
<hr/>
<p>In Python 2.x, it's more like this:</p>
<pre><code>_result = []
_it = iter(foo[10:])
for _ in _it:
    _result.append(_.strip().split())
foo = _result
</code></pre>
<p>Although again, it's not exactly this—<code>_result</code> and <code>_it</code> have names that aren't valid identifiers, and the optimized special version of <code>append</code> is used, and so on.</p>
<p>The 2.x documentation is in <a href="https://docs.python.org/2/reference/expressions.html#list-displays" rel="nofollow noreferrer">List Displays</a>.</p>
<p>The main reason for the change was that the 2.x design means the <code>_</code> leaks out into the enclosing scope,<sup>2</sup> although the fact that it allowed comprehensions and generator expressions to share most of the same code was another benefit.</p>
<p>The other list and string operations are the same between 2.x and 3.x. While many functions did change to return iterators instead of copied lists in 3.x, slicing and splitting are not among them.</p>
<hr/>
<p><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">The tutorial</a> has a nice section on comprehensions, but it explains the 2.x behavior even in 3.x (because it's a bit easier to understand, and the difference isn't likely to matter to novices' code—it is a tutorial, after all).</p>
<hr/>
<p><sub>1. Also, notice the way the outermost iterable is passed in as an argument. This means you don't accidentally end up capturing a nested variable in a closure. Which doesn't make much difference for list comprehensions, but it's important for generator expressions, where the iteration may not start until after the value of that captured variable has changed.</sub></p>
<p><sub>2. In 2.3-2.6, this leaking was officially documented behavior you could rely on. In 2.7, it was deprecated, and you aren't supposed to rely on it either leaking or not leaking. But in all current major implementations of 2.7 (and there won't be any new ones), list comprehensions always leak, although set and dict comprehensions do not.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>Yeah, a new list is created for <code>foo[10:]</code> (assuming <code>foo</code> is a list), and a new list is created for each <code>.split</code> call (assuming <code>_</code> is a <code>str</code>).</p>
<p>It is equivalent to:</p>
<pre><code>foo = []
for _ in foo[:10]: # list slices always create new lists
    foo.append(_.strip().split())
</code></pre>
<p>Except that <code>foo</code> isn't assigned to until the end</p>
<p>Note, by convention, you shouldn't use <code>_</code> as a variable name unless you intend for it to not be used.</p>
<p>Finally, one major difference between list comprehensions between Python 2 and Python 3 is that Python 3 creates an enclosing scope (essentially, a function scope) for the expression inside the list comprehension. Python 2 comprehensions do not, and variable will "leak" out of the construct.</p>
<p>So, in Python 3:</p>
<pre><code>&gt;&gt;&gt; [x for x in range(4)]
[0, 1, 2, 3]
&gt;&gt;&gt; x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'x' is not defined
</code></pre>
<p>However, in Python 2:</p>
<pre><code>&gt;&gt;&gt; [x for x in range(4)]
[0, 1, 2, 3]
&gt;&gt;&gt; x
3
</code></pre>
<p>And if you really want, you can dig into the CPython internals a bit using <code>dis</code>:</p>
<pre><code>In [1]: import dis

In [2]: def f(): foo = [_.strip().split() for _ in foo[10:]]
   ...:

In [3]: dis.dis(f)
  1           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x105d83b70, file "&lt;ipython-input-2-82d65e58298d&gt;", line 1&gt;)
              3 LOAD_CONST               2 ('f.&lt;locals&gt;.&lt;listcomp&gt;')
              6 MAKE_FUNCTION            0
              9 LOAD_FAST                0 (foo)
             12 LOAD_CONST               3 (10)
             15 LOAD_CONST               0 (None)
             18 BUILD_SLICE              2
             21 BINARY_SUBSCR
             22 GET_ITER
             23 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             26 STORE_FAST               0 (foo)
             29 LOAD_CONST               0 (None)
             32 RETURN_VALUE
</code></pre>
<p>Note, the first three operations essentially create a function where the list comprehension magic happens. We can further introspect:</p>
<pre><code>In [8]: f.__code__.co_consts[1]
Out[8]: &lt;code object &lt;listcomp&gt; at 0x105d83b70, file "&lt;ipython-input-2-82d65e58298d&gt;", line 1&gt;

In [9]: dis.dis(f.__code__.co_consts[1])
  1           0 BUILD_LIST               0
              3 LOAD_FAST                0 (.0)
        &gt;&gt;    6 FOR_ITER                24 (to 33)
              9 STORE_FAST               1 (_)
             12 LOAD_FAST                1 (_)
             15 LOAD_ATTR                0 (strip)
             18 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
             21 LOAD_ATTR                1 (split)
             24 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
             27 LIST_APPEND              2
             30 JUMP_ABSOLUTE            6
        &gt;&gt;   33 RETURN_VALUE
</code></pre>
<p>And this is the bytecode that is actually executed for the comprehension. Note that the list is given the name <code>.0</code>, which you can see here: <code>3 LOAD_FAST                0 (.0)</code> `</p>
</div>
