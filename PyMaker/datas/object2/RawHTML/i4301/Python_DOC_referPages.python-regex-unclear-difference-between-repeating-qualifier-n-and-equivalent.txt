<div class="post-text" itemprop="text">
<p>Why does <em>xx</em> yield something different from <em>x{2}</em>?
Please have a look at the following example:</p>
<pre><code>import re

lines = re.findall(r'".*?"".*?"', '"x""y"')
print(lines) # yields: ['"x""y"']

lines = re.findall(r'(".*?"){2}', '"x""y"')
print(lines) # yields: ['"y"']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As per the <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer">documentation of <code>findall</code></a>, if you have a group in the regex, it returns the list of those groups, either as a tuple for 2+ groups or as a string for 1 groups. In your case, your two regexes are not merely <code>xx</code> versus <code>x{2}</code>, but rather the second one is <code>(x){2}</code>, which has a group, when the first regex has no groups.</p>
<p>Hence, <code>"x"</code> matches the group the first time, then <code>"y"</code> matches the group the second time. This fulfills your overall regex, but <code>"y"</code> overwrites <code>"x"</code> for the value of group 1.</p>
<p>The easiest way to solve this in your example is to convert your group to a non-matching group: <code>(?:".*?"){2}</code>. If you want two groups, one for <code>"x"</code> and one for <code>"y"</code>, you need to repeat the group twice: <code>(".*?")(".*?")</code>. You can potentially use named groups to simplify this repetition.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first expression is <em>"X and then Y, where Y accidentally matches the same thing as X"</em>.</p>
<p>The second expression is <em>"(X){repeat two times}"</em>. Group 1 cannot contain XX, because group 1 does not match XX. It matches X. </p>
<p>In other words: Group contents does not change just because of a quantifier outside of the group.</p>
<p>One way to remedy the second expression is to make an outer group (and make the inner group non-capturing)</p>
<pre><code>lines = re.findall(r'((?:".*?"){2})', '"x""y"')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>About your second pattern <code>(".*?"){2}</code>:</p>
<p>A cite from the <a href="https://docs.python.org/3.1/library/re.html#re.MatchObject.group" rel="nofollow noreferrer">rules of matching</a></p>
<blockquote>
<p>If a group is contained in a part of the pattern that matched multiple times, the last match is returned.</p>
</blockquote>
<p>And <a href="https://docs.python.org/3.1/library/re.html#re.findall" rel="nofollow noreferrer">findall</a> does the following:</p>
<blockquote>
<p>If one or more groups are present in the pattern, return a list of groups;</p>
</blockquote>
<p>Your pattern <code>(".*?"){2}</code> means that <code>(".*?")</code> should match twice in a row, and according to the first rule, only the content of the last match is captured.</p>
<p>For your data <code>findall</code> finds the sequence <code>(".*?"){2}</code> only once, so it returns a list consisting of the last captured group for a single match: <code>['"y"']</code>.</p>
<p>This example would make it more obvious: </p>
<pre><code>import re
print (re.findall(r'(\d){2}', 'a12b34c56'))
# ['2', '4', '6']
</code></pre>
<p>You can see that findall finds the sequence <code>(\d){2}</code> three times and for each it returns the last captured content for the group <code>(\d)</code>.</p>
<p>Now about your first pattern: <code>".*?"".*?"</code>.<br/>
This one does not contains subgroups, and, according to <a href="https://docs.python.org/3.1/library/re.html#re.findall" rel="nofollow noreferrer">findall</a> again, in this case it returns:</p>
<blockquote>
<p>all non-overlapping matches of pattern in string, as a list of strings. </p>
</blockquote>
<p>So for your data it is <code>['"x""y"']</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>AFAIK, <code>findall()</code> is <code>capture group first</code>, if there is any capture group in the applied regex, then <code>findall()</code> returns only capture group values.</p>
<p>And only when there is no capture group in the applied regex, <code>findall()</code> returns <code>fullmatch values</code>.</p>
<p>Therefore, if you want <code>findall()</code> returns <code>fullmatch value</code>, then you must not use capture group in the regex like this</p>
<pre><code>(?:".*?"){2}
</code></pre>
<p>in which <code>(?:</code> ... <code>)</code> indicate <code>non-capture group</code>.</p>
<p>Thus, in python</p>
<pre><code>print(re.findall(r'(?:".*?"){2}', '"x""y"'))
</code></pre>
</div>
<span class="comment-copy">Have you tried putting the <code>{2}</code> inside the parentheses like this? <code>'(".*?"{2})'</code></span>
<span class="comment-copy">Thank you! You are absolutely right. I assumed the problem to be due to the {} operator, but actually it is caused by the findall function/method.</span>
<span class="comment-copy">Thank you. You are certainly right. But your first quotation points to the group method of match objects, where, at least by me, the solution was not supposed to be found, as the findall function/method does not return a match object.</span>
<span class="comment-copy">@WernerWenzel I understand that it's hard to make this connection only from the Python documentation, since it's a bit sloppy on this matter (and not only on this). But in fact this capturing behaviour is the same in every major regex implementation, starting with Perl.</span>
<span class="comment-copy">And if you think about it carefully you'll realize that this is pretty much the only sensible way of dealing with subgroups. If the engine had to store every instance of captured text for a subgroup that could repeat thousands times and then had to <i>backtrack</i> to find the better match  it would grind to a halt because of useless memory allocation/deallocation.</span>
