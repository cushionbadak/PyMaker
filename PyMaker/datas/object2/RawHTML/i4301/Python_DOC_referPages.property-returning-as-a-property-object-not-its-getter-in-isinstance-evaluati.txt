<div class="post-text" itemprop="text">
<p>I'm checking if the instance of a property is of a certain type, but in that evaluation it's returning as a property object, not the getter that I have assigned to it.</p>
<p>Other answers to similar questions suggest that it could be because the getter uses something that isn't defined yet, but as far as I can tell everything is already defined.</p>
<p>Definition:</p>
<pre><code>class SceneController():

    ...

    def get_scene(self):
        if self._current_level_name is not None and self._current_level_name in self._scene_stack:
            return self._scene_stack[self._current_level_name]
        else:
            return None


scene_control = SceneController()

@property
def scene():
    return scene_control.get_scene()
</code></pre>
<p>Failing usage:</p>
<pre><code># Prints &lt;class 'property'&gt;
print(type(scene))

# This fails
if isinstance(scene, GameScene):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This should work:</p>
<pre><code>if isinstance(scene(), GameScene)
    ...
</code></pre>
<p>Because you are comparing a <code>@property</code> decorated function to the type of an instance of whatever you return from <code>get_scene</code>. I am assuming <code>self._scene_stack[...]</code> is of <code>GameScene</code>.</p>
<p>You should be careful when using the <code>@property</code> decorator, because it is a <strong>special decorator</strong> in that it provides extra properties (just try typing in  <code>property().getter</code>). By nature, decorators like:</p>
<pre><code>@foo
def bar():
    ...
</code></pre>
<p>Does essentially <code>foo(bar())</code>, so I'm not sure if that's your actual use case for the decorator in the first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python, <code>property()</code> is a built-in function which creates and returns a property object.</p>
<p>The signature of this function is:
<code>property(fget=None, fset=None, fdel=None, doc=None)</code>. </p>
<p>fget is getter, fset is setter and fdel is deleter attributes of property.</p>
<p>When you write a property like:</p>
<p><code>@property
 def foo():
     return 'something'</code></p>
<p>it is internally mapped to <code>foo=property(foo)</code>. And the returned value is a property object.</p>
<p>You can check it by <code>isinstance(foo, property)</code>. It will return True.</p>
<p>For more details, follow <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property in python</a>.</p>
</div>
<span class="comment-copy">properties only work inside classes.</span>
<span class="comment-copy">This is helpful in understanding properties, though adding the parenthesis results in a "property is not callable error".</span>
<span class="comment-copy">Yes, because it's a property. The associated <code>.getter</code>, <code>.setter</code> decorators must be declared and then you can do things like <code>scene = foo</code> for <code>.setter</code> decorated functions, and <code>foo = scene</code> for <code>.getter</code> decorated functions. A property is not a callable entity.</span>
<span class="comment-copy">In this case does code block in which I decorate def scene() with @property not define the getter?</span>
<span class="comment-copy">I didn't know about that internal mapping, very cool, thank you!</span>
