<div class="post-text" itemprop="text">
<p>How to use Rust to collect a time series/stream of sensor data and then make this data available from Python (whilst Rust continues to collect data)?</p>
<p>The objective would be for Rust to continue collecting the data and allow for Python to call functions which would allow to query/retrieve this data. For example all the observations over the past 5 minutes.</p>
<p>Is this possible to achieve without copying memory (similar to view of numpy arrays) or does memory have to be copied when it is received in the Python runtime? </p>
<p>If memory needs to be copied how does the runtime cost of doing it in Rust compare to a doing it in C? Would C be simpler/easier to implement when compared to Rust (as a novice C programmer I like the safety/tools Rust offers)?</p>
<p>In summary, I would like to understand how to:</p>
<ul>
<li>Collect sensor data and continue to collect it in Rust in the background</li>
<li>Allow the data collected in Rust to be queried from Python</li>
<li>Does the data need to be copied when queried from Python or can memory views similar to numpy be implemented?</li>
<li>If the data needs to be copied how does the overhead compare to C?</li>
<li>How does the complexity of implementing this is Rust compare to C?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Your question is to vague to be answered correctly, let me suggest you some approaches.</p>
<h1>1. Using an intermediate layer</h1>
<p>You can use some sort of database (e.g. sqlite, postgresql, ...), filesystem storage (plain text file, sockets) or even build a Webserver with a (JSON) API.</p>
<p>Depending on what you want to use, there are crates for everything (plain text is in std, sqlite, postgres, diesel, hyper, serde, etc).</p>
<p>The neat thing about this implementation is, that it is programming language indepenent, if you for example decide to reprogram your code in Java later (for whatever reason :) ), you just have to change the way java reads the code out of the database/socket/webserver.</p>
<h1>2. Using FFI</h1>
<p>You can take a look at the example from alex at <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/python-to-rust" rel="nofollow noreferrer" title="github.com">github.com</a>, but be aware of the types you can use in FFI, e.g. integer types like i32, u32, i8, pointer, floatings but things like strings can get very hairy, so if you are fine with integer only, use that.</p>
</div>
<span class="comment-copy">Why just not use Rust to save in a database and Python to read from the database ?</span>
<span class="comment-copy"><i>Would C be simpler/easier to implement when compared to Rust</i>: definitely not.</span>
<span class="comment-copy">Are you writing a (C API) extension for Python in Rust? Or embedding Python in Rust? If so, you can use the <a href="https://docs.python.org/3/c-api/buffer.html" rel="nofollow noreferrer">buffer protocol</a> to expose an object that shares a buffer (presumably immutably) with a Python object, and then your Python code can iterate that, create a <code>memoryview</code> over it, construct an <code>np.array</code> out of it, etc. without copying. There are definitely advantages to writing C extensions in C rather than Rust—but also some advantages to writing them in Rust. (The macros wrap up a <i>lot</i> of boilerplate…)</span>
<span class="comment-copy">If these are entirely separate processes, then I assume you'd be using shared memory or an <code>mmap</code>, in which case… yeah, of course that can be zero-copy. But if you want to wrap things up in some way where there's a pipe that you use to pass metadata about the shared memory… well, that's not <i>hard</i> work, but it's a pretty good amount of easy work.</span>
<span class="comment-copy">This question is <i>way</i> too broad.</span>
