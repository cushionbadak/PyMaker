<div class="post-text" itemprop="text">
<p>I have a file, after reading a line from the file I have named it <code>current_line</code>, I want to fetch the 4th line above the current_line. How can this be done using python?</p>
<pre><code>line 1
line 2
line 3
line 4
line 5
line 6
</code></pre>
<p>Now  say I have fetched line 6 and I have made</p>
<pre><code>current_line = line 6
</code></pre>
<p>Now i want 4 the line from above (ie) N now want line 2 </p>
<pre><code>output_line = line 2
</code></pre>
<p>PS: I dont want to read the file from bottom.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can keep a list of the last 4 lines while iterating over the lines of your file. A good way to do it is to use a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">deque</a> with a maximum length of 4:</p>
<pre><code>from collections import deque

last_lines = deque(maxlen=4)

with open('test.txt') as f:
    for line in f:
        if line.endswith('6\n'): # Your real condition here
            print(last_lines[0])  
        last_lines.append(line)

#  Output:
# line 2
</code></pre>
<blockquote>
<p>Once a bounded length deque is full, when new items are added, a
  corresponding number of items are discarded from the opposite end.</p>
</blockquote>
<p>We read the file line by line and only keep the needed lines in memory.</p>
<p>Imagine we have just read line 10. We have lines 6 to 9 in the queue. </p>
<p>If the condition is met, we retrieve line 6 at the start of the queue and use it.</p>
<p>We append line 10 to the deque, the first item (line 6) gets pushed out, as we are sure that we won't need it anymore, we now have lines 7 to 10 in the queue.</p>
</div>
<div class="post-text" itemprop="text">
<p>My approach would be converting the contents to a list splitting on <code>\n</code> and retrieving required line by index.</p>
<pre><code>lines = '''line 1
line 2
line 3
line 4
line 5
line 6'''

s = lines.split('\n')
current_line = 'line 6'

output_line = s[s.index(current_line) - 4]
# line 2
</code></pre>
<p>Since you are reading from file, you don't need to explicitly split on <code>\n</code>. You could read from file as list of lines using <code>readlines</code>:</p>
<pre><code>with open('path/to/your_file') as f:
    lines = f.readlines()
    current_line = 'line 6'
    output_line = lines[lines.index(current_line) - 4]
    # line 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>enumerate</code> for your <code>open()</code>. For example:</p>
<pre><code>with open('path/to/your.file') as f:
    for i, line in enumerate(f):
        # Do something with line
        # And you have the i as index.
</code></pre>
<p>To go back to the i-4 line, you may think about using <code>while</code>.</p>
<p>But why do you need to go back?</p>
</div>
<div class="post-text" itemprop="text">
<p>you can do:</p>
<pre><code>with open("file.txt") as f:
    lines = f.readlines()

for nbr_line, line in enumerate(lines):
    if line == ...:
        output_line = lines[nbr_line - 4] # !!! nbr_line - 4 may be &lt; 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As I can see you are reading the file line by line. I suggest you to read whole file into the list as below example.</p>
<p>with open("filename.txt","r") as fd:
    lines=fd.readlines()   # this will read each line and append it to lines list</p>
<p>lines[line_number] will give you the respected line.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>f.readLines</code> not effective solution. If you work on huge file why do you want to read all file into memory?</p>
<pre><code>def getNthLine(i):
    if i&lt;1:
        return 'NaN';
    else:
        with open('temp.text', 'r') as f:
            for index, line in enumerate(f):
                if index == i:
                    line = line.strip()
                    return line

f = open('temp.text','r');

for i,line in enumerate(f):
    print(line.strip());
    print(getNthLine(i-1));
</code></pre>
<p>There is no much more options to solve that kind of a problem. 
you could also use <code>tell</code> and <code>seek</code> methods to  play around but generally no need for ninja :). </p>
<p>If you using on huge file just do not forget to use <code>enumerate</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>This is how you could do it with a generator, avoids reading the whole file into memory.</p>
<p><strong>Update</strong>: used collections.deque (deque stands for "double ended queue") as recommended by Thierry Lathuille. </p>
<pre><code>import collections

def file_generator(filepath):
    with open(filepath) as file:
        for l in file:
            yield l.rstrip()

def get_n_lines_previous(filepath, n, match):
    file_gen = file_generator(filepath)
    stored_lines = collections.deque('',n)

    for line in file_gen:
        if line == match:
            return stored_lines[0]        
        stored_lines.append(line)

if __name__ == "__main__":
    print(get_n_lines_previous("lines.txt", 4, "line 6"))
</code></pre>
</div>
<span class="comment-copy">Just what I was about to post...</span>
<span class="comment-copy">Well... You're usually faster ;)</span>
<span class="comment-copy">A potential issue with this solution is that it will load the whole file in memory. That's fine if it's a small file, but might crash on large log file...</span>
<span class="comment-copy">Oh and yes, <code>s.index()</code> is O(N). Here again, wether it's a problem or not depends on the file size.</span>
<span class="comment-copy">The way to avoid loading the whole file is to only keep the last 4 lines, see my answer for a way to do it.</span>
<span class="comment-copy">@brunodesthuilliers I agree on that. Seriously I don't think about crashing problems which occur in case the file is huge as you say but I am pretty sure it does not matter to OP much.</span>
<span class="comment-copy">@theausome I added an explanation at the end of my answer.</span>
<span class="comment-copy">See <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">collections.deque</a>, it has exactly the behaviour you implemented for your <code>stored_lines</code>.</span>
<span class="comment-copy">Oh brilliant thank you @Thierry Lathuille, I will update this!</span>
