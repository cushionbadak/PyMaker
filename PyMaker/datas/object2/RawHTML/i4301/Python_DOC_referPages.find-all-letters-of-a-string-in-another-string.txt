<div class="post-text" itemprop="text">
<p>I'm working on a project that find all anagrams of a word with many others words.
For that I need a function that takes 2 strings and return True if all letters of str1 are in str2.</p>
<p>I made this code:</p>
<pre><code>def almost_anagram(str1, str2):
    tmp = list(str2)
    for i in str1:
            if i in tmp:
                    tmp.remove(i)
            else:
                    return False
    return True
</code></pre>
<p>For exemple:</p>
<pre><code> almost_anagram("OLLE", "HELLO") = True
 almost_anagram("OOLE", "HELLO") = False
</code></pre>
<p>But is there a better/faster way to do that ?</p>
</div>
<div class="post-text" itemprop="text">
<p>i prefer using count() function and by the way you don't need to convert the string into list:</p>
<pre><code>def almost_anagram(str1, str2):
    for i in str1:
        if(str1.count(i)==str2.count(i)):
            pass
        else:
            return False
    return True

print(almost_anagram('olle','hello'))
print(almost_anagram('oole','hello')) 
</code></pre>
<p>output:</p>
<pre><code>True
False          
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a>, which essentially represents a multi-set:</p>
<pre><code>import collections

def almost_anagram(word1, word2):
    counter1 = collections.Counter(word1)
    counter2 = collections.Counter(word2)
    return counter1 - counter2 == {}
    # alternatively:
    # return all(counter2[k] &gt;= v for k, v in counter1.items())
    # return counter1 &amp; counter2 == counter1
</code></pre>
<p>The code could be simplified to <code>return counter1 &lt; counter2</code> if <code>Counter</code> supported subset-testing with <code>&lt;</code> like sets do, but unfortunately it doesn't.</p>
<p>Output:</p>
<pre><code>&gt;&gt;&gt; almost_anagram("OLLE", "HELLO")
True
&gt;&gt;&gt; almost_anagram("OOLE", "HELLO")
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With <code>collections.Counter</code> object to get letter counts at once:</p>
<pre><code>import collections    

def almost_anagram(str1, str2):
    str1_cnt, str2_cnt = collections.Counter(str1), collections.Counter(str2)
    return all(k in str2_cnt and str2_cnt[k] == v 
               for k,v in str1_cnt.items())
</code></pre>
<p>Test:</p>
<pre><code>print(almost_anagram("OLLE", "HELLO"))  # True
print(almost_anagram("OOLE", "HELLO"))  # False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a <code>list comprehension</code> with <code>all</code> should be faster. </p>
<p><strong>Ex:</strong></p>
<pre><code>def almost_anagram(str1, str2):
    return all(str2.count(i) &gt;=  str1.count(i) for i in set(str1))

print(almost_anagram("OLLE", "HELLO"))
print(almost_anagram("OOLE", "HELLO"))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>True
False
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/32069724/anagram-of-string-2-is-substring-of-string-1">Anagram of String 2 is Substring of String 1</a></span>
<span class="comment-copy">Nice solution  +1</span>
<span class="comment-copy">You can also subtract the resulting <code>Counter</code> objects.  Something like <code>return counter1 - counter2</code></span>
<span class="comment-copy">@bro-grammer You mean like <code>return counter1 - counter2 == {}</code>? I guess that works. Thanks!</span>
<span class="comment-copy">Yes or <code>bool(counter1 - counter2)</code>?</span>
<span class="comment-copy">You'd have to negate that to get the correct result. It's probably more performant, but I prefer it to be more readable :)</span>
<span class="comment-copy">you can subtract objects of type <code>collections.Counter()</code>. I think that would make it faster</span>
<span class="comment-copy">You don't need to create a list, and <code>True if some_condition else False</code> is equivalent to simply <code>some_condition</code>... So basically <code>all(str2.count(i) &gt;=  str1.count(i)  for i in str1)</code></span>
<span class="comment-copy">@Julien. Thanks</span>
<span class="comment-copy">And this is potentially very inefficient since you are re-counting your letters every time, just count them once at the start, then loop.</span>
<span class="comment-copy">I would recommend including <code>str.lower()</code> as well in case of "HELLO", or "hello".</span>
<span class="comment-copy">@Julien He is just re-counting the non-unique ones, not all. Creating a set from <code>str1</code> and iterating through that would be the way to go.</span>
