<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes">Elegant ways to support equivalence (“equality”) in Python classes</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>In something like this</p>
<pre><code>class Obj:
    def __init__(self, x, y):
        self.x = x
        self.y = y


li = [Obj(0, 0), Obj(0, 1), Obj(2, 3)]

print(Obj(2,3) in li)
</code></pre>
<p>I have a False output because even if x and y are the same it counts the object as a different instance. I can remedy using a loop inside the list and checking</p>
<pre><code>if(2==o.x and 3==o.y):
    return True
</code></pre>
<p>Is there some cleaner way to get this without using a loop ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Special method for <code>==</code> and <code>!=</code>:</p>
<pre><code>class Obj:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, Object):
        """ == comparison method."""
        return self.x == Object.x and self.y == Object.y

    def __ne__(self, Object):
        """ != comparison method."""
        return not self.__eq__(self, Object)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Implement a function <code>__eq__</code> like below in your class.</p>
<pre><code>def __eq__(self,  x,y):
     if self.x==x and self.y==y:
        return True
</code></pre>
<p>After that use list comprehension to traverse over the <code>list</code> of objects.</p>
<p><code>result = any(Obj(2,3) == i for i in obj_list )</code></p>
</div>
<span class="comment-copy">Implement an <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a> method in your class.</span>
<span class="comment-copy">You must define <code>Obj.__eq__</code></span>
<span class="comment-copy">Implement the special methods == and != in your object.</span>
<span class="comment-copy">Alternatively, consider using <a href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer"><code>namedtuple</code></a> or the newer <a href="https://hackernoon.com/a-brief-tour-of-python-3-7-data-classes-22ee5e046517" rel="nofollow noreferrer">data classes</a>.</span>
<span class="comment-copy">It depends on each particular case, but it is frequent to add a check like <code>isinstance(Object, Obj)</code> or <code>Object.__class__ == self.__class__</code> in the implementation of <code>__eq__</code> to avoid considering as equals objects of different classes with similarly-named attributes (although sometimes that may be the intended behavior).</span>
<span class="comment-copy">True. Didn't bother with it for the example, but it should be added.</span>
