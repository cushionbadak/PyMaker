<div class="post-text" itemprop="text">
<p>Newbie question about scope: in the following example, how is <code>property</code> able to get access to <code>getx</code> and <code>setx</code> etc. That is, why don't those names have to be qualified with a <code>C.getx</code>, for example? The code is directly from the python docs (<a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#property</a>):</p>
<pre><code>class C:
    def __init__(self):
        self._x = None

    def getx(self):
        return self._x

    def setx(self, value):
        self._x = value

    def delx(self):
        del self._x

    x = property(getx, setx, delx, "I'm the 'x' property.")
</code></pre>
<p>Update: based on comment</p>
<p>Conversely if I had a class like this</p>
<pre><code>class A:
    def foo(self):
        print("foo")

    def bar(self):
        foo(self)
</code></pre>
<p>This would fail. Is that because CPython has no idea what's in <code>bar</code> until I actually try to run it (and at that point we are no longer in the class scope)? </p>
</div>
<div class="post-text" itemprop="text">
<p>The class is its own namespace until it is finalized, and so names inside it don't need to be qualified during class definition. (In fact, they can't be: the class doesn't yet have a name, so there is no way to specify what namespace the names are in.)</p>
<pre><code>class C:
    a = 0
    b = a + 1   # uses a from preceding line
</code></pre>
<p>In your class definition, <code>getx</code>, <code>setx</code>, and <code>delx</code> can be used unqualified because the <code>property(...)</code> call is executed during class definition.</p>
<p>After the class is finalized, the class has a name, and for methods that are called on instances, the instance has a name (traditionally <code>self</code>). Accessing attributes and methods at this point requires qualifying the name with either the class or instance reference (e.g. <code>C.foo</code> or <code>self.foo</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>That is because there are two different scopes. One is <code>Class</code> and one is <code>function</code>.</p>
<p>When you define a function in a class, that function is defined in <code>Class</code> scope. You can build a minimal example:</p>
<pre><code>class A:
    a = 1
    b = a + 1
    pass
</code></pre>
<p>You can see that when defining <code>b</code>, we can directly access variable <code>a</code> as they are in the same scope <code>A Class</code>.</p>
<p>But when you use a <code>Class</code> scope variable in a function, that is another scope <code>function</code>. So in this case you need to manually specify scope.</p>
<p>Actually, this behave varies from language to language. </p>
</div>
<span class="comment-copy">Because upon class creation the code in the class body is run in its own scope. <code>getx</code>, <code>setx</code>, <code>delx</code> are simply functions defined in that scope.</span>
<span class="comment-copy">understood - let me just edit the question to follow up on this comment to clarify things ...</span>
<span class="comment-copy">Based on update: Yes, this class scope ceases to exist when the class is created. The metaclass (in this case <code>type</code>) will add the single objects defined in that scope to the class as attributes. This is why you need to prefix the class for attribute access <code>A.foo()</code>.</span>
<span class="comment-copy">For a nice read on Python scoping rules see <a href="https://stackoverflow.com/a/23471004">this answer</a>.</span>
<span class="comment-copy">Wow, such similar example : )</span>
<span class="comment-copy">so it is the case that the interpreter simply never looks inside <code>bar</code> until it is called.. at that point the class is finalized and it's "creation" namespace is destroyed? if not, then why does <code>C.bar</code> not look at the parent scope as would happen with a nested function for example</span>
<span class="comment-copy">Defining a function inside a class does not give the function any inherent knowledge of what class or instance it is defined in. A class is not a function's parent in a namespace sense. The namespace of a function isn't determined until runtime (which implies that methods of a class don't need to be defined in that class's definition).</span>
<span class="comment-copy">right but if it's not in the current scope, won't CPython look in the parent scope (in this case being the class scope)? ie why is when <code>C.bar</code> is being defined, <code>foo</code> isn't searched for in <code>C</code> scope</span>
<span class="comment-copy">@Alex A variable defined in <code>Class</code> scope is bound to <code>Class</code> but not instance, that means every instances of this class will share the same  <code>Class</code> variables. But the variable used in methods is bound to instance. As far as I think, CPython <b>can</b> look in the parent scope, but that will be a little confuse as in runtime, a function in instance object need to look for variable in another object(Class object).</span>
