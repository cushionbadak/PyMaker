<div class="post-text" itemprop="text">
<p>What is the most Pythonic way to take a list of dicts and sum up all the values for matching keys from every row in the list?   </p>
<p>I did this but I suspect a comprehension is more Pythonic:</p>
<pre><code>from collections import defaultdict
demandresult = defaultdict(int)   # new blank dict to store results 
for d in demandlist:
    for k,v in d.iteritems():
        demandresult[k] = demandresult[k] + v
</code></pre>
<p>In <a href="https://stackoverflow.com/questions/11692613/python-sum-values-in-dictionary">Python - sum values in dictionary</a>  the question involved the same key all the time, but in my case, the key in each row might be a new key never encountered before. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think that your method is quite pythonic. Comprehensions are nice but they shouldn't really be overdone, and they can lead to really messy one-liners, like the one below :).</p>
<p>If you insist on a dict comp:</p>
<pre><code>demand_list = [{u'2018-04-29': 1, u'2018-04-30': 1, u'2018-05-01': 1}, 
               {u'2018-04-21': 1},
               {u'2018-04-18': 1, u'2018-04-19': 1, u'2018-04-17' : 1}]

d = {key:sum(i[key] for i in demand_list if key in i) 
     for key in set(a for l in demand_list for a in l.keys())}

print(d)
&gt;&gt;&gt;{'2018-04-21': 1, '2018-04-17': 1, '2018-04-29': 1, '2018-04-30': 1, '2018-04-19': 1, '2018-04-18': 1, '2018-05-01': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another one-liner (ab-)using <code>collections.ChainMap</code> to get the combined keys:</p>
<pre><code>&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; {k: sum(d.get(k, 0) for d in demand_list) for k in ChainMap(*demand_list)}
{'2018-04-17': 1, '2018-04-21': 1, '2018-05-01': 1, '2018-04-30': 1, '2018-04-19': 1, '2018-04-29': 1, '2018-04-18': 1}
</code></pre>
<p>This is easily the slowest of the methods proposed here.</p>
</div>
<div class="post-text" itemprop="text">
<p>The only thing that seemed unclear in your code was the double-for-loop. It may be clearer to collapse the <code>demandlist</code> into a flat iterable—then the loopant presents the logic as simply as possible. Consider:</p>
<pre><code>demandlist = [{
    u'2018-04-29': 1,
    u'2018-04-30': 1,
    u'2018-05-01': 1
}, {
    u'2018-04-21': 1
}, {
    u'2018-04-18': 1,
    u'2018-04-19': 1,
    u'2018-04-17': 1
}]

import itertools as it
from collections import defaultdict

demandresult = defaultdict(int)

for k, v in it.chain.from_iterable(map(lambda d: d.items(), demandlist)):
    demandresult[k] = demandresult[k] + v
</code></pre>
<p>(With this, <code>print(demandresult)</code> prints <code>defaultdict(&lt;class 'int'&gt;, {'2018-04-29': 1, '2018-04-30': 1, '2018-05-01': 1, '2018-04-21': 1, '2018-04-18': 1, '2018-04-19': 1, '2018-04-17': 1})</code>.)</p>
<p>Imagining myself reading this for the first time (or a few months later), I can see myself thinking, "Ok, I'm collapsing <code>demandlist</code> into a key-val iterable, I don't particularly care how, and then summing values of matching keys."</p>
<p>It's unfortunate that I need that <code>map</code> there to ensure the final iterable has key-val pairs… <code>it.chain.from_iterable(demandlist)</code> is a key-only iterable, so I need to call <code>items</code> on each dict.</p>
<p>Note that unlike many of the answers proposed, this implementation (like yours!) minimizes the number of scans over the data to just one—performance win (and I try to pick up as many easy performance wins as I can).</p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose you want to return a list of summed values of each dictionary.</p>
<pre><code>list_of_dict = [
    {'a':1, 'b':2, 'c':3},
    {'d':4, 'e':5, 'f':6}
]

sum_of_each_row = [sum(v for v in d.values()) for d in list_of_dict] # [6,15]
</code></pre>
<p>If you want to return the total sum, just simply wrap sum() to "sum_of_each_row".</p>
<p>EDIT:</p>
<p>The main problem is that you don't have a default value for each of the keys, so you can make use of the method dict.setdefault() to set the default value when there's a new key.</p>
<pre><code>list_of_dict = [
    {'a':1, 'b':1},
    {'b':1, 'c':1},
    {'a':2}
]

d = {}
d = {k:d[k]+v if k in d.keys() else d.setdefault(k,v)
    for row in list_of_dict for k,v in row.items()} # {'a':3, 'b':2, 'c':1}
</code></pre>
</div>
<span class="comment-copy">Could you help me understand, <code>demandlist</code> is, what, a list of dicts whose values somehow have rows? Can you give an example?</span>
<span class="comment-copy">Here are 3 rows of demandlist                                                   {u'2018-04-29': 1, u'2018-04-30': 1, u'2018-05-01': 1}                                                                                                                   {u'2018-04-21': 1}                                                                             {u'2018-04-18': 1, u'2018-04-19': 1, u'2018-04-17' : 1}</span>
<span class="comment-copy">Got it. The fact that you're <i>adding</i> the values of duplicate keys makes me think strongly of a <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer">reduction</a>, which is a general tool to express any such combinations (not just add).</span>
<span class="comment-copy">This solution is totally fine. Maybe just <code>demandresult[k] += v</code></span>
<span class="comment-copy">This dict comp did indeed produce the same output after processing the 494 elements in the list as the for loop in my original question.</span>
<span class="comment-copy">it does but the for loop is much cleaner and should be much faster.</span>
<span class="comment-copy">I do like the dict comprehension—make a set of all the keys, then for each key search the list for entries with it and sum them, convoluted but cool—but yes, it's going to be slow because you're looping over the data more times than you need to (accidentally quadratic). A reasonable compromise might be user <code>itertools.chain</code>?</span>
<span class="comment-copy">Take out those brackets in the function calls to <code>sum()</code> and <code>set()</code>; they force Python to go through the middle step of creating a list and then passing it to the function rather than allowing the function to just use the generator expression directly.</span>
<span class="comment-copy">@M.I.Wright fair enough :)</span>
<span class="comment-copy">From your example, my goal is to pick up the '1' value for key 'a' in row 1, and when I encounter key 'a' in a subsequent row, sum this '1' with whatever value the next occurrence of 'a' contains.   So it's a key matching and summing problem.   I edited the original question to make this clearer.</span>
<span class="comment-copy">Totally understand your problem now. Please see my edit;)</span>
