<div class="post-text" itemprop="text">
<p>How do I accomplish variable variables in Python? </p>
<p>Here is an elaborative manual entry, for instance: <em><a href="http://us3.php.net/manual/en/language.variables.variable.php" rel="noreferrer">Variable variables</a></em></p>
<p>I have heard this is a bad idea in general though, and it is a security hole in Python. Is that true?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use dictionaries to accomplish this. Dictionaries are stores of keys and values. </p>
<pre><code>&gt;&gt;&gt; dct = {'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; dct
{'y': 2, 'x': 1, 'z': 3}
&gt;&gt;&gt; dct["y"]
2
</code></pre>
<p>You can use variable key names to achieve the effect of variable variables without the security risk.</p>
<pre><code>&gt;&gt;&gt; x = "spam"
&gt;&gt;&gt; z = {x: "eggs"}
&gt;&gt;&gt; z["spam"]
'eggs'
</code></pre>
<p>For cases where you're thinking of doing something like</p>
<pre><code>var1 = 'foo'
var2 = 'bar'
var3 = 'baz'
...
</code></pre>
<p>a list may be more appropriate than a dict. A list represents an ordered sequence of objects, with integer indices:</p>
<pre><code>l = ['foo', 'bar', 'baz']
print(l[1])           # prints bar, because indices start at 0
l.append('potatoes')  # l is now ['foo', 'bar', 'baz', 'potatoes']
</code></pre>
<p>For ordered sequences, lists are more convenient than dicts with integer keys, because lists support iteration in index order, <a href="https://stackoverflow.com/questions/509211/understanding-pythons-slice-notation">slicing</a>, <code>append</code>, and other operations that would require awkward key management with a dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the built-in <a href="http://docs.python.org/library/functions.html#getattr" rel="noreferrer"><code>getattr</code></a> function to get an attribute on an object by name.  Modify the name as needed.</p>
<pre><code>obj.spam = 'eggs'
name = 'spam'
getattr(obj, name)  # returns 'eggs'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not a good idea. If you are accessing a global variable you can use <a href="http://docs.python.org/library/functions.html#globals" rel="noreferrer"><code>globals()</code></a>.</p>
<pre><code>&gt;&gt;&gt; a = 10
&gt;&gt;&gt; globals()['a']
10
</code></pre>
<p>If you want to access a variable in the local scope you can use <a href="http://docs.python.org/library/functions.html#locals" rel="noreferrer"><code>locals()</code></a>, but you cannot assign values to the returned dict.</p>
<p><strong>A better solution</strong> is to use <code>getattr</code> or store your variables in a dictionary and then access them by name.</p>
</div>
<div class="post-text" itemprop="text">
<p>Whenever you want to use variable variables, it's probably better to use a dictionary. So instead of writing</p>
<pre><code>$foo = "bar"
$$foo = "baz"
</code></pre>
<p>you write </p>
<pre><code>mydict = {}
foo = "bar"
mydict[foo] = "baz"
</code></pre>
<p>This way you won't accidentally overwrite previously existing variables (which is the security aspect) and you can have different "namespaces".</p>
</div>
<div class="post-text" itemprop="text">
<p>New coders sometimes write code like this:</p>
<pre><code>my_calculator.button_0 = tkinter.Button(root, text=0)
my_calculator.button_1 = tkinter.Button(root, text=1)
my_calculator.button_2 = tkinter.Button(root, text=2)
...
</code></pre>
<p>The coder is then left with a pile of named variables, with a coding effort of O(<em>m</em> * <em>n</em>), where <em>m</em> is the number of named variables and <em>n</em> is the number of times that group of variables needs to be accessed (including creation). The more astute beginner observes that the only difference in each of those lines is a number that changes based on a rule, and decides to use a loop. However, they get stuck on how to dynamically create those variable names, and may try something like this:</p>
<pre><code>for i in range(10):
    my_calculator.('button_%d' % i) = tkinter.Button(root, text=i)
</code></pre>
<p>They soon find that this does not work.</p>
<p>If the program requires arbitrary variable "names," a dictionary is the best choice, as explained in other answers. However, if you're simply trying to create many variables and you don't mind referring to them with a sequence of integers, you're probably looking for a <code>list</code>. This is particularly true if your data are homogeneous, such as daily temperature readings, weekly quiz scores, or a grid of graphical widgets.</p>
<p>This can be assembled as follows:</p>
<pre><code>my_calculator.buttons = []
for i in range(10):
    my_calculator.buttons.append(tkinter.Button(root, text=i))
</code></pre>
<p>This <code>list</code> can also be created in one line with a comprehension:</p>
<pre><code>my_calculator.buttons = [tkinter.Button(root, text=i) for i in range(10)]
</code></pre>
<p>The result in either case is a populated <code>list</code>, with the first element accessed with <code>my_calculator.buttons[0]</code>, the next with <code>my_calculator.buttons[1]</code>, and so on. The "base" variable name becomes the name of the <code>list</code> and the varying identifier is used to access it.</p>
<p>Finally, don't forget other data structures, such as the <code>set</code> - this is similar to a dictionary, except that each "name" doesn't have a value attached to it. If you simply need a "bag" of objects, this can be a great choice. Instead of something like this:</p>
<pre><code>keyword_1 = 'apple'
keyword_2 = 'banana'

if query == keyword_1 or query == keyword_2:
    print('Match.')
</code></pre>
<p>You will have this:</p>
<pre><code>keywords = {'apple', 'banana'}
if query in keywords:
    print('Match.')
</code></pre>
<p>Use a <code>list</code> for a sequence of similar objects, a <code>set</code> for an arbitrarily-ordered bag of objects, or a <code>dict</code> for a bag of names with associated values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of a dictionary you can also use namedtuple from the collections module, which makes access easier.</p>
<p>for example:</p>
<pre><code>#using dictionary
variables = {}
variables["first"] = 34
variables["second"] = 45
print variables["first"], variables["second"]

#using namedtuple
Variables = namedtuple('Variables', ['first', 'second'])
vars = Variables(34, 45)
print vars.first, vars.second
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to use <a href="https://docs.python.org/2/library/functions.html#globals" rel="nofollow noreferrer"><code>globals()</code> built in method</a>  to achieve that behaviour:</p>
<pre><code>def var_of_var(k, v):
    globals()[k] = v

print variable_name # NameError: name 'variable_name' is not defined
some_name = 'variable_name'
globals()[some_name] = 123
print variable_name # 123

some_name = 'variable_name2'
var_of_var(some_name, 456)
print variable_name2 # 456
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use any object, you can still use <code>setattr()</code> inside your current module:</p>
<pre><code>import sys
current_module = module = sys.modules[__name__]  # i.e the "file" where your code is written
setattr(current_module, 'variable_name', 15)  # 15 is the value you assign to the var
print(variable_name)  # &gt;&gt;&gt; 15, created from a string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>SimpleNamespace</code> class could be used to create new attributes with <code>setattr</code>, or subclass <code>SimpleNamespace</code> and create your own function to add new attribute names (variables). </p>
<pre><code>from types import SimpleNamespace

variables = {"b":"B","c":"C"}
a = SimpleNamespace(**v)
setattr(a,"g","G")
a.g = "G+"
something = a.a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>globals()</code></p>
<p>You can actually assign variables to global scope dynamically, for instance, if you want 10 variables that can be accessed on a global scope <code>i_1</code>, <code>i_2</code> ... <code>i_10</code>:</p>
<pre><code>for i in range(10):
    globals()['i_{}'.format(i)] = 'a'
</code></pre>
<p>This will assign 'a' to all of these 10 variables, of course you can change the value dynamically as well. All of these variables can be accessed now like other globally declared variable:</p>
<pre><code>&gt;&gt;&gt; i_5
'a'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm am answering the question: <a href="https://stackoverflow.com/questions/9437726/how-to-get-the-value-of-a-variable-given-its-name-in-a-string">How to get the value of a variable given its name in a string?</a>
which is closed as a duplicate with a link to this question. </p>
<p>If the variables in question are part of an object (part of a class for example) then some useful functions to achieve exactly that are <code>hasattr</code>, <code>getattr</code>, and <code>setattr</code>. </p>
<p>So for example you can have:</p>
<pre><code>class Variables(object):
    def __init__(self):
        self.foo = "initial_variable"
    def create_new_var(self,name,value):
        setattr(self,name,value)
    def get_var(self,name):
        if hasattr(self,name):
            return getattr(self,name)
        else:
            raise("Class does not have a variable named: "+name)
</code></pre>
<p>Then you can do:</p>
<pre><code>v = Variables()
v.get_var("foo")
</code></pre>
<blockquote>
<p>"initial_variable"</p>
</blockquote>
<pre><code>v.create_new_var(v.foo,"is actually not initial")
v.initial_variable
</code></pre>
<blockquote>
<p>"is actually not initial"</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The consensus is to use a dictionary for this - see the other answers. This is a good idea for most cases, however, there are many aspects arising from this:</p>
<ul>
<li>you'll yourself be responsible for this dictionary, including garbage collection (of in-dict variables) etc.</li>
<li>there's either no locality or globality for variable variables, it depends on the globality of the dictionary</li>
<li>if you want to rename a variable name, you'll have to do it manually</li>
<li>however, you are much more flexible, e.g. 

<ul>
<li>you can decide to overwrite existing variables or  ...</li>
<li>... choose to implement const variables</li>
<li>to raise an exception on overwriting for different types</li>
<li>etc.</li>
</ul></li>
</ul>
<p>That said, I've implemented a <a href="https://sourceforge.net/projects/python-vvm/" rel="nofollow">variable variables manager</a>-class which provides some of the above ideas. It works for python 2 and 3.</p>
<p>You'd use <a href="https://sourceforge.net/p/python-vvm/code/ci/master/tree/variableVariablesManager.py" rel="nofollow">the class</a> like this:</p>
<pre><code>from variableVariablesManager import VariableVariablesManager

myVars = VariableVariablesManager()
myVars['test'] = 25
print(myVars['test'])

# define a const variable
myVars.defineConstVariable('myconst', 13)
try:
    myVars['myconst'] = 14 # &lt;- this raises an error, since 'myconst' must not be changed
    print("not allowed")
except AttributeError as e:
    pass

# rename a variable
myVars.renameVariable('myconst', 'myconstOther')

# preserve locality
def testLocalVar():
    myVars = VariableVariablesManager()
    myVars['test'] = 13
    print("inside function myVars['test']:", myVars['test'])
testLocalVar()
print("outside function myVars['test']:", myVars['test'])

# define a global variable
myVars.defineGlobalVariable('globalVar', 12)
def testGlobalVar():
    myVars = VariableVariablesManager()
    print("inside function myVars['globalVar']:", myVars['globalVar'])
    myVars['globalVar'] = 13
    print("inside function myVars['globalVar'] (having been changed):", myVars['globalVar'])
testGlobalVar()
print("outside function myVars['globalVar']:", myVars['globalVar'])
</code></pre>
<p>If you wish to allow overwriting of variables with the same type only:</p>
<pre><code>myVars = VariableVariablesManager(enforceSameTypeOnOverride = True)
myVars['test'] = 25
myVars['test'] = "Cat" # &lt;- raises Exception (different type on overwriting)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a known method to emulate a container for variables, which support both methods of access: by a variable's name and a string key.</p>
<pre><code>class Vars:
    def __init__(self, **kw):
        self.__dict__.update(kw)

    def __getitem__(self, key):
        return self.__dict__[key]

    def __setitem__(self, key, val):
        self.__dict__[key] = val

    def __contains__(self, name):
        return name in self.__dict__

    def __nonzero__(self):
        return bool(self.__dict__)

    def __iter__(self):
        return iter(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def __copy__(self):
        return self.__class__(**self.__dict__)

    def __repr__(self):
        return 'Vars(' + ', '.join('%s=%r' % (k,v) for k,v in self.__dict__.items()) + ')'

&gt;&gt;&gt; vars = Vars()
&gt;&gt;&gt; vars.a = 1
&gt;&gt;&gt; vars['b'] = 2
&gt;&gt;&gt; print(vars)
Vars(a=1, b=2)
&gt;&gt;&gt; print(vars['a'], vars.b)
1 2
&gt;&gt;&gt; print(tuple(vars))
('a', 'b')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Any set of variables can also be wrapped up in a class. 
"Variable" variables may be added to the class instance during runtime by directly accessing the built-in dictionary through __dict__ attribute. </p>
<p>The following code defines Variables class, which adds variables (in this case attributes) to its instance during the construction. Variable names are taken from a specified list (which, for example, could have been generated by program code):</p>
<pre><code># some list of variable names
L = ['a', 'b', 'c']

class Variables:
    def __init__(self, L):
        for item in L:
            self.__dict__[item] = 100

v = Variables(L)
print(v.a, v.b, v.c)
#will produce 100 100 100
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please refer following example to create variables runtime. You can use <code>globals()</code>.</p>
<pre><code>for i in range(3):
    globals() ['variable_'+str(i)] = i
</code></pre>
<p>In the above example, I want to create three variables: <code>variable_0</code>, <code>variable_1</code> and <code>variable_2</code> at runtime with values 0,1 and 2 respectively. </p>
<pre><code>variable_0
[Output]:0

variable_1
[Output]:1

variable_2
[Output]:2
</code></pre>
<p>To access the value of variables created at runtime, you can use <code>eval()</code> method as follows:</p>
<pre><code>for i in range(3):
globals() ['variable_'+str(i)] = i
print('Variable Value:',eval('variable_'+str(i)))

[Output]:
Variable Value: 0
Variable Value: 1
Variable Value: 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use the built-in function <code>vars()</code></p>
<pre><code>&gt;&gt;&gt; foo = 'bar'
&gt;&gt;&gt; vars()[foo] = 'something'
&gt;&gt;&gt; bar
'something'
</code></pre>
</div>
<span class="comment-copy">it's the maintainance and debugging aspects that cause the horror. Imagine trying to find out where variable 'foo' changed when there's no place in your code where you actually change 'foo'. Imagine further that it's someone else's code that you have to maintain... OK, you can go to your happy place now.</span>
<span class="comment-copy">The need does still arise, though. I used to think I needed to do this sort of thing all the time before I met real programming languages. Great suggestions here for transitioning to a saner mindset.</span>
<span class="comment-copy">This is an excellent question to ask, if for no other reason than to help people learn how to avoid it. :)</span>
<span class="comment-copy">A further pitfall that hasn't been mentioned so far is if such a dynamically-created variable has the same name as a variable used in your logic. You essentially open up your software as a hostage to the input it is given.</span>
<span class="comment-copy">It's useful in rare places. I need it somewhere in my code, and it wouldn't cause maintenance problems.</span>
<span class="comment-copy"><a href="http://docs.python.org/library/stdtypes.html#dict" rel="nofollow noreferrer">docs.python.org/library/stdtypes.html#dict</a></span>
<span class="comment-copy">That works great with a namedtuple</span>
<span class="comment-copy">Lovely. This is exactly what I needed.  I have an object and needed to access variables by a string and I didn't want to use <code>eval</code>.  Thanks!</span>
<span class="comment-copy">Don't forget to mention that you can't modify variables through locals() (<a href="http://docs.python.org/library/functions.html#locals" rel="nofollow noreferrer">docs.python.org/library/functions.html#locals</a>).</span>
<span class="comment-copy">You can't set variables this way. You can't do <code>globals()['a'] = 10</code>.</span>
<span class="comment-copy">Thx, also working with locals()['x'] = "xxx"</span>
<span class="comment-copy">@oxidworks No, it's not working. However, it may <i>seem</i> to work if you're in the global context, where <code>locals()</code> simply returns the <code>globals()</code> dict.</span>
<span class="comment-copy">Why not use <code>vars()</code> built-in dictionary?</span>
<span class="comment-copy">This one sounds better to me than using 'exec'.</span>
<span class="comment-copy">This does not work with <code>__dict__</code> variable however. I wonder if there is a general mechanism to create <i>any</i> global variable dynamically.</span>
<span class="comment-copy"><code>globals()</code> can do this</span>
<span class="comment-copy">At first glance the long camelised imports made me think this was Java.</span>
