<div class="post-text" itemprop="text">
<p>I've been trying to switch to Python3. Surprisingly, my difficulty is not with modules or my own code breaking. My issue is that I am always trying and testing different aspects of my code in IPython as I write it, and having generators by default makes this infuriating. I'm hoping there is either a gap in my knowledge or some sort of work around to resolve this.</p>
<p>My issues are:</p>
<ul>
<li><p>Whenever I test a few lines of code or a function and get a generator, I have no idea what's inside since I'm getting a response like this: <code>&lt;generator object &lt;genexpr&gt; at 0x0000000007947168&gt;</code>. Getting around it means I can't just run code directly from my editor -- I need to dump the output into a variable and/or wrap it in a list().</p></li>
<li><p>Once I do start to inspect the generator, I either consume it (fully or partially) which messes it up if I wish to test it further. Partially consuming is especially annoying, because sometimes I don't notice and see odd results from subsequent code.</p></li>
</ul>
<p>Oddly enough, I keep finding that I am introducing bugs (or extraneous code), not because I don't understand lazy evaluation, but because of the mismatch in what I'm evaluating in the console and what's making it's way into my editor slipping through my view.</p>
<p>Off the top of my head, I'd like to do one of the following:</p>
<ul>
<li>Configure IPython in some way to force some kind of strict evaluation (unless I shut it off explicitly)</li>
<li>Inspect a generator without consuming it (or maybe inspect it and then restart itself?)</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Your idea of previewing or rewinding a generator is not possible in the general case. That's because generators can have side effects, which you'd either get earlier than expected (when you preview), or get multiple times (before and after rewinding). Consider the following generator, for example:</p>
<pre><code>def foo_gen():
    print("start")
    yield 1
    print("middle")
    yield 2
    print("end")
</code></pre>
<p>If you could preview the results yielded by this generator (<code>1</code> and <code>2</code>), would you expect to get the print outs too?</p>
<p>That said, there may be some ways for you to make your code easier to deal with.</p>
<p>Consider using list comprehensions instead of generator expressions. This is quite simple in most situations, just put square brackets around the genexp you already have. In many situations where you pass a generator to other code, any iterable object (such as a <code>list</code>) will work just as well.</p>
<p>Similarly, if you're getting generators passed into your code from other places, you can often pass the generator to <code>list</code> and use the list in your later code. This is of course not very memory efficient, since you're consuming the whole generator up front, but if you want to see the values in the interactive console, that's probably going to be necessary.</p>
<p>You can also use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><code>itertools.tee</code></a> to get two (or more) iterators that will yield the same values as the iterable you pass in. This will allow you to inspect the values from one, while passing the other on. Be aware though that the <code>tee</code> code will need to store all the values yielded by any of the iterators until it has been yielded by all of the other iterators too (so if you run one iterator far ahead of the others, you may end up using as much or more memory than if you'd just used a <code>list</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>In case it helps anyone else, this is a line magic for IPython I threw together in response to the answer. It makes it a tiny bit less painful:</p>
<p><code>%ins &lt;var&gt;</code> will create two copies of <code>&lt;var&gt;</code> using <code>itertools.tee</code>. One will be re-assigned to <code>&lt;var&gt;</code> (so you can re-use it in it's original state), the other will be passed to print(list()) so it outputs to terminal.</p>
<p><code>%ins &lt;expr&gt;</code> will pass the expression to print(list())</p>
<p>To install save it as <code>ins.py</code>  in <code>~/.ipython/profile_default/startup</code></p>
<pre><code>from IPython.core.magic import register_line_magic

import itertools

@register_line_magic
def ins(line):
    if globals().get(line, None):
        gen1, gen2 = eval("itertools.tee({})".format(line))
        globals()[line] = gen2
        print(list(gen1))
    else:
        print(list(eval(line)))


# You need to delete this item from the namespace
del ins
</code></pre>
</div>
<span class="comment-copy">This shouldn't be a problem if you restart the code every time you test, and only test one thing at a time. It seems you're not doing one of the two things. Test a piece of code <i>every</i> time you make a piece of code.</span>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a> to "copy" an iterator.</span>
<span class="comment-copy">My problem is that it takes too long and is thus frustrating. Restarting IPython more isn't going to help that. Furthermore, a lot of the work I do is in web scraping, data munging, etc. which means I spend a lot of time experimenting with a large dataset outside of just making some code.</span>
<span class="comment-copy">I feel childish for asking you to clarify further but is the answer really that I must type list(x) in the console over and over? How can I be the only person bothered by this? I don't mean to be petulant, but this is something that comes up so many times each day.</span>
<span class="comment-copy">Well, you can write your code to return lists in the first place, rather than returning generators that you'll later have to convert to lists. Python hasn't really been designed with convenience of interactive use as its highest priority.</span>
