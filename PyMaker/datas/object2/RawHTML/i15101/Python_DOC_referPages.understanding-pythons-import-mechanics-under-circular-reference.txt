<div class="post-text" itemprop="text">
<p>I was playing with examples in order to answer a <a href="https://stackoverflow.com/q/28542427/1540197">question posted here on SO</a> and found hard to understand the mechanics through which python's <code>import *</code> messes up the scope. </p>
<p>First a bit of context: this question does not deal with practical issue; I understand well that <code>from foo import *</code> is frowned upon (rightly so) and I grasp that it is <em>for reasons deeper than clarity in the code</em>. My interest here is in <em>understanding the mechanics that causes bad behaviour with circular <code>import *</code>s</em>. In other words, I understand <em>that</em> the observed behaviour is expected; I don't understand <em>why</em>.</p>
<p>The situation I'm not able to understand are the problems that arise when having, from an imported module (<code>b</code>), a reference to the importing module (<code>a</code>), using <code>*</code>. I managed to observe subtle differences in behaviour when the importing module uses <code>*</code> or not, but the overall (bad) behaviour is the same. I couldn't find any clear explanation neither in the documentation nor on SO.   </p>
<p>Investigating the behaviour through what is available on the scope, I managed to build a small example that illustrates the differences in its content based on the above mentioned question and a few searches I did here in SO and elsewhere. I try to demonstrate as concisely as I can. All code and experiments below were done with python 2.7.8.</p>
<hr/>
<p><strong>Working scenarios</strong></p>
<p>First a trivial module containing a trivial module containing one class, <code>a.py</code>:</p>
<pre><code>class A:
    pass
</code></pre>
<p>A first variant of client code, importing module a, <code>b_v1.py</code>:</p>
<pre><code>from pprint import pprint

def dump_frame(offset=0):
    import sys
    frame = sys._getframe(1+offset)
    d = frame.f_globals
    d.update(frame.f_locals)
    return d

print 'before import v1'
pprint (dump_frame())

import a

print 'after import v1'
pprint (dump_frame())
print a.A()
</code></pre>
<p>Second variant of the same code, importing <code>*</code> from module <code>a</code>, <code>b_v2.py</code>:</p>
<pre><code>from pprint import pprint

def dump_frame(offset=0):
    import sys
    frame = sys._getframe(1+offset)
    d = frame.f_globals
    d.update(frame.f_locals)
    return d

print 'before import v2'
pprint (dump_frame())

from a import * 

print 'after import v2'
pprint (dump_frame())
print A()
</code></pre>
<ul>
<li>Running both <code>b_v1</code> and <code>b_v2</code> produce the same output before the import, and both are able to instantiate A, as expected. After the import, however, again, as expected, they differ. I highlight the difference:</li>
</ul>
<p><code>b_v1.py</code>, has in the scope</p>
<pre><code>'a': &lt;module 'a' from '.../stackoverflow/instance/a.py'&gt;
</code></pre>
<p>while <code>b_v2.py</code> does not, but has </p>
<pre><code>'A': &lt;class a.A at 0x...&gt;
</code></pre>
<ul>
<li><p>Both before and after the import, the scope contains <code>__builtins__</code> set to <code>&lt;module '__builtin__' (built-in)&gt;</code>.</p></li>
<li><p>Both variants succeed in instantiating <code>A</code>.</p></li>
</ul>
<hr/>
<p><strong>Not working scenarios</strong></p>
<p><strong>The intriguing behaviour is when changing <code>a.py</code> to contain a circular reference to <code>b</code></strong> (in both the <code>b_v1</code> and <code>b_v2</code> variants). </p>
<p>Adjusted code of <code>a.py</code>:</p>
<pre><code>from b_v1 import *
class A:
    pass
</code></pre>
<p>(for shortness's sake, only one case of <code>a.py</code> is shown; obviously in the case of <code>b_v2.py</code> the import is for this module, not <code>b_v1.py</code>)</p>
<p>In my observations of the contents of the scope in the scenario with a circular reference, I see: </p>
<ul>
<li><p>In both variants, before the import in <code>a</code>, <code>__builtins__</code> is similar to the cases above. After the import, however, it is changed and contains a <code>dict</code> of </p>
<p>'ArithmeticError': ,
'AssertionError': ,
'AttributeError': ,
...</p></li>
</ul>
<p>which is needlessly long to paste here.</p>
<ul>
<li>The changed <code>__builtins__</code> is present twice. This I can understand as being consequence of the importing and would probably not happen if the code were inside a function.</li>
<li><p>In variant <code>b_v2</code> the module <code>a</code> is present in the scope; it is present in variant <code>b_v1</code>. </p></li>
<li><p>In both variants, instantiation of <code>A</code> fails. Given that in variant <code>b_v1</code> the module is present in the scope (therefore, I assume was successfully imported), I had expected to be able to instantiate <code>A</code>. This is not the case. There are differences, however: in case <code>b_v1.py</code>, it fails with an <code>AttributeError: 'module' object has no attribute 'A'</code> and, as for <code>b_v2.py</code>, failure is a <code>NameError</code>. In this later case, it is always the same error independently of whether I try to instantiate as <code>A()</code> (as in the working example) of <code>a.A()</code>.</p></li>
</ul>
<hr/>
<p>Summarizing my questions: </p>
<ul>
<li><p><strong>Through what mechanics a circular <code>import *</code> messes up the scope</strong>? </p></li>
<li><p><strong>Why is it not possible to instantiate <code>A</code> in the case b_v1, although the module is in the scope?</strong></p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Python modules are executed from top to bottom.  Import statements are executable just like any other.  When an import statement is run, it does these things (simplified for expository purposes, see the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="nofollow">language reference</a> for full details):</p>
<ol>
<li>Check whether the module is listed in <code>sys.modules</code>.  If it is, return it immediately</li>
<li>Find the module (usually but not always by searching through the filesystem).</li>
<li>Create an empty entry for the module in <code>sys.modules</code>, with an empty namespace.</li>
<li>Execute the module from top to bottom within the newly-created namespace.</li>
</ol>
<p>Suppose we have files like this:</p>
<p><code>a.py</code>:</p>
<pre><code>from b import *
foo = object()
</code></pre>
<p><code>b.py</code>:</p>
<pre><code>from a import *
print(repr(foo))
</code></pre>
<p>Further suppose that <code>a.py</code> gets imported first.  Let's go through this line-by-line:</p>
<ol>
<li>Someone else imports <code>a</code>.  A reference to <code>a</code> is stored in <code>sys.modules['a']</code> before we even begin executing it.</li>
<li><code>a.py</code> runs <code>from b import *</code>.  This translates to "<code>import b</code> and then grab everything out of <code>b</code>'s namespace into <code>a</code>'s namespace."</li>
<li>Python places an empty module object in <code>sys.modules['b']</code></li>
<li><code>b.py</code> runs <code>from a import *</code>.  Python imports <code>a</code>.</li>
<li>The import of <code>a</code> returns immediately since <code>sys.modules['a']</code> exists.</li>
<li>Since <code>a.py</code> hasn't yet executed <code>foo = object()</code>, <code>a.foo</code> doesn't yet exist, so it cannot be dumped into <code>b</code>'s namespace.</li>
<li><code>b.py</code> crashes on a <code>NameError</code>.</li>
</ol>
</div>
<span class="comment-copy">You may find it illustrative to also try examples that use <code>from a import A</code> instead of <code>from a import *</code>.  The <code>import *</code> is not the problem; the problem is trying to access something from <code>a</code> when <code>a</code> is not fully loaded yet.</span>
