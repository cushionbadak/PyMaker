<div class="post-text" itemprop="text">
<p>I want to go through a text file and create a dictionary that has keywords and the number of times they pop up.I want it to sort of look like this:</p>
<pre><code>defaultdict(&lt;type 'int'&gt;, {'keyword1': 1, 'keyword2': 0, 'keyword3': 3, 'keyword4': 9})
</code></pre>
<p>right now I get something that looks like this:</p>
<pre><code>defaultdict(&lt;type 'int'&gt;, {'keyword1': 1})
</code></pre>
<p>I can print every keyword in my dictionary as it loops through though so I know it's trying something. I also know that more of these keywords should pop up and they should have instances in the text file. My code:</p>
<pre><code>find_it=['keyword1', 'keyword2', 'keyword3', 'keyword4']

with open('inputfile.txt', 'r') as f:
    out = defaultdict(int)

    for key in find_it:
        counter=0
        for line in f:
            if key in line:
                out[key] += 1

my_keys=dict(**out)
</code></pre>
<p>What am I missing here?</p>
</div>
<div class="post-text" itemprop="text">
<p>Joran is right that a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>Counter</code></a> is a better fit for what you're doing than a <code>defaultdict</code>. Here's an alternative solution:</p>
<p><strong>inputfile.txt</strong></p>
<pre><code>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</code></pre>
<p><strong>count.py</strong></p>
<pre><code>from collections import Counter

find_it = {"be", "do", "of", "the", "to"}

keys = Counter()

with open("inputfile.txt") as f:
    for line in f:
        matches = Counter(w for w in line.split() if w in find_it)
        keys += matches

print(keys)
</code></pre>
<pre><code>$ python count.py
Counter({'the': 5, 'to': 5, 'be': 3, 'of': 3, 'do': 2})
</code></pre>
<p>This finds the number of matches against <code>find_it</code> in each line, and adds them to the running counter <code>keys</code> as it goes along.</p>
<p><strong>EDIT:</strong> As pointed out by Blckknght in the comments, the previous solution missed cases where a keyword appears more than once in a line. The edited version of the code uses a slightly different method than before to overcome that problem.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Counter
my_current_count = Counter(open('inputfile.txt').read().split())
</code></pre>
<p>should do that ... and much simpler </p>
<pre><code>for shared_key in set(my_current_count).intersection(my_list_of_keywords):
    print my_current_count[shared_key]
</code></pre>
<p>in its current state there is too much to do to your original method to make it work and still be recognizable</p>
</div>
<div class="post-text" itemprop="text">
<p>You are already reading everything in the file at the first iteration of <code>for key in find_it:</code> so for the next key, there isn't anything left to read.</p>
<p>I'd recommend you to swap those <code>for</code> loops.</p>
<pre><code>with open('inputfile.txt', 'r') as f:
    out = defaultdict(int)

    for line in f:
        for key in find_it:
            if key in line.strip().split(' '):
                out[key] += 1
</code></pre>
<hr/>
<p>By the way, I'd strongly recommend you to go with <a href="https://stackoverflow.com/a/28418628/793428">Joran Beasley's</a> one line solution as it is much easier to read and understand for anyone who will look at your code in the future.</p>
</div>
<span class="comment-copy">Its worth noting that this counts the number of lines each word appears on (which is what the question's code would also count, if it worked). This may or may not be desirable.Joran Beasley's code,  In contrast, will count the number of appearances of each word, regardless of which lines they appear on (so a line like <code>"keyword1 keyword2 keyword1"</code> would increase the count of <code>"keyword1"</code> by two).</span>
<span class="comment-copy">@Blckknght good catch! Fixed now :-)</span>
<span class="comment-copy">this also looks interesting and I'm going to look into this method. Thanks</span>
<span class="comment-copy">shouldn't it go through the array find it?</span>
<span class="comment-copy">It will go through each word in each line and looks if they are in <code>find_it</code></span>
<span class="comment-copy">Oh I see because once you go through a line you can not go back into it with they keyword the way I have it no! Thank you!</span>
<span class="comment-copy">he is exausting <code>f</code>  with the first item of find it ... I was confuzed carry on :P your answer is valid :P</span>
<span class="comment-copy">sorry I forgot that part it's way up at the top of my editor</span>
