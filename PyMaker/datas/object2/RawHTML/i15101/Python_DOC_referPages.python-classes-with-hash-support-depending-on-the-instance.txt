<div class="post-text" itemprop="text">
<p>I have a mutable class in Python which I would like to be able to "freeze", at that point its immutable, therefor can have a <code>__hash__</code> function.</p>
<p>My concern is, will having the <code>__hash__</code> function present will make Python behave strangely because it may check for the existence of a hash function.</p>
<p>I realize I could use a subclass that has a hash function, copy the class to a subtype. But I'm interested to know if having an <em>optional</em> hash function is supported by Python.</p>
<p>In the example below it works in basic cases (but may fail in others).</p>
<p>Note: <em>This assumes you don't touch <code>_var</code> or <code>_is_frozen</code> directly and only use access methods.</em></p>
<p>Note: its probably more Pythonic not to use this method and instead have a <code>FrozenMyVar</code> class, but Im curious if this can be considered to be <em>supported</em> in Python or not.</p>
<pre><code>class MyVar:
    __slots__ = ("_var", "_is_frozen")

    def __init__(self, var):
        self._var = var
        self._is_frozen = False

    def freeze(self):
        self._is_frozen = True

    def __hash__(self):
        if not self._is_frozen:
            raise TypeError("%r not hashable (freeze first)" % type(self))
        return hash(self._var)

    def __eq__(self, other):
        try:
            return self.val == other.val
        except:
            return NotImplemented

    @property
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        if self._is_frozen:
            raise AttributeError("%r is frozen" % type(self))
        self._var = value


# ------------
# Verify Usage

v = MyVar(10)
v.var = 9

try:
    hash(v)
except:
    print("Hash fails on un-frozen instance")

v.freeze()

try:
    v.var = 11
except:
    print("Assignment fails on frozen instance")

print("Hash is", hash(v))
</code></pre>
<hr/>
<p>Adding a note on the real-world use-case, We have some linear math module with Vector/Matrix/Quaternion/Euler classes. In some cases we want to have for eg, a "set of matrices" or a "dict with vector keys". Its always possible to expand them into tuples but they take up more memory &amp; loose their abilities to behave a our own math types - so the ability to <em>freeze</em> them is attractive.</p>
</div>
<div class="post-text" itemprop="text">
<p>The original example didn't quite work "sensibly", because the class had <code>__hash__</code> but not <code>__eq__</code>, and as <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow">https://docs.python.org/3/reference/datamodel.html#object.<strong>hash</strong></a> says "If a class does not define an <strong>eq</strong>() method it should not define a <strong>hash</strong>() operation either".  But the OP's edit fixed that side issue.</p>
<p>This done, if the class and its instances are indeed used with the discipline outlined, behavior should comply with the specs: instances are "born unhashable" but "become hashable" -- "irreversibly" given said discipline, and only, of course, if their <code>self.val</code> is in turn hashable -- once their <code>freeze</code> method is called.</p>
<p>Of course <code>collections.Hashable</code> will "mis-classify" unfrozen instances (as it only checks for the presence of <code>__hash__</code>, not its actual working), but that is hardly unique behavior:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; isinstance((1, [2,3], 4), collections.Hashable)
True
&gt;&gt;&gt; hash((1, [2,3], 4))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>That <code>tuple</code> does appear "hashable", like all tuples (since its type does define <code>__hash__</code>) -- but if you in fact try <code>hash</code>ing it, you nevertheless get a <code>TypeError</code>, as one of the items is a <code>list</code> (making the whole not actually hashable!-).  Not-yet-frozen instances of the OP's class would behave similarly to such a tuple.</p>
<p>An alternative which does avoid this little glitch (yet doesn't require potentially onerous copies of data) is to model the "freezing" as the instance "changing type in-place", e.g...:</p>
<pre><code>class MyVar(object):
    _is_frozen = False

    def __init__(self, var):
        self._var = var

    def freeze(self):
        self.__class__ = FrozenMyVar

    def __eq__(self, other):
        try:
            return self.val == other.val
        except:
            return NotImplemented

    __hash__ = None

    @property
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        if self._is_frozen:
            raise AttributeError("%r is frozen" % type(self))
        self._var = value


class FrozenMyVar(MyVar):
    _is_frozen = True

    def __hash__(self):
        return hash(self._var)
</code></pre>
<p>This behaves essentially like the original example (I've removed the "slots" to avoid issues with <code>object layout differs</code> errors on <code>__class__</code> assignment) but may be considered an improved object model since "changing type in-place" models well such irreversible changes in behavior (and as a small side effect <code>collections.Hashable</code> now behaves impeccably:-).</p>
<p>The concept of an object "changing type in-place" freaks some out because few languages indeed would even tolerate it, and even in Python of course it's a rare thing to have a practical use case for such an obscure feature of the language.  However, use cases do exist -- which is why <code>__class__</code> assignment is indeed supported!-)</p>
</div>
<span class="comment-copy">Well spotted, <code>__eq__</code> part was an oversight (corrected), actual example is much longer (and has an <code>__eq__</code>).</span>
<span class="comment-copy">Good to know its supported, is this documented anywhere?</span>
<span class="comment-copy">@ideasman42, see <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__hash__</a> : "The only required property is that objects which compare equal have the same hash value" (followed but many instances of "should", but by definition "should" in a standard is strongly advisory, not rigidly normative).  A sea lawyer might dispute whether the required behavior is perfectly matched (it surely would if equality of <code>_is_frozen</code> was also required, rather than just equality of <code>_val</code>) but I would argue it still is (too long a discussion for here:-).</span>
