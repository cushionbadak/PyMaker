<div class="post-text" itemprop="text">
<p><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.rint.html" rel="noreferrer">numpy's round int</a> doesn't seem to be consistent with how it deals with xxx.5 </p>
<pre><code>In [2]: np.rint(1.5)
Out[2]: 2.0

In [3]: np.rint(10.5)
Out[3]: 10.0
</code></pre>
<p>1.5 is rounded up while 10.5 is rounded down. Is there a reason for this? Is it just and artifact of <a href="https://stackoverflow.com/questions/21895756/why-are-floating-point-numbers-inaccurate">the inaccuracy of floats</a>?</p>
<p><strong>Edit</strong></p>
<p>Is there a way to get the desired functionality where n.5 is rounded up i.e. to n+1 for both n = even or odd?</p>
</div>
<div class="post-text" itemprop="text">
<p>So, this kind of behavior (as noted in comments), is a very traditional form of rounding, seen in the <a href="http://en.wikipedia.org/wiki/Rounding#Round_half_to_even" rel="noreferrer">round half to even</a> method. Also known (according to David Heffernan) as banker's rounding. The <code>numpy</code> documentation around this behavior implies that they are using this type of rounding, but also implies that there may be issues with the way in which <code>numpy</code> interacts with the IEEE floating point format. (shown below)</p>
<pre><code>Notes
-----
For values exactly halfway between rounded decimal values, Numpy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
to the inexact representation of decimal fractions in the IEEE
floating point standard [1]_ and errors introduced when scaling
by powers of ten.
</code></pre>
<p>Whether or not that is the case, I honestly don't know. I do know that large portions of the <code>numpy</code> core are still written in FORTRAN 77, which predates the IEEE standard (set in 1984), but I don't know enough FORTRAN 77 to say whether or not there's some issue with the interface here.</p>
<p>If you're looking to just round up regardless, the <code>np.ceil</code> function (ceiling function in general), will do this. If you're looking for the opposite (always rounding down), the <code>np.floor</code> function will achieve this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Numpy rounding does round towards even, but the other rounding modes can be expressed using a combination of operations. </p>
<pre><code>&gt;&gt;&gt; a=np.arange(-4,5)*0.5
&gt;&gt;&gt; a
array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ])
&gt;&gt;&gt; np.floor(a)      # Towards -inf
array([-2., -2., -1., -1.,  0.,  0.,  1.,  1.,  2.])
&gt;&gt;&gt; np.ceil(a)       # Towards +inf
array([-2., -1., -1., -0.,  0.,  1.,  1.,  2.,  2.])
&gt;&gt;&gt; np.trunc(a)      # Towards 0
array([-2., -1., -1., -0.,  0.,  0.,  1.,  1.,  2.])
&gt;&gt;&gt; a+np.copysign(0.5,a)   # Shift away from 0
array([-2.5, -2. , -1.5, -1. ,  0.5,  1. ,  1.5,  2. ,  2.5])
&gt;&gt;&gt; np.trunc(a+np.copysign(0.5,a))   # 0.5 towards higher magnitude round
array([-2., -2., -1., -1.,  0.,  1.,  1.,  2.,  2.])
</code></pre>
<p>In general, numbers of the form n.5 can be accurately represented by binary floating point (they are m.1 in binary, as 0.5=2**-1), but calculations expected to reach them might not. For instance, negative powers of ten are not exactly represented: </p>
<pre><code>&gt;&gt;&gt; (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)
&gt;&gt;&gt; [10**n * 10**-n for n in range(20)]
[1, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
 0.9999999999999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is in fact exactly the rounding specified by the IEEE floating point standard <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="noreferrer">IEEE 754</a> (1985 and 2008). It is intended to make rounding unbiased. In normal probability theory, a random number between two integers has zero probability of being exactly N + 0.5, so it shouldn't matter how you round it because that case never happens. But in real programs, numbers are not random and N + 0.5 occurs quite often. (In fact, you have to round 0.5 every time a floating point number loses 1 bit of precision!) If you always round 0.5 up to the next largest number, then the average of a bunch rounded numbers is likely to be slightly larger than the average of the unrounded numbers: this bias or drift can have very bad effects on some numerical algorithms and make them inaccurate.</p>
<p>The reason rounding to even is better than rounding to odd is that the last digit is guaranteed to be zero, so if you have to divide by 2 and round again, you don't lose any information at all.</p>
<p>In summary, this kind of rounding is the best that mathematicians have been able to devise, and you should WANT it under most circumstances.  Now all we need to do is get schools to start teaching it to children.</p>
</div>
<div class="post-text" itemprop="text">
<p>The built-in round function seems to do what you want, although it only works on scalars:</p>
<pre><code>def correct_round(x):
    try:
        y = [ round(z) for z in x ]
    except:
        y = round(x)    
    return y
</code></pre>
<p>and then to verify:</p>
<pre><code>print correct_round([-2.5,-1.5,-0.5,0.5,1.5,2.5])
&gt; [-3.0, -2.0, -1.0, 1.0, 2.0, 3.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An answer to you edit:</p>
<pre><code>y = int(np.floor(n + 0.5))
</code></pre>
</div>
<span class="comment-copy">Well, there's always Python's built-in <code>round</code>, which rounds a single value, with ties going away from zero. If you need to round all the elements in a numpy array, then of course using Python's <code>round</code> could get quite slow. But as Mark Ransom notes in a comment below, numpy doesn't appear to let you choose the rounding rule.</span>
<span class="comment-copy">@JohnY Nowadays Python's <code>round</code> also rounds to the nearest even integer.</span>
<span class="comment-copy">@KirillBulygin - You bring up a good point. Python 2 (including whatever the latest 2.7.x is) rounds away from zero for ties, but Python 3 rounds toward even for ties.</span>
<span class="comment-copy">Good answer, do you happen to know how to get numpy to round up regardless of even or odd?</span>
<span class="comment-copy">It has nothing to do with "how floats are represented", it has <i>everything</i> to do with the rounding mode being used. There are many to choose from, see e.g. <a href="http://en.wikipedia.org/wiki/IEEE_floating_point#Rounding_rules" rel="nofollow noreferrer">en.wikipedia.org/wiki/IEEE_floating_point#Rounding_rules</a></span>
<span class="comment-copy">@Ben yes, np.ceil will do this.</span>
<span class="comment-copy">@Ben You should not have accepted this incorrect answer. These values are exactly representable. The rounder is known as banker's rounding. Google it. As Mark says, this is documented. Slater, you should be aware of the form of values that are exactly representable.</span>
<span class="comment-copy">Regarding NumPy's <code>ceil</code>: This will not do what OP wants. The ceiling of 10.1 and 10.5 are <i>both</i> 11.0.</span>
<span class="comment-copy">This is only relevant to Python 2. See Python 3 docs: <a href="https://docs.python.org/3/library/functions.html#round" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#round</a></span>
