<div class="post-text" itemprop="text">
<p>Edit: To the people that downvoted: I was perfectly clear that I did not want code and that I had already tried it myself. All I was looking for was an explanation of what mathematical process yielded the sample results.</p>
<p>First question. I have done a lot of research and finally resorted to asking, so if I missed the answer somewhere I apologize. I have a problem I am really struggling with:</p>
<blockquote>
<p>Write a Python 3 script that takes three command line arguments: <br/><br/>1. The name of a text file that contains n strings separated
  by white spaces. <br/>2. A positive integer k. <br/>3. The name of a
  text file that the script will create in order to store all possible
  subsequences of k unique strings out of the n strings from the input
  file, one subsequence per line. <br/><br/>For example, assume the
  command line is gen.py input.txt 3 output.txt and the file input.txt
  contains the following line: <br/><br/>Python Java C++ Java Java Python
  <br/><br/>Then the program should create the file output.txt containing
  the following lines (in any order): <br/><br/>Python Java C++ <br/>Python
  C++ Java <br/>Java C++ Python <br/>C++ Java Python <br/><br/>The
  combinations should be generated with your implementation of a
  generator function (i.e. using the keyword yield).</p>
</blockquote>
<p><br/><br/>From my understanding, based on the sample output this doesn't quite follow the definition of a subsequence; nor are they quite permutations, so I'm at a loss for how to go about this. I know how to do the file IO and command line argument portions, I just can't get the right subsequences. I don't need a direct answer as I am supposed to solve this, but if someone could give me some helpful insight it would be much appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're allowed to use itertools:</p>
<pre><code>import itertools
import sys

def unique_substrings(txt_lst:list, k:int) -&gt; set:
    return set([' '.join(combo) for combo in itertools.combinations(txt_lst, 3) \
                if len(set(combo))==3])

if __name__ == "__main__":
    infile, k, outfile = sys.argv[1:]
    with open(infile) as inf:
        txt_lst = infile.read().split()
    with open(outfile) as outf:
        for line in unique_substrings(txt_lst, k):
            outf.write(line + "\n")
</code></pre>
<p>However from your instructor's comment:</p>
<blockquote>
<p>The combinations should be generated with your implementation of a generator function (i.e. using the keyword yield).</p>
</blockquote>
<p>It doesn't look like that's actually going to work.</p>
<p><code>itertools.combinations</code> could be re-implemented with something approximating the following <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow">(from the docs)</a>:</p>
<pre><code>def combinations(iterable, r):
    # combinations('ABCD', 2) --&gt; AB AC AD BC BD CD
    # combinations(range(4), 3) --&gt; 012 013 023 123
    pool = tuple(iterable)
    n = len(pool)
    if r &gt; n:
        return
    indices = list(range(r))
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)
</code></pre>
</div>
<span class="comment-copy">In the example output, why aren't <code>Java Python C++</code> and <code>C++ Python Java</code> present?</span>
<span class="comment-copy">That is sort of the source of my problem: I could easily write code that produces those 2 strings with the 4 in the sample output above. I believe those 2 are not included because of the order of the original string. Because there is no subsequence with "Python" in the middle.</span>
<span class="comment-copy">I'm assuming you can't use <code>itertools.combinations</code> to do this for you, but that's how you'd do this....</span>
<span class="comment-copy">@AdamSmith: I initially thought of using <code>itertools</code> as well, but it doesn't actually apply here due to the above comments: the result is not all permutations, but rather something that involves the sequence of the words in the input.</span>
<span class="comment-copy">@JohnZwinck combinations respects the sequence of words. <code>[' '.join(combo for combo in itertools.combinations(txt.split(), 3) if len(set(combo)) == 3]</code> is the solution</span>
<span class="comment-copy">I appreciate the answer, but I am still confused. I thought his sample output wasn't a combination or permutation? Because both sets of solutions to those do not satisfy the sample output, so would you be able to explain your solution?</span>
<span class="comment-copy">@m7mansfield it is a combination. Why do you think it's not?</span>
<span class="comment-copy">Well I thought it was some sort of modified permutation because order matters, doesn't it? I know your solution works I'm just trying to understand.</span>
<span class="comment-copy">@m7mansfield order matters in combinations. <code>combinations([0,1,2,3], 3)</code> is all 3-length permutations where order is respected e.g. <code>012 013 023 123</code></span>
<span class="comment-copy">Ah I follow. Well clearly I need to study up on my combinatorics. Thanks again for the help!</span>
