<div class="post-text" itemprop="text">
<p>I am attempting to implement a priority queue in Python. I am following an <a href="http://www.bogotobogo.com/python/python_PriorityQueue_heapq_Data_Structure.php" rel="nofollow">example</a> that I found online. The <code>Skill</code> class overrides the <code>__cmp__</code> method so that the priority queue can order itself. I am getting a error when I run:</p>
<pre><code>TypeError: unorderable types: Skill() &lt; Skill()
</code></pre>
<p>I've found several examples online that say as long as you overload the <code>__cmp__()</code> method the priority queue should be good.</p>
<pre><code>try:
    import Queue as Q  # ver. &lt; 3.0
except ImportError:
    import queue as Q

class Skill(object):
    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        print ('New Level:', description)
        return
    def __cmp__(self, other):
        return cmp(self.priority, other.priority)

q = Q.PriorityQueue()

q.put(Skill(5, 'Proficient'))
q.put(Skill(10, 'Expert'))
q.put(Skill(1, 'Novice'))

while not q.empty():
    next_level = q.get()
    print ('Processing level:', next_level.description)
</code></pre>
<p>I'm currently running Python 3.4.1 on my computer.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__cmp__</code> was removed in Python3, you should use the rich comparison dunder methods instead <code>__lt__</code>, <code>__le__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>.</p>
<p>They work as follows:</p>
<pre><code>a &lt; b  # a.__lt__(b)
a &lt;= b # a.__le__(b)
a == b # a.__eq__(b)
a != b # a.__ne__(b)
a &gt; b  # a.__gt__(b)
a &gt;= b # a.__ge__(b)
</code></pre>
<p>You can also use the the class decorator <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow"><code>functools.total_ordering</code></a> which allows you to specify <code>__eq__</code> and any one of <code>__lt__, __le__, __gt__, __ge__</code> and it will infer the rest of the rich comparison methods.</p>
<pre><code>import functools

@functools.total_ordering
class NewNumber(object):
    def __init__(self, num):
        self.num = num
    def __lt__(self, other):
        return self.num &lt; getattr(other, 'num', other)
        # fancy way of doing self.num &lt; other.num if other.num exists,
        #   else to do self.num &lt; other
    def __eq__(self, other):
        return self.num == getattr(other, 'num', other)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>cmp</code> and <code>__cmp__</code> were only used in Python 2.x; they no longer exist in Python 3.x.  Nowadays, you overload the comparison operators directly by implementing <code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__gt__</code>, <code>__ge__</code>, and <code>__le__</code>.</p>
<p>You can read about this change on the What's New In Python 3.0 page under <a href="https://docs.python.org/3/whatsnew/3.0.html#ordering-comparisons" rel="nofollow">Ordering Comparisons</a>:</p>
<blockquote>
<p>The <code>cmp()</code> function should be treated as gone, and the <code>__cmp__()</code>
  special method is no longer supported. Use <code>__lt__()</code> for sorting,
  <code>__eq__()</code> with <code>__hash__()</code>, and other rich comparisons as needed.</p>
</blockquote>
</div>
<span class="comment-copy">Is that your actual indentation? Also, note that <code>__cmp__</code> is ignored in 3.x, and was replaced by rich comparison: <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__lt__</a>. See e.g. <a href="http://stackoverflow.com/q/8276983/3001761">stackoverflow.com/q/8276983/3001761</a></span>
<span class="comment-copy">That is my actual indentation. I'm new to Python, is another indentation more common? So I should use a rich comparison rather than cmp?</span>
<span class="comment-copy">Indentation is crucial in Python, the code you've posted won't work. Yes, you have to use the rich comparison methods if you're writing for 3.x.</span>
<span class="comment-copy">What specifically is wrong about my indentation? What kind of indentation do you use?</span>
<span class="comment-copy">The body of <code>Skill.__init__</code> isn't indented, and <code>__cmp__</code> is shown as being outside of the class altogether. What do you mean <i>"what kind"</i>?! Indentation is <b>part of Python's syntax</b>.</span>
