<div class="post-text" itemprop="text">
<p>How can I use functions that return multiple values as inputs to a format string, without getting the <code>TypeError: not enough arguments for format string</code> error?</p>
<pre><code>&gt;&gt;&gt; def foo():
...     return 1, 2
... 
&gt;&gt;&gt; foo()
(1, 2)
&gt;&gt;&gt; print "%d,%d,%d" % foo(), 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: not enough arguments for format string
</code></pre>
<p>Expected output: "1,2,3"</p>
</div>
<div class="post-text" itemprop="text">
<h3>Element index</h3>
<p><code>string.format()</code> is more powerful and lets you <a href="https://docs.python.org/2/library/string.html#grammar-token-element_index" rel="nofollow">access list elements or even attributes</a>:</p>
<pre><code>&gt;&gt;&gt; print "{0[0]},{0[1]},{1}".format(foo(), 3)
1,2,3
</code></pre>
<h3>Concatenate tuple</h3>
<p>The problem with <code>foo(), 3</code> is that it's a tuple and an integer, two different types. Instead you can create a 3-tuple via concatenation. If you use <code>string.format()</code> it's a bit trickier, as you need to unpack it first using the <code>*</code> operator so you can use it as arguments:</p>
<pre><code>&gt;&gt;&gt; foo() + (3,)
(1, 2, 3)

&gt;&gt;&gt; print "%d,%d,%d" % (foo() + (3,))
1,2,3

&gt;&gt;&gt; print "{},{},{}".format(*foo() + (3,))
1,2,3
</code></pre>
<h3>Temporary variables</h3>
<p>Of course, you can always do it this way, which is obvious but verbose:</p>
<pre><code>&gt;&gt;&gt; foo1, foo2 = foo()
&gt;&gt;&gt; print "%d,%d,%d" % (foo1, foo2, 3)
1,2,3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason <code>print "%d,%d,%d" % foo(), 3</code> is not working is because Python is thinking you're trying to print two items here: <code>"%d,%d,%d" % foo()</code> and then <code>3</code>. Due to this the first expression clearly fails because of in-sufficient number of items:</p>
<pre><code>&gt;&gt;&gt; def func():
...     print "%d,%d,%d" % foo(), 3
...     
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(func)
  2           0 LOAD_CONST               1 ('%d,%d,%d')
              3 LOAD_GLOBAL              0 (foo)
              6 CALL_FUNCTION            0
              9 BINARY_MODULO       
             10 PRINT_ITEM          
             11 LOAD_CONST               2 (3)
             14 PRINT_ITEM          
             15 PRINT_NEWLINE       
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE        
</code></pre>
<p>In fact even something like <code>"%d,%d,%d" % foo() + (3,)</code> won't work because I guess <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow">operator precedence</a> comes into play here:</p>
<pre><code>&gt;&gt;&gt; def func():
    print "%d,%d,%d" % foo() + (3,)
...     
&gt;&gt;&gt; dis.dis(func)
  2           0 LOAD_CONST               1 ('%d,%d,%d')
              3 LOAD_GLOBAL              0 (foo)
              6 CALL_FUNCTION            0
              9 BINARY_MODULO       
             10 LOAD_CONST               3 ((3,))
             13 BINARY_ADD          
             14 PRINT_ITEM          
             15 PRINT_NEWLINE       
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE 
</code></pre>
<p>A working version will be:</p>
<pre><code>&gt;&gt;&gt; print "%d,%d,%d" % (foo() + (3,))
1,2,3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A general solution to take an arbitrary number of arguments and print them with some delimiter would be to use <code>str.join</code></p>
<pre><code>def foo():
    return 1, 2

&gt;&gt;&gt; print(','.join(map(str,foo())))
1,2
</code></pre>
<p>Another example</p>
<pre><code>def bar():
    return 4,5,6,7

&gt;&gt;&gt; print(','.join(map(str,bar())))
4,5,6,7
</code></pre>
</div>
<span class="comment-copy"><code>print "%d,%d,%d" % (foo() + (3,))</code> should do it.</span>
<span class="comment-copy">Ouch! I didn't reallize you already had <code>(foo() + (3,))</code> in your answer. :/</span>
