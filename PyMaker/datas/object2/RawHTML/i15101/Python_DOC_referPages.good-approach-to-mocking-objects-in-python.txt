<div class="post-text" itemprop="text">
<p>I'm trying to understand Python Mock to better unit test my code.  I haven't done much unit testing in the past, but I want to emphasize it moving forward.  The "with mock.patch('something') as mock:" syntax seems really handy for mocking objects that my code is utilizing.  This has been especially convenient for mimicking database or API calls.</p>
<p>However, I'm noticing as the number of tests I write go up, so does the duplication in my tests.  If I have multiple classes used within my class (MyClass below) that need to be mocked, I need to mock them for multiple tests even if they aren't being directly used for a particular test.  For example:</p>
<pre><code>with context("my test"):
  with it('responds true'):
    with mock.patch('lib.mymodule.ClassA') as MockClassA:
      with mock.patch('lib.mymodule.ClassB') as MockClassB:
        with mock.patch('lib.mymodule.ClassC') as MockClassC:
          MockClassA.return_value = "bogus result"
          f = MyClass("host", "user", "password")
          self.assertEqual(f, "bogus result")
</code></pre>
<p>In this case, MockClassA, B, and C might talk to a database or make an API call, which I don't actually want to do during testing.  But since my class is using each, I need to mock all of them for all tests.  Is there a better way to do this?</p>
<p>EDIT: fixed my code to reflect that I'm using Mamba for unit testing.  I apologize for not mentioning that initially.</p>
</div>
<div class="post-text" itemprop="text">
<p>Is not just a case if <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="nofollow"><code>patch</code> documentation</a> starts with</p>
<blockquote>
<p>patch() acts as a function decorator, class decorator ....</p>
</blockquote>
<p>Use patch as decorator is one of the best way to improve readability and simplicity. Your case become </p>
<pre><code>def TestHostRecordCreation(self):
    @mock.patch('lib.mymodule.ClassC')
    @mock.patch('lib.mymodule.ClassB')
    @mock.patch('lib.mymodule.ClassA')
    def test_create_record(self, MockClassA, MockClassB, MockClassC):
        f = MyClass("host", "user", "password")
        self.assertEqual(f, "bogus result")
</code></pre>
<p>Moreover if you want to make the same patches for all test cases you can decorate the class instead of single methods. <a href="https://docs.python.org/3/library/unittest.mock.html#test-prefix" rel="nofollow">As documented here</a> decorate a class by one of <code>patch</code> decorators act like patch all methods that starts by <code>patch.TEST_PREFIX</code>. In your case we use the default value for <code>patch.TEST_PREFIX</code> and we can write:</p>
<pre><code>@mock.patch('lib.mymodule.ClassC')
@mock.patch('lib.mymodule.ClassB')
@mock.patch('lib.mymodule.ClassA')
def TestHostRecordCreation(self):
    def test_A(self, MockClassA, MockClassB, MockClassC):
        f = MyClass("host", "user", "password")
        self.assertEqual(f, "bogus result")

    def test_B(self, MockClassA, MockClassB, MockClassC):
        f = MyClass("myhost", "myuser", "password")
        self.assertEqual(f, "other bogus result")
</code></pre>
<p>Finally you can use <a href="https://docs.python.org/3/library/unittest.mock.html#patch-multiple" rel="nofollow"><code>patch.multiple</code></a> to patch a set of attributes. In that specific synthetic case seams very powerful but in the real word cases its use is very rare:</p>
<pre><code>@mock.patch.multiple('lib.mymodule', ClassA=mock.DEFAULT, ClassB=mock.DEFAULT, ClassC=mock.DEFAULT)
def TestHostRecordCreation(self):
    def test_A(self, MockClassA, MockClassB, MockClassC):
        f = MyClass("host", "user", "password")
        self.assertEqual(f, "bogus result")

    def test_B(self, MockClassA, MockClassB, MockClassC):
        f = MyClass("myhost", "myuser", "password")
        self.assertEqual(f, "other bogus result")
</code></pre>
<p>Consider to use <code>setUp()</code> and <code>tearDown()</code> if you need to create objects useful for a lot of tests (every test unit framework have something like this). You can either use <code>setUp()</code> and <code>tearDown()</code> to start and stop patches context but my taste is that decorators and <code>with</code> context are more readable. </p>
</div>
<span class="comment-copy">Should that be <code>class TestHostRecordCreation(unittest.TestCase):</code>?</span>
<span class="comment-copy">Your question seems similar to the question asked at <a href="http://stackoverflow.com/q/28223321/748858">stackoverflow.com/q/28223321/748858</a> ... In that answer I show how to move patches into the test cases' <code>setUp</code> method, or to use it as a class decorator.  Have a look there and see if it helps you with your problem here.</span>
<span class="comment-copy">I apologize, I was typing that freehand.  I'm actually using Mamba, not unittest.</span>
<span class="comment-copy">I don't know <code>mamba</code>, but a quick look at the github site seems like it should work very similar ... Move my <code>setUp</code> code into the <code>with before.each</code> block and my <code>tearDown</code> code into <code>with after.each</code> and you're pretty much all set... make some adjustments (e.g. you're not gonna call the super class methods), but the idea should be the same...</span>
<span class="comment-copy">The "with" context managers in mamba were nice at first, but I can't decorate them with patch.  So I tried using patch.start() / patch.stop(), but my tests are starting to look pretty ugly.  I think I'm going to switch over to unittest next time.  Thanks for your link, it was helpful.</span>
<span class="comment-copy">Thanks, that's helpful.  I'm actually using Mamba, which I neglected to mention in my original post (not unittest).  Is there a way to apply this to Mamba, or in your opinion is it worth switching over to unittest instead?</span>
<span class="comment-copy">@blindsnowmobile Of course. In [mentioned documentation] (<a href="https://docs.python.org/3/library/unittest.mock.html#test-prefix" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html#test-prefix</a>) is clear that your class can be of every type (not just a <code>unittest.TestCase</code>). The decorator will just apply decorators to all function where the name starts by  <code>patch.TEST_PREFIX</code> value; default value is <code>test</code> but you can change it as you like. I'll update my answer to remove <code>unittest</code> references and make it more general.</span>
<span class="comment-copy">@blindsnowmobile Updated</span>
<span class="comment-copy">Thanks, I was trying to do this with mamba which seems to complicate matters because I can't decorate the "with" context managers.  Since there are no functions to decorate, I tried to look at the patch.start() / patch.stop() methods in before.each as mgilson referenced above. My tests are starting to look rather clunky though, so I think I'm going to be switching over to unittest next time.  Your solution looks more clean.  Marking this as the solution.</span>
