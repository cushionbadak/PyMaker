<div class="post-text" itemprop="text">
<p>I have a multiprocessing application that has workers running in "while True" loops.  For testing, I'd like to be able to mock sys.exit() in a way like this:</p>
<pre><code>with mock.patch('sys.exit') as sys_mock:
  sys_mock.side_effect = break
</code></pre>
<p>or</p>
<pre><code>with mock.patch('sys.exit') as sys_mock:
  sys_mock.side_effect = return
</code></pre>
<p>So I can break out of the loop and complete my test.  Neither of these work, but is there a different way to do what I'm trying to accomplish?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use an <code>Exception</code> as <code>side_effect</code> to simulate <code>sys.exit</code> behavior without exit from your test.</p>
<p><a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow"><code>side_effect</code></a> documentation say:</p>
<blockquote>
<p>This can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.</p>
</blockquote>
<p>So you can not use a <em>statement</em> like <code>break</code> or <code>return</code> but what you want to do is exit from your run cycle and that can be obtained by raise an Exception ... I hope you don't use a wild <code>try</code>-<code>except</code> in your thread's main cycle.</p>
<p>I wrote a <em>simple</em> example to test it, I used decorator <code>patch</code> syntax and put inline <code>side_effect=Exception</code> that make the test more readable:</p>
<pre><code>import sys
import threading
import unittest
from unittest.mock import patch

class T(threading.Thread):
    def __init__(self,  *args, **kwargs):
        super(T, self).__init__(*args, **kwargs)
        self._interrupt = threading.Event()
        self.started = threading.Event() #Used to be sure that we test run() behavior 
        self.started.clear()
        self.terminated = False

    def interrupt(self):
        self._interrupt.set()

    def run(self, *args, **kwargs):
        self._interrupt.clear()
        self.started.set()
        while not self._interrupt.is_set():
            self._interrupt.wait(timeout=1)
        self.terminated = True
        sys.exit()


class TestInterrupt(unittest.TestCase):

    @patch("sys.exit", side_effect=Exception("Ignore it... just close thread"))
    def test_interrupt(self, mock_sys_exit):
        t = T()
        t.start()
        if not t.started.is_set():
            t.started.wait(timeout=0.2)
        self.assertTrue(t.started.is_set(), "t not started!")
        #Ok t is in run() main cycle: we can test interrupt
        t.interrupt()
        t.join(0.1)
        self.assertTrue(t.terminated)
        self.assertFalse(t.isAlive())
</code></pre>
</div>
<span class="comment-copy">Sorry it took a little time to get back to this.  Your solution worked though.  Throwing the exception breaks me out of my cycle quite nicely.  Thanks!</span>
