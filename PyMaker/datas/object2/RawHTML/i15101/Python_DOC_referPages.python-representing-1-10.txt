<div class="post-text" itemprop="text">
<p>I've know base 2 machines cannot represent certain base 10 values accurately such as 1/10. I've seen examples <a href="https://stackoverflow.com/a/2100520/276949">using Python itself</a>. On my machine:</p>
<pre><code>Python 2.7.8 (default, Oct 18 2014, 12:50:18) 
[GCC 4.9.1] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 1.0/10
0.1
</code></pre>
<p>Why is it accurately represented here?</p>
</div>
<div class="post-text" itemprop="text">
<p>From Python 2.7 and 3.1 onward, Python displays floating point numbers using the shortest representation that, when evaluated, results in the same floating point number. From the <a href="https://docs.python.org/3/whatsnew/3.1.html#other-language-changes" rel="nofollow">documentation</a>:</p>
<blockquote>
<p>Python now uses David Gay’s algorithm for finding the shortest floating point representation that doesn’t change its value. This should help mitigate some of the confusion surrounding binary floating point numbers.</p>
<p>The significance is easily seen with a number like <code>1.1</code> which does not have an exact equivalent in binary floating point. Since there is no exact equivalent, an expression like <code>float('1.1')</code> evaluates to the nearest representable value which is <code>0x1.199999999999ap+0</code> in hex or <code>1.100000000000000088817841970012523233890533447265625</code> in decimal. That nearest value was and still is used in subsequent floating point calculations.</p>
<p>What is new is how the number gets displayed. Formerly, Python used a simple approach. The value of <code>repr(1.1)</code> was computed as <code>format(1.1, '.17g')</code> which evaluated to <code>'1.1000000000000001'</code>. The advantage of using 17 digits was that it relied on IEEE-754 guarantees to assure that <code>eval(repr(1.1))</code> would round-trip exactly to its original value. The disadvantage is that many people found the output to be confusing (mistaking intrinsic limitations of binary floating point representation as being a problem with Python itself).</p>
<p>The new algorithm for <code>repr(1.1)</code> is smarter and returns <code>'1.1'</code>. Effectively, it searches all equivalent string representations (ones that get stored with the same underlying float value) and returns the shortest representation.</p>
<p>The new algorithm tends to emit cleaner representations when possible, but it does not change the underlying values. So, it is still the case that <code>1.1 + 2.2 != 3.3</code> even though the representations may suggest otherwise.</p>
<p>The new algorithm depends on certain features in the underlying floating point implementation. If the required features are not found, the old algorithm will continue to be used. Also, the text pickle protocols assure cross-platform portability by using the old algorithm.</p>
</blockquote>
</div>
<span class="comment-copy">Because it's faking it. <code>&gt;&gt;&gt; '{:.30f}'.format(1./10)</code> <code>'0.100000000000000005551115123126'</code></span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/25898733/why-does-strfloat-return-more-digits-in-python-3-than-python-2">Why does str(float) return more digits in Python 3 than Python 2?</a></span>
