<div class="post-text" itemprop="text">
<p>I have an app that takes in some information, performs some calculations using pandas, and turns the final pandas data frame into a CSV that is then downloaded using the Flask app. How do I download multiple CSVs within one view? It seems that I can only return a single response at a time.</p>
<p>An example snippet:</p>
<pre><code>def serve_csv(dataframe,filename):
    buffer = StringIO.StringIO()
    dataframe.to_csv(buffer, encoding='utf-8', index=False)
    buffer.seek(0)
    return send_file(buffer,
             attachment_filename=filename,
             mimetype='text/csv')

def make_calculation(arg1, arg2):
   '''Does some calculations.
   input: arg1 - string, arg2- string
   returns: a pandas data frame'''

@app.route('test_app', methods=['GET', 'POST']
def test_app():
    form = Form1()
    if form.validate_on_submit():
    calculated_dataframe = make_calculation(str(form.input_1.data), str(form.input_2.data))
        return serve_csv(calculated_dataframe, 'Your_final_output.csv')
    return render_template('test_app.html', form=form)
</code></pre>
<p>So let's say in that example above that make_calculation returned two pandas data frames. How would I print both of them to a CSV?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could return a <a href="http://www.ietf.org/rfc/rfc1341.txt" rel="nofollow">MIME Multipart</a> response, a zip file, or a TAR ball (please note the linked RFC is somewhat out of date, but is easier to quickly get up to speed with because it's in HTML; the official one is <a href="http://www.ietf.org/rfc/rfc1341.txt" rel="nofollow">here</a>).</p>
<p>If you choose to do a MIME multipart response, a good starting point might be to look at the <a href="https://github.com/sigmavirus24/requests-toolbelt/blob/master/requests_toolbelt/multipart/encoder.py" rel="nofollow"><code>MultipartEncoder</code></a> and <a href="https://github.com/sigmavirus24/requests-toolbelt/blob/master/requests_toolbelt/multipart/decoder.py" rel="nofollow"><code>MultipartDecoder</code></a> in <a href="https://github.com/sigmavirus24/requests-toolbelt/" rel="nofollow">requests toolbelt</a>; you may be able to use them directly, or at least subclass/compose using those to get your desired behavior. <a href="https://docs.python.org/3/library/zipfile.html" rel="nofollow">Zip files</a> and <a href="https://docs.python.org/3/library/tarfile.html" rel="nofollow">TAR balls</a> can be implemented using standard library modules.</p>
<p>An alternative would be to design your API so that you were returning JSON, use a header (or XML element or JSON field) to indicate that additional CSVs could be obtained by another request, or similar.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is <strong>all the code</strong> you need using the <a href="https://docs.python.org/3/library/zipfile.html" rel="noreferrer"><code>Zip files</code></a>. It will return a zip file with all of your files.</p>
<p>In my program everything I want to zip is in an <code>output</code> folder so i just use <code>os.walk</code> and put it in the zip file with <code>write</code>. Before returning the <code>file</code> you need to <strong>close</strong> it, if you don't <strong>close</strong> it will return an empty file.</p>
<pre><code>import zipfile
import os
from flask import send_file

@app.route('/download_all')
def download_all():
    zipf = zipfile.ZipFile('Name.zip','w', zipfile.ZIP_DEFLATED)
    for root,dirs, files in os.walk('output/'):
        for file in files:
            zipf.write('output/'+file)
    zipf.close()
    return send_file('Name.zip',
            mimetype = 'zip',
            attachment_filename= 'Name.zip',
            as_attachment = True)
</code></pre>
<p>In the <code>html</code> I simply call the route:</p>
<pre><code>&lt;a href="{{url_for( 'download_all')}}"&gt; DOWNLOAD ALL &lt;/a&gt;
</code></pre>
<p>I hope this helped somebody. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Building on @desfido's answer above, here would be some code implementation that does not involve using zip, and instead downloads two different files:</p>
<pre><code>from requests_toolbelt import MultipartEncoder

def make_calculation(arg1, arg2):
    '''Does some calculations.
    input: arg1 - string, arg2- string
    puts results in two different dataframes
    and stores them in two different files,
    returns the names of those two files'''
    return filename1, filename2

@app.route('test_app', methods=['GET', 'POST'])
def test_app():
    form = Form1()
    if form.validate_on_submit():
        f1, f2 = make_calculation(str(form.input_1.data), str(form.input_2.data))
        m = MultipartEncoder({
           'field1': (f1, open(f1, 'rb'), 'text/plain'),
           'field2': (f2, open(f2, 'rb'), 'text/plain')
        })
        return Response(m.to_string(), mimetype=m.content_type)
   return render_template('test_app.html', form=form)
</code></pre>
</div>
<span class="comment-copy">you could let the user download them as a zip?</span>
<span class="comment-copy">It isn't possible to somehow respond to a request by offering multiple file downloads--one request, one response.  You could bundle the files in a zip, or instead return a web page with download links.</span>
<span class="comment-copy">I'd rather use a context manager, to avoid the close thing: <code>with Zipfile(...) as zf: zf.write(...)</code>. It's cleaner and safer in case of unexpected exceptions. Also, you can use <code>os.listdir()</code> instead of <code>os.walk()</code>.</span>
