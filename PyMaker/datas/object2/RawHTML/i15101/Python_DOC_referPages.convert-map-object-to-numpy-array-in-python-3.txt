<div class="post-text" itemprop="text">
<p>In Python 2 I could do the following:</p>
<pre><code>import numpy as np    
f = lambda x: x**2
seq = map(f, xrange(5))
seq = np.array(seq)
print seq
# prints: [ 0  1  4  9 16]
</code></pre>
<p>In Python 3 it does not work anymore:</p>
<pre><code>import numpy as np    
f = lambda x: x**2
seq = map(f, range(5))
seq = np.array(seq)
print(seq)
# prints: &lt;map object at 0x10341e310&gt;
</code></pre>
<p>How do I get the old behaviour (converting the <code>map</code> results to <code>numpy</code> array)?</p>
<p><strong>Edit</strong>: As @jonrsharpe pointed out in his answer this could be fixed if I converted <code>seq</code> to a list first:</p>
<pre><code>seq = np.array(list(seq))
</code></pre>
<p>but I would prefer to avoid the extra call to <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One more alternative, other than the valid solutions @jonrsharpe already pointed out is to use <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html"><code>np.fromiter</code></a>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np    
&gt;&gt;&gt; f = lambda x: x**2
&gt;&gt;&gt; seq = map(f, range(5))
&gt;&gt;&gt; np.fromiter(seq, dtype=np.int)
array([ 0,  1,  4,  9, 16])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although you refer to it as <code>seq</code>, the <code>map</code> object in Python 3 is <strong>not</strong> a <em>sequence</em> (it's an <em>iterator</em>, see <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="noreferrer">what's new in Python 3</a>). <code>numpy.array</code> needs a sequence so the <code>len</code> can be determined and the appropriate amount of memory reserved; it won't consume an iterator. For example, the <code>range</code> object, which <em>does</em> support most sequence operations, <em>can</em> be passed directly;</p>
<pre><code>seq = np.array(range(5))
print(seq)
# prints: [0 1 2 3 4]
</code></pre>
<p>To restore the previous behaviour, as you're aware, you can explicitly convert the <code>map</code> object back to a sequence (e.g. list or tuple):</p>
<pre><code>seq = np.array(list(seq))  # should probably change the name!
</code></pre>
<p>However, as <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="noreferrer">the documentation</a> puts it:</p>
<blockquote>
<p>a quick fix is to wrap <code>map()</code> in <code>list()</code>, e.g. <code>list(map(...))</code>, but a better fix is often to use a list comprehension (especially when the original code uses <code>lambda</code>)</p>
</blockquote>
<p>So another option would be:</p>
<pre><code>seq = [f(x) for x in range(5)]
</code></pre>
<p>or just:</p>
<pre><code>seq = [x**2 for x in range(5)]
</code></pre>
<p>Alternatively, actually use <code>numpy</code> from the start:</p>
<pre><code>import numpy as np    
arr = np.arange(5)
arr **= 2
print(arr)
# prints [ 0  1  4  9 16] in 2.x and 3.x
</code></pre>
</div>
<span class="comment-copy">I was actually aware about the <code>list</code> solution, but I was asking about a direct one.</span>
<span class="comment-copy">Without converting to <code>list</code> fist. I forgot to mention it.</span>
<span class="comment-copy"><code>fromiter</code>'s example is essentially this: <code>np.fromiter((x*x for x in range(5)),int)</code>.</span>
<span class="comment-copy">@btel no, <code>np.array</code> won't consume the iterator. You need the full list up-front so the appropriate memory can be reserved.</span>
