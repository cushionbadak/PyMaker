<div class="post-text" itemprop="text">
<p>Here is my code:</p>
<pre><code>import imaplib
from email.parser import HeaderParser

conn = imaplib.IMAP4_SSL('imap.gmail.com')
conn.login('example@gmail.com', 'password')
conn.select()
conn.search(None, 'ALL')
data = conn.fetch('1', '(BODY[HEADER])')
header_data = data[1][0][1].decode('utf-8')
</code></pre>
<p>at this point I get the error message </p>
<pre><code>AttributeError: 'str' object has no attribute 'decode'
</code></pre>
<p>Python 3 doesn't have decode anymore, am I right? how can I fix this? </p>
<p>Also, in:</p>
<pre><code>data = conn.fetch('1', '(BODY[HEADER])')
</code></pre>
<p>I am selecting only the 1st email. How do I select all?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to decode an object that is <em>already decoded</em>. You have a <code>str</code>, there is no need to decode from UTF-8 anymore.</p>
<p>Simply drop the <code>.decode('utf-8')</code> part:</p>
<pre><code>header_data = data[1][0][1]
</code></pre>
<p>As for your <code>fetch()</code> call, you are explicitly asking for just the first message. Use a range if you want to retrieve more messages. See the <a href="https://docs.python.org/3/library/imaplib.html#imap4-objects">documentation</a>:</p>
<blockquote>
<p>The <em>message_set</em> options to commands below is a string specifying one or more messages to be acted upon. It may be a simple message number (<code>'1'</code>), a range of message numbers (<code>'2:4'</code>), or a group of non-contiguous ranges separated by commas (<code>'1:3,6:9'</code>). A range can contain an asterisk to indicate an infinite upper bound (<code>'3:*'</code>).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Begin with Python 3, all string is unicode object.</p>
<pre><code>  a = 'Happy New Year' # Python 3
  b = unicode('Happy New Year') # Python 2
</code></pre>
<p>the code before are same. So I think you should remove the <code>.decode('utf-8')</code>. Because you have already get the unicode object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use it by this Method:</p>
<pre><code>str.encode().decode()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not familiar with the library, but if your problem is that you don't want a byte array, one easy way is to specify an encoding type straight in a cast:</p>
<pre><code>&gt;&gt;&gt; my_byte_str
b'Hello World'

&gt;&gt;&gt; str(my_byte_str, 'utf-8')
'Hello World'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It s already decoded in Python3, Try directly it should work.</p>
</div>
<span class="comment-copy">Is there a simple way to do this conditionally? (I only want to decode if the message is encoded.)</span>
<span class="comment-copy">@devinbost: in Python 3? Test for the object type or the <code>decode</code> attribute, <i>or</i> just catch the exception. <code>try: data = data.decode('...') except AttributeError: pass</code>.</span>
<span class="comment-copy">@devinbost: however, you are usually better off decoding closer to the source of your data, where you'll usually know exactly what you have.</span>
<span class="comment-copy"><code>bytearray(str, 'encoding').decode('another_encoding')</code> would do the job if you need to decode <code>idna</code> or any other encoding</span>
<span class="comment-copy">This is useless. You are encoding to UTF-8, then decoding the resulting bytes as UTF-8, ending up where you started. You are keeping the CPU warm with no other benefit.</span>
<span class="comment-copy">@MartijnPieters "ending up where you started" - not if you have escape sequences in your string, for example:  &gt;&gt;&gt; '\u0159'.encode().decode() 'ř'</span>
<span class="comment-copy">@Peter: no, you don't need encoding or decoding for that. <code>'\u0159'</code> prints the exact same output. You are confusing the string literal syntax with the canonical representation of the value.</span>
<span class="comment-copy">You can directly use, There is no need to encode and then decode again.</span>
<span class="comment-copy">They don’t have a <code>bytes</code> object to begin with, and <code>str(bytes_object, codec)</code> is just an alternative spelling for <code>bytes_object.decode(codec)</code>. Both fail if you really have a <code>str</code> instead.</span>
<span class="comment-copy">You're right, this specific question does have a <code>str</code> already. This answer could still be useful to people in the future that may have byte arrays (this was the issue I faced when I originally stumbled upon this post).</span>
<span class="comment-copy">I'm not sure how you stumbled on this post, however, because <code>my_byte_str.decode</code> exists and works, and will not throw the exception in the question.</span>
<span class="comment-copy">Thanks @Aditya The reason I arrived here is because of switching code with 2to3</span>
