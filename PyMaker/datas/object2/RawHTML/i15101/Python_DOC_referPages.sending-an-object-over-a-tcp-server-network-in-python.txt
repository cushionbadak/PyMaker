<div class="post-text" itemprop="text">
<p>I am currently working on a small project experimenting with different regions of python. I decided to make a multi-client TCP server in python, and wanted to be able to send a "packet" through the server, it be received by the other clients then parsed. However, I get an error if I try to send the packet, saying I must send either bytes or a string, is there a way to convert the object into bytes, then back or send the packet object through the server itself.</p>
<p><strong>## EDIT ##</strong></p>
<p>I have researched into UDP servers, and I do not believe that is what I am looking for, I probably provided too little information. I am creating a small trial game, for me and some friends to mess about on, I need there to be a constant connection to the server, as information is going to be constantly being sent across the network such as location,direction,speech,inventory etc. and I wanted a way to turn the entire Entity class into a byte array then send that and it be turned back into an instance of the Entity class when it was received. </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use pickle to serialize/deserialize objects to strings and back. <a href="https://docs.python.org/2/library/pickle.html" rel="nofollow">https://docs.python.org/2/library/pickle.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest possible approach would be to send (gzipped?) JSON'd or <a href="https://pypi.python.org/pypi/msgpack-python/" rel="nofollow">msgpack</a>'d objects.</p>
<p>For example, using UDP, this could look something like the below code; note that you would want to reuse the socket object rather than instantiating a new one every time.</p>
<pre class="lang-py prettyprint-override"><code>import socket
import msgpack

def send_object(obj=None, ip, port):
    if obj:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.sendto(msgpack.dumps(obj), (ip, port))
</code></pre>
</div>
<span class="comment-copy">It's not clear what you mean by a "packet". Can you explain how it is that your code has a packet that it's trying to send?</span>
<span class="comment-copy">Remember that TCP is a reliable <b>stream</b> of data. It has no inherent message boundaries. You need to implement some sort of delineation between messages yourself.</span>
<span class="comment-copy">@DavidSchwartz I have created a class which stores a reference to what the object is, and then the object itself.</span>
<span class="comment-copy">@JonathonReinhart I understand that, I was just wondering whether there was a way to decode what I sent back into an object form as if it had lots of variables, then it would take a while to put all that back into the object</span>
<span class="comment-copy">Before you write any code, specify the protocol you are going to use to exchange data. This should be done at the byte level. Then you can use any method you want to generate and process the stream of bytes specified.</span>
<span class="comment-copy">No. Pickle is <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">unsafe</a>, sending pickled objects over the network and unpickling them on the other side is an extremely bad idea and practice.</span>
<span class="comment-copy">@JackRadforth Read the warning near the top of the page. "Never unpickle data received from an untrusted or unauthenticated source."</span>
<span class="comment-copy">While this link may answer the question, it is better to include the essential parts of the answer here and provide the link for reference.  Link-only answers can become invalid if the linked page changes.</span>
<span class="comment-copy">@mata: It's not that <code>pickle</code> is unsafe, it's that it's unsafe when used with an untrusted source or if unauthenticated.  I send pickled objects over RSA encrypted connections through ssh tunnels to do large scale distributed computing and <code>pickle</code> in that case is not unsafe <b>at all</b>.</span>
<span class="comment-copy">@mata: Agreed... that this is bad practice except between two trusted sources.  With untrusted/insecure sources you might as well just give away root.</span>
<span class="comment-copy">Opening a new socket every time you want to send an object is a bad idea.</span>
<span class="comment-copy">Of course, the function is simply there for reference. I'll amend and add a caveat.</span>
<span class="comment-copy">The problem is, people copy and paste code with zero regard from Stack Overflow. So one person's quick example becomes another's code maintenance nightmare.</span>
<span class="comment-copy">@JonathonReinhart How would I decode the send data, if using msgpack.dumps, or should I use msgpack.pack? Also it throws an error saying "Cannot serialize &lt;__main__.Test instance at 0x02AF9C10&gt;" if I try to dumps it</span>
<span class="comment-copy">could you send executable functions in this way?</span>
