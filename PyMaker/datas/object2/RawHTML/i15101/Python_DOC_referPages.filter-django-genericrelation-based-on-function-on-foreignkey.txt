<div class="post-text" itemprop="text">
<p>I want to find attributes associated to my character that fit in various categories. Eventually I want this output:</p>
<pre><code>"Attributes": {
        "Physical": {
            "Level": 1,
            "Strength": 1,
            "Dexterity": 1,
            "Stamina": 1
        },
        "Mental": {
            "Level": 2,
            "Intelligence": 1,
            "Wits": 1,
            "Resolve": 1
        },
        "Social": {
            "Level": 3,
            "Presence": 1,
            "Manipulation": 1,
            "Composure": 1
        }
    },
</code></pre>
<p>I have an Class/Enum(<a href="https://docs.python.org/3/library/enum.html#autonumber" rel="nofollow noreferrer">AutoNumber</a>) with the attributes in, and a method of finding which is which: </p>
<pre><code>class AttributeAbility(models.Model):

    class Attributes(AutoNumber):
        INTELLIGENCE = ()  # Mental, Power
        WITS = ()  # Mental', 'Finesse
        RESOLVE = ()  # Mental', 'Resistance
        STRENGTH = ()  # Physical', 'Power
        DEXTERITY = ()  # Physical', 'Finesse
        STAMINA = ()  # Physical', 'Resistance
        PRESENCE = ()  # Social', 'Power
        MANIPULATION = ()  # Social', 'Finesse
        COMPOSURE = ()  # Social', 'Resistance

    attribute = EnumField(Attributes)

    @property
    def attribute_type(self):
        attribute_group = lambda attribute: (
            int((attribute.value - 1) / 8)) + 1 % 3

        return Category(attribute_group(self.attribute))

class Category(AutoNumber):
    MENTAL = ()
    PHYSICAL = ()
    SOCIAL = ()
</code></pre>
<p>I connect the AttributeAbility with my character using these classes:</p>
<pre><code>class CrossCharacterMixin(models.Model):
    cross_character_types = models.Q(app_label='mage', model='mage')
    content_type = models.ForeignKey(ContentType, limit_choices_to=cross_character_types,
                                     null=True, blank=True)
    object_id = models.PositiveIntegerField(null=True)
    content_object = GenericForeignKey('content_type', 'object_id')

    class Meta:
        abstract = True

class CharacterAttributeLink(Trait, CrossCharacterMixin):
    MIN = 1
    PRIORITY_CHOICES = (
        (0, 'Unassigned'), (1, 'Primary'), (2, 'Secondary'), (3, 'Tertiary')
    )
    attribute = models.ForeignKey('AttributeAbility')
    priority = models.PositiveSmallIntegerField(
        choices=PRIORITY_CHOICES, default=0
    )

    def __str__(self):
        return self.attribute.attribute.label
</code></pre>
<p>And then on the Mage I have:</p>
<pre><code>attributes = GenericRelation('CharacterAttributeLink')

@property
def physical_attributes(self):
    type_id = Category['PHYSICAL']
    return self.attributes.filter(attribute_type=type_id)
</code></pre>
<p>But I'm getting the error that: <code>Cannot resolve keyword 'attribute_type' into field. Choices are: attribute, attribute_id, content_type, content_type_id, current_value, id, maximum_value, object_id, priority</code></p>
<p>And with my function like so:</p>
<pre><code>@property
def physical_attributes(self):
    type_id = Category['PHYSICAL']
    return self.attributes.filter(attribute__attribute_type=type_id)
</code></pre>
<p>I get this error: <code>Related Field got invalid lookup: attribute_type</code> Which makes some sense (though I've seen this in the docs: <code>&gt;&gt;&gt; Entry.objects.filter(blog_id=4)</code>).</p>
<p>Adding <code>__exact</code> on the end, gives me this: <code>Relation fields do not support nested lookups</code>....at which point I'm lost. Do I need a <a href="https://stackoverflow.com/q/5685037/1075247">custom manager</a>? Do I need to move my <code>physical_attribute</code> function elsewhere?</p>
</div>
<div class="post-text" itemprop="text">
<p>I ended up creating a custom manager:</p>
<pre><code>class CategoryManager(models.Manager):

    '''
    Class to manage instances that rely on the category enum
    '''

    def physical(self):
        return [categorised_item for categorised_item in super(CategoryManager, self).get_queryset().all()
                if categorised_item.category == Category['PHYSICAL']]

    def mental(self):
        return [categorised_item for categorised_item in super(CategoryManager, self).get_queryset().all()
                if categorised_item.category == Category['MENTAL']]

    def social(self):
        return [categorised_item for categorised_item in super(CategoryManager, self).get_queryset().all()
                if categorised_item.category == Category['SOCIAL']]
</code></pre>
<p>And then adding this to my AttributeAbility model:</p>
<pre><code>objects = CategoryManager()
</code></pre>
<p>And defining this property on my character model:</p>
<pre><code>@property
def social_skills(self):
    return [self.skills.filter(skill=skill) for skill
            in SkillAbility.objects.social()]
</code></pre>
</div>
