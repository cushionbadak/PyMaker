<div class="post-text" itemprop="text">
<pre><code>class Point:

    def __init__(self, initX, initY):
        """ Create a new point at the given coordinates. """
        self.x = initX
        self.y = initY

    def getX(self):
        return self.x

    def getY(self):
        return self.y

    def distanceFromOrigin(self):
        return ((self.x ** 2) + (self.y ** 2))** 0.5

    def __str__(self):
        return "x=" + str(self.x) + ", y=" + str(self.y)

    def get_line_to(self, target):
        mx = (-target.x + self.x ) 
        my = (-target.y + self.y)
        grad=my/mx
        c=-(grad*(self.x))+self.y
        return grad
    def halfway(self, target):
        """calculating midpoint"""
        mx = (self.x + target.x) / 2
        my = (self.y + target.y) / 2
        return Point(mx, my)

def cencd(p1,p2,p3):
    """calculating the center of a circle"""
    ma=(p2.getY-p1.getY)/(p2.getX-p1.getX)
    mb=(p3.getY-p2.getY)/(p3.getX-p2.getX)
    hw=p1.halfway(p2)
    x=(ma*mb*(p1.getY-p3.getY)+mb*(p1.getX+p2.getX)-ma*(p2.getX+p3.getX))/2*(mb-ma)
    ya=-(1/ma)*((x-hw.getX)+hw.getY)
    return x,ya

"""defining the points for p1,p2 and p3"""

    p = Point(5,5)

    q = Point(6,-2)

    r=Point(2,-4)

    print(cencd(p,q,r))
</code></pre>
<p>I get this error message:SyntaxError: duplicate argument 'p1' in function definition on
Traceback (most recent call last):
  File "python", line 45, in 
  File "python", line 34, in cencd
TypeError: unsupported operand type(s) for -: 'method' and 'method'</p>
<p>please assist.
"""working solution """"</p>
<pre><code>ma=(p2.y-p1.y)/(p2.x-p1.x)
mb=(p3.y-p2.y)/(p3.x-p2.x)
hw=p1.halfway(p2)

x1=(ma*mb*(p1.y-p3.y)+mb*(p1.x+p2.x)-ma*(p2.x+p3.x))/(2*(mb-ma))
ya=-(1/ma)*((x1-hw.x))+hw.y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both <code>getX</code> and <code>getY</code> are methods in your code, not attributes. So you will need to call them using <code>getX()</code> and <code>getY()</code>.</p>
<p>So <code>ma=(p2.getY-p1.getY)/(p2.getX-p1.getX)</code> becomes:</p>
<pre><code>ma = (p2.getY()-p1.getY())/(p2.getX()-p1.getX())
</code></pre>
<p>And so on, the other code changes.</p>
<p>Otherwise, you can also define your methods as <a href="https://docs.python.org/2/library/functions.html#property" rel="nofollow"><code>@property</code></a>:</p>
<pre><code>class Point:
    ...
    ...
    @property
    def getX(self):
        return self.x
    @property
    def getY(self):
        return self.y
    ...
</code></pre>
<p>And now you can access these as <code>p1.getX</code> and <code>p2.getY</code> and so on.</p>
<p>Note that the above @property decorator turns the method into a getter, which makes sense to use only with private variables (variables defined to start with <code>_</code>).</p>
<p>As such, since both x and y are normal attributes of your class, you can access them directly without using and property decorators or using getter methods, like <code>p1.x</code> and <code>p2.y</code>, as @Padraic points in his post.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need getters or setters in python nor is it pythonic to use them, you should access the attributes directly:</p>
<pre><code>def cencd(p1, p2, p3):
    """calculating the center of a circle"""
    ma = (p2.y - p1.y) / (p2.x - p1.x)
    mb = (p3.y - p2.y) / (p3.x - p2.x)
    hw = p1.halfway(p2)
    x = (ma * mb * (p1.y - p3.y) + mb * (p1.x + p2.x) - ma * (p2.x + p3.x)) / 2 * (mb - ma)
    ya = -(1 / ma) * ((x - hw.x) + hw.y)
    return x, ya
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As Padraic Cunningham said, we don't need getters or setters in Python, but as mu said we can make getters if we want, but normally they are used to get "fake" attributes that are actually computed from true attributes. For example, in the code below I've added a fake <code>norm</code> attribute to your Point class.</p>
<p>I've also added a few more double-underscore methods (aka <a href="http://nedbatchelder.com/blog/200605/dunder.html" rel="nofollow">dunder</a> methods or <a href="http://www.rafekettler.com/magicmethods.html" rel="nofollow">magic methods</a>) to your class. These methods are discussed in <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow">the official Python docs</a>. </p>
<p>One of the most common dunder methods is <code>__repr__()</code> which should return a string that corresponds to how you create an instance of the class. This is especially handy when you're using a class in the interactive interpreter. FWIW, if a class doesn't define a <code>__str__()</code> method its <code>__repr__()</code> method will be used if you attempt to turn a class instance into a string. If a <code>__repr__()</code> method hasn't been defined a default one will be used.</p>
<p>The other dunder methods I've added make it easier to perform arithmetic operations on points; this can make code easier to write and to read. I think you'll agree that it makes the <code>cencd()</code> function a little clearer. (I'm not sure exactly what that function's supposed to do; I assume you've got the algebra correct :) ).</p>
<p>This code was tested on Python 2.6.6; it should run ok on Python 3 without modification.</p>
<pre><code>#!/usr/bin/env python

''' Point class demo

    From http://stackoverflow.com/q/28602056/4014959

    Written by koseph, Padraic Cunningham, and PM 2Ring
    2015.02.19
'''

from __future__ import print_function
from __future__ import division

class Point(object):
    def __init__(self, initX, initY):
        """ Create a new point at the given coordinates. """
        self.x, self.y = initX, initY

    @property
    def norm(self):
        return self.x ** 2 + self.y ** 2

    def distance_from_origin(self):
        return self.norm ** 0.5

    def __repr__(self):
        return 'Point({self.x}, {self.y})'.format(self=self)

    def __str__(self):
        return 'x={self.x}, y={self.y}'.format(self=self)

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __mul__(self, scale):
        return Point(self.x * scale, self.y * scale)

    __rmul__ = __mul__

    def __neg__(self):
        return -1 * self

    def __sub__(self, other):
        return self + -other

    def weighted_mean(self, other, weight):
        cweight = 1.0 - weight
        x = cweight * self.x + weight * other.x
        y = cweight * self.y + weight * other.y
        return Point(x, y)

    def halfway(self, other):
        return self.weighted_mean(other, 0.5)


def cencd(p1, p2, p3):
    """ Calculate the center of a circle """
    a = p2 - p1
    b = p3 - p2
    ma = a.y / a.x
    mb = b.y / b.x
    hw = p1.halfway(p2)
    x = ma * mb * (p1 - p3).y + mb * (p1 + p2).x - ma * (p2 + p3).x
    x /= 2.0 * (mb - ma)
    y = -(x - hw.x + hw.y) / ma
    return Point(x, y)


p1 = Point(3, 4)
print(p1)
print('p1 is {0!r}, its norm is {1}'.format(p1, p1.norm))
print('and its distance from the origin is', p1.distance_from_origin(), end='\n\n')

p2 = Point(7, 2)
print('p2 is', repr(p2), end='\n\n')

print('p1 + p2 is', repr(p1 + p2))
print('p1 * 0.1 is', repr(p1 * 0.1))
print('p2 - p1 is', repr(p2 - p1), end='\n\n')

p3 = 4 * p1
print('p3 is', repr(p3), end='\n\n')

print('Weighted means from p1 to p3')
for i in range(5):
    weight = i / 4.0
    print('{0} {1:4.2f} {2!r}'.format(i, weight, p1.weighted_mean(p3, weight)))
print()

print('center of a circle for p1, p2, &amp; p3:', repr(cencd(p1, p2, p3)))
</code></pre>
<p><strong>output</strong></p>
<pre><code>x=3, y=4
p1 is Point(3, 4), its norm is 25
and its distance from the origin is 5.0

p2 is Point(7, 2)

p1 + p2 is Point(10, 6)
p1 * 0.1 is Point(0.3, 0.4)
p2 - p1 is Point(4, -2)

p3 is Point(12, 16)

Weighted means from p1 to p3
0 0.00 Point(3.0, 4.0)
1 0.25 Point(5.25, 7.0)
2 0.50 Point(7.5, 10.0)
3 0.75 Point(9.75, 13.0)
4 1.00 Point(12.0, 16.0)

center of a circle for p1, p2, &amp; p3: Point(8.22727272727, 12.4545454545)
</code></pre>
</div>
<span class="comment-copy">there is absolutely no need to use getters</span>
<span class="comment-copy">Thanks alot.learnt something new today. I keep seeing this "@" in python codes now i know one its usage. code is working fine,i just need to make the formula correct. Thanks alot</span>
<span class="comment-copy">I used this method and its cleaner too.Thanks</span>
<span class="comment-copy">Than you for the solution and presenting a different way for solving this problem. I went to the link you posted-I have something new to read about .Thanks for your contribution.</span>
