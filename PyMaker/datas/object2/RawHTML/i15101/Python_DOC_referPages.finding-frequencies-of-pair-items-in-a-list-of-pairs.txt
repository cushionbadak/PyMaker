<div class="post-text" itemprop="text">
<p>Let's say I have a long list of this type:</p>
<pre><code>text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b'], ... ]
</code></pre>
<p>Given the first elements, I want to construct a dictionary that would show a count of the second elements. For example in the particular example above, I'd like to have something like this:</p>
<pre><code>{'a': {'b':2, 'd':1},
 'w': {'a':1}
}
</code></pre>
<p>Here's how I unsuccessfully tried to solve it. I constructed a list of unique first elements. Let's call it <code>words</code> and then:</p>
<pre><code>dic = {}

for word in words:
  inner_dic = {}
  for pair in text:
    if pair[0] == word:
      num = text.count(pair)
      inner_dic[pair[1]] = num
  dic[pair[0]] = inner_dic
</code></pre>
<p>I get an obviously erroneous result. One problem with the code is, it overcounts pairs. I am not sure how to solve this. </p>
</div>
<div class="post-text" itemprop="text">
<p>You should do this instead:</p>
<pre><code>for word in words:
  inner_dic = {}
  for pair in text:
    if pair[0] == word:
      num = text.count(pair)
      inner_dic[pair[1]] = num
  dic[word] = inner_dic
</code></pre>
<p>that is, you should be doing <code>dic[word]</code> rather than <code>dic[pair[0]]</code>, which will assign the <code>inner_dic</code> to the first element in the last <code>pair</code> checked, even if <code>pair[0]</code> isn't <code>word</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/collections.html#module-collections" rel="nofollow"><em>collections</em> module</a> makes short work of tasks like this.</p>
<p>Use a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><em>Counter</em></a> for the counting part (it is a kind of dictionary that returns 0 for missing values, making it easy to use <code>+=1</code> for incrementing counts).  Use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><em>defaultdict</em></a> for the outer dict (it can automatically make a new counter for each "first" prefix):</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict, Counter
&gt;&gt;&gt; d = defaultdict(Counter)
&gt;&gt;&gt; text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b']]
&gt;&gt;&gt; for first, second in text:
    d[first][second] += 1
</code></pre>
<p>Here is the equivalent using regular dictionaries:</p>
<pre><code>text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b']]

d = {}
for first, second in text:
    if first not in d:
        d[first] = {}
    inner_dict = d[first]
    if second not in inner_dict:
        inner_dict[second] = 0
    inner_dict[second] += 1
</code></pre>
<p>Either the short way or the long way will work perfectly with the <a href="https://docs.python.org/3/library/json.html#module-json" rel="nofollow"><em>json</em> module</a> (both <em>Counter</em> and <em>defaultdict</em> are kinds of dicts that can be JSON encoded).</p>
<p>Hope this helps.  Good luck with your text analysis :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow">defaultdict</a> combined with a <a href="https://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow">Counter</a> dict:</p>
<pre><code>from collections import Counter, defaultdict
d = defaultdict(Counter)

text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b'] ]

for k, v in text:
    d[k][v] += 1 # for single value
   # d[k].update(v) for multiple values i.e list of words

from pprint import pprint as pp

pp(d)
{'a': Counter({'b': 2, 'd': 1}),
'w': Counter({'a': 1})}
</code></pre>
<p>The defaultdict will create a new key/value pairing where the value is a Counter dict if the key does not exist, if the key exists we just update the value using Counter.update which unlike dict.update will increment the value not overwrite.</p>
<p>using a normal <code>dict</code> without imports we can use <a href="http://www.tutorialspoint.com/python/dictionary_setdefault.htm" rel="nofollow">dict.setdefault</a> which will create a new dict as a value for each key <code>k</code> and set a default value of <code>0</code> for each subkey <code>v</code>:</p>
<pre><code>d = {}
text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b'] ]

for k, v in text:
    d.setdefault(k, {}).setdefault(v,0)
    d[k][v] += 1
pp(d)
{'a': {'b': 2, 'd': 1}, 'w': {'a': 1}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a way using the <a href="https://docs.python.org/2/library/stdtypes.html#dict.setdefault" rel="nofollow">.setdefault</a> method:</p>
<pre><code>text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b'] ]
result={}
for x, y in text:
    result.setdefault(x, {}).setdefault(y,0)
    result[x][y]+=1

&gt;&gt;&gt; result 
{'a': {'b': 2, 'd': 1}, 'w': {'a': 1}}
</code></pre>
<p>No external library required.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>text = [ ['a', 'b'], ['a', 'd'], ['w', 'a'], ['a', 'b']]
d = {}
for i in text:
    if d.get(i[0]):
        if d[i[0]].get(i[1]):
            d[i[0]][i[1]] +=1
        else:
            d[i[0]][i[1]] = 1 
    else:
        d[i[0]] = {i[1] : 1}
print d
&gt;&gt;&gt;{'a': {'b': 2, 'd': 1}, 'w': {'a': 1}}
</code></pre>
</div>
<span class="comment-copy">using .count is not efficient</span>
<span class="comment-copy">Thanks. This is the best answer, because you actually read my code and saw where it went wrong instead of writing something from scratch using ready-made libraries. Kudos!</span>
<span class="comment-copy">I believe there is a separate forum for just code-review. On SO, there should be some value placed on answers that demonstrate the most Pythonic solutions so that others may benefit. Otherwise, we're left with code that is inefficient (such as <i>str.count</i>), that uses indexing instead of unpacking (such as <code>pair[0]</code> and pair[1]`` versus <code>for first, second in text</code>), and that avoids standard library solutions that were specifically designed to solve exactly this kind of problem). So, while you may be happy that someone spotted the error in your code, the answer you selected isn't that great.</span>
<span class="comment-copy">@RaymondHettinger: Thanks for your input. I agree that if only efficiency is taken into account, there are better answers. But nobody initially pointed out the inefficiency in my small snippet of code. There should also be some value placed on answers that take into account the OP's attempts and constraints. Otherwise it becomes a contest of who posts the most Pythonic code sooner, without any regard to the thinking process of the person who is trying to solve their problem. At any rate, thanks for your great answer and I apologize if you think I didn't do justice.</span>
<span class="comment-copy">@RaymondHettinger I would agree that your answer contains better code (it got +1 from me), but I think in good questions which include code it is usually helpful to try and answer based on that code - speaking for myself, I learn more from people correcting my code than providing complete alternatives.</span>
<span class="comment-copy">I agree fully and gave a +1 to this answer.  I just wish the selected answers represented the best practices so that future users of SO who read this will find the right way to do things and have a nice model for how to make their own variants.</span>
<span class="comment-copy">I want to save the final dictionary using <code>json</code>. Sorry if the question is too naive, but does that superfluous <code>Counter</code> method appear in the final text file if I dump it as-is?</span>
<span class="comment-copy">@schmutter, you can cast to a normal dict at the end if required, is there a particular reason  you want to?</span>
<span class="comment-copy">Thanks. Good answer.</span>
<span class="comment-copy">+1 for the straight-forward use of <i>dict.setdefault</i> which was designed to solve exactly this problem.  Too bad the OP is averse to using the standard library which offers even cleaner solutions.</span>
<span class="comment-copy">The good news is that this gets the right answer.  The slightly bad news is that using <i>dict.get</i> instead of the <i>in</i>-operator is slower, less clear, and a bit risky (for applications where <i>None</i> is a valid value in a dict).  The mostly bad news is that this code is far from Pythonic -- the repeated use of indexing, <code>i[0]</code> and <code>i[1]</code> makes the code almost unreadable.</span>
