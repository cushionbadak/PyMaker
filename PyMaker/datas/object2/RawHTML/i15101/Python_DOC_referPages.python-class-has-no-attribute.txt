<div class="post-text" itemprop="text">
<p>I'm new to Python and I'm learning about classes and functions and I want to print a class's function but all i get is the error "Class has no attribute"</p>
<p>items.py:</p>
<pre><code>class Item():
    def __init___(self, name, desc, val):
        self.name   = name
        self.desc   = desc
        self.val    = val

    def print_info(self):
        return '{}\n==========\n{}\n\nValue: {}'.format(self.name, self.desc, self.val)

class Gold(Item):
    def __init__(self):
        super().__init__(name = "Gold", desc = "Golden coin.", val = str(5))
</code></pre>
<p>main.py:</p>
<pre><code>from items import Item

print(Item.Gold.print_info)
</code></pre>
<p>The error is</p>
<pre><code>"AttributeError: type object 'Item' has no attribute 'Gold'"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>Gold</code> is not an attribute on the <code>Item</code> class, no. It is a subclass, and a global name in its own right. You can import it from your <code>items</code> module:</p>
<pre><code>&gt;&gt;&gt; from items import Gold
&gt;&gt;&gt; Gold
&lt;class 'items.Gold'&gt;
</code></pre>
<p>You cannot create an instance of it, because used the wrong name for the <code>Item.__init__</code> method:</p>
<pre><code>&gt;&gt;&gt; from items import Item
&gt;&gt;&gt; Item.__init__
&lt;slot wrapper '__init__' of 'object' objects&gt;
&gt;&gt;&gt; Item.__init___
&lt;function Item.__init___ at 0x1067be510&gt;
&gt;&gt;&gt; Item('a', 'b', 4)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object() takes no parameters
</code></pre>
<p>Note that the method you created has <strong>three</strong> underscores in the name. If you fix that:</p>
<pre><code>class Item():
    def __init__(self, name, desc, val):
        # ^   ^ 2 underscores on both sides
        self.name   = name
        self.desc   = desc
        self.val    = val
</code></pre>
<p>you can create instances of the <code>Gold()</code> class:</p>
<pre><code>&gt;&gt;&gt; Gold()
&lt;items.Gold object at 0x1067cfb00&gt;
&gt;&gt;&gt; gold = Gold()
&gt;&gt;&gt; print(gold.print_info())
Gold
==========
Golden coin.

Value: 5
</code></pre>
<p>Now, if you really wanted to create <em>attributes</em> on the <code>Item</code> class, you'll have to add those <em>after</em> you created the class:</p>
<pre><code>class Item():
    def __init___(self, name, desc, val):
        self.name   = name
        self.desc   = desc
        self.val    = val

    def print_info(self):
        return '{}\n==========\n{}\n\nValue: {}'.format(self.name, self.desc, self.val)

Item.gold = Item('Gold', 'Golden coin.', 5)
</code></pre>
<p>You don't need to create subclasses for that. You <em>could</em> use the <a href="https://docs.python.org/3/library/enum.html" rel="nofollow"><code>enum</code> module</a> here though:</p>
<pre><code>from enum import Enum

class Item(Enum):
    Gold = 'Golden coin.', 5
    Silver = 'Silver coin.', 1

    def __init__(self, desc, val):
        self.desc = desc
        self.val = val

    def print_info(self):
        return '{}\n==========\n{}\n\nValue: {}'.format(self.name, self.desc, self.val)
</code></pre>
<p>Here <code>Gold</code> <em>is</em> an attribute of <code>Item</code>:</p>
<pre><code>&gt;&gt;&gt; Item
&lt;enum 'Item'&gt;
&gt;&gt;&gt; Item.Gold
&lt;Item.Gold: ('Golden coin.', 5)&gt;
&gt;&gt;&gt; print(Item.Gold.print_info())
Gold
==========
Golden coin.

Value: 5
&gt;&gt;&gt; Item.Silver
&lt;Item.Silver: ('Silver coin.', 1)&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's what you're doing wrong:</p>
<ul>
<li><code>Gold</code> is a subclass of <code>Item</code>, not an attribute of it. Your error is popping up when you try to do <code>Item.Gold</code>. Gold is accessed entirely separately.</li>
<li>You need to instantiate your classes into objects. Once you instantiate an object, you can call your methods on it and access its attributes. Each object stores methods and attributes independently, so one gold coin can have a different name, description, value, or even print its info differently.</li>
<li>When trying to access a parent class from within a subclass, you just reference the class name directly rather than using <code>super()</code>.</li>
<li>You have an extra underscore in your <code>Item</code> class's <code>__init__()</code></li>
</ul>
<p>So with that in mind, your new <code>main.py</code> should look like this:</p>
<pre><code>from items import Gold

mygold = Gold() # This is where we instantiate Gold into an object
print(mygold.print_info()) # We call the method on the object itself
</code></pre>
<p>And your <code>items.py</code> will look like this:</p>
<pre><code>class Item():
    def __init__(self, name, desc, val):
        self.name   = name
        self.desc   = desc
        self.val    = val

    def print_info(self):
        return '{}\n==========\n{}\n\nValue: {}'.format(self.name, self.desc, self.val)

class Gold(Item):
    def __init__(self):
        Item.__init__(name = "Gold", desc = "Golden coin.", val = str(5))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can call functions that are in <code>Item</code> from the <code>Gold</code> class but <strong>not</strong> the other way around. So your main should be:</p>
<pre><code>from items import Gold
print(Gold.print_info)
</code></pre>
<p>Please note that if you don't end functions with (), then you'll just get the string representation of the function. But if you do that in your current code it wouldn't work unless you create the object first and then call <code>print_info()</code>.</p>
</div>
<span class="comment-copy">that means that the class Item has no method nor variable named Gold ... even if it did ... Gold has no method or variable named <code>print_info</code></span>
<span class="comment-copy">Why are you trying to call <code>Item.Gold</code>?</span>
<span class="comment-copy"><code>Gold</code> is not an attribute of <code>Item</code> so <code>Item.Gold</code> doesn't make much sense. It's a subclass, it's a entirely differnt thing. What are you trying to achieve?</span>
<span class="comment-copy">You can't use non-static data without instantiating a class, for one</span>
<span class="comment-copy">This is correct, but I did notice the author did use <code>super()</code>. If this is desired, then all that must be done is for <code>Item</code> to subclass <code>object</code> ie <code>class Item( object ):</code></span>
