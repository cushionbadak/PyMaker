<div class="post-text" itemprop="text">
<p>Consider the following two modules:</p>
<pre><code># a.py
x = 1
</code></pre>
<p>and</p>
<pre><code># b.py
x = 2
</code></pre>
<p>Is the output of the following program well-defined and the same across all Python 3 implementations?</p>
<pre><code>from a import *
from b import *
print(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to the documentation for the builtin function <a href="https://docs.python.org/3/library/functions.html#__import__" rel="nofollow"><code>__import__()</code></a> (which is called behind the scenes for each <code>import</code> statement):</p>
<blockquote>
<p>... the statement <code>from spam.ham import eggs, sausage as saus</code> results in</p>
<pre><code>_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
eggs = _temp.eggs
saus = _temp.sausage
</code></pre>
<p>Here, the <code>spam.ham</code> module is returned from <code>__import__()</code>. From this object, the names to import are retrieved and assigned to their respective names.</p>
</blockquote>
<p>While this explanation refers to importing specific names, the mechanism is clear: first, the module is imported, and then, the relevant attributes of that module are assigned to names in the local namespace.</p>
<p>So, <strong>yes</strong>, the behaviour is well-defined: any names assigned as a result of <code>from a import *</code> which conflict with names assigned as a result of a subsequent <code>from b import *</code> are overwritten, just as they would be in the case of ordinary reassignment along the lines of</p>
<pre><code>x = 1
x = 2
</code></pre>
<p>Note that this remains true even if you mess about with the import machinery by replacing <code>builtins.__import__()</code> with a custom-defined import function:</p>
<pre><code>&gt;&gt;&gt; class Fake: pass
... 
&gt;&gt;&gt; def fake_import(name, *args, **kwargs):
...     module = Fake()
...     module.x = name
...     return module
... 
&gt;&gt;&gt; import builtins
&gt;&gt;&gt; builtins.__import__ = fake_import
&gt;&gt;&gt; from nonexistent.module import *
&gt;&gt;&gt; x
'nonexistent.module'
&gt;&gt;&gt; from another_made_up_name import *
&gt;&gt;&gt; x
'another_made_up_name'
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">This is precisely why wildcard imports are discouraged...</span>
<span class="comment-copy">just try it____</span>
<span class="comment-copy">@Puppy I want to know whether it's well-defined, not what the behavior happens to be on my implementation on the day before Valentine's day.</span>
