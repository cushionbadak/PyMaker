<div class="post-text" itemprop="text">
<p>I have always defined variables for classes like:</p>
<pre><code>class A():
    def __init__(self):
        self.x = 1
</code></pre>
<p>However, I discovered it is also simply possible to use:</p>
<pre><code>class A():
    x = 1
</code></pre>
<p>In both cases, a new instance will have a variable x with a value of 1.</p>
<p>Is there any difference?</p>
</div>
<div class="post-text" itemprop="text">
<p>For further reading, in the <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="nofollow">Python Tutorial chapter on classes</a>, that matter is discussed in detail. A summary follows:</p>
<p>There is a difference as soon as non-immutable data structures take part in the game.</p>
<pre><code>&gt;&gt;&gt; class A:
...   x = [1]
... 
&gt;&gt;&gt; a1 = A()
&gt;&gt;&gt; a2 = A()
&gt;&gt;&gt; a1.x.append(2)
&gt;&gt;&gt; a1.x
[1, 2]
&gt;&gt;&gt; a2.x
[1, 2]
</code></pre>
<p>In that case, the same instance of x is used for both class instances. When using <code>__init__</code>, new instances are created when a new A instance is created:</p>
<pre><code>&gt;&gt;&gt; class A:
...   def __init__(self):
...     self.x = [1]
... 
&gt;&gt;&gt; a1 = A()
&gt;&gt;&gt; a2 = A()
&gt;&gt;&gt; a1.x.append(2)
&gt;&gt;&gt; a1.x
[1, 2]
&gt;&gt;&gt; a2.x
[1]
</code></pre>
<p>In the first example, a list is created and bound to <code>A.x</code>. This can be accessed both using <code>A.x</code> and using <code>A().x</code> (for any <code>A()</code>, such as <code>a1</code> or <code>a2</code>). They all share the same list object.</p>
<p>In the second example, <code>A</code> does not have an attribute <code>x</code>. Instead, the objects receive an attribute <code>x</code> during initialization, which is distinct for each object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your question is very imprecise. You speak about "variables for classes", but later you say "instance will have a variable". In fact, your examples are reversed. <em>Second one</em> shows a class A with a variable x, and the <em>first one</em> shows a class A with no variable x, but whose every instance (after <code>__init__</code>, unless deleted) has a variable x.</p>
<p>If the value is immutable, there is not much difference, since when you have <code>a=A()</code> and a doesn't have a variable x, a.x automatically delegates to A.x. But if the value is mutable, then it matters, since there is only <em>one</em> x in the second example, and as many xs as there are instances (zero, one, two, seventeen,...) in the first one.</p>
</div>
<span class="comment-copy">Try doing that with something like a list. See if you can spot the difference.</span>
<span class="comment-copy">In first code snippet x is an instance member, in second it's class member.</span>
<span class="comment-copy">So pretty much in the simpler case, a list would be shared among all instances of the class? That really puts you to think... Did you ever specifically use it to share a list among instances?</span>
<span class="comment-copy">@PascalvKooten You could do that, really depends on the use case whether it makes sense. I cannot recall having done it specifically with a list or any other mutable data structure. This doesnâ€™t mean I did not do it though.</span>
<span class="comment-copy">Nice, I'm happy I asked, it's nice to know something like this exists!</span>
<span class="comment-copy">Try inspecting the <code>__dict__</code>s of <code>A</code>, <code>a1</code> and <code>a2</code> to see where <code>x</code> is being stored and what happens when you assign to it via <code>A.x = ...</code> or <code>a1.x = ...</code>. Basically, assigning to <code>a1.x</code> will cause <code>a1</code> to store something for <code>x</code>, which hides the <code>x</code> field of its class. When <code>x</code> holds a mutable object, you would probably not perform such an assignment and so you end up working with an object that's shared across all instances.</span>
