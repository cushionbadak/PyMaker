<div class="post-text" itemprop="text">
<p>Object: to produce a dict showing which unique values in <code>base[2:]</code> (captured in the list <code>uniques</code>) are associated with
<code>base[1]</code> values (i.e. 5001, 5002 etc.).
The code below works but is too slow for the amount of data I
need to process so I'm looking for a faster way to achieve this.</p>
<pre><code>base = [['a', 5001, 1, 4, 8],
        ['b', 5002, 2, 5],
        ['c', 5002, 2, 5],
        ['d', 5003, 2, 6, 7],
        ['e', 5004, 3, 6, 9]]

uniques = [1,2,3,4,5,6,7,8,9]

uniques_dict = {}

for item in uniques:
    uniques_dict[item] = list(set([records[1] for records in base if item in records[2:]]))

print(uniques_dict)

Output:
{   1: [5001], 2: [5002, 5003], 3: [5004], 
    4: [5001], 5: [5002], 6: [5003, 5004], 
    7: [5003], 8: [5001], 9: [5004] }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Rather than loop over all of <code>records</code> again and again, invert the loop. Make <code>uniques</code> a <em>set</em> for fast membership testing, and loop over <code>records</code> just the once.</p>
<p>Even better, that set can be handled by the dictionary keys:</p>
<pre><code>uniques_dict = {u: [] for u in uniques}

for record in base:
    key, values = record[1], record[2:]
    for unique in uniques_dict.keys() &amp; values:  # the intersection
        uniques_dict[unique].append(key)
</code></pre>
<p>In Python 3, <code>dict.keys()</code> is a <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow">dictionary view object</a> which acts like a set. You can create an intersection with that set with the <code>&amp;</code> and operator. If you are using Python 2, replace <code>uniques_dict.keys()</code> with <a href="https://docs.python.org/2/library/stdtypes.html#dict.viewkeys" rel="nofollow"><code>uniques_dict.viewkeys()</code></a> for the exact same behaviour.</p>
<p>Set intersections are fast and efficient; you still need to match each element in <code>record[2:]</code> against the key set still, but it is O(N) loop rather than a O(NK) loop as each key test is a O(1) operation independent of K = <code>len(unique_keys)</code>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; base = [['a', 5001, 1, 4, 8],
...         ['b', 5002, 2, 5],
...         ['c', 5002, 2, 5],
...         ['d', 5003, 2, 6, 7],
...         ['e', 5004, 3, 6, 9]]
&gt;&gt;&gt; uniques = [1,2,3,4,5,6,7,8,9]
&gt;&gt;&gt; uniques_dict = {u: [] for u in uniques}
&gt;&gt;&gt; for record in base:
...     key, values = record[1], record[2:]
...     for unique in uniques_dict.keys() &amp; values:  # the intersection
...         uniques_dict[unique].append(key)
... 
&gt;&gt;&gt; uniques_dict
{1: [5001], 2: [5002, 5002, 5003], 3: [5004], 4: [5001], 5: [5002, 5002], 6: [5003, 5004], 7: [5003], 8: [5001], 9: [5004]}
</code></pre>
<p>If <code>uniques</code> is a strict superset of all possible values in <code>base[*][2:]</code>, then you don't have to even calculate those up front. Just create dictionary keys as you go along, and use a <code>set()</code> on each <code>record[2:]</code> list to only handle unique values. The <code>uniques_dict</code> values should also be sets to eliminate duplicate keys added:</p>
<pre><code>uniques_dict = {}

for record in base:
    key, values = record[1], record[2:]
    for unique in set(values):
        uniques_dict.setdefault(unique, set()).add(key)
</code></pre>
<p>Now <code>list(uniques_dict)</code> is your list of uniques, built as you process <code>base</code>:</p>
<pre><code>&gt;&gt;&gt; uniques_dict = {}
&gt;&gt;&gt; for record in base:
...     key, values = record[1], record[2:]
...     for unique in set(values):
...         uniques_dict.setdefault(unique, set()).append(key)
... 
&gt;&gt;&gt; uniques_dict
{1: {5001}, 2: {5002, 5003}, 3: {5004}, 4: {5001}, 5: {5002}, 6: {5003, 5004}, 7: {5003}, 8: {5001}, 9: {5004}}
&gt;&gt;&gt; list(uniques_dict)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<span class="comment-copy">Is this Python 2 or Python 3?</span>
<span class="comment-copy">This is Python 2.7. Thank you kindly for the comprehensive answer; your solution is much faster and the commentary is very helpful.</span>
<span class="comment-copy">If it is not expected to have duplicate elements in each record, taking the intersection isn't necessary. Also, replacing the initialization of <code>uniques_dict</code> by <code>collections.defaultdict(list)</code> is neater, and will not require knowing beforehand what are the unique elements.</span>
<span class="comment-copy">@RafaelLerm: ah, I think you may be right there. I find <code>dict.setdefault()</code> to be more convenient when building a dictionary like this; no import required, exact same output, and you don't later have to assign <code>None</code> to the <code>default_factory</code> if you need to disable the autovivication.</span>
<span class="comment-copy">You do make a good point. But I normally don't care about what <code>str</code> returns on my dictionaries, and I like being able to type  <code>d[key].append(x)</code>, and forget about it.</span>
<span class="comment-copy">@RafaelLerm: sure, but being explicit about it with <code>d.setdefault(key, []).append(x)</code> can be helpful when you all you are doing is build a dictionary that later on may be expected to throw key errors for missing keys.</span>
<span class="comment-copy">Martijn, thanks to your answer I have just learned about "For set-like views, all of the operations defined for the abstract base class <code>collections.abc.Set</code> are available (for example, ==, &lt;, or ^).". Good to keep in mind.</span>
