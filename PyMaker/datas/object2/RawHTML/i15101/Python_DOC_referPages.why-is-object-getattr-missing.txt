<div class="post-text" itemprop="text">
<p>Why does <code>object</code> seem not to have a <code>__getattr__</code> method?  It defines both <code>__setattr__</code> and <code>__delattr__</code>.  Doesn't it need all three?</p>
<pre><code>&gt;&gt;&gt; object.__setattr__
&lt;slot wrapper '__setattr__' of 'object' objects&gt;
&gt;&gt;&gt; 
&gt;&gt;&gt; object.__delattr__
&lt;slot wrapper '__delattr__' of 'object' objects&gt;
&gt;&gt;&gt; 
&gt;&gt;&gt; object.__getattr__
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: type object 'object' has no attribute '__getattr__'
&gt;&gt;&gt; sys.version
'2.7.3 (default, Feb 27 2014, 19:58:35) \n[GCC 4.6.3]'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Indeed, <code>object</code> does not have a <code>__getattr__</code> method.</p>
<pre><code>&gt;&gt;&gt; import pprint
&gt;&gt;&gt; pprint.pprint(dir(object))
['__class__',
 '__delattr__',
 '__doc__',
 '__format__',
 '__getattribute__',
 '__hash__',
 '__init__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__']
</code></pre>
<p>Instead, it has <code>__getattribute__</code>.</p>
<pre><code>&gt;&gt;&gt; object.__getattribute__
&lt;slot wrapper '__getattribute__' of 'object' objects&gt;
</code></pre>
<p><a href="https://docs.python.org/2/reference/datamodel.html#object.__getattribute__" rel="noreferrer"><code>https://docs.python.org/2/reference/datamodel.html#object.__getattribute__</code></a> explains why:</p>
<blockquote>
<p><code>object.__getattribute__(self, name)</code></p>
<blockquote>
<p>Called unconditionally to implement attribute accesses for instances of the class. If the class also defines <code>__getattr__()</code>, the latter will not be called unless <code>__getattribute__()</code> either calls it explicitly or raises an <code>AttributeError</code>.</p>
</blockquote>
</blockquote>
<p>In other words, if you have <code>__getattribute__</code>, it doesn't make sense to also define <code>__getattr__</code>.</p>
<p>Historically, <code>__getattr__</code> came first, and <code>__getattribute__</code> was introduced with "new-style classes" in Python 2.3 (iirc).  Python 3 only has new-style classes but seems to have preserved both hooks anyway (perhaps because it can be convenient to have a hook that is <em>only</em> called if "normal attribute access" fails).</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/reference/datamodel.html#object.__getattr__" rel="nofollow"><code>__getattr__</code></a> is a method that runs only after <a href="https://docs.python.org/2/reference/datamodel.html#object.__getattribute__" rel="nofollow"><code>__getattribute__</code></a>. Since <code>object</code> has the latter, there is technically no need for the former. But in general, you shouldnâ€™t expect <code>object</code> to have all the things that other objects (deriving from it) have. Since <code>object</code> is implemented in native code, it may behave a bit differently.</p>
</div>
<span class="comment-copy"><code>__getattr__</code> is typically used for computed attributes. For instance, <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>unittest.mock</code></a> uses <code>__getattr__</code> when accessing attributes of a mocked object.</span>
<span class="comment-copy">@Dunes: That or <code>@property</code>/descriptors.  It all depends on what precise effect you're trying to create.</span>
<span class="comment-copy">Most of all, <code>__getattr__</code> is optional, <code>__setattr__</code>, <code>__delattr__</code> and  <code>__getattribute__</code> are not.</span>
