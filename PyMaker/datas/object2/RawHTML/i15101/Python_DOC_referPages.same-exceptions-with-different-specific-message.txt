<div class="post-text" itemprop="text">
<p>I tried to write a code that can distinguish the following four different errors.</p>
<ol>
<li><code>TypeError</code>: The first parameter is not an integer;</li>
<li><code>TypeError</code>: The second parameter is not a string;</li>
<li><code>ValueError</code>: The value of the first parameter is not in the range of <code>1</code> to <code>13</code>; or</li>
<li><code>ValueError</code>: The value of the second parameter is not one of the strings in the set <code>{'s', 'h', 'c', 'd'}</code>.</li>
</ol>
<p>However, I only can get the first one to work but not the other three errors. I tried different ways to make it work, but still can't figure out what's wrong.</p>
<pre><code>class Card: # One object of class Card represents a playing card

    rank = ['','Ace','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Jack','Queen','King']
    suit = {'d':'Diamonds', 'c':'Clubs', 'h':'Hearts', 's':'Spades'}

    def __init__(self, rank=2, suit=0): # Card constructor, executed every time a new Card object is created
        if type(rank) != int:
            raise TypeError()
        if type(suit) != str:
            raise TypeError()
        if rank != self.rank:
            raise ValueError()
        if suit != 'd' or 'c' or 'h' or 's':
            raise ValueError()
        self.rank = rank
        self.suit = suit

    def getRank(self): # Obtain the rank of the card
        return self.rank

    def getSuit(self): # Obtain the suit of the card
        return Card.suit[self.suit]

    def bjValue(self): # Obtain the Blackjack value of a card
        return min(self.rank, 10)

    def __str__(self): # Generate the name of a card in a string
        return "%s of %s" % (Card.rank[int(self.rank)], Card.suit[self.suit])

if __name__ == "__main__": # Test the class Card above and will be skipped if it is imported into separate file to test
    try:
        c1 = Card(19,13)
    except TypeError:
        print ("The first parameter is not an integer")
    except TypeError:
           print ("The second parameter is not a string")
    except ValueError:
        print ("The value of first parameter is not in the range of 1 to 13")
    except ValueError:
        print ("The value of second parameter is not one of the strings in the set {'s','h','c','d'}")

    print(c1)
</code></pre>
<p>I know maybe it is due to that I have same <code>TypeError</code> and <code>ValueError</code>. Therefore, Python can't distinguish the second <code>TypeError</code> which I hit <code>c1 = Card(13,13)</code> is different from the first <code>TypeError</code>. So, I only get the message that <code>"The first parameter is not an integer"</code> when I have <code>c1 = Card(13,13)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to distinguish between the error sources in <strong>completely the wrong place</strong>. By the time the error gets out of <code>Card.__init__</code>, there is no way to tell <em>why</em> e.g. a <code>TypeError</code> was thrown. For each error class (<code>TypeError</code>, <code>ValueError</code>) <strong>only the first</strong> <code>except</code> will ever be triggered:</p>
<pre><code>try:
    ...
except TypeError:
    # all TypeErrors end up here
except TypeError:
    # this is *never* reached
except ValueError:
    # all ValueErrors end up here
except ValueError:
    # this is *never* reached
</code></pre>
<p>Instead, you should provide the specific error messages <strong>inside</strong> <code>Card.__init__</code>, when you actually <code>raise</code> the error and <em>already know</em> what the reason is:</p>
<pre><code>if not isinstance(rank, int):  # better than comparing to type
    raise TypeError("The first parameter is not an integer")
</code></pre>
<p>Then you can handle them much more simply:</p>
<pre><code>try:
    c1 = Card(19,13)
except (TypeError, ValueError) as err:  # assign the error to the name 'err'
    print(err)  # whichever we catch, show the user the message
else:
    print(c1)  # only print the Card if there were no errors
</code></pre>
<hr/>
<p>If you have a particular need to distinguish between different errors of the same class, you can either explicitly check the message:</p>
<pre><code>except TypeError as err:
    if err.args[0] == "The first parameter is not an integer":
        # do whatever you need to
</code></pre>
<p>or create your own, more specific <code>Exception</code> sub-classes, so you can have separate <code>except</code> blocks:</p>
<pre><code>class FirstParamNotIntError(Exception):
    pass
</code></pre>
<p><em>(this is just an example, they are too specific in your particular case).</em></p>
<hr/>
<p>It's probably worth having a read through <a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow">the documentation on exceptions</a> and <a href="https://docs.python.org/3/tutorial/errors.html" rel="nofollow">the tutorial on using them</a>.</p>
</div>
<span class="comment-copy">Thank you, Jonrsharpe. Very Helpful. I followed both your suggestion and the link you posted above, but my code at the end can't give me the right output if I input c1 = Card(12, 'h') since it still gives the ValueError.  For my second ValueError in suit, I wrote if suit != self.suit:   raise ValueError("The value of second parameter is not one of the set....   And for the try/except at the end of my code, I wrote same try with c1 = Card(12, 'h'). except (TypeError, ValueError) as err: print(err)   else: print(c1). But, it still give me the ValueError.  What's wrong in my code?</span>
<span class="comment-copy">I will just add that comparing exception messages, in general, should be used only as a last resort, and especially so if the code raising the exception is not yours. Exception messages do get changed, so It creates very brittle code. Certainly don't be afraid of creating your own Exception (sub)class if it allows you to capture better information about the error.</span>
<span class="comment-copy">Thank you, Jonrsharpe. Very Helpful. I followed both your suggestion and the link you posted above, but my code at the end can't give me the right output if I input c1 = Card(12, 'h') since it still gives the ValueError.  For my second ValueError in suit, I wrote if suit != self.suit:   raise ValueError("The value of second parameter is not one of the set....   And for the try/except at the end of my code, I wrote same try with c1 = Card(12, 'h'). except (TypeError, ValueError) as err: print(err)   else: print(c1). But, it still give me the ValueError.  What's wrong in my code?</span>
<span class="comment-copy">@WuChu why would you expect <code>suit != self.suit</code> to work?! How could something that you're <i>just</i> checked is a string be equal to a dictionary? Perhaps you should have a look at <a href="http://stackoverflow.com/q/15112125/3001761">stackoverflow.com/q/15112125/3001761</a>. Also, using the same name for a class attribute and an instance attribute is a bad move.</span>
<span class="comment-copy">@jonrsharpe Ok, I can fixed the suit != self.suit into suit != 'd' or 'h' or 'c' or 's' or suit not in self.suit. But, what do you mean for the same name for a class attribute and an instance attribute is bad move? Is this related to why I am not getting the correct output if I input c1 = Card(13, 'd')?</span>
<span class="comment-copy">That is still not correct - did you <b>read</b> the question I just linked? Also, I mean you are using e.g. <code>rank</code> for both the list of valid ranks, and the current instance's rank.</span>
