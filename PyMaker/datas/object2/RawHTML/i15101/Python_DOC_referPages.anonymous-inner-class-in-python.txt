<div class="post-text" itemprop="text">
<p>So I have a button class that does something when clicked, but different buttons perform different functions. I was wondering if there is such a thing as anonymous inner classes in Python to override such a callback without creating a new class altogether for each type of button. I know that I can assign a callback attribute to call such a function, but I am just wondering if there is an anonymous inner class equivalent.</p>
<pre><code>class Button:
    def __init__(self):
        # set image here

    def update(self):
        if mouse_clicked():
            # do something
</code></pre>
<p>In Java I can create anonymous inner classes to override the update method for close, play, pause, and all other buttons without creating an entirely different class.</p>
<pre><code>class Button {

    Button() {
        // set image here
    }

    public void update() {
        if mouse_clicked() {
            // do something
        }
    }
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sure, you can (although probably shouldn't) just use <a href="https://docs.python.org/3/library/functions.html#type" rel="nofollow"><code>type</code></a>:</p>
<pre><code>In [1]: class Button:
   ...:     def callback(self):
   ...:         print('Hello')
   ...:         


In [2]: button = type('', (Button,), {'callback': lambda self: print('World')})()

In [3]: button.callback()
World
</code></pre>
<p>You may prefer to define the function outside the expression, so as to be able to avoid code-golfing it:</p>
<pre><code>In [5]: def callback(self):
   ...:     print('World')
   ...: button = type('', (Button,), {'callback': callback})()
   ...: 

In [6]: button.callback()
World
</code></pre>
<p>This does exactly what Java is doing, however it does so more explicitly, and thus, with a more cumbersome syntax. In fact in python you can define local classes:</p>
<pre><code>In [7]: def function():
   ...:     class MyButton(Button):
   ...:         def callback(self):
   ...:             print('Hello, from a local class!')
   ...:     return MyButton()
   ...: 

In [8]: button = function()

In [9]: button.callback()
Hello, from a local class!
</code></pre>
<p>The only difference with respect to Java is that you must give a name to the class and use it to create an instance. Using a decorator you could avoid this last step:</p>
<pre><code>def auto_instantiator(*args, **kwargs):
    def decorator(cls):
        return cls(*args, **kwargs)
    return decorator
</code></pre>
<p>Used as:</p>
<pre><code>In [2]: class Button:
   ...:     def callback(self):
   ...:         print('Button')
   ...:         

In [3]: @auto_instantiator()   # here args that should be passed to __init__
   ...: class button(Button):
   ...:     def callback(self):
   ...:         print('New Button')
   ...: # no need for button = button(...) 

In [4]: button.callback()    # button is an *instance* of the button class
New Button
</code></pre>
<p>However, depending on how you are going to use that method, I'd suggest two different ways to handle the problem:</p>
<ol>
<li><p>Actually all the actions of the buttons are the same, except for some data. In this case it's probably better to just create an instance attribute (or a property) to hold that data, and change the data instead of the method:</p>
<p>I mean something like this:</p>
<pre><code>class Greeter:
    def __init__(self, name):
        self.name = name
    def greet(self):
        print('Hello, {.name}'.format(self))
</code></pre></li>
<li><p>You can just set the instance attribute to the callback you want:</p>
<pre><code>button.callback = new_callback
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to make an anonymous class -- python lets you replace methods with any callable (in fact, any object on the fly):</p>
<pre><code>Button.update = lambda x: x*x 
</code></pre>
<p>is perfectly valid.</p>
<p>EDIT:
The Java approach doesn't actually save you from generating any class -- that class just doesn't have a name, so there's no "benefit" doing that.</p>
</div>
<span class="comment-copy">Generally, I get the feeling that python's way to do this is to create a Button base class and then just override the methods that need to be overridden for each individual button... (but, I'm not a Java programmer, so I could be mis-interpretting what you want to do...)</span>
<span class="comment-copy">Concerning the Java approach, I think it does create a class, only that its scope is restricted. In Python, you can create classes inside of functions, which is very similar. Note that I actually mean classes, not instances!</span>
<span class="comment-copy">Well, they are not completely equivalent, in Python, a class within a function would create a completely new class object for each run, whereas in Java it is more like a Python closure.</span>
<span class="comment-copy">I think the text and the example don't match together. The text talks about anonymous classes in Java, but there is no such example in the code...</span>
<span class="comment-copy">but again in Java one would rather use event listeners instead of subclassing for many GUI related events...</span>
<span class="comment-copy">Thanks, this is probably the closest to what I have in mind.</span>
<span class="comment-copy">@MalikBrahimi I've added the decorator solution I mentioned that avoids the extra assignment when defining local classes. However, I personally would avoid that kind of thing.</span>
<span class="comment-copy">First of all, I do not understand what the x would be in this case for the lambda. Secondly, I would I have to change the method back after every initialization.</span>
<span class="comment-copy">does my edit help?</span>
<span class="comment-copy">No it really doesn't. I'm looking for an exact equivalent, not some arduous workaround.</span>
<span class="comment-copy">@MalikBrahimi Sometimes there are no exact equivalents for a concept. Then the corresponding concept in the target klanguage has to be used, even if it works completely different.</span>
<span class="comment-copy">@MalikBrahimi Um, but python is python and not java. You can't have Java's semantic in a language that is not Java. And it's not an arduous workaround. Java's way of enforcing classes to be used looks like an arduous workaround for people that aren't used to Java.</span>
