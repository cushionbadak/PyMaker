<div class="post-text" itemprop="text">
<p>I found that some classes contain a <code>__init__</code> function, and some don’t. I’m confused about something described below.</p>
<p>What is the difference between these two pieces of code:</p>
<pre><code>class Test1(object):
    i = 1
</code></pre>
<p>and</p>
<pre><code>class Test2(object):
    def __init__(self):
        self.i = 1
</code></pre>
<p>I know that the result or any instance created by these two class and the way of getting their instance variable are pretty much the same. But is there any kind of “default” or “hidden” initialization mechanism of Python behind the scene when we don’t define the <code>__init__</code> function for a class? And why I can’t write the first code in this way:</p>
<pre><code>class Test1(object):
    self.i = 1
</code></pre>
<p>That’s my questions. Thank you very much!</p>
<hr/>
<p>Thank you very much Antti Haapala! Your answer gives me further understanding of my questions. Now, I understand that they are different in a way that one is a "class variable", and the other is a "instance variable". But, as I tried it further, I got yet another confusing problem.</p>
<p>Here is what it is. I created 2 new classes for understanding what you said:</p>
<pre><code>class Test3(object):
    class_variable = [1]
    def __init__(self):
        self.instance_variable = [2]

class Test4(object):
    class_variable = 1
    def __init__(self):
        self.instance_variable = 2
</code></pre>
<p>As you said in the answer to my first questions, I understand the <strong>class_variable</strong> is a <em>"class variable"</em> general to the class, and should be passed or changed by reference to the same location in the memory. And the <strong>instance_variable</strong> would be created distinctly for different instances.</p>
<p>But as I tried out, what you said is true for the <strong>Test3</strong>'s instances, they all share the same memory. If I change it in one instance, its value changes wherever I call it.</p>
<p>But that's not true for instances of <strong>Test4</strong>. Shouldn't the <strong>int</strong> in the <strong>Test4</strong> class also be changed by reference?</p>
<p>i1 = Test3()</p>
<pre><code>i2 = Test3()
&gt;&gt;&gt; i1.i.append(2)
&gt;&gt;&gt; i2.i
[1, 2]

j1 = Test4()
j2 = Test4()
&gt;&gt;&gt; j1.i = 3
&gt;&gt;&gt; j2.i
1
</code></pre>
<p>Why is that? Does that "=" create an "<strong>instance variable</strong>" named "<strong>i</strong>" without changing the original "<strong>Test4.i</strong>" by default? Yet the "<strong>append</strong>" method just handles the "<strong>class variable</strong>"? </p>
<p>Again, thank you for your exhaustive explanation of the most boring basic concepts to a newbie of Python. I really appreciate that!</p>
</div>
<div class="post-text" itemprop="text">
<p>In python the instance attributes (such as <code>self.i</code>) are stored in the instance dictionary (<code>i.__dict__</code>). All the variable declarations in the class body are stored as attributes of the class.</p>
<p>Thus</p>
<pre><code>class Test(object):
    i = 1
</code></pre>
<p>is equivalent to</p>
<pre><code>class Test(object):
    pass
Test.i = 1
</code></pre>
<hr/>
<p>If no <code>__init__</code> method is defined, the newly created instance usually starts with an empty instance dictionary, meaning that none of the properties are defined.</p>
<p>Now, when Python does the <strong>get attribute</strong> (as in <code>print(instance.i)</code> operation, it first looks for the attribute named <code>i</code> that is set on the <strong>instance</strong>).  If that fails, the <code>i</code> attribute is looked up on <code>type(i)</code> instead (that is, the class attribute <code>i</code>).</p>
<p>So you can do things like:</p>
<pre><code>class Test:
    i = 1

t = Test()
print(t.i)  # prints 1
t.i += 1
print(t.i)  # prints 2
</code></pre>
<p>but what this actually does is:</p>
<pre><code>&gt;&gt;&gt; class Test(object):
...     i = 1
... 
&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; t.__dict__
{}
&gt;&gt;&gt; t.i += 1
&gt;&gt;&gt; t.__dict__
{'i': 2}
</code></pre>
<p>There is no <code>i</code> attribute on the newly created <code>t</code> at all! Thus in <code>t.i += 1</code> the <code>.i</code> was looked up in the <code>Test</code> class for reading, but the new value was set into the <code>t</code>.</p>
<p>If you use <code>__init__</code>:</p>
<pre><code>&gt;&gt;&gt; class Test2(object):
...     def __init__(self):
...         self.i = 1
... 
&gt;&gt;&gt; t2 = Test2()
&gt;&gt;&gt; t2.__dict__
{'i': 1}
</code></pre>
<p>The newly created instance <code>t2</code> will already have the attribute set.</p>
<hr/>
<p>Now in the case of immutable value such as <code>int</code> there is not that much difference. But suppose that you used a list:</p>
<pre><code>class ClassHavingAList():
    the_list = []
</code></pre>
<p>vs </p>
<pre><code>class InstanceHavingAList()
    def __init__(self):
        self.the_list = []
</code></pre>
<p>Now, if you create 2 instances of both:</p>
<pre><code>&gt;&gt;&gt; c1 = ClassHavingAList()
&gt;&gt;&gt; c2 = ClassHavingAList()
&gt;&gt;&gt; i1 = InstanceHavingAList()
&gt;&gt;&gt; i2 = InstanceHavingAList()
&gt;&gt;&gt; c1.the_list is c2.the_list
True
&gt;&gt;&gt; i1.the_list is i2.the_list
False
&gt;&gt;&gt; c1.the_list.append(42)
&gt;&gt;&gt; c2.the_list
[42]
</code></pre>
<p><code>c1.the_list</code> and <code>c2.the_list</code> refer to the exactly same list object in memory, whereas <code>i1.the_list</code> and <code>i2.the_list</code> are distinct. Modifying the <code>c1.the_list</code> looks as if the <code>c2.the_list</code> also changes.</p>
<p>This is because the <code>attribute</code> itself is not set, it is just read. The <code>c1.the_list.append(42)</code> is identical in behaviour to</p>
<pre><code>getattr(c1, 'the_list').append(42)
</code></pre>
<p>That is, it only tries read the value of attribute <code>the_list</code> on <code>c1</code>, and if not found there, then look it up in the superclass. The <code>append</code> does not change the attribute, it just changes the value that the attribute points to. </p>
<p>Now if you were to write an example that superficially looks the same:</p>
<pre><code>c1.the_list += [ 42 ]
</code></pre>
<p>It would work identical to</p>
<pre><code>original = getattr(c1, 'the_list')
new_value = original + [ 42 ]
setattr(c1, 'the_list', new_value)
</code></pre>
<p>And do a completely different thing: first of all the <code>original + [ 42 ]</code> would create a new list object. Then the attribute <code>the_list</code> would be created in <code>c1</code>, and set to point to this new list. That is, in case of <code>instance.attribute</code>, if the <code>attribute</code> is "read from", it can be looked up in the class (or superclass) <strong>if</strong> not set in the instance, but if it is written to, as in <code>instance.attribute = something</code>, it will always be set on the instance.</p>
<hr/>
<p>As for this:</p>
<pre><code>class Test1(object):
    self.i = 1
</code></pre>
<p>Such thing does not work in Python, because there is no <code>self</code> defined when the class body (that is all lines of code within the class) is executed - actually, the class is created only <em>after</em> all the code in the class body has been executed. The class body is just like any other piece of code, only the <code>def</code>s and variable assignments will create methods and attributes on the class instead of setting global variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>I understood my newly added question. Thanks to Antti Haapala.</p>
<blockquote>
<p>Now, when Python does the get attribute (as in print(instance.i) operation, it first looks for the attribute named i that is set on the instance). If that fails, the i attribute is looked up on type(i) instead (that is, the class attribute i).</p>
</blockquote>
<p>I'm clear about why is:</p>
<pre><code>j1 = Test4()
j2 = Test4()
&gt;&gt;&gt; j1.i = 3
&gt;&gt;&gt; j2.i
1
</code></pre>
<p>after few tests. The code</p>
<pre><code>j1.3 = 3
</code></pre>
<p>actually creates a new instance variable for j1 without changing the class variable. That's the difference between "=" and methods like "append".</p>
<p>I'm a newbie of Python coming from c++. So, at the first glance, that's weird to me, since I never thought of creating a new instance variable which is not created in the class just using the "=". It's really a big difference between c++ and Python.</p>
<p>Now I got it, thank you all.</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/625083/python-init-and-self-what-do-they-do">Python __init__ and self what do they do?</a></span>
<span class="comment-copy">try <code>Test1.i += 100</code> and <code>Test2.i += 100</code> in between creating two instances of each two classes</span>
<span class="comment-copy">That wouldnt work, @PadraicCunningham; the latter would say  <code>AttributeError</code></span>
<span class="comment-copy">@AnttiHaapala, that is my point, you need to create an instance i.e <code>Test2().i += 100</code></span>
<span class="comment-copy">I mean it is also not much good as a demonstration.</span>
<span class="comment-copy">Thank you very much Mr. Antti Haapala. That's really brilliant as a demonstration. But as I tried to test a little bit, I got yet another confusing problem. Could you please also help me with that? I added that part to my original questions. @Antti Haapala</span>
<span class="comment-copy">I got the reason of my newly added question now! Thank you!</span>
<span class="comment-copy">Ah also, if you have C++ background, you should think it this way: <i>all</i> the variables, attributes and so on in Python are like C++ pointers. They never contain the actual objects themselves.</span>
<span class="comment-copy">Even integers, in Python if you write <code>x = 3</code>, in CPython the implementation code does <a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong" rel="nofollow noreferrer"><code>PyObject *x = PyLong_FromLong(3);</code></a>. The assignment statement changes whatever these named pointers are pointing to.</span>
<span class="comment-copy">Correct me if I'm wrong. It's pretty much close to the concept stated in Swift - "classes are reference type", right? Thanks you very much!</span>
<span class="comment-copy">I am not familiar at all with Swift, but in Objective-C yes all classes are by reference (<code>NSObject *</code>), it is the same in Python except <i>everything</i> is always by reference.</span>
<span class="comment-copy">Great to know that everything is always by reference. Again, I really appreciate your help! It's really a wonderful experience for me as this is my first question in stackoverflow community and it's been answered much more exhaustive than I expected.</span>
