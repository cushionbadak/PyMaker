<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2347265/why-does-behave-unexpectedly-on-lists">Why does += behave unexpectedly on lists?</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I have this python code</p>
<pre><code>x = [1, 2, 3]
y = x
x += [4]
&gt;&gt;&gt; print(y)
[1, 2, 3, 4]
</code></pre>
<p>So, this is because <code>x is y</code> is <code>True</code> and if I change <code>x</code>, I change <code>y</code></p>
<p>But when I do:</p>
<pre><code>x = [1, 2, 3]
y = x
x = x + [4]
&gt;&gt;&gt; print(y)
[1, 2, 3]
</code></pre>
<p>and </p>
<pre><code>&gt;&gt;&gt; id(x) == id(y)
False
</code></pre>
<p>I wonder what's the difference. I thought <code>x += 1</code> is shorthand for <code>x = x+1</code> but obviously there must be a difference.</p>
<p>I was even more confused, when I tried the above to strings:</p>
<pre><code>name = 'John'
name_2 = name
name += ' Doe'

&gt;&gt;&gt; print(name_2)
'John'
</code></pre>
<p>So I think the effect of <code>+=</code> depends on the object on the left, if it is mutable or not?</p>
</div>
<div class="post-text" itemprop="text">
<p>The object "on the left" handles the operator (usually, see the r-operator forms); in this case it is an <a href="https://docs.python.org/3/library/operator.html#inplace-operators" rel="nofollow noreferrer">Inplace Operator</a>.</p>
<blockquote>
<p>10.3.2. Inplace Operators</p>
<p>Many operations have an “in-place” version. Listed below are functions providing a more primitive access to in-place operators than the usual syntax does; for example, the statement <code>x += y</code> is equivalent to <code>x = operator.iadd(x, y)</code> ..</p>
</blockquote>
<p>The actual result is determined by the "x" object and <em>if</em> it handles <code>__iadd__</code> (eg. mutated as with lists) or just <code>__add__</code> (eg. a new result object, as with strings) - the selection of which protocol to use, and what value to return for the assignment, is determined by <code>operator.iadd</code> itself<sup>1</sup>.</p>
<p>So the shorthand of <code>x += y ~~ x = x + y</code> is <em>only</em> true for some objects - notably those that are immutable and [only] implement <code>__add__</code>.</p>
<p>See <a href="https://stackoverflow.com/questions/4772987/how-are-python-in-place-operator-functions-different-than-the-standard-operator">How are Python in-place operator functions different than the standard operator functions?</a></p>
<hr/>
<p><sup>1</sup> Semantically the operator.iadd function works about like:</p>
<pre><code>if x.__iadd__:
    x.__iadd__(y)        # side-effect performed on x,
    return x             # returns original-but-modified object
else
    return x.__add__(y)  # return new object,
                         # __add__ should not have side-effects
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>like @BrenBarn said, if the left hand side object is mutable it will preform an in-place operation. Otherwise a new copy will be returned, and because it was copied their id won't match anymore. </p>
<p>In the background it goes something analogous to this:</p>
<pre><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; y = [1,2,3]
&gt;&gt;&gt; x = y
&gt;&gt;&gt; x+=[4]
&gt;&gt;&gt; y
[1, 2, 3, 4]
&gt;&gt;&gt; x = copy.copy(y) #perhaps even a deepcopy()? Don't know.
&gt;&gt;&gt; y
[1, 2, 3, 4]
&gt;&gt;&gt; x
[1, 2, 3, 4]
&gt;&gt;&gt; x += [5]
&gt;&gt;&gt; y
[1, 2, 3, 4]
&gt;&gt;&gt; x
[1, 2, 3, 4, 5]
</code></pre>
<p><strong>EDIT 1:</strong></p>
<pre><code>class test():
    def __init__(self, ll):
        self.a = ll
    def __add__(self, other):
        return test(ll=self.a+other.a)

&gt;&gt;&gt; a = test([[1,2],[3,4]])
&gt;&gt;&gt; a.a
[[1, 2], [3, 4]]
&gt;&gt;&gt; x = test([[1,2],[3,4]])
&gt;&gt;&gt; x += a
&gt;&gt;&gt; x.a
[[1, 2], [3, 4], [1, 2], [3, 4]]
&gt;&gt;&gt; a.a
[[1, 2], [3, 4]]
&gt;&gt;&gt; x.a[2][0] = 7
&gt;&gt;&gt; x.a
[[1, 2], [3, 4], [7, 2], [3, 4]]
&gt;&gt;&gt; a.a
[[7, 2], [3, 4]]
</code></pre>
</div>
<span class="comment-copy">Yes, your explanation in the last line of your question is correct.  (Well, mostly.  It doesn't actually depend on whether it is mutable, but whether it defines <code>__iadd__</code> to actually mutate the object.  But generally mutable types will do that if they allow the operation at all.)</span>
<span class="comment-copy">See <a href="https://docs.python.org/3/library/operator.html#inplace-operators" rel="nofollow noreferrer">In-place Operators</a>.</span>
<span class="comment-copy">@BrenBarn okay, and if I do <code>x = x + 'foo'</code> it will always create a new object, because the expression on the right side is a new object?</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/q/6645843">python: is there a difference between list.extend() and +=?</a></span>
<span class="comment-copy"><code>x = y[:] or x = y.copy()</code> is all that is needed, you don't need to import copy</span>
<span class="comment-copy">@PadraicCunningham thnx. Did not actually know that....How about the copy vs deepcopy? I presume that if it's a native type it's jsut copy a class instance you made probably goes by deepcopy? Although I fail to understand how do they keep track of the difference then.</span>
<span class="comment-copy">if you are storing other objects in the list  then you would use deepcopy as [:] or list.copy only perform a shallow copy</span>
<span class="comment-copy">@PadraicCunningham I meant, how does python decide when to do a deepcopy and when a shallow one? I just tested couple of examples and it seems to do a shallow copy only... (seems a bit of a dangerous behavior though?)</span>
<span class="comment-copy">It does not decide, you do. If you have other objects stored in the lists use deepcopy,  try  creating a list of lists , use <code>x = y[:] </code> then change values in the sublists of x and see what happens. Then use deepcopy and do the same again</span>
