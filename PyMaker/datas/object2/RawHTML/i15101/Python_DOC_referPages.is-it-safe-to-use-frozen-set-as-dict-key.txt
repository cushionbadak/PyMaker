<div class="post-text" itemprop="text">
<p>It obviously works but are there cases where two sets of same elements happen to add two entries in Dict? I guess I got this condition earlier and changed my code from <code>frozenset(...)</code> to <code>tuple(sorted(frozenset(...)))</code>. Can someone who knows how Dict and frozenset implementation confirm if that is required or not? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>are there cases where two sets of same elements happen to add two entries in Dict?</p>
</blockquote>
<p>No. <a href="https://stackoverflow.com/questions/20832279/python-frozenset-hashing-algorithm-implementation"><code>frozenset</code> hashing algorithm</a> doesn't depend on the order of the elements, only on elements themselves. Two FS'es with the same elements are equal and have equal hashes, thus satisfying both criteria for "dict identity", in other words, they are the same dict key:</p>
<pre><code>&gt;&gt;&gt; a = frozenset([1,1,1,1,2,3])
&gt;&gt;&gt; b = frozenset([3,3,3,3,2,1])
&gt;&gt;&gt; {a:1, b:2}
{frozenset([1, 2, 3]): 2}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is it safe to use a <code>frozenset</code> as a <code>dict</code> key? <strong>Yes.</strong></p>
<p>According to the docs, Frozenset is hashable because it's immutable. This would imply that it can be used as the key to a dict, because the prerequisite for a key is that it is hashable.</p>
<p>From the <a href="https://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer">FrozenSet docs</a></p>
<blockquote>
<p>The frozenset type is immutable and hashable — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</p>
</blockquote>
<p>And redundantly, from the <a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">Dictionary docs</a>:</p>
<blockquote>
<p>...keys, which can be any immutable type</p>
</blockquote>
<hr/>
<p>To clarify, a set (by definition), frozen or not, does not preserve order. They are stored internally with order not taken into account and with duplicate elements removed, so two sets built in different orders would be equivalent keys in a dictionary – they are the same.</p>
<pre><code>&gt;&gt;&gt; frozenset([1,2,2,3,3]) == frozenset([3,2,1,1,1])
True
</code></pre>
<p>and likewise,</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; d[frozenset([1,1,2,3])] = 'hello'
&gt;&gt;&gt; d[frozenset([1,2,3,3])]
'hello'
&gt;&gt;&gt; d[frozenset([3,3,3,2,1,1,1])]
'hello'
&gt;&gt;&gt; d[frozenset([2,1,3])]
'hello'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>from <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="noreferrer">the official docs</a></p>
<blockquote>
<p>The frozenset type is immutable and hashable — its contents cannot be altered after it is created; <strong>it can therefore be used as a dictionary key</strong> or as an element of another set.</p>
</blockquote>
<p>(Emphasis is mine)</p>
</div>
<span class="comment-copy">That's what it's intended for. If you have an example that causes issues, please post it.</span>
<span class="comment-copy">But the question was whether Frozensets built in different order, but with the same final values, have different hash values. The answer is no, they do not have different hash values.</span>
<span class="comment-copy">I assumed this was understood because a set, by definition, does not preserve order.</span>
<span class="comment-copy">You answered <i>yes</i>, meaning you think that the hashes can be different so  <code>tuple(sorted(frozenset(...)))</code> is necessary.  Its not a question of hashability or order, its a question of the hash value.</span>
