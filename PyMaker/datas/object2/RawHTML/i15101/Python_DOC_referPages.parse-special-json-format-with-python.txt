<div class="post-text" itemprop="text">
<p>I want to get GPSLatitude and GPSLongitude value, but I can't use python position because the position is pretty random. I get the value by tag's value, how can I do that?</p>
<pre><code>jsonFlickrApi({ "photo": { "id": "8566959299", "secret": "141af38562", "server": "8233", "farm": 9, "camera": "Apple iPhone 4S", 
    "exif": [
      { "tagspace": "JFIF", "tagspaceid": 0, "tag": "JFIFVersion", "label": "JFIFVersion", 
        "raw": { "_content": 1.01 } },
      { "tagspace": "JFIF", "tagspaceid": 0, "tag": "ResolutionUnit", "label": "Resolution Unit", 
        "raw": { "_content": "inches" } },
      { "tagspace": "JFIF", "tagspaceid": 0, "tag": "XResolution", "label": "X-Resolution", 
        "raw": { "_content": 72 }, 
        "clean": { "_content": "72 dpi" } },
      { "tagspace": "JFIF", "tagspaceid": 0, "tag": "YResolution", "label": "Y-Resolution", 
        "raw": { "_content": 72 }, 
        "clean": { "_content": "72 dpi" } },
      { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLatitudeRef", "label": "GPS Latitude Ref", 
        "raw": { "_content": "North" } },
      { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLatitude", "label": "GPS Latitude", 
        "raw": { "_content": "39 deg 56' 44.40\"" }, 
        "clean": { "_content": "39 deg 56' 44.40\" N" } },
      { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLongitudeRef", "label": "GPS Longitude Ref", 
        "raw": { "_content": "East" } },
      { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLongitude", "label": "GPS Longitude", 
        "raw": { "_content": "116 deg 16' 10.20\"" }, 
        "clean": { "_content": "116 deg 16' 10.20\" E" } },
    ] }, "stat": "ok" })
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With the exception of the last comma just before the closing bracket <code>]</code>, the entire object returned by the FlickrAPI is <a href="http://www.json.org/" rel="nofollow">valid json</a>. </p>
<p>Assuming that that comma is merely a copy-paste error (<a href="https://www.flickr.com/services/api/response.json.html" rel="nofollow">example evidence</a> suggests this is the case), then the builtin <a href="https://docs.python.org/3/library/json.html" rel="nofollow">json module</a> still won't be usable as is. That's because even though a string like <code>"116 deg 16' 10.20\" E"</code> is <a href="http://www.json.org/string.gif" rel="nofollow">valid json</a>, python's json module will complain with a ValueError because the double quote <code>"</code> isn't sufficiently quoted:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.loads('{"a": "2"}')
{u'a': u'2'}
&gt;&gt;&gt; json.loads('{"a": "2\""}')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python2.7/json/__init__.py", line 338, in loads
    return _default_decoder.decode(s)
  File "/usr/lib/python2.7/json/decoder.py", line 365, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "/usr/lib/python2.7/json/decoder.py", line 381, in raw_decode
    obj, end = self.scan_once(s, idx)
ValueError: Expecting , delimiter: line 1 column 10 (char 9)
</code></pre>
<p>The solution is to add another escaping backslash:</p>
<pre><code>&gt;&gt;&gt; json.loads('{"a": "2\\""}')
{u'a': u'2"'}
</code></pre>
<p>For your full <code>jsonFlickrApi</code> response, you could add those extra backslashes with the <a href="https://docs.python.org/2/library/re.html" rel="nofollow"><code>re</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; response = """jsonFlickrApi({ "photo": { "id": "8566959299", "secret": "141af38562", "server": "8233", "farm": 9, "camera": "Apple iPhone 4S", 
...     "exif": [
...       { "tagspace": "JFIF", "tagspaceid": 0, "tag": "JFIFVersion", "label": "JFIFVersion", 
...         "raw": { "_content": 1.01 } },
...       { "tagspace": "JFIF", "tagspaceid": 0, "tag": "ResolutionUnit", "label": "Resolution Unit", 
...         "raw": { "_content": "inches" } },
...       { "tagspace": "JFIF", "tagspaceid": 0, "tag": "XResolution", "label": "X-Resolution", 
...         "raw": { "_content": 72 }, 
...         "clean": { "_content": "72 dpi" } },
...       { "tagspace": "JFIF", "tagspaceid": 0, "tag": "YResolution", "label": "Y-Resolution", 
...         "raw": { "_content": 72 }, 
...         "clean": { "_content": "72 dpi" } },
...       { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLatitudeRef", "label": "GPS Latitude Ref", 
...         "raw": { "_content": "North" } },
...       { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLatitude", "label": "GPS Latitude", 
...         "raw": { "_content": "39 deg 56' 44.40\"" }, 
...         "clean": { "_content": "39 deg 56' 44.40\" N" } },
...       { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLongitudeRef", "label": "GPS Longitude Ref", 
...         "raw": { "_content": "East" } },
...       { "tagspace": "GPS", "tagspaceid": 0, "tag": "GPSLongitude", "label": "GPS Longitude", 
...         "raw": { "_content": "116 deg 16' 10.20\"" }, 
...         "clean": { "_content": "116 deg 16' 10.20\" E" } }
...     ] }, "stat": "ok" })"""
&gt;&gt;&gt; quoted_resp = re.sub('deg ([^"]+)"', r'deg \1\\"', response[14:-1])
</code></pre>
<p>That quoted response can then be used in a call to <code>json.loads</code> and you can then easily access the required data in the newly generated dictionary structure:</p>
<pre><code>&gt;&gt;&gt; photodict = json.loads(quoted_resp)
&gt;&gt;&gt; for meta in photodict['photo']['exif']:                                                                                                               
...     if meta["tagspace"] == "GPS" and meta["tag"] == "GPSLongitude":
...         print(meta["clean"]["_content"])
... 
116 deg 16' 10.20" E
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't say whether you using one of the Flickr APIs; I assume not because handling JSON responses is trivial if you are using an API such as <a href="https://pypi.python.org/pypi/flickrapi" rel="nofollow">flickrapi</a>.</p>
<pre><code>import flickrapi

api_key = '88341066e8f0a40516599d28d8170627'   # from flickr's API explorer
secret = 'sssshhhh'
flickr = flickrapi.FlickrAPI(api_key, secret, format='parsed-json')
response = flickr.photos.getExif(photo_id='8566959299')
lat_long = {exif['tag']: exif['clean']['_content']
                    for exif in response['photo']['exif']
                        if exif['tag'] in (u'GPSLongitude', u'GPSLatitude')}

&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(lat_long)
{u'GPSLatitude': u'39 deg 56\' 44.40" N',
 u'GPSLongitude': u'116 deg 16\' 10.20" E'}
</code></pre>
<hr/>
<p>But continuing with the assumption that you are not using an API, the response format that you are seeing is actually <a href="https://en.wikipedia.org/wiki/JSONP" rel="nofollow">JSONP</a> which is better suited to Javascript than it is Python. You can, however, request a response in JSON representation that does not have the enclosing <code>jsonFlickrApi()</code> function wrapper. Do this by specifying <code>format=json&amp;nojsoncallback=1</code> in the query parameters of the request. Using the <a href="http://docs.python-requests.org" rel="nofollow">requests</a> library makes requesting and parsing the JSON response easy, but this will work just as well with <code>urllib2.urlopen()</code> combined with <code>json.loads()</code> if you can't use <code>requests</code> e.g.</p>
<pre><code>import requests

params = {'api_key': '88341066e8f0a40516599d28d8170627',
          'api_sig': '7b2dcfb2cd3a747179c2ed0fdc492699',
          'format': 'json',
          'method': 'flickr.photos.getExif',
          'nojsoncallback': '1',
          'photo_id': '8566959299',
          'secret': 'sssshhhh'}    
response = requests.get('https://api.flickr.com/services/rest/', params=params)
data = response.json()
lat_long = {exif['tag']: exif['clean']['_content']
                for exif in data['photo']['exif']
                    if exif['tag'] in (u'GPSLongitude', u'GPSLatitude')}

&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(lat_long)
{u'GPSLatitude': u'39 deg 56\' 44.40" N',
 u'GPSLongitude': u'116 deg 16\' 10.20" E'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If looking at the whole string as <code>jsonFlickrApi(XXX)</code>, <code>XXX</code> is a standard JSON string. With <code>json</code> library, <code>XXX</code> can be converted to python dictionary and then parsed easily.</p>
</div>
<span class="comment-copy">Have you tried iterating over them?</span>
<span class="comment-copy">@IgnacioVazquez-Abrams that's the last thing I want to try, is it very time/cpu consuming to iter over? so stilling looking for a better way, or maybe iterating is the best way, i am not sure.</span>
<span class="comment-copy">Is the comma just before the last closing bracket <code>]</code> actually there, or is that a copy-paste mistake?</span>
<span class="comment-copy">@OliverW. it is there: here is the flickr api test page: <a href="https://www.flickr.com/services/api/explore/flickr.photos.getExif" rel="nofollow noreferrer">flickr.com/services/api/explore/flickr.photos.getExif</a></span>
<span class="comment-copy">Thank you for that link - convenient! But, I'm not <a href="https://api.flickr.com/services/rest/?method=flickr.photos.getExif&amp;api_key=88341066e8f0a40516599d28d8170627&amp;photo_id=8566959299&amp;secret=141af38562&amp;format=json" rel="nofollow noreferrer">seeing a comma</a> just before the closing bracket though (and the output wouldn't be valid json if it were there).</span>
<span class="comment-copy">The API allows the client to request standard JSON rather than the JSONP posted by the OP. This avoids stripping of the JSONP function wrapper  <code>jsonFlickrApi() </code>. Also, the actual response is properly escaped (I think the OP has not posted the original response) so the regex backslash escape is unnecessary.</span>
<span class="comment-copy">@mhawke thank you for the explanation, I had no working experience with the API. And thank you for posting a full example: upvoted.</span>
