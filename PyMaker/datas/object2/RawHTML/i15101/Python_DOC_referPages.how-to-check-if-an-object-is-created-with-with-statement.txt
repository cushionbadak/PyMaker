<div class="post-text" itemprop="text">
<p>I would like to ensure that the class is only instantiated within a "with" statement.</p>
<p>i.e. this one is ok:</p>
<pre><code>with X() as x:
 ...
</code></pre>
<p>and this is not:</p>
<pre><code>x = X()
</code></pre>
<p>How can I ensure such functionality?</p>
</div>
<div class="post-text" itemprop="text">
<p>All answers so far do not provide what (I think) OP wants <strong>directly</strong>.<br/>
(I think) OP wants something like this: </p>
<pre><code>&gt;&gt;&gt; with X() as x:
 ...  # ok

&gt;&gt;&gt; x = X()  # ERROR

Traceback (most recent call last):
  File "run.py", line 18, in &lt;module&gt;
    x = X()
  File "run.py", line 9, in __init__
    raise Exception("Should only be used with `with`")
Exception: Should only be used with `with`
</code></pre>
<p>This is what I come up with, it may not be very robust, but I think it's closest to OP's intention.</p>
<pre><code>import inspect
import linecache

class X():

    def __init__(self):
        if not linecache.getline(__file__,
            inspect.getlineno(inspect.currentframe().f_back)
        ).startswith("with "):
            raise Exception("Should only be used with `with`")

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        pass
</code></pre>
<p>This will give the exact same output as I showed above as long as <code>with</code> is in the same line with <code>X()</code> when using context manager.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no straight forward way, as far as I know. But, you can have a boolean flag, to check if <code>__enter__</code> was invoked, before the actual methods in the objects were called.</p>
<pre><code>class MyContextManager(object):

    def __init__(self):
        self.__is_context_manager = False

    def __enter__(self):
        print "Entered"
        self.__is_context_manager = True
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print "Exited"

    def do_something(self):
        if not self.__is_context_manager:
            raise Exception("MyContextManager should be used only with `with`")

        print "I don't know what I am doing"
</code></pre>
<p>When you use it with <code>with</code>,</p>
<pre><code>with MyContextManager() as y:
    y.do_something()
</code></pre>
<p>you will get</p>
<pre class="lang-none prettyprint-override"><code>Entered
I don't know what I am doing
Exited
</code></pre>
<p>But, when you manually create an object, and invoke <code>do_something</code>,</p>
<pre><code>x = MyContextManager()
x.do_something()
</code></pre>
<p>you will get</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "/home/thefourtheye/Desktop/Test.py", line 22, in &lt;module&gt;
    x.do_something()
  File "/home/thefourtheye/Desktop/Test.py", line 16, in do_something
    raise Exception("MyContextManager should be used only with `with`")
Exception: MyContextManager should be used only with `with`
</code></pre>
<p><strong>Note:</strong> This is not a solid solution. Somebody can directly invoke <code>__enter__</code> method alone, before calling any other methods and the <code>__exit__</code> method may never be called in that case.</p>
<p>If you don't want to repeat that check in every function, you can make it a decorator, like this</p>
<pre><code>class MyContextManager(object):

    def __init__(self):
        self.__is_context_manager = False

    def __enter__(self):
        print "Entered"
        self.__is_context_manager = True
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print "Exited"

    def ensure_context_manager(func):
        def inner_function(self, *args, **kwargs):
            if not self.__is_context_manager:
                raise Exception("This object should be used only with `with`")

            return func(self, *args, **kwargs)
        return inner_function

    @ensure_context_manager
    def do_something(self):
        print "I don't know what I am doing"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no foolproof approach to ensure that an instance is constructed within  a <code>with</code> clause, but you can create an instance in the <code>__enter__</code> method and return that instead of <code>self</code>; this is the value that will be assigned into <code>x</code>. Thus you can consider <code>X</code> as a factory that creates the actual instance in its <code>__enter__</code> method, something like:</p>
<pre><code>class ActualInstanceClass(object):
    def __init__(self, x):
        self.x = x

    def destroy(self):
        print("destroyed")

class X(object):
    instance = None
    def __enter__(self):

        # additionally one can here ensure that the
        # __enter__ is not re-entered,
        # if self.instance is not None:
        #     raise Exception("Cannot reenter context manager")
        self.instance = ActualInstanceClass(self)

    def __exit__(self, exc_type, exc_value, traceback):
        self.instance.destroy()
        return None

with X() as x:
    # x is now an instance of the ActualInstanceClass
</code></pre>
<p>Of course this is still reusable, but every <code>with</code> statement would create a new instance.</p>
<p>Naturally one can call the <code>__enter__</code> manually, or get a reference to the <code>ActualInstanceClass</code> but it would be more of <strong>abuse</strong> instead of use.</p>
<hr/>
<p>For an even smellier approach, the <code>X()</code> when called does actually create a <code>XFactory</code> instance, instead of an <code>X</code> instance; and this in turn when used as a context manager, creates the <code>ActualX</code> instance which is the subclass of <code>X</code>, thus <code>isinstance(x, X)</code> will return true.</p>
<pre><code>class XFactory(object):
    managed = None
    def __enter__(self):
        if self.managed:
            raise Exception("Factory reuse not allowed")

        self.managed = ActualX()
        return self.managed

    def __exit__(self, *exc_info):
        self.managed.destroy()
        return


class X(object):
    def __new__(cls):
        if cls == X:
            return XFactory()
        return super(X, cls).__new__(cls)

    def do_foo(self):
        print("foo")

    def destroy(self):
        print("destroyed")

class ActualX(X):
    pass

with X() as x:
    print(isinstance(x, X))  # yes it is an X instance
    x.do_foo()               # it can do foo

# x is destroyed

newx = X()
newx.do_foo()  # but this can't,
# AttributeError: 'XFactory' object has no attribute 'do_foo'
</code></pre>
<p>You could take this further and have <code>XFactory</code> create an actual <code>X</code> instance with a special keyword argument to <code>__new__</code>, but I consider it to be too black magic to be useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unfortunately, you can't very cleanly. </p>
<p>Context managers require having <code>__enter__</code> and <code>__exit__</code> methods, so you can use this to assign a member variable on the class to check in your code.</p>
<pre><code>class Door(object):

    def __init__(self, state='closed'):
        self.state = state
        self.called_with_open = False

    # When being called as a non-context manger object,
    # __enter__ and __exit__ are not called.
    def __enter__(self):
        self.called_with_open = True
        self.state = 'opened'

    def __exit__(self, type, value, traceback):
        self.state = 'closed'

    def was_context(self):
        return self.called_with_open


if __name__ == '__main__':

    d = Door()
    if d.was_context():
        print("We were born as a contextlib object.")

    with Door() as d:
        print('Knock knock.')
</code></pre>
<p>The stateful object approach has the nice added benefit of being able to tell if the <code>__exit__</code> method was called later, or to cleanly handle method requirements in later calls:</p>
<pre><code>def walk_through(self):
    if self.state == 'closed':
        self.__enter__
    walk()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a decorator that automates making sure methods aren't called outside of a context manager:</p>
<pre><code>from functools import wraps

BLACKLIST = dir(object) + ['__enter__']

def context_manager_only(cls):
    original_init = cls.__init__
    def init(self, *args, **kwargs):
        original_init(self, *args, **kwargs)
        self._entered = False
    cls.__init__ = init
    original_enter = cls.__enter__
    def enter(self):
        self._entered = True
        return original_enter(self)
    cls.__enter__ = enter

    attrs = {name: getattr(cls, name) for name in dir(cls) if name not in BLACKLIST}
    methods = {name: method for name, method in attrs.items() if callable(method)}

    for name, method in methods.items():
        def make_wrapper(method=method):
            @wraps(method)
            def wrapper_method(self, *args, **kwargs):
                if not self._entered:
                    raise Exception("Didn't get call to __enter__")
                return method(self, *args, **kwargs)
            return wrapper_method
        setattr(cls, name, make_wrapper())

    return cls
</code></pre>
<p>And here is an example of it in use:</p>
<pre><code>@context_manager_only
class Foo(object):
    def func1(self):
        print "func1"

    def func2(self):
        print "func2"

    def __enter__(self):
        print "enter"
        return self

    def __exit__(self, *args):
        print "exit"

try:
    print "trying func1:"
    Foo().func1()
except Exception as e:
    print e

print "trying enter:"
with Foo() as foo:
    print "trying func1:"
    foo.func1()
    print "trying func2:"
    foo.func2()
    print "trying exit:"
</code></pre>
<p>This was written as an answer to <a href="https://stackoverflow.com/questions/30673402/writing-a-python-class-that-can-only-be-used-as-a-context-manager">this duplicate question</a>.</p>
</div>
<span class="comment-copy">And <b>why in heavens name</b> would you ever want to do that? <code>x = X()</code>, <code>with x as result_of_entering:</code> (creating the CM and using it on two separate lines) is suddenly no longer a valid usecase? What if I wanted to store context managers in a mapping to select one dynamically?</span>
<span class="comment-copy">And what if I wanted to use an <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>contextlib.ExitStack()</code></a>? to combine multiple context managers? There are various good use cases where a context manager is created outside of a <code>with</code> statement that you are trying to prevent. Don't try and fix all possible programmer mistakes at the expense of making life harder for those programmers that know what they are doing.</span>
<span class="comment-copy">Yes, this is what I wanted. Thanks.</span>
<span class="comment-copy">And this is why we can't have nice things.</span>
<span class="comment-copy">Works only with <code>with </code> that is at module level</span>
<span class="comment-copy">I know you don't like it, I don't like this solution too, but I still post it here cause that's what OP wants.</span>
<span class="comment-copy">You could use <code>__getattribute__</code> to really nail it down for everything</span>
<span class="comment-copy">I wouldn't say that this isn't a solid solution. Anything more would be overkill/harmful, since being able to invoke enter/exit directly is quite important at times (e.g. contextlib.ExitStack).</span>
<span class="comment-copy">Function decorator to ensure the state is what you want it to be seems very clean and pythonic. Nice.</span>
<span class="comment-copy">Clever! This solution has a bit of a smell to it (as it silently returns a different object), but it's cleaner than what I've been able to come up with.</span>
