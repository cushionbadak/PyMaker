<div class="post-text" itemprop="text">
<p>Here is a sample chunk of data. </p>
<pre><code>1med,2obs,3soc,1sed,3rhe,2hyp,1inti,1tea,1bod,4sto,1aur,1med,1sin,1ded,5obs
1act,4sed,3per,2inte,2soc,3dan,1intel,3lea,1intel,1inte,3aur,2soc,2neg,3log
2sed,5tea,3her,1medi,1pla,3rhe,3rid,3soc,2swi,3tea,1wri,3obs,3hyp,2aur,1tac
2per,2med,3pla,4intel,3dag,3act,2tac,4obs,1shi,1aur,1medi,1ste,1una,1bra,1hyp
3act,1dan,3ded,5intel,1inte,3inv,1medi,3obs,2soc,1spi,2ste,3rea,3wri,3mat
1intel,4obs
</code></pre>
<p>With some research of my own, I have figured out how to sort in the obvious and common ways. I can sort alphabetically for instance, or I can sort by number, or a variety of other different sorting methods. </p>
<p>However, I am wanting to combine like terms and sort. I can't find any reference to combining like terms. For instance, if the data consisted of:</p>
<pre><code>1med,2obs,2obs,1med,5rhe
</code></pre>
<p>Then after the program processed the data, the output would display as such:</p>
<pre><code>2med
4obs
5rhe
</code></pre>
<p>What am  I missing? </p>
</div>
<div class="post-text" itemprop="text">
<p>I used a much smaller version of your original list because you didn't quote the strings, so I couldn't just copy and paste it, but you get the idea.</p>
<pre><code>&gt;&gt;&gt; original_list
['1med', '2obs', '3soc', '2hyp', '1inti', '3med', '4soc']
&gt;&gt;&gt; counter = {}
&gt;&gt;&gt; for item in original_list:
...   try:
...     counter[item[1:]] += int(item[0])
...   except KeyError:
...     counter[item[1:]] = int(item[0])
... 
&gt;&gt;&gt; counter
{'med': 4, 'obs': 2, 'hyp': 2, 'soc': 7, 'inti': 1}
&gt;&gt;&gt; for k,v in counter.items():
...   print('%s%s' % (v, k))
... 
4med
2obs
2hyp
7soc
1inti
</code></pre>
<p>You split the string by slicing after the number (<code>item[1:]</code>) and then add the number to the count stored in the dict (<code>int(item[0])</code>), using it as the value instead if it isn't there already (<code>except KeyError</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/re.html" rel="nofollow">regular expressions</a> you can detect the number and the letters. Then store their counts in a dict and combine it in the end. </p>
<pre><code>my_str = "1med,2obs,2obs,1med,5rhe"

import re

data_as_lst = my_str.split(',')

words_dct = {}
for chunk in data_as_lst:    
    word = re.findall(r'[a-zA-Z]+', chunk)[0]
    num = int(re.findall(r'[0-9]+', chunk)[0])

    if word not in words_dct:
        words_dct.update({word: num})        
    else:
        words_dct[word] += num

results = []
for word in words_dct:
    results.append(str(words_dct[word]) + word)

print(results)
</code></pre>
<p>Probably not as fast as slicing suggested by others (I missed the comments saying that first character is always a single digit), but it's suitable for any number of digits.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>thelist = ['1med', '2obs', '3soc', '1sed', '3rhe', '2hyp', '1inti', '1tea', '1bod', '4sto', '1aur', '1med', '1sin', '1ded', '5obs', '1act', '4sed', '3per', '2inte', '2soc', '3dan', '1intel', '3lea', '1intel', '1inte', '3aur', '2soc', '2neg', '3log', '2sed', '5tea', '3her', '1medi', '1pla', '3rhe', '3rid', '3soc', '2swi', '3tea', '1wri', '3obs', '3hyp', '2aur', '1tac', '2per', '2med', '3pla', '4intel', '3dag', '3act', '2tac', '4obs', '1shi', '1aur', '1medi', '1ste', '1una', '1bra', '1hyp', '3act', '1dan', '3ded', '5intel', '1inte', '3inv', '1medi', '3obs', '2soc', '1spi', '2ste', '3rea', '3wri', '3mat', '1intel', '4obs']
list_dict = {x[1:]: x[0] for x in thelist}
</code></pre>
<p>A short dictionary comprehension can fix this up for you in 1 line so long as the prefix number is &gt;0 and &lt;10.</p>
<p>Then if you want to print all of that back out you can do a list comprehension to do so, though the dictionary may be nicer.</p>
<pre><code>recombined = [str(list(list_dict.values())[y])+list(list_dict.keys())[y] for y in range(len(list(list_dict.values())))]
for each in recombined:
    print(each)
</code></pre>
<p>To turn that into a list, instead of using Python I simply brute forced it with Notepad++. I did ctrl+h (find and replace), searched for the commas (,) and replaced with quote-comma-quote (','). </p>
<p>If you need to do this on a regular basis consider reading the information in as a CSV file and adding the data to a list before doing the dictionary comprehension.</p>
</div>
<span class="comment-copy">Is it always a 1-digit number followed by some string?</span>
<span class="comment-copy">Yes. It is always a 1-digit number, followed by a string of 3-5 letters.</span>
<span class="comment-copy">Use a dictionary that maps strings to frequencies.</span>
<span class="comment-copy">This is indeed a good answer and the right way to do it if the string is not so well-behaved.</span>
