<div class="post-text" itemprop="text">
<p>I can't understand difference. Help me to watch this difference. And what about ProcessPoolExecutor, is his behavior the same?</p>
<pre><code>def func(task):
    do_something(task)

tasks = [task for i in range(12)]
executor = ThreadPoolExecutor(4)
executor.map(func, tasks)
executor.shutdown(wait=True)  # ok, here the main thread waits for others

tasks = [task for i in range(12)]
executor = ThreadPoolExecutor(4)
executor.map(func, tasks)
executor.shutdown(wait=False)  # here it doesn't wait and what can happens bad?

tasks = [task for i in range(12)]
executor = ThreadPoolExecutor(4)
executor.map(func, tasks)  # if i don't call shutdown ?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From the docs:</p>
<blockquote>
<p>If wait is True then this method will not return until all the pending futures are done executing and the resources associated with the executor have been freed. If wait is False then this method will return immediately and the resources associated with the executor will be freed when all pending futures are done executing. Regardless of the value of wait, the entire Python program will not exit until all pending futures are done executing.</p>
</blockquote>
<p>This covers the first two examples.</p>
<p>For the third one, since <code>ThreadPoolExecutor</code> adheres to the "context manager" protocol you can use it along the <code>with</code> statement in order to have the <code>shutdown</code> method automatically called for as soon as execution exits the <code>with</code> block.</p>
<p>The default is <code>True</code> if you omit the parameter - or if you use it as a context manager, so using it inside the <code>with</code> block is useless no matter the value of <code>wait</code>.</p>
<p>[edit]</p>
<blockquote>
<p>i edited code. See pls, there are my final questions</p>
</blockquote>
<p>You only call the <code>shutdown</code> method if you want to explicitly release all resources and ensure no new calls to <code>submit</code> or <code>map</code> will succeed. If you don't call shutdown (or use <code>ThreadPoolExecutor</code> as a context manager), resources may be released only when the entire Python program exits (and it will not exit until all pending futures are done).</p>
<p>Calling <code>shutdown</code> with <code>wait==True</code> or using <code>ThreadPoolExecutor</code> as a context manager will block until all pending futures are done executing.</p>
<p>The only use case I can think of for calling <code>shutdown</code> explicitly is:</p>
<pre><code>executor = ThreadPoolExecutor(4)
try:
    executor.map(func, tasks)
finally:
    executor.shutdown(wait=False)
</code></pre>
<p>To give some context, this is the code snippet from the first version of this question:</p>
<pre><code>def func(task):
    do_something(task)

tasks = [task for i in range(12)]
with ThreadPoolExecutor(4) as executor:
    executor.map(func, tasks)
    executor.shutdown(wait=True)  # what is happening here?

tasks = [task for i in range(12)]
with ThreadPoolExecutor(4) as executor:
    executor.map(func, tasks)
    executor.shutdown(wait=False)  # what is happening here?

tasks = [task for i in range(12)]
with ThreadPoolExecutor(4) as executor:
    executor.map(func, tasks)  # and without shutdown()?
</code></pre>
<p>Note that <code>tasks = [task for i in range(12)]</code> is redundant - you can use just <code>executor.map(func, range(12))</code> as well.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.shutdown" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">I've read that. Is a method assigment just to wait all the threads to finish?</span>
<span class="comment-copy">I don't understand your comment.</span>
<span class="comment-copy">The <code>shutdown</code> method effectively just says "don't let this object accept any new tasks, and allow it to free its resources when the tasks already allocated are complete." The <code>wait</code> parameter just controls whether the method call blocks until the executor finishes "shutting down" or returns immediately while any running processes finish up (asynchronously).</span>
<span class="comment-copy">i edited code. See pls, there are my final questions</span>
<span class="comment-copy">This explain is better, thx</span>
