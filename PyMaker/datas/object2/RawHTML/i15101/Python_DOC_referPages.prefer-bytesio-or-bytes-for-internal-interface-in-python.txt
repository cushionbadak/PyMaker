<div class="post-text" itemprop="text">
<p>I'm trying to decide on the best internal interface to use in my code, specifically around how to handle file contents. Really, the file contents are just binary data, so bytes is sufficient to represent them.</p>
<p>I'm storing files in different remote locations, so have a couple of different classes for reading and writing. I'm trying to figure out the best interface to use for my functions. Originally I was using file paths, but that was suboptimal because it meant that disk was always used (which meant lots of clumsy tempfiles).</p>
<p>There are several areas of the code that have the same requirement, and would directly use whatever was returned from this interface. As a result whatever abstraction I choose will touch a fair bit of code.</p>
<p>What are the various tradeoffs to using BytesIO vs bytes?</p>
<pre><code>def put_file(location, contents_as_bytes):
def put_file(location, contents_as_fp):
def get_file_contents(location):
def get_file_contents(location, fp):
</code></pre>
<p>Playing around I've found that using the File-Like interfaces (BytesIO, etc) requires a bit of administration overhead in terms of <code>seek(0)</code> etc. That raises a questions like:</p>
<ul>
<li>is it better to <code>seek</code> before you start, or after you've finished?</li>
<li>do you <code>seek</code> to the start or just operate from the position the file is in?</li>
<li>should you <code>tell()</code> to maintain the position?</li>
<li>looking at something like <code>shutil.copyfileobj</code> it doesn't do any seeking</li>
</ul>
<p>One advantage I've found with using file-like interfaces instead is that it allows for passing in the fp to write into when you're retrieving data. Which seems to give a good deal of flexibility.</p>
<pre><code>def get_file_contents(location, write_into=None):
    if not write_into:
        write_into = io.BytesIO()

    # get the contents and put it into write_into

    return write_into

get_file_contents('blah', file_on_disk)
get_file_contents('blah', gzip_file)
get_file_contents('blah', temp_file)
get_file_contents('blah', bytes_io)
new_bytes_io = get_file_contents('blah')
# etc
</code></pre>
<p>Is there a good reason to prefer BytesIO over just using fixed bytes when designing an interface in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>The benefit of <code>io.BytesIO</code> objects is that they implement a common-ish interface (commonly known as a 'file-like' object). <code>BytesIO</code> objects have an internal pointer (whose position is returned by <code>tell()</code>) and for every call to <code>read(n)</code> the pointer advances <code>n</code> bytes. Ex.</p>
<pre><code>import io

buf = io.BytesIO(b'Hello world!')
buf.read(1) # Returns b'H'

buf.tell()  # Returns 1
buf.read(1) # Returns b'e'

buf.tell() # Returns 2

# Set the pointer to 0.
buf.seek(0)
buf.read() # This will return b'H', like the first call.
</code></pre>
<p>In your use case, both the <code>bytes</code> object and the <code>io.BytesIO</code> object are maybe not the best solutions. They will read the complete contents of your files into memory.</p>
<p>Instead, you could look at <code>tempfile.TemporaryFile</code> (<a href="https://docs.python.org/3/library/tempfile.html" rel="nofollow">https://docs.python.org/3/library/tempfile.html</a>).</p>
</div>
<span class="comment-copy">Thanks for the input. I've ended up using a combination of bytes and file-like objects. Good point about tempfile - using file-like objects gives the flexibility of using tempfile where required, which could give better time/space tradeoffs for some use cases.</span>
