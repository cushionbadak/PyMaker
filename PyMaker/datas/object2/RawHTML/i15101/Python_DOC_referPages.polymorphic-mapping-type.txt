<div class="post-text" itemprop="text">
<p>Is there a polymorphic dict-like type in Python? Here is what I mean by polymorphic: consider a basic class hierarchy with an <code>Animal</code> base class and a some derived classes, <code>Cat</code>, <code>Snake</code>, etc. and let's have our mystery mapping type <code>mystery_dict</code></p>
<pre><code>mapping = mystery_dict({
    Animal : 'foo',
    Cat    : 'bar',
    Snake  : 'baz',
    Python : 'eggs',
    Boa    : 'spam'
})
</code></pre>
<p>Now, I want to have the following lines to be true:</p>
<pre><code>mapping[Animal]   == 'foo'
mapping[Cat]      == 'bar'
mapping[Dog]      == 'foo' # No Dog in mapping, take the base class Animal
mapping[Snake]    == 'baz'
mapping[Boa]      == 'spam'
mapping[Anaconda] == 'baz' # No Anaconda in mapping, take the base class Snake
</code></pre>
<p>I know that I could use a bunch of <code>isinstance</code> or an "overload set" with <code>functools.singledispatch</code> since Python 3.4 but in some cases, a polymorphic dictionary type would be handy to reduce boilerplate. Does such a type exist in the wild or do I have to create one? Of course, if you have an even better alternative, I would be glad to hear about it.</p>
<p><em>Note:</em> just in case the question gets asked, I have rather simple needs so it doesn't have to handle multiple inheritance.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is trivial enough to write yourself:</p>
<pre><code>from collections.abc import MutableMapping


class PolymorphicDict(MutableMapping):
    def __init__(self, *args, **kwargs):
        self._mapping = dict(*args, **kwargs)

    def __getitem__(self, key):
        for cls in key.__mro__:
            if cls in self._mapping:
                return self._mapping[cls]
        raise KeyError(key)

    def __delitem__(self, key):
        del self._mapping[key]

    def __setitem__(self, key, value):
        self._mapping[key] = value

    def __iter__(self):
        return iter(self._mapping)

    def __len__(self):
        return len(self._mapping)
</code></pre>
<p>This uses the <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__" rel="nofollow"><code>class.__mro__</code> attribute</a> to list the class hierarchy of the current object, in method lookup order (Method Resolution Order). This sequence includes the current class and lists all classes all the way up to <code>object</code>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class Animal: pass
... 
&gt;&gt;&gt; class Cat(Animal): pass
... 
&gt;&gt;&gt; class Dog(Animal): pass
... 
&gt;&gt;&gt; class Snake(Animal): pass
... 
&gt;&gt;&gt; class Python(Snake): pass
... 
&gt;&gt;&gt; class Boa(Snake): pass
... 
&gt;&gt;&gt; class Anaconda(Snake): pass
... 
&gt;&gt;&gt; Anaconda.__mro__
(&lt;class '__main__.Anaconda'&gt;, &lt;class '__main__.Snake'&gt;, &lt;class '__main__.Animal'&gt;, &lt;class 'object'&gt;)
&gt;&gt;&gt; mapping = PolymorphicDict({
...     Animal : 'foo',
...     Cat    : 'bar',
...     Snake  : 'baz',
...     Python : 'eggs',
...     Boa    : 'spam'
... })
&gt;&gt;&gt; mapping[Animal]
'foo'
&gt;&gt;&gt; mapping[Cat]
'bar'
&gt;&gt;&gt; mapping[Dog]
'foo'
&gt;&gt;&gt; mapping[Snake]
'baz'
&gt;&gt;&gt; mapping[Boa]
'spam'
&gt;&gt;&gt; mapping[Anaconda]
'baz'
</code></pre>
<p>You probably want to look at <a href="https://pypi.python.org/pypi/zope.component" rel="nofollow"><code>zope.component</code></a> however; this lets you do <em>exactly this</em> with added interfaces. It has optimised the lookup mapping to a very high degree to scale the principle to far larger registries of object mappings.</p>
</div>
<span class="comment-copy">Are you writing a new Zope?</span>
<span class="comment-copy">You can 'play' with <code>pickle</code> and pass pickled strings as indexes and use <code>pickle.loads(string)</code> then.</span>
<span class="comment-copy">What exactly are you doing? <code>zope.component</code>/<code>zope.interface</code> has multiadapters, can actually do something like this and even more...</span>
<span class="comment-copy">So, why are you not storing this info on the classes themselves then? <code>Animal.mapping = 'foo'</code> is inherited by all subclasses.</span>
<span class="comment-copy">But an <code>Animal</code> is not a <code>Dog</code>, and a <code>Snake</code> is not an <code>Anaconda</code>.</span>
<span class="comment-copy">Thanks a lot, that's pretty neat :) I will have a look at <code>zope.component</code>, the architecture looks interesting.</span>
<span class="comment-copy">@Morwenn: be careful with interfaces there; it can take a moment before you realise that there is a big distinction between classes and interfaces (classes implement, instances provide the interface). If you are using <code>zope.component</code> to map <i>classes</i> than you want to use <code>directlyProvides</code> semantics.</span>
