<div class="post-text" itemprop="text">
<p>Normally, Python old-style string formatting complains if the number of placeholders in the string doesn't match the number of arguments passed:</p>
<pre><code>&gt;&gt;&gt; 'no.placeholders.here' % 'test'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: not all arguments converted during string formatting
</code></pre>
<p>However, when the argument passed is an instance of a user-defined class, it instead silently ignores it:</p>
<pre><code>&gt;&gt;&gt; class Test(object): pass
&gt;&gt;&gt; 'no.placeholders.here' % Test()
'no.placeholders.here'
</code></pre>
<p>This behavior seems inconsistent and has resulted in some difficult-to-track-down bugs. Why does the type of the format argument matter for the purposes of this error?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>This is exactly why <code>%</code>-formatting is <em>old</em></strong></p>
<p><code>%</code>-formatting is <em>well known</em> for its inconsistencies about argument handling which result in exceptions or not depending on the type. There are only two ways to use <code>%</code> formatting and avoid inconsistencies:</p>
<ol>
<li>Make sure the formatting string contains <em>exactly</em> one formatting field and pass the object to format as only right argument</li>
<li>Use a <code>tuple</code> or <code>dict</code> as right argument. Don't use <code>list</code>s, <code>set</code>s or <code>Model</code>s. <strong>Only</strong> <code>tuple</code>s and <code>dicts</code>. </li>
</ol>
<p>These are taken from the <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting" rel="nofollow noreferrer">documentation</a></p>
<blockquote>
<p>If format requires a single argument, values may be a single non-tuple
  object. Otherwise, values <strong>must</strong> be a tuple with exactly the number
  of items specified by the format string, or a single mapping object
  (for example, a dictionary).</p>
</blockquote>
<p>Your examples do not fall in these two cases because you have 0 formatting fields, which is different than 1 and thus the right argument <strong>must</strong> be a <code>tuple</code> or a mapping, but you are passing a string and a user defined object. As such you are under "undefined behaviour".</p>
<p>The inconsistencies on the error messages were already discussed in <a href="https://stackoverflow.com/q/13864532/510937">this</a> question (in my answer).</p>
<p>If you want more consistent behaviour, use <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>str.format</code></a>.</p>
</div>
<span class="comment-copy">I have tried your examples and for me throws the same TypeError for both cases. Are you sure it ignores silently the second case? What version of python are you using?</span>
<span class="comment-copy">I can reproduce this behavior in Python 2.6. Appears to be a bug in that version of Python; Python 2.7 behaves as expected.</span>
<span class="comment-copy">I should note, I was able to reproduce the behavior with instances of any old user-defined class, not just Django classes. Even <code>class myclass: pass</code>. Then <code>"foo" % myclass()</code> returns <code>"foo"</code> instead of an error. That's why I say it's a bug in Python. <code>"foo" % object()</code> is an error, however.</span>
<span class="comment-copy">I'm using Python 2.7.3, and it does trigger the silent ignore behavior with any instance of a user-defined class as kindall pointed out. I also tested 2.7.5 and it did the same thing. Which version behaved as expected @kindall?</span>
<span class="comment-copy">I edited the question to remove the red herring of Django model instances.</span>
<span class="comment-copy">Perfect explanation: thanks! I guess it "makes sense" in the same way as how <code>{} + [] == 0</code> in JS: perfectly specified but really confusing.</span>
