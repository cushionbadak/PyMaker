<div class="post-text" itemprop="text">
<p>Would like to define something I'd best call 'function extension' / 'function interface' or 'class of functions' in Python. Haven't seen similar constructs in other languages, but I'm no expert in functional languages like LISP. Considering to change to other language later if this is easier to do, say in Julia.</p>
<p>'Function extension' would be a formal way to express that binding few arguments of a function, we end up with a function belonging to a specific 'class of functions'. In my examples below the specific 'class of functions' is a data transformation function (as <code>transform_data_func_class</code>), which has a sole argument: <code>data</code>. <code>power_data</code> extends <code>transform_data_func_class</code> as binding the <code>exponent</code> argument we end up with a function which belongs to the the 'class of functions' <code>transform_data_func_class</code>.</p>
<p>A 'class of functions' defines part of the signature like:</p>
<pre><code>def transform_data_func_class(data):
    raise InterfaceError('Called unimplemented function class.')
</code></pre>
<p>Then would define functions extending the 'class of functions':</p>
<pre><code>def power_data(data, exponent):  # extends: transform_data_func_class
    return data ** exponent      # apply the additional the parameter
</code></pre>
<p>So that when binding the additional parameter(s) we end up with a signature matching that of the extended 'class of functions':</p>
<pre><code>square = partial(power_data, exponent=2)  # matches signature transform_data_func_class(data)
</code></pre>
<p>I'll use these for example, in order to specify types of functions as inputs and outputs of other functions:</p>
<pre><code>def chain(data, transform_data_func_class_list):  
    """Passing in data and a list of functions being elements of 
    transform_data_func_class with a sole argument: data."""
    ...
</code></pre>
<p>Find it odd that while in the case of general objects it is relatively easy to define classes/types, in case of functions there is no such obvious construct. Currently I use <code>extends: function_class</code> comments to specify function types/classes - an idea borrowed from <code>mypy</code> - ideally would use something more formal.</p>
<p>Any suggestions welcome, would be great if I could just call the resulting construct through <code>__call__</code>. Have thought of a class like:</p>
<pre><code>class TransformDataFuncClass(object):
    @classmethod
    def exec(cls, data):
        raise InterfaceError('Called unimplemented function class.')
</code></pre>
<p>But don't like the ununtiutive exec() call. Have also thought of:</p>
<pre><code>class TransformDataFuncClass(object):
    @classmethod
    def __call__(cls, data):
        raise InterfaceError('Called unimplemented function class.')
</code></pre>
<p>but I get <code>TypeError: object() takes no parameters</code> when calling <code>TransformDataFuncClass(data=1)</code>. Signaling 'function extension' through class inheritence would be a great way though. </p>
<p>My most elaborate plan was to do:</p>
<pre><code>class FuncClass(object):
    """Takes care of function classes and extensions being 
    just callable through __call__, e.g. PowerData(data=1, power=2)
    instead of instantiating first: PowerData()(data=1, power=2)"""
    def __init__(self, wrapped_class):
       self.wrapped_class = wrapped_class
       self.wrapped_instance = wrapped_class()
    def __call__(self, *args, **kwargs):
       return self.wrapped_instance(*args, **kwargs)

@FuncClass
class TransformDataFuncClass(object):
    def __call__(self, data):
        raise InterfaceError('Called unimplemented function class.')

@FuncClass
class PowerData(TransformDataFuncClass.wrapped_class):
    def __call__(self, data, exponent):
        return data ** exponent      # apply the additional the parameter
</code></pre>
<p>So that <code>TransformDataFuncClass(data=1)</code> and <code>PowerData(data=1, exponent=2)</code> are natural and valid calls. While the latter actually worked its a bit complicated, and couldn't parallelize calculations as I got errors from <code>dill</code> (an smarter alternative to <code>pickle</code>) saying that <code>&lt;class PowerData&gt;: it's not the same object as PowerData</code>.</p>
<p>Any suggestions welcome, really. I'm also interested in theoretical considerations and how this is done in other languages.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a little hard to see what you're trying to accomplish. Specifically, for these two function definitions:</p>
<pre><code>def transform_data_interface(data):
    raise InterfaceError('Called unimplemented interface.')

def power_data(data, param1):  # extends: transform_data_interface
    return data ** param1      # apply the additional the parameter
</code></pre>
<p>How does <code>power_data</code> extend <code>transform_data_interface</code>? They don't have the same signature: the "interface" takes a single argument, while the function implementing the interface takes two. That doesn't match what most people would say is an <a href="http://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)" rel="nofollow noreferrer">interface</a>.</p>
<p>If what you're trying to do is enforce that a given function has the same  arguments and return value as another function, you can accomplish this by inspecting the function's arguments.</p>
<ul>
<li>the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect</a> module in the stdlib can tell you what arguments a function takes, specifically, <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer">Signatures</a> give a nice API for this</li>
<li><a href="https://docs.python.org/3/tutorial/controlflow.html#function-annotations" rel="nofollow noreferrer">function annotations</a> allow you to mark up the parameters and return values of a function, this could replace what you're trying to do with the <code>"# extends:"</code> comment</li>
<li>also see the <a href="http://www.infoq.com/news/2014/08/python-type-annotation-proposal" rel="nofollow noreferrer">new proposal on using function annotations for optional typing</a> and <a href="http://mypy-lang.org/" rel="nofollow noreferrer">mypy</a></li>
<li>a decorator is the perfect place to add this kind of checking, as it wraps the function before it executes, lots of people have made type checking decorators (examples: <a href="http://code.activestate.com/recipes/578528-type-checking-using-python-3x-annotations/" rel="nofollow noreferrer">1</a>, <a href="https://github.com/dobarkod/typedecorator" rel="nofollow noreferrer">2</a>, <a href="https://github.com/prechelt/typecheck-decorator" rel="nofollow noreferrer">3</a>)</li>
</ul>
<p>For your <code>chain</code> function, see <a href="https://stackoverflow.com/questions/16739290/composing-functions-in-python">Composing functions in python</a>. You can modify one of those to also do the kind of checking I mentioned above.</p>
<p>As far as how other more functional languages do this kind of thing, I'm not sure. I see <a href="http://en.wikipedia.org/wiki/Type_class" rel="nofollow noreferrer">type classes</a> mentioned in that interface article I linked to above, looks like there's some good info there.</p>
<p>If you have more specifics or background on what you're trying to do please update your post!</p>
</div>
<span class="comment-copy">How is this different from function overloading?</span>
<span class="comment-copy">I need several functions with the same (or extended) signature with different names. "Function overloading or method overloading is the ability to create multiple methods of the same name with different implementations". Say <code>MultiplyData(data, param1)</code> would have the same signature as <code>PowerData(data, param1)</code>. What I'm looking for is more like interfaces/abstract classes in case of objects. Once you fix the moving parts of a class, it will match the inherited interface.</span>
<span class="comment-copy">Certainly a bit beyond m,e my first instinct would be to suggest a metaclass but I'm sure I don't completely grasp that concept - These might be a start though ... <a href="http://nedbatchelder.com/text/pythonic-interfaces.html" rel="nofollow noreferrer">A quest for pythonic interfaces</a> and <a href="https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/#Making-Things-Interesting:-Custom-Metaclasses" rel="nofollow noreferrer">A Primer on Python Metaclasses</a></span>
<span class="comment-copy">Thanks for the suggestions, have improved whole my explanation, and added the second paragraph which hopefully explains more clearly. Mypy is a great project, while I'm on Python 2.7 can't wait to upgrade to 3!</span>
<span class="comment-copy">@MarkHorvath, lost-theory's answer led me to the Python Cookbook which may give you some ideas: <a href="http://chimera.labs.oreilly.com/books/1230000000393/ch09.html#_problem_159" rel="nofollow noreferrer">Enforcing an Argument Signature on *args and **kwargs</a> and <a href="http://chimera.labs.oreilly.com/books/1230000000393/ch08.html#_problem_130" rel="nofollow noreferrer">Defining an Interface or Abstract Base Class</a></span>
<span class="comment-copy">@wwii, should probably use ABCs myself. Inspection would be probably the way to go strict on allowing functions of a certain signature as argument. Nonetheless what I need more is a way to express signature type system in the code... will try more, maybe it's only a small thing which I don't understand about <code>dill</code> serialization.</span>
