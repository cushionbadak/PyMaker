<div class="post-text" itemprop="text">
<p>I have a large 3d numpy array that I'd like to preserve. My first approach is simply to use pickle, but this seems to lead to a poorly explained error. </p>
<pre><code>test_rand = np.random.random((100000,200,50))
with open('models/test.pkl', 'wb') as save_file:
    pickle.dump(test_rand, save_file, -1)

---------------------------------------------------------------------------
error                                     Traceback (most recent call last)
&lt;ipython-input-18-511e30b08440&gt; in &lt;module&gt;()
      1 with open('models/test.pkl', 'wb') as save_file:
----&gt; 2         pickle.dump(test_rand, save_file, -1)
      3 

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in dump(obj, file, protocol)
   1368 
   1369 def dump(obj, file, protocol=None):
-&gt; 1370     Pickler(file, protocol).dump(obj)
   1371 
   1372 def dumps(obj, protocol=None):

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in dump(self, obj)
    222         if self.proto &gt;= 2:
    223             self.write(PROTO + chr(self.proto))
--&gt; 224         self.save(obj)
    225         self.write(STOP)
    226 

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in save(self, obj)
    329 
    330         # Save the reduce() output and finally memoize the object
--&gt; 331         self.save_reduce(obj=obj, *rv)
    332 
    333     def persistent_id(self, obj):

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in save_reduce(self, func, args, state, listitems, dictitems, obj)
    417 
    418         if state is not None:
--&gt; 419             save(state)
    420             write(BUILD)
    421 

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in save(self, obj)
    284         f = self.dispatch.get(t)
    285         if f:
--&gt; 286             f(self, obj) # Call unbound method with explicit self
    287             return
    288 

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in save_tuple(self, obj)
    560         write(MARK)
    561         for element in obj:
--&gt; 562             save(element)
    563 
    564         if id(obj) in memo:

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in save(self, obj)
    284         f = self.dispatch.get(t)
    285         if f:
--&gt; 286             f(self, obj) # Call unbound method with explicit self
    287             return
    288 

C:\Users\g1dak02\AppData\Local\Continuum\Anaconda\lib\pickle.pyc in save_string(self, obj, pack)
    484                 self.write(SHORT_BINSTRING + chr(n) + obj)
    485             else:
--&gt; 486                 self.write(BINSTRING + pack("&lt;i", n) + obj)
    487         else:
    488             self.write(STRING + repr(obj) + '\n')

error: integer out of range for 'i' format code
</code></pre>
<p>So the two questions I have are as follows:</p>
<ul>
<li>What is actually going on in this error?</li>
<li>How should I go about saving the array to disk? </li>
</ul>
<p>I am using Python 2.7.8 and NumPy 1.9.0. </p>
</div>
<div class="post-text" itemprop="text">
<p>With regard to #1, it's a bug… and an old one at that. There's an enlightening, albeit surprisingly old, discussion about this here: <a href="http://python.6.x6.nabble.com/test-gzip-test-tarfile-failure-om-AMD64-td1830323.html" rel="nofollow">http://python.6.x6.nabble.com/test-gzip-test-tarfile-failure-om-AMD64-td1830323.html</a></p>
<p>The reasons for the error are here: <a href="http://www.littleredbat.net/mk/files/grimoire.html#contents_item_2.1" rel="nofollow">http://www.littleredbat.net/mk/files/grimoire.html#contents_item_2.1</a></p>
<blockquote>
<p>The simplest and most basic type are integers, which are represented
  as a C long. Their size is therefore dependent on the platform you're
  using; on a 32-bit machine, they can range from -2147483647 to
  2147483647. Python programs can determine the highest possible value for an integer by looking at sys.maxint; the lowest possible value
  will usually be -sys.maxint - 1.</p>
</blockquote>
<p>This error is not a common one, as most people when faced with a very large <code>numpy</code> array, will use <code>np.save</code> or <code>np.savez</code> to take advantage of the reduced pickle format for <code>numpy</code> arrays (see the <code>__reduce__</code> method for a <code>numpy</code> array, which is what <code>np.save</code> calls under the covers).</p>
<p>To show that it's just about the array being too large for <code>pickle</code>…</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; test_rand = np.random.random((100000,200,50))
&gt;&gt;&gt; x = pickle.dumps(test_rand[:20000], -1)
&gt;&gt;&gt; x = pickle.dumps(test_rand[:30000], -1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.3.dev0-py2.7.egg/dill/dill.py", line 194, in dumps
    dump(obj, file, protocol, byref, fmode)#, strictio)
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.3.dev0-py2.7.egg/dill/dill.py", line 184, in dump
    pik.dump(obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 224, in dump
    self.save(obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/Users/mmckerns/lib/python2.7/site-packages/dill-0.2.3.dev0-py2.7.egg/dill/dill.py", line 181, in save_numpy_array
    pik.save_reduce(_create_array, (f, args, state, npdict), obj=obj)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 401, in save_reduce
    save(args)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 562, in save_tuple
    save(element)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 562, in save_tuple
    save(element)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 286, in save
    f(self, obj) # Call unbound method with explicit self
  File "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/pickle.py", line 486, in save_string
    self.write(BINSTRING + pack("&lt;i", n) + obj)
struct.error: 'i' format requires -2147483648 &lt;= number &lt;= 2147483647
&gt;&gt;&gt; 
</code></pre>
<p>however, this works for the full array...</p>
<pre><code>&gt;&gt;&gt; x = test_rand.__reduce__()
&gt;&gt;&gt; type(x)
&lt;type 'tuple'&gt;
&gt;&gt;&gt; x[0]     
&lt;built-in function _reconstruct&gt;
&gt;&gt;&gt; x[1]
(&lt;type 'numpy.ndarray'&gt;, (0,), 'b')
&gt;&gt;&gt; x[2][0:3]
(1, (100000, 200, 50), dtype('float64'))
&gt;&gt;&gt; len(x[2][4])
8000000000
&gt;&gt;&gt; x[2][4][:100]
'Y\xa4}\xdf\x84\xdf\xe1?\xfe\x1fd\xe3\xf2\xab\xe2?\x80\xe4\xfe\x17\xfb\xd6\xc2?\xd73\x92\xc9N]\xe8?\x90\xbc\xe3@\xdcO\xc9?\x18\x9dX\x12MG\xc4?(\x0f\x8f\xf9}\xf6\xb1?\xd0\x90O\xe2\x9b\xf1\xed?_\x99\x06\xacY\x9e\xe2?\xe7\xf8\x15\xa8\x13\x91\xe2?\x96}\xffH\xda\xc3\xd4?@\t\xae_"\xe0\xda?y&lt;%\x8a'
</code></pre>
<p>And if you'd like to burn out your fan, <code>print x</code>. </p>
<p>What you'll also notice is the function in <code>x[0]</code> gets saved along with the data.  It's a self-contained function that can produce a numpy array from the pickled data.</p>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative to <code>pickle</code>, especially for very large datasets, you may wish to consider a Python interface to a binary data format such as HDF5 (e.g., <a href="http://www.h5py.org/" rel="nofollow noreferrer">h5py</a>).  For a discussion of its pros and cons, see <a href="https://stackoverflow.com/q/4871670/1224002">this question</a> and the first answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the first question, "What is actually going on in this error?", here is my <strong>guess</strong>.</p>
<p>Pickle is trying to save your NumPy array as packed binary data. It's saving each integer as a four-byte signed integer (the <a href="https://docs.python.org/3/library/struct.html#format-characters" rel="nofollow"><code>i</code></a> code). However, <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.random.html#numpy.random.random" rel="nofollow"><code>numpy.random.random</code></a> creates floats (which should be eight-byte <code>d</code>s rather than four-byte <code>i</code>s). I have no idea why pickle would do it this way. It's also entirely possible that the <code>i</code> actually is for saving some other piece of information than one of the values of your array. I'm just guessing that the error arises because a value of your array does not fit in four bytes.</p>
<p>What versions of Python and NumPy are you using?</p>
</div>
<span class="comment-copy">Just came across <a href="http://stackoverflow.com/questions/9619199/best-way-to-preserve-numpy-arrays-on-disk" title="best way to preserve numpy arrays on disk">stackoverflow.com/questions/9619199/…</a> that gives the answer to #2: <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.savez.html" rel="nofollow noreferrer">numpy:savez</a>.</span>
<span class="comment-copy">Use <code>np.save</code> instead: <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.save.html" rel="nofollow noreferrer">docs.scipy.org/doc/numpy/reference/generated/numpy.save.html</a>  However, I have no idea why you're getting that error.  Pickling large arrays works fine (given enough memory to hold the intermediate string representation), though you should use <code>pickle.HIGHEST_PROTOCOL</code> for efficiency's sake.</span>
<span class="comment-copy">What's the difference between numpy.save and numpy.savez?</span>
<span class="comment-copy"><code>savez</code> is for saving multiple arrays. <code>save</code> is for saving a single array.  <code>savez</code> is more complex to use if you just want to dump out a single array. They're more or less identical under the hood, though.</span>
<span class="comment-copy"><code>savez</code> saves each variable to a different file, and packs them together as a <code>zip</code> archive.</span>
<span class="comment-copy">Using Python 2.78 and NumPy 1.9.0.</span>
<span class="comment-copy">Is the problem with saving the data or the dimensions?  '&lt;i' might be too small for the 1st dimension, or for the product all 3 (the total number of bytes).</span>
