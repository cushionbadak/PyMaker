<div class="post-text" itemprop="text">
<p>I've got fed up of continually typing the same, repetitive commands over and over again in my <code>__init__</code> function. I was wondering if I could write a decorator to do the work for me. Here's an example of my question:</p>
<pre><code>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
</code></pre>
<p>Is there some way in which I can automatically have all arguments passed into the function become instance variables with the same names? For example:</p>
<pre><code>class Point:
    @instance_variables
    def __init__(self, x, y):
        pass
</code></pre>
<p>Where <code>@instance_variables</code> would automatically set <code>self.x = x</code> and <code>self.y = y</code>. How could I do this?<br/>
Thanks!</p>
<p>EDIT: I should mention that I use CPython 2.7.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my first try at the decorator:</p>
<p>[EDIT second try: I added handling defaults for variables and checking for valid keywords. Thanks <a href="https://stackoverflow.com/users/648265/ivan-pozdeev" title="ivan-pozdeev">ivan_pozdeev</a> ]</p>
<p>[EDIT 3: Added check for defaults is not None]</p>
<pre><code>def instanceVariables(func):
    def returnFunc(*args, **kwargs):
        selfVar = args[0]

        argSpec = inspect.getargspec(func)
        argumentNames = argSpec[0][1:]
        defaults = argSpec[3]
        if defaults is not None:
            defaultArgDict = dict(zip(reversed(argumentNames), reversed(defaults)))
            selfVar.__dict__.update(defaultArgDict)

        argDict = dict(zip(argumentNames, args[1:]))
        selfVar.__dict__.update(argDict)


        validKeywords = set(kwargs) &amp; set(argumentNames)
        kwargDict = {k: kwargs[k] for k in validKeywords}
        selfVar.__dict__.update(kwargDict)

        func(*args, **kwargs)

    return returnFunc
</code></pre>
<p>Here is a example:</p>
<pre><code>class Test():

    @instanceVariables
    def __init__(self, x, y=100, z=200):
        pass

    def printStr(self):
        print(self.x, self.y, self.z)

a = Test(1, z=2)

a.printStr()

&gt;&gt;&gt; 1 100 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do this:</p>
<pre><code>def __init__(self, x, y):
    self.__dict__.update(locals())
    del self.self   # redundant (and a circular reference)
</code></pre>
<p>But this is probably not a real improvement, readability-wise.</p>
</div>
<div class="post-text" itemprop="text">
<p>I disagree that this is useful. I find that forcing developers (including myself) to type out the painful boilerplate of member variable initiation is a good way to deter people from having <code>__init__</code> methods that accept a ridiculous number of arguments, which are turned into a ridiculous number of member variables. </p>
<p>This happens a lot when someone wants to extend the features available in a class through the use of extra arguments, feature flags, and boolean switch variables that control customized instantiation. I consider all of those to be deficient ways to handle the need for accommodating new or optional extended complexity.</p>
<p>Being required to type out this particular kind of boilerplate is like a tax on class bloatedness. If you find yourself accepting so many args in <code>__init__</code> that you need this feature, it's usually a good indicator that you should refactor your design with smaller, compartmentalized classes, maybe a MixIn design.</p>
<p>Nonetheless, here is one way to do it without the misdirection of the decorator. I didn't make an attempt to handle <code>*args</code> but then again in this particular case you would have to define special logic for what unnamed positional arguments meant anyway.</p>
<pre><code>def init_from_map(obj, map):
    for k,v in map.iteritems():
        if k not in ["self", "kwargs"]:
            setattr(obj, k, v)
        elif k == "kwargs":
            for kk, vv in v.iteritems():
                setattr(obj, kk, vv)

class Foo(object):
    def __init__(self, x, y, **kwargs):
        init_from_map(self, locals())

f = Foo(1, 2, z=3)
print f.x, f.y, f.z
print f.__dict__
</code></pre>
<p>Prints:</p>
<pre><code>1 2 3
{'x': 1, 'y': 2, 'z': 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3.3+:</p>
<pre><code>from functools import wraps
from inspect import Parameter, signature


def instance_variables(f):
    sig = signature(f)
    @wraps(f)
    def wrapper(self, *args, **kwargs):
        values = sig.bind(self, *args, **kwargs)
        for k, p in sig.parameters.items():
            if k != 'self':
                if k in values.arguments:
                    val = values.arguments[k]
                    if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY):
                        setattr(self, k, val)
                    elif p.kind == Parameter.VAR_KEYWORD:
                        for k, v in values.arguments[k].items():
                            setattr(self, k, v) 
                else:
                    setattr(self, k, p.default) 
    return wrapper

class Point(object):
    @instance_variables 
    def __init__(self, x, y, z=1, *, m='meh', **kwargs):
        pass
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; p = Point('foo', 'bar', r=100, u=200)
&gt;&gt;&gt; p.x, p.y, p.z, p.m, p.r, p.u
('foo', 'bar', 1, 'meh', 100, 200)
</code></pre>
<p>A non-decorator approach for both Python 2 and 3 using frames:</p>
<pre><code>import inspect


def populate_self(self):
    frame = inspect.getouterframes(inspect.currentframe())[1][0]
    for k, v in frame.f_locals.items():
        if k != 'self':
            setattr(self, k, v)


class Point(object):
    def __init__(self, x, y):
        populate_self(self)
</code></pre>
<p><strong>Demo:</strong> </p>
<pre><code>&gt;&gt;&gt; p = Point('foo', 'bar')
&gt;&gt;&gt; p.x
'foo'
&gt;&gt;&gt; p.y
'bar'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can either use reflection to reduce code duplication</p>
<pre><code>self.__dict__.update(v,locals()[v] for v in 'x','y')
</code></pre>
<p>(or almost equivalent (<code>v</code> must not be a meta-variable name))</p>
<pre><code>for v in 'x','y': setattr(self,v,locals()[v])
</code></pre>
<p>Or use CPython's implementation details to retrieve argument names from runtime as per <a href="https://stackoverflow.com/questions/218616/getting-method-parameter-names-in-python">Getting method parameter names in python</a></p>
<pre><code>cur_fr = sys._getframe().f_code
self.__dict__.update(v,locals()[v] for v in cur_fr.co_varnames[1:cur_fr.co_argcount])  # cur_fr.f_locals is the same as locals()
</code></pre>
<p>The 2nd approach appears more "automated" but, <a href="https://stackoverflow.com/questions/28443527/python-decorator-to-automatically-define-init-variables#comment45217971_28444093">as I've said</a>, it turns out to be rather inflexible. If your argument list is longer than 3-4, you probably only need to handle some of the arguments this way, in which case, you have no other options but to construct their list by hand.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am searching for an autoinit decorator and come across this thread.
I couldn't find any @autoinit in the web that handles variable arguments, variable keywords and the keyword-only arguments.  Inspired by the other solutions, I wrote my own version that support everything.</p>
<p>I did some testing, it seems to work fine in all scenarios, but I haven't exhaustively test the code.  Let me know if it has a bug.   Thanks.</p>
<pre><code>def autoinit(func):
"""
This decorator function auto initialize class variables from __init__() arguments
"""
@functools.wraps(func)
def wrapper(*args, **kwargs):
    if func.__name__ != '__init__':
        return func(*args, **kwargs)

    self = args[0]
    func_spec = inspect.getfullargspec(func)

    # initialize default values
    nargs = dict()
    if func_spec.kwonlydefaults is not None:
        for k,v in func_spec.kwonlydefaults.items():
            nargs[k] = v
    if func_spec.defaults is not None:
        for k,v in zip(reversed(func_spec.args), reversed(func_spec.defaults)):
            nargs[k] = v
    if func_spec.varargs is not None:
        nargs[func_spec.varargs] = []
    if func_spec.varkw is not None:
        nargs[func_spec.varkw] = {}
    # fill in positional arguments
    for index, v in enumerate(args[1:]):
        if index+1 &lt; len(func_spec.args):
            nargs[func_spec.args[index+1]] = v
        elif func_spec.varargs is not None:
            # variable argument
            nargs[func_spec.varargs].append(v)
    # fill in keyword arguments
    for k,v in kwargs.items():
        if k in itertools.chain(func_spec.args, func_spec.kwonlyargs):
            nargs[k] = v
        elif func_spec.varkw is not None:
            # variable keywords
            nargs[func_spec.varkw][k] = v

    # set values to instance attributes
    for k,v in nargs.items():
        setattr(self, k, v)
    return func(*args, **kwargs)
return wrapper
</code></pre>
</div>
<span class="comment-copy">This seems like it would be such a useful tool I imagine that there is some 3rd party library on PyPI that provides this functionality.</span>
<span class="comment-copy">Python version?</span>
<span class="comment-copy">@SethMMorton I disagree that this is useful. I find that forcing developers (including myself) to type out the painful boilerplate of member variable initiation is a good way to deter people from having <code>__init__</code> methods that accept a ridiculous number of arguments, which are turned into a ridiculous number of member variables. It's like a tax on class bloatedness. If you find yourself accepting so many args in <code>__init__</code> that you need this feature, it's usually a good indicator that you should refactor your design with smaller, compartmentalized classes, maybe a MixIn design.</span>
<span class="comment-copy">Still willing to go this way? <a href="http://stackoverflow.com/questions/28443527/python-decorator-to-automatically-define-init-variables/28443934?noredirect=1#comment45218565_28443934">As Ashwin said</a>, a reliable decorator-type solution turns out to be rather ugly and ineffective in comparison with a few lines of code.</span>
<span class="comment-copy">I see a side effect: a collision between meta-variables and <code>kwargs</code> is not checked for until <code>func(*args, **kwargs)</code>, i.e. when the data is already in the object.</span>
<span class="comment-copy">@ivan_pozdeev, you are correct, personally I would not like to have <code>**kwargs</code> supported because then the code creates variable names based on initialization of the object which in turn makes code difficult to read. Let me see if I can work on that and also add defaults to variables.</span>
<span class="comment-copy">I'd even say importing <code>kwargs</code> directly without any sanitizing is a security hazard.</span>
<span class="comment-copy">@ivan_pozdeev Done. It does feel like an awful lot of code just so that we dont have to write <code>self.x = x</code> and <code>self.y = y</code></span>
<span class="comment-copy">This is much easier in Python 3.3+, where you can use <a href="https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object" rel="nofollow noreferrer"><code>Signature</code> objects</a> to inspect and bind the parameters. I think it'd be just <code>sig = inspect.signature(func); bound = sig.bind(*args, **kwargs); for param in sig.parameters.values(): setattr(selfobj, param.name, bound.get(param.name, param.default))</code> or something very similar.</span>
<span class="comment-copy">what about <code>self</code>?</span>
<span class="comment-copy">You could <code>del</code> it afterward if you cared. Added that.</span>
<span class="comment-copy">This still makes an assumption about the 1st meta-variable name and thus is unsuitable for a general-purpose decorator.</span>
<span class="comment-copy">It's not a decorator, and the <code>self</code> is right there in the method signature.</span>
<span class="comment-copy">This won't handle <code>kwargs</code> in the straightforward way (instead there will be <code>self.kwargs</code>) but it is very short and concise.</span>
<span class="comment-copy">Though I disagree this is strictly detrimental, it does come to my mind the "complete arglist"-based approach is rather inflexible. If you only need to handle a part of the arglist in this way, you're stuck with a hand-written list in any case.</span>
<span class="comment-copy">One place I can see it being useful is in machine-generated code. For example, maybe you've got a DSL written in JSON or XML, and from it, a Python class is automatically created on the fly with as many parameters as needed from something in the DSL. The intention must be that the code is not meant to be read or edited by humans though, or it loses the benefit promptly.</span>
<span class="comment-copy">That is another reason for DON'T use the @autoinit hack.  PyCharm doesn't like it.  It can't recognize the object variables</span>
<span class="comment-copy">FYI: That the second answer in the link provides a non-CPython specific answer using the <code>inspect</code> module from the standard library.</span>
<span class="comment-copy">I really hope I never have to see wither solution in any production code...</span>
<span class="comment-copy"><code>inspect</code> isn't fully functional without CPython-specific <code>sys._getframe()</code></span>
