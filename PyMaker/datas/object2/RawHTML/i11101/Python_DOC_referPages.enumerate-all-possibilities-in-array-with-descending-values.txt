<div class="post-text" itemprop="text">
<p>I'm trying to write a recursive approach to enumerate all possible values of an array of arbitrary length whose elements can all descend to one. More formally, given an array A with the elements, A_1, A_2,...,A_N and array B with B_1,B_2...B_N. There is a relationship between A_i and B_i, where i is between 1 and N and any element A_i lies between 1 and B_i. For such a set of arrays, I want to find all possible states for A_i.</p>
<p>For example, the array [1 2 3] has the following six possible states:</p>
<p><code>
[1 1 1]
[1 2 1]
[1 1 2]
[1 1 3]
[1 2 2]
[1 2 3]
</code></p>
<p>[1 2] would produce [1 1] and [1 2], etc</p>
<p>I've tried a solution in python such as:</p>
<pre><code>b = [1, 3, 3]
n = len(b)

a = []
k = 0
r = 0

print b
print '------'

def f(i, k, a, r):
  k += 1
  if i == n-1:
    return False
  for j in range(1, b[i+1]+1):
    r += 1
    print "i: %d b[i]: %d k: %d new: %d r: %d" % (i, b[i], k, j, r)
    f(i+1, k, a, r)

f(0, k, a, r)
</code></pre>
<p>but I can't seem to get the right values and I can't get the data-structure to populate. For example [3 3] only produces a tree with three nodes or the result:</p>
<pre><code>[3, 3]
------
i: 0 b[i]: 3 k: 1 new: 1 r: 1
i: 0 b[i]: 3 k: 1 new: 2 r: 2
i: 0 b[i]: 3 k: 1 new: 3 r: 3
</code></pre>
<p>Since I'm doing this to think through problems, I'm curious how:</p>
<ul>
<li>the python itertools might make this possible</li>
<li>any links that talk about this family of problems</li>
<li>how to more efficiently think about my approach</li>
</ul>
<p>Any thoughts appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically for every column you have a set of 'allowed' values.  By picking a value from each of these sets and putting it in a relevant column you generate a valid "related" array.  You just need to try all the possibilities.</p>
<p>Recursively, you need to make problem smaller. You may recurse on array length here:</p>
<pre><code>def enumerate(v):                                                               
    if len(v) == 0:                                                             
        yield v                                                                 
    else:                                                                       
        for i in range(1, v[0] + 1):                                            
            for rest in enumerate(v[1:]):                                       
                yield [i] + rest                                                
</code></pre>
<p>And you can have same effect with itertools, with no explicit recurrence:</p>
<pre><code>def enumerate2(v):                                                              
    from itertools import product                                               
    return product(*(range(1, e+1) for e in v))   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function / tool you are looking for is called the "Cartesian Product", which has been implemented in many places, including itertools.</p>
<p><a href="https://docs.python.org/3.5/library/itertools.html#itertools.product" rel="nofollow">itertools.product</a>(*iterables[, repeat])</p>
<p>This might also be useful: <a href="https://gist.github.com/hernamesbarbara/68d073f551565de02ac5" rel="nofollow">link</a></p>
<p>To achieve your final goal, what you need is so-called "lexicographical" sorting. I'm not sure if there is a easy-to-use tool available, since I'm not sure it is a solved problem (depends on many arbitrary sorting rules). However, you can look at the Python documentation to get started since they have some <a href="https://docs.python.org/3/howto/sorting.html" rel="nofollow">hints</a> about lexicographical output.</p>
</div>
<span class="comment-copy">wow -- ok -- thanks</span>
<span class="comment-copy">thanks. I'll look into that.</span>
<span class="comment-copy">I'm not sure how the descending elements are a cartesian product. Could you explain any more of that?</span>
<span class="comment-copy">Well, I think first you would use cartesian product to generate all possibilities quickly. Then, you would start sorting the columns, according to your preference. Depending on how you call the cartesian product, the list may already be sorted.</span>
<span class="comment-copy">so itertools.product to generate all possibilities of [3 2 3] for example, not seeing that would generate [1 1 1] for example</span>
