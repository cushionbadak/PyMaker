<div class="post-text" itemprop="text">
<p>I have a temperature application that takes user input (what units, temperature) to convert between different temperature units. It involves prompting the user for these units and numbers, through the normal str(input(xyz)) and float(input(123)) type of prompts, after which the rest of the application takes that data and uses it to perform the task, which from some basic manual testing I have found that it does correctly.</p>
<p>I wanted to practice writing unit tests for my application using unittest, and so wrote those too (correctly as well I believe). The tests pass where expected. My issue, however, is that even though I supply data that I will need for the test to work within the test itself, I am still taken through the input prompt in my my main application. While I can just press enter to skip through it and the tests will proceed as expected, I would rather find some way for either unittest to fill in those input prompts itself,  bypass that input bit completely, or at least silence it so that I don't have to run through all my input prompts every time. Is it possible to do this with unittest?</p>
<p>Here is the basic structure of what I wrote for my main application</p>
<pre><code>def main():
  unit_from, unit_to, temperature = user_input

  # continues with the rest of the application using above data...


#function to get user input
def user_input():
#gets user input using str and float prompts.
#and then returns those values for use in the rest of the program

main()
</code></pre>
<p>and for the unittests: </p>
<pre><code>import unittest

#module containing classes where the formulas for conversion live
import temperature
#main application that utilzes temperature classes and drives it all
import temp_converter

class FahrenheitConvertTestCase(unittest.TestCase):
#one of my example tests
  def test_f_to_c(self):
    from_unit = 'FAHRENHEIT'
    to_unit = 'CELSIUS'
    temp = 32.0
    t_convert = temperature.Fahrenheit(temp, from_unit, to_unit)
    converted_temp = t_convert.convert()
    self.assertEqual(converted_temp, 0.0) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you have a module with a function call like</p>
<pre><code>main()
</code></pre>
<p>it will be invoked on import of the module.</p>
<p>You can avoid that by wrapping it in the conditional</p>
<pre><code>if __name__ == '__main__':
    main()
</code></pre>
<p>Then <code>main</code> will only be called when that module is executed as the main program, not on import.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to mock your input methods to return mocked value. See <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow">unittest.mock</a> for reference of how to add mocking. Also consider reading <a href="http://alexmarandon.com/articles/python_mock_gotchas/" rel="nofollow">Python common mock gotchas</a>, it could save  a lot of your time. So after adding mocking your test would look similar to code below:</p>
<pre><code>@mock.patch('input', return_value='1')
def test_f_to_c(self, mock_input):
    from_unit = 'FAHRENHEIT'
    to_unit = 'CELSIUS'
    temp = 32.0
    t_convert = temperature.Fahrenheit(temp, from_unit, to_unit)
    converted_temp = t_convert.convert()
    self.assertEqual(converted_temp, 0.0) 
</code></pre>
<p><strong>Good Luck !</strong></p>
</div>
<span class="comment-copy">Restructure the applications to have a function you (and <code>main</code>) can call directly? Mock out <code>user_input</code>?</span>
<span class="comment-copy">Thank you for that, it all works how I want it to now.  Just to check that I understand this, the statement checks to see if it is being run as main, if it does then proceed with main() as expected, otherwise if it is not running in the scope of main (such as in the case of the import that I do with my testing), then main() won't be run  On a side note, I had a similar issue when I wrote this program/test on ruby(the basic structure of the program/tests was the same, just written in a ruby way). Was I probably hitting a somewhat similar issue in this case?</span>
<span class="comment-copy">@mc92 Yes almost all Python program puts the main function in this conditional to avoid it being executed when imported as a module.</span>
<span class="comment-copy">Thank you for that. One of the above answers already managed to work in a simple way for me, and at the moment I don't think I need much more. But I'll definitely keep this one for potential future usage</span>
<span class="comment-copy">@mc92 sure, hope that answer would be usefull for you in farther work with python... have a good day :)</span>
