<div class="post-text" itemprop="text">
<p>I am using yield to return the next value in the <strong>next</strong> function in my class. But its does not return the next value, it returns the generator object.
I am trying to better understand iterators and yield. I might be doing it in the wrong way. Please have a look.</p>
<pre><code>class MyString:
    def __init__(self,s):
        self.s=s

    def __iter__(self):
        return self

    def __next__(self):
        for i in range(len(self.s)):
            yield(self.s[i])

r=MyString("abc")
i=iter(r)
print(next(i))
</code></pre>
<p>This returns:</p>
<blockquote>
<p>generator object __next__ at 0x032C05A0</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p><code>next</code> pretty much just calls <code>__next__()</code> in this case.  Calling <code>__next__</code> on your object will start the generator and return it (no magic is done at this point).</p>
<hr/>
<p>In this case, you <em>might</em> be able to get away with not defining <code>__next__</code> at all:</p>
<pre><code>class MyString:
    def __init__(self,s):
        self.s=s

    def __iter__(self):
        for i in range(len(self.s)):
            yield(self.s[i])
        # Or...
        # for item in self.s:
        #     yield item
</code></pre>
<p>If you wanted to use <code>__iter__</code> and <code>__next__</code> (to define an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="noreferrer">iterator</a> rather than simply making an <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="noreferrer">iterable</a>), you'd probably want to do something like this:</p>
<pre><code>class MyString:
    def __init__(self,s):
        self.s = s
        self._ix = None

    def __iter__(self):
        return self

    def __next__(self):
        if self._ix is None:
            self._ix = 0

        try:
            item = self.s[self._ix]
        except IndexError:
            # Possibly reset `self._ix`?
            raise StopIteration
        self._ix += 1
        return item
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's take a look at the purpose of the <code>__next__</code> method. From <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>iterator.__next__()</p>
<p>Return the next item from the container. If there are no further items, raise the StopIteration exception.</p>
</blockquote>
<p>Now let's see what the <code>yield</code> statement does. Another excerpt from <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>Using a yield expression in a functionâ€™s body causes that function to
  be a generator</p>
</blockquote>
<p>And</p>
<blockquote>
<p>When a generator function is called, it returns an iterator known as a
  generator.</p>
</blockquote>
<p>Now compare <code>__next__</code> and <code>yield</code>: <code>__next__</code> <strong>returns the next item from the container</strong>. But a function containing the <code>yield</code> keyword <strong>returns an iterator</strong>. Consequently, using <code>yield</code> in a <code>__next__</code> method results in an iterator that yields iterators.</p>
<hr/>
<p>If you want to use <code>yield</code> to make your class iterable, do it in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer"><code>__iter__</code></a> method:</p>
<pre><code>class MyString:
    def __init__(self, s):
        self.s = s

    def __iter__(self):
        for s in self.s:
            yield s
</code></pre>
<p>The <code>__iter__</code> method is supposed to return an iterator - and the <code>yield</code> keyword makes it do exactly that.</p>
<hr/>
<p>For completeness, here is how you would implement an iterator with a <code>__next__</code> method. You have to keep track of the state of the iteration, and return the corresponding value. The easiest solution is probably to increment an index every time <code>__next__</code> is called:</p>
<pre><code>class MyString:
    def __init__(self,s):
        self.s = s
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1

        if self.index &gt;= len(self.s):
            raise StopIteration

        return self.s[self.index]
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__" rel="nofollow noreferrer"><code>__next__</code> returns the next item in the iterator</a> so making <code>__next__</code> a generator doesn't really make sense, or well it means that every value of your <code>MyString</code> iterator is a generator.</span>
<span class="comment-copy">MyString should not define <code>__next__</code>. <code>__next__</code> is for iterators, not iterables. Similarly, it should not <code>return self</code> for <code>__iter__</code>.</span>
<span class="comment-copy">I had not seen the recent edit. Was asking why it was missing</span>
<span class="comment-copy">@MosesKoledoye -- Yeah, it was an oversight in the original post that I corrected while you were commenting.  I also realized that calling <code>iter(mystring)</code> probably shouldn't reset the iteration ... Thanks for watchin' my back.  :-)</span>
<span class="comment-copy">Would you not be required to do <code>self.index = -1</code> on <code>def __iter__(self)</code> to reset the iteration, then, when called later or nested as <code>for a in list... for b in list... if a!=b...</code></span>
<span class="comment-copy">@user Well, objects that are their own iterators usually don't reset in the <code>__iter__</code> method. Think of a file object, for example. You can only iterate over that once.</span>
