<div class="post-text" itemprop="text">
<p>PEP-484 provides semantics for type annotations.
These are geared very much towards a) documentation and b) help for IDEs. They are less geared towards code optimization.</p>
<p>For example, it is unfortunately not possible to use PEP 484 annotations either with Cython
<a href="https://groups.google.com/d/msg/cython-users/DHcbk78rDec/6-b5XtCRGBEJ" rel="nofollow">https://groups.google.com/d/msg/cython-users/DHcbk78rDec/6-b5XtCRGBEJ</a></p>
<p>or with Numba, the latter using its own annotation format in the form of strings like "float64(int32, int32)"
<a href="http://numba.pydata.org/numba-doc/0.24.0/reference/types.html" rel="nofollow">http://numba.pydata.org/numba-doc/0.24.0/reference/types.html</a></p>
<p><strong>How do I work within the framework of PEP 484 with my own types?</strong>
I explicitly do not want to break PEP-484 semantics, but augment the existing types with additional information
visible to my own type checker, but invisible to any PEP-484 conforming type checker or IDE.</p>
<p>Will the following be interpreted within the PEP-484 semantics as List[int]?</p>
<pre><code>class Int32(int): pass
x = [1]   # type: List[Int32]
</code></pre>
<p><strong>How about a more fancy type like this?</strong></p>
<pre><code>def combine(typeA, typeB):
    class X(typeA, typeB): pass
    return X

class Metre(): pass

# is y an 'int' to PEP-484 typecheckers?
y = 1 # type: combine(Int32, Metre)
</code></pre>
<p>Any recommendations for libraries to work with type-hinting, both for type parsing and type checking?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.5, we not only have the <a href="https://www.python.org/dev/peps/pep-0483/" rel="nofollow">PEP 483</a>, <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow">PEP 484</a>, but also <a href="https://docs.python.org/3/library/typing.html" rel="nofollow"><code>typing</code> module</a> that implements it.</p>
<p>For complete understanding, you might want to read through those 3 documents. But for your specific case, the short answer is that in PEP484 realm you can work with own types in 4 ways:</p>
<ol>
<li>just annotate using own types,</li>
<li>create <a href="https://docs.python.org/3/library/typing.html#type-aliases" rel="nofollow">type aliases</a>,</li>
<li>use <a href="https://docs.python.org/3/library/typing.html#newtype" rel="nofollow"><code>NewType</code></a>, or</li>
<li>use <a href="https://docs.python.org/3/library/typing.html#user-defined-generic-types" rel="nofollow">own generic types</a></li>
</ol>
<hr/>
<p>If what you seek is above all else:</p>
<blockquote>
<p>additional information visible to my own type checker, but invisible to any PEP-484 conforming type checker</p>
</blockquote>
<p>then the 2nd approach gives you just that. If you do:</p>
<pre><code>Int32 = int
Int64 = int

x = 0 # type: Int32
y = 0 # type: Int64
</code></pre>
<p>Then <code>Int32</code> and <code>Int64</code> would be the same in PEP484 realm, but you could add some additional checks by looking into the AST (Abstract Syntax Tree) of your code using community-maintained <a href="https://pypi.python.org/pypi/typed-ast/" rel="nofollow"><code>typed-ast</code> module</a>. That module parses type comments in addition to code, so you can read the <em>exact</em> annotation used, and thus get some additional type information for <code>x</code> and <code>y</code>.</p>
<hr/>
<p>And, if being invisible is not the number one priority, then:</p>
<ul>
<li><p>instead of <code>class Int32(int): pass</code> I would rather do <code>typing.NewType('Int32', int)</code>, and</p></li>
<li><p>instead of <code>combine(Int32, Metre)</code> I would use <code>typing.Union[Int32, Metre]</code>.</p></li>
</ul>
<p>i.e.</p>
<pre><code>Int32 = typing.NewType('Int32', int)

class Metre:
    pass

x = [Int32(1)]  # type: List[Int32]
y = Int32(1) # type: typing.Union[Int32, Metre]

print(x[0] + 1) # ok, since Int32 is still int
y = Metre() # ok, since y can be Int32 or Metre
</code></pre>
<p>On the above code, you can run community-maintained <a href="https://pypi.python.org/pypi/mypy-lang" rel="nofollow">static type-checker <code>mypy</code></a>.</p>
<hr/>
<p>Both <a href="https://pypi.python.org/pypi/typed-ast/" rel="nofollow"><code>typed-ast</code></a> and <a href="https://pypi.python.org/pypi/mypy-lang" rel="nofollow"><code>mypy</code></a> are now (year 2016) under very active development. Not everything works as expected, but as far as I can see they are good enough for many use cases already, and also there seem to be no alternatives.</p>
</div>
<span class="comment-copy">Similar question on  <code>numpy</code> and 484 - <a href="http://stackoverflow.com/q/35673895/901925">stackoverflow.com/q/35673895/901925</a></span>
<span class="comment-copy">I am interested in studying different type systems. I would like to have a system with the flexibility of Shen (<a href="http://www.shenlanguage.org/learn-shen/types/types_sequent_calculus.html" rel="nofollow noreferrer">shenlanguage.org/learn-shen/types/types_sequent_calculus.html</a>) and the ability to define own types and typing rules. The first step is to build a static checker for units of measurement. The 484 typing semantics are very tempting, b/c they are very flexible, for example I (hope) to express that a variable is of type Int32 and at the same time has the dimension metre. The optimizer is happy with int32, physical units are checked, and the gui recognizes y as an int.</span>
<span class="comment-copy">good link to the numpy question, that goes in the right long term direction, I also like the datashape project. To get started, I am more interested in the typing side how to handle my own types in the 484 context and how to parse the type information from the program. Of course, I hope that in the future external libraries will be able to share type annotations to the maximum possible extent.</span>
