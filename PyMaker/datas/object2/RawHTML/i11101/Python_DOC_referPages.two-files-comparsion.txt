<div class="post-text" itemprop="text">
<p>I have a really weird problem. I've got three files, which contain one column of numbers. I need to get ONLY unique values from first file, that are not present at second and third files.</p>
<p>I tried Python like:</p>
<pre><code>for e in firstfile:
    if e not in secondfile:
        resultfile.append(e)
return resultfile
</code></pre>
<p>And same for third file.</p>
<p>I tried uniq, sort, diff, some awk scripts and comm in linux shell like here: <a href="https://stackoverflow.com/questions/18204904/fast-way-of-finding-lines-in-one-file-that-are-not-in-another">Fast way of finding lines in one file that are not in another?</a></p>
<p>But the only result i get each time is THE SAME AMOUNT OF LINES AS IT WAS IN FORMER FIRST FILE. I don't get it at all!</p>
<p>Maybe, i've missed something? Maybe it's something with a format? However, i checked it a lot of times. Here are the files: <a href="http://dropmefiles.com/BaKGj" rel="nofollow noreferrer">http://dropmefiles.com/BaKGj</a></p>
<p>P.S. Later i thought there are no unique lines at all, but i checked it manually, some numbers in first file ARE unique.</p>
<p>P.P.S. The format of files is like this:</p>
<pre><code>380500100000 
380500100001 
380500100002 
380500100003 
380500100004    
380500100005 
380500100008 
380500100020 
380500100022 
380500100050    
380500100070 
380500100080
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>What's wrong</strong></p>
<blockquote>
<p>And same for third file</p>
</blockquote>
<p>If you are really doing the same for the third file, i.e. comparing the original contents of the first file with the third, you can introduce duplicates of items that were not in the second file but are in the third. For example:</p>
<pre>
file 1:
1
2
3

file 2:
1

file 3:
2
</pre>
<p>After processing file 2, <code>resultfile</code> would contain 2 and 3. Then after processing file 3, <code>resultfile</code> would contain 2 and 3 (from the first run) <em>plus</em> 1 and 3, i.e. 2, 3, 1, 3. However, the result should just be 3.</p>
<p>It's not clear from your code whether you are actually writing the output of each run to the <em>file</em> <code>resultfile</code>. If you are, then you should use it as the input for the second and subsequent runs, don't process the first file again.</p>
<hr/>
<p><strong>A better way to fix it</strong></p>
<p>If you do not need to preserve the order of lines from the first file you could use <a href="https://docs.python.org/3/library/stdtypes.html?highlight=set.difference#set.difference" rel="nofollow"><code>set.difference()</code></a> like this:</p>
<pre><code>with open('file1') as f1, open('file2') as f2, open('file3') as f3:
    unique_f1 = set(f1).difference(f2, f3)
</code></pre>
<p>Note that this will include any whitespace (including newline characters) present in the files. If you wanted to ignore leading and trailing whitespace from each line:</p>
<pre><code>from itertools import chain

with open('file1') as f1, open('file2') as f2, open('file3') as f3:
    unique_f1 = set(map(str.strip, f1)).difference(map(str.strip, chain(f2, f3)))
</code></pre>
<p>The above assumes Python 3. If you're using Python 2 then, optionally for better efficiency,  import <code>itertools.imap</code> and use it instead of <code>map()</code>.</p>
<p>Or you might like to treat the data as numeric (I'll assume <code>float</code> here, but you can use <code>int</code> instead):</p>
<pre><code>from itertools import chain

with open('file1') as f1, open('file2') as f2, open('file3') as f3:
    unique_f1 = set(map(float, f1)).difference(map(float, chain(f2, f3)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way would be to read each file into a <code>set</code>, and then use Python's (very efficient) set operations to do the comparison. </p>
<pre><code>file1 = set()
file2 = set()

for element in firstfile:
    file1.add(element)

for element in secondfile:
    file2.add(element)

unique = file1 - file2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's likely the issue might be that <code>first.csv</code> is strictly ASCII text, while <code>second.csv</code>, and <code>third.csv</code> are ASCII text, with CRLF line terminators. I would suggest you change them to the same format (ASCII text would probably work best).</p>
<pre><code>$ file first.csv
first.csv: ASCII text 

$ file second.csv
second.csv: ASCII text, with CRLF line terminators

$ file third.csv
third.csv: ASCII text, with CRLF line terminators
</code></pre>
</div>
<span class="comment-copy">If it's just one column of numbers, you might as well include 20 from eacg so we understand what data you are using.  Putting them on dropmefiles does not help people in the future as the file gets removed in 7 days.  I would also load the first file, then remove everything loaded from second and third file if it exists in the first file.</span>
<span class="comment-copy">Sure, it's a nice note. Are you a russophone?</span>
<span class="comment-copy">I see your point, but my code is more complicated than that. I just didn't want to paste all of that so i made it a bit easier to understand. Originally, i opened csv files, made lists from them, then iterated every element of the first list and stored it in the result list. Then i took the result list of first iteration and made the same thing for the third list (file), the result was stored in another list that later was written to the fourth (resulting) csv file.</span>
<span class="comment-copy">I tried sets like this:  1. Opened csv files in Python by csv module. 2. Extracted all data from these file and transfered it to lists. 3. Made sets from those lists. 4. Tried the construction you suggested (unique = file1 - file2).  Does it have the same effect or i should try your option?</span>
<span class="comment-copy">That will work fine. I just used that (inefficient) construction because I wasn't sure how you reading the files into memory.</span>
