<div class="post-text" itemprop="text">
<pre><code>import numpy as np

def f(x):
    x /= 10

data = np.linspace(0, 1, 5)
print data
f(data)
print data
</code></pre>
<p>Output on my system (debian 8, Python 2.7.9-1, numpy 1:1.8.2-2)</p>
<pre><code>[ 0. 0.25  0.5   0.75  1.  ]
[ 0. 0.025  0.05   0.075  0.1  ]
</code></pre>
<p>Normally I would expect <code>data</code> to stay untouched when passing it to a function as this has its own separate namespace. But when the data is a numpy array the function changes <code>data</code> globally.</p>
<p>Is this a feature, a bug or am I maybe missing something? How should I avoid this behavior when using a custom plot function to scale my data automatically?</p>
<p><strong>UPDATE</strong>
(<em>See Kevin J. Chase's answer for more details</em>)</p>
<pre><code>import numpy as np

def f(x):
    print id(x)
    x = x/10
    print id(x)

data = np.linspace(0, 1, 5)
print id(data)
print data
f(data)
print data
</code></pre>
<p>Output on my system (debian 8, Python 2.7.9-1, numpy 1:1.8.2-2)</p>
<pre><code>48844592
[ 0. 0.25  0.5   0.75  1.  ]
48844592
45972592
[ 0. 0.25  0.5   0.75  1.  ]
</code></pre>
<p>Using <code>x = x/10</code> instead of <code>x /= 10</code> solves the problem for me. </p>
<p>The behaviour of the nice and short <code>x /= 10</code> statement actually depends heavily on the <em>type of x</em>. It rebinds if x is immutable and mutates otherwise.</p>
<p>It is not equivalent to <code>x = x/10</code> which always rebinds.</p>
<p>A numpy array is a mutable object.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Normally I would expect data to stay untouched when passing it to a function as this has its own separate namespace.</p>
</blockquote>
<p><code>x</code> in the function and <code>data</code> at the module level are two names for the <em>same</em> object.  Since that object is mutable, any changes made to it will be "seen" regardless of which name is used to refer to the object.  Namespaces can't protect you from that.</p>
<p><code>x /= 10</code> divides every element of the NumPy array by 10.  The original data is gone after this line executes.  If you were to run <code>f(data)</code> a few more times, you'd find the contents draw closer to 0.0 each time.</p>
<p>Lists are a more familiar example of the same effect:</p>
<pre><code>l = list(range(4))
print(l)
# [0, 1, 2, 3]
l += [4]
print(l)
# [0, 1, 2, 3, 4]
</code></pre>
<p>For a good overview of this sort of thing (including related issues) I recommend Ned Batchelder's “<a href="http://nedbatchelder.com/text/names1.html" rel="nofollow noreferrer">Facts and Myths about Python Names and Values</a>” (26 minute <a href="https://www.youtube.com/watch?v=_AEJHKGk9ns" rel="nofollow noreferrer">video from PyCon US 2015</a>).  His example of list "addition" starts about 10 minutes in.</p>
<h1>Behind the Scenes</h1>
<p><code>/</code> and <code>/=</code> (and similar pairs of operators) do different things.  Tutorials often claim that these two operations are the same:</p>
<pre><code>x = x / 10
x /= 10
</code></pre>
<p>...but they're not.  Full details can be found in <a href="https://docs.python.org/3/reference/" rel="nofollow noreferrer"><em>The Python Language Reference</em></a>, <a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">3.3.7.  Emulating Numeric Types</a>.</p>
<p><code>/</code> calls the <code>__truediv__</code> (or maybe <code>__rtruediv__</code> --- a topic for another day) method on one of the two objects, feeding the other object as the argument:</p>
<pre><code># x = x / 10
x = x.__truediv__(10)
</code></pre>
<p>Typically, these methods return some new value without altering the old one.  This is why <code>data</code> was unchanged by <code>x / 10</code>, but <code>id(x)</code> changed --- <code>x</code> now referred to a new object, and was no longer an alias for <code>data</code>.</p>
<p><code>/=</code> calls a completely different method, <code>__itruediv__</code> for the "in-place" operation:</p>
<pre><code># x /= 10
x = x.__itruediv__(10)
</code></pre>
<p><em>These</em> methods typically modify the object, which then returns <code>self</code>.  This explains why <code>id(x)</code> was unchanged <em>and</em> why <code>data</code>'s contents had changed --- <code>x</code> and <code>data</code> were still the one and only object.  From the docs I linked above:</p>
<blockquote>
<p>These methods should attempt to do the operation in-place (modifying <code>self</code>) and return the result (which could be, but does not have to be, <code>self</code>).  If a specific method is not defined, the augmented assignment falls back to the normal methods  [meaning <code>__add__</code> and family --- <em>KJC</em>].</p>
</blockquote>
<p>If you look at the methods of different data types, you'll find that they don't support all of these.</p>
<ul>
<li><p><code>dir(0)</code> shows that integers lack the in-place methods, which shouldn't be surprising, because they're immutable.</p></li>
<li><p><code>dir([])</code> reveals only two in-place methods: <code>__iadd__</code> and <code>__imul__</code> --- you can't divide or subtract from a list, but you can in-place add another list, and you can multiply it by an integer.  (Again, those methods can do whatever they want with their arguments, including refuse them...  <code>list.__iadd__</code> won't take an integer, while <code>list.__imul__</code> will reject a list.)</p></li>
<li><p><code>dir(np.linspace(0, 1, 5))</code> shows basically <em>all</em> of the arithmetic, logic, and bitwise methods, with normal and in-place for each.  (It could be missing some --- I didn't count them all.)</p></li>
</ul>
<p>Finally, to re-reiterate, what namespace these objects are in when their methods get called makes absolutely no difference.  In Python, data has <em>no scope</em>... if you have a reference to it, you can call methods on it.  (From Ned Batchelder's talk:  Variables have a scope, but no type; data has a type, but no scope.)</p>
</div>
<span class="comment-copy">Can you paste the output?  I'm not able to reproduce your error.</span>
<span class="comment-copy">If I remove the 2 <code>matplotlib</code> lines (<code>import matplotlib.pyplot as plt</code> and <code>plt.plot(x)</code>), then still I get the same output as you do</span>
<span class="comment-copy">Thanks for the hint. Was not suspecting numpy. Question edited.</span>
<span class="comment-copy">I don't understand your list example. You are appending a new element to your list. My Problem is, that a invoked functioin should only be able to make "local" changes inside the function unless global variables or return statements are used otherwise - at least that is what I always thaught.</span>
<span class="comment-copy">@Felix:  That's exactly what happened --- <code>f</code> made "local" changes to the data you gave it.  It is <i>exactly</i> the same as the list example.  Again, namespaces have nothing to do with this.  The fact that the <i>one and only</i> copy of the data was mutated inside a function has nothing to do with this.</span>
<span class="comment-copy">But f makes global changes to the object it is given when using the nice and short <code>a x= b</code> statements instead of the longer <code>a = axb</code> statements. Until now I believed these were equivalent as stated in most places like here <a href="http://www.tutorialspoint.com/python/python_basic_operators.htm" rel="nofollow noreferrer">tutorialspoint.com/python/python_basic_operators.htm</a>  ... bug or feature?</span>
<span class="comment-copy">@Felix:  In my list example, <code>lst += [5]</code> is "equivalent" to <code>lst = lst + [5]</code> (try it).  I could call that list <code>susan</code> or <code>not_a_list</code> or even <code>immutable_forever</code>... doesn't change the fact that it's a list, and its contents have changed.  (This doesn't seem to happen to integers or strings, because they're immutable.)  I put "equivalent" in scare-quotes because they're <i>not</i> actually the same.  <code>+</code> calls an object's <code>__add__</code> or <code>__radd__</code> method, while <code>+=</code> calls its <code>__iadd__</code> "in-place addition" method.  (Those methods <i>could</i> do whatever they want...)</span>
<span class="comment-copy">Can you please stick to the given problem and not talk about yours. When <code>x /= b</code> is invoked depending on the type of x (immutable or not) a rebind or mutation is made. So this is <i>not</i> equivalent to <code>x = x/b</code>.</span>
