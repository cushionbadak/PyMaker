<div class="post-text" itemprop="text">
<p>I want to remove elements of a certain tag value and then write out the <code>.xml</code> file WITHOUT any tags for those deleted elements; is my only option to create a new tree?</p>
<p>There are two options to remove/delete an element:</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.clear" rel="nofollow">clear()</a>
  Resets an element. This function removes all subelements, clears all
  attributes, and sets the text and tail attributes to None.</p>
</blockquote>
<p>At first I used this and it works for the purpose of removing the <strong>data</strong> from the element but I'm still left with an empty element:</p>
<pre><code># Remove all elements from the tree that are NOT "job" or "make" or "build" elements
log = open("debug.log", "w")
for el in root.iter(*):

    if el.tag != "job" and el.tag != "make" and el.tag != "build":
        print("removed = ", el.tag, el.attrib, file=log)
        el.clear()
    else:
        print("NOT", el.tag, el.attrib, file=log)

log.close()
tree.write("make_and_job_tree.xml", short_empty_elements=False)
</code></pre>
<p>The problem is that <code>xml.etree.ElementTree.ElementTree.write()</code> <a href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree.write" rel="nofollow">still writes out empty tags no matter what:</a></p>
<blockquote>
<p>...The keyword-only short_empty_elements parameter controls the
  formatting of elements that contain no content. If True (the default),
  they are emitted as a <strong>single self-closed tag</strong>, otherwise they are
  emitted as a <strong>pair of start/end tags</strong>.</p>
</blockquote>
<p>Why isn't there an option to just not print out those empty tags! Whatever.</p>
<p>So then I thought I might try</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.remove" rel="nofollow">remove(subelement)</a>
  Removes subelement from the element. Unlike the find* methods this
  method compares elements based on the instance identity, not on tag
  value or contents.</p>
</blockquote>
<p>But this only operates on the child elements.</p>
<p>So I'd have to <a href="https://docs.python.org/3/library/xml.etree.elementtree.html#parsing-xml" rel="nofollow">do something like</a>:</p>
<pre><code>for el in root.iter(*):
    for subel in el:
        if subel.tag != "make" and subel.tag != "job" and subel.tag != "build":
            el.remove(subel)
</code></pre>
<p>But there's a big problem here: I'm invalidating the iterator by removing elements, right?</p>
<p>Is it enough to simply check if the element is empty by adding <code>if subel</code>?:</p>
<pre><code>if subel and subel.tag != "make" and subel.tag != "job" and subel.tag != "build"
</code></pre>
<p>Or do I have to get a new iterator to the tree elements every time I invalidate it?</p>
<p>Remember: I just wanted to write out the xml file with no tags for the empty elements.</p>
<p>Here's an example.</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name="Malaysia" direction="N"/&gt;
    &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W"/&gt;
        &lt;neighbor name="Colombia" direction="E"/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</code></pre>
<p>Let's say I want to remove any mention of <code>neighbor</code>.
Ideally, I'd want this output after the removal:</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
    &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
    &lt;/country&gt;
&lt;/data&gt;
</code></pre>
<p>Problem, is when I run the code using clear() (see first code block up above) and write it to a file, I get this:</p>
<pre><code>&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor&gt;&lt;/neighbor&gt;&lt;neighbor&gt;&lt;/neighbor&gt;&lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor&gt;&lt;/neighbor&gt;&lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor&gt;&lt;/neighbor&gt;&lt;neighbor&gt;&lt;/neighbor&gt;&lt;/country&gt;
&lt;/data&gt;
</code></pre>
<p>Notice <code>neighbor</code> still appears.</p>
<p>I know I could easily run a regex over the output but there's gotta be a way (or another Python api) that does this on the fly instead of requiring me to touch my <code>.xml</code> file again.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import lxml.etree as et

xml  = et.parse("test.xml")

for node in xml.xpath("//neighbor"):
    node.getparent().remove(node)


xml.write("out.xml",encoding="utf-8",xml_declaration=True)
</code></pre>
<p>Using elementTree, we need to find the <em><code>parents  of the neighbor nodes</code></em> then find the <em><code>neighbor nodes inside that parent</code></em> and remove them:</p>
<pre><code>from xml.etree import ElementTree as et

xml  = et.parse("test.xml")


for parent in xml.getroot().findall(".//neighbor/.."):
      for child in parent.findall("./neighbor"):
          parent.remove(child)


xml.write("out.xml",encoding="utf-8",xml_declaration=True)
</code></pre>
<p>Both will give you:</p>
<pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;/country&gt;
&lt;/data&gt;
</code></pre>
<p>Using your attribute logic and modifying the xml a bit like below:</p>
<pre><code>x = """&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
           &lt;neighbor name="Costa Rica" direction="W" make="foo" build="bar" job="blah"/&gt;
        &lt;neighbor name="Malaysia" direction="N"/&gt;
    &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W" make="foo" build="bar" job="blah"/&gt;
        &lt;neighbor name="Colombia" direction="E"/&gt;
    &lt;/country&gt;
&lt;/data&gt;"""
</code></pre>
<p>Using lxml:</p>
<pre><code>import lxml.etree as et

xml = et.fromstring(x)

for node in xml.xpath("//neighbor[not(@make) and not(@job) and not(@make)]"):
    node.getparent().remove(node)
print(et.tostring(xml))
</code></pre>
<p>Would give you:</p>
<pre><code> &lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W" make="foo" build="bar" job="blah"/&gt;
        &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W" make="foo" build="bar" job="blah"/&gt;
        &lt;/country&gt;
&lt;/data&gt;
</code></pre>
<p>The same logic in ElementTree:</p>
<pre><code>from xml.etree import ElementTree as et

xml = et.parse("test.xml").getroot()

atts = {"build", "job", "make"}

for parent in xml.findall(".//neighbor/.."):
    for child in parent.findall(".//neighbor")[:]:
        if not atts.issubset(child.attrib):
            parent.remove(child)
</code></pre>
<p>If you are using iter:</p>
<pre><code>from xml.etree import ElementTree as et

xml = et.parse("test.xml")

for parent in xml.getroot().iter("*"):
    parent[:] = (child for child in parent if child.tag != "neighbor")
</code></pre>
<p>You can see we get the exact same output:</p>
<pre><code>In [30]: !cat /home/padraic/untitled6/test.xml
&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;#
      &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;year&gt;2008&lt;/year&gt;
      &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name="Malaysia" direction="N"/&gt;
    &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W"/&gt;
        &lt;neighbor name="Colombia" direction="E"/&gt;
    &lt;/country&gt;
&lt;/data&gt;
In [31]: paste
def test():
    import lxml.etree as et
    xml = et.parse("/home/padraic/untitled6/test.xml")
    for node in xml.xpath("//neighbor"):
        node.getparent().remove(node)
    a = et.tostring(xml)
    from xml.etree import ElementTree as et
    xml = et.parse("/home/padraic/untitled6/test.xml")
    for parent in xml.getroot().iter("*"):
        parent[:] = (child for child in parent if child.tag != "neighbor")
    b = et.tostring(xml.getroot())
    assert  a == b

## -- End pasted text --

In [32]: test()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Whenever modifying XML documents is needed, consider also <a href="https://www.w3.org/Style/XSL/" rel="nofollow">XSLT</a>, the special-purpose language part of the XSL family which includes XPath. XSLT is designed specifically to transform XML files. Pythoners are not quick to recommend it but it avoids the need of loops or nested if/then logic in general purpose code. Python's <code>lxml</code> module can run XSLT 1.0 scripts using the libxslt processor.</p>
<p>Below transformation runs the identity transform to copy document as is and then runs an empty template match on <code>&lt;neighbor&gt;</code> to remove it:</p>
<p><strong>XSLT</strong> Script <em>(save as an .xsl file to be loaded just like source .xml, both of which are well-formed xml files)</em></p>
<pre><code>&lt;xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output version="1.0" encoding="UTF-8" indent="yes" /&gt;
&lt;xsl:strip-space elements="*"/&gt;

  &lt;!-- IDENTITY TRANSFORM TO COPY XML AS IS --&gt;
  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

  &lt;!-- EMPTY TEMPLATE TO REMOVE NEIGHBOR WHEREVER IT EXISTS --&gt;  
  &lt;xsl:template match="neighbor"/&gt;

&lt;/xsl:transform&gt;
</code></pre>
<p><strong>Python</strong> Script</p>
<pre><code>import lxml.etree as et

# LOAD XML AND XSL DOCUMENTS
xml  = et.parse("Input.xml")
xslt = et.parse("Script.xsl")

# TRANSFORM TO NEW TREE
transform = et.XSLT(xslt)
newdom = transform(xml)

# CONVERT TO STRING
tree_out = et.tostring(newdom, encoding='UTF-8', pretty_print=True,  xml_declaration=True)

# OUTPUT TO FILE
xmlfile = open('Output.xml'),'wb')
xmlfile.write(tree_out)
xmlfile.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The trick here is to find the parent (the country node), and delete the neighbor from there. In this example, I am using ElementTree because I am somewhat familiar with it:</p>
<pre><code>import xml.etree.ElementTree as ET

if __name__ == '__main__':
    with open('debug.log') as f:
        doc = ET.parse(f)

        for country in doc.findall('.//country'):
            for neighbor in country.findall('neighbor'):
                country.remove(neighbor)

        ET.dump(doc)  # Display
</code></pre>
</div>
<span class="comment-copy">Can you add a sample of your xml and what you want as output? Also are you open to using lxml?</span>
<span class="comment-copy">@PadraicCunningham if <code>lxml</code> is in Python, yes. I don't care which API I use. I'll update with before and after of what I'm looking for.</span>
<span class="comment-copy">is python a requirement?</span>
<span class="comment-copy">@vtd-xml-author no. I just chose Python cause debugging is easy and I already used it. What do you have in mind?</span>
<span class="comment-copy">@PadraicCunningham how can I make <a href="http://stackoverflow.com/questions/37702011/removing-an-element-from-a-parsed-xml-tree-disrupts-iteration">this question</a> linked to my question? It's the question that answers my question. EDIT: actually doesn't answer it. Merely explains that one way to do it is not valid.</span>
<span class="comment-copy">Can you format the word "neighbor" more distinctly? When I first read your answer I thought you meant neighbor not "the tag called neighbor". I think the <code>code</code> format is appropriate. I'll try modifying your post first but for some reason my edits are never approved.</span>
<span class="comment-copy">@Adrian, if I were using neighbour in a general context I would spell it correctly ;)</span>
<span class="comment-copy">I didn't know you could do use <code>not</code> and concatenate things as in <code>"//neighbor[not(@make) and not(@job) and not(@make)]"</code></span>
<span class="comment-copy">Yes, lxml has complete xpath syntax support as well as  a few extras <a href="http://lxml.de/extensions.html#xpath-extension-functions" rel="nofollow noreferrer">lxml.de/extensions.html#xpath-extension-functions</a></span>
<span class="comment-copy">it is a generator expression, the items are lazily evaluated, as far as the <code>[:]</code> syntax goes it selects all the node in the list/parent node, if you set parent = [...] all you would be doing is creating a binding of the name parent to the list not changing the not actually changing the object/parents lists content</span>
