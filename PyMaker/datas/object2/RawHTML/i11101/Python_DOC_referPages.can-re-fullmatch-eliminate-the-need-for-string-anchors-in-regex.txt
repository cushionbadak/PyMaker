<div class="post-text" itemprop="text">
<p>Consider the following regex, which checks for password strength.  It has the start and end string anchors, to ensure it's matching the entire string.</p>
<pre><code>pattern = re.compile(r'^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[$@$!%*#?&amp;.])[A-Za-z\d$@$!%*#?&amp;.]{8,}$')
    while True:
        user_pass = input('Enter a secure password: ')
        if re.fullmatch(pattern, user_pass):
            print('Successfully changed password')
            break
        else:
            print('Not secure enough. Ensure pass is 8 characters long with at least one upper and lowercase letter, number,'
                  ' and special character.')
</code></pre>
<p>I noticed Python 3.5 has a re.fullmatch() which appears to do the same thing, but without the string anchors:</p>
<pre><code>pattern = re.compile(r'(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[$@$!%*#?&amp;.])[A-Za-z\d$@$!%*#?&amp;.]{8,}')
while True:
    user_pass = input('Enter a secure password: ')
    if re.fullmatch(pattern, user_pass):
        print('Successfully changed password')
        break
    else:
        print('Not secure enough. Ensure pass is 8 characters long with at least one upper and lowercase letter, number,'
              ' and special character.')
</code></pre>
<p>Is this the intended purpose of fullmatch?  Are there any situations where this could cause unintended issues?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/re.html#re.fullmatch" rel="nofollow"><code>fullmatch()</code></a> function and <a href="https://docs.python.org/3/library/re.html#re.regex.fullmatch" rel="nofollow"><code>regex.fullmatch()</code></a> method <a href="https://docs.python.org/3/whatsnew/3.4.html#re" rel="nofollow">are new in Python 3.4</a>.</p>
<p>The changelog is very explicit about it:</p>
<blockquote>
<p>This provides a way to be explicit about the goal of the match, which
  avoids a class of subtle bugs where $ characters get lost during code
  changes or the addition of alternatives to an existing regular
  expression.</p>
</blockquote>
<p>So, the way you use it is indeed the intended purpose of this feature. It can not lead to unexpected issue, <code>^</code> and <code>$</code> are just carefully added internally.</p>
</div>
<span class="comment-copy">why not just use the anchors, its less extra chars 2 vs 4? that way people who are familiar with regex in general,but maybe not with some python specific stuff, will know what you mean.</span>
<span class="comment-copy">@JoranBeasley That isn't helpful in the least.</span>
<span class="comment-copy">you have to type more and its less clear to people who know regex ... im not sure why they even added that ... as such it does not answer your question I know ... thats why its a comment</span>
<span class="comment-copy">@JoranBeasley You're not addressing the question.</span>
<span class="comment-copy">The point is that sometimes you have to use an anchor explicitly, e.g. in lookahead conditions. Thus, the title is a bit ambiguous, you can't just forget about using anchors. Only do that when you know what you are doing.</span>
<span class="comment-copy">Thank you sir.  This is what I was looking for.</span>
<span class="comment-copy"><a href="https://bugs.python.org/issue16203" rel="nofollow noreferrer">Tim Peters observes</a> <code>re.match(r'a|ab$', 'ab').group()</code> returns <code>'a'</code>, while <code>re.fullmatch(r'a|ab', 'ab').group()</code> returns <code>'ab'</code>. So <code>re.fullmatch(...)</code> is not simply a replacement for <code>re.match('...$')</code>. That's pretty subtle.</span>
<span class="comment-copy">I see this actually as an example in favor of fullmatch - the original re should probably have been written re.match(r'(a|ab)$', 'ab').group() but the missing parens caused the end-anchoring '$' to be associated only with the 'ab' branch of the alternation.</span>
