<div class="post-text" itemprop="text">
<p>I just trying to know the rationale behind the empty class size in python, In C++ as everyone knows the size of empty class will always shows 1 byte(as far as i have seen) this let the run time to create unique object,and i trying to find out what size of empty class in python:</p>
<pre><code>class Empty:pass # i hope this will create empty class
</code></pre>
<p>and when i do </p>
<pre><code>import sys
print ("show",sys.getsizeof(Empty)) # i get 1016
</code></pre>
<p>I wonder why the <code>Empty</code> takes this much 1016(bytes)? and also does the value(1016) it returns is this a standard value that never change(mostly) like C++?, Do we expect any zero base class optimization from python interpreter?Is there any way we can reduce the size of am Empty(just for curiosity sake)?</p>
</div>
<div class="post-text" itemprop="text">
<p>I assume you are running a 64 bit version of Python 3. On 32 bit Python 3.6 (on Linux), your code prints <code>show 508</code>.</p>
<p>However, that's the size of the class object itself, which inherits quite a lot of things from the base <code>object</code> class. If you instead get the size of an <em>instance</em> of your class the result is much smaller. On my system, </p>
<pre><code>import sys

class Empty(object):
    pass

print("show", sys.getsizeof(Empty()))
</code></pre>
<p><strong>output</strong></p>
<pre><code>show 28
</code></pre>
<p>which is a <em>lot</em> more compact. :)</p>
<p>FWIW, on Python 2.6.6, <code>sys.getsizeof(Empty)</code> returns 448 for a new-style class, and a measly 44 for an old-style class (one that doesn't inherit from <code>object</code>). <code>sys.getsizeof(Empty())</code> returns 28 for a new-style class instance and 32 for an old-style.</p>
<hr/>
<p>You can reduce the size of an instance by using <a href="https://docs.python.org/3/reference/datamodel.html#object.__slots__"><code>__slots__</code></a></p>
<blockquote>
<p>This class variable can be assigned a string, iterable, or sequence of
  strings with variable names used by instances. <code>__slots__</code> reserves
  space for the declared variables and prevents the automatic creation
  of <code>__dict__</code> and <code>__weakref__</code> for each instance.</p>
</blockquote>
<pre><code>import sys

class Empty(object):
    __slots__ = []

print("show", sys.getsizeof(Empty()))
</code></pre>
<p><strong>output</strong></p>
<pre><code>show 8
</code></pre>
<p>Please read the docs to understand how to use this feature.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>Python 2.7.11 (default, Apr 12 2016, 14:09:35) 
[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin
&gt;&gt;&gt; class Empty:pass
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print ("show",sys.getsizeof(Empty)) # i get 1016
('show', 104)
&gt;&gt;&gt; print ("show",sys.getsizeof(Empty()))
('show', 72)
</code></pre>
<p>Not 1016 bytes. As you can see, this is implementation specific. Other interesting sizes, using new-style classes:</p>
<pre><code>&gt;&gt;&gt; print ("show",sys.getsizeof(object())) 
('show', 16)
&gt;&gt;&gt; class Empty2(object):pass
&gt;&gt;&gt; print ("show",sys.getsizeof(Empty2)) 
('show', 904)
&gt;&gt;&gt; print ("show",sys.getsizeof(Empty2())) 
('show', 64)
</code></pre>
<p>An empty class definition is still a class definition and hence a class object (<a href="https://docs.python.org/2/tutorial/classes.html#class-definition-syntax" rel="nofollow">more here</a>):</p>
<blockquote>
<p>When a class definition is entered, a new namespace is created, and used as the local scope ..</p>
<p>When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of
  the namespace created by the class definition ...</p>
</blockquote>
<p>All class objects have a minimal set of attributes, which you see by doing:</p>
<pre><code>    &gt;&gt;&gt; dir(Empty)
['__doc__', '__module__']
&gt;&gt;&gt; dir(Empty2)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
</code></pre>
<p>And also other implementation details, which is the reason for their larger than naively-expected size.</p>
<p>Finally, note that that the class <em>instances</em> are indeed rather small, as expected, and not as big as class <em>objects</em>. <code>Empty</code> is a class object. <code>Empty()</code> is a class instance.</p>
</div>
<span class="comment-copy">It returns <code>104</code> on my machine.</span>
<span class="comment-copy">I ran my code on this <a href="https://repl.it/languages/python3" rel="nofollow noreferrer">repl.it/languages/python3</a></span>
<span class="comment-copy"><code>104</code> if you are on Python2.x</span>
<span class="comment-copy">It's not really empty, it inherits <code>object</code> which already comes with some baggage. Look at <code>dir(Empty)</code>, it's not an empty list!</span>
<span class="comment-copy">Jon, yes it shows methods, does the method count in size?</span>
<span class="comment-copy">PM, when i do dir(Empty) the most of the things i could see is operators/methods, does the method does count in size()?</span>
<span class="comment-copy">@Richard_G. The actual code of the method isn't counted, but the <i>pointer</i> to the method is counted. Similarly, if you call <code>sys.getsizeof</code> on a list you only get the size of the list object itself plus the size of all the pointers to the objects referenced in the list; <code>sys.getsizeof</code> is <i>not</i> recursive.</span>
<span class="comment-copy">PM, when i add methods in Empty the size is same(so does the method really count)?</span>
<span class="comment-copy">@Richard_G The pointers to the methods (and any other attributes) you add are going into the object's <code>__dict__</code>, so they aren't directly visible to <code>sys.getsizeof</code>.</span>
