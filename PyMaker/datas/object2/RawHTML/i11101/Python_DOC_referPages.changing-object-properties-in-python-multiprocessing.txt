<div class="post-text" itemprop="text">
<p>consider the following objects:</p>
<pre><code>class Item(object):
    def __init__(self):
        self.c = 0
    def increase(self):
        S.increase(self)

class S(object):
    @staticmethod
    def increase(item):
        item.c += 1
</code></pre>
<p>This mirrors the situation I am currently in, S is some library class, Item collects and organises data and data manipulation processes. Now I want to parallelise the work, for that I use the python multiprocessing module:</p>
<pre><code>from multiprocessing import Process
l= [Item() for i in range(5)]
for i in l:
    Process(target=i.increase).start()
</code></pre>
<p>The result is not what I expected:</p>
<pre><code>[i.c for i in l]
[0, 0, 0, 0, 0]
</code></pre>
<p>Where am I going wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're expecting your mutator, the static method <code>increase</code> in class <code>S</code> (called from the non-static <code>increase</code> in class <code>item</code>) to adjust each <code>i.c</code> field—and it does.  The problem is not with the static method, but rather with the internal design of <code>multiprocessing</code>.</p>
<p>The <code>multiprocessing</code> package works by running multiple separate instances of Python.  On Unix-like systems, it uses <code>fork</code>, which makes this easier; on Windows-like systems, it spawns new copies of itself.  Either way, this imposes all the slightly odd restrictions described in the Python documentation: <a href="https://docs.python.org/2/library/multiprocessing.html#programming-guidelines" rel="nofollow">v2</a> and <a href="https://docs.python.org/3/library/multiprocessing.html#programming-guidelines" rel="nofollow">v3</a>.  (NB: the rest of the links below are to the Python2 documentation since that was the page I still had open.  The restrictions are pretty much the same for both Python2 and Python3.)</p>
<p>In this particular case, each <code>Process</code> call makes a copy of the object <code>i</code> and sends that copy to a new process.  The process modifies the copy, which has no effect on the original.</p>
<p>To fix this, you may either send the modified objects back, e.g., through a <a href="https://docs.python.org/2/library/multiprocessing.html#exchanging-objects-between-processes" rel="nofollow">Queue() or Pipe() instance</a>, or place the objects into <a href="https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow">shared memory</a>.  The send-back technique is simpler and easier to program and automatically does most of the necessary synchronization (but see the caveat about being sure to collect all results before using a Process instance's <code>join</code>, even implicitly).</p>
</div>
<span class="comment-copy">This has nothing to do with the use of static methods, but rather with the way the multiprocessing module works. When you start a new <code>Process</code> it gets a <i>copy</i> of each object <code>i</code>. See <a href="http://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python?rq=1" title="multiprocessing vs threading python">stackoverflow.com/questions/3044580/…</a> for instance.  To obtain a mutated object back you must either send it back from the Process, or put it in a shared area: <a href="https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">docs.python.org/2/library/…</a></span>
<span class="comment-copy">This seems to be the issue, if you do post it as an answer, I can give you the mark! Thank you a lot!</span>
