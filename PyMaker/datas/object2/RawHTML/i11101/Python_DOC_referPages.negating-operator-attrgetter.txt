<div class="post-text" itemprop="text">
<p>I would like to use <code>operator.attrgetter</code> and <code>itertool.groupby</code> to split a string of text by spaces, preserving the number of spaces between the text. This is the expected behaviour:</p>
<pre><code>result = process('Am                    G          C')
assert result == [(2, 'Am'), (20, ' '), (1, 'G'), (10, ' '), (1, 'C')]
</code></pre>
<p>As I said I'd like to use <code>attrgetter</code> because I find it more pythonic than using a lambda. I can do:</p>
<pre><code>text = '''Am                    G          C'''
processed=((k, list(l))for k, l in groupby(text, attrgetter("isspace")))
result = [(len(l), "".join(l)) if k else (len(l), " ") for k, l in processed]
</code></pre>
<p>But this will return:</p>
<pre><code>[(1, 'A'), (1, 'm'), (20, '                    '), (1, 'G'), (10, '          '), (1, 'C')]
</code></pre>
<p>What I need though, is exactly the opposite and I tried:</p>
<pre><code>from operator import neg, attrgetter
text = '''Am                    G          C'''
processed = ((k,list(l)) for k,l in groupby(text, neg(attrgetter("isspace"))))
result = [(len(l), "".join(l)) if k else (len(l), " ") for k, l in processed]
</code></pre>
<p>This throws:</p>
<blockquote>
<p>TypeError: bad operand type for unary -: 'operator.attrgetter'</p>
</blockquote>
<p>How can I negate the value returned from <code>attrgetter</code> for keyfunction purposes?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3.5/library/operator.html#operator.attrgetter" rel="nofollow"><code>operator.attrgetter</code></a> won't directly work as a key function here. <code>attrgetter("isspace")(x)</code> will just fetch the <code>"isspace"</code> attribute of <code>x</code>, while you also need to call it:</p>
<pre><code>&gt;&gt;&gt; attrgetter("isspace")(" ")
&lt;built-in method isspace of str object at 0x7f30c4301ab0&gt;
&gt;&gt;&gt; attrgetter("isspace")(" ")()
True
</code></pre>
<p>You could use <a href="https://docs.python.org/3.5/library/stdtypes.html#str.isspace" rel="nofollow"><code>str.isspace</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; processed = ((k, list(l)) for k, l in groupby(text, str.isspace))
&gt;&gt;&gt; result = [(len(l), " ") if k else (len(l), "".join(l)) for k, l in processed]
&gt;&gt;&gt; result
[(2, 'Am'), (20, ' '), (1, 'G'), (10, ' '), (1, 'C')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you cannot make an inverted function of the the <code>attrgetter</code>, or any other function with the <code>neg</code> operator. First of all, <code>neg</code> stands for <em>negation</em>; e.g. <code>neg(x)</code> &lt;=&gt; <code>-x</code>. And this applied to <code>False</code> results in <code>0</code>; <code>True</code> =&gt; <code>-1</code>. The boolean negation is <code>operator.not_</code>. But even then this would do little to help you negate the return value - and actaully even negating wouldn't help you. </p>
<p>Instead you should just pass in <code>str.isspace</code> to <code>groupby</code>; <code>str.ispace</code> is an unbound method - that accepts an argument of type <code>str</code>.</p>
<p>What you are seeing here is that the return value of <code>attrgetter('isspace')</code> is called with each single character as a value. Each invocation returns a <em>bound</em> instance method:</p>
<pre><code>&gt;&gt;&gt; attrgetter('isspace')('a')
&lt;built-in method isspace of str object at 0x7fb204de5110&gt;
</code></pre>
<p>As each of these bound methods are bound to a different instance, they are necessarily distinct from each other, and do not compare equal to each other, that is why your code doesn't do what you'd expect. To get the actual value, you'd have to <em>call</em> this method yet again:</p>
<pre><code>&gt;&gt;&gt; attrgetter('isspace')('a')
False
</code></pre>
<hr/>
<p>For this case I'd ditch the <code>itertools</code> completely. This is a text-only task, so regular expressions and the <a href="https://docs.python.org/3/library/re.html" rel="nofollow"><code>re</code></a> module are the way to go.</p>
<p>There is no need to even handle this character-by-character when <code>re.split</code> is going to already achieve 90 % of what you want:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'Am                    G          C'
&gt;&gt;&gt; parts = re.split('(\s+)', s)
&gt;&gt;&gt; parts
['Am', '                    ', 'G', '          ', 'C']
</code></pre>
<p>Then, just use a list comprehension to make these into length, string tuples:</p>
<pre><code>&gt;&gt;&gt; [(len(i), i) for i in parts]
[(2, 'Am'), (20, '                    '), (1, 'G'), (10, '          '), (1, 'C')]
</code></pre>
<p>That is, <code>re.split</code> splits by a given regular expression. <code>\s+</code> matches one or more white-space characters. Normally the delimiter is discarded, but if the regular expression contains a subgroup <code>(...)</code> then contents of that subgroup are also retained in the match. </p>
</div>
<span class="comment-copy">Just write your own function to invert it and use that.</span>
<span class="comment-copy">I think the closest you will get without resorting to a lambda is <code>" ".__ne__</code>.</span>
<span class="comment-copy">In this specific question, you don't really need to negate the function here, just negate the condition in the if/else expression. So <code>x if y else z</code> becomes <code>x if not y else z</code>. eg. <code>result = [(len(l), "".join(l)) if not k else (len(l), " ") for k, l in processed]</code>. You can also use <code>str.isspace</code> over <code>attrgetter("isspace")</code>.</span>
<span class="comment-copy">This doesn't work because the groups are inverted then</span>
<span class="comment-copy">But that's what you want? You're just applying the negation in a different place. Where you apply the negation, doesn't effect <code>groupby</code>. You do <code>(... groupby(text, (lambda x: not x.isspace())))</code> followed by <code>[x if y else z]</code>. I do <code>(... groupby(text, str.isspace))</code> followed by <code>[x if not y else z]</code></span>
<span class="comment-copy">This is actually a much more readable solution. Thank you.</span>
