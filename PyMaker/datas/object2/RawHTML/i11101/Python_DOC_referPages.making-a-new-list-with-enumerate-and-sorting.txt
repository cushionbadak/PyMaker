<div class="post-text" itemprop="text">
<p>I am brand new to python and coding in general. I'm actually a Cinema 4D artist. C4D has a built in python script manager. I will do my best to explain what I'm trying for.</p>
<p>I have a sphere. The sphere is broken up into points. I have calculated the distance each point on the sphere is away from a different object. I have made a list of all these calculated distances. I would like to make a new array of the index and the corresponding distance calculation. How do I combine the two lists into a new array? Mock example below -</p>
<pre><code>def main():
    pointdistance = [150.2, 2.3, 5.5, 145.2, 30.4, 22]
    indices = list(range(len(pointdistance)))

    print indices
</code></pre>
<p>It returns the correct number of indices needed [0,1,2,3,4,5]
my desired result would look like a combination - something like this:</p>
<pre><code>preweight = [(0,150.2)(1,2.3)(2,5.5)(3,145.2)(4,30.4)(5,22)]
</code></pre>
<p>For bonus I would like to dynamically sort the new "preweight" array based on the distance calculation. So as I move the object around the array sorts from closest point to furtherest point. Kinda like this:</p>
<pre><code>postweight = [(1,2.3)(2,5.5)(5,22)(4,30.4)(3,145.2)(1,150.2)]
</code></pre>
<p>Thanks in advance. I am really enjoying the help this site provides.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>enumerate(..)</code>. When called on a list and iterated over, it returns elements of the list as a tuple of <code>(index, element)</code>.</p>
<p>For the second half of your question, use <code>sorted(.., key=&lt;func&gt;)</code>. <code>sorted(..)</code> when called with a <code>key=</code> will use the value returned by the function applied on the item for  sorting. In your specific case, <code>&lt;func&gt;</code> would be something that would take an element and return the second item of the tuple. Something like: <code>lambda x: x[1]</code></p>
<pre><code>&gt;&gt;&gt; pointdistance = [150.2, 2.3, 5.5, 145.2, 30.4, 22]
&gt;&gt;&gt; list(enumerate(pointdistance))
[(0, 150.2), (1, 2.3), (2, 5.5), (3, 145.2), (4, 30.4), (5, 22)]
&gt;&gt;&gt; sorted(enumerate(pointdistance), key=lambda x: x[1])
[(1, 2.3), (2, 5.5), (5, 22), (4, 30.4), (3, 145.2), (0, 150.2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add to <a href="https://stackoverflow.com/a/38003807/3159288">SuperSaiyan's answer</a>, the built-in <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> provides a more robust tool for solving all similar problems. While <code>enumerate</code> simply pairs a list of elements with their indexes automatically, <code>zip</code> requires that you provide a series of iterables that it will group together:</p>
<pre><code>obj_labels = ['a', 'b', 'c', 'd']
obj_values = [1, 4, 7, 3]

paired = zip(obj_labels, obj_values)

print(paired) # gives: [('a', 1), ('b', 4), ('c', 7), ('d', 3)]

ordered = sorted(paired, key=lambda pair: pair[1])
print(ordered) # gives: [('a', 1), ('d', 3), ('b', 4), ('c', 7)]
</code></pre>
<p>However <code>zip</code> also allows you to do some other cool things like grouping more than two iterables, and "unzipping" a list elements that are equal length pairs. Continuing from the previous example:</p>
<pre><code># we can "unzip" our pairs like this
unzipped = zip(*paired)
# they come out as tuples
l1 = list(unzipped[0])
l2 = list(unzipped[1])

# check that we've unzipped
assert l1 == obj_labels
assert l2 == obj_values

# add more data to our paired list
obj_indexes = range(len(obj_values))

paired_len3 = zip(obj_labels, obj_indexes, obj_values)
ordered_len3 = sorted(paired_len3, key=lambda pair: pair[2])
print(ordered_len3) # gives: [('a', 0, 1), ('d', 3, 3), ('b', 1, 4), ('c', 2, 7)]
</code></pre>
</div>
<span class="comment-copy">Just a pedantic note ... enumerate does not "return a new list"</span>
<span class="comment-copy">Good catch. Let me fix my post..</span>
<span class="comment-copy">Wow thanks for the speedy response. I greatly appreciate your help. So far this seems to be perfect. Now I'll spend all next week trying to implement this data into a practical animation and come back with some C4D specific python questions I am sure.</span>
<span class="comment-copy">@SuperSaiyan Thanks so much! Should I ask a follow up question in a new thread? Or is there a better approach to follow ups?</span>
<span class="comment-copy">You can, as comments here, unless it isn't off the main topic.</span>
<span class="comment-copy">Oh this is a really interesting feature! Thank you! It harps on what my follow up question would be. I'll try to explain it thoughtfully PS: I'm sorry this is my first time on the site and I can't seem to figure out how to add code into the comments: I would like to combine the Distance variable with a global position Vector.  So an example array would look something like this -   pointA = [22.5,Vector(100,100,100)]  And then can I unzip this to access just the Vector value?</span>
<span class="comment-copy">Write `&lt;my code&gt;` and it will render as <code>&lt;my code&gt;</code>. When answering a question tagged with a particular language, it will automatically add syntax highlighting (to force highlighting <a href="http://meta.stackoverflow.com/questions/274371/what-is-syntax-highlighting-and-how-does-it-work">see here</a>).</span>
<span class="comment-copy">As for your vector question, yes. If <code>v_i</code> is a vector and <code>d_i</code> is a distance for <code>i</code> in <code>[1, 2, ... n]</code>, and we have <code>pairs = [(d_1, v_1), (d_2, v_2), ... (d_n, v_n)]</code> we can use <code>zip</code> to separate the vectors and distances with <code>distances, vectors = zip(*pairs)</code> (but remember <code>distances</code> and <code>vectors</code> come out as tuples, not lists).</span>
<span class="comment-copy">Thanks so much! This is great. I am getting an &lt;AssertionError&gt; when trying to &lt;unzipped = zip(*ordered)&gt; . Is there a reason for this? Or could my syntax be wrong?</span>
<span class="comment-copy">Oh i think I understand! The "assert" is checking to see if obj_dis and l2 are exactly the same. But they are not == because obj_dis is "unsorted" and l2 is "sorted". Thanks again Whiskey! You have been very helpful!</span>
