<div class="post-text" itemprop="text">
<p>Does an ordinary for/in statement guarantee the list is iterated in order?</p>
<pre><code>my_list = [5,4,3,2]
for i in my_list
    print(i)
</code></pre>
<p>That is, is the loop above guaranteed to print <code>5 4 3 2</code> every time?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>for</code> loop's iteration order is controlled by whatever object it's iterating over. Iterating over an ordered collection like a <code>list</code> is guaranteed to iterate over elements in the list's order, but iterating over an unordered collection like a <code>set</code> makes almost no order guarantees.</p>
</div>
<div class="post-text" itemprop="text">
<p>For lists, yes, since they are ordered data structures in Python. </p>
</div>
<div class="post-text" itemprop="text">
<p>When you iterate over a sequence (list, tuple, etc.), the order is guaranteed.
Hashed structures (dict, set, etc.) have their own order -- but for a given structure, the order will be the same each time.  If you add or delete an element, the order may then be different.</p>
<hr/>
<p>Consider the folloing code: I make a set of five elements, and then print it out with four identical <strong>for</strong> loops.  The order is the same.  Then I add two elements; this upsets the order.</p>
<pre><code>my_set = set(["Apple", "Banana", "Casaba", "Dinner", "Eggplant"])

for food in my_set:
    print food,
print "\n"

for food in my_set:
    print food,
print "\n"

for food in my_set:
    print food,
print "\n"

for food in my_set:
    print food,
print "\n"

my_set.add("Fruitcacke")
my_set.add("Grape")

for food in my_set:
    print food,
print "\n"
</code></pre>
<p>Output:</p>
<pre><code>Casaba Dinner Apple Eggplant Banana 

Casaba Dinner Apple Eggplant Banana 

Casaba Dinner Apple Eggplant Banana 

Casaba Dinner Apple Eggplant Banana 

Casaba Fruitcacke Grape Apple Dinner Eggplant Banana 
</code></pre>
<p>Note how the original elements are no longer in the same order: "Dinner" now comes after "Apple".</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to test it yourself:</p>
<pre><code>my_list = [5,4,3,2]

for _ in range(20):
    new_list = []
    for i in my_list:
        new_list.append(i)
    print(my_list == new_list) 
</code></pre>
<p>And just for a control case:</p>
<pre><code>print([2,4,5,3] == my_list)
</code></pre>
</div>
<span class="comment-copy">Yes, it should, every time, since lists are ordered.</span>
<span class="comment-copy">If you are iterating over a <code>dict</code>, the order may be different than expected. Python dicts are unordered.</span>
<span class="comment-copy">See <a href="https://docs.python.org/2/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">docs.python.org/2/reference/â€¦</a></span>
<span class="comment-copy">"each time" deserves a bit of elaboration. Within a single run of a Python program, iterating over a dict or set twice without changing it will produce the same order, but iterating over "the same" dict or set in two different runs of the program could produce two different orders.</span>
<span class="comment-copy">Even if currently the order is preserved when iterating multiple times over a set this is not guaranteed and should not be relied on. If order is important one should choose a datastructure that guarantees order.</span>
<span class="comment-copy">@user2357112: Thanks; I added an example to illustrate.</span>
<span class="comment-copy">@syntonym: I'm not sure about sets, but it actually is guaranteed for dicts. The <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">docs</a> give the example that <code>zip(d.values(), d.keys())</code> won't scramble the key-value associations.</span>
<span class="comment-copy">@user2357112 You are right, I forgot about that. Also I can't really imagine a (sane) implementation that would not produce reproducible iteration order, but   depending on undocumented behavoir is bad.</span>
<span class="comment-copy">Heh, I have been trying it myself. Hence my question. But i have since discovered my error. ;-)</span>
