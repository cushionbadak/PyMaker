<div class="post-text" itemprop="text">
<p>I am working through a tutorial on sets in Python 2.7, and I have run into a behavior using a <code>for</code> loop that I do not understand, and I am trying to find out what the reason for the difference in outputs might be.</p>
<p>The object of the exercise is to produce a set, cities, from a dictionary that contains keys made up of city pairs of frozen sets using a for loop. </p>
<p>The data comes from the following dictionary:</p>
<pre><code>flight_distances = {
    frozenset(['Atlanta', 'Chicago']): 590.0,
    frozenset(['Atlanta', 'Dallas']): 720.0,
    frozenset(['Atlanta', 'Houston']): 700.0,
    frozenset(['Atlanta', 'New York']): 750.0,
    frozenset(['Austin', 'Dallas']): 180.0,
    frozenset(['Austin', 'Houston']): 150.0,
    frozenset(['Boston', 'Chicago']): 850.0,
    frozenset(['Boston', 'Miami']): 1260.0,
    frozenset(['Boston', 'New York']): 190.0,
    frozenset(['Chicago', 'Denver']): 920.0,
    frozenset(['Chicago', 'Houston']): 940.0,
    frozenset(['Chicago', 'Los Angeles']): 1740.0,
    frozenset(['Chicago', 'New York']): 710.0,
    frozenset(['Chicago', 'Seattle']): 1730.0,
    frozenset(['Dallas', 'Denver']): 660.0,
    frozenset(['Dallas', 'Los Angeles']): 1240.0,
    frozenset(['Dallas', 'New York']): 1370.0,
    frozenset(['Denver', 'Los Angeles']): 830.0,
    frozenset(['Denver', 'New York']): 1630.0,
    frozenset(['Denver', 'Seattle']): 1020.0,
    frozenset(['Houston', 'Los Angeles']): 1370.0,
    frozenset(['Houston', 'Miami']): 970.0,
    frozenset(['Houston', 'San Francisco']): 1640.0,
    frozenset(['Los Angeles', 'New York']): 2450.0,
    frozenset(['Los Angeles', 'San Francisco']): 350.0,
    frozenset(['Los Angeles', 'Seattle']): 960.0,
    frozenset(['Miami', 'New York']): 1090.0,
    frozenset(['New York', 'San Francisco']): 2570.0,
    frozenset(['San Francisco', 'Seattle']): 680.0,
}
</code></pre>
<p>There is also a test list that will create the intended set as a check:</p>
<pre><code>flying_circus_cities = [
    'Houston', 'Chicago', 'Miami', 'Boston', 'Dallas', 'Denver', 
    'New York', 'Los Angeles', 'San Francisco', 'Atlanta', 
    'Seattle', 'Austin'
]
</code></pre>
<p>When the code is written in the following form, the loop produces the intended result.</p>
<pre><code>cities = set()
for pair in flight_distances:
    cities = cities.union(pair)
print cities
print "Check:", cities == set(flying_circus_cities)
</code></pre>
<p>Output:</p>
<pre><code>set(['Houston', 'Chicago', 'Miami', 'Boston', 'Dallas', 'Denver', 'New York', 'Los Angeles', 'San Francisco', 'Atlanta', 'Seattle', 'Austin'])
Check: True
</code></pre>
<p>However, if I attempt as a comprehension, with either of the following, I get a different result.</p>
<pre><code>cities = set()
cities = {pair for pair in flight_distances}
print cities
print "Check:", cites == set(flying_circus_cities)
</code></pre>
<p>or</p>
<pre><code>cities = set()
cities = cities.union(pair for pair in flight_distances)
print cities
print "Check:", cities == set(flying_circus_cities)
</code></pre>
<p>Output for both:</p>
<pre><code>set([frozenset(['Atlanta', 'Dallas']), frozenset(['San Francisco', 'New York']), frozenset(['Denver', 'Chicago']), frozenset(['Houston', 'San Francisco']), frozenset(['San Francisco', 'Austin']), frozenset(['Seattle', 'Los Angeles']), frozenset(['Boston', 'New York']), frozenset(['Houston', 'Atlanta']), frozenset(['New York', 'Chicago']), frozenset(['San Francisco', 'Seattle']), frozenset(['Austin', 'Dallas']), frozenset(['New York', 'Dallas']), frozenset(['Houston', 'Chicago']), frozenset(['Seattle', 'Denver']), frozenset(['Seattle', 'Chicago']), frozenset(['Miami', 'New York']), frozenset(['Los Angeles', 'Denver']), frozenset(['Miami', 'Houston']), frozenset(['San Francisco', 'Los Angeles']), frozenset(['New York', 'Denver']), frozenset(['Atlanta', 'Chicago']), frozenset(['Boston', 'Chicago']), frozenset(['Houston', 'Austin']), frozenset(['Houston', 'Los Angeles']), frozenset(['New York', 'Los Angeles']), frozenset(['Atlanta', 'New York']), frozenset(['Denver', 'Dallas']), frozenset(['Los Angeles', 'Dallas']), frozenset(['Los Angeles', 'Chicago'])])
Check: False
</code></pre>
<p>I cannot figure out why the for loop in the first example unpacks the pairs as intended so that it produces a set with one instance of each city, while trying to write the loop as a comprehension pulls out the <code>frozenset([city1, city2])</code> pairs and places them in the set instead. </p>
<p>I do not understand why <code>pair</code> would give the city strings in the first instance but passes the frozenset in the second instance.</p>
<p>Can someone explain the different behavior?</p>
<p><strong>Note:</strong> As explained by <a href="https://stackoverflow.com/users/2666289/holt">Holt</a> and <a href="https://stackoverflow.com/users/5249307/donkopotamus">donkopotamus</a>, the issue of why this was behaving differently was that using the comprehension evaluated the entire dictionary completely before making a single assignment to the <code>cities</code> variable, thus creating a set of frozensets, where as the standard <code>for</code> loop unpacked the pairs one at a time and evaluated each individual one separately, assigning them to <code>cities</code> one at a time with each pass of the <code>for</code> loop and allowing the union function to evaluate each instance of the pairs being passed to it.</p>
<p>They further explained that using the <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer"><code>*</code>-operator</a> unpacks the dictionary in the comprehension to produce the desired behavior.</p>
<pre><code>cities = cities.union(*(set(pair) for pair in flight_distances))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the first version, <code>pair</code> is a <code>frozenset</code> at each loop, so you can do a <code>union</code> with it, while in your version, you try do a union with a <code>set</code> of <code>frozenset</code>.</p>
<p>The first case comes down to (union with a <code>frozenset</code> at each iteration):</p>
<pre><code>cities = set()
cities.union(frozenset(['Atlanta', 'Chicago']))
cities.union(frozenset(['Atlanta', 'Dallas']))
...
</code></pre>
<p>So you have (mathematically):</p>
<pre><code>cities = {} # Empty set
cities = {} U {'Atlanta', 'Chicago'} = {'Atlanta', 'Chicago'}
cities = {'Atlanta', 'Chicago'} U {'Atlanta', 'Dallas'} = {'Atlanta', 'Chicago', 'Dallas'}
...
</code></pre>
<p>In your (last) case, you are doing the following (one union with a sequence of <code>frozenset</code>):</p>
<pre><code>cities = set()
cities.union([frozenset(['Atlanta', 'Chicago']), frozenset(['Atlanta', 'Dallas']), ...])
</code></pre>
<p>So you have:</p>
<pre><code>cities = {}
cities = {} U {{'Atlanta', 'Chicago'}, {'Atlanta', 'Dallas'}, ...} 
       = {{'Atlanta', 'Chicago'}, {'Atlanta', 'Dallas'}, ...} # Nothing disappears
</code></pre>
<p>Since no two pairs are identical, you get a set of all the pairs in your initial dictionary, because you are passing a <code>set</code> of <code>set</code> (pair) of cities, not a <code>set</code> of cities to <code>.union()</code>.</p>
<hr/>
<p>On a more abstract point of view, you are trying to obtain:</p>
<pre><code>S = {} U S1 U S2 U S3 U ... U Sn = (((({} U S1) U S2) U S3) U ...) U Sn
</code></pre>
<p>With:</p>
<pre><code>S = {} U {S1, S2, S3, ..., Sn}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The expression:</p>
<pre><code>cities = set()
cities = cities.union(pair for pair in flight_distances)
</code></pre>
<p>will take the union of the empty set <code>{}</code> with another set</p>
<pre><code>{pair_0, pair_1, pair_2, ..., pair_n}
</code></pre>
<p>leaving you with a set of sets. </p>
<p>In contrast, the following will give you all of the cities flown to:</p>
<pre><code>&gt;&gt;&gt; set.union(*(set(pair) for pair in flight_distances))
{'Atlanta',
 'Austin',
 'Boston',
 'Chicago',
 'Dallas',
 'Denver',
 'Houston',
 'Los Angeles',
 'Miami',
 'New York',
 'San Francisco',
 'Seattle'}
</code></pre>
<p>Here we transform each of the frozen set keys into a plain set and find the union.</p>
</div>
<span class="comment-copy">Your set comprehension isn't performing a <code>.union</code> of the pairs, i.e. finding all unique <i>cities</i>, it's just finding all unique <i>pairs</i>. It's the equivalent of replacing <code>cities = cities.union(pair)</code> in the first version with <code>cities.add(pair)</code>. As far as I'm aware, you can't do that using a set comprehension (maybe using <code>reduce</code>, if you want a single line, but in general I think that would be considered less readable than what you currently have).</span>
<span class="comment-copy">@jonrsharpe Why wouldn't the second one with cities.union(pair for pair in flight distances) produce the same result as the first? It would seems like pair should be the same whether it is being fed by the for loop outside or as a comprehension. If you take the code that produces the intended result and put print pair before the set assignment it prints frozenset(['city1', 'city2']) but then the set assignment just takes the list.</span>
<span class="comment-copy">@jonrsharpe you can build such a set without using an ugly <code>reduce</code> ... <code>set.union(s_0, ..., s_n)</code> will return the union of the sets <code>s_0</code> through to <code>s_n</code></span>
<span class="comment-copy">@AMR I already explained that; it's adding the pair to the set not creating a union of the content of the pair with the elements already in the set.</span>
<span class="comment-copy">I understand the mathematical argument you are making. From the perspective of the loop though, is it that in the second example the cities set does not get assigned until the entire loop has run?</span>
<span class="comment-copy">@AMR In your second example you have only one assignment (the first <code>cities = set()</code> is useless here), so you are creating a big "list" of pairs and <b>then</b> sending it to <code>.union()</code>, which is not what you want, you want to send each pair separately to <code>.union()</code> (either one by one, or by using @donkopotamus version).</span>
<span class="comment-copy">Your example produced the intended set. I have not seen the * notation before. What does it do that makes the difference? TY</span>
<span class="comment-copy">@AMR It is unpacking the sequence in an argument list (see <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">the documentation</a>). Basically, <code>f(*[a, b, c, ...])</code> is <code>f(a, b, c, ...)</code>.</span>
<span class="comment-copy">If you don't need a regular <code>set</code> instance for the result, you could also use the most concise version: <code>frozenset.union(*flight_distances)</code> No generator expression needed!</span>
