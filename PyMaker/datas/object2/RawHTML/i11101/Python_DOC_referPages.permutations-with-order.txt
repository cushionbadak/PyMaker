<div class="post-text" itemprop="text">
<p>I am trying to write a Python function that performs a function similar to <code>itertools.permutation</code>.</p>
<pre><code>import itertools
for s in itertools.permutations("TCGA****")
    print s
</code></pre>
<p>The ideal output from such a function would be </p>
<pre><code>('*','*','*','*','T', 'C','G','A')
('*','*','*','T','*', 'C','G','A')
('*','*','*','T','C', '*','G','A')
('*','*','*','T','C', 'G','*','A')
('*','*','*','T','C', 'G','A','*')
('*','*','T','C','G', 'A','*','*')
('*','*','T','C','G', '*','*','A')
('*','*','T','C','*', '*','G','A')
...
('T', 'C','G','A','*','*','*','*')
</code></pre>
<p>The only difference between <code>itertools.permutation</code> and this function is that the order is maintained i.e. 'T' always precedes 'C' which precedes 'G' which precedes 'A'.   </p>
<p>The following is an example that violates this rule</p>
<pre><code>('*','*','T','*','G','C','A','*','*')
</code></pre>
<p>The order of 'C' and 'G' has changed.</p>
<p>How can I produce the permutations for which the order <code>'TCGA'</code> is maintained among the asterisks?</p>
</div>
<div class="post-text" itemprop="text">
<p>One idea would be to produce all the possible indices for your <code>'*'</code> values with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations</code></a> on your list index range, and then construct each possible permutation from those indices, filling with your <code>'TCGA'</code> values accordingly for the indices not found in each combination. </p>
<p>Since you are assured to use all of <code>TCGA</code> in each iteration, <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle</code></a> is one way to continually get the appropriate value for the next position. Here <code>perms</code> is implemented as a generator to allow for lazy evaluation. </p>
<pre><code>from itertools import combinations, cycle

char_cyc = cycle('TCGA')
combos = combinations(range(8), 4)

perms = (['*' if i in combo else next(char_cyc) for i in range(8)]
         for combo in combos)

print(list(perms))
</code></pre>
<p><strong>Outputs</strong>:</p>
<pre><code>[['*', '*', '*', '*', 'T', 'C', 'G', 'A'], ['*', '*', '*', 'T', '*', 'C', 'G', 'A'], ['*', '*', '*', 'T', 'C', '*', 'G', 'A'], ['*', '*', '*', 'T', 'C', 'G', '*', 'A'], ['*', '*', '*', 'T', 'C', 'G', 'A', '*'], ['*', '*', 'T', '*', '*', 'C', 'G', 'A'], ['*', '*', 'T', '*', 'C', '*', 'G', 'A'], ['*', '*', 'T', '*', 'C', 'G', '*', 'A'], ['*', '*', 'T', '*', 'C', 'G', 'A', '*'], ['*', '*', 'T', 'C', '*', '*', 'G', 'A'], ['*', '*', 'T', 'C', '*', 'G', '*', 'A'], ['*', '*', 'T', 'C', '*', 'G', 'A', '*'], ['*', '*', 'T', 'C', 'G', '*', '*', 'A'], ['*', '*', 'T', 'C', 'G', '*', 'A', '*'], ['*', '*', 'T', 'C', 'G', 'A', '*', '*'], ['*', 'T', '*', '*', '*', 'C', 'G', 'A'], ['*', 'T', '*', '*', 'C', '*', 'G', 'A'], ['*', 'T', '*', '*', 'C', 'G', '*', 'A'], ['*', 'T', '*', '*', 'C', 'G', 'A', '*'], ['*', 'T', '*', 'C', '*', '*', 'G', 'A'], ['*', 'T', '*', 'C', '*', 'G', '*', 'A'], ['*', 'T', '*', 'C', '*', 'G', 'A', '*'], ['*', 'T', '*', 'C', 'G', '*', '*', 'A'], ['*', 'T', '*', 'C', 'G', '*', 'A', '*'], ['*', 'T', '*', 'C', 'G', 'A', '*', '*'], ['*', 'T', 'C', '*', '*', '*', 'G', 'A'], ['*', 'T', 'C', '*', '*', 'G', '*', 'A'], ['*', 'T', 'C', '*', '*', 'G', 'A', '*'], ['*', 'T', 'C', '*', 'G', '*', '*', 'A'], ['*', 'T', 'C', '*', 'G', '*', 'A', '*'], ['*', 'T', 'C', '*', 'G', 'A', '*', '*'], ['*', 'T', 'C', 'G', '*', '*', '*', 'A'], ['*', 'T', 'C', 'G', '*', '*', 'A', '*'], ['*', 'T', 'C', 'G', '*', 'A', '*', '*'], ['*', 'T', 'C', 'G', 'A', '*', '*', '*'], ['T', '*', '*', '*', '*', 'C', 'G', 'A'], ['T', '*', '*', '*', 'C', '*', 'G', 'A'], ['T', '*', '*', '*', 'C', 'G', '*', 'A'], ['T', '*', '*', '*', 'C', 'G', 'A', '*'], ['T', '*', '*', 'C', '*', '*', 'G', 'A'], ['T', '*', '*', 'C', '*', 'G', '*', 'A'], ['T', '*', '*', 'C', '*', 'G', 'A', '*'], ['T', '*', '*', 'C', 'G', '*', '*', 'A'], ['T', '*', '*', 'C', 'G', '*', 'A', '*'], ['T', '*', '*', 'C', 'G', 'A', '*', '*'], ['T', '*', 'C', '*', '*', '*', 'G', 'A'], ['T', '*', 'C', '*', '*', 'G', '*', 'A'], ['T', '*', 'C', '*', '*', 'G', 'A', '*'], ['T', '*', 'C', '*', 'G', '*', '*', 'A'], ['T', '*', 'C', '*', 'G', '*', 'A', '*'], ['T', '*', 'C', '*', 'G', 'A', '*', '*'], ['T', '*', 'C', 'G', '*', '*', '*', 'A'], ['T', '*', 'C', 'G', '*', '*', 'A', '*'], ['T', '*', 'C', 'G', '*', 'A', '*', '*'], ['T', '*', 'C', 'G', 'A', '*', '*', '*'], ['T', 'C', '*', '*', '*', '*', 'G', 'A'], ['T', 'C', '*', '*', '*', 'G', '*', 'A'], ['T', 'C', '*', '*', '*', 'G', 'A', '*'], ['T', 'C', '*', '*', 'G', '*', '*', 'A'], ['T', 'C', '*', '*', 'G', '*', 'A', '*'], ['T', 'C', '*', '*', 'G', 'A', '*', '*'], ['T', 'C', '*', 'G', '*', '*', '*', 'A'], ['T', 'C', '*', 'G', '*', '*', 'A', '*'], ['T', 'C', '*', 'G', '*', 'A', '*', '*'], ['T', 'C', '*', 'G', 'A', '*', '*', '*'], ['T', 'C', 'G', '*', '*', '*', '*', 'A'], ['T', 'C', 'G', '*', '*', '*', 'A', '*'], ['T', 'C', 'G', '*', '*', 'A', '*', '*'], ['T', 'C', 'G', '*', 'A', '*', '*', '*'], ['T', 'C', 'G', 'A', '*', '*', '*', '*']]
</code></pre>
<hr/>
<p>A good indication that is output is correct is the fact that the length of <code>perms</code> is 70, which is equal to 8C4 (<em>or "8 choose 4"</em>), which is effectively what your problem concerns. </p>
</div>
<div class="post-text" itemprop="text">
<p>My solution is <strong>much less efficient than Mitch's</strong>, but it is another way to solve the problem, so it might interest you as well.</p>
<p>Here is my approach: generate all the possible permutations of "****XXXX" (40320 exactly), then, for each resulting permutation, replace each "X" by the corresponding value in "TGCA" in the wanted order.
The flaw here is that there won't be 40320 distinct patterns, but only 70, which means:</p>
<ul>
<li>we'll have to execute the "for" loop 40320 times when 70 would have been enough</li>
<li>we'll have to store the generated permutations in order to ignore the duplicates</li>
</ul>
<p>But as I said, it's another way of seeing the problem.</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; already_seen_permutations = set()
&gt;&gt;&gt; for s in itertools.permutations("****XXXX"):
...     if s in already_seen_permutations:
...         continue  # duplicate permutation, just ignore it
...     already_seen_permutations.add(s)
...     # time to insert TCGA correctly
...     s = tuple("".join(s).replace("X", "T", 1).replace("X", "C", 1).replace("X", "G", 1).replace("X", "A", 1))
...     print(s)
</code></pre>
<p>On my computer, it takes roughly one second to execute the code 100 times.
In term of performance, it's approximately the same than generating all the permutations of "****TCGA" and ignoring the ones that do not follow the "TCGA" order.</p>
</div>
<span class="comment-copy">Mitch, Thanks this is amazing</span>
