<div class="post-text" itemprop="text">
<p>I'm using a dictionary to count how many times different items appear in a dataset. In the <strong>init</strong> of the class, I create the property as a dictionary like this</p>
<pre><code>self.number_found = {}
</code></pre>
<p>The first time I find any particular item, I would get a KeyError if I try to do this because the item isn't in the dictionary yet</p>
<pre><code>self.number_found[item] = 1
</code></pre>
<p>so I ended up creating a function that checks if an entry is already in the dictionary and if not, adds it for the first time</p>
<pre><code> def _count_occurrences(self, item):

    try:
        #this checks to see if the item's already in the dict
        self.number_found[item] = self.number_found[item] + 1
        x = self.number_found[item] 
    except KeyError:
        x = 1
        #this adds an item if not in the dict
        self.number_found[item] = x
        return x
</code></pre>
<p>However, this is not working as intended if I find a second occurrence of an item in a dataset. </p>
<p>Let's say there are two 'elephant' in my dataset. When I print <code>self.number_found</code> to the console this is what I get</p>
<pre><code>{'elephant': 1}
{'elephant': None}
</code></pre>
<p>and I get this error when adding the second occurrence</p>
<pre><code>TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
</code></pre>
<p>Question: what's the right way to check if the key's already in the dictionary (with an explanation as to why the <code>1</code> is changing to a <code>None</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>defaultdict</code>:</p>
<pre><code>from collections import defaultdict

self.number_found = defaultdict(int)
</code></pre>
<p>The first time an item is accessed, its value will take a default of <code>0</code></p>
<p>A <code>None</code> is returned because you're not <em>returning</em> anything in your <code>try</code> branch</p>
</div>
<div class="post-text" itemprop="text">
<p>The return at the end of the except block must be moved out.  That way, x is returned for both cases</p>
<pre><code>class C(object):
     def __init__(self):
        self.number_found = {}

     def _count_occurrences(self, item):
        try:
            #this checks to see if the item's already in the dict
            self.number_found[item] = self.number_found[item] + 1
            x = self.number_found[item] 
        except KeyError:
            x = 1
            #this adds an item if not in the dict
            self.number_found[item] = x
        return x

c = C()

r = c._count_occurrences('elephant')
print r
print c.number_found
r = c._count_occurrences('elephant')
print r
print c.number_found
</code></pre>
<p>Here is a test run first with outdented return, then with it where you have it in your OP:</p>
<pre><code>jcg@jcg:~/code/python/stack_overflow$ python number_found.py
1
{'elephant': 1}
2
{'elephant': 2}
jcg@jcg:~/code/python/stack_overflow$ python number_found.py
1
{'elephant': 1}
None
{'elephant': 2}
</code></pre>
<p>As you can see, the second version returns None since there is no return from the _count_occurrences try block</p>
</div>
<span class="comment-copy">Is your return x statement indented correctly?</span>
<span class="comment-copy">no it wasn't :(</span>
<span class="comment-copy">That is what the <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>get</code></a> method is for: <code>d[item] = d.get(item, 0)</code>.  <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> might be of help.</span>
<span class="comment-copy">thank you, can you explain why the 1 changed to None (as requested in the OP)</span>
<span class="comment-copy">See my updated answer</span>
