<div class="post-text" itemprop="text">
<p>One of the basic changes from Python 2 to Python 3 was making <code>print</code> a function - which, to me, makes perfect sense given its structure.  Why aren't the <code>raise</code> and <code>del</code> statements also functions?  Especially in the case of <code>raise</code> it seems like it is taking an argument and doing something with it, just like a function does.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>raise</code> and <code>del</code> are definitely distinct from functions, each for different reasons:</p>
<ul>
<li><p><code>raise</code> exits the current flow of execution; the normal flow of byte-code interpretation is interrupted and the stack is unwound until the next exception handler is found. Functions can't do this, they create a new stack frame instead.</p></li>
<li><p><code>del</code> can't be a function, because you must specify a specific <em>target</em>; you can't use just any expression, and what is deleted depends on the syntax given; if you use subscription, then deletion takes place for a given element in a container, or a name is removed from the current namespace. The right namespace to delete to is also dependent on the scope of the name deleted. See the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-del-statement" rel="nofollow"><code>del</code> statement grammar definition</a>:</p>
<blockquote>
<pre><code>del_stmt ::=  "del" target_list
</code></pre>
</blockquote>
<p>A function can't remove items from a parent namespace, nor can they distinguish between the result of a subscription expression or a direct reference. You pass <em>objects</em> to the function, but to a <code>del</code> statement you pass a name and a context (perhaps by the interpreter when deleting a local or global name).</p></li>
</ul>
<p><code>print</code> on the other hand, requires no special relationship with the current namespace or stack frame, and needs no special syntax constraints to do it's work.  It is purely functionality at the <em>application level</em>. The global <code>sys.stdout</code> reference can be accessed by functions just as much as by the interpreter. As such it didn't need to be a statement, and by moving it to a function, additional benefits were made available, such as being able to override it's behaviour and to innovate on it quicker across Python releases.</p>
<p>Do note that <strong>part</strong> of the <code>raise</code> statement was moved to application-level code instead; in Python 2 you can attach a traceback to the raised exception with:</p>
<pre><code>raise ExceptionClass, exception_value, traceback_object
</code></pre>
<p>In Python 3, attaching a traceback to an exception has been moved to the exception itself:</p>
<pre><code>raise Exception("foo occurred").with_traceback(tracebackobj)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://www.python.org/dev/peps/pep-3105/" rel="nofollow noreferrer">https://www.python.org/dev/peps/pep-3105/</a> has a list of rationals why <code>print</code> is made function. Of the five reasons, (IMO) the most relevant one is:</p>
<blockquote>
<p>print is the only application-level functionality that has a statement dedicated to it.</p>
</blockquote>
<p>As explained by Alex Martelli here <a href="https://stackoverflow.com/a/1054062">https://stackoverflow.com/a/1054062</a>:</p>
<blockquote>
<p>Python statements are things the Python compiler must be specifically aware of -- they may alter the binding of names, may alter control flow, and/or may need to be entirely removed from the generated bytecode in certain conditions (the latter applies to assert). print was the only exception to this assertion in Python 2; by removing it from the roster of statements, Python 3 removes an exception, makes the general assertion "just hold", and therefore is a more regular language.</p>
</blockquote>
<p><code>del</code> and <code>raise</code> obviously alter the binding of names/alter the control flow, thus they both are okay. </p>
</div>
