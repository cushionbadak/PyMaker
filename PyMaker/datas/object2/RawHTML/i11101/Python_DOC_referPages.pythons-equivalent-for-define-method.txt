<div class="post-text" itemprop="text">
<p>I have this code in ruby:</p>
<pre><code>class Package

def initialize(name)
    @name = name
    @elements = []
end

[:type, :block].each do |bindtype|
    define_method "get_#{bindtype}_by_name" do |name|
        get_by_name(name, bindtype)
    end
end

def get_by_name(name, bindtype=nil)
    @elements.each do |element|
        return if element.name == name
    end
    return nil
end
</code></pre>
<p>I've read this question <a href="https://stackoverflow.com/questions/5449244/pythons-equivalent-for-rubys-define-method">about define_method in python</a> and I wanted to implement the same thing in Python with my Ruby code:</p>
<pre><code>bindtypes = {"type", "block"}

class Package:

    def __init__(self, name):
        self.name = name
        self.elements = list()

    def get_by_name(self, name, bindtype=None):
        for element in self.elements:
            if element.name == name:
                return element
        return None

for bindtype in bindtypes:
    def _in_bindtype(self, bindtype, bindtype):
        Package.get_by_name(bindtype, bindtype)
    setattr(Package, "get_"+bindtype+"_by_name", _in_bindtype
</code></pre>
<p>I call the function like this:</p>
<pre><code>package = Package("package")    
block = Block("blockName")
package.elements.append(block)
blockFound = package.get_block_by_name(block.name, block.bindtype)
</code></pre>
<p>But obviously this doesn't work because I don't recover the name of the element that I'm searching. Can someone help me understand better how this python define_method works with my code?</p>
</div>
<div class="post-text" itemprop="text">
<p>You were almost there; bind the <code>bindtype</code> value as a default value for the function argument, and you want to call <code>get_by_name()</code> on <code>self</code>:</p>
<pre><code>for bindtype in bindtypes:
    def _in_bindtype(self, name, bindtype=bindtype):
        self.get_by_name(name, bindtype)
    setattr(Package, "get_{}_by_name".format(bindtype), _in_bindtype)
</code></pre>
<p>I took the liberty of using <code>str.format()</code> to format the method name rather than use <code>+</code> concatenation, it is more readable I find.</p>
<p>Alternatively, in Python 3 you could just create <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow"><code>functools.partialmethod()</code> objects</a>:</p>
<pre><code>from functools import partialmethod

for bindtype in bindtypes:
    setattr(Package, "get_{}_by_name".format(bindtype),
            partialmethod(Package.get_by_name, bindtype=bindtype))
</code></pre>
</div>
<span class="comment-copy">Instead of using <code>list()</code> to create an empty list object, use <code>[]</code>. See <a href="https://stackoverflow.com/q/30216000">Why is [] faster than list()?</a></span>
<span class="comment-copy">Thanks for your time! I think I have explained poorly my problem. I call my function like this for example <code>get_block_by_name("BlockName", "block")</code>, so my parameters are different. I wrote <code>bindtype</code>everywhere because I didn't know have to retrieve the name "BlockName". Do you know how to retrieve the name?</span>
<span class="comment-copy">@user3314570: yes, you are explaining it poorly, I fear. Perhaps you can update your question with an example of how you expect things to work? Give us input and expected output. But given the Ruby code you wrote and the question you linked to, my answer covers what you asked exactly.</span>
<span class="comment-copy">I found my problem. I juste had to replace <code>def _in_bindtype(self, bindtype, bindtype=bindtype):</code>and <code>self.get_by_name(bindtype, bindtype)</code> by <code>def _in_bindtype(self, name, bindtype=bindtype):</code>and <code>self.get_by_name(name, bindtype)</code>. Your response helped me understand how it works. Thanks!</span>
<span class="comment-copy">Ah yes, I should have spotted that. I also cleaned up the <code>partialmethod</code> case as I had left a copy-and-paste error in there.</span>
