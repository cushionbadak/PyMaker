<div class="post-text" itemprop="text">
<p>If one would like to run an algorithm on an arbitrary interchangeable data source, it's a good idea to use iterators:</p>
<pre><code>def do_something(iter):
    for x in iter:
        print(x)

l = list([1, 2, 3])
do_something(iter(l))
</code></pre>
<p>In the given example, the iterator is a <em>source</em>. But how would it look, if I would like to use the iterator as a <em>target</em>? Something like:</p>
<pre><code>def do_something(iter, target):
    for x in iter:
        # if x is prime, insert it into target

l = list([1, 2, 3])
primes = ... # something that will be able to take the primes
do_something(iter(l), primes)
</code></pre>
<p>I could just use <code>list</code>'s <code>append</code>, but that would not work if the target iterator would not be a list, but some different iterator.</p>
<p>In that example, the target iterator is not even allocated. I also wonder how I could/should preallocate and how it would look using <code>nditer</code> and NumPy.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, just a terminology note: an iterator is a read-only construct; it's an object that has a <code>next</code> method. So <code>target</code> is not an iterator, but something else.</p>
<p>What you want is something that is guaranteed to have an <code>append</code> method, which is any class that inherits from <code>collections.MutableSequence</code>. <code>list</code> is just one such class, albeit (the only?) one that is part of the standard library.</p>
<p>Python being the dynamically typed language it is, it is not <em>required</em> that <code>target</code> be an instance of a type that inherits from <code>MutableSequence</code>. It is a <em>sufficient</em> condition (such an object will work), but it is not a <em>necessary</em> condition (an object can have a suitable <code>append</code> method without actually inheriting from <code>MutableSequence</code>).</p>
<p>So the short answer is: go ahead and use <code>append</code>. Just be sure to <em>document</em> that the <code>target</code> argument must support <code>append</code>, and let your users decide what to use.</p>
</div>
<div class="post-text" itemprop="text">
<p>One option would be to use a generator and use the <code>.send</code> method to return values to the <code>yield</code> statement:</p>
<pre><code>def is_prime(n): #for this demo
    return not any(n%i==0 for i in range(2,n))

def do_something(iter, target):
    for x in iter:
        if is_prime(x):
            target.send(x)

def show_results(message):
    while True:
        x = yield
        print(message, x)

l = range(10)
primes = show_results("this is a prime number:")
next(primes) #need to do this before sending values to a generator
do_something(iter(l), primes)
</code></pre>
<p>Although you could also just pass a callable as the Target, that way you can either pass <code>generator.send</code> or <code>list.append</code> as the <code>target</code>, or any other function that does something with a single value:</p>
<pre><code>def do_something(iter, process_func):
    for x in iter:
        if is_prime(x):
            process_func(x)

l = range(10)
primes = show_results("this is a prime number:")
next(primes) #need to do this before sending values to a generator
do_something(iter(l), primes.send)

#or

primes = []
do_something(iter(l), primes.append)
print(primes)
</code></pre>
</div>
<span class="comment-copy">Are you talking about coroutines? <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncio-task.html</a> <a href="http://book.pythontips.com/en/latest/coroutines.html" rel="nofollow noreferrer">book.pythontips.com/en/latest/coroutines.html</a></span>
<span class="comment-copy"><code>geneator.send(x)</code>?</span>
<span class="comment-copy">unless you are talking about <code>do_something</code> generating values itself, in which case you would probably want just <code>yield x</code> so that it is an iterator itself.</span>
<span class="comment-copy">Unlike C++, Python doesn't have output iterators.</span>
<span class="comment-copy">I removed the <code>numpy</code> tag since the core of the question isn't about that.  If you want to focus on <code>np.nditer</code>, do so in a new question.  It has nothing to do with regular Python iteration or generators.  <a href="http://docs.scipy.org/doc/numpy/reference/arrays.nditer.html#iterator-allocated-output-arrays" rel="nofollow noreferrer">docs.scipy.org/doc/numpy/reference/â€¦</a></span>
