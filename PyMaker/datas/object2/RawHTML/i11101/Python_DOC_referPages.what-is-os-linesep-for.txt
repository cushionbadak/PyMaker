<div class="post-text" itemprop="text">
<p>Python's os module contains a value for a platform specific line separating string, but the docs explicitly say not to use it when writing to a file:</p>
<blockquote>
<p>Do not use os.linesep as a line terminator when writing files opened in text mode (the default); use a single '\n' instead, on all platforms.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/os.html#os.linesep" rel="noreferrer">Docs</a></p>
<p><a href="https://stackoverflow.com/questions/21636213/why-you-shouldnt-use-os-linesep-when-editing-on-text-mode">Previous questions</a> have explored why you <em>shouldn't</em> use it in this context, but then what context is it useful for? When should you use the line separator, and for what?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>the docs explicitly say not to use it when writing to a file</p>
</blockquote>
<p>This is not exact, the doc says not to used it in <strong>text</strong> mode.</p>
<p>The <code>os.linesep</code> is used when you want to iterate through the lines of a text file. The internal scanner recognise the <code>os.linesep</code> and replace it by a single "\n".</p>
<p>For illustration, we write a binary file which contains 3 lines separated by "\r\n" (Windows delimiter):</p>
<pre><code>import io

filename = "text.txt"

content = b'line1\r\nline2\r\nline3'
with io.open(filename, mode="wb") as fd:
    fd.write(content)
</code></pre>
<p>The content of the binary file is:</p>
<pre><code>with io.open(filename, mode="rb") as fd:
    for line in fd:
        print(repr(line))
</code></pre>
<p><em>NB: I used the "rb" mode to read the file as a binary file.</em></p>
<p>I get:</p>
<pre><code>b'line1\r\n'
b'line2\r\n'
b'line3'
</code></pre>
<p>If I read the content of the file using the text mode, like this:</p>
<pre><code>with io.open(filename, mode="r", encoding="ascii") as fd:
    for line in fd:
        print(repr(line))
</code></pre>
<p>I get:</p>
<pre><code>'line1\n'
'line2\n'
'line3'
</code></pre>
<p>The delimiter is replaced by "\n".</p>
<p>The <code>os.linesep</code> is also used in write mode: any "\n" character is converted to the system default line separator: "\r\n" on Windows, "\n" on POSIX, etc.</p>
<p>With the <code>io.open</code> function you can force the line separator to whatever you want.</p>
<p>Example: how to write a Windows text file:</p>
<pre><code>with io.open(filename, mode="w", encoding="ascii", newline="\r\n") as fd:
    fd.write("one\ntwo\nthree\n")
</code></pre>
<p>If you read this file in text mode like this:</p>
<pre><code>with io.open(filename, mode="rb") as fd:
    content = fd.read()
    print(repr(content))
</code></pre>
<p>You get:</p>
<pre><code>b'one\r\ntwo\r\nthree\r\n'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you know, reading and writing files in text mode in python converts the platform specific line separator to '\n' and vice versa. But if you would read a file in binary mode, no conversion takes place. Then you can explicitly convert the line endings using <code>string.replace(os.linesep, '\n')</code>. This can be useful if a file (or stream or whatever) contains a combination of binary and text data.</p>
</div>
<span class="comment-copy">It wouldn't work if encoding is ascii incompatible. <code>len('\n'.encode('utf-16'))</code> is 4</span>
