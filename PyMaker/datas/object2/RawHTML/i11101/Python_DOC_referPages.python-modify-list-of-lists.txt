<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/19339/transpose-unzip-function-inverse-of-zip">Transpose/Unzip Function (inverse of zip)?</a>
<span class="question-originals-answer-count">
                    12 answers
                </span>
</li>
</ul>
</div>
<p>Given the following list of lists:</p>
<pre><code>iters=[['EY11', 'EY12', 'EY13', 'EY14'],
       ['EY21', 'EY22', 'EY23', 'EY24'],
       ['PY11', 'PY12', 'PY13', 'PY14'],
       ['PY21', 'PY22', 'PY23', 'PY24']]
</code></pre>
<p>I'd like to modify this list to transpose the values (for lack of a better description) like this:</p>
<pre><code>iters=[['EY11', 'EY21', 'PY11', 'PY21'],
       ['EY12', 'EY22', 'PY12', 'PY22'],
       ['EY13', 'EY23', 'PY13', 'PY23'],
       ['EY14', 'EY24', 'PY14', 'PY24']]
</code></pre>
<p>I can do this with one sub-list at a time like this:</p>
<pre><code>[i[0] for i in iters]
</code></pre>
<p>but now I just need to know how to iterate through each sub-list and automatically make the new list of lists (also, I can't predict how many sub-lists there will be in my actual data, so I'd like to avoid hard-coding the current number of sub-lists in i[0].</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Most concise solution is to use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">the <code>zip</code> function</a> with star unpacking:</p>
<pre><code>newiters = list(zip(*iters))  # Wrapping in list not needed on Python 2
</code></pre>
<p>This will get almost what you want, but not quite, because it will be a <code>list</code> of <code>tuple</code>s; if that's okay, you're done, if not, you just tweak it to convert to <code>list</code>s:</p>
<pre><code>newiters = list(map(list, zip(*iters)))  # Wrapping in list not needed on Python 2
</code></pre>
<p>Reason this works is that star unpacking makes it as if you passed each element of <code>iters</code> as a sequential positional argument to <code>zip</code>, e.g.:</p>
<pre><code>zip(['EY11', 'EY12', 'EY13', 'EY14'],
    ['EY21', 'EY22', 'EY23', 'EY24'],
    ['PY11', 'PY12', 'PY13', 'PY14'],
    ['PY21', 'PY22', 'PY23', 'PY24'])
</code></pre>
<p>And <code>zip</code>'s whole schtick is making new <code>tuple</code>s of values from matching offsets in a set of iterables, so the first <code>tuple</code> is the first element of each argument (<code>('EY11', 'EY21', 'PY11', 'PY21')</code>), the second is the second element of each argument (<code>('EY12', 'EY22', 'PY12', 'PY22')</code>), etc.</p>
<p>Note: This assumes all sub-<code>list</code>s are the same length. You'll lose data if they aren't, because <code>zip</code> stops when the shortest iterable is exhausted. You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow"><code>itertools.zip_longest</code></a> to pad out shorter iterables to the length of the longest iterable if you like.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do you mean something like this:</p>
<pre><code>iters=[['EY11', 'EY12', 'EY13', 'EY14'],
       ['EY21', 'EY22', 'EY23', 'EY24'],
       ['PY11', 'PY12', 'PY13', 'PY14'],
       ['PY21', 'PY22', 'PY23', 'PY24']]


def iterating(iters):
    if len(iters) &gt; 0:
        range_len = len(iters[0]) 
        ret = []
        for idx in range(0,range_len):
            ret.append([i[idx] for i in iters])
        return ret
    return None

if __name__ == '__main__':
    print iterating(iters)
</code></pre>
<p>will output to:</p>
<pre><code>[['EY11', 'EY21', 'PY11', 'PY21'], ['EY12', 'EY22', 'PY12', 'PY22'], ['EY13', 'EY23', 'PY13', 'PY23'], ['EY14', 'EY24', 'PY14', 'PY24']]
</code></pre>
<p>The function is not fixed size but id does assume that all the lists within the list are the same size.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one liner using list comprehension.</p>
<pre><code>transp = [[i[x] for i in iters] for x in range(0,4)]
</code></pre>
<p>Basically what you did except iterates through the indexes.</p>
<pre><code>#Output
['EY11', 'EY21', 'PY11', 'PY21']
['EY12', 'EY22', 'PY12', 'PY22']
['EY13', 'EY23', 'PY13', 'PY23']
['EY14', 'EY24', 'PY14', 'PY24']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If this is the only complex operation you need to perform on the array, then one of the other solutions is probably best.  However, if you don't mind bringing in numpy, then there is a built-in routine for this called <code>transpose</code>.</p>
<pre><code>import numpy as np
iters_np = np.array(iters).transpose()
print(iters_np)

&gt;&gt;&gt;[['EY11' 'EY21' 'PY11' 'PY21']
&gt;&gt;&gt; ['EY12' 'EY22' 'PY12' 'PY22']
&gt;&gt;&gt; ['EY13' 'EY23' 'PY13' 'PY23']
&gt;&gt;&gt; ['EY14' 'EY24' 'PY14' 'PY24']]
</code></pre>
</div>
<span class="comment-copy">This is great! I thought there should be an operation that handles such things. Thanks!</span>
