<div class="post-text" itemprop="text">
<p>I would like to intercept the function calls happening inside a function. This is aimed at producing a "mocking" sort of an effect on function calls inside a function.</p>
<p>For example:</p>
<pre><code>def calls_add(a,b):
    print "this function calls add"
    c = add(a,b)
    print "call to add returned",c
</code></pre>
<p>I would like to add a decorator on top of call_add to intercept calls to the function add and call some other function instead (with the same arguments being passed to add)</p>
<p>Something like this:</p>
<pre><code>def some_other_func(*args,**kwargs):
    return "test value"

@mock(add,some_other_func)
def calls_add(a,b):
    print "this function calls add"
    c = add(a,b)
    print "call to add returned",c
</code></pre>
<p>Is there a way to do this without having to touch the code of calls_add. I was looking at the inspect library but need help.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are looking for <code>unittest.mock.patch</code>:</p>
<blockquote>
<p>patch() acts as a function decorator, class decorator or a context manager. Inside the body of the function or with statement, the target is patched with a new object. When the function/with statement exits the patch is undone.</p>
</blockquote>
<p>From the API <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow">here</a> and documentation <a href="https://docs.python.org/3/library/unittest.mock-examples.html#patch-decorators" rel="nofollow">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You have to use <a href="http://www.voidspace.org.uk/python/mock/patch.html#patch" rel="nofollow"><code>mock.patch</code></a>. You have the following two posiblities:</p>
<ol>
<li><p>If you want to use a decorator:</p>
<pre><code>import mock


def some_other_func(*args, **kwargs):
    return "test value"


def add(a, b): 
    return a + b 


@mock.patch("__main__.add", some_other_func)
def calls_add(a, b): 
    print "this function calls add"
    c = add(a, b)
    print "call to add returned", c


calls_add(1, 2)
</code></pre></li>
<li><p>If you do not want to use a decorator:</p>
<pre><code>import mock


def some_other_func(*args, **kwargs):
    return "test value"


def add(a, b): 
    return a + b 


def calls_add(a, b): 
    print "this function calls add"
    c = add(a, b)
    print "call to add returned", c


calls_add(1, 2)

with mock.patch("__main__.add", some_other_func):
    calls_add(1, 2)
</code></pre></li>
</ol>
</div>
