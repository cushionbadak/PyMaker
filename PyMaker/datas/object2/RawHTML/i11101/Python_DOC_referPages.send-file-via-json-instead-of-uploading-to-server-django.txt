<div class="post-text" itemprop="text">
<p>I have an app that currently allows a user to upload a file and it saves the file on the web server. My client has now decided to use a third party cloud hosting service for their file storage needs. The company has their own API for doing CRUD operations on their server, so I wrote a script to test their API and it sends a file as a base64 encoded JSON payload to the API. The script works fine but now I'm stuck on how exactly how I should implement this functionality into Django.</p>
<p>json_testing.py</p>
<pre><code>import base64
import json
import requests
import magic

filename = 'test.txt'

# Open file and read file and encode it as a base64 string
with open(filename, "rb") as test_file:
    encoded_string = base64.b64encode(test_file.read())

# Get MIME type using magic module
mime = magic.Magic(mime=True)
mime_type = mime.from_file(filename)

# Concatenate MIME type and encoded string with string data
# Use .decode() on byte data for mime_type and encoded string
file_string = 'data:%s;base64,%s' % (mime_type.decode(), encoded_string.decode())
payload = {
    "client_id": 1,
    "file": file_string
}
headers = {
    "token": "AuthTokenGoesHere",
    "content-type": "application/json",
}
request = requests.post('https://api.website.com/api/files/', json=payload, headers=headers)
print(request.json())
</code></pre>
<p>models.py</p>
<pre><code>def upload_location(instance, filename):
    return '%s/documents/%s' % (instance.user.username, filename)

class Document(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
    file = models.FileField(upload_to=upload_location)

    def __str__(self):
        return self.filename()

    def filename(self):
        return os.path.basename(self.file.name)
</code></pre>
<p>So to reiterate, when a user uploads a file, instead of storing the file somewhere on the web server, I want to base64 encode the file so I can send the file as a JSON payload. Any ideas on what would be the best way to approach this? </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The simplest way I can put this is that I want to avoid saving the
  file to the web server entirely. I just want to encode the file, send
  it as a payload, and discard it, if that's possible.</p>
</blockquote>
<p>From the <a href="https://docs.djangoproject.com/en/1.9/topics/http/file-uploads/#upload-handlers" rel="nofollow">django docs</a>:</p>
<blockquote>
<p>Upload Handlers</p>
<p>When a user uploads a file, Django passes off the file data to an
  upload handler – a small class that handles file data as it gets
  uploaded. Upload handlers are initially defined in the
  FILE_UPLOAD_HANDLERS setting, which defaults to:</p>
<p>["django.core.files.uploadhandler.MemoryFileUploadHandler", 
  "django.core.files.uploadhandler.TemporaryFileUploadHandler"]   </p>
<p>Together
  MemoryFileUploadHandler and TemporaryFileUploadHandler provide
  Django’s default file upload behavior of reading small files into
  memory and large ones onto disk.</p>
<p><strong><em>You can write custom handlers that customize how Django handles files</em></strong>.
  You could, for example, use custom handlers to enforce user-level
  quotas, compress data on the fly, render progress bars, <strong><em>and even send
  data to another storage location directly without storing it locally</em></strong>.
  <a href="https://docs.djangoproject.com/en/1.9/ref/files/uploads/#writing-custom-upload-handlers" rel="nofollow">See Writing custom upload handlers</a> for details on how you can
  customize or completely replace upload behavior.</p>
</blockquote>
<p><strong><em>Contrary thoughts:</em></strong></p>
<p>I think you should consider sticking with the default file upload handlers because they keep someone from uploading a file that will overwhelm the server's memory.</p>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/1.9/topics/http/file-uploads/#where-uploaded-data-is-stored" rel="nofollow">Where uploaded data is stored</a></p>
<p>Before you save uploaded files, the data needs to be stored somewhere.</p>
<p>By default, if an uploaded file is smaller than 2.5 megabytes, Django
  will hold the entire contents of the upload in memory. This means that
  saving the file involves only a read from memory and a write to disk
  and thus is very fast.</p>
<p>However, if an uploaded file is too large, Django will write the
  uploaded file to a temporary file stored in your system’s temporary
  directory. On a Unix-like platform this means you can expect Django to
  generate a file called something like /tmp/tmpzfp6I6.upload. If an
  upload is large enough, you can watch this file grow in size as Django
  streams the data onto disk.</p>
<p>These specifics – 2.5 megabytes; /tmp; etc. – are simply “reasonable
  defaults” which can be customized as described in the next section.  </p>
</blockquote>
<hr/>
<p><a href="https://docs.djangoproject.com/en/1.9/topics/http/file-uploads/#basic-file-uploads" rel="nofollow">request.FILES info</a>:</p>
<blockquote>
<pre><code>#forms.py:

from django import forms

class UploadFileForm(forms.Form):
    title = forms.CharField(max_length=50)
    json_file = forms.FileField()
</code></pre>
<p>A view handling this form will receive the file data in request.FILES,
  which is a dictionary containing a key for each FileField (or
  ImageField, or other FileField subclass) in the form. So the data from
  the above form would be accessible as request.FILES[‘json_file’].</p>
<p>Note that request.FILES will only contain data if the request method
  was POST and the <code>&lt;form&gt;</code> that posted the request has the attribute
  <code>enctype="multipart/form-data"</code>. Otherwise, request.FILES will be empty.</p>
</blockquote>
<hr/>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest.FILES" rel="nofollow">HttpRequest.FILES</a></p>
<p>A dictionary-like object containing all uploaded files. Each key in
  FILES is the name from the <code>&lt;input type="file" name="" /&gt;</code>. Each value
  in FILES is an UploadedFile.</p>
</blockquote>
<hr/>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/1.9/topics/http/file-uploads/#upload-handlers" rel="nofollow">Upload Handlers</a></p>
<p>When a user uploads a file, Django passes off the file data to an
  upload handler – a small class that handles file data as it gets
  uploaded. Upload handlers are initially defined in the
  FILE_UPLOAD_HANDLERS setting, which defaults to:</p>
<p>["django.core.files.uploadhandler.MemoryFileUploadHandler", 
  "django.core.files.uploadhandler.TemporaryFileUploadHandler"]</p>
</blockquote>
<p>The <a href="https://docs.djangoproject.com/en/1.9/_modules/django/core/files/uploadhandler/#FileUploadHandler" rel="nofollow">source code</a> for <code>TemporaryFileUploadHandler</code> contains this:</p>
<pre><code>lass TemporaryFileUploadHandler(FileUploadHandler):
    """
    Upload handler that streams data into a temporary file.
    """
      ...
      ...
      def new_file(self, *args, **kwargs):
        """
        Create the file object to append to as data is coming in.
        """
        ...
        self.file = TemporaryUploadedFile(....)  #&lt;***HERE
</code></pre>
<p>And the <a href="https://docs.djangoproject.com/en/1.9/_modules/django/core/files/uploadedfile/#TemporaryUploadedFile" rel="nofollow">source code</a> for <code>TemporaryUploadedFile</code> contains this:</p>
<pre><code>class TemporaryUploadedFile(UploadedFile):
    """
    A file uploaded to a temporary location (i.e. stream-to-disk).
    """
    def __init__(self, name, content_type, size, charset, content_type_extra=None):
        ...
        file = tempfile.NamedTemporaryFile(suffix='.upload')  #&lt;***HERE
</code></pre>
<p>And the python <a href="https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile" rel="nofollow">tempfile docs</a> say this:</p>
<blockquote>
<p><strong>tempfile.NamedTemporaryFile</strong>(...., delete=True)<br/>
  ...<br/>
  If delete is true (the default), the file is deleted as soon as it is closed.</p>
</blockquote>
<p>Similarly, the other of the two default file upload handlers, <code>MemoryFileUploadHandler</code>, creates a file of type <a href="https://docs.python.org/3/library/io.html#io.BytesIO" rel="nofollow">BytesIO</a>:</p>
<blockquote>
<p>A stream implementation using an in-memory bytes buffer. It inherits
  BufferedIOBase. The buffer is discarded when the close() method is
  called.</p>
</blockquote>
<p>Therefore, all you have to do is close <code>request.FILES[“field_name”]</code> to erase the file (whether the file contents are stored in memory or on disk in the /tmp file directory), e.g.:</p>
<pre><code> uploaded_file = request.FILES[“json_file”]
 file_contents = uploaded_file.read()

 #Send file_contents to other server here.

 uploaded_file.close()  #erases file
</code></pre>
<p>If for some reason you don't want django to write to the server's <code>/tmp</code> directory at all, then you'll need to write a custom file upload handler to reject uploaded files that are too large.</p>
</div>
<span class="comment-copy">I'm not sure I understand. You already know how to do an appropriate request, where's the problem?</span>
<span class="comment-copy">@freakish. Instead of physically saving the file on the web server, I just want to encode the file, send it as a payload, and then discard the file. Do I have to upload the file, then do the encoding, then send it as a JSON payload, then delete the file? I was wondering if there was some way I could encode the file in memory without having to save it to the web server</span>
<span class="comment-copy">just call u're script from the django app instead of what u used to do, i do not get it ....</span>
<span class="comment-copy">@OhadtheLad. The simplest way I can put this is that I want to avoid saving the file to the web server entirely. I just want to encode the file, send it as a payload, and discard it, if that's possible. I was just wondering if there was another way of doing this than uploading the file, saving it to the web server, then encoding it, then sending the payload, then deleting the file.</span>
<span class="comment-copy">@nastyn8 You don't have to save the file onto hard drive as long as it fits in memory (but I assume that these files are small since you are using base64 encoding which is very inefficient). Actually it's pretty much the same procedure, except you change the underlying storage. Are you saying you don't know how to do that? Is that the question?</span>
<span class="comment-copy">@nastyn8, I thought about this some more, and the default file upload handlers are well thought out, so there is no need to create a custom upload handler to do what you want.  See additional explanation at the bottom of my answer.</span>
