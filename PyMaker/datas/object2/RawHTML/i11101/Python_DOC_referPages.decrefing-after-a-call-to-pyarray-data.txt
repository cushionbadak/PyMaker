<div class="post-text" itemprop="text">
<p>I'm writing a Python extension in C. My function takes a list of Numpy arrays (that contain integers) as a parameter. I go through the list, get each array, increase the reference, get the C pointers to the array and then decrease the reference.</p>
<pre><code>if (!PyArg_ParseTuple(args, "O", &amp;list))
    return NULL;

long nb_arrays = PyList_Size(list);

arrays = (int **) malloc(nb_arrays * sizeof(int *));

for (i = 0; i &lt; nb_arrays; i++)
{
    PyArrayObject *array = (PyArrayObject *) PyList_GetItem(list, i);
    Py_INCREF(array);

    arrays[i] = (int *) PyArray_DATA(array);

    Py_DECREF(array);
}
</code></pre>
<p>After this loop, I'm using the pointers to do my calculations. Is it correct or must I wait for the end of the function to decrease the reference counts?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>PyArray_DATA</code> has no effect on the reference count of the array it is applied to.  Furthermore, when the list that was passed to your function was created, the reference count of each of the arrays in it was increased by one.  So while they don't hurt much, those <code>Py_INCREF</code> and <code>Py_DECREF</code> are completely unnecessary, you can get rid of both of them.</p>
<p>You typically have to <code>Py_INCREF</code> an object when you are going to pass it to a function that steals the reference (i.e. takes ownership of it and assumes the responsibility of decreasing the count when it is done with needing it).</p>
<p>You typically have to <code>Py_DECREF</code> any temporary objects you have created inside a function, that are not part of your returns, and that are not needed by any of the returns.</p>
<p>You rarely (if ever) have to first <code>Py_INCREF</code> something to later <code>Py_DECREF</code> it.  You can probably write some messed up multi-threaded code releasing the GIL that makes this parragraph not true, but in general everything passed to your function was part of a tuple (if a positional argument) or a dictionary (if a keyword argument), so it had its reference count increased when the call was made.  That tuple and dictionary will not be destroyed until your function returns, so it is safe to assume that all items passed to you will not be garbage collected midway through your function, i.e. you are borrowing that reference, hence there is no need to explicitly increase the reference count just to access the objects.</p>
</div>
<span class="comment-copy">Your code is problematic. First you don't actually check that each item in the list is really an array. You need to handle this possibility. Use <a href="http://docs.scipy.org/doc/numpy/reference/c-api.array.html#c.PyArray_Check" rel="nofollow noreferrer">PyArray_Check</a>. Second, you are borrowing a reference to the data in the arrays. If a reference to the data in the arrays persists after the function call then you could have a memory leak.</span>
<span class="comment-copy">You're right about parameter checking, I haven't done it yet in order to focus on memory handling. About the reference to the data, Jaime (see below) says that PyArray_DATA has no effect on reference counting.</span>
<span class="comment-copy">Regarding the second point, if <code>arrays</code> is freed before the function ends, then everything is fine. However, if you save <code>arrays</code> somewhere and then if one of the arrays drops to zero references, then <code>arrays</code> will be left with a pointer to an array that no longer exists.</span>
<span class="comment-copy">Of course, I freed <code>arrays</code> at the end of my function since I allocated it myself. But I didn't modify the original Numpy array.</span>
<span class="comment-copy">Thanks for this interesting explanation. I was confused (and still am) by the example given on <a href="https://docs.python.org/3/extending/extending.html" rel="nofollow noreferrer">link</a> about reference counting. They do call Py_INCREF and then Py_DECREF while they don't actually modify the item passed. The explanation for this looks very unclear to me since they invoke a probable destruction of the item 0 while only the item 1 is erased.</span>
<span class="comment-copy">Yes, I can imagine the <a href="https://docs.python.org/3/extending/extending.html#thin-ice" rel="nofollow noreferrer">Thin Ice</a> section is confusing...  Your code doesn't fall into any of the two examples there listed, so in your case it is safe to remove those calls.</span>
