<div class="post-text" itemprop="text">
<p>I was playing around with Python bytecode with the <a href="https://docs.python.org/3/library/dis.html#module-dis" rel="nofollow"><strong><code>dis</code></strong></a> module when I noticed something about bytecode generated for modules. Given a small test module named <code>mod.py</code>:</p>
<pre><code>if __name__ == "__main__":
    print("Hello World")
</code></pre>
<p>I created a code object for it with the <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow"><strong><code>compile()</code></strong></a> function:</p>
<pre><code>&gt;&gt;&gt; cobj = compile(open("mod.py").read(), "mod", "exec")
</code></pre>
<p>and then, disassembled the code object to view the bytecode:</p>
<pre><code>&gt;&gt;&gt; dis.dis(cobj)
  1           0 LOAD_NAME                0 (__name__)
              3 LOAD_CONST               0 ('__main__')
              6 COMPARE_OP               2 (==)
              9 POP_JUMP_IF_FALSE       22

  2          12 LOAD_NAME                1 (print)
             15 LOAD_CONST               1 ('Hello World')
             18 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
             21 POP_TOP
        &gt;&gt;   22 LOAD_CONST               2 (None)
             25 RETURN_VALUE
</code></pre>
<p>What struck me were the two last commands <a href="https://docs.python.org/3/library/dis.html#opcode-LOAD_CONST" rel="nofollow"><strong><code>LOAD_CONST</code></strong></a> and <a href="https://docs.python.org/3/library/dis.html#opcode-RETURN_VALUE" rel="nofollow"><strong><code>RETURN_VALUE</code></strong></a> which, if my understanding is correct, place the constant <code>None</code> on the <em>value stack</em> and consequently return it.</p>
<p>Do modules implicitly return <code>None</code> and, if so, why?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, in a nutshell, modules do implicitly return <code>None</code> in order for the big evaluation loop inside <strong><a href="https://github.com/python/cpython/blob/master/Python/ceval.c#L1925" rel="nofollow"><code>ceval.c</code></a></strong> to be able detect when to the current frame is finished and terminate. </p>
<p>Interestingly, you can see this even when a python file that is completely empty is interpreted, from a terminal:</p>
<pre><code>jim@lpt&gt; touch file.py
jim@lpt&gt; python -m dis file.py
1           0 LOAD_CONST               0 (None)
            3 RETURN_VALUE    
</code></pre>
<p>This behavior is not limited to modules but, rather, <em><a href="https://docs.python.org/3/reference/executionmodel.html#structure-of-a-program" rel="nofollow">for anything that can form a code block</a></em>; this includes <strong>class definitions</strong>:</p>
<pre><code>&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; co = compile("class mycls: pass", filename = "stdin", mode = "exec")
&gt;&gt;&gt; dis(co.co_consts[0])  # co_consts[0] contains class definition
  1           0 LOAD_NAME                0 (__name__)
              3 STORE_NAME               1 (__module__)
              6 LOAD_CONST               0 ('mycls')
              9 STORE_NAME               2 (__qualname__)
             12 LOAD_CONST               1 (None)
             15 RETURN_VALUE
</code></pre>
<p>and <strong>function bodies</strong>: </p>
<pre><code>&gt;&gt;&gt; def foo(): pass

&gt;&gt;&gt; dis(foo)
  1           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE
</code></pre>
<p>That is, the <code>RETURN_VALUE</code> bytecode command <em><a href="https://github.com/python/cpython/blob/master/Python/ceval.c#L3643" rel="nofollow">terminates the current block that was executing</a></em> and returns (<code>LOAD_CONST</code>) the value on the top of the stack to the callee (if there exists one).</p>
<p>The only caveat is that it is that specifying a custom return value is only allowed for functions, in class definitions and modules a return value doesn't have much of a purpose and as such trying to specify one results in an appropriate <code>SyntaxError</code>.</p>
<hr/>
<p>For the people interested in the source code for this, you can find it by stepping through the functions defined in <strong><a href="https://github.com/python/cpython/blob/master/Python/compile.c" rel="nofollow"><code>compile.c</code></a></strong>, from the documentation in <code>compile.c</code>:</p>
<pre><code> * The primary entry point is PyAST_Compile(), which returns a
 * PyCodeObject.  The compiler makes several passes to build the code
 * object:
 *   1. Checks for future statements.  See future.c
 *   2. Builds a symbol table.  See symtable.c.
 *   3. Generate code for basic blocks.  See compiler_mod() in this file.
 *   4. Assemble the basic blocks into final code.  See assemble() in
 *      this file.
 *   5. Optimize the byte code (peephole optimizations).  See peephole.c
</code></pre>
<p>The relevant steps are <code>3.</code> and <code>4.</code> or <strong><a href="https://github.com/python/cpython/blob/master/Python/compile.c#L1384" rel="nofollow"><code>compiler_mod</code></a></strong> and <strong><a href="https://github.com/python/cpython/blob/master/Python/compile.c#L4939" rel="nofollow"><code>assemble</code></a></strong> functions</p>
</div>
<span class="comment-copy">This is about the code object, not the fact that it is a module.  The bytecode needs to return something so that  <code>exec(cobj)</code> has a return value.</span>
<span class="comment-copy">Modules don't return anything because they don't return. They can be imported, executed directly, or compiled, but that's about all.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen The module is represented by a code object. Final returns inside code objects (for functions, classes or modules) are simply a means to represent termination of the current frame of execution.</span>
