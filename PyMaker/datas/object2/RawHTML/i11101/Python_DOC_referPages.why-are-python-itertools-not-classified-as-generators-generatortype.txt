<div class="post-text" itemprop="text">
<p>I just discovered that the various itertools functions return class types which are not considered generators by the Python type system.</p>
<p>First, the setup:</p>
<pre><code>import collections
import glob  
import itertools
import types

ig = glob.iglob('*')
iz = itertools.izip([1,2], [3,4])
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; isinstance(ig, types.GeneratorType) 
True
&gt;&gt;&gt; isinstance(iz, types.GeneratorType)
False
</code></pre>
<p>The <code>glob.iglob()</code> result, or any other typical generator, is of type <code>types.GeneratorType</code>.  But itertools results are not.  This leads to a great deal of confusion if I want to write a function whose input sequence must be eagerly evaluated--I need to know if it's a generator or not.</p>
<p>I found this alternative:</p>
<pre><code>&gt;&gt;&gt; isinstance(ig, collections.Iterator)
True
&gt;&gt;&gt; isinstance(iz, collections.Iterator)
True
</code></pre>
<p>But it's not ideal, because <code>iter(x)</code> is an <code>Iterator</code> regardless of whether <code>x</code> was a concrete (eagerly evaluated) sequence, or a generator (lazily evaluated).</p>
<p>The end goal is something like this:</p>
<pre><code>def foo(self, sequence):
    """Store the sequence, making sure it is fully
    evaluated before this function returns."""

    if isinstance(sequence, types.GeneratorType):
        self.sequence = list(sequence)
    else:
        self.sequence = sequence
</code></pre>
<p>An example of why I'd want to do this would be if the evaluation of the sequence might raise an exception, and I want that exception to be raised from <code>foo()</code> and not from subsequent use of <code>self.sequence</code>.</p>
<p>I don't like the <code>types.GeneratorType</code> approach because it produces some false positives--I don't want to construct a copy of the input list unnecessarily, as it may be large.</p>
<p>I'm willing to ignore "unusual" iterators, meaning if someone implements a custom one that doesn't qualify as a generator, but I'm not as willing to have the wrong behavior for itertools, because they're rather popular.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Why are Python itertools not classified as generators?</h2>
<p>Think of a <a href="https://docs.python.org/3/glossary.html#term-generator" rel="nofollow noreferrer">generators</a> as being one of many possible ways to implement an <a href="https://docs.python.org/3/glossary.html#term-iterator" rel="nofollow noreferrer">iterator</a>.  The <a href="https://docs.python.org/2.7/library/itertools.html#module-itertools" rel="nofollow noreferrer"><em>itertools</em></a> are all custom iterators written in C.  Most of the could have been been implemented with slower code using generators, but they were designed for speed.</p>
<p>The <a href="https://docs.python.org/2.7/library/types.html#types.GeneratorType" rel="nofollow noreferrer"><em>types.GeneratorType</em></a> is specified to be "The type of generator-iterator objects, produced by calling a generator function."  Since the iterator returned by <a href="https://docs.python.org/2.7/library/glob.html#glob.iglob" rel="nofollow noreferrer"><em>glob.iglob()</em></a> is produced by calling a generator function, it will match the generator type.  However, the iterator returned by <a href="https://docs.python.org/2.7/library/itertools.html#itertools.izip" rel="nofollow noreferrer"><em>itertools.izip()</em></a> is produced by C code, so it will not match the generator type.</p>
<p>In other words, <strong><em>types.GeneratorType</em> isn't useful for recognizing all lazily evaluated iterators</strong>, it is only useful for recognizing actual <a href="https://docs.python.org/3/glossary.html#term-generator-iterator" rel="nofollow noreferrer">generator-iterators</a>.</p>
<h2>How to recognize a fully-evaluated collection?</h2>
<p>It sounds like the goal is to distinguish between "eagerly evaluated" collections (like <em>list</em>, <em>tuple</em>, <em>dict</em>, and <em>set</em>) versus "lazily evaluated" iterators.  Using <a href="https://docs.python.org/2.7/library/collections.html#collections.Iterator" rel="nofollow noreferrer"><em>collections.Iterator</em></a> is likely the way to go:</p>
<pre><code>&gt;&gt;&gt; isinstance([], collections.Iterator)
False
&gt;&gt;&gt; isinstance((), collections.Iterator)
False
&gt;&gt;&gt; isinstance({}, collections.Iterator)
False
&gt;&gt;&gt; isinstance(set(), collections.Iterator)
False

&gt;&gt;&gt; isinstance(iter([]), collections.Iterator)
True
&gt;&gt;&gt; isinstance(iter(()), collections.Iterator)
True
&gt;&gt;&gt; isinstance(iter({}), collections.Iterator)
True
&gt;&gt;&gt; isinstance(iter(set()), collections.Iterator)
True

&gt;&gt;&gt; isinstance(glob.iglob('.'), collections.Iterator)
True
&gt;&gt;&gt; isinstance(itertools.izip('abc', 'def'), collections.Iterator)
True
&gt;&gt;&gt; isinstance((x**2 for x in range(5)), collections.Iterator)
True
</code></pre>
<h2>What if iter() has already been called?</h2>
<p>If you've already called <em>iter()</em> on any of "eager" collections, then it is too late to figure-out the nature of the upstream iterable without resorting to shenanigans such as <code>type(x) in {type(iter(s)) for s in ([], (), {}, set())}</code>.</p>
<h2>End goal</h2>
<p>The stated goal is "store the sequence, making sure it is fully evaluated before this function returns".  The usual way to do this is just <code>list(sequence)</code> with no surrounding checks to see if it is already a list, tuple, deque or some other fully-evaluated sequence.  This may seem wasteful, but the <a href="https://docs.python.org/2.7/library/functions.html#func-list" rel="nofollow noreferrer"><em>list()</em></a> call is very fast (it just copies the object pointers at C-speed).</p>
</div>
<span class="comment-copy">Per <a href="https://docs.python.org/2/library/types.html#types.GeneratorType" rel="nofollow noreferrer">the docs</a> <code>GeneratorType</code> is <i>"The type of generator-iterator objects, <b>produced by calling a generator function</b>."</i> <a href="https://hg.python.org/cpython/file/tip/Lib/glob.py#l22" rel="nofollow noreferrer"><code>iglob</code></a> is, calling <code>_iglob</code> which is a Python function with <code>yield</code>, but <code>izip</code> is implemented in C.</span>
<span class="comment-copy">Took me a while to find the right branch, but: <a href="https://hg.python.org/cpython/file/2.7/Modules/itertoolsmodule.c#l3491" rel="nofollow noreferrer">hg.python.org/cpython/file/2.7/Modules/itertoolsmodule.c#l3491</a></span>
<span class="comment-copy">@jonrsharpe: Thanks for that hg link.  It shows that <code>tp_base</code> for <code>izip_type</code> is null.  I wonder why this is--<code>tp_base</code> was added in Python 2.2, and itertools was added in 2.3, so they could use it but don't.  I'm not sure if it's because the timing didn't work out, or if there's some concrete reason why the itertools types would not want to subclass <code>GeneratorType</code>.</span>
<span class="comment-copy">as a tip you can just check both with <code>isinstance(sequence, (types.GeneratorType, collections.Iterator))</code></span>
