<div class="post-text" itemprop="text">
<p>I often run into a situation where I have a top level function from which I want to be able to modify any of the parameters of multiple subfunctions. I'll express this as the following example:</p>
<pre><code>def plot_data_processing(data_param_1=3, data_param_N=4,
        processing_param_1='a', processing_param_2='b', plotting_param_1='c',
        plotting_param_2=1324):
    data = get_data(data_param_1=data_param_1, data_param_1=data_param_N),
    processed_data = process_data(data, processing_param_1=processing_param_1, processing_param_2=processing_param_2)
    plot_data(processed_data, plotting_param_1=plotting_param_1, plotting_param_2=plotting_param_2)
</code></pre>
<p>Now, this is sort of ugly, because I'm forced to redefine all the defaults for my inner functions, and my parameters are one big mess.  I suppose I could do the following:</p>
<pre><code>def plot_data_processing(data_kwargs, processing_kwargs, plotting_kwargs):
    data = get_data(**data_kwargs),
    processed_data = process_data(data, **processing_kwargs)
    plot_data(processed_data, **plotting_kwargs)

plot_data_processing(dict(data_param_1=3, data_param_N=4), dict(processing_param_1='a', processing_param_2='b'), dict(plotting_param_1='c',plotting_param_2=1324))
</code></pre>
<p>Still, this is not great, because I'm doing this odd practice of passing arguments via a dict, where they only wait for the function to be called to be validated.  Seems like a recipe for bugs and unreadable code.  Also, I have no freedom to swap the functions called internally for different functions with a similar interface.  So I could also go:</p>
<pre><code>def plot_data_processing(data_getter, data_processor, plotter):
    data = data_getter(),
    processed_data = data_processor(data)
    plotter(processed_data)

class DataGetter(object):
    def __init__(self, data_param_1=3, data_param_N=4):
        self.data_param_1 = data_param_1
        self.data_param_N = data_param_N
    def __call__(self):
        # ....
        return data

# ... Also define classes DataProcessor and Plotter

plot_data_processing(DataGetter(data_param_1=3, data_param_N=4), DataProcessor(processing_param_1='a', processing_param_2='b'), Plotter(plotting_param_1='c',plotting_param_2=1324))
</code></pre>
<p>However this also seems to involve unnecessary structure and fluff code (self.x = x and all that).  I can get around that by using partials (or lambdas):</p>
<pre><code>def plot_data_processing(data_getter, data_processor, plotter):
    data = data_getter(),
    processed_data = data_processor(data)
    plotter(processed_data)

# Called like:
plot_data_processing(
    data_getter = partial(get_data, data_param_1=3, data_param_N=4),
    data_processor = partial(process_data, processing_param_1='a', processing_param_2=3),
    plotter = partial(plot, plotting_param_1='c', plotting_param_2=1342),
    )
</code></pre>
<p>But this also seems unsatisfying - because there is no clear "type" of arguments to call the function with - just a partial function which should work when called - makes it more difficult for another programmer who wants to use the function.</p>
<p>So, none of these methods leave me feeling fulfilled or happy.  I guess I like partial, but I'd like some way to declare that a partial function obeys some interface.  </p>
<p>Does anybody know a better way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.5 has a new (optional) type hinting system that might do what you want. It's not checked at run-time by the Python interpreter, but does allow you to make statements about the types of arguments and return function values. A separate static analyzer program like <a href="http://mypy-lang.org/" rel="nofollow"><code>mypy</code></a> can be run on the code to look for typing errors.</p>
<p>For your <code>plot_data_processing</code> function, I think you'd want to declare things something like this:</p>
<pre><code>from typing import Callable, TypeVar

DataType = TypeVar("DataType")
ProcessedDataType = TypeVar("ProcessedDataType") # could be the same as DataType

def plot_data_processing(data_getter: Callable[[], DataType],
                         data_processor: Callable[[DataType], ProcessedDataType],
                         plotter: Callable[[ProcessedDataType], None]) -&gt; None:
    ...
</code></pre>
<p>You might be able to get away with only one <code>DataType</code> rather than two if the <code>data_processer</code> function returns the same the processed data using the same type as the original data. You could also specify those types more specifically (e.g. with <code>Sequence[float]</code> or whatever, rather than using a <code>TypeVar</code>) if you didn't need a generic approach.</p>
<p>See <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow">PEP 484</a> and documentation <a href="https://docs.python.org/3/library/typing.html" rel="nofollow">the <code>typing</code> module</a> for more details.</p>
</div>
<span class="comment-copy">What do you mean <i>"declare that a partial function obeys some interface"</i>?</span>
<span class="comment-copy">For example, my "data_getter" function should take no arguments and return some kind of data object.  My "data_processor" should take some kind of data object and return a processed data object.  I want the functions that are passed in to obey these interfaces, and to be able to assert that they do before calling them.  You can do this with classes (assert isinstance(data_getter, DataGetter)), but I'm looking for an equivalent when the data_getter object is a partial function, and the DataGetter interface specifies a function's i/o - rather than the methods for a class.</span>
<span class="comment-copy">That's not really a thing you do in Python at all. Generally we stick to duck-typing: if you pass in something that has the appropriate interface everything works, if not you get a <code>TypeError</code> (or other exception). There is no difference between functions and methods on this.</span>
<span class="comment-copy">Just use the partials (or, if they're going to be in-lined like that, <code>lambda</code>).</span>
<span class="comment-copy">Or use a different language?</span>
