<div class="post-text" itemprop="text">
<p>Alright here is the bit in question.</p>
<pre><code>if any(char in word for char in ["a", "ā", "e", "ē", "i", "ī", "u", "ū", "o", "ai", "ei", "ui"]):
for ch in ["a", "ā", "e", "ē", "i", "ī", "u", "ū", "o", "ai", "ei", "ui"]:
    if ch in word:
       word = word.replace(ch, ch + "p" + ch)
</code></pre>
<p>This might seem a bit weird but its for a translator for Latvian umm.. slang.
    I know finding the vowels could probably be done much more efficiently but my problem is that i want it to not take, for example, the "i" in "ei" if the ei is there. right now it takes for example <em>"aiza"</em> and gives <em>"apaipaipizapa"</em> instead of the preferred <em>"aipaizapa"</em>. Hope this hasn't been asked too many times, English is not my native so i didn't know how to formulate an effective search term.
    Thank you in advance.</p>
<p>EDIT: I am afraid i worded my issue quite poorly. what i need is 
So, here is an <strong>example</strong>.</p>
<pre><code>list = ["a", "b", "ay", "by"] 
state = input("Type a, b, ay or by")
for char in list
    if char in state
        state = state.replace(char, k)
print state
</code></pre>
<p>So now, if the input is <strong>by</strong> or <strong>ay</strong> it will give <strong>kk</strong> but I need it to give out a single <strong>k</strong>. How do i achieve Python 3 ignoring the smaller value if it is a part of the bigger one?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can join those characters to a regular expression using <code>|</code>. Make sure to sort the multi-char parts first, so they are preferred in the match (i.e. it matches <code>ai</code> instead of <code>a</code> and then <code>i</code>). Then use <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a> with a callback function:</p>
<pre><code>&gt;&gt;&gt; chars = ["a", "ā", "e", "ē", "i", "ī", "u", "ū", "o", "ai", "ei", "ui"] 
&gt;&gt;&gt; s = "aiza"
&gt;&gt;&gt; p = "|".join(sorted(chars, key=len, reverse=True))
&gt;&gt;&gt; print(p)
ā|ē|ī|ū|ai|ei|ui|a|e|i|u|o
&gt;&gt;&gt; re.sub(p, lambda m: "{0}p{0}".format(m.group()), s)
'aipaizapa'
</code></pre>
<p>Regular expression matches are non-overlapping, and since it replaces all the characters at once, and one one after the other, characters that are part of other characters will not be a problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is not python3, but from what I understood from your second example, try this:</p>
<pre><code>list1 = ["a", "b", "ay", "by"] 
state = input("Type a, b, ay or by: ")

for char in state:
    if char in list1:
        print("k")
        break
</code></pre>
</div>
<span class="comment-copy">yeah but when i replace the long ones and it runs through the small ones it still finds them in the new "eipei"s or whatever. i need a way to say do not replace if the i is inside ei.</span>
<span class="comment-copy">@jonrsharpe could you break that bit of code down a bit so its a bit more understandable? I'm sorry but i am a bit of a newbie at coding, especially python.</span>
<span class="comment-copy">I think I understood what you wanted. Regex will take care of that, as two "matches" within a string will not overlap, and all the characters are replaced in one go, so it can not happen that the "result" of one replacement is replaced again.</span>
