<div class="post-text" itemprop="text">
<p>Here is a simple example of <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow">descriptor</a> usage in Python:</p>
<pre><code>class MyDescriptor(object):
  def __get__(self, obj, objtype):
    return 42

class MyClass(object):
  d = MyDescriptor()

print MyClass().d  # 42
</code></pre>
<p>But what if I want a descriptor object to be an <em>actual</em> attribute of the class, so <code>MyClass().d</code> would be <code>MyDescriptor</code> instance, not 42.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are many ways to get what you want, depending on what exactly it is that you want.</p>
<p>If all you want is to access the descriptor object (i.e., you don't care whether it is actually stored directly as an attribute on the class), then just store it in a list or something:</p>
<pre><code>class Foo(object):
    descriptor = [MyDescriptor()]
</code></pre>
<p>This will require an extra level of indirection to access it, but in practice that's likely less work than the alternatives.</p>
<p>As described in <a href="https://docs.python.org/2/howto/descriptor.html#invoking-descriptors" rel="nofollow">the documentation</a> the descriptor is activated via <code>object.__getattribute__</code>.  So if you really wanted it to be an attribute, you could override <code>__getattribute__</code> on the class containing the descriptor (<code>MyClass</code>) and thus block the descriptor mechanism from taking effect:</p>
<pre><code>class MyClass(object):
  d = MyDescriptor()

  def __getattribute__(self, attr):
    if attr=='d':
        return self.__class__.__dict__['d']
    else:
        return super(MyClass, self).__getattribute__(attr)

&gt;&gt;&gt; MyClass().d
&lt;__main__.MyDescriptor object at 0x0000000002843E80&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <a href="https://docs.python.org/3/library/inspect.html?highlight=inspect#inspect.getattr_static" rel="nofollow"><code>inspect.getattr_static</code></a></p>
<blockquote>
<p>getattr_static() <strong>does not resolve descriptors</strong>, for example slot
  descriptors or getset descriptors on objects implemented in C. The
  <strong>descriptor object is returned instead</strong> of the underlying attribute.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; inspect.getattr_static(MyClass, 'd')
&lt;__main__.MyDescriptor object at 0x105678c18&gt;
&gt;&gt;&gt; inspect.getattr_static(MyClass(),"d")
&lt;__main__.MyDescriptor object at 0x105678c18&gt;
</code></pre>
<p>If you want to make this the default behaviour for instances you could override <code>__getattribute__</code> to be <code>getattr_static</code>:</p>
<pre><code>class MyClass(object):
  from inspect import getattr_static as __getattribute__
  d = MyDescriptor()

&gt;&gt;&gt; MyClass().d
&lt;__main__.MyDescriptor object at 0x105678c18&gt;
</code></pre>
<p>Quite frankly I don't see why you would want this, it would make more sense to store the descriptor in a data structure that doesn't invoke descriptors like a <code>dict</code>:</p>
<pre><code>descriptors = {"d": MyDescriptor()}
</code></pre>
<p>Then you can look up <code>descriptors["d"]</code> without risk of invoking the descriptor.</p>
</div>
<div class="post-text" itemprop="text">
<p>The simpliest idea I have is to wrap this descriptor into another one. It would work since only one <code>__get__</code> would be called.</p>
<pre><code>class TrivialDescriptor(object):
  def __init__(self, data):
    self._data = data

  def __get__(self, obj, objtype):
    return self._data

class MyDescriptor(object):
  def __get__(self, obj, objtype):
    return 42

class MyClass(object):
  d = TrivialDescriptor(MyDescriptor())
</code></pre>
</div>
<span class="comment-copy">You could make <code>__get__</code> return <code>self</code>.  But why would you want to do that?  The whole purpose of descriptors is to enable this behavior.  If you don't want it, why not just not make the class a descriptor?</span>
<span class="comment-copy">I may want to store descriptors for the future use, by example. And returning <code>self</code> is not an option in that case: I obviously don't want to change descriptor.</span>
<span class="comment-copy">You could always store them in a list or something instead of directly as an attribute.  Also, because only one copy of the descriptor is stored on the class, storing the descriptor itself is often not that useful (since you can likely only use it in one place without causing confusing behavior).  You could instead store the descriptor <i>class</i> and create a new instance when you want to use that kind of descriptor later.</span>
<span class="comment-copy">"Store it in a list" is a kinda answer btw.</span>
<span class="comment-copy">Wow, that's good. The other solution, without “extra level of indirection to access” is what is suggested in the answer: put my descriptor into another trivial descriptor. Could you please add it to your answer (or I'll do it if you are ok with that).</span>
<span class="comment-copy">@VadimPushtaev: Not sure what you mean.  Neither of the solutions in my example involves wrapping your descriptor in another descriptor.</span>
<span class="comment-copy">@VadimPushtaev if you have a solution of your own question feel free to post it as an answer.  It is fine to answer your own question.</span>
<span class="comment-copy">@BrenBarn, sorry, I meant "is what I suggested in the question" :) But nevermind, I'll post it separately.</span>
<span class="comment-copy">That's a real good answer, thanks. Sadly, it's a way to disable <i>all</i> descriptors, not just one of them.</span>
<span class="comment-copy">well not really, the first part is a way to look up descriptors without invoking them (what I thought you wanted) then the second part is to disable all descriptor functionality in a class (not a good idea, breaks all bound methods) which may be useful for a container for descriptors.  I still do not understand what you are trying to accomplish with this anyway.</span>
