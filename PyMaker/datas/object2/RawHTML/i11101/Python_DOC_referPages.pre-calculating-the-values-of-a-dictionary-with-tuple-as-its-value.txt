<div class="post-text" itemprop="text">
<p>I have the following code example where I am creating a dictionary <code>result</code> for each <code>id</code> with a tuple of 2 numbers for its value.</p>
<pre><code># populate the ids list (contents of the current directory which is for a speicif id name)
ids_list = [filename for filename in glob('*' + .txt)

def some_numerical_calc(filename):
    # calculates and returns some number as string
def size_of_file(filename):
    # calculates and returns size number as string

def count_stuff(id, filename):
    result = { id: (some_numerical_calc(filename), size_of_file(filename)) }

for id in ids_list:
    for f in files_list:
        count_stuff(id, f)
</code></pre>
<p>The idea is that I will eventually aggregate all these dictionary key-value pairs under one dictionary (perhaps this parts needs redesigning..).</p>
<p>The problem I am dealing is for cases where the <code>files_list</code> of a specific <code>id</code> is greater than 1; in these cases I would like every 2 numbers inside the tuple for each <code>filename</code> to be added with the previous numbers for that same <code>filename</code>.</p>
<blockquote>
<p>As an <strong>example</strong>,</p>
<p><code>ids_list = ['001', '002', '003']</code> </p>
<p>where for <code>id='001'</code> it has 
  <code>files_list=['file1.txt', 'file2.txt', 'file3.txt']</code></p>
<p>and if </p>
<p><code>some_numerical_calc('file1.txt')</code> gives <code>10</code> and
  <code>size_of_file('file1.txt')</code> gives <code>80</code>,</p>
<p><code>some_numerical_calc('file2.txt')</code> gives <code>150</code> and
  <code>size_of_file('file2.txt')</code> gives <code>35</code>,</p>
<p><code>some_numerical_calc('file3.txt')</code> gives <code>30</code> and
  <code>size_of_file('file3.txt')</code> gives <code>120</code>,</p>
<p><strong>then</strong>, I would expect the output for <code>id='001'</code> to be <code>result = { '001': (190, 235) }</code></p>
</blockquote>
<p>I know that <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow">tuples</a> are immutable. I am struggling to come up with an implementation to pre-compute the 2 numbers for all files for each id and then create its specific dictionary entry. Alternatively, perhaps I should remove the tuples structure -even though I was hoping to use <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow">namedtuples</a> and store the 2 numbers in a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow">set</a> (?). Any suggestions are would be much appreciated.</p>
<p>Hoping for an efficient and pythonic suggestions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Part of the problem is you've organized your code badly.  You're creating your dictionary too early.</p>
<p>Consider if you reorganized it something like this:</p>
<pre><code>def count_stuff(id, filename):
    return (some_numerical_calc(filename), size_of_file(filename))

for id in ids_list:
    nums = 0
    sizes = 0
    for f in files_list:
        num, size = count_stuff(id, f)
        nums += num
        sizes += sizes
    result = { id: (nums, sizes) }
</code></pre>
<p>Now your dictionary is created after you've aggregated your data.</p>
</div>
<div class="post-text" itemprop="text">
<p>To create a tuple that contains sums, you can do something like this*:</p>
<pre><code>result[id] = (sum(some_numerical_calc(filename) for filename in files_list),
              sum(size_of_file(filename) for filename in files_list))
</code></pre>
<p>But just as a heads up, using your current code, this would store the same tuple value in the dict for all of your <code>id</code> keys. You don't currently have any way of associating a particular <code>files_list</code> with a particular <code>id</code>.</p>
<p>*If you only want to iterate once through <code>files_list</code> instead of twice, you can adapt one of the answers from here: <a href="https://stackoverflow.com/questions/497885/python-element-wise-tuple-operations-like-sum">Python element-wise tuple operations like sum</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few things strange about your code, for one, you are creating a new dictionary every time you call count_stuff, but never doing anything with it or return it. From the question it seems like you want everything added to one dictionary.</p>
<p>Something like this might work better:</p>
<pre><code>def some_numerical_calc(filename):
    # calculates and returns some number as string
def size_of_file(filename):
    # calculates and returns size number as string

def count_stuff(id, file_list):
    some_number = 0
    size = 0
    for filename in file_list:
        some_number += some_numerical_calc(filename)
        size += size_of_file(filename)
    return (some_number, size) 

results = {}
for id in ids_list:
    results[id] = count_stuff(id, file_list))
print results
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try mixing map and sum:</p>
<pre><code>resultDict = {}

for id in ids_list:
    resultDict[id] = (sum(map(some_numerical_calc(files_list[id]))), sum(map(size_of_file(files_list[id]))))
</code></pre>
<p>Edit:</p>
<p>A more detailed example given your particular situation. Some parts will be described in comments in angle brackets.</p>
<pre><code>#&lt;Get list of ids as strings&gt;
files_list = {} #Initialize the files dictionary.

for id in ids_list:
    #&lt;Switch to directory based on id&gt;
    files_list[id] = [filename for filename in glob('*' + .txt)]

def some_numerical_calc(filename):
    # calculates and returns some number as string
def size_of_file(filename):
    # calculates and returns size number as string

result_dict = {} #Init results.

for id in ids_list:
    resultDict[id] = (sum(map(some_numerical_calc(files_list[id]))), sum(map(size_of_file(files_list[id]))))
</code></pre>
</div>
<span class="comment-copy">use a list, change the values while you are using it, cast every value to a namedtuple when you are done.  Or alternatively you could use <code>sum(some_numerical_calc(f) for f in file_list), sum(size_of_file(f) for f in file_list)</code> and then use that as the two values in the tuple.</span>
<span class="comment-copy">You are right. Failed to clarify that; I intend to have all dictionary under on dictionary which will hold <code>id</code> as keys and the numbers as values. (modified question to mention this)</span>
<span class="comment-copy">Trying to understand your answer which I find fascinating as an idea. I do not get the <code>files_list[id]</code> part. I mean, what will a list return when provided an index which happens to be the key of an unrelated dictionary? Perhaps  if you could add a working example?</span>
<span class="comment-copy">Your explanation seemed to indicate that the files_list was a two-dimensional data set. That is, each id had its own set of files. So, files list would look something like: <code>files_list = {'001': ['file1.txt', 'file2.txt', 'file3.txt'], '002': ['file4.txt', 'file5.txt'], '003': ['file6.txt']}</code>. So, <code>files_list[id]</code> would yield the list of files associated with the given id.</span>
<span class="comment-copy">Apologies if I did not make clearer; no the <code>files_list</code> is list of filenames for a specific <code>id</code>. Every <code>id</code> has its own <code>files_list</code>. Like the contents of a folder. Do you think this elegant <code>sum</code> &amp; <code>map</code> combo could be implemented now?</span>
<span class="comment-copy">Can you edit your question to include how files_list is populated?</span>
<span class="comment-copy">Your code uses <code>for id in ids_list: for f in files_list:</code> That uses the same <code>files_list</code> variable for every id, so I assumed it was a two-dimensional data set.</span>
