<div class="post-text" itemprop="text">
<p>Is it possible to make a function that returns several elements like this:</p>
<pre><code>def foo():
  return 'b', 'c', 'd'

print ['a', foo(), 'e'] # ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>I tried this but it doesn't work</p>
</div>
<div class="post-text" itemprop="text">
<p>You can insert a sequence into a list with a slice assignment:</p>
<pre><code>bar = ['a', 'e']
bar[1:1] = foo()
print bar
</code></pre>
<p>Note that the slice is essentially empty; <code>bar[1:1]</code> is an empty list between <code>'a'</code> and <code>'e'</code> here.</p>
<p>To do this on one line in Python 2 requires concatenation:</p>
<pre><code>['a'] + list(foo()) + ['e']
</code></pre>
<p>If you were to upgrade to Python 3.5, you can use <code>*</code> unpacking instead:</p>
<pre><code>print(['a', *foo(), 'e'])
</code></pre>
<p>See <a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448" rel="nofollow"><em>Additional Unpacking Generalisations</em></a> in  <em>What's New in Python 3.5</em>. </p>
<p>Demo (using Python 3):</p>
<pre><code>&gt;&gt;&gt; def foo():
...     return 'b', 'c', 'd'
...
&gt;&gt;&gt; bar = ['a', 'e']
&gt;&gt;&gt; bar[1:1] = foo()
&gt;&gt;&gt; bar
['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; ['a'] + list(foo()) + ['e']
['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; ['a', *foo(), 'e']
['a', 'b', 'c', 'd', 'e']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use this simple piece of code:</p>
<pre><code>import itertools

def foo():
  return 'b', 'c', 'd'

l = ['a', foo(), 'e']
x=list(itertools.chain(*l))
print x 
</code></pre>
<blockquote>
<p>Output: ['a', 'b', 'c', 'd', 'e']</p>
</blockquote>
</div>
<span class="comment-copy">You have a list and a tuple here (<code>foo()</code> returns a tuple). Python does have an <code>array</code> module but that's something different again.</span>
<span class="comment-copy">You can do this in Python 3 with tuple unpacking: <code>['a', *foo(), 'e']</code>. Yet another reason to upgrade!</span>
<span class="comment-copy">So there's no way to do it in a single line?</span>
<span class="comment-copy">@Vinz243: You can use concatenation: <code>['a'] + list(foo()) + ['e']</code></span>
<span class="comment-copy">@Vinz243 If your only goal is to have a single line code you could do something insane like: <code>(lambda x: x.__setitem__(slice(1,1), (1,2,3)) or x)(['a', 'e'])</code>. Fortunately in this case list concatenation isn't really that bad, but the point is: sometimes making things fit in a single line is simply not worth it.</span>
<span class="comment-copy"><code>print(['a', *foo(), 'e'])</code> doesn't work in 3.4.3</span>
<span class="comment-copy">@NizamMohamed yes, this is new in Python 3.5. I'll clarify.</span>
<span class="comment-copy">This only works because strings like <code>'a'</code> and <code>'e'</code> are themselves iterable. It won't work for integers or other non-iterables nor will it produce correct output for strings with more than one character, or empty strings.</span>
