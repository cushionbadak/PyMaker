<div class="post-text" itemprop="text">
<p>The following code will print out the current time every 5 seconds, and it handles keyboard interrupt signals with <code>int_handler</code>.</p>
<pre><code>from signal import *
import time
from datetime import datetime


def int_handler(*args):
    print 'interrupted'

signal(SIGINT, int_handler)

while True:
    print datetime.now()
    time.sleep(5)
</code></pre>
<p>However, every time I press <kbd>Ctrl</kbd>-<kbd>C</kbd> it will print out the current time immediately, and continue running. </p>
<pre><code>2016-06-28 18:17:19.441574
2016-06-28 18:17:24.446659
2016-06-28 18:17:29.451759
2016-06-28 18:17:34.452328
^Cinterrupted
2016-06-28 18:17:37.244227
^Cinterrupted
2016-06-28 18:17:37.692217
^Cinterrupted
2016-06-28 18:17:38.236343
^Cinterrupted
2016-06-28 18:17:38.572194
2016-06-28 18:17:43.577122
2016-06-28 18:17:48.577242
</code></pre>
<p>It seems that the interruption awakes the process from sleeping, the handler gets executed, and somehow it gets back to the while loop again.</p>
<p>Can someone explain it to me why? Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>From the documentation of <code>sleep()</code>:</p>
<blockquote>
<p>The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signalâ€™s catching routine.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow">https://docs.python.org/3/library/time.html#time.sleep</a></p>
<p>So what you describe is exactly what is happening: after handling the signal in your signal handler execution continues after the sleep, which is the last expression in your while-loop.</p>
<p>Hence in order to really sleep approximately 5 seconds ignoring interruptions you'd have to store the time before sleep and check on waking up that enough has passed, or sleep some more.</p>
</div>
