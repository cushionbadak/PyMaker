<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/988228/convert-a-string-representation-of-a-dictionary-to-a-dictionary">Convert a String representation of a Dictionary to a dictionary?</a>
<span class="question-originals-answer-count">
                    11 answers
                </span>
</li>
</ul>
</div>
<p>I have a string </p>
<pre><code>"{a:'b', c:'d',e:''}"
</code></pre>
<p>Please not that the keys to the dictionary entries are unquoted, so a simple <code>eval("{a:'b', c:'d',e:''}")</code> as suggested in a <a href="https://stackoverflow.com/questions/988228/converting-a-string-to-dictionary">previous question</a> does not work.</p>
<p>What would be the most convenient way to convert this string to a dictionary?</p>
<pre><code>{'a':'b', 'c':'d', 'e':''}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Depending on the complexity of what you're parsing, this could work:</p>
<pre><code>s = "{a:'b', c:'d',e:''}"
d = dict([
    (x.split(':')[0].strip(), x.split(':')[1].strip("' "))
    for x in s.strip("{}").split(',')
])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If this is from a <strong>trusted source</strong> (do not use this for general user input, as <a href="https://stackoverflow.com/questions/661084/security-of-pythons-eval-on-untrusted-strings">eval is not secure</a>; but then again, if you're getting input from a potentially malicious user you should use JSON format and the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code> module</a> instead), you can use <code>eval</code> with a trick.</p>
<pre><code>source = """{e: '', a: 'b', c: 'd'}"""

class identdict(dict):
    def __missing__(self, key):
        return key

d = eval(source, identdict())
print(d)
</code></pre>
<p>prints</p>
<pre><code>{'a': 'b', 'c': 'd', 'e': ''}
</code></pre>
<p>How this works is that we create a new dictionary subclass <code>identdict</code> that defines the magic method <code>__missing__</code>. This method is called for lookups on keys that are missing from the dictionary. In this case, we just return the key, so the dictionary maps keys to themselves. Then the <code>source</code> is <code>eval</code>uated using an <code>identdict</code> instance as the <code>globals</code> argument. <code>eval</code> will look up the values of variables from the <code>globals</code> mapping; as it is an <code>identdict</code>, the value of each variable accessed is conveniently now the name of the variable.</p>
<p>Works for even more complex strings as values, and anything that is proper Python literal syntax.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>WARNING</strong> This approach will not work as desired if you have a key mapping to an empty string in the middle of your "dictionary." I'll not delete this answer because I think this approach might still be salvageable. </p>
<p>This might be a little more general than Will's answer, although, it is still going to depend on the exact structure of what you are parsing. If your key, value pairs will consist of alphanumeric words, you should be fine, though. </p>
<pre><code>In [3]: import re

In [4]: import itertools

In [5]: my_string = "{a:'b', c:'d',e:''}"

In [6]: temp = re.findall(r"\w", my_string)

In [7]: temp = itertools.zip_longest(temp[0::2], temp[1::2], fillvalue = "")

In [8]: dict(temp)
Out[8]: {'a': 'b', 'c': 'd', 'e': ''}
</code></pre>
<p>If you want to know what is happening with the zip function, see these questions:</p>
<p><a href="https://stackoverflow.com/questions/4647050/collect-every-pair-of-elements-from-a-list-into-tuples-in-python">Collect every pair of elements from a list into tuples in Python</a></p>
<p>I used <code>itertools.zip_longest</code> so you can use a fill value, inspired by:</p>
<p><a href="https://stackoverflow.com/questions/4628290/pairs-from-single-list">Pairs from single list</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could also do it this way, even though it's not pretty. It really does depend on what the structure of your string is. Are there any other sort of string dicts you have to evaluate?</p>
<pre><code>string = "{a:'b', c:'d',e:''}"[1:-1].split(",")

d = {}
for s in string:
    s = s.strip()
    key, value = s[0], s[-2]
    if value.isalpha():
        d[key] = value
    else:
        d[key] = ''

print(d)
</code></pre>
<p>Output:</p>
<pre><code>{'e': '', 'a': 'b', 'c': 'd'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can achieve this by using json package;</p>
<pre><code>import json
s = '{"a":"b", "c":"d","e":"f"}'
my_dict = json.loads(s)
print type(my_dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
str="{a:'b', c:'d',e:''}"
dict([i.replace("'","").split(":") for i in re.findall(r"(\w+\:'.*?')",str)])
</code></pre>
</div>
<span class="comment-copy">What is the source of those of such a string?</span>
<span class="comment-copy">@KevinGuan, it's different. <code>eval</code> will work for for <code>'a':'b'</code> but not <code>a:'b'</code></span>
<span class="comment-copy">@juanpa.arrivillaga: I'm guessing it's a Javascript object literal (<i>not</i> JSON, which requires the property names to be quoted).</span>
<span class="comment-copy">You may want to edit your question to note that the keys to the dictionary are not 'quoted'.</span>
<span class="comment-copy">@Bakuriu could you please revisit whether this question is a duplicate? I think recent edits make it clear that it is not.</span>
<span class="comment-copy">Wow, cool answer man :)</span>
<span class="comment-copy">Thank you :) Python is cool.</span>
<span class="comment-copy">Yeah it is Will, still have difficulty doing long expression like that though, Nice work man :)</span>
<span class="comment-copy">Nice. Although my content is alphanumeric only, good to learn something new. As I already accepted the other answer, I only can upvote for you. Appreciate.</span>
<span class="comment-copy">@Harrison it is always possible for you to change the accepted answer</span>
<span class="comment-copy">@AnttiHaapala Great little hack! But how exactly does this work? I'm not quite understanding how this gets past the <code>NameError</code>, shouldn't that be raised before the dictionary even deals with a a missing value? And how does it return a string? I added <code>print(type(key))</code> to the` __missing__` method, and it prints <code>&lt;class int&gt;</code> if I do something like <code>id[1]</code>, where <code>id</code> is an <code>identdict</code>, and if I do something like <code>id[x]</code> where x is not defined, I get a <code>NameError</code> and the <code>__missing__</code> method is never called! Clearly, I'm not understanding exactly what the <code>eval</code> built-in is doing.</span>
<span class="comment-copy">@juanpa.arrivillaga no, the global variables in python are stored in a module-wise dictionary; additionally mapping of local variables can be provided to <code>eval</code>. Normally <code>eval</code> defaults to those mappings which are returned by calls to <code>globals()</code> and <code>locals()</code>; now instead we use a <code>identdict</code> instance.</span>
<span class="comment-copy">Hmm, on second thought, this will not work as desired if you have a key mapping to an empty string in the middle of your "dictionary." Well, it might still be useful.</span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy">seems like someone downvoted everyone. I voted it back for you.</span>
<span class="comment-copy">This is very much dependent on the exact contents of the string.</span>
<span class="comment-copy">Right, I've acknowledged this deficiency in the first comment. Should I edit the answer to include a warning?</span>
<span class="comment-copy">Doesn't work with the string in the question</span>
