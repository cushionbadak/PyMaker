<div class="post-text" itemprop="text">
<p>In a view, I create a Django HttpResponse object composed entirely of a csv using a simply csv writer:</p>
<pre><code>response = HttpResponse(content_type='text/csv')
response['Content-Disposition'] = 'attachment; filename="foobar.csv"'

writer = csv.writer(response)

    table_headers = ['Foo', 'Bar']
    writer.writerow(table_headers)

    bunch_of_rows = [['foo', 'bar'], ['foo2', 'bar2']]
    for row in bunch_of_rows:
        writer.writerow(row)

return response
</code></pre>
<p>In a unit test, I want to test some aspects of this csv, so I need to read it. I'm trying to do so like so: </p>
<pre><code>response = views.myview(args)

reader = csv.reader(response.content)

headers = next(reader)
row_count = 1 + sum(1 for row in reader)

self.assertEqual(row_count, 3) # header + 1 row for each attempt
self.assertIn('Foo', headers)
</code></pre>
<p>But the test fails with the following on the <code>headers = next(reader)</code> line:</p>
<pre><code>nose.proxy.Error: iterator should return strings, not int (did you open the file in text mode?)
</code></pre>
<p>I see in the HttpResponse source that <code>response.content</code> is spitting the string back out as a byte-string, but I'm not sure the correct way to deal with that to let <code>csv.reader</code> read the file correctly. I thought I would be able to just replace <code>response.content</code> with <code>response</code> (since you write to the object itself, not it's content), but that just resulted in a slight variation in the error:</p>
<pre><code>_csv.Error: iterator should return strings, not bytes (did you open the file in text mode?)
</code></pre>
<p>Which seems closer but obviously still wrong. Reading the <code>csv</code> docs, I assume I am failing to open the file correctly. How do I "open" this file-like object so that <code>csv.reader</code> can parse it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>response.content</code> provides bytes. You need to decode this to a string:</p>
<pre><code>foo = response.content.decode('utf-8')
</code></pre>
<p>Then pass this string to the csv reader using io.StringIO:</p>
<pre><code>import io
reader = csv.reader(io.StringIO(foo))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>io.TextIOWrapper</code></a> to convert the provided bytestring to a text stream:</p>
<pre><code>import io
reader = csv.reader(io.TextIOWrapper(io.BytesIO(response.content), encoding='utf-8'))
</code></pre>
<p>This will convert the bytes to strings as they're being read by the reader. </p>
</div>
<span class="comment-copy">While both answers are valid, in my particular case the content is so small that the minor performance improvements afforded by knbk's answer are outweighed by the readability of this answer. Both upvoted, this one accepted. The final form I ended up using was this: <code>reader = csv.reader(StringIO(response.content.decode('utf-8')))</code>. I chose to import only StringIO, hence the omission of <code>io.</code></span>
<span class="comment-copy">Replacing my <code>reader =</code> line for yours, I get the error: <code>AttributeError: 'bytes' object has no attribute 'readable'</code>. Investigating...</span>
<span class="comment-copy">Upon further investigation my initial comment, was wrong.  To use this, you would first need to pass <code>response.content</code> to BytesIO first.</span>
<span class="comment-copy">You're right about that. It does have the advantage that it decodes the chunks, rather than all content at once, but generally that won't make any difference. In most cases your answer is easier to use, but I'll leave this here for completeness' sake.</span>
<span class="comment-copy">At any rate, it was a good learning experience.</span>
