<div class="post-text" itemprop="text">
<p>I am attempting to segment a LiDAR point cloud after the ground has been classified. I am using numpy to create an "image" of the the point cloud (pc) and am looping through the numpy array.  I would like to speed up the loop or avoid it all together.  I am going to use image segmentation techniques, but first I need to run this code to create an "image" and this is the part that is taking a while.  Is there a way to increase the speed of this loop or a way to avoid it?   </p>
<pre class="lang-py prettyprint-override"><code>
import numpy as np
from math import ceil, floor


'''In this case:
pc = point cloud (X,Y,Z values)'''

# point cloud is in the numpy array, pc
minx,maxx,miny,maxy = floor(np.min(pc[:,0]-1)),ceil(np.max(pc[:,0]+1)),floor(np.min(pc[:,1]-1)),ceil(np.max(pc[:,1]+1))# x,y bounding box

# grid x and y direction (resolution: 0.2 meters)
gridx = np.linspace(minx,maxx,int((maxx - minx+0.2)*5),endpoint=True) 
gridy = np.linspace(miny,maxy,int((maxy - miny +0.2)*5),endpoint=True)

#shape of the new image with 0.2 meter resolution.
imgx,imgy = int((maxx-minx+0.2)*5),int((maxy - miny +0.2)*5)

# this is what will be created at the end.  It will be a binary image.
img = np.zeros((imgx,imgy))

#loop through array to generate image (this is the part that takes a while)
for x,i in enumerate(gridx):
    for y,j in enumerate(gridy):

# Test if there any points in this "grid"
        input_point = pc[np.where(((pc[:,0]&gt;i) &amp; (pc[:,0]&lt;i+1))&amp; ((pc[:,1]&gt;j) &amp; (pc[:,1]&lt;j+1)))]
# if there are points, give pixel value 1.
        if input_point.shape[0]!=0:
            img[x,y]=1

print('Image made')


</code></pre>
<p>Thank you.  </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a vectorized version that produces the same output on a random test set:</p>
<pre><code>import numpy as np
from math import ceil, floor
import time

width = 0.2

t = [time.time()]

pc = np.random.uniform(-10, 10, (100, 3))

# point cloud is in the numpy array, pc
minx,maxx,miny,maxy = floor(np.min(pc[:,0]-1)),ceil(np.max(pc[:,0]+1)),floor(np.min(pc[:,1]-1)),ceil(np.max(pc[:,1]+1))# x,y bounding box

# grid x and y direction (resolution: 0.2 meters)
gridx = np.linspace(minx,maxx,int((maxx - minx+0.2)*5),endpoint=True) 
gridy = np.linspace(miny,maxy,int((maxy - miny +0.2)*5),endpoint=True)

#shape of the new image with 0.2 meter resolution.
imgx,imgy = int((maxx-minx+0.2)*5),int((maxy - miny +0.2)*5)

print('Shared ops done')
t.append(time.time())

# this is what will be created at the end.  It will be a binary image.
img = np.zeros((imgx,imgy))

#loop through array to generate image (this is the part that takes a while)
for x,i in enumerate(gridx):
    for y,j in enumerate(gridy):

# Test if there any points in this "grid"
        input_point = pc[np.where(((pc[:,0]&gt;i) &amp; (pc[:,0]&lt;i+width))&amp; ((pc[:,1]&gt;j) &amp; (pc[:,1]&lt;j+width)))]
# if there are points, give pixel value 1.
        if input_point.shape[0]!=0:
            img[x,y]=1

t.append(time.time())            
print('Image made')

if width == 0.2:
    img2 = np.zeros((imgx, imgy), 'u1')
    x2, y2 = (((pc[:, :2] - (minx, miny)) * (5, 5))).astype(int).T
    img2[x2, y2] = 1

elif width == 1:
    img2 = np.zeros((imgx+4, imgy+4), 'u1')
    x2, y2 = (((pc[:, :2] - (minx, miny)) * (5, 5))).astype(int).T

    np.lib.stride_tricks.as_strided(img2, (imgx, imgy, 5, 5), 2 * img2.strides)[x2, y2] = 1
    img2 = img2[4:, 4:]

t.append(time.time())
print('Image remade')

print('took', np.diff(t), 'secs respectively')
assert((img2==img).all())
print('results equal')
</code></pre>
<p>Your code produces 5x5 pixels. Is that intentional? I had to be a bit tricksy to reproduce that.</p>
<p><strong>UPDATE</strong>: added a version that makes ordinary pixels instead.</p>
<p>Sample run:</p>
<pre><code>Shared ops done
Image made
Image remade
took [2.29120255e-04 1.54510736e-01 1.44481659e-04] secs respectively
results equal
</code></pre>
</div>
<span class="comment-copy">Thank you!  I was trying to get pixels that were 0.2 meters by taking the max and min y values and splitting them up by 0.2 meters.  Is this not true?  Sorry I'm trying to wrap my head around what you mean.</span>
<span class="comment-copy">@Steven But the intervals you check are <code>i</code> to <code>i+1</code> and <code>j</code> to <code>j+1</code> which span 5 grid units in each direction.</span>
<span class="comment-copy">I wasn't trying to span 5 grid units.  What I was trying to do was check based on the 0.2 interval.  for example, if <code>i = 300.0</code> and <code>j = 400.0</code>, it would check if there are points from <code>300.0 - 300.2</code> in the <code>x</code> and <code>400.0 - 400.2</code> in the <code>y</code>.  Does it not do this?</span>
<span class="comment-copy">oh duh!!  That's not what it does.  shoot...I guess I would have to change that.  I meant the next number in the interval and I guess I'm just adding 1 which would make it 5 pixels since each is 0.2 meters.  Thank you for catching that.</span>
<span class="comment-copy">@Steven That makes things simpler, actually. I've updated the answer.</span>
