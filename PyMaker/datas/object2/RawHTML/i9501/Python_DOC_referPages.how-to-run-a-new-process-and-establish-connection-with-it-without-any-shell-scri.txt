<div class="post-text" itemprop="text">
<p>My purpose is create a new process of other program and establish with it  a long-time connection (opportunity to write to its stdin and read a result) i.e. not atomic write-read operation with following killing of created process. I have to use program code only, not any shell command.</p>
<p>There is my code:</p>
<pre><code>import subprocess
proc = subprocess.Popen(['myprog', '-l'], shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE)
#proc was kept
#after some waiting I try to send to proc some command
if proc.returncode == None:
    proc.stdin.write(b'command')
    response = process.communicate()[0]
</code></pre>
<p>This code returns either empty string (if one transaction was commited) or rises BrokenPipeError (if it was running in loop). 
Does proc stay alive after the first <code>process.communicate()</code>? What approach I need to use to get control of stdin/stdout of proc? </p>
</div>
<div class="post-text" itemprop="text">
<p>You are checking for <code>proc.returncode == None</code>.</p>
<p>But if you read the <a href="https://docs.python.org/3/library/subprocess.html?highlight=popen#subprocess.CompletedProcess.returncode" rel="nofollow noreferrer">documentation of subprocess</a> the returncode is either <code>0</code> or a negative number, but never <code>None</code>.</p>
<ul>
<li><p>Second, if you have long running processes, you should either adjust and handle the <code>timeout</code>, or disable it..</p></li>
<li><p>Third: You should really really really avoid <code>shell=True</code> in Popen, it is a huge security risk.</p></li>
</ul>
<p>Here is some example how I normally deal with Popen:</p>
<pre><code>from shlex import split as sh_split
from subprocess import PIPE, Popen, TimeoutExpired


def launch(command, cwd=None, stdin=None, timeout=15):
    with Popen(
        sh_split(command), universal_newlines=True,
        cwd=cwd, stdout=PIPE, stderr=PIPE, stdin=PIPE
    ) as proc:
        try:
            out, err = proc.communicate(input=stdin, timeout=timeout)
        except TimeoutExpired:
            proc.kill()
            out, err = proc.communicate()
        return proc.returncode, out.splitlines(), err.splitlines()
</code></pre>
<p>This is for short living processes, but I hope you can see how stdin, stdout and stderr handling is done.</p>
</div>
