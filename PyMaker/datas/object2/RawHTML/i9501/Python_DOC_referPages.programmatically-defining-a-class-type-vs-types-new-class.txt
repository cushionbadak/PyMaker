<div class="post-text" itemprop="text">
<p>Aside from <code>types.new_class</code>'s capability to define the keyword arguments when creating a class. Are there any major differences between the two approaches?</p>
<pre><code>import types

First = type('First',(object,),{'asd':99})
k = First()

Second = types.new_class('Second',(object,),{},lambda x:x)
x = Second()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I realise this is late, and hence you've already likely answered this yourself.</p>
<p>Firstly, it seems that you misunderstand the <code>kwds</code> argument of <code>types.new_class</code>; it is the class keyword arguments, e.g</p>
<pre><code>class MyMeta(type):
    def __new__(metacls, name, bases, attrs, **config):
        print(config)
        return super().__new__(metacls, name, bases, attrs)

    def __init__(cls, name, bases, attrs, **config):
        super().__init__(name, bases, attrs)

class SomeCls(metaclass=MyMeta, debug=True):
    pass

&gt;&gt; {'debug': True}
</code></pre>
<p>is analogous to (without the print)</p>
<pre><code>SomeCls = types.new_class("SomeCls", (), {'debug':True})
</code></pre>
<p>These meta-arguments are useful when configuring meta-classes.</p>
<p>I am not really sure as to why <code>new_class</code> was designed to accept a callable vs a dict directly, but I suspect it was to avoid implicit shared state between "new" classes that did not inherit from one another. </p>
</div>
<div class="post-text" itemprop="text">
<h3>Are there any major differences between the two approaches?</h3>
<p><strong>Yes</strong>. The answer involves a concept called "<a href="https://stackoverflow.com/q/100003/7246614">metaclasses</a>". </p>
<blockquote>
<p>[Metaclasses] are deeper magic than 99% of users should
  ever worry about.  If you wonder whether you need them, you don't (the
  people who actually need them know with certainty that they need them, and
  don't need an explanation about why). <em>â¸º Tim Peters, author of Zen of Python (<a href="https://groups.google.com/d/msg/comp.lang.python/o61KSF77IWs/s09TqSEvTQgJ" rel="nofollow noreferrer">source</a>)</em></p>
</blockquote>
<p><strong>If you think you're in that 99%, then read no further, feel free to just use <a href="https://docs.python.org/3/library/functions.html?highlight=type%20built#type" rel="nofollow noreferrer"><code>type</code></a>. It's just as good as <a href="https://docs.python.org/3/library/types.html#types.new_class" rel="nofollow noreferrer"><code>types.new_class</code></a> except for in the rare situation that you're using metaclasses.</strong></p>
<p>If you want to know more about metaclasses, I suggest you <strong>take a look at some of the high quality answers posted to "<a href="https://stackoverflow.com/q/100003/7246614">What are metaclasses in Python?</a>".</strong> (I recommend <a href="https://stackoverflow.com/a/6581949/7246614">this one</a>.)</p>
<p>Once you understand what a metaclass is, the answer is fairly self-evident. Since <code>type</code> is a specific metaclass, it will only work if you want to create classes that use it as their metaclass.</p>
<p>However, if you want to use a non-default metaclass</p>
<pre class="lang-py prettyprint-override"><code>class MySimpleMeta(type):
    pass
</code></pre>
<p>and a static class won't do</p>
<pre class="lang-py prettyprint-override"><code>class MyStaticClass(object, metaclass=MySimpleMeta):
    pass
</code></pre>
<p>then you can use <code>types.new_class</code></p>
<pre class="lang-py prettyprint-override"><code>import types

MyStaticClass = types.new_class("MyStaticClass", (object,), {"metaclass": MyMeta}, lambda ns: ns)
# this is equivalent to the above class.
</code></pre>
<p>(As a brief aside, the reason that it requires a callable (e.g. <code>lambda ns: ns</code>) instead of a dictionary is <a href="https://www.python.org/dev/peps/pep-3115/#id11" rel="nofollow noreferrer">because metaclasses are allowed to care about the order in which the attributes are defined.</a> )</p>
</div>
