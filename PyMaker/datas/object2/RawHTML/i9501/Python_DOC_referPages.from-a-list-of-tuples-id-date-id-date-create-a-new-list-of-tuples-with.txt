<div class="post-text" itemprop="text">
<p>I have a list of tuples [(ID,date),(ID,date),...]. The same ID can occur many times or only once. If ID occur more than once i only want the most recent one. </p>
<pre><code>lst = [(587,"2015-01-01"),
        (625,"2011-12-01"),
        (587,"1998-05-01")]
</code></pre>
<p>I want this:</p>
<pre><code>list2 = [(587,"2015-01-01"),
        ("625,2011-12-01"),]
</code></pre>
<p>One of the tuples look like:</p>
<pre><code>(2, 14, 58875, 1, datetime.datetime(2009, 11, 1, 0, 0), u'RB', u'SYSTEM', datetime.datetime(2016, 6, 21, 9, 7, 38), u'SYSTEM', datetime.datetime(2016, 6, 21, 9, 7, 38))
</code></pre>
<p>The ID field has index 2 and date field index 4</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>defaultdict()</code> with an empty string as the default value:</p>
<pre><code>lst = [(587,'2015-01-01'),
       (625,'2011-12-01'),
       (587,'1998-05-01')]

from collections import defaultdict
result = defaultdict(lambda: "")

for k, v in lst:
    if result[k] &lt; v:
        result[k] = v

list(result.items())
# [(625, '2011-12-01'), (587, '2015-01-01')]
</code></pre>
<hr/>
<p>If the elements in each tuple are too many to unpack as above, you can capture the tuple with a single variable and then use index to access it, for instance:</p>
<pre><code>for x in lst: 
    if result[x[0]] &lt; x[1]: 
        result[x[0]] = x[1]

list(result.items())
# [(625, '2011-12-01'), (587, '2015-01-01')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.groupby</code> to group your tuples by the first element, then select the last element from each group:</p>
<pre><code>groups = itertools.groupby(sorted(lst), lambda x:x[0])
[(list(x[1])[-1]) for x in groups]
# [(587, '2015-01-01'), (625, '2011-12-01')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An approach is using <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter()</code></a> like below:</p>
<pre><code>my_list = [(587, '2015-01-01'),
        (625, '2011-12-01'),
        (587, '1998-05-01')]

my_keys = set(item[0] for item in my_list)  # to eliminate duplicates

res_list = []
for key in my_keys:
    res_list.append(filter(lambda item: item[0] == key, my_list)[0])
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt;&gt;&gt; res_list
[(625, '2011-12-01'), (587, '2015-01-01')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from datetime import datetime

list = [(587,"2015-01-01"),
        (625,"2011-12-01"),
        (587,"1998-05-01")]

listsort = sorted([(e[0], datetime.strptime(e[1], "%Y-%m-%d")) for e in list])[::]
listfilter = sorted([(k, datetime.strftime(v, "%Y-%m-%d")) for k,v in dict(listsort).iteritems()])
print listfilter
</code></pre>
<p>Output</p>
<pre><code>[(587, '2015-01-01'),
 (625, '2011-12-01')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use any library, this should work:</p>
<pre><code>list2=[]

for i in list1:
    if i[0] not in [j[0] for j in list2]:
        list2.append(i)
    else: 
      for k in range(len(list2)):
        if i[0] == list2[k][0] and i[1] &gt; list2[k][1]:
            list2[k] = i
</code></pre>
<p>Thus, if the ID is not in <code>list2</code>, it will append the touple, while if it is and the <code>i</code> date value is higher than the one in <code>list2</code>, it will replace it.</p>
<p>If your touples have other values, then just adapt it for your ID and date positions. For the case (value,ID,value,value,date,value,...) it would be:</p>
<pre><code>list2=[]

for i in list1:
    if i[1] not in [j[1] for j in list2]:
        list2.append(i)
    else: 
      for k in range(len(list2)):
        if i[1] == list2[k][1] and i[4] &gt; list2[k][4]:
            list2[k] = i
</code></pre>
<p>Hope this helped!</p>
</div>
<span class="comment-copy">Don't call your variables <code>list</code>: <code>list()</code> is a list constructor.</span>
<span class="comment-copy">Is the order of the tuple elements in the list of importance? If not, you could migrate the list to dictionary, and when adding new dictionary key-value pairs, simply check if a pair already exist for the given key, and update the value in case the existing date is older than the one of the new pair.</span>
<span class="comment-copy">the order is not important</span>
<span class="comment-copy">Neat with the default value! Maybe worth mentioning (at least here in a comment) that it's possible that the OP needn't really return to the list data structure; it might be appropriate simply using a dictionary (also easing updating when new KV pairs arrive), as the (non-ordered) dictionary items can still be readily traversed over using <code>.items()</code> (/ <code>.iteriterms</code>).</span>
<span class="comment-copy">My tuples actually look like (value,ID,value,value,date,value,...), can i use indexes in the for k,v, like k[1], v[4]?</span>
<span class="comment-copy">In this case there are too many values to unpack the tuple in this manner. You can use a single variable and then index it. <code>for x in lst: if result[x[1]] &lt; x[4]: result[x[1]] = x[4]</code> for instance.</span>
<span class="comment-copy">Sorry i dont understand. Could you add this code to your answer?</span>
<span class="comment-copy">Edited the answer with a different method, see the update.</span>
<span class="comment-copy">I get syntax error at this line: list2.append((i[0], max(i[1], [j[1] if j[0]==i[0] for j in list2][0])))</span>
<span class="comment-copy">The max() wasn't appropiate, my mistake. Now it works!</span>
