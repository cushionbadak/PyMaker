<div class="post-text" itemprop="text">
<p>Consider the following piece of code that generates all subsets of size k of an array [1,2,3,...,n]:</p>
<pre><code>def combinations(n, k):
   result = []
   directed_combinations(n, k, 1, [], result)
   return result

def directed_combinations(n, k, offset, partial_combination, result):
    if len(partial_combination) == k:
        new_partial = [x for x in partial_combination]
        result.append(new_partial)
        return
    num_remaining = k - len(partial_combination)
    i = offset
    #                kind of checks if expected num remaining is no greater than actual num remaining
    while i &lt;= n and num_remaining &lt;= n - i + 1:
        partial_combination.append(i)
        directed_combinations(n, k, i + 1, partial_combination, result)
        del partial_combination[-1]
        # partial_combination = partial_combination[:-1] &lt;-- same funcationality as line above, but produces weird bug.
        i += 1

print(combinations(n=4,k=2))
</code></pre>
<p>For example, <code>combinations(n=4,k=2)</code> will generate all subsets of length 2 of [1,2,3,4]. 
There are two lines in the code that produce a list with the last element removed. I tried accomplishing it with <code>del</code> and creating a brand new list by slicing off the last element (i.e. <code>[-1]</code>). The version with <code>del</code> produces the correct result. But, version with <code>[-1]</code> doesn't. There is no runtime error; just a logical bug (i.e. incorrect result). </p>
<p>I suspect this has something to do with creating a new list when doing slicing vs. keeping the same list with <code>del</code>. I can't seem to understand why this is an issue. </p>
</div>
<div class="post-text" itemprop="text">
<p>I didn't notice at first that your function is recursive (should've read your tags better).</p>
<p>You're right, functionally the two are <em>almost</em> the same. Here is the <em>exact</em> same thing:</p>
<pre><code># del partial_combination[-1]                     # working (mutate)
# partial_combination = partial_combination[:-1]  # different (rebind)
partial_combination[:] = partial_combination[:-1] # same (mutate)
</code></pre>
<p>The result of each of the above will be that you end up with a list containing the same elements. But while <code>del</code> and <code>partial_combination[:]</code> <em>mutate</em> your original list, the middle one <em>rebinds the name to a new list</em> with the same elements. When you pass on this new list to the next recursive step, it will operate on its own copy rather than on the single list the previous recursive levels are working on.</p>
<p>To prove this, you can call <code>print(id(partial_combination))</code> after each of the above options, and see that the <code>id</code> changes in the rebinding case, while it stays the same throughout the mutating ones.</p>
</div>
<span class="comment-copy">Okay. It makes sense. However, at first, I was confused why the last option mutated the list rather than creating a new one. I've never seen assignment to slices before. Checking the <a href="https://docs.python.org/3/tutorial/introduction.html" rel="nofollow noreferrer">docs (3.1.3 section)</a> clarified it for me.</span>
<span class="comment-copy">@AzaTulepbergenov <a href="http://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">here's an additional source</a> for understanding mutating vs rebinding.</span>
