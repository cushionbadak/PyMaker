<div class="post-text" itemprop="text">
<p>I want to use a data structure that allows me to store up to X objects with thier rankings and managing that structure in the best run-time.</p>
<p>Lets call it <code>Rank_List()</code>. Lets define <code>X = 2</code> and the following should happen.</p>
<pre><code>ranked_list = Rank_List()
ranked_list.add((obj1, 0.5)
print ranked_list -&gt; [(obj1, 0.5)]

ranked_list.add((obj2, 0.75))
print ranked_list -&gt; [(obj2, 0.75), (obj1, 0.5)]
</code></pre>
<p>So we can see it keeps the rank in check (0.75 is in the first place, and 0.5 is in the 2nd)</p>
<pre><code>ranked_list.add(obj3, 0.7)
print ranked_list -&gt; [(obj2, 0.75), (obj3, 0.7)]
</code></pre>
<p>After adding another object that is ranked higher then obj1, obj1 is cast out of the list (<code>X = 2</code> so only up to 2 object may be stored in the list)</p>
<p>Is there a data structure like that that already exists in python?
If not which way should I implement it to get the best run-time results</p>
</div>
<div class="post-text" itemprop="text">
<p>From the comments I understand you are looking to extract the top K elements from a sequence. In that case you don't need to keep your list sorted at all. You can use a <em>heap queue</em>.</p>
<p>A heapq is a binary tree where any parent has a value either smaller than any of its children (or larger, if you flip the values). This means you can always find the top K elements, in order, in O(K) time, but keeping the heap in order on inserting only takes O(logN) time. In total, for N items going in and K top items to come out (in order), this gives you a very efficient O(KlogN) algorithm.</p>
<p>The Python standard library includes the <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer"><code>heapq</code> module</a> to do this for you.</p>
<p>You can either keep a heap yourself or use the <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer"><code>heapq.nlargest</code> function</a> to build a heap from an iterable for you and then directly return the top K items.</p>
<p>To keep the K <em>largest</em> items in a manually kept heap, build a list of K elements first (as <code>(priority, elem)</code> tuples), use <code>heapify()</code> once it reaches that size, and from there on out use <code>heapreplace()</code> to push your next element onto the list and remove the <em>smallest</em>. That way you always keep a fixed-size heap of K largest items. In the end, use <code>sorted(heap, reverse=True)</code> to give you those largest items in reverse sorted order (largest to smallest).</p>
</div>
<span class="comment-copy">You mean you want a list that is automatically kept in sorted order? No, there is no such structure. What is the goal here, to extract the element with the highest rank each time? Then you don't need the rest in sorted order, use a heap (see the <code>heapq</code> module), or use a priority queue (a thread-safe version is in the <code>queue</code> module).</span>
<span class="comment-copy">The goal will be to get first Z top elements while Z &lt;= X. Also, in anytime i could get better (obj, rank) to that list, so it needs to be maintained</span>
<span class="comment-copy">Then use a heapq.</span>
<span class="comment-copy">Just a question: does heapq work for minimum values as well? it seems really neat!</span>
<span class="comment-copy">You can create a min heap yes.</span>
<span class="comment-copy">Im looking up to it if it satisfy my needs</span>
<span class="comment-copy">@SonderingNarcissist: yes, the default implementation is to give you a <i>min heap</i>. To get a max heap (as the OP wants), just invert the priority (store <code>-0.75</code> rather than <code>0.75</code> in the first element of a tuple).</span>
