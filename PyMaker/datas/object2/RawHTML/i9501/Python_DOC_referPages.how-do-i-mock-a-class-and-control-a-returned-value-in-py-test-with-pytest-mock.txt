<div class="post-text" itemprop="text">
<p>I'm trying to use <code>py.test</code> to test some code that does various <code>LDAP</code> searches, and modifications.</p>
<p>I'm using <code>pytest-mock</code>, but I'm having trouble understanding how to mock out the creation of the an LDAP object, and control what it returns when a <code>search_s()</code> is called on the mocked object.</p>
<p>I thought this would do what I wanted, but the test fails, the count shows the generator function <code>find_users()</code> never yields anything.</p>
<pre><code>import pytest
# Here is some code to simply test mocking out ldap.initialize(), and
# controlling the return value from calls to search_s()
import ldap

def find_users(ldap_url, admin_user, admin_password, userbase):
    lobj = ldap.initialize(ldap_url)
    lobj.simple_bind_s(admin_user, admin_password)
    for i in lobj.search_s(userbase, ldap.SCOPE_SUBTREE, '*'):
        yield i[1]['uid'][0]

class TestMocking:

    @pytest.fixture()
    def no_ldap(self, mocker):
        return mocker.patch('ldap.initialize')


    def test_ad_one_user(self, no_ldap):
        # try and modify how search_s() would return
        no_ldap.search_s.return_value = ('', {'uid': ['happy times']})
        count = 0 
        for i in find_users('', '', '', ''):
            count += 1
            assert i=='happy times'
        assert count == 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use patch directly (and something was off about your structure): </p>
<pre><code>from mock import patch, Mock
import pytest
# Here is some code to simply test mocking out ldap.initialize(), and
# controlling the return value from calls to search_s()
import ldap

def find_users(ldap_url, admin_user, admin_password, userbase):
    lobj = ldap.initialize(ldap_url)
    lobj.simple_bind_s(admin_user, admin_password)
    for i in lobj.search_s(userbase, ldap.SCOPE_SUBTREE, '*'):
        yield i[1]['uid'][0]

class TestMocking:

    @patch('ldap.initialize')
    def test_ad_one_user(self, no_ldap):
        # try and modify how search_s() would return
        data = [('', {'uid': ['happy times']})]
        search_s = Mock(return_value=data)
        no_ldap.return_value = Mock(search_s=search_s)
        count = 0
        for i in find_users('', '', '', ''):
            count += 1
            assert i=='happy times'
        assert count == 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you may be getting confused between <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html</a> and pytest mockey patch. I don't think both behave in the same way. </p>
<p>You can make it work using mock patch
(<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch</a>) </p>
<pre><code>@pytest.fixture()
def no_ldap(self):
    patcher = mock.patch('ldap.initialize')
    patcher.start()
    yield patcher
    patcher.stop()
</code></pre>
</div>
<span class="comment-copy">Thanks for the answer @salparadise.  This one works, but I'm still confused, because I thought the py.test "way" was to use fixtures, so you could re-use them across tests.</span>
<span class="comment-copy">@GeoffCrompton depends on your goal. fixtures allows scoping per module or test session, and by default only on a function (so exactly as this is doing), however you can also use unittest.TestCase and use a <code>setUp</code> function to initialize your patches for all the unittests in the class.</span>
<span class="comment-copy"><code>You can just use patch directly</code> - is this documented somewhere?</span>
<span class="comment-copy">@dm295 is this what you are after <a href="https://docs.python.org/3/library/unittest.mock.html#nesting-patch-decorators" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">@salparadise thanks. I knew how to use <code>patch</code> with <code>unittests</code>. But I didn't know that it's possible to use with <code>pytest</code> as well.</span>
<span class="comment-copy">Nice. See also <a href="https://stackoverflow.com/a/50048692/456550">this answer</a> for a way to do the same thing by using patch() as a context manager.</span>
