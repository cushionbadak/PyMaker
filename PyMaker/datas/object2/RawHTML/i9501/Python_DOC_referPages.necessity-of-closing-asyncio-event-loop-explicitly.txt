<div class="post-text" itemprop="text">
<p><strong>The Story:</strong></p>
<p>I am currently looking through the <a href="https://github.com/python/asyncio/blob/master/examples" rel="noreferrer">asyncio basic examples</a>, in particular <a href="https://github.com/python/asyncio/blob/master/examples/fetch0.py" rel="noreferrer">this one</a> - the simplest possible HTTP client. The main function starts an event loop, runs until the data fetching is complete and closes the event loop:</p>
<pre><code>def main():
    loop = get_event_loop()
    try:
        body = loop.run_until_complete(fetch())
    finally:
        loop.close()
    print(body.decode('latin-1'), end='')
</code></pre>
<p>But, the code also works if I omit the <code>loop.close()</code>:</p>
<pre><code>def main():
    loop = get_event_loop()
    body = loop.run_until_complete(fetch())
    print(body.decode('latin-1'), end='')
</code></pre>
<p><strong>The Question:</strong></p>
<p>While there is an example, the question is a generic one - what can potentially go wrong if one would forget to close the asyncio event loop? Is the event loop going to be always implicitly closed?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>.close()</code> can be used by different event loop implementations to free up system resources allocated by the loop (or do anything else).  If you'll take a look at the code of <code>_UnixSelectorEventLoop</code>, which is the (default) IOLoop used in Linux, you would find the following code:</p>
<pre><code>def close(self):
    super().close()
    for sig in list(self._signal_handlers):
        self.remove_signal_handler(sig)
</code></pre>
<p>Here, for example, <code>close()</code> removes signal handlers registered with <code>loop.add_signal_handler()</code>.</p>
<p>As multiple IOLoops can be started on different threads, or new IOLoops can be created after an old one is closed, (see <code>asyncio.new_event_loop()</code>), closing them should be considered as a good habit.</p>
<p><strong>Update</strong></p>
<p>Starting with Python 3.7 it is recommended to use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run" rel="nofollow noreferrer"><code>asyncio.run</code></a> instead of <code>run_until_complete()</code>:</p>
<pre><code># Python 3.7+
def main():
    body = asyncio.run(fetch())
    print(body.decode('latin-1'), end='')
</code></pre>
<p>Among other things, <code>asyncio.run</code> takes care of <code>finally</code> <code>close()</code>ing the loop. </p>
</div>
<span class="comment-copy">You'll leak resources.</span>
<span class="comment-copy">what do you think is implicitly closing it? I'd think garbage collection which you'd only be able to rely on when the program ends, how long does your program run after finishing with the event loop until the program finishes?</span>
<span class="comment-copy">@FilipHaglund thanks. Can you think of a way to test/demonstrate that?</span>
<span class="comment-copy">(Keep in mind the <a href="https://github.com/python/asyncio/blob/master/examples" rel="nofollow noreferrer">link you have supplied</a> is for asyncio for python 3.3 and was <a href="https://github.com/python/asyncio/commits/master/examples" rel="nofollow noreferrer">not updated</a> to python 3.5/3.6.)</span>
<span class="comment-copy">I guess the real question is why there isn't a context manager for it then...</span>
<span class="comment-copy">Because since python 3.7 it is recommended to use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run" rel="nofollow noreferrer"><code>asyncio.run</code></a> that does this for   you: <a href="https://github.com/python/cpython/blob/master/Lib/asyncio/runners.py" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Lib/asyncio/runners.py</a></span>
