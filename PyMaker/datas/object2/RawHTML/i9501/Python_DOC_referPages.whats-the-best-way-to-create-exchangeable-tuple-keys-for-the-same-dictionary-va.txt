<div class="post-text" itemprop="text">
<pre><code>def check():
    dict_choice_a = {(a, b) : value, (b, a) : value}  #(a, b) and (b, a) refer to the same value but repeted
    dict_choice_b = {tuple(sorted((a, b)) : value}  #not repetitive but unreadable
    dict_choice_a[(a, b)] = new_value #need to do twice to change value but more readable than dict_choice_b
    dict_choice_a[(b, a)] = new_value

    #value of both keys are always the same
</code></pre>
<p>I want to create a <code>dictionary</code> that has tuple keys referred to its values, that keys need to be exchangeable as <code>(a, b) = (b, a)</code> and they only refer to the same value.</p>
<p>Here's the question is: what is the best way to make the element of tulpe of keys exchangeable but also refer to the same value.</p>
<p>Moreover, string should be also work in the solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per the comments, you can put <code>a</code> and <code>b</code> into a <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset" rel="nofollow noreferrer"><code>frozenset</code></a>, which is unordered:</p>
<pre><code>dict_choice = {frozenset((a, b)): value}
</code></pre>
<hr/>
<p>If you need this to be automatic, you could create your own <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping" rel="nofollow noreferrer"><code>MutableMapping</code></a>:</p>
<pre><code>class MyDict(MutableMapping):

    def __init__(self, arg=None):
        self._map = {}
        if arg is not None:
            self.update(arg)

    def __getitem__(self, key):
        return self._map[frozenset(key)]

    def __setitem__(self, key, value):
        self._map[frozenset(key)] = value

    def __delitem__(self, key):
        del self._map[frozenset(key)]

    def __iter__(self):
        return iter(self._map)

    def __len__(self):
        return len(self._map)
</code></pre>
<p>In use:</p>
<pre><code>&gt;&gt;&gt; d = MyDict([((1, 2), 'hello'), ((3, 4), 'world')])
&gt;&gt;&gt; d[(2, 1)]
'hello' 
</code></pre>
<p>However note that this could have unexpected behaviour with other kinds of keys:</p>
<pre><code>&gt;&gt;&gt; d['hello'] = 'world'
&gt;&gt;&gt; d['hole']
'world'
&gt;&gt;&gt; d[1] = 2
Traceback (most recent call last):
  File "python", line 1, in &lt;module&gt;
  File "python", line 14, in __setitem__
TypeError: 'int' object is not iterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using @jonrsharpe solution, I created an alternative for the unexpected behavior with other kinds of keys, considered that only tuples will be used in an unordered way:</p>
<pre><code>class MyDict(MutableMapping):

    def __init__(self, arg=None):
        self._map = {}
        if arg is not None:
            self.update(arg)

    def __getitem__(self, key):
        if isinstance(key, tuple):
            return self._map[frozenset(key)]
        return self._map[key]

    def __setitem__(self, key, value):
        if isinstance(key, tuple):
            self._map[frozenset(key)] = value
        else:
            self._map[key] = value

    def __delitem__(self, key):
        if isinstance(key, tuple):
            del self._map[frozenset(key)]
        else:
            del self.map[key]

    def __iter__(self):
        return iter(self._map)

    def __len__(self):
        return len(self._map)

    def __str__(self):
        return str(self._map)
</code></pre>
</div>
<span class="comment-copy">you can use <code>set</code> instead of <code>tuple</code></span>
<span class="comment-copy">@Ni. <code>frozenset</code>, <code>set</code>s aren't hashable so can't be keys</span>
<span class="comment-copy">right, good point.</span>
