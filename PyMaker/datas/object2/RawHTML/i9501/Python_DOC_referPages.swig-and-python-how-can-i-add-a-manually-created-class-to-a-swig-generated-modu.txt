<div class="post-text" itemprop="text">
<p>My <a href="http://github.com/tensorflow/tensorflow" rel="nofollow noreferrer">project</a> uses <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/tensorflow.i" rel="nofollow noreferrer">SWIG</a> to automatically create wrappers for a set of C++ functions and types, in a single module called <code>tensorflow.python.pywrap_tensorflow</code>. I want to define a new type using the Python C API directly, and add it to that module. (In particular, I want to define a new type that implements the <a href="https://docs.python.org/2/c-api/buffer.html" rel="nofollow noreferrer">Python buffer protocol</a>, so that I can expose a native buffer as a <code>memoryview</code>.)</p>
<p>I can define the requisite structs for my new type by inlining it in a <code>.i</code> file:</p>
<pre><code>%{

typedef struct {
  PyObject_HEAD
  /* Other fields... */
} MyType;

// Define functions for the initializer, destructor, and buffer protocol:
// * MyType_init
// * MyType_dealloc
// * MyType_old_getbuffer (the readbufferproc for Python 2.7)
// * MyType_segcount (for Python 2.7)
// * MyType_getbuffer (the Python 2.7/3.x buffer protocol)

// ...

static PyBufferProcs MyType_as_buffer = {
#if PY_VERSION_HEX &lt; 0x03000000
  (readbufferproc)MyType_old_getbuffer,
  (writebufferproc)0,
  (segcountproc)MyType_segcount,
  (charbufferproc)0,
#endif
  (getbufferproc)MyType_getbuffer,
  (releasebufferproc)0,
};

static PyTypeObject MyType_TypeObject = {
  /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX&gt;=0x03000000
  PyVarObject_HEAD_INIT(NULL, 0)
#else
  PyObject_HEAD_INIT(NULL)
  0 /* ob_size */,
#endif
  "MyType" /* tp_name */,
  sizeof(MyType) /* tp_basicsize */,
  0 /* tp_itemsize */,
  (destructor)MyType_dealloc /* tp_dealloc */,
  0 /* tp_print */,
  0 /* tp_getattr */,
  0 /* tp_setattr */,
#if PY_VERSION_HEX&gt;=0x03000000
  0 /* tp_reserved in 3.0.1 */
#else
  0 /* tp_compare */,
#endif
  0 /* tp_repr */,
  0 /* tp_as_number */,
  0 /* tp_as_sequence */,
  0 /* tp_as_mapping */,
  0 /* tp_hash */,
  0 /* tp_call */,
  0 /* tp_str */,
  0 /* tp_getattro */,
  0 /* tp_setattro */,
  &amp;MyType_as_buffer /* tp_as_buffer */,
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_NEWBUFFER /* tp_flags */,
  "Python wrapper for MyType." /* tp_doc */,
  0 /* tp_traverse */,
  0 /* tp_clear */,
  0 /* tp_richcompare */,
  0 /* tp_weaklistoffset */,
  0 /* tp_iter */,
  0 /* tp_iternext */,
  0 /* tp_methods */,
  0 /* tp_members */,
  0 /* tp_getset */,
  0 /* tp_base */,
  0 /* tp_dict */,
  0 /* tp_descr_get */,
  0 /* tp_descr_set */,
  0 /* tp_dictoffset */,
  (initproc)MyType_init /* tp_init */,
};

%}
</code></pre>
<p>After doing this, I want to add the type object to the SWIG-generated module, by calling <a href="https://docs.python.org/2/c-api/module.html#c.PyModule_AddObject" rel="nofollow noreferrer"><code>PyModule_AddObject()</code></a>, presumably in the module initialization block (<code>%init %{ ... %}</code>). However, I do not know what name to give for the value returned from <a href="https://docs.python.org/2/c-api/allocation.html#c.Py_InitModule" rel="nofollow noreferrer"><code>Py_InitModule()</code></a> (or <a href="https://docs.python.org/3/c-api/module.html#c.PyModule_Create" rel="nofollow noreferrer"><code>PyModule_Create()</code></a> in Python 3.x) in the generated code that creates the <code>tensorflow.python.pywrap_tensorflow</code> module. I have been able to create a second module in the <code>%init %{ ... %}</code> block, but I'd prefer to add it to the auto-generated module if possible.</p>
<p>An answer to either of these questions would solve my problem:</p>
<ul>
<li><p>Is there a SWIG macro for accessing the generated module object in the initialization block (e.g. by expanding to the variable name for the corresponding <code>PyObject*</code>)? This object seems to be stored in a local variable called <code>m</code> in my generated code, but I don't know if that is guaranteed to be the same in all distributions.</p></li>
<li><p>Or is there a more idiomatic way to do what I am trying to achieve using SWIG? The buffer protocol typemaps seem from their <a href="http://www.swig.org/Doc1.3/Python.html#Python_nn75" rel="nofollow noreferrer">documentation</a> seemed to be designed for writing functions that accept buffers as arguments, whereas I want my wrapper type to implement the buffer protocol.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If you are writing you own class or structure, swig will build a python type for it, and all you have to do is add slots. Try %feature(python:slot). This feature can let you add arbitrary function/structures to generated python type slot. Also build your .i file using '-builtin' option, emit the unnecessary proxy python file.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to make Jacky's answer more explicit - you probably want to do something like:</p>
<pre><code>%{
static *PyBuffer mycoolbuffer_function(PyObject* self) {
    // get the C data for self
    // build your buffer
}
%}

%feature("python:tp_as_buffer") MyTypeThatWillBeWrapped "&amp;mycoolbuffer_function";
</code></pre>
<p>This is sort of untested, I'm analogizing from some work I'm doing with iterators. And it certainly requires the -builtin option.</p>
</div>
