<div class="post-text" itemprop="text">
<p>I want to measure the latency of zeromq between two python processes in high resolution(in a us/ns unit)(windows 10).</p>
<p>Here's my code.</p>
<p><strong>sub.py</strong></p>
<pre><code>import sys
import zmq
import time

port = "5556"
if len(sys.argv) &gt; 1:
    port =  sys.argv[1]
    int(port)

if len(sys.argv) &gt; 2:
    port1 =  sys.argv[2]
    int(port1)

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print('connecting to publisher')
socket.connect ("tcp://localhost:%s" % port)

if len(sys.argv) &gt; 2:
    socket.connect ("tcp://localhost:%s" % port1)
topicfilter = "10001"
socket.setsockopt_string(zmq.SUBSCRIBE, topicfilter)

total_value = 0
while True:
    string = socket.recv()
    got_time = time.time() # resolution in windows 10: 15.6ms
    topic, msgdata = string.split()
    dur = got_time - float(msgdata)
    print('it took %.5fms from pub' % (dur*1000))
</code></pre>
<p><strong>pub.py</strong></p>
<pre><code>import zmq
import random
import sys
import time

port = "5556"
if len(sys.argv) &gt; 1:
    port =  sys.argv[1]
    int(port)

context = zmq.Context()
socket = context.socket(zmq.PUB)
socket.bind("tcp://*:%s" % port)

topic = 10001
while True:
    msgdata = time.time() # resolution in windows 10: 15.6ms
    socket.send_string("%d %.5f" % (topic, msgdata))
    print("topic:%d, msg:%.5f" % (topic, msgdata))
    time.sleep(1)
</code></pre>
<p>However, since <code>time.time()</code> function's resolution in windows 10 is only 15.6ms(windows default timer period), I was unable to measure the latency below 15.6ms with code.</p>
<p>So I thought about using <code>time.perf_counter()</code> function, which have microsecond resolution, but it was also useless in measuring time difference of two process since <code>time.perf_counter()</code> function's reference point is undefined according to <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer">doc</a>.</p>
<p>Is there any other way to measure the time difference between two python processes in high resolution(microsecond or nanosecond unit)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, there is: ZeroMQ has a built-in tool for doing this, platform independent and indeed lovely to use.</p>
<pre><code>aClk = zmq.Stopwatch()                         // creates a Stopwatch instance
...
..
.
aClk.start();_=aProcessUnderTEST();aClk.stop() // measure an embedded latency
2169L                                          // &lt;-------------------latency[us]
</code></pre>
<p><strong><code>.stop()</code></strong> method returns a long number ( <code>1234L</code> ), representing a duration <strong>with a [us] resolution.</strong></p>
<p><strong>Hints:</strong> avoid any printing and memory-allocation operations when going down into testing performance details ( always <strong>pre-allocate</strong>, always rather assign a function's returning value, than to get interpreter's result-value repr/printing overheads included into the measurement-embedded section-of-code == <strong>avoid <code>repr()</code> overheads by assignment to <code>_</code></strong> ( special symbol ( variable ) without any allocation overhead ) ).</p>
<hr/>
<p>Still, there are points to solve ( or to be aware of ):</p>
<p><strong>- on distributed hosts,</strong> ( non-local process-starts/ends ) you need to find and synchronise a common reference-clock to compute meaningful differences, or one has to re-arrange the test to form a loop in message/signal delivery there-and-back to measure on the same refClk-side. For additional aspects of high-res clocks ( having sub-<code>1E-6</code> resolutions ), monotonicity ( immune to NTP-adjustments ), kindly check <strong><code>time.process_time()</code></strong>, <strong><code>time.perf_counters()</code></strong> and one may use more complex scenarios to measure differentially, as one message triggers beginning of test-measurement and the second arrival triggers end of the test-measurement, carrying the initiator-side inter-message duration ( processing, intended delay et al ) overhead ( in <code>[us]</code> ) as a payload ( to substitute from the result on the receiver side ). Anyway, be careful on below mentioned systematic uncertainties when dealing sub-<code>[us]</code>-events.</p>
<p><strong>- expect O/S interventions</strong> on various ZeroMQ transport-classes. The <strong><code>tcp://</code></strong> transport-class, for instance, is a subject of Windows buffering and there have been published heavily unpredictable deferred wireline transmits on Windows TCP/IP-stack ( google 'em, countermeasures exist, google 'em too ).</p>
<p><strong>- expect O/S scheduler</strong> influences on how <strong><code>aProcessUnderTEST</code></strong> is being executed amongst all other system + user processing and prioritised resources handling.</p>
</div>
