<div class="post-text" itemprop="text">
<p>Is it possible to construct a unicode string that the <code>utf-8</code> codec cannot encode?</p>
<p>From the documentation (<a href="https://docs.python.org/2/library/codecs.html" rel="nofollow noreferrer">https://docs.python.org/2/library/codecs.html</a>), it appears that the <code>utf-8</code> codec can encode a symbol in "any language". The docs also note when a codec can only encode certain characters or only the Basic Multilingual Plane. I don't know whether this is equivalent to saying "it is impossible to construct a <code>unicode</code> value that cannot be converted to a bytestring using the <code>utf-8</code> codec", however.</p>
<p>Here's the table entry for the <code>utf-8</code> codec.</p>
<blockquote>
<p>Codec   Aliases          Purpose </p>
<p>utf_8   U8, UTF, utf8  all languages</p>
</blockquote>
<p>The motivation here is that I have a utility function that takes either a unicode string or a byte string and converts it to a byte string. When given a byte string it is a no-op. This function is not supposed to throw an exception unless it is called with a non-string type and in that case it's supposed to fail informatively with a TypeError that will be caught later and logged. (We can still run into problems if the repr of the item we attempted to insert into the exception message is too big, but let's ignore that for now).</p>
<p>I'm using the <code>strict</code> setting because I want this function to throw an exception in the event that it encounters a unicode object that it cannot encode, but am hoping that that isn't possible.</p>
<pre><code>def utf8_to_bytes(item):
    """take a bytes or unicode object and convert it to bytes,
    using utf-8 if necessary"""
    if isinstance(item, bytes):
        return item
    elif isinstance(item, unicode):
        return codecs.encode(item, 'utf-8', 'strict')
    else:
        raise TypeError("item must be bytes or unicode. got %r" % type(item))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>UTF-8 is designed to encode all of the Unicode standard. Encoding Unicode text to UTF-8 will not normally throw an exception.</p>
<p>From the <a href="https://en.wikipedia.org/wiki/UTF-8" rel="nofollow noreferrer">Wikipedia article on the codec</a>:</p>
<blockquote>
<p>UTF-8 is a character encoding capable of encoding all possible characters, or code points, defined by Unicode</p>
</blockquote>
<p>The Python 2 UTF-8 encoding has no edge-cases that I know of; non-BMP data and surrogate pairs are handled just the same:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; hex(sys.maxunicode)  # a narrow UCS-2 build
'0xffff'
&gt;&gt;&gt; len(u'\U0001F525')
2
&gt;&gt;&gt; u'\U0001F525'.encode('utf-8')
'\xf0\x9f\x94\xa5'
&gt;&gt;&gt; u'\ud83d\udd25'
u'\U0001f525'
&gt;&gt;&gt; len(u'\ud83d\udd25')
2
&gt;&gt;&gt; u'\ud83d\udd25'.encode('utf-8')
'\xf0\x9f\x94\xa5'
</code></pre>
<p>Note that <code>strict</code> is the default encoding mode. You don't need to use the <code>codecs</code> module either, just use the <code>encode</code> method on the <code>unicode</code> object:</p>
<pre><code>return item.encode('utf-8')
</code></pre>
<p>In Python 3, the situation is slightly more complicated. Decoding and encoding <a href="https://en.wikipedia.org/wiki/UTF-16#U.2BD800_to_U.2BDFFF" rel="nofollow noreferrer"><em>surrogate pairs</em></a> is restricted; the official standard states such characters should only ever appear in UTF-16 encoded data, and then only in a low and high pair.</p>
<p>As such, you need to explicitly state that you want to support such codepoints with the <a href="https://docs.python.org/3/library/codecs.html#error-handlers" rel="nofollow noreferrer"><code>surrogatepass</code> error handler</a>:</p>
<blockquote>
<p>Allow encoding and decoding of surrogate codes. These codecs normally treat the presence of surrogates as an error.</p>
</blockquote>
<p>The only difference between <code>surrogatepass</code> and <code>strict</code> is that <code>surrogatepass</code> will allow you to encode any surrogate codepoints in your Unicode text to UTF-8. You'd only get such data in rare circumstances (defined as literals, or when accidentally leaving such codepoints unpaired in UTF-16 and then decoding using <code>surrogatepass</code>).</p>
<p>So, in Python 3, <em>only if you there is a chance your Unicode text could have been produced with a <code>surrogatepass</code> decode or from literal data</em>, you'd need to use <code>item.encode('utf8', 'surrogatepass')</code> to be absolutely certain all possible Unicode values can be encoded.</p>
</div>
<span class="comment-copy">I don't think my question is ill-informed. Yes, <code>utf-8</code> is capable of encoding any valid sequence of unicode codepoints ... but that doesn't mean a priori that it's impossible to construct a unicode object in python that isn't encodable.</span>
<span class="comment-copy">Can a unicode object in Python only store valid code points? Is there a way to insert an invalid UCS2 string or whatever encoding CPython uses internally into a unicode object? I'm just trying to understand if there are any possible weird edge cases where I could be handed an unencodeable unicode object that's still a unicode object from Python's perspective.</span>
<span class="comment-copy">@GregoryNisbet: I'm not currently aware of any way to do that in Python 2, even with the UCS2 narrow builds using UTF-16 surrogates internally.</span>
<span class="comment-copy">@GregoryNisbet: sample: <code>u'\U0001F525'.encode('utf-8')</code> encodes cleanly, even though <code>len(u'\U0001F525')</code> gives 2 on my narrow UCS2 build of Python 2.7.12.</span>
<span class="comment-copy">@GregoryNisbet: and even if you were to use a surrogate pair in a  literal, encoding to UTF-8 works just fine. Try <code>u'\ud861\udd37'.encode('utf-8')</code> for example.</span>
<span class="comment-copy">When I try <code>'\ud861\udd37'.encode('utf-8')</code> in Python 3.5.0 I get an error, <code>UnicodeEncodeError: 'utf-8' codec can't encode character '\ud861' in position 0: surrogates not allowed</code>. Surely that means it's an invalid code point by @GregoryNisbet's definition? Even if it's still valid in 2.7, there's no good reason to make porting difficult.</span>
