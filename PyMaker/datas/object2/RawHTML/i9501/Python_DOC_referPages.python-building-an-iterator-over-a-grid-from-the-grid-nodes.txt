<div class="post-text" itemprop="text">
<p>I am using python 3
I would like to start from a list of nodes in 3 dimensions and build a grid. 
I would like to avoid the construct</p>
<pre><code>import numpy as np
l = np.zeros(len(xv)*len(yv)*len(zv))
for (i,x) in zip(range(len(xv)),xv):
   for (j,y) in zip(range(len(yv)),yv):
       for (k,z) in zip(range(len(zv)),zv):
           l[i,j,k] = func(x,y,z)
</code></pre>
<p>I am looking for a more compact version of the above lines. An iterator like <code>zip</code>, but that would iterate on all possible tuple in the grid</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use something like <code>np.meshgrid</code> to construct your grid.  Assuming that <code>func</code> is properly vectorized, that should be good enough to construct <code>l</code></p>
<pre><code>X, Y, Z = np.meshgrid(xv, yv, zv)
l = func(X, Y, Z)
</code></pre>
<p>If <code>func</code> <em>isn't</em> vectorized, you can construct a vectorized version using <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html" rel="nofollow noreferrer"><code>np.vectorize</code></a>.</p>
<p>Also note that you might even be able to get away without using <code>np.meshgrid</code> through judicious use of <code>np.newaxis</code>:</p>
<pre><code>&gt;&gt;&gt; x
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; y
array([0, 1, 2])
&gt;&gt;&gt; z
array([0, 1])
&gt;&gt;&gt; def func(x, y, z):
...     return x + y + z
... 
&gt;&gt;&gt; vfunc = np.vectorize(func)
&gt;&gt;&gt; vfunc(x[:, np.newaxis, np.newaxis], y[np.newaxis, :, np.newaxis], z[np.newaxis, np.newaxis, :])
array([[[ 0,  1],
        [ 1,  2],
        [ 2,  3]],

       [[ 1,  2],
        [ 2,  3],
        [ 3,  4]],

       [[ 2,  3],
        [ 3,  4],
        [ 4,  5]],

       [[ 3,  4],
        [ 4,  5],
        [ 5,  6]],

       [[ 4,  5],
        [ 5,  6],
        [ 6,  7]],

       [[ 5,  6],
        [ 6,  7],
        [ 7,  8]],

       [[ 6,  7],
        [ 7,  8],
        [ 8,  9]],

       [[ 7,  8],
        [ 8,  9],
        [ 9, 10]],

       [[ 8,  9],
        [ 9, 10],
        [10, 11]],

       [[ 9, 10],
        [10, 11],
        [11, 12]]])
</code></pre>
<p>As pointed out in the comments, <code>np.ix_</code> can be used as a shortcut instead of <code>np.newaxis</code>:</p>
<pre><code>vfunc(*np.ix_(xv, yv, zv))
</code></pre>
<p><sup>Also note that with this stupid simple function, <code>np.vectorize</code> isn't necessary and will actually hurt our performance a lot...</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>Say your func is something like</p>
<pre><code>def func(x,y,z,indices):
    xv, yv, zv = [i[j] for i,j in zip((x,y,z),indices)]
    #do a calc with the value for the specific x,y,z points
</code></pre>
<p>Hook the lists you want to it using <a href="https://docs.python.org/3/library/functools.html" rel="nofollow noreferrer">partial</a> by doing</p>
<pre><code>from functools import partial
f = partial(func, x=xv, y=yv, z=zv)
</code></pre>
<p>Now just do a map supplying the indices and you're set!</p>
<pre><code>l = list(map(lambda x: f(indices=x), itertools.product(x,y,z)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With a simple function:</p>
<pre><code>def foo(x,y,z):
   return x**2 + y*2 + z
</code></pre>
<p>and space defined by:</p>
<pre><code>In [328]: xv, yv, zv = [np.arange(i) for i in [2,3,4]]
</code></pre>
<p>This iteration is as fast any as any, even if it is a bit wordy:</p>
<pre><code>In [329]: res = np.zeros((xv.shape[0], yv.shape[0], zv.shape[0]), dtype=int)
In [330]: for i,x in enumerate(xv):
     ...:     for j,y in enumerate(yv):
     ...:         for k,z in enumerate(zv):
     ...:             res[i,j,k] = foo(x,y,z)

In [331]: res
Out[331]: 
array([[[0, 1, 2, 3],
        [2, 3, 4, 5],
        [4, 5, 6, 7]],

       [[1, 2, 3, 4],
        [3, 4, 5, 6],
        [5, 6, 7, 8]]])
</code></pre>
<p>As <code>@mgilson</code> explains, you can generate 3 arrays that define the 3d space with:</p>
<pre><code>In [332]: I,J,K = np.meshgrid(xv,yv,zv,indexing='ij',sparse=True)
In [333]: I.shape
Out[333]: (2, 1, 1)
In [334]: J.shape
Out[334]: (1, 3, 1)
In [335]: I,J,K = np.ix_(xv,yv,zv)    # equivalently
In [336]: I.shape
Out[336]: (2, 1, 1)
</code></pre>
<p><code>foo</code> was written so it works with arrays just as well as with scalars, so:</p>
<pre><code>In [337]: res1 = foo(I,J,K)
In [338]: res1
Out[338]: 
array([[[0, 1, 2, 3],
      ...
        [5, 6, 7, 8]]])
</code></pre>
<p>So if your function fits this pattern, use it.  Look at those <code>I,J,K</code> arrays, with and without <code>sparse</code>. </p>
<p>There are other tools for generating the <code>i,j,k</code> sets.  For example:</p>
<pre><code>for i,j,k in np.ndindex(res.shape):
    res[i,j,k] = foo(xv[i], yv[j], zv[k])

for i,j,k in itertools.product(range(2),range(3),range(4)):
    res[i,j,k] = foo(xv[i], yv[j], zv[k])
</code></pre>
<p><code>itertools.product</code> is fast, especially when used as <code>list(product(...))</code>.  But the iteration mechanism isn't that important.  It's the repeated call to <code>foo</code> that take up most of the time.</p>
<p><code>ndindex</code> actually uses <code>nditer</code>, which can be used directly in:</p>
<pre><code>it = np.nditer([I,J,K,None],flags=['external_loop','buffered'])
for x,y,z,r in it:
    r[...] = foo(x,y,z)
it.operands[-1]
</code></pre>
<p><code>nditer</code> is best described in: 
<a href="https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html" rel="nofollow noreferrer">https://docs.scipy.org/doc/numpy/reference/arrays.nditer.html</a>.  It is best used as a stepping stone toward a cython version. Otherwise it doesn't have any speed advantages.  (Though with this <code>foo</code>, and 'external_loop' it is as fast as <code>foo(I,J,K)</code>).  Note that this doesn't need the indices (but see 'multi_index').</p>
<p>And yes, there's <code>vectorize</code>.  Convenient, but not a speedy solution.</p>
<pre><code>vfoo=np.vectorize(foo, otypes=['int'])
vfoo(I,J,K)
</code></pre>
</div>
<span class="comment-copy"><code>itertools.product</code>?</span>
<span class="comment-copy">A more pythonic iteration expression is: <code>for i,x in enumerate(xv):</code></span>
<span class="comment-copy">@juanpa.arrivillaga nice, but how do I get the opportune i (and j,k)?</span>
<span class="comment-copy">Tell us about <code>func</code>.  Does it only work with scalar <code>x,y,z</code> values, or does it accept arrays?  If arrays, how many dimensions?</span>
<span class="comment-copy">Since OP is looking for compact code, maybe we could suggest : <code>func(*np.meshgrid(xv,yv,zv))</code>. Also, it seems we would need a swapaxes there : <code>.swapaxes(0,1)</code>.</span>
<span class="comment-copy">Similarly, <code>np.ix_</code> could be used to create those extended arrays : <code>func(*np.ix_(xv,yv,zv))</code>.</span>
<span class="comment-copy">@Divakar -- Ahh yes.  I always forget about <code>np.ix_</code> for some reason...</span>
<span class="comment-copy">This is the kind of question we see again and again, 'how do I "vectorize" this function?'  or 'get rid of the loops'.  We can suggest various ways of generating a grid/mesh or broadcasting, but it really comes down to the nature of the <code>func</code>.  If it handles arrays the problem is trivial.  If it only works with scalars, it is impossible, except in the most superficial way.  If the problem is inherently serial, you have to pull out the <code>cumsum</code> guns, or resort to cython.</span>
<span class="comment-copy">@hpaulj -- Yeah, but this question wasn't necessarily about performance -- It was more about "How can I write this in a nicer way" (at least that's how I read it).  And so the "superficial" treatment (e.g. <code>np.vectorize</code>) may very well be good enough for this answer.  I agree that this is a near impossible question to answer without knowing <code>func</code> if we care about how long the solution takes to execute.</span>
