<div class="post-text" itemprop="text">
<p>I am currently having a problem, which i have to sort a list of path. 
the file which the path lead to is named as such a-b-c.wav.</p>
<p>These path are given to a function which outputs two list, </p>
<p>a list of the sampled_sounds - (<code>raw_sounds</code>)</p>
<p>a list of the file_names_of_sampled_audio - (<code>data_name</code>).</p>
<p>The function: </p>
<pre><code>def load_sound_files(file_paths):
    raw_sounds = []
    data_output = []
    data_name = []
    max = 0
    for fp in file_paths:
        y,sr = librosa.load(fp,sr=16000)
        X = librosa.util.frame(y, frame_length=400, hop_length=160)
        raw_sounds.append(X.T)
        if max &lt; (X.shape)[1]:
            max = (X.shape)[1]
            print "New max " + str((X.shape)[1])
        index_file = list(find_all(fp,'/'))
        filename = fp[index_file[len(index_file)-1]+1:len(fp)-4]
        file_name = filename.split('-')
        file_name = file_name[1]+'-'+file_name[2]+'-'+file_name[0]
        data_name.append(file_name)
    return raw_sounds, data_name
</code></pre>
<p>The function start by sampling the audio.
After the audio has been sampled, is the name renamed to
b-c-a.wav.</p>
<p>The sampled audio is appended to the list <code>raw_sounds</code>
the new name is appended to list <code>data_name</code>. </p>
<p>The problem here is that i need to sort the list <code>data_name</code>
but at the same time ensure that the list with the <code>raw_sounds</code> is still listed correctly according to the name in <code>data_name</code>.. </p>
<p>I guess i would have to implement sorting manually, example of the name:</p>
<pre><code>mblw-b-an1 
mdcs2-b-an111 
mdcs2-b-an112 
mdcs2-b-an113 
mdcs2-b-an114 
mdcs2-b-an115 
fmjc-b-an116 
fmjc-b-an117 
fmjc-b-an118 
fmjc-b-an119 
fmjc-b-an120 
fjdn-b-an121 
fjdn-b-an122 
</code></pre>
<p>How do i sort something like this, while also reordering raw_sound, so both entries in <code>data_name</code> and <code>raw_sounds</code> contains the correct data. </p>
<p>Edit: </p>
<p>The solution i ended up using was this:</p>
<pre><code>def resort(data_names, raw_sounds):
    data_names_bak = data_names
    data_names_sorted = sorted(data_names)
    raw_sound_output = []
    for i in range(0,len(data_names)):
        index = data_names.index(data_names_sorted[i])
        raw_sound_output.append(raw_sounds[index])
    return raw_sound_output, data_names_sorted
</code></pre>
<p>I will keep this open, in case there is a builtin solution, that i didn't know of. </p>
</div>
<div class="post-text" itemprop="text">
<p>I would rather have both in the same list as a tuple or use a dictionary</p>
<p>also if that <code>find_all</code> is what I think it is, then the <a href="https://docs.python.org/3/library/os.path.html" rel="nofollow noreferrer"><code>os.path</code></a> module have a function for just that</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; test="/path/to/my_audio/file.wav"
&gt;&gt;&gt; os.path.basename(test)
'file.wav'
&gt;&gt;&gt; 
</code></pre>
<p>then your function can be rewrite as </p>
<pre><code>import os

def load_sound_files(file_paths):
    data_output = []
    max = 0
    for fp in file_paths:
        y,sr = librosa.load(fp,sr=16000)
        X = librosa.util.frame(y, frame_length=400, hop_length=160)
        if max &lt; (X.shape)[1]:
            max = (X.shape)[1]
            print "New max:", (X.shape)[1]
        file_name = os.path.basename(fp)[:-4].split('-')
        file_name = file_name[1]+'-'+file_name[2]+'-'+file_name[0]
        data_output.append( (file_name,X.T) )
    data_output.sort(key=lambda x: x[0])
    return data_output
    #return [ x[1] for x in data_output], [ x[0] for x in data_output  ]
    #use the commented return instead for obtain the lists with each 
    #part individually  
</code></pre>
<p>also notice that you can use negative indexes <code>some_list[-n]</code> which is equivalent to <code>some_list[len(some_list)-n]</code></p>
<hr/>
<p>with the suggestions of <em>EvensF</em>, you can include the file extension and/or work with files which have extension of different length like .midi, to mention one, without needed to modify the code. Like this for instance</p>
<pre><code>name, ext = os.path.splitext( os.path.basename(fp) )
file_name = "{0[1]}-{0[2]}-{0[0]}".format(name.split("-")) + ext
</code></pre>
<p>(that way you don't need to later add the extension, or worry about what that is later in case you have multiples ones)</p>
</div>
<div class="post-text" itemprop="text">
<p>If I get it right you just want two sort the to lists:</p>
<pre><code>zipped_list = zip(data_names, raw_sounds)
zipped_list.sort(key=lambda (data_names, raw_sounds): data_names)
</code></pre>
<p>This gives you a sorted zipped list.</p>
<pre><code>data_names, raw_sounds = zip(*zipped_list)
</code></pre>
<p>can undo the zipping.</p>
<hr/>
<p>If you use python 2.x consider using <code>itertools.izip</code> to work with iterator instead of lists.</p>
</div>
<span class="comment-copy">Does it help? <a href="http://stackoverflow.com/questions/13668393/python-sorting-two-lists" title="python sorting two lists">stackoverflow.com/questions/13668393/python-sorting-two-lists</a></span>
<span class="comment-copy">We don't really need to know about paths, filenames, etc. It's not really relevant to the problem. See how to create a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">@IlyaV.Schurov thanks for the link.. I am not sure how i can't test it..  the data list is pretty huge..</span>
<span class="comment-copy">@IlyaV.Schurov Unfortunately it doesn't work.  <code>list1, list2 = (list(x) for x in zip(*sorted(zip(list1, list2), key=lambda pair: pair[0]))) ValueError: operands could not be broadcast together with shapes (468,400) (288,400) </code></span>
<span class="comment-copy">Your answer mirrors what I had in mind except for a few minor details: I think the original poster wanted the filename without the extension (<code>os.path.basename(fp)[:-4]</code>). You could have used <code>os.path.splitext()</code> for that. And the new filename (<code>file_name[1]+'-'+file_name[2]+'-'+file_name[0]</code>) could have been reconstructed with a formating string (<code>file_name = "{0[1]}-{0[2]}-{0[0]}".format(file_name)</code>) but like I said this is minor.</span>
<span class="comment-copy">@EvensF nice points, I always forget the full power of str.format</span>
