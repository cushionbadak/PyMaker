<div class="post-text" itemprop="text">
<p>How do I convert an unsigned integer (representing a user ID) to a random looking but actually a deterministically repeatable choice? The choice must be selected with equal probability (irrespective of the distribution of the the input integers). For example, if I have 3 choices, i.e. <code>[0, 1, 2]</code>, the user ID 123 may always be randomly assigned choice 2, whereas the user ID 234 may always be assigned choice 1.</p>
<p>Cross-language and cross-platform algorithmic reproducibility is desirable. I'm inclined to use a hash function and modulo unless there is a better way. Here is what I have:</p>
<pre><code>&gt;&gt;&gt; num_choices = 3
&gt;&gt;&gt; id_num = 123
&gt;&gt;&gt; int(hashlib.sha256(str(id_num).encode()).hexdigest(), 16) % num_choices
2
</code></pre>
<p>I'm using the latest stable Python 3. Please note that this question is similar but not exactly identical to the related question to <a href="https://stackoverflow.com/questions/44556105/convert-string-to-random-but-deterministically-repeatable-uniform-probability">convert a string to random but deterministically repeatable uniform probability</a>.</p>
</div>
<div class="post-text" itemprop="text">
<h3>Using hash and modulo</h3>
<pre><code>import hashlib

def id_to_choice(id_num, num_choices):
    id_bytes = id_num.to_bytes((id_num.bit_length() + 7) // 8, 'big')
    id_hash = hashlib.sha512(id_bytes)
    id_hash_int = int.from_bytes(id_hash.digest(), 'big')  # Uses explicit byteorder for system-agnostic reproducibility
    choice = id_hash_int % num_choices  # Use with small num_choices only
    return choice

&gt;&gt;&gt; id_to_choice(123, 3)
0
&gt;&gt;&gt; id_to_choice(456, 3)
1
</code></pre>
<p>Notes:</p>
<ul>
<li><p>The built-in
<a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>hash</code></a>
method must not be used because it can preserve the input's
distribution, e.g. with <code>hash(123)</code>. Alternatively, it can return values that differ when Python is restarted, e.g. with <code>hash('123')</code>.</p></li>
<li><p>For converting an int to bytes, <code>bytes(id_num)</code> works but is grossly inefficient as it returns an array of null bytes, and so it must not be used. Using <a href="https://docs.python.org/library/stdtypes.html#int.to_bytes" rel="nofollow noreferrer"><code>int.to_bytes</code></a> is better. Using <code>str(id_num).encode()</code> works but wastes a few bytes.</p></li>
<li><p>Admittedly, using modulo doesn't offer exactly uniform probability,<a href="https://stackoverflow.com/questions/13104478/uniformity-of-random-numbers-taken-modulo-n">[1]</a><a href="https://stackoverflow.com/questions/10984974/why-do-people-say-there-is-modulo-bias-when-using-a-random-number-generator">[2]</a> but this shouldn't bias much for this application because <code>id_hash_int</code> is expected to be very large and <code>num_choices</code> is assumed to be small.</p></li>
</ul>
<h3>Using random</h3>
<p>The <a href="https://docs.python.org/library/random.html" rel="nofollow noreferrer"><code>random</code></a> module can be used with <code>id_num</code> as its seed, while addressing concerns surrounding both <a href="https://stackoverflow.com/questions/10021882/make-the-random-module-thread-safe-in-python">thread safety</a> and continuity. Using <code>randrange</code> in this manner is comparable to and simpler than hashing the seed and taking modulo.</p>
<p>With this approach, not only is cross-language reproducibility a concern, but reproducibility across multiple future versions of Python could also be a concern. It is therefore not recommended.</p>
<pre><code>import random

def id_to_choice(id_num, num_choices):
    localrandom = random.Random(id_num)
    choice = localrandom.randrange(num_choices)
    return choice

&gt;&gt;&gt; id_to_choice(123, 3)
0
&gt;&gt;&gt; id_to_choice(456, 3)
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative is to encrypt the user ID.  If you keep the encryption key the same, then each input number will encrypt to a different output number up to the block size of the cipher you use. DES uses 64 bit blocks which cover IDs 000000 to 18446744073709551615.  That will give a random appearing replacement for the user ID, which is guaranteed not to give two different user IDs the same 'random' number because encryption is a one-to-one permutation of the block values.</p>
</div>
<div class="post-text" itemprop="text">
<p>I apologize I don't have Python implementation but I do have very clear, readable and self evident implementation in Java which should be easy to translate into Python with minimal effort. The following produce long predictable evenly distributed sequences covering all range except zero</p>
<p><strong>XorShift</strong> ( <a href="http://www.arklyffe.com/main/2010/08/29/xorshift-pseudorandom-number-generator" rel="nofollow noreferrer">http://www.arklyffe.com/main/2010/08/29/xorshift-pseudorandom-number-generator</a> )</p>
<pre><code>public int nextQuickInt(int number) {
    number ^= number &lt;&lt; 11;
    number ^= number &gt;&gt;&gt; 7;
    number ^= number &lt;&lt; 16;
    return number;
}

public short nextQuickShort(short number) {
    number ^= number &lt;&lt; 11;
    number ^= number &gt;&gt;&gt; 5;
    number ^= number &lt;&lt; 3;
    return number;
}

public long nextQuickLong(long number) {
    number ^= number &lt;&lt; 21;
    number ^= number &gt;&gt;&gt; 35;
    number ^= number &lt;&lt; 4;
    return number;
}
</code></pre>
<p>or <strong>XorShift128Plus</strong> (need to re-seed state0 and state1 to non-zero values before using, <a href="http://xoroshiro.di.unimi.it/xorshift128plus.c" rel="nofollow noreferrer">http://xoroshiro.di.unimi.it/xorshift128plus.c</a>)</p>
<pre><code>public class XorShift128Plus {

private long state0, state1; // One of these shouldn't be zero

public long nextLong() {
    long state1 = this.state0;
    long state0 = this.state0 = this.state1;
    state1 ^= state1 &lt;&lt; 23;
    return (this.state1 = state1 ^ state0 ^ (state1 &gt;&gt; 18) ^ (state0 &gt;&gt; 5)) + state0;
}

public void reseed(...) {
    this.state0 = ...;
    this.state1 = ...;
}

}
</code></pre>
<p>or <strong>XorOshiro128Plus</strong> (<a href="http://xoroshiro.di.unimi.it/" rel="nofollow noreferrer">http://xoroshiro.di.unimi.it/</a>)</p>
<pre><code>public class XorOshiro128Plus {

private long state0, state1; // One of these shouldn't be zero

public long nextLong() {
    long state0 = this.state0;
    long state1 = this.state1;
    long result = state0 + state1;
    state1 ^= state0;
    this.state0 = Long.rotateLeft(state0, 55) ^ state1 ^ (state1 &lt;&lt; 14);
    this.state1 = Long.rotateLeft(state1, 36);
    return result;
}

public void reseed() {

}

}
</code></pre>
<p>or <strong>SplitMix64</strong> (<a href="http://xoroshiro.di.unimi.it/splitmix64.c" rel="nofollow noreferrer">http://xoroshiro.di.unimi.it/splitmix64.c</a>)</p>
<pre><code>public class SplitMix64 {

private long state;

public long nextLong() {
    long result = (state += 0x9E3779B97F4A7C15L);
    result = (result ^ (result &gt;&gt; 30)) * 0xBF58476D1CE4E5B9L;
    result = (result ^ (result &gt;&gt; 27)) * 0x94D049BB133111EBL;
    return result ^ (result &gt;&gt; 31);
}

public void reseed() {
    this.state = ...;
}
}
</code></pre>
<p>or <strong>XorShift1024Mult</strong> (<a href="http://xoroshiro.di.unimi.it/xorshift1024star.c" rel="nofollow noreferrer">http://xoroshiro.di.unimi.it/xorshift1024star.c</a>) or <strong>Pcg64_32</strong> (<a href="http://www.pcg-random.org/" rel="nofollow noreferrer">http://www.pcg-random.org/</a>, <a href="http://www.pcg-random.org/download.html" rel="nofollow noreferrer">http://www.pcg-random.org/download.html</a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest method is to modulo <code>user_id</code> by number of options:</p>
<pre><code>choice = user_id % number_of_options
</code></pre>
<p>It's very easy and fast. However if you know user_id's you may to guess an algorithm. </p>
<p>Also, pseudorandom sequences can be obtained from <code>random</code> seeded with user constants (e.g. <code>user_id</code>):</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; def generate_random_value(user_id):
...     random.seed(user_id)
...     return random.randint(1, 10000)
...
&gt;&gt;&gt; [generate_random_value(x) for x in range(20)]
[6312, 2202, 927, 3899, 3868, 4186, 9402, 5306, 3715, 7586, 9362, 7412, 7776, 4244, 1751, 3424, 5924, 8553, 2970, 709]
&gt;&gt;&gt; [generate_random_value(x) for x in range(20)]
[6312, 2202, 927, 3899, 3868, 4186, 9402, 5306, 3715, 7586, 9362, 7412, 7776, 4244, 1751, 3424, 5924, 8553, 2970, 709]
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">In your real application, what's the domain of the user ID integers, and how big is the choice set? And how secure do you wan this randomization to be? Does it just have to look random-ish, or would you like something that's cryptographically strong?</span>
<span class="comment-copy">@PM2Ring I do not know the domain of the user ID integers by they could be a 32 or 64 bit unsigned int obtained from a database. The choice set length is 2 to 10. Cryptographic randomness is not necessary, but repeatability and equiprobability are.</span>
<span class="comment-copy">I assume that "choice set length is 2 to 10" means that there at most 10 choices, rather than that the number of choices could be a 10 digit number. If the former is true, then it'd be pretty hard to make it cryptographically strong. :) But you may still be interested in the topic of <a href="https://en.wikipedia.org/wiki/Format-preserving_encryption" rel="nofollow noreferrer">format-preserving encryption</a>.</span>
<span class="comment-copy">@PM2Ring To clarify the domain of choices, yes, there are at most 10 choices that are to be used in a statistical A/B testing or similar experiment. I do not understand what relation this has to cryptography.</span>
<span class="comment-copy">The condition <i>The choices must be selected with equal probability</i> is not well defined unless you explain this in terms of random variables. Which quantities need to be equal ? I think this ambiguity hides an impossible task.</span>
<span class="comment-copy">So what do these four (non-Python) PRNGs provide that's better than A-B-B's answer, to the point where OP would want to port them?</span>
<span class="comment-copy">Options sir. This answer is not better, it rather compliments the first answer with alternatives. The focus is not even on these 6 specific alternatives but rather direction to look and explore.</span>
<span class="comment-copy">This is not random at all.</span>
