<div class="post-text" itemprop="text">
<p>I'm trying to make a quick Python script to rename a bunch of files. These files were made in a Linux system on this NTFS drive, but I'm now on Windows. The naming convention looks like this:</p>
<pre><code>Screenshot at 2016-12-11 21:12:56.png
</code></pre>
<p>The <code>:</code> character is illegal in Windows filenames, so the behaviour of this script is a little strange to me.</p>
<pre><code>for i in os.listdir("."):
    print(i)
    x = i.replace(":", "-")
    comm = """mv "{}" "{}" """.format(i, x)
    os.system(comm)
</code></pre>
<p>In the above code, the <code>print(i)</code> prints the filenames happily. However when I try to run <code>os.system(comm)</code> to rename my files, I get this error:</p>
<pre><code>mv: cannot stat ‘Screenshot at 2016-12-24 14:54:57.png’: No such file or directory
</code></pre>
<p>Firstly, I find it a little strange that Python under Windows can tell that these naughty files exist, but isn't able to actually move them. Secondly, what's the best way to get around this issue? </p>
<p>I've also tried <code>shutil.move()</code> and <code>os.rename()</code> with no luck. <a href="https://stackoverflow.com/questions/10386344/how-to-get-a-file-in-windows-with-a-colon-in-the-filename">This</a> SO question seems to discuss the issue, but seems more concerned with prevention than fixing it. I could obviously switch back to Linux and fix it, but I'm wondering if I can't fix it on Windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can find them because they're in the directory. You can't access them, because the colon symbol is parsed differently in a path. This means the files cannot be reached by common path functions including <code>MoveFile</code>. You basically have two options: finding a method that doesn't rely on the name, like <code>OpenFileById</code>, or finding an alternate name for the file, like <code>dir /x</code>. The latter gets you the short name (8.3), which should not contain any colons. I don't know if there's a ready function to access those names from Python, so the shortest clear (to me) workaround is executing <code>dir /x</code> and parsing its output. </p>
<p>I think <a href="https://docs.python.org/3/library/os.html#dir-fd" rel="nofollow noreferrer" title="paths relative to directory descriptors">paths relative to directory descriptors</a> is as close as Python's standard library gets to the first method, but I don't know if it would be enough. The underlying FindFirstFile/FindNextFile functions do produce both names in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365740(v=vs.85).aspx" rel="nofollow noreferrer">WIN32_FIND_DATA</a> (cFileName and cAlternateFileName), but Python expects the first one to be valid. Either method would also have made sense in PowerShell, but it looks like it is wholly unaware of short names and also tracks files by name, not IDs. Otherwise <a href="https://msdn.microsoft.com/en-us/library/system.io.fileinfo.moveto(v=vs.110).aspx" rel="nofollow noreferrer">FileInfo.MoveTo</a> would've done the trick neatly. </p>
<p>To prevent this situation in the first place, <a href="http://www.tuxera.com/community/open-source-ntfs-3g/" rel="nofollow noreferrer">ntfs-3g</a> supports a <code>windows_names</code> option. This causes it to balk when trying to create the files. </p>
<p>Conclusion: as discussed in <a href="https://superuser.com/questions/31587/how-to-force-windows-to-rename-a-file-with-a-special-character">https://superuser.com/questions/31587/how-to-force-windows-to-rename-a-file-with-a-special-character</a> there is no clear solution. All of my attempted methods (and a handful others) have been discussed there. Probably the least messy option is to mount the disk in Linux again and rename from there; the filesystem is technically corrupt because the characters are invalid, but Microsoft's repair solution is deletion, not renaming. </p>
<p>Cygwin merely emulated the colon by using a private unicode character (':'+0xf000). </p>
</div>
<span class="comment-copy">you mix <code>"""</code> with <code>"</code>. does that work? should it not be <code>'mv "{}" "{}"'.format(i, x)</code> (no need for multi-line here)?</span>
<span class="comment-copy">I would use <code>os.rename()</code> instead of a system call.</span>
<span class="comment-copy">so the <code>mv</code> you are using, is it the MSYS/Cygwin flavour on windows?</span>
<span class="comment-copy">@hiroprotagonist Yes it works, no doubt yours would too I just prefer the multi-line. @Jean <code>os.rename()</code> also doesn't work, and the <code>mv</code> is the <code>mv</code> offered in the Linux subsystem of Windows 10. Officially known as Bash on Ubuntu on Windows (Microsoft keeping it concise as always).</span>
<span class="comment-copy">@Daniel, WSL's <code>mv</code> command should require <code>bash -c "mv ..."</code>, and you'd have to use the <code>/mnt</code> folder. Run <code>where mv</code> to see what <code>mv</code> is executing.</span>
<span class="comment-copy">Does the NTFS filesystem driver in Linux default to creating the 8.3 DOS names? Even in Windows, creating short names can be disabled per volume or in general. If you don't have short names, unfortunately opening by file ID will not work. NTFS supports file hard links, so it immediately fails attempts to rename or delete a file by ID because the target name is ambiguous. The file has to be opened by name.</span>
<span class="comment-copy">Actually, it's unlikely anything was written with Linux' ntfs driver; it's more common to use ntfs-3g. Its documentation mentions an option <code>windows_names</code> to forbid filenames like these, and that they should be valid on Windows using the Posix layer. Indeed, it looks like they are usable in Cygwin, which should be a cleaner solution.</span>
<span class="comment-copy">I tried using the <code>windows_names</code> option when mounting an NTFS volume, but it didn't automatically create DOS 8.3 names. I had to manually add the short name to the file record via <code>setfattr -h -v "DOS_NAME.EXT" -n system.ntfs_dos_name "Windows long filename.ext"</code>.</span>
<span class="comment-copy">Also, the NTFS filesystem driver in Windows absolutely does not support filenames containing any of the 5 wildcard characters (*?&lt;&gt;"). They're reserved for wildcard matching in <code>NtfsQueryDirectoryFile</code> (the system call for listing a directory). If any name contains a wildcard character, the call fails with <code>STATUS_FILE_CORRUPT_ERROR</code> (0xC0000102). Names containing control characters, slashes, pipe, and colon can be listed, but such files cannot be opened by name, not even by the new Linux subsystem under <code>/mnt</code> -- and certainly not by Cygwin, which just uses standard NT system calls.</span>
<span class="comment-copy">Maybe Cygwin smuggles invalid filenames in an NTFS named stream, or some other clever workaround. The root filesystem (VolFs) in the new Linux subsystem smuggles invalid characters by escaping them, e.g. "test*?&lt;&gt;":\|.txt" is stored as "test#002A#003F#003C#003E#0022#003A#005C#007C.txt".</span>
