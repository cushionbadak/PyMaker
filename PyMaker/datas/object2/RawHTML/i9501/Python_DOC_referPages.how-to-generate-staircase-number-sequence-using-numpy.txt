<div class="post-text" itemprop="text">
<p>I'm trying to generate a list of number sequences using python, like below.</p>
<pre><code>[0,0,0,0] [0,0,0,1] [0,0,0,2] [0,0,1,1] [0,0,1,2] [0,0,2,2] [0,1,1,1]
[0,1,1,2] [0,1,2,2] [0,2,2,2] [1,1,1,1] [1,1,1,2] ... [2,2,2,2]
</code></pre>
<p>Right now, I can do this using pure python with a recursive call, but it takes a lot of time for a single run (a few hours). I wonder if it's possible to do this with numpy and save a huge amount of time, and if yes, how?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you're looking for is <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" rel="nofollow noreferrer"><code>itertools.combinations_with_replacement</code></a>. From the docs:</p>
<blockquote>
<p><code>combinations_with_replacement('ABCD', 2)
  AA AB AC AD BB BC BD CC CD DD</code></p>
</blockquote>
<p>Hence:</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; list(it.combinations_with_replacement((0, 1, 2), 4))
[(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 0, 2),
 (0, 0, 1, 1), (0, 0, 1, 2), (0, 0, 2, 2),
 (0, 1, 1, 1), (0, 1, 1, 2), (0, 1, 2, 2),
 (0, 2, 2, 2), (1, 1, 1, 1), (1, 1, 1, 2),
 (1, 1, 2, 2), (1, 2, 2, 2), (2, 2, 2, 2)]
</code></pre>
<p>The best part of this method is that since it returns a generator, you can iterate over it without storing it. This is a huge plus, since it'll save you a <em>lot</em> of memory.</p>
<h3>Other implementations and timing</h3>
<p>Here are some more implementations, including a numpy implementation. <code>combinations_with_replacement</code> (the <code>try2</code> function) appears to be the fastest:</p>
<pre><code>import itertools as it
import timeit

import numpy as np

def try1(n, m):
    return [t for t in it.product(range(n), repeat=m) if all(a &lt;= b for a, b in zip(t[:-1], t[1:]))]

def try2(n, m):
    return list(it.combinations_with_replacement(range(n), m))

def try3(n, m):
    a = np.mgrid[(slice(0, n),) * m] # All points in a 3D grid within the given ranges
    a = np.rollaxis(a, 0, m + 1)     # Make the 0th axis into the last axis
    a = a.reshape((-1, m))           # Now you can safely reshape while preserving order
    return a[np.all(a[:, :-1] &lt;= a[:, 1:], axis=1)]

&gt;&gt;&gt; %timeit b = try1(3, 4)
10000 loops, best of 3: 78.1 µs per loop
&gt;&gt;&gt; %timeit b = try2(3, 4)
The slowest run took 8.04 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.66 µs per loop
&gt;&gt;&gt; %timeit b = try3(3, 4)
10000 loops, best of 3: 97.8 µs per loop
</code></pre>
<p>This is true even for bigger numbers:</p>
<pre><code>&gt;&gt;&gt; %timeit b = try1(3, 6)
1000 loops, best of 3: 654 µs per loop
&gt;&gt;&gt; %timeit b = try2(3, 6)
The slowest run took 7.20 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 2.33 µs per loop
&gt;&gt;&gt; %timeit b = try3(3, 6)
10000 loops, best of 3: 166 µs per loop
</code></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>I was using python3</li>
<li>I used <a href="https://stackoverflow.com/a/3755410/525169">this answer</a> for the implementation of <code>try1</code>.</li>
<li>I used <a href="https://stackoverflow.com/a/27286794/525169">this answer</a> for the implementation of <code>try3</code>.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>do you mean this (or how is the sequence you mean defined)?</p>
<pre><code>from itertools import product

for item in product((0, 1, 2), repeat=4):
    print(item)
</code></pre>
<p>this prints:</p>
<pre><code>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 1, 2)
...
(2, 2, 1, 2)
(2, 2, 2, 0)
(2, 2, 2, 1)
(2, 2, 2, 2)
</code></pre>
<p>not sure if that is what you are looking for, but <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> is included in python.</p>
<p>this should be fast and memory-efficient. the lists are created on demand.</p>
<p>...on second thought: this is probably what you mean, right?</p>
<pre><code>for a, b, c, d in product((0, 1, 2), repeat=4):
    if not a &lt;= b &lt;= c &lt;= d:
        continue
    print(a,b,c,d)
</code></pre>
<p>with output:</p>
<pre><code>0 0 0 0, 0 0 0 1, 0 0 0 2, 0 0 1 1, 0 0 1 2, 0 0 2 2, 0 1 1 1, 
0 1 1 2, 0 1 2 2, 0 2 2 2, 1 1 1 1, 1 1 1 2, 1 1 2 2, 1 2 2 2, 
2 2 2 2, 
</code></pre>
<p>and now i see how you would want that more efficient...</p>
<p>looks like <a href="https://stackoverflow.com/a/41422171/4954037">Praveen's answer</a> provides just that.</p>
</div>
<span class="comment-copy">Take time to read this post on how to compose a good SO question:  <a href="http://stackoverflow.com/help/how-to-ask">stackoverflow.com/help/how-to-ask</a>  Hint: Include code you have tried.</span>
<span class="comment-copy">excellent! ...i was too lazy to go on with this.</span>
