<div class="post-text" itemprop="text">
<p>I am taking a udacity course on python where we are supposed to check for profane words in a document. I am using the website <a href="http://www.wdylike.appspot.com/?q=" rel="nofollow noreferrer">http://www.wdylike.appspot.com/?q=</a> (text_to_be_checked_for_profanity). The text to be checked can be passed as a query string in the above URL and the website would return a true or false after checking for profane words. Below is my code. </p>
<pre><code>import urllib.request

# Read the content from a document
def read_content():

    quotes = open("movie_quotes.txt")
    content = quotes.read()
    quotes.close()
    check_profanity(content)



def check_profanity(text_to_read):
    connection = urllib.request.urlopen("http://www.wdylike.appspot.com/?q="+text_to_read)
    result = connection.read()
    print(result)
    connection.close

read_content()
</code></pre>
<p>It gives me the following error</p>
<blockquote>
<p>Traceback (most recent call last):   File
  "/Users/Vrushita/Desktop/Rishit/profanity_check.py", line 21, in
  
      read_content()   File "/Users/Vrushita/Desktop/Rishit/profanity_check.py", line 11, in
  read_content
      check_profanity(content)   File "/Users/Vrushita/Desktop/Rishit/profanity_check.py", line 16, in
  check_profanity
      connection = urllib.request.urlopen("<a href="http://www.wdylike.appspot.com/?q=" rel="nofollow noreferrer">http://www.wdylike.appspot.com/?q=</a>"+text_to_read)
  File
  "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py",
  line 163, in urlopen
      return opener.open(url, data, timeout)   File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py",
  line 472, in open
      response = meth(req, response)   File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py",
  line 582, in http_response
      'http', request, response, code, msg, hdrs)   File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py",
  line 510, in error
      return self._call_chain(*args)   File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py",
  line 444, in _call_chain
      result = func(*args)   File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py",
  line 590, in http_error_default
      raise HTTPError(req.full_url, code, msg, hdrs, fp) urllib.error.HTTPError: HTTP Error 400: Bad Request</p>
</blockquote>
<p>The document that I am trying to read the content from contains a string  "<strong>Hello world</strong>" However, if I change the string to "<strong>Hello+world</strong>", the same code works and returns the desired result. Can someone explain why this is happening and what is a workaround for this?  </p>
</div>
<div class="post-text" itemprop="text">
<p><code>urllib</code> accepts it, the <em>server</em> doesn't. And well it should not, because a space is not a <a href="https://en.wikipedia.org/wiki/Percent-encoding#Types_of_URI_characters" rel="noreferrer">valid URL character</a>.</p>
<p>Escape your query string properly with <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.quote_plus" rel="noreferrer"><code>urllib.parse.quote_plus()</code></a>; it'll unsure your string is <a href="https://en.wikipedia.org/wiki/Percent-encoding#The_application.2Fx-www-form-urlencoded_type" rel="noreferrer">valid for use in query parameters</a>. Or better still, use the <a href="https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlencode" rel="noreferrer"><code>urllib.parse.urlencode()</code> function</a> to encode all key-value pairs:</p>
<pre><code>from urllib.quote import urlencode

params = urlencode({'q': text_to_read})
connection = urllib.request.urlopen("http://www.wdylike.appspot.com/?" + params)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The below response is for python 3.*
400 Bad request occurs when there is space within your input text.
To avoid this use parse. 
so import it. </p>
<pre><code>from urllib import request, parse
</code></pre>
<p>If you are sending any text along with the url then parse the text. </p>
<pre><code>url = "http://www.wdylike.appspot.com/?q="
url = url + parse.quote(input_to_check) 
</code></pre>
<p>Check the explanation here - <a href="https://discussions.udacity.com/t/problem-in-profanity-with-python-3-solved/227328" rel="nofollow noreferrer">https://discussions.udacity.com/t/problem-in-profanity-with-python-3-solved/227328</a></p>
<p>The Udacity profanity checker program - </p>
<pre><code>from urllib import request, parse

def read_file():
    fhand = open(r"E:\Python_Programming\Udacity\movie_quotes.txt")
    file_content = fhand.read()
    #print (file_content)
    fhand.close()
    profanity_check(file_content)

def profanity_check(input_to_check):
    url = "http://www.wdylike.appspot.com/?q="
    url = url + parse.quote(input_to_check)
    req = request.urlopen(url)
    answer = req.read()
    #print(answer)
    req.close()

    if b"true" in answer:
        print ("Profanity Alret!!!")
    else:
        print ("Nothing to worry")


read_file()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this code is closer to what the Lesson was aiming to, inferencing the difference between native functions, classes and functions inside classes:</p>
<pre><code>from urllib import request, parse

def read_text():
    quotes = open('C:/Users/Alejandro/Desktop/movie_quotes.txt', 'r+')
    contents_of_file = quotes.read()
    print(contents_of_file)
    check_profanity(contents_of_file)
    quotes.close()

def check_profanity(text_to_check):
    connection = request.urlopen('http://www.wdylike.appspot.com/?q=' + parse.quote(text_to_check))
    output = connection.read()
    # print(output)
    connection.close()

    if b"true" in output:
        print("Profanity Alert!!!")
    elif b"false" in output:
        print("This document has no curse words!")
    else:
        print("Could not scan the document properly")

read_text()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm working on the same project also using Python 3 like the most. </p>
<p>While looking for the solution in Python 3, I found <a href="http://wolfprojects.altervista.org/articles/change-urllib-user-agent/" rel="nofollow noreferrer">this HowTo</a>, and I decided to give it a try. </p>
<p>It seems that on some websites, including Google, connections through programming code (for example, via the urllib module), sometimes does not work properly. Apparently this has to do with the User Agent, which is recieved by the website when building the connection. </p>
<p>I did some further researches and came up with the following solution: </p>
<p>First I imported <code>URLopener</code> from <code>urllib.request</code> and created a class called <code>ForceOpen</code> as a subclass of <code>URLopener</code>. </p>
<p>Now I could create a "regular" User Agent by setting the variable <code>version</code> inside the <code>ForceOpen</code> class. Then just created an instance of it and used the <code>open</code> method in place of <code>urlopen</code> to open the URL. </p>
<p>(It works fine, but I'd still appreciate comments, suggestions or any feedback, also because I'm not absolute sure, if this way is a good alternative - many thanks)</p>
<hr/>
<pre><code>from urllib.request import URLopener


class ForceOpen(URLopener):  # create a subclass of URLopener
    version = "Mozilla/5.0 (cmp; Konqueror ...)(Kubuntu)"

force_open = ForceOpen()  # create an instance of it


def read_text():
    quotes = open(
        "/.../profanity_editor/data/quotes.txt"
    )
    contents_of_file = quotes.read()
    print(contents_of_file)
    quotes.close()
    check_profanity(contents_of_file)


def check_profanity(text_to_check):
    # now use the open method to open the URL
    connection = force_open.open(
        "http://www.wdylike.appspot.com/?q=" + text_to_check
    )
    output = connection.read()
    connection.close()

    if b"true" in output:
        print("Attention! Curse word(s) have been detected.")

    elif b"false" in output:
        print("No curse word(s) found.")

    else:
        print("Error! Unable to scan document.")


read_text()
</code></pre>
</div>
<span class="comment-copy"><code>urllib</code> accepts it, the <i>server</i> doesn't. And well it should not, because a space is not a valid URL character.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/32762219/how-to-formally-insert-url-space-20-using-python">How to formally insert URL space (%20) using Python?</a></span>
<span class="comment-copy">And you just gave the workaround: use <code>+</code>.</span>
<span class="comment-copy">As @MartijnPieters said, spaces are not allowed in URLs. You may think they do, because browsers silently encode them to <code>%20</code> or <code>+</code>; but you are outside a browser here, so you have to do it yourself.</span>
<span class="comment-copy">@DanielRoseman Bad idea, the error will show up with other characters. The right way is to use <code>urllib.quote</code> or <code>urllib.quote_plus</code>.</span>
