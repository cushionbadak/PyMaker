<div class="post-text" itemprop="text">
<p>So splitting a list using <code>itertools.groupby()</code> is a fairly easy.</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; iterable = it.groupby([1, 2, 3, 4, 5, 2, 3, 4, 2], lambda p: p==2)
&gt;&gt;&gt; for x, y in iterable:
...     print(x, list(y))
...     next(iterable)
False [1]
False [3, 4, 5]
False [3, 4]
</code></pre>
<p>Works as expected. But using a common python idiom of <code>zip</code>ing up the iterator multiple times to step through 2 at a time seems to break things.</p>
<pre><code>&gt;&gt;&gt; iterable = it.groupby([1, 2, 3, 4, 5, 2, 3, 4, 2], lambda p: p==2)
&gt;&gt;&gt; for (x, y), _ in zip(iterable, iterable):
...     print(x, list(y))
False []
False []
False []
</code></pre>
<p>Adding a <code>print(y)</code> shows the expected nested iterable <code>&lt;itertools._grouper object at 0xXXXXXXXX&gt;</code>, but I'm obviously missing something as to why the <code>grouper</code> object is empty. Can anyone shed some light?</p>
<p>I get an even weirder result if I have an uneven list and use <code>itertools.zip_longest</code>:</p>
<pre><code>&gt;&gt;&gt; iterable = it.groupby([1, 2, 3, 4, 5, 2, 3, 4], lambda p: p==2)
&gt;&gt;&gt; for (x, y), _ in it.zip_longest(iterable, iterable, fillvalue=None):
...     print(x, list(y))
False []
False []
False [4]
</code></pre>
<p><strong>Update</strong>: Simple fix is to use <code>itertools.islice()</code>:</p>
<pre><code>&gt;&gt;&gt; iterable = it.groupby([1, 2, 3, 4, 5, 2, 3, 4, 2], lambda p: p==2)
&gt;&gt;&gt; for x, y in it.islice(iterable, None, None, 2):
...     print(x, list(y))
False [1]
False [3, 4, 5]
False [3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>groupby</code> documentation warns you that</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, <strong>the previous group is no longer visible</strong>.</p>
</blockquote>
<p>When your <code>zip</code> produces a <code>((key, group), (key, group))</code> pair, it advances the <code>groupby</code> iterator <strong>past the first group</strong>, rendering the first group unusable. You need to materialize the group before advancing:</p>
<pre><code>iterable = ((key, list(group)) for (key, group) in it.groupby([1, 2, 3, 4, 5, 2, 3, 4, 2], lambda p: p==2))
for (x, y), _ in zip(iterable, iterable):
    print(x, y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because as soon as you get to the next item in <code>itertools.groupby</code> it discards any previous encountered <code>_grouper</code>-generators.</p>
<p>The latest items they will be visible:</p>
<pre><code>&gt;&gt;&gt; iterable = it.groupby([1, 2, 3, 4, 5, 2, 3, 4, 2], lambda p: p==2)
&gt;&gt;&gt; for (x, y), (x2, y2) in zip(iterable, iterable):
...     print(x2, list(y2))
True [2]
True [2]
True [2]
</code></pre>
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">documentation</a> contains a Warning about this behaviour:</p>
<blockquote>
<p>The returned group is itself an iterator that shares the underlying iterable with groupby(). Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, <strong>if that data is needed later, it should be stored as a list</strong>.</p>
</blockquote>
<p>So by using <code>(x, y), _ in zip(iterable, iterable)</code> you actually advanced the iterator by 2 (even if the latest result is dumped in <code>_</code>) and the first one (your <code>x, y</code>) is not avaiable anymore!</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/35991852/unexpected-behavior-of-itertools-groupby">Unexpected Behavior of itertools.groupby</a></span>
<span class="comment-copy">Thanks, make sense. Any reason the <code>zip_longest</code> last result is only <code>[4]</code> and not <code>[3, 4]</code>, given the grouper isn't being advanced in the final iteration.</span>
<span class="comment-copy">@AChampion: But it <i>is</i> advanced, because <code>groupby</code> needs to advance the underlying iterator to figure out that there's no final group. (The reason it's <code>[4]</code> instead of <code>[]</code> is because of implementation details mentioned in the link vaultah provided.)</span>
