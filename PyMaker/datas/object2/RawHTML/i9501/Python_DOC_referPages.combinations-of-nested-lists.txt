<div class="post-text" itemprop="text">
<p>I have three lists that are generated by other functions. Let's assume for now they are:</p>
<pre><code>x = ['d', 'e']
g = ['1', '2']
y = ['f', g]
</code></pre>
<p>As you can see, <code>g</code> is part of <code>y</code>. I am trying to get all combinations of the elements of the three lists. I have tried going about this in two ways:</p>
<p>One way:</p>
<pre><code>l = []
l.append([a]+[b] for a in x for b in y)
</code></pre>
<p>Another way using itertools:</p>
<pre><code>import itertools
l = list(itertools.product([a for a in x], [b for b in y]))
</code></pre>
<p>Both ways produce the following combinations:</p>
<pre><code>[('d', 'f'), ('d', ['1', '2']), ('e', 'f'), ('e', ['1', '2'])]
</code></pre>
<p>But what I would like to get is:</p>
<pre><code>[('d', 'f'), ('d', '1'), ('d','2'), ('e', 'f'), ('e', '1'), ('e','2')]
</code></pre>
<p>Also, when <code>x</code> for example is empty, I get no combinations at all when I am still expecting to get the element combinations of the remaining two lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is inspired from @Psidoms answer but just uses a specifically tailored <code>flatten</code> function to make sure only items that should be flattened are iterated:</p>
<pre><code>def flatten(x, types=list):
    lst = []
    for item in x:
        if isinstance(item, types):
            for subitem in item:
                lst.append(subitem)
        else:
            lst.append(item)
    return lst

&gt;&gt;&gt; from itertools import product

&gt;&gt;&gt; list(product(x, flatten(y)))
[('d', 'f'), ('d', '1'), ('d', '2'), ('e', 'f'), ('e', '1'), ('e', '2')]
</code></pre>
<p>Note that there is unfortunatly no such <code>flatten</code> function in the standard library but you could also use one from an external library, for example <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html" rel="nofollow noreferrer"><code>iteration_utilities.deepflatten</code></a>. Note that this requires to provide <code>str</code> or <code>basestring</code> as <code>ignore</code>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import deepflatten

&gt;&gt;&gt; list(product(x, deepflatten(y, ignore=str)))
[('d', 'f'), ('d', '1'), ('d', '2'), ('e', 'f'), ('e', '1'), ('e', '2')]
</code></pre>
<hr/>
<p>To exclude empty iterables from the product simply exclude empty subiterables. For example:</p>
<pre><code>&gt;&gt;&gt; x = []
&gt;&gt;&gt; iterables = [subiterable for subiterable in (x, list(deepflatten(y, ignore=str))) if subiterable]
&gt;&gt;&gt; list(product(*iterables))
[('f',), ('1',), ('2',)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As @BrenBarn commented, you can flatten list <code>y</code> with <code>chain</code> function, and then use <code>product</code>:</p>
<pre><code>from itertools import product, chain

list(product(x, chain.from_iterable(y)))
# [('d', 'f'), ('d', '1'), ('d', '2'), ('e', 'f'), ('e', '1'), ('e', '2')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would like to point out two implementations for flatten-like functions available in <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> (install via <code>pip install more_itertools</code>).</p>
<p><a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten" rel="nofollow noreferrer"><code>flatten</code></a> is an <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> recipe</a> and emulates @Psidom's proposal:</p>
<pre><code>import itertools as it
import more_itertools as mit

list(it.product(x, mit.flatten(y)))
# [('d', 'f'), ('d', '1'), ('d', '2'), ('e', 'f'), ('e', '1'), ('e', '2')]
</code></pre>
<p>However, for flattening more deeply nested iterables, consider using <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse" rel="nofollow noreferrer"><code>collapse</code></a>:</p>
<pre><code># Example
x = ['d', 'e']
g = [('1'), [[['2']]]]
y = [{'f'}, g]

# Bad
list(it.product(x, mit.flatten(y)))
# [('d', 'f'), ('d', '1'), ('d', [[['2']]]), ('e', 'f'), ('e', '1'), ('e', [[['2']]])]

# Good
list(it.product(x, mit.collapse(y)))
# [('d', 'f'), ('d', '1'), ('d', '2'), ('e', 'f'), ('e', '1'), ('e', '2')]
</code></pre>
</div>
<span class="comment-copy">Why don't you just flatten y first and then use <code>itertools.product</code>?</span>
<span class="comment-copy">Beat me to it :) I think it might be desirable to check if <code>item</code> inherits from the abstract base class <code>abc.Iterable</code>, then make sure it's not a string, then pull the elements into the top level.  That would let us get things out of generators, maps, tuples, etc...</span>
<span class="comment-copy">@PatrickHaugh Yeah, I think determining the types or excludes could be better but I already did that once <a href="http://iteration-utilities.readthedocs.io/en/latest/api/cfuncs.html#iteration_utilities.deepflatten" rel="nofollow noreferrer"><code>iteration_utilities.deepflatten</code></a> (a pure python implementation can be found at the bottom of that function docstring), no need to repeat it again. :-)</span>
<span class="comment-copy">Thank you @MSeifert . This is a great to-the-point answer.</span>
<span class="comment-copy">It's just great that even single character strings are iterable, otherwise this wouldn't work! I wish I had a (up-)vote left.</span>
<span class="comment-copy">@MSeifert Right, if the elements are int/float, it wouldn't work.</span>
<span class="comment-copy">Be aware that if you change <code>y = ['fall', g]</code>, or some other multiple character string, it displays potentially undesirable behaviour</span>
<span class="comment-copy">@PatrickHaugh True, I am wondering if there is a general <code>flatten</code> method that can discriminate between strings and other iterable such as list/tuple/dictionary. Or you just have to be always careful about it.</span>
<span class="comment-copy">Thank you all for the answer and comments. But how do you deal with the case when x is an empty list?</span>
<span class="comment-copy">Nice alternative with <code>more_itertools.collapse</code> but strangly this is slower than using the pure-python implementation I've presented in <a href="http://iteration-utilities.readthedocs.io/en/latest/api/cfuncs.html#iteration_utilities.deepflatten" rel="nofollow noreferrer"><code>iteration_utilities.deepflatten</code></a> and much slower than using <code>iteration_utilities.deepflatten</code> itself. Maybe there is some room for improvement!</span>
<span class="comment-copy">@MSeifert Perhaps there is room for improvement, but what do you consider "much slower"? I ran Jupyter's <code>%timeit</code> command on both <code>mit.collapse(y)</code> and <code>iteration_utilities.deepflatten(y)</code> and got ~700 ns for each. What times did you observe? Also, I found <code>collapse</code> flattened deeply nested iterables, e.g. <code>[[1], 2, [[3], 4], [[[5]]], 'abc']</code> as is, without keywords, which may be a reasonable tradeoff.</span>
<span class="comment-copy">both return generators, so did you cast them to lists or otherwise iterate over them? Because I get 15us for <code>collapse</code> and 4us for <code>deepflatten</code>. However, the difference get's bigger if the iterables get longer.</span>
<span class="comment-copy">You're right about the "no need for additional keywords", however I consider it somewhat of a drawback not being able to flatten strings (even if only optionally). But in the end it doesn't matter. I was just surprised about the time difference. :-)</span>
<span class="comment-copy">Yes I can reproduce your value by timing a list comprehension with <code>collapse</code>, but my computer stops responding if I attempt a similar process for <code>deepflatten</code>.  I welcome suggestions.  An aside, how would you apply  <code>deepflatten</code> to <code>[[1], 2, [[3], 4], [[[5]]], 'abc']</code>?</span>
