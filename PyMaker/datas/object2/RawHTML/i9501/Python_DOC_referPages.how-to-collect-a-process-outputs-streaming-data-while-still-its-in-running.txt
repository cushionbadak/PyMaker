<div class="post-text" itemprop="text">
<p>I have a service which runs in terminal (like a messenger) and it has its own printing console like so:</p>
<pre><code>$ service-process --sync-start --text
&gt; service started.
&gt; wait to get results.
&gt; TB1: 0X4571 
&gt; TT1: 0X3321
..
..
..
&gt; TY1: 0X6634
..
..
..
^Ctrl+C
exited
$
</code></pre>
<p>When I want to get it's output I should call it like so:</p>
<pre><code>$ service-process --sync-start --text &gt;&gt; output
</code></pre>
<p>Storing data in file is not a good solution for my situation. So I need to get it's printed outputs in my python program while this process still is in running in other terminal (or in background). This process should be in running on server for a long time.</p>
<p>I've written this code to collect the outputs (streaming data) but it never collect all of them, it just collect some first data and never works for a long time (never collect other data):</p>
<pre><code>p = subprocess.Popen(['service-process', '--sync-start', '--text'], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
while True:
    output = ''
    if hasattr(p, 'stdout'):
        output = p.stdout.readline().strip().replace('\n','').replace('\r','')
    elif hasattr(p, 'stderr'):
        output = p.stderr.readline().strip().replace('\n','').replace('\r','')
    else:
        print('sleep...')
        time.sleep(1)
        continue
    print(output)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>By default, reading from <code>Popen.stdout</code> &amp; <code>Popen.stderr</code> is going to block until there is data in the stream. This might cause issues where the program is waiting for data in <code>stderr</code>, while data becomes available in <code>stdout</code>, but since it's blocked it can't attend to <code>stdout</code>. We can use the <code>fcntl</code> (file control) Linux syscall to set the file descriptors of <code>stdout</code> &amp; <code>stderr</code> to non-blocking instead.</p>
<p>Here is a sample code:</p>
<pre><code>import subprocess
from time import sleep
import fcntl, os
import sys

p = subprocess.Popen(['service-process', '--sync-start', '--text'], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
fcntl.fcntl(p.stdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
fcntl.fcntl(p.stderr.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)

while True:
    out1 = ''
    out2 = ''

    if hasattr(p, 'stdout'):
        out1 = p.stdout.readline().strip().replace('\n','').replace('\r','')
    if hasattr(p, 'stderr'):
        out2 = p.stderr.readline().strip().replace('\n','').replace('\r','')

    if out1 != '':
        print(out1)
    if out2 != '':
        print(out2)

    sleep(1)
</code></pre>
</div>
<span class="comment-copy">It seems that you're executing the <code>subprocess.Popen()</code> once. Which makes it returns only one output which is a generator object and you've consumed in last iteration using <code>readline()</code>. I think you need to read the <code>stdout</code>  using <code>sys</code> or basically use a general function for reading from stdout.</span>
<span class="comment-copy">@Kasramvd thanks for your message. Would you please show me a sample code?</span>
<span class="comment-copy">Here you go: <a href="https://docs.python.org/3/library/sys.html#sys.__stdout__" rel="nofollow noreferrer">docs.python.org/3/library/sys.html#sys.__stdout__</a></span>
<span class="comment-copy">@Kasramvd I've changed <code>stdout=process.PIPE</code> to <code>stdout=sys.stdout</code> it shows some outputs but it exits after calling the service.</span>
<span class="comment-copy">Thank you so much!</span>
