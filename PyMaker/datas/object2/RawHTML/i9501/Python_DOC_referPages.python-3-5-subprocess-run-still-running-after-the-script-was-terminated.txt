<div class="post-text" itemprop="text">
<p>Why after I terminate a python script with <code>ctrl+c</code> while the command <code>subprocess.run('knife ec2 server create...', shell=True, check=True)</code> is running from this script, the control returns to the terminal session but after a few min/sec the shell command reappears in the terminal session and the shell command from <code>subprocess.run</code> still running?</p>
<p>I think I saw the same issue with <code>os.system</code>, for example <code>os.system('ping 8.8.8.8')</code> .</p>
<p><code>^C</code></p>
<pre><code>Waiting for EC2 to create the instance.....^CTraceback (most recent call last):
  File "t.py", line 177, in &lt;module&gt;
    subprocess.run(command, shell=True, check=True)
  File "/usr/lib/python3.5/subprocess.py", line 695, in run
    stdout, stderr = process.communicate(input, timeout=timeout)
  File "/usr/lib/python3.5/subprocess.py", line 1064, in communicate
    self.wait()
  File "/usr/lib/python3.5/subprocess.py", line 1658, in wait
    (pid, sts) = self._try_wait(0)
  File "/usr/lib/python3.5/subprocess.py", line 1608, in _try_wait
    (pid, sts) = os.waitpid(self.pid, wait_flags)
KeyboardInterrupt
$ ..............................................................................done

SSH Target Address: ec2()
Doing old-style registration with the validation key at /etc/chef/validation.pem...
Delete your validation key in order to use your user credentials instead
</code></pre>
<p>I tried also the below code but I got an error:</p>
<pre><code>command = ('knife ec2 server create -N ' + fullname + ' -f ' + instance_type + ' -i ' + pem_file)...

p = subprocess.Popen(command, shell=True, stderr=subprocess.PIPE)
while True:
    out = p.stderr.read(1)
    if out == '' and p.poll() != None:
        break
    if out != '':
        sys.stdout.write(out)
        sys.stdout.flush()
</code></pre>
<p>error: </p>
<pre><code>`sys.stdout.write(out) TypeError: write() argument must be str, not bytes'
</code></pre>
<p>Is there a simple way to run a shell command with <code>python</code> like <code>Ruby</code> with <code>system()</code> ?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>the subprocess module spawns a new process. when you send the CTRL+C signal to your python code,  you are existing your python application but the subprocess is still running and your code decides not to wait for the process to finish. </p>
<p>Try catching the Ctrl+C signal in your code, and then use Popen terminate call to end the subprocess before existing your application. </p>
<pre><code>import shlex, subprocess
command_line = input()

args = shlex.split(command_line)
print(args)

p = subprocess.Popen(args) # Success!
</code></pre>
<p><a href="https://docs.python.org/3.5/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">Popen and subprocess docs</a></p>
<p>Here is the API doc for the terminate call:</p>
<p><a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen.terminate" rel="nofollow noreferrer">Popen.Terminate</a></p>
<p><b>EDIT</b>
Here is sample demo code for python 2.7, the section of the code that prints strout doesn't apply for ping, because it will still output the ping result to the terminal, but I placed it there for reference.</p>
<pre><code>import subprocess
import signal
import sys

command = 'ping {0}'.format('8.8.8.8')
p = subprocess.Popen(command, shell=True, stderr=subprocess.PIPE)

# callback for the Ctrl+C signal
def signal_handler(signal, frame):
    print("CTRL+C received")
    p.kill() # or terminate
    p.wait()
    sys.exit(0)    

# register signal with the callback
signal.signal(signal.SIGINT, signal_handler)

# white subprocess hasn't finished
while p.poll() is None:
    out = p.communicate()
    print(out.stdoutdata)
</code></pre>
</div>
<span class="comment-copy">the subprocess module spawns a new process. when you send the CTRL+C signal to your python code,  you are existing your python application but the subprocess is still running and your code decides not to wait for the process to finish. I posted my possible solution as an answer.</span>
<span class="comment-copy">thank you, so what is the best soultion for this ?</span>
<span class="comment-copy">Kill em' at the end of your main thread.</span>
<span class="comment-copy">there is <code>os.system(command)</code> call. but apparently that is going to be depreciated. see <a href="https://docs.python.org/3/library/os.html#os.system" rel="nofollow noreferrer">docs.python.org/3/library/os.html#os.system</a></span>
<span class="comment-copy">yes that exactly what I did :), thanks</span>
<span class="comment-copy">thank you, I will try your soultion, I wonder why you can do it with <code>ruby</code> only with one command <code>system()</code>.</span>
<span class="comment-copy">I don't know ruby, but having this level of control over spawning sub-processes is good since someone might want a different behavior for example, starting a subprocess and existing afterwards like a multi process initialization process or something.</span>
<span class="comment-copy">He's also doing it in one line, the rest is just a cherry on the top ;)</span>
<span class="comment-copy">I tried for example - <code>command_line = input()</code> <code>args = shlex.split('ping 8.8.8.8')</code> <code>print(args)</code> <code>p = subprocess.Popen(args)</code> , but you cant see the stdout unless you press <code>enter</code>, any idea?</span>
<span class="comment-copy">is it possible to run the command with the <code>stdout</code> ?</span>
