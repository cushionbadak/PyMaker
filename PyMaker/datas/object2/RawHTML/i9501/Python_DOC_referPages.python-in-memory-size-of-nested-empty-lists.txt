<div class="post-text" itemprop="text">
<p>The size in memory of an object can be gotten with <code>sys.getsizeof</code>.</p>
<p>As one could expect, the size of <code>[]</code> is smaller than the size of <code>[[]]</code>. On my machine, I get the following sizes:</p>
<pre><code>&gt;&gt;&gt; sys.getsizeof([])
36
&gt;&gt;&gt; sys.getsizeof([[]])
40
</code></pre>
<p>Now, whatever the number of nested empty lists I have, I always get the same size:</p>
<pre><code>&gt;&gt;&gt; sys.getsizeof([[[]]])
40
&gt;&gt;&gt; sys.getsizeof([[[[]]]])
40
</code></pre>
<p>What is the reason why the size of nested empty lists seems to have an upper boundary?</p>
</div>
<div class="post-text" itemprop="text">
<p>The size just refers to the outermost object and not the nested ones. From the perspective of <code>getsizeof</code> the object size is just the size of the object plus the size of the pointers contained in the object not the objects being pointed to. You can see this from the following:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof([])
64
&gt;&gt;&gt; sys.getsizeof([[]])
72
&gt;&gt;&gt; sys.getsizeof([[[]]])
72
&gt;&gt;&gt; sys.getsizeof([[],[]])
80
&gt;&gt;&gt; sys.getsizeof([[[]],[[]]])
80
</code></pre>
<p>If you want to get the total memory footprint you will either need to recursively find the sizes for the object or use some other memory profiling.</p>
<p>Also if you are writing your own objects and want <code>getsizeof</code> to correctly return the size you can implement your own <code>__sizeof__</code> method. For example:</p>
<pre><code>import sys
class mylist:
    def __init__(self, iterable):
        self.data = list(iterable)

    def __sizeof__(self):
        return object.__sizeof__(self) + \
            sum(sys.getsizeof(v) for v in self.__dict__.values()) + \
            sum(sys.getsizeof(item) for item in self.data)

original_data = [[1,2,3], [1,2,3]]
print(sys.getsizeof(original_data))
foo = mylist(original_data)
print(sys.getsizeof(foo))
</code></pre>
<p>Results:</p>
<pre><code>~/code_snippets$ python3 sizeof_list.py 
80
336
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reading <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer">the documentation</a> would have taught me that when calling <code>getsizeof</code>,</p>
<blockquote>
<p>Only the memory consumption directly attributed to the object is
  accounted for, not the memory consumption of objects it refers to.</p>
</blockquote>
<p>Since <code>[]</code> is a container, its size, according to <code>getsizeof</code>, is its own size plus the size of the references it contains, but not the sizes of the objects referred to.</p>
<p>Therefore, if <code>[]</code> has a size of <code>36</code>, and a reference has a size of <code>4</code>, then the size of <code>[[]]</code> is <code>36+4</code>, hence <code>40</code>.</p>
<p>Now, <code>[[[]]]</code> is nothing more than <code>[x]</code> where <code>x</code> is a reference to <code>[[]]</code>. Hence, the size of <code>[[[]]]</code> is the size of <code>[]</code> plus the size of a reference, so <code>40</code> as well.</p>
</div>
<span class="comment-copy">Did you read <a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="nofollow noreferrer">the documentation</a>, specifically the part that says "Only the memory consumption directly attributed to the object is accounted for, not the memory consumption of objects it refers to."?</span>
<span class="comment-copy">@BrenBarn Actually I hadn't and it answers my question. Thank you!</span>
<span class="comment-copy"><a href="http://stackoverflow.com/a/30316760/533399">stackoverflow.com/a/30316760/533399</a></span>
