<div class="post-text" itemprop="text">
<p>I came across this behavior that surprised me in Python 2.6 and 3.2:</p>
<pre><code>&gt;&gt;&gt; xs = dict.fromkeys(range(2), [])
&gt;&gt;&gt; xs
{0: [], 1: []}
&gt;&gt;&gt; xs[0].append(1)
&gt;&gt;&gt; xs
{0: [1], 1: [1]}
</code></pre>
<p>However, <code>dict</code> comprehensions in 3.2 show a more polite demeanor:</p>
<pre><code>&gt;&gt;&gt; xs = {i:[] for i in range(2)}
&gt;&gt;&gt; xs
{0: [], 1: []}
&gt;&gt;&gt; xs[0].append(1)
&gt;&gt;&gt; xs
{0: [1], 1: []}
&gt;&gt;&gt; 
</code></pre>
<p>Why does <code>fromkeys</code> behave like that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your Python 2.6 example is equivalent to the following, which may help to clarify:</p>
<pre><code>&gt;&gt;&gt; a = []
&gt;&gt;&gt; xs = dict.fromkeys(range(2), a)
</code></pre>
<p>Each entry in the resulting dictionary will have a reference to the same object. The effects of mutating that object will be visible through every dict entry, as you've seen, because it's one object.</p>
<pre><code>&gt;&gt;&gt; xs[0] is a and xs[1] is a
True
</code></pre>
<p>Use a dict comprehension, or if you're stuck on Python 2.6 or older and you don't have dictionary comprehensions, you can get the dict comprehension behavior by using <code>dict()</code> with a generator expression:</p>
<pre><code>xs = dict((i, []) for i in range(2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the first version, you use the <em>same</em> empty list object as the value for both keys, so if you change one, you change the other, too.</p>
<p>Look at this:</p>
<pre><code>&gt;&gt;&gt; empty = []
&gt;&gt;&gt; d = dict.fromkeys(range(2), empty)
&gt;&gt;&gt; d
{0: [], 1: []}
&gt;&gt;&gt; empty.append(1) # same as d[0].append(1) because d[0] references empty!
&gt;&gt;&gt; d
{0: [1], 1: [1]}
</code></pre>
<p>In the second version, a <em>new</em> empty list object is created in every iteration of the dict comprehension, so both are independent from each other.</p>
<p>As to "why" <code>fromkeys()</code> works like that - well, it would be surprising if it didn't work like that. <code>fromkeys(iterable, value)</code> constructs a new dict with keys from <em>iterable</em> that all have the value <code>value</code>. If that value is a mutable object, and you change that object, what else could you reasonably expect to happen?</p>
</div>
<div class="post-text" itemprop="text">
<p>To answer the actual question being asked: <code>fromkeys</code> behaves like that because there is no other reasonable choice. It is not reasonable (or even possible) to have <code>fromkeys</code> decide whether or not your argument is mutable and make new copies every time. In some cases it doesn't make sense, and in others it's just impossible.</p>
<p>The second argument you pass in is therefore just a reference, and is copied as such. An assignment of <code>[]</code> in Python means "a single reference to a new list", not "make a new list every time I access this variable". The alternative would be to pass in a function that generates new instances, which is the functionality that dict comprehensions supply for you.</p>
<p>Here are some options for creating multiple actual copies of a mutable container:</p>
<ol>
<li><p>As you mention in the question, dict comprehensions allow you to execute an arbitrary statement for each element:</p>
<pre><code>d = {k: [] for k in range(2)}
</code></pre>
<p>The important thing here is that this is equivalent to putting the assignment <code>k = []</code> in a <code>for</code> loop. Each iteration creates a new list and assigns it to a value.</p></li>
<li><p>Use the form of the <code>dict</code> constructor suggested by <a href="https://stackoverflow.com/a/8174807/2988730">@Andrew Clark</a>:</p>
<pre><code>d = dict((k, []) for k in range(2))
</code></pre>
<p>This creates a generator which again makes the assignment of a new list to each key-value pair when it is executed.</p></li>
<li><p>Use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> instead of a regular <code>dict</code>:</p>
<pre><code>d = collections.defaultdict(list)
</code></pre>
<p>This option is a little different from the others. Instead of creating the new list references up front, <code>defaultdict</code> will call <code>list</code> every time you access a key that's not already there. You can there fore add the keys as lazily as you want, which can be very convenient sometimes:</p>
<pre><code>for k in range(2):
    d[k].append(42)
</code></pre>
<p>Since you've set up the factory for new elements, this will actually behave exactly as you expected <code>fromkeys</code> to behave in the original question.</p></li>
<li><p>Use <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code></a> when you access potentially new keys. This does something similar to what <code>defaultdict</code> does, but it has the advantage of being more controlled, in the sense that only the access you want to create new keys actually creates them:</p>
<pre><code>d = {}
for k in range(2):
    d.setdefault(k, []).append(42)
</code></pre>
<p>The disadvantage is that a new empty list object gets created every time you call the function, even if it never gets assigned to a value. This is not a huge problem, but it could add up if you call it frequently and/or your container is not as simple as <code>list</code>.</p></li>
</ol>
</div>
<span class="comment-copy">the difference is the same as in <code>[[]]*2</code> and <code>[[] for _ in range(2)]</code>.</span>
<span class="comment-copy">@J.F.Sebastian I am used to the meaning of [[]]*2 and other gotchas alike. But fromkeys got me by surprise. Maybe is just a question of familiarity...I practically never use the fromkeys method...</span>
<span class="comment-copy">Each entry in the resulting <code>xs</code> dictionary will have a reference to the same <code>a</code> object as its value, whether or not <code>a</code> happens to be mutable. But of course the problem in the OP only arises when <code>a</code> is mutable and you mutate it.</span>
<span class="comment-copy">Tim, I understand why it happens. My question is more like "why is it designed to behave like this?". Sorry not being clear in the question.</span>
<span class="comment-copy">Good point about the new empty list object getting created every time. OTOH, they're pretty cheap to create, and the unused ones will be recycled.</span>
<span class="comment-copy">Recycling is overhead too. It offends my sense of neatness to do it like that, not to mention that not all possibilities are as cheap as list.</span>
