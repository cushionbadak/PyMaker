<div class="post-text" itemprop="text">
<p>I have a recursive code of the catalan numbers.
I managed to write the recursive call, but for some reason the counter is not working properly.
for example, the number of calls for 7th catalan number should be 1215.
the return value needs to be a tuple of the catalan number and the number of calls,for example: (429,1215).
original code:</p>
<pre><code>def catalan_rec(n):
    if n&lt;=1:
        return 1
    res=0
    for i in range(n):
        res+=catalan_rec(i)*catalan_rec(n-i-1)
    return res
</code></pre>
<p>counter code:</p>
<pre><code>def catalan_rec_count(n,counter=1):
    if n&lt;=1:
        return 1
    res=0
    for i in range(n):
        res+=catalan_rec_count(i,counter+1)*catalan_rec_count(n-i-1,counter+1)        
    return (res,counter)
</code></pre>
<p>thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>python allows you to attach a variable (<code>catalan.counter</code> in the snippet below) to the function object, so you don't have to pass the counter along all the time and don't need a global variable:</p>
<pre><code>def catalan(n):

    catalan.counter += 1

    if n &lt;= 1:
        return 1
    res = 0
    for i in range(n):
        res += catalan(i) * catalan(n-i-1)
    return res

catalan.counter = 0

print(catalan(5))
print(catalan.counter)
</code></pre>
<p>and seeing that the function is called several times with the same arguments: for more efficiency you could use the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noreferrer"><code>lru_cache</code></a>; but this of course defeats the purpose of counting how many times the function was called; you'd only get the number the function was called with a <em>unique</em> <code>n</code>.</p>
<pre><code>from functools import lru_cache

@lru_cache(maxsize=128)
def catalan(n):

    ...
</code></pre>
<hr/>
<p>this may be a bit off-topic... but in case you need separate instances of the function with separate counters, a <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noreferrer">closure</a> might be just what you need:</p>
<pre><code>def make_catalan():

    counter = 0

    def catalan(n):

        nonlocal counter
        counter += 1
        catalan.counter = counter

        if n &lt;= 1:
            return 1
        res = 0
        for i in range(n):
            res += catalan(i) * catalan(n-i-1)
        return res

    return catalan

catalan_1 = make_catalan()
print(catalan_1(2))
print(catalan_1.counter)

catalan_2 = make_catalan()
print(catalan_2(3))
print(catalan_2.counter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to seperate out the line <code>res+=catalan_rec_count(i,counter+1)*catalan_rec_count(n-i-1,counter+1)</code> so that it can do operations with the recursive results and the counters seperately, so just split it up into a few extra lines, also in this case you wouldn't pass <code>counter+1</code> to the recursive calls so that it tracks it's calls independant to the current frame..</p>
<pre><code>def catalan_rec_count(n,counter=1):
    if n&lt;=1:
        return (1, counter) #remember to return the counter in this case too!
    res=0
    for i in range(n):
        #get the recursive results and counters for both calls
        #don't pass counter+1 to it, it should count how many times it is called on it's own
        partial1, inner_c1 = catalan_rec_count(i)
        partial2, inner_c2 = catalan_rec_count(n-i-1)
        #apply the logic with the actual result and add to the counter
        res+=partial1*partial2
        counter+= inner_c1 + inner_c2
    return (res,counter)
</code></pre>
</div>
<span class="comment-copy">You appear to be returning a number, <code>res</code>, not a tuple.</span>
<span class="comment-copy">How do you implement both pieces of code? Show an example of you using the functions, the output you get, and the output you want.</span>
<span class="comment-copy">Note that <code>catalan_rec_count(i,counter+1)*catalan_rec_count(n-i-1,counter+1)</code> is multiplying two tuples together.</span>
<span class="comment-copy">@CharlesMorris that is called recursion. I think it is intentional.</span>
<span class="comment-copy">@CharlesMorris, nop, its the recursive call.</span>
<span class="comment-copy">I don't think the closure would be necessary, just an internal function that is used in the recursion and a public version that resets it and returns it along with the result in a tuple.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen : i was trying to make a version where you do not have to pass the counter along. resetting would work with my first variant already; but with the closure you can call both functions independently and they keep their own count. but i agree; it is overkill!</span>
<span class="comment-copy">I was just about to post the counter returns a wrong number. and your comment gave me a good laugh ;)</span>
<span class="comment-copy">It quite surprised me how quickly I got upvoted, anyway I do recommend <a href="http://stackoverflow.com/a/41203348/5827215">@hiro protagonist's solution</a> over my own (was going to edit in that method in my answer) since it means you can track the counter without needing to deal with splitting out the return value.</span>
<span class="comment-copy">Thanks a lot, it works great, and actually yours is more suited to my needs because it uses the counter as defined in my example.</span>
