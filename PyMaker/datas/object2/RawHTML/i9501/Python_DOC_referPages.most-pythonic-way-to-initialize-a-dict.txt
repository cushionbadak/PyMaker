<div class="post-text" itemprop="text">
<p>Suppose I have a dict like this</p>
<pre><code>d = {
    1: [1,4,7],
    2: [2,5,8],
    0: [3,6,9]       
}
</code></pre>
<p>It can be constructed by</p>
<pre><code>d = {}

for i in range(1,10):
    key = i % 3
    if key not in d: d[key] = []
    d[key].append(i)
</code></pre>
<p>I used this line <code>if key not in d: d[key] = []</code> to check existence of the key/value pair in the dict and initiate the pair. </p>
<p>Is there a more pythonic way to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is probably best handled with a <a href="https://docs.python.org/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a>, which will automatically create any key-value mapping that is accessed if it doesn't already exist. You pass a callable to the <code>defaultdict</code> constructor that will be used to initialize the value. For example:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; d
defaultdict(list, {})
&gt;&gt;&gt; d[3]
[]
&gt;&gt;&gt; d
defaultdict(list, {3: []})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using a comprehension:</p>
<pre><code>&gt;&gt;&gt; {n%3: list(range(n, n+7, 3)) for n in range(1,4)}
{0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}
</code></pre>
<p>Using <code>dict.setdefault()</code>:</p>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for i in range(1, 10):
...     d.setdefault(i%3, []).append(i)
... 
&gt;&gt;&gt; d
{0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}
</code></pre>
<p>Using <code>defaultdict</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for i in range(1, 10):
...     d[i%3].append(i)
... 
&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import defaultdict

d = defaultdict(list)
for i in range(1,10):
    key = i % 3
    d[key].append(i)
print(d)
</code></pre>
<p>out:</p>
<pre><code>defaultdict(&lt;class 'list'&gt;, {0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]})
</code></pre>
<blockquote>
<p>When each key is encountered for the first time, it is not already in
  the mapping; so an entry is automatically created using the
  default_factory function which returns an empty list. The
  list.append() operation then attaches the value to the new list. When
  keys are encountered again, the look-up proceeds normally (returning
  the list for that key) and the list.append() operation adds another
  value to the list. This technique is simpler and faster than an
  equivalent technique using dict.setdefault():</p>
</blockquote>
<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for k, v in s:  
        d.setdefault(k, []).append(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list slices [start:stop:step] nominclature</p>
<pre><code>d={}
for i in range(3):
     d[i] = list(range(1,10))[(i+2)%3::3]

{0: [3, 6, 9],
 1: [1, 4, 7], 
 2: [2, 5, 8]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given that you haven't given any input nor variable parts you might just initialize it with the literal you already have:</p>
<pre><code>d = {1: [1,4,7],
     2: [2,5,8],
     0: [3,6,9]}
</code></pre>
<hr/>
<p>If you have variable input you may use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> with <code>list</code> as factory. Given that this operation is very common several external libraries have functions for this:</p>
<ul>
<li><a href="https://iteration-utilities.readthedocs.io/en/latest/generated/groupedby.html" rel="nofollow noreferrer"><code>iteration_utilities.groupedby</code></a></li>
<li><a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.groupby" rel="nofollow noreferrer"><code>toolz.groupby</code></a></li>
</ul>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import groupedby

&gt;&gt;&gt; groupedby(range(1, 10), lambda x: x % 3)
{0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}
</code></pre>
<p>or:</p>
<pre><code>&gt;&gt;&gt; from toolz import groupby

&gt;&gt;&gt; groupby(lambda x: x % 3, range(1, 10))
{0: [3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}
</code></pre>
</div>
<span class="comment-copy">why you can't use array ?</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a></span>
