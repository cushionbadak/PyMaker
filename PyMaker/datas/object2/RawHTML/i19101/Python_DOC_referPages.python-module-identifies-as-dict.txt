<div class="post-text" itemprop="text">
<p>Lets say I have a lot of key-pair data. I would like to have this data in a package so that it can be imported. Is there a way to make modules work like dicts, for performance and extendibility reasons?</p>
<p>Example: </p>
<pre><code>common/pairs/
 ├── BUILDINGS.py
 └── __init__.py

import BUILDINGS

BUILDINGS["foo"] == "bar"
</code></pre>
<p>Note: The desired result can be archived by putting declaring <code>BUILDINGS</code> in <code>__init__.py</code> but they will all be compiled every time, its not drag and undroppable, and it seems ugly.</p>
<p>Is there a way to achieve this well? Is there a way to achieve it at all? </p>
</div>
<div class="post-text" itemprop="text">
<p>Not that I recommend it, but you can assign the <code>dict</code> into <code>sys.modules</code>. Python doesn't care that what's there is actually a module object.</p>
<pre><code># BUILDINGS.py
from sys import modules
if __name__ != "__main__":
    modules[__name__] = {'a': 1, 'b': 2, ...}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Modules are already dicts with their atributes stored in <code>BUILDINGS.__dict__</code>. Just make an utility fonction to write directly to it.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you correctly, I think what you want is the <code>pickle</code> package</p>
<p>ie,</p>
<pre><code>In [16]: import pickle

In [17]: mydict = {'this':1, 'is':2, 'my':3, 'dict':4}

In [18]: mydict
Out[18]: {'dict': 4, 'is': 2, 'my': 3, 'this': 1}

In [20]: outfile = open('/tmp/mydict.pickle', 'w')

In [21]: pickle.dump(mydict, outfile)

In [22]: outfile.close()

In [23]: infile = open('/tmp/mydict.pickle', 'r')

In [24]: mydict_loaded = pickle.load(infile)

In [25]: mydict_loaded
Out[25]: {'dict': 4, 'is': 2, 'my': 3, 'this': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to store key-value data that you want to reference later, you should try  the <a href="http://docs.python.org/2/tutorial/modules.html" rel="nofollow">shelve</a> module</p>
<p>Example from the above linked page</p>
<pre><code>import shelve

d = shelve.open(filename) # open -- file may get suffix added by low-level
                          # library

d[key] = data   # store data at key (overwrites old data if
                # using an existing key)
data = d[key]   # retrieve a COPY of data at key (raise KeyError if no
                # such key)
del d[key]      # delete data stored at key (raises KeyError
                # if no such key)
flag = d.has_key(key)   # true if the key exists
klist = d.keys() # a list of all existing keys (slow!)

# as d was opened WITHOUT writeback=True, beware:
d['xx'] = range(4)  # this works as expected, but...
d['xx'].append(5)   # *this doesn't!* -- d['xx'] is STILL range(4)!

# having opened d without writeback=True, you need to code carefully:
temp = d['xx']      # extracts the copy
temp.append(5)      # mutates the copy
d['xx'] = temp      # stores the copy right back, to persist it

# or, d=shelve.open(filename,writeback=True) would let you just code
# d['xx'].append(5) and have it work as expected, BUT it would also
# consume more memory and make the d.close() operation slower.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you <em>really</em> want a module that you can use as a <code>dict</code>, you have to make it implement the mapping protocol.</p>
<p>In particular, you need to make sure that <code>type(BUILDINGS).__getitem__(BUILDINGS, key)</code> is defined (as, e.g., <code>getattr(BUILDINGS, key)</code>. And likewise for <code>__setitem__</code>, <code>__delitem__</code>, and anything else you want to implement. (You can get most of what you want through <code>collections.abc.MutableMapping</code>, or <code>collections.MutableMapping</code> if you're on 2.x. See <a href="http://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow">the docs</a> for exactly what you have to implement to get everything else for free.)</p>
<p>The problem is that (at least in CPython, which is probably what you care about) <code>module</code> is a builtin type whose attributes cannot be modified. So, you need to cause <code>BUILDINGS</code> to be an instance of a different type, which you can then add <code>__getitem__</code> to. For example:</p>
<pre><code>class DictModuleType(types.ModuleType, collections.abc.MutableMapping):
    def __getitem__(self, key):
        return getattr(self, key)
    def __setitem__(self, key, value):
        return setattr(self, key, value)
    # ... etc.

import BUILDINGS as _BUILDINGS
BUILDINGS = DictModuleType('BUILDINGS')
for name, member in inspect.getmembers(_BUILDINGS):
    if not name.startswith('_'):
        setattr(BUILDINGS, name, member)
</code></pre>
<p>Now you've got a <code>BUILDINGS</code> that acts just like the real module, except that it also provides dict-like access instead of just namespace-like access.</p>
<p>You can wrap this up in a variety of different ways.</p>
<p>The simplest way is to take effectively that code (but using <code>__import__</code> or <code>imp</code> so you don't pollute <code>globals</code> and <code>sys.modules</code> with the intermediate value) and put it in a function, so instead of <code>import BUILDINGS</code> you'd write <code>helper_mod.dict_import(BUILDINGS)</code>.</p>
<p>The most powerful way is to create and install an <a href="http://www.python.org/dev/peps/pep-0302/" rel="nofollow">import hook</a> that just returns a <code>DictModuleType</code> instead of <code>ModuleType</code> (you may need to implement <code>__new__</code> and/or <code>__init__</code> to make this work) for, say, all modules whose names are in all caps (just check if <code>fullname.split('.')[-1].isupper()</code>, and, if not, don't wrap it). Then, you can just write a module named <code>BUILDINGS.py</code>, and <code>import BUILDINGS</code>, and <code>BUILDINGS</code> will act like a <code>dict</code>.</p>
</div>
<span class="comment-copy">Why isn't <code>BUILDINGS.foo</code> good enough?</span>
<span class="comment-copy">I am curious, what do you expect to gain by importing data from a package versus loading it from an external resource ?</span>
<span class="comment-copy">Compile? If you import it once, a cache <code>pyc</code> file will exist and you don't need to "recompile" to bytecode. True that if you import <code>pairs</code> then the dict is loaded.</span>
<span class="comment-copy">Thats a cool trick I might use it somewhere :-) Thanks.</span>
<span class="comment-copy">Works as expected with removal of "sys." on line 4. Thanks.</span>
<span class="comment-copy">Oh yeah, I originally just imported <code>sys</code> and changed that without changing the other use. Fixed. :-)</span>
