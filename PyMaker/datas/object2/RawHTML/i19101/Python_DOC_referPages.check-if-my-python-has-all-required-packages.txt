<div class="post-text" itemprop="text">
<p>I have a <code>requirements.txt</code> file with a list of packages that are required for my virtual environment. Is it possible to find out whether all the packages mentioned in the file are present. If some packages are missing, how to find out which are the missing packages?</p>
</div>
<div class="post-text" itemprop="text">
<p>The pythonic way of doing it is via the <code>pkg_resources</code> <a href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#api-reference" rel="noreferrer">API</a>. The requirements are written in a format understood by setuptools. E.g:</p>
<pre><code>Werkzeug&gt;=0.6.1
Flask
Django&gt;=1.3
</code></pre>
<p>The example code:</p>
<pre><code>import pkg_resources
from pkg_resources import DistributionNotFound, VersionConflict

# dependencies can be any iterable with strings, 
# e.g. file line-by-line iterator
dependencies = [
  'Werkzeug&gt;=0.6.1',
  'Flask&gt;=0.9',
]

# here, if a dependency is not met, a DistributionNotFound or VersionConflict
# exception is thrown. 
pkg_resources.require(dependencies)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can run <code>pip freeze</code> to see what you have installed and compare it to your <code>requirements.txt</code> file.</p>
<p>If you want to install missing modules you can run <code>pip install -r requirements.txt</code> and that will install any missing modules and tell you at the end which ones were missing and installed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the <a href="https://stackoverflow.com/a/16298328/832230">answer by Zaur</a>, assuming you indeed use a <code>requirements.txt</code> file, you may want a unit test, perhaps in <code>tests/test_requirements.py</code>, that confirms the availability of packages.</p>
<p>This approach uses a <a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" rel="nofollow noreferrer">subtest</a> to independently confirm each requirement. This is useful so that all failures are documented.</p>
<pre><code>from pathlib import Path
import unittest

import pkg_resources


class TestRequirements(unittest.TestCase):
    def test_requirements(self):
        """Recursively confirm that requirements are available."""
        # Ref: https://stackoverflow.com/a/45474387/
        requirements = (Path(__file__).parents[1] / 'requirements.in').read_text().strip().split('\n')
        requirements = [r.strip() for r in requirements]
        requirements = [r for r in sorted(requirements) if r and not r.startswith('#')]
        for requirement in requirements:
            with self.subTest(requirement=requirement):
                pkg_resources.require(requirement)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a virtualenv with access to the system site packages and test check whether the package (or another dependencies) are installed or not. This way the packages are not really installed (if you just want to check). An example using <a href="https://virtualenvwrapper.readthedocs.io/en/latest/" rel="nofollow">virtualenv wrapper</a> would be: </p>
<pre><code>$ cat requirements.txt 
requests
simplejson

$ mkvirtualenv --system-site-packages test
Running virtualenv with interpreter /usr/bin/python2
New python executable in test/bin/python2
Also creating executable in test/bin/python
Installing setuptools, pip...done.

$ pip install -r requirements.txt
Downloading/unpacking requests (from -r requirements.txt (line 1))
  Downloading requests-2.10.0-py2.py3-none-any.whl (506kB): 506kB downloaded
Requirement already satisfied (use --upgrade to upgrade): simplejson in /usr/lib/python2.7/dist-packages (from -r requirements.txt (line 2))
Installing collected packages: requests
Successfully installed requests
Cleaning up...

$ pip install -r requirements.txt
Requirement already satisfied (use --upgrade to upgrade): requests in /home/yucer/.virtualenvs/test/lib/python2.7/site-packages (from -r requirements.txt (line 1))
Requirement already satisfied (use --upgrade to upgrade): simplejson in /usr/lib/python2.7/dist-packages (from -r requirements.txt (line 2))
Cleaning up...

$ deactivate

$ rmvirtualenv test
Removing test...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If requirements.txt is like :</p>
<pre><code>django
oursql
sys
notexistingmodule
</code></pre>
<p>Then the following script will tell you which modules are missing :</p>
<pre><code>#!/usr/bin/python3
fname = 'requirements.txt'
with open(fname, 'r', encoding='utf-8') as fhd:
    for line in fhd:
        try:
            exec("import " + line)
        except:
            print("[ERROR] Missing module:", line)
</code></pre>
<p>This would print :</p>
<pre><code>[ERROR] Missing module: notexistingmodule
</code></pre>
</div>
<span class="comment-copy">As a bonus, this automatically recursively detects conflicting version requirements -- these would be unsatisfiable.</span>
<span class="comment-copy">Loop over the require call with a try: except pkg_resources.DistributionNotFound wrapping the call. Then on exception you print. This way it'll tell you all missing dependencies and not die on the first missing one found.</span>
<span class="comment-copy">@GeorgeAppleton To build upon your suggestion, I have updated <a href="https://stackoverflow.com/a/45474387/832230">my answer</a> to use subtests.</span>
<span class="comment-copy">This is truly a great idea!</span>
<span class="comment-copy">This would fail if requirements.txt contains version info e.g. <code>django==1.5.1</code></span>
<span class="comment-copy">Indeed. And it will fail if modules are listed in one line too. It will work, as stated, if requirements.txt list one module per line.</span>
<span class="comment-copy">Are you sure that package name is the same as module name?</span>
<span class="comment-copy">What about <code>python-memcached</code>, <code>django-json-field</code>, <code>django-statsd-mozilla</code>, etc?</span>
