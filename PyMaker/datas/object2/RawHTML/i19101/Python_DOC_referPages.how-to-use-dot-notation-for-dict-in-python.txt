<div class="post-text" itemprop="text">
<p>I'm very new to python and I wish I could do <code>.</code> notation to access values of a <code>dict</code>. </p>
<p>Lets say I have <code>test</code> like this:</p>
<pre><code>&gt;&gt;&gt; test = dict()
&gt;&gt;&gt; test['name'] = 'value'
&gt;&gt;&gt; print(test['name'])
value
</code></pre>
<p>But I wish I could do <code>test.name</code> to get <code>value</code>. Infact I did it by overriding the <code>__getattr__</code> method in my class like this:</p>
<pre><code>class JuspayObject:

    def __init__(self,response):
        self.__dict__['_response'] = response

    def __getattr__(self,key): 
        try:
            return self._response[key]
        except KeyError,err:
            sys.stderr.write('Sorry no key matches')
</code></pre>
<p>and this works! when I do:</p>
<pre><code>test.name // I get value.
</code></pre>
<p>But the problem is when I just print <code>test</code> alone I get the error as:</p>
<pre><code>'Sorry no key matches'
</code></pre>
<p>Why is this happening?</p>
</div>
<div class="post-text" itemprop="text">
<p>This functionality already <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer">exists in the standard libraries</a>, so I recommend you just use their class.  </p>
<pre><code>&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; d = {'key1': 'value1', 'key2': 'value2'}
&gt;&gt;&gt; n = SimpleNamespace(**d)
&gt;&gt;&gt; print(n)
namespace(key1='value1', key2='value2')
&gt;&gt;&gt; n.key2
'value2'
</code></pre>
<p>Adding, modifying and removing values is achieved with regular attribute access, i.e. you can use statements  like <code>n.key = val</code> and <code>del n.key</code>.  </p>
<p>To go back to a dict again:</p>
<pre><code>&gt;&gt;&gt; vars(n)
{'key1': 'value1', 'key2': 'value2'}
</code></pre>
<p>The keys in your dict should be string <a href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="noreferrer">identifiers</a> for attribute access to work properly. </p>
<p>Simple namespace was added in Python 3.3.  For older versions of the language, <a href="https://docs.python.org/3/library/argparse.html#argparse.Namespace" rel="noreferrer"><code>argparse.Namespace</code></a> has similar behaviour.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I assume that you are comfortable in Javascript and want to borrow that kind of syntax... I can tell you by personal experience that this is not a great idea.</p>
<p>It sure does look less verbose and neat; but in the long run it is just obscure. Dicts are dicts, and trying to make them behave like objects with attributes will probably lead to (bad) surprises.</p>
<p>If you need to manipulate the fields of an object as if they were a dictionary, you can always resort to use the internal <code>__dict__</code> attribute when you need it, and then it is <em>explicitly</em> clear what you are doing. Or use <code>getattr(obj, 'key')</code> to have into account the inheritance structure and class attributes too.</p>
<p>But by reading your example it seems that you are trying something different... As the dot operator will already look in the <code>__dict__</code> attribute without any extra code.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__getattr__</code> is used as a fallback when all other attribute lookup rules have failed. When you try to "print" your object, Python look for a <code>__repr__</code> method, and since you don't implement it in your class it ends up calling <code>__getattr__</code> (yes, in Python methods are attributes too). You shouldn't assume which key <strong>getattr</strong> will be called with, and, most important, <code>__getattr__</code> must raise an AttributeError if it cannot resolve <code>key</code>.</p>
<p>As a side note: don't use <code>self.__dict__</code> for ordinary attribute access, just use the plain attribute notation: </p>
<pre><code>class JuspayObject:

    def __init__(self,response):
        # don't use self.__dict__ here
        self._response = response

    def __getattr__(self,key):
        try:
            return self._response[key]
        except KeyError,err:
            raise AttributeError(key)
</code></pre>
<p>Now if your class has no other responsability (and your Python version is &gt;= 2.6 and you don't need to support older versions), you may just use a namedtuple : <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="nofollow">http://docs.python.org/2/library/collections.html#collections.namedtuple</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Could you use a <a href="https://stackoverflow.com/questions/2970608/what-are-named-tuples-in-python">named tuple?</a></p>
<pre><code>from collections import namedtuple
Test = namedtuple('Test', 'name foo bar')
my_test = Test('value', 'foo_val', 'bar_val')
print(my_test)
print(my_test.name)
</code></pre>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>You have to be careful when using <code>__getattr__</code>, because it's used for a lot of builtin Python functionality.</p>
<p>Try something like this...</p>
<pre><code>class JuspayObject:

    def __init__(self,response):
        self.__dict__['_response'] = response

    def __getattr__(self, key):
        # First, try to return from _response
        try:
            return self.__dict__['_response'][key]
        except KeyError:
            pass
        # If that fails, return default behavior so we don't break Python
        try:
            return self.__dict__[key]
        except KeyError:
            raise AttributeError, key

&gt;&gt;&gt; j = JuspayObject({'foo': 'bar'})
&gt;&gt;&gt; j.foo
'bar'
&gt;&gt;&gt; j
&lt;__main__.JuspayObject instance at 0x7fbdd55965f0&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Add a <code>__repr__()</code> method to the class so that you can customize the text to be shown on </p>
<pre><code>print text
</code></pre>
<p>Learn more here: <a href="http://www.diveintopython.net/object_oriented_framework/special_class_methods2.html" rel="nofollow">http://www.diveintopython.net/object_oriented_framework/special_class_methods2.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to <a href="https://stackoverflow.com/a/16279578/7665691">this answer</a>, one can add support for nested dicts as well:</p>
<pre><code>from types import SimpleNamespace

class NestedNamespace(SimpleNamespace):
    def __init__(self, dictionary, **kwargs):
        super().__init__(**kwargs)
        for key, value in dictionary.items():
            if isinstance(value, dict):
                self.__setattr__(key, NestedNamespace(value))
            else:
                self.__setattr__(key, value)

nested_namespace = NestedNamespace({
    'parent': {
        'child': {
            'grandchild': 'value'
        }
    },
    'normal_key': 'normal value',
})


print(nested_namespace.parent.child.grandchild)  # value
print(nested_namespace.normal_key)  # normal value
</code></pre>
</div>
<span class="comment-copy">You need to call super class <b>getattr</b> when you ask for attribute that's not in your dict.</span>
<span class="comment-copy">@DavidHeffernan Does an old-style class like the OP's example even have a superclass?</span>
<span class="comment-copy">@Aya No idea. If not, use a new style class. Who still uses old style classes anyway?</span>
<span class="comment-copy">@DavidHeffernan Well, there's still quite a lot of old-style classes in the standard Python lib, e.g. <code>cgi.py</code>.</span>
<span class="comment-copy"><a href="http://www.fabfile.org" rel="nofollow noreferrer">Fabric</a> also has a nice minimal <a href="https://github.com/fabric/fabric/blob/1.13.1/fabric/utils.py#L186" rel="nofollow noreferrer">implementation</a>, which I also posted <a href="http://stackoverflow.com/a/41274937/307614">here</a>.</span>
<span class="comment-copy">Would be nice if you could recurse this.. i.e. accessing <code>myobj.subdict.subdict</code></span>
<span class="comment-copy">@Pithikos There's a 3rd party lib providing that functionality, checkout out <a href="https://pypi.python.org/pypi/python-box/" rel="nofollow noreferrer">python-box</a>.</span>
<span class="comment-copy">Example of a bad surprise: if you have a key in the dict which happens to be a python keyword, e.g. the string <code>'for'</code>, then attribute access fails and there's no elegant way to handle this case properly.  The whole idea is fundamentally broken from the start.</span>
<span class="comment-copy">On the other hand, auto-completion makes for more efficient, less error-prone code.  That would work perfectly <i>If the dict structure can be predefined.</i></span>
<span class="comment-copy">This is an interesting way to access a data structure via dotted notation, but it doesn't seem particularly compatible with JSON or dict. There are libs that use named tuples under the covers that do provide JSON and dict support. Try <a href="https://github.com/dsc/bunch" rel="nofollow noreferrer">github.com/dsc/bunch</a> or <a href="https://github.com/kennknowles/python-jsonpath-rw" rel="nofollow noreferrer">github.com/kennknowles/python-jsonpath-rw</a></span>
<span class="comment-copy"><code>__getattr__</code> is only used as a fallback if no other lookup rule matched, so no need to lookup <code>self.__dict__[key]</code>, it's already been done if <code>__getattr__</code> is called. Just raising <code>AttributeError</code> if the lookup on self._response['key'] failed is enough.</span>
<span class="comment-copy">@brunodesthuilliers Looks like you're right. Strange. Maybe this only used to be necessary back in the days of Python v1.5.</span>
<span class="comment-copy">While this would technically solve the specific case mentioned in the question, hacking up built-in behaviour to patch other hacks of builtin behaviour is objectively bad code.</span>
