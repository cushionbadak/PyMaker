<div class="post-text" itemprop="text">
<p>I'm cleaning up an API library, and trying to figure out the best way to handle unhandled exceptions.</p>
<p>Right now, the library catches just about everything that could go wrong with the API -- credential errors, server errors, urllib2 errors, httplib errors, etc.  There will be edge cases.</p>
<p>My current thinking is that 99% of library users don't care about the exception itself, they just care that the API call failed.  Only developers would care about the exception.</p>
<p>That leads me to this solution :</p>
<pre><code>class ApiError(Exception):
    pass

class ApiUnhandledError(ApiError):
    pass
</code></pre>
<p>Known issues with the API raise an ApiError or specific subclass.</p>
<p>Everything else raises an ApiUnhandledError , with the original error stashed in, which a user can either catch or ignore.</p>
<pre><code>try:
    stuff
except urllib2.UrlError , e :
    raise ApiError(raised=e)
except Exception as e :
    raise ApiUnhandledError(raised=e)
</code></pre>
<p>Does this sound like a good approach to ensuring the users just know a Pass/Fail , while developers can maintain a method of support ?</p>
<p><strong>Update</strong></p>
<p>Based on the consensus of best practices, I won't be trapping this.</p>
<p>The original goal was to allow people to do this:</p>
<pre><code>try:
   stuff_a
   other_stuff
   even_more_stuff

   api.proxy(url)

   again_stuff
   again_others
 except api.ApiUnhandledError , e :
    handle error
 except api.ApiError , e :
    handle error
 except Stuff , e :
     other error
 except:
     raise
</code></pre>
<p>in that example, the user only has to catch ApiError ( and optionally ApiUnhandledError or any of the other subclasses )</p>
<p>i thought this would be largely preferable to every api interaction having its own block :</p>
<pre><code>try:
   stuff_a
   other_stuff
   even_more_stuff

   try:
       api.proxy(url)
     except api.ApiError , e :
        handle error
     except CatchSomething1 , e :
        handle error
     except CatchSomething2 , e :
        handle error
     except CatchSomething3 , e :
        handle error
     except CatchSomething4 , e :
        handle error
     except:
        raise

   again_stuff
   again_others
 except Stuff , e :
     other error
 except:
     raise
</code></pre>
<p>when dealing with urllib2 , i've seem to discover a new exception every day.  these exceptions tend to get very long and difficult to maintain.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your library raises an exception that you had not foreseen and you are not handling, be it so. It could be the sign of a library bug that would be ignored otherwise. If you can make the cause of the error explicit, it is ok to catch and relaunch (e.g. catch a <code>socket.error</code> and relaunch an <code>AuthenticationFailedError</code> in an authenticator method), but it is not fair to mask points of failure to library users (who are programmers themselves).</p>
<p>A user should not attempt to handle or silence errors directly coming from within the library (i.e. not part of your API -- roughly, not written or raised by you), since they are <em>internal</em> to that piece of code. If the library author forgot to handle them or to catch and relaunch a more specific one, it's a bug and it should be reported. If the function makes assumptions on the input (say, for speed), it should be clearly stated in the API reference and any violation is a user's fault.</p>
<p>In Python2 only a classic class or a new style class inheriting from <code>BaseException</code> can be raised, in Python3 classic classes are gone, so anything that your libraries may raise must be inherited from <code>BaseException</code>. Any exception that the user would normally want to handle (this excludes <code>SystemExit</code>, <code>GeneratorExit</code>, <code>KeyboardInterrupt</code>, etc., which make special cases) must inherit from <code>Exception</code>. Failure to do so will be reported when trying to raise it:</p>
<p>Python3:</p>
<pre><code>&gt;&gt;&gt; class Test:
...     pass
... 
&gt;&gt;&gt; raise Test()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: exceptions must derive from BaseException
</code></pre>
<p>Python2:</p>
<pre><code>&gt;&gt;&gt; class Test(object):
...     pass
... 
&gt;&gt;&gt; raise Test()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: exceptions must be old-style classes or derived from BaseException, not Test
&gt;&gt;&gt; 
</code></pre>
<p>That said, you don't need to wrap exceptions inside an <code>UnhandledException</code> container, just make all exceptions in your code inherit from <code>Exception</code>. Masking failures is bad practice (and you should not encourage it), but lazy user can still take advantage of the inheritance from <code>Exception</code> base class and catch all unhandled exceptions with this:</p>
<pre><code>try:
    yourapi.call_me()
except APIKnownError as error:
    report(error)
except Exception as error:
    pass
    # Or whatever
</code></pre>
<p>It is worth noticing that Python offers a <a href="http://docs.python.org/3/library/warnings.html" rel="nofollow"><code>warnings</code></a> module for reporting <em>"some condition in a program, where that condition (normally) doesnâ€™t warrant raising an exception and terminating the program"</em>.</p>
<p>Speaking of application frameworks (not libraries), I like very much the <a href="http://www.tornadoweb.org/en/stable/" rel="nofollow">Tornado</a> approach: it will log all unhandled exceptions and continue if it the error is not critical. I think that this decision should be up to the final user.</p>
</div>
<span class="comment-copy">Are you sure you want to use a mechanism like this? You will just mask a true exception with your "fake" one. I would just leave the unhandled exceptions alone, because they are the most informative that way. If you wanted to log them somewhere or create a general action, that's another story.</span>
<span class="comment-copy">I'm not sure I want to do this.  My concern is that there are a handful of error codes that could pop up from one of the underlying libraries.  Looking at my own "consumer" code that is using this library, I've had to nest the call to this library in its own block and then chain a decent amount of exception handling around it to catch these errors.  I'm trying to port this exception handling upstream, and this seemed like a potential way to minimize most work for consumers - while still preserving the exceptions.</span>
<span class="comment-copy">In your example, I am pondering this:  I catch a <code>socket.error</code> exception , then raise <code>ApiUnhandledError</code> with the instance of <code>socket.error</code> as an attribute.  I don't want to hide the points of failure, I just want library users to have an "easier" time with error handling.  If they care about what the underlying issue is they can easily inspect - the API raised an Exception, that exception stores the original raise. As this library uses the much hated urllib2 package, I'm consolidating all the random edge cases that can occur (aside from 9 explicit catches) into a single ApiUnhandledError.</span>
<span class="comment-copy">@JonathanVanasco, I wouldn't wrap an exception inside another because this will expose an internal dependency to the user: what if you want to switch from <code>socket</code> to a more advanced library using its own error types? The user will have to rewrite his/her handling code without a  reason. I would extract relevant info and use them to build your exception. Also check the edit.</span>
<span class="comment-copy">User exceptions in Python 2 should derive from <code>Exception</code> , not <code>BaseException</code> <a href="http://docs.python.org/2/library/exceptions.html#exceptions.Exception" rel="nofollow noreferrer">docs.python.org/2/library/exceptions.html#exceptions.Exception</a></span>
<span class="comment-copy">That's true (I mentioned it in the answer). But nothing forbids you to inherit from <code>BaseException</code>. Replaced "will" with "must" for clarity.</span>
