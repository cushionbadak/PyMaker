<div class="post-text" itemprop="text">
<p>Here is a function that iterates over permutations of letters in a string:</p>
<pre><code>def permutations(items):
    for x in _permutations_rec('', items, len(items)):
        yield x

def _permutations_rec(current, items, n):
    if len(current) == n:
        yield current
    else:
        for item, other_items in pick_item(items):
            for next_ in _permutations_rec(current+item, other_items, n):
                yield next_

def pick_item(items):
    for i, item in enumerate(items):
        yield item, items[:i] + items[i+1:]

# print permutations
for x in permutations('abc'):
    print x
</code></pre>
<p>In <code>_permutations_rec</code> in <code>else</code> part, I have two loops. In the first one I
pick the next item that I append to the <code>current</code> string. The second loop
iterates the next partial results and yields them.  So, the second <code>for</code> is only to
handle the iterator for the recursive call and "bubble-up" its results.
I have found this pattern frequently when yielding results from recursive calls, e.g. when working with <a href="http://en.wikipedia.org/wiki/Backtracking" rel="nofollow">backtracking</a>.</p>
<p>Question:</p>
<p>Is there an idiomatic, elegant way to use only one loop there, instead of two? Although I know there is nothing wrong there with those two loops, maybe there is some iterator kung-fu that would allow me to use only one (the simpler, the better).</p>
<p><strong>Edit:</strong></p>
<ul>
<li>I know <code>itertools.permutations</code>, my <code>permutations</code> is just a toy example </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In modern Python, you can use <a href="http://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow">yield from</a> to avoid the innermost loop.  Time to upgrade? :^)</p>
<pre><code>    for item, other_items in pick_item(items):
        yield from _permutations_rec(current+item, other_items, n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because <a href="http://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">"simple is better than complex"</a>, you can simply use <a href="http://docs.python.org/3.3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer">itertools.permutations</a>:</p>
<pre><code>from itertools import permutations

for p in permutations('abc'):
    print(p)
</code></pre>
<p>Output:</p>
<pre><code>('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a') 
</code></pre>
<p>If you still want to use your function, yo can use the new python3's <code>yield from</code> statement as <a href="https://stackoverflow.com/questions/16126413/permutations-iterator-recursion-and-double-loop/16126462#16126462">@DSM explained</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>A shorter version of your, almost the same:</p>
<pre><code>In [1]: def permutations(items):
   ....:     if len(items) == 0:
   ....:         yield items
   ....:     else:
   ....:         for n in range(len(items)):
   ....:             for ps in permutations(items[:n]+items[n+1:]):
   ....:                 yield ps + items[n:n+1]
   ....:

In [2]: list(permutations('abc'))
Out[2]: ['cba', 'bca', 'cab', 'acb', 'bac', 'abc']

In [3]: list(permutations(list('abc')))
Out[3]:
[['c', 'b', 'a'],
 ['b', 'c', 'a'],
 ['c', 'a', 'b'],
 ['a', 'c', 'b'],
 ['b', 'a', 'c'],
 ['a', 'b', 'c']]
</code></pre>
<p>BTW: The equivalent code in Scala as following:</p>
<pre><code>scala&gt; def perm[T](xs: List[T]): Iterator[List[T]] = xs match {
     |   case Nil =&gt; Iterator(Nil)
     |   case _ =&gt; for(x &lt;- xs.iterator; ys &lt;- perm(xs diff Seq(x))) yield x::ys
     | }
perm: [T](xs: List[T])Iterator[List[T]]
scala&gt; val itr = perm(List.range(0,100))
itr: Iterator[List[Int]] = non-empty iterator

scala&gt; itr.next
res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
scala&gt; perm(1::2::3::Nil) foreach println
List(1, 2, 3)
List(1, 3, 2)
List(2, 1, 3)
List(2, 3, 1)
List(3, 1, 2)
List(3, 2, 1)
</code></pre>
</div>
<span class="comment-copy">About your edit: sorry, that was just for saying in case you didn't know...</span>
<span class="comment-copy">Sorry me, I should have made it clear earlier in my question</span>
<span class="comment-copy">When I was young, python2.7 was sufficient for everything! What this world turned to! :)</span>
