<div class="post-text" itemprop="text">
<p>I need to build a generator and I was looking for a way to shorten this for loop into a single line. I tried enumerate but that did not work.</p>
<pre><code>counter=0
for element in string:
    if function(element):
        counter+=1
        yield counter
    else:
        yield counter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>counter=0
for element in string:
    counter+=bool(function(element))
    yield counter
</code></pre>
<p>(Yes, adding Booleans to ints works exactly as if <code>True</code> was <code>1</code> and <code>False</code> was <code>0</code>).</p>
<p>The <code>bool()</code> call is only necessary if <code>function()</code> can have return values other than <code>True</code>, <code>False</code>, <code>1</code>, and <code>0</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you can transform the string into an iterator over the <code>function</code> return values:</p>
<pre><code>truths = (function(x) for x in string)
</code></pre>
<p>Then you can map those to 0s and 1s:</p>
<pre><code>onesandzeroes = (1 if function(x) else 0 for x in string)
</code></pre>
<p>And then <a href="http://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow">accumulate</a> them:</p>
<pre><code>running = itertools.accumulate(1 if function(x) else 0 for x in string)
</code></pre>
<p>As the docs note, <code>accumulate</code> was added in Python 3.2. If you're using 2.x, you can copy and paste the "Equivalent to" recipe from the docs. (If you're using 3.0-3.1, you can do the same, but really, in that case, just upgrade.)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3, you can do:</p>
<pre><code>from itertools import accumulate

yield from accumulate(1 if function(x) else 0 for x in string)
</code></pre>
<p>Although I'd use <a href="https://stackoverflow.com/a/16310487/464744">Simeon Visser's answer</a>. While this one may be short, it isn't immediately clear what the code does.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could shorten it to:</p>
<pre><code>counter=0
for element in string:
    if function(element):
        counter+=1
    yield counter
</code></pre>
</div>
<span class="comment-copy">Are you missing a <code>counter=0</code>, or is this supposed to be a closure around whatever <code>counter</code> is in the outer code?</span>
<span class="comment-copy">What version of Python?</span>
<span class="comment-copy">No, I excluded it initially, but I just included it.</span>
<span class="comment-copy">@jamylak: You aren't left with a <code>counter</code> variable at the end.</span>
<span class="comment-copy">This won't work unless <code>function</code> explicitly returns 0 and 1. If it returns, say, <code>None</code> or a string, you'll get <code>TypeError</code>s all over. Even if it returns <code>True</code> and <code>False</code>, the very first value will be <code>False</code> instead of <code>0</code>.</span>
<span class="comment-copy">I'm not sure what "I'm assuming <code>accumulate</code> returns a boolean" means. It returns an iterator. And it's an iterator over whatever addable type you give it (or, rather, over the result of adding whatever type you give itâ€”not quite the same thing, because, e.g., <code>False+True == 1</code>, or, in older Python, <code>(1&lt;&lt;31) + (1&lt;&lt;31) = (1L&lt;&lt;32)</code>).</span>
<span class="comment-copy">@abarnert: Sorry, <code>accumulate</code> should've been <code>function</code></span>
<span class="comment-copy">@Blender: Then it's still wrong, because, as I explained before, the first value you yield will be <code>False</code>, not <code>0</code>.</span>
<span class="comment-copy">I need to keep a running count, so I need to yield with the else statement as well.</span>
<span class="comment-copy">@garlfd: this still yields with every element in the string, it only updates it for some elements.</span>
