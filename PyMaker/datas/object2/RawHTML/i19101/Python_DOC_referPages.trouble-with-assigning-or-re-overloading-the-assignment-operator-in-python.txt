<div class="post-text" itemprop="text">
<p>I'm having trouble assigning the assignment operator.</p>
<p>I have successfully overloaded <code>__setattr__</code>.  But after the object is initialized, I want <code>__setattr__</code> to do something else, so I try assigning it to be another function, <code>__setattr2__</code>.</p>
<p>Code:</p>
<pre><code>class C(object):

    def __init__(self):
        self.x = 0
        self.__setattr__ = self.__setattr2__

    def __setattr__(self, name, value):
        print "first, setting", name
        object.__setattr__(self, name, value)

    def __setattr2__(self, name, value):
        print "second, setting", name
        object.__setattr__(self, name, value)

c = C()
c.x = 1
</code></pre>
<p>What I get:</p>
<pre><code>first, setting x
first, setting __setattr__
first, setting x
</code></pre>
<p>What I want/expect:</p>
<pre><code>first, setting x
first, setting __setattr__
second, setting x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/reference/datamodel.html#new-style-special-lookup" rel="noreferrer">From the docs</a>:</p>
<blockquote>
<h2>Special method lookup for new-style classes</h2>
<p>For new-style classes, implicit invocations of special methods are
  only guaranteed to work correctly if defined on an object’s type, not
  in the object’s instance dictionary. That behaviour is the reason why
  the following code raises an exception (unlike the equivalent example
  with old-style classes):</p>
<pre><code>&gt;&gt;&gt; class C(object):
...     pass
...
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.__len__ = lambda: 5
&gt;&gt;&gt; len(c)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object of type 'C' has no len()
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Why not use a flag to indicate that <code>__init__</code> is still in progress?</p>
<pre><code>class C(object):
    def __init__(self):
        # Use the superclass's __setattr__ because we've overridden our own.
        super(C, self).__setattr__('initialising', True)
        self.x = 0
        # the very last thing we do in __init__ is indicate that it's finished
        super(C, self).__setattr__('initialising', False)

    def __setattr__(self, name, value):
        if self.initialising:
            print "during __init__, setting", name
            # I happen to like super() rather than explicitly naming the superclass
            super(C, self).__setattr__(name, value)
        else:
            print "after __init__, setting", name
            super(C, self).__setattr__(name, value)
</code></pre>
</div>
<span class="comment-copy">+1. I knew the behaviour existed but couldn't find the relevant reference in the docs.</span>
<span class="comment-copy">Great answer as to why I can't do it.  The only thing I don't understand is that first I tried it with old-style classes (assigning by <code>self.__dict__[name] = value</code>), and it also didn't work.</span>
<span class="comment-copy">@chappy: old-style as in <code>class C:</code> rather than <code>class C(object):</code>?</span>
<span class="comment-copy">Yes, that too.  (in addition to using <code>__dict__</code> for assignment)</span>
<span class="comment-copy">Really nice workaround, thank you.  The fact that I have to use a workaround, though, makes me suspect that I should solve my more general problem a different way.  But in the mean time I'll use this!</span>
<span class="comment-copy">@chappy: I totally agree with "I should solve my more general problem a different way". I always feel squeamish rummaging around in <code>__dict__</code>. In my opinion, whenever one feels the need for <code>__setattr__</code>, one can generally get the job done with finer-grained <a href="http://docs.python.org/3.3/reference/datamodel.html#descriptors" rel="nofollow noreferrer">descriptors</a> or <a href="http://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">properties</a> (or just a general change of strategy). Your original idea looks like a workaround too!</span>
