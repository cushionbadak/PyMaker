<div class="post-text" itemprop="text">
<p>What's the recommended way to flatten nested lists since the <a href="http://docs.python.org/2/library/compiler.html#module-compiler" rel="noreferrer">deprecation of the compiler package</a>?  </p>
<pre><code>&gt;&gt;&gt; from compiler.ast import flatten
&gt;&gt;&gt; flatten(["junk",["nested stuff"],[],[[]]])
['junk', 'nested stuff']
</code></pre>
<p>I know that there are a few stack overflow answers for list flattening, but I'm hoping for the pythonic, standard package, "one, and preferably only one, obvious way" to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your stated function takes a nested list and flattens that into a new list.</p>
<p>To flatten an arbitrarily nested list into a new list, this works on Python 3 as you expect:</p>
<pre><code>import collections
def flatten(x):
    result = []
    for el in x:
        if isinstance(x, collections.Iterable) and not isinstance(el, str):
            result.extend(flatten(el))
        else:
            result.append(el)
    return result

print(flatten(["junk",["nested stuff"],[],[[]]]))  
</code></pre>
<p>Prints:</p>
<pre><code>['junk', 'nested stuff']
</code></pre>
<p>If you want a generator that does the same thing:</p>
<pre><code>def flat_gen(x):
    def iselement(e):
        return not(isinstance(e, collections.Iterable) and not isinstance(e, str))
    for el in x:
        if iselement(el):
            yield el
        else:
            for sub in flat_gen(el): yield sub

print(list(flat_gen(["junk",["nested stuff"],[],[[[],['deep']]]]))) 
# ['junk', 'nested stuff', 'deep']
</code></pre>
<p>For Python 3.3 and later, use <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow">yield from</a> instead of the loop:</p>
<pre><code>def flat_gen(x):
    def iselement(e):
        return not(isinstance(e, collections.Iterable) and not isinstance(e, str))
    for el in x:
        if iselement(el):
            yield el
        else:
            yield from flat_gen(el)   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/itertools.html#itertools.chain"><code>itertools.chain</code></a> is the best solution for flattening any nested iterable one level - it's highly efficient compared to any pure-python solution.</p>
<p>That said, it will work on <em>all</em> iterables, so some checking is required if you want to avoid it flattening out strings, for example.</p>
<p>Likewise, it won't magically flatten out to an arbitrary depth. That said, generally, such a generic solution isn't required - instead it's best to keep your data structured so that it doesn't require flattening in that way.</p>
<p>Edit: I would argue that if one had to do arbitrary flattening, this is the best way:</p>
<pre><code>import collections

def flatten(iterable):
    for el in iterable:
        if isinstance(el, collections.Iterable) and not isinstance(el, str): 
            yield from flatten(el)
        else:
            yield el
</code></pre>
<p>Remember to use <code>basestring</code> in 2.x over <code>str</code>, and <code>for subel in flatten(el): yield el</code> instead of <code>yield from flatten(el)</code> pre-3.3.</p>
<p>As noted in the comments, I would argue this is the nuclear option, and is likely to cause more problems than it solves. Instead, the best idea is to make your output more regular (output that contains one item still give it as a one item tuple, for example), and do regular flattening by one level where it is introduced, rather than all at the end.</p>
<p>This will produce more logical, readable, and easier to work with code. Naturally, there are cases where you <em>need</em> to do this kind of flattening (if the data is coming from somewhere you can't mess with, so you have no option but to take it in the poorly-structured format), in which case, this kind of solution might be needed, but in general, it's probably a bad idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://funcy.readthedocs.org/en/latest/seqs.html#flatten" rel="nofollow">flatten</a> function from <a href="https://github.com/Suor/funcy" rel="nofollow">funcy</a> library:</p>
<pre><code>from funcy import flatten, isa
flat_list = flatten(your_list)
</code></pre>
<p>You can also explicitly specify which values to follow:</p>
<pre><code># Follow only sets
flat_list = flatten(your_list, follow=isa(set))
</code></pre>
<p>Take a peek at <a href="https://github.com/Suor/funcy/blob/1.0.0/funcy/seqs.py#L147" rel="nofollow">its implementation</a> if you want an algorythm.</p>
</div>
<div class="post-text" itemprop="text">
<p>My ugly <code>while-chain</code> solution, just for fun:</p>
<pre><code>from collections import Iterable
from itertools import chain

def flatten3(seq, exclude=(str,)):
    sub = iter(seq)
    try:
        while sub:
            while True:
                j = next(sub)
                if not isinstance(j, Iterable) or isinstance(j, exclude):
                    yield j
                else:
                    sub = chain(j, sub)
                    break
    except StopIteration:
        return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no built-in method for an list with arbitrary nesting, but something like this...</p>
<pre><code>def flatten(l):
    for i in l:
        if isinstance(i, (list, tuple)):
            for ii in flatten(i):
                yield ii
        else:
            yield i

&gt;&gt;&gt; l = ["junk",["nested stuff"],[],[[]]]
&gt;&gt;&gt; list(flatten(l))
['junk', 'nested stuff']
</code></pre>
<p>...will work for lists and tuples. If you want to support any object which you could use in a <code>for item in object</code> expression, then it's probably best to using duck-typing like this...</p>
<pre><code>def flatten(l):
    for i in l:
        if isinstance(i, (str, bytes)):
            yield i
        else:
            try:
                for ii in flatten(i):
                    yield ii
            except TypeError:
                yield i

&gt;&gt;&gt; l = ["junk",["nested stuff"],[],[[]]]
&gt;&gt;&gt; list(flatten(l))
['junk', 'nested stuff']
</code></pre>
<p>...which is slightly more robust than checking <code>isinstance(el, Iterable)</code>, since it won't cope with some cases, such as this...</p>
<pre><code>class Range10:
    def __getitem__(self, index):
        if index &gt;= 10:
            raise IndexError
        return index

&gt;&gt;&gt; import collections
&gt;&gt;&gt; r10 = Range10()
&gt;&gt;&gt; isinstance(r10, collections.Iterable)
False
&gt;&gt;&gt; list(Range10())
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Built for recursion:  Python 3.6</p>
<pre><code>def flatten(lst):
    """Flattens a list of lists"""
    return [subelem for elem in lst 
                    for subelem in elem]
</code></pre>
<p>Define your types in a list and use the any builtin to check </p>
</div>
<span class="comment-copy">Building a list like this is a really bad solution, a generator would be far more apt.</span>
<span class="comment-copy">I would say 'really bad solution' is a little strong. If the nested list is relatively small, building a generator might be slower. It depends on the need. I posted both.</span>
<span class="comment-copy">It may well be slower to create a generator on a small list, but when it's small, the time difference isn't going to matter. When it's large, however, it may well do. It's best to just use the generator regardless, and it's more readable. Beyond that, <code>hasattr(e, "__iter__")</code> is generally a check better done by using the <code>Iterable</code> ABC - it is more readable that way.</span>
<span class="comment-copy">Thanks.  This may be a silly clarification, but do you have a recommendation for how to uniterate it?  <code>&gt;&gt;&gt; itertools.chain([["junk",["nested stuff"],[],[[]]]]) &lt;itertools.chain object at 0x227dc90&gt;</code>  I usually use list(iterable) to uniterate it, but if I do that in this case, I end up with a nonflat list!</span>
<span class="comment-copy"><i>uniterate</i>? I'm not really sure what that is means to mean. <code>list(iterable)</code> is the best way to get a list from an arbitrary iterable.</span>
<span class="comment-copy">Using list on the above, I get:  <code>&gt;&gt;&gt; list(itertools.chain([["junk",["nested stuff"],[],[[]]]]))</code> <code>[['junk', ['nested stuff'], [], [[]]]]</code> versus <code>flatten()</code> which gives <code>['junk', 'nested stuff']</code></span>
<span class="comment-copy"><code>chain()</code> takes an iterable as each argument, if you want to pass in an iterable, use <code>chain.from_iterable()</code>. Note that it will (as stated in the answer) only remove one layer of nesting. Beyond that, it's not really worth making a generic tool, as different situations will treat different iterables as needing to be flattened (for example, strings).</span>
<span class="comment-copy">Sorry, I'm maybe still not getting it:  <code>&gt;&gt;&gt; list(itertools.chain.from_iterable([["junk",["nested stuff"],[],[[]]]]))</code> gives me <code>['junk', ['nested stuff'], [], [[]]]</code></span>
<span class="comment-copy">I've come to like funcy a lot.  Thanks for the tip.</span>
<span class="comment-copy">-1 - Type checking against lists and tuples makes this extremely inflexible.</span>
<span class="comment-copy">@Lattyware The question was: "What's the recommended way to flatten nested lists..."</span>
<span class="comment-copy">@Lattyware Any comments on the second option?</span>
<span class="comment-copy">Sorry, I was answering on my own question. My problem is that Python is a flexible language and type checking is just a generally bad solution. The asker may think only of lists, but then at some point use some custom data structure that functions like a list, but won't work with your code. Python is designed for duck typing, and so functions that only work with certain types, despite other types being capable are very annoying to work with, and generally a bad idea.</span>
<span class="comment-copy">I'm pretty sure <code>Sequence</code> requires <code>__len__()</code> to be defined, and probably tests it's <code>Iterable</code> too.</span>
