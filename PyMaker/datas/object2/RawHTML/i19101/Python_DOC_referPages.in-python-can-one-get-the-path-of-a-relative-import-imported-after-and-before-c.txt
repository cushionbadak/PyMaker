<div class="post-text" itemprop="text">
<p>I'm looking to get the path of a module after <code>os.chdir</code> has been called.</p>
<p>In this example:</p>
<pre><code>import os

os.chdir('/some/location')
import foo   # foo is located in the current directory.

os.chdir('/other/location')
# How do I get the path of foo now?  ..is this impossible?
</code></pre>
<p>..the <code>foo.__file__</code> variable will be <code>'foo.py'</code>, as will <code>inspect.stack()[0][1]</code> -- yet, there's no way to know where <code>'foo.py'</code> is located now, right?</p>
<p>What could I use, outside (or inside, without storing it as a variable at import time) of <code>'foo'</code>, which would allow me to discover the location of <code>foo</code>?</p>
<p>I'm attempting to build a definitive method to determine which file a module is executing from.  Since I use IPython as a shell, this is something I could actually run into.  </p>
<p>Example usage:<br/>
I have two versions of a project I'm working on, and I'm comparing their behavior during the process of debugging them.  ..let's say they're in the directories <code>'proj1'</code> and <code>'proj2'</code>.  ..which <code>foo</code> do I have loaded in the IPython interpreter again?</p>
<p>The ideal:</p>
<pre><code>In [242]: from my_tools import loc
In [243]: loc(foo)
'/home/blah/projects/proj2/foo.py'
</code></pre>
<p>** As abarnert noted, that is not possible, as python does not record the base directory location of relative imports.  This will, however, work with normal (non-relative) imports.</p>
<p>** Also, regular python (as opposed to IPython) does not allow imports from the current directory, but rather only from the module directory.</p>
</div>
<div class="post-text" itemprop="text">
<p>The information isn't available anymore, period. Tracebacks, the debugger, ipython magic, etc. can't get at it. For example:</p>
<pre><code># foo.py
def bar():
    1/0

$ ipython
In [1]: import foo
In [2]: os.chdir('/tmp')
In [3]: foo.baz()
---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
&lt;ipython-input-5-a70d319d0d05&gt; in &lt;module&gt;()
----&gt; 1 foo.baz()

/private/tmp/foo.pyc in baz()

ZeroDivisionError: integer division or modulo by zero
</code></pre>
<hr/>
<p>So:</p>
<blockquote>
<p>the <code>foo.__file__</code> variable will be <code>'foo.py'</code>, as will <code>inspect.stack()[0][1]</code> -- yet, there's no way to know where <code>'foo.py'</code> is located now, right?</p>
</blockquote>
<p>Right. As you can see, Python treats it as a relative path, and (incorrectly) resolves it according to the current working directory whenever it needs an absolute path.</p>
<blockquote>
<p>What could I use, outside (or inside, without storing it as a variable at import time) of 'foo', which would allow me to discover the location of foo?</p>
</blockquote>
<p>Nothing. You have to store it somewhere.</p>
<p>The obvious thing to do is to store <code>os.path.abspath(foo.__file__)</code> from outside, or <code>os.path.abspath(__file__)</code> from inside, at import time. Not what you were hoping for, but I can't think of anything better.</p>
<hr/>
<p>If you want to get tricky, you can build an <a href="http://www.python.org/dev/peps/pep-0302/" rel="nofollow">import hook</a> that modifies modules as they're imported, adding a new <code>__abspath__</code> attribute or, more simply, changing <code>__file__</code> to always been an abspath. This is easier with the <a href="http://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow"><code>importlib</code></a> module Python 3.1+.</p>
<p>As a quick proof of concept, I slapped together <a href="https://github.com/abarnert/abspathimporter" rel="nofollow"><code>abspathimporter</code></a>. After doing an <code>import imppath</code>, every further <code>import</code> you do that finds a normal .py file or package will absify its <code>__file__</code>.</p>
<p>I don't know whether it works for .so/.pyd modules, or .pyc modules without source. It definitely doesn't work for modules inside zipfiles, frozen modules, or anything else that doesn't use the stock <a href="http://docs.python.org/3/library/importlib.html#importlib.machinery.FileFinder" rel="nofollow"><code>FileFinder</code></a>. It won't retroactively affect the paths of anything imported before it. It requires 3.3+, and is horribly fragile (most seriously, the <code>FileFinder</code> class or its hook function has to be the last thing in <a href="http://docs.python.org/3/library/sys.html#sys.path_hooks" rel="nofollow"><code>sys.path_hooks</code></a>—which it is by default in CPython 3.3.0-3.3.1 on four Mac and linux boxes I tested, but certainly isn't guaranteed).</p>
<p>But it shows what you can do if you want to. And honestly, for playing around in iPython for the past 20 minutes or so, it's kind of handy.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import foo

foodir = os.getcwd()

os.chdir('/other/location')
</code></pre>
<p><code>foodir</code> now has original directory stored in it...</p>
</div>
<span class="comment-copy">What is that <code>loc</code> function? It's not a standard builtin, ipython <code>%magic</code> function, <code>inspect</code> function, or anything else I know about…</span>
<span class="comment-copy">the 'loc' function is what I'm making.  It just returns the path of whatever module calls it, using the stack.  I was looking to make it definitive, but figured there was no way to do so -- which you confirmed.  :-)  Thanks.</span>
<span class="comment-copy">Ah, I get it. If you really want this, what about creating an import hook that automatically does <code>mod.__abspath__ = os.path.abspath(mod.__file__)</code> at import time? That could actually be a pretty handy thing to have with long iPython sessions where you <code>chdir</code> all over the place (which I occasionally do as well)…</span>
<span class="comment-copy">Huh.  That's a good idea.. ..and seeing I just downloaded the ipython code..  :-)</span>
<span class="comment-copy">OK, after 2 hours playing with my proof-of-concept import hook… now I'm thinking it might be worth porting to 2.7 and 3.2 as well. It really is handy for screwing around inside iPython. I don't think it'll be as trivial as in 3.3 (where it's ultimately just a matter of patching <code>Loader.get_filename</code>), but…</span>
<span class="comment-copy">Thanks!  That's what I thought, i just wanted to get an external confirmation.  I appreciate your detailed reply.</span>
<span class="comment-copy">I think the OP already knows this. He wants to know whether there's a way to recover the path "without storing it in a variable at import time". I don't think storing it in a variable before or after import time is the answer he's looking for.</span>
