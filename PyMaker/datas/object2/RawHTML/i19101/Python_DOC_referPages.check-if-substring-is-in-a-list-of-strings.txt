<div class="post-text" itemprop="text">
<p>I have found some answers to this question before, but they seem to be obsolete for the current Python versions (or at least they don't work for me).</p>
<p>I want to check if a substring is contained in a list of strings. I only need the boolean result.</p>
<p>I found this solution:</p>
<pre><code>word_to_check = 'or'
wordlist = ['yellow','orange','red']

result = any(word_to_check in word for word in worldlist)
</code></pre>
<p>From this code I would expect to get a <code>True</code> value. If the word was "der", then the output should be <code>False</code>.</p>
<p>However, the result is a generator function, and I can't find a way to get the <code>True</code> value.</p>
<p>Any idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can import <code>any</code> from <code>__builtin__</code> in case it was replaced by some other <code>any</code>:</p>
<pre><code>&gt;&gt;&gt; from  __builtin__ import any as b_any
&gt;&gt;&gt; lst = ['yellow', 'orange', 'red']
&gt;&gt;&gt; word = "or"
&gt;&gt;&gt; b_any(word in x for x in lst)
True
</code></pre>
<p>Note that in Python 3 <code>__builtin__</code> has been renamed to <code>builtins</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code you posted using <em>any()</em> is correct and should work unless you've redefined it somewhere.</p>
<p>That said, there is a simple and fast solution to be had by using the substring search on a single combined string:</p>
<pre><code>&gt;&gt;&gt; wordlist = ['yellow','orange','red']
&gt;&gt;&gt; combined = '\t'.join(wordlist)

&gt;&gt;&gt; 'or' in combined
True
&gt;&gt;&gt; 'der' in combined
False
</code></pre>
<p>This should work <em>much</em> faster than the approach using <em>any</em>.   The join character can be any character that doesn't occur in one of the words in the wordlist.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a> instead:</p>
<pre><code>colors = ['yellow', 'orange', 'red'] 
search = "or"

result = next((True for color in colors if search in color), False)

print(result) # True
</code></pre>
<p>To show the string that contains the substring:</p>
<pre><code>colors = ['yellow', 'orange', 'red'] 
search = "or"

result = [color for color in colors if search in color]  

print(result) # Orange
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Also if someone wants to check if any of the values of a dictionary exists as a substring in a list of strings, can use this:</p>
<pre><code>list_a = [
    'Copy of snap-009ecf9feb43d902b from us-west-2',
    'Copy of snap-0fe999422014504b6 from us-west-2',
    'Copy of snap-0fe999422014cscx504b6 from us-west-2',
    'Copy of snap-0fe999422sdad014504b6 from us-west-2'
]
dict_b = {
    '/dev/xvda': 'snap-0fe999422014504b6',
    '/dev/xvdsdsa': 'snap-sdvcsdvsdvs'
}

for b1 in dict_b.itervalues():
    result = next( ("found" for a1 in a if b1 in a1), "not found")
    print result 
</code></pre>
<p>It prints</p>
<pre><code>not found
found
</code></pre>
</div>
<span class="comment-copy">The code you posted works fine (except for <code>wordlist</code>/<code>worldlist</code>). I'm guessing you forgot the <code>any()</code> call when you tried it before.</span>
<span class="comment-copy">I missed that you already used <code>any</code>.</span>
<span class="comment-copy">Don't do <code>from numpy import *</code>.  Just <code>import numpy</code> or also common <code>import numpy as np</code>.</span>
<span class="comment-copy">This problem comes up for me all the time when using <code>ipython --pylab</code>, which "helpfully" imports * from numpy for you. In that case you can directly use <code>__builtin__.any</code> without having to import <code>__builtin__</code> like in Ashwini's answer, since <code>__builtin__</code> shows up in interactive shells automatically. Also @DSM: apparently the behavior of <code>numpy.any</code> changed (for the worse) in 1.7.</span>
<span class="comment-copy">Also, see the new answer below that shows a much faster alternative approach by combining the words into a single string.</span>
<span class="comment-copy">You can work around the issue with <code>numpy.any</code> if a list comp is used instead of a generator: <code>np.any([word in x for x in lis])</code>.</span>
<span class="comment-copy">@MarkTolonen <code>np.any</code> is going to be slow then as it generates the whole list first.</span>
<span class="comment-copy">Relatively slower yes, noticeably slower...only the OP can say, but not for his example :)</span>
<span class="comment-copy">+1 for the most readable solution in my opinion</span>
<span class="comment-copy">This is by far the most useful and simple solution in my opinion. It can also be shortened to one line: <code>'or' in '\t'.join(wordlist)</code></span>
<span class="comment-copy">Much faster than going through the list and using 'in' expression on each item</span>
<span class="comment-copy">Very clean and fast solution of the <code>wordlist</code> is not too large...</span>
<span class="comment-copy">That looks like a great way to find the objects with the substring, and could be used also for the True/False objective checking the length of the resulting array.</span>
