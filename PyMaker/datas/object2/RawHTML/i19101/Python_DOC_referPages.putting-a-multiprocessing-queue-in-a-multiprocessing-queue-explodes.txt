<div class="post-text" itemprop="text">
<p>The following code throws an exception AND prints 123 in both python 2.7 and 3.3.</p>
<pre><code>from multiprocessing import Queue

class Pool(object):
    def __init__(self):
        self.q = Queue()

p = Pool()
p.q.put(p)
print(123)
</code></pre>
<p>It's actually some sort of race condition as can be seen here:</p>
<pre><code>yuv@yuvpad2:~/$ python3.3 t.py
123
Traceback (most recent call last):
  File "/home/yuv/Downloads/Python-3.3.0/Lib/multiprocessing/queues.py", line 249, in _feed
yuv@yuvpad2:~/$ 
</code></pre>
<p>The full error is <code>RuntimeError: Queue objects should only be shared between processes through inheritance</code> and the traceback doesn't at all explain how/where it happens. The source of the problem is that an object in a Queue can't reference a Queue. My real use case is actually a worker object and a pool object, where a worker reports it finished working to the Pool's <code>Queue</code>. So I wanted the worker to send itself back to the worker <code>Queue</code>.</p>
<p>The reason I'm not using <code>Queue.Queue</code>,although multithreading would work well for my case, is because in Python 2.7 there's a bug which makes queue.get() ignore Ctrl-C which is just annoying.</p>
<p>Is there a way to do this pattern cleanly?</p>
<p><a href="http://codepad.org/JX0lDoeG" rel="nofollow">The real problem code is on codepad</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I guess there are a couple of ways to do this, but without knowing exactly what it is you wan't to do it's hard to recommend one. </p>
<p>I guess the easiest one would be using 2 different queues for this purpose. One for the incoming workers and one fore the finished workers. </p>
</div>
<div class="post-text" itemprop="text">
<p>The reason that the traceback isn't showing the problem in your code is that the <code>multiprocessing.Queue</code> class starts a background thread, and the exception is being generated in that thread. I get the following traceback...</p>
<pre><code>Traceback (most recent call last):
  File "/usr/lib/python2.7/multiprocessing/queues.py", line 266, in _feed
    send(obj)
  File "/usr/lib/python2.7/multiprocessing/queues.py", line 77, in __getstate__
    assert_spawning(self)
  File "/usr/lib/python2.7/multiprocessing/forking.py", line 51, in assert_spawning
    ' through inheritance' % type(self).__name__
RuntimeError: Queue objects should only be shared between processes through inheritance
</code></pre>
<p>...which I suspect is being initiated by the line...</p>
<pre><code>p.q.put(p)
</code></pre>
<p>...in which you seem to be putting a <code>Pool</code> object containing a <code>Queue</code> object into a <code>Queue</code>, which is not allowed, hence the error.</p>
<p>It would help to clarify exactly what you're trying to achieve if you want a useful solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>What the error is complainig about is this:</p>
<pre><code>p.q.put(p)
</code></pre>
<p>Here you're trying to put an object which references a <code>Queue</code> into a queue. Queues are used to communicate between processes, and the way this works is by pickling whatever you try to put into it, and unpickling it in the other process - but pickling a <code>Queue</code> is not possible, and doesn't even make sense.</p>
<p>That's why when you try to pickle a Queue you get the error you mentioned:</p>
<pre><code>&gt;&gt;&gt; from multiprocessing import Queue
&gt;&gt;&gt; q = Queue()
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.dumps(q)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.2/multiprocessing/queues.py", line 77, in __getstate__
    assert_spawning(self)
  File "/usr/lib/python3.2/multiprocessing/forking.py", line 51, in assert_spawning
    ' through inheritance' % type(self).__name__
RuntimeError: Queue objects should only be shared between processes through inheritance
</code></pre>
<p>If you want to use a Queue to share data between processes, a way is doing it like this:</p>
<pre><code>class Worker(multiprocessing.Process):
    queue = multiprocessing.Queue()
    def run(self):
        print(self.queue.get())
        ...
</code></pre>
<p>For more examples you should check the <a href="http://docs.python.org/3/library/multiprocessing" rel="nofollow">docs</a></p>
</div>
<span class="comment-copy">I'm not sure how having 2 queues would help. I.e. I want to queue an object which can add things to the queue. (See the code on codepad)</span>
<span class="comment-copy">I added the code snippet <a href="http://codepad.org/JX0lDoeG" rel="nofollow noreferrer">codepad.org/JX0lDoeG</a></span>
