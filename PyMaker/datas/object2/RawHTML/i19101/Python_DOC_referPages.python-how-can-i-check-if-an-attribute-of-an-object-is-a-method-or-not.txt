<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1259963/python-assert-that-variable-is-instance-method">Python : Assert that variable is instance method?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I want to define a class with it's <code>__repr__</code> method defined in such a way that it will write out only the names and values of all attributes that are not methods. How can I do this? I have managed to write it like this, but I realize that this does not check for the attribute type.</p>
<pre><code>class Example:
    def __repr__(self):
        return "\n".join(["%s: %s" % (x, getattr(self, x)) for x in dir(self) if not x.startswith('__')])
</code></pre>
<p>What is missing here is the check for the type of the attribute.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>inspect</code> for something like this:</p>
<pre><code>from inspect import ismethod,getmembers

class Example:
    def __repr__(self):
        return "\n".join("%s: %s" % (k, v) for (k,v) in getmembers(self,lambda x: not ismethod(x)))

    def method(self):
        return 1

a = Example()
a.foo = 'bar'
print a
</code></pre>
<p>This also picks up the double underscore attributes (<code>__module__</code>, <code>__doc__</code>).  If you don't want those, you can pretty easily filter them out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try built-in function callable:
<a href="http://docs.python.org/2/library/functions.html#callable" rel="nofollow">http://docs.python.org/2/library/functions.html#callable</a> </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Assuming your class does not define <code>__slots__</code>,</strong> you could also just iterate the instance's <code>__dict__</code> (or via the <a href="http://docs.python.org/3/library/functions.html#vars" rel="nofollow"><code>vars()</code> function</a>).</p>
<pre><code>class Superclass:
    def __init__(self, w):
        self.w = w

class Example(Superclass):
    def __init__(self, x, y, z):
        super().__init__(1234)
        self.x = x
        self.y = y
        self.z = z

    @property
    def x_prop(self):
        return self.x

    @classmethod
    def do_something(cls, z):
        return str(cls) + str(z)

    def __call__(self):
        return 4444

    class_property = 42


    def __repr__(self):
        return "\n".join("%s: [%s]" % (k, v) for (k,v) in vars(self).items())

example = Example(2, lambda y: z, '4')
example2 = Example(example, 6j, b'90')

print(repr(example2))
</code></pre>
<p>This prints</p>
<pre><code>x: [x: [2]
y: [&lt;function &lt;lambda&gt; at 0x7f9368b21ef0&gt;]
z: [4]
w: [1234]]
y: [6j]
z: [b'90']
w: [1234]
</code></pre>
</div>
<span class="comment-copy">You can use inspect.ismethod to find if the attribute is a method type :)</span>
<span class="comment-copy">It will pick up <code>@property</code> and class variables as well.</span>
<span class="comment-copy">I would argue that it <i>should</i> pick up both of those cases.  Definitely property objects.  After all, from an API perspective, there's no difference between a property and an attribute ... but I suppose that really depends on what OP wants :).</span>
<span class="comment-copy">The downside of this is that you can make a callable object an attribute:  <code>e = Example(); e.foo = lambda x:x*x</code> for example.</span>
<span class="comment-copy">Better is <a href="http://stackoverflow.com/a/1260997/1322401">this answer</a> to <a href="http://stackoverflow.com/questions/1259963/python-assert-that-variable-is-instance-method">Assert that variable is instance method?</a>.</span>
