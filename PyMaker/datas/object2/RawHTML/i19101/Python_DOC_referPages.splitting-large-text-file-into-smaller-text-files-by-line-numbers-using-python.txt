<div class="post-text" itemprop="text">
<p>I have a text file say really_big_file.txt that contains:</p>
<pre><code>line 1
line 2
line 3
line 4
...
line 99999
line 100000
</code></pre>
<p>I would like to write a Python script that divides really_big_file.txt into smaller files with 300 lines each. For example, small_file_300.txt to have lines 1-300, small_file_600 to have lines 301-600, and so on until there are enough small files made to contain all the lines from the big file.</p>
<p>I would appreciate any suggestions on the easiest way to accomplish this using Python</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>lines_per_file = 300
smallfile = None
with open('really_big_file.txt') as bigfile:
    for lineno, line in enumerate(bigfile):
        if lineno % lines_per_file == 0:
            if smallfile:
                smallfile.close()
            small_filename = 'small_file_{}.txt'.format(lineno + lines_per_file)
            smallfile = open(small_filename, "w")
        smallfile.write(line)
    if smallfile:
        smallfile.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="http://docs.python.org/2/library/itertools.html#recipes" rel="noreferrer"><code>itertools</code> grouper</a> recipe:</p>
<pre><code>from itertools import izip_longest

def grouper(n, iterable, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)

n = 300

with open('really_big_file.txt') as f:
    for i, g in enumerate(grouper(n, f, fillvalue=''), 1):
        with open('small_file_{0}'.format(i * n), 'w') as fout:
            fout.writelines(g)
</code></pre>
<p>The advantage of this method as opposed to storing each line in a list, is that it works with iterables, line by line, so it doesn't have to store each <code>small_file</code> into memory at once.</p>
<p>Note that the last file in this case will be <code>small_file_100200</code> but will only go until <code>line 100000</code>. This happens because <code>fillvalue=''</code>, meaning I write out <em>nothing</em> to the file when I don't have any more lines left to write because a group size doesn't divide equally. You can fix this by writing to a temp file and then renaming it after instead of naming it first like I have. Here's how that can be done.</p>
<pre><code>import os, tempfile

with open('really_big_file.txt') as f:
    for i, g in enumerate(grouper(n, f, fillvalue=None)):
        with tempfile.NamedTemporaryFile('w', delete=False) as fout:
            for j, line in enumerate(g, 1): # count number of lines in group
                if line is None:
                    j -= 1 # don't count this line
                    break
                fout.write(line)
        os.rename(fout.name, 'small_file_{0}.txt'.format(i * n + j))
</code></pre>
<p>This time the <code>fillvalue=None</code> and I go through each line checking for <code>None</code>, when it occurs, I know the process has finished so I subtract <code>1</code> from <code>j</code> to not count the filler and then write the file. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
import os
import re

MAX_CHUNKS = 300


def writeRow(idr, row):
    with open("file_%d.csv" % idr, 'ab') as file:
        writer = csv.writer(file, delimiter=',', quotechar='\"', quoting=csv.QUOTE_ALL)
        writer.writerow(row)

def cleanup():
    for f in os.listdir("."):
        if re.search("file_.*", f):
            os.remove(os.path.join(".", f))

def main():
    cleanup()
    with open("large_file.csv", 'rb') as results:
        r = csv.reader(results, delimiter=',', quotechar='\"')
        idr = 1
        for i, x in enumerate(r):
            temp = i + 1
            if not (temp % (MAX_CHUNKS + 1)):
                idr += 1
            writeRow(idr, x)

if __name__ == "__main__": main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I do this a more understandable way and using less short cuts in order to give you a further understanding of how and why this works. Previous answers work, but if you are not familiar with certain built-in-functions, you will not understand what the function is doing. </p>
<p>Because you posted no code I decided to do it this way since you could be unfamiliar with things other than basic python syntax given that the way you phrased the question made it seem as though you did not try nor had any clue as how to approach the question</p>
<p>Here are the steps to do this in basic python:</p>
<p>First you should read your file into a list for safekeeping:</p>
<pre><code>my_file = 'really_big_file.txt'
hold_lines = []
with open(my_file,'r') as text_file:
    for row in text_file:
        hold_lines.append(row)
</code></pre>
<p>Second, you need to set up a way of creating the new files by name! I would suggest a loop along with a couple counters:</p>
<pre><code>outer_count = 1
line_count = 0
sorting = True
while sorting:
    count = 0
    increment = (outer_count-1) * 300
    left = len(hold_lines) - increment
    file_name = "small_file_" + str(outer_count * 300) + ".txt"
</code></pre>
<p>Third, inside that loop you need some nested loops that will save the correct rows into an array:</p>
<pre><code>hold_new_lines = []
    if left &lt; 300:
        while count &lt; left:
            hold_new_lines.append(hold_lines[line_count])
            count += 1
            line_count += 1
        sorting = False
    else:
        while count &lt; 300:
            hold_new_lines.append(hold_lines[line_count])
            count += 1
            line_count += 1
</code></pre>
<p>Last thing, again in your first loop you need to write the new file and add your last counter increment so your loop will go through again and write a new file</p>
<pre><code>outer_count += 1
with open(file_name,'w') as next_file:
    for row in hold_new_lines:
        next_file.write(row)
</code></pre>
<p>note: if the number of lines is not divisible by 300, the last file will have a name that does not correspond to the last file line.</p>
<p>It is important to understand why these loops work. You have it set so that on the next loop, the name of the file that you write changes because you have the name dependent on a changing variable. This is a very useful scripting tool for file accessing, opening, writing, organizing etc. </p>
<p>In case you could not follow what was in what loop, here is the entirety of the function:</p>
<pre><code>my_file = 'really_big_file.txt'
sorting = True
hold_lines = []
with open(my_file,'r') as text_file:
    for row in text_file:
        hold_lines.append(row)
outer_count = 1
line_count = 0
while sorting:
    count = 0
    increment = (outer_count-1) * 300
    left = len(hold_lines) - increment
    file_name = "small_file_" + str(outer_count * 300) + ".txt"
    hold_new_lines = []
    if left &lt; 300:
        while count &lt; left:
            hold_new_lines.append(hold_lines[line_count])
            count += 1
            line_count += 1
        sorting = False
    else:
        while count &lt; 300:
            hold_new_lines.append(hold_lines[line_count])
            count += 1
            line_count += 1
    outer_count += 1
    with open(file_name,'w') as next_file:
        for row in hold_new_lines:
            next_file.write(row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>lines_per_file = 300  # Lines on each small file
lines = []  # Stores lines not yet written on a small file
lines_counter = 0  # Same as len(lines)
created_files = 0  # Counting how many small files have been created

with open('really_big_file.txt') as big_file:
    for line in big_file:  # Go throught the whole big file
        lines.append(line)
        lines_counter += 1
        if lines_counter == lines_per_file:
            idx = lines_per_file * (created_files + 1)
            with open('small_file_%s.txt' % idx, 'w') as small_file:
                # Write all lines on small file
                small_file.write('\n'.join(stored_lines))
            lines = []  # Reset variables
            lines_counter = 0
            created_files += 1  # One more small file has been created
    # After for-loop has finished
    if lines_counter:  # There are still some lines not written on a file?
        idx = lines_per_file * (created_files + 1)
        with open('small_file_%s.txt' % idx, 'w') as small_file:
            # Write them on a last small file
            small_file.write('n'.join(stored_lines))
        created_files += 1

print '%s small files (with %s lines each) were created.' % (created_files,
                                                             lines_per_file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had to do the same with 650000 line files.</p>
<p>Use the enumerate index and integer div it (//) with the chunk size</p>
<p>When that number changes close the current file and open a new one</p>
<p>This is a python3 solution using format strings.</p>
<pre><code>chunk = 50000  # number of lines from the big file to put in small file
this_small_file = open('./a_folder/0', 'a')

with open('massive_web_log_file') as file_to_read:
    for i, line in enumerate(file_to_read.readlines()):
        file_name = f'./a_folder/{i // chunk}'
        print(i, file_name)  # a bit of feedback that slows the process down a

        if file_name == this_small_file.name:
            this_small_file.write(line)

        else:
            this_small_file.write(line)
            this_small_file.close()
            this_small_file = open(f'{file_name}', 'a')
</code></pre>
</div>
<span class="comment-copy">Nice, short code and works like charm</span>
<span class="comment-copy">This works perfect</span>
<span class="comment-copy">If you are using the first script in python 3.x, replace the <code>izip_longest</code> with the new <code>zip_longest</code> <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.zip_longest</a></span>
<span class="comment-copy">Hey quick question, would you mind explaining why you using quotechar='\"'   thanks</span>
<span class="comment-copy">I was using it as I had a different quote char ( | ) in my case. You can skip setting this one as the default quote character is (quotes ")</span>
<span class="comment-copy">For people who are concerned about speed, a CSV file with 98500 records (and about 13MB in size) was split with this code in about 2.31 seconds. I'd say that's pretty good.</span>
<span class="comment-copy">Excellent @Ryan Saxe !</span>
<span class="comment-copy">The only thing is that you have to store each <code>small_file</code> in memory at once before writing it with this method, that may or may not be a problem though. Of course you could fix that by just chaing this to write to the file line by line.</span>
