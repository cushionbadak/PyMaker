<div class="post-text" itemprop="text">
<p>I've read a few other SO (<a href="https://stackoverflow.com/questions/146359/python-scope">PythonScope</a> and <a href="https://stackoverflow.com/questions/14323817/global-dictionaries-dont-need-keyword-global-to-modify-them">globals don't need global</a>) but nothing seems to explain as explicitly as I would like and I'm having trouble mentally sifting through whether or not <a href="http://docs.python.org/3/reference/lexical_analysis.html#operators" rel="nofollow noreferrer">PyDocs</a> tells me the answer to my question:</p>
<pre><code>myList = [1]

def foo():
    myList = myList + [2, 3]
def bar():
    myList.extend([2, 3])
def baz():
    myList += [2, 3]
</code></pre>
<p>Now, understandably, </p>
<pre><code>&gt;&gt;&gt; foo()
UnboundLocalError
</code></pre>
<p>and</p>
<pre><code>bar()  # works
myList # shows [1, 2, 3]
</code></pre>
<p>but then</p>
<pre><code>&gt;&gt;&gt; baz()
UnboundLocalError
</code></pre>
<p>I thought, however, that things like <code>+=</code> implicitly called the method operators, in this case <code>extend()</code>, but the error implies that for some reason it does not actually treat <code>+=</code> as <code>extends()</code>. Is this consistent with how Python parsing ought to work?</p>
<p>I would have thought that calling functions that are equivalent to method-operators, they would be equivalent in all cases. Instead it seems that it treats <code>+=</code> as an actual assignment operator. Except, this isn't completely true, because if I do something (admittedly contrived):</p>
<pre><code>myList = range(50000000) # wait a second or two on my laptop before returning
myList += [0]            # returns instantly
myList = myList + [1]    # wait a second or two before returning
</code></pre>
<p>all of which is expected, if <code>+=</code> actually just calls <code>extend()</code>. </p>
<p>Is there some finer distinction (or very obvious point...) that I'm missing that makes it clear that <code>myList</code> in <code>baz()</code> needs to be treated as a local variable, and that therefore the <code>+=</code> cannot be implicitly converted to an <code>extend()</code> such that it recognizes the global variable?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>+=</code> doesn't implicitly call <code>extend()</code>. Firstly, it is an <a href="http://docs.python.org/2/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow">augmented assignment operator</a>.</p>
<p>If you look at the section on <code>assignment</code> it says:</p>
<blockquote>
<p>Assignment of an object to a single target is recursively defined as follows.</p>
<p>If the target is an identifier (name):</p>
<p>If the name does not occur in a global statement in the current code block: the name is bound to the object in the current local namespace.
  Otherwise: the name is bound to the object in the current global namespace.</p>
</blockquote>
<p>Since an augmented assignment is:</p>
<blockquote>
<p>Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement:</p>
</blockquote>
<p>It plays by the same rules. 
As you can see:</p>
<pre><code>&gt;&gt;&gt; def baz():
        myList += [2, 3]


&gt;&gt;&gt; dis.dis(baz)
  2           0 LOAD_FAST                0 (myList)
              3 LOAD_CONST               1 (2)
              6 LOAD_CONST               2 (3)
              9 BUILD_LIST               2
             12 INPLACE_ADD         
             13 STORE_FAST               0 (myList)
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE  
</code></pre>
<blockquote>
<p>An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target. The target is only evaluated once..</p>
</blockquote>
<p>The first call trys to evaluate <code>myList</code>, this results in <code>LOAD_FAST</code> since there was no <code>global</code> statement it is assumed to be a local variable:</p>
<blockquote>
<p><code>LOAD_FAST(var_num)</code></p>
<p>Pushes a reference to the <strong>local</strong> <code>co_varnames[var_num]</code> onto the stack.</p>
</blockquote>
<p>It can't be found so the error is raised. If it <strong>was</strong> found, <strong>then</strong> we get to the oppcode <code>INPLACE_ADD</code> which calls the method <code>myList.__iadd__</code> which does the job of extend, once this operation completes the result will be assigned back to the variable but we never get this far.</p>
<p>You shouldn't really be manipulating <code>global</code>s anyway, return the new result from your function or pass it as a parameter.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you mutate the list, you should say global myList. By mutate I mean change the reference. The first example and the 3rd one is basically same, you just use += for shorthand</p>
<pre><code>myList = [1]

def foo():
    global myList
    myList = myList + [2, 3]
def bar():
    myList.extend([2, 3])
def baz():
    global myList
    myList += [2, 3]

foo()
bar()
baz()
</code></pre>
</div>
<span class="comment-copy">5 years later and this bit me again, but in a different way. If <code>isinstance(other, numpy.ndarray)</code> and <code>isinstance(orig, list)</code>, then <code>orig += other</code> fails with a numpy error (<code>operands could not broadcast</code>) but <code>orig.extend(other)</code> works</span>
<span class="comment-copy">Ah, ok, that makes more sense now, thanks for the explanation. And I'll have to look into messing around with the disassembler a bit more, since familiarity with that would've helped me here. And yes, I wouldn't do this in practice - I made the mistake once, wasn't sure why I got this output so I was curious, but then did the normal thing and just passed it as a parameter. Thanks!</span>
<span class="comment-copy">The examples with the large-range show that my first example (L = L + M) is NOT equivalent to my third example (L += M), otherwise they both would have taken noticeable time, if they are (actively) changing the reference.</span>
<span class="comment-copy">Apparently you're correct, += does not change reference. I've checked this using 'is' operator.</span>
<span class="comment-copy">I mean, I think +=/extend()/append() <i>could</i> implicitly change the reference operator, if it needed to resize the list, but the user/code isn't <i>requiring</i> a reference change. Thanks for posting an answer and following back up on it, I appreciate it!</span>
