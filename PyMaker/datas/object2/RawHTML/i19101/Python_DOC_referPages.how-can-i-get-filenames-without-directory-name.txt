<div class="post-text" itemprop="text">
<p>how can I list only file names in a directory without directory info in the result? I tried</p>
<pre><code>for file in glob.glob(dir+filetype):
    print file
</code></pre>
<p>give me result
<code>/path_name/1.log,/path_name/2.log,....</code>
but what I do need is file name only: <code>1.log</code>, <code>2.log</code>, etc. I do not need the directory info in the result.  is there a simple way to get rid of the path info? I don't want to some substr on the result. Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/os.path.html#os.path.basename" rel="noreferrer"><code>os.path.basename</code></a>:</p>
<blockquote>
<p>Return the base name of pathname <code>path</code>. This is the second element of the pair returned by passing <code>path</code> to the function <code>split()</code>. Note that the result of this function is different from the Unix <code>basename</code> program; where <code>basename</code> for '/foo/bar/' returns 'bar', the <code>basename()</code> function returns an empty string ('').</p>
</blockquote>
<p>So:</p>
<pre><code>&gt;&gt;&gt; os.path.basename('/path_name/1.log,/path_name/2.log')
'2.log'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os

# Do not use 'dir' as a variable name, as it's a built-in function
directory = "path"
filetype  = "*.log"

# ['foo.log', 'bar.log']
[f for f in os.listdir(directory) if f.endswith(filetype[1:])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can do</p>
<pre><code>import os
[file.rsplit(os.path.sep, 1)[1] for file in glob.glob(dir+filetype)]
</code></pre>
</div>
<span class="comment-copy"><code>dir</code> is a built-in function, <code>dir()</code>. You should choose another variable name in case any of your modules use the function, as it could lead to confusing bugs.</span>
<span class="comment-copy">thank you timss for pointing out this</span>
<span class="comment-copy">And likewise, as @timss points out in a comment to his own answer, you shouldn't use <code>file</code> either, as it's the name of a builtin type (and therefore also callable as a function, which works just like <code>open</code>).</span>
<span class="comment-copy">thank you. I applied os.path.basename on the result like this: for file in glob.glob(adir+filetype):     print os.path.basename (file)   I get what I expected.</span>
<span class="comment-copy">Not to sound annoyed or anything, but I genuinely wonder why this is the most popular answer. How is <code>glob.glob</code> and <code>os.path.basename</code> better than the simple <code>os.listdir</code>? <code>os.listdir</code> strikes me as more flexible, especially since it'll give you a list right away, which is probably what you want in most cases. Maybe most people don't like <a href="http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>?</span>
<span class="comment-copy">@timss: The OP specifically wants to get only the files that match a glob-style wildcard expression. Sure, he could use <code>listdir</code> plus <code>fnmatch</code>, or rethink his code (or possibly even his user interface) so he has some other rule instead of a glob-style wildcard expression… but why? That's exactly what <code>glob</code> is for.</span>
<span class="comment-copy">@abarnert Aye, thanks for answering my silly question. I somehow forgot to consider the posibility that OP might use a wildcard expression, and not a simple path.</span>
<span class="comment-copy">Presumably he's got a string <code>filetype="*.log"</code>, so you need to do <code>file.endswith(filetype[1:])</code> or something… and hope that's the only kinds of glob pattern you ever get. (Also, you have to spell the methods right.)</span>
<span class="comment-copy">Of course, but OP doesn't say anything about the use of a filetype variable being final, just how to list all files in a directory with a given filetype without full path. Thanks for pointing out the spelling error.</span>
<span class="comment-copy">Well, you have to assume that his code represents what he's trying to do, especially given that his code apparently already works, other than returning paths instead of just filenames.</span>
<span class="comment-copy">Fair point. I updated my answer (and changed <code>file</code> with <code>f</code> to not overwrite <code>class file(object)</code></span>
<span class="comment-copy">Well, the <code>help</code> is written separately from the code. In CPython 2.x, a <code>file</code> is a wrapper around a <code>PyFile *</code> (as defined <a href="http://hg.python.org/cpython/file/2.7/Objects/fileobject.c" rel="nofollow noreferrer">here</a>). There's no actual inheritance… but since <code>object</code> has no non-default method slots, the <code>help</code> system adds the <code>class foo(object)</code> for any builtin type that doesn't say otherwise, and <code>isinstance</code> and <code>subclass</code> treat any <code>type</code> as if it were a subclass of <code>object</code>, I guess it is correct as far as any reasonable attempt to detect it from within Python. Is that good enough?</span>
<span class="comment-copy">Don't you want <code>[-1]</code> instead?</span>
<span class="comment-copy">Sure, but is there a difference ? Just curious</span>
<span class="comment-copy">I take it back, didn't notice it was <code>rsplit</code> which I'm not familiar with.</span>
<span class="comment-copy">The whole reason for <code>os.path</code> is that you shouldn't try to do pathname manipulation in terms of string manipulation, because it's harder to read, easier to get wrong, and more likely to confuse other readers (as happened with Mark Ransom). Also, this is presumably the kind of thing the OP meant by "I don't want to some substr on the result".</span>
<span class="comment-copy">@abarnert - good to know. thanks.</span>
