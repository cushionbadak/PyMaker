<div class="post-text" itemprop="text">
<p>Why is it that in the following code, using a class variable as a method pointer results in unbound method error, while using an ordinary variable works fine:</p>
<pre><code>class Cmd: 
    cmd = None

    @staticmethod   
    def cmdOne():
        print 'cmd one'

    @staticmethod   
    def cmdTwo():
        print 'cmd two'

def main():
    cmd = Cmd.cmdOne
    cmd() # works fine

    Cmd.cmd = Cmd.cmdOne        
    Cmd.cmd() # unbound error !!

if __name__=="__main__":
    main()
</code></pre>
<p>The full error: </p>
<pre><code>TypeError: unbound method cmdOne() must be called with Cmd instance as 
           first argument (got nothing instead)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like to view this behaviour from the "bottom up".</p>
<p>A function in Python acts as a "<a href="http://docs.python.org/2/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor object</a>". As such, it has a <code>__get__()</code> method.</p>
<p>A read access to a class attribute which has such a <code>__get__()</code> method is "redirected" to this method. A attribute access to the class is executed as <code>attribute.__get__(None, containing_class)</code>, while an attribute access to the instance is mapped to <code>attribute.__get__(instance, containing_class)</code>.</p>
<p>A function's <code>__get__()</code> method's task is to wrap the function in a method object which wraps away the <code>self</code> parameter - for the case of an attribute access to the instance. This is called a bound method.</p>
<p>On a class attribute access on 2.x, a function's <code>__get__()</code> returns an unbound method wrapper, while, as I <a href="https://stackoverflow.com/a/16244344/296974">learned today</a>, on 3.x, it returns itself. (Note that the <code>__get__()</code> mechanism still exists in 3.x, but a function just returns itself.) That's nearly the same, if you look at how it is called, but an unbound method wrapper additionally checks for the correct type of the <code>self</code> argument.</p>
<p>A <code>staticmethod()</code> call just creates an object whose <code>__get__()</code> call is designed to return the originally given object so that it undoes the described behaviour. That's how <a href="https://stackoverflow.com/a/16229814/296974">HYRY's trick</a> works: the attribute acces undoes the <code>staticmethod()</code> wrapping, the call does it again so that the "new" attribute has the same status as the old one, although in this case, <code>staticmethod()</code> seems to be applied twice (but really isn't).</p>
<p>(BTW: It even works in this weird context:</p>
<pre><code>s = staticmethod(8)
t = s.__get__(None, 2) # gives 8
</code></pre>
<p>although <code>8</code> is not a function and <code>2</code> is not a class.)</p>
<p>In your question, you have two situations:</p>
<pre><code>cmd = Cmd.cmdOne
cmd() # works fine
</code></pre>
<p>accesses the class and asks for its <code>cmdOne</code> attribute, a <code>staticmethod()</code> object. This is queried via its <code>__get__()</code> and returns the original function, which is then called. That's why it works fine.</p>
<pre><code>Cmd.cmd = Cmd.cmdOne
Cmd.cmd() # unbound error
</code></pre>
<p>does the same, but then assigns this function to <code>Cmd.cmd</code>. The next line is an attribute access - which does, again, the <code>__get__()</code> call to the function itself and thus returns an unbound method, which must be called with a correct <code>self</code> object as first argument.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <code>staticmethod()</code> to convert the function:</p>
<pre><code>Cmd.cmd = staticmethod(Cmd.cmdOne)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're running into the behavior of "unbound methods" in Python 2.x. Basically, in Python 2.x, when you get an attribute of a class (e.g. in this case <code>Cmd.cmd</code>), and the value is a function, then the class "wraps" the function into a special "unbound method" object, because they assume that attributes of classes that are functions and are not decorated with <code>staticmethod</code> or <code>classmethod</code> are meant to be instance methods (an incorrect assumption in this case). This unbound method expects an argument when called, even though in this case the underlying function does not expect an argument.</p>
<p>This behavior is explained in the <a href="http://docs.python.org/2/reference/datamodel.html" rel="nofollow">language reference</a>:</p>
<p>(in the "Classes" section)</p>
<blockquote>
<p>When a class attribute reference (for class C, say) would yield a
  user-defined function object or [...], it is
  transformed into an unbound user-defined method object whose im_class
  attribute is C.</p>
</blockquote>
<p>(in the "User-defined methods" section)</p>
<blockquote>
<p>When a user-defined method object is created by retrieving a
  user-defined function object from a class, its im_self attribute is
  None and the method object is said to be unbound.</p>
</blockquote>
<p>[...]</p>
<blockquote>
<p>When an unbound user-defined method object is called, the underlying
  function (im_func) is called, with the restriction that the first
  argument must be an instance of the proper class (im_class) or of a
  derived class thereof.</p>
</blockquote>
<p>That is what is causing the error you're seeing.</p>
<p>You could explicitly retrieve the underlying function out of the method object and call that (but it's obviously not ideal to need to do this):</p>
<pre><code>Cmd.cmd.im_func()
</code></pre>
<p>Note that Python 3.x <a href="http://docs.python.org/3/whatsnew/3.0.html#operators-and-special-methods" rel="nofollow">got rid of unbound methods</a> and your code would run fine on Python 3.x</p>
</div>
<span class="comment-copy">Doesn't answer question.</span>
<span class="comment-copy">To be exact, it is the function itself which "wraps" itself into an "unbound method" object: by accessing it, the class calls the function's <code>__get__()</code> which creates the wrapper.</span>
