<div class="post-text" itemprop="text">
<p>I'm relatively new to Python, and reading through a <a href="http://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" rel="nofollow noreferrer">tutorial page</a> on the documentation website, I came across this snippet:<img alt="enter image description here" src="https://i.stack.imgur.com/tIFUa.png"/>
This made me curious, so I decided to type it into a Python file and test it out. When I did this, however, it gave me a different result:</p>
<pre><code>   .1+.1+.1 == .3
=&gt; True
</code></pre>
<p>This question may seem trivial, but I'm curious why the actual behavior did not match what the Python documentation said it would do. Any answers?</p>
<p><strong>This behavior occured while using an <a href="http://labs.codecademy.com/" rel="nofollow noreferrer">online interpreter</a>. Running it locally returned False.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You never said which version of Python you're running, and that can make a huge difference. The arithmetic is likely to be IEEE based doubles which should be consistent from system to system. However CPython is based on underlying C libraries, and those can vary in the way they round floating-point constants as they're input. Other versions of Python will also be dependent on some underlying platform.</p>
<p><strong>Edit:</strong> Confirmed. Using the online interpreter given in the question I get:</p>
<pre><code>   '%0.20f' % (.1+.1+.1,)
=&gt; '0.30000000000000004441'
   '%0.20f' % (.3,)
=&gt; '0.30000000000000004441'
</code></pre>
<p>Using Python 2.7 on Windows:</p>
<pre><code>&gt;&gt;&gt; '%0.20f' % (.1+.1+.1,)
'0.30000000000000004441'
&gt;&gt;&gt; '%0.20f' % (.3,)
'0.29999999999999998890'
</code></pre>
<p>It appears the online interpreter rounds the input differently.</p>
</div>
<div class="post-text" itemprop="text">
<p>First comment is the answer. On my system:</p>
<pre><code>Python 2.7.3 (default, Sep 26 2012, 21:53:58) 
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 0.1+0.1+0.1 == 0.3
False
&gt;&gt;&gt;
</code></pre>
<p>from python docs (<a href="http://docs.python.org/2/tutorial/floatingpoint.html" rel="nofollow">http://docs.python.org/2/tutorial/floatingpoint.html</a>):</p>
<blockquote>
<p>Binary floating-point arithmetic holds many surprises like this. The
  problem with “0.1” is explained in precise detail below, in the
  <a href="http://docs.python.org/2/tutorial/floatingpoint.html#representation-error" rel="nofollow">“Representation Error”</a> section. See <a href="http://www.lahey.com/float.htm" rel="nofollow">The Perils of Floating Point</a> for a
  more complete account of other common surprises.</p>
</blockquote>
</div>
<span class="comment-copy">The keyword here is <i>may</i> not. It depends on the floating point implementation of your platform.</span>
<span class="comment-copy">No, they should not. Code is never run in isolation, what comes out depends on what you put in, and running code on Windows can have different results from running the same code on Unix systems, etc.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/tagged/ieee-754">ieee-754</a> is a good starting point to understand what can and cannot happen under the hood.</span>
<span class="comment-copy">@LeeDanielCrocker, as tempting as that would be, there are cases when floating point comparisons are really valid, for example when you want to know if a value changed from some previous saved value.</span>
<span class="comment-copy">This is another one of those questions that seems to be a duplicate of the countless "I don't get floating point" questions, but in fact has a twist. First, the OP has at least done the basic reading, and is even <i>expecting</i> floating point problems. Second, it turns out his environment was really at fault, not a misunderstanding of floats per se. So it's not truly a duplicate in my mind. However, is it worth trying to reopen this question just to get rid of its scarlet letter? That I'm not sure.</span>
<span class="comment-copy">I'm running Python 3.3 -- does Python 3 handle floating point numbers differently than Python 2?</span>
<span class="comment-copy">@jarednielsen, I wouldn't expect so but that's good info, thanks.</span>
<span class="comment-copy">As of version 2.7 and above, CPython has its own code for string to float and float to string conversions; the platform shouldn't made a difference.</span>
<span class="comment-copy">... and it turns out that it's exactly the platform that's the problem.  I retract that last comment.  Apologies.</span>
<span class="comment-copy">Thanks. Do you know what factors would cause the code to return True on one computer and False on another?</span>
<span class="comment-copy">What does it matter? You won't realistically be able to do anything about the inconsistency, and anyway the proper and correct programming practice is to write the code in a way that doesn't care about the result of things like this.</span>
<span class="comment-copy">@jarednielsen added link to article in answer</span>
<span class="comment-copy">@KarlKnechtel, I think it's proper to question why your results should deviate from the official documentation no matter what best practice is.</span>
