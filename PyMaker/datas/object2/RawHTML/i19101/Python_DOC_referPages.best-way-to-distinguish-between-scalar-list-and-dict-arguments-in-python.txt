<div class="post-text" itemprop="text">
<p>I want a function that normally takes in an argument of type X where X is either a scalar, a list, or a dict, and returns a list of X's with the same key values, based on other information.</p>
<pre><code>def foo(info, k):
   return [bar(item,k) for item in processInfo(info)]

def bar(item, keydata):
   # pseudocode follows.
   # What we want to do is return an output of parallel type to the input key k,
   # using the key data to lookup information from the input item.
   if keydata is a scalar:
      return item[keydata]
   elif keydata is a list:
      return [item[k] for k in keydata]
   elif keydata is a dict:
      return dict((k,item[v]) for (k,v) in keydata.iteritems())
   else:
      raise ValueError('bar expects a scalar, list, or dict')
</code></pre>
<p>My question is, how can I dispatch between the three types?</p>
<hr/>
<p>edit: A string is to be interpreted as a scalar, not a list/iterable. Tuples are to be interpreted as iterable.</p>
<p>edit 2: I want duck typing, not strict typing.</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on how strict you want to be with your input. The <code>isinstance</code> approach forces you to specify the types to accept (I.e., no duck-typing). It works as long as your users are only passing in those classes or subtypes of those classes.  You can also try to distinguish parameters by the methods they support. An example of this would be</p>
<p><strong>Edit</strong>: added the special case for strings</p>
<pre><code>if isinstance(keydata, basestring):
    # special case to avoid considering strings as containers
    # for python 3.x use str instead of basestring
    return item[keydata]
try:
    return dict((k,item[v]) for (k,v) in keydata.iteritems())
except AttributeError:
    # it's not a dict-like
    pass
try:
    return [item[k] for k in keydata]
except TypeError:
    # it's not iterable
return item[keydata]
</code></pre>
<p>The choice of control flow depends on how flexible you want to be, and also how you want yo deal with ambiguous cases. Eg, is a string considered a sequence of characters or a scalar?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to do things in the proper order since <code>str</code> and <code>dict</code> types are iterable.</p>
<pre><code>from collections import Iterable, Mapping  # in Python 3 use from collections.abc

def bar(item, keydata):
    if isinstance(keydata, Mapping):
        return {k: item[v] for (k,v) in keydata.iteritems()}
    elif isinstance(keydata, Iterable) and not isinstance(keydata, str):
        return [item[k] for k in keydata]
    return item[keydata]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the new fancy stuff :) by import collections</p>
<pre><code>&gt;&gt;&gt; isinstance([], collections.Sequence)
True
&gt;&gt;&gt; isinstance({}, collections.Mapping)
True
</code></pre>
<p>You should also consider looking at the <a href="http://docs.python.org/2/library/types.html" rel="nofollow">types</a> module</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>if isinstance(keydata,(int,float,str)): #scalar

elif isinstance(keydata,(list,tuple)):#iterable

elif isinstance(keydata,dict):#dictionary
</code></pre>
<p>maybe?? (Im probably missing a few types) ...</p>
</div>
<div class="post-text" itemprop="text">
<p>Or you can use type, but isinstance is recommended according to <a href="http://docs.python.org/2/library/functions.html#type" rel="nofollow">http://docs.python.org/2/library/functions.html#type</a></p>
<pre><code>if type(asd) in (int, str):
    print 'asd is int or str'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for all the information!</p>
<p>I ended up doing this, since I had to do some preprocessing of the <code>keydata</code> prior to iterating over the information:</p>
<pre><code>def asKVlists(keydata):
    # return a tuple (keys, values, isScalar)
    # where keys and values are iterable
    if not isinstance(keydata, basestring):
        # check for dict behavior:
        try:
            return zip(*keydata.iteritems()) + [False]
        except AttributeError:
            pass

        # otherwise check for list behavior
        # make sure we can iterate over it
        try:
            iter(keydata)
            return (None, keydata, False)
        except TypeError:
            pass
    return (None, (keydata,), True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_scalar(x):
    return hasattr(x, 'lower') or not hasattr(x, '__iter__')
</code></pre>
<p>Then you never have to worry about failing an <code>isinstance</code> because of somebody implementing an iterable subclassed from something unexpected.</p>
</div>
<span class="comment-copy">what if an object can exhibit both behaviours of a list and a dict?</span>
<span class="comment-copy">then behavior for dict-like items takes precedence over behavior for iterable items</span>
<span class="comment-copy">This question needs renaming, as it's the best one for determining the difference between dict and list, not just between scalar and nonscalar as the title implies. I keep skipping over it in searches.</span>
<span class="comment-copy">just reworded... how's the title now?</span>
<span class="comment-copy">I've added a minor tweak, but yes much better thanks.</span>
<span class="comment-copy">see my edits in the question. string is a scalar. (for my purposes)</span>
<span class="comment-copy">Would it be acceptable to special-case strings (and unicodes, I assume!) and leave everything else duck-typed? Otherwise you need to specify in more detail what exactly makes strings so special :-)</span>
<span class="comment-copy">Yes... it is ok to special-case strings. Strings are strings. :-)</span>
<span class="comment-copy">@JasonS, why did you accept this answer when it doesn't do the right thing with strings?</span>
<span class="comment-copy">Strings, special cased :-)</span>
<span class="comment-copy"><code>isinstance(''. collections.Sequence)</code> is <code>True</code> too.</span>
<span class="comment-copy">@MartijnPieters shouldn't it be :) I would also say a tuple is a scalar since it is hashable :)</span>
<span class="comment-copy">I'd call them scalars not because they are hashable but because they are immutable, but yes.</span>
<span class="comment-copy"><code>str</code> is an interesting case, it can act both as a scalar and an iterable.</span>
<span class="comment-copy">yeah ... but I figured it was closer to a scalar for OP's needs ...</span>
<span class="comment-copy">oh crap, that makes life more difficult, because I want to treat a string as a scalar, not as an iterable.</span>
<span class="comment-copy">Test against the <a href="http://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">ABC types</a> instead.</span>
<span class="comment-copy">@MarkRansom: it is a iterable scalar... There is no such distinction in Python, really.</span>
<span class="comment-copy">But then I have to worry about somebody implementing an iterable with a <code>lower()</code> attribute or method.</span>
