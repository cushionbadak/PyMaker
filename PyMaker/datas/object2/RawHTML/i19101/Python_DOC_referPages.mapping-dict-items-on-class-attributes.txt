<div class="post-text" itemprop="text">
<p>The <code>__dict__</code> attribute of class instances is very useful for mapping a given <code>dict</code> object to a class instance (the keys of the dict becoming in the process the class instance attributes).</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; class SomeClass(object):
...     def __init__(self):
...         self.numbers = [1, 3, 5, 7, 9]
... 
&gt;&gt;&gt; inst = SomeClass()
&gt;&gt;&gt; inst.__dict__
{'numbers': [1, 3, 5, 7, 9]}
&gt;&gt;&gt; inst.__dict__.update({
...     'letters': ['a', 'b', 'c', 'd'],
...     'numbers': [2, 4, 6, 8, 10]
...     })
&gt;&gt;&gt; inst.letters, inst.numbers
(['a', 'b', 'c', 'd'], [2, 4, 6, 8, 10])
</code></pre>
<p>However, this doesn't work if class attributes are declared as follows:</p>
<pre><code>&gt;&gt;&gt; class SomeClass(object):
...     numbers = [1, 3, 5, 7, 9]
... 
&gt;&gt;&gt; inst = SomeClass()
&gt;&gt;&gt; inst.__dict__
{}
</code></pre>
<p>Is there a way to have access to them in this case ? I mean, is there a way to list them independently of the other special class attributes, such as methods, or defaults attributes ?</p>
</div>
<div class="post-text" itemprop="text">
<p>My advice is that you should avoid modifying <code>__dict__</code>, <code>locals()</code> and so on.</p>
<p>Why not explicitly store the attributes that you're expecting to be dynamic in a dictionary? That way you don't end up having a bunch of objects around with attributes you weren't expecting because they weren't defined in the class and were monkey-patched by code somewhere else.</p>
<p>I think this is a lot clearer and less scary:</p>
<pre><code>class MyClass(object):
    classattrs = {'numbers': [1,2,3,4,5]}

MyClass.classattrs['letters'] = ['a','b','c']
</code></pre>
<p>It boils down to the fact that people expect the contents of a dict to change. They don't expect the attributes of a class to change.</p>
<p>In any case, <code>inspect</code>, <code>dir</code> and their ilk will have trouble filtering out all the other class attributes like special methods and so on.</p>
<p>This idea of keeping names and attributes (reasonably) static has been expressed by people a lot cleverer and more experienced than me: <a href="http://nedbatchelder.com/blog/201112/keep_data_out_of_your_variable_names.html" rel="nofollow">http://nedbatchelder.com/blog/201112/keep_data_out_of_your_variable_names.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Those are <em>class</em> attributes, not instance attributes. Class attributes are shared between instances. This is also how instances inherit the methods of their class. Instance attributes with the same name shadow class attributes, so you can set <code>numbers</code> on the instance to give the instance it's own copy.</p>
<p>You can use <code>dir()</code> on an instance to list a combined view of instance and class attribute names:</p>
<pre><code>&gt;&gt;&gt; inst = SomeClass()
&gt;&gt;&gt; dir(inst)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'numbers']
</code></pre>
<p>You can use <a href="http://docs.python.org/2/library/inspect.html#inspect.getmembers" rel="nofollow"><code>inspect.getmembers()</code></a> to filter on the type of attribute.</p>
<p>Another option is to list the <em>class</em> attributes with <code>__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; vars(type(inst))
dict_proxy({'__dict__': &lt;attribute '__dict__' of 'SomeClass' objects&gt;, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'SomeClass' objects&gt;, 'numbers': [1, 3, 5, 7, 9], '__doc__': None})
&gt;&gt;&gt; {k: v for k, v in vars(type(inst)).iteritems() if not k.startswith('__') and not inspect.isfunction(v)}
{'numbers': [1, 3, 5, 7, 9]}
</code></pre>
<p>From the <a href="http://docs.python.org/3/reference/compound_stmts.html#class-definitions" rel="nofollow">Class definitions documentation</a>:</p>
<blockquote>
<p>Variables defined in the class definition are class attributes; they are shared by instances. Instance attributes can be set in a method with <code>self.name = value</code>. Both class and instance attributes are accessible through the notation “<code>self.name</code>”, and an instance attribute hides a class attribute with the same name when accessed in this way.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>If you define <code>numbers</code> as a class attribute, </p>
<pre><code>class SomeClass(object):
    numbers = [1, 3, 5, 7, 9]
</code></pre>
<p>then it is put in <code>SomeClass.__dict__</code>:</p>
<pre><code>In [5]: SomeClass.__dict__
Out[5]: dict_proxy(
{'__dict__': &lt;attribute '__dict__' of 'SomeClass' objects&gt;,
 '__module__': '__main__',
 '__weakref__': &lt;attribute '__weakref__' of 'SomeClass' objects&gt;,
 'numbers': [1, 3, 5, 7, 9],
 '__doc__': None})
</code></pre>
</div>
<span class="comment-copy">I understand the rationale, but in my particular situation there is no problem changing attributes on-the-fly. If I do this, it is because I find it (paradoxically) easier to deal with.</span>
<span class="comment-copy">On your own head be it! If you want a list of all the attributes that aren't 'magic', you could try filtering out all of the double-underscore names with from <code>inspect.getmembers</code> - something like this: <code>[name, attr for name, attr in inspect.getmembers(MyClass) if not name.startswith('__') and not inspect.ismethod(attr)]</code></span>
<span class="comment-copy"><i>This</i> is scary ! :) So it seems I may be wrong trying to do this. I'll try to find another way around. Thanks for the advice !</span>
<span class="comment-copy">I knew the <code>dir</code> thing, but not <code>inspect.getmembers</code>. However, they seem both to be unusable in my case without using a ugly hack.</span>
