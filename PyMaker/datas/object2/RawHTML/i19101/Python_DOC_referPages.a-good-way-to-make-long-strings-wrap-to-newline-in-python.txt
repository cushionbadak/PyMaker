<div class="post-text" itemprop="text">
<p>In my project, I have a bunch of strings that are read in from a file. Most of them, when printed in the command console, exceed 80 characters in length and wrap around, looking ugly.</p>
<p>I want to be able to have Python read the string, then test if it is over 75 characters in length. If it is, then split the string up into multiple strings, then print one after the other on a new line.
I also want it to be smart, not cutting off full words. i.e. <code>"The quick brown &lt;newline&gt; fox..."</code> instead of <code>"the quick bro&lt;newline&gt;wn fox..."</code>.</p>
<p>I've tried modifying similar code that truncates the string after a set length, but just trashes the string instead of putting it in a new line.</p>
<p>What are some methods I could use to accomplish this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/textwrap.html" rel="noreferrer"><code>textwrap</code></a> module:</p>
<pre><code>&gt;&gt;&gt; import textwrap
&gt;&gt;&gt; strs = "In my project, I have a bunch of strings that are read in from a file. Most of them, when printed in the command console, exceed 80 characters in length and wrap around, looking ugly."
&gt;&gt;&gt; print(textwrap.fill(strs, 20))
In my project, I
have a bunch of
strings that are
read in from a file.
Most of them, when
printed in the
command console,
exceed 80 characters
in length and wrap
around, looking
ugly.
</code></pre>
<p><strong>help</strong> on <a href="https://docs.python.org/3/library/textwrap.html#textwrap.fill" rel="noreferrer"><code>textwrap.fill</code></a>:</p>
<pre><code>&gt;&gt;&gt; textwrap.fill?

Definition: textwrap.fill(text, width=70, **kwargs)
Docstring:
Fill a single paragraph of text, returning a new string.

Reformat the single paragraph in 'text' to fit in lines of no more
than 'width' columns, and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are expanded and other
whitespace characters converted to space.  See TextWrapper class for
available keyword args to customize wrapping behaviour.
</code></pre>
<p>Use <code>regex</code> if you don't want to merge a line into another line:</p>
<pre><code>import re


strs = """In my project, I have a bunch of strings that are.
Read in from a file.
Most of them, when printed in the command console, exceed 80.
Characters in length and wrap around, looking ugly."""

print('\n'.join(line.strip() for line in re.findall(r'.{1,40}(?:\s+|$)', strs)))

# Reading a single line at once:
for x in strs.splitlines():
    print '\n'.join(line.strip() for line in re.findall(r'.{1,40}(?:\s+|$)', x))
</code></pre>
<p><strong>output:</strong></p>
<pre><code>In my project, I have a bunch of strings
that are.
Read in from a file.
Most of them, when printed in the
command console, exceed 80.
Characters in length and wrap around,
looking ugly.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what the <a href="http://docs.python.org/3/library/textwrap.html">textwrap</a> module is for.  Try <code>textwrap.fill(some_string, width=75)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is similar to Ashwini's answer but does not use <code>re</code>:</p>
<pre><code>lim=75
for s in input_string.split("\n"):
    if s == "": print
    w=0 
    l = []
    for d in s.split():
        if w + len(d) + 1 &lt;= lim:
            l.append(d)
            w += len(d) + 1 
        else:
            print " ".join(l)
            l = [d] 
            w = len(d)
    if (len(l)): print " ".join(l)
</code></pre>
<p><strong>Output</strong> when the input is your question:</p>
<pre><code>In my project, I have a bunch of strings that are read in from a file.
Most of them, when printed in the command console, exceed 80 characters in
length and wrap around, looking ugly.

I want to be able to have Python read the string, then test if it is over
75 characters in length. If it is, then split the string up into multiple
strings, then print one after the other on a new line. I also want it to be
smart, not cutting off full words. i.e. "The quick brown &lt;newline&gt; fox..."
instead of "the quick bro&lt;newline&gt;wn fox...".
</code></pre>
</div>
<span class="comment-copy"><a href="http://docs.python.org/3/library/textwrap.html" rel="nofollow noreferrer">textwrap</a> is great for this, but it depends on the format of your file! Is the file a bunch of strings together, or are they on separate lines, because on separate lines, when you use <code>textwrap</code> it will most likely get wonky</span>
<span class="comment-copy">@Ryan-Saxe it's a text file with each string separated by a set character (a pipe, |). textwrap sounds like it would work, then!</span>
<span class="comment-copy">@Ryan-Saxe. This is just on-the-spot logic, but how about putting a terminal character at the end of each line, reading each string into a list, then doing textwrap on each list index? There might need to be some form of character stripping after this, but it sounds like ti would work. Testing now.</span>
<span class="comment-copy">@JoshuaMerriman that wouldn't work because if a line has like 90 characters, the next line would have 10</span>
<span class="comment-copy">@RyanSaxe - what I've done in my project, which may work for others, is I've read each line into an array, then set variables to the values of those arrays. therefore, it does not matter if the strings are on new lines in the source file - they will be in their own variable in the program.</span>
<span class="comment-copy">@RyanSaxe I've added a <code>regex</code> based solution to handle that case.</span>
<span class="comment-copy">Sometimes it's necessary to preserve words longer than the wrap width (e.g. a really long URL). You can use <code>r'(?:\S{41,}|.{1,40})(?:\s+|$)'</code> regex for that instead.</span>
<span class="comment-copy">Thanks for the answer, but frankly I think using <code>textwrap</code> is a much better and easier manage method of wrapping text. that said, it would be good for people who want more flexibility in their line wrapping, or want to understand the logic behind textwrapping to develop their own modules!</span>
<span class="comment-copy">@JoshuaMerriman Yes but that doesn't mean you have to make this the accepted answer. Accept the answer that helped <b>you</b>, you are correct this answer will help people who want to implement this solution by themselves but that doesn't mean we should promote reinventing the wheel. This is not a good reason to unaccepted the answer that you actually used.</span>
<span class="comment-copy">Oops, did I un-accept the last answer? I was under the impression that I could accept multiple answers. I was wrong, though. Terribly sorry!</span>
