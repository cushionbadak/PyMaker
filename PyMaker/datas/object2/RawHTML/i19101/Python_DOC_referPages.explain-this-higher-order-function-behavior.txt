<div class="post-text" itemprop="text">
<p>Can someone explain why version 1 and 2 execute at the same speed? I expected versions 2, 3, and 4 to take about the same amount of time. </p>
<pre><code>def fib(n):
    return n if n in [0, 1] else fib(n-2)+fib(n-1)

def memoize(fn):
    stored_results = {}

    def memoized(*args):
        try:
            return stored_results[args]
        except KeyError:
            #nothing cached
            result = stored_results[args] = fn(*args)
            return result

    return memoized

#version 1 (unmemoized)
print timeit.timeit('fib(35)', 'from __main__ import fib', number=1)
print fib, '\n'

#version 2
memo_fib = memoize(fib)
print timeit.timeit('memo_fib(35)', 'from __main__ import memo_fib', number=1)
print memo_fib, '\n'

#version 3 (wrapped)
fib = memoize(fib)
print timeit.timeit('fib(35)', 'from __main__ import fib', number=1)
print fib, '\n'

#version 4 (w/ decoration line)
@memoize
def fib(n):
    return n if n in [0, 1] else fib(n-2)+fib(n-1)

print timeit.timeit('fib(35)', 'from __main__ import fib', number=1)
</code></pre>
<p>Results: </p>
<pre><code>version 1:  4.95815300941
&lt;function fib at 0x102c2b320&gt; 

version 2:  4.94982290268
&lt;function memoized at 0x102c2b410&gt; 

version 3:  0.000107049942017
&lt;function memoized at 0x102c2b488&gt; 

version 4:  0.000118970870972
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>memoize</code> function isn't actually replacing <code>fib</code> with <code>memo_fib</code>, it's just returning a new function. </p>
<p>That new function still recursively calls the original, un-memoized <code>fib</code>. </p>
<p>So, basically, you're only memoizing the very top level.</p>
<hr/>
<p>Within <code>fib</code>, the recursive call to <code>fib</code> is just using the module-global name. (Functions are basically no different from any other kind of value, and function names no different from any other kind of name, so if you define a function at the module global level, that's what it does. If you, e.g., disassemble the bytecode with <code>dis.dis(fib)</code>, you will see a <code>LOAD_GLOBAL</code> on the name <code>fib</code>.)</p>
<p>So, the easy fix is:</p>
<pre><code>fib = memoize(fib)
</code></pre>
<p>Or just use <code>memoize</code> as a decorator, to make this harder to get wrong. </p>
<p>In other words, your examples 3 and 4.</p>
<p>Or, even more simply, use the built-in <a href="http://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow"><code>lru_cache</code></a> decorator. (Notice the second example in its documentation.)</p>
<hr/>
<p>If you want to be <em>really</em> sneaky: Define <code>fib</code> within a function body. It will end up referencing <code>fib</code> as a closure cell from the defining scope, rather than a global (<code>LOAD_DEREF</code> instead of <code>LOAD_GLOBAL</code> in disassembly). You can then reach into that scope and replace <em>its</em> <code>fib</code>, which means that your recursive function is now memoized "secretly" (the actual global <code>fib</code> isn't memoized, but the function it recursively calls is) and "safely" (nobody else has a reference to the closure cell except through <code>fib</code> itself).</p>
</div>
<div class="post-text" itemprop="text">
<p>In version 2, you've stored the memoized version with a different name, so you wind up calling fib just as many times as in the first version. Your call stack looks like this:</p>
<pre><code>memo_fib(35)
    fib(35)
        fib(34)
            fib(33)
        fib(33)
</code></pre>
<p>etc.</p>
<p>So you aren't actually receiving any benefit from the memoization in this case.</p>
</div>
<span class="comment-copy">Use the <code>timeit</code> module for timing your code.</span>
