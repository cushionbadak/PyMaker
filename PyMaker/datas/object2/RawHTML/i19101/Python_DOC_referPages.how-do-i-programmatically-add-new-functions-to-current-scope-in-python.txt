<div class="post-text" itemprop="text">
<p>In Python <a href="https://stackoverflow.com/questions/4582521/python-creating-dynamic-functions">it is easy to create new functions programmatically</a>. How would I assign this to programmatically determined names in the current scope?</p>
<p>This is what I'd like to do (in non-working code):</p>
<pre><code>obj_types = ('cat', 'dog', 'donkey', 'camel')
for obj_type in obj_types:
    'create_'+obj_type = lambda id: id
</code></pre>
<p>In the above example, the assignment of <code>lambda</code> into a to-be-determined function name obviously does not work. In the real code, the function itself would be created by a function factory.</p>
<p>The background is lazyness and do-not-repeat-yourself: I've got a dozen and more object types for which I'd assign a generated function. So the code currently looks like:</p>
<pre><code>create_cat   = make_creator('cat')
# ...
create_camel = make_creator('camel')
</code></pre>
<p>The functions <code>create_cat</code> etc are used hardcoded in a parser.</p>
<p>If I would create classes as a new type programmatically, <code>types.new_class()</code> as seen in the <a href="http://docs.python.org/3/library/types.html" rel="nofollow noreferrer">docs</a> seems to be the solution.
Is it my best bet to (mis)use this approach?</p>
</div>
<div class="post-text" itemprop="text">
<p>One way to accomplish what you are trying to do (but not create functions with dynamic names) is to store the lamda's in a <code>dict</code> using the name as the key.  Instead of calling <code>create_cat()</code> you would call <code>create['cat']()</code>.  That would dovetail nicely with not hardcoding names in the parser logic as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Vaughn Cato points out that one could just assign into <code>locals()[object_type] = factory(object_type)</code>. However <a href="http://docs.python.org/3/library/functions.html#locals" rel="nofollow">the Python docs prohibit this</a>: "Note: The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter"</p>
<p>D. Shawley points out that it would be wiser to use a <code>dict()</code> object which entries would hold the functions. Access would be simple by using <code>create['cat']()</code> in the parser. While this is compelling I do not like the syntax overhead of the brackets and ticks required.</p>
<p>J.F. Sebastian points to classes. And this is what I ended up with:</p>
<pre><code># Omitting code of these classes for clarity
class Entity:
    def __init__(file_name, line_number):
        # Store location, good for debug, messages, and general indexing

# The following classes are the real objects to be generated by a parser
# Their constructors must consume whatever data is provided by the tokens
# as well as calling super() to forward the file_name,line_number info.
class Cat(Entity): pass
class Camel(Entity): pass

class Parser:
    def parse_file(self, fn):
        # ...

        # Function factory to wrap object constructor calls
        def create_factory(obj_type):
            def creator(text, line_number, token):
                try:
                    return obj_type(*token,
                                    file_name=fn, line_number=line_number)
                except Exception as e:
                    # For debug of constructor during development
                    print(e)
            return creator

        # Helper class, serving as a 'dictionary' of obj construction functions
        class create: pass
            for obj_type in (Cat, Camel):
                setattr(create,
                        obj_type.__name__.lower(),
                        create_factory(obj_type))

        # Parsing code now can use (again simplified for clarity):
        expression = Keyword('cat').setParseAction(create.cat)
</code></pre>
<p>This is helper code for deploying a <a href="http://pyparsing.wikispaces.com/" rel="nofollow">pyparsing parser</a>. D. Shawley is correct in that the dict would actually more easily allow to dynamically generate the parser grammar.</p>
</div>
<span class="comment-copy">You can create a variable with <code>locals()[name] = value</code></span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/4010840/4279">generating variable names on fly in python</a></span>
<span class="comment-copy">@Vaughn: Oh! That is simple, indeed. Why not convert it into an answer?</span>
<span class="comment-copy">@VaughnCato: you shouldn't use <code>locals()</code> in that way.</span>
<span class="comment-copy">@Vaughn: To provide the reasoning behind J.F.'s rejection of using <code>locals()</code> that way, here's what the <a href="http://docs.python.org/3/library/functions.html#locals" rel="nofollow noreferrer">docs think about that</a>: "Note:  The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter"</span>
<span class="comment-copy">This answer and the comment by J.F. Sebastian pushed me to use a class with dynamically defined methods. Will post the code in an answer.</span>
