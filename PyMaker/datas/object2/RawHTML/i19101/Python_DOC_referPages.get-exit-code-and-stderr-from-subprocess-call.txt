<div class="post-text" itemprop="text">
<p>I read up on the functions provided by subprocess - call, check_call, check_output, and understand how each works and differs in functionality from one another.  I am currently using check_output, so I can have access to the stdout, and used "try block" to catch the exception, as follows:</p>
<pre><code># "cmnd" is a string that contains the command along with it's arguments. 
try:
    cmnd_output = check_output(cmnd, stderr=STDOUT, shell=True, timeout=3, universal_newlines=True);                         
except CalledProcessError:                                                                                                   
    print("Status : FAIL")                                                                                                   
print("Output: \n{}\n".format(cmnd_output))                                                                                  
</code></pre>
<p>The issue I am running into is when an exception is thrown, "cmnd_output" is not initialized and don't have access to stderr, and I get the following error message:</p>
<pre><code>print("Output: \n{}\n".format(cmnd_output))
UnboundLocalError: local variable 'cmnd_output' referenced before assignment
</code></pre>
<p>I think thats because the exception causes the "check_output" to bail immediately without any further processing, aka assignment to "cmnd_output", in the try block.  Please correct me if I am wrong.</p>
<p>Is there any way I can get access to stderr (it's ok if it's sent to stout) and have access to the exit code. I can manually check for pass/fail based on exit code with out the exception being throuwn.</p>
<p>Thank you,
Ahmed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this version:</p>
<pre><code>import subprocess
try:
    output = subprocess.check_output(
        cmnd, stderr=subprocess.STDOUT, shell=True, timeout=3,
        universal_newlines=True)
except subprocess.CalledProcessError as exc:
    print("Status : FAIL", exc.returncode, exc.output)
else:
    print("Output: \n{}\n".format(output))
</code></pre>
<p>This way you will print the output only if the call was successful.
In case of a <a href="http://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" rel="noreferrer"><code>CalledProcessError</code></a> you print the return code and the output.</p>
</div>
<div class="post-text" itemprop="text">
<p>The accepted solution covers the case in which you are ok mixing <code>stdout</code> and <code>stderr</code>, but in cases in which the child process (for whatever reason) decides to use <code>stderr</code> IN ADDITION to <code>stdout</code> for a non failed output (i.e. to output a non-critical warning), then the given solution may not desirable.</p>
<p>For example, if you will be doing additional processing on the output, like converting to JSON, and you mix in the <code>stderr</code>, then the overall process will fail since the output will not be pure JSON because of the added <code>stderr</code> output.</p>
<p>I've found the following to work in that case:</p>
<pre><code>cmd_args = ... what you want to execute ...

pipes = subprocess.Popen(cmnd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
std_out, std_err = pipes.communicate()

if pipes.returncode != 0:
    # an error happened!
    err_msg = "%s. Code: %s" % (std_err.strip(), pipes.returncode)
    raise Exception(err_msg)

elif len(std_err):
    # return code is 0 (no error), but we may want to
    # do something with the info on std_err
    # i.e. logger.warning(std_err)

# do whatever you want with std_out
# i.e. json.loads(std_out)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Both of the proposed solutions either mix the stdout/stderr, or use <code>Popen</code> which isn't quite as simple to use as <code>check_output</code>. However, you can accomplish the same thing, and keep stdout/stderr separate, while using <code>check_output</code> if you simply <em>capture stderr</em> by using a pipe:</p>
<pre><code>import sys
import subprocess

try:
    subprocess.check_output(cmnd, stderr=subprocess.PIPE)
except subprocess.CalledProcessError as e:
    print('exit code: {}'.format(e.returncode))
    print('stdout: {}'.format(e.output.decode(sys.getfilesystemencoding())))
    print('stderr: {}'.format(e.stderr.decode(sys.getfilesystemencoding())))
</code></pre>
<p>In this example, since we captured stderr, it's available in the exception's <code>stderr</code> attribute (without capturing with the pipe, it would just be <code>None</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>why not initialize the varible cmnd_output before the try statement? That way it will work the way you expect it to.
Following line would work, just add it above try statement : </p>
<pre><code>cmnd_output = ''
</code></pre>
</div>
<span class="comment-copy">Awesome. That worked out just perfect.  Thank you.</span>
<span class="comment-copy">I am getting this error : <code>ret = subprocess.check_output(cmd , stderr=STDOUT,shell=True)</code> <code>NameError: global name 'STDOUT' is not defined</code></span>
<span class="comment-copy">@ARH, <a href="https://docs.python.org/3/library/subprocess.html#subprocess.STDOUT" rel="nofollow noreferrer">docs.python.org/3/library/subprocess.html#subprocess.STDOUT</a></span>
<span class="comment-copy">Perfect! Do not forget <code>stderr=STDOUT</code>, when you try this approach</span>
<span class="comment-copy">works without timeout=3</span>
<span class="comment-copy">Very useful. This is my use case as well. stdout is used by my target as more of a log output than an error output. By the way, can you comment on the necessity of providing <code>stderr=subprocess.PIPE</code>? I've seen other posts doing it without the additional pipe and I'm not sure why.</span>
<span class="comment-copy">For python 2.7 at least this crashes unless you add shell=True to the Popen</span>
<span class="comment-copy">Thanks, this is very useful. I also needed a <code>.decode("utf-8")</code> after the err's as they are returned in bytes for some reason.</span>
<span class="comment-copy">This solution requires python &gt;= 3.5</span>
<span class="comment-copy">I'm not a Python dev, so forgive the potential ignorance, but the Python docs sound like they suggest <i>not</i> doing <a href="https://docs.python.org/2/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer">this</a>: <code>Note: Do not use stderr=PIPE with this function as that can deadlock based on the child process error volume. Use Popen with the communicate() method when you need a stderr pipe.</code></span>
<span class="comment-copy">I need cmnd_output to be initialized by the content of stdout (and also stderr).  This would happen under most cases except when the exit code of the program is non-zero.</span>
<span class="comment-copy">Exactly, so in case there is an exception your code would print the exception and you won't have anything in the variable. But, when it runs normally(no exceptions) you would get the values of cmnd_output.</span>
