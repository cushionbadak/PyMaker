<div class="post-text" itemprop="text">
<p>Currently, I'm working on a Python program that returns the word that occurs most times in however many lines of input, with the last line being the string "###".</p>
<pre><code>poetry  = []
max = 0
maxitem = None
while True:
 poetry.append(input().lower().split())
for x in poetry:
    count =  poetry.count(x)
if count &gt; max:
    max = count
    maxitem = x
    print(maxitem)
</code></pre>
<p>Now, the main problem I have is the EOF error I get in the body of the while loop.  As far as I can tell, the reason behind this is that it continually calls for a new line of input, but it gets none.  I do not know how to rectify this.  Any help with the rest of the program would be appreciated as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use <code>input()</code> to read data, use <code>sys.stdin</code> instead:</p>
<pre><code>for line is sys.stdin:
    poetry.append(line.lower().split())
</code></pre>
<p>This will read lines from the <code>stdin</code> file handle until closed, without throwing EOF exceptions. The loop body won't execute at all if <code>stdin</code> starts closed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>sys.stdin</code> as suggested by Martijn Pieters is the way to go here, but for completeness here is how you could continue to use <code>input()</code>.  You just need to catch the <code>EOFError</code> exception and exit the loop:</p>
<pre><code>while True:
    try:
        poetry.append(input().lower().split())
    except EOFError:
        break
</code></pre>
</div>
<span class="comment-copy">You could <code>try</code> your code and catch the SyntaxError, making your code process an empty string or just continue iterating.</span>
<span class="comment-copy">@Dolphiniac: What <code>SyntaxError</code>? Did you try running this python-3.x code in 2.x?</span>
<span class="comment-copy">@abarnert Perhaps I did.  Thanks.  I guess I need to update.</span>
<span class="comment-copy">@Dolphiniac: not really, most people are still using 2.x. However, if you want to run 3.x code, install Python 3 alongside 2.</span>
<span class="comment-copy">… or use an online Python 3 interpreter, or just don't answer questions tagged python-3.x. But yeah, I'd suggest having a 3.3.x alongside your 2.x, and putting some time into learning it. The only downside is that once you use <code>yield from</code>, or get exceptions with chained causes while debugging, it's hard to go back to 2.x…</span>
<span class="comment-copy">Thank you, although I'm more inclined to use input(), as that is what is expected of me for this task.</span>
<span class="comment-copy">It's worth pointing out the differences between the two. <code>input</code> will strip each trailing newline (which doesn't matter, since you explicitly call <code>strip</code>). <code>input</code> will work better with certain IDEs/GUI wrappers (which doesn't matter unless you're using one). <code>input</code> will always run immediately, rather than possibly waiting until you hit the EOF, or at least fill a buffer (which doesn't matter since you're not running code that's nearly a slow as a <code>read</code> from a file or a human user, or timing-sensitive). Iterating the file is a lot simpler and easier to read (which always matters).</span>
<span class="comment-copy">You could make this into a simple <code>for</code> loop by using the two-argument form of <a href="http://docs.python.org/3/library/functions.html#iter" rel="nofollow noreferrer"><code>iter</code></a>. (That doesn't mean you <i>should</i>. Especially since, to really do it nicely, you'd want to <code>iter</code> over a wrapper function that converts <code>EOFError</code> to returning a sentinel, at which point you might as well just write a wrapper generator instead.)</span>
