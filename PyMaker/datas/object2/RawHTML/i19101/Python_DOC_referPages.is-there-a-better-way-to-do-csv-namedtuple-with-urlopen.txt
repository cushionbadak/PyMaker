<div class="post-text" itemprop="text">
<p>Using the <a href="http://docs.python.org/3.3/library/collections.html#collections.namedtuple" rel="nofollow">namedtuple</a> documentation example as my template in Python 3.3, I have the following code to download a csv and turn it into a series of namedtuple subclass instances:</p>
<pre><code>from collections import namedtuple
from csv import reader
from urllib.request import urlopen    

SecurityType = namedtuple('SecurityType', 'sector, name')

url = 'http://bsym.bloomberg.com/sym/pages/security_type.csv'
for sec in map(SecurityType._make, reader(urlopen(url))):
    print(sec)
</code></pre>
<p>This raises the following exception:</p>
<pre><code>Traceback (most recent call last):
  File "scrap.py", line 9, in &lt;module&gt;
    for sec in map(SecurityType._make, reader(urlopen(url))):
_csv.Error: iterator should return strings, not bytes (did you open the file in text mode?)
</code></pre>
<p>I know that the issue is that urlopen is returning bytes and not strings and that I need to decode the output at some point. Here's how I'm doing it now, using StringIO:</p>
<pre><code>from collections import namedtuple
from csv import reader
from urllib.request import urlopen
import io

SecurityType = namedtuple('SecurityType', 'sector, name')

url = 'http://bsym.bloomberg.com/sym/pages/security_type.csv'
reader_input = io.StringIO(urlopen(url).read().decode('utf-8'))

for sec in map(SecurityType._make, reader(reader_input)):
    print(sec)
</code></pre>
<p>This smells funny because I'm basically iterating over the bytes buffer, decoding, rebuffering, then iterating over the new string buffer. Is there a more Pythonic way to do this without two iterations? </p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>io.TextIOWrapper()</code></a> to decode the <code>urllib</code> response:</p>
<pre><code>reader_input = io.TextIOWrapper(urlopen(url), encoding='utf8', newline='')
</code></pre>
<p>Now <code>csv.reader</code> is passed the <em>exact same interface</em> that it would get when opening a regular file on the filesystem in text mode.</p>
<p>With this change your example URL works for me on Python 3.3.1:</p>
<pre><code>&gt;&gt;&gt; for sec in map(SecurityType._make, reader(reader_input)):
...     print(sec)
... 
SecurityType(sector='Market Sector', name='Security Type')
SecurityType(sector='Comdty', name='Calendar Spread Option')
SecurityType(sector='Comdty', name='Financial commodity future.')
SecurityType(sector='Comdty', name='Financial commodity generic.')
SecurityType(sector='Comdty', name='Financial commodity option.')
...
SecurityType(sector='Muni', name='ZERO COUPON, OID')
SecurityType(sector='Pfd', name='PRIVATE')
SecurityType(sector='Pfd', name='PUBLIC')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
SecurityType(sector='', name='')
</code></pre>
<p>The last lines appear to yield empty tuples; the original indeed has lines with nothing more than a comma on them.</p>
</div>
<span class="comment-copy">Hmm.  What I was going to recommend (using <code>TextIOWrapper</code>) didn't work, and IMO it should have.  Some digging around revealed <a href="http://bugs.python.org/issue16723" rel="nofollow noreferrer">this bug (issue 16723)</a>, which seems to be the problem.</span>
<span class="comment-copy">@DSM: The patch was already applied in february, so the latest 3.x releases include it. What version of 3.x did you use?</span>
<span class="comment-copy">3.3.0.  I like to stay current, but it hasn't even been a month since 3.3.1 came out. :^)</span>
<span class="comment-copy">See my note above-- though this <i>should</i> work, I don't think it actually does, due to a bug.</span>
<span class="comment-copy">@DSM: The bug has been resolved; this works for me in 3.3.1. I had no problem running the OP example with this change.</span>
