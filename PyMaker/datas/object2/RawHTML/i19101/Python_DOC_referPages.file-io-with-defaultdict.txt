<div class="post-text" itemprop="text">
<p>I'm attempting to:</p>
<ul>
<li>load dictionary</li>
<li>update/change the dictionary</li>
<li>save</li>
<li>(repeat)</li>
</ul>
<p>Problem:  I want to work with just 1 dictionary (players_scores) 
but the defaultdict expression creates a completely seperate dictionary.
How do I load, update, and save to one dictionary? </p>
<p>Code:</p>
<pre><code>from collections import defaultdict#for manipulating dict
players_scores = defaultdict(dict)

import ast #module for removing string from dict once it's called back 


a = {}

open_file = open("scores", "w")
open_file.write(str(a))
open_file.close()

open_file2 = open("scores")
open_file2.readlines()
open_file2.seek(0)



i = input("Enter new player's name: ").upper()
players_scores[i]['GOLF'] = 0 
players_scores[i]['MON DEAL'] = 0
print()

scores_str = open_file2.read()
players_scores = ast.literal_eval(scores_str)
open_file2.close()
print(players_scores)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are <em>wiping</em> your changes; instead of writing out your file, you read it anew and the result is used to <em>replace</em> your <code>players_scores</code> dictionary. Your <code>defaultdict</code> worked just fine before that, even if you can't really use <code>defaultdict</code> here (<code>ast.literal_eval()</code> does <em>not</em> support <code>collections.defaultdict</code>, only standard python literal dict notation).</p>
<p>You can simplify your code by using the <a href="http://docs.python.org/3/library/json.html" rel="nofollow"><code>json</code> module</a> here:</p>
<pre><code>import json

try:
    with open('scores', 'r') as f:
        player_scores = json.load(f)
except IOError:
    # no such file, create an empty dictionary
    player_scores = {}

name = input("Enter new player's name: ").upper()
# create a complete, new dictionary
players_scores[name] = {'GOLF': 0, 'MON DEAL': 0}


with open('scores', 'w') as f:
    json.dump(player_scores, f)
</code></pre>
<p>You don't need <code>defaultdict</code> here at all; you are only creating new dictionary for every player name anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think one problem is that to index the data structure the way you want, something like a <code>defaultdict(defaultdict(dict))</code> is what's really needed â€” but which unfortunately it's impossible to specify one directly like that. However, to workaround that, all you need to do is define a simple intermediary factory function to pass to the upper-level <code>defaultdict</code>:</p>
<pre><code>from collections import defaultdict

def defaultdict_factory(*args, **kwargs):
    """ Create and return a defaultdict(dict). """
    return defaultdict(dict, *args, **kwargs)
</code></pre>
<p>Then you can use <code>players_scores = defaultdict(defaultdict_factory)</code> to create one.</p>
<p>However <code>ast.literal_eval()</code> won't work with one that's been converted to string representation because it's not one of the simple literal data types the function supports. Instead I would suggest you consider using Python's venerable <a href="http://docs.python.org/3/library/pickle.html?highlight=pickle#pickle" rel="nofollow"><code>pickle</code></a> module which can handle most of Python's built-in data types as well custom classes like I'm describing. Here's an example of applying it to your code (in conjunction with the code above):</p>
<pre><code>import pickle

try:
    with open('scores', 'rb') as input_file:
        players_scores = pickle.load(input_file)
except FileNotFoundError:
    print('new scores file will be created')
    players_scores = defaultdict(defaultdict_factory)

player_name = input("Enter new player's name: ").upper()
players_scores[player_name]['GOLF'] = 0
players_scores[player_name]['MON DEAL'] = 0
# below is a shorter way to do the initialization for a new player
# players_scores[player_name] = defaultdict_factory({'GOLF': 0, 'MON DEAL': 0})

# write new/updated data structure (back) to disk
with open('scores', 'wb') as output_file:
    pickle.dump(players_scores, output_file)

print(players_scores)
</code></pre>
</div>
<span class="comment-copy">Don't use <code>ast.literal_eval</code> unless you <i>have</i> to. Use the <code>json</code> module instead, it'll work fine for your needs here. <code>json.dump(fileobj)</code>, then <code>json.load(fileobj)</code> (no <code>.read()</code> or <code>.write()</code> needed).</span>
<span class="comment-copy">Use the right tool for the job. Nice use of the standard lib.</span>
<span class="comment-copy">I've been working on this all weekend and I finally got it!  It's an amazing feeling to have made progress.  Thank you!</span>
<span class="comment-copy">I was reading comparisons between json and pickle and couldn't find an advantageous use for pickle.  Do you prefer it over json for any situations?  Thank you for your post, it's encouraging to receive help.</span>
<span class="comment-copy">@eternal44: <code>pickle</code> supports basic Python types and most user-defined classes with little or no extra work, <code>json</code> supports only a small but important subset of Python's built-in types. On the other hand it is supported by a number of other languages and is therefore more cross-platform and often used for web programming for that reason, if that's a consideration. It's also very fashionable to use <code>json</code> at the moment.</span>
