<div class="post-text" itemprop="text">
<p>normaly I can use eval like that:</p>
<pre><code>new_dict={'color':'green'}
eval("color=='green'",new_dict)
</code></pre>
<p>in this case it would return true and therefore I would know that the color in new_dict is actually green. Now I found some code where somebody wanted to use eval but with a more general object instead of a dict.
In the following code is basicly what this person did:</p>
<pre><code>class myStuff(object):
    def __init__(self):
        self.color = "green"

class Dummy(dict):
    def __init__(self, node):
        dict.__init__(self)
        self.node = node

    def __getitem__(self, key):
        return(getattr(self.node, key))


node=myStuff()
new_dict = Dummy(node)
print eval("color=='green'",new_dict)
</code></pre>
<p>I wonder now - how did the developer of the above code know that eval is using the method <code>__getitem__</code> on new_dict for color? I found the documentation and the python help function, but I couln't find a step-by-step documentation for a method (or the actual code), so that I would never ever came up on the idea to do just that what the above code does. Or is it bad to use the above method, because no one really knows how the eval method has been implemented and the code could therefore come up with some strange errors in future?</p>
<p>EDIT: Here is why eval is used in the program: Imagine you got like 20 objects of myStuff in a list mylist and you want to filter them by color yellow, then one can simply call [ n for n in mylist if eval(query, Dummy(n) ] with `query="color=='yellow'". I am not an expert but I just want to know if this method can lead to problems.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__getitem__</code> function is a way to simulate a dictionary or list (or, more accurately, any mapping or sequence).</p>
<p>The reference documentation for sequences and mappings is in <a href="http://docs.python.org/3/reference/datamodel.html" rel="nofollow">Data model</a>, but the best place to start is probably with the <a href="http://docs.python.org/3/library/collections.abc.html" rel="nofollow"><code>collections.abc</code></a> module, and the links from there.</p>
<p>To summarize the basic idea, when you write code like this:</p>
<pre><code>foo[bar]
</code></pre>
<p>Python translates it into*:</p>
<pre><code>foo.__getitem__(bar)
</code></pre>
<hr/>
<p>There is nothing wrong with defining <code>__getitem__</code> to simulate a <code>dict</code>. </p>
<p>And doing it to create an object that treats its attributes as dict items is such a common pattern that it has a name ("attrdict").</p>
<p>However, using <code>eval</code> <em>is</em> almost always the wrong thing to do. So, doing the right thing to make <code>eval</code> work is, generally, right in that you're doing the right thing, but wrong in that you're using <code>eval</code> in the first place.</p>
<hr/>
<p>In your particular case, there's no good reason to use <code>eval</code> in the first place. Instead of this:</p>
<pre><code>eval("color=='green'",new_dict)
</code></pre>
<p>Just do this:</p>
<pre><code>new_dict['color']=='green'
</code></pre>
<p>One reason Python novices (especially those who grew up on old versions of PHP, Tcl, or JavaScript) often want to use <code>eval</code> is to get an expression they can pass around easily. But in Python (and, for that matter, modern PHP and JS), functions are first-class values, just as easy to pass around as strings—and, unlike strings, of course, they're callable. You can create named or lambda functions, or use <code>partial</code>, close over whatever local variables you want, etc. </p>
<p>There is almost nothing you can do with a string you can't do with a function—except, of course, for opening a gaping security hole, slowing down performance, and hindering debugging.</p>
<p>So, instead of something like this:</p>
<pre><code>expr = "color=='green'"
# ...
eval(expr, new_dict)
</code></pre>
<p>… just do this:</p>
<pre><code>expr = lambda x: x.color=='green'
# ...
expr(new_dict)
</code></pre>
<hr/>
<p>In you edited question:</p>
<blockquote>
<p>Here is why eval is used in the program: Imagine you got like 20 objects of myStuff in a list mylist and you want to filter them by color yellow, then one can simply call [ n for n in mylist if eval(query, Dummy(n) ] with `query="color=='yellow'".</p>
</blockquote>
<p>So, you're presumably doing something like this:</p>
<pre><code>query = "color=={}'.format(color)
# ...
[n for n in mylist if eval(query, Dummy(n)]
</code></pre>
<p>But you could just as easily do this:</p>
<pre><code>[n for n in mylist if n.color == color]
</code></pre>
<p>Even when you need something more dynamic, you can build functions dynamically, even more easily than strings:</p>
<pre><code>query = lambda n: n.color == color
[n for n in mylist if query(n)]
</code></pre>
<p>In fact, if you really want to, you can even make this completely functional:</p>
<pre><code>filter(compose(partial(operator.eq, color), attrgetter('color')), mylist)
</code></pre>
<p>But the great thing about Python is that you don't have to go completely functional or completely imperative, you can write something half-way between—or 25% or 75%, whatever happens to be easiest to read and write.</p>
<hr/>
<p>Meanwhile:</p>
<blockquote>
<p>Or is it bad to use the above method, because no one really knows how the eval method has been implemented and the code could therefore come up with some strange errors in future?</p>
</blockquote>
<p>No, that's almost <em>never</em> a problem. </p>
<p>First, the <a href="http://docs.python.org/3/library/functions.html#eval" rel="nofollow">documentation for <code>eval</code></a> is generally sufficient to predict exactly what it will do, and all Python implementations must follow that documentation.</p>
<p>In the rare occasions where you <em>do</em> need to know more, all of the major implementations are open source, so you can just read the code. For example, you can browse the CPython 3.3 code online <a href="http://hg.python.org/cpython/file/3.3/" rel="nofollow">here</a>.**</p>
<hr/>
<p>* This isn't completely accurate; the real code actually looks up <code>__getitem__</code> in the class rather than the object (slightly differently for old-style vs. new classes in 2.x), and handles extension types from C modules/Java packages/whatever's appropriate to your Python implementation, deals with slices (differently in 2.x vs. 3.x), etc. But that's the basic idea.</p>
<p>** The <code>eval</code> code has been gradually refactored over the years, so at this point you could pretty much reimplement <code>eval</code> in a few lines of pure Python by using the <code>ast</code> module and friends, or a few lines of C using the <code>PyEval*</code> functions, so it's hard to point you to the exact line of code to start in without knowing which implementation and version you care about.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__getitem__</code> is what <code>dict</code>s use to retrieve items by their key. By overriding <code>__getitem__</code> and making it return the attributes of <code>self.node</code>, you essentially turn <code>node</code> into a dictionary.</p>
<p>A simpler way would be to just use the <code>__dict__</code> attribute, which does the same thing:</p>
<pre><code>print eval("color=='green'", node.__dict__)
</code></pre>
<p>But really, don't use this. Please. <code>eval()</code> is rarely the right tool for the job and this is a perfect instance of where you don't need to use <code>eval</code>.</p>
</div>
<span class="comment-copy">Why are you using <code>eval</code> this way? What's wrong with just <code>d['color'] == 'green'</code>?</span>
<span class="comment-copy">It is a perfectly reasonable question to wonder how <i>eval</i> works (i.e. evaluations are performed in namespace that can be an arbitrary mapping using __getitem__).  The technique is versatile and makes it possible to easily implement chained calculations such as those used in spreadsheets (something that can't be easily done with a regular dictionary).</span>
<span class="comment-copy">@RaymondHettinger: Yes, it's reasonable to wonder how <code>eval</code> works, and it actually would be pretty cool if someone wrote the kind of tutorial the OP is searching for. But that doesn't change the fact that, like 99% of the people who have a problem with <code>eval</code>, the OP shouldn't have been using it here. That's why it's always worth asking "Why do you want to use <code>eval</code> here?" first. The worst-case scenario is that they have a good response (which can include "because I want to understand <code>eval</code>") which makes their question more useful for future readers, right?</span>
<span class="comment-copy">@Adam: BTW, "I'm taking over (or patching) someone else's project that (ab)uses <code>eval</code>" may <i>also</i> be a perfectly good response to "Why do you want to use <code>eval</code> here?" Even if it <i>isn't</i> the best answer in this case, refactoring the code to make it unnecessary may not be your top priority. For your own benefit, you should expect Blender's immediate reaction to be your first response (or, if you're unlucky, your first 20), and understand why, so you can figure out how to head them off in advance and get the answer you want.</span>
<span class="comment-copy">Hey thank you for your very long response. Ofc my example to use eval didn't make much sense. I just wanted to motivate the code. I wrote in the Edit section where eval is actually used in the code. Would you still say its not recommended to use it there?</span>
<span class="comment-copy">Yes, it is still not recommended. Let me edit the answer to explain how to do this.</span>
<span class="comment-copy">Thanks for your respond. Actually I work now at a finished program on github and I try to understand what the person before me has done in the code (he's gone now, but at least I can contact him by phone). Imagine you got like 20 objects of myStuff in a list <code>mylist</code> and you want to filter them by color yellow, then one can simply call <code>[ n for n in mylist if eval(query, Dummy(n) ]</code> or as you say <code>[ n for n in mylist if eval(query, n.__dict__ ]</code> with `query="color=='yellow'". I am not an expert but I just want to know if this method can lead to problems. Why would you recommend not to use it?</span>
