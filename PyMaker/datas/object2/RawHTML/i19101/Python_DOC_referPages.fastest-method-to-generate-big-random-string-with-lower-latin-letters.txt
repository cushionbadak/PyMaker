<div class="post-text" itemprop="text">
<p>I'm trying to solve <a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1219" rel="nofollow noreferrer">this</a> problem from Timus Online Judge. To solve this problem you need  generate a sequence of 1 000 000 lowercase Latin letters and write it to stdin in 1 second.</p>
<p>It is easy to solve this problem with C++ or Java. I have python solution here:</p>
<pre><code>import os
from random import randint

s = ''.join(chr(97 + randint(0, 25)) for i in range(1000000))
os.write(1, bytes(s, 'utf8'))
</code></pre>
<p>It takes 1.7s:</p>
<pre><code>$ time python3.3 1219.py &gt; /dev/null

real    0m1.756s
user    0m1.744s
sys     0m0.008s
</code></pre>
<p>And I got "Time limit exceeded" in result. So the question is "How to do it faster?"</p>
<p><strong>UPD1</strong>:
Using <code>randint(97, 122)</code> reduces time at 16ms. Now it is 1.740s</p>
<p><strong>UPD2:</strong>
Solution by @Martijn Pieters takes 0.979s, but it doesn't pass test either.</p>
<p><strong>UPD3</strong>
<a href="https://stackoverflow.com/users/100297/martijn-pieters">Martijn Pieters</a> suggested a very good solutions, but it's still slow:</p>
<pre><code>from sys import stdin
from random import choice
from string import ascii_lowercase

s = ''.join([choice(ascii_lowercase) for _ in range(1000000)])
stdout.write(s) 
</code></pre>
<p>Takes <strong>0.924s</strong></p>
<pre><code>from sys import stdout
from random import choice
from string import ascii_lowercase

for _ in range(1000000):
    stdout.write(choice(ascii_lowercase))
</code></pre>
<p>Takes <strong>1.173s</strong></p>
<pre><code>from sys import stdout
from random import choice
from string import ascii_lowercase
bal = [c.encode('ascii') for c in ascii_lowercase]
out = stdout.buffer

for _ in range(1000000):
    out.write(choice(bal))
</code></pre>
<p>Takes <strong>1.155s</strong></p>
<pre><code>from sys import stdout
from random import choice
from string import ascii_lowercase

bal = [c.encode('ascii') for c in ascii_lowercase]
stdout.buffer.write(b''.join([choice(bal) for _ in range(1000000)]))
</code></pre>
<p>Takes <strong>0.901s</strong></p>
<p><strong>UPD4</strong></p>
<p>Some guy <a href="http://acm.timus.ru/status.aspx?space=1&amp;num=1219" rel="nofollow noreferrer">just solved</a> problem on Timus. I hope he will share his solution :)</p>
<p><strong>UPD5</strong>
Thanks to <a href="https://stackoverflow.com/users/846892/ashwini-chaudhary">Ashwini Chaudhary</a> for sharing his Python 2.x solution with us:</p>
<pre><code>from random import choice
from string import ascii_lowercase
lis=list(ascii_lowercase)
print ''.join(choice(lis) for _ in xrange(1000000)) 
</code></pre>
<p>It takes <strong>0.527s</strong> on my computer and it passes tests on Timus. But problem with Python3.x still remains.</p>
<p><strong>UPD6</strong>
Thanks to <a href="https://stackoverflow.com/users/2275418/markku-k">Markku K.</a> this code:</p>
<pre><code>import os
from random import random
from string import ascii_lowercase

bal = [c.encode('ascii') for c in ascii_lowercase]
os.write(1, b''.join([bal[int(random() * 26)] for _ in range(1000000)]))
</code></pre>
<p>Takes <strong>0.445s</strong>, but still didn't pass the test</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's Python 3 code that generates 1000000 "random" lowercase letters in <code>0.28</code> seconds (see also <code>0.11</code>-seconds solution at the end; @Ashwini Chaudhary's code from the question takes <code>0.55</code> seconds on my machine,  @Markku K.'s code -- <code>0.53</code>):</p>
<pre><code>#!/usr/bin/env python3
import os
import sys

def write_random_lowercase(n):
    min_lc = ord(b'a')
    len_lc = 26
    ba = bytearray(os.urandom(n))
    for i, b in enumerate(ba):
        ba[i] = min_lc + b % len_lc # convert 0..255 to 97..122
    sys.stdout.buffer.write(ba)

write_random_lowercase(1000000)
</code></pre>
<p><code>% len_lc</code> skews the distribution (see at the end on how to fix it) though It still satisfies the conditions (ascii, lowercase, frequencies of 1, 2, 3 letter sequences):</p>
<pre><code>$ python3 generate-random.py | python3 check-seq.py
</code></pre>
<p>where <code>check-seq.py</code>:</p>
<pre><code>#!/usr/bin/env python3
import sys
from collections import Counter
from string import ascii_lowercase

def main():
    limits = [40000, 2000, 100]

    s = sys.stdin.buffer.readline() # a single line
    assert 1000000 &lt;= len(s) &lt;= 1000002 # check length +/- newline
    s.decode('ascii','strict') # check ascii
    assert set(s) == set(ascii_lowercase.encode('ascii')) # check lowercase

    for n, lim in enumerate(limits, start=1):
        freq = Counter(tuple(s[i:i+n]) for i in range(len(s)))
        assert max(freq.values()) &lt;= lim, freq

main()
</code></pre>
<p>Note: on acm.timus.ru <code>generate-random.py</code> gives "Output limit exceeded".</p>
<p>To improve performance, you could use <a href="http://docs.python.org/3.3/library/stdtypes.html#bytes.translate" rel="nofollow"><code>bytes.translate()</code> method</a> (<code>0.11</code> seconds):</p>
<pre><code>#!/usr/bin/env python3
import os
import sys

# make translation table from 0..255 to 97..122
tbl = bytes.maketrans(bytearray(range(256)),
                      bytearray([ord(b'a') + b % 26 for b in range(256)]))
# generate random bytes and translate them to lowercase ascii
sys.stdout.buffer.write(os.urandom(1000000).translate(tbl))
</code></pre>
<h2>How to fix <code>% len_lc</code> skew</h2>
<p><code>256</code> (number of bytes) is not evenly divisible by <code>26</code> (number of lower Latin letters) therefore the formula <code>min_lc + b % len_lc</code> makes some values appear less often than others e.g.:</p>
<pre><code>#!/usr/bin/env python3
"""Find out skew: x = 97 + y % 26 where y is uniform from [0, 256) range."""
from collections import Counter, defaultdict

def find_skew(random_bytes):
    char2freq = Counter(chr(ord(b'a') + b % 26) for b in random_bytes)
    freq2char = defaultdict(set)
    for char, freq in char2freq.items():
        freq2char[freq].add(char)
    return {f: ''.join(sorted(c)) for f, c in freq2char.items()}

print(find_skew(range(256)))
# -&gt; {9: 'wxyz', 10: 'abcdefghijklmnopqrstuv'}
</code></pre>
<p>Here, the input <code>range(256)</code> is uniformly distributed (each byte occurs exactly once) but <code>'wxyz'</code> letters in the output are less often then the rest <code>9</code> vs. <code>10</code> occurrences. To fix it, unaligned bytes could be dropped:</p>
<pre><code>print(find_skew(range(256 - (256 % 26))))
# -&gt; {9: 'abcdefghijklmnopqrstuvwxyz'}
</code></pre>
<p>Here, the input is uniformly distributed bytes in the range <code>[0, 234)</code> the output is uniformly distributed ascii lowercase letters.</p>
<p><code>bytes.translate()</code> accepts the second argument to specify bytes to delete:</p>
<pre><code>#!/usr/bin/env python3
import os
import sys

nbytes = 256
nletters = 26
naligned = nbytes - (nbytes % nletters)
tbl = bytes.maketrans(bytearray(range(naligned)),
                      bytearray([ord(b'a') + b % nletters
                                 for b in range(naligned)]))
bytes2delete = bytearray(range(naligned, nbytes))
R = lambda n: os.urandom(n).translate(tbl, bytes2delete)

def write_random_ascii_lowercase_letters(write, n):
    """*write* *n* random ascii lowercase letters."""    
    while n &gt; 0:
        # R(n) expected to drop `(nbytes - nletters) / nbytes` bytes
        # to compensate, increase the initial size        
        n -= write(memoryview(R(n * nbytes // naligned + 1))[:n])

write = sys.stdout.buffer.write
write_random_ascii_lowercase_letters(write, 1000000)
</code></pre>
<p>If the random generator (<code>os.urandom</code> here) produces long sequences of the bytes that are outside of the aligned range (<code>&gt;=234</code>) then the <code>while</code> loop may execute many times.</p>
<p>The time performance can be improved by another order of magnitude if <a href="https://docs.python.org/library/random.html#random.getrandbits" rel="nofollow"><code>random.getrandbits(8*n).to_bytes(n, 'big')</code></a> is used instead of <a href="https://docs.python.org/library/os.html#os.urandom" rel="nofollow"><code>os.urandom(n)</code></a>. The former uses Mersenne Twister as the core generator that may be faster than <code>os.urandom()</code> that uses sources provided by the operating system. The latter is more secure if you use the random string for secrets.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>string.ascii_lowercase</code> instead of <code>chr</code> to generate lowercase charaters:</p>
<pre><code>from sys import stdin
from random import choice
from string import ascii_lowercase

s = ''.join([choice(ascii_lowercase) for _ in range(1000000)])
stdout.write(s)
</code></pre>
<p>Also writing to <code>stdout</code> directly appears to be faster, encoding yourself in python is not faster than having it all handled in the C code.</p>
<p>I also use a list comprehension; <code>str.join()</code> needs to scan through the input sequence twice, once to determine the length of the output, once to actually copy the input elements to output  string. A list comprehension then beats out the slower generator-to-list code.</p>
<p>Just using <code>choice(ascii_lowercase)</code> over your method of generating each character from an integer is over twice as fast:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('f()', 'from __main__ import yours as f', number=3)
11.299837955011753
&gt;&gt;&gt; timeit.timeit('f()', 'from __main__ import mine as f', number=3)
5.330044150992762
</code></pre>
<p>You could try and avoid the <code>''.join()</code> overhead by writing individual characters directly to <code>stdout</code>:</p>
<pre><code>from sys import stdout
from random import choice
from string import ascii_lowercase

for _ in range(1000000):
    stdout.write(choice(ascii_lowercase))
</code></pre>
<p>Next to try is to write raw bytes:</p>
<pre><code>from sys import stdout
from random import choice
from string import ascii_lowercase
bal = [c.encode('ascii') for c in ascii_lowercase]
out = stdout.buffer

for _ in range(1000000):
    out.write(choice(bal))
</code></pre>
<p>but these are no improvements over <code>''.join()</code> in my tests.</p>
<p>Next we move to encoding the ASCII characters to bytes once, then using <code>bytes.join()</code>:</p>
<pre><code>from sys import stdout
from random import choice
from string import ascii_lowercase

bal = [c.encode('ascii') for c in ascii_lowercase]
stdout.buffer.write(b''.join([choice(bal) for _ in range(1000000)]))
</code></pre>
<p><code>bal</code> is a list of lowercase ASCII characters encoded to bytes, from which we random pick 1 million items, join them to into a large byte string then write that in one go to the binary stdout buffer.</p>
<p>The bytes join is just as 'slow' as the string version:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('f()', 'from __main__ import bytes as f', number=3)
5.41390264898655
</code></pre>
<p>but we encode 26 characters, not 1 million so the write stage is faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>I get a huge speed improvement by changing from randint(0,25) to int(random()*25) in your original solution. On my machine, the time went from about 2 seconds, to about 0.6 seconds. If you take a look at the random.py code, you will see that randint is full of checks that you don't want or need.</p>
<p><strong>update:</strong> Oops, off by one. You need int(random()*26). Thanks <a href="https://stackoverflow.com/users/846892/ashwini-chaudhary">Ashwini</a></p>
</div>
<div class="post-text" itemprop="text">
<p>My solution which just got accepted (python 2.7, Execution time: 0.984):</p>
<pre><code>from random import choice
from string import ascii_lowercase

lis = list(ascii_lowercase)
print ''.join(choice(lis) for _ in xrange(1000000)) 
</code></pre>
<p>Accessing elements of a list is faster is than for strings.</p>
<pre><code>In [13]: from random import choice

In [14]: from string import ascii_lowercase

In [15]: lis = list(ascii_lowercase)

In [16]: %timeit ''.join(choice(lis) for _ in xrange(10**5))
1 loops, best of 3: 128 ms per loop

In [17]: %timeit ''.join(choice(ascii_lowercase) for _ in xrange(10**5))
1 loops, best of 3: 134 ms per loop
</code></pre>
<p>And you don't need <code>stdout</code> or <code>stdin</code> here as most online judges us something like this to test your script:</p>
<pre><code>$python script.py &lt;in.txt &gt;out.txt
</code></pre>
<p>So you can use <code>print</code> instead of <code>stdout</code> and <code>raw_input()</code> instead of <code>stdin</code>, though for huge inputs <code>stdin.readline</code> is faster than <code>raw_input()</code>.</p>
<p><strong>Update 1</strong>:</p>
<p>Using @Markku's  <a href="https://stackoverflow.com/a/16310117/846892">tip</a> execution time was reduced to .64 in py2.7:</p>
<pre><code>from random import random
from string import ascii_lowercase

lis = list(ascii_lowercase)
print "".join( [lis[int(random() * 26)] for _ in xrange(1000000)] )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try turning some part of it into C++ or another compiled language. That will almost guaranteed make it faster. Python, unfortunately, isn't too fast, especially when it comes to things like this. Try C++, C, or <a href="http://www.freepascal.org/" rel="nofollow">Pascal</a>.</p>
<p><strong>EDIT:</strong> Also see the <a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips" rel="nofollow">Python Performance Tips</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Generate and write in chunks that are a larger power of 2 in size.</p>
<p>Maybe use a string or array of the 26 lower-case letters and randomly pick then instead of generating chars.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer">random.choices</a>?</p>
<p>On Python 3.6:</p>
<pre>
import random
import string

%timeit ''.join(random.choices(string.ascii_lowercase, k=10**6))
1 loop, best of 3: 235 ms per loop
</pre>
</div>
<span class="comment-copy">Use a list-comprehension instead of a generator expression.  That can sometimes save a bit when using <code>join</code>. (and <code>join</code> turns your generator into a list or a tuple anyway).</span>
<span class="comment-copy"><code>randint(97, 122)</code> might be a small timesaver over <code>97 + randint(0, 25)</code>. Even addition isn't cheap in Python because it involves typechecks.</span>
<span class="comment-copy">Randomly pick one letter and write it a million times. :) Its a 1,000,000 random letters.</span>
<span class="comment-copy">I already shared it. :)</span>
<span class="comment-copy">It must be <code>random() * 26</code>, this one was the fastest yet, executed in .64s.(I've updated my solutuion). Still no luck for py3x. :(</span>
<span class="comment-copy">I wrote them a letter about this issue and they have confirmed that they have bug with definition OLE in Python.</span>
<span class="comment-copy">Not a criticism, just a general comment: The trick with speed in any interpreted language is to move as much control logic as possible into builtins instead of using interpreted code. Note how J.F.'s fastest solution does not have a single loop implemented in Python in the timing critical code: <code>os.urandom</code> does the mem allocation, and random number generation and <code>str.translate</code> iterates over the numbers, transcribing them into the wanted output format (latin lowercase chars). The end result is similar to what kirbyfan64sos proposed: Write your code in C. I'd say: Know your stdlib! :-)</span>
<span class="comment-copy">@cfi: It is true bitwise operations on many bytes in Python code are much slower (x100-200 times) on CPython compared to C. Note: the fast implementation in Pypy, Jython, IronPython might look different.</span>
<span class="comment-copy">0.9s. It is great!</span>
<span class="comment-copy">How to use list comprehension if I need a string to write in stdout?</span>
<span class="comment-copy">@ilalex: <code>stdout</code> you mean? It encodes the unicode string to bytes for you depending on the output encoding. In this case you only generate ASCII, so it's fine.</span>
<span class="comment-copy">I'm trying to use list comprehension in that way: for a in [choice(ascii_lowercase) for _ in range(1000000)]:  stdout.write(a) But it takes more time than your code above.</span>
<span class="comment-copy">@ilalex: use <code>for _ in range(1000000): stdout.write(choice(ascii_lowercase))</code> instead.</span>
<span class="comment-copy">I can't see why this woudn't work in Python 3, other than the print statement.</span>
<span class="comment-copy">I can do it in C++. I want to know: is there way to do it Python?</span>
<span class="comment-copy">@ilalex: See the <a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips" rel="nofollow noreferrer">Python Performance Tips</a>.</span>
<span class="comment-copy">The <a href="http://stackoverflow.com/a/16310739/923794">fastest solution</a> does exactly that: Moving as much functionality from explicit, interpreted code into Python's builtins and the stdlib - using <code>bytearray</code>, it's feature to internally call arbitrary constructors (again passing a builtin), and <code>maketrans</code>. J.F.'s trick is to not have a single loop coded in python but in C in Python's internals.</span>
