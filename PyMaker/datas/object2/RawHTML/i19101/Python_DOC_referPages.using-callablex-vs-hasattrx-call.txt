<div class="post-text" itemprop="text">
<p>I'm writing Python that targets versions 3.2 and higher. It looks like using the built-in function callable is the most straightforward and efficient way to do this. I've seen recommendations for <code>hasattr(x, "__call__")</code>, <code>collections.Callable(x)</code>, and just using <code>try/except</code> around an attempted call.</p>
<p>I've tested items that are callable (a class and a function), using <code>timeit</code> with 100,000 iterations; in both cases using callable takes only about 75% of the time of checking for the attribute. When the item is not callable (an integer and a string) using callable stays at the same cost as a class or function while checking for the attribute is about 2.3 times more expensive than for a class or function. I didn't expect that difference, but it also favors the clear and concise <code>callable(x)</code> approach.</p>
<p>But I'm relatively new to Python and no expert, so are there reasons I'm not aware of that I should use the hasattr approach or another approach?</p>
<p>FWIW, the results of the various timeits follow. The first character is just t for timeit, the second indicates what the type of the object being tested (c = class, f = function, i = integer, s = string), and the rest indicates the method (attr - check attribute, call - use callable, try - use try/except).</p>
<pre>
tcattr 0.03665385400199739
tccall 0.026238360142997408
tctry 0.09736267629614304
tfattr 0.03624538065832894
tfcall 0.026362861895904643
tftry 0.032501874250556284
tiattr 0.08297350149314298
ticall 0.025826044152381655
titry 0.10657657453430147
tsattr 0.0840187013927789
tscall 0.02585409547373274
tstry 0.10742772077628615
</pre>
</div>
<div class="post-text" itemprop="text">
<p><code>hasattr()</code> will return more false positives than <code>callable</code>:</p>
<pre><code>&gt;&gt;&gt; class X(object):
...     def __getattr__(self, name):
...         return name
...
&gt;&gt;&gt; i = X()
&gt;&gt;&gt; from collections import Callable
&gt;&gt;&gt; isinstance(i, Callable)
False
&gt;&gt;&gt; callable(i)
False
&gt;&gt;&gt; hasattr(i, '__call__')
True
&gt;&gt;&gt; i()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'X' object is not callable
</code></pre>
<p>I'm not sure which <code>callable</code> you were testing, but both look nicer than <code>hasattr</code> and handle more cases, so I would use them in place of <code>hasattr()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>callable</code> is not only the fastest, but the <a href="http://www.python.org/dev/peps/pep-0020/" rel="nofollow">Zen</a> provides four more important reasons to use it instead of the other two contraptions:</p>
<blockquote>
<p>Beautiful is better than ugly.<br/>
  Explicit is better than implicit.<br/>
  Simple is better than complex.<br/>
  Readability counts.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Great question! I'd say you should use <code>callable</code>. Several points apart from the speed issue:</p>
<ol>
<li>It's explicit, simple, clear, short, and neat.</li>
<li>It's a Python built-in, so anyone who doesn't already know what it does can find out easily.</li>
<li><code>try... except TypeError</code> has a problem: <code>TypeError</code> can sometimes be raised by other things. For example, if you successfully call a function which raises <code>TypeError</code> in its body, the <code>except</code> will erroneously catch that and assume that the object was not callable.</li>
<li>Some common customisations, like <code>__getattr__</code>, can cause <code>hasattr</code> to make mistakes.</li>
<li><code>collections.abc.Callable</code> seems like rather heavy machinery for something so simple. After all, <code>callable</code> does the same job.</li>
</ol>
<p>Footnote: the <code>try</code> block is a <a href="http://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">very common pattern</a> in Python for this sort of thing, so you may see a lot of it in other people's code. However, as I've outlined above, this is one case where it's not quite suitable.</p>
</div>
<span class="comment-copy">sidenote: callable was <a href="http://www.python.org/dev/peps/pep-3100/#built-in-namespace" rel="nofollow noreferrer">removed in python3.0</a> and - after noticing that this <a href="http://bugs.python.org/issue10518" rel="nofollow noreferrer">was a bad choice</a> - <a href="http://docs.python.org/3.2/library/functions.html?highlight=callable#callable" rel="nofollow noreferrer">brought back in 3.2</a></span>
<span class="comment-copy"><a href="http://docs.python.org/3/library/functions.html#callable" rel="nofollow noreferrer"><code>callable</code></a> can also return <a href="http://ideone.com/PexRWg" rel="nofollow noreferrer">false positives</a>.</span>
<span class="comment-copy">@J.F.Sebastian - True, but only a crazy person would define a class with a non-callable <code>__call__</code>. That'd just be a bug in real code.</span>
<span class="comment-copy">Thank you both for the perspective. For completeness I was using the built-in callable, not the collections.Callable.</span>
