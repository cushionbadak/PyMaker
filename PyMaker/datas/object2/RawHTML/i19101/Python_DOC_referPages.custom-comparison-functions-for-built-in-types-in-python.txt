<div class="post-text" itemprop="text">
<p>I am using Python's built-in sets to hold objects of a class I have defined. For this class, I defined <code>__eq__</code>, <code>__ne__</code>, and <code>__hash__</code> so that I can compare objects by my custom comparison functions. That works just fine, until I find out that I actually need <em>two</em> sets of comparison functions, which will be used in different ways at different times in my code.</p>
<p>I can't define two sets of <code>__eq__</code>, etc. methods in my class, and Python's built-in set type does not accept a comparator argument. I suppose I could go write a wrapper class around set, but that seems like a lot more work than necessary.</p>
<p>Is there any easier solution to this than writing my own set class?</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's say you have this class:</p>
<pre><code>class Thingy(object):
    def __init__(self, key, notkey):
        self.key, self.notkey = key, notkey
    def __eq__(self, other):
        return self.key == other.key
    def __hash__(self):
        return hash(self.key)
</code></pre>
<p>Now, you want to put these in a set, but keyed by <code>notkey</code> instead of <code>key</code>. You can't do that as-is, because a set expects its elements to have a consistent meaning for equality—and also a consistent meaning for hash such that <code>a == b</code> always implies <code>hash(a) == hash(b)</code>. So, create a wrapper:</p>
<pre><code>class WrappedThingy(object):
    def __init__(self, thingy):
        self.thingy = thingy
    def __eq__(self, other):
        return self.thingy.notkey == other.thingy.notkey
    def __hash__(self):
        return hash(self.thingy.notkey)
</code></pre>
<p>And you can put <em>those</em> in a set:</p>
<pre><code>wts = set(WrappedThingy(thingy) for thingy in thingies)
</code></pre>
<hr/>
<p>For example, let's say you want to uniquify your thingies, keeping exactly one thingy (arbitrarily) for each <code>notkey</code> value. Just wrap them, stick the the wrappers in a set, then unwrap them and stick the unwrappees in a list:</p>
<pre><code>wts = set(WrappedThingy(thingy) for thingy in thingies)
thingies = [wt.thingy for wt in wts]
</code></pre>
<p>This is part of a more general Python pattern called "DSU". This stands for "decorate-sort-undecorate", which is wildly inaccurate nowadays, since you almost never need it for sorting-related tasks in modern Python… but historically it made sense. Feel free to call it "decorate-process-undecorate" in hopes that it will catch on, but don't hope too hard.</p>
<p>The reason you don't need DSU for sorting nowadays is that most sorting functions all take <code>key</code> functions as arguments. In fact, even for uniquifying, the <code>unique_everseen</code> function in the <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes"><code>itertools</code> recipes</a> takes a <code>key</code>. </p>
<p>But if you look at what it does under the covers, it's basically DSU:</p>
<pre><code>for element in iterable:
    k = key(element)
    if k not in seen:
        seen.add(k)
        yield element
</code></pre>
<p>(The fact that it's a generator rather than a list-building function means it can "undecorate on the fly", which makes things a bit simpler. But otherwise, same idea.)</p>
</div>
<span class="comment-copy">You cannot store objects in sets that are equal only some of the time. They are either equal or they are not equal, as far as the set is concerned.</span>
<span class="comment-copy">The usual way around this is to "decorate" the elements that you put in the list: Store wrapper elements that are equal according to your alternate comparison element. This is a bit hard to explain in a comment, but I can write up an answer if that sounds promising.</span>
<span class="comment-copy">Instead of writing a wrapper around set, you could write a wrapper around your own class, which provides the alternative equality definition.  Then have one set of objects of your original class and another set of these "alternate" objects when you need that other equality definition.</span>
<span class="comment-copy">Also, keep in mind that sets care about hash stability as well as equality. If <code>a == b</code> (using the definition of equality that you want to use with the set), <code>hash(a) == hash(b)</code> must be true, or all kinds of things will break.</span>
