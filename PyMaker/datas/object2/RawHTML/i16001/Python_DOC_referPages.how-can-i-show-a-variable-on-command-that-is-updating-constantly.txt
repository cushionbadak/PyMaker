<div class="post-text" itemprop="text">
<p><a href="http://pastebin.com/rfB4XVnS" rel="nofollow">http://pastebin.com/rfB4XVnS</a></p>
<p>how can i get it so when i run this, it keeps rolling the dice and when i enter "roll" it shows the latest amount of dice rolls for each thing.</p>
<p>im new to python btw</p>
<pre><code>import random

picked6 = 0
picked5 = 0
picked4 = 0
picked3 = 0
picked2 = 0
picked1 = 0

while 1 == 1:

ra = (random.randint(1, 6))

if ra == 6:
    picked6 += 1

if ra == 5:
    picked5 += 1

if ra == 4:
    picked4 += 1

if ra == 3:
    picked3 += 1

if ra == 2:
    picked2 += 1

if ra == 1:
    picked1 += 1

reroll = input ("Input 'roll' to roll the dice.")

if reroll == "roll":
    print ("The Dice has been rolled", (picked6)+(picked5)+(picked4)+(picked3)+(picked2)+(picked1), ("times."))
    print ("You rolled 6,", (picked6), "times")
    print ("You rolled 5,", (picked5), "times")
    print ("You rolled 4,", (picked4), "times")
    print ("You rolled 3,", (picked3), "times")
    print ("You rolled 2,", (picked2), "times")
    print ("You rolled 1,", (picked1), "times")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want something to keep constantly working in the background, even while you're waiting for input, the simplest way to do that is with a thread.</p>
<p>The <a href="https://docs.python.org/3/library/threading.html" rel="nofollow"><code>threading</code></a> module has some great documentation, but I'm not sure the examples will be sufficient for someone who's never heard of threads before, so let's make a simple example.</p>
<p>First, you want to wrap your die-rolling loop up into a function:</p>
<pre><code>def roll_dice_forever():
    while 1 == 1:
        # all the rest of your code up to picked1 += 1
</code></pre>
<p>However, since <code>picked1</code>, etc., are all still global variables, that <code>pickle1 += 1</code> isn't going to work inside a function unless you first add this to the top of the function:</p>
<pre><code>global picked1, picked2, picked3, picked4, picked5, picked6
</code></pre>
<p>Now, to start that function running in the background, you just pass that function to a <code>Thread</code> object and <code>start</code> it.</p>
<p>But how can you ever quit? You need some way to signal the worker thread to stop working. Or, more simply, you need to be able to abandon the worker thread, so the OS will just kill it when the main thread quits. That doesn't work in many situations, but it happens to work here. You do that with the <code>daemon</code> attribute.</p>
<p>And there's still one more problem. What if the main thread is trying to print out <code>picked1</code> at the same time the background thread is trying to do <code>picked1 += 1</code>? As it turns out, CPython (the Python implementation you're almost certainly using) guarantees this is safe, but if you don't understand why, you shouldn't rely on that. Instead, you want to use a lock, to make sure only one thread at a time can touch each variable.</p>
<p>So, putting it all together:</p>
<pre><code>import threading

# everything before while 1 == 1

lock = threading.Lock()

def roll_dice_forever():
    global picked1, picked2, picked3, picked4, picked5, picked6
    while 1 == 1:
        with lock:
            # all the rest of your code up to picked1 += 1

worker = threading.Thread(target=roll_dice_forever)
worker.daemon = True
worker.start()

while True:
    reroll = input ("Input 'roll' to roll the dice.")
    with lock:
        # the whole rest of the program
</code></pre>
<hr/>
<p>As a side note, using lists and loops instead of a bunch of separate variables and copy-pasted code can make things a lot simpler. For example, this replaces your whole function:</p>
<pre><code>picked = [0, 0, 0, 0, 0, 0, 0]

def roll_dice_forever():
    global picked
    while True:
        ra = random.randint(1, 6)
        with lock:
            picked[ra] += 1
</code></pre>
<p>And this replaces your whole output loop:</p>
<pre><code>while True:
    reroll = input("Input 'roll' to roll the dice.")
    if reroll == "roll":
        print("The Dice has been rolled", sum(picked), "times.")
        for i in range(7, 1, -1):
            print ("You rolled", i, picked[i], "times")
</code></pre>
</div>
<span class="comment-copy">What exactly do you mean by "keeps rolling the dice"? Do you want it to be running in the background adding up rolls while it is waiting on you to type "roll"? That probably requires an extra thread or process.</span>
<span class="comment-copy">Yeah, thats what i mean. Do you know how i could do this?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">Threading documentation</a>.</span>
<span class="comment-copy">A couple of side notes: (1) just <code>while True:</code>, not <code>while 1 == 1:</code>, unless you're really testing to see that the number <code>1</code> hasn't changed out from under you. (2) use a list of 6 values, not 6 separate variables, and you can get rid of 87% of your code.</span>
