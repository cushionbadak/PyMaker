<div class="post-text" itemprop="text">
<p>I notice that in python you can append to a list with <code>+=</code> do this:</p>
<pre><code>s = ['a', 'b', 'c']
s += 'd'
# s = ['a', 'b', 'c', 'd']
</code></pre>
<p>Which is the same as doing <code>s.append('d')</code>. But there is not an equivalent for s.remove('a'):</p>
<pre><code>s -= 'a'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for -=: 'list' and 'str'
</code></pre>
<p>So what is happening when you use <code>+=</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>+=</code> on a <code>list</code> is <em>not</em> the same as doing <code>s.append</code>. It's the same as doing <code>s.extend</code>. It only happens to look the same in this case because a string is a sequence of characters, so a one-character string is a sequence of itself. In general, it's very different. Try it with numbers, or 3-character strings.</p>
<hr/>
<p>Anyway, "what is happening when you use <code>+=</code>" goes like this:</p>
<p>First, the statement <code>a += b</code> looks up the method <code>a.__iadd__</code>. If it exists (as it usually does on objects that can be mutated in-place, like <code>list</code>), it's transformed into this code:</p>
<pre><code>a = a.__iadd__(b)
</code></pre>
<p>Otherwise (as with immutable objects, like <code>int</code>), it's transformed (loosely speaking) into:</p>
<pre><code>a = a + b
</code></pre>
<p><code>list.__iadd__</code> exists. In CPython, of course, it's implemented in C, but the equivalent Python code is pretty trivial:</p>
<pre><code>def __iadd__(self, other):
    self.extend(other)
    return self
</code></pre>
<p>That <code>extend</code> method is equivalent to this:</p>
<pre><code>def self.extend(self, iterable):
    for element in iterable:
        self.append(element)
</code></pre>
<p>So, your <code>s += 'd'</code> effectively does this:</p>
<pre><code>for char in 'd': # this loops once, with `char` being `'d'`
    s.append(char)
s = s
</code></pre>
<hr/>
<p>Obviously under the covers a lot of things are optimized; <code>extend</code> doesn't have to look up the <code>append</code> method dynamically or call it in a loop (possibly expanding the list's storage multiple times), it just has to have the same visible effect as if it had done so.</p>
<hr/>
<p>For more on how this works, see the following sections of the documentation:</p>
<ul>
<li><a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow">Emulating numeric types</a> explains exactly how <code>a += b</code> is interpreted.</li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" rel="nofollow">Emulating container types</a> explains how this specifically applies to containers.</li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range" rel="nofollow">Sequence Types â€” <code>list</code>, <code>tuple</code>, <code>range</code></a> explains what <code>list.__iadd__</code>, <code>list.extend</code>, and <code>list.append</code> all do.</li>
<li><a href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes" rel="nofollow"><code>collections.abc.MutableSequence</code></a> shows what operations mutable sequences in general are expected to support.</li>
<li><a href="https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements" rel="nofollow">Augmented assignment statements</a> explains the details on how <code>+=</code> is parsed (note that it's not an operator in Python, unlike many other languages, but rather a special kind of thing that can only appear in statements, not expressions).</li>
</ul>
</div>
<span class="comment-copy">Try with <code>'de'</code>, <code>+=</code> is not same as <code>.append()</code> it is equivalent to <code>.extend()</code> in case of list.</span>
<span class="comment-copy">Also, the opposite of <code>append()</code> is <code>pop()</code>, not <code>remove()</code>. The latter does a search starting from the beginning of the array and could be a costly operation on long arrays.</span>
