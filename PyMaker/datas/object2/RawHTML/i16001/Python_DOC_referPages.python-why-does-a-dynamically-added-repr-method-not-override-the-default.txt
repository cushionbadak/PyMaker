<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/10376604/overriding-special-methods-on-an-instance">Overriding special methods on an instance</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>Where is python getting the repr which is still yielding 'foo' even after the original <strong>repr</strong> method has been overwritten? </p>
<pre><code>class Test(object):
    def __init__(self, name, number_array): 
        self.name = name
        self.number_array = number_array
    def __repr__(self):
        return str(self.name) 

def custom_repr(self): 
    return str(self.name*4)

&gt;&gt;&gt; A = Test('foo', [1,2])
&gt;&gt;&gt; A
foo
&gt;&gt;&gt; A.__repr__ = custom_repr.__get__(A, A.__class__)
&gt;&gt;&gt;A.__repr__()
foofoofoofoo
&gt;&gt;&gt;A
foo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As explained in <a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow">Special Method Lookup</a>:</p>
<blockquote>
<p>For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary … In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the <code>__getattribute__()</code> method even of the object’s metaclass</p>
</blockquote>
<p>(The part I've snipped out explains the rationale behind this, if you're interested in that.)</p>
<p>Python doesn't document exactly when an implementation should or shouldn't look up the method on the type; all it documents is, in effect, that implementations may or may not look at the instance for special method lookups, so you shouldn't count on either.</p>
<p>But, as you can guess from your test results, in the CPython implementation, <code>__repr__</code> is one of the functions looked up on the type.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__repr__</code> is looked up directly on the class, not on the instance, when it's looked up by <code>repr</code> or similar (such as when it's called by the interactive interpreter). If you must monkey-patch a <strong>repr</strong>, do it on the class (but please don't).</p>
<p>This same basic rule applies to most dunder methods.</p>
</div>
<span class="comment-copy">No, you're right, I think it is a duplicate, only your way of asking it is a little bit less to the point - so i couldn't tell right away :)</span>
<span class="comment-copy">You're right that it's a dup, but I really don't love the answer there. It doesn't link to the docs, it speculates (incorrectly) about the rationale, it makes it sound like Python guarantees that all special methods are always looked up on the class… so I copied my answer over there.</span>
<span class="comment-copy">PS, did you lose your comment upvote rep when the dup comment got auto-deleted? (Not hugely important, but I'm mildly curious.)</span>
<span class="comment-copy">I still have +15, not sure about the in between, I'm not all that familiar with how the rep system works.</span>
<span class="comment-copy">so you mean it's impossible to dynamically add a <b>repr</b> method in that case?</span>
<span class="comment-copy">@user3467349, adding it to the instance does not work. (If you must monkey-patch a new <code>__repr__</code> for a specific instance (and please feel free <i>not</i> to do so), do so on the class, special-casing the instance with <code>is</code>.)</span>
<span class="comment-copy">Unfortunately that will monkey-patch every object of the class, which really wasn't what I was going for.</span>
<span class="comment-copy">@user3467349, Yes, as noted, you can only monkey-patch it on the class. However you <i>can</i> have the <i>same effect</i> by special-casing the instance in the new <code>__repr__</code> (not that that is recommended).</span>
