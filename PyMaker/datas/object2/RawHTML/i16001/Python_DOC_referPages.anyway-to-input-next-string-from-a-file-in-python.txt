<div class="post-text" itemprop="text">
<p>Ok I'm new to python and Im trying to input a file and my question is that is there only the .read() function to read in a file? Or is there anyway you can take in the next string up to the next whitespace? Would the best way be to read in the line with .readline() then split the line? Any help is welcome</p>
<pre><code>if loop == "do":
            outfile.write(" label 1; label 2;\n")
            ch = infile.read(1)
            count = 0

            while ch != "":
                var += ch
                ch = infile.read(1)

            varList[count] = var
            count++
</code></pre>
<p>This is an example of the program, the question is where the infile.read(1) is. Right now that only takes in the next character I was wondering if there was anyway to get the next set of characters until the next whitespace.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no built-in method on file objects to read up to the next whitespace, or up to a certain character.</p>
<p>Reading a character at a time does of course work, and if you've opened the file with the default settings it will be buffered reasonably (either in C's stdio for Python 2.x, or in Python's <code>io</code> module for 3.1+)â€¦ but it still may be pretty slow just because of all that looping.</p>
<p>You can definitely use <code>readline</code> and then <code>split</code>, as you suggest. That just means you need somewhere to store the other words on the line between reads. The cleanest way to do that is probably with a wrapper around the file. For example:</p>
<pre><code>def words(f):
    for line in f:
        yield from line.split()
</code></pre>
<p>Or, in Python 3.2 and earlier:</p>
<pre><code>def words(f):
    for line in f:
        for word in line.split():
            yield word
</code></pre>
<p>Then you can do this:</p>
<pre><code>with open(filename) as f:
    for word in words(f):
        do_stuff(word)
</code></pre>
<p>In particular, your whole code could be written as:</p>
<pre><code>if loop == "do":
    outfile.write(" label 1; label 2;\n")
    for count, word in enumerate(words(infile)):
        varList[count] = var
</code></pre>
<hr/>
<p>If you actually want to wrap this in a complete file-like object with an extra method instead of just a generator of words:</p>
<p>In 3.1+, you can look at how <a href="https://docs.python.org/3/library/io.html#io.TextIOWrapper" rel="nofollow"><code>io.TextIOWrapper</code></a> works and add a <code>readword</code> method that interacts with its buffering the same way <code>readline</code> does, which is pretty simple.</p>
<p>But in 2.x that isn't possible. Unless you want to <code>dup</code> the file descriptor and create an <code>io</code> object out of it instead of a traditional file object, the best option is to create a custom <code>io.BufferedIOBase</code> subclass that delegates to a real file object, which is a lot more work.</p>
<p>Fortunately, most apps aren't going to need a complete file-like object, so this isn't a big deal.</p>
</div>
<span class="comment-copy">Im basically asking is there anyway to read in the next string in python or just a set number of characters.</span>
<span class="comment-copy">if you provide some code then, it'll be better to understand what you are trying to achieve. currently your question is unclear.</span>
<span class="comment-copy">Let me know if that helps or not. Instead of reading in one character at a time I would like to read in a string</span>
<span class="comment-copy">There is no built-in function to read to the next whitespace, or to a certain character or regular expression. That's something you could add without <i>too</i> much trouble in Python 3.1+, but it would be a huge pain in 2.7. But if all you need to do is, e.g., iterate over the words one by one, you can easily build a wrapper around <code>readline</code> (or around iterating the file) and <code>split</code> as you suggest.</span>
<span class="comment-copy">also, would be nice to have a sample of your input file.</span>
<span class="comment-copy">+1 for <code>yield from line.split()</code> which I had not yet seen.</span>
