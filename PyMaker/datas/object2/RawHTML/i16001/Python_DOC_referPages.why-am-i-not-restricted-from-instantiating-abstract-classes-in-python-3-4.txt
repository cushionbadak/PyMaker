<div class="post-text" itemprop="text">
<p>I have written a Python script and just found out that Python 3.4 does not restrict an abstract class from being instantiated while Python 2.7.8 did.  </p>
<p>Here is my abstract class in the file named <code>Shape.py</code>.  </p>
<pre><code>from abc import ABCMeta, abstractmethod

class Shape:

    __metaclass__ = ABCMeta # Making the class abstract

    def __init__(self):
        pass:

    @abstractmethod
    def getArea(self):
        print("You shouldn't have called me.")
        return None
</code></pre>
<p>Now I created another class that inherits from the <code>abstract</code> class <code>Shape</code>:<br/>
Filename: <code>Circle.py</code> </p>
<pre><code>from Shape import Shape

class Circle(Shape):

    PI = 3.141

    def __init__(self, radius=0):
        self.radius = radius

    def getArea(self):    # Overriding it from Shape class
        return self.PI * self.radius ** 2
</code></pre>
<p>Now in my <code>Main.py</code>:</p>
<pre><code>from Shape import Shape
from Circle import Circle

shape = Shape() # This gave me errors in Python 2.7.8 but not in Python 3.4
shape2 = Circle(5) 

print("Area of shape = "+str(shape.getArea()))    # This should have not been executed.
print("Area of circle = "+str(shape2.getArea()))
</code></pre>
<p>This <code>Main.py</code> gives errors on commented areas in Python2.7.8 but works fine on Python3.4.<br/>
Output on Python3.4:  </p>
<pre><code>You shouldn't have called me
Area of shape = None
Area of circle = 78.525
</code></pre>
<ol>
<li>Why is this happening? This is not what abstraction is! Is it?  </li>
<li>Or has there been any new way introduced for abstraction in Python 3.4?  </li>
<li>Can any one give me the link of official documentation for python 3.4?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, you declare a metaclass differently:</p>
<pre><code>class Shape(metaclass=ABCMeta):
</code></pre>
<p>See the <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow"><em>Customizing class creation</em> documentation</a>:</p>
<blockquote>
<p>The class creation process can be customised by passing the <code>metaclass</code> keyword argument in the class definition line, or by inheriting from an existing class that included such an argument.</p>
</blockquote>
<p>All examples in the <a href="https://docs.python.org/3/library/abc.html" rel="nofollow"><code>abc</code> module documentation</a> for Python 3 also use the correct notation.</p>
<p>This was changed to give metaclasses a chance to get involved with class creation earlier than was possible in Python 2; see <a href="http://www.python.org/dev/peps/pep-3115/" rel="nofollow">PEP 3115</a>.</p>
<p>The <code>__metaclass__</code> attribute has no special meaning anymore, so you didn't actually create a proper abstract class.</p>
<p>Demo with Python 3.4:</p>
<pre><code>&gt;&gt;&gt; from abc import ABCMeta, abstractmethod
&gt;&gt;&gt; class Shape(metaclass=ABCMeta):
...     @abstractmethod
...     def getArea(self):
...         print("You shouldn't have called me.")
...         return None
... 
&gt;&gt;&gt; Shape()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class Shape with abstract methods getArea
</code></pre>
</div>
<span class="comment-copy">you could use six.add_meta_class decorator to support both Python 2 &amp; 3</span>
<span class="comment-copy">Thanks. This worked. How silly of me. Can you please answer my third sub question too(edited question)? Thanks for help in advance.</span>
<span class="comment-copy">@Aditya: I already added documentation links for you.</span>
<span class="comment-copy">Thanks for docs. :)</span>
