<div class="post-text" itemprop="text">
<p>In python3 this just works</p>
<pre><code>&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Animal(Enum):
...     cat = [0]
...     dog = {1}
</code></pre>
<p>But in python v2.7.6 it raises <code>TypeError</code>, because there is unhandled exception when the metaclass bases try to call sorted on the values.</p>
<p>We can fix it like this: </p>
<pre><code>&gt;&gt;&gt; class Animal(Enum):
...     __order__ = 'cat dog'
...     cat = [0]
...     dog = {1}
</code></pre>
<p>My question: why is definition order unavailable in python2 ?  I'm assuming that's why the python2 version doesn't work, correct me if I'm wrong here.</p>
<p>If we make an enumeration like this:</p>
<pre><code>&gt;&gt;&gt; class Animal(Enum):
...     cat = {0, 1}
...     dog = {1, 2}
...     fish = {2, 0}
</code></pre>
<p>Will the ordering be safe and well-defined? Or will it be unreliable, like <code>dict</code> or <code>set</code> iteration?  </p>
<hr/>
<p><em>edit</em>: with traceback</p>
<pre><code>In [1]: from enum import Enum

In [2]: class Animal(Enum):
    dog = [0]
    cat = {1}
   ...:     
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-2-d14b1041d5bc&gt; in &lt;module&gt;()
----&gt; 1 class Animal(Enum):
      2     dog = [0]
      3     cat = {1}
      4 

/usr/local/lib/python2.7/dist-packages/enum/__init__.pyc in __new__(metacls, cls, bases, classdict)
    164         if __order__ is None:
    165             if pyver &lt; 3.0:
--&gt; 166                 __order__ = [name for (name, value) in sorted(members.items(), key=lambda item: item[1])]
    167             else:
    168                 __order__ = classdict._member_names

TypeError: Error when calling the metaclass bases
    can only compare to a set
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Enum makes use of a new metaclass feature: <a href="https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace" rel="nofollow"><em>preparing the class namespace</em></a>, allowing the metaclass to specify an alternative namespace implementation with a with <code>__prepare__</code> hook. This is not available in Python 2.</p>
<p>By having <code>__prepare__</code> return a custom mapping object, you can capture the definition order of the class body. See the <a href="https://hg.python.org/cpython/file/7b962b896f10/Lib/enum.py#l40" rel="nofollow"><code>_EnumDict</code> implementation</a> and <a href="https://hg.python.org/cpython/file/7b962b896f10/Lib/enum.py#l82" rel="nofollow"><code>EnumMeta.__prepare__</code> definition</a>. The <code>_member_names</code> attribute is a list, an ordered structure, and names in the <code>Enum</code> subclass are added to it as they are defined.</p>
<p>In Python 2, you are stuck with the normal <code>dict</code> namespace for class bodies, which don't retain definition order. As such your last example the attribute order is subject to the implementation details of the mapping object used. Without an <code>__order__</code> attribute, in Python 2 <code>enum34</code> sorts by value, and in Python 2 that means the order is arbitrary if the items do not actually have a defined order. Your sets have no defined order because they are not strict subsets of one another:</p>
<pre><code>&gt;&gt;&gt; {0, 1} &lt; {1, 2}
False
&gt;&gt;&gt; {0, 1} &gt; {1, 2}
False
</code></pre>
<p>so the original class namespace order is used, which is arbitrary. If you switch on <a href="https://docs.python.org/2/using/cmdline.html#cmdoption-R" rel="nofollow">hash randomisation</a> you'll see the order fluctuate:</p>
<pre><code>$ bin/python -R -c $'from enum import Enum\nclass Animal(Enum):\n    cat = {0, 1}\n    dog = {1, 2}\n    fish = {2, 0}\n\nprint list(Animal)\n'
[&lt;Animal.dog: set([1, 2])&gt;, &lt;Animal.cat: set([0, 1])&gt;, &lt;Animal.fish: set([0, 2])&gt;]
$ bin/python -R -c $'from enum import Enum\nclass Animal(Enum):\n    cat = {0, 1}\n    dog = {1, 2}\n    fish = {2, 0}\n\nprint list(Animal)\n'
[&lt;Animal.fish: set([0, 2])&gt;, &lt;Animal.cat: set([0, 1])&gt;, &lt;Animal.dog: set([1, 2])&gt;]
$ bin/python -R -c $'from enum import Enum\nclass Animal(Enum):\n    cat = {0, 1}\n    dog = {1, 2}\n    fish = {2, 0}\n\nprint list(Animal)\n'
[&lt;Animal.fish: set([0, 2])&gt;, &lt;Animal.dog: set([1, 2])&gt;, &lt;Animal.cat: set([0, 1])&gt;]
</code></pre>
<p>As I am using Python 2.7.8 I did not see your <code>TypeError</code>; until the fix for <a href="http://bugs.python.org/issue8743" rel="nofollow">issue 8743</a> made it possible to use the <a href="https://docs.python.org/2/library/collections.html#collections.Set" rel="nofollow"><code>collections.Set()</code> ABC</a> with <code>set()</code> objects, <code>set</code> objects were indeed not orderable.</p>
<p>The fix for that issue is part of Python 2.7.8, and I personally consider the old behaviour a bug; a <code>NotImplemented</code> sentinel should have been returned instead rather than raise an exception.</p>
<p>So, if you <em>have</em> to have an enum with a mix of types for the values, you are stuck with the <code>__order__</code> attribute until you can upgrade to 2.7.8. That a <code>set</code> doesn't play nice when ordering heterogenous types is a pity, but hardly <code>enum34</code>'s fault.</p>
</div>
<span class="comment-copy">What <code>enum</code> implementation are you using with Python 2? The <a href="https://pypi.python.org/pypi/enum34/" rel="nofollow noreferrer"><code>enum34</code> backport package</a> does not raise a <code>TypeError</code> on your first example. Is something missing here?</span>
<span class="comment-copy">It is precisely the enum34 backport, version <code>enum34==1.0</code> according to pip freeze.  And yes it is raising exception on python 2.7.6, are you saying yours isn't?!</span>
<span class="comment-copy">Perhaps you are using a different implementation Martijn ..</span>
<span class="comment-copy">I am using <code>enum34==1.0</code> on Python 2.7.8, and no exception is raised; sorting mixed types doesn't raise an exception on Python 2.</span>
<span class="comment-copy">Found the <a href="https://hg.python.org/cpython/diff/3615cdb3b86d/Objects/setobject.c" rel="nofollow noreferrer">changeset</a> and the <a href="http://bugs.python.org/issue8743" rel="nofollow noreferrer">corresponding bug</a>; this is indeed changed in Python 2.7.8.</span>
<span class="comment-copy">Don't we in theory have access to the code object in python2, to recover the definition order using introspection?</span>
<span class="comment-copy">@wim: even getting to the original code object that defines the class is going to be tricky, as there is no function scope to pull it from. You'd have to load the original module bytecode first, meaning you have to rely on being able to access that data in the first place. That requires supporting zipped module archives, etc. This is apart from the pain you'll have to go through of mapping the <code>STORE_FAST</code> bytecode order to the names they store, etc.</span>
<span class="comment-copy">@wim: and then there is support for Jython, IronPython and PyPy, so using implementation details like the bytecode is right out.</span>
<span class="comment-copy">yeah OK, makes sense.  can you comment on the behaviour of the pathological enum, where sorted thinks it is using ordering operators but is actually using subset operators?</span>
<span class="comment-copy">I am not sure what you mean by that; perhaps that has to do with the exception you say is being raised?</span>
