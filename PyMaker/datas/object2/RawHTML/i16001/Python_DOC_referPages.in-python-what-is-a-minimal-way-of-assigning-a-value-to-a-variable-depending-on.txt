<div class="post-text" itemprop="text">
<p>I want to access a few values in a dictionary in a way something like the following:</p>
<pre><code>self.userName              = self.options["--username"]
self.files                 = self.options["--files"].split(",")
self.configurationFileName = self.options["--configuration"]
</code></pre>
<p>However, it may be that some of these keys may not exist in the dictionary -- let's say "--files" might not be in it. If the key does not exist in the dictionary, I want the value of the variable to be set to <code>None</code>, i.e. <code>self.files = None</code>. At present, I am doing something like the following:</p>
<pre><code>if "--files" in self.options:
    self.files = self.options["--files"].split(",")
else:
    self.files = None
</code></pre>
<p>Would there be some way of doing this that would be a bit more minimal, efficient or Pythonic? I would prefer this to be done in a one-liner for clarity. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>get</code> and an empty string as default and substitute with <code>None</code> in case of empty string or empty list:</p>
<pre><code>self.files = self.options.get('--files', "").split(",") or None
</code></pre>
<p>This way <code>split</code> is always called on a valid object, and you get <code>None</code> if the object is empty.</p>
<p>EDIT</p>
<p>Actually the tests I made used <code>split()</code> which <a href="https://stackoverflow.com/questions/16645083/when-splitting-an-empty-string-in-python-why-does-split-return-an-empty-list">uses a different algorithm than</a> <code>split(",")</code> </p>
<p>So to work, it should be</p>
<pre><code>self.files = self.options.get('--files', "").replace(',', '\n').split() or None
</code></pre>
<p>Another way to do it using <code>set</code> operations:</p>
<pre><code>self.files = set(self.options.get('--files', "").split(",")) ^ set(['']) or None
</code></pre>
<p>but then <code>self.files</code> is a set and not a list.</p>
<p>AFTERTHOUGHT:</p>
<p>what I would do is define a small helper class</p>
<pre><code>class NoneFound:
  @classmethod
  def split(self, _):
    return None
</code></pre>
<p>and then simply:</p>
<pre><code>self.files = self.options.get('--files', NoneFound).split(',')
</code></pre>
<p>See with that class defined:</p>
<pre><code>&gt;&gt;&gt; print {'--files': "a,b,c"}.get("--files", NoneFound).split(',')
['a', 'b', 'c']
&gt;&gt;&gt; print {}.get("--files", NoneFound).split(',')
None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <a href="https://docs.python.org/2/library/stdtypes.html#dict.get" rel="nofollow">get</a>:</p>
<pre><code>self.files = self.options.get('--files', None)
if self.files:
    self.files.split(',')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Pythonic way to get a dictionary key with default value if the key isn't present is <code>get</code>, e.g.</p>
<pre><code>self.user_name = self.options.get("--username", None)
self.configuration_file_name = self.options.get("--configuration", None)
</code></pre>
<p>As for the files option, you could use the same approach and do the split afterwards:</p>
<pre><code>self.files = self.options.get("--files", None)
if self.files:
    self.files = self.files.split(",")
</code></pre>
<p>or use a try/except block:</p>
<pre><code>try:
    self.files = self.options["--files"].split(",")
except KeyError:
    self.files = None
</code></pre>
<p>or, if you really want it on one line, use a conditional expression:</p>
<pre><code>self.files = self.options["--files"].split(",") if "--files" in self.options else None
</code></pre>
<p>I'm guessing opinions on which way to handle "--files" is most Pythonic will differ. I would go with the first case above (use <code>get</code> and check do the split afterwards) because it's consistent with using <code>get</code> which is definitely the Pythonic way to handle the general case of a not-found dictionary value, and I find this way of handling the split logic most obvious and easy to understand.</p>
<p>Note that since you ask about being Pythonic, I used underscore_case instead of camelCase. That's the Python way for variable naming.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would take a step back and ask "Why am I storing a comma-delimited string in <code>self.options['--files']</code> instead of a list in the first place?". If you did that, then your code would simply be</p>
<pre><code>self.files = self.options.get("--files")
</code></pre>
<p>Whatever populates <code>self.options</code> should split the list first.</p>
</div>
<div class="post-text" itemprop="text">
<p>In general, the Pythonic way is to use a try-except block, especially when you expect the operation to succeed most of the time. See <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow">EAFP</a>.</p>
<pre><code>try:
    self.files = self.options["--files"].split(",")
except KeyError:
    self.files = None
</code></pre>
<p>If you expect it to succeed most of the time, you can check first as you have done (see <a href="https://docs.python.org/3/glossary.html#term-lbyl" rel="nofollow">LBYL</a>). In general, this isn't really a big deal, use whatever method makes more sense in your application.</p>
</div>
<span class="comment-copy">I find this very unpythonic. Using a line or two less in exchange for being harder to read and understand.</span>
<span class="comment-copy">Oh, that is sensible, very readable and a one-liner. Thank you very much for your help!</span>
<span class="comment-copy">this doesn't work, splitting a empty string returns a list with a empty string which is true: see <a href="http://ideone.com/w7ur6x" rel="nofollow noreferrer">ideone.com/w7ur6x</a></span>
<span class="comment-copy">This method still requires type checking, as <code>None</code> doesn't have a <code>split</code> method. So you're just moving around when/what you need to check.</span>
<span class="comment-copy">thanks @RogerFan</span>
<span class="comment-copy">Thank you very much for your help on that. The use of the method <code>get</code> was of particular use. You can see in <a href="http://stackoverflow.com/a/25877977/1556092">the solution</a> provided by <a href="http://stackoverflow.com/users/1763614/damienfrancois">damienfrancois</a> that the type checking can be brought cleanly into one line with the <code>get</code>.</span>
<span class="comment-copy">As I responded to @HasanRamezani, this method still requires type checking, as None doesn't have a split method. So you're just moving around when/what you need to check.</span>
<span class="comment-copy">@RogerFan - true, but that's really just for the case of the files. For the general case (and 2 out of the 3 examples in the question), <code>get</code> is clearly the Pythonic way to do it, wouldn't you agree?</span>
<span class="comment-copy">For the files case I slightly prefer to try-except block, but that's probably because that's how I learned it. Not a lot of difference. I hate the single-line if-else clause though.</span>
<span class="comment-copy">Thank you very much for your help on that. The use of the get method of was of particular use.</span>
<span class="comment-copy">Thanks for your thoughts on that. The reason why the string is stored rather than a list (which would, indeed, be nicer) is because it is input from command line options. I'm using <a href="http://docopt.org/" rel="nofollow noreferrer">docopt</a> to convert the command line options to a dictionary.</span>
<span class="comment-copy">I wonder if there is a way in <code>docopt</code> to process the argument. You could use <code>[--file=&lt;arg&gt;]...</code>, but I understand that <code>--file f1 --file f2 --file f3</code> would be far less desirable than <code>--files f1,f2,f3</code>. In <code>argparse</code>, for instance, you could define the option as <code>p.add_argument('--files', type=lambda x: x.split(','))</code> to automatically convert the comma-separated string to a list.</span>
<span class="comment-copy">Thank you very much for your help on that. Your references to documentation on what is Pythonic were helpful.</span>
