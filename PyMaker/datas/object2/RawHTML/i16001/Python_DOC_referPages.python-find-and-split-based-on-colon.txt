<div class="post-text" itemprop="text">
<p>I have a list of million strings, some of them are in the following pattern,</p>
<pre><code>text = 'ClassName::ClassName( str text ) : prop1(abc, CLassName2::fnName())'
</code></pre>
<p>My objective is,
If there is a pattern like 'ClassName::CLassName' at the start and there is a single colon(:) following it (there may be :: also which should not be considered like ::fnName), then add prop0 as follows,</p>
<pre><code>text = ' ClassName::ClassName( str text ) : prop0('null'),prop1(abc, CLassName2::fnName())'
</code></pre>
<p>Is it possible to do this avoiding re?</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use <code>re.sub()</code> for it:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'(?&lt;=\B:\B )',"prop0('null'),",text)
"ClassName::ClassName( str text ) : prop0('null'),prop1(abc, CLassName2::fnName())"
</code></pre>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#str.split" rel="nofollow noreferrer">string.split</a> on the colons and rebuild the list, adding characters as needed.</span>
<span class="comment-copy">Are you willing to use some very tedious looping when <code>import re</code> could do this easily?</span>
<span class="comment-copy"><code>re</code> is an appropriate tool for the job here.</span>
<span class="comment-copy">Why do you want to avoid using a regular expression? It is the ideal tool for this. And what does <code>str text</code> look like? Could it contain nested parentheses or quoted strings?</span>
<span class="comment-copy">Well worked it out.. I didnt want to use re because I am reading the string from a log file. THe log file contains millions of lines and going through it line by line with re's processing takes more time when compared to simpler .split() and .find(). This is what I observed.</span>
