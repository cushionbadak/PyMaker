<div class="post-text" itemprop="text">
<p>I am trying to create two new lists one for colors and one for sizes.<br/>
So I want the new code to be:</p>
<pre><code>resp["colors"] = ["Teal Combo", "Teal Combo"]
resp["sizes"] = ["s","s"]
</code></pre>
<p>So far, no dice.</p>
<pre><code>resp = {}
resp["color"] = ['Color:', 'Teal Combo', 'Size:', 'S', 'Color:', 'Teal Combo', 'Size:',        'S']


for i, s in enumerate(resp["color"]):
    colors = []
    sizes = []
    print i , s
    if s.lower() == 'Color:' and len(resp["color"]) &gt; i+2:
        colors.append(resp["color"][i+1])   
        sizes.append(resp["color"][i+2])
    resp["colors"] = colors
    resp["sizes"] = sizes
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = resp["color"]
i = 0
colors = []
sizes = []
while i&lt;len(data)-1:
    d = data[i]
    if d.startwith("Color"):
        colors.append(data[i+1])
        i += 1
    elif d.startwith("Size"):
        sizes.append(data[i+1])
        i += 1
    i += 1

resp['color'] = colors
resp['size'] = sizes
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are a few different ways to turn an iterable of alternating values into an iterable of pairs.</p>
<p>In your case, you're using a sequence (a list), so we can do it by slicing and zipping:</p>
<pre><code>color = resp['color']
pairs = zip(color[::2], color[1::2])
</code></pre>
<p>The <code>::2</code> means "a slice starting at the beginning, ending at the end, and picking every 2nd element", while <code>1::2</code> means the same thing but starting at element 1 instead of at the beginning.</p>
<p>If you wanted to work with any arbitrary iterable, you could do it like this:</p>
<pre><code>color = resp['color']
icolor = iter(color)
pairs = zip(icolor, icolor)
</code></pre>
<p>This is a special case of the more general <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>grouper</code></a> function in the Recipes second of the <code>itertools</code> docs, or in the third-party <a href="https://pypi.python.org/pypi/more-itertools" rel="nofollow"><code>more-itertools</code></a> library:</p>
<pre><code>pairs = more_itertools.grouper(resp['color'], 2)
</code></pre>
<p>If you want to understand <a href="http://stupidpythonideas.blogspot.com/2013/08/how-grouper-works.html" rel="nofollow">how grouper works</a>, click the link.</p>
<hr/>
<p>However you do this, you'll end up with pairs like this:</p>
<pre><code>&gt;&gt;&gt; print(list(zip(color[::2], color[1::2]))
[('Color:', 'Teal Combo'),
 ('Size:', 'S'),
 ('Color:', 'Teal Combo'),
 ('Size:', 'S')]
</code></pre>
<hr/>
<p>Once you have those pairs, this should be easy:</p>
<pre><code>resp['colors'] = []
resp['sizes'] = []
for name, value in pairs:
    if name == 'Color:':
        resp['colors'].append(value)
    elif name == 'Size:':
        resp['sizes'].append(value)
</code></pre>
<p>Or, if you want to do it more generally:</p>
<pre><code>result = collections.defaultdict(list)
for name, value in pairs:
    result[name].append(value)
resp['colors'] = result['Color:']
resp['sizes'] = result['Size:']
</code></pre>
<p>Or even:</p>
<pre><code>result = collections.defaultdict(list)
for name, value in pairs:
    name = name.rstrip(':').lower() + 's'
    result[name].append(value)
resp.update[result]
</code></pre>
</div>
<span class="comment-copy">Assumably <code>resp</code> (in the first part of this question) is a dictionary?</span>
<span class="comment-copy">thanks for the answer. anyway to solve this using a python module?</span>
<span class="comment-copy">@slopeofhope: If you're sure about the structure of the <code>resp['color']</code>, then: <code>resp={'color':resp['color'][1:4:len(resp['color'])], 'size':resp['color'][3:4:len(resp['color'])]</code></span>
