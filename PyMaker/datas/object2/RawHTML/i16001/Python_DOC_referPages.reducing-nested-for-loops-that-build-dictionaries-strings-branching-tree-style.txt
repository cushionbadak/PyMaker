<div class="post-text" itemprop="text">
<p>For a recent script I had to iterate possible flows through a branching tree. I built a dictionary that would contain the run state for each item in order for me to evaluate. For example:</p>
<pre><code>for a in range(0, 2):
  for b in range(0, 2):
    for c in range(0, 2):
      for d in range(0, 2):
        ...
        run = [a,b,c,d ...]
</code></pre>
<p>Unfortunately, it started out small but grew to over a dozen states. How could this be reduced to eliminate all of the nested loops?</p>
<p>Would a similar answer differ if some of the states had 3 or 4 states instead of 2?</p>
<p>Similarly, how would the same issue be affected if each loop was from a function list? I suspected it would be the same. For example:</p>
<pre><code>def leet_lookup(char):
    table = {"a": ["a","A","@"],
            "b": ["b", "B", "8"],
            "c": ["c", "C", "&lt;"],
            "e": ["e", "E", "3"],
            "i": ["i", "I", "1"],
            "l": ["l", "L", "1"],
            "o": ["o", "O", "0"],
            "t": ["t", "T", "7"] }
    try:
        result = table[char.lower()]
    except KeyError:
        result = [char.lower(), char.upper()]
    return result

result = []
# V o l l e y b a l l = 10 chars
for c1 in leet_lookup('v'):
  for c2 in leet_lookup('o'):
    for c3 in leet_lookup('l'):
      for c4 in leet_lookup('l'):
        for c5 in leet_lookup('e'):
          for c6 in leet_lookup('y'):
            for c7 in leet_lookup('b'):
              for c8 in leet_lookup('a'):
                for c9 in leet_lookup('l'):
                  for c10 in leet_lookup('l'):
                    result.append("%s%s%s%s%s%s%s%s%s%s" % (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Once again, it's a problem begging for a solution from <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools</code></a>.</p>
<p>For the first problem, simply use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>product</code></a>. </p>
<pre><code>from itertools import product
for run in product(range(2), repeat=5):
    print(run)

# (0, 0, 0, 0, 0)
# (0, 0, 0, 0, 1)
# (0, 0, 0, 1, 0)
# etc.
</code></pre>
<p>If you have more states per indicator, either a) every indicator has the same number of states and you can simply change the argument of <code>range</code>, or b) different indicators have different numbers of states, in which case you could do something similar to the answer below, replacing the <code>leet_lookup</code> call with <code>range</code> and having a list of state numbers instead of <code>lookups</code>.</p>
<p>For the second one, you probably want to build a list of iterables which you can then use <code>product</code> on.</p>
<pre><code>lookups = ['v', 'o', 'l', 'l']
items = [leet_lookup(a) for a in lookups]
for c in product(*items):
    print(c)

# ('v', 'o', 'l', 'l')
# ('v', 'o', 'l', 'L')
# ('v', 'o', 'l', '1')
# ('v', 'o', 'L', 'l')
# etc.
</code></pre>
<p>In general, if you ever have a problem that involves any sort of combination or transformation of iterators, you should first look for an <code>itertools</code> function or <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">recipe</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You want all permutation between all of <code>table</code> dictionary values so you can use <code>itertools</code> module for find that , which is more <strong>pythonic</strong> and <code>map</code> and <code>join</code> functions to concatenate them !</p>
<pre><code>import itertools
table = {"a": ["a","A","@"],
        "b": ["b", "B", "8"],
        "c": ["c", "C", "&lt;"],
        "e": ["e", "E", "3"],
        "i": ["i", "I", "1"],
        "l": ["l", "L", "1"],
        "o": ["o", "O", "0"],
        "t": ["t", "T", "7"] }

for pro in itertools.product(table['a'],table['b'],table['c'],table['e'],table['i'],table['l'],table['o'],table['t']):
     print ''.join(pro)
</code></pre>
<p>some of output :</p>
<pre><code>@8&lt;3Il0T
@8&lt;3Il07
@8&lt;3ILot
@8&lt;3ILoT
@8&lt;3ILo7
@8&lt;3ILOt
@8&lt;3ILOT
@8&lt;3ILO7
@8&lt;3IL0t
...
</code></pre>
</div>
<span class="comment-copy">nice solution tho!</span>
<span class="comment-copy">Excellent answer and advice, the second one was particularly daunting but your solution is excellent! Thank you</span>
<span class="comment-copy">Thanks for the solution. However, that appears to make just every permutation of characters within the table and doesn't work off the provided string as needed.</span>
