<div class="post-text" itemprop="text">
<p>i am working on my project where i i want to capture video frames from my webcam and send to remote client in python, i am using opencv to capture frames but i have to send it to remote client frame by frame without saving in server...
I am stuck here since a week pls help me 
should i have to conver it to string to send via sockets? if yes then how?
PLS help me my code is </p>
<pre><code>import cv2
import socket
import base64

host = "localhost"
port = 6052

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.bind((host,port))
s.listen(5)
print "server started...."
#if __name__ == "__main__":
while True:
    c, addr = s.accept()
    print "client connected..."
    capture = cv2.cv.CaptureFromCAM(0)
    #cv2.cv.NamedWindow('image')
    frame = cv2.cv.QueryFrame(capture)
    #cv2.cv.ShowImage('image', frame)
    #succ, ig = cv2.cv.LoadImage(capture)
    with open(frame,"rb") as f:
        es = base64.b64encode(f.read())
        stri = str.decode('base64','strict')
        print "string is " + stri
    #with open(ig, "rb") as f:
    #   b = f.read(87029)
    #  print "data = " + b
   # c.send(b)


   #k = cv2.cv.WaitKey(10)

   #if k % 256 ==27 :
        #break

#cv2.DestroyWindow('image')
    s.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the problems in the other answer—which you still have to fix—you have <em>another</em> problem.</p>
<pre><code>frame = cv2.cv.QueryFrame(capture)
open(frame,"rb")
</code></pre>
<p><a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#IplImage*%20cvQueryFrame(CvCapture*%20capture)" rel="nofollow"><code>QueryFrame</code></a> returns an image object. <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow"><code>open</code></a> takes a filename or an integer file descriptor. An image object is quite obviously not a filename, so that <code>open</code> is going to raise an exception.</p>
<p>The only way you're going to get a filename that you can pass to <code>open</code> is if you have a file, e.g., by saving the frame to it. You claim that you had code that did that. Presumably in that code, you had code similar to this:</p>
<pre><code>cv2.cv.imwrite(filename, image, params)
f = open(filename, 'rb')
</code></pre>
<p>I don't know what params you used; the <code>image</code> is presumably the image you read by capturing a frame.</p>
<p>The <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#imencode" rel="nofollow"><code>imencode</code></a> function is similar to <code>imwrite</code>, except that it creates an image file in-memory, in a buffer, instead of writing it to disk. It takes the same parameters as <code>imwrite</code>, except with a file extension instead of a full filename (because it isn't going to save anything to disk, but it still needs to know what type of file—PNG, JPE, etc.).</p>
<p>So:</p>
<pre><code>buf = cv2.cv.imencode(extension, image, params)
</code></pre>
<p>And now, <code>buf</code> is the bytes you can pass to <code>send</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem you're trying to solve is here:</p>
<pre><code>c.send(b)
</code></pre>
<p>If you read the docs for <a href="https://docs.python.org/2/library/socket.html#socket.socket.send" rel="nofollow"><code>socket.send</code></a>:</p>
<blockquote>
<p>Send data to the socket. The socket must be connected to a remote socket. The optional <em>flags</em> argument has the same meaning as for <code>recv()</code> above. Returns the number of bytes sent. <strong>Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data.</strong> For further information on this concept, consult the <a href="https://docs.python.org/2/howto/sockets.html#socket-howto" rel="nofollow">Socket Programming HOWTO</a>.</p>
</blockquote>
<p>And in fact, sending a big hunk of data immediately upon opening a TCP socket is exactly the kind of situation where you'd expect it to send only part of the data.</p>
<p>You could read the linked HOWTO, which will explain how to deal with partially-sent buffers, but for your problem, since you're doing nothing but handling one client at a time with no concurrency, completing the request, and hanging up on it, the next function in the docs, <a href="https://docs.python.org/2/library/socket.html#socket.socket.sendall" rel="nofollow"><code>sendall</code></a>, does everything you want.</p>
<hr/>
<p>However, this isn't the only problem in your code. For example, the very next line does this:</p>
<pre><code>s.close
</code></pre>
<p>Just referencing a function, without calling it with <code>()</code>, has no effect. Which turns out to be a good thing, because if this <em>had</em> an effect, it would be closing the <em>listener</em> socket, not the <em>client</em> socket. If the client waits for shutdown, it would wait forever; meanwhile, if a second client tried to connect, it would be rejected.</p>
<hr/>
<p>Also, if you wrote the client side yourself, I'm willing to bet you just used <code>b = s.recv(87029)</code>, which is going to have the same problem: it's not necessarily going to receive 87029 bytes, it'll receive anything <em>up to</em> that many bytes. You have to loop around <code>recv</code> adding to a buffer until you get enough. See <a href="http://stupidpythonideas.blogspot.com/2013/05/sockets-are-byte-streams-not-message.html" rel="nofollow">Sockets are byte streams, not message streams</a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>please, <em>never, ever</em> try to convert an image to a string, it's a total waste.</li>
<li>yes, you will have to encode the image fom the webcam, but <em>not</em> to base64 (instead,you will need an image, that your client can read, like a png in memory)</li>
<li>do not use the deprecated cv2.cv api, it will be gone soon (opencv 3.0)</li>
<li>stick to a well known <em>protocol</em>, like MJPEG</li>
</ul>
<hr/>
<pre><code>import cv2
from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
import time

capture=None

class CamHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        print self.path
        if self.path.endswith('.mjpg'):
            self.send_response(200)
            self.send_header('Content-type','multipart/x-mixed-replace; boundary=--jpgboundary')
            self.end_headers()
            while True:
                try:
                    rc,img = capture.read()
                    if not rc:
                        continue
                    imgRGB = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
                    r, buf = cv2.imencode(".jpg",imgRGB)
                    self.wfile.write("--jpgboundary\r\n")
                    self.send_header('Content-type','image/jpeg')
                    self.send_header('Content-length',str(len(buf)))
                    self.end_headers()
                    self.wfile.write(bytearray(buf))
                    self.wfile.write('\r\n')
                    time.sleep(0.5)
                except KeyboardInterrupt:
                    break
            return
        if self.path.endswith('.html') or self.path=="/":
            self.send_response(200)
            self.send_header('Content-type','text/html')
            self.end_headers()
            self.wfile.write('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;')
            self.wfile.write('&lt;img src="http://127.0.0.1:9090/cam.mjpg"/&gt;')
            self.wfile.write('&lt;/body&gt;&lt;/html&gt;')
            return

def main():
    global capture
    capture = cv2.VideoCapture(0)
    capture.set(cv2.CAP_PROP_FRAME_WIDTH, 320); 
    capture.set(cv2.CAP_PROP_FRAME_HEIGHT, 240);
    try:
        server = HTTPServer(('',9090),CamHandler)
        print "server started"
        server.serve_forever()
    except KeyboardInterrupt:
        capture.release()
        server.socket.close()

if __name__ == '__main__':
    main()
</code></pre>
</div>
<span class="comment-copy">What exactly is the <i>problem</i> with this code? What is it doing wrong?</span>
<span class="comment-copy">problem is in line c.send(b), it says have to type error, i am not able to send the frames to client..</span>
<span class="comment-copy">Well, <i>what is <code>b</code>?</i> Paste the exception and traceback, and tell us what the type of <code>b</code> is. (If you don't know, just ask Python: <code>print(type(b))</code>. Also, tell us whether this is Python 2.x or 3.x. And give us code that actually runs if you want anyone to help you debug it; this code just gives a <code>NameError</code> on that <code>ig</code> variable.</span>
<span class="comment-copy">since i am new to python i don't know much, in simple i am trying to send is image captured from my webcam without saving it to client, for some time consider client as browser hope u can help me now.. –</span>
<span class="comment-copy">@Learner: I have no idea what "for some time consider client as browser" means. A browser doesn't make raw socket calls, it makes HTTP requests. If you want to build a web server, you have to do that (or, better, use a framework that does it for you).</span>
<span class="comment-copy">i can send if the image is already is saved, but i can't send the captured frames without saving it..  help me with the code, thanx for ur help..  example code is appreciated...</span>
<span class="comment-copy">@Learner: What have you tried to send the captured frames? Your code shows you calling <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#cv.QueryFrame" rel="nofollow noreferrer"><code>QueryFrame</code></a> to get an image object. What code are you using to get the bytes out of it? If you don't show us that, and instead show us different code that opens a file, how can anyone debug it?</span>
<span class="comment-copy">yup i've wrote client side also.. for the line b=s.recv(87029) i was sending already saved image in my pc, it is working fine for statically present data, but my problem is i don't want to save those frames, just capture and send to client how can i do it??</span>
<span class="comment-copy">since i am new to python i don't know much, in simple i am trying to send is image captured from my webcam without saving it to client, for some time consider client as browser hope u can help me now..</span>
<span class="comment-copy">@Learner: If you're only going to answer about a third of the questions that you're asked, and aren't going to show us the actual code that you're having a problem with, how can anyone possibly help you?</span>
