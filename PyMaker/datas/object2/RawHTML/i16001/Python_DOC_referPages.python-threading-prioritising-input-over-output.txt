<div class="post-text" itemprop="text">
<p>I have a python program that sends a message over a network using sockets, which uses two threads, one to run the server, and one to run the client.
However, if a message is received while the user has partially entered an input, the received message is printed between the halves of the input.
While this makes no difference functionally, aesthetically it looks horrible. Is there any way I can make the message be output as if it was received before the user began typing?</p>
<p>In case my explanation wasn't clear, assuming the user entered "hel" before the message ("Sup") was received, and then "lo" after, this would be shown:</p>
<pre><code>HelPartner Sent: Sup
lo
</code></pre>
<p>Any suggestions would be more than welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>I <em>think</em> you can do this with just <a href="https://docs.python.org/3/library/readline.html" rel="nofollow"><code>readline</code></a>.</p>
<p>Of course that means it won't help on Windows. Or if you've done anything funky with <code>sys.stdin</code>, or you're reading directly from <code>stdin</code> instead of using functions like <code>input</code>, or you're not on a TTY, or you're running under an environment like IDLE that hooks <code>input</code> in its own way, etc. But assuming none of those is a deal-breaker, <code>readline.get_line_buffer()</code> may be what you want.</p>
<p>If you're looking to queue up output until the user finishes typing—basically the same thing the shell does with, e.g., job control messages—something like this:</p>
<pre><code>import readline
output_buffer = []
output_buffer_lock = threading.Lock()

# Wherever you would normally print the output
if readline.get_line_buffer():
    with output_buffer_lock:
        output_buffer.append(output)
else:
    with output_buffer_lock:
        print('\n'.join(output_buffer + [output]))
        output_buffer = []

# Wherever you're reading the input
line = input()
with output_buffer_lock:
    print('\n'.join(output_buffer + [output]))
    output_buffer = []
</code></pre>
<p>If you instead want to interrupt the user's input, remember what they'd typed, show the output, and restart the input, that's a bit more complicated. The output thread will need some way to stash the current input buffer (<code>readline.get_line_buffer</code>), interrupt the input thread, clear the current input (printing <code>'\r' then a row of spaces and another '\r' should do it in simple cases, but see below), print the output, start a new</code>input<code>call, and refill the buffer (</code>readline.insert_text<code>then possibly</code>readline.redisplay<code>; note that you have to call this after</code>input<code>starts but before it returns, so you probably want to use</code>set_pre_input_hook` to do this).</p>
<p>If the input is happening on the main thread, a <a href="https://docs.python.org/3/library/signal.html" rel="nofollow"><code>signal</code></a> handler (which just raises a custom exception) is a great way to interrupt the <code>input</code> call. If not, it's a lot trickier.</p>
<p>Meanwhile, <code>readline</code> supports multi-line input, and by default will wrap things onto multiple lines if the user types more than 80 (or <code>$COLS</code>) characters. In that case, there's really no way to erase the whole input from the high-level API that Python's <code>readline</code> module provides. Unless you want to write or find a lower-level wrapper with <code>ctypes</code> or a custom extension module, I can't see any way around this problem.</p>
</div>
<span class="comment-copy">...and if the user isn't typing something when 'Sup' arrives, you want it to display right away?</span>
<span class="comment-copy">Exactly, so I still want messages to appear immediately, but not in the middle of the current message.</span>
<span class="comment-copy">unfortunately, that's not so easy to do on the command line because the input echoing is done for you. You'd need something that read stdin char at a time. When it sees the first char, it blocks background Sup stuff til it sees a \n.</span>
<span class="comment-copy">shame I was hoping there would be a way by either removing the input, printing the output, and putting the input back again? or print the output as if it was done before the user began typing?</span>
<span class="comment-copy">Your writing a terminal based chat program? I suggest you take a look at <code>curses</code></span>
