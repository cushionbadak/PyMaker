<div class="post-text" itemprop="text">
<p>I would like to store a bunch of variables under a Python namespace without creating a separate module. I notice that the result of <code>ArgumentParser</code>'s <code>parse_args()</code> is a <code>argparse.Namespace</code> object. You can access the arguments through dot-syntax.</p>
<pre><code>from argparse import ArgumentParser

parser = ArgumentParser()
# some arg definitions here...
args = parser.parse_args()  # returns a `argparse.Namespace` object
</code></pre>
<p>How can I create the equivalent of an <code>argparse.Namespace</code>? I know I can do something similar with a <code>dict</code> but I would like to use dot-syntax. Is there any built-in class that just lets you assign arbitrary attributes?</p>
</div>
<div class="post-text" itemprop="text">
<p>Starting with python3.3 you can use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow"><code>types.SimpleNamespace</code></a>.</p>
<p>However an alternative is simply:</p>
<pre><code>class Namespace(object):
    pass

namespaceA = Namespace()
namespaceA.x = 1
</code></pre>
<p>The full code for <code>SimpleNamespace</code> isn't much longer.</p>
<hr/>
<p>Note that you cannot simply use an <code>object</code> instance:</p>
<pre><code>&gt;&gt;&gt; o = object()
&gt;&gt;&gt; o.x = 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'object' object has no attribute 'x'
</code></pre>
<p>This is because instances of <code>object</code> do not have a <code>__dict__</code> attribute:</p>
<pre><code>&gt;&gt;&gt; vars(object())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: vars() argument must have __dict__ attribute
</code></pre>
<p>Which means you cannot set the attributes of an instance of <code>object</code>. </p>
<p>Any <code>object</code> subclass that does not have the <a href="https://docs.python.org/3.4/reference/datamodel.html#slots" rel="nofollow"><code>__slots__</code></a> attribute set <em>does</em> have the <code>__dict__</code> which is used (by default) to store/retrieve attributes:</p>
<pre><code>&gt;&gt;&gt; class Namespace(object):
...     pass
... 
&gt;&gt;&gt; a = Namespace()
&gt;&gt;&gt; a.x = 1     # same as as.__dict__['a'] = 1
&gt;&gt;&gt; a.__dict__
{'x': 1}
</code></pre>
<p>For further information about attribute setting/lookup you should learn about <a href="https://docs.python.org/3.4/howto/descriptor.html" rel="nofollow">descriptors</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want a python <code>class</code>. See <a href="https://docs.python.org/2/tutorial/classes.html" rel="nofollow">the docs</a>.</p>
<p>Depending on what you want exactly, you can define a bunch of variables as attributes of a class (either a variable of an instance or of the class itself) and access them that way.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want "the equivalent of an <code>argparse.Namespace</code>", use <code>argparse.Namespace</code>:</p>
<pre><code>from argparse import Namespace

ns = Namespace(a=1)
print ns.a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A class can be used as a namespace, where the variables are class members:</p>
<pre><code>class Namespace1:
    foo = 'a'
    bar = 5
</code></pre>
<p>To prevent callers from trying to instantiate, you can use a baseclass like:</p>
<pre><code>class objectless(object):
    def __new__(cls, *args, **kwargs):
        raise RuntimeError('%s should not be instantiated' % cls)
</code></pre>
<p>And use it like:</p>
<pre><code>class Namespace1(objectless):
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I'm understanding correctly, you want to dynamically add attributes to it.  For example, a class parses command-line flags you access them directly like args.verbose, right?  If so, you may be thinking of setattr() that lets you add arbitrary attributes.  </p>
<pre><code>class Foo(object):
    pass

foo = Foo()
setattr(foo, 'ack', 'bar')
print(foo.ack) # prints 'bar'
</code></pre>
</div>
<span class="comment-copy">How about <code>class Namespace(object): pass</code>? Instantiate it, then just start assigning attributes.</span>
<span class="comment-copy"><i>Is there any built-in class that just lets you assign arbitrary attributes?</i> - instances of <i>any</i> Python class that doesn't define <code>__slots__</code> will let you assign arbitrary attributes. (That's the principle behind @dano's and @Bakuriu's suggestion of just using a class).</span>
<span class="comment-copy">+1 because I didn't know about <code>types.SimpleNamespace</code>, and it makes the intention clear</span>
<span class="comment-copy">Great answer. I'm a little confused about something though-- why is it that I can assign arbitrary attributes to an instance of a new class that inherits from <code>object</code>, but not to an instance of <code>object</code>?</span>
<span class="comment-copy">@Sean: Because <code>object</code> instances have no <code>__dict__</code> in which to store new arbitrary attributes.</span>
<span class="comment-copy">Bakuriu: If you changed your answer to <code>class Namespace(object):</code> it would work in both Python 2 and 3...</span>
<span class="comment-copy">@SeanMackesey It works, but there are reason to avoid old-style classes, so, since it doesn't cost anything, you should always inherit from <code>object</code> in python2. I've decided to follow martineau advice and simply change the code myself (although I use only python3 currently). I also expanded a bit with regard to your observation about <code>object</code>.</span>
<span class="comment-copy">Personally I think that overloading a class definition like this wouldn't be a good idea.</span>
<span class="comment-copy">@martineau can you explain why?</span>
<span class="comment-copy">Mainly because it's defining a weird class that can't be instantiated and is unnecessary given that there's a standard way to do such a thing in Python, namely by a defining a module, which doesn't require any tricky class definitions and is more explicit. There are other issues, like defining a regular function in this type of namespace would require using a <code>@staticmethod</code> decorator to prevent a <code>TypeError: unbound method func() must be called with Namespace1 instance as first argument</code> when calling it outside of the class definition via a <code>Namespace1.func()</code> (the most likely usage)</span>
