<div class="post-text" itemprop="text">
<p>While I was away, something strange happened to Python (3.4) builtin functions. Functions like <code>map</code> and <code>zip</code> now return objects (not lists or tuples).</p>
<pre><code>In [34]: map(lambda x:1, [1,2,3])
Out[34]: &lt;map at 0x7fe27a15dac8&gt;
</code></pre>
<ol>
<li>When were these added to Python?</li>
<li>Why were they added?</li>
<li>And, most importantly, will this break any code of mine?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short answer</strong>: These are iterables, used to prevent allocating an entire list if only a limited number of elements are required. Since 3.0</p>
<p>I guess these are lazy function calls (or coroutines).</p>
<p>A lazy function call returns an object that will calculate objects only if needed.</p>
<p>For instance say you have a list of <code>1M</code> items, but you only need the first <code>3</code> of the map. Then the iterator, will only compute the first three.</p>
<p>This can also be used to perform operations on infinite lists. Say you have a list of all prime numbers. This is an iterator. Of course you can never store <strong>all</strong> prime numbers. You only compute the next one, if that's really necessary.</p>
<p>Based on the <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow">documentation</a>, I would say at 3.0?</p>
<p>In order to <em>emit</em> all items in your iterator and convert them to a list, you can use the <code>list</code> function:</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x:1, [1,2,3]))
[1, 1, 1]
</code></pre>
<p><strong>Example</strong> Infinite list.</p>
<p>Say you use the old list <code>[1,2,3]</code> but now you want a list that repeats the given list such that the total length is <code>k</code> instead of doing all the calculus yourself (for instance determining what the last element will be, you can perform):</p>
<pre><code>&gt;&gt;&gt; from itertools import *
&gt;&gt;&gt; list(islice(cycle([1,2,3]),20))
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2]
</code></pre>
<p>In other words, you can perform operations over the infinite iterator [1,2,3,1,2,3,...]. <strong>Don't perform <code>list</code> on such iterators, they will cause an out of memory exception.</strong></p>
<p>As shown in the <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow">documentation</a>, you can also take the <code>n</code>th element:</p>
<pre><code>def nth(iterable, n, default=None):
    "Returns the nth item or a default value"
    return next(islice(iterable, n, None), default)
</code></pre>
<p>And thus for instance determine whether element <code>1337</code> of the infinite Fibonacci sequence is even:</p>
<pre><code>def fibbonacci():
    i = 0
    j = 1
    while True :
        yield j
        k = j
        j = i+j
        i = k

nth(fibbonacci(),1337)
1887894200332450578485872635131438888682034332759626203734370221207918536632734791920258721345445695603925109666619483005485820744328669636758022665585261815175601673908370933079008727762461226800205778071936133115682958306317629552911384353679816770236462076654822205794785629944
</code></pre>
<p>You can define in other words a sequence that is able to calculate each element, and still perform arithmetic on the first <code>n</code>, the <code>k</code>-th,... without having to store all these values explicitly in a list per se.</p>
</div>
<span class="comment-copy">This has been the case since the 3.x line started, back in 2008. You must have been gone for a while.</span>
<span class="comment-copy">Relevant: <a href="http://stackoverflow.com/questions/22147757/iterators-in-python-3" title="iterators in python 3">stackoverflow.com/questions/22147757/iterators-in-python-3</a></span>
<span class="comment-copy">It is mainly an issue for interactive use. The majority of 2.x code works seamlessly and you only notice in the interactive interpreter.</span>
<span class="comment-copy">@dawg: Not entirely. Say you <code>map</code> a list, then modify that list and convert the mapping to a list. Since the <code>map</code> is executed after the modification of the list, the conversion is taken into account where this was not done in Python 2.x.</span>
<span class="comment-copy"><code>map</code> is not a function. In fact, <code>type(map) == map</code> not <code>builtin_function_or_method</code>.</span>
<span class="comment-copy">@PythonNut: Then why is it listed at the Python builtin functions? <a href="https://docs.python.org/3.2/library/functions.html#map" rel="nofollow noreferrer">docs.python.org/3.2/library/functions.html#map</a></span>
<span class="comment-copy">Because that's the docs for Python 3.2? I don't know; it's listed as a function in the <a href="https://docs.python.org/3.4/library/functions.html#map" rel="nofollow noreferrer">3.4 docs</a>. But it's clearly not a function... unless I'm being dumb and types are functions now.</span>
<span class="comment-copy">@PythonNut: No, you can select any Python version you want (at the top of the page). And they all have a builtin <code>map</code>. I think the term is ambiguous because there is a <code>Type</code> called <code>map</code> (the iterator type) and the function <code>map</code>. They both exist, and Python chooses the right interpretation based on syntactical usage.</span>
<span class="comment-copy">@PythonNut: Python documents many types as functions if they're primarily used as callables, since "callable" is slightly more awkward a term than "function". For example, <code>int</code>, <code>set</code>, and just about everything in <code>itertools</code>. Also, <code>type(map) != map</code>; <code>type(map) is type</code>. As for converting the map instance into a list, yes, that defeats the point of laziness, so we generally don't do it. If you want a list, a list comprehension would be the usual way to go.</span>
