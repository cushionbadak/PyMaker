<div class="post-text" itemprop="text">
<p>I'm trying to accomplish something <strong>without using threading</strong></p>
<p>I'd like to execute a function within a function, but I dont want the first function's flow to stop. Its just a procedure and I don't expect any return and I also need this to keep the execution for some reasons.</p>
<p>Here is a snippet code of what I'd like to do:</p>
<pre><code>function foo():

    a = 5

    dosomething() 
    # I dont wan't to wait until dosomething finish. Just call and follow it

    return a
</code></pre>
<p>Is there any way to do this?</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow" title="concurrent.futures">https://docs.python.org/3/library/concurrent.futures.html</a> to achieve fire-and-forget behavior.</p>
<pre><code>import concurrent.futures

def foo():
    a = 5

    with ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(dosomething)
        future.add_done_callback(on_something_done)
        #print(future.result())

    #continue without waiting dosomething()
    #future.cancel() #To cancel dosomething
    #future.done() #return True if done.

    return a

def on_something_done(future):
    print(future.result())
</code></pre>
<h2>[updates]</h2>
<p><em>concurrent.futures</em> is built-in since python <strong>3</strong></p>
<p>for Python <strong>2.x</strong> you can download <a href="https://pypi.python.org/pypi/futures" rel="nofollow" title="futures 2.1.6 here">futures 2.1.6 here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python is synchronous, you'll have to use asynchronous processing to accomplish this. </p>
<p>While there are many many ways that you can execute a function  asynchronously, one way is to use <a href="https://github.com/ui/django-rq" rel="nofollow">python-rq</a>. Python-rq allows you to queue jobs for processing in the background with workers. It is backed by Redis and it is designed to have a low barrier to entry. It should be integrated in your web stack easily.</p>
<p>For example:</p>
<pre><code>from rq import Queue, use_connection
def foo():
   use_connection()
   q = Queue()
   # do some things
   a = 5
   # now process something else asynchronously
   q.enqueue(do_something)
   # do more here
   return a
</code></pre>
</div>
<span class="comment-copy">Not really.  One interpreter implies one (and only one) thing executing python bytecode at once.  Your options are to fire it off in a new thread or process.  Or, well, you could rewrite everything using <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> I guess, but that's hardly everyone's cup of tea.</span>
<span class="comment-copy">Sadly I'm using 2.8 and that is a 3.x feature</span>
<span class="comment-copy">I found this <a href="https://pypi.python.org/pypi/futures" rel="nofollow noreferrer">pypi.python.org/pypi/futures</a> back port for python 2.7 by Alex Gr√∂nholm. didn't test it myself but looks to be same as python3.</span>
<span class="comment-copy">there is a little known multiprocessing.ThreadPool you can use in 2.7.</span>
