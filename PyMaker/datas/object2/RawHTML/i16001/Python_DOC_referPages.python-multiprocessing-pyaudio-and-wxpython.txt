<div class="post-text" itemprop="text">
<p>I have a wxPython GUI, and would like to use multiprocessing to create a separate process which uses PyAudio.  That is, I want to use PyAudio, wxPython, and the multiprocessing module, but although I can use any two of these, I can't use all three together.  Specifically, if from one file I import wx, and create a <code>multiprocessing.Process</code> which opens PyAudio, PyAudio won't open.  Here's an example:</p>
<p><strong>file: A.py</strong></p>
<pre><code>import wx
import time
use_multiprocessing = True
if use_multiprocessing:
    from multiprocessing import Process as X
else:
    from threading import Thread as X
import B

if __name__=="__main__":
    p = X(target=B.worker)
    p.start()
    time.sleep(5.)
    p.join()
</code></pre>
<p><strong>file: B.py</strong><br/></p>
<pre><code>import pyaudio

def worker():
    print "11"
    feed = pyaudio.PyAudio()
    print "22"
    feed.terminate()
</code></pre>
<p>In all my tests I see <code>11</code> print, but the problem is that I don't see <code>22</code> for the program as shown.</p>
<ul>
<li>If I only comment out <code>import wx</code> I see <code>22</code> and pyaudio loads</li>
<li>If I only set <code>use_multiprocessing=False</code> so I use threading instead, I see <code>22</code> and pyaudio loads.</li>
<li>If I do something else in <code>worker</code>, it will run (only pyaudio doesn't run) </li>
</ul>
<p>I've tried this with Python 2.6 and 2.7; PyAudio 0.2.4, 0.2.7, and 0.2.8; and wx 3.0.0.0 and 2.8.12.1; and I'm using OSX 10.9.4</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two reasons this can happen, but they look pretty much the same.</p>
<p>Either way, the root problem is that <code>multiprocessing</code> is just <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/fork.2.html" rel="nofollow"><code>fork</code></a>ing a child. This could be either causing CoreFoundation to get confused about its runloop*, or causing some internal objects inside <code>wx</code> to get confused about its threads.**</p>
<hr/>
<p>But you don't care why your child process is deadlocking; you want to know how to fix it.</p>
<p>The simple solution is to, instead of trying to <code>fork</code> and then clean up all the stuff that shouldn't be copied, <code>spawn</code> a brand-new Python process and then copy over all the stuff that should.</p>
<p>As of Python 3.4, there are actually two variations on this. See <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow">Contexts and start methods</a> for details, and <a href="http://bugs.python.org/issue8713" rel="nofollow">issue #8713</a> for the background.</p>
<p>But you're on 2.6, so that doesn't help you. So, what can you do?</p>
<hr/>
<p>The easiest answer is to switch from <code>multiprocessing</code> to the third-party library <a href="https://pypi.python.org/pypi/billiard/" rel="nofollow"><code>billiard</code></a>. <code>billiard</code> is a fork of Python 2.7's <code>multiprocessing</code>, which adds many of the features and bug fixes from both Python 3.x and Celery.</p>
<p>I believe new versions have the exact same fix as Python 3.4, but I'm not positive (sorry, I don't have it installed, and can't find the docs online…).</p>
<p>But I'm <em>sure</em> that it has a similar but different solution, inherited from Celery: call <code>billiards.forking_enable(False)</code> before calling anything else on the library. (Or, from outside the program, set the environment variable <code>MULTIPROCESSING_FORKING_DISABLE=1</code>.)</p>
<hr/>
<p><sub>* Usually, CF can detect the problem and call <code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YO‌U_MUST_EXEC__</code>, which logs an error message and fails. But sometimes it can't, and will wait end up waiting forever for an event that nobody can send. Google that string for more information.</sub></p>
<p><sub>** See <a href="http://bugs.python.org/issue5527" rel="nofollow">#5527</a> for details on the equivalent issue with threaded Tkinter, and the underlying problem. This one affects all BSD-like *nixes, not just OS X.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>If you can't solve the problem by fixing or working around <code>multiprocessing</code>, there's another option. If you can spin off the child process before you create your main runloop or create any threads, you can prevent the child process from getting confused. This doesn't <em>always</em> work, but it <em>often</em> does, so it may be worth trying.</p>
<p>That's easy to do with Tkinter or PySide or another library that doesn't actually do anything until you call a function like <code>mainloop</code> or construct an <code>App</code> instance.</p>
<p>But with wx, I think it does some of the setup before you even touch anything beyond the <code>import</code>. So, you may have to do something a little hacky and move the <code>import wx</code> after the <code>p.start()</code>.</p>
<p>In your real app, you probably aren't going to want to start doing audio until some trigger from the GUI. This means you'll need to create some kind of sync object, like an <code>Event</code>. So, you create the <code>Event</code>, then start the child process. The child initializes the audio, and then waits on the <code>Event</code>. And then, where you'd like to launch the child from the GUI, you instead just signal the <code>Event</code>.</p>
</div>
<span class="comment-copy">Is the pyaudio process dumping something like <code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</code> to stderr?</span>
<span class="comment-copy">No, nothing goes to strderr, it just hangs at pyaudio.PyAudio().</span>
<span class="comment-copy">Hmm… I'd still bet it's the same problem, but <code>PyAudio</code> isn't using the runloop in the normal way so CF can't detect it for you. Since it's too hard to explain in a comment, let me try to write an answer, and if it's wrong I'll delete it.</span>
<span class="comment-copy">Thanks for your answer. Seems like a good idea, but can't get it to work yet.  Billiard seems to not be installing correctly.</span>
<span class="comment-copy">@tom10: I would honestly try to get Billiard working first. But as an alternative, you can look at how either 3.4 <code>multiprocessing</code> or <code>billiard</code> does things and override the code in 2.6 <code>multiprocessing</code> yourself. The quickest way to pull it off is to use <code>spawn</code> in place of <code>fork</code> and then do all the Windows stuff instead of the Unix stuff.</span>
<span class="comment-copy">As you suggest, billiard solves the problem (after getting it to compile -- took some effort).  Thanks for all of your input and insight here.</span>
<span class="comment-copy">This also works.  For example, in the example in the question, if I <code>import wx</code> after starting <code>multiprocessing.Process</code>, everything works fine.  For my needs, this could be sufficient as I could start the pyaudio process first thing, but as you say, billiard seems to be the preferred approach.</span>
