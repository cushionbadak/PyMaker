<div class="post-text" itemprop="text">
<p>In Python most examples of yield from explain it with saying that </p>
<pre><code>yield from foo()
</code></pre>
<p>is similar to </p>
<pre><code>for x in foo(): yield x
</code></pre>
<p>On the other hand it doesn't seem to be exactly the same and there's some magic thrown in. I feel a bit uneasy about using a function that does magic that I don't understand. What do I have to know about the magic of <code>yield from</code> to avoid getting into a situation where the magic does something I don't expect? What advantages does the magic provide, that I should be aware of?</p>
</div>
<div class="post-text" itemprop="text">
<p>When <code>foo()</code> returns a regular iterable, the two are equivalent. The 'magic' comes into play when <code>foo()</code> is a <em>generator too</em>. At that moment, the <code>yield from foo()</code> and <code>for x in foo(): yield x</code> cases differ materially.</p>
<p>A generator can be <em>sent</em> data too, using the <a href="https://docs.python.org/3/reference/expressions.html#generator.send" rel="nofollow"><code>generator.send()</code> method</a>. When you use the <code>for</code> loop, the <code>yield x</code> expression 'receives' the sent data; the <code>foo()</code> generator will never see this. But when you use <code>yield from</code> the sent data goes straight to whatever <code>yield</code> expression the delegated-to generator is currently paused at. In other words, <code>yield from</code> passes on the sent data so the delegated-to generator can receive it instead.</p>
<p>You can also raise exceptions <em>in</em> a generator, with <a href="https://docs.python.org/3/reference/expressions.html#generator.throw" rel="nofollow"><code>generator.throw()</code></a>; with the <code>for</code> loop case, the exception is raised from the <code>yield x</code> line, while with <code>yield from</code> the exception is passed on again; the exception is raised inside <code>foo()</code> instead.</p>
<p>Together, this means that <code>yield from</code> <em>in essence</em> replaces the current generator for the duration of the delegated iteration.</p>
<p>The delegated-to generator also gets to communicate with the parent generator, when done the <code>.value</code> attribute of the <code>StopIteration</code> exception raised is returned as the value of the <code>yield from</code> expression. You can set the value of that exception by using <code>return &lt;expression&gt;</code> in the delegated-to <code>foo()</code> generator, or you can use <code>raise StopIteration(&lt;expression&gt;)</code> explicitly.</p>
<p><code>yield from</code> was introduced into the language with <a href="http://www.python.org/dev/peps/pep-0380/" rel="nofollow">PEP 380: <em>Syntax for Delegating to a Subgenerator</em></a>.</p>
</div>
<span class="comment-copy">See <a href="http://legacy.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP-380</a>.</span>
<span class="comment-copy">Related question: <a href="http://stackoverflow.com/questions/24033577/difference-between-generator-expression-and-generator-function" title="difference between generator expression and generator function">stackoverflow.com/questions/24033577/â€¦</a></span>
<span class="comment-copy">+1 for the simple explanation. <code>yield from</code> allows you to refactor a generator into several functions without changing the behavior of the code (though the nested generators are still not optimized as far as I know e.g., <code>O(n*k)</code> behavior is possible if you are implementing a power set instead of <code>O(n)</code> where <code>n=2**k</code>).</span>
<span class="comment-copy">This really set the foundation of your answer: <i>"When <code>foo()</code> returns a regular iterable, the two are equivalent. The 'magic' comes into play when <code>foo()</code> is a generator too."</i> Wanna delegate to another generator? Use <code>yield from</code>.</span>
