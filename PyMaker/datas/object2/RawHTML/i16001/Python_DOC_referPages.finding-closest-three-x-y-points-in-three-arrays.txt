<div class="post-text" itemprop="text">
<p>In Python, I have three lists containing x and y coordinates. Each list contains 128 points. How can I find the the closest three points in an efficient way?</p>
<p>This is my working python code but it isn't efficient enough:</p>
<pre><code>   def findclosest(c1, c2, c3):
       mina = 999999999
       for i in c1:
          for j in c2:
             for k in c3:
                # calculate sum of distances between points
                d = xy3dist(i,j,k)
                if d &lt; mina:
                   mina = d

    def xy3dist(a, b, c):
       l1 = math.sqrt((a[0]-b[0]) ** 2 + (a[1]-b[1]) ** 2 )   
       l2 = math.sqrt((b[0]-c[0]) ** 2 + (b[1]-c[1]) ** 2 )   
       l3 = math.sqrt((a[0]-c[0]) ** 2 + (a[1]-c[1]) ** 2 )       
       return l1+l2+l3
</code></pre>
<p>Any idea how this can be done using numpy?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use Numpy's broadcasting features to vectorize the two inner loops:</p>
<pre><code>
import numpy as np

def findclosest(c1, c2, c3):
   c1 = np.asarray(c1)
   c2 = np.asarray(c2)
   c3 = np.asarray(c3)

   for arr in (c1, c2, c3):
       if not (arr.ndim == 2 and arr.shape[1] == 2):
           raise ValueError("expected arrays of 2D coordinates")

   min_val = np.inf
   min_pos = None

   for a, i in enumerate(c1):
       d = xy3dist(i, c2.T[:,:,np.newaxis], c3.T[:,np.newaxis,:])
       k = np.argmin(d)

       if d.flat[k] &lt; min_val:
           min_val = d.flat[k]
           b, c = np.unravel_index(k, d.shape)
           min_pos = (a, b, c)

       print a, min_val, d.min()

   return min_val, min_pos

def xy3dist(a, b, c):
   l1 = np.sqrt((a[0]-b[0]) ** 2 + (a[1]-b[1]) ** 2 )   
   l2 = np.sqrt((b[0]-c[0]) ** 2 + (b[1]-c[1]) ** 2 )   
   l3 = np.sqrt((a[0]-c[0]) ** 2 + (a[1]-c[1]) ** 2 )       
   return l1+l2+l3

np.random.seed(1234)
c1 = np.random.rand(5, 2)
c2 = np.random.rand(9, 2)
c3 = np.random.rand(7, 2)

val, pos = findclosest(c1, c2, c3)

a, b, c = pos
print val, xy3dist(c1[a], c2[b], c3[c])
</code></pre>
<p>It's also possible to vectorize all of the 3 loops
<code><pre>
def findclosest2(c1, c2, c3):
    c1 = np.asarray(c1)
    c2 = np.asarray(c2)
    c3 = np.asarray(c3)
    d = xy3dist(c1.T[:,:,np.newaxis,np.newaxis], c2.T[:,np.newaxis,:,np.newaxis], c3.T[:,np.newaxis,np.newaxis,:])
    k = np.argmin(d)
    min_val = d.flat[k]
    a, b, c = np.unravel_index(k, d.shape)
    min_pos = (a, b, c)
    return min_val, min_pos
</pre></code></p></div>
<div class="post-text" itemprop="text">
<p>Let's try timing some different solutions to see.</p>
<p>I'm going to initialize three arrays using numpy's random functions. If you have existing variables that are lists of tuples or lists of lists, just call <code>np.array</code> on them.</p>
<pre><code>import numpy as np

c1 = np.random.normal(size=(128, 2))
c2 = np.random.normal(size=(128, 2))
c3 = np.random.normal(size=(128, 2))
</code></pre>
<hr/>
<p>First let's time your code so we have a starting point.</p>
<pre><code>def findclosest(c1, c2, c3):
    mina = 999999999
    for i in c1:
        for j in c2:
            for k in c3:
                 # calculate sum of distances between points
                 d = xy3dist(i,j,k)
                 if d &lt; mina:
                     mina = d
    return mina

def xy3dist(a, b, c):
     l1 = math.sqrt((a[0]-b[0]) ** 2 + (a[1]-b[1]) ** 2 )   
     l2 = math.sqrt((b[0]-c[0]) ** 2 + (b[1]-c[1]) ** 2 )   
     l3 = math.sqrt((a[0]-c[0]) ** 2 + (a[1]-c[1]) ** 2 )       
     return l1+l2+l3

%timeit findclosest(c1, c2, c3)
# 1 loops, best of 3: 23.3 s per loop
</code></pre>
<hr/>
<p>One function that might be helpful is <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html#scipy.spatial.distance.cdist" rel="nofollow"><code>scipy.spatial.distance.cdist</code></a>, which calculates all the pairwise distances between two arrays of points. So we can use this to calculate and store all the distances beforehand, then simply get and add distances from those arrays. I'm also going to use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> to simplify the loop, though it won't be doing any speedup work.</p>
<pre><code>from scipy.spatial.distance import cdist
from itertools import product

def findclosest_usingcdist(c1, c2, c3):
    dists_12 = cdist(c1, c2)
    dists_23 = cdist(c2, c3)
    dists_13 = cdist(c1, c3)

    min_dist = np.inf
    ind_gen = product(range(len(c1)), range(len(c2)), range(len(c3)))
    for i1, i2, i3 in ind_gen:
        dist = dists_12[i1, i2] + dists_23[i2, i3] + dists_13[i1, i3]
        if dist &lt; min_dist:
            min_dist = dist
            min_points = (c1[i1], c2[i2], c3[i3])

    return min_dist, min_points

%timeit findclosest_usingcdist(c1, c2, c3)
# 1 loops, best of 3: 2.02 s per loop
</code></pre>
<p>So using <code>cdist</code> buys us an order of magnitude speedup.</p>
<hr/>
<p>That, however, doesn't even compare to @pv's answer. An implementation of his with some stuff stripped away to compare better with the previous solutions (see @pv's answer for the implementation that returns the points).</p>
<pre><code>def findclosest2(c1, c2, c3):
    d = xy3dist(c1.T[:,:,np.newaxis,np.newaxis], 
                c2.T[:,np.newaxis,:,np.newaxis], 
                c3.T[:,np.newaxis,np.newaxis,:])
    k = np.argmin(d)
    min_val = d.flat[k]
    i1, i2, i3 = np.unravel_index(k, d.shape)
    min_points = (c1[i1], c2[i2], c3[i3])
    return min_val, min_points 

def xy3dist(a, b, c):
    l1 = np.sqrt((a[0]-b[0]) ** 2 + (a[1]-b[1]) ** 2 )   
    l2 = np.sqrt((b[0]-c[0]) ** 2 + (b[1]-c[1]) ** 2 )   
    l3 = np.sqrt((a[0]-c[0]) ** 2 + (a[1]-c[1]) ** 2 )       
    return l1+l2+l3

%timeit findclosest_usingbroadcasting(c1, c2, c3)
# 100 loops, best of 3: 19.1 ms per loop
</code></pre>
<p>So that's a massive speedup and is definitely the right answer.</p>
</div>
<span class="comment-copy">What is the distance function xy3dist?</span>
<span class="comment-copy">Sorry - post updated. It can be simplified by removing the sqrt but does not improve speed alot. I need another solution :-)</span>
<span class="comment-copy">Just to clarify. By "closest three points" you still mean one point of each list?</span>
<span class="comment-copy">To clarify, you just want the minimum distance right? You don't care about what the points corresponding to that distance are?</span>
<span class="comment-copy">Yes, one point in each list. And yes, total min distance when adding distance between all three points.</span>
<span class="comment-copy">maybe trivial for numpy users, but I would need the x,y coordinates of the three points...OK - it was trivial - solved :-)</span>
<span class="comment-copy">@AlterSchwede That's why his second solution returns <code>min_pos</code>, that's just the indices in each array of the minimum point. You can extract them with a simple <code>c1[a], c2[b], c3[c]</code>.</span>
<span class="comment-copy">This solution is a factor 100 faster then the original version - Great Thanks!</span>
<span class="comment-copy">Looks good but I would need the xy coordinates of the three closest points...</span>
<span class="comment-copy">@AlterSchwede Sigh, I wish you had clarified that when I asked exactly that question in the comments. Regardless, I modified the latter two solutions to return the points. pv's answer already 90% of the way to do that.</span>
<span class="comment-copy">Sorry - now solved and thanks for fixing performance problem for me.</span>
