<div class="post-text" itemprop="text">
<p>i have a dictionary:</p>
<pre><code>People={
       'name':['john','peter'],
       'age':[56,64]
       }
</code></pre>
<p>output</p>
<pre><code>'My name is {name[0]},i am {age[0]} old'.format_map(People)
</code></pre>
<p>gives</p>
<pre><code>'My name is john,i am 56 old'
</code></pre>
<p>i would like to use format_map in a loop to get:</p>
<pre><code>'My name is {name[x]},i am {age[x]} old'
</code></pre>
<p>for each item in the dictionary like:</p>
<pre><code>'My name is john,i am 56 old'
'My name is peter,i am 64 old'
</code></pre>
<p>but a loop like:</p>
<pre><code>['My name is {name[x]},i am {age[x]} old'.format_map(People) for x in range(0,len(People['name']))]
</code></pre>
<p>gives:</p>
<pre><code>KeyError: 'name'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>str.format_map</code> accepts a mapping. You cannot pass additional argument.</p>
<p>Alternatively, you can use <code>str.format</code>, but nesting <code>{..}</code> inside indexing (<code>{0[name][{x}]}</code>) is not allowed.</p>
<p>Workaround using <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow"><code>str.format</code></a> and <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> / <a href="https://docs.python.org/3/library/functions.html#map" rel="nofollow"><code>map</code></a>:</p>
<pre><code>&gt;&gt;&gt; people = {
...    'name': ['john','peter'],
...    'age': [56, 64]
... }

&gt;&gt;&gt; ['My name is {}, i am {} old'.format(*x)
...  for x in zip(people['name'], people['age'])]
['My name is john, i am 56 old', 'My name is peter, i am 64 old']

&gt;&gt;&gt; ['My name is {}, i am {} old'.format(*x)
...  for x in zip(*map(people.get, ['name', 'age']))]
['My name is john, i am 56 old', 'My name is peter, i am 64 old']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may wish to consider using a different structure for your data, something that keeps all the data for each person together. With only two people and with only two attributes for each person, it doesn't really matter, but if you have lots of people and lots of attributes it only takes a single error in one of your lists to destroy the synchronisation. And if that happens, one or more of the people in your database will get the wrong data associated with them.</p>
<p>One possibility is to use a list of dicts, one dict for each person, eg</p>
<pre><code>new_people = [
    {'age': 56, 'name': 'john'},
    {'age': 64, 'name': 'peter'}
]
</code></pre>
<p>And then you can easily print it by doing something like this:</p>
<pre><code>for d in new_people:
    print('My name is {0}, I am {1} years old.'.format(d['name'], d['age']))
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>My name is john, I am 56 years old.
My name is peter, I am 64 years old.
</code></pre>
<hr/>
<p>It's not that hard to convert your existing People dict to a list of dicts. It's probably more readable to do it with a couple of <code>for</code> loops, but I did it with this nested list comprehension / generator expression:</p>
<p><code>new_people = [dict(t) for t in (((k,v[i]) for k,v in People.items()) for i in range(len(People['name'])))]</code></p>
<p>PS. It's a convention in Python to use lower-case names for normal variables. Names beginning with an upper-case letter, like People, are usually used for classes. You don't <em>have</em> to follow that convention, but it does make it easier for people who are reading your code. You may notice that in the code you posted above People is in a light blue colour, that's because the SO code formatter thinks its a class name.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do two-pass formatting:</p>
<pre><code>people = {
   'name': ['John', 'Peter'],
   'age': [56, 64]
}

for i in range(2):
    'My name is {{name[{0}]}}, I am {{age[{0}]}} years old.'.format(i).format_map(people)

#&gt;&gt;&gt; 'My name is John, I am 56 years old.'
#&gt;&gt;&gt; 'My name is Peter, I am 64 years old.'
</code></pre>
<p><code>...{{...}}...</code> formats to <code>...{...}...</code>, so is suitable the <em>second</em> call to <code>format</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It might be more intuitive for you to do:</p>
<pre><code>strs = ["My name is " + People['name'][i] + ",i am " + str(People['age'][i]) + " old" for i in len(People)]
print(strs # ['My name is john,i am 56 old', 'My name is peter,i am 64 old'])
</code></pre>
</div>
<span class="comment-copy">@PM2Ring, It works very well for me (both in Python 2.7, Python 3.4). See this: <a href="https://asciinema.org/a/12330" rel="nofollow noreferrer">asciinema.org/a/12330</a></span>
<span class="comment-copy">@PM2Ring, <code>map</code> version will be more useful if there are more than 2 keys in the dictionary. (You don't need to repeat <code>people[...]</code>)</span>
<span class="comment-copy">@PM2Ring, You were totally right. Sorry for insting wrong thought. Thank you for pointing that.</span>
<span class="comment-copy">No problem, falsetru.</span>
<span class="comment-copy">OP uses Python 3.x. There's no <code>dict.iteritems</code> in Python 3.x. It should be <code>items</code>.</span>
<span class="comment-copy"><code>len(People)</code> will always return 2 even though there are more people in the lists because there are two keys in the given dictionary; <code>len(People)</code> should be <code>len(People['name'])</code>.</span>
<span class="comment-copy">I would do: <code>new_people = [{k: v[i] for k, v in People.items()} for i in range(len(People['name']))]</code> (using dict-comprehension)</span>
<span class="comment-copy">@falsetru: Your dict comprehension is certainly a <i>lot</i> cleaner than my (in)comprehension. I really ought to learn Python 3 one of these days...</span>
<span class="comment-copy">dictionary comprehension is also available in Python 2.7.</span>
<span class="comment-copy">I would use <code>len(people['name'])</code> instead of hard-coded 2 as OP did.  BTW, <code>print</code> in  Python 3.x is a function.</span>
<span class="comment-copy">Good points! Thanks @falsetru</span>
