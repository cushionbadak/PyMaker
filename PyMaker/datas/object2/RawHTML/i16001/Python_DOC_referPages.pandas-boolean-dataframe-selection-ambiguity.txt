<div class="post-text" itemprop="text">
<p>EDIT: Fixed values in tables.</p>
<p>Let's say I have a pandas dataframe df:</p>
<pre><code>&gt;&gt;&gt;df
                  a         b         c
        0  0.016367  0.289944 -0.891527
        1  1.130206  0.899758 -0.276587
        2  1.390528 -1.472802  0.128979
        3  0.023598 -0.931329  0.158143
        4  1.401183 -0.162357 -0.959156
        5 -0.127765  1.142039 -0.734434
</code></pre>
<p>So now I try to do some Boolean indexing:</p>
<pre><code>&gt;&gt;&gt;df[df &gt; 0.5]
          a         b         c
0       NaN       NaN        Nan
1  1.130206  0.899758        NaN
2  1.390528       NaN        NaN
3       NaN       NaN        NaN
4  1.401183       NaN        NaN
5       NaN  1.142039        NaN

&gt;&gt;&gt;df[df &lt; 0]
          a         b         c
0       NaN       NaN -0.891527
1       NaN       NaN -0.276587
2       NaN -1.472802       NaN
3       NaN -0.931329       NaN
4       NaN -0.162357 -0.959156
5 -0.127765       NaN -0.734434
</code></pre>
<p>So now I try to do the logical OR of thos to conditions as the indexing condition:</p>
<pre><code>&gt;&gt;&gt;df[df &gt; 0.5 or df &lt; 0]
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
File "C:\Users\Ben\Anaconda\lib\site-packages\pandas\core\generic.py", line 692, in __nonzero__
.format(self.__class__.__name__))
ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any()    or a.all().
</code></pre>
<p>I've researched this a bit, its a basic feature that the developers of numpy decided certain conditions may be ambiguous depending in the any or all case.  What I don't get is why checking if the value is &gt; 0.5 is valid and checking if its &lt; 0 is valid, but checking if its &gt; 0.5 or &lt; 0 is INVALID.  I've also tried mixing up the boolean syntax, but this error is in escable.  Can some one explain why doing the OR creates an ambiguous case?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is not possible for custom types to override the behavior of <code>and</code> and <code>or</code> in Python.  That is, it is not possible for Numpy to say that it wants <code>[0, 1, 1] and [1, 1, 0]</code> to be <code>[0, 1, 0]</code>.  This is because of how the <code>and</code> operation short-circuits (see <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow">the documentation</a>); in essence, the short-circuiting behavior of <code>and</code> and <code>or</code> means that these operations must work as two separate truth values on the two arguments; they cannot combine their two operands in some way that makes use of data in both operands at once (for instance, to compare the elements componentwise, as would be natural for Numpy).</p>
<p>The solution is to use the bitwise operators <code>&amp;</code> and <code>|</code>.  However, you do have to be careful with this, since the precedence is not what you might expect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the logical operators are not overridable in python, numpy and pandas override the bitwise operators.</p>
<p>This means you need to use the bitwise-or operator:</p>
<pre><code>df[(df &gt; 0.5) | (df &lt; 0)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to use the bitwise or and put the conditions in parentheses:</p>
<pre><code>df[(df &gt; 0.5) | (df &lt; 0)]
</code></pre>
<p>The reason is because it is ambiguous to compare arrays when maybe some of the values in the array satisfy the condition, that is why it becomes ambiguous.</p>
<p>If you called the attribute <code>any</code> then it would evaluate to True.</p>
<p>The parentheses is required due to operator precedence.</p>
<p>Example:</p>
<pre><code>In [23]:

df = pd.DataFrame(randn(5,5))
df
Out[23]:
          0         1         2         3         4
0  0.320165  0.123677 -0.202609  1.225668  0.327576
1 -0.620356  0.126270  1.191855  0.903879  0.214802
2 -0.974635  1.712151  1.178358  0.224962 -0.921045
3 -1.337430 -1.225469  1.150564 -1.618739 -1.297221
4 -0.093164 -0.928846  1.035407  1.766096  1.456888
In [24]:

df[(df &gt; 0.5) | (df &lt; 0)]
Out[24]:
          0         1         2         3         4
0       NaN       NaN -0.202609  1.225668       NaN
1 -0.620356       NaN  1.191855  0.903879       NaN
2 -0.974635  1.712151  1.178358       NaN -0.921045
3 -1.337430 -1.225469  1.150564 -1.618739 -1.297221
4 -0.093164 -0.928846  1.035407  1.766096  1.456888
</code></pre>
</div>
<span class="comment-copy">Interesting, I wasn't aware of that behavior in numpy.  When you say the precedence isn't always what you expect, what side effects do you mean?  Is there a more idiomatic way to filter numpy/pandas objects based on compound Boolean expressions?</span>
<span class="comment-copy">@user3299166: The bitwise operators have higher precedence than comparison operators so for instance <code>1 &lt; 2 &amp; 0 &lt; 1</code> is false (it is interpreted as (<code>1 &lt; (2 &amp; 0) &lt; 1</code>).  You best thing is to use the bitwise operators, but parenthesise their operands to avoid surprises, e.g., <code>df[(df.A &lt; 5) &amp; (df.B &gt; 0)]</code>.</span>
<span class="comment-copy">That makes sense, is there s way to perform the desired filtering using any()?</span>
<span class="comment-copy">It wouldn't be that much use to be honest, essentially you still have to use the bitwise operators and if you did say <code>df[df.any() &gt; 0.5]</code> it would return the whole df if a single element satisfied the condition which would not be much use</span>
