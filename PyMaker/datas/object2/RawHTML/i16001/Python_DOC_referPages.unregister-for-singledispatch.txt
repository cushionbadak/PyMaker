<div class="post-text" itemprop="text">
<p>Is there way to "unregister" a registered function for a generic ?</p>
<p>For example:</p>
<pre><code>from functools import singledispatch

@singledispatch
def foo(x):
    return 'default function'

foo.register(int, lambda x: 'function for int')

# later I would like to revert this.

foo.unregister(int) # does not exist - this is the functionality I am after
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>singledispatch</code> is meant to be <em>append only</em>; you cannot really unregister anything.</p>
<p>But as with all things Python, the implementation <em>can</em> be forced to unregister. The following function will add a <code>unregister()</code> method to a singledispatch function:</p>
<pre><code>def add_unregister(func):
    # build a dictionary mapping names to closure cells
    closure = dict(zip(func.register.__code__.co_freevars, 
                       func.register.__closure__))
    registry = closure['registry'].cell_contents
    dispatch_cache = closure['dispatch_cache'].cell_contents
    def unregister(cls):
        del registry[cls]
        dispatch_cache.clear()
    func.unregister = unregister
    return func
</code></pre>
<p>This reaches into the closure of the <code>singledispatch.register()</code> function to access the actual <code>registry</code> dictionary so we can remove an existing class that was registered. I also clear the <code>dispatch_cache</code> weak reference dictionary to prevent it from stepping in.</p>
<p>You can use this as a decorator:</p>
<pre><code>@add_unregister
@singledispatch
def foo(x):
    return 'default function'
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; @add_unregister
... @singledispatch
... def foo(x):
...     return 'default function'
... 
&gt;&gt;&gt; foo.register(int, lambda x: 'function for int')
&lt;function &lt;lambda&gt; at 0x10bed6400&gt;
&gt;&gt;&gt; foo.registry
mappingproxy({&lt;class 'object'&gt;: &lt;function foo at 0x10bed6510&gt;, &lt;class 'int'&gt;: &lt;function &lt;lambda&gt; at 0x10bed6400&gt;})
&gt;&gt;&gt; foo(1)
'function for int'
&gt;&gt;&gt; foo.unregister(int)
&gt;&gt;&gt; foo.registry
mappingproxy({&lt;class 'object'&gt;: &lt;function foo at 0x10bed6510&gt;})
&gt;&gt;&gt; foo(1)
'default function'
</code></pre>
</div>
<span class="comment-copy">It's probably worth pointing out that although Martijn's answer proves you <i>can</i>, in fact, do this, you probably <i>shouldn't</i>: the designers of singledispatch made a <a href="http://permalink.gmane.org/gmane.comp.python.devel/139709" rel="nofollow noreferrer">conscious decision</a> to make it difficult by exposing a <a href="https://docs.python.org/3/library/types.html#types.MappingProxyType" rel="nofollow noreferrer"><code>mappingproxy</code></a> rather than a regular dictionary.</span>
<span class="comment-copy">@ZeroPiraeus It is not apparent to me that unregistering a function is precisely what they were trying to prevent. It seems like like reflection from the registered function (the functions changing the generic).</span>
<span class="comment-copy">Thanks. I am surprised that this feature is not part of singledispatch.</span>
<span class="comment-copy">@lgautier: the perceived use-case for this is that you construct this <i>once</i>, not alter dispatch rules as you go along.</span>
<span class="comment-copy">@martjin-pieters: Since Python is dynamic it seems unnecessary limiting to not allow it. Technically, dispatch rules <i>are</i> altered as one goes along (as the Python code is evaluated, and as new functions for the generic are registered). Anyway, this is more likely a discussion for python-ideas, or possibly python-dev. Thanks again for stopping by with an answer.</span>
