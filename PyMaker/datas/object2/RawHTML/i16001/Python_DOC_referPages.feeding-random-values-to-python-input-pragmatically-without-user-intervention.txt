<div class="post-text" itemprop="text">
<p>I am looking to find a way to pass random values to a python code which takes multiple user inputs from the user command line from following python command. I think it could help me in testing.</p>
<pre><code>num = input("Some prompt")
</code></pre>
<p>Is there any method/way to automatically (programatically) pass values to these python input() functions without waiting for user input on console ?</p>
<p>Also, my code takes multiple inputs from user based on a user input which specifies how many user inputs to fetch. </p>
<p>My code:</p>
<pre><code>def delicious_prize(n):
    ##N no of boxes
    ##K product number of chocklates in N boxes 
    ##T total no of test cases
    print("n = ", n)
    if not isinstance(n, int):
        print("Not integer type. Only int accepted. Aborting")
        return False
    elif not n &lt;= 1000:
        print("Inpute n: %s is not in range. Should be less than or equal to 1000"%(n))
        exit
    elif n &lt; 0:
        print("No of boxes cannot be negative. Taking positve magnitude as %s"%(abs(n)))
        n = abs(n)
    elif n == 0:
        print("No chocklate boxes offered !")
        exit

    num_list = []
    for i in range(n):
        num = input("Enter no of chocklates in %sth box : "%(i))
        num_list.append(int(num))
    num_tuple = tuple(num_list)
    print(num_tuple)
    return tuple_count(num_tuple)


if __name__=='__main__':

    print(delicious_prize(2))
    print(delicious_prize(0))
    print(delicious_prize(-3))
    print(delicious_prize('wqete'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <em>replace</em> the <code>input()</code> function with your own. A dedicated package for doing this during testing is part of the Python standard library: <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow"><code>unittest.mock</code></a>.</p>
<p>In your test you'd mock <code>input()</code> and have it return specific values, or entirely random values:</p>
<pre><code>if __name__=='__main__':
    from unittest import mock
    with mock.patch('__main__.input', create=True) as mocked_input:
        mocked_input.side_effect = ['first input', 'second input', 'third input']
        delicious_prize(3)
</code></pre>
<p>In the above code, a new <code>input</code> object is inserted into your module, masking the built-in <code>input()</code> function. When it is called by code in <code>delicious_prize</code>, each time another value from the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow"><code>side_effect</code> attribute list</a> is returned.</p>
<p>In this specific test, the strings are not valid numbers; your real tests would use values that can be converted to integers.</p>
<p>When testing, always pass in <em>predictable</em> values; you want your unit tests to be solid and repeatable, not fail just some of the time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way to feed data to a program that's expecting console input is to use <a href="http://en.wikipedia.org/wiki/Redirection_%28computing%29#Redirecting_standard_input_and_standard_output" rel="nofollow">input redirection</a></p>
<p>You just put the data you want to input into a plain text file (eg data.txt), with one input string per line, and then you can do:</p>
<p>python myprog.py &lt; data.txt</p>
<p>There are variations on this theme, eg feeding the output of one program into the input of another, as the Wikipedia article explains.</p>
<p>The main advantage of this method is that you don't have to modify <code>myprog.py</code> in any way, but the disadvantage is that the stuff printed by your input prompts will look a little bit weird because the data read from the file will not be echoed to the console. Also, this technique isn't as flexible as the techniques discussed by Wolf and Martijn Pieters. But it can be <em>very</em> handy.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a very <strong>obvious way to replace the built-in <em>input</em> function</strong>. Just insert two lines at the beginning of the part you dedicated to testing:</p>
<pre><code>if __name__=='__main__':
    import random
    input = lambda s: random.randint(1, 12)
    print(delicious_prize(2))
    print(delicious_prize(0))
    print(delicious_prize(-3))
    print(delicious_prize('wqete'))
</code></pre>
<p>You asked for randomness that's why I used it - I'd probably start with a constant input:</p>
<pre><code>    input = lambda s: 6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would rather replace <code>sys.stdin</code> when you are doing the testing:</p>
<pre><code>import StringIO
import sys 

sys.stdin = StringIO.StringIO("1000\n")
num = input("some number: ")

print("\nread %d from input" % num)
</code></pre>
<p>Step through the example above at <a href="https://dbgr.cc/4u#autoPlay=true" rel="nofollow">https://dbgr.cc/4u#autoPlay=true</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/questions/25946903/feeding-random-values-to-python-input-pragmatically-without-user-intervention#comment40621794_25946903">quamrana suggested in a comment</a>, you can pass your own input function as parameter. </p>
<pre><code>import random

def test(x, input=input): # input function, defaults to the built-in one
    v=input("Your input: ")
    print v==x

results = (3, 4)

def ran(s):
    i = random.choice(results)
    print s+str(i)
    return i

test(3, ran)
test(4, ran)
test(4)
</code></pre>
<p>Output (depending on <code>random</code> and <em>your</em> input) may look like this:</p>
<pre><code>Your input: 4
False
Your input: 3
False
Your input: 4
True
</code></pre>
<hr/>
<p>BTW: <strong>Testability is only one reason</strong> for isolating function logic from specific ways of input and output.</p>
</div>
<span class="comment-copy">Just pass 'input' as a parameter to your function.</span>
<span class="comment-copy">Is feeding random values really such a good idea in this case? I'd use a constant instead, and <a href="http://stackoverflow.com/a/25957770/2932052">just replacing input is pretty easy</a></span>
<span class="comment-copy">Random inputs can be a good, but non-deterministic, way to look for test cases. However, keep in mind that tests are do not find bugs; they ensure that known working code does not <i>develop</i> bugs in later changes.</span>
<span class="comment-copy">BTW: What does <code>tuple_count</code> do?</span>
<span class="comment-copy">@Wolf : It returns the count of integers items entered in the input. If you want i can paste the code here. I also got a better suggestion from some article which says using command line arguments instead of raw_inputs is a good practice. Random values for testing is a good choice. I am looking into mock tests for details on implementation. Thanks a lot wolf for wonderful suggestions :)</span>
<span class="comment-copy">@MartijinPieters : Thanks for mock library. I wasen't aware of that. Will go through it and update my code.</span>
<span class="comment-copy">I would also suggest against using random numbers as test inputs, you want to use values which exercise your code and produce values which you can identify independently (either by another algorithm, or by working out the answer before hand). If you use random numbers, how will you know that your code is producing the correct result, unless you replicate all of your code in your test modules.</span>
<span class="comment-copy">Very nice suggestion indeed @TonySuffolk :) Thanks and +1 for for the tip. Havent thought about that either</span>
<span class="comment-copy">Good to bring this opportunity to mind. But in the give case the tests are already difficult to control, this will even get worse with input from two different files. I think the <code>delicious_prize</code> function is badly testable.</span>
<span class="comment-copy">@Wolf : Yeah, I'd be inclined to pipe the input from a small Python program that generates <code>n</code> followed by the next n lines of data, rather than pulling it from a file. But that's why I supplied the Wiki link, so that the OP could learn about such things...</span>
<span class="comment-copy">Good solution: StringIO prevents working on a second file. I'm curious if the <code>to_stdin</code> function could be omitted...</span>
<span class="comment-copy">you could just set stdin to <code>sys.stdin = StringIO.StringIO("1000\n")</code> as well (to omit the <code>to_stdin</code> function). Example: <a href="https://dbgr.cc/4u#autoPlay=true" rel="nofollow noreferrer">dbgr.cc/4u#autoPlay=true</a>.  Also, if/when you want to restore <code>stdin</code> to the <i>real</i> stdin, do <code>sys.stdin = sys.__stdin__</code></span>
<span class="comment-copy">That's an excellent BTW, Wolf.</span>
<span class="comment-copy">@PM2Ring Oh thanks a lot :-) but I think <a href="http://stackoverflow.com/a/25957770/2932052">my second answer</a> is so much simpler.</span>
<span class="comment-copy">Your answer is cool; I've never thought of shadowing <code>input</code> like that before. But I was mostly referring to your <code>**Testability is only one reason for isolating function logic from specific ways of input and output.**</code> Volumes could (and have) been written on <i>that</i> topic. :)</span>
