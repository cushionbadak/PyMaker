<div class="post-text" itemprop="text">
<p>I know that <code>multiprocessing</code> uses pickling in order to have the processes run on different CPUs, but I think I am a little confused as to what is being pickled. Lets look at this code.</p>
<pre><code>from multiprocessing import Process

def f(I):
    print('hello world!',I)

if __name__ == '__main__':
    for I in (range1, 3):
        Process(target=f,args=(I,)).start()
</code></pre>
<p>I assume what is being pickled is the <code>def f(I)</code> and the argument going in.  First, is this assumption correct?</p>
<p>Second, lets say <code>f(I)</code> has a function call within in it like:</p>
<pre><code>def f(I):
    print('hello world!',I)
    randomfunction()
</code></pre>
<p>Does the <code>randomfunction</code>'s definition get pickled as well, or is it only the function call?</p>
<p>Further more, if that function call was located in another file, would the process be able to call it?</p>
</div>
<div class="post-text" itemprop="text">
<p>In this particular example, what gets pickled is platform dependent. On systems that support <code>os.fork</code>, like Linux, nothing is pickled here. Both the target function and the args you're passing get inherited by the child process via <code>fork</code>.</p>
<p>On platforms that don't support <code>fork</code>, like Windows, the <code>f</code> function and <code>args</code> tuple will both be pickled and sent to the child process. The child process will re-import your <code>__main__</code> module, and then unpickle the function and its arguments.</p>
<p>In either case, <code>randomfunction</code> is not actually pickled. When you pickle <code>f</code>, all you're really pickling is a pointer for the child function to re-build the <code>f</code> function object. This is usually little more than a string that tells the child how to re-import <code>f</code>:</p>
<pre><code>&gt;&gt;&gt; def f(I):
...     print('hello world!',I)
...     randomfunction()
... 
&gt;&gt;&gt; pickle.dumps(f)
'c__main__\nf\np0\n.'
</code></pre>
<p>The child process will just re-import <code>f</code>, and then call it. <code>randomfunction</code> will be accessible as long as it was properly imported into the original script to begin with.</p>
<p>Note that in Python 3.4+, you can get the Windows-style behavior on Linux by using <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow">contexts</a>:</p>
<pre><code>ctx = multiprocessing.get_context('spawn')
ctx.Process(target=f,args=(I,)).start()  # even on Linux, this will use pickle
</code></pre>
<p>The descriptions of the contexts are also probably relevant here, since they apply to Python 2.x as well:</p>
<blockquote>
<p><strong>spawn</strong> </p>
<p>The parent process starts a fresh python interpreter process.
  The child process will only inherit those resources necessary to run
  the process objects run() method. In particular, unnecessary file
  descriptors and handles from the parent process will not be inherited.
  Starting a process using this method is rather slow compared to using
  fork or forkserver.</p>
<p>Available on Unix and Windows. The default on Windows.</p>
<p><strong>fork</strong> </p>
<p>The parent process uses os.fork() to fork the Python interpreter.
  The child process, when it begins, is effectively identical to the
  parent process. All resources of the parent are inherited by the child
  process. Note that safely forking a multithreaded process is
  problematic.</p>
<p>Available on Unix only. The default on Unix.</p>
<p><strong>forkserver</strong> </p>
<p>When the program starts and selects the forkserver start
  method, a server process is started. From then on, whenever a new
  process is needed, the parent process connects to the server and
  requests that it fork a new process. The fork server process is single
  threaded so it is safe for it to use os.fork(). No unnecessary
  resources are inherited.</p>
<p>Available on Unix platforms which support passing file descriptors
  over Unix pipes.</p>
</blockquote>
<p>Note that <code>forkserver</code> is only available in Python 3.4, there's no way to get that behavior on 2.x, regardless of the platform you're on.</p>
</div>
<div class="post-text" itemprop="text">
<p>The function is pickled, but possibly not in the way you think of it:</p>
<p>You can look at what's actually in a pickle like this:</p>
<pre><code>pickletools.dis(pickle.dumps(f))
</code></pre>
<p>I get:</p>
<pre><code> 0: c    GLOBAL     '__main__ f'
12: p    PUT        0
15: .    STOP
</code></pre>
<p>You'll note that there is nothing in there correspond to the code of the function. Instead, it has references to <code>__main__ f</code> which is the module and name of the function. So when this is unpickled, it will always attempt to lookup the <code>f</code> function in the <code>__main__</code> module and use that. When you use the multiprocessing module, that ends up being a copy of the same function as it was in your original program. </p>
<p>This does mean that if you somehow modify which function is located at <code>__main__.f</code> you'll end up unpickling a different function then you pickled in. </p>
<p>Multiprocessing brings up a complete copy of your program complete with all the functions you defined it. So you can just call functions. The entire function isn't copied over, just the name of the function. The pickle module's assumption is that function will be same in both copies of your program, so it can just lookup the function by name.</p>
</div>
<div class="post-text" itemprop="text">
<p>Only the function arguments <code>(I,)</code> and the return value of the function <code>f</code> are pickled. The actual definition of the function <code>f</code> has to be available when loading the module.</p>
<p>The easiest way to see this is through the code:</p>
<pre><code>from multiprocessing import Process

if __name__ == '__main__':
    def f(I):
        print('hello world!',I)

    for I in [1,2,3]:
        Process(target=f,args=(I,)).start()
</code></pre>
<p>That returns:</p>
<pre><code>AttributeError: 'module' object has no attribute 'f'
</code></pre>
</div>
<span class="comment-copy">Great answer, but one note: In many cases where you think you need <code>spawn</code> (generally because you're using a library that expects to be able to talk to a specific event loop in the main thread), <code>forkserver</code> is actually better.</span>
<span class="comment-copy">@abarnert Yeah, I had skipped <code>forkserver</code> altogether since it's 3.4+ only. I've edited it in, since its relevant (and useful, as you pointed out) for any folks on Unix using 3.4+.</span>
<span class="comment-copy">Doesn't <code>spawn</code> also require 3.4? IIRC, 3.3 had an undocumented OS X-specific hack for doing something similar, but that's not likely to help anyone except people with the specific bug that was a workaround for.</span>
<span class="comment-copy">One more thing to note that probably won't affect the OP or any future askers, but just in case: <code>multiprocessing</code> extends <code>pickle</code> in a few ways (see <a href="https://hg.python.org/cpython/file/default/Lib/multiprocessing/reduction.py" rel="nofollow noreferrer"><code>multiprocessing/reduction.py</code></a> for details) to add support for things like (IIRC) raw files, bound and unbound methods, <code>functools.partial</code>s, and <code>operator.itemgetter</code>s and <code>attrgetter</code>s, so the documentation on what can be pickled (and the output of <code>pickletools</code>) can be misleading.</span>
<span class="comment-copy">The return value of <code>f</code> is not sent back the parent process, so its never pickled. Also, <code>f</code> <i>is</i> pickled and sent to the child. Unpickling <code>f</code> requires being able to import it from the top-level of the module, though, which is why you see that error. All of this also only applies if using Windows (unless you're using Python 3.x and the <code>'spawn'</code> context on Posix).</span>
<span class="comment-copy">Aha -- I was thinking of the multipricessing <code>map</code> function. That surely has to pickle the return value?</span>
<span class="comment-copy">Yep, on all platforms, all calls to <code>multiprocessing.Pool</code> instance methods (like <code>map</code>, and <code>apply</code>) will pickle the arguments and return values; <code>fork</code> can't help you once the child process has already been started.</span>
