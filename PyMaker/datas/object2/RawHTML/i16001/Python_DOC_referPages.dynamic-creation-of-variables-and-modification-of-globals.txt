<div class="post-text" itemprop="text">
<p>If I do this:</p>
<pre><code>newvar = raw_input()
globals()[newvar] = 4
</code></pre>
<p>It is clear that the resulting variable is created at runtime, simply because it's the only possibility. However, if I do this:</p>
<pre><code>globals()['y']=3
</code></pre>
<p>It seems that <code>y</code> is also created at runtime. Why is it the case? Where does the dynamic behavior come from?</p>
<p>PS: I am aware that this is a bad practice, I just want to understand.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your module's (or <code>exec</code> context's, etc.) globals are a <code>dict</code>, and <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow"><code>globals()</code></a> just returns that <code>dict</code>. After that, the <code>['y'] = 3</code> part is just like any other dictionary assignment.</p>
<p>If you're asking why Python doesn't optimize this into a static assignmentâ€¦ well, think about what it would have to do.</p>
<p>First, detecting that <code>'y'</code> is a literal is pretty easy; that information is right there in the AST.</p>
<p>But detecting that the <code>dict</code> is your module's global dictionary is a lot harder. <code>globals</code> isn't a keyword or anything else magical, it's just a regular function in <code>builtins</code>. You could hide it with a global, nonlocal, or local name, or monkeypatch <code>builtins</code>, or even replace the builtins for your globals so it's not accessible. So, it would have to do sufficient analysis to determine that there's no way the name lookup on <code>globals</code> could possibly return anything but the appropriate global dict.</p>
<p>And, not only that, in order to make this useful, the language would have to require <em>every</em> implementation to make the same optimization. Otherwise, you could get different semantics from some programs based on whether the optimization took place.</p>
<p>It's also worth keeping in mind that CPython doesn't do anything beyond basic peephole optimization, so you'd have to build the infrastructure for a more complicated optimizer from scratch just to add this one minor change.</p>
<p>On top of that, references to the same global dictionary are stored all over the place. So, even with this optimization, you could still trick Python just as easily:</p>
<pre><code>g = globals()
g['y'] = 3

globals().__getitem__('globals')()['y'] = 3

def f(): pass
f.__globals__['y'] = 3

inspect.currentframe().f_globals['y'] = 3
</code></pre>
</div>
<span class="comment-copy">Because <code>globals</code> is a simple variable name here, what if you name any of your variable to <code>globals</code>. That's the reason <code>exec</code> works differently in Python 2(keyword) and 3(function).</span>
