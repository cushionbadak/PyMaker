<div class="post-text" itemprop="text">
<p>Suppose I have a list:-</p>
<pre><code>person_name = ['zakesh', 'oldman LLC', 'bikash', 'goldman LLC', 'zikash','rakesh']
</code></pre>
<p>I am trying to group the list in such a way so the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noreferrer">Levenshtein distance</a> between two strings is maximum. For finding out the ratio between two words, I am using a python package <a href="https://github.com/seatgeek/fuzzywuzzy" rel="noreferrer">fuzzywuzzy</a>.</p>
<p><strong>Examples :-</strong> </p>
<pre><code>&gt;&gt;&gt; from fuzzywuzzy import fuzz
&gt;&gt;&gt; combined_list = ['rakesh', 'zakesh', 'bikash', 'zikash', 'goldman LLC', 'oldman LLC']
&gt;&gt;&gt; fuzz.ratio('goldman LLC', 'oldman LLC')
95
&gt;&gt;&gt; fuzz.ratio('rakesh', 'zakesh')
83
&gt;&gt;&gt; fuzz.ratio('bikash', 'zikash')
83
&gt;&gt;&gt; 
</code></pre>
<p><strong>My end goal:</strong></p>
<blockquote>
<p>My end goal is to group the words such that Levenshtein distance between them is more than 80 percent?</p>
</blockquote>
<p>My list should look something like this :- </p>
<pre><code>person_name = ['bikash', 'zikash', 'rakesh', 'zakesh', 'goldman LLC', 'oldman LLC'] because the distance between `bikash` and `zikash` is very high so they should be together.
</code></pre>
<p>Code: </p>
<p>I am trying to achieve this by sorting but key function should be <code>fuzz.ratio</code>. Well below code is not working, but I am approaching the problem in this angle.</p>
<pre><code>from fuzzywuzzy import fuzz
combined_list = ['rakesh', 'zakesh', 'bikash', 'zikash', 'goldman LLC', 'oldman LLC']
combined_list.sort(key=lambda x, y: fuzz.ratio(x, y))
print combined_list
</code></pre>
<blockquote>
<p>Could anyone help me to combine the words so that Levenshtein distance between them is more than 80 percent?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This groups the names</p>
<pre><code>from fuzzywuzzy import fuzz

combined_list = ['rakesh', 'zakesh', 'bikash', 'zikash', 'goldman LLC', 'oldman LLC']
combined_list.append('bakesh')
print('input names:', combined_list)

grs = list() # groups of names with distance &gt; 80
for name in combined_list:
    for g in grs:
        if all(fuzz.ratio(name, w) &gt; 80 for w in g):
            g.append(name)
            break
    else:
        grs.append([name, ])

print('output groups:', grs)
outlist = [el for g in grs for el in g]
print('output list:', outlist)
</code></pre>
<p>producing</p>
<pre><code>input names: ['rakesh', 'zakesh', 'bikash', 'zikash', 'goldman LLC', 'oldman LLC', 'bakesh']
output groups: [['rakesh', 'zakesh', 'bakesh'], ['bikash', 'zikash'], ['goldman LLC', 'oldman LLC']]
output list: ['rakesh', 'zakesh', 'bakesh', 'bikash', 'zikash', 'goldman LLC', 'oldman LLC']
</code></pre>
<p>As you can see, the names are grouped correctly, but the order may not be the one you desire.</p>
</div>
<span class="comment-copy">"combine", "similar", "very high" and "something like this" are all not well defined. You have to clarify your specifications.</span>
<span class="comment-copy">I'm confused. I see an optimization problem, i.e. "split this set of words into clusters with maximum internal distance", yet you continue to talk about "sorting", which is "putting the list into order". I'm not sure how those two mix. Do you only want the distance between two <i>successive</i> strings to be maximum?</span>
<span class="comment-copy">In python 2 you can pass a comparison function <code>cmp</code> to <code>sort</code> (and related functions). That has been removed from Python 3, but there <i>is</i> a workaround: see <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer">cmp_to_key</a>.</span>
<span class="comment-copy">As for the clustering problem (if it is one): Sounds like <a href="https://en.wikipedia.org/wiki/Clique_problem#Finding_maximum_cliques_in_arbitrary_graphs" rel="nofollow noreferrer">maximum clique</a>. The nodes are the words and you have an edge between words, if the edit distance is &gt;= 80% between those words. The rest is NP-complete, take an approximation algorithm of your choosing, <a href="https://networkx.github.io/documentation/latest/reference/algorithms.clique.html" rel="nofollow noreferrer">networkx</a> implements some.</span>
<span class="comment-copy">@python For <i>group by</i>, you need a function that determines the group association of a word based on the word itself. Problem here is: If you can add a word to a group depends on <i>all</i> the elements that are already in the group. It's a combinatorial optimization problem and as far as I can tell, maximum clique fits the bill.</span>
<span class="comment-copy">Isn't this only one (greedy) approach and the resulting groups may not be optimal?</span>
<span class="comment-copy">@dhke yes of course. I never said it's optimal nor the only one. Please do provide a better/alternative solution.</span>
<span class="comment-copy">I just wanted to mention it, but I'll try to give an optimal (maximum groups) when I get around. Nonetheless, your solution is of course correct and returns valid clusters.</span>
<span class="comment-copy">@dhke OK, no prob. I am truly interested in this kind of problems and my answer is the first one I could think of, as I cannot dedicate much time to it either right now. I had upvoted your comments in fact. :)</span>
