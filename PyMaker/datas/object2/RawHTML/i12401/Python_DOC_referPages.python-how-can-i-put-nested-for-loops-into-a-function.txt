<div class="post-text" itemprop="text">
<p>I am writing a python script, in which I have multiple for loops that are all identical EXCEPT for the number of for loops nested within them.</p>
<p>Let me show you what I mean:</p>
<pre><code>#4 &amp; 1
for a1 in someList:
    for a2 in someList:
        for a3 in someList:
            for a4 in someList:
                for b1 in anotherList:
                    resultList.append((a1 + a2 + a3 + a4) - b1);

#3 &amp; 1
for a1 in someList:
    for a2 in someList:
        for a3 in someList:
            for b1 in anotherList:
                resultList.append((a1 + a2 + a3) - b1);

#2 &amp; 1
for a1 in someList:
    for a2 in someList:
        for b1 in anotherList:
            resultList.append((a1 + a2) - b1);

#2 &amp; 2
for a1 in someList:
    for a2 in someList:
        for b1 in anotherList:
            for b2 in anotherList:
                resultList.append((a1 + a2) - (b1 + b2));
</code></pre>
<p>Please remember that this is just an example to demonstrate the problem. The actual data I'm working with is not numeric, and I'm performing a lot more operations for each iteration.</p>
<p>Alright, now here's the question:</p>
<p>How can I put all of this code into a nice function so that I could just do something like this:</p>
<pre><code>myFunc(4, 1);
myFunc(3, 1);
myFunc(2, 1);
myFunc(2, 2);
</code></pre>
<p>This would be a HUGE help to me if you guys can answer this. I'm not creative enough to solve this puzzle on my own. :(</p>
<p>Also, sorry for posting this question if the answer already exists out there -- I don't know what this thing is called, so I didn't know what to search for.</p>
<p>Thanks in advance!
~PM</p>
<p>Update:
Thanks everybody for your help. I think this will work. You all were extremely helpful!</p>
</div>
<div class="post-text" itemprop="text">
<p>No problem. As a word of advice, so many nested for-loops is bad style and can make your code a pain to understand, even to you! You should probably avoid going more than two loops deep. If something else needs a loop, you can write a function for that.</p>
<p>There's actually a function in <code>itertools</code> (<a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow">https://docs.python.org/3/library/itertools.html#itertools.product</a>) that can do what you're looking for, called <code>product()</code>. <code>product</code> will give you the Cartesian product of an iterable like a like, so for example, if <code>someList = [1, 2, 3 ... n]</code> then <code>product(someList, 2)</code> will give you <code>[(1, 1), (1, 2), (1, 3) ... (1, n), (2, 1) ... (n, 1) ... (n, n)]</code>. You can vary how many times the list repeats itself. Do that for both <code>someList</code> and <code>someOtherList</code> like so</p>
<pre><code>def func(num_a, num_b):
    a_sums = sum(a_inner for a_inner in product(someList, repeat=num_a))
    b_sums = sum(b_inner for b_inner in product(someOtherList, repeat=num_b))
    return (a - b for a, b in product(a_sums, b_sums))
</code></pre>
<p>This function will generate an iterable of the sums of the Cartesian product of your first list, and then do the same for your other list. Keep in mind, you probably want to be able to pass in your lists as arguments and not treat them as some nonlocal variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>My approach would be to first negate your <code>b</code> lists. That way, you could use something like:</p>
<pre><code>from itertools import product
def sum_of_cartesian_tuples(*lists):
    tuples = product(*lists)
    return map(sum, tuples)

if __name__ == '__main__':
    a1 = [1,2,3]
    a2 = [3,4,5]
    b1 = [6,7,8]

    b1_neg = [-1*b for b in b1]

    print sum_of_cartesian_tuples(a1, a2, b1_neg)
    # [-2, -3, -4, -1, -2, ..., 0, -1, 2, 1, 0]
</code></pre>
<p>Note that this code is in Python 2.7 and has not been tested in Python 3.X. But, in essence, your loops iterate over the tuples in the Cartesian product generated by your lists, so using <code>itertools.product</code> saves you all the looping.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can generate Cartesian Products using itertools:</p>
<pre><code>import itertools
&gt; a = [1,2]
&gt; b = [3,4]
&gt; c = [4,5]
&gt; itertools.product(a, b, c)
[(1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (2, 2, 4), (2, 2, 5), (2, 3, 4), (2, 3, 5)]
</code></pre>
<p>You can generate your list of lists using a loop or a list comprehension:</p>
<pre><code>&gt; list1 = [1,2,3]
&gt; list2 = [3,4,5]
&gt; a, b = 4, 1
&gt; [list1 for i in range(a)] + [list2 for i in range(b)]
[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [2, 3, 4]]
</code></pre>
<p>And then use the cartesian product:</p>
<pre><code>&gt; lists = [list1 for i in range(a)] + [list2 for i in range(b)]
&gt; itertools.product(*lists)
</code></pre>
<p>You can add a function to take care of each sublist:</p>
<pre><code>def doWorkOnProduct(list1, list2, a, b, func):
    lists = [list1 for i in range(a)] + [list2 for i in range(b)]
    products = itertools.product(*lists)
    return map(func, products)
</code></pre>
<p>Example call:</p>
<pre><code>def func(nums):
    return sum(nums[:-1]) + nums[-1]

&gt; sums = list(doWorkOnProduct([1,2,3], [4,5,6], 4, 1, func))
&gt; print sum(sums)
&gt; 3159
</code></pre>
</div>
<span class="comment-copy">Why do you have these quintuply-nested <code>for</code> loops? It sounds like you're brute-forcing something you really shouldn't, either because there are much quicker ways to do it or because it's a really hard problem that you should bring in an established library for.</span>
<span class="comment-copy"><code>zip</code> is the wrong tool; you want <code>product</code> again.</span>
<span class="comment-copy">Oops, thanks. Didn't catch that until now.</span>
<span class="comment-copy">You can't pass the <code>repeat</code> argument to <code>itertools.product</code> by position. Pass it by keyword argument.</span>
<span class="comment-copy">Thanks for pointing that. I should have a bit more prudent writing up the code. Edited to fix it.</span>
<span class="comment-copy">Hey, I have another question for you. How can I only include a cartesian pair in the result list if both values in the pair are different? For example, I'd never have <code>[a, a]</code>, but <code>[a, b]</code> would work. Thanks!</span>
<span class="comment-copy">Pairs? Other than that, this answer is good, but why do you keep calling the tuples pairs? Even in your example, they have 3 elements each.</span>
<span class="comment-copy">Will this method work if I'm iterating over non-numeric values as well?</span>
<span class="comment-copy">@PMethodVanAlternate: <code>itertools.product</code> will work fine. <code>sum</code> probably won't, of course, but you'll probably be doing something else with your non-numeric values.</span>
<span class="comment-copy">I fixed the pairs wording. It depends on what kind of non-numeric values. The essence of what you want is in the use of products though.</span>
