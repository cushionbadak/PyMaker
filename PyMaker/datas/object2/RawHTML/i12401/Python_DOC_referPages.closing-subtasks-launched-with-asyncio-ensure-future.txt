<div class="post-text" itemprop="text">
<p>If I have the following:</p>
<pre><code>async def foo():
    for i in range(10):
        print "1"
        await asyncio.sleep(1)

async def bar()
    t = asyncio.ensure_future(foo())
    while not t.done():
        print("waiting")
        await asyncio.sleep(0.5)

async def baz():
    t = asyncio.ensure_future(bar())
    await asyncio.sleep(2.5)
    t.cancel()
</code></pre>
<p>And <code>baz()</code> is called in a larger event loop, how can I make sure that foo() is cancelled?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <code>try/finally</code> block would catch the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.CancelledError" rel="nofollow">CancelledError</a> exception:</p>
<pre><code>task = asyncio.ensure_future(foo())
try:
    [...]
finally:
    task.cancel()  # return False if task is already finished
</code></pre>
<p>Some <a href="https://docs.python.org/3/library/asyncio-task.html#task-functions" rel="nofollow">task functions</a> already handle the cancellation of subtasks:</p>
<pre><code>result = await asyncio.wait_for(foo(), 60.)  
result, = await asyncio.gather(foo())
</code></pre>
<p>In both examples, <code>foo()</code> is wrapped in a task and would be canceled automatically if the parent task were to be canceled.</p>
<hr/>
<p><strong>EDIT</strong></p>
<p>Here's a simple example of a coroutine controlling the execution of another one:</p>
<pre><code>async def control(coro, timeout=1.):
    task = asyncio.ensure_future(coro)
    while not task.done():
        try:
            print("The task is not finished yet")
            await asyncio.wait([task, asyncio.sleep(timeout)], "FIRST_COMPLETED")
        except asyncio.CancelledError:
            task.cancel()
    return task.result()  # Raise task.exception() if any
</code></pre>
<p>Now, <code>await control(foo(), 1.)</code> should work exactly like <code>await foo()</code> (regarding cancellation, exception and result) except it prints <code>The task is not finished yet</code> every second until <code>foo()</code> is done.</p>
</div>
<span class="comment-copy">I guess I missed a requirement here - I'd like to also trigger any exceptions thrown by the subtask to be thrown in the current task</span>
<span class="comment-copy">@Eric Then why not simply use <code>await task</code> or <code>await foo()</code>?</span>
<span class="comment-copy">Because I want to watch other things and cancel the task early</span>
<span class="comment-copy">@Eric Once the task is done, using <code>await task</code> or <code>task.result()</code> would instantly raise the <code>task.exception()</code> if any. Would that work?</span>
<span class="comment-copy">But that would always raise at least a <code>CancelledError</code>, right? Can I safely swallow that, or will that make the swallowing task sometimes uncancellable?</span>
