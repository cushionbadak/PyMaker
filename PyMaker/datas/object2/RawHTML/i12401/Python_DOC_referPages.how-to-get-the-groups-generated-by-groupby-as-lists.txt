<div class="post-text" itemprop="text">
<p>I am testing <code>itertools.groupby()</code> and try to get the groups as lists but can't figure out how to make it work.</p>
<p>using the examples here, in <a href="https://stackoverflow.com/questions/773/how-do-i-use-pythons-itertools-groupby">How do I use Python's itertools.groupby()?</a></p>
<pre><code>from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"),
         ("vehicle", "speed boat"), ("vehicle", "school bus")]
</code></pre>
<p>I tried (python 3.5):</p>
<pre><code>g = groupby(things, lambda x: x[0])
ll = list(g)
list(tuple(ll[0])[1])
</code></pre>
<p>I thought I should get the first group ("animal") as a list <code>['bear', 'duck']</code>. But I just get an empty list on REPL.</p>
<p>What am I doing wrong?</p>
<p>How should I extract all three groups as lists?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you just want the groups, without the keys, you need to realize the group generators as you go, <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">per the docs</a>:</p>
<blockquote>
<p>Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list.</p>
</blockquote>
<p>This means that when you try to <code>list</code>-ify the <code>groupby</code> generator first using <code>ll = list(g)</code>, before converting the individual group generators, all but the last group generator will be invalid/empty.</p>
<p>(Note that <code>list</code> is just one option; a <code>tuple</code> or any other container works too).</p>
<p>So to do it properly, you'd make sure to <code>list</code>ify each group generator before moving on to the next:</p>
<pre><code>from operator import itemgetter  # Nicer than ad-hoc lambdas

# Make the key, group generator
gen = groupby(things, key=itemgetter(0))

# Strip the keys; you only care about the group generators
# In Python 2, you'd use future_builtins.map, because a non-generator map would break
groups = map(itemgetter(1), gen)

# Convert them to list one by one before the next group is pulled
groups = map(list, groups)

# And listify the result (to actually run out the generator and get all your
# results, assuming you need them as a list
groups = list(groups)
</code></pre>
<p>As a one-liner:</p>
<pre><code>groups = list(map(list, map(itemgetter(1), groupby(things, key=itemgetter(0)))))
</code></pre>
<p>or because this many <code>map</code>s gets rather ugly/non-Pythonic, and list comprehensions let us do nifty stuff like unpacking to get named values, we can simplify to:</p>
<pre><code>groups = [list(g) for k, g in groupby(things, key=itemgetter(0))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a list comprehension as follows:</p>
<pre><code>from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"),
         ("vehicle", "speed boat"), ("vehicle", "school bus")]


g = groupby(things, lambda x: x[0])
answer = [list(group[1]) for group in g]
print(answer)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[[('animal', 'bear'), ('animal', 'duck')],
 [('plant', 'cactus')],
 [('vehicle', 'speed boat'), ('vehicle', 'school bus')]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quoting from Python Doc on <a href="https://docs.python.org/3/library/itertools.html?highlight=groupby#itertools.groupby" rel="nofollow"><code>groupby</code></a> :</p>
<blockquote>
<p><code>itertools.groupby(iterable, key=None)</code> <br/>
  Make an iterator that returns
  <strong>consecutive keys and groups from the iterable</strong>. The key is a function
  computing a key value for each element. If not specified or is None,
  key defaults to an identity function and returns the element
  unchanged. Generally, the iterable needs to already be sorted on the
  same key function.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; 
&gt;&gt;&gt; things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"),
         ("vehicle", "speed boat"), ("vehicle", "school bus")]
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; for _, g in groupby(things, lambda x:x[0]):
    print(list(g))

[('animal', 'bear'), ('animal', 'duck')]
[('plant', 'cactus')]
[('vehicle', 'speed boat'), ('vehicle', 'school bus')]
&gt;&gt;&gt;
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; l = [list(g) for _, g in groupby(things, itemgetter(0))]
&gt;&gt;&gt; l
[[('animal', 'bear'), ('animal', 'duck')], [('plant', 'cactus')], [('vehicle', 'speed boat'), ('vehicle', 'school bus')]]
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; 
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt;
&gt;&gt;&gt; for k,v in groupby(things, itemgetter(0)):
    for sub in v:
        for item in sub:
            if item != k:
                d[k].append(item)


&gt;&gt;&gt; d
defaultdict(&lt;class 'list'&gt;, {'animal': ['bear', 'duck'], 'plant': ['cactus'], 'vehicle': ['speed boat', 'school bus']})
</code></pre>
</div>
<span class="comment-copy">What is your expected output?</span>
<span class="comment-copy">could you explain what I did wrong? thx</span>
<span class="comment-copy">The quote from @ShadowRanger's answer describes the problem: "Because the source is shared, when the groupby() object is advanced, the previous group is no longer visible." By creating a list from the returned iterable, <code>ll = list(g)</code>, you advanced the iterator <code>g</code> all the way to its end, making all of the groups no longer available, causing them to seem empty.</span>
