<div class="post-text" itemprop="text">
<p>Say I'd like to have a class which holds multiple unmanaged resources, such as files. I'd also like the public interface of that class to allow the user to use it in an exception-safe manner, i.e. not to leak unmanaged resources/leave them at the mercy of the garbage-collector, which isn't ever guaranteed to run at any point (deterministic resource reclamation).</p>
<p>Take, for instance, the following case:</p>
<pre><code>class Gizmo(object):
    def __init__(self, filepath1, filepath2):
        self._file1 = open(filepath1, 'rb')
        self._file2 = open(filepath2, 'rb')

    def __enter__(self):
        return self

    def __exit__(self):
        self.close()
        return False

    def __del__(self):
        self.close()

    def frob(self):
        ...manipulate the files...

    def close(self):
        self._file1.close()
        self._file2.close()
</code></pre>
<p>This is not exception-safe, because if the line opening the second file in <code>__init__</code> fails, the first file is leaked in the sense that it is left at the mercy of the garbage collector (no matter whether I use the class via a <code>with</code>-statement or not).</p>
<p>My question is this: what's the cleanest way to achieve what I'd like, preferably in a manner which I'd be able to scale up to more than two unmanaged resources, and which doesn't clutter the public interface of my class too horribly (if at all)? The idea of having an initialization method separate to the <code>__init__</code> method came to mind, but it sounds a bit odd.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're on Python 3, this looks like a job for <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>contextlib.ExitStack</code></a>. If you're on Python 2, there appears to be a <a href="https://contextlib2.readthedocs.org/en/latest/" rel="nofollow noreferrer">backport</a> of this feature available.</p>
<pre><code>from contextlib import ExitStack

class Gizmo(object):
    def __init__(self, filepath1, filepath2):
        with ExitStack() as stack:
            # If opening the second file fails,
            # unwinding the stack will close the first file.

            self._file1 = stack.enter_context(open(filepath1, 'rb'))
            self._file2 = stack.enter_context(open(filepath2, 'rb'))

            # It worked! But we don't want to close the files when the with statement ends.
            # Take the files off the stack without closing them
            # (and put them on a new stack).
            self._exitstack = stack.pop_all()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        return self._exitstack.__exit__(exc_type, exc_value, exc_tb)

    def __del__(self):
        self.close()

    def frob(self):
        ...manipulate the files...

    def close(self):
        # __del__ will try to close a Gizmo even if we couldn't set up its _exitstack,
        # so don't try to close a nonexistent _exitstack.
        if hasattr(self, '_exitstack'):
            # The stack calls __exit__ on all the files, exactly as if we were
            # exiting a "with open(...) as file1, open(...) as file2" block.
            # If closing one file fails, we'll still try to close the other.
            self._exitstack.close()
</code></pre>
</div>
<span class="comment-copy">That's pretty cool. I'd add that because the <code>__del__</code> method calls <code>close</code> and it may be called on an object that doesn't have the <code>_exitstack</code> attribute set yet, you might want to set it to None and check it before accessing it.</span>
