<div class="post-text" itemprop="text">
<p>My Input is:</p>
<pre><code>input = ['(var1, )', '(var2,var3)']
</code></pre>
<p>Expected Output is:</p>
<pre><code>output = [('var1', ), ('var2','var3')]
</code></pre>
<p>Iterating over input and using <code>eval</code>/<code>literal_eval</code> on the tuple-strings is not possible:</p>
<pre><code>&gt;&gt;&gt; eval('(var1, )')
&gt;&gt;&gt; NameError: name 'var1' is not defined
</code></pre>
<p>How can I convert an item such as <code>'(var1, )'</code> to a tuple where the inner objects are treated as strings instead of variables?</p>
<p>Is there a simpler way than writing a parser or using regex?</p>
</div>
<div class="post-text" itemprop="text">
<p>For each occurrence of a variable, <a href="//docs.python.org/3/library/functions.html#eval" rel="nofollow"><code>eval</code></a> searches the symbol table for the name of the variable. It's possible to provide a custom mapping that  will return the key name for every missing key:</p>
<pre><code>class FakeNamespace(dict):
    def __missing__(self, key):
        return key
</code></pre>
<p>Example:</p>
<pre><code>In [38]: eval('(var1,)', FakeNamespace())
Out[38]: ('var1',)

In [39]: eval('(var2, var3)', FakeNamespace())
Out[39]: ('var2', 'var3')
</code></pre>
<p><strong><em>Note:</em></strong> <code>eval</code> copies current globals to the submitted <code>globals</code> dictionary, if it doesn't have <code>__builtins__</code>. That means that the expression will have access to built-in functions, exceptions and constants, as well as variables in your namespace. You can try to solve this by passing <code>FakeNamespace(__builtins__=&lt;None or some other value&gt;)</code> instead of just <code>FakeNamespace()</code>,  but it won't make <code>eval</code> 100% safe (<a href="//stackoverflow.com/q/35804961/2301450" rel="nofollow"><em>Python eval: is it still dangerous if I disable builtins and attribute access?</em></a>)</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>tuples = [tuple(filter(None, t.strip('()').strip().split(','))) for t in input]
</code></pre>
<p>For example:</p>
<pre><code>In [16]: tuples = [tuple(filter(None, t.strip('()').strip().split(','))) for t in input]

In [17]: tuples
Out[17]: [('var1',), ('var2', 'var3')]
</code></pre>
<p>We're iterating through our list of tuple strings, and for each one, removing the <code>()</code>s, then splitting our string into a list by the <code>,</code>, and then converting our list back into a tuple. We use <a href="https://docs.python.org/2/library/functions.html#filter" rel="nofollow"><code>filter()</code></a> to remove empty elements.</p>
</div>
<div class="post-text" itemprop="text">
<p>I like vaultah's solution. Here's another one with <code>ast.literal_eval</code> and <code>re</code> if <code>eval</code> is not an option:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; from ast import literal_eval
&gt;&gt;&gt; [literal_eval(re.sub('(?&lt;=\(|,)(\w+)(?=\)|,)', r'"\1"', x)) for x in input]
[('var1',), ('var2', 'var3')]
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1810109/parsing-a-string-which-represents-a-list-of-tuples" title="parsing a string which represents a list of tuples">stackoverflow.com/questions/1810109/â€¦</a></span>
<span class="comment-copy">@MarounMaroun That doesn't work as I explained. In the question you provided, floats can be evaluated. Strings like 'var1" can't. <code>literal_eval</code> will throw a <code>ValueError: malformed string</code></span>
<span class="comment-copy">Cool approach! Although we should be careful sanitizing input if using <code>eval()</code>.</span>
<span class="comment-copy">Pass fake_globals as both globals and locals to the eval to mitigate attacks - <code>__builtins__</code> can't be accessed (nor any other Python name) if both dictionaries are changed: <code>In [15]: eval("__builtins__['zip']", FakeGlobals() ) Out[15]: zip</code> ,  <code>eval("__builtins__['zip']", FakeGlobals(), FakeGlobals() ) TypeError   string indices must be integers</code></span>
<span class="comment-copy">(for the above comment: the approach is not absolute, but it might mitigate naive attacks)</span>
