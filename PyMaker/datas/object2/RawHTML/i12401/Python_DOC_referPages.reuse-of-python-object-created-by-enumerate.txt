<div class="post-text" itemprop="text">
<p>I have a list of lists that I am searching through to find the indices of duplicates. </p>
<pre><code>listA = [[1,2,3],[3,4,5],[6,7,8],[1,2,3]]
listA_set = [[1,2,3],[3,4,5],[6,7,8]]
enum_listA = enumerate(listA)
listA_indices = []
for i in listA_set:
    listA_indices([j[0] for j in enum_listA if j[1] == i])
</code></pre>
<p>The intended outcome is:</p>
<pre><code>listA_indices = [[0,3],[1],[2]]
</code></pre>
<p>But instead I am getting:</p>
<pre><code>listA_indices = [[0,3],[],[]]
</code></pre>
<p>If I include the enumerate within the in-line for loop (see example below), I receive the correct answer but see a significant reduction in speed. How can I perform this task without losing the enumerate information stored in enum_listA?</p>
<pre><code>for i in listA_set:
    listA_indices([j[0] for j in enumerate(listA) if j[1] == i])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> returns an iterator which can only be iterated once. So once it is exhausted, which is the case after you iterate it in the list comprehension of the first for loop iteration, it will not yield any more items.</p>
<p>If you want to keep the information, you will have to actually store that data in memory, for example as a list:</p>
<pre><code>enum_listA = list(enumerate(listA))
</code></pre>
<p>Note that this effectively duplicates the information in the list and adds the indexes, so this is wasting a lot of extra memory and might not end up being more efficient than recreating the enumerate object over and over.</p>
<p>The performance difference you are seeing however comes from the fact that after the first loop iteration, the enumerator is empty, so the list comprehension no longer runs for subsequent iterations.</p>
</div>
<div class="post-text" itemprop="text">
<p>use a <code>dict</code> and a <code>set</code> and your code will run a lot more efficiently:</p>
<pre><code>from collections import defaultdict

st = set(map(tuple, listA_set))
d = defaultdict(list)

for i, ele in enumerate(map(tuple,listA)):
    if ele in st:
        d[ele].append(i)

print(list(d.items()))

print(list(d.values()))
</code></pre>
<p>Output:</p>
<pre><code>[((3, 4, 5), [1]), ((6, 7, 8), [2]), ((1, 2, 3), [0, 3])]
[[1], [2], [0, 3]]
</code></pre>
<p>If you want to maintain the order first seen:</p>
<pre><code>from collections import  OrderedDict
d = OrderedDict()

for i, ele in enumerate(map(tuple, listA)):
    if ele in st:
        d.setdefault(ele, []).append(i)

print(list(d.items()))

print(list(d.values()))
</code></pre>
<p>output:</p>
<pre><code>[((1, 2, 3), [0, 3]), ((3, 4, 5), [1]), ((6, 7, 8), [2])]
[[0, 3], [1], [2]]
</code></pre>
<p>Whatever way you use enumerate, your complexity is still quadratic, this will be considerably faster than your own approach.</p>
<p>Some timings on a random data set:</p>
<pre><code>In [27]: from random import randint

In [28]: listA_set = [[randint(1,20) for _ in range(10)] for _ in range(2000)]

In [29]: listA = [[randint(1,20) for _ in range(10)] for _ in range(3000)]

In [30]: %%timeit
listA_indices = []
for i in listA_set:
    listA_indices.append([j[0] for j in enumerate(listA) if j[1] == i])
   ....: 
1 loops, best of 3: 696 ms per loop

In [31]: %%timeit
st = set(map(tuple, listA_set))
from collections import  OrderedDict
d = OrderedDict()
for i, ele in enumerate(map(tuple,listA)):
    if ele in st:
        d.setdefault(ele, []).append(i)
   ....: 
1000 loops, best of 3: 1.49 ms per loop
</code></pre>
<p><code>~400</code>  times faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason you are seeing a significant reduction in speed (by your terminology) is that your second, correct version is actually computing the values you are looking for.</p>
<p>Because enumerate produces a generator, once you consume its values, you cannot produce them again. The second version you have presented is the correct way of using enumerate.</p>
<p>Side not, I'm not sure how your code is working at all. You are calling a list, a non-callable object</p>
<pre><code>listA_indices([...])
</code></pre>
<p>Maybe, you meant to do</p>
<pre><code>listA_indices += [...] 
</code></pre>
</div>
<span class="comment-copy">"I receive the correct answer but see a significant reduction in speed" - never compare the performance of correct code and uselessly wrong code. You can do anything in constant time if you're okay with the results being uselessly wrong.</span>
<span class="comment-copy">Thanks for the suggestion. I implemented this approach and it looks to be working quite well (I'm still fairly new to structured lists, so it has not typically been my default approach).</span>
