<div class="post-text" itemprop="text">
<p>I have two or more huge lists(each containing 20 to 25 GB data).I want to perform minus and join operations.For example I want to find out the items present in list1 but not in list2 for following lists.</p>
<pre><code>    list1=[1,2,1,3,4,4,5,6,2,8]
    list2=[3,5,3,8,1,9,9] 
</code></pre>
<p>the result should be:</p>
<pre><code>    result_list1minuslist2 =[1,2,2,4,4,6]
    result_list2minuslist1 =[3,9,9]
</code></pre>
<p>join operations:</p>
<pre><code>    result_list1joinlist2 =[1,1,3,5,8]
    result_list2joinlist1 =[3,5,3,8,1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For list subtraction you could try using a dictionary containing lists to group the values from the source list, and to provide fast lookup operations. An assumption is that the items in your lists are hashable and can therefore be used as dictionary keys.</p>
<p>This could be reasonably memory efficient because object references should be used within the data structure, so duplication of the data in the original list <em>should</em> be minimised. However, if the original list contains many small objects, then you'll still end up with large memory consumption in the overhead of constructing the data structure. Depends on your data.</p>
<p>I suggest using a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a> of lists because it is easy to group the values from the original list, but you can also use a standard dictionary. </p>
<p>So, convert the list from which you want to subtract to a <code>defaultdict</code> of lists. Each item from the original list is a key in this dictionary, and the corresponding value is a list containing the same key, one entry per entry in the original list.</p>
<p>Then iterate over the second list, removing entries from the dictionary's values if they are present. This bit should be faster than operating directly on lists as an <code>in</code> operation on a dictionary is on average O(1), whereas an <code>in</code> operation on a list is O(N).</p>
<pre><code>from collections import defaultdict

def list_sub(list1, list2):
    '''Subtract list2 from list1'''    
    dd = defaultdict(list)
    for i in list1:
        dd[i].append(i)

    # now remove items in list2 from the defaultdict
    for i in list2:
        if dd[i]:
            dd[i].pop()

    return (x for v in dd.itervalues() for x in v)


list1=[1,2,1,3,4,4,5,6,2,8]
list2=[3,5,3,8,1,9,9]

&gt;&gt;&gt; list_sub(list1, list2)
[1, 2, 2, 4, 4, 6]
&gt;&gt;&gt; list_sub(list2, list1)
[3, 9, 9]
</code></pre>
<h1>Alternatives</h1>
<p>Using a <code>defaultdict</code> of int as a counter:</p>
<pre><code>from collections import defaultdict

def list_sub_ddi(list1, list2):
    dd = defaultdict(int)
    for i in list1:
        dd[i] += 1

    for i in list2:
        dd[i] -= 1

    return (x for l in ([k]*n for k,n in dd.iteritems() if n&gt;0) for x in l)
</code></pre>
<p>Using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>:</p>
<pre><code>from collections import Counter

def list_sub_counter(list1, list2):
    c = Counter(list1) - Counter(list2)
    return (x for l in ([k]*n for k,n in c.iteritems() if n&gt;0) for x in l)
</code></pre>
<h1>Execution times</h1>
<p>Using the <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow"><code>timeit</code></a> module:</p>
<pre><code># test.py
from random import randint
from collections import defaultdict
from collections import Counter

list1 = [randint(1, 10000) for i in range(1000000)]
list2 = [randint(1, 5000) for i in range(10000)]

def list_sub_ddl(list1, list2):
    dd = defaultdict(list)
    for i in list1:
        dd[i].append(i)

    for i in list2:
        if dd[i]:
            dd[i].pop()

    return (x for v in dd.itervalues() for x in v)

def list_sub_ddi(list1, list2):
    dd = defaultdict(int)
    for i in list1:
        dd[i] += 1

    for i in list2:
        dd[i] -= 1

    return (x for l in ([k]*n for k,n in dd.iteritems() if n&gt;0) for x in l)

def list_sub_counter(list1, list2):
    c = Counter(list1) - Counter(list2)
    return (x for l in ([k]*n for k,n in c.iteritems() if n&gt;0) for x in l)
</code></pre>
<p>Note that each function returns a generator, which minimises the amount of work done upfront, and allows the calling code to iterate over the values or convert to a list as required. Each function could return a fully realised list if preferred. The tests below consume all items from the generator in one go.</p>
<p><strong>Python 2</strong></p>
<pre><code>$ python -m timeit -s 'import test' 'list(test.list_sub_ddl(test.list1, test.list2))'
10 loops, best of 3: 362 msec per loop

$ python -m timeit -s 'import test' 'list(test.list_sub_ddi(test.list1, test.list2))'
10 loops, best of 3: 223 msec per loop

$ python -m timeit -s 'import test' 'list(test.list_sub_counter(test.list1, test.list2))'
10 loops, best of 3: 476 msec per loop
</code></pre>
<p><strong>Python 3</strong></p>
<p>The code is the same as for Python 2, however, <code>itervalues()</code> and <code>iteritems()</code> are changed to <code>values()</code> and <code>items()</code>.</p>
<pre><code>$ python3 -m timeit -s 'import test' 'list(test.list_sub_ddl(test.list1, test.list2))'
10 loops, best of 3: 386 msec per loop

$ python3 -m timeit -s 'import test' 'list(test.list_sub_ddi(test.list1, test.list2))'
10 loops, best of 3: 267 msec per loop

$ python3 -m timeit -s 'import test' 'list(test.list_sub_counter(test.list1, test.list2))'
10 loops, best of 3: 214 msec per loop
</code></pre>
<h1>Result</h1>
<p>If you are using Python 2, use a <code>defaultdict</code> of ints. For Python 3 use a <code>Counter</code>.</p>
<p>Your mileage will vary, depending on the actual data used. This test data is much smaller than 20GB, and long lists of small objects may behave differently from shorter lists with larger objects.</p>
<p>This test also ignores differences in memory usage for each the methods because I don't know of an easy way to measure it, and my test data might be unrepresentative. The defaultdict of lists will probably consume more though.</p>
</div>
<div class="post-text" itemprop="text">
<p>in python the multisets is offer in the form of a <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow">counter</a> as you have multiples instances of the same hashable and therefore inmutable object you should considere using this.</p>
<p>Here the minus and join list</p>
<pre><code>def list_sub(list1, list2):
    result = Counter(list1)
    result.subtract(list2)
    return result.elements()

def list_join(list1,list2):
    test = set(list2)
    return filter(lambda x: x in test,list1)  
    #return (x for x in list1 if x in test)
</code></pre>
<p>both return a iterator over the result, to the same effect in python 2 use <a href="https://docs.python.org/2/library/itertools.html#itertools.ifilter" rel="nofollow">itertools.ifilter</a> or a generator expresion</p>
<pre><code>&gt;&gt;&gt; list(list_sub(list1,list2))
[1, 2, 2, 4, 4, 6]
&gt;&gt;&gt; list(list_sub(list2,list1))
[3, 9, 9]
&gt;&gt;&gt; list(list_join(list1,list2))
[1, 1, 3, 5, 8]
&gt;&gt;&gt; list(list_join(list2,list1))
[3, 5, 3, 8, 1]
&gt;&gt;&gt; 
</code></pre>
<p>now compare this version vs @mhawke version (using the same script of mhawke)</p>
<p>in <strong>python3</strong> </p>
<pre><code>&gt;python3 -m timeit -s 'import test' 'list(test.list_sub_counter(test.list1, test.list2))'
10 loops, best of 3: 274 msec per loop

&gt;python3 -m timeit -s 'import test' 'list(test.list_sub(test.list1, test.list2))'
10 loops, best of 3: 199 msec per loop
</code></pre>
<p>in <strong>python2</strong></p>
<pre><code>&gt;python2 -m timeit -s 'import test' 'list(test.list_sub_counter(test.list1, test.list2))'
10 loops, best of 3: 627 msec per loop

&gt;python2 -m timeit -s 'import test' 'list(test.list_sub(test.list1, test.list2))'
10 loops, best of 3: 558 msec per loop    
</code></pre>
<p>in both cases this version is better, other than that I get the same result in <em>defaultdict</em> vs <em>Counter</em>, so use <code>defaultdict(int)</code> in python2 or <code>Counter</code> in python3</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is some fun pythonic version for the minus case:</p>
<pre><code>from heapq import heapify, heappop

def sort_gen(l, StopException=StopIteration):
    heapify(l)
    for i in xrange(len(l)):
        yield heappop(l)
    raise StopException

class YStopIteration(StopIteration):
    pass

def diff_gen(l1, l2):
    xgen = sort_gen(l1)
    ygen = sort_gen(l2, YStopIteration)

    try:
        x = next(xgen)
        y = next(ygen)
        while True:
            if x &lt; y:
                yield x
                x = next(xgen)
            elif x == y:
                x = next(xgen)
                y = next(ygen)
            else:
                y = next(ygen)
    except YStopIteration:
        # 2nd generator exhausted: yield all the rest
        yield x
        for x in xgen:
            yield x


list1=[1,2,1,3,4,4,5,6,2,8]
list2=[3,5,3,8,1,9,9] 

dg = diff_gen(list1, list2)

d = list(dg)  # [1, 2, 2, 4, 4, 6]
</code></pre>
</div>
<span class="comment-copy">I used set operation but it eliminates all the duplicate entries and gives the result of all unique entries</span>
<span class="comment-copy">Do you have many duplicates? In which case, <code>collections.Counter</code> might help you.</span>
<span class="comment-copy">Why in your resulted <code>list1 - list2</code> value <code>1</code>? Or they checked for the place where there are?</span>
<span class="comment-copy">@AntonProtopopov : because list1 has two 1s and list2 has one 1</span>
<span class="comment-copy">@DainDwarf : I used count operation but not counter and it takes too long time for huge data.set operation was faster but only giving unique results</span>
<span class="comment-copy">That's really inefficient and nothing I'd try with 20 to 25 GiB worth of list data.  The <code>reduce()</code> with <code>add()</code> on <code>list</code> instances produces temporary lists with each add operation and discards the previous list parts. And the involved lists are getting larger with each add operation.</span>
<span class="comment-copy">@BlackJack: you're right, that's not an appropriate use for <code>reduce()</code>. It can easily be changed to a list comprehension, which I have done. A generator expression is also an option. Is that the only problem you see?</span>
<span class="comment-copy">I don't see the point of using in a dict this way, is terrible with all the slices because you duplicate the list with each one, instead use <code>pop()</code> or use a <code>Counter</code></span>
<span class="comment-copy">@Copperfield: The idea is to provide O(1) lookup and membership  operations. If you try to use lists, you end up with a O(N^2) solution due to an outer loop combined with an inner <code>in</code> operation (effectively a nested loop).  I've edited to address your point regarding the slice. Now using <code>pop()</code> and its a bit faster, and more readable.  Thanks.</span>
<span class="comment-copy">@Copperfield: also, compared against a <code>Counter</code> based solution, I found that the <code>defaultdict</code> is faster. It's hard to tell though because the OP's data might be different to the large list of integers that I've used for testing.</span>
<span class="comment-copy">Wow, didn't know about <code>Counter.elements()</code>! It's way faster than my complicated generator expression!</span>
