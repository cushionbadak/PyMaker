<div class="post-text" itemprop="text">
<p>I know python does not allow us to overload functions. However, does it have inbuilt overloaded methods?</p>
<p>Consider this:</p>
<pre><code>setattr(object_name,'variable', 'value')

setattr(class_name,'method','function')
</code></pre>
<p>The first statement dynamically adds variables to objects during run time, but the second one attaches outside functions to classes at run time.</p>
<p>The same function does different things based on its arguments. Is this function overload? </p>
</div>
<div class="post-text" itemprop="text">
<p>The function <code>setattr(foo, 'bar', baz)</code> is always the same as <code>foo.bar = baz</code>, regardless of the type of foo.  There is no overloading here.</p>
<p>In Python 3, limited overloading is possible with <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow"><code>functools.singledispatch</code></a>, but <code>setattr</code> is not implemented with that.</p>
<p>A far more interesting example, in my opinion, is <code>type()</code>.  <code>type()</code> does two entirely different things depending on how you call it:</p>
<ol>
<li>If called with a single argument, it returns the type of that argument.</li>
<li>If called with three arguments (of the correct types), it dynamically creates a new class.</li>
</ol>
<p>Nevertheless, <code>type()</code> is not overloaded.  Why not?  Because it is implemented as one function that <a href="https://hg.python.org/cpython/file/tip/Objects/typeobject.c#l2270" rel="nofollow">counts how many arguments it got</a> and then decides what to do.  In pure Python, this is done with the variadic <code>*args</code> syntax, but <code>type()</code> is implemented in C, so it looks rather different.  It's doing the same thing, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python, in some sense, doesn't need a function overloading capability when other languages do. Consider the following example in C:</p>
<pre><code>int add(int x, int y) {
    return x + y;
}
</code></pre>
<p>If you wish to extend the notion to include stuff that are not integers you would need to make another function:</p>
<pre><code>float add(float x, float y) {
    return x + y;
}
</code></pre>
<p>In Python, all you need is:</p>
<pre><code>def add(x, y):
    return x + y
</code></pre>
<p>It works fine for both, and it isn't considered function overloading. You can also handle different cases of variable types using methods like <code>isinstance</code>. The major issue, <a href="https://stackoverflow.com/questions/733264/function-overloading-in-python-missing">as pointed out by this question</a>, is the number of types. But in your case you pass the same number of types, and even so, there are ways around this without function overloading.</p>
</div>
<div class="post-text" itemprop="text">
<p>overloading methods is tricky in python. However, there could be usage of passing the dict, list or primitive variables.</p>
<p>I have tried something for my use cases, this could help here to understand people to overload the methods.</p>
<p>Let's take the example:</p>
<p>a class overload method with call the methods from different class.</p>
<p><code>def add_bullet(sprite=None, start=None, headto=None, spead=None, acceleration=None):</code></p>
<p>pass the arguments from remote class:</p>
<p><code>add_bullet(sprite = 'test', start=Yes,headto={'lat':10.6666,'long':10.6666},accelaration=10.6}</code></p>
<p>OR  <code>add_bullet(sprite = 'test', start=Yes,headto={'lat':10.6666,'long':10.6666},speed=['10','20,'30']}</code></p>
<p>So, handling is being achieved for list, Dictionary or primitive variables from method overloading.</p>
<p>try it out for your codes</p>
</div>
<span class="comment-copy">setattr is not actually implement in straight python. You can see the implementation here: <a href="https://hg.python.org/cpython/file/tip/Objects/object.c" rel="nofollow noreferrer">hg.python.org/cpython/file/tip/Objects/object.c</a></span>
<span class="comment-copy">Those two things are the exact same thing.</span>
<span class="comment-copy">@user 2357112, no they are not.</span>
<span class="comment-copy">@user93868: No, seriously, they're the exact same thing. It doesn't matter whether the object happens to be a class or the attribute happens to be a function. You're just setting an ordinary attribute of an object either way.</span>
<span class="comment-copy">Sorry, I didn't realise. Thanks for clearing that.</span>
