<div class="post-text" itemprop="text">
<p>I need to be able to open a document using its default application in Windows and Mac OS. Basically, I want to do the same thing that happens when you double click on the document icon in Explorer or Finder. What is the best way to do this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Mac OS, you can use the "open" command.  There is a Windows API call that does something similar, but I don't remember it offhand.</p>
<h3>Update</h3>
<p>Okay, the "start" command will do it, so this should work.</p>
<p>Mac OS/X:</p>
<pre><code>os.system("open "+filename)
</code></pre>
<p>Windows:</p>
<pre><code>os.system("start "+filename)
</code></pre>
<h3>Much later update by Edward: os.system works, but <em>it only works with filenames that don't have any spaces in folders and files in the filename (e.g. A:\abc\def\a.txt)</em>.</h3>
<h3>Later Update</h3>
<p>Okay, clearly this silly-ass controversy continues, so let's just look at doing this with subprocess.</p>
<p><code>open</code> and <code>start</code> are command interpreter things for Mac OS/X and Windows respectively.  Now, let's say we use subprocess.  Canonically, you'd use:</p>
<pre><code>try:
    retcode = subprocess.call("open " + filename, shell=True)
    if retcode &lt; 0:
        print &gt;&gt;sys.stderr, "Child was terminated by signal", -retcode
    else:
        print &gt;&gt;sys.stderr, "Child returned", retcode
except OSError, e:
    print &gt;&gt;sys.stderr, "Execution failed:", e
</code></pre>
<p>Now, what are the advantages of this?  In theory, this is more secure -- but in fact we're needing to execute a command line one way or the other; in either environment, we need the environment and services to interpet, get paths, and so forth.  In neither case are we executing arbitrary text, so it doesn't have an inherent "but you can type <code>'filename ; rm -rf /'</code>" problem, and IF the file name can be corrupted, using <code>subprocess.call</code> gives us no protection.</p>
<p>It doesn't actually give us any more error detection, we're still depending on the <code>retcode</code> in either case.  We don't need to wait for the child process, since we're by problem statement starting a separate process.</p>
<p>"But <code>subprocess</code> is preferred."  However, <code>os.system()</code> is not deprecated, and it's the simplest tool for this particular job.</p>
<p>Conclusion: using <code>os.system()</code> is the simplest, most straightforward way to do this, and is therefore a correct answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the <code>subprocess</code> module available on Python 2.4+, not <code>os.system()</code>, so you don't have to deal with shell escaping.</p>
<pre><code>import subprocess, os, platform
if platform.system() == 'Darwin':       # macOS
    subprocess.call(('open', filepath))
elif platform.system() == 'Windows':    # Windows
    os.startfile(filepath)
else:                                   # linux variants
    subprocess.call(('xdg-open', filepath))
</code></pre>
<p>The double parentheses are because <code>subprocess.call()</code> wants a sequence as its first argument, so we're using a tuple here. On Linux systems with Gnome there is also a <code>gnome-open</code> command that does the same thing, but <code>xdg-open</code> is the Free Desktop Foundation standard and works across Linux desktop environments.</p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer:</p>
<pre><code>os.startfile(path, 'open')
</code></pre>
<p>Note that this module supports filenames that have spaces in their folders and files e.g. </p>
<pre><code>A:\abc\folder with spaces\file with-spaces.txt
</code></pre>
<p>(<a href="http://docs.python.org/library/os.html#os.startfile" rel="noreferrer">python docs</a>) 'open' does not have to be added (it is the default).  The docs specifically mention that this is like double-clicking on a file's icon in Windows Explorer.</p>
<p>This solution is windows only.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for completeness (it wasn't in the question), <a href="http://portland.freedesktop.org/xdg-utils-1.0/xdg-open.html" rel="noreferrer">xdg-open</a> will do the same on Linux.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import subprocess

def click_on_file(filename):
    '''Open document with default application in Python.'''
    try:
        os.startfile(filename)
    except AttributeError:
        subprocess.call(['open', filename])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have to use an heuristic method, you may consider <code>webbrowser</code>.<br/>
It's standard library and despite of its name it would also try to open files:</p>
<blockquote>
<p>Note that on some platforms, trying to open a filename using this
  function, may work and start the operating systemâ€™s associated
  program. However, this is neither supported nor portable.
  (<a href="http://docs.python.org/library/webbrowser.html#webbrowser.open" rel="noreferrer">Reference</a>)</p>
</blockquote>
<p>I tried this code and it worked fine in Windows 7 and Ubuntu Natty:</p>
<pre><code>import webbrowser
webbrowser.open("path_to_file")
</code></pre>
<p>This code also works fine in Windows XP Professional, using Internet Explorer 8.</p>
</div>
<div class="post-text" itemprop="text">
<p>Start does not support long path names and white spaces. You have to convert it to 8.3 compatible paths.</p>
<pre><code>import subprocess
import win32api

filename = "C:\\Documents and Settings\\user\\Desktop\file.avi"
filename_short = win32api.GetShortPathName(filename)

subprocess.Popen('start ' + filename_short, shell=True )
</code></pre>
<p>The file has to exist in order to work with the API call.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to go the <code>subprocess.call()</code> way, it should look like this on Windows:</p>
<pre><code>import subprocess
subprocess.call(('cmd', '/C', 'start', '', FILE_NAME))
</code></pre>
<p>You can't just use:</p>
<pre><code>subprocess.call(('start', FILE_NAME))
</code></pre>
<p>because <code>start</code> <a href="http://frank.neatstep.com/node/84" rel="nofollow noreferrer">is not an executable</a> but a command of the <code>cmd.exe</code> program. This works:</p>
<pre><code>subprocess.call(('cmd', '/C', 'start', FILE_NAME))
</code></pre>
<p>but only if there are no spaces in the FILE_NAME.</p>
<p>While <code>subprocess.call</code> method <strike>en</strike>quotes the parameters properly, the <code>start</code> command has a rather strange syntax, where:</p>
<pre><code>start notes.txt
</code></pre>
<p>does something else than:</p>
<pre><code>start "notes.txt"
</code></pre>
<p>The first quoted string should set the title of the window. To make it work with spaces, we have to do:</p>
<pre><code>start "" "my notes.txt"
</code></pre>
<p>which is what the code on top does.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am pretty late to the lot, but here is a solution using the windows api. This always opens the associated application.</p>
<pre><code>import ctypes

shell32 = ctypes.windll.shell32
file = 'somedocument.doc'

shell32.ShellExecuteA(0,"open",file,0,0,5)
</code></pre>
<p>A lot of magic constants. The first zero is the hwnd of the current program. Can be zero. The other two zeros are optional parameters (parameters and directory). 5 == SW_SHOW, it specifies how to execute the app.
Read the 
<a href="http://msdn.microsoft.com/en-us/library/bb762153%28v=vs.85%29.aspx" rel="nofollow">ShellExecute API docs</a> for more info.</p>
</div>
<div class="post-text" itemprop="text">
<p>os.startfile(path, 'open') under windows is good because when spaces exist in the directory, os.system('start', path_name) can't open the app correct and when the i18n exist in the directory, os.system needs to change the unicode to the codec of the console in Windows.</p>
</div>
<div class="post-text" itemprop="text">
<p>on mac os you can call 'open'</p>
<pre><code>import os
os.popen("open myfile.txt")
</code></pre>
<p>this would open the file with TextEdit, or whatever app is set as default for this filetype</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to specify the app to open the file with on Mac OS X, use this:
<code>os.system("open -a [app name] [file name]")</code></p>
</div>
<div class="post-text" itemprop="text">
<p>On windows 8.1, below have worked while other given ways with <code>subprocess.call</code> fails with path has spaces in it.</p>
<pre><code>subprocess.call('cmd /c start "" "any file path with spaces"')
</code></pre>
<p>By utilizing this and other's answers before, here's an inline code which works on multiple platforms.</p>
<pre><code>import sys, os, subprocess
subprocess.call(('cmd /c start "" "'+ filepath +'"') if os.name is 'nt' else ('open' if sys.platform.startswith('darwin') else 'xdg-open', filepath))
</code></pre>
</div>
<span class="comment-copy">There's been an issue for this to be included in the standard library in the Python tracker from 2008: <a href="http://bugs.python.org/issue3177" rel="nofollow noreferrer">bugs.python.org/issue3177</a></span>
<span class="comment-copy">Depending where <code>filename</code> comes form, this is a perfect example of why os.system() is insecure and bad. subprocess is better.</span>
<span class="comment-copy">Nick's answer looked fine to me. Nothing got in the way. Explaining things using wrong examples isn't easily justifiable.</span>
<span class="comment-copy">It's less secure and less flexible than using subprocess. That sounds wrong to me.</span>
<span class="comment-copy">Of course it matters. It's the difference between a good answer and a bad answer (or a terrible answer). The docs for os.system() themselves say "Use the subprocess module." What more is needed? That's deprecation enough for me.</span>
<span class="comment-copy">I feel a bit reluctant to restart this discussion, but I think the "Later update" section gets it entirely wrong.  The problem with <code>os.system()</code> is that it uses the shell (and you are not doing any shell escaping here, so Bad Things will happen for perfectly valid filenames that happen to contain shell meta-characters).  The reason why <code>subprocess.call()</code> is preferred is that you have the option to bypass the shell by using <code>subprocess.call(["open", filename])</code>.  This works for all valid filenames, and doesn't introduce a shell-injection vulnerability even for untrusted filenames.</span>
<span class="comment-copy">Using 'start' in subprocess.call() doesn't work on Windows -- start is not really an executable.</span>
<span class="comment-copy">nitpick: on all linuxen (and I guess most BSDs) you should use <code>xdg-open</code> - <a href="http://linux.die.net/man/1/xdg-open" rel="nofollow noreferrer">linux.die.net/man/1/xdg-open</a></span>
<span class="comment-copy">start on Windows is a shell command, not an executable.  You can use subprocess.call(('start', filepath), shell=True), although if you're executing in a shell you might as well use os.system.</span>
<span class="comment-copy">import sys.....</span>
<span class="comment-copy">I ran <code>xdg-open test.py</code> and it opened firefox download dialog for me. What's wrong? I'm on manjaro linux.</span>
<span class="comment-copy">This is windoze only.</span>
<span class="comment-copy">Thanks.  I didn't notice the availability, since the docs have it appended to the last paragraph.  In most other sections, the availability note occupies its own line.</span>
<span class="comment-copy">+1 Usually, responders should not answer questions that were not asked, but in this case I think it is very relevant and helpful for the SO community as a whole.</span>
<span class="comment-copy">Huh, I didn't know about startfile. It would be nice if the Mac and Linux versions of Python picked up similar semantics.</span>
<span class="comment-copy">Relevant python bug: <a href="http://bugs.python.org/issue3177" rel="nofollow noreferrer">bugs.python.org/issue3177</a> - provide a nice patch, and it might get accepted =)</span>
<span class="comment-copy">As far as I can tell, this is by far the best answer. Seems cross-platform and no need to check which platform is in use or import os, platform.</span>
<span class="comment-copy">But this doesn't seem to work on Mac.</span>
<span class="comment-copy">@jonathanrocher: I see <a href="https://github.com/python/cpython/blob/78d05eb847c6b8fede08ca74bb59210c00e4c599/Lib/webbrowser.py#L626" rel="nofollow noreferrer">Mac support in the source code</a>.  It uses <code>open location</code> there that should work if you give the path as a valid url.</span>
<span class="comment-copy">macOS: <code>import webbrowser webbrowser.open("file:///Users/nameGoesHere/Desktop/folder/file.py")</code></span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/webbrowser.html#webbrowser.open" rel="nofollow noreferrer">docs.python.org/3/library/webbrowser.html#webbrowser.open</a> "Note that on some platforms, trying to open a filename using [webbrowser.open(url)], may work and start the operating systemâ€™s associated program. However, this is neither supported nor portable."</span>
<span class="comment-copy">Another workaround is to give it a title in quotes, e.g. <code>start "Title" "C:\long path to\file.avi"</code></span>
<span class="comment-copy">how it compares to <code>os.startfile(file)</code>?</span>
