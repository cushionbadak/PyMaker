<div class="post-text" itemprop="text">
<p>In statically typed languages to solve the problem below I would use interface (or abstract class etc.). But I wonder if in python there is more "pythonic" way of doing it.</p>
<p>So, consider the situation:</p>
<pre><code>class MyClass(object):
    # ...
    def my_function(self, value_or_value_provider):
        if is_value_provider(value_or_value_provider):
            self._value_provider = value_or_value_provider
        else:
            self._value_provider = StandardValueProvider(value_or_valie_provider)
            # `StandardValueProvider` just always returns the same value.
</code></pre>
<p>Above "value provider" is custom class, which has <code>get_value()</code> method. Of course, the idea is that it can be implemented by the user.</p>
<p>Now, the question is: what is the best way to implement <code>is_value_provider()</code>? I.e., what is the best way to distinguish between "single value" and "value provider"?</p>
<p>The first idea, which came to my mind is to use inheritance: Introduce base class <code>BaseValueProvider</code> with empty implementation and tell in documentation, that custom "value providers" must inherit from it. Then in <code>is_value_provider()</code> function just check <code>isinstance(objectToCheck, BaseValueProvider)</code>. What I don't like about this solution is that inheritance seems to be somehow redundant in this case (specifically in case of python), because we cannot even force one, who derive to implement <code>get_value()</code> method. Besides, for someone who wants to implement custom "value provider" this solution implies need to have a dependency on the module, which exposes <code>BaseValueProvider</code>.</p>
<p>The other solution would be to use "trait attribute". I.e. instead of checking base class, check existence of particular attribute with <code>hasattr()</code> function. We can check either existence of <code>get_value()</code> method itself. Or, if we afraid, that the name of the method is too common, we could check for dedicated trait attribute, like <code>is_my_library_value_provider</code>. Then in documentation tell, that any custom "value provider" must have not only <code>get_value()</code> method, but also <code>is_my_library_value_provider</code>. This second solution seems to be better, as it does not abuse inheritance and allows to implement custom "value providers" without being dependent on some additional library, which provides base class.</p>
<p>Could someone comment on which solution is preferable (or if there are other better ones), and why?</p>
<p>EDIT: Change the example slightly to reflect the fact, that value-provider is going to be stored and used later (probably, multiple times).</p>
</div>
<div class="post-text" itemprop="text">
<p>I highly suggest using <a href="https://docs.python.org/3/library/functions.html#hasattr" rel="nofollow"><code>hasattr()</code></a>.  </p>
<p>Your code will be highly readable and via <a href="https://en.wikipedia.org/wiki/Duck_typing#In_Python" rel="nofollow">ducktyping</a> you can later on make it work with other types you have in mind.</p>
<p>Regarding not getting confused with other objects having the <code>get_value()</code> function, Python idioms assume the coder is a responsible person and won't try to destoy the system he is implementing the code with, therefore a single <code>hasattr(obj, "get_value")</code> is enough. If the class has <code>.get_value()</code> it can be assumed as a value provider and not a value (else, the value is the value itself. <code>.get_value()</code> on a value, returning <code>self</code> is rather useless).</p>
</div>
<span class="comment-copy">Use the <code>try</code>-<code>except</code> thing in Python</span>
<span class="comment-copy">@ssm In this specific context try-except does not work (or I don't see how). In fact, as you can imagine, the value-provider is delayed value generator. This means, that actually I want to store value provider. If I get single value, I will create some standard value provider, which always returns given value. This way I will be sure, that what is stored in my object is value-provider and I do not have to test it every time I use it.</span>
<span class="comment-copy">@DmitrySemikin <code>try</code>-<code>except</code> <i>does</i> work: <code>def is_value_provider(x): try: x.get_value;return True except AttributeError: return False</code>.  Anyway what you call "checking for the trait attribute" seems exactly what is mean by <i>duck typing</i>, which is the way in which things are usually done in python.</span>
<span class="comment-copy">@Bakuriu Ah, ok, indeed. I did not get the idea first. But what if <code>get_value</code> is long operation?</span>
<span class="comment-copy">Doing <code>x.get_value</code> does <b>not</b> execute anything, so it doesn't matter what <code>get_value</code> is. It simply looks up the attribute. In fact that code is equivalent to calling <code>hasattr</code> with the name <code>"get_value"</code>.</span>
<span class="comment-copy">Thanks for the answer. I agree. One notice: it may be the case, that the "value" returned by value provider itself may have "get_value" method. Than it becomes hard to distinguish between them. Similar problem shows up, when one tries to distinguish between a collection and single object by checking usability of <code>len()</code>. But then get collection of strings...</span>
