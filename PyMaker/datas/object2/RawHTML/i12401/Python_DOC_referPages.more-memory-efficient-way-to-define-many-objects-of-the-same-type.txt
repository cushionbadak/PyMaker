<div class="post-text" itemprop="text">
<p>So, I'm foraying into the world of plasma simulation. Now, while I'm aware that top-level simulations are written in fortran and have ultra-memory efficient subroutines and specialized code, I'm hoping to just run some low-level simulations.</p>
<p>My problem is that, when simulating a large number of particles in a time-varying environment (well, time-stepped), keeping track of all that data is a trick. I've used multi-dimensional arrays before - using the column number for the particle, and the row number for the attribute, however this feels rather clumsy. It does, however, seem to be more quickly executed.</p>
<p>I recently tried defining my own class, however being a python newbie, I probably did it in a very inefficient way. For each particle in 3 dimensions, I needed to be able to store the particle's position, velocity and Force (with the potential to add more variables once the code becomes more complex). Using what I knew of classes, I defined a <code>particle</code> object (I think) that make my code much easier to read and follow:</p>
<pre><code># Define Particle as a class
class particle():
    def __init__(self, index=0, pos=np.array([0, 0, 0]), vel=np.array([0,0,0]), 
                 F=np.array([0, 0, 0])):
        self.index = index      # Particle index (identifier)
        self.pos = pos          # Position 3-vector
        self.vel = vel          # Velocity 3-vector
        self.F = F              # Net force 3-vector (at particle)
</code></pre>
<p>So, I can easily initialize an array containing lots of these objects, and modify each value in a reasonably straightforward way. However as I mentioned, this ran slower for simulations involving only a few particles. I will be playing with my code to compare it to a purely matrix-oriented method to see which one scales better with large simulations.</p>
<p>My question I suppose then is this: Is defining a "particle" in this way the most efficient? Or is there a more CPU/memory efficient way to define such an object. I would like to keep it's method ability (i.e. <code>particle[i].pos = [1,2,3]</code> or <code>particle[2].vx[1] = 3</code>) so I can set values for each particle, as well as pass them through functions. Keep in mind I'm a Python newbie, so I probably won't have great success with large, complex code.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Save memory with <code>__slots__</code></h2>
<p>One way to save memory is using <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__" rel="nofollow noreferrer"><strong>slots</strong></a>:</p>
<pre><code>class Particle():  # Python 3
    __slots__ = ['index', 'pos', 'vel', 'F']
    def __init__(self, index=0, pos=None, vel=None, F=None):
        # Particle index (identifier)
        self.index = index      
        # Position 3-vector
        self.pos = np.array([0, 0, 0]) if pos is None else pos    
        # Velocity 3-vector
        self.vel = np.array([0,0,0]) if vel is None else vel   
        # Net force 3-vector (at particle)
        self.F = np.array([0, 0, 0]) if F is None else F        
</code></pre>
<p>From the docs:</p>
<blockquote>
<p>This class variable can be assigned a string, iterable, or sequence of strings with variable names used by instances. <code>__slots__</code> reserves space for the declared variables and prevents the automatic creation of <code>__dict__</code> and <code>__weakref__</code> for each instance.</p>
</blockquote>
<p><strong>Side note</strong>: I fixed the <a href="https://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument">mutable default argument problem</a> by setting them to <code>None</code> and creating a new NumPy array in the <code>__init__()</code> for <code>None</code> values.</p>
<h2>Cannot add new attributes to instance</h2>
<p>One important difference is that you cannot add attributes after instantiation that are not listed in <code>__slots__</code>:</p>
<pre><code>p = Particle()

p.new_attr = 45

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-664-a970d86f4ca3&gt; in &lt;module&gt;()
      1 p = Particle()
      2 
----&gt; 3 p.new_attr = 45

AttributeError: 'Particle' object has no attribute 'new_attr'
</code></pre>
<p>Compare to a class without <code>__slots__</code>:</p>
<pre><code>class A:   # Python 3
    pass

a = A()
a.new_attr = 10
</code></pre>
<p>No exception is raised.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want the flyweight pattern. Maybe store one integer in the object as an index into an array with rows of 9 elements?</p>
</div>
<span class="comment-copy">Are you using numpy?</span>
<span class="comment-copy">Yes. I'm also using matplotlib for the visualization.</span>
<span class="comment-copy">Watch out for that <a href="http://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument">mutable default argument</a>.</span>
<span class="comment-copy">@user2357112 Good point. Addressed this in my updated answer.</span>
<span class="comment-copy">That looks interesting! Does that enable me to interact with the objects in the same way once created?  Also, how do 'slots' work exactly? (If you know)  Edit: Thanks! I will be trying that when I get to the place with the computers. I was really hoping to keep using my class, because it made my code look so pretty - and using matrices in python is a bit of a headache.</span>
<span class="comment-copy">There are several <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__slots__#object.__slots__" rel="nofollow noreferrer">difference</a>. But for many practical purposes there are no major drawbacks.</span>
<span class="comment-copy">Trying the basic experiment to generate 100 static particles, my program executes slower <i>with</i> the <b>slots</b> declaration:</span>
<span class="comment-copy">How do you measure this? I've been doing performance measurements in Python for many years and there many things that can distort timing results.</span>
<span class="comment-copy">I've just been using a difference timer from timeit:  from timeit import default_timer as timer start_time = timer() elapsed = timer() - start_time  Having run the simulation with several thousand particles now, unfortunately having the matrix seems to be the most expedient method for it. I'll just have to deal with messy code. For 10,000 particles, it took 0.61 seconds with classes, and 0.48 seconds with a matrix. Once I start moving these particles, I imagine the difference will only increase.</span>
