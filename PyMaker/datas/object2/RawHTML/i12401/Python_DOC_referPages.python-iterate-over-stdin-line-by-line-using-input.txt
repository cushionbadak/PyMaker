<div class="post-text" itemprop="text">
<p>I am trying to get multiple names separated by newlines from the console and put them into a variable. Let's assume I want to get input from the terminal forever (I'll add some code to break out of the loop later). I know how to do it with a while loop and recursion, but I would like to be able to do it with a for loop. </p>
<p>In the below example when I get <code>"peter"</code> as input from the terminal I get each letter rather than a whole line at a time:</p>
<pre><code>for name in input():
    print(name)
</code></pre>
<p>Now, if I use <code>sys.stdin</code> the <code>name</code> variable becomes <code>"peter\n"</code>:</p>
<pre><code>for name in sys.stdin:
    print(name)
</code></pre>
<p>Is there a easy way to get <code>input()</code> to give <code>"name"</code> a whole line rather than individual characters? Or just by the nature of using <code>for in</code> I am going to be iterating through the characters in the input? Are there any inherent risks/problems with getting input in this fashion? Is there a "standard" way of getting input in a situation like this?</p>
<p>I am using Python 3.5.1 on Ubuntu 15.10.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can wrap <code>stdin</code> to strip the newlines; if you can strip all trailing whitespace (usually okay), then it's just:</p>
<pre><code>for name in map(str.rstrip, sys.stdin):
    ...
</code></pre>
<p>You're on Py3, so that works as is; if you're on Py2, you'll need to add an import, <code>from future_builtins import map</code>, so you get a lazy, generator based <code>map</code> (that yields the lines as they're requested, rather than slurping <code>stdin</code> until it ends, then returning a <code>list</code> of all the lines).</p>
<p>If you need to limit to newlines, a generator expression can do it:</p>
<pre><code>for name in (line.rstrip("\r\n") for line in sys.stdin):
    ...
</code></pre>
<p>or with an import to allow <code>map</code> to push work to C layer for (slightly) faster code (a matter of 30-some nanoseconds per line faster than the genexpr, but still 40 ns per line slower than the argumentless option at the top of this answer):</p>
<pre><code>from operator import methodcaller

for name in map(methodcaller('rstrip', '\r\n'), sys.stdin):
    ...
</code></pre>
<p>Like the first solution, on Py2, make sure to get the <code>map</code> from <code>future_builtins</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wouldn't recommend you this, but you can create a generator to be used in a <code>for</code> loop to iterate through input line by line:</p>
<pre><code>def getlines():
    while True:
        yield input()

for name in getlines():
    print(name)
    ## Remember to break out of the loop at some point
</code></pre>
</div>
<span class="comment-copy"><code>input()</code> returns a string which is an iterable, so therefore when you try and iterate over it you are getting each character one by one.</span>
<span class="comment-copy">Ok that makes sense. input() returns a string. So does sys.stdin return a buffer that is iterated line by line?</span>
<span class="comment-copy">Because sys.stdin returns a file like object which, when iterated through, will contain each individual line of the input.</span>
<span class="comment-copy">@PeterH <a href="https://docs.python.org/3/library/sys.html?highlight=sys.stdin#sys.stdin" rel="nofollow noreferrer"><code>sys.stdin</code> isn't a function</a>, it actually is a file object which is used by the system to get the standard input, therefore <code>for name in sys.stdin</code> behaves like it would do on a file: reading it line by line.</span>
<span class="comment-copy">Cool makes sense. If I am using 'for name in sys.stdin' that would exit the loop when the input ends correct?</span>
<span class="comment-copy">Sorry if I was unclear. I am trying to do it more than one time with each name separated by a newline in the terminal.</span>
<span class="comment-copy">@PeterH I updated my answer</span>
