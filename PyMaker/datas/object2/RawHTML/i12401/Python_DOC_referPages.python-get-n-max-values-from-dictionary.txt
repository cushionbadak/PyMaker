<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/7197315/5-maximum-values-in-a-python-dictionary">5 maximum values in a python dictionary</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/11902665/top-values-from-dictionary">top values from dictionary</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<p>Assume we have dictionary:</p>
<pre><code>items = {'a': 7, 'b': 12, 'c': 9, 'd': 0, 'e': 24, 'f': 10, 'g': 24}
</code></pre>
<p>I want to get another dictionary, containing 4 elements with maximum values. E.g. I expect to get:</p>
<pre><code>subitems = {'e': 24, 'g': 24, 'b': 12, 'f': 10}
</code></pre>
<p>What will be most pythonic and efficient (memory consumption, execution speed - when f.e. I'll have dict with 1000000 elements) way to do this? Generators, lambdas, something another?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer"><code>heapq.nlargest</code></a> is always the correct answer when the question is "How do I get a small number of maximum values from a huge set of inputs?" It minimizes memory usage and CPU usage better than just about anything else you could do in Python, by using heaps. Example:</p>
<pre><code>import heapq
from operator import itemgetter

items = {'a': 7, 'b': 12, 'c': 9, 'd': 0, 'e': 24, 'f': 10, 'g': 24}

topitems = heapq.nlargest(items.items(), key=itemgetter(1))  # Use .iteritems() on Py2
topitemsasdict = dict(topitems)
</code></pre>
<p><code>sorted</code> and slicing the result can win when the number of max items requested is a large percentage of the input, but for huge inputs and small numbers of max items, the memory savings of <code>heapq.nlargest</code> will win.</p>
<p>For the CS theory geeks, <code>heapq.nlargest</code>, for an input of size <code>n</code>, selecting the <code>k</code> max values, requires <code>O(n log k)</code> computation, and <code>k</code> storage. <code>sorted</code> followed by slicing requires <code>O(n log n)</code> computation and <code>n</code> storage. So for 1024 inputs and 4 selected items, work for <code>nlargest</code> is ~1024 * <em>2</em> computation with storage required of 4; <code>sorted</code> + slicing would be ~1024 * <em>10</em> computation with storage of 1024. In practice, Python's TimSort used in <code>sorted</code> has lower overhead than big-O notation can properly convey, and usually performs better than the big-O notation would indicate, which is why for, say, selecting the top 200 items out of 1024, <code>sorted</code> + slicing can still win, but <code>nlargest</code> lacks pathological degradation for huge inputs and outputs; it may be slower on occasion, but it's usually not much slower, where sorted can be faster, but it can also be <em>much</em> slower.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check the source code of <a href="https://hg.python.org/cpython/file/2.7/Lib/collections.py#l484" rel="nofollow"><code>collections.Counter.most_common()</code></a> method. It shows the best solution. And of course, the best way is using <code>Counter()</code> instead of <code>{}</code>.</p>
<pre><code>def most_common(self, n=None):
    '''List the n most common elements and their counts from the most
    common to the least.  If n is None, then list all element counts.

    &gt;&gt;&gt; Counter('abcdeabcdabcaba').most_common(3)
    [('a', 5), ('b', 4), ('c', 3)]

    '''
    # Emulate Bag.sortedByCount from Smalltalk
    if n is None:
        return sorted(self.iteritems(), key=_itemgetter(1), reverse=True)
    return _heapq.nlargest(n, self.iteritems(), key=_itemgetter(1))
</code></pre>
</div>
<span class="comment-copy">or this one <a href="http://stackoverflow.com/questions/11902665/top-values-from-dictionary">top values from dictionary</a>. Your call really.</span>
<span class="comment-copy">@Lafexlos Well, I like the <a href="http://stackoverflow.com/questions/11902665/top-values-from-dictionary" title="top values from dictionary">stackoverflow.com/questions/11902665/top-values-from-dictionary</a> one better.</span>
