<div class="post-text" itemprop="text">
<p>Hi I am new to programming and python programming. 
I have a tab delimited txt file that I have imported using <code>numpy.getfromtxt</code> and it looks like</p>
<pre><code>[['chr' 'start' 'end' 'name' 'score' 'strand']
['chr1' '822979' '822980' 'CLL6.08_1_snv' '88.2' '+']
..., 
['chrX' '153986959' '153986960' 'CLL6.08_2678_snv' '500' '+']]
</code></pre>
<p>I want to split this data in subarrays with different chromosomes like </p>
<pre><code>Chr1, Chr2 ...
</code></pre>
<p>I was trying something like this but getting an syntax error. I am trying to do so as I want to extract each chromosome data when conditionally.</p>
<pre><code>import numpy as np  
data=np.genfromtxt("CLL608.txt",delimiter ="\t",dtype=None,skip_header=0)
subarray=(['Chr1':data[data[:,0]=='chr1'], 'Chr2':data[data[:,0]=='chr2']])
</code></pre>
<p>I would really appreciate any suggestion in this regard. </p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot make association in a list [] you have to use a dictionary {}</p>
<pre><code>&gt;&gt;&gt; subarray=({'Chr1':'bla'=='blu'})
&gt;&gt;&gt; print subarray
{'Chr1': False}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Create a <code>dict</code>-ionary, which takes a string (or any hashable object) and returns an arbitrary value. Use that to map your 'chr' names to sub-arrays with just those records:</p>
<pre><code>sublists = {}  # empty dict
for record in data:
    key = record[0] # 'chr1' or whatever
    if key in sublists:   # already seen it?
        sublists[key].append(record)
    else:
        sublists[key] = [record]  # start new sublist
</code></pre>
<p>You can speed this up by knowing that in Python, the whole "I wish my dictionary had a default value for new keys" problem comes up <em>a lot</em>, and there are some standard solutions:</p>
<pre><code>sublists = {}
for record in data:
    key = record[0]
    sublists.get(key, list()).append(record)
</code></pre>
<p>The <code>list()</code> creates a new, empty, list. Either the empty list, or a previously existing list, has the <code>record</code> appended.</p>
<p>Finally, you can speed that up even more by recognizing that iterating across a list and doing exactly one thing to it is a good use of the <code>map</code> function. Although generally you use the <em>result</em> of whatever you're doing, with map.</p>
<pre><code>sublists = {}
map(data, lambda r: sublists.get(r[0], list()).append(r))
</code></pre>
<p>Finally, if your data happens to be <em>sorted</em> on the key value, you might use the <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools.groupby#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a> function, which will handle the grouping logic for you if the data is already sorted. I mention these last two (<code>map</code> and <code>groupby</code>) because I suspect your dataset may be large, and performance may be an issue.</p>
</div>
<span class="comment-copy">You may want to have a look at <code>pandas</code> and use its data frame data structure.</span>
