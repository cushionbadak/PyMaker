<div class="post-text" itemprop="text">
<p>I'm trying to wrap my head around a common generator idiom I encounter in the wild.  I've noticed it (and used it) for a long time but never bothered to question it. An example of the idiom using a toy function:</p>
<pre><code>def contains_vowels(string):
    vowels = set('aeiou')

    if any((char in vowels) for char in string):
        return True

    return False
</code></pre>
<p>Why does <code>any((char in vowels) for char in string)</code> work as expected?  I get that <code>(char in vowels)</code> is a generator expression, but e.g. <code>(char in vowels) for char in string</code> is not a valid generator outside of a function call.</p>
<p>Put another way, given that the above code is valid, why does the following code <em>not</em> work: </p>
<pre><code>    for b in (char in vowels) for char in string:
        print b
</code></pre>
<p>(obviously, making the whole expression a generator <em>does</em> work as expected:</p>
<pre><code>    for b in (char in vowels for char in string):
        print b
</code></pre>
<p>)</p>
<p>I get that it's a bit of a silly question but the answer isn't immediately intuitive to me.  Is it just a case of "because that's the way the syntax works" or is there something I'm missing?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I
  get that <code>(char in vowels)</code> is a generator expression,</p>
</blockquote>
<p>Actually, it's not. The parentheses are completely superfluous in this case, since there's just a single operator <code>in</code>. When you have more operators, parentheses are used to set order of operations. <code>(1+2)*3 == 9</code></p>
<blockquote>
<p><code>(char in vowels) for char in string</code> is not a valid generator outside of a
  function call.</p>
</blockquote>
<p>Actually it is. Inside a function call you can skip the extra parentheses, when the generator is the only argument. So the following two lines are in effect the same. </p>
<pre><code>any(char in vowels for char in string)
any((char in vowels for char in string))
</code></pre>
<p>Outside a function call, the generator must have parentheses.</p>
<pre><code>(char in vowels for char in string)
</code></pre>
</div>
<span class="comment-copy"><code>(char in vowels)</code> is not a generator expression. <code>expression for i in seq</code> is a generator expression. <code>x in foo</code> is checking for containment.</span>
<span class="comment-copy">I get that <code>x in foo</code> checks for containment.  I just always assumed the <code>()</code> were indicating a generator because this is the only context in which I've used this pattern, although what you're saying makes sense.  So I guess the take away is you can define generator expressions without parentheses inside a function call... but e.g., I know this doesn't work in function calls with multiple arguments.  So, a more elaborate answer would be useful.</span>
<span class="comment-copy">You would also <code>return any(char in vowels for char in string)</code>, you don't need an if/else</span>
<span class="comment-copy">Sure Padraic, it's just a toy.</span>
<span class="comment-copy">So generator expressions inside single-parameter function calls are just a special case.  I guess I knew the answer to this question all along, but felt the implicit generator syntax was inconsistent with what I'd expect.</span>
<span class="comment-copy">Yes, it's a special case.</span>
<span class="comment-copy">This can be a bit hard to find in the docs if one does not <a href="https://docs.python.org/3/howto/functional.html" rel="nofollow noreferrer">use python for functional programming</a> - search for <i>parentheses signalling a function call also count</i>.</span>
