<div class="post-text" itemprop="text">
<p>From the question and answer in <a href="https://stackoverflow.com/questions/35166992/utf-8-coding-in-python">UTF-8 coding in Python</a>, I could use binascii package to decode an utf-8 string with '_' in it. </p>
<pre><code>def toUtf(r):
    try:
        rhexonly = r.replace('_', '')
        rbytes = binascii.unhexlify(rhexonly)
        rtext = rbytes.decode('utf-8')
    except TypeError:
        rtext = r
    return rtext
</code></pre>
<p>This code works fine with only utf-8 characters:</p>
<pre><code>r = '_ed_8e_b8'
print toUtf(r)
&gt;&gt; 편 
</code></pre>
<p>However, this code does not work when the string has normal ascii code in it. The ascii can be anywhere in the string. </p>
<pre><code>r = '_2f119_ed_8e_b8'
print toUtf(r)
&gt;&gt; doesn't work - _2f119_ed_8e_b8
&gt;&gt; this should be '/119편'
</code></pre>
<p>Maybe, I can use regular expression to extract the utf-8 part and ascii part to reassmeble after the conversion, but I wonder if there is an easier way to do the conversion. Any good solution? </p>
</div>
<div class="post-text" itemprop="text">
<p>Quite straightforward with <code>re.sub</code>:</p>
<pre><code>import re

bytegroup = r'(_[0-9a-z]{2})+'

def replacer(match):
    return toUtf(match.group())

rtext = re.sub(bytegroup, replacer, r, flags=re.I)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That is some truly terrible input you've got. It's still fixable though. First off, replace the non-"encoded" stuff with hex equivalents:</p>
<pre><code>import itertools
import re

r = '_2f119_ed_8e_b8'

# Split so you have even entries in the list as ASCII, odd as hex encodings
rsplit = re.split(r'((?:_[0-9a-fA-F]{2})+)', r)   # ['', '_2f', '119', '_ed_8e_b8', '']

# Process the hex encoded UTF-8 with your existing function, leaving
# ASCII untouched
rsplit[1::2] = map(toUtf, rsplit[1::2])  # ['', '/', '119', '관', '']

rtext = ''.join(rsplit)  # '/119편'
</code></pre>
<p>The above is a verbose version that shows the individual steps, but as <a href="https://stackoverflow.com/a/35167557/364696">chthonicdaemon's answer</a> point's out, it can be shortened dramatically. You use the same regular expression with <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> instead of <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer"><code>re.split</code></a>, and pass a function to perform the replacement instead of a replacement pattern string:</p>
<pre><code># One-liner equivalent to the above with no intermediate lists
rtext = re.sub(r'(?:_[0-9a-f]{2})+', lambda m: toUtf(m.group()), r, flags=re.I)
</code></pre>
<p>You can package that up as a function itself, so you have one function that deals with purely hex encoded UTF-8, and a second general function that uses the first function as part of processing mixed non-encoded ASCII and hex encoded UTF-8 data.</p>
<p>Mind you, this won't necessarily work all that well if the non-encoded ASCII might contain <code>_</code> normally; the regex tries to be as targeted as possible, but you've got a problem here where no matter how finely you target your heuristics, some ASCII data will be mistaken for encoded UTF-8 data.</p>
</div>
<span class="comment-copy">You should probably ask @ShadowRanger in a comment on his answer.</span>
<span class="comment-copy">As a rule, you shouldn't edit answers into questions. Also, note the edit I made to @chthonicdaemon's answer; you need to pass <code>flags=re.I</code>, not <code>re.I</code> after <code>r</code>, or the regex is run case-sensitively, and won't do more than two replacements (because oops, turns out <code>re.sub</code> takes an optional <code>count</code> argument before the <code>flags</code> argument). Also, the outermost parens in the pattern are only needed for the <code>re.split</code> approach; for <code>re.sub</code>, they can (and should, for minor performance gains) be omitted.</span>
<span class="comment-copy">I should have remembered <code>re.sub</code> with a function as the shorthand from the <code>re.split</code> + post-processing and re-<code>''.join</code>. It's a little more magical, but it's the better solution. Unless you object, I'll copy it in as the short form in my answer to make it complete (the spread out bit illustrates the pieces, <code>re.sub</code> is the all-in-one). I'm upvoting you regardless.</span>
<span class="comment-copy">No problem with copying it.</span>
<span class="comment-copy">I checked that r'(_[0-9a-z]{2})+' also works fine, do you have any reason to use r'(?:_[0-9a-z]{2})+'?</span>
<span class="comment-copy">@prosseek The non-capturing group was necessary for one of my early iterations on the solution, but not anymore. I've edited it out.</span>
<span class="comment-copy">@Kevin: It's not even vs odd characters, it's even vs. odd split results. The <code>re.split</code> return value <i>does</i> give you even-&gt;ASCII, odd-&gt;encoded automatically. I'll add the example intermediate values.</span>
