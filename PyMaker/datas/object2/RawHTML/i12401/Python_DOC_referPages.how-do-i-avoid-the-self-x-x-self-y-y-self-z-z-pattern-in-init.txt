<div class="post-text" itemprop="text">
<p>I see patterns like</p>
<pre><code>def __init__(self, x, y, z):
    ...
    self.x = x
    self.y = y
    self.z = z
    ...
</code></pre>
<p>quite frequently, often with a lot more parameters. Is there a good way to avoid this type of tedious repetitiveness? Should the class inherit from <code>namedtuple</code> instead?</p>
</div>
<div class="post-text" itemprop="text">
<p>A decorator solution that keeps the signature:</p>
<pre><code>import decorator
import inspect
import sys


@decorator.decorator
def simple_init(func, self, *args, **kws):
    """
    @simple_init
    def __init__(self,a,b,...,z)
        dosomething()

    behaves like

    def __init__(self,a,b,...,z)
        self.a = a
        self.b = b
        ...
        self.z = z
        dosomething()
    """

    #init_argumentnames_without_self = ['a','b',...,'z']
    if sys.version_info.major == 2:
        init_argumentnames_without_self = inspect.getargspec(func).args[1:]
    else:
        init_argumentnames_without_self = tuple(inspect.signature(func).parameters.keys())[1:]

    positional_values = args
    keyword_values_in_correct_order = tuple(kws[key] for key in init_argumentnames_without_self if key in kws)
    attribute_values = positional_values + keyword_values_in_correct_order

    for attribute_name,attribute_value in zip(init_argumentnames_without_self,attribute_values):
        setattr(self,attribute_name,attribute_value)

    # call the original __init__
    func(self, *args, **kws)


class Test():
    @simple_init
    def __init__(self,a,b,c,d=4):
        print(self.a,self.b,self.c,self.d)

#prints 1 3 2 4
t = Test(1,c=2,b=3)
#keeps signature
#prints ['self', 'a', 'b', 'c', 'd']
if sys.version_info.major == 2:
    print(inspect.getargspec(Test.__init__).args)
else:
    print(inspect.signature(Test.__init__))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Disclaimer:</strong> It seems that several people are concerned about presenting this solution, so I will provide a very clear disclaimer. You should not use this solution. I only provide it as information, so you know that the language is capable of this. The rest of the answer is just showing language capabilities, not endorsing using them in this way.</p>
<hr/>
<p>There isn't really anything wrong with explicitly copying parameters into attributes. If you have too many parameters in the ctor, it is sometimes considered a code smell and maybe you should group these params into a fewer objects. Other times, it is necessary and there is nothing wrong with it. <strong>Anyway, doing it explicitly is the way to go.</strong></p>
<p>However, since you are asking HOW it can be done (and not whether it should be done), then one solution is this:</p>
<pre><code>class A:
    def __init__(self, **kwargs):
        for key in kwargs:
          setattr(self, key, kwargs[key])

a = A(l=1, d=2)
a.l # will return 1
a.d # will return 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have mentioned, the repetition isn't bad, but in some cases a namedtuple can be a great fit for this type of issue. This avoids using locals() or kwargs, which are usually a bad idea. </p>
<pre><code>from collections import namedtuple
# declare a new object type with three properties; x y z
# the first arg of namedtuple is a typename
# the second arg is comma-separated or space-separated property names
XYZ = namedtuple("XYZ", "x, y, z")

# create an object of type XYZ. properties are in order
abc = XYZ("one", "two", 3)
print abc.x
print abc.y
print abc.z
</code></pre>
<p>I've found limited use for it, but you can inherit a namedtuple as with any other object (example continued):</p>
<pre><code>class MySuperXYZ(XYZ):
    """ I add a helper function which returns the original properties """
    def properties(self):
        return self.x, self.y, self.z

abc2 = MySuperXYZ(4, "five", "six")
print abc2.x
print abc2.y
print abc2.z
print abc2.properties()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>explicit is better than implicit ... 
so sure you could make it more concise:</p>
<pre><code>def __init__(self,a,b,c):
    for k,v in locals().items():
        if k != "self":
             setattr(self,k,v)
</code></pre>
<p>The better question is should you?</p>
<p>... that said if you want a  named tuple I would recommend using a namedtuple (remember tuples have certain conditions attached to them) ... perhaps you want an ordereddict or even just a dict ...</p>
</div>
<div class="post-text" itemprop="text">
<p>To expand on <code>gruszczy</code>s answer, I have used a pattern like:</p>
<pre><code>class X:
    x = None
    y = None
    z = None
    def __init__(self, **kwargs):
        for (k, v) in kwargs.items():
            if hasattr(self, k):
                setattr(self, k, v)
            else:
                raise TypeError('Unknown keyword argument: {:s}'.format(k))
</code></pre>
<p>I like this method because it:</p>
<ul>
<li>avoids repetition</li>
<li>is resistant against typos when constructing an object</li>
<li>works well with subclassing (can just <code>super().__init(...)</code>)</li>
<li>allows for documentation of the attributes on a class-level (where they belong) rather than in <code>X.__init__</code></li>
</ul>
<p>Prior to Python 3.6, this gives no control over the order in which the attributes are set, which could be a problem if some attributes are properties with setters that access other attributes.</p>
<p>It could probably be improved upon a bit, but I'm the only user of my own code so I am not worried about any form of input sanitation.  Perhaps an <code>AttributeError</code> would be more appropriate.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also do:</p>
<pre><code>locs = locals()
for arg in inspect.getargspec(self.__init__)[0][1:]:
    setattr(self, arg, locs[arg])
</code></pre>
<p>Of course, you would have to import the <code>inspect</code> module.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a solution without any additional imports.</p>
<h2>Helper function</h2>
<p>A small helper function makes it more convenient and re-usable:</p>
<pre><code>def auto_init(local_name_space):
    """Set instance attributes from arguments.
    """
    self = local_name_space.pop('self')
    for name, value in local_name_space.items():
        setattr(self, name, value)
</code></pre>
<h2>Application</h2>
<p>You need to call it with <code>locals()</code>:</p>
<pre><code>class A:
    def __init__(self, x, y, z):
        auto_init(locals())
</code></pre>
<h2>Test</h2>
<pre><code>a = A(1, 2, 3)
print(a.__dict__)
</code></pre>
<p>Output:</p>
<pre><code>{'y': 2, 'z': 3, 'x': 1}
</code></pre>
<h2>Without changing <code>locals()</code></h2>
<p>If you don't like to change <code>locals()</code> use this version:</p>
<pre><code>def auto_init(local_name_space):
    """Set instance attributes from arguments.
    """
    for name, value in local_name_space.items():
        if name != 'self': 
            setattr(local_name_space['self'], name, value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An interesting library that handles this (and avoids a lot of other boilerplate) is <a href="https://attrs.readthedocs.io/en/stable/" rel="noreferrer">attrs</a>. Your example, for instance, could be reduced to this (assume the class is called <code>MyClass</code>):</p>
<pre><code>import attr

@attr.s
class MyClass:
    x = attr.ib()
    y = attr.ib()
    z = attr.ib()
</code></pre>
<p>You don't even need an <code>__init__</code> method anymore, unless it does other stuff as well. Here's <a href="https://glyph.twistedmatrix.com/2016/08/attrs.html" rel="noreferrer">a nice introduction by Glyph Lefkowitz</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>My 0.02$. It is very close to Joran Beasley answer, but more elegant:</p>
<pre><code>def __init__(self, a, b, c, d, e, f):
    vars(self).update((k, v) for k, v in locals().items() if v is not self)
</code></pre>
<p>Additionally, Mike MÃ¼ller's answer (the best one to my taste) can be reduced with this technique:</p>
<pre><code>def auto_init(ns):
    self = ns.pop('self')
    vars(self).update(ns)
</code></pre>
<p>And the just call <code>auto_init(locals())</code> from your <code>__init__</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It's a natural way to do things in Python. Don't try to invent something more clever, it will lead to overly clever code that no one on your team will understand. If you want to be a team player and then keep writing it this way.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3.7 onwards</h2>
<p>In Python 3.7, you may (ab)use the <a href="https://docs.python.org/3.7/library/dataclasses.html#module-dataclasses" rel="nofollow noreferrer"><code>dataclass</code></a> decorator, available from the <code>dataclasses</code> module.  From the documentation:</p>
<blockquote>
<p>This module provides a decorator and functions for automatically adding generated special methods such as <code>__init__()</code> and <code>__repr__()</code> to user-defined classes. It was originally described in PEP 557.</p>
<p>The member variables to use in these generated methods are defined using PEP 526 type annotations. For example this code:</p>
<pre><code>@dataclass
class InventoryItem:
    '''Class for keeping track of an item in inventory.'''
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self) -&gt; float:
        return self.unit_price * self.quantity_on_hand
</code></pre>
<p>Will add, among other things, a <code>__init__()</code> that looks like:</p>
<pre><code>def __init__(self, name: str, unit_price: float, quantity_on_hand: int=0):
      self.name = name
      self.unit_price = unit_price
      self.quantity_on_hand = quantity_on_hand
</code></pre>
<p>Note that this method is automatically added to the class: it is not directly specified in the InventoryItem definition shown above.</p>
</blockquote>
<p>If your class is large and complex, it <em>may</em> be inappropriate to use a <code>dataclass</code>.  I'm writing this on the day of release of Python 3.7.0, so usage patterns are not yet well established.</p>
</div>
<span class="comment-copy">Not all receptiveness is bad. Keep in mind that Python's class model doesn't include explicit definition of instance attributes, so these assignments are the self-documenting equivalents.</span>
<span class="comment-copy">@chepner: Well, doesn't <i>require</i> explicit definition. You can use <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer"><code>__slots__</code> for the purpose though</a>; it's mildly unpythonic (more verbose to get memory savings), but I like it largely to avoid the risk of auto-vivifying a whole new attribute if I typo the name.</span>
<span class="comment-copy">Any good editor will have templates. You type <code>ini &lt;shortcut&gt; x, y, z): &lt;shortcut&gt;</code> and you are done.</span>
<span class="comment-copy">Namedtuples are awesome, <i>if</i> you want an immutable value object. If you want a regular, mutable class, you can't use them.</span>
<span class="comment-copy">"Don't" is a good option, any option available will kill the method signature (and thus potentially the whole interface). Besides, if your classes have a unbearable amount of fields to initialize, you might want to consider splitting them.</span>
<span class="comment-copy">nice answer, but won't work with python2.7: no <code>signature</code></span>
<span class="comment-copy">@alexis the "decorator.decorator" decorator automatically wraps the function</span>
<span class="comment-copy">I'm quite torn about whether to love this or hate it. I do appreciate preserving the signature.</span>
<span class="comment-copy">"... Explicit is better than implicit. Simple is better than complex. ..." -Zen of Python</span>
<span class="comment-copy">-1 Quite frankly this is horrible. I have no idea what this code is doing at a glance, and it's literally ten times the amount of code. Being clever feels cool and all, but this is a misuse of your obvious cleverness.</span>
<span class="comment-copy">good answer +1 ... although <code>self.__dict__.update(kwargs)</code> might be marginally more pythonic</span>
<span class="comment-copy">The problem with this approach is that there is no record of what arguments <code>A.__init__</code> actually expects, and no error checking for mistyped argument names.</span>
<span class="comment-copy">@JoranBeasley Updating the instance dictionary blindly with <code>kwargs</code> leaves you open to the equivalent of an SQL injection attack. If your object has a method named <code>my_method</code> and you pass an argument named <code>my_method</code> to the constructor, then <code>update()</code> the dictionary, you just overwrote the method.</span>
<span class="comment-copy">As others said, the suggestion is really poor programming style. It hides crucial information. You can show it, but you should explicitely discourage the OP from using it.</span>
<span class="comment-copy">@Pedro Is there any semantic difference between gruzczy's and JoranBeasley's syntax?</span>
<span class="comment-copy">These <i>are</i> tuples, so your <code>properties</code> method can be written as just <code>return tuple(self)</code>, which is more maintainable if in future more fields are added to the namedtuple definition.</span>
<span class="comment-copy">Also, your namedtuple declaration string does not require commas between the fieldnames, <code>XYZ = namedtuple("XYZ", "x y z")</code> works just as well.</span>
<span class="comment-copy">Thanks @PaulMcGuire. I was trying to think of a really simple add-on to show the inheritance and kind of spaced on that. You're 100% right and it's a great shorthand with other inherited objects, too! I do mention the field names can be comma or space separated -- I prefer CSV from habit</span>
<span class="comment-copy">I often use <code>namedtuple</code>s for this exact purpose, especially in mathematical code where a function might be highly parametrised and have a bunch of coefficients that only make sense together.</span>
<span class="comment-copy">The problem with <code>namedtuple</code> is that they are read-only. You can not do <code>abc.x += 1</code> or anything like that.</span>
<span class="comment-copy">Then the object will need cyclic garbage collection since it has itself as an attribute</span>
<span class="comment-copy">thanks gribbler ... fixed :P</span>
<span class="comment-copy">that's gnibbler</span>
<span class="comment-copy">@bernie (or is it bemie?), sometimes ke  r ning is hard</span>
<span class="comment-copy">For slightly more efficient tests, <code>if k != "self":</code> could be changed to <code>if v is not self:</code>, cheap identity test, rather than string comparison. I suppose technically <code>__init__</code> could be called a second time after construction and passed <code>self</code> as a subsequent argument, but I really don't want to think what sort of monster would do that. :-)</span>
<span class="comment-copy">Why the downvote?</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/functions.html#locals" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#locals</a> <code>locals()</code> should not be modified (it may affect the interpreter, in your case, removing <code>self</code> from the calling function's scope)</span>
<span class="comment-copy">@MaxB From the docs you cite: <i>... changes may <b>not</b> affect the values of local and free variables used by the interpreter.</i> <code>self</code> is still available in <code>__init__</code> .</span>
<span class="comment-copy">Right, the reader expects it to affect the local variables, but it may or may <b>not</b>, depending on a number of circumstances. The point is that it's UB.</span>
<span class="comment-copy">Quote: "The contents of this dictionary should not be modified"</span>
<span class="comment-copy">@MaxB I added a version that does not change locals().</span>
<span class="comment-copy">To what degree is the functionaly of <code>attr</code> made redundant by <a href="https://docs.python.org/3.7/library/dataclasses.html#module-dataclasses" rel="nofollow noreferrer"><code>dataclasses</code></a>?</span>
<span class="comment-copy">@gerrit This is discussed in the <a href="https://www.attrs.org/en/stable/why.html#data-classes" rel="nofollow noreferrer">documentation of the attrs package</a>. Tbh, the differences don't seem that large anymore.</span>
<span class="comment-copy"><a href="https://docs.python.org/2/library/functions.html#locals" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#locals</a> <code>locals()</code> should not be modified (undefined behavior)</span>
