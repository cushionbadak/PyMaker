<div class="post-text" itemprop="text">
<p>I'm trying to parse command-line arguments such that the three possibilities below are possible:</p>
<pre><code>script
script file1 file2 file3 …
script -p pattern
</code></pre>
<p>Thus, the list of files is optional. If a <code>-p pattern</code> option is specified, then nothing else can be on the command line. Said in a "usage" format, it would probably look like this:</p>
<pre><code>script [-p pattern | file [file …]]
</code></pre>
<p>I thought the way to do this with Python's <code>argparse</code> module would be like this:</p>
<pre><code>parser = argparse.ArgumentParser(prog=base)
group = parser.add_mutually_exclusive_group()
group.add_argument('-p', '--pattern', help="Operate on files that match the glob pattern")
group.add_argument('files', nargs="*", help="files to operate on")
args = parser.parse_args()
</code></pre>
<p>But Python complains that my positional argument needs to be optional:</p>
<pre><code>Traceback (most recent call last):
  File "script", line 92, in &lt;module&gt;
    group.add_argument('files', nargs="*", help="files to operate on")
…
ValueError: mutually exclusive arguments must be optional
</code></pre>
<p>But the <a href="https://docs.python.org/3/library/argparse.html#nargs">argparse documentation</a> says that the <code>"*"</code> argument to <code>nargs</code> meant that it is optional.</p>
<p>I haven't been able to find any other value for <code>nargs</code> that does the trick either. The closest I've come is using <code>nargs="?"</code>, but that only grabs one file, not an optional list of any number.</p>
<p>Is it possible to compose this kind of argument syntax using <code>argparse</code>?</p>
</div>
<div class="post-text" itemprop="text">
<h2>short answer</h2>
<p>Add a <code>default</code> to the <code>*</code> positional</p>
<h2>long</h2>
<p>The code that is raising the error is, </p>
<pre><code>    if action.required:
        msg = _('mutually exclusive arguments must be optional')
        raise ValueError(msg)
</code></pre>
<p>If I add a * to the parser, I see that the <code>required</code> attribute is set:</p>
<pre><code>In [396]: a=p.add_argument('bar',nargs='*')
In [397]: a
Out[397]: _StoreAction(option_strings=[], dest='bar', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
In [398]: a.required
Out[398]: True
</code></pre>
<p>while for a <code>?</code> it would be False.  I'll have dig a bit further in the code to see why the difference.  It could be a bug or overlooked 'feature', or there might a good reason.  A tricky thing with 'optional' positionals is that no-answer is an answer, that is, an empty list of values is valid.</p>
<pre><code>In [399]: args=p.parse_args([])
In [400]: args
Out[400]: Namespace(bar=[], ....)
</code></pre>
<p>So the mutually_exclusive has to have some way to distinguish between a default <code>[]</code> and real <code>[]</code>.</p>
<p>For now I'd suggest using <code>--files</code>, a flagged argument rather than a positional one if you expect <code>argparse</code> to perform the mutually exclusive testing.</p>
<hr/>
<p>The code that sets the <code>required</code> attribute of a positional is:</p>
<pre><code>    # mark positional arguments as required if at least one is
    # always required
    if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:
        kwargs['required'] = True
    if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:
        kwargs['required'] = True
</code></pre>
<p>So the solution is to specify a default for the <code>*</code></p>
<pre><code>In [401]: p=argparse.ArgumentParser()
In [402]: g=p.add_mutually_exclusive_group()
In [403]: g.add_argument('--foo')
Out[403]: _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type=None, choices=None, help=None, metavar=None)
In [404]: g.add_argument('files',nargs='*',default=None)
Out[404]: _StoreAction(option_strings=[], dest='files', nargs='*', const=None, default=None, type=None, choices=None, help=None, metavar=None)
In [405]: p.parse_args([])
Out[405]: Namespace(files=[], foo=None)
</code></pre>
<p>The default could even be <code>[]</code>.  The parser is able to distinguish between the default you provide and the one it uses if none is given.</p>
<p>oops - <code>default=None</code> was wrong.  It passes the <code>add_argument</code> and <code>required</code> test, but produces the mutually_exclusive error.  Details lie in how the code distinguishes between user defined defaults and the automatic ones.  So use anything but <code>None</code>.</p>
<p>I don't see anything in the documentation about this.  I'll have to check the bug/issues to see it the topic has been discussed.  It's probably come up on SO before as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to use the 'files' argument to catch a number of files but you are not supplying it on the cmdline examples. I think the library gets confused that you're not using the dash prefix. I would suggest the following:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser(prog="base")
group = parser.add_mutually_exclusive_group()
group.add_argument('-p', '--pattern', action="store", help="Operate on files that match the glob pattern")
group.add_argument('-f', '--files',  nargs="*", action="store", help="files to operate on")

args = parser.parse_args()
print args.pattern
print args.files
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>    import argparse
    parse  = argparse.ArgumentParser()
    parse.add_argument("-p",'--pattern',help="Operates on File")
    parse.add_argument("files",nargs = "*",help="Files to operate on")

    arglist = parse.parse_args(["-p","pattern"])
    print arglist
    arglist = parse.parse_args()
    print arglist
    arglist = parse.parse_args(["file1","file2","file3"])
    print arglist
</code></pre>
</div>
<span class="comment-copy">Might there be a way to do this with "subparsers"? <a href="https://docs.python.org/2/library/argparse.html#sub-commands" rel="nofollow noreferrer">docs.python.org/2/library/argparse.html#sub-commands</a></span>
<span class="comment-copy">Not a bad idea, @mac. Subparsers do seem to operate independently of one another. But my quick reading of the documentation suggests to me that the choice of which subparser is invoked is done by an earlier positional argument. (They use the example of parameters to the <code>svn</code> command.) I don't have any such selection mechanism I could use here in the desired command line arguments.</span>
<span class="comment-copy">yeah, this seems to be a major limitation; too bad there isn't support for a "default" subparser that would be used when the args don't contain any of the other named subparsers</span>
<span class="comment-copy">NIce, but even adding <code>default=None</code> to the <code>files</code> positional argument, I still get an error if I run <code>p.parse_args(["-p", "foo"])</code>: <code>error: argument files: not allowed with argument -p/--pattern</code></span>
<span class="comment-copy">I had more success with <code>default=[]</code></span>
<span class="comment-copy">Yes, <code>default=[]</code> seems to be helping. Lemme do a bit more testing. This may have done the trick.</span>
<span class="comment-copy">That did the trick entirely. Adding <code>default=[]</code> to the argument with the <code>nargs="*"</code> gives the right result in all cases.</span>
<span class="comment-copy">With <code>None</code>, you are getting the mutually_exclusive error.  It's result of how it tests for user given defaults v automatic ones.  So anything but <code>None</code> is needed.</span>
<span class="comment-copy">I don't want to use a dash prefix. I want them all to be positional arguments.</span>
<span class="comment-copy">Yes, but <code>arglist = parse.parse_args(["-p", "pattern", "file1","file2","file3"])</code> should give an error, and it does not.</span>
<span class="comment-copy">Namespace(files=['file1', 'file2', 'file3'], pattern='pattern')                           It wont give any error as optional argument "-p" by default takes one argument so (pattern ='pattern') and rest arguments will assigned to positional argument (files = ['file1','file2','file3'])</span>
<span class="comment-copy">Exactly. Because you skipped the mutually exclusive group, argparse is not throwing an error for <code>-p pat file1 file2 file3</code> as it should.</span>
