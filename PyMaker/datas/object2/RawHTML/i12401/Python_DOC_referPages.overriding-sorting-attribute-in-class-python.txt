<div class="post-text" itemprop="text">
<p>I would like to use bisect (as shown here, in the second answer: <a href="https://stackoverflow.com/questions/1109804/does-python-have-a-sorted-list">Does python have a sorted list?</a>),
but instead of using a list of numbers, I have a list of objects. In specific, objects from this class: <a href="https://networkx.github.io/documentation/latest/_modules/networkx/classes/graph.html" rel="nofollow noreferrer">https://networkx.github.io/documentation/latest/_modules/networkx/classes/graph.html</a></p>
<p>I would like the list to keep the graphs sorted by their number of nodes.
If I push these graphs into the list, it looks like it is being inserted in an arbitrary way, (If I run it many times, it changes between the runs).</p>
<p>Is there "sort" function that each class can define, that when applying sorting it will be used (like operator overriding in other languages) ?</p>
<pre><code>import bisect
import networkx as nx

L=[]
G1 = nx.Graph()
G2 = nx.Graph()

G1.add_edges_from([(1,2),(1,3),(2,3),(3,4),(4,5),(4,6),(5,6),(4,7),(7,8),(7,9),(8,9)])
print 'G1', G1.number_of_nodes()
G2.add_edges_from([(1,2),(1,3)])
print 'G2', G2.number_of_nodes()

bisect.insort(L,G1)
bisect.insort(L,G2)

print 'L0 ', L[0].number_of_nodes()
print 'L1' ,L[1].number_of_nodes()
</code></pre>
<p>If there's another way of doing that, it would be great to.</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The somewhat arbitrary order of your list is due to the fact that objects are ordered by <a href="https://docs.python.org/3.3/library/functions.html#id" rel="nofollow">id</a> (which is derived from the RAM address of the object in CPython) unless they provide some other way to define an ordering.</p>
<p>The easy way to solve your problem is to simply use the built-in <code>list.sort</code> method (or the <code>sorted</code> function), passing <code>key=len</code> as the key function argument.</p>
<p>However, if you want to use <code>bisect</code> to maintain a sorted list, you can do that too, but your class needs to define the <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow">Rich Comparison methods</a>. </p>
<p>You <em>could</em> add these methods to your graph class, but it may be easier (and cleaner) to define a new class as a wrapper.</p>
<p>Here's a simple example that wraps the built-in <code>list</code> type. It defines a private method, <code>_cmp</code> to perform length-based comparisons, and the Rich Comparison "magic" methods call <code>_cmp</code>. For greater efficiency, the Rich Comparison methods <em>should</em> be defined directly, to avoid calling another method, but using <code>_cmp</code> is easier to read (and to write :) ).</p>
<pre><code>import bisect

class MyList(object):
    def __init__(self, data):
        self.data = data

    def __repr__(self):
        return 'MyList({0!r})'.format(self.data)

    def _cmp(self, other):
        return len(self.data) - len(other.data)

    #Rich comparison methods
    def __lt__(self, other):
        return self._cmp(other) &lt; 0

    def __le__(self, other):
        return self._cmp(other) &lt;= 0

    def __eq__(self, other):
        return self._cmp(other) == 0

    def __ne__(self, other):
        return self._cmp(other) != 0

    def __ge__(self, other):
        return self._cmp(other) &gt;= 0

    def __gt__(self, other):
        return self._cmp(other) &gt; 0


data = (
    [50, 60],
    [10, 20, 30],
    [1, 2, 3, 4, 5],
    [5, 6],
    [7, 8, 9, 10],
)

blist = []
for seq in data:
    a = MyList(seq)
    bisect.insort(blist, a)
    print(a)
    print(blist)
    print()    
</code></pre>
<p><strong>output</strong></p>
<pre><code>MyList([50, 60])
[MyList([50, 60])]

MyList([10, 20, 30])
[MyList([50, 60]), MyList([10, 20, 30])]

MyList([1, 2, 3, 4, 5])
[MyList([50, 60]), MyList([10, 20, 30]), MyList([1, 2, 3, 4, 5])]

MyList([5, 6])
[MyList([50, 60]), MyList([5, 6]), MyList([10, 20, 30]), MyList([1, 2, 3, 4, 5])]

MyList([7, 8, 9, 10])
[MyList([50, 60]), MyList([5, 6]), MyList([10, 20, 30]), MyList([7, 8, 9, 10]), MyList([1, 2, 3, 4, 5])]
</code></pre>
<p>You may like to take a look at <a href="https://docs.python.org/3/library/heapq.html#module-heapq" rel="nofollow"><code>heapq</code></a>: you may find it better for your purposes than <code>bisect</code>. <code>heapq</code> will (of course) use the Rich Comparison methods if they are defined.</p>
</div>
<span class="comment-copy">Something like that may also be ok: L_sort = sorted(L, key=L.__len__)</span>
<span class="comment-copy">Got it:    L_sort = sorted(L, key=lambda graph: graph.number_of_nodes())</span>
<span class="comment-copy">Or more simply <code>L_sort = sorted(L, key=Graph.number_of_nodes)</code>. But this is equivalent to <code>L_sort = sorted(L, key=len)</code> given <code>Graph</code> implements <code>__len__</code>. You need to reference the class method not instance, so in your first comment <code>Graph.__len__</code> would also have worked.</span>
<span class="comment-copy">Do you need to maintain the list in sorted order, or is it satisfactory to simple sort it after you've added all the graphs to it?</span>
<span class="comment-copy">it is enough for me to sort it after I add, since the list shouldn't be very long. Thanks for your answer. The Rich Comparison Methods were actually something I was looking for, but didn't know of (it's good to know its out there).</span>
