<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3460161/remove-adjacent-duplicate-elements-from-a-list">Remove adjacent duplicate elements from a list</a>
<span class="question-originals-answer-count">
                    17 answers
                </span>
</li>
</ul>
</div>
<p>Is there a way to use list comprehensions in python to filter <strong>adjacent</strong> duplicates from a list?</p>
<p>Here's an example of what I mean:</p>
<pre><code>&gt;&gt;&gt; xs = [1,2,2,3]
&gt;&gt;&gt; print added.reAdj(xs)
[1,2,3]
</code></pre>
<p>A search through SE revealed an <a href="https://stackoverflow.com/questions/23881352/python-list-comprehension-remove-duplicates">earlier inquiry</a> asking a <em>similar</em> but slightly different question: whether all duplicates could be removed from a list, <strong>but not explicitly asking for solutions involving list comprehensions</strong>. The motivation for using list comprehensions specifically follows a recognition of <a href="https://stackoverflow.com/questions/16341775/what-is-the-advantage-of-a-list-comprehension-over-a-for-loop">their advantages over traditional for loops</a>.  Users suggested the use of the set() function or standard looping as such:</p>
<pre><code>result = []
most_recent_elem = None
for e in xs:
    if e != most_recent_elem:
        result.append(e)
        most_recent_elem = e
</code></pre>
<p>The <code>set()</code> suggestion fails to meet the task in that non-adjacent duplicates are removed, while the loop is effective but verbose.</p>
<p>It seems a means for safely referencing the next element in a list comprehension as follows is needed.</p>
<pre><code>[x for x in xs if x != **x.next()**]
</code></pre>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions"><code>list comprehension</code></a> and <a href="https://docs.python.org/3/library/functions.html#enumerate"><code>enumerate</code></a> with solution suggested by @AChampion:</p>
<pre><code>xs = [1,2,2,2,1,1]
In [115]: [n for i, n in enumerate(xs) if i==0 or n != xs[i-1]]
Out[115]: [1, 2, 1]
</code></pre>
<p>That list comprehension return item if it's first or for the following if it's not equal to previous. It'll work due to lazy evaluations of <code>if</code> statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby"><code>itertools.groupby</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; [key for key, grp in itertools.groupby([1, 2, 2, 3])]
[1, 2, 3]
</code></pre>
<hr/>
<p><code>itertools.groupby</code> returns an iterator. By iterating it, you will get a key, group pairs. (<code>key</code> will be a item if no <code>key</code> function is specified, otherwise the return value of the <code>key</code> function). <code>group</code> is an iterator which will yields items grouped by applying <code>key</code> function (if not specified, same values will be grouped)</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; it = itertools.groupby([1, 2, 2, 3])
&gt;&gt;&gt; it
&lt;itertools.groupby object at 0x7feec0863048&gt;
&gt;&gt;&gt; for key, grp in it:
...     print(key)
...     print(grp)
... 
1
&lt;itertools._grouper object at 0x7feec0828ac8&gt;
2
&lt;itertools._grouper object at 0x7feec0828b00&gt;
3
&lt;itertools._grouper object at 0x7feec0828ac8&gt;
&gt;&gt;&gt; it = itertools.groupby([1, 2, 2, 3])
&gt;&gt;&gt; for key, grp in it:
...     print(list(grp))
... 
[1]
[2, 2]
[3]
</code></pre>
<p>Above solution, I used only <code>key</code> because the question does not care how many items are adjacent.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using pairwise from the itertools recipes (with zip_longest) gives you an easy way of checking the next element:</p>
<pre><code>import itertools as it

def pairwise(iterable):
    a, b = it.tee(iterable)
    next(b, None)
    return it.zip_longest(a, b, fillvalue=object())   # izip_longest for Py2

&gt;&gt;&gt; xs = [1,2,2,3]
&gt;&gt;&gt; [x for x, y in pairwise(xs) if x != y]
[1, 2, 3]
&gt;&gt;&gt; xs = [1,2,2,2,2,3,3,3,4,5,6,6]
&gt;&gt;&gt; [x for x, y in pairwise(xs) if x != y]
[1, 2, 3, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a less verbose loop solution:</p>
<pre><code>&gt;&gt;&gt; result = xs[:1]
&gt;&gt;&gt; for e in xs:
        if e != result[-1]:
            result.append(e)
</code></pre>
<p>Or:</p>
<pre><code>&gt;&gt;&gt; result = []
&gt;&gt;&gt; for e in xs:
        if e not in result[-1:]:
            result.append(e)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>&gt;&gt;&gt; l = [1,1,2,3,4,4,4,4,5,6,3,3,5,5,7,8,8,8,9,1,2,3,3,3,10,10]
&gt;&gt;&gt; 
&gt;&gt;&gt; o = []
&gt;&gt;&gt; p = None
&gt;&gt;&gt; for n in l:
        if n == p:
            continue
        o.append(n)
        p = n    

&gt;&gt;&gt; o
[1, 2, 3, 4, 5, 6, 3, 5, 7, 8, 9, 1, 2, 3, 10]
</code></pre>
<p>Apparently, above solution is more verbose than OP's, so here is an alternative to that using <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools#itertools.zip_longest" rel="nofollow"><code>zip_longest</code></a> from <code>itertools</code> module:</p>
<pre><code>&gt;&gt;&gt; l
[1, 1, 2, 3, 4, 4, 4, 4, 5, 6, 3, 3, 5, 5, 7, 8, 8, 8, 9, 1, 2, 3, 3, 3, 10, 10]
&gt;&gt;&gt; from itertools import zip_longest
&gt;&gt;&gt; o = [p for p,n in zip_longest(l,l[1:]) if p != n] #By default fillvalue=None
&gt;&gt;&gt; o
[1, 2, 3, 4, 5, 6, 3, 5, 7, 8, 9, 1, 2, 3, 10]
</code></pre>
</div>
<span class="comment-copy">Does this mean even <code>[1,2,2,2,2,3,3,3,4,5,6,6] --&gt; [1,2,3,4,5,6]</code> ?</span>
<span class="comment-copy">@IronFist, you understand correctly. That's the desired result.</span>
<span class="comment-copy">@Achampion. Thanks for the link, but as far as I can tell, the poster doesn't ask specifically for an answer involving list comprehensions. My original question post included a loop solution.</span>
<span class="comment-copy">@AntonProtopopov. Please update when you make progress. Its unfortunate that the case that Stefan Pochmann brought up doesn't work because your solution otherwise is very elegant IMO.</span>
<span class="comment-copy">@AntonProtopopov - <b>Please</b>, please, please incorporate AChampion's suggested fix into your answer. This is so much better than an inscrutable call to some inscrutable function in <code>itertools</code> whose documentation is in turn inscrutable.</span>
<span class="comment-copy">@DavidHammen <code>groupby</code> is easy and perfectly alright, you shouldn't blame it for your own deficiency.</span>
<span class="comment-copy">@AntonProtopopov - And now you get a minus one. As everyone knows,<code>xs[-1]</code> refers to the last element of an array in python. If you do not correct for this, your answer is flat out wrong.</span>
<span class="comment-copy">Seems as if the bug is clear. I'll accept this answer pending any additional problems people suggest over the next few hours.</span>
<span class="comment-copy">It's so strange to see <code>groupby</code> used without a sorted input, but I guess this is actually appropriate in this particular use case.</span>
<span class="comment-copy">Same here it confused me at first</span>
<span class="comment-copy">Slight nitpick: It removes trailing <code>None</code> values.</span>
<span class="comment-copy">Noted: but not an issue with a list of ints. And can be avoided with adding a <code>fillvalue</code> to <code>zip_longest</code>, fixed!</span>
<span class="comment-copy">It works but it's exactly the same logic as the OP, except being slightly more verbose.</span>
<span class="comment-copy">@AlexanderHuszagh .. yep...I forgot about that point <i>verbosity</i></span>
<span class="comment-copy">Updated .. using <code>zip_longest</code></span>
