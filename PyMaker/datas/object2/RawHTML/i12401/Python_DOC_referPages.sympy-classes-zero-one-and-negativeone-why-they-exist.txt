<div class="post-text" itemprop="text">
<p>Today I found this</p>
<pre><code>&gt;&gt;&gt; type(1)
&lt;class 'sympy.core.numbers.One'&gt;
&gt;&gt;&gt; type(0)
&lt;class 'sympy.core.numbers.Zero'&gt;
&gt;&gt;&gt; type(-1)
&lt;class 'sympy.core.numbers.NegativeOne'&gt;
&gt;&gt;&gt; type(2)
&lt;class 'sympy.core.numbers.Integer'&gt;
</code></pre>
<p>I looked the <a href="http://docs.sympy.org/dev/modules/core.html#zero">documentation from sympy</a> about those types, but it doesn't say anything about why they exist. Is there a reason to have 3 special singleton classes for -1, 0 and 1? </p>
<p>Edit: I saw this at the <a href="http://live.sympy.org/">SymPy online shell</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Every number in SymPy is represented by an instance of <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L313" rel="nofollow">the class
<code>Number</code></a>.
<code>Float</code>s, <code>Integer</code>s and <code>Rational</code>s are subclasses of <code>Number</code>. <code>Zero</code> is a
subclass of <code>Integer</code>.</p>
<p>You can inspect the full class lineage of an object by calling its class's <code>mro</code> (method resolution order) method:</p>
<pre><code>In [34]: from sympy import S
In [38]: type(S.Zero).mro()
Out[38]: 
[sympy.core.numbers.Zero,
 sympy.core.numbers.IntegerConstant,
 sympy.core.numbers.Integer,            &lt;-- Zero is a kind of Integer
 sympy.core.numbers.Rational,
 sympy.core.numbers.Number,
 sympy.core.expr.AtomicExpr,
 sympy.core.basic.Atom,
 sympy.core.expr.Expr,
 sympy.core.basic.Basic,
 sympy.core.evalf.EvalfMixin,
 object]
</code></pre>
<p>These subclasses "teach" SymPy how to manipulate and simplify expressions symbolically. As a
example, instances of the Rational class are <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L1368" rel="nofollow">negated this
way</a>:</p>
<pre><code>def __neg__(self):
    return Rational(-self.p, self.q)
</code></pre>
<p>That is to say, if <code>x</code> is an instance of <code>Rational</code>, then <code>-x</code> causes <a href="https://docs.python.org/3/reference/datamodel.html#object.__neg__" rel="nofollow"><code>x.__neg__()</code></a> to be called. Meanwhile, instances of the <code>Integer</code> class, are <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L1776" rel="nofollow">negated by</a></p>
<pre><code>def __neg__(self):
    return Integer(-self.p)
</code></pre>
<p>And if the object is, in particular, an instance of <code>Zero</code>, then <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L2228" rel="nofollow">its negation</a> is
defined by:</p>
<pre><code>@staticmethod
def __neg__():
    return S.Zero    # the negation of Zero is still Zero
</code></pre>
<p><code>Zero</code>, <code>One</code> and <code>MinusOne</code> also implement a <code>_eval_power</code> method which
"teaches" these objects how to evaluate <code>x</code> raised to a power (where <code>x</code> is
<code>Zero</code>, <code>One</code> or <code>MinusOne</code>). For example, <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L2232" rel="nofollow"><code>Zero</code> raised to a positive
expression</a> equals itself:</p>
<pre><code>def _eval_power(self, expt):
    if expt.is_positive:
        return self
    ...
</code></pre>
<p><a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L2290" rel="nofollow"><code>One</code> raised to anything</a> equals itself: </p>
<pre><code>def _eval_power(self, expt):
    return self
</code></pre>
<p>If you peruse <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py" rel="nofollow">the source code</a> for the <code>sympy.core.numbers</code> module, you'll find
loads of definitions which are in effect teaching SymPy how to do symbolic
arithmetic. It's not too different from what children are taught in math class, except that it is expressed in computer-ese.</p>
<p>You might be wondering why there isn't a special class for every integer.
<code>Integers</code> besides <code>Zero</code>, <code>One</code> and <code>MinusOne</code> are treated as instances of the
general <code>Integer</code> class. Their rules of addition and multiplication and so on are laid out there. Unlike <code>Zero</code>, <code>One</code> and <code>MinusOne</code> which are instantated when the module is loaded, other Integers are cached <a href="https://github.com/sympy/sympy/blob/master/sympy/core/numbers.py#L1742" rel="nofollow">only as needed</a>:</p>
<pre><code>def __new__(cls, i):
    ...
    try:
        return _intcache[ival]   # &lt;-- return the cached Integer if seen before
    except KeyError:           
        obj = Expr.__new__(cls)  # &lt;-- create a new Integer if ival not in _intcache
        obj.p = ival

        _intcache[ival] = obj
        return obj
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, note that <code>type(1)</code> gave you <code>type(Integer(1))</code> because SymPy Live wraps integer literals in <code>Integer()</code> automatically (this is to avoid a <a href="http://docs.sympy.org/latest/tutorial/gotchas.html" rel="nofollow">gotcha</a> where <code>1/2</code> evaluates to <code>0.5</code> instead of <code>Rational(1, 2)</code>). But note that in a regular Python session <code>type(1)</code> is <code>int</code>. </p>
<p>There are several objects in SymPy which are implemented as singletons, meaning only one instance will ever exist. You can see these all on the <code>S</code> object</p>
<pre><code>In [13]: dir(S)
Out[13]:
['Catalan',
 'ComplexInfinity',
 'Complexes',
 'EulerGamma',
 'Exp1',
 'GoldenRatio',
 'Half',
 'IdentityFunction',
 'ImaginaryUnit',
 'Infinity',
 'NaN',
 'Naturals0',
 'NegativeInfinity',
 'NegativeOne',
 'One',
 'Pi',
 'Reals',
 'Zero',
 '__call__',
 '__class__',
 '__delattr__',
 '__doc__',
 '__format__',
 '__getattr__',
 '__getattribute__',
 '__hash__',
 '__init__',
 '__module__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__slots__',
 '__str__',
 '__subclasshook__',
 '_classes_to_install',
 'false',
 'register',
 'true']
</code></pre>
<p>(ignore the ones that start with <code>_</code>; those are Python internal methods)</p>
<p>The reason this is done is that these objects are used a lot. 0, 1, and -1 are very common objects. Every time you write <code>1/x</code> it is represented internally as <code>Pow(x, -1)</code>. <code>x - y</code> is represented as <code>Add(x, Mul(-1, y))</code>. For 0, it appears quite often in all sorts of symbolic calculations. 1 is also common. By having a single instance, SymPy enables two optimizations. First, it saves memory. Second, you can compare against these objects using <code>is</code> comparison, like <code>x is S.One</code>. Because only one instance can ever exist <code>Integer(1)</code> is always the same as <code>S.One</code>. </p>
<p>(also, I should note that some of the objects in <code>S</code> aren't actually that common, like <code>Catalan</code> and <code>EulerGamma</code>. I guess they were added more for convenience than anything)</p>
</div>
<span class="comment-copy">What the heck did you do to get <code>type(1)</code> to be anything other than <code>int</code>?</span>
<span class="comment-copy">@user2357112 just imported sympy module</span>
<span class="comment-copy">Importing sympy won't screw with the parser like that. <code>type(1)</code> will always construct an actual Python integer and take its type, which will be <code>int</code>.</span>
<span class="comment-copy">I tried it in their <a href="http://live.sympy.org/" rel="nofollow noreferrer">online shell</a></span>
<span class="comment-copy">Looks like their online shell's setup is more extensive than it says; <a href="https://github.com/sympy/sympy/blob/master/sympy/interactive/session.py" rel="nofollow noreferrer">it actually does hook into the parser</a>, among other things.</span>
<span class="comment-copy">Wow, excellent answer. Just one more question, the fact that other integers beside <code>Zero</code>, <code>One</code> and <code>NegativeOne</code> are cached on demand is the reason why it always returns the same memory address (with <code>id</code> function)? It's somekind of "singletoning" every Integer instance?</span>
<span class="comment-copy">Yes. <code>_intcache</code> is a (private) <code>dict</code> which maps Python integers to SymPy <code>Integer</code>s. Whenever an <code>Integer</code> is instantiated, <code>_intcache</code> is checked first. If the integer already exists as a key in <code>_intcache</code>, then that <code>Integer</code> is returned.</span>
<span class="comment-copy">The int auto-wrapping sure makes the "Run code block in SymPy Live" links for that particular gotcha pretty silly, though. SymPy Live does the opposite of the behavior the documentation is trying to explain.</span>
<span class="comment-copy">Ha good point. I opened <a href="https://github.com/sympy/sympy/issues/10484" rel="nofollow noreferrer">github.com/sympy/sympy/issues/10484</a>.</span>
