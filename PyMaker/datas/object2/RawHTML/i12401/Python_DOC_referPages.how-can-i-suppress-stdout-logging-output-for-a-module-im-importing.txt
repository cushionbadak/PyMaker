<div class="post-text" itemprop="text">
<p>I'm importing a module <code>foo</code> which uses Python's <code>logging</code> module. However, <code>foo</code> produces a huge amount of logging output, and I need to use <code>stdout</code> to communicate important information to the user, which is largely being drowned out by the ridiculous output of the module I'm importing.</p>
<p>How can I disable the module's ability to log to <code>stdout</code> without modifying <code>foo</code>'s code? I still want it to log to the files it logs to, but I don't want it logging to <code>stdout</code>.</p>
<p>I have tried the following:</p>
<p><code>logging.getLogger("foo").propagate = False</code></p>
<p>and</p>
<pre><code>@contextlib.contextmanager
def nostdout():
    class DummyFile(object):
        def write(self, x): pass
    save_stdout = sys.stdout
    sys.stdout = DummyFile()
    yield
    sys.stdout = save_stdout

with nostdout(): import foo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://eli.thegreenplace.net/2015/redirecting-all-kinds-of-stdout-in-python/" rel="nofollow">I'm referencing this article.</a>
In general, if you want to capture anything written to <code>stdout</code> you can use the <code>contextlib</code> in Python 3:</p>
<pre><code>from contextlib import redirect_stdout

f = io.StringIO()
with redirect_stdout(f):
    print('foobar')
    call_annoying_module()
print('Stdout: "{0}"'.format(f.getvalue()))
</code></pre>
<p>On Python 3.4 and older, <code>redirect_stdout</code> can be implemented like this:</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def stdout_redirector(stream):
    old_stdout = sys.stdout
    sys.stdout = stream
    try:
        yield
    finally:
        sys.stdout = old_stdout
</code></pre>
<p>If the library has any C bindings that print using <code>puts</code> then it gets more complicated. See the article.</p>
<p>The easiest case is when you're running another program using <code>subprocess</code>,
then all <code>stdout</code> output can be easily captured.</p>
<pre><code>proc = subprocess.Popen("echo output".split(), stdout=subprocess.PIPE)
std_output, err_output = proc.communicate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try the following:</p>
<pre><code>logging.getLogger(&lt;logger_name_used_in_foo&gt;).propagate = False
</code></pre>
</div>
<span class="comment-copy">Does module <code>foo</code> configure the logging itself? If it is a library it should not. Then you can simply configure logging to go to a file instead of stdout.  <a href="https://docs.python.org/3/library/logging.config.html#module-logging.config" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">It is a library. Sadly all libraries are not well-written, and this one does configure the logging itself.</span>
<span class="comment-copy">I'll give this a shot, but a previous user posted something similar to this (using a context manager and manually redirecting stdout to a dummy file), but that didn't work.</span>
<span class="comment-copy">I see. If all else fails and if it's possible to call the module as a separate program, see my recent edit at the bottom of the post.</span>
<span class="comment-copy">Oh, sorry, using Python2.7 so this doesn't work generally.</span>
<span class="comment-copy">I'm not entirely sure how your subprocess example works. I need to be able to use objects from the module I'm importing.</span>
<span class="comment-copy">Ok, nevermind the subprocess example. On Python 2 you can implement redirect_stdout on your own. See edits.</span>
<span class="comment-copy">Nope, this doesn't work.</span>
<span class="comment-copy">What kind of library are you using?</span>
<span class="comment-copy">Can you clarify your question? It's a data retrieval module.</span>
<span class="comment-copy">I've updated my answer. What is the name of the logger which is used in the "foo" module?</span>
