<div class="post-text" itemprop="text">
<p>There are <a href="https://stackoverflow.com/q/12674167/647991">some</a> <a href="https://stackoverflow.com/q/7728371/647991">related</a> questions, but none apply.</p>
<p>This is my directory tree:</p>
<pre><code>» tree abc_backend
abc_backend/
├── backend_main.py
├── FundDatabase.db
├── healthcheck.py
├── __init__.py
├── init.py
├── portfolio.py
├── private.py
├── __pycache__
├── questionnaire.py
├── recurring.py
├── registration.py
├── tests
│   ├── config.py
│   ├── __init__.py
│   ├── __pycache__
│   ├── test_backend.py
│   ├── test_healthcheck.py
│   └── test_private.py
├── trading.py
├── Users.db
├── VERSION
└── visualisation.py
</code></pre>
<p><code>unittest</code> is not able to find anything:</p>
<pre><code>top » python -m unittest abc_backend

----------------------------------------------------------------------
Ran 0 tests in 0.000s

OK
</code></pre>
<p>Not even from within <code>abc_backend</code>:</p>
<pre><code>abc_backend » python -m unittest tests

----------------------------------------------------------------------
Ran 0 tests in 0.000s

OK
</code></pre>
<p>What I have already verified:</p>
<ul>
<li>my test methods are properly named (<code>test_whatever</code>)</li>
<li>my testcases extend <code>unittest.TestCase</code></li>
<li>the <code>abc_backend</code> and the <code>abc_backend/tests</code> directories have an (empty) <code>__init__.py</code></li>
<li>all test modules are importable (see below)</li>
<li><code>unittest discover</code> finds the tests, but has problems with relative imports (see below)</li>
<li><code>nose</code> is able to discover and run the tests, no problems</li>
</ul>
<p>I would like to understand:</p>
<ul>
<li>why do I need to pass <code>discover</code> to <code>unittest</code> to force it to discover the tests? What does <code>unittest</code> do without the <code>discover</code> sub-command? (I thought unittest does test discovery by default). According to the <a href="https://docs.python.org/3.4/library/unittest.html#test-discovery" rel="noreferrer">documentation</a>: </li>
</ul>
<blockquote>
<p>python -m unittest is the equivalent of python -m unittest discover</p>
</blockquote>
<ul>
<li>once the tests are discovered (by forcing the <code>discover</code> sub-command), why do I have import issues?</li>
</ul>
<h2>Test modules are importable</h2>
<pre><code>» python
Python 3.4.3 (default, Oct 14 2015, 20:28:29) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import abc_backend.tests
&gt;&gt;&gt; import abc_backend.tests.test_private
&gt;&gt;&gt; import abc_backend.tests.test_healthcheck
&gt;&gt;&gt; import abc_backend.tests.test_backend
</code></pre>
<h2>unittest discover has problems with relative imports</h2>
<p>If I run it from the top dir:</p>
<pre><code>top » python -m unittest discover abc_backend
======================================================================
ERROR: tests.test_private (unittest.loader.ModuleImportFailure)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/lib/python3.4/unittest/case.py", line 58, in testPartExecutor
    yield
  File "/usr/lib/python3.4/unittest/case.py", line 577, in run
    testMethod()
  File "/usr/lib/python3.4/unittest/loader.py", line 32, in testFailure
    raise exception
ImportError: Failed to import test module: tests.test_private
Traceback (most recent call last):
  File "/usr/lib/python3.4/unittest/loader.py", line 312, in _find_tests
    module = self._get_module_from_name(name)
  File "/usr/lib/python3.4/unittest/loader.py", line 290, in _get_module_from_name
    __import__(name)
  File "/foo/bar/abc_backend/tests/test_private.py", line 6, in &lt;module&gt;
    from .. import init
ValueError: attempted relative import beyond top-level package
</code></pre>
<p>If I run it from within <code>abc_backend</code>:</p>
<pre><code>abc_backend » python -m unittest discover tests

======================================================================
ERROR: test_private (unittest.loader.ModuleImportFailure)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/lib/python3.4/unittest/case.py", line 58, in testPartExecutor
    yield
  File "/usr/lib/python3.4/unittest/case.py", line 577, in run
    testMethod()
  File "/usr/lib/python3.4/unittest/loader.py", line 32, in testFailure
    raise exception
ImportError: Failed to import test module: test_private
Traceback (most recent call last):
  File "/usr/lib/python3.4/unittest/loader.py", line 312, in _find_tests
    module = self._get_module_from_name(name)
  File "/usr/lib/python3.4/unittest/loader.py", line 290, in _get_module_from_name
    __import__(name)
  File "/foo/bar/abc_backend/tests/test_private.py", line 6, in &lt;module&gt;
    from .. import init
SystemError: Parent module '' not loaded, cannot perform relative import
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I reproduced all the problems with CPython 3.5, so my answer should
be relevant to both 3.4 and 3.5.</p>
<h2>Relative import issues</h2>
<p>The reason why there are issues with relative imports is that due to
specifics of invocations you really do not import <code>abc_backend</code> package.</p>
<p>First, let’s take a look at </p>
<pre><code>top» python3 -m unittest discover abc_backend
</code></pre>
<p>When you run tests from top that way, <code>abc_backend</code> is just not imported.
That is because <code>/home/user/top/abc_backend</code> is added to sys.path instead
of <code>/home/user/top</code>. To solve this problem, do</p>
<pre><code>top» python3 -m unittest discover abc_backend -t .
</code></pre>
<p>Now, about the in-abc_backend invocation. When you do</p>
<pre><code>abc_backend» python3 -m unittest discover tests
</code></pre>
<p><code>abc_backend</code> is not importable, as <code>/home/user/top/abc_backend/tests</code>
dir does not contain <code>abc_backend</code> package. This too can be solved with</p>
<pre><code>abc_backend» python3 -m unittest discover tests -t ../
</code></pre>
<p>that will correctly put <code>/home/user/top</code> dir (pun intended) into <code>sys.path</code>.</p>
<p>The <code>-t</code> (or <code>--top-level-directory</code>) option sets top level directory
of project and defaults to start directory (which is <code>.</code> by default).
So, what is in <code>sys.path</code> is important, as that affects imports, which
affect test loading, as discovery loads tests using import machinery.</p>
<h2>Difference between <code>-m unittest</code> and <code>-m unittest discover</code></h2>
<p>When you do</p>
<pre><code>top» python3 -m unittest abc_backend
</code></pre>
<p>in reality you are running <code>unittest/__main__.py</code> file. There
<code>main(module=None)</code> is invoked, and eventually you get to
<code>loadTestsFromModule</code> that does</p>
<pre><code>tests = []
for name in dir(module):
    obj = getattr(module, name)
    if isinstance(obj, type) and issubclass(obj, case.TestCase):
        tests.append(self.loadTestsFromTestCase(obj))
</code></pre>
<p>As <code>abc_backend/__init__.py</code> does not contain any test cases,
<code>isinstance(obj, type) and issubclass(obj, case.TestCase)</code> returns
<code>False</code> for all module members (so <code>tests</code> is empty).</p>
<p>To make this particular way of invocation work, you’ll have to do
what people usually did in pre-<code>discover</code> times (aside from non-stdlib
frameworks): manually import cases from test modules (or
maybe construct test suite according to <code>load_tests</code> protocol).</p>
<p>So, how </p>
<pre><code>top» python3 -m unittest discover abc_backend
</code></pre>
<p>differs?</p>
<p>Basically, differences may be expressed as following conditional:</p>
<pre><code>if len(argv) &gt; 1 and argv[1].lower() == 'discover':
    # -m unittest discover
    loader.discover(...)
else:
    # -m unittest
    loader.loadTestsFromNames(...)
</code></pre>
<p>When <code>argv</code> is <code>['python3 -m unittest', 'discover', 'abc_backend']</code>,
actual discovery mechanism is used. When <code>argv</code> is <code>['python3 -m unittest', 'abc_backend']</code>,
<code>loadTestsFromNames</code> is used, which calls <code>loadTestsFromModule</code> at some point, and no tests are found.
That’s the way things are in <code>unittest/main.py</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I encountered similar problem today, actually the solution was written in the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestLoader.discover" rel="nofollow noreferrer">Python API document</a>:</p>
<blockquote>
<p>If a package (a directory containing a file named <strong>init</strong>.py) is found, the package will be checked for a load_tests function. If this exists then it will be called package.load_tests(loader, tests, pattern). Test discovery takes care to ensure that a package is only checked for tests once during an invocation, even if the load_tests function itself calls loader.discover.</p>
</blockquote>
<p>Hence, all you need to do is write a load_tests function and register your TestCase classes in __init__.py</p>
</div>
<span class="comment-copy">Thank you so much for this answer!</span>
