<div class="post-text" itemprop="text">
<p>My python code pass some dictionary and lists to C like this:</p>
<pre><code>if (!PyArg_ParseTuple(args, "O!lO!O!O!O!O!", &amp;PyList_Type,&amp;list,&amp;los,&amp;PyDict_Type,&amp;entity_len,&amp;PyDict_Type,&amp;inlist_len,&amp;PyList_Type,&amp;inindex,&amp;PyDict_Type,&amp;inlist,&amp;PyList_Type,&amp;tokens))
        return NULL; 
</code></pre>
<p>is that OK to get items like this?</p>
<pre><code>int i = PyInt_AS_LONG(PyList_GetItem(PyDict_GetItem(inlist,PyList_GetItem(tokens,pi)),current_index[pi]))
</code></pre>
<p>I need to call my C function in python for 10K times, and after running my code for about 100 times, it shows segment fault 11. How can I fixed it?  </p>
</div>
<div class="post-text" itemprop="text">
<p>I would not suggest it, you should do error checking for both <a href="https://docs.python.org/2/c-api/dict.html#c.PyDict_GetItem" rel="nofollow"><code>PyDict_GetItem</code></a> and <a href="https://docs.python.org/2/c-api/list.html#c.PyList_GetItem" rel="nofollow"><code>PyList_GetItem</code></a>:</p>
<pre><code>PyObject *obj = PyList_GetItem(args)
if(!obj){
    return NULL
}
// Same for PyDict_GetItem with the difference
// that PyDict won't set an exception, so you 
// probably need to set it yourself.
</code></pre>
<p>Both <code>*_GetItem</code> functions return <code>NULL</code> when something goes wrong. So, if you simply chain these calls without proper error checking you'll run into problems if one of these returns <code>NULL</code>.</p>
<p>Additionally, both these functions <em><a href="https://docs.python.org/3/extending/extending.html#reference-counting-in-python" rel="nofollow">return a borrowed reference to the Object</a></em>:</p>
<blockquote>
<p>The advantage of borrowing over owning a reference is that <em>you don’t need to take care of disposing of the reference on all possible paths through the code</em> — in other words, with a borrowed reference you don’t run the risk of leaking when a premature exit is taken. <em>The disadvantage of borrowing over owning is that there are some subtle situations where in seemingly correct code a borrowed reference can be used after the owner from which it was borrowed has in fact disposed of it.</em></p>
</blockquote>
<p>(emphasis mine)</p>
<p>So you generally shouldn't worry about <code>Py_DECREF</code>ing them. But, be careful; if you need to use a reference, store it or pass it elsewhere you <em>should</em> increment it's reference and get ownership of it. </p>
<p>Finally, I'm not 100% sure what the effect is when you pass a borrowed reference to <code>PyDict</code>; couldn't find something in the documentation. Looking at the <a href="https://hg.python.org/cpython/file/tip/Objects/dictobject.c#l1041" rel="nofollow">source for <code>PyDict_GetItem</code></a> though, I can't see it <code>DECREF</code>ing the <code>key</code> parameter so I think there shouldn't be issues there.</p>
</div>
<span class="comment-copy"><code>PyInt_AS_LONG</code> is a macro that does not perform error checking. You should use <code>PyInt_AsLong</code> instead, as you can't be 100% sure that the object is really an <code>int</code> object.</span>
<span class="comment-copy">You have a memory leak somewhere, but it doesn't seem to be in the code you showed. If you're still having problems with this, post more code that's shows what else you're doing. You have to be very careful to Py_DECREF objects at the correct times and only when needed.</span>
<span class="comment-copy">Thanks, I tried error checking, but it didn't work. And another problem showed, "object was probably modified after being freed."  Sometimes, it showed segment fault, and sometimes Abort trap. Any more suggestion?</span>
<span class="comment-copy">That definitely has to do with not managing your references correctly; you could try <code>Py_INCREF</code>ing the <code>PyObjects</code> returned from each call to <code>*_GetItem</code> before passing them to the next <code>_GetItem</code> call.</span>
<span class="comment-copy">I checked the memory my code uses(I should do that first...). It shows that my python program occupied large amount of memory. And that's why my code always crashed by segment fault. Could it caused by incorrect reference count or just the problem of C code?</span>
