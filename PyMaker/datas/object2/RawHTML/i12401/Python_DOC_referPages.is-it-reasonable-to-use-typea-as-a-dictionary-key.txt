<div class="post-text" itemprop="text">
<p>I am trying to store files in a dictionary depending on their type. For this, I am using <code>pygments</code> API as follow:</p>
<pre class="lang-python prettyprint-override"><code># Initialization of the self.files dictionary
self.files = dict()
# Scanning and categorizing the files
for file in files:
    lexer = guess_lexer__for_filename(file, None)
    if type(lexer) in self.files:
        self.files[type(lexer)].append(file)
    else:
        self.files[type(lexer)] = [file]
</code></pre>
<p>But, now, when passing this code through <code>pylint3</code>, I get a warning telling me that I should use <code>isinstance()</code> in place of <code>type()</code> (unidiomatic-typecheck).</p>
<p>The best way to workaround this warning I found so far is as follow:</p>
<pre class="lang-python prettyprint-override"><code>self.files = dict()
for file in files:
    lexer = guess_lexer__for_filename(file, None)
    if lexer.__class__ in self.files:
        self.files[lexer.__class__].append(file)
    else:
        self.files[lexer.__class__] = [file]
</code></pre>
<p>But, does it really solve the problem ? And, moreover, I started to doubt that using a type as a key in a dictionary is robust enough.</p>
<p>So, is there more suitable and robust ways to do? Any solution with good arguments is welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the <code>type()</code> output, an object, as a key is just fine. <a href="https://stackoverflow.com/questions/28829236/is-it-possible-to-ignore-one-single-specific-line-with-pylint">Ignore that warning</a> in this case.</p>
<p>I'd use <a href="https://docs.python.org/2/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault()</code></a> or <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a> to extend the list value:</p>
<pre><code>self.files = {}

for file in files:
    lexer = guess_lexer__for_filename(file, None)
    self.files.setdefault(type(lexer), []).append(file)
</code></pre>
<p>or</p>
<pre><code>from collections import defaultdict

self.files = defaultdict(list)

for file in files:
    lexer = guess_lexer__for_filename(file, None)
    self.files[type(lexer)].append(file)
</code></pre>
<p>However, on Python 3, you could investigate if <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>functools.singledispatch()</code></a> could be used to handle your use-case instead. It calls a registered function for a given object type, taken from the first argument, and supports subclasses.</p>
</div>
<span class="comment-copy">The <code>singledispatch()</code> is nice but it is not fitting the usage I intend to have. And, I did not know the <code>setdefault</code>/<code>defaultdict</code> trick and I will definitely use it. Thanks a lot !</span>
