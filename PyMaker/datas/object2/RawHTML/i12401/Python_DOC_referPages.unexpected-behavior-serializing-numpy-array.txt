<div class="post-text" itemprop="text">
<h2>Code</h2>
<p>Suppose I have:</p>
<pre><code>import numpy
import pickle


class Test():
    def __init__(self):
        self.base = numpy.zeros(6)
        self.view = self.base[-3:]

    def __len__(self):
        return len(self.view)

    def update(self):
        self.view[0] += 1

    def add(self):
        self.view = self.base[-len(self.view) - 1:]
        self.view[0] = 1

    def __repr__(self):
        return str(self.view)


def serialize_data():
    data = Test()
    return pickle.dumps(data)
</code></pre>
<p>Note that class <code>Test</code> is simply a class that contains a <code>view</code> of a NumPy array <code>base</code>. This <code>view</code> is simply a slice of the last <code>N</code> elements in base (<code>N == 3</code> on initialization).</p>
<p><code>Test</code> has a method <code>update()</code> which adds <code>1</code> to the value at position <code>0</code> of the view, and a method <code>add()</code> which modifies the view size (<code>N = N + 1</code>) and sets the value at position <code>0</code> to <code>1</code>.</p>
<p>The function <code>serialize_data</code> simply creates a <code>Test()</code> instance and then returns the serialized object using <code>pickle</code>.</p>
<h2>Behavior</h2>
<p>If I create a local variable and <code>update</code> it twice and <code>add</code> it once, everything works as expected:</p>
<pre><code># Local variable
test = Test()
print(test)    # [ 0.  0.  0.]

test.update()
test.update()
print(test)    # [ 2.  0.  0.]

test.add()
print(test)    # [ 1.  2.  0.  0.]
</code></pre>
<p>Now, if I create a local variable out of serialized data, then after executing <code>add</code> the value <code>2</code> (set after calling <code>update</code> twice) seems to be lost:</p>
<pre><code># Serialized variable
data = pickle.loads(serialize_data())
print(data)    # [ 0.  0.  0.]

data.update()
data.update()
print(data)    # [ 2.  0.  0.]

data.add()
print(data)    # [ 1.  0.  0.  0.]  &lt;----  This should be [ 1. 2. 0. 0. ] !!!
</code></pre>
<h2>Question</h2>
<p>Why is this happening and how could I avoid this behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that after pickling/unpickling the view is no longer a view into base but has its' own copy of the data. <a href="https://stackoverflow.com/q/13746601/3005167">See here</a>, unfortunately, there is no answer on how to prevent this.</p>
<p>The particular problem can be overcome by defining <a href="https://docs.python.org/3/library/pickle.html#object.__getstate__" rel="nofollow noreferrer"><code>__getstate__</code> and <code>__setstate__</code></a> methods for the class that redefine the view after unpickling.</p>
<p>In addition to the view it is necessary to track which part of the base the view looks into. I've chosen to use a slice object, but there are other ways. It is not necessary to pickle the view itself, since it will be reconstructed from the slice upon unpickling.</p>
<pre><code>class Test():
    def __init__(self):
        self.base = numpy.zeros(6)
        self.slice = slice(-3, self.base.size)
        self.view = self.base[self.slice]

    def __len__(self):
        return len(self.view)

    def update(self):
        self.view[0] += 1

    def add(self):
        self.slice = slice(-len(self.view) - 1, self.base.size)
        self.view = self.base[self.slice]        
        self.view[0] = 1

    def __getstate__(self):
        return {'base': self.base, 'slice': self.slice}

    def __setstate__(self, state):
        self.base = state['base']
        self.slice = state['slice']
        self.view = self.base[self.slice]

    def __repr__(self):
        return str(self.view)
</code></pre>
</div>
<span class="comment-copy">The problem is that after pickling/depickling the view is no longer a view into base but has its' own copy of the data. <a href="http://stackoverflow.com/q/13746601/3005167">see here</a>, unfortunately, there is no answer on how to prevent this.</span>
<span class="comment-copy">@kazemakase: with that information I can work-around the problem for my particular use-case. I will try to implement it and answer my own question with the solution (in case it is valid for others in the future). Thank you! :-) PS: please, consider adding your answer as well so I can accept it.</span>
<span class="comment-copy">I think my comment is a bit meager to qualify for an answer. However, I found a workaround for your particular problem, which I'll post in a minute :)</span>
<span class="comment-copy">@kazemakase: I think it was good enough! :-D With the <code>__getstate__ and __setstate__</code> reference links is better, of course. However, the actual implementation varies depending on the use-case (the case I posted was not the real case I was working with). I will accept your answer within the next 24 hours. I like to keep questions opened for a couple of hours in case someone else jumps in with a different approach. ;-) Thanks again!</span>
<span class="comment-copy">Don't worry about accepting. This is an interesting problem and I'd like to know if there are other ways to solve it. So, just remember to post your own solution if you have a different one :)</span>
