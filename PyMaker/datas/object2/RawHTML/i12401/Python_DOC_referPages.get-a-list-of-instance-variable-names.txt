<div class="post-text" itemprop="text">
<p>I want to get a list of all instance variables of a class <em>without</em> creating an instance of that class. I have a feeling that this is not possible in Python.</p>
<p>Suppose I have this class:</p>
<pre><code>class Person(object):
    def __init__(self, fullname, age):
        self.firstname, self.lastname = fullname.split(' ')
        self.age = age
</code></pre>
<p>What I want to get from this is the list <code>['lastname', 'age', 'firstname']</code>.</p>
<p>The only way I've been able to get this is by using a temporary instance of <code>Person</code>:</p>
<pre><code>temp = Person('Bob Jones', 27)
print vars(temp)  # {'lastname': 'Jones', 'age': 27, 'firstname': 'Bob'}
print vars(temp).keys()  # ['lastname', 'age', 'firstname']
</code></pre>
<p>The problem here is that, because <code>fullname.split()</code> is called, if I try to make an empty instance with <code>Person(None, None)</code>, an error will be raised. I'm not allowed to change <code>__init__</code> to allow this.</p>
<p>My first thought was to use <code>vars(Person).keys()</code>, but this gives all attributes of the <code>Person</code> type, not what an instance of <code>Person</code> would have:</p>
<pre><code>print vars(Person).keys()
# ['__module__', '__dict__', '__weakref__', '__doc__', '__init__']
</code></pre>
<p>Is there a way, without modifying the class, to do this without using <code>temp</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not know what attributes will be defined until it executes the <code>__init__</code> method.  In order to execute that method, you have to create an instance of the class.  Oh well :(</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on how badly you want to know. For example, you could fork/exec a new instance of your program, instantiate the class, analyze the instance, and return your result.</p>
<p>You could create an object that used some of the <code>__magic_methods__()</code> to detect which, if any, of its methods were being called (such as <code>.split()</code>) and then try to guess an appropriate input type...</p>
<p>But can you call something that knows what the starting list of instance data will be? No.</p>
</div>
<span class="comment-copy">Unless your attributes are all properties or otherwise defined on the class, you can't do this; the attributes created in <code>__init__</code> don't exist until an instance has been created.</span>
<span class="comment-copy">Since we can add arbitrary attributes, there's no way to know what attributes a particular instance will have at any given moment without asking it.</span>
<span class="comment-copy">"The problem here is that I have to know that Person.__init__ takes a str and an int." No. You have to know that <b>init</b> takes an argument which has a split() method, and another one. Duck typing - define yourself a Banana class, give it a split() method, and Person.__init__ will happily take it, as long as that split() method produces two things as output</span>
<span class="comment-copy">@JonKiparsky That makes sense. I edited my question so that's more accurate. Either way, that particular problem persists as there's no <code>None.split()</code>, right?</span>
<span class="comment-copy">Could there be a way to detect every time in init that <code>self.something  = somethingelse</code> is called, then build a list of everything that was assigned to?</span>
<span class="comment-copy">You could override or temporarily replace the class' <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__set__#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code> method.</a></span>
