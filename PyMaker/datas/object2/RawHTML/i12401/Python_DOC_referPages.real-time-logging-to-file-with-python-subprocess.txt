<div class="post-text" itemprop="text">
<p>I expect this is really simple but I can't work this out.</p>
<p>I am trying to write to a log file in real time the output from a <code>DD</code> imaging subprocess - I'm using <code>DD v 8.25</code> from which you can get regular progress updates using the <code>'status=progress'</code> option which writes to <code>stderr</code>.</p>
<p>I can get it to log the full output real time by passing the file object to the <code>stderr</code> i.e</p>
<pre><code>log_file = open('mylog.log', 'a')
p = subprocess.Popen['dd command...'], stdout=None, stderr=log_file)
</code></pre>
<p>...but I would prefer to intercept the string from <code>stderr</code> first so I can parse it before writing to file.</p>
<p>I have tried threading but I can't seem to get it to write, or if it does, it only does it at the end of the process and not during.</p>
<p>I'm a python noob so example code would be appreciated. Thanks!</p>
<p><strong>UPDATE - NOW WORKING (ISH)</strong></p>
<p>I had a look at the link J.F. Sebastian suggested and found posts about using threads, so after that I used the "kill -USR1" trick to get DD to post progress to stderr which I could then pick up:</p>
<pre><code>#! /usr/bin/env python
from subprocess import PIPE, Popen
from threading import Thread
from queue import Queue, Empty
import time

q = Queue()

def parsestring(mystr):
    newstring = mystr[0:mystr.find('bytes')]
    return newstring

def enqueue(out, q):
    for line in proc1.stderr:
        q.put(line)
    out.close()

def getstatus():
    while proc1.poll() == None:
        proc2 = Popen(["kill -USR1 $(pgrep ^dd)"], bufsize=1, shell=True)
        time.sleep(2)

with open("log_file.log", mode="a") as log_fh:
    start_time = time.time()

    #start the imaging
    proc1 = Popen(["dd if=/dev/sda1 of=image.dd bs=524288 count=3000"], bufsize=1, stderr=PIPE, shell=True)

    #define and start the queue function thread
    t = Thread(target=enqueue, args=(proc1.stderr, q))
    t.daemon = True
    t.start()

    #define and start the getstatus function thread
    t_getstatus = Thread(target=getstatus, args=())
    t_getstatus.daemon
    t_getstatus.start()

    #get the string from the queue

    while proc1.poll() == None:
        try: nline = q.get_nowait()
        except Empty:
            continue
        else:
            mystr = nline.decode('utf-8')           
            if mystr.find('bytes') &gt; 0:
                log_fh.write(str(time.time()) + ' - ' + parsestring(mystr))
                log_fh.flush()

        #put in a delay
        #time.sleep(2)

    #print duration
    end_time=time.time()
    duration=end_time-start_time
    print('Took ' + str(duration) + ' seconds')     
</code></pre>
<p>The only issue is I can't work out how to improve performance. I only need it to report status every 2 seconds or so but increasing the time delay increases the time of the imaging, which I don't want. That's a question for another post though...</p>
<p>Thanks to both J.F. Sebastian and Ali.</p>
</div>
<div class="post-text" itemprop="text">
<p>With this example it's possible (with python 3) to stream from stderr to console:</p>
<pre><code>#! /usr/bin/env python
from subprocess import Popen, PIPE

# emulate a program that write on stderr
proc = Popen(["/usr/bin/yes 1&gt;&amp;2 "],  bufsize=512, stdout=PIPE, stderr=PIPE, shell=True)
r = b""
for line in proc.stderr:
    r += line
    print("current line", line, flush=True)
</code></pre>
<p>To stream to a file:</p>
<pre><code>#! /usr/bin/env python
from subprocess import Popen, PIPE

with open("log_file.log", mode="b",  encoding="utf8") as log_fh:
        proc = Popen(["/usr/bin/yes 1&gt;&amp;2 "],  bufsize=512, stdout=PIPE, stderr=PIPE, shell=True)
        r = b""
        # proc.stderr is an io.TextIOWrapper file-like obj
    # iter over line
        for line in proc.stderr:
                r += line
                # print("current line", line, flush=True)
                log_fh.write(line) # file open in binary mode
                # log_fh.write(line.decode("utf8")) # for text mode
                log_fh.flush() # flush the content
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To display <code>dd</code>'s progress report in a terminal and to save (parsed) output to a log file:</p>
<pre><code>#!/usr/bin/env python3
import io
from subprocess import PIPE, Popen
from time import monotonic as timer

cmd = "dd if=/dev/sda1 of=image.dd bs=524288 count=3000 status=progress".split()
with Popen(cmd, stderr=PIPE) as process, \
        open("log_file.log", "a") as log_file:
    start_time = timer()
    for line in io.TextIOWrapper(process.stderr, newline=''):
        print(line, flush=True, end='')  # no newline ('\n')
        if 'bytes' in line:
            # XXX parse line here, add flush=True if necessary
            print(line, file=log_file)
    # print duration
    print('Took {duration} seconds'.format(duration=timer() - start_time))
</code></pre>
<h3>Note</h3>
<ul>
<li>no <code>shell=True</code>: you don't need the shell here. <code>Popen()</code> can run <code>dd</code> directly</li>
<li>no threads, queues: you don't need them here</li>
<li>please, please DO NOT USE <code>while proc1.poll() == None</code> You don't need it here (you'll see EOF on <code>proc1.stderr</code> if <code>proc1.poll()</code> is not None). You may lose data (there could be a buffered content even if the process has exited already). Unrelated: if you need to compare with <code>None</code>; use <code>is None</code> instead of <code>== None</code></li>
<li><code>io.TextIOWrapper(newline='')</code> enables text mode
(it uses <code>locale.getpreferredencoding(False)</code>) and it
treats <code>'\r'</code> as a newline too</li>
<li>use the default <code>bufsize=-1</code> (see <a href="https://docs.python.org/3/library/io.html#io.DEFAULT_BUFFER_SIZE" rel="nofollow"><code>io.DEFAULT_BUFFER_SIZE</code></a>)</li>
</ul>
</div>
<span class="comment-copy">Take a look <a href="http://stackoverflow.com/questions/2804543/read-subprocess-stdout-line-by-line" title="read subprocess stdout line by line">stackoverflow.com/questions/2804543/â€¦</a>. in your case store the output or errout to a variable before to write it to a file at the send of your process.</span>
<span class="comment-copy">that example doesn't appear to work - again, I don't get any logging until the process has completed.</span>
<span class="comment-copy">Thanks, but didn't work. It worked fine with your example but using my DD command "dd if=/dev/sdb1 of=image.dd status=progress", I still get nothing until the process has finished. This may be a down to DD and how it does output.</span>
<span class="comment-copy">(1) don't use <code>stdout=PIPE</code> unless you read from the <code>proc.stdout</code> otherwise a deadlock is possible in the general case (2) Don't use <code>str(bytes_object)</code>; instead, open the file in binary mode or decode the bytes first (using <code>universal_newlines=True</code> or <code>io.TextIOWrapper(proc.stderr, encoding='utf-8')</code> or <code>line.decode('utf-8')</code> (if <code>b'\n'</code>-separated lines are enough in your case)).</span>
<span class="comment-copy">Thanks for the advices. I was sure that str on bytes making python calling decode on bytes.</span>
<span class="comment-copy">note: <code>print(bytestring)</code> calls <code>str()</code> implicitly. You should decode bytes into a Unicode text before printing them instead e.g., you could pass <code>universal_newlines=True</code> to <code>Popen()</code> to enable the text mode. Note: your code won't work with <code>dd status=progress</code>  because it doesn't produce <code>b'\n'</code> until the very end (it uses <code>b'\r'</code> instead, to type the info in the same place).</span>
