<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/291978/short-description-of-the-scoping-rules">Short description of the scoping rules?</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>I'm a bit confused with the variable scope of Python. Perhaps because of being used to the convention of C++, I always made some mistakes in variable scope of Python. For example:</p>
<p>in C++:  </p>
<pre><code>int main(){
    int i = 3;
    for (int j = 0; j &lt;= 3; ++j){
        i += 1;
    }
    cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
    cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; endl; //Error, out of 'for' scoping.
    return 0;
}
</code></pre>
<p>But in Python:  </p>
<pre><code>i = 3
for j in range(1,4):
    i += 1
print j               # j = 3, nothing wrong
for i in range(5,7):
    j += 1
print i               # i = 6, changed by operation in for loop
</code></pre>
<p>This is just a simple example, and I'm not going to list other differences. Could anyone please give a detailed explanation of their differences in scoping.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python doesn't provide a block scope. The minimum scope for a variable is the function (like it happens in pre-ES6 Javascript).</p>
<p>The original reason for this design (if I understood correctly) is that if you need block-scope variable then the code is probably too complex anyway and factorizing out a function is a good idea (note that you can create local functions/closures in Python so this doesn't necessarily mean the code will need to be spread and delocalized like it would happen with C).</p>
<p>As an exception to this "no-block-scope" rule, with Python3 variables used inside comprehensions were made local to the comprehension, i.e. after</p>
<pre><code>x = [i*i for i in range(10)]
</code></pre>
<p><code>i</code> will be 9 in Python2, but no variable <code>i</code> will leak from the expression in Python3.</p>
<p>Python rules for scoping are not very complex: if there are assignments (or augmented assigments like <code>+=</code> <code>-=</code> and so on) in the body of the function then the variable is considered a local, if instead it's only accessed for reading the variable is considered coming from an outer scope (or a global if the function is at top level).</p>
<p>If you need to modify a global in a function (not something that should happen often) you need to declare it explicitly with <code>global</code>.</p>
<p>In Python3 it's also possible to access a local variable captured in an inner function for writing by using a <code>nonlocal</code> declaration. In Python2 instead captured local variables can only be accessed for reading in inner functions (assignment would make them locals of the inner function and <code>global</code> declaration would make them globals instead).</p>
</div>
<div class="post-text" itemprop="text">
<p>Python distinguishes only two variable scopes - local and global.</p>
<p>Global variable is the same like in C/C++, i.e. it's globally accessible and keeps its value cross function calls.</p>
<p>Local variable is local to the function (similar to JavaScript). Any modification inside inner blocks modifies the variable for the whole function scope.</p>
<p>EDIT: Thanks to the comments, I forgot <code>nonlocal</code> statement. This allows referring from inner function to variable from enclosing function, check <a href="https://stackoverflow.com/a/1261961/4787126">here</a> for explanation. However it still doesn't allow limiting the scope of the variable to specific block.</p>
</div>
<span class="comment-copy">There are detailed explanations of the python/c++ scoping rules in the official documentation. What part when reading it did you not understand? Surely you don't want us to reiterate everything or copy-paste it.</span>
<span class="comment-copy">After both loops, the loop variable has the last value it was given.  You comment claiming some difference is wrong.</span>
<span class="comment-copy">Hi, @timgeb, I didn't find the corresponding part, could you please attach a link? Thank you so much!</span>
<span class="comment-copy">Read the tutorial at least up the the point where it starts discussing the stdlib modules.  Basically, the module is a scope, each class and function is a new scope, blocks are not scopes.</span>
<span class="comment-copy">Somehow your question shortens to: How not to do the same error again and again? The answer is simple: concentration and focus.</span>
<span class="comment-copy">There also captured variables in closures, normally read-only for syntax reasons but can also be made read-write (with Python3 only) by the <code>nonlocal</code> declaration.</span>
<span class="comment-copy">This is wrong. Python allows access to variables from containing scopes. In Python 3.x, you can even use <a href="https://docs.python.org/3/reference/simple_stmts.html#nonlocal" rel="nofollow noreferrer">the <code>nonlocal</code> statement</a> to explicitly refer to a variable from an outer scope (see <a href="https://www.python.org/dev/peps/pep-3104/" rel="nofollow noreferrer">PEP 3104</a> for details).</span>
<span class="comment-copy">@6502: You're right about <code>nonlocal</code>, but actually it solves the other problem - referring to outer scope function. Basically it doesn't introduce new type of scope.</span>
<span class="comment-copy">@ZbynekVyskovsky-kvr000: it depends how you define scope. A captured variable is a local but a local of someone else: inside a function you have locals, locals of someone else (captured) and globals (and also comprehension iteration variables in Python3).</span>
