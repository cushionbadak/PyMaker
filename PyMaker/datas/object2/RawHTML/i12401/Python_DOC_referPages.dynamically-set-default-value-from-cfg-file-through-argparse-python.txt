<div class="post-text" itemprop="text">
<p>I am trying to use <code>argparse</code> module. I am dealing with 2 configuration files:<br/>
1.default cfg file 2. File provided by user.   </p>
<p>If no file provided at run time, read from default file. And if user provides a file, use the content of provided file.</p>
<p>My question is : I want to provide <code>default</code> field for each <code>parser.add_agument</code>, so if it's not provided by user,it will always have some default value. These values can be read from either of the file (i.e. default or user given file). I need to check which file is provided and then <code>from default/user-given-file import *</code></p>
<p>My code:<br/>
get_args.py</p>
<pre><code>class GetArgs:
   def get_args(self):
       parser = argparse.ArgumentParser(description='foo')
       #
       parser.add_argument(
        '-c', '--config', type=str, help='Provide a file', 
                          required=False, default='settings.cfg')
         #now note that below "default=version" will be from either "settings.cfg" or "user given file"

         # here may be i need to import from file ? 
        parser.add_argument(
        '-v','--version', type=str, help='API version', required=False, default=version)
        args = parser.parse_args()

        # Assign args to variables
        config=args.config
        version = args.version
        retutn config,version
</code></pre>
<p>code to read cfg file: 
read_file.py</p>
<pre><code>import ConfigParser
configParser = ConfigParser.RawConfigParser()
configParser.read(file)
try:
    version= configParser.get('Set', 'version')
    ....
    ....
except ConfigParser.NoOptionError:
    print "Option not found in configuration file!"
    sys.exit(1)
</code></pre>
<p>something like:  </p>
<pre><code>1.python get_args.py                                      #reads "version" from settings.cfg
2.python get_args.py --config /path/to/file/file.cfg      #reads "version" file.cfg   
</code></pre>
<p>It works perfect when i don't provide --config.</p>
<p>Is this possible to read dynamically?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Populating a parser dynamically</h2>
<p>Another question today got an answer that shows how to populate a parser from values in a dictionary:  <a href="https://stackoverflow.com/a/35132772/901925">https://stackoverflow.com/a/35132772/901925</a></p>
<p>Ipython does something similar.  It reads config files (default as well as user profile one(s)), and uses the config values to popular a parser.  That gives the user several levels of control - default config, profile config, and finally, commandline.  But the Ipython code is rather complex.</p>
<h2>Editing argument values</h2>
<p>Another useful point, is that each argument, or Action object, is available after creation, and may (within limits) be modified.</p>
<pre><code>arg1 = parser.add_argument('--foo', default='test', ...)
# arg1 is an Action object with the various parameters
print arg1     # a display of some attributes
print arg1.default    # the value of the default as set above
arg1.default = 'different'  # assign a new value
</code></pre>
<p>So it is possible dynamically set the default values before parsing.</p>
<h2>Prefix char file</h2>
<p>Another useful tool is <a href="https://docs.python.org/3/library/argparse.html#fromfile-prefix-chars" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#fromfile-prefix-chars</a></p>
<pre><code>parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
</code></pre>
<p>allows me to specify the name of a file prefaced with the character.  It will read the files contents and splice the strings into the <code>sys.argv</code> list, just as though I had typed them it.  </p>
<h2>Filling in defaults after parsing</h2>
<p>However if you want to specify the config file in the commandline, and then use its contents to set defaults for the parser, things get more complicated.</p>
<p>After parsing <code>args</code> will be a namespace object that contains the config file name along with all other arguments that it parsed.</p>
<p>You can see the exact contents of <code>args</code> with <code>print args</code>, or in dictionary form as <code>vars(args)</code>.  There's no hidden information about which values were set with the parser defaults and which were set by the commandline.</p>
<p>The cleanest, post parsing test for defaults is</p>
<pre><code>if args.foo is None:
   # this has the default default
</code></pre>
<p>If the value is <code>None</code> it can only come from the default, not the commandline (there's no string that translates to <code>None</code>).</p>
<p>So I can imagine writing a function that iterates through the keys of <code>vars(args)</code>, testing for <code>None</code>, and replacing it with the corresponding value from <code>config</code>.  (Do you need help with that?).</p>
<p>If both <code>config</code> and <code>args</code> are cast as compatible dictionaries, then you could use the dictionary <code>update</code> method to transfer values from one to the other.  </p>
<p><code>default=argparse.SUPPRESS</code> can be used to keep an argument out of the namespace if the argument does not appear in the commandline.  <a href="https://docs.python.org/3/library/argparse.html#default" rel="nofollow noreferrer">https://docs.python.org/3/library/argparse.html#default</a>.  This could be used along with the dictionary update, e.g.</p>
<pre><code>config_dict.update(vars(args))
</code></pre>
<p>would only change <code>config_dict</code> for arguments given in the commandline.</p>
<h2>Two stage parser</h2>
<p>Another idea is to use two stage parsing.  Define one parser that has the <code>config_file</code> argument, and no (or few) others.  Run it with <code>parse_known_args</code> to the get the <code>config_file</code> value.  Read the config file and use it to populate the 2nd stage parser (or at least to modify its defaults).  Now run the 2nd stage parser to get the full namespace (I'd just ignore any <code>config_file</code> values in this args).</p>
<h2>ChainMap</h2>
<p><a href="https://docs.python.org/3/library/collections.html#chainmap-examples-and-recipes" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#chainmap-examples-and-recipes</a></p>
<p>A newish <code>collections</code> class, <code>ChainMap</code> has an example of chained value lookup from a namespace, env, defaults, etc.</p>
<pre><code>namespace = parser.parse_args() 
command_line_args = {k:v for k, v in vars(namespace).items() if v} 
combined = ChainMap(command_line_args, os.environ, defaults) 
print(combined['color'])
</code></pre>
<hr/>
<p>Other good ideas at <a href="https://stackoverflow.com/questions/10551117/setting-options-from-environment-variables-when-using-argparse">Setting options from environment variables when using argparse</a></p>
</div>
<span class="comment-copy">I don't think what you want to achieve is possible, because the default value must be set before the arguments are parsed â€“ this is for instance important to display the default values when you call <code>./get_args.py -h</code>. However, you could set the default value to <code>None</code> and later replace the values with values you read from either configuration file.</span>
<span class="comment-copy">@DavidZwicker - Yes make sense that default value should be set before we execute script.</span>
