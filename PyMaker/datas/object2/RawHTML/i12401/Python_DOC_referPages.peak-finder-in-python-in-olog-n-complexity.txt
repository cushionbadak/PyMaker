<div class="post-text" itemprop="text">
<p>I'm completely new to Python, thus the question. I'm trying to solve a standard interview question, which is finding a peak in an array. A peak is defined as a number which is greater than it's left and right neighbor. I'm trying to find the largest such peak.</p>
<p>This is my code:</p>
<pre><code>def main():
    arr = [7, 12, 13, 8, 2, 16, 24, 11, 5, 1]
    print(find_peak(arr))


def find_peak(arr):
    return _find_peak(arr, 0, len(arr))


def _find_peak(arr, start, stop):

    mid = (start + stop) // 2

    if arr[mid] &gt; arr[mid - 1] and arr[mid] &gt; arr[mid + 1]:
        return arr[mid]

    elif arr[mid] &lt; arr[mid - 1]:
        _find_peak(arr, 0, mid - 1)

    elif arr[mid] &lt; arr[mid + 1]:
        _find_peak(arr, mid + 1, stop)


if __name__ == '__main__':
    main()
</code></pre>
<p>The output of this program is <code>None</code>, where as the expected output is <code>24</code>. Any help appreciated.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Data</h2>
<pre><code>arr = [7, 12, 13, 8, 2, 16, 24, 11, 5, 1]
</code></pre>
<h2>A one-liner:</h2>
<p>One line should be enough:</p>
<pre><code>max_peak = max(x2 for x1, x2, x3 in zip(arr, arr[1:], arr[2:]) if x1 &lt; x2 &gt; x3)
</code></pre>
<h2>In a loop</h2>
<p>Maybe easier to understand when you are new to Python:</p>
<pre><code>peak = float('-inf')
for x1, x2, x3 in zip(arr, arr[1:], arr[2:]):
    if x1 &lt; x2 &gt; x3:
        peak = max(peak, x2)
print(peak)
</code></pre>
<p>Output:</p>
<pre><code>24
</code></pre>
<h2>All peaks</h2>
<p>You can also use a one-liner to get all peaks:</p>
<pre><code>&gt;&gt;&gt; [x2 for x1, x2, x3 in zip(arr, arr[1:], arr[2:]) if x1 &lt; x2 &gt; x3]
[13, 24]
</code></pre>
<p>and get the greatest one with <code>max()</code> on the result.</p>
<h2>Explanation</h2>
<p>Let's have a look at some of the components of the solution. I am working with Python 3 here, as everybody should. ;)</p>
<p>You can slice lists.</p>
<pre><code>&gt;&gt;&gt; arr = [7, 12, 13, 8, 2, 16, 24, 11, 5, 1]
</code></pre>
<p>This gives you all of the list but the first element:</p>
<pre><code>&gt;&gt;&gt; arr[1:]
[12, 13, 8, 2, 16, 24, 11, 5, 1]
</code></pre>
<p>Here its starts with element three:</p>
<pre><code>&gt;&gt;&gt; arr[2:]
[13, 8, 2, 16, 24, 11, 5, 1]
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html?highlight=zip#zip" rel="nofollow">zip()</a> function zips multiple sequences together. To visualize what happens, you can convert the zip object into a list:</p>
<pre><code>&gt;&gt;&gt; list(zip(arr, arr[1:], arr[2:]))
[(7, 12, 13),
 (12, 13, 8),
 (13, 8, 2),
 (8, 2, 16),
 (2, 16, 24),
 (16, 24, 11),
 (24, 11, 5),
 (11, 5, 1)]
</code></pre>
<p>Python supports tuple unpacking. This allows to assign individual names to all members of a tuple:</p>
<pre><code>&gt;&gt;&gt; x1, x2, x3 = (7, 12, 13)
&gt;&gt;&gt; x1
7
&gt;&gt;&gt; x2
12
&gt;&gt;&gt; x3
13
</code></pre>
<p>Another nice feature is the comparison of more than two objects:</p>
<pre><code>&gt;&gt;&gt; 10 &lt; 12 &gt; 8
True
</code></pre>
<p>This is equivalent to:</p>
<pre><code>&gt;&gt;&gt; (10 &lt; 12) and (12 &gt; 8)
True
</code></pre>
<p>Python offers <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">list comprehensions</a>:</p>
<pre><code>&gt;&gt;&gt; [x * 2 for x in range(2, 6)]
[4, 6, 8, 10]
</code></pre>
<p><a href="https://docs.python.org/3/glossary.html#term-generator-expression" rel="nofollow">Generator expression</a> work in a similar way but don't produce a list but an iterator and can be consumed without using lots of memory:</p>
<pre><code>&gt;&gt;&gt; sum(x * 2 for x in range(2, 6))
28
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you are missing a return statement for your two <code>elif</code> cases</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the 13 also is a peak (greater than 12 and 8).</p>
<p>Try this approach:</p>
<pre><code>def main():
    arr = [7, 12, 13, 8, 2, 16, 24, 11, 5, 1]
    print(find_peaks(arr))


def find_peaks(arr):
    return list(_search(arr))


def _search(arr):
    last = len(arr) - 1
    for i, e in enumerate(arr):
        if not any((i &gt; 0 and arr[i-1] &gt; e, i &lt; last and arr[i+1] &gt; e)):
            yield e


if __name__ == '__main__':
    main()
</code></pre>
<p>If you don’t understand anything, ask!</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach – using only one function:</p>
<pre><code>def main():
    arr = [7, 12, 13, 8, 2, 16, 24, 11, 5, 1]
    print(find_peaks(arr))


def find_peaks(arr):
    last = len(arr) - 1
    return [
        e for i, e in enumerate(arr)
        if not any((i &gt; 0 and arr[i-1] &gt; e, i &lt; last and arr[i+1] &gt; e))
    ]


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you can find a peak in O(log N) time, because by definition the items cannot be in order, and there is no way to predict the peaky-ness of any item in a list given other items, except that comparing item N with item N+1 is presumably reflexive - it tells you that either N or N+1 might be a peak. That gets you to N/2 compares, which must then be followed by N/2 more compares to check the other side of the peak.</p>
<p>Here's a <code>local_maxima(iterable)</code> function that you can use with <code>max()</code> to find peaks. It treats start/end elements as peaks if they are greater than their one neighbor.</p>
<pre><code>data = [7, 12, 13, 8, 2, 16, 24, 11, 5, 1, None, 2, None, 3, 4, None, 5, 1, None]
firstpeak = [12, 7, 9, 8]
lastpeak = [1, 2, 3, 4]

def local_maxima(it):
    """Find local maxima in iterable _it_. Compares with None using
    `is (not) None`, and using operator `&lt;`."""

    peaking = False
    last = None

    for item in it:

        # Deal with last item peaking
        if peaking and (item is None or item &lt; last):
            yield last
            peaking = False
        elif item is None:
            peaking = False
        elif last is None or last &lt; item:
            peaking = True
        else:
            peaking = False

        last = item

    if peaking:
        yield last

print([x for x in local_maxima(data)])
print("Highest:", max(local_maxima(data)))
print([x for x in local_maxima(firstpeak)])
print("Highest:", max(local_maxima(firstpeak)))
print([x for x in local_maxima(lastpeak)])
print("Highest:", max(local_maxima(lastpeak)))
</code></pre>
</div>
<span class="comment-copy">You don't return any values from _find_peak, so the result will always be None.</span>
<span class="comment-copy"><i>Largest</i> peak? Not possible. Even if you just want to find <i>any</i> peak, you can't do it in O(log n) with this definition of "peak"; it's only possible for a definition where a peak is any element <i>at least</i> as great as its neighbors, rather than <i>greater</i>.</span>
<span class="comment-copy">Apologies, amended that wrong line. It slipped through the crack.</span>
<span class="comment-copy">You should <code>return _find_peak...</code> in the <code>elif</code> parts.. But you'll still get bad result (at least not <code>None</code>) :)</span>
<span class="comment-copy">I wonder whether you're looking for this: <a href="https://gist.github.com/alvations/29a970409f7bebf1ad9b" rel="nofollow noreferrer">gist.github.com/alvations/29a970409f7bebf1ad9b</a></span>
<span class="comment-copy">very Pythonic :)</span>
<span class="comment-copy">Can you explain the code a bit. This is going way above me.</span>
<span class="comment-copy">Added a bit of explanation. Covering all this in detail with examples and exercises  can be easily one day of teaching. ;)</span>
<span class="comment-copy">This does not provide an answer to the question. To critique or request clarification from an author, leave a comment below their post. - <a href="/review/low-quality-posts/11079356">From Review</a></span>
<span class="comment-copy">@Prune, this answers the question. It may not be a high quality answer, but it does provide an answer. Please be more careful when reviewing. Ensure that it actually is <i>not</i> an answer before making it as such.</span>
<span class="comment-copy">From the SO guidelines I've seen, you should provide correct return statements to fully qualify as a valid answer.  That's my interpretation (including answers <i>I</i> have left a little short), hardly canonized SO practice.</span>
<span class="comment-copy">It would really help if you could explain your approach. I'm a stark newbie in python.</span>
<span class="comment-copy">The <code>[... for ...]</code> syntax is a list comprehension: it builds a list of elements for each iteration over the iterable after <code>in</code>. The <code>enumerate()</code> function returns a iterable of which each element is a tuple containing the index of an element (<code>i</code>) of the <code>arr</code> and the element itself (<code>e</code>). The <code>if</code> inside the list comprehesion filters the elements: <code>any()</code> returns <code>True</code> if any element of the parameter is true, so it checks if the current element is greater than the left (<code>arr[i-1]</code>) and right (<code>arr[i+i]</code>) neighbours (nor left or right one is greater).</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs.python.org/3/tutorial/…</a></span>
<span class="comment-copy">In other words: I just filter the original <code>arr</code>, selecting only the elements that’s not less than left neighbour, nor less than right one (<code>if not any(…)</code>).</span>
