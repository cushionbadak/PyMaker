<div class="post-text" itemprop="text">
<p>As part of some of the code I am trying to write, I am trying to validate some user input before using it.  I would like to do something akin to the following that operates identically regardless of whether the collection is a list or a dictionary, preferably without having to always convert it into one of the two.</p>
<pre><code>list_or_dict = {0:7, 1:12}  # or [7, 12]
for addr, value in list_or_dict.items():
    if addr &gt; addr_max:
        raise Exception()
    if value &gt; val_max:
        raise Exception()
</code></pre>
<p>Edit:</p>
<p>Just to be clear, I will only expect integer keys for dictionaries. Also, I want the indicies of a list to be an addr if only for consistency reasons.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd use <code>enumerate(list_or_dict)</code> or <code>list_or_dict.items()</code> depending on what it is. Then you have <code>(addr, value)</code> pairs in both cases and can use the same code.</p>
<pre><code>&gt;&gt;&gt; def check(list_or_dict):
        items = enumerate(list_or_dict) if isinstance(list_or_dict, list) else list_or_dict.items()
        for addr, value in items:
            print(addr, value)

&gt;&gt;&gt; check({0:7, 1:12})
(0, 7)
(1, 12)
&gt;&gt;&gt; check([7, 12])
(0, 7)
(1, 12)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just assume it's a <code>dict</code> and try to convert it to a <code>list</code>. If it fails, then you already have a <code>list</code>.</p>
<pre><code>list_or_dict = {0:7, 1:12}  # or [7, 12]
try:
    list_or_dict = list(list_or_dict.items())
except AttributeError:
    list_or_dict = list(enumerate(list_or_dict))
# your processing
</code></pre>
<p>Note that this will only produce correct results if the dictionary version will always have integer keys starting at 0 and increasing by 1 with each item. Otherwise, you will have to find some other way of filling in these missing data. Also note that, if that is indeed a consistent pattern, instead of checking each key or index you can just check the length of the object. You can also use <code>any()</code> to streamline this (and you don't need <code>()</code> after <code>Exception</code>):</p>
<pre><code>list_or_dict = {0:7, 1:12}  # or [7, 12]
try:
    list_or_dict = list(list_or_dict.values())
except AttributeError:
    pass
if len(list_or_dict) &gt;= addr_max or any(value &gt; val_max for value in list_or_dict):
    raise Exception
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to have just a single loop. It uses a single iterator that gives successive <code>(addr, value)</code> pairs. If the parameter is a list, <code>addr</code> is always <code>None</code> and the <code>value</code>s are the successive list elements; if the parameter is a dict, <code>(addr, value)</code> are the dict's items. I'm assuming that elements of lists are analogous to the values of dicts; adjust accordingly if they're analogous to keys.</p>
<pre><code>def handle_list_or_dict(ld):
    if isinstance(ld, list):
        ld_iter = ((None, value) for value in ld)
    else:
        ld_iter = ld.items()

    for addr, value in ld_iter:
        if addr is not None and addr &gt; addr_max:
            raise Exception()
        if value &gt; val_max:
            raise Exception()
        # Do what you really want to do... Here we just print:
        print(addr, value)
</code></pre>
<p>Take it for a spin:</p>
<pre><code>&gt;&gt;&gt; addr_max = 2; val_max = 12
&gt;&gt;&gt; handle_list_or_dict({0:7, 1:12})
0 7
0 12

&gt;&gt;&gt; handle_list_or_dict([7, 12])
None 7
None 12
</code></pre>
<p>Exception-raising:</p>
<pre><code>&gt;&gt;&gt; addr_max = 0
&gt;&gt;&gt; handle_list_or_dict([7, 12])    # won't raise
None 7
None 12

&gt;&gt;&gt; handle_list_or_dict({0:7, 1:12})  # will raise
Traceback (most recent call last):
...
Exception
</code></pre>
<p>Changing the upper bounds to <code>addr_max = 2; val_max = 10</code>, both lists and dicts raise for values out of range.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could handle lists and dictionaries separately by checking the type. Here's an example:</p>
<pre><code>test_cases = [ {1337:'foo'}, [1337, 'foo'] ]

for case in test_cases:
    if type(case) is dict:
        for k, v in case.items():
            print(k, v)
    elif type(case) is list:
        for i in case:
            print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the <code>if</code> <em>operator</em> at the beginning of the loop to grab the intended iterator:</p>
<pre><code>def agnostic(x):
    for y in x if isinstance(x,list) else x.items():
        print(y)
</code></pre>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; agnostic(x)
1
2
3
&gt;&gt;&gt; d = {0:1,2:7}
&gt;&gt;&gt; agnostic(d)
(0, 1)
(2, 7)
</code></pre>
<p>Note that you can replace <code>x.items()</code> by either <code>x.keys()</code> or <code>x.values()</code> in the definition of the agnostic iterator, depending on exactly what part of the dictionary (if that is what it is) you want to iterate over.</p>
</div>
<span class="comment-copy">why not have 2 validators, one for dictionaries and 1 for lists, with the main code testing types then dispatching? No conversion required and avoids the need for things like checking or error-trapping in the middle of the loop.</span>
<span class="comment-copy">I am wondering if there is any way to have to avoid writing two similar validators. If there really isn't, then that is what I will do.</span>
<span class="comment-copy">How is it possible that the input comes in those different forms? Seems rather odd.</span>
<span class="comment-copy">What would you want to do with a list? Would list elements be analogous to dict keys, or values? ("agonistic" is pretty funny)</span>
<span class="comment-copy">@BrianO list elements themselves would be analogous to values, with the indices of the list analogous to the keys</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance</code></a> might be a better choice than <code>type</code></span>
