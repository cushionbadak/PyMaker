<div class="post-text" itemprop="text">
<p>I have a <code>JSON</code> object which contains all sorts of unnecessary values like <code>"null"</code>, <code>""</code>, <code>None</code>. I'd like to remove the whole object if it contains such a value. </p>
<pre><code>&gt;&gt;&gt; json.dumps(event, indent=4)
"event" = {
    "status": "COMPLETED",  
    "dataValues": [
    {
        "key": "wiiDcsQ5pdQ",
        "value": "25"
    },
    {
        "key": "RsZ4gQzWPWU",
        "value": "null"
    },
    {
        "key": "L7aO70bcrbP",
        "value": ""
    },
    {
        "key": "gY6pXRwdThm",
        "value": "null"
    },
    {
        "key": "x1708y0C4C7",
        "value": False
    }
    ]
}
</code></pre>
<p>My failed attempts:</p>
<pre><code>no_values = ["null", "", None]

# no changes/deletions:
[elem for elem in event['dataValues'] if elem['value'] not in no_values]

# TypeError: argument of type 'bool' is not iterable
[elem for elem in event['dataValues'] if any(s in elem['value'] for s in no_values]
</code></pre>
<p>How can I do so?</p>
</div>
<div class="post-text" itemprop="text">
<p>This works for me, where I store the data in a variable and evaluate it using your first list comprehension. Note that I'm using a set of ignored_values, which is slightly faster:</p>
<pre><code>In [12]: import json

In [13]: json_text = """{
    "status": "COMPLETED",  
    "dataValues": [
    {
        "key": "wiiDcsQ5pdQ",
        "value": "25"
    },
    {
        "key": "RsZ4gQzWPWU",
        "value": "null"
    },
    {
        "key": "L7aO70bcrbP",
        "value": ""
    },
    {
        "key": "gY6pXRwdThm",
        "value": null
    },
    {
        "key": "x1708y0C4C7",
        "value": false
    }
    ]
}"""

In [14]: data = json.loads(json_text)

In [15]: ignored_values = set(["null", "", None])

In [16]: [elem for elem in data['dataValues'] if elem['value'] not in ignored_values]
Out[16]: 
[{u'key': u'wiiDcsQ5pdQ', u'value': u'25'},
 {u'key': u'x1708y0C4C7', u'value': False}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this is what you want;</p>
<pre><code>ignored_values = ['null', '', None]
data_values = event['dataValues']

In [36]: event['dataValues'] = filter(lambda x: x['value'] not in  ignored_values, data_values) 
In [37]: event
Out[37]:
{'dataValues': [{'key': 'wiiDcsQ5pdQ', 'value': '25'},
  {'key': 'x1708y0C4C7', 'value': False}],
 'status': 'COMPLETED'}
</code></pre>
</div>
<span class="comment-copy">Did you try to store your first atempt into an variable? Because it does not modify the original</span>
<span class="comment-copy">Yes.. dumb printing/reassignment error</span>
<span class="comment-copy">Minor note: If this is modern Python (Py3.2 or higher), you can get a minor speed up by avoiding the creating of a named <code>ignored_vals</code> <code>set</code> on each use of such a function, instead having Python load a constant <code>frozenset</code>, by doing: <code>[elem for elem in data['dataValues'] if elem['value'] not in {"null", "", None}]</code> <a href="https://docs.python.org/3/whatsnew/3.2.html#optimizations" rel="nofollow noreferrer">The peephole optimizer was upgraded to recognize membership tests in a <code>set</code> literal of Python literals, and converts it to a constant <code>frozenset</code> once at byte code compile time, then reuses it for free thereafter.</a></span>
<span class="comment-copy">@ShadowRanger That's an interesting tidbit, thanks for sharing.</span>
