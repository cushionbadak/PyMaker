<div class="post-text" itemprop="text">
<p>I have a text file with 32 articles. Each article starts with the expression: <code>&lt;Number&gt; of 32 DOCUMENTS</code>, for example: <code>1 of 32 DOCUMENTS</code>, <code>2 of 32 DOCUMENTS</code>, etc. In order to find each article I have used the following code:</p>
<pre><code>import re 
sections = [] 
current = []
with open("Aberdeen2005.txt") as f:
    for line in f:
        if re.search(r"(?i)\d+ of \d+ DOCUMENTS", line):        
           sections.append("".join(current))
           current = [line]
        else:
           current.append(line)

print(len(sections)) 
</code></pre>
<p>So now, articles are represented by the expression <code>sections</code></p>
<p>The next thing I want to do, is to subgroup the articles in 2 groups. Those articles containing the words: economy OR economic AND uncertainty OR uncertain AND tax OR policy, identify them with the number 1. </p>
<p>Whereas those articles containing the following words: economy OR economic AND uncertain OR uncertainty AND regulation OR spending, identify them with the number 2. This is what I have tried so far:</p>
<pre><code>for i in range(len(sections)):
group1 = re.search(r"+[economic|economy].+[uncertainty|uncertain].+[tax|policy]", , sections[i])
group2 = re.search(r"+[economic|economy].+[uncertainty|uncertain].+[regulation|spending]", , sections[i])
</code></pre>
<p>Nevertheless, it does not seem to work. Any ideas why?</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a bit wordy, but you can get away without using regular expressions here, for example:</p>
<pre><code># Take a lowercase copy for comparisons
s = sections[i].lower()
if (('economic' in s or 'economy' in s) and
    ('uncertainty' in s or 'uncertain' in s) and
    ('tax' in s or 'policy' in s)):
    do_stuff()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to write this as a single regular expression, but it is a bit tricky. For each <code>and</code> you'd use a zero-width lookahead assertion <code>(?= )</code>, and for each <code>or</code> you'd use a branch. Also, we'd have to use the <code>\b</code> for a word boundary. We'd use <code>re.match</code> instead of <code>re.search</code>.</p>
<pre><code>belongs_to_group1 = bool(re.match(
     r'(?=.*\b(?:economic|economy)\b)'
     r'(?=.*\b(?:uncertain|uncertainty)\b)'
     r'(?=.*\b(?:tax|policy)\b)', text, re.I))
</code></pre>
<p>Thus not very readable.</p>
<p>A more fruitful approach would be to find all words and put them into a set</p>
<pre><code>words = set(re.findall(r'\w+', text.lower()))
belongs_to_group1 = (('uncertainty' in words or 'uncertain' in words)
    and ('economic' in words or 'economy' in words)
    and ('tax' in words or 'policy' in words))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use re.search to find those words. Then you can use if statements and python's <code>and</code> and <code>or</code> statements for the logic, and then store group one and two as two lists with the section index number as a value.</p>
<p>One thing you might want to note is that your logic may need brackets. </p>
<p>By</p>
<p>economy OR economic AND uncertainty OR uncertain AND tax OR policy</p>
<p>I assume you mean</p>
<p>(economy OR economic) AND (uncertainty OR uncertain) AND (tax OR policy)</p>
<p>which is different to (for example)</p>
<p>economy OR (economic AND uncertainty) OR (uncertain AND tax) OR policy</p>
<p>EDIT1: 
Python will evaluate your statement without brackets from left to right, i.e.:</p>
<p>( ( ( ( (economy OR economic) AND uncertainty) OR uncertain) AND tax) OR policy)</p>
<p>Which I imagine is not what you want (e.g. the above evaluates true if it includes the word policy but none of the others)</p>
<p>EDIT2:
As pointed out in comments, EDIT1 is incorrect, although you would still need brackets to achieve case 1, if you don't have them you will get case 2 instead (and case 3 is a load of rubbish)</p>
</div>
<span class="comment-copy">Describe what the expected output of "identify them with the number 'x'" looks like to you.</span>
<span class="comment-copy">well, creating a a group with all the articles that fulfilled certain criteria: for example group1 = sections[1,3,7,9] and group2 = sections[2,4,10,27].</span>
<span class="comment-copy">Okay, I was think more a dictionary <code>{"1": [1,3,7,9], "2": [2,4,10,27]}</code></span>
<span class="comment-copy">either works, as I said I am new to this and I do  not know which one might be more straight forward :)</span>
<span class="comment-copy">@AndresAzqueta you should read the <a href="https://docs.python.org/3/howto/regex.html" rel="nofollow noreferrer">Regular Expression HOWTO</a> and try the regular expressions on texts using <a href="https://regex101.com/" rel="nofollow noreferrer">regex101</a>. The latter regular expression does not even compile.</span>
<span class="comment-copy">this does not consider word boundaries at all</span>
<span class="comment-copy">@AnttiHaapala Correct.</span>
<span class="comment-copy">what do you mean it does not consider word boundaries at all?</span>
<span class="comment-copy">@AndresAzqueta This solution would match not only if the section contains "tax", but also, for example, "ataxia". In other words, it's not matching whole words, but just checking to make sure those particular sequences of characters exist <i>somewhere</i> in the section. If that's an important distinction for you, you'll need to look further at regexes.</span>
<span class="comment-copy">great, thanks for the tip. I will check regex and implement a few changes to deal with the problem. Cheers,</span>
<span class="comment-copy">Could you shorten-up <code>uncertain|uncertainty</code> to <code>uncertain(?:ty)?</code>? And <code>economic|economy</code> to <code>econom(?:ic|y)</code></span>
<span class="comment-copy">I did, but I reverted that because it made it even less readable</span>
<span class="comment-copy">Python absolutely will <b>not</b> evaluate <code>and</code> and <code>or</code> left to right like that. Instead <code>and</code>s are always evaluated <b>first</b>, and  <code>or</code>s afterwards</span>
<span class="comment-copy">@antti Huh, thats interesting. I'd assumed it would evaluated like one would mathematically. Does <code>and</code> being evaluated first mean that "economy OR economic AND uncertainty OR uncertain" becomes " economy OR (economic AND uncertainty) OR uncertain" or does it becomes  " (economy OR economic) AND (uncertainty OR uncertain)"</span>
<span class="comment-copy">@user3088440 <code>and</code> has higher precedence than <code>or</code>, in Python, most other languages, and <a href="https://en.wikipedia.org/wiki/Logical_connective#Order_of_precedence" rel="nofollow noreferrer">in math</a>.</span>
<span class="comment-copy">@user3088440: It becomes your first case. Without any brackets, and's come before or's. This IS mathematically, by the way, as multiplication/division comes before addition/subtraction.</span>
<span class="comment-copy">Huh, had no idea, I've just always bracketed anything ambiguous. Good to know!</span>
