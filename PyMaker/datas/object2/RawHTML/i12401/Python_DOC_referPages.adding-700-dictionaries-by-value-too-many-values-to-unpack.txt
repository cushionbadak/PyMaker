<div class="post-text" itemprop="text">
<p>I have a list of 2 lists, each with 700 dictionaries. </p>
<p>Each dictionary has a word count, and I want to combine them, such that values of same keys will be added. </p>
<p>I tried doing : </p>
<pre><code>combine_dicts = collections.defaultdict(int)
for k, v in itertools.chain(x.iteritems() for x in tuple(dicts[0])):
        combine_dicts[k] += v
</code></pre>
<p><code>dicts[0]</code> and <code>dicts[1]</code> are 2 lists of dictionaries. </p>
<p>But it throws the following error: </p>
<blockquote>
<p>ValueError: too many values to unpack.</p>
</blockquote>
<p>Is there any better way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You misused <code>chain</code>; you wanted <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>chain.from_iterable</code></a> to chain the iterable outputs of your generator expression, not just wrap the generator function as a no-op:</p>
<pre><code>for k, v in itertools.chain.from_iterable(x.iteritems() for x in dicts[0]):
</code></pre>
<p>That only gets the first <code>list</code> of <code>dict</code>s though; to get both, we need MOAR CHAINING!:</p>
<pre><code># Qualifying chain over and over is a pain
from itertools import chain

for k, v in chain.from_iterable(x.iteritems() for x in chain(*dicts)):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>combine_dicts = defaultdict(int)
for i in range(0,2):
   for d in dicts[i]:
      for k,v in d.iteritems():
          combine_dicts[k] += v
</code></pre>
<p>This iterates each dictionary once so memory usage should be efficient.</p>
</div>
<span class="comment-copy">I was about to suggest <code>itertools.chain(*(x.iteritems() for x in tuple(dicts[0])))</code> but I like this solution better.</span>
<span class="comment-copy">Since its a list of lists of dicts, I think <code>itertools.chain(*(x.iteritems() for x in itertools.chain.from_iterable(dicts)))</code> would unpack them all.</span>
<span class="comment-copy">@tdelaney: Yeah, <code>*</code> unpacking wouldn't matter much in this case (all the inputs clearly exist in memory already), but for iterables of iterables where the outer iterable is of indeterminate length, this means you need to create all the inner iterables before you begin processing, for long outer iterables that are generators, that could blow up your RAM usage something fierce.</span>
<span class="comment-copy">@tdelaney: Ah, missed that. I swapped it for brevity, but it's the same end result.</span>
<span class="comment-copy">Makes so much sense now. Thanks.</span>
<span class="comment-copy">What on earth is the point of <code>for i in range(0, 1):</code> there?</span>
<span class="comment-copy">I think it was meant to be range(0,2):  Because, there were 2 lists of dictionaries.</span>
<span class="comment-copy">yea - was not exactly thinking straight when writing it - should be <code>(0,2)</code> - fixed.  my bad</span>
