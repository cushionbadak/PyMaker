<div class="post-text" itemprop="text">
<p>Why does <code>assertFalse</code> succeed on <code>None</code>?</p>
<pre><code>import unittest

class TestNoneIsFalse(unittest.TestCase):
    def test_none_is_false(self):
        self.assertFalse(None)
</code></pre>
<p>Results:</p>
<pre><code>&gt; python -m unittest temp
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
</code></pre>
<p>It seems as if this behaviour invites errors where a function does not always return a value. For example:</p>
<pre><code>def is_lower_than_5(x):
    if x &lt; 5:
        return True
    elif x &gt; 5:
        return False

....

def test_5_is_not_lower_than_5(self):
   self.assertFalse(is_lower_than_5(5))
</code></pre>
<p>The above test would pass even though it should fail. It is missing an error in the code that should be caught.</p>
<p>How should we assert that the value is literally <code>False</code> and not merely false in a boolean context? e.g.</p>
<pre><code>self.assertEquals(False, None)  # assert fails. good!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>None</code> is falsy, as well as <code>0</code>, <code>""</code>, <code>[]</code>, ...</p>
<p><code>assertFalse</code> does not check whether the given value is <code>False</code> by identity. This behavior is consistent with the <code>if</code> statement:</p>
<pre><code>if not None:
    print('falsy value!')
</code></pre>
<p>Similarly, <code>assertTrue</code> does not check whether a value is <code>True</code>, and as such values like <code>1</code>, <code>"abc"</code>, <code>[1, 2, 3]</code> pass the test. See <a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noreferrer">Truth Value Testing</a> for more information.</p>
<p>This behavior is also <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertTrue" rel="noreferrer">explicitly documented</a>:</p>
<blockquote>
<pre><strong>assertTrue</strong>(expr, msg=None)
<strong>assertFalse</strong>(expr, msg=None)</pre>
<p>Test that <em>expr</em> is true (or false).</p>
<p>Note that this is equivalent to <code>bool(expr) is True</code> and not to <code>expr is True</code></p>
</blockquote>
<p>If you really want to be sure that a value is <code>True</code> or <code>False</code>, use <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertIs" rel="noreferrer"><code>assertIs</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your case is actually pointed out in the documentation:</p>
<blockquote>
<p>Note that this is equivalent to bool(expr) is True and not to expr is
  True (use assertIs(expr, True) for the latter).</p>
</blockquote>
<p>Source: <a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertFalse" rel="nofollow">https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertFalse</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Python default return value for functions is <code>None</code>.</p>
<p>Python also implements <a href="https://en.wikipedia.org/wiki/Duck_typing#In_Python" rel="nofollow">Duck typing</a>, so some values are threated as <em>falsey</em>, those are</p>
<ul>
<li>empty string</li>
<li>integer zero</li>
<li>boolean False</li>
<li>empty list</li>
<li>empty tuple</li>
</ul>
<p>So yes, you should implement it as <code>self.assertEquals(False, None)</code> if you want to explicitly check the <code>False</code> boolean value. This is not a good idea, in python you can just do</p>
<pre><code>if my_value:
    print 'truthy value'
else:
    print 'falsey value'
</code></pre>
<p>You could design your test cases using <a href="https://en.wikipedia.org/wiki/Boundary-value_analysis" rel="nofollow">boundary-value analysis</a> to check your corner cases.</p>
</div>
<span class="comment-copy">I'd say your test uncovered a bug in your function. It <i>should</i> return <code>False</code> if <code>x</code> is 5, since 5 is not lower than 5.</span>
<span class="comment-copy">@chepner Unfortunately, it looks like I have to use <code>assertIs(... False)</code> to uncover the bug. The test passes using <code>assertFalse</code>.</span>
<span class="comment-copy">A better idea is to not use True and False if you need a 3-way distinction between possible return values. Consider using 0, positive, and negative integers (like <code>cmp</code>), then use <code>assertEqual</code>, <code>assertLess</code>, and <code>assertGreater</code>.</span>
<span class="comment-copy">Doesn't this actually show that your function already works just fine? If you have <code>if it_lower_than_five(number):</code> somewhere else in your code, as <code>None</code> is false-y, the correct behaviour will occur. If you <i>really need</i> the return value to actually <i>be</i> <code>True</code> or <code>False</code>, then you <i>should</i> be more specific in your test.</span>
<span class="comment-copy">@jonrsharpe Thanks for the advice! You're right I don't <i>need</i> the return value to be True or False, per se, but I personally think using <code>assertIs</code> is preferable in this instance to prevent possible maintenance issues in the future arising from the missing <code>x == 5</code> case.</span>
<span class="comment-copy">I don't like it, but I suppose I must accept it. For future vim users: <code>%s/assert\(True\|False\)(\(.*\))/assertIs(\2, \1)/</code></span>
