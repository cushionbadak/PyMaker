<div class="post-text" itemprop="text">
<p>I have a list of lists that contain indices, e.g.,</p>
<pre class="lang-py prettyprint-override"><code>[[ 1955 16898 15202 18603]
 [ 7758 14357 13451 18447]
 [12883 13453 14576 14604]
 ..., 
 [  954 17712  1196  1250]
 [17712   859   954 18962]
 [  954   859 17712  1250]]
</code></pre>
<p>all ranging from <code>0</code> to <code>21000</code>. Some entries will occur more than once, but what I'd like to know: Which indices between <code>0</code> and <code>21000</code> are <em>not</em> contained in that list?</p>
<p>The lists can be large, so efficiency matters.</p>
</div>
<div class="post-text" itemprop="text">
<p>First off you should use numpy. Then you can use <code>setdiff1d</code> and <code>flatten</code>:</p>
<pre><code>import numpy as np

a = np.array(your_list_of_lists)

np.setdiff1d(np.arange(21000), a.flatten())
</code></pre>
<p>EDIT:</p>
<p>To avoid copying the input twice you could flatten the array with <code>ravel</code>:</p>
<pre><code>import numpy as np

a = np.ravel(your_list_of_lists)

np.setdiff1d(np.arange(21000), a)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For sure, <code>numpy</code> is really fast when working with huge amount of data. However, I just want to provide a native approach using Python's <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow"><code>sets</code></a> since there might be environments where additional modules are not a allowed (e.g. due to security issues).</p>
<p>For further explanation please see comments in code:</p>
<pre><code># sample list containing some numbers from 0 to 10
# 0, 9 and 10 are missing and need to be found
l = [
    [1,2,3,4],
    [5,6,7,8],
    ]

# flatten/merge sublists
merged = [item for sublist in l for item in sublist]

# convert list to set
s = set(merged)

# define a set containing all numbers of the desired range
interval = set([i for i in range(0,11)])

# get the difference of both sets
# the difference are the elements which are missing
missing = interval.difference(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Constant memory, linear time, no dependencies:</p>
<pre><code>def missing(ll):
    present = [False for _ in range(21000 + 1)]

    for l in ll:
        for n in l:
            present[n] = True

    return [n for n, is_present in enumerate(present) if not is_present]
</code></pre>
</div>
<span class="comment-copy">Can you elaborate with maybe a smaller test example? Are you looking for the <b>values</b> not contained in the lists?</span>
<span class="comment-copy">Language to use? Also, as M4rtini said - you need to be a bit more specific.  There are probably at least a dozen ways to do what you want.  So you need to tells us a bit more. :-)</span>
<span class="comment-copy">I guess I could recreate the same with Python's own <code>set</code>s, but numpy is just as fine.</span>
<span class="comment-copy">The arguments should also be the other way around.</span>
<span class="comment-copy">numpy is more efficient on large arrays though.</span>
<span class="comment-copy">@NicoSchl√∂mer Why would you reverse the arguments?</span>
<span class="comment-copy">The task is to find the indices between <code>0</code> and <code>21000</code> which aren't in <code>a</code>.</span>
