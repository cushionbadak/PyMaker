<div class="post-text" itemprop="text">
<p>I have following structure of configuration files:</p>
<pre><code>app
  \config
     \development
        \__init__.py
        \settings.py
        \app_config.py
     \production
        \__init__.py
        \settings.py
        \app_config.py
     \testingpy
        \settings.py
        \app_config.py
     \settinngs.py
     \app_config.py
</code></pre>
<p>Actually <code>app.config.settings</code> just check environment variable <code>RUNTIME_ENV</code> (which could be <code>development|production|testing</code>, equivalent to one of <code>config</code>'s subfolders) and load corresponding settings.</p>
<p>I know only about importing with <code>importlib</code> which return to me module as local variable and I forced to write something like that:</p>
<pre><code>SCALA_URL = imported_settings.SCALA_URL
REDIS_URL = imported_settings.REDIS_URL
SOME_SETTINGS_VAR = imported_settings.REDIS_URL
.... tons of duplicated strings here, i.e. variables names are the same ...
</code></pre>
<p>Is there way to do something similar to python's expression: <code>from config.${RUNTIME_ENV}.settings import *</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The return value of <a href="https://docs.python.org/3/library/functions.html#globals" rel="nofollow"><code>globals()</code></a> is mutable.  You could do something like this:</p>
<pre><code>imported_foo = importlib.import_module('foo')
globals().update(vars(imported_foo))
</code></pre>
<p>Note that this imports underscore-prefixed things into the global namespace.  If you want to exclude those, write a dictionary comprehension that only includes the things you want.  For example:</p>
<pre><code>globals().update({name: value 
                  for name, value in vars(imported_foo).items()
                  if not name.startswith('_')})
</code></pre>
<p>This <em>does not work</em> with <code>locals()</code>, which returns a read-only value.  It is not reasonably possible to do that (<code>import *</code> into a non-global namespace), because Python has to know the names of all local variables at compile time in order to generate the correct <code>LOAD_FOO</code> instructions in the bytecode (along with a variety of other interesting problems such as identifying the variables captured by a <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" rel="nofollow">closure</a>).  You will find that <code>import *</code> is illegal inside a function or class:</p>
<pre><code>&gt;&gt;&gt; def foo():
...     from foo import *
... 
  File "&lt;stdin&gt;", line 1
SyntaxError: import * only allowed at module level
&gt;&gt;&gt; 
</code></pre>
<p>That's not just a matter of "<code>import *</code> is bad design."  It's a fundamental language limitation and can't be worked around with <code>importlib</code>.</p>
</div>
