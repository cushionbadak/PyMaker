<div class="post-text" itemprop="text">
<p>I am currently trying to translate Python's formal grammar (<a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">https://docs.python.org/3/reference/grammar.html</a>) into Rail Diagrams.
The website we are using <a href="http://www.bottlecaps.de/rr/ui" rel="nofollow">http://www.bottlecaps.de/rr/ui</a> is very helpful for most of it and we have changed many things by hand to fir the proper notation for it to create the rail diagram but there is still 50+ lines that are incorrect and very hard for us to fix as we are brand new to this. Is there an easier way to do this than changing it all by hand?</p>
<p><em>Note the website uses EBNF</em></p>
<p>Thanks for your time,</p>
</div>
<div class="post-text" itemprop="text">
<p>Write a parser that parses the grammar, then transform from parse-tree to required notation.</p>
<p>The transformation itself is fairly simple:</p>
<ul>
<li>replace '#' comment introducers by '//'</li>
<li>replace ':' tokens by '::='</li>
<li>replace '[' tokens by '('</li>
<li>replace ']' tokens by ')?'</li>
</ul>
<p>A suitable meta-grammar, in <a href="http://www.w3.org/TR/xquery/#EBNFNotation" rel="nofollow">W3C notation</a>, is</p>
<pre><code>Grammar  ::= Rule+ EOF
Rule     ::= Nonterminal ':' Alternatives
Alternatives
         ::= Alternative ( '|' Alternative )*
Alternative
         ::= ( Symbol ( '*' | '+' )? )*
Symbol   ::= Nonterminal
           | Terminal
           | '(' Alternatives ')'
           | '[' Alternatives ']'

&lt;?TOKENS?&gt;

Nonterminal
         ::= [a-z] [a-z_]*
Terminal ::= [A-Z] [A-Z_]*
           | "'" [^']+ "'"
EOF      ::= $
IgnorableWhitespace
         ::= [ #x9#xA#xD]+
           | '#' [^#xA]* [#xA]
          /* ws: definition */
</code></pre>
<p>Put it in <code>grammar.ebnf</code>, then use <a href="http://bottlecaps.de/rex/" rel="nofollow">REx</a> to create a parser for it, coded e.g. in <a href="https://www.w3.org/TR/xquery-30/" rel="nofollow">XQuery</a>, using this command line:</p>
<pre><code>   -xquery -tree
</code></pre>
<p>This gives you XQuery module <code>grammar.xquery</code>. Next, put the python grammar in <code>python.grammar</code>, and this XQuery program in <code>transform.xquery</code>:</p>
<pre><code>import module namespace p="grammar" at "grammar.xquery";
declare option saxon:output "method=text";
declare variable $input as xs:string external;
for $token in p:parse-Grammar(unparsed-text($input))//text()
return
  if (starts-with(normalize-space($token), "#")) then
    replace($token, "((^|&amp;#xA;)[\s])*#", "$1//")
  else
    switch ($token)
    case ":" return "::="
    case "[" return "("
    case "]" return ")?"
    default return $token
</code></pre>
<p>Then use <a href="http://sourceforge.net/projects/saxon/files/Saxon-HE/9.7/SaxonHE9-7-0-2J.zip/download" rel="nofollow">Saxon</a> to run it:</p>
<pre><code>  java net.sf.saxon.Query transform.xquery input=python.grammar &gt; python.ebnf
</code></pre>
<p>The result is what you were looking for.</p>
<p>Of course you can also use your favorite text editor to carefully do global replaces achieving the same. It's just so much more fun to do it right.</p>
</div>
