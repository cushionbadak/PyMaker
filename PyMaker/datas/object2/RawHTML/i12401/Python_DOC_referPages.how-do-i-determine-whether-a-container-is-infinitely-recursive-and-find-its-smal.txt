<div class="post-text" itemprop="text">
<p>I was reading <a href="https://stackoverflow.com/questions/2158395/flatten-an-irregular-list-of-lists-in-python">Flatten (an irregular) list of lists</a> and decided to adopt it as a Python exercise - a small function I'll occasionally rewrite without referring to the original, just for practice. The first time I tried this, I had something like the following:</p>
<pre><code>def flat(iterable):
    try:
        iter(iterable)
    except TypeError:
        yield iterable
    else:
        for item in iterable:
            yield from flatten(item)
</code></pre>
<p>This works fine for basic structures like nested <code>list</code>s containing numbers, but strings crash it because the first element of a string is a single-character string, the first element of which is itself, the first element of which is itself again, and so on. Checking the question linked above, I realized that that explains the check for strings. That gave me the following:</p>
<pre><code>def flatter(iterable):
    try:
        iter(iterable)
        if isinstance(iterable, str):
            raise TypeError
    except TypeError:
        yield iterable
    else:
        for item in iterable:
            yield from flatten(item)
</code></pre>
<p>Now it works for strings as well. However, I then recalled that a <code>list</code> can contain references to itself.</p>
<pre><code>&gt;&gt;&gt; lst = []
&gt;&gt;&gt; lst.append(lst)
&gt;&gt;&gt; lst
[[...]]
&gt;&gt;&gt; lst[0][0][0][0] is lst
True
</code></pre>
<p>So, a string isn't the only type that could cause this sort of problem. At this point, I started looking for a way to guard against this issue without explicit type-checking.</p>
<p>The following <code>flattener.py</code> ensued. <code>flattish()</code> is a version that just checks for strings. <code>flatten_notype()</code> checks whether an object's first item's first item is equal to itself to determine recursion. <code>flatten()</code> does this and then checks whether either the object or its first item's first item is an instance of the other's type. The <code>Fake</code> class basically just defines a wrapper for sequences. The comments on the lines that test each function describe the results, in the form <code>should be `desired_result` [&gt; `undesired_actual_result`]</code>. As you can see, each fails in various ways on <code>Fake</code> wrapped around a string, <code>Fake</code> wrapped around a <code>list</code> of integers, single-character strings, and multiple-character strings.</p>
<pre><code>def flattish(*i):
    for item in i:
        try: iter(item)
        except: yield item
        else:
            if isinstance(item, str): yield item
            else: yield from flattish(*item)

class Fake:
    def __init__(self, l):
        self.l = l
        self.index = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.index &gt;= len(self.l):
            raise StopIteration
        else:
            self.index +=1
            return self.l[self.index-1]
    def __str__(self):
        return str(self.l)

def flatten_notype(*i):
    for item in i:
        try:
            n = next(iter(item))
            try:
                n2 = next(iter(n))
                recur = n == n2
            except TypeError:
                yield from flatten(*item)
            else:
                if recur:
                    yield item
                else:
                    yield from flatten(*item)
        except TypeError:
            yield item

def flatten(*i):
    for item in i:
        try:
            n = next(iter(item))
            try:
                n2 = next(iter(n))
                recur = n == n2
            except TypeError:
                yield from flatten(*item)
            else:
                if recur:
                    yield item if isinstance(n2, type(item)) or isinstance(item, type(n2)) else n2
                else:
                    yield from flatten(*item)
        except TypeError:
            yield item


f = Fake('abc')

print(*flattish(f)) # should be `abc`
print(*flattish((f,))) # should be `abc` &gt; ``
print(*flattish(1, ('a',), ('bc',))) # should be `1 a bc`

f = Fake([1, 2, 3])

print(*flattish(f)) # should be `1 2 3`
print(*flattish((f,))) # should be `1 2 3` &gt; ``
print(*flattish(1, ('a',), ('bc',))) # should be `1 a bc`

f = Fake('abc')
print(*flatten_notype(f)) # should be `abc`
print(*flatten_notype((f,))) # should be `abc` &gt; `c`
print(*flatten_notype(1, ('a',), ('bc',))) # should be `1 a bc` &gt; `1 ('a',) bc`

f = Fake([1, 2, 3])     

print(*flatten_notype(f)) # should be `1 2 3` &gt; `2 3`
print(*flatten_notype((f,))) # should be `1 2 3` &gt; ``
print(*flatten_notype(1, ('a',), ('bc',))) # should be `1 a bc` &gt; `1 ('a',) bc`

f = Fake('abc')
print(*flatten(f)) # should be `abc` &gt; `a`
print(*flatten((f,))) # should be `abc` &gt; `c`
print(*flatten(1, ('a',), ('bc',))) # should be `1 a bc`

f = Fake([1, 2, 3])     

print(*flatten(f)) # should be `1 2 3` &gt; `2 3`
print(*flatten((f,))) # should be `1 2 3` &gt; ``
print(*flatten(1, ('a',), ('bc',))) # should be `1 a bc`
</code></pre>
<p>I've also tried the following with the recursive <code>lst</code> defined above and <code>flatten()</code>:</p>
<pre><code>&gt;&gt;&gt; print(*flatten(lst))
[[...]]
&gt;&gt;&gt; lst.append(0)
&gt;&gt;&gt; print(*flatten(lst))
[[...], 0]
&gt;&gt;&gt; print(*list(flatten(lst))[0])
[[...], 0] 0
</code></pre>
<p>As you can see, it fails similarly to <code>1 ('a',) bc</code> as well as in its own special way.</p>
<p>I read <a href="https://stackoverflow.com/questions/3109289/how-can-python-function-access-its-own-attributes">how can python function access its own attributes?</a> thinking that maybe the function could keep track of every object it had seen, but that wouldn't work either because our <code>lst</code> contains an object with matching identity and equality, strings contain objects that may only have matching equality, and equality isn't enough due to the possibility of something like <code>flatten([1, 2], [1, 2])</code>.</p>
<p>Is there any reliable way (i.e. doesn't simply check known types, doesn't require that a recursive container and its containers all be of the same type, etc.) to check whether a container holds iterable objects with potential infinite recursion, and reliably determine the smallest unique container? If there is, please explain how it can be done, why it is reliable, and how it handles various recursive circumstances. If not, please explain why this is logically impossible.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there's a reliable way to find out if an arbitrary iterable is infinite. The best we can is to yield primitives infinitely from such an iterable without exhausting the stack, for example:</p>
<pre><code>from collections import deque

def flat(iterable):

    d = deque([iterable])

    def _primitive(x):
        return type(x) in (int, float, bool, str, unicode)

    def _next():
        x = d.popleft()
        if _primitive(x):
            return True, x
        d.extend(x)
        return False, None

    while d:
        ok, x = _next()
        if ok:
            yield x


xs = [1,[2], 'abc']
xs.insert(0, xs)

for p in flat(xs):
    print p
</code></pre>
<p>The above definition of "primitive" is, well, primitive, but that surely can be improved.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's an issue with your test code that's unrelated to the recursive container issue you're trying to solve. The issue is that your <code>Fake</code> class is an iterator and can only be used once. After you iterate over all its values, it will always raise <code>StopIteration</code> when you try to iterate on it again.</p>
<p>So if you do multiple operations on the same <code>Fake</code> instance, you shouldn't expect to get anything be empty output after the first operation has consumed the iterator. If you recreate the iterator before each operation, you won't have that problem (and you can actually try addressing the recursion issue).</p>
<p>So on to that issue. One way to avoid infinite recursion is to maintain a stack with the objects that you're currently nested in. If the next value you see is already on the stack somewhere, you know it's recursive and can skip it. Here's an implementation of this using a list as the stack:</p>
<pre><code>def flatten(obj, stack=None):
    if stack is None:
        stack = []

    if obj in stack:
        yield obj

    try:
        it = iter(obj)
    except TypeError:
        yield obj
    else:
        stack.append(obj)
        for item in it:
            yield from flatten(item, stack)
        stack.pop()
</code></pre>
<p>Note that this can still yield values from the same container more than once, as long as it's not nested within itself (e.g. for <code>x=[1, 2]; y=[x, 3, x]; print(*flatten(y))</code> will print <code>1 2 3 1 2</code>).</p>
<p>It also does recurse into strings, but it will only do so for only one level, so <code>flatten("foo")</code> will yield the letters <code>'f'</code>, <code>'o'</code> and <code>'o'</code> in turn. If you want to avoid that, you probably do need the function to be type aware, since from the iteration protocol's perspective, a string is not any different than an iterable container of its letters. It's only single character strings that recursively contain themselves.</p>
</div>
<div class="post-text" itemprop="text">
<p>The scenario you ask about is very loosely defined.  As defined in your question, it is logically impossible "to check whether a container holds iterable objects with potential infinite recursion[.]"  The only limit on the scope of your question is "iterable" object.  The official Python documentation defines "<a href="https://docs.python.org/3/glossary.html#term-iterable" rel="nofollow noreferrer">iterable</a>" as follows:</p>
<blockquote>
<p>An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects, and objects of any classes you define with an <code>__iter__()</code> or <code>__getitem__()</code> method. [...]</p>
</blockquote>
<p>The key phrase here is "any classes [defined] with an <code>__iter__()</code> or <code>__getitem__()</code> method."  This allows for "iterable" objects with members that are generated on demand.  For example, suppose that someone seeks to use a bunch of string objects that automatically sort and compare in chronological order based on the time at which the particular string was created.  They either subclass str or reimplement its functionality, adding a timestamp associated with each pointer to a <code>timestampedString( )</code> object, and adjust the comparison methods accordingly.</p>
<p>Accessing a substring by index location is a way of creating a new string, so a <code>timestampedString( )</code> of <code>len( ) == 1</code> could legitimately return a <code>timestampedString( )</code> of <code>len( ) == 1</code> with the same character but a new timestamp when you access <code>timestampedString( )[0:1]</code>.  Because the timestamp is part of the specific object instance, there is no kind of identity test that would say that the two objects are the same unless any two strings consisting of the same character are considered to be the same.  You state in your question that this should not be the case.</p>
<p>To detect infinite recursion, you first need to add a constraint to the scope of your question that the container only contain static, i.e. pre-generated, objects.  With this constraint, any legal object in the container can be converted to some byte-string representation of the object.  A simple way to do this would be to pickle each object in the container as you reach it, and maintain a stack of the byte-string representations that result from pickling.  If you allow any arbitrary static object, nothing less than a raw-byte interpretation of the objects is going to work.</p>
<p>However, algorithmically enforcing the constraint that the container only contain static objects presents another problem: it requires type-checking against some pre-approved list of types such as some notion of primitives.  Two categories of objects can then be accommodated: single objects of a known-static type (e.g. primitives) and containers for which the number of contained items can be determined in advance.  The latter category can then be shown to be finite when that many contained objects have been iterated through and all have been shown to be finite.  Containers within the container can be handled recursively.  The known-static type single objects are the recursive base-case.</p>
<p>If the container produces more objects, then it violates the definition of this category of object.  The problem with allowing arbitrary objects in Python is that these objects can be defined in Python code that can use components written in C code and any other language that C can be linked to.  There is no way to evaluate this code to determine if it actually complies with the static requirement.</p>
</div>
<div class="post-text" itemprop="text">
<p>What about something like this:</p>
<pre><code>def flat(obj, used=[], old=None):        
    #This is to get inf. recurrences
    if obj==old:
        if obj not in used:
            used.append(obj)
            yield obj
        raise StopIteration
    try:
        #Get strings
        if isinstance(obj, str):
            raise TypeError
        #Try to iterate the obj
        for item in obj:
            yield from flat(item, used, obj)
    except TypeError:
        #Get non-iterable items
        if obj not in used:
            used.append(obj)
            yield obj
</code></pre>
<p>After a finite number of (recursion) steps a list will contain at most itself as iterable element (Since we have to generate it in finite many steps). That's what we test for with <code>obj==old</code> where <code>obj</code> in an element of <code>old</code>.</p>
<p>The list <code>used</code> keeps track of all elements since we want each element only once. We could remove it but we'd get an ugly (and more importantly not well-defined) behaviour on which elements get yield how often.
Drawback is that we store the entire list at the end in the list <code>used</code>...</p>
<p>Testing this with some lists seems to work: </p>
<pre><code>&gt;&gt; lst = [1]
&gt;&gt; lst.append(lst)
&gt;&gt; print('\nList1:   ', lst)       
&gt;&gt; print([x for x in flat(lst)])
List1:     [1, [...]]
Elements: [1, [1, [...]]]

#We'd need to reset the iterator here!
&gt;&gt; lst2 = []
&gt;&gt; lst2.append(lst2)
&gt;&gt; lst2.append((1,'ab'))
&gt;&gt; lst2.append(lst)
&gt;&gt; lst2.append(3)
&gt;&gt; print('\nList2:   ', lst2)       
&gt;&gt; print([x for x in flat(lst2)])
List2:     [[...], (1, 'ab'), [1, [...]], 3]
Elements: [[[...], (1, 'ab'), [1, [...]], 3], 1, 'ab', [1, [...]], 3]
</code></pre>
<p>Note: It actually makes sense that the infinite lists <code>[[...], (1, 'ab'), [1, [...]], 3]</code> and <code>[1, [...]]</code> are considered as elements since these actually contain themselves but if that's not desired one can comment out the first <code>yield</code> in the code above.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just avoid flattening recurring <em>containers</em>. In the example below <code>keepobj</code> keeps track of them and <code>keepcls</code> ignores containers of a certain type. I believe this works down to python 2.3.</p>
<pre><code>def flatten(item, keepcls=(), keepobj=()):
    if not hasattr(item, '__iter__') or isinstance(item, keepcls) or item in keepobj:
        yield item
    else:
        for i in item:
            for j in flatten(i, keepcls, keepobj + (item,)):
                yield j
</code></pre>
<p>It can flatten circular lists like <code>lst = [1, 2, [5, 6, {'a': 1, 'b': 2}, 7, 'string'], [...]]</code> and keep some containers like strings and dicts un-flattened.</p>
<pre><code>&gt;&gt;&gt; list(flatten(l, keepcls=(dict, str)))
[1, 2, 5, 6, {'a': 1, 'b': 2}, 7, 'string', [1, 2, [5, 6, {'a': 1, 'b': 2}, 7, 'string'], [...]]]
</code></pre>
<p>It also works with the following case:</p>
<pre><code>&gt;&gt;&gt; list(flatten([[1,2],[1,[1,2]],[1,2]]))
[1, 2, 1, 1, 2, 1, 2]
</code></pre>
<blockquote>
<p>You may want to keep some default classes in <code>keepcls</code> to make calling
  the function more terse.</p>
</blockquote>
</div>
<span class="comment-copy">I think this can be reduced to detecting cycles in directed graphs. So all solutions that apply there should apply here.: <a href="http://stackoverflow.com/questions/261573/best-algorithm-for-detecting-cycles-in-a-directed-graph" title="best algorithm for detecting cycles in a directed graph">stackoverflow.com/questions/261573/â€¦</a></span>
