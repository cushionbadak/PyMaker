<div class="post-text" itemprop="text">
<p>Using Python 3.5.1, I pulled in a text file where each line is in JSON form:
{"a":"windows", "b":"stairs"...}</p>
<pre><code>import json
path = 'folder/data.txt'
records=[json.loads(line) for line in open(path,'rb')]
</code></pre>
<p>But I received the error:</p>
<pre><code>the JSON object must be str, not 'bytes'
</code></pre>
<p>I have no problem printing the first line of file, so I am reassured that the file path is correct.</p>
</div>
<div class="post-text" itemprop="text">
<p>Open the file in text mode, not binary mode (possibly explicitly passing <code>encoding='utf-8'</code> to override the system default, since JSON is usually stored as UTF-8). The <code>json</code> module only takes <code>str</code> input; reading from a file opened in binary mode returns <code>bytes</code> objects:</p>
<pre><code># Using with statement just for good form; in this case it would work the
# same on CPython, but on other interpreters or different CPython use cases,
# it's easy to screw something up; use with statements all the time to build good habits
with open(path, encoding='utf-8') as f:
    records=[json.loads(line) for line in f]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try:
records=[json.loads(line.<strong>decode()</strong>) for line in open(path,'rb')]</p>
</div>
<div class="post-text" itemprop="text">
<p>You do not want to specify "rb", since binary representation of the file isn't going to be readable by the JSON module. You likely want "utf-8" encoding and "read". EDIT: I originally had said both of these are defaults, but it was brought to my attention that many OS's have different default encoding and that Python uses the system setting as default in open(). I would therefore recommend explicitly providing the encoding setting as "utf-8".</p>
<p>json supports loading from an open file with "json.load" instead of "json.loads", which loads from a string, so we can skip the read-in-as-text and go right to JSON. I don't think you'll want to "loads" individual lines, since this likely won't be valid JSON. </p>
<pre><code>import json
# open has __enter__ and __exit__ functions, so we can call it as a guard
# using "with" syntax and it'll close when the scope ends
with open(r".\myjson.json", encoding="utf-8") as fh:
    # load() is a convenience function to help us avoid iterating lines
    # on our own. It calls loads() on the whole doc and returns an obj
    json_obj = json.load(fh)
print (json_obj)
</code></pre>
</div>
<span class="comment-copy">Maybe get rid of the 'b' in your <code>open</code> call? <a href="https://docs.python.org/2/library/functions.html#open" rel="nofollow noreferrer">docs.python.org/2/library/functions.html#open</a> says that will load the file in binary form, which may be why it's not being taken as a string.</span>
<span class="comment-copy">If you take just one line of the file, can you load it to json? Like <code>json.loads(file.readlines()[0])</code></span>
<span class="comment-copy">@TW80000 your suggestion solves my problem. I also learned that passing <code>encoding='utf-8'</code> directly in the <code>open</code> call works as well. Thank you for your comment.</span>
<span class="comment-copy">This works and thank you for the advice on using proper form. Switching 'rb' out for 'encoding='utf-8' in my original code seems works as well.</span>
<span class="comment-copy">UTF-8 is not always the default <code>encoding</code>, <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">it's determined dynamically from platform dependent settings using <code>locale.getpreferredencoding(False)</code></a>. If you know the input is UTF-8, say so explicitly. Similarly, if someone wrote JSON blobs one-per-line, you can't load the whole file at once, because the whole file taken together isn't valid JSON, the lines are only legal JSON in isolation. Also, <code>json.load</code> just calls <code>file.read()</code> and passes to <code>loads</code>, so it's neither better nor worse than <code>loads</code>. Also, Py3 <code>print</code> needs parens.</span>
<span class="comment-copy">great points, @ShadowRanger. For load() vs loads(), I didn't mean to imply there was a performance gap here, but that there's a for loop which we do not need to write/read/maintain in our own code. Using load() has less noise, which is usually the pythonic way to do things. The print was me working in a 2.7 interpreter (my bad and fixed). The UTF-8 think you're totally right and I should have prefaced that with on Windows (not necessarily OP's case at all).</span>
<span class="comment-copy">Actually, on Windows, I don't think UTF-8 is the default, it's usually one of the Windows code pages (e.g. cp1252, a variation on latin-1 that replaces some of the usually unused control characters with additional printable characters, e.g. smart quotes). If the data was all ASCII, then you're fine either way (both UTF-8 and cp1252 are ASCII supersets), it's only when you reach outside the ASCII range that you'd have problems. Aside from the code pages, Windows usually uses UTF-16 for everything; it only accepts UTF-8 when dealing with data on the internet (where UTF-8 is the standard).</span>
