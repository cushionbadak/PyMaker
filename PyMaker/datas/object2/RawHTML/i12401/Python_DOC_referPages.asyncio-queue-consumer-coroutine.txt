<div class="post-text" itemprop="text">
<p>I have a <code>asyncio.Protocol</code> subclass receiving data from a server.
I am storing this data (each line, because the data is text) in a <code>asyncio.Queue</code>.</p>
<pre><code>import asyncio

q = asyncio.Queue()

class StreamProtocol(asyncio.Protocol):
    def __init__(self, loop):
        self.loop = loop
        self.transport = None

    def connection_made(self, transport):
        self.transport = transport

    def data_received(self, data):
        for message in data.decode().splitlines():
            yield q.put(message.rstrip())

    def connection_lost(self, exc):
        self.loop.stop()

loop = asyncio.get_event_loop()
coro = loop.create_connection(lambda: StreamProtocol(loop),
                              '127.0.0.1', '42')
loop.run_until_complete(coro)
loop.run_forever()
loop.close()
</code></pre>
<p>I want to have another coroutine responsible for consuming the data in the queue and processing it.</p>
<ul>
<li>Should this be a <code>asyncio.Task</code>?</li>
<li>What if the queue becomes empty because for a few seconds no data is received? How can I make sure my consumer doesn't stop (<code>run_until_complete</code>)?</li>
<li>Is there a cleaner way than using a global variable for my queue?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Should this be a asyncio.Task?</p>
</blockquote>
<p>Yes, create it using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="noreferrer">asyncio.ensure_future</a> or <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.create_task" rel="noreferrer">loop.create_task</a>.</p>
<blockquote>
<p>What if the queue becomes empty because for a few seconds no data is received?</p>
</blockquote>
<p>Simply use <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.get" rel="noreferrer">queue.get</a> to wait until an item is available:</p>
<pre><code>async def consume(queue):
    while True:
        item = await queue.get()
        print(item)
</code></pre>
<blockquote>
<p>Is there a cleaner way than using a global variable for my queue?</p>
</blockquote>
<p>Yes, simply pass it as argument to the consumer coroutine and stream protocol:</p>
<pre><code>class StreamProtocol(asyncio.Protocol):
    def __init__(self, loop, queue):
        self.loop = loop
        self.queue = queue

    def data_received(self, data):
        for message in data.decode().splitlines():
            self.queue.put_nowait(message.rstrip())

    def connection_lost(self, exc):
        self.loop.stop()
</code></pre>
<blockquote>
<p>How can I make sure my consumer doesn't stop (run_until_complete)?</p>
</blockquote>
<p>Once the connection is closed, use <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.join" rel="noreferrer">queue.join</a> to wait until the queue is empty.</p>
<hr/>
<p>Full example: </p>
<pre><code>loop = asyncio.get_event_loop()
queue = asyncio.Queue()
# Connection coroutine
factory = lambda: StreamProtocol(loop, queue)
connection = loop.create_connection(factory, '127.0.0.1', '42')
# Consumer task
consumer = asyncio.ensure_future(consume(queue))
# Set up connection
loop.run_until_complete(connection)
# Wait until the connection is closed
loop.run_forever()
# Wait until the queue is empty
loop.run_until_complete(queue.join())
# Cancel the consumer
consumer.cancel()
# Let the consumer terminate
loop.run_until_complete(consumer)
# Close the loop
loop.close()
</code></pre>
<p>Alternatively, you can also use <a href="https://docs.python.org/3/library/asyncio-stream.html?highlight=streams#tcp-echo-client-using-streams" rel="noreferrer">streams</a>:</p>
<pre><code>async def tcp_client(host, port, loop=None):
    reader, writer = await asyncio.open_connection(host, port, loop=loop)
    async for line in reader:
        print(line.rstrip())
    writer.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(tcp_client('127.0.0.1', 42, loop))
loop.close()
</code></pre>
</div>
<span class="comment-copy">Your code is wrong, sorry: <code>data_received</code> should be regular function, not a coroutine with <code>yield</code> inside. Moreover <code>asyncio.Queue</code> requires <code>yield from</code>, not just <code>yield</code>.</span>
<span class="comment-copy">Ah right. I put that there without testing it just to give the idea of what i wanted to do.</span>
<span class="comment-copy">Thanks! Looks like the right way to do it. I think there's a problem with your full example, the <code>coro</code> variable doesn't exist</span>
<span class="comment-copy">@toogy True, I just fixed it.</span>
<span class="comment-copy">Perfect. Just one last thing. What if I want my consumer to be more than a function (I mean a class)? Should I simply inherit the <code>asyncio.Task</code> class?</span>
<span class="comment-copy">@toggy No, just have your class define coroutines that you can schedule as task using <code>asyncio.ensure_future</code>.</span>
<span class="comment-copy">Thanks again Vincent</span>
