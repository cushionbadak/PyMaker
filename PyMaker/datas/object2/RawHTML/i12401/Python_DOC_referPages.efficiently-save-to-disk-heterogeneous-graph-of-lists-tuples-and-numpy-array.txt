<div class="post-text" itemprop="text">
<p>I am regularly dealing with large amounts of data (order of several GB), which are stored in memory in NumPy arrays. Often, I will be dealing with nested lists/tuples of such NumPy arrays. How should I store these to disk? I want to preserve the list/tuple structure of my data, the data has to be compressed to conserve disk space, and saving/loading needs to be fast.</p>
<p>(The particular use case I'm facing right now is a 4000-element long list of 2-tuples <code>x</code> where <code>x[0].shape = (201,)</code> and <code>x[1].shape = (201,1000)</code>.)</p>
<p>I have tried several options, but all have downsides:</p>
<ul>
<li><p><a href="https://docs.python.org/3.5/library/pickle.html" rel="nofollow"><code>pickle</code></a> storage into a <code>gzip</code> archive. This works well, and results in acceptable disk space usage, but is extremely slow and consumes a lot of memory while saving.</p></li>
<li><p><a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.savez_compressed.html" rel="nofollow"><code>numpy.savez_compressed</code></a>. Is much faster than <code>pickle</code>, but unfortunately only allows either a sequence of numpy arrays (not nested tuples/lists as I have) or a dictionary-style way of specifying the arguments.</p></li>
<li><p>Storing into HDF5 through <a href="http://www.h5py.org/" rel="nofollow"><code>h5py</code></a>. This seems too cumbersome for my relatively simple needs. More importantly, I looked a lot into this, and also there does not seem to be a straightforward way to store heterogeneous (nested) lists.</p></li>
<li><p><a href="https://github.com/telegraphic/hickle" rel="nofollow"><code>hickle</code></a> seems to do exactly what I want, however unfortunately it's incompatible with Python 3 at the moment (which is what I'm using).</p></li>
</ul>
<p>I was thinking of writing a wrapper around <code>numpy.savez_compressed</code>, which would determine the nested structure of the data, store this structure in some variable <code>nest_structure</code>, flatten the full graph, and store both <code>nest_structure</code> and all the flattened data using <code>numpy.savez_compressed</code>. Then, the corresponding wrapper around <a href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.load.html" rel="nofollow"><code>numpy.load</code></a> would understand the <code>nest_structure</code> variable, and re-create the graph and return it. However, I was hoping there is something like this already out there.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may like the <a href="https://docs.python.org/3/library/shelve.html" rel="nofollow" title="shelve"><code>shelve</code></a> package. It effectively wraps heterogeneous pickled objects in a convenient file. <code>shelve</code> is oriented more toward a "persistent storage" than classic save-to-file model. </p>
<p>The main benefit of using <code>shelve</code> is that you can conveniently save most kinds of structured data.  The main disadvantage of using <code>shelve</code> is that it is Python-specific. Unlike HDF-5 or saved Matlab files or even simple CSV files, it isn't so easy to use other tools with your data.</p>
<p>Example of saving (Out of habit, I created objects and copy them to <code>df</code>, but you don't need to do this. You could just save directly to items in <code>df</code>):</p>
<pre><code>import shelve
import numpy as np
a = np.arange(0, 1000, 12)
b = "This is a string"
class C(object):
   alpha = 1.0
   beta = [3, 4]
c = C()
class C(object):
   alpha = 1.0
   beta = [3, 4]
c = C()
df = shelve.open('test.shelve', 'c')
df['a'] = a
df['b'] = b
df['c'] = c
df.sync()
exit()
</code></pre>
<p>Following the above example, recovering data:</p>
<pre><code>import shelve
import numpy as np
class C():
   alpha = 1.0
   beta = [3, 4]
df = shelve.open('test.shelve')
print(df['a'])
print(df['b'])
print(df['c'].alpha)
</code></pre>
</div>
<span class="comment-copy">What version of python are you using? <code>cPickle</code> exists in python 2 and is considerably faster than <code>pickle</code>.</span>
<span class="comment-copy">@Dunes Python 3, in which the default <code>pickle</code> implementation is the same as Python 2's <code>cPickle</code>.</span>
<span class="comment-copy">Thanks, but I'm afraid <code>shelve</code> won't do it. It is a wrapper around <code>pickle</code>, which is either way too slow for my needs (when combining with <code>gzip</code>, see original post) or takes up way too much space (when not using compression).</span>
