<div class="post-text" itemprop="text">
<p>I'd like to create a <code>struct</code> that contains the data for stats_user, stats_password, and stats_ui together, instead of having to use them individually like this. How do I go about cleaning this?</p>
<pre><code>def config(apps, groups, stats_user, stats_password, stats_uri,
           bind_http_https, ssl_certs, templater):
    logger.info("generating config")
    config = templater.haproxy_head.format(
        statsUser=stats_user,
        statsPassword=stats_password,
        statsURI=stats_uri
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>It is a pretty bad idea to assign something to <code>config</code> inside a function named <code>config</code>.</p></li>
<li><p>Python doesn't have anything called a "struct", but if I understand you correctly, you can put it in a dictionary, and unroll it in the call to <code>.format</code>:</p></li>
</ol>
<p>‌</p>
<pre><code>data = {'statsUser': 'foo', 'statsPassword': 'bar', 'statsURI': 'bat'}
</code></pre>
<p>and</p>
<pre><code>def config(apps, groups, data, bind_http_https, ssl_certs, templater):
    logger.info("generating config")
    config = templater.haproxy_head.format(**data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <code>namedtuple</code>. See here: <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow">https://docs.python.org/3/library/collections.html#collections.namedtuple</a></p>
<p>Something like:</p>
<pre><code>from collections import namedtuple
Stats = namedtuple('Stats', ['user', 'password', 'uri'])
</code></pre>
<p>You can then create a Stats object with positional arguments, keyword arguments or a mix:</p>
<pre><code>s1 = stats(stats_user, stats_password, stats_uri) # positional
s2 = stats(user=stats_user, password=stats_password, uri=stats_uri) # keyword
s3 = stats(stats_user, stats_password, uri=stats_uri)
</code></pre>
<p>Members may be accessed like any other object (e.g. <code>s1.user</code>)    </p>
<p>In your code, you could use one of these objects as:</p>
<pre><code>config = templater.haproxy_head.format(**s1._asdict())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many ways to accomplish this. You could create a <a href="https://docs.python.org/3.5/tutorial/classes.html#classes" rel="nofollow">class</a>, or you could use a <a href="https://docs.python.org/3.5/library/stdtypes.html#mapping-types-dict" rel="nofollow">dictionary</a>, or you could use a <a href="https://docs.python.org/3.5/library/collections.html#collections.namedtuple" rel="nofollow">named tuple</a>.</p>
<p>It's not entirely clear from your question how you intend to use them, but with all of these solutions (class, dictionary, named tuple) you can pass the objects around as a single entity. </p>
<h2>Custom class</h2>
<p>A class is the most expressive solution. You can define a class that has the attributes you want, but you can also attach methods that work with the data in the class. Classes can also inherit from or be composed of other classes.</p>
<pre><code># accept stats as a single argument, but then use each
# piece of data separately
def config(..., stats, ...):
    templater.haproxy_head.format(
        statsUser = stats.username,
        statsPassword=stats.password,
        statsURI = stats.uri
    )

# define the "Stats" class
class Stats(object):
   def __init__(self, username, password, uri):
        self.username = username
        self.password = password
        self.uri = uri

# create a stats object
stats = Stats("homer", "doh", "www.example.com")
...

# pass the object to config
config(..., stats, ...)
</code></pre>
<h2>Named tuple</h2>
<p>A named tuple is very similar to a class, but is a bit simpler to set up. All you need to do is define the name, and a list of attributes. What you get back is a custom class.</p>
<p>Another important distinction is that they are immutable. Once you create a named tuple, you can't change the values that it contains. </p>
<pre><code>import collections

# accept stats as a single argument, but then use each
# piece of data separately
def config(..., stats, ...):
    templater.haproxy_head.format(
        statsUser = stats.username,
        statsPassword=stats.password,
        statsURI = stats.uri
    )
# define the Stats named tuple
Stats = collections.namedtuple("Stats", ["username", "password", "uri"])

# create a stats object
stats = Stats("homer", "doh", "www.example.com")
...

# pass the object to config
config(..., stats, ...)
</code></pre>
<p>Notice that in actual usage, classes and named tuples are identical. In both cases you use "dot notation" to access the elements of the object (eg: stats.username).</p>
<h2>Dictionary</h2>
<p>A dictionary has the least amount of overhead. It is just a mapping of names to values. </p>
<pre><code># accept stats as a single argument, but then use each
# piece of data separately
def config(..., stats, ...):
    templater.haproxy_head.format(
        statsUser = stats["username",
        statsPassword=stats["password"],
        statsURI = stats["uri"]
    )
# define the stats
stats = {
    "username": "homer",
    "password": "doh",
    "uri": "http://www.example.com"
}
# pass them to the config function as a single object
config(..., stats, ...)
</code></pre>
<p>A dictionary differs from classes and named tuples in that you reference the elements by giving the item name as a key (eg: stats["username"]).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a dictionary:</p>
<pre><code>stats = {user: stats_user, password: stats_password, uri: stats_uri}
</code></pre>
<p>Then access each with the following:</p>
<pre><code>print(stats["user"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create your own struct-like <code>dict</code> subclass which is its own <code>__dict__</code>. The basic concept is the same as that of the ActiveState <a href="http://code.activestate.com/recipes/576972-attrdict/" rel="nofollow">AttrDict</a> recipe, but the implementation is simpler. The result is mutable than you need since both an instance's attributes and their values are changeable. Although the attributes aren't ordered, you can iterate through the current ones and/or their values by using the base classes <code>keys()</code> and <code>values()</code> methods (and/or <code>iterkeys()</code> and <code>itervalues()</code> in Python 2).</p>
<pre><code>class Struct(dict):
    def __init__(self, *args, **kwargs):
        super(Struct, self).__init__(*args, **kwargs)
        self.__dict__ = self

stats = Struct(user='Mohamed', password='secret', uri='bit.ly/1Syb5DU')

print('stats.user: {}'.format(stats.user))
print('stats.password: {}'.format(stats.password))
print('stats.uri: {}'.format(stats.password))

print("stats['user']: {}".format(stats['user']))
print("stats['password']: {}".format(stats['password']))
print("stats['uri']: {}".format(stats['uri']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm answering my question for reference, here is how my code looks like now (this works and acts as wanted):</p>
<pre><code>def config(apps, groups, stats_data, bind_http_https, ssl_certs, templater):
   logger.info("generating config")
   config = templater.haproxy_head.format(**stats_data)
   groups = frozenset(groups)
</code></pre>
<p>My struct is a dictionary and I initiated it as follows:</p>
<pre><code>stats_data = {'statsUser': '', 'statsPassword': '', 'statsURI': ''}
</code></pre>
<p>I have an argument parser named <code>args</code> and this is how I am assigning values to my keys in my <code>dict</code></p>
<pre><code>stats_data['statsUser']= args.stats_user
stats_data['statsPassword']= args.stats_password
stats_data['statsURI']= args.stats_uri
</code></pre>
</div>
<span class="comment-copy">Python doesn't have structs.</span>
<span class="comment-copy">What would be a nice work around then?</span>
<span class="comment-copy">@L3viathan: python doesn't specifically have something named <i>struct</i>, but it has things that work very much like a struct.</span>
<span class="comment-copy">Thanks a ton! Appreciate the help :)</span>
<span class="comment-copy">another important difference is that named tuples are immutable, unlike dictionaries and objects.</span>
<span class="comment-copy">@HåkenLid: good point. I'll update my answer.</span>
<span class="comment-copy">@Bryan: In C/C++ the value of a <code>struct</code> variable <i>can</i> be changed, so a <code>namedtuple</code> is not similar to one in that respect.</span>
<span class="comment-copy">Thanks @martineau: I've updated my answer. My days of using compiled languages with structs are a couple decades back in my rear view mirror. I should have known better.</span>
