<div class="post-text" itemprop="text">
<p>So I'm kind of new in Python. I'm doing a log in form that redirects you to a python script running in a linux server to authenticate the user. I'm using multiple commands at once to see if the user is in the database. 
The command is echo "$password" | login -p -h 192.0.. $user &gt;/dev/null 2&gt;&amp;1
and when I echo $? it supposed to return a 0 if it's in the database or a 1 if it's not.</p>
<p>In the python script I have this:</p>
<pre><code>import cgi,shlex,subprocess

form = cgi.FieldStorage()

params={}

for key in form.keys():
   params[key]= form[key].value

user_name_variable=params['id']
password_variable=params['pwd']

command1="login -p -h 192.0. "+user_name_variable+" &gt;/dev/null 2&gt;&amp;1"
command2="echo "+password_variable
command3="'echo $?'"
p1=subprocess.Popen(shlex.split(command2),shell=True,stdout=subprocess.PIPE)
p2=subprocess.Popen(shlex.split(command1),shell=True,stdin=p1.stdout, stdout=subprocess.PIPE)
p3=subprocess.Popen(shlex.split(command3),shell=True, stdin=p2.stdout, stdout=subprocess.PIPE)
p1.stdout.close()
p2.stdout.close()
out, err= p3.communicate()[0]
</code></pre>
<p>and out comes up to be 0 always even if the input is wrong. Is there something wrong that I'm doing with the PIPE? What I know is that the problem is not when I'm passing the variables because I am getting the right variables. The problem must be in the chaining. I would appreciate your help. Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>$?</code> is a shell variable, it's not going to be meaningful here (each subprocess is run in its own subshell with <code>shell=True</code>; the <code>$?</code> from <code>login</code> is only visible in its shell, not the one you try to <code>echo $?</code> in).</p>
<p>But <code>Popen</code> objects already provide their exit status, so you don't need to run anything at all. You're also trying to use <code>shlex.split</code> to split commands with shell elements illegally (you either pass a single string and <code>shell=True</code>, or a sequence of arguments with <code>shell=False</code>; mixing them is illegal). You can shave off a lot of processes here too, and avoid running commands that would include the password in their command line:</p>
<pre><code># Define command as a list directly; making a string and splitting it is silly
command1 = ['login', '-p', '-h', '192.0.', user_name_variable]

# Only need a single Popen; we can pass it stdin and read its status directly
# As the shell command did, we throw away stdout and keep stderr
p1=subprocess.Popen(command1, stdin=subprocess.PIPE, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)


# Sends the password, closes proc stdin, waits for proc to complete slurping
# the stderr (stdout was thrown away so it's returned empty)
_, err = p1.communicate(password_variable)

# Process is complete, so we can just ask for the return code
if p1.returncode != 0:
     ... handle failed run ...
</code></pre>
<p>Note: <a href="https://docs.python.org/3/library/subprocess.html#subprocess.DEVNULL" rel="nofollow"><code>subprocess.DEVNULL</code></a> is new in 3.3; if you're on older Python, substitute:</p>
<pre><code>with open('/dev/null', 'wb') as devnull:
    p1 = subprocess.Popen(command1, stdin=subprocess.PIPE, stdout=devnull, stderr=subprocess.PIPE)
</code></pre>
<p>or just change it to <code>subprocess.PIPE</code> and ignore the captured stdout output.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, that approach doesn't work in bash, either:</p>
<pre class="lang-sh prettyprint-override"><code>false | echo $?  # echoes 0
</code></pre>
<p>Skip <code>p3</code>, and instead of <code>p3.communicate</code>, run <code>p2.communicate</code>. After that, <a href="https://docs.python.org/2/library/subprocess.html?highlight=subprocess#subprocess.Popen.returncode" rel="nofollow">simply check <code>p2.returncode</code></a>.</p>
</div>
