<div class="post-text" itemprop="text">
<p>Given the function that takes <code>x</code> and manipulate <code>x</code> as such:</p>
<pre><code>&gt;&gt;&gt; x = [5,3,0,0]
&gt;&gt;&gt; j = 1
&gt;&gt;&gt; for i, xi in enumerate(x):
...     if xi == 0:
...             x[i] = 1.0/2**j
...             j+=1
... 
&gt;&gt;&gt; x
[5, 3, 0.5, 0.25]
</code></pre>
<p>And in a function:</p>
<pre><code>def f(x):
  j = 1
  for i, xi in enumerate(x):
    if xi == 0:
      x[i] = 1.0/2**j
      j+=1
  return x
</code></pre>
<p><strong>I want to change it into a lambda function but how is that possible when it uses an extra variable that not in my loop?</strong></p>
<p>Without the complication of <code>j+=1</code> and considering <code>j</code> as a constant I could do this:</p>
<pre><code>j = 1
f = lambda x: [1.0/2**j if xi == 0 else xi for i, xi in enumerate(x)]
</code></pre>
<p>But I need the j to change when it if statement is made. <strong>How can that be achieved in a lambda function?</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You could make <code>j</code> an <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow"><code>itertools.count()</code> object</a>; each time you call <code>next()</code> on it it'll yield the next value in the sequence:</p>
<pre><code>from itertools import count

j = count(1)
f = lambda x: [1.0 / 2 ** next(j) if xi == 0 else xi for i, xi in enumerate(x)]
</code></pre>
<p>This works because you only ever ask for that next value when <code>x == 0</code> is true.</p>
<p>However, you now need to <em>reset</em> <code>j</code> each time you want to use the <code>lambda</code>. You could incorporate it into your list comprehension as an extra one-element tuple to loop over:</p>
<pre><code>f = lambda x: [1.0 / 2 ** next(j) if xi == 0 else xi
               for j in (count(1),)
               for i, xi in enumerate(x)]
</code></pre>
<p>All this is <em>not all that readable</em>. I'd stick with the <code>def</code> function object instead.</p>
<p>As a side note, you could use <code>or</code> to replace the <code>.. if xi == 0 else xi</code> expression; <code>xi == 0</code> makes <code>xi</code> falsey:</p>
<pre><code>f = lambda x: [xi or 1.0 / 2 ** next(j)
               for j in (count(1),)
               for i, xi in enumerate(x)]
</code></pre>
</div>
<span class="comment-copy">Why do you need to create a <code>lambda</code> for this? What advantages do you feel that gives you? A <code>lambda</code> is nothing more than limited method of creating a function object in an expression.</span>
<span class="comment-copy">You can't really do what you want, not without <b>very ugly</b> hacks with mutable objects and <code>or</code> expressions. Readability<b>will</b> be severely compromised.</span>
<span class="comment-copy">It's because of a larger part of the code where there're many different variants of this function, and this function is passed on to another to manipulate <code>x</code>.</span>
<span class="comment-copy">To give the background, it's from this PR suggestion to convert these functions into some sort of pass-able function into another: <a href="https://github.com/nltk/nltk/pull/1270" rel="nofollow noreferrer">github.com/nltk/nltk/pull/1270</a></span>
<span class="comment-copy">Oh cool! Why didn't I think of that? hahaha.</span>
<span class="comment-copy">Yeah, I agree that it's not readable too!</span>
