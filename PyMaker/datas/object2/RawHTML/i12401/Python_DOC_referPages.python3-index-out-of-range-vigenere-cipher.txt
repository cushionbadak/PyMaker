<div class="post-text" itemprop="text">
<p>I'm starting out on making code to carry out Vigenere cipher encryption. First, I want to make the key. The key needs to be repeated over and over till it matches the length of the message to be encrypted so I created a function that would do this for me:</p>
<pre><code>def makekey(key, message):
    finalkey = []
    print(message) # to see if the key fits under the message correctly
    key = list(key)
    while len(finalkey) &lt; len(message): # while the key is shorter than the message
        for i in range(0, len(key)): # iterate through characters in the key
            finalkey.append(key[i]) # append the characters in the processed key list
                if len(finalkey) &gt; len(message): # if the final key is still bigger than the message
                    difference = len(finalkey) - len(message) # finds the difference between the two
                    del key[-difference] # removes the difference
    return ''.join(finalkey) # joins the final key into a string

print(makekey("LOVE", "Python")) # calling the function
</code></pre>
<p>The output should look like:</p>
<pre><code>Python
LOVELO
</code></pre>
<p>But the program just gives me an index out of range error and I have no idea what's going on!</p>
<p>Error message:</p>
<pre><code>Traceback (most recent call last):
  File "test.py", line 14, in &lt;module&gt;
    print(makekey("LOVE", "Python")) # calling the function
  File "test.py", line 8, in makekey
    finalkey.append(key[i]) # append the characters in the processed key list
IndexError: list index out of range
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason your code doesn't work:</p>
<pre><code>del key[-difference]
</code></pre>
<p>Should have been:</p>
<pre><code>del finalkey[-difference]
</code></pre>
<p>You get an <code>IndexError</code> from trying to access <code>key[3]</code> in the line <code>finalkey.append(key[i])</code> (where i=3) after you deleted that element.</p>
<p>And just for fun, here's an alternate implementation.</p>
<pre><code>def make_key(key, message):
    """ Returns a string that repeats the `key` string until it's
        the length of the `message` string
    """
    if len(key) &lt; len(message):  # only lengthen key if it's too short
        # In python, "abc" * 3 == "abcabcabc"
        # so what would we need to multiply our `key` by to get
        # it to be as long as `message`, or longer?
        # A guaranteed answer is: floor(len(message) / len(key)) + 1
        multiplier = (len(message) // len(key)) + 1
        key = key * multiplier
    # now we have a `key` that is at least as long as `message`
    # so return a slice of the key where the end of the slice == len(message)
    return key[:len(message)]

print(makekey("LOVE", "Python"))
</code></pre>
<p>Prints: <code>LOVELO</code></p>
<h3>Edit - cryptic one-liner solution</h3>
<p>If you want to make everyone who reads your code roll their eyes at you, you could try this:</p>
<pre><code>from itertools import islice, cycle
key = "LOVE"
message = "Python"
finalkey = ''.join(islice(cycle(key), len(message)))
</code></pre>
<p>The <code>cycle</code> function takes an <code>iterable</code> object - in our case, the <code>key</code> string - and repeats it in an infinite loop. So, if we create <code>cycle("LOVE")</code> it will generate <code>"L", "O", "V", "E", "L", "O", "V", "E", "L" ...</code> forever.</p>
<p>The <code>islice</code> function allows us to take a "slice" of an iterator object. In Python, "slice" is the term for the <code>[0:3]</code> part of the expression <code>new = old[0:3]</code> - we "sliced" out a sub-set of the original. Since we don't want our string to be infinitely long - which wouldn't be very useful - we want to just take a slice of the <code>cycle</code> we created:</p>
<p><code>islice(cycle(key), len(message)</code></p>
<p>This takes our iterator - <code>cycle(key)</code> - and slices it starting from index 0 and ending at index <code>len(message)</code>. This will return another iterator - this time, one that isn't infinite. The contents of the iterator are now: <code>"L", "O", "V", "E", "L", "O"</code>.</p>
<p>Now, we just need to stitch that <code>islice</code> back up into a whole string:</p>
<p><code>''.join(islice...) == "LOVELO"</code></p>
<p>Just to give you another tool in your toolbox!</p>
</div>
<span class="comment-copy">there is a simpler way using <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer">cycle</a></span>
<span class="comment-copy">itertools -&gt; cycle.</span>
<span class="comment-copy">Wait so, how does your version of the code work and do you know what went wrong with my code?</span>
<span class="comment-copy">@user3124306 I've finished editing my reply to fully answer your question. I've also submitted some suggested edits to the question itself.</span>
<span class="comment-copy">Thank you! Darn, I feel so stupid for not realizing what I did -- I swear I went over the code thrice... Also, what do you mean by 'floor' when you say 'floor(len(message) / len(key)) + 1'?</span>
<span class="comment-copy">When dividing two numbers, taking the "floor" of the result is rounding it to the nearest LOWEST integer (to round up, the term is "ceiling"). In Python3 the operator for this is <code>//</code> (integer division). So I want to see how many <i>whole</i> times the key will fit into the message, and ignore the decimal. So let's say <code>len(message) == 10</code> and <code>len(key) == 3</code> - <code>10//3 == 3</code>. But, at this point, if I do <code>key * 3</code> I'll only have 9 characters - so just add 1 to the result. <code>(10//3) + 1 == 4</code> and <code>len(key*4) &gt; len(message)</code> is guaranteed <code>True</code>.</span>
<span class="comment-copy">Thank you so much, Best answer and explanations I've gotten so far on stackoverflow!</span>
