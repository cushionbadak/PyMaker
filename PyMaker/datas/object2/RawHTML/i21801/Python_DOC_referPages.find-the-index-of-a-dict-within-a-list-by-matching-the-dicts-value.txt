<div class="post-text" itemprop="text">
<p>I have a list of dicts:</p>
<pre><code>list = [{'id':'1234','name':'Jason'},
        {'id':'2345','name':'Tom'},
        {'id':'3456','name':'Art'}]
</code></pre>
<p>How can I efficiently find the index position [0],[1], or [2] by matching on name = 'Tom'?</p>
<p>If this were a one-dimensional list I could do list.index() but I'm not sure how to proceed by searching the values of the dicts within the list.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>tom_index = next((index for (index, d) in enumerate(lst) if d["name"] == "Tom"), None)
# 1
</code></pre>
<p>If you need to fetch repeatedly from name, you should index them by name (using a dictionary), this way <em>get</em> operations would be O(1) time. An idea:</p>
<pre><code>def build_dict(seq, key):
    return dict((d[key], dict(d, index=index)) for (index, d) in enumerate(seq))

info_by_name = build_dict(lst, key="name")
tom_info = info_by_name.get("Tom")
# {'index': 1, 'id': '2345', 'name': 'Tom'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple readable version is</p>
<pre><code>def find(lst, key, value):
    for i, dic in enumerate(lst):
        if dic[key] == value:
            return i
    return -1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It won't be efficient, as you need to walk the list checking every item in it (O(n)). If you want efficiency, you can use <strong>dict of dicts</strong>. 
On the question, here's one possible way to find it (though, if you want to stick to this data structure, it's actually more efficient to <strong>use a generator</strong> as Brent Newey has written in the comments; see also tokland's answer):</p>
<pre><code>&gt;&gt;&gt; L = [{'id':'1234','name':'Jason'},
...         {'id':'2345','name':'Tom'},
...         {'id':'3456','name':'Art'}]
&gt;&gt;&gt; [i for i,_ in enumerate(L) if _['name'] == 'Tom'][0]
1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a function that finds the dictionary's index position if it exists.</p>
<pre><code>dicts = [{'id':'1234','name':'Jason'},
         {'id':'2345','name':'Tom'},
         {'id':'3456','name':'Art'}]

def find_index(dicts, key, value):
    class Null: pass
    for i, d in enumerate(dicts):
        if d.get(key, Null) == value:
            return i
    else:
        raise ValueError('no dict with the key and value combination found')

print find_index(dicts, 'name', 'Tom')
# 1
find_index(dicts, 'name', 'Ensnare')
# ValueError: no dict with the key and value combination found
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems most logical to use a filter/index combo:</p>
<pre><code>names=[{}, {'name': 'Tom'},{'name': 'Tony'}]
names.index(filter(lambda n: n.get('name') == 'Tom', names)[0])
1
</code></pre>
<p>And if you think there could be multiple matches:</p>
<pre><code>[names.index(n) for item in filter(lambda n: n.get('name') == 'Tom', names)]
[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For a given iterable, <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.locate" rel="nofollow noreferrer"><code>more_itertools.locate</code></a> yields positions of items that satisfy a predicate.</p>
<pre><code>import more_itertools as mit


iterable = [
    {"id": "1234", "name": "Jason"},
    {"id": "2345", "name": "Tom"},
    {"id": "3456", "name": "Art"}
]

list(mit.locate(iterable, pred=lambda d: d["name"] == "Tom"))
# [1]
</code></pre>
<p><a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> is a third-party library that implements <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a> among other useful tools.</p>
</div>
<span class="comment-copy">"list" is the list constructor, you better choose another name for a list (even in a example). And what should be the response if no element is found? raise an exception? return None?</span>
<span class="comment-copy">If you're going to need this a lot, use a more appropriate data structure (perhaps <code>{ 'Jason': {'id': '1234'}, 'Tom': {'id': '1245'}, ...}</code>?)</span>
<span class="comment-copy">@delnan Because that's a recipe for disaster! If anything, it should be <code>{'1234': {'name': 'Jason'}, ...}</code>. Not that that would help this use-case.</span>
<span class="comment-copy">+1 Beat me to it.</span>
<span class="comment-copy">+1 for the more generic solution, which seems nice</span>
<span class="comment-copy">IMHO this is not as readable or Pythonic is @Emile's answer. Because the intention is not really to create a generator (and using <code>next()</code> for this seems weird to me), the aim is just to get the index. Also, this raises StopIteration, whereas the Python <code>lst.index()</code> method raises ValueError.</span>
<span class="comment-copy">@gdw2: I get <code>SyntaxError: Generator expression must be parenthesized if not sole argument</code> when doing that.</span>
<span class="comment-copy">@avoliva add a parenthesis around next like follows <code>next((index for (index, d) in enumerate(lst) if d["name"] == "Tom"), None)</code></span>
<span class="comment-copy">This seems the most readable and Pythonic. It also mimics the behaviour of <code>str.find()</code> nicely. You could also call it <code>index()</code> and raise a <code>ValueError</code> instead of returning -1 if that was preferable.</span>
<span class="comment-copy">Agreed - by returning -1 when no match is found, you'll always get the last dict in the list, which is probably not what you want. Better to return None and check for exsistence of a match in the calling code.</span>
<span class="comment-copy">You can gain the efficiency you desire by using a generator. See tokland's answer.</span>
<span class="comment-copy">@Brent Newey: The generator does not change the fact, that you have to traverse the entire list, making the search O(n) as aeter claims... Depending on how long that list is, the difference between using a generator vs using a for loop or whatever might be neglible, wheras the difference between using a dict vs. using a list might not</span>
<span class="comment-copy">@Brent: You are right, but can it beat a O(1) lookup in a dictionary, moreover if the searched item is at the end of the list?</span>
<span class="comment-copy">@Dirk The next() call on the generator stops when a match is found, therefore it does not have to traverse the entire list.</span>
<span class="comment-copy">@aeter You make a fair point. I was referring to being able to stop when a match is found.</span>
