<div class="post-text" itemprop="text">
<p>This is pretty simple but I'd love a pretty, pythonic way of doing it. Basically, given a dictionary, return the subdictionary that contains only those keys that start with a certain string. </p>
<pre><code>» d = {'Apple': 1, 'Banana': 9, 'Carrot': 6, 'Baboon': 3, 'Duck': 8, 'Baby': 2}
» print slice(d, 'Ba')
{'Banana': 9, 'Baby': 2, 'Baboon': 3}
</code></pre>
<p>This is fairly simple to do with a function:</p>
<pre><code>def slice(sourcedict, string):
    newdict = {}
    for key in sourcedict.keys():
        if key.startswith(string):
            newdict[key] = sourcedict[key]
    return newdict
</code></pre>
<p>But surely there is a nicer, cleverer, more readable solution? Could a generator help here? (I never have enough opportunities to use those). </p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<p>in python 2.x :</p>
<pre><code>def slicedict(d, s):
    return {k:v for k,v in d.iteritems() if k.startswith(s)}
</code></pre>
<p>In python 3.x :</p>
<pre><code>def slicedict(d, s):
    return {k:v for k,v in d.items() if k.startswith(s)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In functional style:</p>
<p><code>dict(filter(lambda item: item[0].startswith(string),sourcedict.iteritems()))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>In <a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow">Python 3</a> use <code>items()</code> instead:</p>
<pre><code>def slicedict(d, s):
    return {k:v for k,v in d.items() if k.startswith(s)}
</code></pre>
</div>
<span class="comment-copy">Don't obscure python code just because it is possible. The whole idea of python is readability. If you just need obscure power, use Perl.</span>
<span class="comment-copy">Also see <a href="http://pythoncentral.io/how-to-slice-custom-objects-classes-in-python/" rel="nofollow noreferrer">pythoncentral.io/how-to-slice-custom-objects-classes-in-python</a>, you can customize <code>__getitem__</code> in your own type/subclass of dict.</span>
<span class="comment-copy">Don't shadow the <code>slice</code> built-in (even though almost no one uses it).</span>
<span class="comment-copy">That dict comprehension is delicious. And I had no idea <code>slice</code> was a builtin, wtf?</span>
<span class="comment-copy">@Ignacio: When you're in a tiny, local function, it really isn't always worth worrying about stepping on builtins--there are too many of them, with far too common names.  Better just to worry about it for nontrivial functions (if that) and globals.  Builtins aren't keywords, after all.</span>
<span class="comment-copy">No dictionary comprehension way <code>dict((k, v) for k,v in d.iteritems() if k.startswith(s))</code></span>
<span class="comment-copy">in 2017: python can comprehension a dict purely using <code>in</code>: <code>{k:d[k] for k in d if k.startswith(s)}</code>, no more need to invoke a function call.</span>
<span class="comment-copy">In Python, functional style is usually just what you don't want.</span>
<span class="comment-copy">Eh? The dict-comprehension approach certainly falls under my definition of "functional style".</span>
