<div class="post-text" itemprop="text">
<p>I know virtual methods from PHP or Java.</p>
<p>How can they be implemented in Python?</p>
<p>Or have I to define an empty method in an abstract class and override it?</p>
</div>
<div class="post-text" itemprop="text">
<p>Sure, and you don't even have to define a method in the base class. In Python methods are better than virtual - they're completely dynamic, as the typing in Python is <em>duck typing</em>.</p>
<pre><code>class Dog:
  def say(self):
    print "hau"

class Cat:
  def say(self):
    print "meow"

pet = Dog()
pet.say() # prints "hau"
another_pet = Cat()
another_pet.say() # prints "meow"

my_pets = [pet, another_pet]
for a_pet in my_pets:
  a_pet.say()
</code></pre>
<p><code>Cat</code> and <code>Dog</code> in Python don't even have to derive from a common base class to allow this behavior - you gain it for free. That said, some programmers prefer to define their class hierarchies in a more rigid way to document it better and impose <em>some</em> strictness of typing. This is also possible - see for example the <a href="https://docs.python.org/3/library/abc.html" rel="noreferrer"><code>abc</code> standard module</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python methods are always virtual.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>raise NotImplementedError()</code></strong></p>
<p>This is the recommended exception to raise on "pure virtual methods" of "abstract" base classes that don't implement a method.</p>
<p><a href="https://docs.python.org/3.5/library/exceptions.html#NotImplementedError" rel="noreferrer">https://docs.python.org/3.5/library/exceptions.html#NotImplementedError</a> says:</p>
<blockquote>
<p>This exception is derived from <code>RuntimeError</code>. In user defined base classes, abstract methods should raise this exception when they require derived classes to override the method.</p>
</blockquote>
<p>As others said, this is mostly a documentation convention and is not required, but this way you get a more meaningful exception than a missing attribute error.</p>
<p>E.g.:</p>
<pre><code>class Base(object):
    def virtualMethod(self):
        raise NotImplementedError()
    def usesVirtualMethod(self):
        return self.virtualMethod() + 1

class Derived(Base):
    def virtualMethod(self):
        return 1

print Derived().usesVirtualMethod()
Base().usesVirtualMethod()
</code></pre>
<p>gives:</p>
<pre><code>2
Traceback (most recent call last):
  File "./a.py", line 13, in &lt;module&gt;
    Base().usesVirtualMethod()
  File "./a.py", line 6, in usesVirtualMethod
    return self.virtualMethod() + 1
  File "./a.py", line 4, in virtualMethod
    raise NotImplementedError()
NotImplementedError
</code></pre>
<p>Related: <a href="https://stackoverflow.com/questions/13646245/is-it-possible-to-make-abstract-classes-in-python">Is it possible to make abstract classes in Python?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, in version 2.6 python provides something called <strong>abstract base classes</strong> and you can explicitly set virtual methods like this:</p>
<pre><code>from abc import ABCMeta
from abc import abstractmethod
...
class C:
    __metaclass__ = ABCMeta
    @abstractmethod
    def my_abstract_method(self, ...):
</code></pre>
<p>It works very well, provided the class does not inherit from classes that already use metaclasses.</p>
<p>source: <a href="http://docs.python.org/2/library/abc.html" rel="nofollow noreferrer">http://docs.python.org/2/library/abc.html</a> </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Python methods are always virtual</p>
</blockquote>
<p>like Ignacio said yet
Somehow class inheritance may be a better approach to implement what you want.</p>
<pre><code>class Animal:
    def __init__(self,name,legs):
        self.name = name
        self.legs = legs

    def getLegs(self):
        return "{0} has {1} legs".format(self.name, self.legs)

    def says(self):
        return "I am an unknown animal"

class Dog(Animal): # &lt;Dog inherits from Animal here (all methods as well)

    def says(self): # &lt;Called instead of Animal says method
        return "I am a dog named {0}".format(self.name)

    def somethingOnlyADogCanDo(self):
        return "be loyal"

formless = Animal("Animal", 0)
rover = Dog("Rover", 4) #&lt;calls initialization method from animal

print(formless.says()) # &lt;calls animal say method

print(rover.says()) #&lt;calls Dog says method
print(rover.getLegs()) #&lt;calls getLegs method from animal class
</code></pre>
<p>Results should be:</p>
<pre><code>I am an unknown animal
I am a dog named Rover
Rover has 4 legs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Python methods are always virtual.</p>
</blockquote>
<p>...provided they are not private ! Too bad for a C++ guy.</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like a virtual method in C++ (calling method implementation of a derived class through a reference or pointer to the base class) doesn't make sense in Python, as Python doesn't have typing. (I don't know how virtual methods work in Java and PHP though.)</p>
<p>But if by "virtual" you mean calling the bottom-most implementation in the inheritance hierarchy, then that's what you always get in Python, as several answers point out.</p>
<p>Well, almost always...</p>
<p>As dplamp pointed out, not all methods in Python behave like that. Dunder method don't. And I think that's a not so well known feature.</p>
<p>Consider this artificial example</p>
<pre><code>class A:
    def prop_a(self):
        return 1
    def prop_b(self):
        return 10 * self.prop_a()

class B(A):
    def prop_a(self):
        return 2
</code></pre>
<p>Now</p>
<pre><code>&gt;&gt;&gt; B().prop_b()
20
&gt;&gt;&gt; A().prob_b()
10
</code></pre>
<p>However, consider this one</p>
<pre><code>class A:
    def __prop_a(self):
        return 1
    def prop_b(self):
        return 10 * self.__prop_a()

class B(A):
    def __prop_a(self):
        return 2
</code></pre>
<p>Now</p>
<pre><code>&gt;&gt;&gt; B().prop_b()
10
&gt;&gt;&gt; A().prob_b()
10
</code></pre>
<p>The only thing we've changes was making <code>prop_a()</code> a dunder method.</p>
<p>A problem with the first behavior can be that you can't change the behavior of <code>prop_a()</code> in the derived class without impacting the behavior of <code>prop_b()</code>. <a href="https://youtu.be/HTLu2DFOdTg" rel="nofollow noreferrer">This</a> very nice talk by Raymond Hettinger gives an example for a use case where this is inconvenient.</p>
</div>
<span class="comment-copy">+1 for an example.  In what language do dogs say "hau" by the way?</span>
<span class="comment-copy">@JeremyP: hmm, good point :-) I guess in languages where "h" is understood as making the sound like the first letter of "hippy", or of "Javier" in Spanish.</span>
<span class="comment-copy">@Eli:  Sorry, but I was seriously interested in the answer to the question.  In English they say "woof", well they don't but that is the word we use analogous to "meow" for cats and "moo" for cows.  Is "hau" Spanish then?</span>
<span class="comment-copy">@Eli:  that's great, I'd up vote you again if I could :)</span>
<span class="comment-copy">@JeremyP I know for sure that's what Polish dogs say ;)</span>
<span class="comment-copy">Except for dunder methods.</span>
<span class="comment-copy">this answer should be the accepted answer!</span>
<span class="comment-copy">Is there a python 3 equivalent for this directive?</span>
<span class="comment-copy">What is the reference?</span>
