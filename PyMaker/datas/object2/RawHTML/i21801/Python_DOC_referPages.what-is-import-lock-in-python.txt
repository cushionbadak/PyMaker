<div class="post-text" itemprop="text">
<p>I am reading "The Little Book of Semaphores", and in it he has some code to make python use similar syntax to what he uses in the book. However, when I try to import his code it gives me the following error.</p>
<pre><code>from threading_cleanup import *
RuntimeError: not holding the import lock
</code></pre>
<p>I know it has something to do with the watcher function code because if I comment it out the error goes away, the code there makes it so I can use a KeyboardInterrupt to end the program.</p>
<p>Is there any way to fix the error?</p>
<h3>threading_cleanup.py</h3>
<pre><code>import threading
import time
import os
import signal
import sys

__all__ = ['Thread', 'Semaphore', 'watcher']

class Thread(threading.Thread):
    def __init__(self, target, *args):
        threading.Thread.__init__(self, target=target, args=args)
        self.start()


class Semaphore(threading._Semaphore):
    wait = threading._Semaphore.acquire

    def signal(self, n=1):
        for _ in range(n): self.release()

    def value(self):
        return self._Semaphore__value


def watcher():
    child = os.fork()
    if child == 0: return
    try:
        os.wait()
    except KeyboardInterrupt:
        print 'KeyboardInterrupt'
        os.kill(child, signal.SIGKILL)
    sys.exit()


watcher()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On my setup the error only happens in interpreted mode. </p>
<p>It seems that the interpreter doesn't like that the module does a fork while it is still importing it. </p>
<p>The error goes away if you remove the <code>watcher()</code> call or if you wrap it in an <code>if __name__ == '__main__':</code>.</p>
<p>In general, code executed by a Python module should be only for initialization of globals and singletons.</p>
<p>Oh! After the import, you can call <code>threading_cleanup.watcher()</code> from the interpreter, and it doesn't raise the exception.</p>
<p>Eh! I realized I didn't answer the title of your question:</p>
<p>The call to <code>fork()</code> creates a new process of the interpreter; one that will have to import the module to start executing. In interpreted mode, you are making that happen while the module is still being imported, and thus locked. In interpreted mode, the interactive interpreter is the main program. In execution mode, as in <code>python mymodule.py</code>, the module is the main program, so it doesn't get <em>imported</em>. Does that make sense?</p>
</div>
<div class="post-text" itemprop="text">
<p>The title of this question asks what the import lock is.</p>
<p>The import lock is the part of Python's <code>import</code> implementation that makes programs fail if you violate these obscure restrictions:</p>
<p><a href="https://docs.python.org/2/library/threading.html#importing-in-threaded-code" rel="nofollow noreferrer">https://docs.python.org/2/library/threading.html#importing-in-threaded-code</a></p>
<p>In your case, because you call <code>watcher()</code> directly in your module, it can't start threads unless that module happens to be the main module. Here's an example:</p>
<p><a href="https://stackoverflow.com/q/46290045/5896591">python2.7 - import silently locks up the thread</a></p>
<p>Your example seems a bit different though, as it involves <em>processes</em>. If I reduce your <code>threading_cleanup.py</code> to:</p>
<pre><code>import os
def watcher():
    child = os.fork()
watcher()
</code></pre>
<p>I still get the same error:</p>
<pre><code>  File "main.py", line 1, in &lt;module&gt;
    import threading_cleanup.py
RuntimeError: not holding the import lock
</code></pre>
<p>So gosh that's not an import lock. Except the error message says it's an import lock, now doesn't it? Sounds like a bug in the error message text.</p>
</div>
<span class="comment-copy">Can't you just wrap your program with <code>try</code> - <code>except KeyboardInterrupt</code> to finish it? Why do you create separate process for this?</span>
<span class="comment-copy">For reference, my deleted answer as a comment:  For me, this error occurs when using IPython, but not when using a vanilla Python interpreter.  But Zach is not using IPython, so that's not the cause for him.</span>
<span class="comment-copy">@ulidtko I think this is so that you don't have to put that at the end of every program. Since this is from a book, most of the programs are small programs, so I guess it is just easier to have a single import solve the problem.</span>
<span class="comment-copy">@Sven Marnach I was using a 32 bit version of python 2.7 for mac os x. In the default installed python 2.6 the code works perfectly, so I guess it is just my interpreter.</span>
<span class="comment-copy">@Zach:  Very strange issue.  I think it would be worth asking on a Python dev mailing list.</span>
<span class="comment-copy">This is what I ended up doing. (calling after the import)  However, this is also happening when not on the cmd line interpreter. Which is annoying.  It does make sense though. In python2.6 it doesn't cause an issue for me. 2.7 has the issue. Either way, calling watcher after import seems to be a reasonable work around.</span>
<span class="comment-copy">@Zach: I guess that 2.7 resets the import lock after forking so as not to cause a deadlock: <a href="http://bugs.python.org/issue6380" rel="nofollow noreferrer">bugs.python.org/issue6380</a></span>
<span class="comment-copy">The expected behavior is in the documentation for the <code>multiprocessing</code> module.</span>
<span class="comment-copy">The same is true for spawning processes, e.g. "Make sure that the main module can be safely imported by a new Python interpreter without causing unintended side effects (such a starting a new process)." - <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
