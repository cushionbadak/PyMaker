<div class="post-text" itemprop="text">
<p>Let's say I have a string <code>'gfgfdAAA1234ZZZuijjk'</code> and I want to extract just the <code>'1234'</code> part.</p>
<p>I only know what will be the few characters directly before <code>AAA</code>, and after <code>ZZZ</code> the part I am interested in <code>1234</code>.</p>
<p>With <code>sed</code> it is possible to do something like this with a string:</p>
<pre><code>echo "$STRING" | sed -e "s|.*AAA\(.*\)ZZZ.*|\1|"
</code></pre>
<p>And this will give me <code>1234</code> as a result.</p>
<p>How to do the same thing in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using regular expressions - <a href="http://docs.python.org/2/library/re.html" rel="noreferrer">documentation</a> for further reference</p>
<pre><code>import re

text = 'gfgfdAAA1234ZZZuijjk'

m = re.search('AAA(.+?)ZZZ', text)
if m:
    found = m.group(1)

# found: 1234
</code></pre>
<p>or:</p>
<pre><code>import re

text = 'gfgfdAAA1234ZZZuijjk'

try:
    found = re.search('AAA(.+?)ZZZ', text).group(1)
except AttributeError:
    # AAA, ZZZ not found in the original string
    found = '' # apply your error handling

# found: 1234
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; s = 'gfgfdAAA1234ZZZuijjk'
&gt;&gt;&gt; start = s.find('AAA') + 3
&gt;&gt;&gt; end = s.find('ZZZ', start)
&gt;&gt;&gt; s[start:end]
'1234'
</code></pre>
<p>Then you can use regexps with the re module as well, if you want, but that's not necessary in your case. </p>
</div>
<div class="post-text" itemprop="text">
<h3>regular expression</h3>
<pre><code>import re

re.search(r"(?&lt;=AAA).*?(?=ZZZ)", your_text).group(0)
</code></pre>
<p>The above as-is will fail with an <code>AttributeError</code> if there are no "AAA" and "ZZZ" in <code>your_text</code></p>
<h3>string methods</h3>
<pre><code>your_text.partition("AAA")[2].partition("ZZZ")[0]
</code></pre>
<p>The above will return an empty string if either "AAA" or "ZZZ" don't exist in <code>your_text</code>.</p>
<p>PS Python Challenge?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
print re.search('AAA(.*?)ZZZ', 'gfgfdAAA1234ZZZuijjk').group(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/library/re.html" rel="noreferrer">re</a> module for that:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.compile(".*AAA(.*)ZZZ.*").match("gfgfdAAA1234ZZZuijjk").groups()
('1234,)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>With sed it is possible to do something like this with a string:</p>
</blockquote>
<p><code>echo "$STRING" | sed -e "s|.*AAA\(.*\)ZZZ.*|\1|"</code></p>
<blockquote>
<p>And this will give me 1234 as a result.</p>
</blockquote>
<p>You could do the same  with <code>re.sub</code> function using the same regex.</p>
<pre><code>&gt;&gt;&gt; re.sub(r'.*AAA(.*)ZZZ.*', r'\1', 'gfgfdAAA1234ZZZuijjk')
'1234'
</code></pre>
<p>In basic sed, capturing group are represented by <code>\(..\)</code>, but in python it was represented by <code>(..)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can do using just one line of code</p>
<pre><code>&gt;&gt;&gt; import re

&gt;&gt;&gt; re.findall(r'\d{1,5}','gfgfdAAA1234ZZZuijjk')

&gt;&gt;&gt; ['1234']
</code></pre>
<p>result will receive list...</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>You can find first substring with this function in your code (by character index). Also, you can find what is after a substring. </p>
</blockquote>
<pre><code>def FindSubString(strText, strSubString, Offset=None):
    try:
        Start = strText.find(strSubString)
        if Start == -1:
            return -1 # Not Found
        else:
            if Offset == None:
                Result = strText[Start+len(strSubString):]
            elif Offset == 0:
                return Start
            else:
                AfterSubString = Start+len(strSubString)
                Result = strText[AfterSubString:AfterSubString + int(Offset)]
            return Result
    except:
        return -1

# Example:

Text = "Thanks for contributing an answer to Stack Overflow!"
subText = "to"

print("Start of first substring in a text:")
start = FindSubString(Text, subText, 0)
print(start); print("")

print("Exact substring in a text:")
print(Text[start:start+len(subText)]); print("")

print("What is after substring \"%s\"?" %(subText))
print(FindSubString(Text, subText))

# Your answer:

Text = "gfgfdAAA1234ZZZuijjk"
subText1 = "AAA"
subText2 = "ZZZ"

AfterText1 = FindSubString(Text, subText1, 0) + len(subText1)
BeforText2 = FindSubString(Text, subText2, 0) 

print("\nYour answer:\n%s" %(Text[AfterText1:BeforText2]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python, extracting substring form string can be done using <code>findall</code> method in regular expression (<code>re</code>) module.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'gfgfdAAA1234ZZZuijjk'
&gt;&gt;&gt; ss = re.findall('AAA(.+)ZZZ', s)
&gt;&gt;&gt; print ss
['1234']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just in case somebody will have to do the same thing that I did. I had to extract everything inside parenthesis in a line. For example, if I have a line like 'US president (Barack Obama) met with ...' and I want to get only 'Barack Obama' this is solution:</p>
<pre><code>regex = '.*\((.*?)\).*'
matches = re.search(regex, line)
line = matches.group(1) + '\n'
</code></pre>
<p>I.e. you need to block parenthesis with <code>slash \</code> sign. Though it is a problem about more regular expressions that Python.</p>
<p>Also, in some cases you may see 'r' symbols before regex definition. If there is no r prefix, you need to use escape characters like in C. <a href="https://stackoverflow.com/questions/2241600/python-regex-r-prefix">Here</a> is more discussion on that. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; s = '/tmp/10508.constantstring'
&gt;&gt;&gt; s.split('/tmp/')[1].split('constantstring')[0].strip('.')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Surprised that nobody has mentioned this which is my quick version for one-off scripts:</p>
<pre><code>&gt;&gt;&gt; x = 'gfgfdAAA1234ZZZuijjk'
&gt;&gt;&gt; x.split('AAA')[1].split('ZZZ')[0]
'1234'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution without regex that also accounts for scenarios where the first substring contains the second substring. This function will only find a substring if the second marker is after the first marker.</p>
<pre><code>def find_substring(string, start, end):
    len_until_end_of_first_match = string.find(start) + len(start)
    after_start = string[len_until_end_of_first_match:]
    return string[string.find(start) + len(start):len_until_end_of_first_match + after_start.find(end)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>text = 'I want to find a string between two substrings'
left = 'find a '
right = 'between two'

print(text[text.index(left)+len(left):text.index(right)])
</code></pre>
<p>Gives</p>
<pre><code>string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One liners that return other string if there was no match.
Edit: improved version uses <code>next</code> function, replace <code>"not-found"</code> with something else if needed:</p>
<pre><code>import re
res = next( (m.group(1) for m in [re.search("AAA(.*?)ZZZ", "gfgfdAAA1234ZZZuijjk" ),] if m), "not-found" )
</code></pre>
<p>My other method to do this, less optimal, uses regex 2nd time, still didn't found a shorter way:</p>
<pre><code>import re
res = ( ( re.search("AAA(.*?)ZZZ", "gfgfdAAA1234ZZZuijjk") or re.search("()","") ).group(1) )
</code></pre>
</div>
<span class="comment-copy">The second solution is better, if the pattern matches most of the time, because its <a href="http://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">Easier to ask for forgiveness than permission.</a>.</span>
<span class="comment-copy">Doesn't the indexing start at 0? So you would need to use group(0) instead of group(1)?</span>
<span class="comment-copy">@Alexander, no, group(0) will return full matched string: AAA1234ZZZ, and group(1) will return only characters matched by first group: 1234</span>
<span class="comment-copy">@Bengt: Why is that? The first solution looks quite simple to me, and it has fewer lines of code.</span>
<span class="comment-copy">In this expression the ? modifies the + to be non-greedy, ie. it will match any number of times from 1 upwards but as few as possible, only expanding as necessary. without the ?, the first group would match gfgfAAA2ZZZkeAAA43ZZZonife as 2ZZZkeAAA43, but with the ? it would only match the 2, then searching for multiple (or having it stripped out and search again) would match the 43.</span>
<span class="comment-copy">The question seems to imply that the input text will always contain both "AAA" and "ZZZ". If this is not the case, your answer fails horribly (by that I mean it returns something completely wrong instead of an empty string or throwing an exception; think "hello there" as input string).</span>
<span class="comment-copy">@user225312 Is the <code>re</code> method not faster though?</span>
<span class="comment-copy">Voteup, but I would use "x = 'AAA' ; s.find(x) + len(x)" instead of "s.find('AAA') + 3" for maintainability.</span>
<span class="comment-copy">If any of the tokens can't be found in the <code>s</code>, <code>s.find</code> will return <code>-1</code>.  the slicing operator <code>s[begin:end]</code>  will accept it as valid index, and return undesired substring.</span>
<span class="comment-copy">This answer probably deserves more up votes. The string method is the most robust way. It does not need a try/except.</span>
<span class="comment-copy">... nice, though limited.  partition is not regex based, so it only works in this instance because the search string was bounded by fixed literals</span>
<span class="comment-copy">Great, many thanks! - this works for strings and does not require regex</span>
<span class="comment-copy"><code>AttributeError: 'NoneType' object has no attribute 'groups'</code> - if there is no AAA, ZZZ in the string...</span>
<span class="comment-copy">@user1810100 mentioned essentially that almost exactly 5 years to the day before you posted this...</span>
