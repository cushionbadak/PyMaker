<div class="post-text" itemprop="text">
<pre><code>[(1,2), (2,3), (4,5), (3,4), (6,7), (6,7), (3,8)]
</code></pre>
<p>How do I return the 2nd value from each tuple inside this list?</p>
<p>Desired output:</p>
<pre><code>[2, 3, 5, 4, 7, 7, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noreferrer">list comprehension</a>.</p>
<pre><code>[x[1] for x in L]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ignacio's answer is what you want. However, as someone also learning Python, let me try to dissect it for you... As mentioned, it is a list comprehension (covered in <a href="http://diveintopython3.org/comprehensions.html#listcomprehension" rel="noreferrer">DiveIntoPython3</a>, for example). Here are a few points:</p>
<p><code>[x[1] for x in L]</code></p>
<ul>
<li>Notice the <code>[]</code>'s around the line of code. These are what define a list. This tells you that this code returns a list, so it's of the <code>list</code> type. Hence, this technique is called a "list comprehension."</li>
<li>L is your original list. So you should define <code>L = [(1,2),(2,3),(4,5),(3,4),(6,7),(6,7),(3,8)]</code> prior to executing the above code.</li>
<li><code>x</code> is a variable that only exists in the comprehension - try to access <code>x</code> outside of the comprehension, or type <code>type(x)</code> after executing the above line and it will tell you <code>NameError: name 'x' is not defined</code>, whereas <code>type(L)</code> returns <code>&lt;class 'list'&gt;</code>.</li>
<li><code>x[1]</code> points to the <em>second</em> item in each of the tuples whereas <code>x[0]</code> would point to each of the first items.</li>
<li>So this line of code literally reads "return the second item in a tuple for all tuples in list L."</li>
</ul>
<p>It's tough to tell how much you attempted the problem prior to asking the question, but perhaps you just weren't familiar with comprehensions? I would spend some time reading through <a href="http://diveintopython3.org/comprehensions.html" rel="noreferrer">Chapter 3 of DiveIntoPython</a>, or any resource on comprehensions. Good luck.</p>
</div>
<div class="post-text" itemprop="text">
<p>A list comprehension is absolutely the way to do this. Another way that <em>should</em> be faster is <code>map</code> and <code>itemgetter</code>.</p>
<pre><code>import operator

new_list = map(operator.itemgetter(1), old_list)
</code></pre>
<p>In response to the comment that the OP couldn't find an answer on google, I'll point out a super naive way to do it.</p>
<pre><code>new_list = []
for item in old_list:
    new_list.append(item[1])
</code></pre>
<p>This uses:</p>
<ol>
<li>Declaring a variable to reference an empty list.</li>
<li>A for loop.</li>
<li>Calling the <code>append</code> method on a list.</li>
</ol>
<p>If somebody is trying to learn a language and can't put together these basic pieces for themselves, then they need to <em>view it as an exercise</em> and do it themselves even if it takes twenty hours.</p>
<p>One needs to learn how to <em>think about what one wants</em> and compare that to <em>the available tools</em>. Every element in my second answer should be covered in a basic tutorial. <strong>You cannot learn to program without reading one</strong>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use sequence unpacking with <code>zip</code>:</p>
<pre><code>L = [(1,2),(2,3),(4,5),(3,4),(6,7),(6,7),(3,8)]

_, res = zip(*L)

print(res)

# (2, 3, 5, 4, 7, 7, 8)
</code></pre>
<p>This also creates a tuple <code>_</code> from the discarded first elements. Extracting only the second is possible, but more verbose:</p>
<pre><code>from itertools import islice

res = next(islice(zip(*L), 1, None))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>OR you can use <code>pandas</code>:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; L = [(1,2),(2,3),(4,5),(3,4),(6,7),(6,7),(3,8)]
&gt;&gt;&gt; df=pd.DataFrame(L)
&gt;&gt;&gt; df[1]
0    2
1    3
2    5
3    4
4    7
5    7
6    8
Name: 1, dtype: int64
&gt;&gt;&gt; df[1].tolist()
[2, 3, 5, 4, 7, 7, 8]
&gt;&gt;&gt; 
</code></pre>
<p>Or <code>numpy</code>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; L = [(1,2),(2,3),(4,5),(3,4),(6,7),(6,7),(3,8)]
&gt;&gt;&gt; arr=np.array(L)
&gt;&gt;&gt; arr.T[1]
array([2, 3, 5, 4, 7, 7, 8])
&gt;&gt;&gt; arr.T[1].tolist()
[2, 3, 5, 4, 7, 7, 8]
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">I understand this is a simple question. Is SO such an elitist place? Try googling the question, the results are not what I need. I did learning python the hard way and i didn't find this in there. I've asked questions before about the the best approach to learning Python and the unanimous answer is to get a basic book and just dive in. It frustrates me as well as I just cannot find the solution in any book or online material I have search for so far? Plus your comment really isn't helpful and discourages newbies new members from posting on SO.</span>
<span class="comment-copy">@Nai: I suggest to read the Python tutorial: <a href="http://docs.python.org/tutorial/index.html" rel="nofollow noreferrer">docs.python.org/tutorial/index.html</a> . In general, the documentation is very good. And sometimes, one just has to try ;)</span>
<span class="comment-copy">I Googled "accessing item in tuple" with the intent of accessing an item in a tuple list. It brought me to your question so thank you. I am fairly new to Python and don't find the answer particularly intuitive, but that's just me!</span>
<span class="comment-copy">I thought the entire concept with SO was to make it easier to find answers to your questions. Why must a question be of a certain difficulty in order to be valid? Good question, good answer.</span>
<span class="comment-copy">Brilliant! A short, sharp, to the point answer to a short, sharp, to the point question. You both just made my day!</span>
<span class="comment-copy">In 2.x, <code>x</code> will exist outside of the LC, with the last value bound to it. This is fixed in 3.x.</span>
<span class="comment-copy">I didn't realize this. Thanks for the info.</span>
<span class="comment-copy">Awesome explanation @gary. I appreciate especially your pointing out what L refers to.</span>
<span class="comment-copy">Thanks for the feedback @PatrickWilliams. I'm glad this helps. You could also do <code>[x[1] for x in [(1,2),(2,3),(4,5),(3,4),(6,7),(6,7),(3,8)]]</code> but it's not as easy on the eyes.</span>
