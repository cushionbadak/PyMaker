<div class="post-text" itemprop="text">
<p>I have two dictionaries, but for simplification, I will take these two:</p>
<pre><code>&gt;&gt;&gt; x = dict(a=1, b=2)
&gt;&gt;&gt; y = dict(a=2, b=2)
</code></pre>
<p>Now, I want to compare whether each <code>key, value</code> pair in <code>x</code> has the same corresponding value in <code>y</code>. So I wrote this:</p>
<pre><code>&gt;&gt;&gt; for x_values, y_values in zip(x.iteritems(), y.iteritems()):
        if x_values == y_values:
            print 'Ok', x_values, y_values
        else:
            print 'Not', x_values, y_values
</code></pre>
<p>And it works since a <code>tuple</code> is returned and then compared for equality.</p>
<p>My questions:</p>
<p>Is this correct? Is there a <em>better</em> way to do this? Better not in speed, I am talking about code elegance.</p>
<p>UPDATE: I forgot to mention that I have to check how many <code>key, value</code> pairs are equal. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to know how many values match in both the dictionaries, you should have said that :) </p>
<p>Maybe something like this:</p>
<pre><code>shared_items = {k: x[k] for k in x if k in y and x[k] == y[k]}
print len(shared_items)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you want to do is simply <code>x==y</code> </p>
<p>What you do is not a good idea, because the items in a dictionary are not supposed to have any order. You might be comparing <code>[('a',1),('b',1)]</code> with <code>[('b',1), ('a',1)]</code> (same dictionaries, different order).</p>
<p>For example, see this:</p>
<pre><code>&gt;&gt;&gt; x = dict(a=2, b=2,c=3, d=4)
&gt;&gt;&gt; x
{'a': 2, 'c': 3, 'b': 2, 'd': 4}
&gt;&gt;&gt; y = dict(b=2,c=3, d=4)
&gt;&gt;&gt; y
{'c': 3, 'b': 2, 'd': 4}
&gt;&gt;&gt; zip(x.iteritems(), y.iteritems())
[(('a', 2), ('c', 3)), (('c', 3), ('b', 2)), (('b', 2), ('d', 4))]
</code></pre>
<p>The difference is only one item, but your algorithm will see that <em>all</em> items are different</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def dict_compare(d1, d2):
    d1_keys = set(d1.keys())
    d2_keys = set(d2.keys())
    intersect_keys = d1_keys.intersection(d2_keys)
    added = d1_keys - d2_keys
    removed = d2_keys - d1_keys
    modified = {o : (d1[o], d2[o]) for o in intersect_keys if d1[o] != d2[o]}
    same = set(o for o in intersect_keys if d1[o] == d2[o])
    return added, removed, modified, same

x = dict(a=1, b=2)
y = dict(a=2, b=2)
added, removed, modified, same = dict_compare(x, y)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1><code>dic1 == dic2</code></h1>
<p>From <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="noreferrer">python docs</a>:  </p>
<blockquote>
<p>To illustrate, the following examples all return a dictionary <strong>equal</strong>  to
  <code>{"one": 1, "two": 2, "three": 3}</code>:</p>
<pre><code>&gt;&gt;&gt; a = dict(one=1, two=2, three=3)
&gt;&gt;&gt; b = {'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
&gt;&gt;&gt; d = dict([('two', 2), ('one', 1), ('three', 3)])
&gt;&gt;&gt; e = dict({'three': 3, 'one': 1, 'two': 2})
&gt;&gt;&gt; a == b == c == d == e
True
</code></pre>
</blockquote>
<p>Valid for <code>py2</code> and <code>py3</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm new to python but I ended up doing something similar to @mouad</p>
<pre><code>unmatched_item = set(dict_1.items()) ^ set(dict_2.items())
len(unmatched_item) # should be 0
</code></pre>
<p>The XOR operator (<code>^</code>) should eliminate all elements of the dict when they are the same in both dicts.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just use:</p>
<pre><code>assert cmp(dict1, dict2) == 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since it seems nobody mentioned <a href="https://pypi.org/project/deepdiff/" rel="noreferrer"><code>deepdiff</code></a>, I will add it here just for the completeness.
I find it very convenient for getting diff of (nested) objects in general.</p>
<pre><code>import deepdiff
from pprint import pprint

aa = {
    "a": 1,
    "nested": {
        "b": 1,
    }
}
bb = {
    "a": 2,
    "nested": {
        "b": 2,
    }
}
pprint(deepdiff.DeepDiff(aa, bb))
</code></pre>
<p>Output:</p>
<pre><code>{'values_changed': {"root['a']": {'new_value': 2, 'old_value': 1},
                "root['nested']['b']": {'new_value': 2, 'old_value': 1}}}
</code></pre>
<p>NOTE:</p>
<ul>
<li><p><code>deepdiff</code> package needs to be installed as this is not a standard package</p></li>
<li><p>some effort will have to be put for parsing the result</p></li>
</ul>
<hr/>
<p>However, for taking the diff of dictionaries, I find <a href="http://dictdiffer.readthedocs.io/en/latest/" rel="noreferrer"><code>dictdiffer</code></a> to be very handy.</p>
</div>
<div class="post-text" itemprop="text">
<p>@mouad 's answer is nice if you assume both dictionaries just contain simple values. However if you have dictionaries that contain dictionaries you'll get an exception as dictionaries are not hashable.</p>
<p>Off the top of my head, something like this might work:</p>
<pre><code>def compare_dictionaries(dict1, dict2):
     if dict1 is None or dict2 is None:
        print('Nones')
        return False

     if (not isinstance(dict1, dict)) or (not isinstance(dict2, dict)):
        print('Not dict')
        return False

     shared_keys = set(dict2.keys()) &amp; set(dict2.keys())

     if not ( len(shared_keys) == len(dict1.keys()) and len(shared_keys) == len(dict2.keys())):
        print('Not all keys are shared')
        return False


     dicts_are_equal = True
     for key in dict1.keys():
         if isinstance(dict1[key], dict) or isinstance(dict2[key], dict):
             dicts_are_equal = dicts_are_equal and compare_dictionaries(dict1[key], dict2[key])
         else:
             dicts_are_equal = dicts_are_equal and all(atleast_1d(dict1[key] == dict2[key]))

     return dicts_are_equal
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yet another possibility, up to the last note of the OP, is to compare the hashes (<code>SHA</code> or <code>MD</code>) of the dicts dumped as JSON. The way hashes are constructed guarantee that if they are equal, the source strings are equal as well. This is very fast and mathematically sound. </p>
<pre><code>import json
import hashlib

def hash_dict(d):
    return hashlib.sha1(json.dumps(d, sort_keys=True)).hexdigest()

x = dict(a=1, b=2)
y = dict(a=2, b=2)
z = dict(a=1, b=2)

print(hash_dict(x) == hash_dict(y))
print(hash_dict(x) == hash_dict(z))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To test if two dicts are equal in keys and values:</p>
<pre><code>def dicts_equal(d1,d2):
    """ return True if all keys and values are the same """
    return all(k in d2 and d1[k] == d2[k]
               for k in d1) \
        and all(k in d1 and d1[k] == d2[k]
               for k in d2)
</code></pre>
<p>If you want to return the values which differ, write it differently:</p>
<pre><code>def dict1_minus_d2(d1, d2):
    """ return the subset of d1 where the keys don't exist in d2 or
        the values in d2 are different, as a dict """
    return {k,v for k,v in d1.items() if k in d2 and v == d2[k]}
</code></pre>
<p>You would have to call it twice i.e </p>
<pre><code>dict1_minus_d2(d1,d2).extend(dict1_minus_d2(d2,d1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Code</h1>
<pre><code>def equal(a, b):
    type_a = type(a)
    type_b = type(b)

    if type_a != type_b:
        return False

    if isinstance(a, dict):
        if len(a) != len(b):
            return False
        for key in a:
            if key not in b:
                return False
            if not equal(a[key], b[key]):
                return False
        return True

    elif isinstance(a, list):
        if len(a) != len(b):
            return False
        while len(a):
            x = a.pop()
            index = indexof(x, b)
            if index == -1:
                return False
            del b[index]
        return True

    else:
        return a == b

def indexof(x, a):
    for i in range(len(a)):
        if equal(x, a[i]):
            return i
    return -1
</code></pre>
<h1>Test</h1>
<pre><code>&gt;&gt;&gt; a = {
    'number': 1,
    'list': ['one', 'two']
}
&gt;&gt;&gt; b = {
    'list': ['two', 'one'],
    'number': 1
}
&gt;&gt;&gt; equal(a, b)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function is fine IMO, clear and intuitive. But just to give you (another) answer, here is my go:</p>
<pre><code>def compare_dict(dict1, dict2):
    for x1 in dict1.keys():
        z = dict1.get(x1) == dict2.get(x1)
        if not z:
            print('key', x1)
            print('value A', dict1.get(x1), '\nvalue B', dict2.get(x1))
            print('-----\n')
</code></pre>
<p>Can be useful for you or for anyone else..</p>
</div>
<div class="post-text" itemprop="text">
<p>I am using this solution that works perfectly for me in Python 3</p>
<pre class="lang-py prettyprint-override"><code>
import logging
log = logging.getLogger(__name__)

...

    def deep_compare(self,left, right, level=0):
        if type(left) != type(right):
            log.info("Exit 1 - Different types")
            return False

        elif type(left) is dict:
            # Dict comparison
            for key in left:
                if key not in right:
                    log.info("Exit 2 - missing {} in right".format(key))
                    return False
                else:
                    if not deep_compare(left[str(key)], right[str(key)], level +1 ):
                        log.info("Exit 3 - different children")
                        return False
            return True
        elif type(left) is list:
            # List comparison
            for key in left:
                if key not in right:
                    log.info("Exit 4 - missing {} in right".format(key))
                    return False
                else:
                    if not deep_compare(left[left.index(key)], right[right.index(key)], level +1 ):
                        log.info("Exit 5 - different children")
                        return False
            return True
        else:
            # Other comparison
            return left == right

        return False

</code></pre>
<p>It compares dict, list and any other types that implements the "==" operator by themselves.
If you need to compare something else different, you need to add a new branch in the "if tree".</p>
<p>Hope that helps.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; hash_1
{'a': 'foo', 'b': 'bar'}
&gt;&gt;&gt; hash_2
{'a': 'foo', 'b': 'bar'}
&gt;&gt;&gt; set_1 = set (hash_1.iteritems())
&gt;&gt;&gt; set_1
set([('a', 'foo'), ('b', 'bar')])
&gt;&gt;&gt; set_2 = set (hash_2.iteritems())
&gt;&gt;&gt; set_2
set([('a', 'foo'), ('b', 'bar')])
&gt;&gt;&gt; len (set_1.difference(set_2))
0
&gt;&gt;&gt; if (len(set_1.difference(set_2)) | len(set_2.difference(set_1))) == False:
...    print "The two hashes match."
...
The two hashes match.
&gt;&gt;&gt; hash_2['c'] = 'baz'
&gt;&gt;&gt; hash_2
{'a': 'foo', 'c': 'baz', 'b': 'bar'}
&gt;&gt;&gt; if (len(set_1.difference(set_2)) | len(set_2.difference(set_1))) == False:
...     print "The two hashes match."
...
&gt;&gt;&gt;
&gt;&gt;&gt; hash_2.pop('c')
'baz'
</code></pre>
<p>Here's another option:</p>
<pre><code>&gt;&gt;&gt; id(hash_1)
140640738806240
&gt;&gt;&gt; id(hash_2)
140640738994848
</code></pre>
<p>So as you see the two id's are different. But the <a href="http://docs.python.org/2/reference/datamodel.html#object.__lt__" rel="nofollow">rich comparison operators</a> seem to do the trick:</p>
<pre><code>&gt;&gt;&gt; hash_1 == hash_2
True
&gt;&gt;&gt;
&gt;&gt;&gt; hash_2
{'a': 'foo', 'b': 'bar'}
&gt;&gt;&gt; set_2 = set (hash_2.iteritems())
&gt;&gt;&gt; if (len(set_1.difference(set_2)) | len(set_2.difference(set_1))) == False:
...     print "The two hashes match."
...
The two hashes match.
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In PyUnit there's a method which compares dictionaries beautifully. I tested it using the following two dictionaries, and it does exactly what you're looking for.</p>
<pre><code>d1 = {1: "value1",
      2: [{"subKey1":"subValue1",
           "subKey2":"subValue2"}]}
d2 = {1: "value1",
      2: [{"subKey2":"subValue2",
           "subKey1": "subValue1"}]
      }


def assertDictEqual(self, d1, d2, msg=None):
        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')
        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')

        if d1 != d2:
            standardMsg = '%s != %s' % (safe_repr(d1, True), safe_repr(d2, True))
            diff = ('\n' + '\n'.join(difflib.ndiff(
                           pprint.pformat(d1).splitlines(),
                           pprint.pformat(d2).splitlines())))
            standardMsg = self._truncateMessage(standardMsg, diff)
            self.fail(self._formatMessage(msg, standardMsg))
</code></pre>
<p>I'm not recommending importing <code>unittest</code> into your production code. My thought is the source in PyUnit could be re-tooled to run in production. It uses <code>pprint</code> which "pretty prints" the dictionaries. Seems pretty easy to adapt this code to be "production ready".</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.6, It can be done as:-</p>
<pre><code>if (len(dict_1)==len(dict_2): 
  for i in dict_1.items():
        ret=bool(i in dict_2.items())
</code></pre>
<p>ret variable will be true if all the items of dict_1 in present in dict_2</p>
</div>
<div class="post-text" itemprop="text">
<p>see dictionary view objects:
<a href="https://docs.python.org/2/library/stdtypes.html#dict" rel="nofollow noreferrer">https://docs.python.org/2/library/stdtypes.html#dict</a></p>
<p>This way you can subtract dictView2 from dictView1 and it will return a set of key/value pairs that are different in dictView2:</p>
<pre><code>original = {'one':1,'two':2,'ACTION':'ADD'}
originalView=original.viewitems()
updatedDict = {'one':1,'two':2,'ACTION':'REPLACE'}
updatedDictView=updatedDict.viewitems()
delta=original | updatedDict
print delta
&gt;&gt;set([('ACTION', 'REPLACE')])
</code></pre>
<p>You can intersect, union, difference (shown above), symmetric difference these dictionary view objects.<br/>
Better? Faster? - not sure, but part of the standard library - which makes it a big plus for portability</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my answer, use a recursize way:</p>
<pre><code>def dict_equals(da, db):
    if not isinstance(da, dict) or not isinstance(db, dict):
        return False
    if len(da) != len(db):
        return False
    for da_key in da:
        if da_key not in db:
            return False
        if not isinstance(db[da_key], type(da[da_key])):
            return False
        if isinstance(da[da_key], dict):
            res = dict_equals(da[da_key], db[da_key])
            if res is False:
                return False
        elif da[da_key] != db[da_key]:
            return False
    return True

a = {1:{2:3, 'name': 'cc', "dd": {3:4, 21:"nm"}}}
b = {1:{2:3, 'name': 'cc', "dd": {3:4, 21:"nm"}}}
print dict_equals(a, b)
</code></pre>
<p>Hope that helps!</p>
</div>
<div class="post-text" itemprop="text">
<p>Below code will help you to compare list of dict in python </p>
<pre><code>def compate_generic_types(object1, object2):
    if isinstance(object1, str) and isinstance(object2, str):
        return object1 == object2
    elif isinstance(object1, unicode) and isinstance(object2, unicode):
        return object1 == object2
    elif isinstance(object1, bool) and isinstance(object2, bool):
        return object1 == object2
    elif isinstance(object1, int) and isinstance(object2, int):
        return object1 == object2
    elif isinstance(object1, float) and isinstance(object2, float):
        return object1 == object2
    elif isinstance(object1, float) and isinstance(object2, int):
        return object1 == float(object2)
    elif isinstance(object1, int) and isinstance(object2, float):
        return float(object1) == object2

    return True

def deep_list_compare(object1, object2):
    retval = True
    count = len(object1)
    object1 = sorted(object1)
    object2 = sorted(object2)
    for x in range(count):
        if isinstance(object1[x], dict) and isinstance(object2[x], dict):
            retval = deep_dict_compare(object1[x], object2[x])
            if retval is False:
                print "Unable to match [{0}] element in list".format(x)
                return False
        elif isinstance(object1[x], list) and isinstance(object2[x], list):
            retval = deep_list_compare(object1[x], object2[x])
            if retval is False:
                print "Unable to match [{0}] element in list".format(x)
                return False
        else:
            retval = compate_generic_types(object1[x], object2[x])
            if retval is False:
                print "Unable to match [{0}] element in list".format(x)
                return False

    return retval

def deep_dict_compare(object1, object2):
    retval = True

    if len(object1) != len(object2):
        return False

    for k in object1.iterkeys():
        obj1 = object1[k]
        obj2 = object2[k]
        if isinstance(obj1, list) and isinstance(obj2, list):
            retval = deep_list_compare(obj1, obj2)
            if retval is False:
                print "Unable to match [{0}]".format(k)
                return False

        elif isinstance(obj1, dict) and isinstance(obj2, dict):
            retval = deep_dict_compare(obj1, obj2)
            if retval is False:
                print "Unable to match [{0}]".format(k)
                return False
        else:
            retval = compate_generic_types(obj1, obj2)
            if retval is False:
                print "Unable to match [{0}]".format(k)
                return False

    return retval
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Being late in my response is better than never!</p>
<p>Compare Not_Equal is more efficient than comparing Equal. As such two dicts are not equal if any key values in one dict is not found in the other dict. The code below takes into consideration that you maybe comparing default dict and thus uses get instead of <strong>getitem</strong> []. </p>
<p>Using a kind of random value as default in the get call equal to the key being retrieved - just in case the dicts has a None as value in one dict and that key does not exist in the other. Also the get != condition is checked before the not in condition for efficiency because you are doing the check on the keys and values from both sides at the same time.</p>
<pre><code>def Dicts_Not_Equal(first,second):
    """ return True if both do not have same length or if any keys and values are not the same """
    if len(first) == len(second): 
        for k in first:
            if first.get(k) != second.get(k,k) or k not in second: return (True)
        for k in second:         
            if first.get(k,k) != second.get(k) or k not in first: return (True)
        return (False)   
    return (True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; x = {'a':1,'b':2,'c':3}
&gt;&gt;&gt; x
{'a': 1, 'b': 2, 'c': 3}

&gt;&gt;&gt; y = {'a':2,'b':4,'c':3}
&gt;&gt;&gt; y
{'a': 2, 'b': 4, 'c': 3}

METHOD 1:

&gt;&gt;&gt; common_item = x.items()&amp;y.items() #using union,x.item() 
&gt;&gt;&gt; common_item
{('c', 3)}

METHOD 2:

 &gt;&gt;&gt; for i in x.items():
        if i in y.items():
           print('true')
        else:
           print('false')


false
false
true
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import json

if json.dumps(dict1) == json.dumps(dict2):
    print("Equal")
</code></pre>
</div>
<span class="comment-copy"><code>x == y</code> should be true according to <a href="http://stackoverflow.com/a/5635309/186202">stackoverflow.com/a/5635309/186202</a></span>
<span class="comment-copy">Same error if there is list element for the dict key. I think cmp is better way to do it unless I am missing anything.</span>
<span class="comment-copy">@Mutant that is a different issue. You cannot create a dictionary with a <code>list</code> key in the first place. <code>x = {[1,2]: 2}</code> will fail. The question already has valid <code>dicts</code>.</span>
<span class="comment-copy">@annan: wrong, the question is generic. the <b>example</b> in the question description has already "valid dicts". If I post a new question, with same title, but with a different "invalid"  dict, somebody will mark it as duplicate. Downvoting.</span>
<span class="comment-copy">@ribamar the question is "Comparing two dictionaries [...]". The 'invalid dict' above with <code>list</code> keys is not valid python code - dict <i>keys</i> must be immutable. Therefore you are not comparing dictionaries. If you try and use a list as a dictionary key your code will not run. You have no objects for which to compare. This is like typing <code>x = dict(23\;dfg&amp;^*$^%$^$%^)</code> then complaining how the comparison does not work with the dictionary. Of course it will not work. Tim's comment on the other hand is about mutable <code>values</code>, hence why I said that these are different issues.</span>
<span class="comment-copy">@MikeyE - <code>set</code> requires values to be hashable and <code>dict</code> requires keys to be hashable.  <code>set(x.keys())</code> will always work because keys are required to be hashable, but <code>set(x.values())</code> will fail on values that aren't hashable.</span>
<span class="comment-copy">@THC4k, sorry for not mentioning. But I have to check how many values match in both the dictionaries.</span>
<span class="comment-copy">Ok, so based on my update, is my way of doing still incorrect?</span>
<span class="comment-copy">@A A: I added why your's doesn't work when you want to count.</span>
<span class="comment-copy">This doesn't work for nested dictionaries.</span>
<span class="comment-copy">As of Python 3.6, dict is orderd out-of-the-box.</span>
<span class="comment-copy">This one actually handles mutable values in the dict!</span>
<span class="comment-copy">When I run this, I still get an error seeing dealing with the mutable values:  ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().</span>
<span class="comment-copy">@Afflatus - <code>DataFrame</code>s by design don't allow truthy comparisons (unless it has a length of 1) as they inherit from <code>numpy.ndarray</code>.  -credit to <a href="http://stackoverflow.com/a/33307396/994076">stackoverflow.com/a/33307396/994076</a></span>
<span class="comment-copy">I don't agree with @ErkinAlpGüney. Could you provide a proof?</span>
<span class="comment-copy">Just create 2 equal dics and test the code.</span>
<span class="comment-copy">I disagree with @ErkinAlpGüney. The official documentation shows that == does indeed compare dictionaries by value, not by address. <a href="https://docs.python.org/2/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">docs.python.org/2/library/stdtypes.html#mapping-types-dict</a></span>
<span class="comment-copy">Works for Python 2.7.13</span>
<span class="comment-copy">Does not work with <code>OrderedDict</code>:  <code>odict=OrderedDict; assert odict([(1, 1), (2, 2)]) == odict([(2, 2), (1, 1)])</code> fails!</span>
<span class="comment-copy">Unfortunately this doesn't work if the values in the dict are mutable (ie not hashable).  (Ex <code>{'a':{'b':1}}</code> gives <code>TypeError: unhashable type: 'dict'</code>)</span>
<span class="comment-copy">It seems that the task is not only to check if the contents of both are the same but also to give a report of the differences</span>
<span class="comment-copy">I believe this is identical to <code>dict1 == dict2</code></span>
<span class="comment-copy">For anyone using Python3.5, the <code>cmp</code> built in has been removed (and should be treated as <a href="https://docs.python.org/3.0/whatsnew/3.0.html#ordering-comparisons" rel="nofollow noreferrer">removed before</a>. An alternative they propose: <code>(a &gt; b) - (a &lt; b) == cmp(a, b)</code> for a functional equivalent (or better <code>__eq__</code> and <code>__hash__</code>)</span>
<span class="comment-copy">@nerdwaller - dicts are not orderable types, so dict_a &gt; dict_b would raise a <code>TypeError</code>: <code>unorderable types: dict() &lt; dict()</code></span>
<span class="comment-copy">@Stefano: Good call, my comment was more for general comparison in python (I wasn't paying attention to the actual answer, my mistake) .</span>
<span class="comment-copy">Why nobody upvote this answer? I think it is good.</span>
<span class="comment-copy">Interesting. Thanks for answering this. Useful for me atleast. This answer needs more upvotes.</span>
<span class="comment-copy">If you use <code>not isinstance(dict1, dict)</code> instead of <code>type(dict1) is not dict</code>, this will work on other classes based on <code>dict. Also, instead of </code>(dict1[key] == dict2[key])<code>, you can do </code>all(atleast_1d(dict1[key] == dict2[key]))` to handle arrays at least.</span>
<span class="comment-copy">That's completly wrong, just parsing the data into json is really slow. Then hashing that huge sring you just created is even worse. You should never do that</span>
<span class="comment-copy">@Bruno: quoting the OP: <i>"Better not in speed, I am talking about code elegance"</i></span>
<span class="comment-copy">It's not elegant at all, it feels unsafe and it's overly complicated for a really simple problem</span>
<span class="comment-copy">@Bruno: elegance is subjective. I can understand that you do not like it (and probably downvoted). This is not the same as "wrong".</span>
<span class="comment-copy">This is a great answer. <code>json.dumps(d, sort_keys=True)</code> will give you canonical JSON so that you can be certain that both dict are equivalent. Also it depends what you are trying to achive. As soon as the value are not JSON serizalizable it will fail. For thus who say it is inefficient, have a look at the ujson project.</span>
<span class="comment-copy">Let's improve it so it works both ways. Line 2: "for x1 in set(dict1.keys()).union(dict2.keys()):"</span>
<span class="comment-copy">Welcome to Stack Overflow! While this code snippet may solve the question, <a href="//s.tk/meta/questions/114762/explaining-entirely-code-based-answers" rel="nofollow noreferrer">including an explanation</a> really helps to improve the quality of your post. Remember that you are answering the question for readers in the future, and those people might not know the reasons for your code suggestion. Please also try not to crowd your code with explanatory comments, this reduces the readability of both the code and the explanations!</span>
<span class="comment-copy">This may not do what was exactly requested, and pulls in the json std lib, but it does work ( as <code>json.dumps</code> is deterministic with the default settings ).</span>
