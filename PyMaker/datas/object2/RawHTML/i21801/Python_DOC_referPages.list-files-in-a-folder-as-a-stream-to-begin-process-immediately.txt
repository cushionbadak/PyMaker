<div class="post-text" itemprop="text">
<p>I get a folder with 1 million files in it.</p>
<p>I would like to begin process immediately, when listing files in this folder, in Python or other script langage.</p>
<p>The usual functions (os.listdir in python...) are blocking and my program has to wait the end of the list, which can take a long time.</p>
<p>What's the best way to list huge folders ?</p>
</div>
<div class="post-text" itemprop="text">
<p>If convenient, change your directory structure; but if not, you can <a href="http://mysqlcon.com/python/waling-directory-with-very-many-files-t6360-10.html#p23155" rel="nofollow noreferrer">use ctypes to call <code>opendir</code> and <code>readdir</code></a>.</p>
<p>Here is a copy of that code; all I did was indent it properly, add the <code>try/finally</code> block, and fix a bug. You might have to debug it. Particularly the struct layout.</p>
<p>Note that this code is <strong>not</strong> portable. You would need to use different functions on Windows, and I think the structs vary from Unix to Unix.</p>
<pre><code>#!/usr/bin/python
"""
An equivalent os.listdir but as a generator using ctypes
"""

from ctypes import CDLL, c_char_p, c_int, c_long, c_ushort, c_byte, c_char, Structure, POINTER
from ctypes.util import find_library

class c_dir(Structure):
    """Opaque type for directory entries, corresponds to struct DIR"""
    pass
c_dir_p = POINTER(c_dir)

class c_dirent(Structure):
    """Directory entry"""
    # FIXME not sure these are the exactly correct types!
    _fields_ = (
        ('d_ino', c_long), # inode number
        ('d_off', c_long), # offset to the next dirent
        ('d_reclen', c_ushort), # length of this record
        ('d_type', c_byte), # type of file; not supported by all file system types
        ('d_name', c_char * 4096) # filename
        )
c_dirent_p = POINTER(c_dirent)

c_lib = CDLL(find_library("c"))
opendir = c_lib.opendir
opendir.argtypes = [c_char_p]
opendir.restype = c_dir_p

# FIXME Should probably use readdir_r here
readdir = c_lib.readdir
readdir.argtypes = [c_dir_p]
readdir.restype = c_dirent_p

closedir = c_lib.closedir
closedir.argtypes = [c_dir_p]
closedir.restype = c_int

def listdir(path):
    """
    A generator to return the names of files in the directory passed in
    """
    dir_p = opendir(path)
    try:
        while True:
            p = readdir(dir_p)
            if not p:
                break
            name = p.contents.d_name
            if name not in (".", ".."):
                yield name
    finally:
        closedir(dir_p)

if __name__ == "__main__":
    for name in listdir("."):
        print name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This feels dirty but should do the trick:</p>
<pre><code>def listdirx(dirname='.', cmd='ls'):
    proc = subprocess.Popen([cmd, dirname], stdout=subprocess.PIPE)
    filename = proc.stdout.readline()
    while filename != '':
        yield filename.rstrip('\n')
        filename = proc.stdout.readline()
    proc.communicate()
</code></pre>
<p>Usage: <code>listdirx('/something/with/lots/of/files')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>For people coming in off Google, PEP 471 added a proper solution to the Python 3.5 standard library and it got backported to Python 2.6+ and 3.2+ as the <code>scandir</code> module on PIP.</p>
<p>Source: <a href="https://stackoverflow.com/a/34922054/435253">https://stackoverflow.com/a/34922054/435253</a></p>
<p>Python 3.5+:</p>
<ul>
<li><code>os.walk</code> has been updated to use this infrastructure for better performance.</li>
<li><code>os.scandir</code> returns an iterator over <code>DirEntry</code> objects.</li>
</ul>
<p>Python 2.6/2.7 and 3.2/3.3/3.4:</p>
<ul>
<li><code>scandir.walk</code> is a more performant version of <code>os.walk</code></li>
<li><code>scandir.scandir</code> returns an iterator over <code>DirEntry</code> objects.</li>
</ul>
<p>The <code>scandir()</code> iterators wrap <code>opendir</code>/<code>readdir</code> on POSIX platforms and <code>FindFirstFileW</code>/<code>FindNextFileW</code> on Windows.</p>
<p>The point of returning <code>DirEntry</code> objects is to allow metadata to be cached to minimize the number of system calls made. (eg. <code>DirEntry.stat(follow_symlinks=False)</code> never makes a system call on Windows because the <code>FindFirstFileW</code> and <code>FindNextFileW</code> functions throw in <code>stat</code> information for free)</p>
<p>Source: <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow noreferrer">https://docs.python.org/3/library/os.html#os.scandir</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is your answer on how to traverse a large directory file by file on Windows!</p>
<p>I searched like a maniac for a Windows DLL that will allow me to do what is done on Linux, but no luck.</p>
<p>So, I concluded that the only way is to create my own DLL that will expose those static functions to me, but then I remembered pywintypes.
And, YEEY! this is already done there. And, even more, an iterator function is already implemented! Cool!</p>
<p>A Windows DLL with FindFirstFile(), FindNextFile() and FindClose() may be still somewhere there but I didn't find it. So, I used pywintypes.</p>
<p>EDIT: They were hiding in plain sight in kernel32.dll. Please see ssokolow's answer, and my comment to it.</p>
<p>Sorry for dependency. But I think that you can extract win32file.pyd from ...\site-packages\win32 folder and eventual dependencies and distribute it independent of win32types with your program if you have to.</p>
<p>I found this question when searching on how to do this, and some others as well.</p>
<p>Here:</p>
<p><a href="https://stackoverflow.com/questions/31426536/how-to-copy-first-100-files-from-a-directory-of-thousands-of-files-using-python/31427309#31427309">How to copy first 100 files from a directory of thousands of files using python?</a></p>
<p>I posted a full code with Linux version of listdir() from here (by Jason Orendorff) and with my Windows version that I present here.</p>
<p>So anyone wanting a more or less cross-platform version, go there or combine two answers yourself.</p>
<p>EDIT: Or better still, use scandir module or os.scandir() (in Python 3.5) and following versions. It better handles errors and some other stuff as well.</p>
<pre><code>from win32file import FindFilesIterator
import os

def listdir (path):
    """
    A generator to return the names of files in the directory passed in
    """
    if "*" not in path and "?" not in path:
        st = os.stat(path) # Raise an error if dir doesn't exist or access is denied to us
        # Check if we got a dir or something else!
        # Check gotten from stat.py (for fast checking):
        if (st.st_mode &amp; 0170000) != 0040000:
            e = OSError()
            e.errno = 20; e.filename = path; e.strerror = "Not a directory"
            raise e
        path = path.rstrip("\\/")+"\\*"
    # Else:  Decide that user knows what she/he is doing
    for file in FindFilesIterator(path):
        name = file[-2]
        # Unfortunately, only drives (eg. C:) don't include "." and ".." in the list:
        if name=="." and name=="..": continue
        yield name
</code></pre>
</div>
<span class="comment-copy">You want the POSIX functions opendir/readdir, I think, but I don't believe they're available in Python's standard library. What's the processing you plan to do on the filenames?</span>
<span class="comment-copy">Where is "c_dir_p" defined?</span>
<span class="comment-copy">Pretty sure this is missing <code>c_dir_p = POINTER(c_dir)</code></span>
<span class="comment-copy">Oops. You're right, I'll add it.</span>
<span class="comment-copy">in line: <code>dir_p = opendir(".")</code> should be <code>path</code> instead of current directory</span>
<span class="comment-copy">Bogolt: Yep. Fixed it.</span>
<span class="comment-copy">That's pretty cool</span>
<span class="comment-copy"><code>ls</code> sorts the filenames, though, at least by default. So I don't think it can start returning them any faster than <code>os.listdir()</code> could. Is there a flag to make <code>ls</code> not sort?</span>
<span class="comment-copy"><code>ls -f</code> does not sort.  Note that <code>-f</code> turns on the <code>-a</code> flag so if you don't want hidden files, hidden directories, <code>.</code> and <code>..</code> they'd need to be filtered out.</span>
<span class="comment-copy">It seems its development started in 2013. but I didn't find it at the time (2015.). I really don't know how. Therefore I wrote myown solution and was also disappointed to discover (in scandir's code) that FindFirstFile is in kernel32.dll. Whole time hiding in front of my nose. For both reasons I was on a point of drowning myself in a teaspoon, but decided to edit my posts instead. :D You got here first, so +1! OK I still get to add info about FindFirstFile(). :D</span>
