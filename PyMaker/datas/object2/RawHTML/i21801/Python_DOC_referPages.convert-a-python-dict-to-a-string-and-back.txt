<div class="post-text" itemprop="text">
<p>I am writing a program that stores data in a dictionary object, but this data needs to be saved at some point during the program execution and loaded back into the dictionary object when the program is run again.
How would I convert a dictionary object into a string that can be written to a file and loaded back into a dictionary object? This will hopefully support dictionaries containing dictionaries.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/json.html" rel="noreferrer">The json module</a> is a good solution here. It has the advantages over pickle that it only produces plain text output, and is cross-platform and cross-version.</p>
<pre><code>json.dumps(dict)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your dictionary isn't too big maybe str + eval can do the work:</p>
<pre><code>dict1 = {'one':1, 'two':2, 'three': {'three.1': 3.1, 'three.2': 3.2 }}
str1 = str(dict1)

dict2 = eval(str1)

print dict1==dict2
</code></pre>
<p>You can use <a href="http://docs.python.org/library/ast.html" rel="noreferrer">ast.literal_eval</a> instead of eval for additional security if the source is untrusted.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use <a href="https://docs.python.org/2/library/json.html"><code>json</code></a>:</p>
<pre><code>import json

# convert to string
input = json.dumps({'id': id })

# load to dict
my_dict = json.loads(input) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://wiki.python.org/moin/UsingPickle" rel="noreferrer"><code>pickle</code></a> module to save it to disk and load later on.</p>
</div>
<div class="post-text" itemprop="text">
<p>If in Chinses</p>
<pre><code>import codecs
fout = codecs.open("xxx.json", "w", "utf-8")
dict_to_json = json.dumps({'text':"中文"},ensure_ascii=False,indent=2)
fout.write(dict_to_json + '\n')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not to use Python 3's inbuilt <strong>ast</strong> library's function <strong>literal_eval</strong>. It is better to use <strong>literal_eval</strong> instead of <strong>eval</strong></p>
<pre><code>import ast
str_of_dict = "{'key1': 'key1value', 'key2': 'key2value'}"
ast.literal_eval(str_of_dict)
</code></pre>
<p>will give output as actual Dictionary</p>
<pre><code>{'key1': 'key1value', 'key2': 'key2value'}
</code></pre>
<p>And If you are asking to convert a <strong>Dictionary to a String</strong> then, How about using <strong>str()</strong> method of Python. </p>
<p>Suppose the dictionary is : </p>
<pre><code>my_dict = {'key1': 'key1value', 'key2': 'key2value'}
</code></pre>
<p>And this will be done like this : </p>
<pre><code>str(my_dict)
</code></pre>
<p>Will Print : </p>
<pre><code>"{'key1': 'key1value', 'key2': 'key2value'}"
</code></pre>
<p>This is the easy as you like.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you should consider using the <a href="http://docs.python.org/library/shelve.html#module-shelve" rel="nofollow"><code>shelve</code></a> module which provides persistent file-backed dictionary-like objects. It's easy to use in place of a "real" dictionary because it almost transparently provides your program with something that can be used just like a dictionary, without the need to explicitly convert it to a string and then write to a file (or vice-versa). </p>
<p>The main difference is needing to initially <code>open()</code> it before first use and then <code>close()</code> it when you're done (and possibly <code>sync()</code>ing it, depending on the <code>writeback</code> option being used). Any "shelf" file objects create can contain regular dictionaries as values, allowing them to be logically nested.</p>
<p>Here's a trivial example:</p>
<pre><code>import shelve

shelf = shelve.open('mydata')  # open for reading and writing, creating if nec
shelf.update({'one':1, 'two':2, 'three': {'three.1': 3.1, 'three.2': 3.2 }})
shelf.close()

shelf = shelve.open('mydata')
print shelf
shelf.close()
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>{'three': {'three.1': 3.1, 'three.2': 3.2}, 'two': 2, 'one': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use yaml for that if needs to be readable (neither JSON nor XML are that IMHO), or if reading is not necessary I use pickle.</p>
<p>Write</p>
<pre><code>from pickle import dumps, loads
x = dict(a=1, b=2)
y = dict(c = x, z=3)
res = dumps(y)
open('/var/tmp/dump.txt', 'w').write(res)
</code></pre>
<p>Read back</p>
<pre><code>from pickle import dumps, loads
rev = loads(open('/var/tmp/dump.txt').read())
print rev
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use conventional methods rather than libraries, which are simple
. This worked for me</p>
<pre><code>dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
d=" " 
for  i in dict:
 a=i
 b=dict[i]
 c=i+":"+dict[i]
 d=d+c+'\n'

print d 
</code></pre>
</div>
<span class="comment-copy">I will be taking a look at this module as well. Both json and pickle seem easy enough to use, so it will come down to things such as cross-platform support. Thanks</span>
<span class="comment-copy">Pickle tends to be seen as rather deprecated at this point. I always use json for things like this. Being (relatively) human readable is a BIG plus much of the time.</span>
<span class="comment-copy">You are right, the readability is a great feature, especially for what I am using this for.</span>
<span class="comment-copy">You should add a simple example to allow users see how to do that.</span>
<span class="comment-copy">@TylerEaves Can you provide example how it should be done.</span>
<span class="comment-copy">I am not really prepared to deal with the possible exploits this could introduce into the code. I don't know what problems json or pickle might have, but I know for a fact that eval would be dangerous in this case.</span>
<span class="comment-copy">@AJ00200: and the ast.literal_eval alternative I mentioned?. From the Python help: "Safely evaluate an expression node or a string containing a Python expression. The string or node provided may only consist of the following Python literal structures: strings, numbers, tuples, lists, dicts, booleans, and None. This can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself."</span>
<span class="comment-copy">The does seem useful, but when I was previously using SQLite to handle this data and it had over 1500 entries, so it is quite large and growing all the time.</span>
<span class="comment-copy">cPickle is faster.</span>
<span class="comment-copy">Lets get the basics first, shall we? Performance is next ;)</span>
<span class="comment-copy">@extraneon Actually, it is an answer to the question. It converts it to a string somewhere and writes it to a file. I don't have to do the actual conversion or file writing as it is all encapsulated by pickle.</span>
<span class="comment-copy">You should really use <code>b</code> flag when opening file here.</span>
<span class="comment-copy">I could have been more explicit. However <code>dumps()</code> defaults to protocol 0, which is an ascii protocol. That is why <code>'rb'</code> is not necessary IMHO.</span>
<span class="comment-copy">How do you convert this back into a <code>dict</code> object, and why is it better than any of the other methods?</span>
<span class="comment-copy">better in d sense looks simple and straight forward if u need to just convert to a string and store it .</span>
<span class="comment-copy">Doesn't work for nested objects</span>
