<div class="post-text" itemprop="text">
<pre><code>class A(object):
    x = 4

i = A()
d = {}

d[i] = 2

print d

i.x = 10

print d
</code></pre>
<p>I thought only immutable objects can be dictionary keys, but the object i above is mutable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Any object with a <a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">__hash__</a> method can be a dictionary key.  For classes you write, this method defaults to returning a value based off id(self), and if equality is not determined by identity for those classes, you may be surprised by using them as keys:</p>
<pre><code>&gt;&gt;&gt; class A(object):
...   def __eq__(self, other):
...     return True
... 
&gt;&gt;&gt; one, two = A(), A()
&gt;&gt;&gt; d = {one: "one"}
&gt;&gt;&gt; one == two
True
&gt;&gt;&gt; d[one]
'one'
&gt;&gt;&gt; d[two]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: &lt;__main__.A object at 0xb718836c&gt;

&gt;&gt;&gt; hash(set())  # sets cannot be dict keys
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'set'
</code></pre>
<blockquote>
<p>Changed in version 2.6: __hash__ may now be set to None to explicitly flag instances of a class as unhashable. <sup>[<a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">__hash__</a>]</sup></p>
</blockquote>
<pre><code>class Unhashable(object):
  __hash__ = None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The requirement is that the hash of an object doesn't change over time, and that it keeps comparing equal (==) with its original value. Your class A meets both these requirements, so it makes a valid dictionary key. The x attribute is not considered at all in keying, only the object identity is.</p>
</div>
<div class="post-text" itemprop="text">
<p>An object kan be a key in a dictionary if it is <a href="http://docs.python.org/glossary.html#term-hashable" rel="noreferrer">hashable</a>.</p>
<p>Here is the definition of hashable from the documentation:</p>
<blockquote>
<p>An object is hashable if it has a hash value which never changes during its lifetime (it needs a <a href="http://docs.python.org/reference/datamodel.html#object.__hash__" rel="noreferrer"><code>__hash__()</code></a> method), and can be compared to other objects (it needs an <a href="http://docs.python.org/reference/datamodel.html#object.__eq__" rel="noreferrer"><code>__eq__()</code></a> or<a href="http://docs.python.org/reference/datamodel.html#object.__cmp__" rel="noreferrer"><code>__cmp__()</code></a> method). Hashable objects which compare equal must have the same hash value.</p>
<p>Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.</p>
<p>All of Pythonâ€™s immutable built-in objects are hashable, while no mutable containers (such as lists or dictionaries) are. Objects which are instances of user-defined classes are hashable by default; they all compare unequal, and their hash value is their id().</p>
</blockquote>
<p>Since <code>object</code> provides a default implementation of <code>__hash__</code>, <code>__eq__</code> and <code>__cmp__</code> this means that anything deriving from <code>object</code> is hashable unless it is explicitly defined not to be hashable. It is not disallowed to create a mutable type that is hashable, but it might not behave as you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>@fred-nurk's example above luckily no longer works in Python 3, because of <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow">this change</a>:</p>
<blockquote>
<p>A class that overrides <code>__eq__()</code> and does not define <code>__hash__()</code> will have its <code>__hash__()</code> implicitly set to <code>None</code>. When the <code>__hash__()</code> method of a class is <code>None</code>, instances of the class will raise an appropriate <code>TypeError</code> when a program attempts to retrieve their hash value...</p>
</blockquote>
<p>Thank God for that. However, if you explicitly define <code>__hash__()</code> for yourself, you can still do evil things:</p>
<pre><code>class BadHasher:
    def __init__(self):
        self.first = True

    # Implement __hash__ in an evil way. The first time an instance is hashed,
    # return 1. Every time after that, return 0.
    def __hash__(self):
        if self.first:
            self.first = False
            return 1
        return 0

myobject = BadHasher()
# We can put this object in a set...
myset = {myobject}
# ...but as soon as we look for it, it's gone!
if myobject not in myset:
    print("what the hell we JUST put it in there")
</code></pre>
</div>
