<div class="post-text" itemprop="text">
<p>In Python, long integers have unlimited precision. I would like to write a 16 byte (128 bit) integer to a file. <code>struct</code> from the standard library supports only up to 8 byte integers. <code>array</code> has the same limitation. Is there a way to do this without masking and shifting each integer?</p>
<p>Some clarification here: I'm writing to a file that's going to be read in from non-Python programs, so pickle is out. All 128 bits are used.</p>
</div>
<div class="post-text" itemprop="text">
<p>Two possible solutions:</p>
<ol>
<li><p>Just <a href="http://docs.python.org/library/pickle.html" rel="nofollow noreferrer">pickle</a> your long integer.  This will write the integer in a special format which allows it to be read again, if this is all you want.</p></li>
<li><p>Use the second code snippet in <a href="https://stackoverflow.com/questions/4358285/is-there-a-faster-way-to-convert-an-arbitrary-large-integer-to-a-big-endian-seque/4358429#4358429">this answer</a> to convert the long int to a big endian string (which can be easily changed to little endian if you prefer), and write this string to your file.</p></li>
</ol>
<p>The problem is that the internal representation of bigints does not directly include the binary data you ask for.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think for unsigned integers (and ignoring endianness) something like</p>
<pre><code>import binascii

def binify(x):
    h = hex(x)[2:].rstrip('L')
    return binascii.unhexlify('0'*(32-len(h))+h)

&gt;&gt;&gt; for i in 0, 1, 2**128-1:
...     print i, repr(binify(i))
... 
0 '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
1 '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01'
340282366920938463463374607431768211455 '\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
</code></pre>
<p>might technically satisfy the requirements of having non-Python-specific output, not using an explicit mask, and (I assume) not using any non-standard modules.  Not particularly elegant, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://pypi.python.org/pypi/bitarray" rel="nofollow noreferrer">PyPi bitarray</a> module in combination with the builtin <code>bin()</code> function seems like a good combination for a solution that is simple and flexible.</p>
<pre><code>bytes = bitarray(bin(my_long)[2:]).tobytes()
</code></pre>
<p>The endianness can be controlled with a few more lines of code. You'll have to evaluate the efficiency.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not use struct with the <em>unsigned long long</em> type twice?</p>
<pre><code>import struct
some_file.write(struct.pack("QQ", var/(2**64), var%(2**64)))
</code></pre>
<p>That's documented here (scroll down to get the table with Q): <a href="http://docs.python.org/library/struct.html" rel="nofollow">http://docs.python.org/library/struct.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This may not avoid the "mask and shift each integer" requirement.  I'm not sure that avoiding mask and shift means in the context of Python long values. </p>
<p>The bytes are these:</p>
<pre><code>def bytes( long_int ):
    bytes = []
    while long_int != 0:
        b = long_int%256
        bytes.insert( 0, b )
        long_int //= 256
    return bytes
</code></pre>
<p>You can then pack this list of bytes using <code>struct.pack( '16b', bytes )</code></p>
</div>
<div class="post-text" itemprop="text">
<p>With Python 3.2 and later, you can use <code>int.to_bytes</code> and <code>int.from_bytes</code>: <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow">https://docs.python.org/3/library/stdtypes.html#int.to_bytes</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You could pickle the object to binary, use protocol buffers (I don't know if they allow you to serialize unlimited precision integers though) or BSON if you do not want to write code.</p>
<p>But writing a function that dumps 16 byte integers by shifting it should not be so hard to do if it's not time critical.</p>
</div>
<div class="post-text" itemprop="text">
<p>This may be a little late, but I don't see why you can't use struct:</p>
<pre><code>bigint = 0xFEDCBA9876543210FEDCBA9876543210L
print bigint,hex(bigint).upper()

cbi = struct.pack("!QQ",bigint&amp;0xFFFFFFFFFFFFFFFF,(bigint&gt;&gt;64)&amp;0xFFFFFFFFFFFFFFFF)

print len(cbi)
</code></pre>
<p>The bigint by itself is rejected, but if you mask it with &amp;0xFFFFFFFFFFFFFFFF you can reduce it to an 8 byte int instead of 16.  Then the upper part is shifted and masked as well.  You may have to play with byte ordering a bit.  I used the ! mark to tell it to produce a network endian byte order.  Also, the msb and lsb (upper and lower bytes) may need to be reversed.  I will leave that as an exercise for the user to determine.  I would say saving things as network endian would be safer so you always know what the endianess of your data is.</p>
<p>No, don't ask me if network endian is big or little endian...</p>
</div>
<span class="comment-copy">It looks like he has already done that - <i>struct from the standard library supports only up to 8 byte integers.</i></span>
<span class="comment-copy">Do you need the whole 128 bit range, or just the lower 64 bits, do you need signed integers?</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/4358285/is-there-a-faster-way-to-convert-an-arbitrary-large-integer-to-a-big-endian-seque">Is there a faster way to convert an arbitrary large integer to a big endian sequence of bytes?</a></span>
<span class="comment-copy">This fails for negative input: <code>hex(x)</code> returns <code>-0x123</code> for example.</span>
<span class="comment-copy">@Score_Under: the very first sentence says "for unsigned integers".</span>
<span class="comment-copy">Be careful! <code>bin()</code> produces something like <code>0b0101110</code>, so you need to trim off the <code>0b</code> prefix.</span>
<span class="comment-copy">You also want <code>tobytes()</code> not <code>tostring()</code>.</span>
<span class="comment-copy">The idea is more or less ok, but the code is invalid.</span>
<span class="comment-copy">"invalid"?  Could you be more specific so that I can fix it?</span>
<span class="comment-copy">There is some confusion with the variable names (<code>n</code> vs. <code>long_int</code>).  Also, you probably should use <code>n //= 256</code> or <code>n &gt;&gt;= 8</code> or <code>n, b = divmod(n, 256)</code> instead of <code>n /= 256</code> to prevent an (almost) infinite loop in Python 3 (or when a float is passed).</span>
<span class="comment-copy">@Apalala, @Sven Marnach.  Thanks.</span>
<span class="comment-copy">That can probably look even nicer with <code>long_int, b = divmod(long_int, 256)</code> :)</span>
