<div class="post-text" itemprop="text">
<p>As far as I know, Python has 3 ways of finding out what operating system is running on:</p>
<ol>
<li><code>os.name</code></li>
<li><code>sys.platform</code></li>
<li><code>platform.system()</code></li>
</ol>
<p>Knowing this information is often useful in conditional imports, or using functionality that differs between platforms (e.g. <code>time.clock()</code> on Windows v.s. <code>time.time()</code> on UNIX).</p>
<p>My question is, why 3 different ways of doing this? When should one way be used and not another? Which way is the 'best' (most future-proof or least likely to accidentally exclude a particular system which your program can actually run on)?</p>
<p>It seems like <code>sys.platform</code> is more specific than <code>os.name</code>, allowing you to distinguish <code>win32</code> from <code>cygwin</code> (as opposed to just <code>nt</code>), and <code>linux2</code> from <code>darwin</code> (as opposed to just <code>posix</code>). But if that's so, that what about the difference between <code>sys.platform</code> and <code>platform.system()</code>?</p>
<p>For example, which is better, this:</p>
<pre><code>import sys
if sys.platform == 'linux2':
    # Do Linux-specific stuff
</code></pre>
<p>or this? :</p>
<pre><code>import platform
if platform.system() == 'Linux':
    # Do Linux-specific stuff
</code></pre>
<p>For now I'll be sticking to <code>sys.platform</code>, so this question isn't particularly urgent, but I would be very grateful for some clarification regarding this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Dived a bit into the source code.</p>
<p>The output of <code>sys.platform</code> and <code>os.name</code> are determined at compile time. <code>platform.system()</code> determines the system type at run time.</p>
<ul>
<li><code>sys.platform</code> is specified as a compiler define during the build configuration.</li>
<li><code>os.name</code> checks whether certain os specific modules are available (e.g. <code>posix</code>, <code>nt</code>, ...)</li>
<li><code>platform.system()</code> actually runs <code>uname</code> and potentially several other functions to determine the system type at run time.</li>
</ul>
<p>My suggestion, use <code>os.name</code> to check whether it's a posix-compliant system, use <code>sys.platform</code> to check whether it's a linux, cygwin, darwin, atheos, whatever, and use <code>platform.system()</code>, well, if you don't believe the other sources.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a thin line difference between <code>platform.system()</code> and <code>sys.platform</code> and interestingly for most cases  <code>platform.system()</code> degenerates to <code>sys.platform</code></p>
<p>Here is what the Source <code>Python2.7\Lib\Platform.py\system</code> says</p>
<pre><code>def system():

    """ Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    """
    return uname()[0]

def uname():
    # Get some infos from the builtin os.uname API...
    try:
        system,node,release,version,machine = os.uname()
    except AttributeError:
        no_os_uname = 1

    if no_os_uname or not filter(None, (system, node, release, version, machine)):
        # Hmm, no there is either no uname or uname has returned
        #'unknowns'... we'll have to poke around the system then.
        if no_os_uname:
            system = sys.platform
            release = ''
            version = ''
            node = _node()
            machine = ''
</code></pre>
<p>Also per the <a href="http://docs.python.org/2/library/os.html#os.uname">documentation</a></p>
<blockquote>
<p>os.uname()</p>
<p>Return a 5-tuple containing information identifying the current operating system. The tuple contains 5 strings: (sysname, nodename,
  release, version, machine). Some systems truncate the nodename to 8
  characters or to the leading component; a better way to get the
  hostname is socket.gethostname() or even
  socket.gethostbyaddr(socket.gethostname()).</p>
<pre><code>Availability: recent flavors of Unix.
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="http://docs.python.org/dev/library/sys.html#sys.platform"><code>sys.platform</code> docs</a>:</p>
<ul>
<li><a href="http://docs.python.org/dev/library/os.html#os.name"><code>os.name</code></a> has a coarser granularity</li>
<li><a href="http://docs.python.org/dev/library/os.html#os.uname"><code>os.uname()</code></a> gives system-dependent version information</li>
<li>The <a href="http://docs.python.org/dev/library/platform.html#module-platform"><code>platform</code></a> module provides detailed checks for the systemâ€™s identity</li>
</ul>
<p>Often the "best" future-proof way to test whether some functionality is available is just to try to use it and use a fallback if it fails.</p>
<blockquote>
<p>what about the difference between sys.platform and platform.system()?</p>
</blockquote>
<p><a href="http://hg.python.org/cpython/file/2.7/Lib/platform.py#l1139"><code>platform.system()</code></a> returns a normalized value that it might get from several sources: <code>os.uname()</code>, <code>sys.platform</code>, <code>ver</code> command (on Windows).</p>
</div>
<div class="post-text" itemprop="text">
<p>It depends on whether you prefer raising exception or trying anything on an untested system and whether your code is so high level or so low level that it can or can't work on a similar untested system (e.g. untested Mac - 'posix' or on embedded ARM systems). More pythonic is to not enumerate all known systems but to test possible relevant properties. (e.g. it is considered important the endianess of the system but unimportant multiprocessing properties.)</p>
<ul>
<li><p>os.name is a sufficient resolution for the correct usage of <code>os</code> module. Possible values are 'posix', 'nt', 'os2', 'ce', 'java' or 'riscos' in Python 2.7, while only the 'posix', 'nt' and 'java' are used since Python 3.4.</p></li>
<li><p>sys.platform is a finer resolution. It is recommended to use <code>if sys.platform.startswith('linux')</code> idiom because "linux2" means a Linux kernel version 2.xx or 3. Older kernels are currently never used. In Python 3.3 are all Linux systems simple 'linux'. </p></li>
</ul>
<p>I do not know the specifics of "Mac" and "Java" systems and so I can not use the results of very good method platform.system() for branching, but I would use advantages of the <code>platform</code> module for messages and error logging.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe the platform module is probably preferred for new code. The others existed before it. It is an evolution, and the others remain for backwards compatibility.</p>
</div>
<span class="comment-copy">use <code>sys.platform.startswith('linux')</code> instead of <code>sys.platform == 'linux2'</code> for future compatibility</span>
<span class="comment-copy"><code>os.name</code> possible return values are <code>'posix'</code>, <code>'nt'</code>, <code>'java'</code> according to <a href="https://docs.python.org/3/library/os.html#os.name" rel="nofollow noreferrer">Python 3 docs</a>. See also: <a href="https://docs.python.org/3/library/platform.html" rel="nofollow noreferrer">platform module docs</a>. I do <i>not</i> believe <code>'riscos'</code> and <code>'os2</code>' are possible return values from <code>os.name</code>; they may be <a href="https://stackoverflow.com/a/13874620/737230">return values from <code>sys.platform</code></a>. The <a href="https://docs.python.org/3/library/sys.html#platform" rel="nofollow noreferrer">Python 3 <code>sys.platform</code> documentation</a> does not appear to be exhaustive.</span>
<span class="comment-copy">@afeique: I updated my answer for newer Python, but it was right at that time. See <a href="https://docs.python.org/3.3/library/os.html#os.name" rel="nofollow noreferrer">Python 3.3 - os.name</a> (the latest version at that time). Python 2.7 is still supported and 'riscos' is a possible value for it.</span>
<span class="comment-copy">Thanks @hynekcer, I appreciate your edit to add Python version numbers. I apologize for not realizing it changed after Python 3.3. I did not peruse the different versions of the documentation and made the gross assumption that Python 3 behaviour of <code>os.name</code> was consistent across versions. I also did not double-check the <a href="https://docs.python.org/2.7/library/os.html#os.name" rel="nofollow noreferrer">2.7 documentation</a>, but I know now that you're correct.</span>
<span class="comment-copy">I wonder if we can get any Python developers to confirm this. Maybe even whoever developed the platform module.</span>
