<div class="post-text" itemprop="text">
<p>I'd like something that has the same effect as this:</p>
<pre><code>&gt;&gt;&gt; path = "/foo/bar/baz/file"
&gt;&gt;&gt; path_split = path.rsplit('/')[1:]
&gt;&gt;&gt; path_split
['foo', 'bar', 'baz', 'file']
</code></pre>
<p>But that will work with Windows paths too. I know that there is an <code>os.path.split()</code> but that doesn't do what I want, and I didn't see anything that does.</p>
</div>
<div class="post-text" itemprop="text">
<p>The OP specified "will work with Windows paths too". There are a few wrinkles with Windows paths.</p>
<p>Firstly, Windows has the concept of multiple drives, each with its own current working directory, and <code>'c:foo'</code> and <code>'c:\\foo'</code> are often not the same. Consequently it is a very good idea to separate out any drive designator first, using os.path.splitdrive(). Then reassembling the path (if required) can be done correctly by
<code>drive + os.path.join(*other_pieces)</code></p>
<p>Secondly, Windows paths can contain slashes or backslashes or a mixture. Consequently, using <code>os.sep</code> when parsing an unnormalised path is not useful.</p>
<p>More generally:</p>
<p>The results produced for <code>'foo'</code> and <code>'foo/'</code> should not be identical.</p>
<p>The loop termination condition seems to be best expressed as "os.path.split() treated its input as unsplittable".</p>
<p>Here's a suggested solution, with tests, including a comparison with @Spacedman's solution</p>
<pre><code>import os.path

def os_path_split_asunder(path, debug=False):
    parts = []
    while True:
        newpath, tail = os.path.split(path)
        if debug: print repr(path), (newpath, tail)
        if newpath == path:
            assert not tail
            if path: parts.append(path)
            break
        parts.append(tail)
        path = newpath
    parts.reverse()
    return parts

def spacedman_parts(path):
    components = [] 
    while True:
        (path,tail) = os.path.split(path)
        if not tail:
            return components
        components.insert(0,tail)

if __name__ == "__main__":
    tests = [
        '',
        'foo',
        'foo/',
        'foo\\',
        '/foo',
        '\\foo',
        'foo/bar',
        '/',
        'c:',
        'c:/',
        'c:foo',
        'c:/foo',
        'c:/users/john/foo.txt',
        '/users/john/foo.txt',
        'foo/bar/baz/loop',
        'foo/bar/baz/',
        '//hostname/foo/bar.txt',
        ]
    for i, test in enumerate(tests):
        print "\nTest %d: %r" % (i, test)
        drive, path = os.path.splitdrive(test)
        print 'drive, path', repr(drive), repr(path)
        a = os_path_split_asunder(path)
        b = spacedman_parts(path)
        print "a ... %r" % a
        print "b ... %r" % b
        print a == b
</code></pre>
<p>and here's the output (Python 2.7.1, Windows 7 Pro):</p>
<pre><code>Test 0: ''
drive, path '' ''
a ... []
b ... []
True

Test 1: 'foo'
drive, path '' 'foo'
a ... ['foo']
b ... ['foo']
True

Test 2: 'foo/'
drive, path '' 'foo/'
a ... ['foo', '']
b ... []
False

Test 3: 'foo\\'
drive, path '' 'foo\\'
a ... ['foo', '']
b ... []
False

Test 4: '/foo'
drive, path '' '/foo'
a ... ['/', 'foo']
b ... ['foo']
False

Test 5: '\\foo'
drive, path '' '\\foo'
a ... ['\\', 'foo']
b ... ['foo']
False

Test 6: 'foo/bar'
drive, path '' 'foo/bar'
a ... ['foo', 'bar']
b ... ['foo', 'bar']
True

Test 7: '/'
drive, path '' '/'
a ... ['/']
b ... []
False

Test 8: 'c:'
drive, path 'c:' ''
a ... []
b ... []
True

Test 9: 'c:/'
drive, path 'c:' '/'
a ... ['/']
b ... []
False

Test 10: 'c:foo'
drive, path 'c:' 'foo'
a ... ['foo']
b ... ['foo']
True

Test 11: 'c:/foo'
drive, path 'c:' '/foo'
a ... ['/', 'foo']
b ... ['foo']
False

Test 12: 'c:/users/john/foo.txt'
drive, path 'c:' '/users/john/foo.txt'
a ... ['/', 'users', 'john', 'foo.txt']
b ... ['users', 'john', 'foo.txt']
False

Test 13: '/users/john/foo.txt'
drive, path '' '/users/john/foo.txt'
a ... ['/', 'users', 'john', 'foo.txt']
b ... ['users', 'john', 'foo.txt']
False

Test 14: 'foo/bar/baz/loop'
drive, path '' 'foo/bar/baz/loop'
a ... ['foo', 'bar', 'baz', 'loop']
b ... ['foo', 'bar', 'baz', 'loop']
True

Test 15: 'foo/bar/baz/'
drive, path '' 'foo/bar/baz/'
a ... ['foo', 'bar', 'baz', '']
b ... []
False

Test 16: '//hostname/foo/bar.txt'
drive, path '' '//hostname/foo/bar.txt'
a ... ['//', 'hostname', 'foo', 'bar.txt']
b ... ['hostname', 'foo', 'bar.txt']
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.4 introduced a new module <a href="https://docs.python.org/3/library/pathlib.html#module-pathlib" rel="noreferrer"><code>pathlib</code></a>.  <a href="https://docs.python.org/3/library/pathlib.html#concrete-paths" rel="noreferrer"><code>pathlib.Path</code></a> provides file system related methods, while <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath" rel="noreferrer"><code>pathlib.PurePath</code></a> operates completely independent of the file system:</p>
<pre><code>&gt;&gt;&gt; from pathlib import PurePath
&gt;&gt;&gt; path = "/foo/bar/baz/file"
&gt;&gt;&gt; path_split = PurePath(path).parts
&gt;&gt;&gt; path_split
('\\', 'foo', 'bar', 'baz', 'file')
</code></pre>
<p>You can use PosixPath and WindowsPath explicitly when desired:</p>
<pre><code>&gt;&gt;&gt; from pathlib import PureWindowsPath, PurePosixPath
&gt;&gt;&gt; PureWindowsPath(path).parts
('\\', 'foo', 'bar', 'baz', 'file')
&gt;&gt;&gt; PurePosixPath(path).parts
('/', 'foo', 'bar', 'baz', 'file')
</code></pre>
<p>And of course, it works with Windows paths as well:</p>
<pre><code>&gt;&gt;&gt; wpath = r"C:\foo\bar\baz\file"
&gt;&gt;&gt; PurePath(wpath).parts
('C:\\', 'foo', 'bar', 'baz', 'file')
&gt;&gt;&gt; PureWindowsPath(wpath).parts
('C:\\', 'foo', 'bar', 'baz', 'file')
&gt;&gt;&gt; PurePosixPath(wpath).parts
('C:\\foo\\bar\\baz\\file',)
&gt;&gt;&gt;
&gt;&gt;&gt; wpath = r"C:\foo/bar/baz/file"
&gt;&gt;&gt; PurePath(wpath).parts
('C:\\', 'foo', 'bar', 'baz', 'file')
&gt;&gt;&gt; PureWindowsPath(wpath).parts
('C:\\', 'foo', 'bar', 'baz', 'file')
&gt;&gt;&gt; PurePosixPath(wpath).parts
('C:\\foo', 'bar', 'baz', 'file')
</code></pre>
<p>Huzzah for Python devs constantly improving the language!</p>
</div>
<div class="post-text" itemprop="text">
<p>Someone said "use <code>os.path.split</code>". This got deleted unfortunately, but it is the right answer.</p>
<blockquote>
<p>os.path.split(path)</p>
<p>Split the pathname path into a pair, (head, tail) where tail is the last pathname component and head is everything leading up to that. The tail part will never contain a slash; if path ends in a slash, tail will be empty. If there is no slash in path, head will be empty. If path is empty, both head and tail are empty. Trailing slashes are stripped from head unless it is the root (one or more slashes only). In all cases, join(head, tail) returns a path to the same location as path (but the strings may differ).</p>
</blockquote>
<p>So it's not just splitting the dirname and filename. You can apply it several times to get the full path in a portable and correct way. Code sample:</p>
<pre><code>dirname = path
path_split = []
while True:
    dirname, leaf = split(dirname)
    if leaf:
        path_split = [leaf] + path_split #Adds one element, at the beginning of the list
    else:
        #Uncomment the following line to have also the drive, in the format "Z:\"
        #path_split = [dirname] + path_split 
        break
</code></pre>
<p>Please credit the original author if that answer gets undeleted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the functionality provided in <a href="http://docs.python.org/library/os.path.html" rel="nofollow"><code>os.path</code></a>, e.g.</p>
<pre><code>os.path.split(path)
</code></pre>
<p>Like written elsewhere you can call it multiple times to split longer paths.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the functionality provided in os.path, e.g.</p>
<pre><code>os.path.split(path)
</code></pre>
<p>(This answer was by someone else and was mysteriously and incorrectly deleted, since it's a working answer; if you want to split each part of the path apart, you can call it multiple times, and each call will pull a component off of the end.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an explicit implementation of the approach that just iteratively
uses <code>os.path.split</code>; uses a slightly different loop termination condition than the accepted answer.</p>
<pre><code>def splitpath(path):
    parts=[]
    (path, tail)=os.path.split( path)
    while path and tail:
         parts.append( tail)
         (path,tail)=os.path.split(path)
    parts.append( os.path.join(path,tail) )
    return map( os.path.normpath, parts)[::-1]
</code></pre>
<p>This should satisfy <code>os.path.join( *splitpath(path) )</code> is <code>path</code> 
in the sense that they both indicate the same file/directory. </p>
<p>Tested in linux:</p>
<pre><code>In [51]: current='/home/dave/src/python'

In [52]: splitpath(current)
Out[52]: ['/', 'home', 'dave', 'src', 'python'] 

In [53]: splitpath(current[1:])
Out[53]: ['.', 'dave', 'src', 'python']

In [54]: splitpath( os.path.join(current, 'module.py'))
Out[54]: ['/', 'home', 'dave', 'src', 'python', 'module.py']

In [55]: splitpath( os.path.join(current[1:], 'module.py'))
Out[55]: ['.', 'dave', 'src', 'python', 'module.py']
</code></pre>
<p>I hand checked a few of the DOS paths, using the by replacing <code>os.path</code> with <code>ntpath</code> module, look OK to me, but I'm not too familiar with the ins and outs of DOS paths.</p>
</div>
<div class="post-text" itemprop="text">
<p>One more try with maxplit option, which is a replacement for os.path.split()</p>
<pre class="lang-py prettyprint-override"><code>def pathsplit(pathstr, maxsplit=1):
    """split relative path into list"""
    path = [pathstr]
    while True:
        oldpath = path[:]
        path[:1] = list(os.path.split(path[0]))
        if path[0] == '':
            path = path[1:]
        elif path[1] == '':
            path = path[:1] + path[2:]
        if path == oldpath:
            return path
        if maxsplit is not None and len(path) &gt; maxsplit:
            return path
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So keep using os.path.split until you get to what you want. Here's an ugly implementation using an infinite loop:</p>
<pre><code>import os.path
def parts(path):
    components = [] 
    while True:
        (path,tail) = os.path.split(path)
        if tail == "":
            components.reverse()
            return components
        components.append(tail)
</code></pre>
<p>Stick that in parts.py, import parts, and voila:</p>
<pre><code>&gt;&gt;&gt; parts.parts("foo/bar/baz/loop")
['foo', 'bar', 'baz', 'loop']
</code></pre>
<p>Probably a nicer implementation using generators or recursion out there...</p>
</div>
<span class="comment-copy">BTW Python has <code>os.path</code> that assumes your current OS path syntax but there are also OS-specific path modules called <a href="http://docs.python.org/2/library/os.path.html" rel="nofollow noreferrer"><code>posixpath</code>, <code>ntpath</code>, <code>macpath</code> and <code>os2emxpath</code></a> with the same interface.</span>
<span class="comment-copy">I'm on OS X. <code>os_path_split_asunder(r'c:\windows\program files\winword.exe') &gt;&gt;&gt; ['c:\\windows\\program files\\winword.exe']</code></span>
<span class="comment-copy">except in python 2.7 you <i>have</i> <code>os.path.normpath()</code>, so normalize the path, then split it using <code>os.sep</code>. The objective should be behavorial identity, not literal identity. ('C:/dir/..\\file2' === 'C:\\file2').</span>
<span class="comment-copy">looks great but need for 2.7</span>
<span class="comment-copy">@user966588: that is no problem at all, just run <code>pip install pathlib</code></span>
<span class="comment-copy"><a href="https://pypi.python.org/pypi/pathlib2/" rel="nofollow noreferrer">Backport of pathlib (named pathlib2) is here</a>.</span>
<span class="comment-copy">this library is a godsend</span>
<span class="comment-copy">+1: Just using the proper library functions the right way is really the best solution.</span>
<span class="comment-copy">@lunaryorn: Not necessarily the best; this is O(n^2), after all.  It's not likely to matter for path-length strings, though.</span>
<span class="comment-copy">Why is this solution O(n^2)?  Sorry, if the answer is obvious, but I'm not getting it.  "os.split()" likely just traverses the given path from the right side up to the last occurrence of a path separator.  So even if the function itself is applied multiple times, the overall complexity should just be O(n) as well (with n being the length of the initial path).</span>
<span class="comment-copy">Easier said than done. Show your code.</span>
<span class="comment-copy">lunaryorn my intuition for why it's O(n^2) is that if i think of every iteration before the last taking a little longer until it's the entire length of the string... add up all the time it takes <code>1 + 2 +  ... + n</code> and that series is <code>n * (n+1) / 2</code>, which is O(n^2)</span>
<span class="comment-copy">Please read my question. <code>os.path.split()</code> just splits it into a pair in the form <code>(dir, basename)</code>—not what I want.</span>
<span class="comment-copy">I'm sorry for not getting what you said. If you want, edit your question so I can upvote you.</span>
<span class="comment-copy">Easier said than done. Show your code.</span>
<span class="comment-copy">He asked how to do it, and I told him how.  I'm not going to hold his hand for such a simple thing.</span>
<span class="comment-copy">(I'm surprised people are willing to admit publically that they can't figure out how to call a function twice without it being written for them.)</span>
<span class="comment-copy">how about <code>the_path.split(os.path.sep)</code>? just saying…</span>
<span class="comment-copy">@aharon: -1 Multiple problems, see my answer.</span>
<span class="comment-copy">@hop: as already commented elsewhere, Windows paths can MIX slashes and backslashes.</span>
<span class="comment-copy">-1 this does not work. See @john-machin answer for solution</span>
