<div class="post-text" itemprop="text">
<p>I have a piece of code in Python that seems to cause an error probabilistically because it is accessing a server and sometimes that server has a 500 internal server error. I want to keep trying until I do not get the error. My solution was:</p>
<pre><code>while True:
    try:
        #code with possible error
    except:
         continue
    else:
         #the rest of the code
         break
</code></pre>
<p>This seems like a hack to me. Is there a more Pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>It won't get much cleaner. This is not a very clean thing to do. At best (which would be more readable anyway, since the condition for the <code>break</code> is up there with the <code>while</code>), you could create a variable <code>result = None</code> and loop while it <code>is None</code>. You should also adjust the variables and you can replace <code>continue</code> with the semantically perhaps correct <code>pass</code> (you don't care if an error occurs, you just want to ignore it) and drop the <code>break</code> - this also gets the rest of the code, which only executes once, out of the loop. Also note that bare <code>except:</code> clauses are evil for reasons <a href="https://web.archive.org/web/20140526061028/https://docs.python.org/3/howto/doanddont.html#except" rel="noreferrer">given in the documentation</a>.</p>
<p>Example incorporating all of the above:</p>
<pre><code>result = None
while result is None:
    try:
        # connect
        result = get_data(...)
    except:
         pass
# other code that uses result but is not involved in getting it
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe something like this:</p>
<pre><code>connected = False

while not connected:
    try:
        try_connect()
        connected = True
    except ...:
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one that hard fails after 4 attempts, and waits 2 seconds between attempts. Change as you wish to get what you want form this one:</p>
<pre><code>from time import sleep

for x in range(0, 4):  # try 4 times
    try:
        # msg.send()
        # put your logic here
        str_error = None
    except Exception as str_error:
        pass

    if str_error:
        sleep(2)  # wait for 2 seconds before trying to fetch the data again
    else:
        break
</code></pre>
<p>Here is an example with backoff:</p>
<pre><code>from time import sleep

sleep_time = 2
num_retries = 4
for x in range(0, num_retries):  
    try:
        # put your logic here
        str_error = None
    except Exception as str_error:
        pass

    if str_error:
        sleep(sleep_time)  # wait before trying to fetch the data again
        sleep_time *= 2  # Implement your backoff algorithm here i.e. exponential backoff
    else:
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools.iter_except</code></a> recipes encapsulates this idea of "calling a function repeatedly until an exception is raised".  It is similar to the accepted answer, but the recipe gives an iterator instead.</p>
<p>From the recipes:</p>
<pre><code>def iter_except(func, exception, first=None):
    """ Call a function repeatedly until an exception is raised."""
    try:
        if first is not None:
            yield first()            # For database APIs needing an initial cast to db.first()
        while True:
            yield func()
    except exception:
        pass
</code></pre>
<p>You can certainly implement the latter code directly.  For convenience, I use a separate library, <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a>, that implements this recipe for us (optional).  </p>
<p><strong>Code</strong></p>
<pre><code>import more_itertools as mit

list(mit.iter_except([0, 1, 2].pop, IndexError))
# [2, 1, 0]
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>Here the <code>pop</code> method (or given function) is called for every iteration of the list object until an <code>IndexError</code> is raised.</p>
<p>For your case, given some <code>connect_function</code> and expected error, you can make an iterator that calls the function repeatedly until an exception is raised, e.g.</p>
<pre><code>mit.iter_except(connect_function, ConnectionError)
</code></pre>
<p>At this point, treat it as any other iterator by looping over it or calling <code>next()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an utility function that I wrote to wrap the retry until success into a neater package. It uses the same basic structure, but prevents repetition. It could be modified to catch and rethrow the exception on the final try relatively easily.</p>
<pre><code>def try_until(func, max_tries, sleep_time):
    for _ in range(0,max_tries):
        try:
            return func()
        except:
            sleep(sleep_time)
    raise WellNamedException()
    #could be 'return sensibleDefaultValue'
</code></pre>
<p>Can then be called like this</p>
<pre><code>result = try_until(my_function, 100, 1000)
</code></pre>
<p>If you need to pass arguments to <code>my_function</code>, you can either do this by having <code>try_until</code> forward the arguments, or by wrapping it in a no argument lambda:</p>
<pre><code>result = try_until(lambda : my_function(x,y,z), 100, 1000)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe decorator based?
You can pass as decorator arguments list of exceptions on which we want to retry and/or number of tries.</p>
<pre><code>def retry(exceptions=None, tries=None):
    if exceptions:
        exceptions = tuple(exceptions)
    def wrapper(fun):
        def retry_calls(*args, **kwargs):
            if tries:
                for _ in xrange(tries):
                    try:
                        fun(*args, **kwargs)
                    except exceptions:
                        pass
                    else:
                        break
            else:
                while True:
                    try:
                        fun(*args, **kwargs)
                    except exceptions:
                        pass
                    else:
                        break
        return retry_calls
    return wrapper


from random import randint

@retry([NameError, ValueError])
def foo():
    if randint(0, 1):
        raise NameError('FAIL!')
    print 'Success'

@retry([ValueError], 2)
def bar():
    if randint(0, 1):
        raise ValueError('FAIL!')
    print 'Success'

@retry([ValueError], 2)
def baz():
    while True:
        raise ValueError('FAIL!')

foo()
bar()
baz()
</code></pre>
<p>of course the 'try' part should be moved to another funcion becouse we using it in both loops but it's just example;)</p>
</div>
<div class="post-text" itemprop="text">
<p>Like most of the others, I'd recommend trying a finite number of times and sleeping between attempts. This way, you don't find yourself in an infinite loop in case something were to actually happen to the remote server.</p>
<p>I'd also recommend continuing only when you get the specific exception you're expecting. This way, you can still handle exceptions you might not expect.</p>
<pre><code>from urllib.error import HTTPError
import traceback
from time import sleep


attempts = 10
while attempts &gt; 0:
    try:
        #code with possible error
    except HTTPError:
        attempts -= 1
        sleep(1)
        continue
    except:
        print(traceback.format_exc())

    #the rest of the code
    break
</code></pre>
<p>Also, you don't need an else block. Because of the continue in the except block, you skip the rest of the loop until the try block works, the while condition gets satisfied, or an exception other than HTTPError comes up.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>e = ''
while e == '':
    try:
        response = ur.urlopen('https://https://raw.githubusercontent.com/MrMe42/Joe-Bot-Home-Assistant/mac/Joe.py')
        e = ' '
    except:
        print('Connection refused. Retrying...')
        time.sleep(1)
</code></pre>
<p>This should work. It sets e to '' and the while loop checks to see if it is still ''. If there is an error caught be the try statement, it prints that the connection was refused, waits 1 second and then starts over. It will keep going until there is no error in try, which then sets e to ' ', which kills the while loop. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a short piece of code I use to capture the error as a string. Will retry till it succeeds. This catches all exceptions but you can change this as you wish.</p>
<pre><code>start = 0
str_error = "Not executed yet."
while str_error:
    try:
        # replace line below with your logic , i.e. time out, max attempts
        start = raw_input("enter a number, 0 for fail, last was {0}: ".format(start))
        new_val = 5/int(start)
        str_error=None
    except Exception as str_error:
         pass
</code></pre>
<p><strong>WARNING:</strong> This code will be stuck in a forever loop until no exception occurs.  This is just a simple example and MIGHT require you to break out of the loop sooner or sleep between retries.</p>
</div>
<span class="comment-copy">Err... what happens when the remote server dies?  Will this sit there consuming 100% of a CPU core?</span>
<span class="comment-copy">continue should be in else and break in except. Is it a typo?</span>
<span class="comment-copy">@aand: No. If an exception occurs, he wants to try again (read: <code>continue</code>), but if no exception occurs, he wants to to some things (sketched out by a comment) and get outta that weird abuse of a loop. (<code>else</code> executes if no exception occurs, is that the missing piece?)</span>
<span class="comment-copy">You might be interested in this <a href="http://area51.stackexchange.com/proposals/11464/code-review?referrer=aWNm_PdciyFqjFW8CUacGw2" title="code review">stack-exchange proposal</a>. It's almost ready to begin beta, just needs a few more.</span>
<span class="comment-copy">Word of warning: you should add some degree of protection against persistent failures, such as a sleep or a maximum attempt limit.  Otherwise, your process will consume CPU indefinitely, as @user9876 noted.</span>
<span class="comment-copy">If there is a persistent reason that the connection is not succeeding, this solution will be grinding away in an infinite loop.</span>
<span class="comment-copy">@BradKoch Of course. That is inherent to the question, and furthermore any fix (such as an overall timeout or a limited number of tries) is relatively orthogonal to the changes I describe.</span>
<span class="comment-copy">But any proposed answer should be safe, or at least note the pitfalls.  This does not offer protection against 100% CPU consumption and endangers future readers.</span>
<span class="comment-copy">Any proposed answer should be safe, or at least note the pitfalls. This does not offer protection against 100% CPU consumption and endangers future readers.</span>
<span class="comment-copy">I like this answer better than others because this one is "nice" to other processes due to the sleep function and also has limited tries.</span>
<span class="comment-copy">Bit of a late comment, but the doubling of the code could be avoided by using "for _ in itertools.repeat(None,times=tries):"  If tries is None, the loop continues forever, but if tries is a number, it terminates after that many iterations.</span>
