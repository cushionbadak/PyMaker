<div class="post-text" itemprop="text">
<p>I have 2 issues with the code below:</p>
<ol>
<li>push(o) throws an exception <em>TypeError: can only assign an iterable</em>.</li>
<li><p>Should I throw an exception if pop() is invoked on an empty stack ? </p>
<pre><code>class Stack(object):

    def __init__(self):
        self.storage = []

    def isEmpty(self):
        return len(self.storage) == 0

    def push(self,p):
        self.storage[:0] = p

    def pop(self):
        """issue: throw exception?"""
        return None
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>No need to jump through these loops, See <a href="https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks">5.1.1 Using Lists as Stacks</a> </p>
<p>If you insist on having methods <code>isEmpty()</code> and <code>push()</code> you can do:</p>
<pre><code>class stack(list):
    def push(self, item):
        self.append(item)
    def isEmpty(self):
        return not self
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are right to use composition instead of inheritance, because inheritance brings methods in that you don't want to expose.</p>
<pre><code>class Stack:
  def __init__(self):
    self.__storage = []

  def isEmpty(self):
    return len(self.__storage) == 0

  def push(self,p):
    self.__storage.append(p)

  def pop(self):
    return self.__storage.pop()
</code></pre>
<p>This way your interface works pretty much like <code>list</code> (same behavior on <code>pop</code> for example), except that you've locked it to ensure nobody messes with the internals.</p>
</div>
<div class="post-text" itemprop="text">
<p>I won't talk about the list structure as that's already been covered in this question. Instead I'll mention my preferred method for dealing with stacks:</p>
<p>I always use the <code>Queue</code> module. It supports FIFO and LIFO data structures and is thread safe.</p>
<p>See <a href="http://docs.python.org/library/queue.html" rel="noreferrer">the docs</a> for more info. It doesn't implement a <code>isEmpty()</code> function, it instead raises a <code>Full</code> or <code>Empty</code> exception if a push or pop can't be done.</p>
</div>
<div class="post-text" itemprop="text">
<p>Stack follows LIFO mechanism.You can create a list and do a normal <code>append()</code> to append the element to list and do <code>pop()</code> to retrieve the element out of the list which you just inserted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example for stack class</p>
<pre><code>class Stack(object):

   def __init__(self):
      self.items = []

   def push(self, item):
      self.items.append(item)

   def pop(self):
       return self.items.pop()

   def peek(self):
       return self.items[-1]

   def isEmpty(self):
       return len(self.items) == 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code> class Stack:
    def __init__(self):
        self.items=[]

    def isEmpty(self):
        return self.items==[]

    def push(self , item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def size(self):
        return len(self.items)

    def peek(self):
        return self.items[-1]
</code></pre>
<p><strong>Create a stack</strong></p>
<p>To create a new stack we can simply use <code>Stack()</code></p>
<p>for example:</p>
<pre><code> s=Stack()
</code></pre>
<p>"s" is the name of new stack</p>
<p><strong>isEmpty</strong></p>
<p>By using <code>isEmpty()</code> we can check our stack is empty or not</p>
<p>for example:</p>
<p>we have two stacks name s1=(0,1,4,5,6) and s2=()</p>
<p>if we use  <code>print(s1.isEmpty())</code> it will return <code>False</code></p>
<p>if we use  <code>print(s2.isEmpty())</code> it will return <code>True</code></p>
<p><strong>push</strong></p>
<p>By using push operation we can add items to top of the stack</p>
<p>we can add "6" to the stack name "s" using</p>
<pre><code>s.push(6)
</code></pre>
<p><strong>pop</strong></p>
<p>we can use pop operation to remove and return the top item of a stack</p>
<p>if there is a stack name "s" with n amount items (n&gt;0) 
we can remove it's top most item by using</p>
<pre><code>s.pop()
</code></pre>
<p><strong>size</strong></p>
<p>This operation will return how many items are in the stack</p>
<p>if there is a stack name "s"   s=(1,2,3,4,5,3)</p>
<pre><code>`print(s.size())`   
</code></pre>
<p>will return "6"</p>
<p><strong>peek</strong>
This operation returns the top item without removing it</p>
<pre><code>`print(s.peek())`
</code></pre>
<p>"we can print items of the stack using  <code>print(s.items)</code>"</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Stack:
    def __init__(self):
        self.stack = []
    def pop(self):
        if self.is_empty():
            return None
        else:
            return self.stack.pop()
    def push(self, d):
        return self.stack.append(d)
    def peek(self):
        if self.is_empty():
            return None
        else:
            return self.stack[-1]
    def size(self):
        return len(self.stack)
    def is_empty(self):
        return self.size() == 0
</code></pre>
</div>
<span class="comment-copy">One fundamental issue: all lists operations are now available, so it's more a decorated list that a stack...</span>
<span class="comment-copy">And why exactly is that an issue? If Frankie had an explicit need of preventing people from poking at the internals, he probably would have mentioned it.</span>
<span class="comment-copy">You can't ensure that nobody messes with the internals. <code>__storage</code> can be accessed by <code>_Stack__storage</code></span>
<span class="comment-copy">@Akavall: Sure. And on Linux <code>/proc/${PID}/mem</code> <a href="https://unix.stackexchange.com/questions/6301/how-do-i-read-from-proc-pid-mem-under-linux">allows you to read/write the process memory</a>. As they say: <a href="https://www.reddit.com/r/Fantasy/comments/3h29vx/a_lock_does_no_more_than_keep_an_honest_man/" rel="nofollow noreferrer">A lock does not more than keep an honest man, honest</a>.</span>
<span class="comment-copy">c'mon this is python not C++, in python every thing is accessible and exposed so why bother with the drama?</span>
<span class="comment-copy">@denizensoft: This is about protecting yourself against Murphy, not Machiavelli. If the user wishes to meddle with the internals and mess things up, they brought it upon themselves; however if they accidentally insert to the front because the API was too permissive, then it's the API designer fault. By restricting the API, errors can be detected sooner (in this case, an exception telling you the method doesn't exist).</span>
<span class="comment-copy">I'm a newbie, so it's good to hear about different ways of doing things. Thanks.</span>
<span class="comment-copy">You're welcome. I'm somewhat of a newbie to Python also.</span>
<span class="comment-copy">You could also use deques: <a href="https://docs.python.org/2/library/collections.html#deque-objects" rel="nofollow noreferrer">docs.python.org/2/library/collections.html#deque-objects</a></span>
<span class="comment-copy">Actually, isn't a stack a LIFO?  <a href="http://en.wikipedia.org/wiki/LIFO_(computing)" rel="nofollow noreferrer">en.wikipedia.org/wiki/LIFO_(computing)</a></span>
<span class="comment-copy">@dstromberg yes it is. I dont know what i was thinking. Corrected it. Thanks!</span>
<span class="comment-copy">Yes it did. thank you.</span>
<span class="comment-copy">Try adding some context to your code.</span>
<span class="comment-copy">@GrantMiller I thought It's self-explanatory. Feel free to ask if you have any questions.</span>
