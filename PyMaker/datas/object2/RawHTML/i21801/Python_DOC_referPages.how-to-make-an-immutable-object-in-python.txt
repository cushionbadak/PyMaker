<div class="post-text" itemprop="text">
<p>Although I have never needed this, it just struck me that making an immutable object in Python could be slightly tricky. You can't just override <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="noreferrer"><code>__setattr__</code></a>, because then you can't even set attributes in the <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="noreferrer"><code>__init__</code></a>. Subclassing a tuple is a trick that works:</p>
<pre><code>class Immutable(tuple):

    def __new__(cls, a, b):
        return tuple.__new__(cls, (a, b))

    @property
    def a(self):
        return self[0]

    @property
    def b(self):
        return self[1]

    def __str__(self):
        return "&lt;Immutable {0}, {1}&gt;".format(self.a, self.b)

    def __setattr__(self, *ignored):
        raise NotImplementedError

    def __delattr__(self, *ignored):
        raise NotImplementedError
</code></pre>
<p>But then you have access to the <code>a</code> and <code>b</code> variables through <code>self[0]</code> and <code>self[1]</code>, which is annoying.</p>
<p>Is this possible in Pure Python? If not, how would I do it with a C extension?</p>
<p>(Answers that work only in Python 3 are acceptable).</p>
<p><strong>Update:</strong> </p>
<p>So subclassing tuple is the way to do it in Pure Python, which works well except for the additional possibility of accessing the data by <code>[0]</code>, <code>[1]</code> etc. So, to complete this question all that is missing is howto do it "properly" in C, which I suspect would be quite simple, by just not implementing any <code>geititem</code> or <code>setattribute</code>, etc. But instead of doing it myself, I offer a bounty for that, because I'm lazy. :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another solution I just thought of:  The simplest way to get the same behaviour as your original code is</p>
<pre><code>Immutable = collections.namedtuple("Immutable", ["a", "b"])
</code></pre>
<p>It does not solve the problem that attributes can be accessed via <code>[0]</code> etc., but at least it's considerably shorter and provides the additional advantage of being compatible with <code>pickle</code> and <code>copy</code>.</p>
<p><a href="https://docs.python.org/library/collections.html#collections.namedtuple" rel="noreferrer"><code>namedtuple</code></a> creates a type similar to what I described in <a href="https://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python/4828108#4828108">this answer</a>, i.e. derived from <code>tuple</code> and using <code>__slots__</code>.  It is available in Python 2.6 or above.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to do this is using <code>__slots__</code>:</p>
<pre><code>class A(object):
    __slots__ = []
</code></pre>
<p>Instances of <code>A</code> are immutable now, since you can't set any attributes on them.</p>
<p>If you want the class instances to contain data, you can combine this with deriving from <code>tuple</code>:</p>
<pre><code>from operator import itemgetter
class Point(tuple):
    __slots__ = []
    def __new__(cls, x, y):
        return tuple.__new__(cls, (x, y))
    x = property(itemgetter(0))
    y = property(itemgetter(1))

p = Point(2, 3)
p.x
# 2
p.y
# 3
</code></pre>
<p><strong>Edit</strong>: If you want to get rid of indexing either, you can override <code>__getitem__()</code>:</p>
<pre><code>class Point(tuple):
    __slots__ = []
    def __new__(cls, x, y):
        return tuple.__new__(cls, (x, y))
    @property
    def x(self):
        return tuple.__getitem__(self, 0)
    @property
    def y(self):
        return tuple.__getitem__(self, 1)
    def __getitem__(self, item):
        raise TypeError
</code></pre>
<p>Note that you can't use <code>operator.itemgetter</code> for the properties in thise case, since this would rely on <code>Point.__getitem__()</code> instead of <code>tuple.__getitem__()</code>.  Fuerthermore this won't prevent the use of <code>tuple.__getitem__(p, 0)</code>, but I can hardly imagine how this should constitute a problem.</p>
<p>I don't think the "right" way of creating an immutable object is writing a C extension.  Python usually relies on library implementers and library users being <a href="http://mail.python.org/pipermail/tutor/2003-October/025932.html" rel="noreferrer">consenting adults</a>, and instead of really enforcing an interface, the interface should be clearly stated in the documentation.  This is why I don't consider the possibility of circumventing an overridden <code>__setattr__()</code> by calling <code>object.__setattr__()</code> a problem.  If someone does this, it's on her own risk.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>..howto do it "properly" in C..</p>
</blockquote>
<p>You could use <a href="http://docs.cython.org/index.html" rel="noreferrer">Cython</a> to create an extension type for Python:</p>
<pre><code>cdef class Immutable:
    cdef readonly object a, b
    cdef object __weakref__ # enable weak referencing support

    def __init__(self, a, b):
        self.a, self.b = a, b
</code></pre>
<p>It works both Python 2.x and 3.</p>
<h3>Tests</h3>
<pre><code># compile on-the-fly
import pyximport; pyximport.install() # $ pip install cython
from immutable import Immutable

o = Immutable(1, 2)
assert o.a == 1, str(o.a)
assert o.b == 2

try: o.a = 3
except AttributeError:
    pass
else:
    assert 0, 'attribute must be readonly'

try: o[1]
except TypeError:
    pass
else:
    assert 0, 'indexing must not be supported'

try: o.c = 1
except AttributeError:
    pass
else:
    assert 0, 'no new attributes are allowed'

o = Immutable('a', [])
assert o.a == 'a'
assert o.b == []

o.b.append(3) # attribute may contain mutable object
assert o.b == [3]

try: o.c
except AttributeError:
    pass
else:
    assert 0, 'no c attribute'

o = Immutable(b=3,a=1)
assert o.a == 1 and o.b == 3

try: del o.b
except AttributeError:
    pass
else:
    assert 0, "can't delete attribute"

d = dict(b=3, a=1)
o = Immutable(**d)
assert o.a == d['a'] and o.b == d['b']

o = Immutable(1,b=3)
assert o.a == 1 and o.b == 3

try: object.__setattr__(o, 'a', 1)
except AttributeError:
    pass
else:
    assert 0, 'attributes are readonly'

try: object.__setattr__(o, 'c', 1)
except AttributeError:
    pass
else:
    assert 0, 'no new attributes'

try: Immutable(1,c=3)
except TypeError:
    pass
else:
    assert 0, 'accept only a,b keywords'

for kwd in [dict(a=1), dict(b=2)]:
    try: Immutable(**kwd)
    except TypeError:
        pass
    else:
        assert 0, 'Immutable requires exactly 2 arguments'
</code></pre>
<p>If you don't mind indexing support then <a href="http://docs.python.org/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="noreferrer"><code>collections.namedtuple</code></a> suggested by <a href="https://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python/4828831#4828831">@Sven Marnach</a> is preferrable:</p>
<pre><code>Immutable = collections.namedtuple("Immutable", "a b")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another idea would be to completely disallow <code>__setattr__</code> and use <code>object.__setattr__</code> in the constructor:</p>
<pre><code>class Point(object):
    def __init__(self, x, y):
        object.__setattr__(self, "x", x)
        object.__setattr__(self, "y", y)
    def __setattr__(self, *args):
        raise TypeError
    def __delattr__(self, *args):
        raise TypeError
</code></pre>
<p>Of course you could use <code>object.__setattr__(p, "x", 3)</code> to modify a <code>Point</code> instance <code>p</code>, but your original implementation suffers from the same problem (try <code>tuple.__setattr__(i, "x", 42)</code> on an <code>Immutable</code> instance).</p>
<p>You can apply the same trick in your original implementation: get rid of <code>__getitem__()</code>, and use <code>tuple.__getitem__()</code> in your property functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could create a <code>@immutable</code> decorator that either overrides the <code>__setattr__</code> <em>and</em> change the <code>__slots__</code> to an empty list, then decorate the <code>__init__</code> method with it.</p>
<p>Edit: As the OP noted, changing the <code>__slots__</code> attribute only prevents the <em>creation of new attributes</em>, not the modification.</p>
<p>Edit2: Here's an implementation:</p>
<p>Edit3: Using <code>__slots__</code> breaks this code, because if stops the creation of the object's <code>__dict__</code>. I'm looking for an alternative.</p>
<p>Edit4: Well, that's it. It's a but hackish, but works as an exercise :-)</p>
<pre><code>class immutable(object):
    def __init__(self, immutable_params):
        self.immutable_params = immutable_params

    def __call__(self, new):
        params = self.immutable_params

        def __set_if_unset__(self, name, value):
            if name in self.__dict__:
                raise Exception("Attribute %s has already been set" % name)

            if not name in params:
                raise Exception("Cannot create atribute %s" % name)

            self.__dict__[name] = value;

        def __new__(cls, *args, **kws):
            cls.__setattr__ = __set_if_unset__

            return super(cls.__class__, cls).__new__(cls, *args, **kws)

        return __new__

class Point(object):
    @immutable(['x', 'y'])
    def __new__(): pass

    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(1, 2) 
p.x = 3 # Exception: Attribute x has already been set
p.z = 4 # Exception: Cannot create atribute z
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think it is entirely possible except by using either a tuple or a namedtuple. No matter what, if you override <code>__setattr__()</code> the user can always bypass it by calling <code>object.__setattr__()</code> directly. Any solution that depends on <code>__setattr__</code> is guaranteed not to work.</p>
<p>The following is about the nearest you can get without using some sort of tuple:</p>
<pre><code>class Immutable:
    __slots__ = ['a', 'b']
    def __init__(self, a, b):
        object.__setattr__(self, 'a', a)
        object.__setattr__(self, 'b', b)
    def __setattr__(self, *ignored):
        raise NotImplementedError
    __delattr__ = __setattr__
</code></pre>
<p>but it breaks if you try hard enough:</p>
<pre><code>&gt;&gt;&gt; t = Immutable(1, 2)
&gt;&gt;&gt; t.a
1
&gt;&gt;&gt; object.__setattr__(t, 'a', 2)
&gt;&gt;&gt; t.a
2
</code></pre>
<p>but Sven's use of <code>namedtuple</code> is genuinely immutable.</p>
<p><strong>Update</strong></p>
<p>Since the question has been updated to ask how to do it properly in C, here's my answer on how to do it properly in Cython:</p>
<p>First <code>immutable.pyx</code>:</p>
<pre><code>cdef class Immutable:
    cdef object _a, _b

    def __init__(self, a, b):
        self._a = a
        self._b = b

    property a:
        def __get__(self):
            return self._a

    property b:
        def __get__(self):
            return self._b

    def __repr__(self):
        return "&lt;Immutable {0}, {1}&gt;".format(self.a, self.b)
</code></pre>
<p>and a <code>setup.py</code> to compile it (using the command <code>setup.py build_ext --inplace</code>:</p>
<pre><code>from distutils.core import setup
from distutils.extension import Extension
from Cython.Distutils import build_ext

ext_modules = [Extension("immutable", ["immutable.pyx"])]

setup(
  name = 'Immutable object',
  cmdclass = {'build_ext': build_ext},
  ext_modules = ext_modules
)
</code></pre>
<p>Then to try it out:</p>
<pre><code>&gt;&gt;&gt; from immutable import Immutable
&gt;&gt;&gt; p = Immutable(2, 3)
&gt;&gt;&gt; p
&lt;Immutable 2, 3&gt;
&gt;&gt;&gt; p.a = 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: attribute 'a' of 'immutable.Immutable' objects is not writable
&gt;&gt;&gt; object.__setattr__(p, 'a', 1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: attribute 'a' of 'immutable.Immutable' objects is not writable
&gt;&gt;&gt; p.a, p.b
(2, 3)
&gt;&gt;&gt;      
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the excellent other answers I like to add a method for python 3.4 (or maybe 3.3). This answer builds upon several previouse answers to this question.</p>
<p>In python 3.4, you can use properties <em>without setters</em> to create class members that cannot be modified. (In earlier versions assigning to properties without a setter was possible.)</p>
<pre><code>class A:
    __slots__=['_A__a']
    def __init__(self, aValue):
      self.__a=aValue
    @property
    def a(self):
        return self.__a
</code></pre>
<p>You can use it like this:</p>
<pre><code>instance=A("constant")
print (instance.a)
</code></pre>
<p>which will print <code>"constant"</code></p>
<p>But calling <code>instance.a=10</code> will cause:</p>
<pre><code>AttributeError: can't set attribute
</code></pre>
<p>Explaination: properties without setters are a very recent feature of python 3.4 (and I think 3.3). If you try to assign to such a property, an Error will be raised.
Using slots I restrict the membervariables to <code>__A_a</code> (which is <code>__a</code>).</p>
<p>Problem: Assigning to <code>_A__a</code> is still possible (<code>instance._A__a=2</code>). But if you assign to a private variable, it is your own fault...</p>
<p><a href="https://stackoverflow.com/a/472017/5069869">This answer</a> among others, however, discourages the use of <code>__slots__</code>. Using other ways to prevent attribute creation might be preferrable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an <strong>elegant</strong> solution:</p>
<pre><code>class Immutable(object):
    def __setattr__(self, key, value):
        if not hasattr(self, key):
            super().__setattr__(key, value)
        else:
            raise RuntimeError("Can't modify immutable object's attribute: {}".format(key))
</code></pre>
<p>Inherit from this class, initialize your fields in the constructor, and you'e all set.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've made immutable classes by overriding <code>__setattr__</code>, and allowing the set if the caller is <code>__init__</code>:</p>
<pre><code>import inspect
class Immutable(object):
    def __setattr__(self, name, value):
        if inspect.stack()[2][3] != "__init__":
            raise Exception("Can't mutate an Immutable: self.%s = %r" % (name, value))
        object.__setattr__(self, name, value)
</code></pre>
<p>This isn't quite enough yet, since it allows anyone's <code>___init__</code> to change the object, but you get the idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are interested in objects with behavior, then namedtuple is <em>almost</em> your solution.  </p>
<p>As described at the bottom of the namedtuple <a href="https://docs.python.org/dev/library/collections.html#collections.namedtuple" rel="nofollow">documentation</a>, you can derive your own class from namedtuple; and then, you can add the behavior you want.</p>
<p>For example (code taken directly from the <a href="https://docs.python.org/dev/library/collections.html#collections.namedtuple" rel="nofollow">documentation</a>):</p>
<pre><code>class Point(namedtuple('Point', 'x y')):
    __slots__ = ()
    @property
    def hypot(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5
    def __str__(self):
        return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)

for p in Point(3, 4), Point(14, 5/7):
    print(p)
</code></pre>
<p>This will result in:</p>
<pre><code>Point: x= 3.000  y= 4.000  hypot= 5.000
Point: x=14.000  y= 0.714  hypot=14.018
</code></pre>
<p>This approach works for both Python 3 and Python 2.7 (tested on IronPython as well).<br/>
The only downside is that the inheritance tree is a bit weird; but this is not something you usually play with.</p>
</div>
<div class="post-text" itemprop="text">
<p>I needed this a little while ago and decided to make a Python package for it. The initial version is on PyPI now:</p>
<pre><code>$ pip install immutable
</code></pre>
<p>To use:</p>
<pre><code>&gt;&gt;&gt; from immutable import ImmutableFactory
&gt;&gt;&gt; MyImmutable = ImmitableFactory.create(prop1=1, prop2=2, prop3=3)
&gt;&gt;&gt; MyImmutable.prop1
1
</code></pre>
<p>Full docs here: <a href="https://github.com/theengineear/immutable" rel="nofollow">https://github.com/theengineear/immutable</a></p>
<p>Hope it helps, it wraps a namedtuple as has been discussed, but makes instantiation much simpler.</p>
</div>
<div class="post-text" itemprop="text">
<p>This way doesn't stop <code>object.__setattr__</code> from working, but I've still found it useful:</p>
<pre><code>class A(object):

    def __new__(cls, children, *args, **kwargs):
        self = super(A, cls).__new__(cls)
        self._frozen = False  # allow mutation from here to end of  __init__
        # other stuff you need to do in __new__ goes here
        return self

    def __init__(self, *args, **kwargs):
        super(A, self).__init__()
        self._frozen = True  # prevent future mutation

    def __setattr__(self, name, value):
        # need to special case setting _frozen.
        if name != '_frozen' and self._frozen:
            raise TypeError('Instances are immutable.')
        else:
            super(A, self).__setattr__(name, value)

    def __delattr__(self, name):
        if self._frozen:
            raise TypeError('Instances are immutable.')
        else:
            super(A, self).__delattr__(name)
</code></pre>
<p>you may need to override more stuff (like <code>__setitem__</code>) depending on the use case.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.7, you can use the <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>@dataclass</code> decorator</a> in your class and it will be immutable like a struct! Though, it may or may not add a <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__()</code></a> method to your class. Quote:</p>
<blockquote>
<p><strong>hash</strong>() is used by built-in hash(), and when objects are added to hashed collections such as dictionaries and sets. Having a <strong>hash</strong>() implies that instances of the class are immutable. Mutability is a complicated property that depends on the programmer’s intent, the existence and behavior of <strong>eq</strong>(), and the values of the eq and frozen flags in the dataclass() decorator.</p>
<p>By default, dataclass() will not implicitly add a <strong>hash</strong>() method unless it is safe to do so. Neither will it add or change an existing explicitly defined <strong>hash</strong>() method. Setting the class attribute <strong>hash</strong> = None has a specific meaning to Python, as described in the <strong>hash</strong>() documentation.</p>
<p>If <strong>hash</strong>() is not explicit defined, or if it is set to None, then dataclass() may add an implicit <strong>hash</strong>() method. Although not recommended, you can force dataclass() to create a <strong>hash</strong>() method with unsafe_hash=True. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.</p>
</blockquote>
<p>Here the example from the docs linked above:      </p>
<pre><code>@dataclass
class InventoryItem:
    '''Class for keeping track of an item in inventory.'''
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self) -&gt; float:
        return self.unit_price * self.quantity_on_hand
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Classes which inherit from the following <code>Immutable</code> class are immutable, as are their instances, after their <code>__init__</code> method finishes executing.  Since it's pure python, as others have pointed out, there's nothing stopping someone from using the mutating special methods from the base <code>object</code> and <code>type</code>, but this is enough to stop anyone from mutating a class/instance by accident.</p>
<p>It works by hijacking the class-creation process with a metaclass.</p>
<pre><code>"""Subclasses of class Immutable are immutable after their __init__ has run, in
the sense that all special methods with mutation semantics (in-place operators,
setattr, etc.) are forbidden.

"""  

# Enumerate the mutating special methods
mutation_methods = set()
# Arithmetic methods with in-place operations
iarithmetic = '''add sub mul div mod divmod pow neg pos abs bool invert lshift
                 rshift and xor or floordiv truediv matmul'''.split()
for op in iarithmetic:
    mutation_methods.add('__i%s__' % op)
# Operations on instance components (attributes, items, slices)
for verb in ['set', 'del']:
    for component in '''attr item slice'''.split():
        mutation_methods.add('__%s%s__' % (verb, component))
# Operations on properties
mutation_methods.update(['__set__', '__delete__'])


def checked_call(_self, name, method, *args, **kwargs):
    """Calls special method method(*args, **kw) on self if mutable."""
    self = args[0] if isinstance(_self, object) else _self
    if not getattr(self, '__mutable__', True):
        # self told us it's immutable, so raise an error
        cname= (self if isinstance(self, type) else self.__class__).__name__
        raise TypeError('%s is immutable, %s disallowed' % (cname, name))
    return method(*args, **kwargs)


def method_wrapper(_self, name):
    "Wrap a special method to check for mutability."
    method = getattr(_self, name)
    def wrapper(*args, **kwargs):
        return checked_call(_self, name, method, *args, **kwargs)
    wrapper.__name__ = name
    wrapper.__doc__ = method.__doc__
    return wrapper


def wrap_mutating_methods(_self):
    "Place the wrapper methods on mutative special methods of _self"
    for name in mutation_methods:
        if hasattr(_self, name):
            method = method_wrapper(_self, name)
            type.__setattr__(_self, name, method)


def set_mutability(self, ismutable):
    "Set __mutable__ by using the unprotected __setattr__"
    b = _MetaImmutable if isinstance(self, type) else Immutable
    super(b, self).__setattr__('__mutable__', ismutable)


class _MetaImmutable(type):

    '''The metaclass of Immutable. Wraps __init__ methods via __call__.'''

    def __init__(cls, *args, **kwargs):
        # Make class mutable for wrapping special methods
        set_mutability(cls, True)
        wrap_mutating_methods(cls)
        # Disable mutability
        set_mutability(cls, False)

    def __call__(cls, *args, **kwargs):
        '''Make an immutable instance of cls'''
        self = cls.__new__(cls)
        # Make the instance mutable for initialization
        set_mutability(self, True)
        # Execute cls's custom initialization on this instance
        self.__init__(*args, **kwargs)
        # Disable mutability
        set_mutability(self, False)
        return self

    # Given a class T(metaclass=_MetaImmutable), mutative special methods which
    # already exist on _MetaImmutable (a basic type) cannot be over-ridden
    # programmatically during _MetaImmutable's instantiation of T, because the
    # first place python looks for a method on an object is on the object's
    # __class__, and T.__class__ is _MetaImmutable. The two extant special
    # methods on a basic type are __setattr__ and __delattr__, so those have to
    # be explicitly overridden here.

    def __setattr__(cls, name, value):
        checked_call(cls, '__setattr__', type.__setattr__, cls, name, value)

    def __delattr__(cls, name, value):
        checked_call(cls, '__delattr__', type.__delattr__, cls, name, value)


class Immutable(object):

    """Inherit from this class to make an immutable object.

    __init__ methods of subclasses are executed by _MetaImmutable.__call__,
    which enables mutability for the duration.

    """

    __metaclass__ = _MetaImmutable


class T(int, Immutable):  # Checks it works with multiple inheritance, too.

    "Class for testing immutability semantics"

    def __init__(self, b):
        self.b = b

    @classmethod
    def class_mutation(cls):
        cls.a = 5

    def instance_mutation(self):
        self.c = 1

    def __iadd__(self, o):
        pass

    def not_so_special_mutation(self):
        self +=1

def immutabilityTest(f, name):
    "Call f, which should try to mutate class T or T instance."
    try:
        f()
    except TypeError, e:
        assert 'T is immutable, %s disallowed' % name in e.args
    else:
        raise RuntimeError('Immutability failed!')

immutabilityTest(T.class_mutation, '__setattr__')
immutabilityTest(T(6).instance_mutation, '__setattr__')
immutabilityTest(T(6).not_so_special_mutation, '__iadd__')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The third party <a href="https://attrs.readthedocs.io/" rel="nofollow noreferrer"><code>attr</code></a> module provides <a href="https://attrs.readthedocs.io/en/stable/examples.html#immutability" rel="nofollow noreferrer">this functionality</a>.</p>
<p>Edit: python 3.7 has adopted this idea into the stdlib with <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>@dataclass</code></a>.</p>
<pre><code>$ pip install attrs
$ python
&gt;&gt;&gt; @attr.s(frozen=True)
... class C(object):
...     x = attr.ib()
&gt;&gt;&gt; i = C(1)
&gt;&gt;&gt; i.x = 2
Traceback (most recent call last):
   ...
attr.exceptions.FrozenInstanceError: can't set attribute
</code></pre>
<p><code>attr</code> implements frozen classes by overriding <code>__setattr__</code> and has a minor performance impact at each instantiation time, according to the documentation.</p>
<p>If you're in the habit of using classes as datatypes, <code>attr</code> may be especially useful as it takes care of the boilerplate for you (but doesn't do any magic). In particular, it writes nine dunder (__X__) methods for you (unless you turn any of them off), including repr, init, hash and all the comparison functions.</p>
<p><code>attr</code> also provides a <a href="https://attrs.readthedocs.io/en/stable/examples.html#slots" rel="nofollow noreferrer">helper for <code>__slots__</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can override <strong>setattr</strong> and still use <strong>init</strong> to set the variable. You would use super class <strong>setattr</strong>. here is the code.</p>
<pre>
class Immutable:
    __slots__ = ('a','b')
    def __init__(self, a , b):
        super().__setattr__('a',a)
        super().__setattr__('b',b)

    def __str__(self):
        return "".format(self.a, self.b)

    def __setattr__(self, *ignored):
        raise NotImplementedError

    def __delattr__(self, *ignored):
        raise NotImplementedError
</pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternative approach is to create a wrapper which makes an instance immutable.</p>
<pre><code>class Immutable(object):

    def __init__(self, wrapped):
        super(Immutable, self).__init__()
        object.__setattr__(self, '_wrapped', wrapped)

    def __getattribute__(self, item):
        return object.__getattribute__(self, '_wrapped').__getattribute__(item)

    def __setattr__(self, key, value):
        raise ImmutableError('Object {0} is immutable.'.format(self._wrapped))

    __delattr__ = __setattr__

    def __iter__(self):
        return object.__getattribute__(self, '_wrapped').__iter__()

    def next(self):
        return object.__getattribute__(self, '_wrapped').next()

    def __getitem__(self, item):
        return object.__getattribute__(self, '_wrapped').__getitem__(item)

immutable_instance = Immutable(my_instance)
</code></pre>
<p>This is useful in situations where only some instances have to be immutable (like default arguments of function calls).</p>
<p>Can also be used in immutable factories like:</p>
<pre><code>@classmethod
def immutable_factory(cls, *args, **kwargs):
    return Immutable(cls.__init__(*args, **kwargs))
</code></pre>
<p>Also protects from <code>object.__setattr__</code>, but fallable to other tricks due to Python's dynamic nature.</p>
</div>
<div class="post-text" itemprop="text">
<p>I used the same idea as Alex: a meta-class and an "init marker", but in combination with over-writing __setattr__:</p>
<pre><code>&gt;&gt;&gt; from abc import ABCMeta
&gt;&gt;&gt; _INIT_MARKER = '_@_in_init_@_'
&gt;&gt;&gt; class _ImmutableMeta(ABCMeta):
... 
...     """Meta class to construct Immutable."""
... 
...     def __call__(cls, *args, **kwds):
...         obj = cls.__new__(cls, *args, **kwds)
...         object.__setattr__(obj, _INIT_MARKER, True)
...         cls.__init__(obj, *args, **kwds)
...         object.__delattr__(obj, _INIT_MARKER)
...         return obj
...
&gt;&gt;&gt; def _setattr(self, name, value):
...     if hasattr(self, _INIT_MARKER):
...         object.__setattr__(self, name, value)
...     else:
...         raise AttributeError("Instance of '%s' is immutable."
...                              % self.__class__.__name__)
...
&gt;&gt;&gt; def _delattr(self, name):
...     raise AttributeError("Instance of '%s' is immutable."
...                          % self.__class__.__name__)
...
&gt;&gt;&gt; _im_dict = {
...     '__doc__': "Mix-in class for immutable objects.",
...     '__copy__': lambda self: self,   # self is immutable, so just return it
...     '__setattr__': _setattr,
...     '__delattr__': _delattr}
...
&gt;&gt;&gt; Immutable = _ImmutableMeta('Immutable', (), _im_dict)
</code></pre>
<p>Note: I'm calling the meta-class directly to make it work both for Python 2.x and 3.x.</p>
<pre><code>&gt;&gt;&gt; class T1(Immutable):
... 
...     def __init__(self, x=1, y=2):
...         self.x = x
...         self.y = y
...
&gt;&gt;&gt; t1 = T1(y=8)
&gt;&gt;&gt; t1.x, t1.y
(1, 8)
&gt;&gt;&gt; t1.x = 7
AttributeError: Instance of 'T1' is immutable.
</code></pre>
<p>It does work also with slots ...:</p>
<pre><code>&gt;&gt;&gt; class T2(Immutable):
... 
...     __slots__ = 's1', 's2'
... 
...     def __init__(self, s1, s2):
...         self.s1 = s1
...         self.s2 = s2
...
&gt;&gt;&gt; t2 = T2('abc', 'xyz')
&gt;&gt;&gt; t2.s1, t2.s2
('abc', 'xyz')
&gt;&gt;&gt; t2.s1 += 'd'
AttributeError: Instance of 'T2' is immutable.
</code></pre>
<p>... and multiple inheritance:</p>
<pre><code>&gt;&gt;&gt; class T3(T1, T2):
... 
...     def __init__(self, x, y, s1, s2):
...         T1.__init__(self, x, y)
...         T2.__init__(self, s1, s2)
...
&gt;&gt;&gt; t3 = T3(12, 4, 'a', 'b')
&gt;&gt;&gt; t3.x, t3.y, t3.s1, t3.s2
(12, 4, 'a', 'b')
&gt;&gt;&gt; t3.y -= 3
AttributeError: Instance of 'T3' is immutable.
</code></pre>
<p>Note, however, that mutable attributes stay to be mutable:</p>
<pre><code>&gt;&gt;&gt; t3 = T3(12, [4, 7], 'a', 'b')
&gt;&gt;&gt; t3.y.append(5)
&gt;&gt;&gt; t3.y
[4, 7, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One thing that's not really included here is total immutability... not just the parent object, but all the children as well. tuples/frozensets may be immutable for instance, but the objects that it's part of may not be. Here's a small (incomplete) version that does a decent job of enforcing immutability all the way down:</p>
<pre><code># Initialize lists
a = [1,2,3]
b = [4,5,6]
c = [7,8,9]

l = [a,b]

# We can reassign in a list 
l[0] = c

# But not a tuple
t = (a,b)
#t[0] = c -&gt; Throws exception
# But elements can be modified
t[0][1] = 4
t
([1, 4, 3], [4, 5, 6])
# Fix it back
t[0][1] = 2

li = ImmutableObject(l)
li
[[1, 2, 3], [4, 5, 6]]
# Can't assign
#li[0] = c will fail
# Can reference
li[0]
[1, 2, 3]
# But immutability conferred on returned object too
#li[0][1] = 4 will throw an exception

# Full solution should wrap all the comparison e.g. decorators.
# Also, you'd usually want to add a hash function, i didn't put
# an interface for that.

class ImmutableObject(object):
    def __init__(self, inobj):
        self._inited = False
        self._inobj = inobj
        self._inited = True

    def __repr__(self):
        return self._inobj.__repr__()

    def __str__(self):
        return self._inobj.__str__()

    def __getitem__(self, key):
        return ImmutableObject(self._inobj.__getitem__(key))

    def __iter__(self):
        return self._inobj.__iter__()

    def __setitem__(self, key, value):
        raise AttributeError, 'Object is read-only'

    def __getattr__(self, key):
        x = getattr(self._inobj, key)
        if callable(x):
              return x
        else:
              return ImmutableObject(x)

    def __hash__(self):
        return self._inobj.__hash__()

    def __eq__(self, second):
        return self._inobj.__eq__(second)

    def __setattr__(self, attr, value):
        if attr not in  ['_inobj', '_inited'] and self._inited == True:
            raise AttributeError, 'Object is read-only'
        object.__setattr__(self, attr, value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just override setAttr in the final statement of init. THen you can construct but not change. Obviously you can still override by usint object.<strong>setAttr</strong> but in practice most languages have some form of reflection so immutablility is always a leaky abstraction. Immutability is more about preventing clients from accidentally violating the contract of an object. I use:</p>
<p>=============================</p>
<p>The original solution offered was incorrect, this was updated based on the comments using the solution from <a href="https://stackoverflow.com/a/16426447/137635">here</a></p>
<p>The original solution is wrong in an interesting way, so it is included at the bottom.</p>
<p>===============================</p>
<pre><code>class ImmutablePair(object):

    __initialised = False # a class level variable that should always stay false.
    def __init__(self, a, b):
        try :
            self.a = a
            self.b = b
        finally:
            self.__initialised = True #an instance level variable

    def __setattr__(self, key, value):
        if self.__initialised:
            self._raise_error()
        else :
            super(ImmutablePair, self).__setattr__(key, value)

    def _raise_error(self, *args, **kw):
        raise NotImplementedError("Attempted To Modify Immutable Object")

if __name__ == "__main__":

    immutable_object = ImmutablePair(1,2)

    print immutable_object.a
    print immutable_object.b

    try :
        immutable_object.a = 3
    except Exception as e:
        print e

    print immutable_object.a
    print immutable_object.b
</code></pre>
<p>Output :</p>
<pre><code>1
2
Attempted To Modify Immutable Object
1
2
</code></pre>
<p>======================================</p>
<p>Original Implementation:</p>
<p>It was pointed out in the comments, correctly, that this does not in fact work, as it prevents the creation of more than one object as you are overriding the class setattr method, which means a second cannot be created as self.a = will fail on the second initialisation.</p>
<pre><code>class ImmutablePair(object):

    def __init__(self, a, b):
        self.a = a
        self.b = b
        ImmutablePair.__setattr__ = self._raise_error

    def _raise_error(self, *args, **kw):
        raise NotImplementedError("Attempted To Modify Immutable Object")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The basic solution below addresses the following scenario:</p>
<ul>
<li><code>__init__()</code> can be written accessing the attributes as usual. </li>
<li>AFTER that the OBJECT is frozen for <em>attributes</em> changes only:</li>
</ul>
<p>The idea is to override <code>__setattr__</code> method and replace its implementation each time the object frozen status is changed.</p>
<p>So we need some method (<code>_freeze</code>) which stores those two implementations and switches between them when requested.</p>
<p>This mechanism may be implemented inside the user class or inherited from a special <code>Freezer</code> class as shown below:</p>
<pre><code>class Freezer:
    def _freeze(self, do_freeze=True):
        def raise_sa(*args):            
            raise AttributeError("Attributes are frozen and can not be changed!")
        super().__setattr__('_active_setattr', (super().__setattr__, raise_sa)[do_freeze])

    def __setattr__(self, key, value):        
        return self._active_setattr(key, value)

class A(Freezer):    
    def __init__(self):
        self._freeze(False)
        self.x = 10
        self._freeze()
</code></pre>
</div>
<span class="comment-copy">Doesn't your code facilitate access to the attributes via <code>.a</code> and <code>.b</code>?  That's what the properties seems to exist for after all.</span>
<span class="comment-copy">@Sven Marnach: Yes, but [0] and [1] still work, and why would they? I don't want them. :) Maybe the idea of an immutable object with attributes is nonsense? :-)</span>
<span class="comment-copy">Just another note: <a href="http://docs.python.org/library/constants.html#NotImplemented" rel="nofollow noreferrer"><code>NotImplemented</code></a> is only meant as a return value for rich comparisons.  A return value for <code>__setatt__()</code> is rather pointless anyway, since you won't usually see it at all.  Code like <code>immutable.x = 42</code> will silently do nothing.  You should raise a <code>TypeError</code> instead.</span>
<span class="comment-copy">@Sven Marnach: OK, I was surprised, because I thought you could raise NotImplemented in this situation, but that gives a weird error. So I returned it instead, and it seemed to work. TypeError made obvious sense once I saw you used it.</span>
<span class="comment-copy">@Lennart: You could raise <code>NotImplementedError</code>, but <code>TypeError</code> is what a tuple raises if you try to modify it.</span>
<span class="comment-copy">The advantage of this variant compared to hand-written analog (even on Python 2.5 (using <code>verbose</code> parameter to <code>namedtuple</code> the code is easily generated))  is the single interface/implementation of a <code>namedtuple</code> is preferrable to dozens <i>ever so slightly</i> different hand-written interfaces/implementations that do <i>almost</i> the same thing.</span>
<span class="comment-copy">OK, you get the "best answer", because it's the easiest way of doing it. Sebastian gets the bounty for giving a short Cython implementation. Cheers!</span>
<span class="comment-copy">Another characteristic of immutable objects is that when you pass them as a parameter through a function, they are copied by value, rather than another reference being made. Would <code>namedtuple</code>s be copied by value when passed through functions?</span>
<span class="comment-copy">@hlin117: Every parameter is passed as a reference to an object in Python, regardless of whether it is mutable or immutable.  For immutable objects, it would be particularly pointless to make a copy – since you can't change the object anyway, you may just as well pass a reference to the original object.</span>
<span class="comment-copy">Can you use namedtuple internally inside the class instead of instantiating the object externally? I'm very new to python but the advantage to your other answer is that I can have a class hide the details and also have the power of things like optional parameters. If I only look at this answer it seems like I need to have everything which uses my class instantiate named tuples. Thank you for both answers.</span>
<span class="comment-copy">Wouldn't it be a better idea to use a <code>tuple</code> here, <code>__slots__ = ()</code>, rather than <code>__slots__ = []</code>? (Just clarifying)</span>
<span class="comment-copy">@sukhbir: I think this does not matter at all.  Why would you prefer a tuple?</span>
<span class="comment-copy">@Sven: I agree it wouldn't matter (except the speed part, which we can ignore), but I thought of it this way: <code>__slots__</code> is not going to be changed right? It's purpose is to identify for once which attributes can be set. So doesn't a <code>tuple</code> seem a much <i>natural</i> choice in such a case?</span>
<span class="comment-copy">But  with an empty <code>__slots__</code> I can't set <i>any</i> attributes. And if I have <code>__slots__ = ('a', 'b')</code> then the a and b attributes are still mutable.</span>
<span class="comment-copy">But your solution is better than overriding <code>__setattr__</code> so it's an improvement over mine. +1 :)</span>
<span class="comment-copy">@Lennart: Instances of <code>namedtuple</code> (or more precisely of the type returned by the function <code>namedtuple()</code>) are immutable.  Definitely.</span>
<span class="comment-copy">@Lennart Regebro: <code>namedtuple</code> passes all the tests (except indexing support). What requirement did I miss?</span>
<span class="comment-copy">Yes, you are right, I made a namedtuple type, instantiated it, and then did the test on the type instead of the instance. Heh. :-)</span>
<span class="comment-copy">I would not care about someone deliberately modifying the object using superclass' <code>__setattr__</code>, because the point is not to be foolproof. The point is to make it clear that it should not be modified and to prevent modification by mistake.</span>
<span class="comment-copy">Making a (class?) decorator or metaclass out of the solution is indeed a good idea, but the question is what the solution is. :)</span>
<span class="comment-copy"><code>object.__setattr__()</code> breaks it <a href="http://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python/4829374#4829374" title="how to make an immutable object in python">stackoverflow.com/questions/4828080/…</a></span>
<span class="comment-copy">Indeed. I just carried on as an exercise on decorators.</span>
<span class="comment-copy">Thanks for the Cython code, Cython is awesome. J.F. Sebastians implementation with the readonly is neater and arrived first though, so he gets the bounty.</span>
<span class="comment-copy"><code>property</code> is available on Python 2 too (look at the code in the question itself). It does not create an immutable object, try <a href="http://stackoverflow.com/a/4854045/4279">the tests from my answer</a> e.g., <code>instance.b = 1</code> creates a new <code>b</code> attribute.</span>
<span class="comment-copy">Right, the question is really how to prevent doing <code>A().b = "foo"</code> ie not allowing setting new attributes.</span>
<span class="comment-copy">Propertis without a setter raise an error in python 3.4 if you try to assigne to that property. In earlier versions the setter was generated implicitely.</span>
<span class="comment-copy">@Lennart: My solution is an answer to a subset of use-cases for immutable objects and an addition to previous answers. One reason I might want an immutable object is so that I can make it hashable, for which case my solution might works. But you are correct, this is not an immutable object.</span>
<span class="comment-copy">@j-f-sebastian: Changed my answer to use slots for preventing attribute creation. What is new in my answer compared to other answers, is that I use python3.4's properties to avoid changing existent attributes. While the same is achieved in previose answers, my code is shorther because of the change in the behaviour of properties.</span>
<span class="comment-copy">but with this logic it possible to assign new attributes to the object</span>
<span class="comment-copy"><code>object.__setattr__()</code> breaks it <a href="http://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python/4829374#4829374" title="how to make an immutable object in python">stackoverflow.com/questions/4828080/…</a></span>
<span class="comment-copy">Using stack inspection to ensure the caller is <code>__init__</code> is not very satisfying.</span>
<span class="comment-copy">Python 3.6+ supports this directly, using <code>class Point(typing.NamedTuple):</code></span>
<span class="comment-copy">I came up with something similar before I saw this, but used <code>getattr</code> so I could provide a default value for <code>frozen</code>. That simplified things a bit. <a href="http://stackoverflow.com/a/22545808/5987">stackoverflow.com/a/22545808/5987</a></span>
<span class="comment-copy">I like this approach the best, but you don't need the <code>__new__</code> override. Inside <code>__setattr__</code> just replace the conditional with <code>if name != '_frozen' and getattr(self, "_frozen", False)</code></span>
<span class="comment-copy">Also, there is no need to freeze the class upon construction. You can freeze it at any point if you provide a <code>freeze()</code> function. The object will then be "freeze once". Finally, worrying about <code>object.__setattr__</code> is silly, because "we're all adults here".</span>
<span class="comment-copy">you need to use <code>frozen</code>, i.e. <code>@dataclass(frozen=True)</code>, but it basically blocks use of <code>__setattr__</code> and <code>__delattr__</code> like in most of the other answers here . It just does it in a way that is compatible with the other options of dataclasses.</span>
<span class="comment-copy">That won't work: you're overriding the method <i>on the class</i>, so you'll get NotImplementedError as soon as you try to create a second instance.</span>
<span class="comment-copy">If you want to pursue this approach, note that it's difficult to override special methods at runtime: see <a href="https://stackoverflow.com/a/16426447/137635">stackoverflow.com/a/16426447/137635</a> for a couple workarounds to this.</span>
