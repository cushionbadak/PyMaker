<div class="post-text" itemprop="text">
<p>I have been Googling to try and find an equivalent in Python to some of Perl's file test operators. </p>
<p>Most of the file test operators are just a direct Pythonification of the underlying os' <code>stat</code> call. For example, <code>os.stat('file').st_ctime</code> just reads the inode change time as the *nix <code>stat</code> utility or <code>ls -l</code> would do.</p>
<p>Some of the Perl file test operators I cannot find an equivalent in Python. For example, I have a data tree of 85,000 image files created by a variety of applications. Some of the files have the <a href="http://unixpapa.com/incnote/setuid.html" rel="noreferrer">effective UID</a> set in a way that is nettlesome and a modification fails for a permission issue. So for those files I need to run something like:</p>
<pre><code>$ find . -type f -print0 | perl -0 -lnE 'say unless -w' | change euid...
</code></pre>
<p>Since I have not found the equivalent in Python, I have to shell out to Perl to find these files. I found <a href="http://blog.endpoint.com/2009/08/file-test-comparison-table-for-shell.html" rel="noreferrer">this table</a> which suggests there is no direct equivalent. True?</p>
</div>
<div class="post-text" itemprop="text">
<p>Looking at the output of <code>strace</code>, perl does a <code>stat()</code> call followed by <code>getgroups()</code> to get the supplementary group IDs of the perl process.  So it seems it just checks the results of the <code>stat()</code> call against the EUID, EGID and supplementary group IDs.</p>
<p>Python has a <code>getgroups()</code> function in <code>os</code>, so I'm sure you could do the same.</p>
<p>EDIT: You could try something like this if nobody comes up with a better answer.  (Hardly tested):</p>
<pre><code>def effectively_readable(path):
    import os, stat

    uid = os.getuid()
    euid = os.geteuid()
    gid = os.getgid()
    egid = os.getegid()

    # This is probably true most of the time, so just let os.access()
    # handle it.  Avoids potential bugs in the rest of this function.
    if uid == euid and gid == egid:
        return os.access(path, os.R_OK)

    st = os.stat(path)

    # This may be wrong depending on the semantics of your OS.
    # i.e. if the file is -------r--, does the owner have access or not?
    if st.st_uid == euid:
        return st.st_mode &amp; stat.S_IRUSR != 0

    # See comment for UID check above.
    groups = os.getgroups()
    if st.st_gid == egid or st.st_gid in groups:
        return st.st_mode &amp; stat.S_IRGRP != 0

    return st.st_mode &amp; stat.S_IROTH != 0
</code></pre>
<p>Obviously the -w one would be almost identical, but with W_OK, S_IWUSR, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>Starting with Python 3.3 you can do this with <a href="http://docs.python.org/3/library/os.html#os.access" rel="nofollow"><code>os.access</code></a>: </p>
<blockquote>
<p>Changed in version 3.3: Added the dir_fd, effective_ids, and
  follow_symlinks parameters.</p>
<p>If effective_ids is True, access() will perform its access checks
  using the effective uid/gid instead of the real uid/gid. effective_ids
  may not be supported on your platform; you can check whether or not it
  is available using os.supports_effective_ids. If it is unavailable,
  using it will raise a NotImplementedError.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>To check if your effective user can write to a file, most would simply open it and try, and catch the error in an exception. May not be the correct solution in all cases, but goes some way to explaining why there is no specific support for this.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/release/2.6.6/library/os.html#os.access" rel="nofollow"><code>os.access</code></a> does exactly what you want.</p>
<blockquote>
<p>Use the real uid/gid to test for access to <em>path</em>. Note that most operations will use the effective uid/gid, therefore this routine can be used in a suid/sgid environment to test if the invoking user has the specified access to <em>path</em>.</p>
</blockquote>
</div>
<span class="comment-copy">Doesn't <a href="http://docs.python.org/library/os.html#os.access" rel="nofollow noreferrer"><code>os.access</code></a> do the job? As far as I understand the Perl operators, they just check whether the effective user can read/write the file, right?</span>
<span class="comment-copy">@AndiDog: From your link: "Use the real uid/gid to test for access to path." It goes on to explain how this is different from testing for access with the process' effective UID and why it can be useful to skip the effective UID.</span>
<span class="comment-copy">@AndiDog: No, they do not as far as I can tell. os.access only accesses the real UID, not the effective UID. I cannot control the UID of who creates the files. It is a shared pool. I would prefer to not have to run as super user. I just want to see if the process running Python can access a group of files not owned by the process... Easy in Perl, not so easy (yet) that I have discovered in Python.</span>
<span class="comment-copy">You say "Some of the files have the effective UID set in a way that is nettlesome", but that doesn't make sense.  The EUID is a property of a running process, not of a file.  What does your "change euid..." operation actually entail?</span>
<span class="comment-copy">@Wodin: I stated that backwards I guess. It is more that EUID of the Python process is nettlesome given the UID of the owners of the files, the permissions of the directories where they drop files, and the RUID and permissions of the resulting files and directories. Does that make more sense? It is an anon photo drop directory on a LAN with the only access credentials the WiFi password. The "change euid" has not been written. It is just a list that then the admin runs <code>chown</code> on which requires superuser password.</span>
<span class="comment-copy">Note to Windows users: the <code>os</code> module provides everthing except the <code>getuid</code> etal functions, so you might want to add a <code>if hasattr(os, 'getuid'): return os.access(path, os.R_OK)</code> for portability.</span>
<span class="comment-copy">You think that is the only solution? I can see it fits in EAFP mode, but you really have to try and open thousands of files?</span>
<span class="comment-copy">No, it's not the only solution. There is never only one solution.</span>
<span class="comment-copy">Perl's -r, -w, and -x test using the process' effective IDs.  Python's os.access tests using the process' real IDs.  How are these the same?  Are you confusing -r, -w, and -x with -R, -W, and -X?  (The latter use real IDs, just like os.access.)</span>
<span class="comment-copy">os.access only return the real UID. The equivalent in Perl is -R -W and -X. I am looking for the access to the effective UID. This means that the file is readable, writeable, exactable by the user your process is NOW, now the user that owns the file. Two different things...</span>
<span class="comment-copy">Yes, I must be wrong.</span>
