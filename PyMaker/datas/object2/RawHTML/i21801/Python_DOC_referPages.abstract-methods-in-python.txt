<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/13646245/is-it-possible-to-make-abstract-classes-in-python">Is it possible to make abstract classes in Python?</a>
<span class="question-originals-answer-count">
                    10 answers
                </span>
</li>
</ul>
</div>
<p>I am having trouble in using inheritance with Python. While the concept seems too easy for me in Java yet up till now I have been unable to understand in Python which is surprising to me at least.</p>
<p>I have a prototype which follow:</p>
<pre><code>class Shape():
   def __init__(self, shape_name):
       self.shape = shape_name

class Rectangle(Shape):
   def __init__(self, name):
       self.shape = name
</code></pre>
<p>In the above code how can I make an abstract method that would need to be implemented for all the subclasses?</p>
</div>
<div class="post-text" itemprop="text">
<p>Something along these lines, using ABC</p>
<pre><code>import abc

class Shape(object):
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def method_to_implement(self, input):
        """Method documentation"""
        return
</code></pre>
<p>Also read this good tutorial: <a href="http://www.doughellmann.com/PyMOTW/abc/">http://www.doughellmann.com/PyMOTW/abc/</a></p>
<p>You can also check out <strong>zope.interface</strong> which was used prior to introduction of ABC in python.  </p>
<ul>
<li><a href="http://pypi.python.org/pypi/zope.interface">http://pypi.python.org/pypi/zope.interface</a></li>
<li><a href="http://wiki.zope.org/Interfaces/FrontPage">http://wiki.zope.org/Interfaces/FrontPage</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Before abc was introduced you would see this frequently.</p>
<pre><code>class Base(object):
    def go(self):
        raise NotImplementedError("Please Implement this method")


class Specialized(Base):
    def go(self):
        print "Consider me implemented"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See the <a href="http://docs.python.org/library/abc.html" rel="noreferrer">abc module</a>. Basically, you define <code>__metaclass__ = abc.ABCMeta</code> on the class, then decorate each abstract method with <code>@abc.abstractmethod</code>. Classes derived from this class cannot then be instantiated unless all abstract methods have been overridden.</p>
<p>If your class is already using a metaclass, derive it from <code>ABCMeta</code> rather than <code>type</code> and you can continue to use your own metaclass.</p>
<p>A cheap alternative (and the best practice before the <code>abc</code> module was introduced) would be to have all your abstract methods just raise an exception (<code>NotImplementedError</code> is a good one) so that classes derived from it would have to override that method to be useful. </p>
<p>However, the <code>abc</code> solution is better because it keeps such classes from being instantiated at all (i.e., it "fails faster"), and also because you can provide a default or base implementation of each method that can be reached using the <code>super()</code> function in derived classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't, with language primitives. As has been called out, the <a href="http://docs.python.org/library/abc.html" rel="noreferrer">abc package</a> provides this functionality in Python 2.6 and later, but there are no options for Python 2.5 and earlier. The <code>abc</code> package is not a new feature of Python; instead, it adds functionality by adding explicit "does this class say it does this?" checks, with manually-implemented consistency checks to cause an error during initialization if such declarations are made falsely.</p>
<p>Python is a militantly dynamically-typed language. It does not specify language primitives to allow you to prevent a program from compiling because an object does not match type requirements; this can only be discovered at run time. If you require that a subclass implement a method, document that, and then just call the method in the blind hope that it will be there.</p>
<p>If it's there, fantastic, it simply works; this is called <a href="http://en.wikipedia.org/wiki/Duck_typing" rel="noreferrer">duck typing</a>, and your object has quacked enough like a duck to satisfy the interface. This works just fine <em>even if <code>self</code> is the object you're calling such a method on</em>, for the purposes of mandatory overrides due to base methods that need specific implementations of features (generic functions), because <code>self</code> is a convention, not anything actually special.</p>
<p>The exception is in <code>__init__</code>, because when your initializer is being called, the derived type's initializer hasn't, so it hasn't had the opportunity to staple its own methods onto the object yet.</p>
<p>If the method was't implemented, you'll get an AttributeError (if it's not there at all) or a TypeError (if something by that name is there but it's not a function or it didn't have that signature). It's up to you how you handle that- either call it programmer error and let it crash the program (and it "should" be obvious to a python developer what causes that kind of error there- an unmet duck interface), or catch and handle those exceptions when you discover that your object didn't support what you wish it did. Catching AttributeError and TypeError is important in a lot of situations, actually.</p>
</div>
<div class="post-text" itemprop="text">
<p>Abstract base classes are deep magic.  Periodically I implement something using them and am amazed at my own cleverness, very shortly afterwards I find myself completely confused by my own cleverness (this may well just be a personal limitation though).</p>
<p>Another way of doing this (should be in the python std libs if you ask me) is to make a decorator.</p>
<pre><code>def abstractmethod(method):
    """
    An @abstractmethod member fn decorator.
    (put this in some library somewhere for reuse).

    """
    def default_abstract_method(*args, **kwargs):
        raise NotImplementedError('call to abstract method ' 
                                  + repr(method))
    default_abstract_method.__name__ = method.__name__    
    return default_abstract_method


class Shape(object):

    def __init__(self, shape_name):
       self.shape = shape_name

    @abstractmethod
    def foo(self):
        print "bar"
        return

class Rectangle(Shape):
    # note you don't need to do the constructor twice either
    pass  

r = Rectangle("x")
r.foo()
</code></pre>
<p>I didn't write the decorator.  It just occurred to me someone would have.  You can find it here: <a href="http://code.activestate.com/recipes/577666-abstract-method-decorator/" rel="noreferrer">http://code.activestate.com/recipes/577666-abstract-method-decorator/</a>  Good one jimmy2times.  Note the discussion at the bottom of that page r.e. type safety of the decorator.  (That could be fixed with the inspect module if anyone was so inclined). </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use six and abc to construct a class for both python2 and python3 efficiently as follows: </p>
<pre><code>import six
import abc

@six.add_metaclass(abc.ABCMeta)
class MyClass(object):
    """
    documentation
    """

    @abc.abstractmethod
    def initialize(self, para=None):
        """
        documentation
        """
        raise NotImplementedError
</code></pre>
<p><a href="https://pymotw.com/3/abc/" rel="nofollow noreferrer">This</a> is an awesomoe document of it. </p>
</div>
<div class="post-text" itemprop="text">
<p>You have to implement an abstract base class (ABC).</p>
<p><a href="http://docs.python.org/library/abc.html" rel="nofollow">Check python docs</a></p>
</div>
<span class="comment-copy">Btw this really was an afterthought in python. abstract interfaces and such were just recently introduced. Since python isn't compiled, you should make your intent clear in documentation instead of abstract classes.</span>
<span class="comment-copy">Does adding this effects the other things as well ?? ie will other part of my class code need to be changed ??</span>
<span class="comment-copy">@user506710: Remember that it is only introduced now. Earlier, Python used "duck typing".</span>
<span class="comment-copy">@user506710: The only other part of your code that might need to be changed is if you are already using a metaclass. In this case, just have your metaclass derive from <code>abc.ABCMeta</code> instead of from <code>type</code> and you should be OK. If you don't know what a metaclass is, don't worry about it. :-)</span>
<span class="comment-copy">The linked tutorial is <b>much</b> clearer than the Python abc doc (<a href="http://docs.python.org/2/library/abc.html" rel="nofollow noreferrer">docs.python.org/2/library/abc.html</a>); yet they say the <i>same thing</i>.</span>
<span class="comment-copy">This syntax doesn't work in python 3, see this question/answer: <a href="http://stackoverflow.com/a/18513858/1240268">stackoverflow.com/a/18513858/1240268</a>.</span>
<span class="comment-copy">this is more pythonic than the accepted answer in my opinion, since it follows the python adage "we're all adults here" - if a subclass doesn't implement this type of abstract method, it will have to deal with the consequences</span>
<span class="comment-copy">@EmmettJ.Butler But abc should be implemented after all. Am I right?</span>
<span class="comment-copy">@Spiderman nope, abc is not for simple base classes, abc is when you need isinstance checks, similar to isinstance(x, number) or isinstance(x, collections.abc.Sequence).</span>
<span class="comment-copy">@EmmettJ.Butler But it doesn't provide any immediate feedback. It provides the feedback only after the method was used, which makes this mechanism completely useless as an abstract class.</span>
<span class="comment-copy"><code>you can provide a default or base implementation of each method that can be reached using the super() function in derived classes</code> you can't use <code>super()</code> without <code>abc</code>?</span>
<span class="comment-copy">What it's saying is that you must use <code>super()</code> to reach method implementations in an ABC, not that you need to use <code>abc</code> in order to use <code>super()</code>. <code>super()</code> works with any new-style class.</span>
<span class="comment-copy">I was only confused because it was "abc is better for motivation 1 and motivation 2" but motivation 2 is not <code>abc</code> specific :)</span>
<span class="comment-copy">What about the abc module mentioned in the other answer then ??</span>
<span class="comment-copy">For what it's worth, Python <i>is</i> strongly typed, it's just dynamically typed.</span>
<span class="comment-copy">Ack. This is the first time I'd heard of the <code>abc</code> module. I'm leaving this answer, though, because it applies to versions of Python before 2.6 (CentOS ships with 2.4), and duck typing still works here.</span>
<span class="comment-copy">Yeah, it's a good point about the duck typing. Generally, programming in Python, you will generally be happier just calling the methods you expect rather than enforcing real type constraints. The <code>abc</code> is a nice option to specify <i>what kind</i> of duck you want, though.</span>
<span class="comment-copy">python certainly is strongly typed.  he is referring to static vs. dynamic typing.</span>
<span class="comment-copy">How does this differ from <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">abc.abstractmethod</a>?</span>
<span class="comment-copy">Not a great deal.  Under the hood they're not too different I imagine.  Pragmatically: "Using the abc.abstractmethod decorator requires that the class’s metaclass is ABCMeta or is derived from it.".</span>
