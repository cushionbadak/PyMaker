<div class="post-text" itemprop="text">
<p>What I want to do is print the integers 0 through 5 in the code below but all I get is an address of the iterator?</p>
<pre><code>def main():

    l = []
    for i in range(0,5):
        l.append(i)

    it = iter(l)

    for i in range(0,5):
        print it
        it.next()

if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To access the values returned by an iterator, you use the <a href="http://docs.python.org/library/functions.html#next" rel="noreferrer">next()</a> method of the iterator like so:</p>
<pre><code>try:
    while True:
        val = it.next()
        print(val)
except StopIteration:
    print("Iteration done.")
</code></pre>
<p>next() has both the purpose of advancing the iterator and returning the next element. StopIteration is thrown when iteration is done.</p>
<p>Since this is quite cumbersome, all of this is wrapped nicely up in the for-syntax:</p>
<pre><code>for i in it:
    print(i)
print("Iteration done.")
</code></pre>
<p>More links:</p>
<ul>
<li><a href="http://docs.python.org/glossary.html#term-iterator" rel="noreferrer">Python documentation on iterator.</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>When you have an iterator, you have to iterate over it, not over a range.</p>
<pre><code>for i in it:
    print(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you are using the for loop, you are actually calling the iterator object's <code>__next__</code> method implicitly. So, you would just not use something like range, but instead just use iterator itself.</p>
<pre><code>for i in it:
    print i
</code></pre>
<p>For what it is worth, <code>xrange</code> in Python 2 and <code>range</code> in Python 3 returns an iterator, so you just write your first loop with those to have your desired solution,</p>
</div>
<span class="comment-copy">Just so you know, calling <code>next()</code> returns the next value in the iterator.  So the loop body should read <code>print it.next()</code>.</span>
<span class="comment-copy">Quick way to produce your iterator: it = iter(range(5))</span>
<span class="comment-copy">On the first code block, is it possible to not include the try statement?</span>
<span class="comment-copy">Yes, but then the exception will be thrown further up.</span>
<span class="comment-copy">looks like in version 3 (or so) you need to change next to <b>next</b></span>
<span class="comment-copy">@kdubs I believe the Pythonic way is to <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next(it)</code></a> rather than <code>it.__next__()</code>. By the way, <code>__</code> means <b>bold</b> in <a href="http://stackoverflow.com/editing-help#italics-bold">Markdown</a>.</span>
<span class="comment-copy">yeah, just noticed that. and thanks for the update.</span>
<span class="comment-copy">Is there a way to dereference an iterator like in C++ using *it?</span>
<span class="comment-copy">No, Python doesn't use pointers at all. And why would you want to? Dereferencing is used to get a value, and Python already hands you that value. Try not to think in C++ terms at all when working with Python.</span>
<span class="comment-copy">Python <code>it.next()</code> is roughly equivalent to C++ <code>*it++</code>. You don't get to separate the operations.</span>
