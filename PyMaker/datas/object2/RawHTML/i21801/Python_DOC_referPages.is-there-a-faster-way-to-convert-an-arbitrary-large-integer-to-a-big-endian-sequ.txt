<div class="post-text" itemprop="text">
<p>I have this Python code to do this:</p>
<pre><code>from struct import pack as _pack

def packl(lnum, pad = 1):
    if lnum &lt; 0:
        raise RangeError("Cannot use packl to convert a negative integer "
                         "to a string.")
    count = 0
    l = []
    while lnum &gt; 0:
        l.append(lnum &amp; 0xffffffffffffffffL)
        count += 1
        lnum &gt;&gt;= 64
    if count &lt;= 0:
        return '\0' * pad
    elif pad &gt;= 8:
        lens = 8 * count % pad
        pad = ((lens != 0) and (pad - lens)) or 0
        l.append('&gt;' + 'x' * pad + 'Q' * count)
        l.reverse()
        return _pack(*l)
    else:
        l.append('&gt;' + 'Q' * count)
        l.reverse()
        s = _pack(*l).lstrip('\0')
        lens = len(s)
        if (lens % pad) != 0:
            return '\0' * (pad - lens % pad) + s
        else:
            return s
</code></pre>
<p>This takes approximately 174 usec to convert <code>2**9700 - 1</code> to a string of bytes on my machine.  If I'm willing to use the Python 2.7 and Python 3.x specific <code>bit_length</code> method, I can shorten that to 159 usecs by pre-allocating the <code>l</code> array to be the exact right size at the very beginning and using <code>l[something] =</code> syntax instead of <code>l.append</code>.</p>
<p>Is there anything I can do that will make this faster?  This will be used to convert large prime numbers used in cryptography as well as some (but not many) smaller numbers.</p>
<p><strong>Edit</strong></p>
<p>This is currently the fastest option in Python &lt; 3.2, it takes about half the time either direction as the accepted answer:</p>
<pre><code>def packl(lnum, padmultiple=1):
    """Packs the lnum (which must be convertable to a long) into a
       byte string 0 padded to a multiple of padmultiple bytes in size. 0
       means no padding whatsoever, so that packing 0 result in an empty
       string.  The resulting byte string is the big-endian two's
       complement representation of the passed in long."""

    if lnum == 0:
        return b'\0' * padmultiple
    elif lnum &lt; 0:
        raise ValueError("Can only convert non-negative numbers.")
    s = hex(lnum)[2:]
    s = s.rstrip('L')
    if len(s) &amp; 1:
        s = '0' + s
    s = binascii.unhexlify(s)
    if (padmultiple != 1) and (padmultiple != 0):
        filled_so_far = len(s) % padmultiple
        if filled_so_far != 0:
            s = b'\0' * (padmultiple - filled_so_far) + s
    return s

def unpackl(bytestr):
    """Treats a byte string as a sequence of base 256 digits
    representing an unsigned integer in big-endian format and converts
    that representation into a Python integer."""

    return int(binascii.hexlify(bytestr), 16) if len(bytestr) &gt; 0 else 0
</code></pre>
<p>In Python 3.2 the <code>int</code> class has <code>to_bytes</code> and <code>from_bytes</code> functions that can accomplish this <strong>much</strong> more quickly that the method given above.</p>
</div>
<div class="post-text" itemprop="text">
<p>For completeness and for future readers of this question:</p>
<p>Starting in Python 3.2, there are functions <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow"><code>int.from_bytes()</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#int.to_bytes" rel="nofollow"><code>int.to_bytes()</code></a> that perform the conversion between <code>bytes</code> and <code>int</code> objects in a choice of byte orders.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution calling the Python/C API via <code>ctypes</code>.  Currently, it uses NumPy, but if NumPy is not an option, it could be done purely with <code>ctypes</code>.</p>
<pre><code>import numpy
import ctypes
PyLong_AsByteArray = ctypes.pythonapi._PyLong_AsByteArray
PyLong_AsByteArray.argtypes = [ctypes.py_object,
                               numpy.ctypeslib.ndpointer(numpy.uint8),
                               ctypes.c_size_t,
                               ctypes.c_int,
                               ctypes.c_int]

def packl_ctypes_numpy(lnum):
    a = numpy.zeros(lnum.bit_length()//8 + 1, dtype=numpy.uint8)
    PyLong_AsByteArray(lnum, a, a.size, 0, 1)
    return a
</code></pre>
<p>On my machine, this is 15 times faster than your  approach.</p>
<p><strong>Edit:</strong> Here is the same code using <code>ctypes</code> only and returning a string instead of a NumPy array:</p>
<pre><code>import ctypes
PyLong_AsByteArray = ctypes.pythonapi._PyLong_AsByteArray
PyLong_AsByteArray.argtypes = [ctypes.py_object,
                               ctypes.c_char_p,
                               ctypes.c_size_t,
                               ctypes.c_int,
                               ctypes.c_int]

def packl_ctypes(lnum):
    a = ctypes.create_string_buffer(lnum.bit_length()//8 + 1)
    PyLong_AsByteArray(lnum, a, len(a), 0, 1)
    return a.raw
</code></pre>
<p>This is another two times faster, totalling to a speed-up factor of 30 on my machine.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose you really should just be using numpy, which I'm sure has something or other built in for this. It might also be faster to hack around with the <code>array</code> module. But I'll take a stab at it anyway.</p>
<p>IMX, creating a generator and using a list comprehension and/or built-in summation is faster than a loop that appends to a list, because the appending can be done internally. Oh, and 'lstrip' on a large string has got to be costly.</p>
<p>Also, some style points: special cases aren't special enough; and you appear not to have gotten the memo about the new <code>x if y else z</code> construct. :) Although we don't need it anyway. ;)</p>
<pre><code>from struct import pack as _pack


Q_size = 64
Q_bitmask = (1L &lt;&lt; Q_size) - 1L


def quads_gen(a_long):
    while a_long:
        yield a_long &amp; Q_bitmask
        a_long &gt;&gt;= Q_size


def pack_long_big_endian(a_long, pad = 1):
    if lnum &lt; 0:
        raise RangeError("Cannot use packl to convert a negative integer "
                         "to a string.")
    qs = list(reversed(quads_gen(a_long)))
    # Pack the first one separately so we can lstrip nicely.
    first = _pack('&gt;Q', qs[0]).lstrip('\x00')
    rest = _pack('&gt;%sQ' % len(qs) - 1, *qs[1:])
    count = len(first) + len(rest)
    # A little math trick that depends on Python's behaviour of modulus
    # for negative numbers - but it's well-defined and documented
    return '\x00' * (-count % pad) + first + rest
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just wanted to post a follow-up to Sven's answer (which works great). The <em>opposite</em> operation - going from arbitrarily long bytes object to Python Integer object requires the following (because there is no PyLong_FromByteArray() C API function that I can find):</p>
<pre><code>import binascii

def unpack_bytes(stringbytes):
    #binascii.hexlify will be obsolete in python3 soon
    #They will add a .tohex() method to bytes class
    #Issue 3532 bugs.python.org
    return int(binascii.hexlify(stringbytes), 16)
</code></pre>
</div>
<span class="comment-copy">What does <code>pad</code> do? A docstring would be handy to understand the usage.</span>
<span class="comment-copy">@Scott As far as I can tell, the output is zero-padded at the front to the next multiple-of-pad number of bytes.</span>
<span class="comment-copy">Reagrdelss of eing a localy used variable, you shoul avoid using a variable name sucha s "l" - it looks too much like "1" on most fonts to keep readability.</span>
<span class="comment-copy">@Karl Knechtel - That's precisely right.  I wanted to use this in situations where I wanted to dump it into a slot that was exactly 64 bits long, or 128 bits long or something like that.</span>
<span class="comment-copy">@Scott Griffiths - You're right, it does need a docstring.  <i>embarrassed look</i></span>
<span class="comment-copy">Thanks! I'm wondering though if the endian flags will slow it down or not. We'll see.</span>
<span class="comment-copy">Even with the endian flag, it still takes 1/3rd the time (or less) of the fastest method I'd found so far.</span>
<span class="comment-copy">Won't that use the system native endianness though?</span>
<span class="comment-copy">@Karl: No, it won't.  The fourth parameter to <code>PyLong_AsByteArray()</code> indicates which endianness to use: <code>0</code> means big endian, anything else means little endian.</span>
<span class="comment-copy">Awesome. Now I wish this were exposed directly... :/</span>
<span class="comment-copy">Has this API changed much over different versions of Python?</span>
<span class="comment-copy"><code>int(binascii.hexlify(stringbytes), 16)</code> is faster than <code>ctypes.pythonapi._PyLong_FromByteArray</code>. Whoulda thunk it?</span>
<span class="comment-copy">Have you tested this against the original code?</span>
<span class="comment-copy">I shouldn't have voted you up.  Your code has numerous errors.</span>
<span class="comment-copy">There is in fact a <code>_PyLong_FromByteArray</code> function (at least in Python 2.7 and Python 3). I'm using it. But your method would probably be pretty fast too.</span>
<span class="comment-copy">This is, in fact, faster than calling _PyLong_FromByteArray using ctypes. How bizarre. Even better, I don't have to check if the input is a <code>memoryview</code> because hexlify handles those, and I don't have to convert to an <code>int</code> in Python 2.7 in order to make the value into a straight <code>int</code> if it's small enough to not need to be a <code>long</code>.</span>
<span class="comment-copy">Also, using <code>hex(lnum)' and </code>binascii.unhexlify` (with a little extra glue) is also faster than the ctypes option.</span>
<span class="comment-copy">Weird. I looked through the Python 3.1.x C API reference and couldn't find PyLong_FromByteArray().</span>
