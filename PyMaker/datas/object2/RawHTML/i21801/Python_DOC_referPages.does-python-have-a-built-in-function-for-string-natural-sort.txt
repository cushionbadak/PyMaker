<div class="post-text" itemprop="text">
<p>Using Python 3.x, I have a list of strings for which I would like to perform a natural alphabetical sort. </p>
<p><strong>Natural sort:</strong> The order by which files in Windows are sorted.</p>
<p>For instance, the following list is naturally sorted (what I want):</p>
<pre><code>['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
<p>And here's the "sorted" version of the above list (what I have):</p>
<pre><code>['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
</code></pre>
<p>I'm looking for a sort function which behaves like the first one.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a third party library for this on PyPI called <a href="https://github.com/SethMMorton/natsort" rel="noreferrer">natsort</a> (full disclosure, I am the package's author).  For your case, you can do either of the following:</p>
<pre><code>&gt;&gt;&gt; from natsort import natsorted, ns
&gt;&gt;&gt; x = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
&gt;&gt;&gt; natsorted(x, key=lambda y: y.lower())
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
&gt;&gt;&gt; natsorted(x, alg=ns.IGNORECASE)  # or alg=ns.IC
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
<p>You should note that <code>natsort</code> uses a general algorithm so it should work for just about any input that you throw at it. If you want more details on why you might choose a library to do this rather than rolling your own function, check out the <code>natsort</code> documentation's <a href="http://natsort.readthedocs.io/en/master/howitworks.html" rel="noreferrer">How It Works</a> page, in particular the <a href="http://natsort.readthedocs.io/en/master/howitworks.html#special-cases-everywhere" rel="noreferrer">Special Cases Everywhere!</a> section.</p>
<hr/>
<p>If you need a sorting key instead of a sorting function, use either of the below formulas.</p>
<pre><code>&gt;&gt;&gt; from natsort import natsort_keygen, ns
&gt;&gt;&gt; l1 = ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
&gt;&gt;&gt; l2 = l1[:]
&gt;&gt;&gt; natsort_key1 = natsort_keygen(key=lambda y: y.lower())
&gt;&gt;&gt; l1.sort(key=natsort_key1)
&gt;&gt;&gt; l1
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
&gt;&gt;&gt; natsort_key2 = natsort_keygen(alg=ns.IGNORECASE)
&gt;&gt;&gt; l2.sort(key=natsort_key2)
&gt;&gt;&gt; l2
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>import re

def natural_sort(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ] 
    return sorted(l, key = alphanum_key)
</code></pre>
<p>Output:</p>
<pre><code>['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
<p>See it working online: <a href="http://ideone.com/W0HUe">ideone</a>.</p>
<p>Code adapted from here: <a href="http://www.codinghorror.com/blog/2007/12/sorting-for-humans-natural-sort-order.html">Sorting for Humans : Natural Sort Order</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a much more pythonic version of Mark Byer's answer:</p>
<pre><code>import re

def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in _nsre.split(s)]    
</code></pre>
<p>Now this function can be used as a key in any function that uses it, like <code>list.sort</code>, <code>sorted</code>, <code>max</code>, etc.</p>
<p>As a lambda:</p>
<pre><code>lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split('(\d+)', s)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wrote a function based on <a href="http://www.codinghorror.com/blog/2007/12/sorting-for-humans-natural-sort-order.html">http://www.codinghorror.com/blog/2007/12/sorting-for-humans-natural-sort-order.html</a> which adds the ability to still pass in your own 'key' parameter. I need this in order to perform a natural sort of lists that contain more complex objects (not just strings).</p>
<pre><code>import re

def natural_sort(list, key=lambda s:s):
    """
    Sort the list into natural alphanumeric order.
    """
    def get_alphanum_key_func(key):
        convert = lambda text: int(text) if text.isdigit() else text 
        return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))]
    sort_key = get_alphanum_key_func(key)
    list.sort(key=sort_key)
</code></pre>
<p>For example:</p>
<pre><code>my_list = [{'name':'b'}, {'name':'10'}, {'name':'a'}, {'name':'1'}, {'name':'9'}]
natural_sort(my_list, key=lambda x: x['name'])
print my_list
[{'name': '1'}, {'name': '9'}, {'name': '10'}, {'name': 'a'}, {'name': 'b'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>data = ['elm13', 'elm9', 'elm0', 'elm1', 'Elm11', 'Elm2', 'elm10']
</code></pre>
<p>Let's analyse the data. The digit capacity of all elements is 2. And there are 3 letters in common literal part <code>'elm'</code>. </p>
<p>So, the maximal length of element is 5. We can increase this value to make sure (for example, to 8).</p>
<p><strong>Bearing that in mind, we've got a one-line solution:</strong></p>
<pre><code>data.sort(key=lambda x: '{0:0&gt;8}'.format(x).lower())
</code></pre>
<p><strong>without regular expressions and external libraries!</strong></p>
<pre><code>print(data)

&gt;&gt;&gt; ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'elm13']
</code></pre>
<p>Explanation:</p>
<pre><code>for elm in data:
    print('{0:0&gt;8}'.format(elm).lower())

&gt;&gt;&gt;
0000elm0
0000elm1
0000elm2
0000elm9
000elm10
000elm11
000elm13
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given:</p>
<pre><code>data=['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
</code></pre>
<p>Similar to SergO's solution, a <strong>1-liner without external libraries would be</strong>:</p>
<pre><code>data.sort(key=lambda x : int(x[3:]))
</code></pre>
<p>or </p>
<pre><code>sorted_data=sorted(data, key=lambda x : int(x[3:]))
</code></pre>
<p>Explanation:</p>
<p>This solution uses the <em>key</em> feature of <em>sort</em> to define a function that will be employed for the sorting. Because we know that every data entry is preceded by 'elm' the sorting function converts to integer the portion of the string after the 3rd character (i.e. int(x[3:])). If the numerical part of the data is in a different location, then this part of the function would have to change.</p>
<p>Cheers</p>
</div>
<div class="post-text" itemprop="text">
<strong>And now for something more* elegant (pythonic)</strong> <em>-just a touch</em>
<p>There are many implementations out there, and while some have come close, none quite captured the elegance modern python affords.</p>
<ul>
<li>Tested using python(3.5.1)</li>
<li>Included an additional list to demonstrate that it works when the
numbers are mid string</li>
<li>Didn't test, however, I am assuming that if your list was sizable it would be more efficient to compile the regex beforehand

<ul>
<li><em>I'm sure someone will correct me if this is an erroneous assumption</em></li>
</ul></li>
</ul>
<p></p>
<strong>Quicky</strong>
<pre class="lang-python prettyprint-override"><code>from re import compile, split    
dre = compile(r'(\d+)')
mylist.sort(key=lambda l: [int(s) if s.isdigit() else s.lower() for s in split(dre, l)])
</code></pre>
<strong>Full-Code</strong>
<pre class="lang-python prettyprint-override"><code>#!/usr/bin/python3
# coding=utf-8
"""
Natural-Sort Test
"""

from re import compile, split

dre = compile(r'(\d+)')
mylist = ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13', 'elm']
mylist2 = ['e0lm', 'e1lm', 'E2lm', 'e9lm', 'e10lm', 'E12lm', 'e13lm', 'elm', 'e01lm']

mylist.sort(key=lambda l: [int(s) if s.isdigit() else s.lower() for s in split(dre, l)])
mylist2.sort(key=lambda l: [int(s) if s.isdigit() else s.lower() for s in split(dre, l)])

print(mylist)  
  # ['elm', 'elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
print(mylist2)  
  # ['e0lm', 'e1lm', 'e01lm', 'E2lm', 'e9lm', 'e10lm', 'E12lm', 'e13lm', 'elm']
</code></pre>
<p><strong>Caution</strong> when using</p>
<ul>
<li><code>from os.path import split</code>
<ul>
<li>you will need to differentiate the imports</li>
</ul></li>
</ul>
<p><strong>Inspiration</strong> from</p>
<ul>
<li><a href="https://docs.python.org/3.5/howto/sorting.html" rel="noreferrer">Python Documentation- Sorting HOW TO</a></li>
<li><a href="https://blog.codinghorror.com/sorting-for-humans-natural-sort-order/" rel="noreferrer">Sorting for Humans : Natural Sort Order</a></li>
<li><a href="http://nedbatchelder.com/blog/200712.html#e20071211T054956" rel="noreferrer">Human Sorting</a></li>
<li>Contributors/Commentators to this and referenced posts </li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>One option is to turn the string into a tuple and replace digits using expanded form <a href="http://wiki.answers.com/Q/What_does_expanded_form_mean" rel="nofollow">http://wiki.answers.com/Q/What_does_expanded_form_mean</a></p>
<p>that way a90 would become ("a",90,0) and a1 would become ("a",1)</p>
<p>below is some sample code (which isn't very efficient due to the way It removes leading 0's from numbers)</p>
<pre><code>alist=["something1",
    "something12",
    "something17",
    "something2",
    "something25and_then_33",
    "something25and_then_34",
    "something29",
    "beta1.1",
    "beta2.3.0",
    "beta2.33.1",
    "a001",
    "a2",
    "z002",
    "z1"]

def key(k):
    nums=set(list("0123456789"))
        chars=set(list(k))
    chars=chars-nums
    for i in range(len(k)):
        for c in chars:
            k=k.replace(c+"0",c)
    l=list(k)
    base=10
    j=0
    for i in range(len(l)-1,-1,-1):
        try:
            l[i]=int(l[i])*base**j
            j+=1
        except:
            j=0
    l=tuple(l)
    print l
    return l

print sorted(alist,key=key)
</code></pre>
<p>output:</p>
<pre><code>('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 1)
('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 10, 2)
('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 10, 7)
('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 2)
('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 20, 5, 'a', 'n', 'd', '_', 't', 'h', 'e', 'n', '_', 30, 3)
('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 20, 5, 'a', 'n', 'd', '_', 't', 'h', 'e', 'n', '_', 30, 4)
('s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g', 20, 9)
('b', 'e', 't', 'a', 1, '.', 1)
('b', 'e', 't', 'a', 2, '.', 3, '.')
('b', 'e', 't', 'a', 2, '.', 30, 3, '.', 1)
('a', 1)
('a', 2)
('z', 2)
('z', 1)
['a001', 'a2', 'beta1.1', 'beta2.3.0', 'beta2.33.1', 'something1', 'something2', 'something12', 'something17', 'something25and_then_33', 'something25and_then_34', 'something29', 'z1', 'z002']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Value Of This Post</h1>
<p>My point is to offer a non regex solution that can be applied generally.<br/>
I'll create three functions:</p>
<ol>
<li><code>find_first_digit</code> which I borrowed from <a href="https://stackoverflow.com/a/4510805/2336654">@AnuragUniyal</a>.  It will find the position of the first digit or non-digit in a string.</li>
<li><code>split_digits</code> which is a generator that picks apart a string into digit and non digit chunks.  It will also <code>yield</code> integers when it is a digit.</li>
<li><code>natural_key</code> just wraps <code>split_digits</code> into a <code>tuple</code>.  This is what we use as a key for <code>sorted</code>, <code>max</code>, <code>min</code>.</li>
</ol>
<h1>Functions</h1>
<pre><code>def find_first_digit(s, non=False):
    for i, x in enumerate(s):
        if x.isdigit() ^ non:
            return i
    return -1

def split_digits(s, case=False):
    non = True
    while s:
        i = find_first_digit(s, non)
        if i == 0:
            non = not non
        elif i == -1:
            yield int(s) if s.isdigit() else s if case else s.lower()
            s = ''
        else:
            x, s = s[:i], s[i:]
            yield int(x) if x.isdigit() else x if case else x.lower()

def natural_key(s, *args, **kwargs):
    return tuple(split_digits(s, *args, **kwargs))
</code></pre>
<p>We can see that it is general in that we can have multiple digit chunks:</p>
<pre><code># Note that the key has lower case letters
natural_key('asl;dkfDFKJ:sdlkfjdf809lkasdjfa_543_hh')

('asl;dkfdfkj:sdlkfjdf', 809, 'lkasdjfa_', 543, '_hh')
</code></pre>
<p>Or leave as case sensitive:</p>
<pre><code>natural_key('asl;dkfDFKJ:sdlkfjdf809lkasdjfa_543_hh', True)

('asl;dkfDFKJ:sdlkfjdf', 809, 'lkasdjfa_', 543, '_hh')
</code></pre>
<hr/>
<p>We can see that it sorts the OP's list in the appropriate order</p>
<pre><code>sorted(
    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13'],
    key=natural_key
)

['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
<p>But it can handle more complicated lists as well:</p>
<pre><code>sorted(
    ['f_1', 'e_1', 'a_2', 'g_0', 'd_0_12:2', 'd_0_1_:2'],
    key=natural_key
)

['a_2', 'd_0_1_:2', 'd_0_12:2', 'e_1', 'f_1', 'g_0']
</code></pre>
<hr/>
<p>My regex equivalent would be</p>
<pre><code>def int_maybe(x):
    return int(x) if str(x).isdigit() else x

def split_digits_re(s, case=False):
    parts = re.findall('\d+|\D+', s)
    if not case:
        return map(int_maybe, (x.lower() for x in parts))
    else:
        return map(int_maybe, parts)

def natural_key_re(s, *args, **kwargs):
    return tuple(split_digits_re(s, *args, **kwargs))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The above answers are good for the <strong>specific example</strong> that was shown, but miss several useful cases for the more general question of natural sort. I just got bit by one of those cases, so created a more thorough solution:</p>
<pre><code>def natural_sort_key(string_or_number):
    """
    by Scott S. Lawton &lt;scott@ProductArchitect.com&gt; 2014-12-11; public domain and/or CC0 license

    handles cases where simple 'int' approach fails, e.g.
        ['0.501', '0.55'] floating point with different number of significant digits
        [0.01, 0.1, 1]    already numeric so regex and other string functions won't work (and aren't required)
        ['elm1', 'Elm2']  ASCII vs. letters (not case sensitive)
    """

    def try_float(astring):
        try:
            return float(astring)
        except:
            return astring

    if isinstance(string_or_number, basestring):
        string_or_number = string_or_number.lower()

        if len(re.findall('[.]\d', string_or_number)) &lt;= 1:
            # assume a floating point value, e.g. to correctly sort ['0.501', '0.55']
            # '.' for decimal is locale-specific, e.g. correct for the Anglosphere and Asia but not continental Europe
            return [try_float(s) for s in re.split(r'([\d.]+)', string_or_number)]
        else:
            # assume distinct fields, e.g. IP address, phone number with '.', etc.
            # caveat: might want to first split by whitespace
            # TBD: for unicode, replace isdigit with isdecimal
            return [int(s) if s.isdigit() else s for s in re.split(r'(\d+)', string_or_number)]
    else:
        # consider: add code to recurse for lists/tuples and perhaps other iterables
        return string_or_number
</code></pre>
<p>Test code and several links (on and off of StackOverflow) are here:
<a href="http://productarchitect.com/code/better-natural-sort.py" rel="nofollow">http://productarchitect.com/code/better-natural-sort.py</a></p>
<p>Feedback welcome. That's not meant to be a definitive solution; just a step forward.</p>
</div>
<div class="post-text" itemprop="text">
<p>Most likely <code>functools.cmp_to_key()</code> is closely tied to the underlying implementation of python's sort. Besides, the <em>cmp</em> parameter is legacy. The modern way is to transform the input items into objects that support the desired rich comparison operations.</p>
<p>Under CPython 2.x, objects of disparate types can be ordered even if the respective rich comparison operators haven't been implemented. Under CPython 3.x, objects of different types must explicitly support the comparison. See <a href="https://stackoverflow.com/a/3270689">How does Python compare string and int?</a> which links to the <a href="https://docs.python.org/2/library/stdtypes.html#comparisons" rel="nofollow noreferrer">official documentation</a>. Most of the answers depend on this implicit ordering. Switching to Python 3.x will require a new type to implement and unify comparisons between numbers and strings.</p>
<pre><code>Python 2.7.12 (default, Sep 29 2016, 13:30:34) 
&gt;&gt;&gt; (0,"foo") &lt; ("foo",0)
True  
</code></pre>
<pre><code>Python 3.5.2 (default, Oct 14 2016, 12:54:53) 
&gt;&gt;&gt; (0,"foo") &lt; ("foo",0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  TypeError: unorderable types: int() &lt; str()
</code></pre>
<p>There are three different approaches. The first uses nested classes to take advantage of Python's <code>Iterable</code> comparison algorithm. The second unrolls this nesting into a single class. The third foregoes subclassing <code>str</code> to focus on performance. All are timed; the second is twice as fast while the third almost six times faster. Subclassing <code>str</code> isn't required, and was probably a bad idea in the first place, but it does come with certain conveniences.</p>
<p>The sort characters are duplicated to force ordering by case, and case-swapped to force lower case letter to sort first; this is the typical definition of "natural sort". I couldn't decide on the type of grouping; some might prefer the following, which also brings significant performance benefits:</p>
<pre><code>d = lambda s: s.lower()+s.swapcase()
</code></pre>
<p>Where utilized, the comparison operators are set to that of <code>object</code> so they won't <a href="https://hg.python.org/cpython/file/3.5/Lib/functools.py#l192" rel="nofollow noreferrer">be ignored by <code>functools.total_ordering</code></a>.</p>
<pre><code>import functools
import itertools


@functools.total_ordering
class NaturalStringA(str):
    def __repr__(self):
        return "{}({})".format\
            ( type(self).__name__
            , super().__repr__()
            )
    d = lambda c, s: [ c.NaturalStringPart("".join(v))
                        for k,v in
                       itertools.groupby(s, c.isdigit)
                     ]
    d = classmethod(d)
    @functools.total_ordering
    class NaturalStringPart(str):
        d = lambda s: "".join(c.lower()+c.swapcase() for c in s)
        d = staticmethod(d)
        def __lt__(self, other):
            if not isinstance(self, type(other)):
                return NotImplemented
            try:
                return int(self) &lt; int(other)
            except ValueError:
                if self.isdigit():
                    return True
                elif other.isdigit():
                    return False
                else:
                    return self.d(self) &lt; self.d(other)
        def __eq__(self, other):
            if not isinstance(self, type(other)):
                return NotImplemented
            try:
                return int(self) == int(other)
            except ValueError:
                if self.isdigit() or other.isdigit():
                    return False
                else:
                    return self.d(self) == self.d(other)
        __le__ = object.__le__
        __ne__ = object.__ne__
        __gt__ = object.__gt__
        __ge__ = object.__ge__
    def __lt__(self, other):
        return self.d(self) &lt; self.d(other)
    def __eq__(self, other):
        return self.d(self) == self.d(other)
    __le__ = object.__le__
    __ne__ = object.__ne__
    __gt__ = object.__gt__
    __ge__ = object.__ge__
</code></pre>
<pre><code>import functools
import itertools


@functools.total_ordering
class NaturalStringB(str):
    def __repr__(self):
        return "{}({})".format\
            ( type(self).__name__
            , super().__repr__()
            )
    d = lambda s: "".join(c.lower()+c.swapcase() for c in s)
    d = staticmethod(d)
    def __lt__(self, other):
        if not isinstance(self, type(other)):
            return NotImplemented
        groups = map(lambda i: itertools.groupby(i, type(self).isdigit), (self, other))
        zipped = itertools.zip_longest(*groups)
        for s,o in zipped:
            if s is None:
                return True
            if o is None:
                return False
            s_k, s_v = s[0], "".join(s[1])
            o_k, o_v = o[0], "".join(o[1])
            if s_k and o_k:
                s_v, o_v = int(s_v), int(o_v)
                if s_v == o_v:
                    continue
                return s_v &lt; o_v
            elif s_k:
                return True
            elif o_k:
                return False
            else:
                s_v, o_v = self.d(s_v), self.d(o_v)
                if s_v == o_v:
                    continue
                return s_v &lt; o_v
        return False
    def __eq__(self, other):
        if not isinstance(self, type(other)):
            return NotImplemented
        groups = map(lambda i: itertools.groupby(i, type(self).isdigit), (self, other))
        zipped = itertools.zip_longest(*groups)
        for s,o in zipped:
            if s is None or o is None:
                return False
            s_k, s_v = s[0], "".join(s[1])
            o_k, o_v = o[0], "".join(o[1])
            if s_k and o_k:
                s_v, o_v = int(s_v), int(o_v)
                if s_v == o_v:
                    continue
                return False
            elif s_k or o_k:
                return False
            else:
                s_v, o_v = self.d(s_v), self.d(o_v)
                if s_v == o_v:
                    continue
                return False
        return True
    __le__ = object.__le__
    __ne__ = object.__ne__
    __gt__ = object.__gt__
    __ge__ = object.__ge__
</code></pre>
<pre><code>import functools
import itertools
import enum


class OrderingType(enum.Enum):
    PerWordSwapCase         = lambda s: s.lower()+s.swapcase()
    PerCharacterSwapCase    = lambda s: "".join(c.lower()+c.swapcase() for c in s)


class NaturalOrdering:
    @classmethod
    def by(cls, ordering):
        def wrapper(string):
            return cls(string, ordering)
        return wrapper
    def __init__(self, string, ordering=OrderingType.PerCharacterSwapCase):
        self.string = string
        self.groups = [ (k,int("".join(v)))
                            if k else
                        (k,ordering("".join(v)))
                            for k,v in
                        itertools.groupby(string, str.isdigit)
                      ]
    def __repr__(self):
        return "{}({})".format\
            ( type(self).__name__
            , self.string
            )
    def __lesser(self, other, default):
        if not isinstance(self, type(other)):
            return NotImplemented
        for s,o in itertools.zip_longest(self.groups, other.groups):
            if s is None:
                return True
            if o is None:
                return False
            s_k, s_v = s
            o_k, o_v = o
            if s_k and o_k:
                if s_v == o_v:
                    continue
                return s_v &lt; o_v
            elif s_k:
                return True
            elif o_k:
                return False
            else:
                if s_v == o_v:
                    continue
                return s_v &lt; o_v
        return default
    def __lt__(self, other):
        return self.__lesser(other, default=False)
    def __le__(self, other):
        return self.__lesser(other, default=True)
    def __eq__(self, other):
        if not isinstance(self, type(other)):
            return NotImplemented
        for s,o in itertools.zip_longest(self.groups, other.groups):
            if s is None or o is None:
                return False
            s_k, s_v = s
            o_k, o_v = o
            if s_k and o_k:
                if s_v == o_v:
                    continue
                return False
            elif s_k or o_k:
                return False
            else:
                if s_v == o_v:
                    continue
                return False
        return True
    # functools.total_ordering doesn't create single-call wrappers if both
    # __le__ and __lt__ exist, so do it manually.
    def __gt__(self, other):
        op_result = self.__le__(other)
        if op_result is NotImplemented:
            return op_result
        return not op_result
    def __ge__(self, other):
        op_result = self.__lt__(other)
        if op_result is NotImplemented:
            return op_result
        return not op_result
    # __ne__ is the only implied ordering relationship, it automatically
    # delegates to __eq__
</code></pre>
<pre><code>&gt;&gt;&gt; import natsort
&gt;&gt;&gt; import timeit
&gt;&gt;&gt; l1 = ['Apple', 'corn', 'apPlE', 'arbour', 'Corn', 'Banana', 'apple', 'banana']
&gt;&gt;&gt; l2 = list(map(str, range(30)))
&gt;&gt;&gt; l3 = ["{} {}".format(x,y) for x in l1 for y in l2]
&gt;&gt;&gt; print(timeit.timeit('sorted(l3+["0"], key=NaturalStringA)', number=10000, globals=globals()))
362.4729259099986
&gt;&gt;&gt; print(timeit.timeit('sorted(l3+["0"], key=NaturalStringB)', number=10000, globals=globals()))
189.7340817489967
&gt;&gt;&gt; print(timeit.timeit('sorted(l3+["0"], key=NaturalOrdering.by(OrderingType.PerCharacterSwapCase))', number=10000, globals=globals()))
69.34636392899847
&gt;&gt;&gt; print(timeit.timeit('natsort.natsorted(l3+["0"], alg=natsort.ns.GROUPLETTERS | natsort.ns.LOWERCASEFIRST)', number=10000, globals=globals()))
98.2531585780016
</code></pre>
<p>Natural sorting is both pretty complicated and vaguely defined as a problem. Don't forget to run <code>unicodedata.normalize(...)</code> beforehand, and consider use <code>str.casefold()</code> rather than <code>str.lower()</code>. There are probably subtle encoding issues I haven't considered. So I tentatively recommend the <a href="https://pypi.python.org/pypi/natsort" rel="nofollow noreferrer">natsort</a> library. I took a quick glance at the github repository; the code maintenance has been stellar.</p>
<p>All the algorithms I've seen depend on tricks such as duplicating and lowering characters, and swapping case. While this doubles the running time, an alternative would require a total natural ordering on the input character set. I don't think this is part of the unicode specification, and since there are many more unicode digits than <code>[0-9]</code>, creating such a sorting would be equally daunting. If you want locale-aware comparisons, prepare your strings with <a href="https://docs.python.org/3/library/locale.html#locale.strxfrm" rel="nofollow noreferrer"><code>locale.strxfrm</code></a> per Python's <a href="https://docs.python.org/3/howto/sorting.html#odd-and-ends" rel="nofollow noreferrer">Sorting HOW TO</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the answers here, I wrote a <code>natural_sorted</code> function that behaves like the built-in function <code>sorted</code>:</p>
<pre><code># Copyright (C) 2018, Benjamin Drung &lt;bdrung@posteo.de&gt;
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import re

def natural_sorted(iterable, key=None, reverse=False):
    """Return a new naturally sorted list from the items in *iterable*.

    The returned list is in natural sort order. The string is ordered
    lexicographically (using the Unicode code point number to order individual
    characters), except that multi-digit numbers are ordered as a single
    character.

    Has two optional arguments which must be specified as keyword arguments.

    *key* specifies a function of one argument that is used to extract a
    comparison key from each list element: ``key=str.lower``.  The default value
    is ``None`` (compare the elements directly).

    *reverse* is a boolean value.  If set to ``True``, then the list elements are
    sorted as if each comparison were reversed.

    The :func:`natural_sorted` function is guaranteed to be stable. A sort is
    stable if it guarantees not to change the relative order of elements that
    compare equal --- this is helpful for sorting in multiple passes (for
    example, sort by department, then by salary grade).
    """
    prog = re.compile(r"(\d+)")

    def alphanum_key(element):
        """Split given key in list of strings and digits"""
        return [int(c) if c.isdigit() else c for c in prog.split(key(element)
                if key else element)]

    return sorted(iterable, key=alphanum_key, reverse=reverse)
</code></pre>
<p>The source code is also available in my GitHub snippets repository:
<a href="https://github.com/bdrung/snippets/blob/master/natural_sorted.py" rel="nofollow noreferrer">https://github.com/bdrung/snippets/blob/master/natural_sorted.py</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you simply use the <code>key</code> keyword argument of <code>sorted</code> to achieve your desired list<br/>
For example:</p>
<pre><code>to_order= [e2,E1,e5,E4,e3]
ordered= sorted(to_order, key= lambda x: x.lower())
    # ordered should be [E1,e2,e3,E4,e5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = ['H1', 'H100', 'H10', 'H3', 'H2', 'H6', 'H11', 'H50', 'H5', 'H99', 'H8']
b = ''
c = []

def bubble(bad_list):#bubble sort method
        length = len(bad_list) - 1
        sorted = False

        while not sorted:
                sorted = True
                for i in range(length):
                        if bad_list[i] &gt; bad_list[i+1]:
                                sorted = False
                                bad_list[i], bad_list[i+1] = bad_list[i+1], bad_list[i] #sort the integer list 
                                a[i], a[i+1] = a[i+1], a[i] #sort the main list based on the integer list index value

for a_string in a: #extract the number in the string character by character
        for letter in a_string:
                if letter.isdigit():
                        #print letter
                        b += letter
        c.append(b)
        b = ''

print 'Before sorting....'
print a
c = map(int, c) #converting string list into number list
print c
bubble(c)

print 'After sorting....'
print c
print a
</code></pre>
<p><strong>Acknowledgments</strong>:</p>
<p><a href="https://stackoverflow.com/questions/895371/bubble-sort-homework">Bubble Sort Homework</a></p>
<p><a href="https://stackoverflow.com/questions/2633942/how-to-read-a-string-one-letter-at-a-time-in-python">How to read a string one letter at a time in python</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; sorted(lst, key=lambda x: int(re.findall(r'\d+$', x)[0]))
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
</div>
<span class="comment-copy">@SilentGhost: It actually is relevant if Python is version 2 or version 3 - due to syntax changes and available libraries. Actually, even the minor version can be relevant in most questions as well.</span>
<span class="comment-copy">@jsbueno: it's relevant when it's a legacy version.</span>
<span class="comment-copy">@SilentGhost: It's not relevant in the case of your answer, but it might be relevant to other answers.</span>
<span class="comment-copy">The definition of a natural sort is not "the order Windows sorts files".</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/questions/2545532/python-analog-of-natsort-function-sort-a-list-using-a-natural-order-algorithm">Python analog of natsort function (sort a list using a "natural order" algorithm)</a></span>
<span class="comment-copy">I also think it's quite interesting that natsort also sorts correct when the number is not at the end: like it's often the case for filenames. Feel free to include the following example:  <a href="http://pastebin.com/9cwCLdEK" rel="nofollow noreferrer">pastebin.com/9cwCLdEK</a></span>
<span class="comment-copy">+1 Why the lambdas assigned to names?</span>
<span class="comment-copy">why do you use <code>return sorted(l, key)</code> instead of <code>l.sort(key)</code>? Is it for any performance gain or just to be more pythonic?</span>
<span class="comment-copy">@jperelli I think the ladder would change the original list in the caller. But most likely the caller wants another shallow copy of the list.</span>
<span class="comment-copy">Just for the record, this can't handle all inputs: the str/int splits must line up, otherwise you'll create comparisons like ["foo",0] &lt; [0,"foo"] for the input ["foo0","0foo"], which raises a TypeError.</span>
<span class="comment-copy">@user19087: In fact it does work, because <code>re.split('([0-9]+)', '0foo')</code> returns <code>['', '0', 'foo']</code>. Because of that, strings will always be on even indexes and integers on odd indexes in the array.</span>
<span class="comment-copy">You'd probably want to precompile the pattern though...</span>
<span class="comment-copy">re module compiles and caches regexes automagically, so there is no need to precompile</span>
<span class="comment-copy">@wim: it caches the last X usages, so it's technically possible to use X+5 regexes and then do a natural sort over and over, at which point this wouldn't be cached. but probably negligible in the long run</span>
<span class="comment-copy">I did not do it, but perhaps the reason was that it can't handle tuples, like a regular python sort.</span>
<span class="comment-copy">The X usages mentioned by @Claudiu seem to be <b>100</b> on Python 2.7 and <b>512</b> on Python 3.4. And also note that when the limit is reached the cache is completely cleared (so it's not only the oldest one that is thrown out).</span>
<span class="comment-copy">a simpler way to do this would be to define <code>natural_sort_key</code>, and then when sorting a list you could do chain your keys, e.g.: <code>list.sort(key=lambda el: natural_sort_key(el['name']))</code></span>
<span class="comment-copy">@SergO: Thanks. Some of the solutions here are not explained well.</span>
<span class="comment-copy">This doesn't handle dynamic/unknown length data. It also sorts differently than other solutions for data that has numbers within the data opposed to at the end. *This isn't necessarily undesirable but I think it's good to point out.</span>
<span class="comment-copy">If you need to handle dynamic length data you can use <code>width = max(data, key=len)</code> to calculate what to sub in for the <code>8</code> above and then sub it into the format string with <code>'{0:0&gt;{width}}'.format(x, width=width)</code></span>
<span class="comment-copy">And to think I forgot about <code>dre</code>.</span>
<span class="comment-copy">Unfortunately, this solution only works for Python 2.X.  For Python 3, <code>('b', 1) &lt; ('b', 'e', 't', 'a', 1, '.', 1)</code> will return <code>TypeError: unorderable types: int() &lt; str()</code></span>
<span class="comment-copy">In your test script to which you link, <code>natsorted</code> and <code>humansorted</code> fail because they were used incorrectly... you tried to pass <code>natsorted</code> as a key but its actually the sorting function itself.  You should have tried <code>natsort_keygen()</code>.</span>
<span class="comment-copy">Your implementation only solves the numbers problem. The implementation fails if the strings don't have numbers in them. Try it on ['silent','ghost'] for instance (list index out of range).</span>
<span class="comment-copy">@snaklie: your question fails to provide decent example case. You haven't explained what you're trying to do, and neither you have updated your question with this new information. You haven't posted anything you have tried, so please don't be so dismissive of my telepathy attempt.</span>
<span class="comment-copy">@SilentGhost: First, I gave you an upvote because I think your answer is useful (even though it doesn't solve my problem). Second, I cannot cover all the possible cases with examples. I think I've given a pretty clear definition to natural sort. I don't think it's a good idea to give a complex example or a long definition to such a simple concept. You're welcome to edit my question if you can think of a better  formulation to the problem.</span>
<span class="comment-copy">@SilentGhost: I'd want to deal with such strings the same way Windows deals with such file names when it sorts files by name (ignore cases, etc). It seems clear to me, but anything I say seems clear to me, so I'm not to judge whether it's clear or not.</span>
<span class="comment-copy">@snakile you have come nowhere near close defining natural search. That would be quite hard to do and would require a lot of detail. If you want the sort order used by windows explorer do you know that there is a simple api call that provides this?</span>
