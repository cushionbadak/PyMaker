<div class="post-text" itemprop="text">
<p>I want to change a couple of files at one time, <strong>iff</strong> I can write to all of them. I'm wondering if I somehow can combine the multiple open calls with the <code>with</code> statement:</p>
<pre><code>try:
  with open('a', 'w') as a and open('b', 'w') as b:
    do_something()
except IOError as e:
  print 'Operation failed: %s' % e.strerror
</code></pre>
<p>If that's not possible, what would an elegant solution to this problem look like?</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 2.7 (or 3.1 respectively) you can write</p>
<pre><code>with open('a', 'w') as a, open('b', 'w') as b:
    do_something()
</code></pre>
<p>In earlier versions of Python, you can sometimes use 
<a href="http://docs.python.org/library/contextlib.html#contextlib.nested" rel="noreferrer"><code>contextlib.nested()</code></a> to nest context managers.  This won't work as expected for opening multiples files, though -- see the linked documentation for details.</p>
<hr/>
<p>In the rare case that you want to open a variable number of files all at the same time, you can use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer"><code>contextlib.ExitStack</code></a>, starting from Python version 3.3:</p>
<pre><code>with ExitStack() as stack:
    files = [stack.enter_context(open(fname)) for fname in filenames]
    # Do something with "files"
</code></pre>
<p>Most of the time you have a variable set of files, you likely want to open them one after the other, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just replace <code>and</code> with <code>,</code> and you're done:</p>
<pre><code>try:
    with open('a', 'w') as a, open('b', 'w') as b:
        do_something()
except IOError as e:
    print 'Operation failed: %s' % e.strerror
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For opening many files at once or for long file paths, it may be useful to break things up over multiple lines.  From the <a href="http://legacy.python.org/dev/peps/pep-0008/#maximum-line-length" rel="noreferrer">Python Style Guide</a> as suggested by @Sven Marnach in comments to another answer:</p>
<pre><code>with open('/path/to/InFile.ext', 'r') as file_1, \
     open('/path/to/OutFile.ext', 'w') as file_2:
    file_2.write(file_1.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Nested with statements will do the same job, and in my opinion, are more straightforward to deal with.</p>
<p>Let's say you have inFile.txt, and want to write it into two outFile's simultaneously.</p>
<pre><code>with open("inFile.txt", 'r') as fr:
    with open("outFile1.txt", 'w') as fw1:
        with open("outFile2.txt", 'w') as fw2:
            for line in fr.readlines():
                fw1.writelines(line)
                fw2.writelines(line)
</code></pre>
<p>EDIT:</p>
<p>I don't understand the reason of the downvote. I tested my code before publishing my answer, and it works as desired: It writes to all of outFile's, just as the question asks. No duplicate writing or failing to write. So I am really curious to know why my answer is considered to be wrong, suboptimal or anything like that.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.3, you can use the class <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>ExitStack</code></a> from the <a href="https://docs.python.org/3/library/contextlib.html#module-contextlib" rel="nofollow noreferrer"><code>contextlib</code></a> module to safely<br/>
<strong>open an arbitrary number of files</strong>.</p>
<p>It can manage a <em>dynamic</em> number of context-aware objects, which means that it will prove especially useful <em>if you don't know how many files you are going to handle</em>.</p>
<p>In fact, the canonical use-case that is mentioned in the documentation is managing a dynamic number of files.</p>
<pre><code>with ExitStack() as stack:
    files = [stack.enter_context(open(fname)) for fname in filenames]
    # All opened files will automatically be closed at the end of
    # the with statement, even if attempts to open files later
    # in the list raise an exception
</code></pre>
<hr/>
<p>If you are interested in the details, here is a generic example in order to explain how <code>ExitStack</code> operates:</p>
<pre><code>from contextlib import ExitStack

class X:
    num = 1

    def __init__(self):
        self.num = X.num
        X.num += 1

    def __repr__(self):
        cls = type(self)
        return '{cls.__name__}{self.num}'.format(cls=cls, self=self)

    def __enter__(self):
        print('enter {!r}'.format(self))
        return self.num

    def __exit__(self, exc_type, exc_value, traceback):
        print('exit {!r}'.format(self))
        return True

xs = [X() for _ in range(3)]

with ExitStack() as stack:
    print(len(stack._exit_callbacks)) # number of callbacks called on exit
    nums = [stack.enter_context(x) for x in xs]
    print(len(stack._exit_callbacks))

print(len(stack._exit_callbacks))
print(nums)
</code></pre>
<p>Output:</p>
<pre><code>0
enter X1
enter X2
enter X3
3
exit X3
exit X2
exit X1
0
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With python 2.6 It will not work, we have to use below way to open multiple files:</p>
<pre><code>with open('a', 'w') as a:
    with open('b', 'w') as b:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Late answer (8 yrs), but for someone looking to <strong>join multiple files into one</strong>, the following function may be of help:</p>
<pre><code>def multi_open(_list):
    out=""
    for x in _list:
        try:
            with open(x) as f:
                out+=f.read()
        except:
            pass
            # print(f"Cannot open file {x}")
    return(out)

fl = ["C:/bdlog.txt", "C:/Jts/tws.vmoptions", "C:/not.exist"]
print(multi_open(fl))
</code></pre>
<hr/>
<pre><code>2018-10-23 19:18:11.361 PROFILE  [Stop Drivers] [1ms]
2018-10-23 19:18:11.361 PROFILE  [Parental uninit] [0ms]
...
# This file contains VM parameters for Trader Workstation.
# Each parameter should be defined in a separate line and the
...
</code></pre>
</div>
<span class="comment-copy">Unfortunately, according to the contextlib.nested docs, you shouldn't use it for file opening: "using nested() to open two files is a programming error as the first file will not be closed promptly if an exception is thrown when opening the second file."</span>
<span class="comment-copy">is there a way to use <code>with</code> to open a variable list of files?</span>
<span class="comment-copy">@monkut: Very good question (you could actually ask this as a separate question).  Short answer: Yes, there is <a href="http://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>ExitStack</code></a> as of Python 3.3.  There is no easy way of doing this in any earlier version of Python.</span>
<span class="comment-copy">Is it possible to have this syntax span multiple lines?</span>
<span class="comment-copy">@tommy.carstensen: You can use the usual <a href="https://docs.python.org/2.7/reference/lexical_analysis.html#explicit-line-joining" rel="nofollow noreferrer">line continuation mechanisms</a>.  You should probably use backslash line continuation to break at the comma, as <a href="http://legacy.python.org/dev/peps/pep-0008/#maximum-line-length" rel="nofollow noreferrer">recommended by PEP 9</a>.</span>
<span class="comment-copy">You should specify which versions of Python support this syntax.</span>
<span class="comment-copy">With this indentation I get: "flake8: continuation line over-indented for visual indent"</span>
<span class="comment-copy">@LouisM That sounds like something coming from your editor or environment, rather than base python.  If it continues to be a problem for you, I'd recommend creating a new question relating to it and giving more detail on your editor and environment.</span>
<span class="comment-copy">Yes it is definitely my editor, and it is only a warning. What I wanted to emphasize is that your indentation does not comply with PEP8. You should indent the second open() with 8 spaces instead of aligning it with the first one.</span>
<span class="comment-copy">@LouisM PEP8 is a <i>guideline</i>, not rules, and in this case I would most certainly ignore it</span>
<span class="comment-copy">Yes no problem with that, it might be useful for other people with automatic linters though :)</span>
<span class="comment-copy">i don't know what someone else downvoted you, but I UPVOTED you because this is the only example that had three files (one input, two output) which happened to be just what I needed.</span>
<span class="comment-copy">maybe you are downvoted bcoz in Python &gt; 2.6 you can write more pythonic code -  <a href="https://gist.github.com/IaroslavR/3d8692e2a11e1ef902d2d8277eb88cb8" rel="nofollow noreferrer">gist.github.com/IaroslavR/3d8692e2a11e1ef902d2d8277eb88cb8</a> (why i can't insert code fragment in the comments?!) We are in 2018 ;) so ancient versions in the past</span>
<span class="comment-copy">Maybe it was downvoted because the original question was asking for a combination rather than a nesting. That is, the nesting seems too obvious to have been the question. Just a random thought though. It's the most general answer anyways.</span>
