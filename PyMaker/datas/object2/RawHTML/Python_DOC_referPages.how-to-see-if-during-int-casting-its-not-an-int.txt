<div class="post-text" itemprop="text">
<p>I have this <code>Matrix=[['1', '2', '3'], ['4', 'a', 'n']]</code></p>
<p>Im doing this:</p>
<pre><code>Matrix=[arr.split() for arr in Matrix]
Matrix=[list(map(int, arr)) for arr in Matrix]
</code></pre>
<p>as you can see I have 'a' and 'n' there, I want to stop the process and raise a flag like con=false everytime I got a char inside the Matrix,
how do I do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>One solution is to declare a "better" casting function and call it instead of <code>int</code> in <code>map</code>:</p>
<pre class="lang-py prettyprint-override"><code>matrix = [['1', '2', '3'], ['4', 'a', 'n']]

def int_with_default(value, default="NaN"):
    try: 
        return int(value)
    except ValueError: 
        return default

matrix = [list(map(int_with_default, arr)) for arr in matrix]
</code></pre>
<p>The output matrix will be <code>[[1, 2, 3], [4, 'NaN', 'NaN']]</code>. Note that you could also use <a href="https://docs.python.org/dev/library/math.html#math.nan" rel="nofollow noreferrer"><code>math.nan</code></a> instead of this arbitrary string I used as an example. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you have only positive integers you can use the following listcomp:</p>
<pre><code>m = [['1', '2', '3'], ['4', 'a', 'n']]

[list(map(lambda x: int(x) if x.isdigit() else None, row)) for row in m]
# [[1, 2, 3], [4, None, None]]
</code></pre>
</div>
<span class="comment-copy">You can't. It's "buried" in the list comprehension. You'll need to go back to a <code>for</code> loop with a <code>try</code>/<code>except</code> and print the exceptional values.</span>
<span class="comment-copy">can I have a snippet please?</span>
<span class="comment-copy">I find it remarkably unlikely that you couldn't unpack your list comprehension here into a bog-standard <code>for</code> loop so I'm not sure what you're asking for</span>
<span class="comment-copy">No reason to add <code>numpy</code> here;  <a href="https://stackoverflow.com/a/944733/4799172">stackoverflow.com/a/944733/4799172</a></span>
<span class="comment-copy">I use numpy so often I wasn't even aware python had its own representation of <code>nan</code>. Now I'm wondering why numpy doesn't use this directly.</span>
<span class="comment-copy">Because <code>math.isnan()</code> is a CPython function and would require calling all of that code to do the check. If <code>numpy</code> keeps its  own version of nan then it doesn't require CPython</span>
<span class="comment-copy">I would like to hear more about this but I can't find anything that talks about that choice, do you have any ref? (Strangely <code>dir(math.nan) == dir(np.nan)</code> evaluate to <code>True</code>, but sadly <code>math.nan == np.nan</code> doesn't, luckily <code>math.isnan(np.nan)</code> evaluates to <code>True</code>.)</span>
<span class="comment-copy">Well, <code>np.nan == np.nan</code> is also <code>False</code>. That's <a href="https://en.wikipedia.org/wiki/NaN#Comparison_with_NaN" rel="nofollow noreferrer">by design</a> hence the need for methods to identify <code>NaN</code> rather than check for equality. Your choice would be dictated by the libraries you are using and there is <i>no need</i> to introduce <code>np.nan</code> here because the OP didn't say they were using it.</span>
