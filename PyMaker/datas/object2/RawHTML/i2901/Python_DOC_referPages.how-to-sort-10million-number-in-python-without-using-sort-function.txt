<div class="post-text" itemprop="text">
<p>Sort the list of random generated 10 Million numbers between 1 and 100, in python without using inbuilt functions, Quicksort didnt worked for me here.</p>
<p>I have used quicksort code from the mentioned link:
<a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/TheQuickSort.html" rel="nofollow noreferrer">http://interactivepython.org/runestone/static/pythonds/SortSearch/TheQuickSort.html</a></p>
<p>Error I got while implementing it :
for x in range (0, 100000):
    listOfNumbers.append(random.randint(1, 100))</p>
<p>quickSort(listOfNumbers)
print(listOfNumbers)</p>
<p>RuntimeError: maximum recursion depth exceeded</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use any sort algorithm you want, as long as you implement it right. But the problem is calling out for a <a href="https://en.wikipedia.org/wiki/Radix_sort" rel="nofollow noreferrer">radix sort</a>. In particular, the dumbest kind of radix sort, a bucket-counter.</p>
<p>You have <code>N=10,000,000</code> total values and a range of <code>M=100</code> distinct values. A bucket counter will take <code>O(N+M)</code> time, which is better than <code>O(N*log N)</code>, and <code>O(M)</code> space,<sup>1</sup> which is negligible‚Äîand. best of all, it's dead simple:</p>
<pre><code>def bucketsorted100(xs):
    buckets = [0] * 101
    for x in xs:
        buckets[x] += 1
    for x, count in enumerate(buckets):
        yield from [x] * count
</code></pre>
<p>You can obviously extend this to not be hardcoded for numbers from 1-100 (actually, I hardcoded it for numbers from 0-100, wasting 1% space, but who cares?). Or you can add support for a <code>key</code> function. Or you can make it even simpler by using a <code>Counter</code> instead of a <code>list</code>.</p>
<hr/>
<p><sub>1. Technically, it's <code>O(logN * M)</code> space, because the counts range up to <code>N</code>, which takes <code>logN</code> bits, which the values only range up to 100, which takes a constant number of bits. But practically, all of the counts fit into a single 30-bit "digit" in CPython, so the <code>logN</code> factor never comes up.</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the mighty <a href="https://en.wikipedia.org/wiki/Bogosort" rel="nofollow noreferrer">Bogosort</a>.</p>
<pre><code>import random

def is_sorted(data):
    for i in range(len(data) - 1):
        if data[i] &gt; data[i + 1]:
            return False
    return True

def bogosort(data):
    while not is_sorted(data):
        random.shuffle(data)
    return data
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe <code>numpy</code> will be faster... you can convert numbers to a <code>numpy array</code> then use <a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.sort.html" rel="nofollow noreferrer">numpy.sort</a> </p>
<p>Like this:</p>
<pre><code>import numpy as np
mylist=[15,65,3,1,10,35,11,65,23,95,20,36,85,12,37,85,46,93] # ...
sorted_mylist=np.ndarray.tolist(np.sort(np.asarray(mylist)))
print sorted_mylist
</code></pre>
<p>which give you:</p>
<pre><code>[1, 3, 10, 11, 12, 15, 20, 23, 35, 36, 37, 46, 65, 65, 85, 85, 93, 95]
</code></pre>
</div>
<span class="comment-copy">Are you sure you used quicksort correctly? Maybe start with bubble sort if you couldn't get quicksort. <a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/TheBubbleSort.html" rel="nofollow noreferrer">interactivepython.org/runestone/static/pythonds/SortSearch/‚Ä¶</a></span>
<span class="comment-copy">What do you mean quicksort didn't work for you? Your implementation didn't work?</span>
<span class="comment-copy">You can write something a lot simpler‚Äîand more efficient‚Äîthan quicksort for this problem. As a hint: if you had a list of 100 counts, could you turn that into a list of 10 million numbers in sorted order?</span>
<span class="comment-copy">Welcome to StackOverflow.  Please read and follow the posting guidelines in the help documentation, as suggested when you created this account.  <a href="http://stackoverflow.com/help/mcve">Minimal, complete, verifiable example</a> applies here.  We cannot effectively help you until you post your MCVE code and accurately describe the problem.   We should be able to paste your posted code into a text file and reproduce the problem you described.</span>
<span class="comment-copy">@Easton, I tried quicksort. It worked fine for 1000 numbers. But with 10000 numbers, it showed error : Tree limit exceeded.</span>
<span class="comment-copy">Thanks Abanert for your answer. Just adding a bit modification of it. import random listOfNumbers=[] def bucketsorted100(xs):     buckets = [0] * 101     for x in xs:         buckets[x] += 1     for x, count in enumerate(buckets):         if(count&gt;0):             yield  [x] * count for x in range (0, 1000000):     listOfNumbers.append(random.randint(1, 100))  #Calling function: tuple(bucketsorted100(listOfNumbers))  It worked for me(in less than 5 seconds)</span>
<span class="comment-copy">@Ashish With your modification, this no longer produces an iterable of the sorted values, it now produces an iterable of <i>lists</i> of values, which you have to flatten. But if that's OK for your use, that's fine.</span>
<span class="comment-copy">But this uses the ‚Äúinbuilt function‚Äù <code>random.shuffle</code>. Otherwise, of course, it would be perfect. :)</span>
<span class="comment-copy">@abarnert But <code>random.shuffle</code> <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer">is not listed as a built in function</a> so I think we're good -- Unless you consider <code>import</code> statement to be a built in function...</span>
<span class="comment-copy">@ gabriel Random.shuffle will not be considered as inbuilt function üëçüèºüëçüèºüëçüèº</span>
<span class="comment-copy">Well, the <code>import</code> statement isn't a function‚Äîit does call a bunch of functions from <code>importlib</code>, but those are implemented in Python, just like <code>shuffle</code> is, so I don't think it makes much difference.</span>
<span class="comment-copy">@Ashish It works best if you're lucky.</span>
<span class="comment-copy">Sometimes I feel numpy is the jQuery of Python.</span>
<span class="comment-copy">Since Numpy is implemented in C, it makes sense that we'd be seeing a huge improvement over our pure Python Sort</span>
<span class="comment-copy">NumPy's hybrid introsort/heapsort implemented in C still isn't going to be anywhere near as fast as a radix sort implemented in C for this problem‚Ä¶</span>
<span class="comment-copy">@Gabriel But can numpy generate freehand circles? Not very easy‚Ä¶ unless you add in <code>scipy.ndimage</code>. :)</span>
