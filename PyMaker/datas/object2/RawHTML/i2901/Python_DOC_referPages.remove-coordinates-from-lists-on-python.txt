<div class="post-text" itemprop="text">
<p>This is a follow-up question from my last question:
<a href="https://stackoverflow.com/questions/51681673/python3-numpy-np-where-error">Python3 Numpy np.where Error</a>.</p>
<p>I have 2 lists like these:</p>
<pre><code>x = [None,[1, 15, 175, 20],
    [150, 175, 18, 20],
    [150, 175, 18],
    [192, 150, 177],...]


y = [None,[12, 43, 55, 231],
    [243, 334, 44, 12],
    [656, 145, 138],
    [12, 150, 177],
    [150, 177, 188],...]
</code></pre>
<p>I want to remove the <code>x</code> values lower than 30 and <code>y</code> values that correspond to the removed <code>x</code> values. (For example, <code>(x,y) = (1,12)</code> in <code>x[1]</code> and <code>y[1]</code>)</p>
<p>In order to do that, I got the corrected <code>x</code> list:</p>
<pre><code>In : [[v2 for v2 in v1 if v2&gt;=30] for v1 in x[1:]]
Out: [[175], [150, 175], [150, 175], [192, 150, 177]]
</code></pre>
<p>I also got the coordinates of the remaining <code>x</code> values:</p>
<pre><code>In : [(i,j) for i,v1 in enumerate(x[1:]) for j,v2 in enumerate(v1) if v2&lt;30]
Out: [(0, 0), (0, 1), (0, 3), (1, 2), (1, 3), (2, 2)]
</code></pre>
<p>Now I want to use these coordinates to remove items from <code>y</code>.</p>
<p>How can I implement this?</p>
</div>
<div class="post-text" itemprop="text">
<p>To get the corrected <code>y</code> values, I would recommend bypassing the coordinates entirely as a first approach. The reason is that you may end up with empty lists along the way, which will throw off the shape of the output of you don't keep special track of them. Also, removing elements is generally much more awkward than not including them in the first place.</p>
<p>It would be much easier to make a corrected version of <code>y</code> in the same way you corrected <code>x</code>:</p>
<pre><code>y_corr = [[n for m, n in zip(row_x, row_y) if m &gt;= 30] for row_x, row_y in zip(x, y)]
</code></pre>
<p>Here we just used <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> to step along both sets of lists in the same way you did with one.</p>
<p>If you absolutely insist on using the coordinates, I would recommend just copying <code>y</code> entirely and removing the elements from the corrected copy. You have to go backwards in each row to avoid shifting the meaning of the coordinates (e.g. with <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow noreferrer"><code>reversed</code></a>). You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to do the actual iteration for each row:</p>
<pre><code>y_corr = [row.copy() for row in y]
for r, group in groupby(reversed(coord), itemgetter(0)):
    for c in map(itemgetter(1), group):
        del y_corr[r][c]
</code></pre>
<p>Instead of reversing <code>coord</code>, you can reverse each group individually, e.g. with <code>map(itemgetter(1), reversed(group))</code>.</p>
<p>A better approach might be to compute the coordinates of the retained values instead of the discarded ones. I would recommend pre-allocating the output list, to help keep track of the empty lists and preserve the shape:</p>
<pre><code>from itertools import groupby
from operator import itemgetter

coord = [(r, c) for r, row in enumerate(x) for c, n in enumerate(row) if n &gt;= 30]

y_corr = [[]] * len(x)
for r, group in groupby(coord, itemgetter(0)):
    y_corr[r] = [y[r][c] for c in map(itemgetter(1), group)]
</code></pre>
<p>If you don't care about preserving the empty rows, you can skip the loop and use a one-liner instead:</p>
<pre><code>y_corr = [[y[r][c] for c in map(itemgetter(1), group)] for r, group in groupby(coord, itemgetter(0))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_y = []
for i in range(len(y)):
    new_y.append([y[i][j] for j in range(len(y[i])) if (i,j) not in BadList])
</code></pre>
<p>where <code>BadList</code> is </p>
<pre><code>[(i,j) for i,v1 in enumerate(x[1:]) for j,v2 in enumerate(v1) if v2&lt;30]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get it using <code>zip</code> with</p>
<pre><code>In [395]: [(a, b) for z in list(zip(x, y))[1:] for a, b in list(zip(*z)) if a &gt;= 30]
Out[395]:
[(175, 55),
 (150, 243),
 (175, 334),
 (150, 656),
 (175, 145),
 (192, 12),
 (150, 150),
 (177, 177)]
</code></pre>
<p>This is the equivalent of</p>
<pre><code>In [396]: v = []

In [398]: for z in list(zip(x, y))[1:]:
     ...:     for a, b in list(zip(*z)):
     ...:         if a &gt;= 30:
     ...:             v.append((a,b))
     ...:
</code></pre>
<p>Where</p>
<pre><code>In [388]:  list(zip(x, y))[1:]
Out[388]:
[([1, 15, 175, 20], [12, 43, 55, 231]),
 ([150, 175, 18, 20], [243, 334, 44, 12]),
 ([150, 175, 18], [656, 145, 138]),
 ([192, 150, 177], [12, 150, 177])]
</code></pre>
<p>and</p>
<pre><code>In [392]: list(zip(*list(zip(x, y))[1]))
Out[392]: [(1, 12), (15, 43), (175, 55), (20, 231)]
</code></pre>
</div>
<span class="comment-copy">Do you actually need the intermediate coordinates?</span>
<span class="comment-copy">The first code worked well! I need to learn more about zip. Thank you so much for your help.</span>
<span class="comment-copy">The intuitive version is just "step along multiple things at the same time". Glad it worked out for you.</span>
<span class="comment-copy">It seems like this command eludes some elements. For example, x[2] = [12,11] y[2]=[130,195], BadList[3] = (2, 0), BadList[4]= (2, 1) and new_y.append... should remove all of the elements in y[3] but it only remove the first 130. This problems happen sometimes.  Do you have any ideas? thank you :)</span>
<span class="comment-copy">Sorry, can you explain again? I didn't understand</span>
<span class="comment-copy">It was my fault! Your code works well. I'm sorry! I appreciate it :)</span>
<span class="comment-copy">Glad I helped out!</span>
<span class="comment-copy">I want to get those lists without braking each list. With your code, I can get 1 large list but can't tell which one is from which list. Do you have another idea? Thank you for helping</span>
<span class="comment-copy">the first entry is from <code>x</code> and the second one is from <code>y</code></span>
<span class="comment-copy">@HigashiYutaka you can access like <code>for x, y in v: print('x is {0}, y is {1}'.format(x, y))</code></span>
<span class="comment-copy">Thank you so much. I made sure your code works well. I appreciate your help :) I'll study hard and try not to ask silly questions..</span>
<span class="comment-copy">no worries at all</span>
