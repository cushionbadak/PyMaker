<div class="post-text" itemprop="text">
<p>So I'm locked to a python 3.6.2 interpreter that follows my desktop application. </p>
<p>What I want is to call an async function from a synchronized method or function.</p>
<p>When calling the python function from the desktop application it has to be a normal function which can not be awaited. </p>
<p>From the desktop application I am able to send a list of urls, and what I want is to send back response from every url in an async matter.</p>
<p>here is my try I've marked the SyntaxError which I don't know how to bypass.</p>
<pre><code>import fmeobjects
import asyncio
import aiohttp
import async_timeout
logger = fmeobjects.FMELogFile()
timeout = 10

class FeatureProcessor(object):
    def __init__(self):
        pass
    def input(self, feature):
        urls_and_coords = zip(feature.getAttribute('_list{}._wms'),\
        feature.getAttribute('_list{}._xmin'),\
        feature.getAttribute('_list{}._ymin'),\
        feature.getAttribute('_list{}._xmax'),\
        feature.getAttribute('_list{}._ymax'))
        -&gt; SyntaxError: newfeature = await main(urls_and_coords)
        self.pyoutput(newfeature)

    def close(self):
       pass 

async def main(urls):
    loop = asyncio.get_event_loop()
    async with aiohttp.ClientSession(loop=loop) as session:
        feature = loop.run_until_complete(fetch_all(session, urls, loop))
        return feature

async def fetch_all(session, urls, loop):
    results = await asyncio.gather(*[loop.create_task(fetch(session, url)) for url in urls])
    return results


async def fetch(session, url):
    with async_timeout.timeout(10):
        async with session.get(url[0]) as response:
            newFeature = fmeobjects.FMEFeature()
            response_data = await response
            newFeature.setAttribute('response', response_data)
            newFeature.setAttribute('_xmin',url[1])
            newFeature.setAttribute('_xmax',url[2])
            newFeature.setAttribute('_ymin',url[3])
            newFeature.setAttribute('_ymax',url[4])
            return newFeature
</code></pre>
<p>I have tried making these changes:
    import fme
    import fmeobjects
    import asyncio
    import aiohttp
    import async_timeout
    logger = fmeobjects.FMELogFile()</p>
<pre><code>class FeatureProcessor(object):
    def __init__(self):
        pass
    def input(self, feature):
        urls_and_coords = zip(feature.getAttribute('_list{}._wms'),\
        feature.getAttribute('_list{}._xmin'),\
        feature.getAttribute('_list{}._ymin'),\
        feature.getAttribute('_list{}._xmax'),\
        feature.getAttribute('_list{}._ymax'))
        loop = asyncio.get_event_loop()
        result = loop.run_until_complete(main(loop, urls_and_coords))
        #feature.setAttribute('result',result)
        self.pyoutput(feature)

    def close(self):
       pass 

async def main(loop, urls):
    async with aiohttp.ClientSession(loop=loop) as session:
        return await fetch_all(session, urls, loop)


async def fetch_all(session, urls, loop):
    results = await asyncio.gather(*[loop.create_task(fetch(session, url)) for url in urls])
    return results


async def fetch(session, url):
    with async_timeout.timeout(10):
        async with session.get(url[0]) as response:
            #newFeature = fmeobjects.FMEFeature()
            response = await response
            #newFeature.setAttribute('response', response_data)
            #newFeature.setAttribute('_xmin',url[1])
            #newFeature.setAttribute('_xmax',url[2])
            #newFeature.setAttribute('_ymin',url[3])
            #newFeature.setAttribute('_ymax',url[4])
            return response, url[1], url[2], url[3], url[4]
</code></pre>
<p>but now I end up with this error:</p>
<pre><code>Python Exception &lt;TypeError&gt;: object ClientResponse can't be used in 'await' 
expression
Traceback (most recent call last):
  File "&lt;string&gt;", line 20, in input
  File "asyncio\base_events.py", line 467, in run_until_complete
  File "&lt;string&gt;", line 29, in main
  File "&lt;string&gt;", line 33, in fetch_all
  File "&lt;string&gt;", line 41, in fetch
TypeError: object ClientResponse can't be used in 'await' expression
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You would use an event loop to execute the asynchronous function to completion:</p>
<pre><code>newfeature = asyncio.get_event_loop().run_until_complete(main(urls_and_coords))
</code></pre>
<p>(This technique is already used inside <code>main</code>. And I'm not sure why, since <code>main</code> is <code>async</code> you could/should use <code>await fetch_all(...)</code> there.)</p>
</div>
<div class="post-text" itemprop="text">
<p>@deceze answer is probably the best you can do in Python 3.6.
But in Python 3.7, you could directly use <a href="https://docs.python.org/3/library/asyncio-task.html?highlight=asyncio%20run#asyncio.run" rel="nofollow noreferrer">asyncio.run</a> in the following way:</p>
<pre><code>newfeature = asyncio.run(main(urls))
</code></pre>
<p>It will properly create, handle, and close an <code>event_loop</code>.</p>
</div>
<span class="comment-copy">You may want to have a look at the <code>trio</code> library. It has a much more straightforward interface than the <code>asyncio</code> standard library.</span>
<span class="comment-copy">Cool, looks like it implements run similar to asyncio in python 3.7. I will have a look at this.</span>
<span class="comment-copy">But then I probably need to rewrite main, since it already has an event_loop?</span>
<span class="comment-copy">Interesting point, I'm not actually sure off the top of my head whether that would cause any issues. But as I wrote, it makes little sense to use <code>run_until_complete</code> inside an <code>async</code> function to begin with, you should simply <code>await</code> it.</span>
<span class="comment-copy">Ever ended up with a Python Exception &lt;KeyError&gt;: 'abc_separted_comma'?, weird exception it tells me: Traceback (most recent call last):   File "&lt;string&gt;", line 83, in input KeyError: 'abc_separted_comma' but my file is only 45 lines..</span>
<span class="comment-copy">Yes, but i'm stuck in 3.6.2...</span>
<span class="comment-copy">I've read it, but I think it might still be useful for other people. I'll clarify it further.</span>
