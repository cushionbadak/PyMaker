<div class="post-text" itemprop="text">
<p>I have a python 2.7x Tornado application that when run serves up a handful of RESTful api endpoints.</p>
<p>My project folder includes numerous test cases that rely on the python <code>mock</code> module such as shown below.</p>
<pre><code>from tornado.testing import AsyncHTTPTestCase
from mock import Mock, patch
import json
from my_project import my_model

class APITestCases(AsyncHTTPTestCase):

    def setUp(self):
        pass

    def tearDown(self):
        pass

    @patch('my_project.my_model.my_method')
    def test_something(
        self,
        mock_my_method
    ):

        response = self.fetch(
            path='http://localhost/my_service/my_endpoint',
            method='POST',
            headers={'Content-Type': 'application/json'},
            body=json.dumps({'hello':'world'})
        )
</code></pre>
<p>The RESTful endpoint <code>http://localhost/my_service/my_endpoint</code> has two internal calls to <code>my_method</code> respectively: <code>my_method(my_arg=1)</code> and <code>my_method(my_arg=2)</code>.</p>
<p>I want to mock out <code>my_method</code> in this test-case such that it returns <code>0</code> if it is called with <code>my_arg</code>==2, but otherwise it should return what it would always normally return. How can I do it?</p>
<p>I know that I should do something like this:</p>
<pre><code>mock_my_method.return_value = SOMETHING
</code></pre>
<p>But I don't know how to properly specify that something so that its behavior is conditional on the arguments that my_method is called with. Can someone show me or point me to an example??</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I want to mock out <code>my_method</code> in this test-case such that it returns 0 if it is called with <code>my_arg==2</code>, but otherwise it should return what it would always normally return. How can I do it?</p>
</blockquote>
<p>Write your own method mock calling the original one on condition:</p>
<pre><code>from my_project import my_model

my_method_orig = my_project.my_model.my_method
def my_method_mocked(self, *args, my_arg=1, **kwargs):
    if my_arg == 2:  # fake call
        return 0
    # otherwise, dispatch to real method
    return my_method_orig(self, *args, **kwargs, my_arg=my_arg)
</code></pre>
<p>For patching: if you don't need to assert how often the mocked method was called and with what args etc, it is sufficient to pass the mock via <code>new</code> argument:</p>
<pre><code>@patch('my_project.my_model.my_method', new=my_method_mocked)
def test_something(
    self,
    mock_my_method
):

    response = self.fetch(...)
    # this will not work here:
    mock_my_method.assert_called_with(2)
</code></pre>
<p>If you want to invoke the whole mock assertion machinery, use <code>side_effect</code> as suggested in the other answer. Example:</p>
<pre><code>@patch('my_project.my_model.my_method', side_effect=my_method_mocked, autospec=True)
def test_something(
    self,
    mock_my_method
):

    response = self.fetch(...)
    # mock is assertable here 
    mock_my_method.assert_called_with(2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you could use <code>side_effect</code> to change return value dynamically:</p>
<pre><code>class C:
    def foo(self):
        pass  

def drive():
    o = C()
    print(o.foo(my_arg=1))
    print(o.foo(my_arg=2))  

def mocked_foo(*args, **kwargs):
    if kwargs.get('my_arg') == 2:
        return 0
    else:
        return 1

@patch('__main__.C.foo')
def test(mock):
    mock.side_effect = mocked_foo
    drive()
</code></pre>
<hr/>
<p>update: as you want to run original <code>my_method</code> code under some condition, you may need a method proxy, <code>Mock</code> can't get back the real function object being patched.</p>
<pre><code>from unittest.mock import patch

class MyClass:

    def my_method(self, my_arg):
        return 10000

def func_wrapper(func):
    def wrapped(*args, **kwargs):
        my_arg = kwargs.get('my_arg')
        if my_arg == 2:
            return 0
        return func(*args, **kwargs)
    return wrapped

def drive(o, my_arg):
    print('my_arg', my_arg, 'ret', o.my_method(my_arg=my_arg))

def test():
    with patch.object(MyClass, 'my_method', new=func_wrapper(MyClass.my_method)):
        o = MyClass()
        drive(o, 1)
        drive(o, 2)
</code></pre>
<p>will outputs:</p>
<pre><code>my_arg 1 ret 10000
my_arg 2 ret 0
</code></pre>
</div>
<span class="comment-copy">Apologies, but I don't understand the last two lines. Could you please clarify? Are you saying that based on your expectations if you pass <code>foo</code> to <code>my_method</code> then you want to return one thing as opposed to the other? If so, then this is actually set up in each test method. So you have one test method for the scenario you pass foo and set the <code>return_value</code> of that, and then another for the other condition(s).</span>
<span class="comment-copy">Clarification: <code>my_method()</code> is called twice, with different arguments from within the single RESTful endpoint <code>my_endpoint</code>. Changing the test case will not change the internal workings of <code>my_endpoint</code>.</span>
<span class="comment-copy">If it is called twice and you need it to return different values on subsequent calls, it sounds like <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer">side_effect</a> might be useful to you. Have you looked in to that? With <code>side_effect</code> every time the method is called, it returns the subsequent item you set in the list of items =&gt; <code>mock_my_method.side_effect = ['first_return', 'second_return']</code></span>
<span class="comment-copy">OK, let me correct something I said in my previous comment. <code>my_method()</code> is not called twice. <code>my_method()</code> is called an unknown number of times within <code>my_endpoint</code>. But I want to replace it's return value if and only if my_arg==2.</span>
<span class="comment-copy">What counts as "the whole mock assertion machinery"? In both examples you have shown, you invoked <code>assert_called_with()</code> so why does one require the <code>side_effect</code> and one doesn't??</span>
<span class="comment-copy">By the "mock assertion machinery" meant the bundle of <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.assert_called" rel="nofollow noreferrer"><code>Mock.assert_*</code></a> methods available in the stdlib. You can check whether the mocked method was called, how often it was called, with what parameters etc.</span>
<span class="comment-copy">Yes, I invoked <code>assert_called_with()</code> in both examples, however in the first example the call will not work - I indicated that with <code># this will not work here:</code> comment. Just keep that in mind: when you want to use <code>Mock.assert_called_*</code> checks in test, use <code>side_effect</code>. If you don't use them, <code>new</code> will already do the trick.</span>
<span class="comment-copy">@SaqibAli why this answer got accepted, I dont understand how this could "return what it would always normally return"?</span>
<span class="comment-copy">@DanielJ.Anderson because it calls the original method?</span>
