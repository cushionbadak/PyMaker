<div class="post-text" itemprop="text">
<p>This has been a source of confusion and frustration for years now. Say you import a particularly poorly documented module and some method that you need to you only has **kwargs for its arguments, how are you supposed to know what keys that method is checking for?</p>
<pre><code>def test(**kwargs):
    if 'greeting' in kwargs:
        print(kwargs['greeting'])
</code></pre>
<p>If i were to call text, how would i know that 'greeting is something the method was looking for?</p>
<pre><code>test(greeting='hi)
</code></pre>
<p>Some simplistic cases the IDE can help out with, but most use cases seem to be out of the IDE's scope</p>
</div>
<div class="post-text" itemprop="text">
<p>Think of <code>kwargs</code> as a dictionary. There is no way to tell from the outside what key-value combinations the method will accept (in your case the <code>test</code> method is essentially a black box) but this is the point of having documentation. Without kwargs, some function headers would get extremely cluttered.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use documentation!</p>
<p>The <a href="http://docs.python.org/library/subprocess.html" rel="nofollow noreferrer"><code>subprocess</code>-module's docs</a> is a good example. If you are using a newer version of python (3.7 or 3.6 with backport), consider using <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>dataclasses</code></a> as an alternative to <code>kwargs</code>, if it fits your usecase. </p>
</div>
<div class="post-text" itemprop="text">
<p>If it's not documented, your only recourse is to read the source.</p>
</div>
<div class="post-text" itemprop="text">
<p>Adding a <code>**kwargs</code> argument to a function is used when you don't want to explicitly define the arguments which must be named.</p>
<p>A trivial example:</p>
<p>If a function takes as an argument another function which is undetermined and may have different <code>kwargs</code> each time</p>
<p><code>def foo(func,**kwargs):
    print(func)
    return func(**kwargs)
</code></p>
<p>You won't know what the function is explicitly looking for.</p>
<p>You can have in your example</p>
<p><code>def foo(greeting=None):</code></p>
<p>which shows the function is looking for <code>greeting</code> but it can be <code>None</code></p>
</div>
<span class="comment-copy">So it is up to the author to document the modules, and if they don't we are more or lessed forced to read the code for the method?</span>
<span class="comment-copy">Yep, in my opinion this is why <code>kwargs</code> should be avoided in most cases, but makes sense for highly customizable functions in large libraries, i.e. <code>matplotlib</code></span>
<span class="comment-copy">Do you think it might be acceptable to write to the author and request documentation for a method that needlessly uses kwargs? Also, is there some kind of convention specifying a number of keyword arguments before using kwargs?</span>
<span class="comment-copy">It doesn't hurt to ask, and it's fairly common to see something like <code>def func(key1, key2, **kwargs)</code> where the first two keys are required but the rest (inside kwargs) are not.</span>
<span class="comment-copy">Yes, I've seen that quite often too. In that case it seems to be more of an error prevention mechanism, no? If you misspell key1, it'll end up in the kwargs.</span>
<span class="comment-copy">The question already states that the module is poorly documented, and data classes only help if you are <i>writing</i> the code (in which case you could also simply write better documentation yourself).</span>
