<div class="post-text" itemprop="text">
<p>I cannot produce example in Python which shows Boolean operator precedence rules combined with short circuit evaluation. I can show operator precedence using:</p>
<pre><code>print(1 or 0 and 0)  # Returns 1 because `or` is evaluated 2nd.
</code></pre>
<p>But the issue with short circuiting shows up when I change it to this:</p>
<pre><code>def yay(): print('yay'); return True
def nay(): print('nay')
def nope(): print('nope')
print(yay() or nay() and nope())  # Prints "yay\nTrue"
</code></pre>
<p>For each of 4 possibilities when expression before <code>or</code> is <code>True</code> it is the only evaluated expression. If operator precedence works this should print <code>"nay\nnope\nyay\nTrue"</code> or <code>"nay\nyay\nTrue"</code>, with short circuiting, because <code>and</code> should be evaluated 1st.</p>
<p>What comes to mind from this example is that Python reads boolean expression from left to right and ends it when result is known regardless of operator precedence.</p>
<p>Where is my error or what am I missing? Please give an example where it's visible that <code>and</code> is evaluated 1st and it isn't due to code being interpreted from left to right.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are confusing operator precedence and evaluation order.</p>
<p>The expression <code>r = x or y and z</code> is not evaluated as <code>tmp = y and z; r = x or tmp</code>, but just as <code>r = x or (y and z)</code>. This expression is evaluated from left to right, and if the result of the <code>or</code> is already decided, then <code>(y and z)</code> will not be evaluated at all.</p>
<p>Note that it would be different if <code>or</code> and <code>and</code> were functions; in this case, the parameters of the functions would be evaluated before the function itself is called. Hence, <code>operator.or_(yay(), operator.and_(nay(), nope()))</code> prints <code>yay</code>, <code>nay</code> and <code>nope</code> i.e. it prints all three, but still in order from left to right.</p>
<p>You can generalize this to other operators, too. The following two expressions will yield different results due to the different operator precedence (both implicit and explicit by using <code>(...)</code>), but the functions are called from left to right both times.</p>
<pre><code>&gt;&gt;&gt; def f(x): print(x); return x
&gt;&gt;&gt; f(1) + f(2) * f(3) / f(4) ** f(5) - f(6)         # 1 2 3 4 5 6 -&gt; -4.99
&gt;&gt;&gt; (f(1) + f(2)) * (((f(3) / f(4)) ** f(5)) - f(6)) # 1 2 3 4 5 6 -&gt; -17.29
</code></pre>
<p>As pointed out in comments, while the terms in between operations are evaluated from left to right, the actual operations are evaluated according to their precedence.</p>
<pre><code>class F:
    def __init__(self,x): self.x = x
    def __add__(self, other): print(f"add({self},{other})"); return F(self.x+other.x)
    def __mul__(self, other): print(f"mul({self},{other})"); return F(self.x*other.x)
    def __pow__(self, other): print(f"pow({self},{other})"); return F(self.x**other.x)
    def __repr__(self): return str(self.x)
def f(x): print(x); return F(x)
</code></pre>
<p>This way, the expression <code>f(1) + f(2) ** f(3) * f(4)</code> is evaluated as <code>1</code>, <code>2</code>, <code>3</code>, <code>pow(2,3)</code>, <code>4</code>, <code>mul(8,4)</code>, <code>add(1,32)</code>, i.e. terms are evaluated left-to-right (and pushed on a stack) and expressions are evaluated as soon as their parameters are evaluated.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first value returned from <code>yay()</code> is <code>True</code> so python will not even run the rest of the expression. This is for efficiency, as the rest of the expression will not impact the result.</p>
<p>Take the following example where I have changed the order:</p>
<pre><code>def yay(): print('yay'); return True
def nay(): print('nay')
def nope(): print('nope')
print(nay() and nope() or yay())
</code></pre>
<p>Output:</p>
<pre><code>nay
yay
True
</code></pre>
<p>What is happening here? <code>nay()</code> returns <code>None</code> which is falsy so we already know that it doesn't matter what <code>nope()</code> returns (because it is an <code>and</code> condition and the first part is already <code>False</code>) - so we don't run it. We then run the <code>yay()</code> because it could change the already <code>False</code> value of the expression - which returns <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually, your code returns <code>1</code> not because <code>or</code> is evaluated 2nd but because 1 is true and no further evalution is necessary. Which makes the behaviour consistent. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>or</code> has lower precedence than <code>and</code> so that <code>a or b and c</code> is interpreted as <code>a or (b and c)</code>.</p>
<p>In addition, the logical operators are evaluated "lazily" so that if <code>a</code> is <code>True</code>, <code>a or b</code> will not cause the evaluation of <code>b</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python evaluates expression from left to right and stops as soon as the result is known.
For ex, in case of an or operator, if the entity of left side is True then it is for sure that the operator will return true do the expression on right will not be evaluated in this case.</p>
<p>In case of <code>and</code> operator, if the expression on the left side is False, it is sure that the operator should return False. So the expression to the right is not evaluated here.</p>
<p>This is what is happening in your example.</p>
</div>
<span class="comment-copy">Note that operator precedence is not the same as evaluation order.</span>
<span class="comment-copy">I know that all arguments must be evaluated before they are passed to function but your example with <code>operator.or_</code> and <code>operator.and_</code> makes an interesting counterexample and shows that <code>and</code> and <code>or</code> operators evaluation cannot be replicated with function from <code>operator</code>.  So operator precedence is only about implicit parenthesis nesting not about evaluation order right?</span>
<span class="comment-copy">In your example the functions are all called in order left to right, but the operator evaluation happens in precedence order: so define a class which implements arithmetic operators and prints them and you'll see the calculations are not left to right. Indeed if you do that you'll even see that <code>f(1) ** f(2) ** f(3)</code> calls the <code>__pow__</code> method right to left.</span>
<span class="comment-copy">@Duncan Yes, operations are evaluated by precedence, I did not mean to deny this. Hope my edit clears it up.</span>
<span class="comment-copy">One might argue that right to left evaluation doesn't occur here but it only seems like it because number of expressions is getting smaller when operator is called thus the line gets shorter. You're not intentionally going back, it's like going against escalator direction.</span>
<span class="comment-copy">This is good example for short cirquiting but it doesn't show difference between operator precedence and evaluation order. That is why I asked for <code>and</code> which isn't evaluated 1st because of the left-to-rigth evaluation order.</span>
<span class="comment-copy">It doesn't evaluate everything left to right: <code>a if cond else b</code> will evaluate <code>cond</code> before either <code>a</code> or <code>b</code>.</span>
<span class="comment-copy">I didn't understand the syntax here. Can you explain a bit. I am a bit curious to know about what you want to say.</span>
<span class="comment-copy">I'm just saying that while most expressions in Python evaluate left to right there are exceptions. The conditional expression evaluates the condition and then evaluates one of the left or right expressions, so when the condition is true it cannot follow the left-to-right rule. See <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a></span>
<span class="comment-copy">Thanks for letting me know.</span>
