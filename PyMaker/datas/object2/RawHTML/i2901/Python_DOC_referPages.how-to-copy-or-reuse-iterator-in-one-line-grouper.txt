<div class="post-text" itemprop="text">
<p>I'm trying to do grouping in python in a one line expression. I want to build a <code>dict</code> of groups and number of items in the group:</p>
<pre><code>{k: {'objects': list(g), 'count': len(list(g))}
        for k,g in groupby(rows, key=lambda x: x['group_id'])}
</code></pre>
<p>But <code>g</code> is an iterator and it does not work in second use with <code>'count': len(list(g))</code>. 
How can I do counting and reusing <code>g</code> in one line expression?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't call <code>list()</code> on an iterator more than once, no. You have to store the result first.</p>
<p>Your options are, in order of feasibility:</p>
<ul>
<li>To not use a one-liner. Use a regular <code>for</code> loop and assign the <code>list()</code> result to a separate variable first.</li>
<li>Wrap the <code>groupby()</code> iterator in a generator expression that applies <code>list()</code> to the group object.</li>
<li>Add a second loop over with a single element tuple, the <code>list()</code> call, so you can use the loop target as a variable for both keys in the dictionary you are building.</li>
<li>Wait until Python 3.8 which adds <a href="https://www.python.org/dev/peps/pep-0572/" rel="nofollow noreferrer">PEP 572 assignment expressions</a> and assign the <code>list()</code> call result to a name to re-use for <code>len()</code></li>
</ul>
<p>The first should be the preferred option. Readability counts!</p>
<pre><code>result = {}
for group_id, group in groupby(rows, key=lambda x: x['group_id']):
    objects = list(group)
    result[group_id] = {'objects': objects, 'count': len(objects)}
</code></pre>
<p>Using a generator expression is perhaps the next best option:</p>
<pre><code>list_group = ((k, list(g)) for k, g in groupby(rows, key=lambda x: x['group_id']))
result = {k: {'objects': gl, 'count': len(gl)} for k, gl in list_group}
</code></pre>
<p>The generator expression loop is executed in parallel as <code>for k, gl in list_group</code> iterates.</p>
<p>The second-loop option looks like this:</p>
<pre><code>{
    k: {'objects': gl, 'count': len(gl)}
    for k, g in groupby(rows, key=lambda x: x['group_id'])
    for gl in (list(g),)
}
</code></pre>
<p>Because this trick is surprising and hard to read, I strongly recommend against using it.</p>
<p>In Python 3.8, with PEP 572 implemented, you can use:</p>
<pre><code>{
    k: {'objects': gl := list(g), 'count': len(gl)}
    for k, g in groupby(rows, key=lambda x: x['group_id'])
}
</code></pre>
<p>Iterators can be 'doubled' by using the <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee()</code> object</a>, but that has to then cache the whole list in memory separately, doubling the memory cost and the code would become no more readable (as you'd have to use a similar trick then to store the <code>tee()</code> call iterators in variables too!).</p>
</div>
<span class="comment-copy">Are you seriously suggesting that someone "Wait until Python 3.8"? Completely unrealistic IMO.</span>
<span class="comment-copy">@martineau: I am telling them all the options. So yes, that includes the future option of Python 3.8, because answers on Stack Overflow tend to stick around for long enough for that to become an option soon enough.</span>
<span class="comment-copy">@martineau: ah, editing snafu, I re-arranged my bulleted options list and forgot to update the 'last option' reference. That should be 'first' now, corrected.</span>
<span class="comment-copy">Martijn: I think your edit is a big improvement to an already very good answer. <code>;Â¬)</code> Also, your point about the needs of future readers is well taken (and something I've never considered before).</span>
<span class="comment-copy">Thank you, python future option also very interesting to know.</span>
