<div class="post-text" itemprop="text">
<pre><code>print(test[0].keys())
keys = test[0].keys()
with open('work.csv', 'w') as output_file:
    dict_writer = csv.DictWriter(output_file, keys)
    dict_writer.writeheader()
    dict_writer.writerows(test)

def get_user_category(user_polarity, followers_polarity, following_polarity):
if user_polarity and followers_polarity == following_polarity:
    return following_polarity
elif user_polarity and following_polarity == followers_polarity:
    return followers_polarity
elif followers_polarity and following_polarity == user_polarity:
    return user_polarity 

def get_users_tweet(username):
user_tweet = user_csv[user_csv["user"] == username]["tweets"]
user_tweet = list(user_tweet)
return user_tweet

def convertDictToCSV(dictionary):
w = csv.writer(open("output.csv", "w"))
for key, val in dictionary.items():
    w.writerow([key,val])
    return "Written to csv"

def get_maximum_class(username):
l = []
w = {}
for x in user_csv[user_csv["user"] == username ]["labels"]:
    l.append(x)
for z in set(l):
    w[z] = l.count(z)
return max(w)

def get_maximum_class_for_followers(username):
l = []
w = {}
for x in followers_csv[followers_csv["user"] == username ]["labels"]:
    l.append(x)
for z in set(l):
    w[z] = l.count(z)
return max(w)

def get_maximum_class_for_followed_users(username):
l = []
w = {}
for x in follow_csv[follow_csv["follows"] == username ]["labels"]:
    l.append(x)
for z in set(l):
    w[z] = l.count(z)
return max(w)
</code></pre>
<p>def get_followers_and_class_max(user):
    majority = []
    user_followers = set(followers_csv[followers_csv["follows"] == user]["user"])
    user_followers_class = set(followers_csv[followers_csv["follows"] == user]["labels"])
    for each_user in user_followers:
        majority.append(get_maximum_class_for_followers(each_user))
    return max(majority)</p>
<pre><code>def get_follow_follow_max(user):
majority = []
users_followed = set(follow_csv[follow_csv["user"] == user]["follows"])
users_followed_class = set(follow_csv[follow_csv["user"] == user]["follows"])
for each_user in users_followed:
    majority.append(get_maximum_class_for_followed_users(each_user))
return max(majority)
</code></pre>
<p>test = []
for each_user in set(user_csv["user"]):
    try:
        followers_polarity = get_followers_and_class_max(each_user)
    except(ValueError):
        followers_polarity = 0
    try:
        following_polarity = get_follow_follow_max(each_user)
    except(ValueError):
        following_polarity = 0</p>
<pre><code>user_category = get_user_category(get_maximum_class(each_user), followers_polarity, following_polarity)
users_tweet = get_users_tweet(each_user)
data = {"User:": each_user, "Polarity: ": get_maximum_class(each_user), "Following Polarity: ": following_polarity,            "Followers Polarity: ": followers_polarity, "Users Category: ": user_category }
test.append(data)
</code></pre>
<h1>print(test)</h1>
<pre><code>new_file =StringIO(newline='')   

#print(test[0].keys())
keys = test[0].keys()
with open('work.csv', 'w') as output_file:
    dict_writer = csv.DictWriter(output_file, keys)
    dict_writer.writeheader()
    dict_writer.writerows(test)
with open('work3','w',newline='') as f_out:
    f_out.write(output_file.getvalue())
</code></pre>
<p>i want to create a new csv file with new fields. the classification is displaying on the terminal but not creating a new csv file.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>StringIO</code> class (<a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow noreferrer">docs here</a>) to write to memory (without creating any file) and then write to terminal. This example will write CSV data to <code>StringIO</code> object and prints it:</p>
<pre><code>import csv
from io import StringIO   # from StringIO import StringIO in case of Python2

test = [{'col1':1, 'col2':2, 'col3':3},
        {'col1':4, 'col2':5, 'col3':6}]

output_file = StringIO(newline='')

dict_writer = csv.DictWriter(output_file, ['col1', 'col2', 'col3'])
dict_writer.writeheader()
dict_writer.writerows(test)

output_file.seek(0)
print(output_file.read())
</code></pre>
<p>Prints:</p>
<pre><code>col1,col2,col3
1,2,3
4,5,6
</code></pre>
<p>Edit:</p>
<p>For writing to multiple CSV files you can use this snippet:</p>
<pre><code>import csv
from io import StringIO

test = [{'col1':1, 'col2':2, 'col3':3},
        {'col1':4, 'col2':5, 'col3':6}]

output_file = StringIO(newline='')

dict_writer = csv.DictWriter(output_file, ['col1', 'col2', 'col3'])
dict_writer.writeheader()
dict_writer.writerows(test)

with open('work1.csv', 'w', newline='') as f1_out, \
    open('work2.csv', 'w', newline='') as f2_out:

    f1_out.write(output_file.getvalue())
    f2_out.write(output_file.getvalue())
</code></pre>
<p>This will create two files <code>work1.csv</code> and <code>work2.csv</code>.</p>
</div>
<span class="comment-copy">What exactly do you wish to display on the terminal ? Your question isn't clear.</span>
<span class="comment-copy">i meant to say save the output into a new csv file. thanks for the explanation</span>
<span class="comment-copy">@namdi I updated my answer</span>
<span class="comment-copy">here is the full code.</span>
