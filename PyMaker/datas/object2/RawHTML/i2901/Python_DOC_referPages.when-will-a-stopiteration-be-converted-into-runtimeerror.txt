<div class="post-text" itemprop="text">
<p>I'm reading the documentation for Python 3 <a href="https://docs.python.org/3/library/exceptions.html#StopIteration" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<p>If a generator code directly or indirectly raises <code>StopIteration</code>, it is converted into a <code>RuntimeError</code> (retaining the <code>StopIteration</code> as the new exception's cause).</p>
</blockquote>
<p>I don't understand that, can anyone explain?</p>
<p>This is what I've tried in Python 3.6, but nothing seems to have been caught:</p>
<pre><code>def gen1():
    yield from [1, 2, 3]
    raise StopIteration

def gen2():
    raise StopIteration

try:
    a = list(gen1())
    # a == [1, 2, 3]
except RuntimeError:
    print("Caught")

try:
    a = gen1()
    next(a), next(a), next(a), next(a), next(a)
except RuntimeError:
    print("Caught")

try:
    gen2()
except RuntimeError:
    print("Caught")

try:
    a = list(gen2())
except RuntimeError:
    print("Caught")
</code></pre>
<p>Specially, both calls to <code>gen2()</code> raised the <code>StopIteration</code>, but still not converted into <code>RuntimeError</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You missed that this change applies to Python 3.7 and newer. <em>You won't see the conversion in Python 3.6 or older</em>, unless you enable the feature with a <code>from __future__</code> import first (available as of Python 3.5).</p>
<p>From the same page you linked:</p>
<blockquote>
<p><em>Changed in version 3.5</em>: Introduced the <code>RuntimeError</code> transformation via <code>from __future__ import generator_stop</code>, see PEP 479.</p>
<p><em>Changed in version 3.7</em>: Enable PEP 479 for all code by default: a <code>StopIteration</code> error raised in a generator is transformed into a <code>RuntimeError</code>.</p>
</blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0479/" rel="noreferrer">PEP 479 -- <em>Change StopIteration handling inside generators</em></a> further details why this change was made and how it applies. For your code, running on Python 3.7, the output becomes:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version_info
sys.version_info(major=3, minor=7, micro=0, releaselevel='final', serial=0)
&gt;&gt;&gt; def gen1():
...     yield from [1, 2, 3]
...     raise StopIteration
...
&gt;&gt;&gt; def gen2():
...     yield 42  # make this an actual generator
...     raise StopIteration
...
&gt;&gt;&gt; try:
...     a = list(gen1())
... except RuntimeError:
...     print("Caught")
...
Caught
&gt;&gt;&gt; try:
...     a = gen1()
...     next(a), next(a), next(a), next(a), next(a)
... except RuntimeError:
...     print("Caught")
...
Caught
&gt;&gt;&gt; try:
...     a = list(gen2())
... except RuntimeError:
...     print("Caught")
...
Caught
</code></pre>
<p>Note that I added a <code>yield 42</code> line to <code>gen2()</code> to make it a generator. Without <code>yield</code> or <code>yield from</code> in the body, you get a regular function instead. Calling a generator function produces a generator object and the function body starts out paused, while calling a normal function executes the body immediately:</p>
<pre><code>&gt;&gt;&gt; def normal():
...     raise StopIteration
...
&gt;&gt;&gt; def generator():
...     raise StopIteration
...     yield  # never reached, but this is now a generator
...
&gt;&gt;&gt; normal()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in normal
StopIteration
&gt;&gt;&gt; generator()
&lt;generator object generator at 0x105831ed0&gt;
&gt;&gt;&gt; next(generator())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in generator
StopIteration

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: generator raised StopIteration
</code></pre>
<p>For Python 3.6, you'd use the <code>from __future__ import generator_stop</code> compiler switch (use it at the top of your code when writing a script or module):</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version_info
sys.version_info(major=3, minor=6, micro=5, releaselevel='final', serial=0)
&gt;&gt;&gt; def generator():
...     raise StopIteration
...     yield
...
&gt;&gt;&gt; next(generator())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in generator
StopIteration
&gt;&gt;&gt; from __future__ import generator_stop
&gt;&gt;&gt; def generator():  # re-define it so it is compiled anew
...     raise StopIteration
...     yield
...
&gt;&gt;&gt; next(generator())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in generator
StopIteration

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: generator raised StopIteration
</code></pre>
</div>
<span class="comment-copy">Note: <code>gen2</code> is <i>not a generator</i>. It is a regular function, and the PEP 479 changes do not apply to it. Add a <code>yield</code> expression to make it a generator.</span>
