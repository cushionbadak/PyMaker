<div class="post-text" itemprop="text">
<p>Is there a way using Python's standard library to easily determine (i.e. one function call) the last day of a given month?</p>
<p>If the standard library doesn't support that, does the dateutil package support this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I didn't notice this earlier when I was looking at the <a href="https://docs.python.org/2/library/calendar.html" rel="noreferrer">documentation for the calendar module</a>, but a method called <a href="http://docs.python.org/library/calendar.html#calendar.monthrange" rel="noreferrer">monthrange</a> provides this information:</p>
<blockquote>
<p><b>monthrange(year, month)</b><br/>
      Returns weekday of first day of the month and number of days in month, for the specified year and month. </p>
</blockquote>
<pre><code>&gt;&gt;&gt; import calendar
&gt;&gt;&gt; calendar.monthrange(2002,1)
(1, 31)
&gt;&gt;&gt; calendar.monthrange(2008,2)
(4, 29)
&gt;&gt;&gt; calendar.monthrange(2100,2)
(0, 28)
</code></pre>
<p>so:</p>
<pre><code>calendar.monthrange(year, month)[1]
</code></pre>
<p>seems like the simplest way to go.</p>
<p>Just to be clear, <code>monthrange</code> supports leap years as well:</p>
<pre><code>&gt;&gt;&gt; from calendar import monthrange
&gt;&gt;&gt; monthrange(2012, 2)
(2, 29)
</code></pre>
<p><a href="https://stackoverflow.com/questions/42950/get-last-day-of-the-month-in-python#43088">My previous answer</a> still works, but is clearly suboptimal.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to import the <code>calendar</code> module, a simple two-step function can also be:</p>
<pre><code>import datetime

def last_day_of_month(any_day):
    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)  # this will never fail
    return next_month - datetime.timedelta(days=next_month.day)
</code></pre>
<p>Outputs:</p>
<pre><code>&gt;&gt;&gt; for month in range(1, 13):
...     print last_day_of_month(datetime.date(2012, month, 1))
...
2012-01-31
2012-02-29
2012-03-31
2012-04-30
2012-05-31
2012-06-30
2012-07-31
2012-08-31
2012-09-30
2012-10-31
2012-11-30
2012-12-31
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>EDIT: See @Blair Conrad's answer for a cleaner solution</p>
<hr/>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.date (2000, 2, 1) - datetime.timedelta (days = 1)
datetime.date(2000, 1, 31)
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>EDIT: see <a href="/questions/42950/get-last-day-of-the-month-in-python#43663">my other answer</a>. It has a better implementation than this one, which I leave here just in case someone's interested in seeing how one might "roll your own" calculator.</p>
<p>@John Millikin gives a good answer, with the added complication of calculating the first day of the next month.</p>
<p>The following isn't particularly elegant, but to figure out the last day of the month that any given date lives in, you could try:</p>
<pre><code>def last_day_of_month(date):
    if date.month == 12:
        return date.replace(day=31)
    return date.replace(month=date.month+1, day=1) - datetime.timedelta(days=1)

&gt;&gt;&gt; last_day_of_month(datetime.date(2002, 1, 17))
datetime.date(2002, 1, 31)
&gt;&gt;&gt; last_day_of_month(datetime.date(2002, 12, 9))
datetime.date(2002, 12, 31)
&gt;&gt;&gt; last_day_of_month(datetime.date(2008, 2, 14))
datetime.date(2008, 2, 29)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is actually pretty easy with <code>dateutil.relativedelta</code> (package python-datetutil for pip). <code>day=31</code> will always always return the last day of the month.</p>
<p>Example:</p>
<pre><code>from datetime import datetime
from dateutil.relativedelta import relativedelta

date_in_feb = datetime.datetime(2013, 2, 21)
print datetime.datetime(2013, 2, 21) + relativedelta(day=31)  # End-of-month
&gt;&gt;&gt; datetime.datetime(2013, 2, 28, 0, 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>relativedelta</code> you would get last date of month like this:</p>
<pre><code>from dateutil.relativedelta import relativedelta
last_date_of_month = datetime(mydate.year,mydate.month,1)+relativedelta(months=1,days=-1)
</code></pre>
<p>The idea is to get the fist day of month and use <code>relativedelta</code> to go 1 month ahead and 1 day back so you would get the last day of the month you wanted.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another solution would be to do something like this: </p>
<pre><code>from datetime import datetime

def last_day_of_month(year, month):
    """ Work out the last day of the month """
    last_days = [31, 30, 29, 28, 27]
    for i in last_days:
        try:
            end = datetime(year, month, i)
        except ValueError:
            continue
        else:
            return end.date()
    return None
</code></pre>
<p>And use the function like this:</p>
<pre><code>&gt;&gt;&gt; 
&gt;&gt;&gt; last_day_of_month(2008, 2)
datetime.date(2008, 2, 29)
&gt;&gt;&gt; last_day_of_month(2009, 2)
datetime.date(2009, 2, 28)
&gt;&gt;&gt; last_day_of_month(2008, 11)
datetime.date(2008, 11, 30)
&gt;&gt;&gt; last_day_of_month(2008, 12)
datetime.date(2008, 12, 31)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from datetime import timedelta
(any_day.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; import calendar
&gt;&gt;&gt; date  = datetime.datetime.now()

&gt;&gt;&gt; print date
2015-03-06 01:25:14.939574

&gt;&gt;&gt; print date.replace(day = 1)
2015-03-01 01:25:14.939574

&gt;&gt;&gt; print date.replace(day = calendar.monthrange(date.year, date.month)[1])
2015-03-31 01:25:14.939574
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you are willing to use an external library, check out <a href="http://crsmithdev.com/arrow/" rel="noreferrer">http://crsmithdev.com/arrow/</a></p>
<p>U can then get the last day of the month with:</p>
<pre><code>import arrow
arrow.utcnow().ceil('month').date()
</code></pre>
<p>This returns a date object which you can then do your manipulation.</p>
</div>
<div class="post-text" itemprop="text">
<p>To get the last date of the month we do something like this:</p>
<pre><code>from datetime import date, timedelta
import calendar
last_day = date.today().replace(day=calendar.monthrange(date.today().year, date.today().month)[1])
</code></pre>
<p>Now to explain what we are doing here we will break it into two parts:</p>
<p>first is getting the number of days of the current month for which we use <a href="https://docs.python.org/3/library/calendar.html#calendar.monthrange" rel="noreferrer">monthrange</a> which Blair Conrad has already mentioned his solution:</p>
<pre><code>calendar.monthrange(date.today().year, date.today().month)[1]
</code></pre>
<p>second is getting the last date itself which we do with the help of <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.replace" rel="noreferrer">replace</a> e.g</p>
<pre><code>&gt;&gt;&gt; date.today()
datetime.date(2017, 1, 3)
&gt;&gt;&gt; date.today().replace(day=31)
datetime.date(2017, 1, 31)
</code></pre>
<p>and when we combine them as mentioned on the top we get a dynamic solution.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import datetime

now = datetime.datetime.now()
start_month = datetime.datetime(now.year, now.month, 1)
date_on_next_month = start_month + datetime.timedelta(35)
start_next_month = datetime.datetime(date_on_next_month.year, date_on_next_month.month, 1)
last_day_month = start_next_month - datetime.timedelta(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For me it's the simplest way:</p>
<pre><code>selected_date = date(some_year, some_month, some_day)

if selected_date.month == 12: # December
     last_day_selected_month = date(selected_date.year, selected_date.month, 31)
else:
     last_day_selected_month = date(selected_date.year, selected_date.month + 1, 1) - timedelta(days=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way (without having to import calendar), is to get the first day of the next month, and then subtract a day from it.</p>
<pre><code>import datetime as dt
from dateutil.relativedelta import relativedelta

thisDate = dt.datetime(2017, 11, 17)

last_day_of_the_month = dt.datetime(thisDate.year, (thisDate + relativedelta(months=1)).month, 1) - dt.timedelta(days=1)
print last_day_of_the_month
</code></pre>
<p>Output:</p>
<pre><code>datetime.datetime(2017, 11, 30, 0, 0)
</code></pre>
<hr/>
<p><strong>PS:</strong> This code runs faster as compared to the <code>import calendar</code>approach; see below:</p>
<pre><code>import datetime as dt
import calendar
from dateutil.relativedelta import relativedelta

someDates = [dt.datetime.today() - dt.timedelta(days=x) for x in range(0, 10000)]

start1 = dt.datetime.now()
for thisDate in someDates:
    lastDay = dt.datetime(thisDate.year, (thisDate + relativedelta(months=1)).month, 1) - dt.timedelta(days=1)

print ('Time Spent= ', dt.datetime.now() - start1)


start2 = dt.datetime.now()
for thisDate in someDates:
    lastDay = dt.datetime(thisDate.year, 
                          thisDate.month, 
                          calendar.monthrange(thisDate.year, thisDate.month)[1])

print ('Time Spent= ', dt.datetime.now() - start2)
</code></pre>
<p>OUTPUT:</p>
<pre><code>Time Spent=  0:00:00.097814
Time Spent=  0:00:00.109791
</code></pre>
<p>This code assumes that you want the date of the last day of the month (i.e., not just the DD part, but the entire YYYYMMDD date)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can calculate the end date yourself. the simple logic is to subtract a day from the start_date of next month. :) </p>
<p>So write a custom method,</p>
<pre><code>import datetime

def end_date_of_a_month(date):


    start_date_of_this_month = date.replace(day=1)

    month = start_date_of_this_month.month
    year = start_date_of_this_month.year
    if month == 12:
        month = 1
        year += 1
    else:
        month += 1
    next_month_start_date = start_date_of_this_month.replace(month=month, year=year)

    this_month_end_date = next_month_start_date - datetime.timedelta(days=1)
    return this_month_end_date
</code></pre>
<p>Calling, </p>
<pre><code>end_date_of_a_month(datetime.datetime.now().date())
</code></pre>
<p>It will return the end date of this month. Pass any date to this function. returns you the end date of that month. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another answer. No extra packages required.</p>
<pre><code>datetime.date(year + int(month/12), month%12+1, 1)-datetime.timedelta(days=1)
</code></pre>
<p>Get the first day of the next month and subtract a day from it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This does not address the main question, but one nice trick to get the last <em>weekday</em> in a month is to use <code>calendar.monthcalendar</code>, which returns a matrix of dates, organized with Monday as the first column through Sunday as the last.</p>
<pre><code># Some random date.
some_date = datetime.date(2012, 5, 23)

# Get last weekday
last_weekday = np.asarray(calendar.monthcalendar(some_date.year, some_date.month))[:,0:-2].ravel().max()

print last_weekday
31
</code></pre>
<p>The whole <code>[0:-2]</code> thing is to shave off the weekend columns and throw them out. Dates that fall outside of the month are indicated by 0, so the max effectively ignores them.</p>
<p>The use of <code>numpy.ravel</code> is not strictly necessary, but I hate relying on the <em>mere convention</em> that <code>numpy.ndarray.max</code> will flatten the array if not told which axis to calculate over.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use pandas!</p>
<pre><code>def isMonthEnd(date):
    return date + pd.offsets.MonthEnd(0) == date

isMonthEnd(datetime(1999, 12, 31))
True
isMonthEnd(pd.Timestamp('1999-12-31'))
True
isMonthEnd(pd.Timestamp(1965, 1, 10))
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer this way</p>
<pre><code>import datetime
import calendar

date=datetime.datetime.now()
month_end_date=datetime.datetime(date.year,date.month,1) + datetime.timedelta(days=calendar.monthrange(date.year,date.month)[1] - 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to make your own small function, this is a good starting point:</p>
<pre><code>def eomday(year, month):
    """returns the number of days in a given month"""
    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    d = days_per_month[month - 1]
    if month == 2 and (year % 4 == 0 and year % 100 != 0 or year % 400 == 0):
        d = 29
    return d
</code></pre>
<p>For this you have to know the rules for the leap years:</p>
<ul>
<li>every fourth year</li>
<li>with the exception of every 100 year</li>
<li>but again every 400 years</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.7 there is <a href="https://github.com/python/cpython/blob/4583525835baf8fc7bd49a60725d1e8c49ef92b3/Lib/calendar.py#L130" rel="nofollow noreferrer">the undocumented <code>calendar.monthlen(year, month)</code> function</a>:</p>
<pre><code>&gt;&gt;&gt; calendar.monthlen(2002, 1)
31
&gt;&gt;&gt; calendar.monthlen(2008, 2)
29
&gt;&gt;&gt; calendar.monthlen(2100, 2)
28
</code></pre>
<p>It is equivalent to <a href="https://docs.python.org/3/library/calendar.html#calendar.monthrange" rel="nofollow noreferrer">the documented <code>calendar.monthrange(year, month)[1]</code> call</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import calendar
from time import gmtime, strftime
calendar.monthrange(int(strftime("%Y", gmtime())), int(strftime("%m", gmtime())))[1]
</code></pre>
<p>Output:<br/></p>
<pre><code>31
</code></pre>
<p><br/><br/>
This will print the last day of whatever the current month is. In this example it was 15th May, 2016.  So your output may be different, however the output will be as many days that the current month is.  Great if you want to check the last day of the month by running a daily cron job.
<p>
So: <br/></p>
<pre><code>import calendar
from time import gmtime, strftime
lastDay = calendar.monthrange(int(strftime("%Y", gmtime())), int(strftime("%m", gmtime())))[1]
today = strftime("%d", gmtime())
lastDay == today
</code></pre>
<p>Output:<br/></p>
<pre><code>False
</code></pre>
<p>Unless it IS the last day of the month.</p>
</p></div>
<div class="post-text" itemprop="text">
<p>If you pass in a date range, you can use this:</p>
<pre><code>def last_day_of_month(any_days):
    res = []
    for any_day in any_days:
        nday = any_day.days_in_month -any_day.day
        res.append(any_day + timedelta(days=nday))
    return res
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In the code below <em>'get_last_day_of_month(dt)'</em> will give you this, with date in string format like 'YYYY-MM-DD'.</p>
<pre><code>import datetime

def DateTime( d ):
    return datetime.datetime.strptime( d, '%Y-%m-%d').date()

def RelativeDate( start, num_days ):
    d = DateTime( start )
    return str( d + datetime.timedelta( days = num_days ) )

def get_first_day_of_month( dt ):
    return dt[:-2] + '01'

def get_last_day_of_month( dt ):
    fd = get_first_day_of_month( dt )
    fd_next_month = get_first_day_of_month( RelativeDate( fd, 31 ) )
    return RelativeDate( fd_next_month, -1 )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can use relativedelta
<a href="https://dateutil.readthedocs.io/en/stable/relativedelta.html" rel="nofollow noreferrer">https://dateutil.readthedocs.io/en/stable/relativedelta.html</a>
<code>
month_end = &lt;your datetime value within the month&gt; + relativedelta(day=31)
</code>
that will give you the last day.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution based python lambdas:</p>
<pre><code>next_month = lambda y, m, d: (y, m + 1, 1) if m + 1 &lt; 13 else ( y+1 , 1, 1)
month_end  = lambda dte: date( *next_month( *dte.timetuple()[:3] ) ) - timedelta(days=1)
</code></pre>
<p>The <code>next_month</code> lambda finds the tuple representation of the first day of the next month, and rolls over to the next year. The <code>month_end</code> lambda transforms a date (<code>dte</code>) to a tuple, applies <code>next_month</code> and creates a new date. Then the "month's end" is just the next month's first day minus <code>timedelta(days=1)</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I hope,It's usefull for very much..Try it on this way..we must need import some package</p>
<pre><code>import time
from datetime import datetime, date
from datetime import timedelta
from dateutil import relativedelta

  start_date = fields.Date(
        string='Start Date', 
        required=True,
        ) 

    end_date = fields.Date(
        string='End Date', 
        required=True,
        )

    _defaults = {
        'start_date': lambda *a: time.strftime('%Y-%m-01'),
        'end_date': lambda *a: str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10],
    }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i have a simple solution:
</p>
<pre><code>import datetime   
datetime.date(2012,2, 1).replace(day=1,month=datetime.date(2012,2,1).month+1)-timedelta(days=1)
datetime.date(2012, 2, 29)
</code></pre>
</div>
<span class="comment-copy">Am I the only one who thought that you were asking for the Last Day of Monty Python?  :D  [20081124 Moved from reply to a comment --- the original reply was posted before the comment system was introduced on SO]</span>
<span class="comment-copy">This is not a correct answer to the original question! What if the last day of the month is a Sat/Sun.</span>
<span class="comment-copy">@mahdi: it is correct, the second number is the "nr of days in the month" == "the last day", irrespective what kind of day that is.</span>
<span class="comment-copy">It's returns wrong day for year 1800 february. I don't get it</span>
<span class="comment-copy">@sword1st, I see <code>28</code> as the answer, which is correct, using <a href="https://en.wikipedia.org/wiki/Leap_year#Algorithm" rel="nofollow noreferrer">the rules for the Gregorian calendar</a></span>
<span class="comment-copy">I would actually call this cleaner, except for the fact that it fails in December when <code>today.month + 1 == 13</code> and you get a <code>ValueError</code>.</span>
<span class="comment-copy">You can solve that by using <code>(today.month % 12) + 1</code> since <code>12 % 12</code> gives 0</span>
<span class="comment-copy">It sounds silly but How do I get first day of month similarly like this.</span>
<span class="comment-copy">Is it not always 1?</span>
<span class="comment-copy">Yeah but i was confused I was looking something like this : start_date = date(datetime.now().year, datetime.now().month, 1)</span>
<span class="comment-copy">Ah. <code>today = datetime.date.today(); start_date = today.replace(day=1)</code>. You'd want to avoid calling datetime.now twice, in case you called it just before midnight on December 31 and then just after midnight. You'd get 2016-01-01 instead of either 2016-12-01 or 2017-01-01.</span>
<span class="comment-copy">This is very straightforward to understand and returns a datetime instance, which may be useful in many cases. Another advantage is that it works if the input <code>date</code> is an instance of <code>datetime.date</code>, <code>datetime.datetime</code> and also <code>pandas.Timestamp</code>.</span>
<span class="comment-copy">I personally like relativedelta(months=+1, seconds=-1) seems more obvious what is going on</span>
<span class="comment-copy">You're wrong. <code>datetime(2014, 2, 1) + relativedelta(days=31)</code> gives <code>datetime(2014, 3, 4, 0, 0)</code>...</span>
<span class="comment-copy">you used days= instead of day=</span>
<span class="comment-copy">@VinceSpicer working for leap years?</span>
<span class="comment-copy">Too complex, breaks the third rule of the zen of python.</span>
<span class="comment-copy">Suboptimal solution, but it works.  Doesn't deserve -3.  +1 ;)</span>
<span class="comment-copy">This is what bugs are made of ;) Try with 31 of January</span>
<span class="comment-copy">@LeartS: it works for me. What happens when you try?</span>
<span class="comment-copy">set any_day to  31 of January，this would not work</span>
<span class="comment-copy">It works. any_day is Jan 31, we replace day with 1, so Jan 1, add 32 days, we get Feb 2nd, replace with day=1 again and we get Feb 1. Subtract one day and we get Jan 31. I don't see what the issue is. What day do you get?</span>
<span class="comment-copy">Although this code may help to solve the problem, it doesn't explain <i>why</i> and/or <i>how</i> it answers the question. Providing this additional context  would significantly improve its long-term educational value. Please <a href="https://stackoverflow.com/posts/39223365/edit">edit</a> your answer to add explanation, including what limitations and assumptions apply.</span>
<span class="comment-copy">This seems the most straightforward.. if you are wiling to give it two lines you can get a nice <code>date.replace(day=day)</code> so everyone knows what's going on.</span>
<span class="comment-copy">why would you not want to <code>import calendar</code>?</span>
<span class="comment-copy">Because it's faster. I have modified my answer above to include this.</span>
<span class="comment-copy">@Vishal you got the concept right but the following line was not:  ``` dt.datetime(thisDate.year, (thisDate + relativedelta(months=1)).month, 1) - dt.timedelta(days=1) ``` especially if the month is at the end of the year. try  ```     last_date_of_month = \         first_date_of_month + relativedelta(months=1) - relativedelta(days=1) ``` instead</span>
<span class="comment-copy">you can also implemented using <code>pd.series.dt.is_month_end</code> <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.dt.is_month_end.html" rel="nofollow noreferrer">link</a></span>
<span class="comment-copy">Pandas datetime object has a specific method for that: <code>now=datetime.datetime.now(); pd_now = pd.to_datetime(now); print(pd_now.days_in_month)</code></span>
<span class="comment-copy">Sure, but the system libraries already have this data, and should the rules be changed by decree  the updating of the libraries is somebody else's problem.</span>
<span class="comment-copy">Well, possible, but highly unlikely, and even if - it would only bite you in about 2000 years...  <a href="https://en.wikipedia.org/wiki/Gregorian_calendar#Accuracy" rel="nofollow noreferrer">en.wikipedia.org/wiki/Gregorian_calendar#Accuracy</a></span>
<span class="comment-copy">These rules don't work for 500 years into the past I have no confidence that they will stand for thousands of years into the future,</span>
<span class="comment-copy">Can you please explain this answer? This code doesn't even run.</span>
<span class="comment-copy">must import relative package....Then create one lambda function creating map value to filed.... if you want  last date only take last date..                                                                                                                      last_date = fields.Date(string='Last Date',  required=True, )                                                _defaults = {                                                                                                         'last_date': lambda *a: str(datetime.now() + relativedelta.relativedelta(months=+1, day=1, days=-1))[:10],     }</span>
<span class="comment-copy">I'm not sure why you've posted an answer that is related to an open source ERP system (Odoo). This implementation uses way too many imports too..</span>
<span class="comment-copy">This won't work for december; you cannot use <code>13</code> for a month value.</span>
