<div class="post-text" itemprop="text">
<p>I'm trying to merge list items with previous items if they don't contain a certain prefix, and adding a <code>\n</code> between said list items when doing so. </p>
<pre><code>prefix  = '!'
cmds    = ['!test','hello','world','!echo','!embed','oh god']

output  = ['!test\nhello\nworld','!echo','!embed\noh god']
</code></pre>
<p>I tried something like</p>
<pre><code>for i in list(range(0,len(cmds))):
    if not cmds[i+1].startswith(prefix):
        cmds[i] += cmds.pop(i+1)
</code></pre>
<p>but always get the <code>list index out of range</code> error.</p>
<p>My apologies if this is badly worded, or seems like an obvious fix, I'm fairly new to python/programming.</p>
<p>Edit:</p>
<p>I had managed to get it to work with </p>
<pre><code>prefix = '!'
cmds    = ['!test','hello','world','!echo','!embed','oh god']
print(list(range(0,len(cmds))))
for i in reversed(range(len(cmds))):
    if not cmds[i].startswith(prefix):
        cmds[i-1] += '\n'+cmds.pop(i)
print(cmds)
</code></pre>
<p>but your answers seem so much neater and efficient. Much thanks everyone</p>
</div>
<div class="post-text" itemprop="text">
<p>I propose to create a new list, as you showed in your problem specification:</p>
<pre><code>prefix  = '!'
cmds    = ['!test','hello','world','!echo','!embed','oh god']

output  = []
for cmd in cmds:
    if cmd.startswith(prefix) or not output:
        output.append(cmd)
    else:
        output[-1] += "\n" + cmd  # change the string in the last element of output
</code></pre>
<p>The result is:</p>
<pre><code>&gt;&gt;&gt; output
['!test\nhello\nworld', '!echo', '!embed\noh god']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a one liner solution using <code>itertools.groupby</code> and <code>itertools.accumulate</code>:</p>
<pre><code>from itertools import accumulate, groupby
from operator import itemgetter

x = ['!test','hello','world','!echo','!embed','oh god']

cumsum = accumulate(map(lambda s: s.startswith('!'), x))
result = ['\n'.join(map(itemgetter(0), g)) for _, g in groupby(zip(x, cumsum), itemgetter(1))]
</code></pre>
<p>This looks like a two liner because I wanted to make it semi-legible, but that's not always necessary:</p>
<pre><code>result = ['\n'.join(map(itemgetter(0), g)) for _, g in groupby(zip(x, accumulate(map(lambda s: s.startswith('!'), x))), itemgetter(1))]
</code></pre>
<p><code>cumsum</code> provides the number of elements starting with <code>!</code> found so far. This makes for a nice key to <code>groupby</code>. It works by accumulating the booleans returned by <code>str.startswith</code> into an integer.</p>
<p>The final result uses <code>cumsum</code> as the key, but joins the grouped elements of <code>x</code> with newlines.</p>
<p>Here's an <a href="https://ideone.com/TndjMB" rel="nofollow noreferrer">IDEOne Link</a> to play with.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do it with list comprehension "also".</p>
<pre><code>In [1]: cmds    = ['!test','hello','world','!echo','!embed','oh god']
In [2]: prefix  = '!'
In [3]: inds = [i for i, x in enumerate(cmds) if prefix in x]
In [4]: inds.append(len(cmds))
In [5]: lens = list(zip(inds, inds[1:]))
# [(0, 3), (3, 4), (4, 6)]

In [6]: ["\n".join(cmds[a:b]) for a, b in lens]
Out[6]: ['!test\nhello\nworld', '!echo', '!embed\noh god']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A solution that is a bit longer, but that can easily be generalized to other situations, using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer">itertools.groupby</a>:</p>
<pre><code>from itertools import groupby

class StartGroupOnPrefix:
    def __init__(self, prefix):
        self.output = False
        self.prefix = prefix

    def __call__(self, item):
        if item.startswith(self.prefix):
            self.output = not self.output
        return self.output


prefix  = '!'
cmds    = ['!test','hello','world','!echo','!embed','oh god']

condition = StartGroupOnPrefix(prefix)

out = ['\n'.join(group) for f, group in groupby(cmds, condition)]
print(out)

#  ['!test\nhello\nworld','!echo','!embed\noh god']
</code></pre>
<p>As we have an iterator, we also don't have to create the whole output list at once, we can generate each output on-the-fly:</p>
<pre><code>for grouped_item in ('\n'.join(group) for f, group in groupby(cmds, condition)):
    print('-----------\n', grouped_item)

# -----------
#  !test
# hello
# world
# -----------
#  !echo
# -----------
#  !embed
# oh god
</code></pre>
<p>A bit of explanation :<code>groupby(iterable)</code> starts a new group each time it gets a different item from <code>iterable</code>. <code>groupby(iterable, key)</code> starts a new group everytime the return value of the <code>key</code> function changes. Our <code>condition</code> function alternates its output between <code>True</code> and <code>False</code> each time the item starts with the prefix. </p>
</div>
<span class="comment-copy">If using pop, the list size changes, so don't increment the index</span>
