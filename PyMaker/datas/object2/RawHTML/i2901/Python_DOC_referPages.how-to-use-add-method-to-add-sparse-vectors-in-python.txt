<div class="post-text" itemprop="text">
<p>I am given an assignment to add two sparse vectors using special methods in SparseVec(length) class.I have limited understanding of special methods and method overloading, can you please describe what i am missing in the following code and what exactly is method overloading? 
I have two alternatives: using stand alone functions and class methods(OOP). I want to know the advantage of the later (OOP). </p>
<p>Stand-alone function (Works fine)</p>
<pre><code>def SparseVec(numbers):
    dic={}
    for key,val in enumerate(numbers):
        if val:
            dic[key]=val
    return dic

numbers=[-1,0,9.2,0]
a=SparseVec(numbers)
print(a)

numbers2=[0,1,0,0,0]
b=SparseVec(numbers2)
print(b)

#Adds and merges values with keys in two dictionaries
def merged_dictionaries(a,b):
    merged_dict={}
    for key in a:
        if key in b:
            new_value=a[key]+b[key]
        else:
            new_value=a[key]
        merged_dict[key]=new_value
    for key in b:
        if key not in merged_dict:
            merged_dict[key]=b[key]
    return merged_dict
c=merged_dictionaries(a,b)
for key, val in c.items(): # SparseVec iterator
    print ('c[%d]=%g ' % (key,val))
print(c)
</code></pre>
<p>class method(OOP)-(Defective)</p>
<pre><code>#Implements a Sparse vector (vector with many zero values) and adds two sparse vectors
class SparseVec:
    #initializes the instance with given length
    def __init__(self,length):
        self.length=length
        self.data={}
    def __str__(self):
        return 'Dense Vector {}'. format(self.data)
    #Returns the length of the vector
    def __len__(self):
        return len(self.data)
    # Returns nonzeros from the given(self) dictionary
    def __getitem__(self, item):
        return self.data
    def __setitem__(self, key, val):
        #To set a value by its key
        self.data[key]= val

    def nonzeros(self):
        nonzerodict = {}
        for key, val in enumerate(self):
            if val:
                nonzerodict[key] = val
        return nonzerodict
    def __add__(self, other):
        c = {}
        for key in self:
            if key in other:
                new_value = self[key]+ other[key]
            else:
                new_value = self[key]
            c[key] = new_value
        for key in other:
            if key not in c:
                c[key] = other[key]
        return c

a = SparseVec(4)
a[2] = 9.2
a[0] = -1
print(a)
print(a.nonzeros())
b = SparseVec(5)
b[1] = 1
print(b.nonzeros())
c=a+b
print(c)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to add the components of each vector pairwise, and return a <code>SparseVector</code> object:</p>
<pre><code>class SparseVec:

    def __init__(self, dimension):
        self.dimension = dimension
        self.data = {}

    def __str__(self):
        return 'Sparse Vector {}'. format(self.data)

    def __len__(self):
        return self.dimension    # what matters is the size of the vector, not the length of the stored data

    def __getitem__(self, key):
        assert isinstance(key, int)
        assert 0 &lt;= key &lt; self.dimension, 'the key must be compatible with the vector dimension' 
        try:
            return self.data[key]
        except KeyError:
            return 0     # must return zero if valid key but no entry

    def __setitem__(self, key, val):
        assert isinstance(key, int)
        assert 0 &lt;= key &lt; self.dimension, 'this vector does not have an appropriate dimension'
        if val != 0:     # avoid cluttering with zero values
            self.data[key] = val

    def purge_zeros(self):  # &lt;-- resparsifies a vector by purging the zero values
        nonzerodict = {}
        for key, val in self.data.items():
            if val != 0:
                nonzerodict[key] = val
        self.data = nonzerodict

    def __add__(self, other):
        assert self.dimension == other.dimension, 'vectors must have the same dimension'
        resulting_vector = SparseVec(self.dimension)
        c = {k:v for k, v in self.data.items()}  # &lt;-- copies self data
        for k, v in other.data.items():
            try:
                c[k] += v
            except KeyError:
                c[k] = v
        resulting_vector.data = c
        resulting_vector.purge_zeros()
        return resulting_vector
</code></pre>
<h3>tests:</h3>
<pre><code>a = SparseVec(4)
b = SparseVec(4)
a.data = {0: 2, 1: 1}
b.data = {0: -2, 1: 2, 2: 4}
print(a + b)
print(a[0], a[1], a[2], a[3])
print(b[0], b[1], b[2], b[3])
a[3] = -3
print(a[0], a[1], a[2], a[3])
</code></pre>
<h3>output:</h3>
<pre><code>Sparse Vector {1: 3, 2: 4}
2 1 0 0
-2 2 4 0
2 1 0 -3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Overloading a class method is essentially writing a method that would usually be handled by a default method in Python and replacing it with your own method for that class.</p>
<p>This is the default add method from Python 3 docs:
<a href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="nofollow noreferrer">https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types</a> </p>
<p>I'm not sure on why you are using a dict for this rather than a list without more context, but the following should work:</p>
<pre><code>c = a.add(b)
print(c)
</code></pre>
<p>a is an instance of the SparseVec class, so in order to access the <strong>add</strong> method we call a.add() and pass in the other object we wish to add to it.</p>
</div>
<span class="comment-copy">Thank you for the code. Can you explain what you mean by on <b>len</b> "It is the size of the vector that matters not the length"? Excuse my knolwedge, I thought the size and length are the same?</span>
<span class="comment-copy">What if the sparse vectors are different sizes like SparseVec (4) and SparseVec (5)</span>
<span class="comment-copy">Vector addition is not well defined for vectors of different dimensions: what does <code>[1 2 3 4] + [9 8 7]</code> mean, and what is the result?</span>
<span class="comment-copy">answering your first comment: It is a sparse vector, the length of the stored data may not reflect the dimension of the vector. The length value provided at initialization is the only way to access the true dimension of a <code>SparseVector</code> as defined above.</span>
<span class="comment-copy">I renamed <code>length</code> to <code>dimension</code>, and also changed the word <code>size</code> to <code>dimension</code> in the comments, and error messages; I think it makes things more clear.</span>
<span class="comment-copy">I wanted to use dictionary only to process nonzero values because the list is sparse vector.</span>
