<div class="post-text" itemprop="text">
<p>For a 2D list [["bacon", "banana"], ["ham", "salami", "cheese"]] I want to iterate through as "bacon", then "banana", then "ham" etc.</p>
<pre><code>sandwiches = [["bacon", "banana"], ["ham", "salami", "cheese"]]
preferences = ["bacon", 5, "ham", -2, "salami", 1]
</code></pre>
<p>In the sandwiches array, there are 2 sandwiches, bacon+banana and ham+salami+cheese. I want to know the score for each sandwich by doing something like this (doesn't work but shows what I'd like to do):</p>
<pre><code>sandwichscores = [0 for i in sandwiches]
sandwichscores = [+preferences[preferences.index(j)+1] for j in i in sandwiches if
j in preferences]
</code></pre>
<p>But of course for j in i in sandwiches doesn't work. I've tried messing around with the order of the fors and ins but haven't gotten anywhere. How could this be done?</p>
<p>For instance, the output I want here would be:</p>
<pre><code>sandwichscores = [5, -1]
</code></pre>
<p>Since the ingredients have a combined score of 5 in the first sandwich and -1 in the second. The ingredients that aren't in the preferences get ignored.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a one-liner that does what you want; I converted your preferences list into <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">a dictionary</a> because that is a <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict" rel="nofollow noreferrer">much more suitable data structure when you are storing key/value pairs</a>:</p>
<pre><code>sandwiches = [["bacon", "banana"], ["ham", "salami", "cheese"]]
prefs = {"bacon": 5, "ham": -2, "salami": 1}

scores = [ [ ", ".join(i), sum( prefs[j] for j in i if j in prefs) ] for i in sandwiches ]
print(scores)
</code></pre>
<p>Output:</p>
<pre><code>[['bacon, banana', 5], ['ham, salami, cheese', -1]]
</code></pre>
<p>The solution uses <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum</code></a> to add up the values of the sandwich ingredients, which are filtered by whether or not the ingredient appears in <code>prefs</code>.</p>
<p>You can change the output format to remove the list of ingredients and just output the score by altering the <code>[ ", ".join(i), sum( prefs[j] for j in i if j in prefs) ]</code> part. I would have assumed it was important to know which sandwich got which score, but who knows!</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is the logic you want to use, unpacked into a nested for loop:</p>
<pre><code>for i, sandwich in enumerate(sandwiches):
    for filling in sandwich:
        if filling in preferences:
            sandwichscores[i] += preferences[preferences.index(filling)+1]
</code></pre>
<p></p>
<pre><code>print(sandwichscores)
&gt;&gt;&gt; [5, -1]
</code></pre>
<p>As i alarmed alien says, the logic is much simpler if you use a dictionary for the scores:</p>
<pre><code>preferences = {'bacon':5,'ham':-2,'salami':1}

#...

for i, sandwich in enumerate(sandwiches):
    for filling in sandwich:
        sandwichscores[i] += preferences.get(filling, 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's one liner using <code>groupby</code>:</p>
<pre><code>from itertools import groupby

sandwiches = [["bacon", "banana"], ["ham", "salami", "cheese"]]
preferences = ["salami", 999, "bacon", 5, "ham", -2, "banana", 1000]

l = [(v, sum(i[-1] for i in g)) for v, g in groupby(((sandwich, preferences[preferences.index(p)+1]) for sandwich, prefs in zip(sandwiches, [preferences[::2]] * len(sandwiches)) for p in prefs if p in sandwich), key=lambda v: v[0])]
print(l)
</code></pre>
<p>Prints:</p>
<pre><code>[(['bacon', 'banana'], 1005), (['ham', 'salami', 'cheese'], 997)]
</code></pre>
<p>For sandwich <code>['bacon', 'banana']</code>: Bacon has 5, banana has 1000, sandwich score is 1005</p>
<p>For sandwich <code>['ham', 'salami', 'cheese']</code>: Ham has -2, salami has 999, sanwich score is 997</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionary</a> for the score lookup - it is the designated datastructure for lookups. </p>
<p>You can go from your representation of <code>preferences</code> to a dictionary with a dict-comprehension:</p>
<pre><code>preferences = ["bacon", 5, "ham", -2, "salami", 1]

prefs = {k:v for k,v in zip(preferences[::2],preferences[1::2])} # dict-comprehension
</code></pre>
<p>This uses <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer">zip()</a> to join every 2nd element starting at 0 <code>["bacon","ham","salami"]</code> to every 2nd element starting at 1 <code>[5,-2,1]</code> resulting in a zip-generator of <code>(("bacon,5),("ham",-2),("salami",1))</code>. </p>
<p>The zip-generator-result is then decomposed into <code>key:value</code> pairs that create the dict.</p>
<hr/>
<p>With that out of the way, you can calculate your sums like so:</p>
<pre><code>sandwiches = [["bacon", "banana"], ["ham", "salami", "cheese"]]
prefs = {"bacon": 5, "ham": -2, "salami": 1}

score = [ (sandw, sum( prefs.get(ingred,0) 
                       for ingred in sandw)) 
          for sandw in sandwiches ]

print(score) 
</code></pre>
<p>The <code>score</code> sums up each ingredients score for each sandwinch you defined. If an ingredient is not found, 0 is added instead.</p>
<p>The output is a tuple of the sandwich and its score: </p>
<pre><code> [(['bacon', 'banana'], 5), (['ham', 'salami', 'cheese'], -1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is another way in which you can do it, although I changed the structure of <code>preferences</code> to dictionary, which is more practical and easier to utilize:</p>
<pre><code>sandwiches = [["bacon", "banana"], ["ham", "salami", "cheese"]]
preferences = {"bacon" : 5, "ham" : -2, "salami" : 1}

scores = [sum(preferences.get(ingredient,0) for ingredient in sandwich) for sandwich in sandwiches]
print(scores)
</code></pre>
<p>Output:</p>
<pre><code>[5, -1]
</code></pre>
</div>
<span class="comment-copy">You would be better off with a dictionary for your preferences: <code>preferences = { 'bacon' : 5, 'ham' : -2 }</code></span>
<span class="comment-copy">It's unclear what you're asking.  What comes after "bacon" and "banana" in the iteration?  Is it "ham" "salami" "cheese" or something else?  It's also unclear what output you want.</span>
<span class="comment-copy">The order doesn't matter as long as each element iterates once.</span>
<span class="comment-copy">Actually it does matter sorry, I've hopefully cleared up the ambiguity of the order I want.</span>
<span class="comment-copy">To be clear, do you want to generate the scores for bacon/ham, bacon/salami, bacon/cheese, banana/ham, banana/salami, banana/cheese?</span>
<span class="comment-copy"><code>dict.get(key, 0)</code> is shorter then <code>prefs[j] for ... if j in prefs</code></span>
<span class="comment-copy">@PatrickArtner Great observation!</span>
<span class="comment-copy">its what I used ;)</span>
<span class="comment-copy">@PatrickArtner I hope the OP will take inspiration from both of our answers and investigate the amazing power of dictionaries further. ;D</span>
<span class="comment-copy">This works but I want it more elegant :)</span>
<span class="comment-copy">@Leosha define 'more elegant' - this is the same runtime as the logic in your attempt. If you mean 'shorter', the code is very readable as it is, which seems like a benefit - trying to fit all of this logic into a one line list comprehension caused you difficulty.</span>
<span class="comment-copy">I enjoy making it short.</span>
<span class="comment-copy">How would you generate a dictionary from a text file? I've currently got:</span>
<span class="comment-copy">preferences = [line.translate({ord(c): "" for c in " "}).translate({ord(c): " " for c in ","}).split() for line in file1] (gets rid of the spaces and commas and makes a 2d list of the preferences) and then preferences = sum(preferences, []) (turns the 2d array into a 1d one)</span>
<span class="comment-copy">@Leosha this is another question. See my edit. You can create the dict directly when reading in your file or transform your current list to a dict (see edit). Comments are ill suited for <code>code</code>.</span>
