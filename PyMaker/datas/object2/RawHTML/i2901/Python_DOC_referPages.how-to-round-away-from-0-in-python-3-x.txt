<div class="post-text" itemprop="text">
<p>In Python 2 <a href="http://docs.python.org/2/library/functions.html#round" rel="noreferrer">rounding</a> is done away from <code>0</code>, so, for example, <code>round(0.5)</code> is <code>1.0</code>.<br/>
In Python 3.x, however, <a href="http://docs.python.org/3/library/functions.html#round" rel="noreferrer">rounding</a> is done toward the even choice, so <code>round(0.5)</code>  is <code>0</code>.<br/>
What function can I use in Python 3.x to get the old behavior?</p>
</div>
<div class="post-text" itemprop="text">
<p>If your code is not particularly performance sensitive, you can use the standard <code>decimal</code> library to achieve the result you want. <code>Decimal().quantize()</code> allows choosing the rounding method:</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP
result = float(Decimal(0.5).quantize(Decimal(0), rounding=ROUND_HALF_UP))
print(result)  # Will output 1.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To get the Python 2 rounding behavior in Python 3 for the one-argument form of <code>round()</code> you can use a custom function like this:</p>
<pre><code>def myround(n):
    if round(n + 1) - round(n) == 1:
        return float(round(n))
    return n + abs(n) / n * 0.5
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; myround(0.5)
1.0
&gt;&gt;&gt; myround(1.5)
2.0
&gt;&gt;&gt; myround(-0.5)
-1.0
&gt;&gt;&gt; myround(-1.5)
-2.0
&gt;&gt;&gt; myround(1)
1.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def round_up(x):
    aX = abs(x)
    return math.ceil(aX)*(aX/x)
</code></pre>
<p>This solution might work for you. </p>
<p>For x = -1.2 <code>round_up(x) = -2</code>, x = 2.3 <code>round_up(x) = 3</code> etc.</p>
<p>edit: this solution will crash for x = 0. you can change the return value to</p>
<pre><code>return math.ceil(aX)*(aX/x) if x is not 0 else 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Equivalent of Python 2.7 <code>round()</code> when rounding to an integer (one-parameter):</p>
<pre><code>import math
def py2round(x):
    if x &gt;= 0.0:
        return math.floor(x + 0.5)
    else:
        return math.ceil(x - 0.5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a possible solution I've come up with:</p>
<pre><code>import math

def round_away_from_zero(x):
    a = abs(x)
    r = math.floor(a) + math.floor(2 * (a % 1))
    return r if x &gt;= 0 else -r
</code></pre>
<p>Tests:</p>
<pre><code>round_away_from_zero(0.5)
# 1
round_away_from_zero(1.5)
# 2
round_away_from_zero(2.5)
# 3
round_away_from_zero(-0.5)
# -1
round_away_from_zero(-1.5)
# -2
round_away_from_zero(-2.5)
# -3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="https://github.com/python/cpython/blob/2.7/Objects/floatobject.c#L1109" rel="nofollow noreferrer">CPython source code</a>,</p>
<blockquote>
<p>The basic idea is very simple: convert and round the double to a
  decimal string using _Py_dg_dtoa, then convert that decimal string
  back to a double with _Py_dg_strtod.  There's one minor difficulty:
  Python 2.x expects round to do round-half-away-from-zero, while
  _Py_dg_dtoa does round-half-to-even.  So we need some way to detect and correct the halfway cases.</p>
</blockquote>
<p>If you care about the performance, consider copying the relevant C code and import as an extension. But if you don't care, here's a Python implementation:</p>
<pre><code>def myround(a):
    num = str(a)
    num = str.split('.', 1)
    if int(num[1][0]) &gt;= 5:
        return int(num[0]) + 1 if a &gt; 0 else int(num[0]) - 1
    else:
        return int(num[0]) - 1 if a &gt; 0 else int(num[0]) + 1
</code></pre>
</div>
<span class="comment-copy">Do you really want the Python 2 rounding behaviour? The behaviour is pretty complex <a href="https://stackoverflow.com/a/22155830/6260170">stackoverflow.com/a/22155830/6260170</a></span>
<span class="comment-copy">You should make clear that you're referring only to rounding of values ending in <code>.5</code>.</span>
<span class="comment-copy">if you want to get -1 for x = -1.2 just use math.ceil function</span>
