<div class="post-text" itemprop="text">
<p>I am getting an UnboundLocalError despite the variable being declared in the global scope. It seems as if the variable is assumed/forced to be a local variable for this specific statement.</p>
<p>I can't figure out why variables within if statement conditions would be treated differently. Could someone explain what's going on?</p>
<p>The following snippet is a simplified example of what I was trying to do:</p>
<pre><code>In [1]:  global mock
...      mock = False
...
...
...      def foo():
...          if not mock:
...              # do stuff
...              mock = True
...
...          # do other stuff
...
...
...      foo()
</code></pre>
<p>This throws an UnboundLocalError, despite the global bool declared right above the function declaration.</p>
<pre><code>---------------------------------------------------------------------------
UnboundLocalError                         Traceback (most recent call last)
&lt;ipython-input-31-540737067cb1&gt; in &lt;module&gt;()
      7 
      8 
----&gt; 9 foo()

&lt;ipython-input-31-540737067cb1&gt; in foo()
      3 
      4 def foo():
----&gt; 5     if not mock:
      6         mock = True
      7 

UnboundLocalError: local variable 'mock' referenced before assignment
</code></pre>
<p>However, this snippet runs as expected:</p>
<pre><code>In [2]:  mock = False
...
...
...      def bar():
...          return mock
...
...
...      bar()

Out[2]:  False
</code></pre>
<p>Similarly, this snippet with the variable in the body of an if statement also runs as expected:</p>
<pre><code>In [3]:  mock = False
...
...
...      def foobar():
...          if True:
...              return mock
...
...          return True
...
...
...      foobar()

Out[3]:  False
</code></pre>
<p>I found the following article on scopes and namespaces in the docs (<a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces</a>) but I feel that it should work as expected based on the following,</p>
<blockquote>
<p>Although scopes are determined statically, they are used dynamically. At any time during execution, there are at least three nested scopes whose namespaces are directly accessible:</p>
<ul>
<li>the innermost scope, which is searched first, contains the local names</li>
<li>the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contains non-local, but also non-global names</li>
<li>the next-to-last scope contains the current moduleâ€™s global names</li>
<li>the outermost scope (searched last) is the namespace containing built-in names</li>
</ul>
</blockquote>
<p>I was using Jupyter 4.4.0 with Python 3.6.6 and IPython 6.5.0 within Conda on Windows 10, but I am able to reproduce this behaviour with console IPython, and IDLE 3.6.0 GUI running Python 3.6.0.</p>
<p>Edit: Somehow the following snippet isn't affected? It seems like this is tied to updating the variable within the same. I feel like I must be missing something trivial at this point.</p>
<pre><code>In [4]:  global mock # also works without this line
...      mock = False
...
...
...      def foo1():
...          if not mock:
...              return mock
...
...          return True
...
...
...      foo1()

Out[4]:  False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>variables are function scoped. because there's an assignment within the function to the name <code>mock</code>, all references to <code>mock</code> are attempted as "local" (they actually get compiled to a different opcode!)</p>
<p>you can change this by using <code>global mock</code> in the function (so the assignment and reference are forced to <em>global</em>)</p>
<pre><code>def foo():
    global mock
    if not mock:
        mock = true
</code></pre>
<p>Note that in your first example you wrote <code>global mock</code> at the module scope -- this does nothing :)</p>
<p>It may make more sense to look at the disassembly directly:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def f():
...     if not mock:
...         mock = True
...
&gt;&gt;&gt; dis.dis(f)
  2           0 LOAD_FAST                0 (mock)
              3 POP_JUMP_IF_TRUE        15

  3           6 LOAD_GLOBAL              0 (True)
              9 STORE_FAST               0 (mock)
             12 JUMP_FORWARD             0 (to 15)
        &gt;&gt;   15 LOAD_CONST               0 (None)
             18 RETURN_VALUE
&gt;&gt;&gt; def g():
...     global mock
...     if not mock:
...         mock = True
...
&gt;&gt;&gt; dis.dis(g)
  3           0 LOAD_GLOBAL              0 (mock)
              3 POP_JUMP_IF_TRUE        15

  4           6 LOAD_GLOBAL              1 (True)
              9 STORE_GLOBAL             0 (mock)
             12 JUMP_FORWARD             0 (to 15)
        &gt;&gt;   15 LOAD_CONST               0 (None)
             18 RETURN_VALUE
</code></pre>
</div>
<span class="comment-copy">If you found this answer useful or the solution, click the green check mark.</span>
