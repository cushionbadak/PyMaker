<div class="post-text" itemprop="text">
<p>Recently i working on raspberry pi 3(OS raspbian) with OPENCV + PYTHON to detect face on live camera. And I see detected face on raspberry pi3 use opencv very slow, about 4 - 5 FPS/s. So I wonder can I use MultiThread or MultiProcessing to speed up the FPS and if yes, how can i do that?</p>
<p>Please help me, any idea will appreciate. Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>update. I use separate thread to capture image from camera and I don't see any speed up of FPS compare to serial... Please see my code.</p>
<pre><code>import threading
import time
import cv2
import numpy as np
class myThread (threading.Thread):
    def __init__(self, src):
        print("thread -------------init-------------")
        threading.Thread.__init__(self)
        self.cap = cv2.VideoCapture(src)
        self.stop = False
    def run(self):
        while(self.stop == False):
            self.ret, self.frame = self.cap.read()

    def Stop(self):
        self.cap.release()
        self.stop = True

    def read(self):
        return self.ret, self.frame

recognizer = cv2.face.LBPHFaceRecognizer_create()
recognizer.read('trainer/trainer.yml')
cascadePath = "haarcascade_frontalface_default.xml"
faceCascade = cv2.CascadeClassifier(cascadePath);

thread = myThread(0)
thread.start()
time.sleep(1)

start = time.time()
frames = 0
font = cv2.FONT_HERSHEY_SIMPLEX
cap = cv2.VideoCapture(0)
while(True):
    ret, frame = thread.read()
    frame = cv2.resize(frame, (640, 480))
    frames += 1
    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
    faces = faceCascade.detectMultiScale(gray, 1.2, 5)
    for(x,y,w,h) in faces:
        # Create rectangle around the face
        cv2.rectangle(frame, (x-20,y-20), (x+w+20,y+h+20), (0,255,0), 4)
        Id, con = recognizer.predict(gray[y:y+h,x:x+w])
        print(Id, con)

        # Check the ID if exist
        if(con &lt; 60):
            if(Id == 1):
                Id = "HUY"
            if(Id == 2):
                Id = "HOA"
        #If not exist, then it is Unknown
        else:
            #print(Id)
            Id = "Unknow"

        # Put text describe who is in the picture
        cv2.rectangle(frame, (x-22,y-90), (x+w+22, y-22), (0,255,0), -1)
        cv2.putText(frame, str(Id), (x,y-40), font, 2, (255,255,255), 3)  

    if cv2.waitKey(10) &amp; 0xFF == ord('q'):
        thread.Stop()
        break
    cv2.imshow("frame", frame) 
end = time.time()
second = end - start
print("second:", + second)
print(frames/second)
cv2.destroyAllWindows()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can multithread the process. 
Use the <a href="https://docs.python.org/2/library/threading.html" rel="nofollow noreferrer">threading</a> library in python 2, or <a href="https://docs.python.org/3/library/_thread.html" rel="nofollow noreferrer">thread</a> in python 3.</p>
<p>Here is a simple example.</p>
<p>Besides your main thread,</p>
<p>Have one thread only operating the camera and constantly updating the latest frame, which is global in this case.</p>
<pre><code>def camera_thread():       
    cam = cv2.VideoCapture(1)
    _ret, self.image = cam.read()
    cv2.imshow('camera', self.image)
</code></pre>
<p>A second thread can run the inference from the model using the latest frame.</p>
<p>An optional third could perhaps draw a bounding box over the face, or perform other operations etc.</p>
<p>You might need mutex locks in between 2nd and 3rd threads in this case as you can only begin drawing boxes after you obtain an output from the model. This allows your 2nd thread to begin inference of the next frame without waiting for other threads. </p>
<p>The above example will result in a smooth video output with the inference lagging behind slightly. If you're not sure how multithreading works, I suggest reading up on the basics first. </p>
</div>
<span class="comment-copy">First thanks for your anwser. But following search google i see they said <code>The Python Global Interpreter Lock or GIL, in simple words, is a mutex (or a lock) that allows only one thread to hold the control of the Python interpreter. </code> This means that only one thread can be in a state of execution at any point in time. The impact of the GIL isnâ€™t visible to developers who execute single-threaded programs, but it can be a performance bottleneck in CPU-bound and multi-threaded code. And i think in python unneed use multithread right?? Sr im newbie python.</span>
<span class="comment-copy">GIL is not as bad as you might think. Yes it basically means python multithreads arent really run in parallel. But for this case, if all u wanted was higher fps from camera. It will work as both processes of capturing frames and model inferencing are 'concurrrent'. If you really want true multithreading, I suggest using C++ instead.</span>
<span class="comment-copy">Can i use multiprocessing instead of multithread. And if i use multithread using C++, it wound be speed up of FPS?</span>
<span class="comment-copy">I don't think multiprocessing can help here, as you need to access a shared image data. C++ multithreading could certainly help if you really wish to have the most optimal performance. But for simplicity, you should try and see if python threading could achieve what you're looking for here.</span>
