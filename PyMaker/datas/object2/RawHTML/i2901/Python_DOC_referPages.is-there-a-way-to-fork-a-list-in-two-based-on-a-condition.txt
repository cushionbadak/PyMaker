<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/949098/python-split-a-list-based-on-a-condition">Python: split a list based on a condition?</a>
<span class="question-originals-answer-count">
                    29 answers
                </span>
</li>
</ul>
</div>
<p>I have seen a pattern repeated a couple times in my team's code, it looks like this</p>
<pre><code>numbers = [1, 2, 3, 4]
even_numbers = [n for n in numbers if n % 2 == 0]
odd_numbers = [n for n in numbers if n % 2 != 0]
</code></pre>
<p>I was wondering if there is a function somewhere (I have looked around but haven't been able to find it) that would do something like this</p>
<pre><code>numbers = [1, 2, 3, 4]
even_numbers, odd_numbers = fork(numbers, lambda x: x % 2 == 0)
</code></pre>
<p>So, this function I am looking for, would receive an iterable and a function, and return two lists, one would be the values that match a provided condition, and the other would be the ones that didn't.</p>
<p>Is there something around python's standard library that achieves this?</p>
</div>
<div class="post-text" itemprop="text">
<p>I usually call this <code>sift</code>, but <code>partition</code> is fine too.</p>
<p>Another, itertools-less implementation might be</p>
<pre><code>def sift(iterable, predicate):
    t = []
    f = []
    for value in iterable:
        (t if predicate(value) else f).append(value)
    return (t, f)

even, odd = sift([1, 2, 3, 4, 5], lambda x: x % 2 == 0)
</code></pre>
<p>EDIT: for a slightly more complex implementation that is about 30% faster (on my Python installation anyway):</p>
<pre><code>def sift2(iterable, predicate):
    t = []
    f = []
    ta = t.append
    fa = f.append
    for value in iterable:
        (ta if predicate(value) else fa)(value)
    return (t, f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following function:</p>
<pre><code>from itertools import filterfalse, tee

def fork(pred, iterable):
    'Use a predicate to partition entries into false entries and true entries'
    t1, t2 = tee(iterable)
    return list(filterfalse(pred, t1)), list(filter(pred, t2))
</code></pre>
<p>Source: <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I did not find anything in standard library performing what you want. I suggest you this user-defined implementation, which is not optimized at all but very simple and easy to read:  </p>
<pre><code>def myFunc(iterable, func):

    first  = [i for i in iterable if func(i)]
    second = [i for i in iterable if not func(i)]

    return first,second


numbers = [1, 2, 3, 4]
even_numbers, odd_numbers = myFunc(numbers, lambda x: x % 2 == 0)

print(even_numbers) # [2, 4]
print(odd_numbers)  # [1, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Full code following @jonrsharpe suggestion.</p>
<pre><code>import itertools

def fork(iterable):
    "Returns list of even, odd elements of a list"
    t1, t2 = itertools.tee(iterable)
    pred = lambda i: i % 2 == 0
    return list(filter(pred, t2)), list(itertools.filterfalse(pred, t1))

odd, even = fork([1,2,3,4,5])
print(odd)
print(even)
</code></pre>
<p>Alternative numpy version which might be faster for big arrays</p>
<pre><code>import numpy as np

def fork(iterable):
    "Returns array of even, odd elements of an array"
    iterable_array = np.asarray(iterable)
    mask = (iterable_array % 2 == 0)
    return iterable_array[~mask], iterable_array[mask]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create your own function:</p>
<pre><code>l = [1, 2, 3, 4]
def fork(l,key):
   return list(filter(key,l)), [i for i in l if i not in list(filter(key,l))]
even_numbers, odd_numbers = fork(l, lambda x: x % 2 == 0)
print(even_numbers)
print(odd_numbers)
</code></pre>
<p>Output:</p>
<pre><code>[2, 4]
[1, 3]
</code></pre>
</div>
<span class="comment-copy">Normally this is called a "partition", there's a <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">recipe in <code>itertools</code></a> for it.</span>
<span class="comment-copy">I really like this implementation, I will mark it as the answer since it does not use itertools and iterates only once.</span>
<span class="comment-copy">using <code>timeit</code> suggests this takes quite a bit longer than the original approach for a list of 1000 items. <code>%timeit two_lists(lst) 186 µs ± 526 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code> vs <code>%timeit using_sift(lst) 290 µs ± 360 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code> though it does have an additional function call</span>
<span class="comment-copy">@roganjosh Yeah, that's probably the function call overhead. Can't do much about it for a generic solution.</span>
<span class="comment-copy">@AKX I'll modify the code a bit and time without function call over head. Well, if I can find an elegant way to balance the books a bit :)</span>
<span class="comment-copy">@roganjosh I also added a 30% faster implementation. :)</span>
