<div class="post-text" itemprop="text">
<p>Does <code>f.seek(500000,0)</code> go through all the first 499999 characters of the file before getting to the 500000th?
In other words, is <code>f.seek(n,0)</code> of order O(n) or O(1)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to be a bit more specific on what type of object <code>f</code> is.</p>
<p>If <code>f</code> is a normal <a href="https://docs.python.org/3/library/io.html" rel="nofollow noreferrer"><code>io</code> module</a> object for a file stored on disk, you have to determine if you are dealing with:</p>
<ul>
<li>The raw binary file object</li>
<li>A buffer object, wrapping the raw binary file</li>
<li>A TextIO object, wrapping the buffer</li>
<li>An in-memory <code>BytesIO</code> or <code>TextIO</code> object</li>
</ul>
<p>The first option just uses the <a href="http://man7.org/linux/man-pages/man2/lseek.2.html" rel="nofollow noreferrer"><code>lseek</code> system call</a> to reposition the file descriptor position. If this call is O(1) depends on the OS and what kind of file system you have. For a Linux system with ext4 filesystem, <a href="https://stackoverflow.com/questions/21658364/is-lseek-o1-complexity"><code>lseek</code> is O(1)</a>.</p>
<p>Buffers just clear the buffer <a href="https://github.com/python/cpython/blob/2fc46979b8c802675ca7fd51c6f2108a305001c8/Modules/_io/bufferedio.c#L1259-L1306" rel="nofollow noreferrer">if your seek target is outside of the current buffered region</a> and read in new buffer data. That's O(1) too, but the fixed cost is higher.</p>
<p>For text files, things are more complicated as variable-byte-length codecs and line-ending translation mean you can't always map the binary stream position to a text position without scanning from the start. The implementation doesn't allow for non-zero current-position- or end-relative seeks, and does it's best to minimise how much data is read for absolute seeks. <a href="https://github.com/python/cpython/blob/2fc46979b8c802675ca7fd51c6f2108a305001c8/Modules/_io/textio.c#L2190-L2198" rel="nofollow noreferrer">Internal state shared with the text decoder</a> tracks a <a href="https://github.com/python/cpython/blob/2fc46979b8c802675ca7fd51c6f2108a305001c8/Modules/_io/textio.c#L2425-L2502" rel="nofollow noreferrer">recent 'safe point' to seek back to</a> and read forward to the desired position. Worst-case this is O(n). </p>
<p>The in-memory file objects are just long, addressable arrays really. Seeking is O(1) because you can just alter the current position pointer value.</p>
<p>There are legion other file-like objects that may or may not support seeking. How they handle seeking is implementation dependent.</p>
<ul>
<li><p>The <a href="https://docs.python.org/3/library/zipfile.html" rel="nofollow noreferrer"><code>zipfile</code> module</a> supports seeking on zip files opened in read-only mode, and seeking to a point that lies before the data section covered by the current buffer requires a full re-read and decompression of the data up to the desired point, seeking after requires reading from the current position until you reach the new. The <a href="https://docs.python.org/3/library/gzip.htmlhttps://docs.python.org/3/library/gzip.html" rel="nofollow noreferrer"><code>gzip</code></a>, <a href="https://docs.python.org/3/library/lzma.html" rel="nofollow noreferrer"><code>lzma</code></a> and <a href="https://docs.python.org/3/library/bz2.html" rel="nofollow noreferrer"><code>bz2</code></a> modules all use the same shared implementation, that also starts reading from the start if you seek to a point before the current read position (and there's no larger buffer to avoid this). </p></li>
<li><p>The <a href="https://docs.python.org/3/library/chunk.html" rel="nofollow noreferrer"><code>chunk</code> module</a> allows seeking within the chunk boundaries and delegates to the underlying object. This is an O(1) operation if the underlying file seek operation is O(1).</p></li>
</ul>
<p>Etc. So, <em>it depends</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It would depend on the implementation of f.  However, in normal file-system files, it is O(1).</p>
<p>If python implements f on text files, it could be implemented as O(n), as each character may need to be inspected to manage cr/lf pairs correctly.</p>
<ul>
<li>This would be based on whether <code>f.seek(n,0)</code> gave the same result as a loop of reading chars, and (depending on OS) cr/lf were shrunk to lf or lf expanded to cr/lf </li>
</ul>
<p>If python implements f on a compressed stream,  then the order would b O(n), as decompression may require some working of blocks, and decompression.</p>
</div>
<span class="comment-copy"><code>However, in normal file-system files, it is O(1).</code> This seems very wrong.</span>
<span class="comment-copy">@ninesalt: why is that wrong? It's OS dependent.</span>
<span class="comment-copy">Time should not depend on <code>n</code> in terms of big-O, however, I'd expect if <code>n</code> is close enough to the current offset, seek would not cause any disk access.</span>
<span class="comment-copy">@mksteve: I was wrong, <code>zipfile.ZipFile</code> does support seeking when reading, and it'll try to satisfy that from the current buffer. If it can't it'll seek back to compression section start and re-read data until it reaches the desired position.</span>
<span class="comment-copy"><code>seek</code> itself is almost certainly O(1), because any further work can (and should) be delayed until a read or write actually <i>needs</i> the new file position. No sense doing an O(N) operation if the next operation on the file is a close.</span>
