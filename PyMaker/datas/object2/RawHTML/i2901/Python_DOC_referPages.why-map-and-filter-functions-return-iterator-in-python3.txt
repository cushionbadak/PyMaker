<div class="post-text" itemprop="text">
<p>Why map and filter functions return iterator in python3 whereas reduce returns fold operation itself? What all performance/memory gains we get with returning iterator?</p>
<p>Map returns "map" object:</p>
<pre><code>&gt;&gt;&gt; numbers = [1,2,3,4,5]
&gt;&gt;&gt; map(lambda x:x*x , numbers)
&lt;map object at 0x103e01f28&gt;
</code></pre>
<p>Reduce returns me directly the result of fold operation itself</p>
<pre><code>&gt;&gt;&gt; words = ['apple', 'pineapple', 'pear', 'mango']
&gt;&gt;&gt; reduce(lambda word1,word2: word1 if len(word1) &gt; len(word2) else word2 ,words)
'pineapple'
</code></pre>
<p>Whereas filter again returns "filter: object:</p>
<pre><code>&gt;&gt;&gt; numbers = [1,2,3,4,5]
&gt;&gt;&gt; filter(lambda x:x%2 == 0,numbers)
&lt;filter object at 0x103e07c18&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason <code>map</code> and <code>filter</code> operations return a (lazy) iterable is that sometimes there is no need for the list to be allocated. Generating a list requires calculating all results, as well as allocating memory which may be useless.</p>
<hr/>
<p><strong>Useless allocation of memory:</strong></p>
<pre><code>sum(map(math.pow, range(10), repeat(2)))
</code></pre>
<p>Because <code>sum</code> is effectively a partial <code>reduce(operator.add, iterator, 0)</code> there is no need to hold the entire data. In this example, if map would create a list it would allocate memory needlessly. Also, if the list doesn't fit in memory it wouldn't work (unlike the lazy version). See this example which would blow up in python2 but works in python3 because of laziness:</p>
<pre><code>any(map(math.sqrt, range(99999999999999999999)))
</code></pre>
<hr/>
<p><strong>Useless calculation of results:</strong></p>
<pre><code>def is_odd(n):
    return n % 2

first_odd = next(filter(is_odd, range(10)))
</code></pre>
<p>In this example, if <code>filter</code> would calculate all results, it would then throw away almost the entire list since only the first odd number (1) is interesting. In this case only <code>0 % 2</code> and <code>1 % 2</code> are actually calculated. This saves CPU in this case, but can reduce IO and memory consumption in many real-life examples.</p>
<hr/>
<p>When you need the results, it is up to you to collect them in any way you want. The collection is separate from the calculations, which are implemented lazily via iterators since python3.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>filter</code> and <code>map</code> return iterators. You can convert them to lists by wrapping in list</p>
<pre><code>numbers = [1,2,3,4,5]
list(map(lambda x:x*x , numbers))
# [1, 4, 9, 16, 25]
</code></pre>
<hr/>
<p>Why is there no consistency with <code>reduce</code>? Because <code>reduce</code> returns a single value. It would make no sense for it to return an iterator. </p>
<hr/>
<p>Why do <code>map</code> and <code>filter</code> not return a list? Well, they used to, but then it was changed for python 3, and for good reason. <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow noreferrer">Lazy iterators</a> are useful because we aren't creating a new list of <code>N</code> values every time we use one. This means they can be used in sequence like</p>
<pre><code>map(operator.truediv, filter(lambda t: t[1] != 0, zip(itr1, itr2)))
</code></pre>
<p>without the creation of unnecessary large blocks of data. </p>
<hr/>
<p>To answer the question in the comments:</p>
<p>No, <code>map</code> is not only applied after <code>filter</code> has completed in the example above. Proof:</p>
<pre><code>def verbose_count():
   i = 0
   while True:
       print(f'generating {i}')
       yield i
       i += 1

itr = map(lambda x: x * x, filter(lambda x: x % 2 == 0, verbose_count()))


next(itr)
generating 0
Out[2]: 0

next(itr)
generating 1
generating 2
Out[3]: 4
</code></pre>
<p>As you can see I can get outputs of a <code>filter -&gt; map</code> sequence when I haven't passed all the values in (I even passed an infinite generator that will never complete).</p>
</div>
<span class="comment-copy">No, <code>reduce()</code> returns the result of the fold operation.</span>
<span class="comment-copy">why, why cant map and filter return the result of map and filter operations?</span>
<span class="comment-copy">They <i>do</i> return the result, as an iterator. See e.g. <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="nofollow noreferrer">docs.python.org/3/whatsnew/â€¦</a></span>
<span class="comment-copy">They do return the result. Its just lazy. Try <code>list(map(...))</code> and <code>list(fiter(...))</code></span>
<span class="comment-copy">Because they don't need to be a list.</span>
<span class="comment-copy">This looks like a complete answer that I was looking for. Though I am not sure how this optimisation of filter not calculating everything is implemented internally.</span>
<span class="comment-copy">@LokeshAgrawal It can be implemented with a simple generator. But the implementation doesn't matter.</span>
<span class="comment-copy">Thats true. I will check further how this can be implemented using generators.</span>
<span class="comment-copy">On thinking further I am not fully convinced with the point of "we aren't creating a new list", new list has to be created, because filter is an immutable operation and once filter is done completely then only map is getting applied. Isn't that correct?</span>
<span class="comment-copy">@LokeshAgrawal No. It is an immutable operation, but that doesn't prevent it from returning an iterator (why should it?). And as such, the filtering happens each time that <code>map</code> request a new item from the iterator - not all at once before <code>map</code> starts.</span>
<span class="comment-copy">@LokeshAgrawal See my edit</span>
<span class="comment-copy">Thanks @sepp2k for providing this insight "And as such, the filtering happens each time that map request a new item from the iterator - not all at once before map starts". This is useful.</span>
<span class="comment-copy">Thanks @FHTMitchell, this makes sense now. Thanks for completing the answer.</span>
