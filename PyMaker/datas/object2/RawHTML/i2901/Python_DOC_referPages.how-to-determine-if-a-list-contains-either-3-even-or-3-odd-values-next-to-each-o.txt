<div class="post-text" itemprop="text">
<p>How do you determine if a list contains either 3 even or 3 odd values all next to each other?</p>
<p>Example lists (True, False, True):</p>
<pre><code>[2, 1, 3, 5]
[2, 1, 2, 5]
[2, 4, 2, 5]
</code></pre>
<p>Closest code:</p>
<pre><code>evenOdd = []

while True: 
    try:
        n = int(input())
        evenOdd.append(n)
    except:
        break

for x in evenOdd:
   if x % 2 == 0:
       print("True")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is some code. This is considered more "pythonic" than iterating over indices--this iterates over consective-triples, using the <code>zip</code> function. This will give an error if the list has fewer than three items--you can add that error check. The <code>zip</code> function stops when one of the iterables runs out of values, which is exactly what we want here.</p>
<pre><code>def three_evens_or_odds(alist):
    for a, b, c in zip(alist, alist[1:], alist[2:]):
        if (((a &amp; 1) and (b &amp; 1) and (c &amp; 1)) or
            ((a &amp; 1 == 0) and (b &amp; 1 == 0) and (c &amp; 1 == 0))):
            return True
    return False

print(three_evens_or_odds([2, 1, 3, 5]))
print(three_evens_or_odds([2, 1, 2, 5]))
print(three_evens_or_odds([2, 4, 2, 5]))
</code></pre>
<p>Or, even shorter (borrowing an idea from @jdehesa which I should have thought of on my own, so upvote his answer as I did),</p>
<pre><code>def three_evens_or_odds(alist):
    for a, b, c in zip(alist, alist[1:], alist[2:]):
        if a &amp; 1 == b &amp; 1 == c &amp; 1:
            return True
    return False

print(three_evens_or_odds([2, 1, 3, 5]))
print(three_evens_or_odds([2, 1, 2, 5]))
print(three_evens_or_odds([2, 4, 2, 5]))
</code></pre>
<p>The printout from that is</p>
<pre><code>True
False
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noreferrer"><code>itertools.groupby()</code></a>:</p>
<pre><code>from itertools import groupby

def check_list(lst):
    for k, g in groupby(lst, key=lambda x: x % 2):
        if len(list(g)) == 3:
            return True
    return False    

print(check_list([2, 1, 3, 5]))  # True
print(check_list([2, 1, 2, 5]))  # False
print(check_list([2, 4, 2, 5]))  # True
</code></pre>
<p>This can be easily adjusted for any group size.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate through the list of numbers in blocks of three:</p>
<pre><code>def hasThreeContiguousEvenOrOdd(numbers):
    for i in range(len(numbers) - 2):
        a, b, c = numbers[i:i + 3]
        if a % 2 == 0 and b % 2 == 0 and c % 2 == 0:
            return True
        elif a % 2 == 1 and b % 2 == 1 and c % 2 == 1:
            return True
    return False

numbers1 = [2, 1, 3, 5]
numbers2 = [2, 1, 2, 5]
numbers3 = [2, 4, 2, 5]

print(numbers1, hasThreeContiguousEvenOrOdd(numbers1))
print(numbers2, hasThreeContiguousEvenOrOdd(numbers2))
print(numbers3, hasThreeContiguousEvenOrOdd(numbers3))
</code></pre>
<p>Output:</p>
<pre><code>[2, 1, 3, 5] True
[2, 1, 2, 5] False
[2, 4, 2, 5] True
</code></pre>
<p>If you want to be more idiomatic or "pythonic" you can improve the code and do for example something like this:</p>
<pre><code>def hasThreeContiguousEvenOrOdd(numbers):
    for a, b, c in zip(numbers, numbers[1:], numbers[2:]):
        if a % 2 == b % 2 == c % 2:
            return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One more short and generic solution:</p>
<pre><code>def consecutive_evenodd(lst, n=3):
    n_uplets = ( lst[i:i+n] for i in range(len(lst)-n+1) )
    return any( sum(el % 2 for el in n_uplet) % n == 0 for n_uplet in n_uplets )

# test
inputs = [[2, 1, 3, 5],                                                
          [2, 1, 2, 5],                                                
          [2, 4, 2, 5]] 

for lst in inputs:
    print(lst, consecutive_evenodd(lst))
</code></pre>
<p>output:</p>
<pre><code>[2, 1, 3, 5] True
[2, 1, 2, 5] False
[2, 4, 2, 5] True
</code></pre>
<p>Some explanation: The <code>sum(...)</code> part gives the number of odd number in each n-uplet. When all numbers are odd or even, this sum is equal to either <code>n</code> or zero. For the other cases, the result of the sum falls in-between. So, <code>sum(...) % n</code> is equal to <code>0</code> only when all the n-uplet numbers are either odd or even. </p>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for exact 3 of odd or even in a list of 4 element:</p>
<pre><code>def ex(l):
    return sum([1 if item%2 ==0 else -1 for item in l]) in [2, -2]


ex([2, 1, 3, 5]) # True
ex([2, 1, 2, 5]) # False
ex([2, 4, 2, 5]) # True
</code></pre>
<p>And if list length and number of odd or even elements are parameters you can change 2 and -2 to a parameter.</p>
</div>
<div class="post-text" itemprop="text">
<p>one way with two int counters:</p>
<pre><code>Time:  O(n)
space: O(1)
</code></pre>
<p>function:</p>
<pre><code>def chk(alist):
    odd=even=0
    for n in alist:
        if n % 2:
            odd += 1
            even = 0
        else:
            even += 1
            odd = 0
        if odd&gt;2 or even&gt;2:
            return True
    return False
</code></pre>
<p>3 lists from your example output <code>True</code> <code>False</code> <code>True</code>. (tested with python2)</p>
</div>
<div class="post-text" itemprop="text">
<p>Tried a simple way to do it. Maintain two flags for even and odd. If you find an even, increment the even flag and reset the odd flag, and vice versa. As soon as one flag's value becomes 3, you know you have found three in succession.</p>
<pre><code>evenodd = []

while True:
    try:
        n = int(input())
        evenodd.append(n)
    except:
        break

evenflag = 0
oddflag = 0
print(evenodd)

for number in evenodd:
    if number % 2 == 0:
        evenflag += 1
        oddflag = 0
    else:
        oddflag += 1
        evenflag = 0
    if evenflag == 3:
        print("Found 3 consecutive even numbers")
        break
    elif oddflag == 3:
        print ("Found three consecutive odd numbers")
        break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>zip</code> to create n element tuples (3 in our case), the use <code>all(map(lambda x: x%2, sl)</code> to find if all the 3 elements in the tuples are odd and then use <code>any</code> to check if there is atleast one match.</p>
<p>Using <code>any</code> and <code>all</code> would guarantee minimal number of odd or even checks needed </p>
<pre><code>&gt;&gt;&gt; n =3
&gt;&gt;&gt; three_odds_or_even = lambda lst: any(all(map(lambda x: x%2, sl)) or all(map(lambda x: not x%2, sl)) for sl in zip(*(lst[i:] for i in range(n))))
&gt;&gt;&gt; three_odds_or_even([2, 1, 3, 5])
True
&gt;&gt;&gt; three_odds_or_even([2, 1, 2, 5])
False
&gt;&gt;&gt; three_odds_or_even([2, 4, 2, 5])
True
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution using a simple <code>for</code> loop.</p>
<p>The idea is to maintain a list, whose values depend on whether elements in the input list are even or odd. Clear the list when you don't have a consecutive odd/even.</p>
<p>If at any point you have 3 items in your tracker list, the function returns <code>True</code>.</p>
<pre><code>L1 = [2, 1, 3, 5]
L2 = [2, 1, 2, 5]
L3 = [2, 4, 2, 5]

def even_odd_consec(x, k=3):
    lst = []
    for item in x:
        is_odd = item % 2
        if not (lst and (lst[-1] == is_odd)):
            lst.clear()
        lst.append(is_odd)
        if len(lst) == k:
            return True
    return False

even_odd_consec(L1, 3)  # True
even_odd_consec(L2, 3)  # False
even_odd_consec(L3, 3)  # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just checks that odd/even holds as long as the minimum sequence length requested, 3 in this case.</p>
<pre><code>def determine(list_, in_a_row=3):
    prv, cntr = None, 1
    for v in list_:
        cur = bool(v % 2)

        if prv is cur:
            cntr += 1
        else:
            cntr = 1
        prv = cur

        if cntr &gt;= in_a_row:
            return True   

    return False

dataexp = [
    ([2, 1, 3, 5],True),
    ([2, 1, 2, 5],False),
    ([2, 4, 2, 5],True),
    #hmmm, you're able to handle lists smaller than 3, right?
    ([],False),
    ]

for li, exp in dataexp:
    got = determine(li)
    msg = "exp:%s:%s:got for %s" % (exp, got, li)
    if exp == got:
        print("good! %s" % msg)
    else:
        print("bad ! %s" % msg)
</code></pre>
<p>output</p>
<pre><code>good! exp:True:True:got for [2, 1, 3, 5]
good! exp:False:False:got for [2, 1, 2, 5]
good! exp:True:True:got for [2, 4, 2, 5]
good! exp:False:False:got for []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>evenOdd=[]

while True:
    try:
        n=int(input())
        evenOdd.append(n)
    except:
        break

for x[0] in evenOdd:
   if x % 2 == 0:
       print("True")
for x[1] in evenOdd:
   if x % 2 == 0:
       print("True")
for x[2] in evenOdd:
   if x % 2 == 0:
       print("True")
</code></pre>
<p>Using list indices, you can test only specific items in a list. For example, <code>x[3]</code> would test the <em>4th item</em> in a list (<code>x[0]</code> is the first item in a list, <code>x[1]</code> second, etc.). So we use this method to test the first, second, and third items individually.</p>
</div>
<span class="comment-copy">exact 3 odd/even numbers?</span>
<span class="comment-copy">wouldn't <code>any(len(list(x))==3 for _, x in groupby([x%2 for x in lst]))</code> be more straightforward?</span>
<span class="comment-copy">this does not work in the general case.</span>
<span class="comment-copy">@Ev.Kounis This shouldn't <i>work in general case</i>! also 2 is a parameter of list length and number of elements , I just didn't parameterize that.</span>
<span class="comment-copy">Is this work for first example?</span>
<span class="comment-copy">@ᴀʀᴍᴀɴ yes, it worked here.</span>
<span class="comment-copy">This doesn't make sense. You're trying to use <code>x[0]</code> as a looping variable, and then you're treating <code>x</code> as a number, but <code>x</code> doesn't exist.</span>
