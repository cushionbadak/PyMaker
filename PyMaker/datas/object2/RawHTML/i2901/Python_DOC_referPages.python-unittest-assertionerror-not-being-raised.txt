<div class="post-text" itemprop="text">
<p>I am trying to write unit tests for my python package and I am finding that when I run the tests AssertionErrors are not being raised, when they should be. Here is a MWE:</p>
<p>In exampleModule.py I have:</p>
<pre><code>#! /usr/bin/env python                                                                                                                                                          
import unittest

class UnitTest(unittest.TestCase):

    def runTest(self):
        print("Starting test...")
        a = 4
        b = 5
        self.assertEqual(a,b)
        print("TEST COMPLETE")
        return
</code></pre>
<p>and in testError.py I have:</p>
<pre><code>#! /usr/bin/env python                                                                                                                                                          
import unittest

class AllTests(unittest.TestCase):

    def testExample(self):
        from exampleModule import UnitTest
        UT = UnitTest()
        UT.run()
        return

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>When I run testError.py I expect to see the AssertionError reported from the UnitTest in exampleModule.py, however, I simply see the following:</p>
<pre><code>&gt; ./testError.py
Starting test...
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
</code></pre>
<p>Why is the AssertionError not being raised? If I place the UnitTest() class in testError.py (i.e. have everything in the same file) then the AssertionError is raised. So why when UnitTest is stored in a different file does the error not get raised? </p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.run" rel="nofollow noreferrer"><code>TestCase.run()</code></a>
creates or updates a
<a href="https://docs.python.org/3/library/unittest.html#unittest.TestResult" rel="nofollow noreferrer"><code>TestResult</code></a>
object, on the assumption you intend to do something interesting with those results.
But you immediately throw them away:</p>
<pre><code>    UT.run()
</code></pre>
<p>Any failures or errors --- including exceptions raised --- would have been in that results object.
For example:</p>
<pre><code>def testExample(self):
    from exampleModule import UnitTest
    UT = UnitTest()
    result = UT.run()
    print('Errors:  {!r}'.format(result.errors))
    print('Failures:  {!r}'.format(result.failures))
    return
</code></pre>
<p>This prints:</p>
<blockquote>
<p><strong>Failures</strong>:  [(&lt;exampleModule.UnitTest testMethod=runTest&gt;, 'Traceback (most recent call last):\n  File "/home/kjc/tmp/exampleModule.py", line 11, in runTest\n    self.assertEqual(a, b)\n<strong>AssertionError: 4 != 5</strong>\n')]</p>
</blockquote>
<p>It catches all kinds of exceptions, like this example where I added <code>sys.exit()</code> before the assertion:</p>
<blockquote>
<p><strong>Errors</strong>:  [(&lt;exampleModule.UnitTest testMethod=runTest&gt;, 'Traceback (most recent call last):\n  File "/home/kjc/tmp/exampleModule.py", line 11, in runTest\n    import sys; sys.exit()\n<strong>SystemExit</strong>\n')]</p>
</blockquote>
<p>For the record, the one passing test your example produced is <code>testExample</code> itself.
You can verify this by calling <code>self.fail()</code> early in <code>testExample</code>.
(As one commentator said, calling unit tests <em>from</em> a unit test is a very strange thing to do.)</p>
<h2>One Solution</h2>
<p>You seem to want to run tests normally, but from multiple files.
If so, you can make a bunch of typical
<a href="https://docs.python.org/3/library/unittest.html#unittest.main" rel="nofollow noreferrer"><code>unittest.main()</code></a>-style
test modules, and then load them manually.
Your test-everything script would look something like this:</p>
<pre><code>#!/usr/bin/env python
import unittest


# Edit this to include new modules or TestCases to run.
_NAMES = ['testmoda', 'testmodb']  # testothermodule.SomeTestCase, etc...


def _main():
    suite = unittest.defaultTestLoader.loadTestsFromNames(_NAMES)
    unittest.TextTestRunner().run(suite)
    return  # WARNING: This always returns a successful exit value.


if __name__ == '__main__':
    _main()
</code></pre>
<p>Your test modules would be the usual one-or-more <code>TestCase</code>s, with conditional calls to <code>unittest.main()</code>, so each could be run independently:</p>
<pre><code>#!/usr/bin/env python
import unittest


class TestModA(unittest.TestCase):

    def testThatPasses(self):
        self.assertEqual(0, -0)
        return

    def testThatFails(self):
        self.assertEqual(0, float('inf'))
        return

    def testThatBlowsUp(self):
        raise RuntimeError('OMG!')
        return


if '__main__' == __name__:
    unittest.main()
</code></pre>
<p>If that's not fiddly enough for you, you can also read up on the
<a href="https://docs.python.org/3/library/unittest.html#unittest.TestLoader.discover" rel="nofollow noreferrer"><code>discover()</code> method</a>
or the module-level
<a href="https://docs.python.org/3/library/unittest.html#load-tests-protocol" rel="nofollow noreferrer"><code>load_tests</code> protocol</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The convention to structure unittests is like this:</p>
<p>Hold all tests in <code>tests</code> directory.</p>
<p>test module will be named as <code>test_modulea.py</code> with <code>class TestClassA</code></p>
<p><code>nosetests -vw tests</code> to run all tests.</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertRaises" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
<span class="comment-copy">Thanks @Gang -- so where do I put the call to assertRaises()? In my AllTests class? Is the context manager returned by the TestCase.run() call? If I am understanding correct, any error raised inside the UnitTest.runTest() function is ignored and simply stored in the context manager? Querying the context manager inside my UnitTest.runTest() function simply creates another AssertionError, that is also "ignored".</span>
<span class="comment-copy">it is meaningless to to test a unittest using another unittest.</span>
<span class="comment-copy">@Gang -- so how would I restructure my example such that I can have an individual test stored in a module, and have a script that calls all those tests and runs them using the main() function?</span>
<span class="comment-copy">do you means <code>nosetests</code> or <code>nose2</code> or <code>pytest</code>, they will discover and make tests without using the <code>__main__</code>?</span>
<span class="comment-copy">Great! Thanks for the explanation -- think I understand better now. Thanks also for your suggested solution!</span>
