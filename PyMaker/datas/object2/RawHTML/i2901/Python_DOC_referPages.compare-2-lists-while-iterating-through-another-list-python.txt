<div class="post-text" itemprop="text">
<p>I have a list <code>source</code> which represents nodes in a network graph. I iterate through the nodes in <code>source</code> to obtain a sub-list of neighbouring nodes. At the same time, all neighbouring nodes are compared against another list <code>watch_list</code>. </p>
<p>I want to create a separate list <code>adjacent</code> that specifies whether the node in <code>source</code> has a neighbour in <code>watch_list</code>. See the code below: </p>
<pre><code>import networkx as nx
import pandas as pd

source = ['A','C','B','D','G','C','B','G']
target = ['B','T','G','A','T','B','H','V']
weight = [2, 1, 6, 6, 3, 3, 2, 1]
watch_list = ['H','D','T']

df = pd.DataFrame([source,target,weight])
df = df.transpose()
df.columns = ['source','target','weight']
G = nx.from_pandas_edgelist(df,'source','target','weight') 

adjacent = []
for i in source:
    for j in list(nx.all_neighbors(G, i)):
        if j in watch_list:
            adjacent.append('Y')
        else: adjacent.append('N') 

print(adjacent)
</code></pre>
<p>Running this code returns the following list:</p>
<pre><code>&gt;&gt;&gt; ['N', 'Y', 'Y', 'N', 'N', 'N', 'N', 'Y', 'N', 'N', 'Y', 'N', 'Y', 'N', 'N', 'N', 'N', 'Y', 'N', 'Y', 'N']
</code></pre>
<p>The problem is that the code is iterating through the all the neighbours and appending 'Y' or 'N' with each iteration. </p>
<p>How can I control the flow to append 'Y' or 'N' only once, indicating that a node in <code>source</code> either has a neighbour on the <code>watch_list</code> ('Y'), or doesn't ('N'). </p>
<p>It seems like a simple flow-control question, but I can't seem to get it right. 
Any advice appreciated!    </p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any()</code></a> and check if any neighbour is in your <code>watch_list</code>:</p>
<pre><code>adjacent = []
for i in source:
    if any(x in watch_list for x in list(nx.all_neighbors(G, i))):
        adjacent.append('Y')
    else: 
        adjacent.append('N') 

print(adjacent)
</code></pre>
<p>Result:</p>
<pre><code>['Y', 'Y', 'Y', 'N', 'Y', 'Y', 'Y', 'Y']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This code produces a <code>'Y'</code> or <code>'N'</code> for each <code>j</code>:</p>
<pre><code>for j in list(nx.all_neighbors(G, i)):
    if j in watch_list:
        adjacent.append('Y')
    else: adjacent.append('N') 
</code></pre>
<p>If you just want to know if there is any <code>j</code> for which there is a neighbour, use <code>any</code>:</p>
<pre><code>is_there_any = any(j in watch_list
                   for j in list(nx.all_neighbors(G, i)))
if is_there_any:
    adjacent.append('Y')
else:
    adjacent.append('N')
</code></pre>
<p>Or, I would rather do simply this:</p>
<pre><code>adjacent = [any(j in watch_list
                for j in list(nx.all_neighbors(G, i)))
            for i in source]
# adjacent now holds booleans, rather than strings, but I think that is better
</code></pre>
</div>
