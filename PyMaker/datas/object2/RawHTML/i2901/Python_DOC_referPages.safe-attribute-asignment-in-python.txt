<div class="post-text" itemprop="text">
<p>I have a class representing parameter options for my algorithm. Creating an object initializes all options to some predefined values. I can then change a parameter by simply assigning a different value to the corresponding attribute:</p>
<pre><code>opts = AlgOptions()
opts.mutation_strength = 0.2
</code></pre>
<p>However, I sometimes make a mistake when typing the attribute name, for example:</p>
<pre><code>opts = AlgOptions()
opts.mutation_str = 0.2
</code></pre>
<p>Python just creates a different attribute and continues running, producing unexpected results which are difficult to debug.</p>
<p>Is there an elegant way to avoid this potential pitfall? It feels tedious to always double check all attribute names, compared to languages such as C# which would interpret this situation as an error. Few things come to my mind, but have some caveats:</p>
<p>1) I can make setter methods for parameters, but that seems like a lot of boilerplate code. That way if I try to invoke a method with a wrong name, I will get a meaningful excepion.</p>
<p>2) I can create a list of all attributes inside the class, and perform a check if there is any class attribute whose name is not in the list. However, I am not sure where and when would I perform the check, and it seems like a clumsy solution anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve this by using <a href="https://docs.python.org/3/reference/datamodel.html#slots" rel="nofollow noreferrer">slots</a>, which basically prevents creating of attributes not declared in <code>__init__</code>:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     __slots__ = ["bar", "baz"]
...     def __init__(self, bar, baz):
...         self.bar = bar
...         self.baz = baz
...
&gt;&gt;&gt; foo = Foo(1, 2)
&gt;&gt;&gt; foo.asdf = 1
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Foo' object has no attribute 'asdf'
&gt;&gt;&gt; foo.bar
1
&gt;&gt;&gt; foo.bar += 5
&gt;&gt;&gt; foo.bar
6
</code></pre>
<p>Note that using <code>__slots__</code> has some disadvantages discussed in the documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>So generally it's best to just avoid making typos ;) but here is one (slightly hacky) solution. Basically subclass the <code>NoSetAttr</code> class and use the <code>set_new_attr</code> method to set new attributes in the class.</p>
<pre><code>class NoSetAttr:
    def __setattr__(self, attr, value):
        getattr(self, attr)  # will raise error if not found
        super().__setattr__(attr, value)
    def set_new_attr(self, attr, value):
        super().__setattr__(attr, value)

class ExampleClass(NoSetAttr):
    def __init__(self, x):
        self.set_new_attr('x', x)

inst = ExampleClass(12)
inst.x  # 12
inst.x = 23
inst.x  # 23
inst.y = 2  # raises attribute error
</code></pre>
<p>You could probably turn the base class into a class decorator <code>@no_set_attr</code> and then annotate your classes which may be easier.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a possible way to allow only certain attributes to be set:</p>
<pre><code>class AlgOptions():

    def __str__(self):
        return str(self.__dict__)

    def __setattr__(self, k, v):
        allowed = ('mutation_strength',)
        if k in allowed:
            self.__dict__[k] = v
        else:
            raise AttributeError(f"attribute {k} not allowed")


opts = AlgOptions()
opts.mutation_strength = 0.2
try:
    opts.mutation_str = 0.2
except Exception as e:
    print('Sorry about this:', e)

print(opts)
</code></pre>
<p>Personally I would never use something like this on my code. I don't like these type of methods that try to "fight" the language... remember, python isn't c#. </p>
</div>
<span class="comment-copy">Thanks, this seems like a clean way to do it!</span>
<span class="comment-copy">Not part of the question, but you're <code>__str__</code> function is an awful solution. It will fail if you have set any attribute to something that isn't a <code>dict</code>, <code>list</code>, <code>float</code>, <code>int</code>, <code>float</code> or <code>None</code> (or if the former two contain anything that isn't). Why not just use <code>return str(self.__dict__)</code> if you want that behaviour?</span>
<span class="comment-copy">@FHTMitchell You're absolutely right. A lot of times when creating&amp;debugging these throwaway snippets i tend to use json.dumps instead favouring str+prettyprint. Usually when dealing with non-json serializable datatypes I'll write my own encoder/decoder or using another libraries for serialization. Anyway, with your suggestion you get rid of the json dependency in the snippet so I'll just change my answer, thanks to point it out, +1 ;)</span>
