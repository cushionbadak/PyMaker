<div class="post-text" itemprop="text">
<p>I have two lists of dictionaries:</p>
<pre><code>dict_list1 = [{'k1':1, 'k2':2}, {'k1':3, 'k2':4}]
dict_list2 = [{'k1':1, 'k2':2, 'k3':10}, {'k1':3, 'k2':4, 'k3':10}]
</code></pre>
<p>And now for each dict_x in dict_list1, I want to know if there is a dict_y on dict_list2 that contains every key,value from dict_x.</p>
<p>I cannot think of another way of doing this other then:</p>
<pre><code>for dict_x in dict_list1:
    for dict_y in dict_list2:
        count = len(dict_x)
        for key, val in dict_x.items():
            if key in dict_y and dict_y[key] == val:
                count -= 1
        if count == 0:
            print('YAY')
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>dict</code> views can perform quick "is subset" testing via the inequality operators. So:</p>
<pre><code>if dict_x.items() &lt;= dict_y.items():  # Use .viewitems() instead of .items() on Python 2.7
</code></pre>
<p>will only return true if every key/value pair in <code>dict_x</code> also appears in <code>dict_y</code>.</p>
<p>This won't change anything in terms of big-O performance, but it does make the code somewhat cleaner:</p>
<pre><code>for dict_x in dict_list1:
    for dict_y in dict_list2:
        if dict_x.items() &lt;= dict_y.items():
            print('YAY')
            break
</code></pre>
<p>Note that creating the views costs <em>something</em> (it's just a fixed cost, not dependent on <code>dict</code> size), so if performance matters, it may be worth caching the views; doing so for <code>dict_list1</code> is free:</p>
<pre><code>for dict_x in dict_list1:
    dict_x_view = dict_x.items()
    for dict_y in dict_list2:
        if dict_x_view &lt;= dict_y.items():
            print('YAY')
            break
</code></pre>
<p>but some eager conversions would be needed to cache both:</p>
<pre><code># Convert all of dict_list2 to views up front; costs a little if
# not all views end up being tested (we always break before finishing)
# but usually saves some work at the cost of a tiny amount of memory
dict_list2_views = [x.items() for x in dict_list2]
for dict_x in dict_list1:
    dict_x_view = dict_x.items()
    for dict_y_view in dict_list2_views:
        if dict_x_view &lt;= dict_y_view:
            print('YAY')
            break
</code></pre>
<p>You could also collapse the loop using <code>any</code> (which removes the need to <code>break</code> since <code>any</code> short-circuits), so the first (simplest) check could become:</p>
<pre><code>for dict_x in dict_list1:
    if any(dict_x.items() &lt;= dict_y.items() for dict_y in dict_list2):
       print('YAY')
</code></pre>
<p>This could be further collapsed to a single list comprehension that results in the various matches, but at that point the code is going to be pretty cramped/ugly:</p>
<pre><code>for _ in (dict_x in dict_list1 if any(dict_x.items() &lt;= dict_y.items() for dict_y in dict_list2)):
    print('YAY')
</code></pre>
<p>though without knowing what you'd really do (as opposed to just printing <code>YAY</code>) that's getting a little pointless.</p>
</div>
<div class="post-text" itemprop="text">
<p>Below, I use the fact that the <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer"><code>dict.items</code> view implements <code>set</code> operations</a> to check for each <code>d1.items()</code> if there exists a <code>d2.items()</code>, such that <code>d1.items()</code> is a subset of <code>d2.items()</code></p>
<pre><code>[any(d1.items() &lt;= d2.items() for d2 in dict_list2) for d1 in dict_list1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>any</code> and <code>all</code>:</p>
<pre><code>dict_list1 = [{'k1':1, 'k2':2}, {'k1':3, 'k2':4}]
dict_list2 = [{'k1':1, 'k2':2, 'k3':10}, {'k1':3, 'k2':4, 'k3':10}]
v = [any(all(c in i and i[c] == k for c, k in b.items()) for i in dict_list2)\
   for b in dict_list1]
</code></pre>
<p>Output:</p>
<pre><code>[True, True]
</code></pre>
</div>
<span class="comment-copy">Accepting @ShadowRanger answer because it is more complete.</span>
<span class="comment-copy">My current version returns a list the length of <code>dict_list1</code> representing whether or not some element of <code>dict_list2</code> is a superdict of the dict at that index in <code>dict_list1</code>.</span>
<span class="comment-copy">This only checks keys, not values.</span>
<span class="comment-copy">Also, doesn't it have multiple loops just put in a 1-liner?</span>
<span class="comment-copy">Yes, I supose there are 3 fors as well, but in one single line</span>
<span class="comment-copy">@PatrickHaugh Opps, see my recent edit.</span>
<span class="comment-copy">Try <code>dict_list1 = [{'k1':1, 'k2': None}]</code> and <code>dict_list2 = [{'k1':1}]</code>.</span>
