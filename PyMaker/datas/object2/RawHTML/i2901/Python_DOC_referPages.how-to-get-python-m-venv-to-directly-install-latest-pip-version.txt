<div class="post-text" itemprop="text">
<p>As part of the compilation step for a new python version, I fetch and run <a href="https://bootstrap.pypa.io/get-pip.py" rel="noreferrer"><code>get-pip.py</code></a>, to have the latest pip installed next to the python executable:</p>
<pre><code>$ /opt/python/3.7.0/bin/python --version
Python 3.7.0
$ /opt/python/3.7.0/bin/pip --version
pip 18.0 from /opt/python/3.7.0/lib/python3.7/site-packages/pip (python 3.7)
</code></pre>
<p>I have 25 such versions under <code>/opt/python</code>, although I mostly use the five latest versions of each major.minor version that is not EOL. To setup an invorment I used to run <code>virtualenv</code> or my <code>virtualenvutils</code> with the <code>-p /opt/python/X.Y.Z/bin/python</code> option to get a virtual environment with a specific version.</p>
<p>With Python 3.7 this gives the imp module deprecation warning:</p>
<pre><code>$ virtualenv -p /opt/python/3.7.0/bin/python /tmp/py37virtualenv
Running virtualenv with interpreter /opt/python/3.7.0/bin/python
Using base prefix '/opt/python/3.7.0'
/opt/util/virtualenvutils/lib/python3.6/site-packages/virtualenv.py:1041: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
  import imp
New python executable in /tmp/py37virtualenv/bin/python
Installing setuptools, pip, wheel...done.
</code></pre>
<p>I have little hope this will be solved in virtualenv, as this has had a <code>PendingDeprecationWarning</code> at least since 2014 (as can be seen from the output in <a href="https://stackoverflow.com/q/26550004/1307905">this question</a>)</p>
<p>While investigating replacing <code>virtualenv</code> with <code>python -m venv</code> in <code>virtualenvutils</code>, I first created a new <code>venv</code> based virtual environment by hand:</p>
<pre><code>$ /opt/python/3.7.0/bin/python -m venv /tmp/py37venv
$ /tmp/py37venv/bin/pip --version
pip 10.0.1 from /tmp/py37venv/lib/python3.7/site-packages/pip (python 3.7)
</code></pre>
<p>That has an old <code>pip</code> version! If you use it, you'll get:</p>
<blockquote>
<p>You are using pip version 10.0.1, however version 18.0 is available.<br/>
  You should consider upgrading via the 'pip install --upgrade pip' command</p>
</blockquote>
<p>In the virtual environment created with <code>virtualenv</code> you immediately get the latest version:</p>
<pre><code>$ /tmp/py37virtualenv/bin/pip --version
pip 18.0 from /tmp/py37virtualenv/lib/python3.7/site-packages/pip (python 3.7)
</code></pre>
<p>I can run a post-creation step:</p>
<pre><code>/tmp/py37venv/bin/pip install -U --disable-pip-version-check pip 
</code></pre>
<p>which will take extra time. And if there was a some security update for <code>pip</code>, this would imply running the non-secure version to get a secure version, an ideal point of attack.</p>
<p>From <code>virtualenvutils</code> it is trivial to do the multiple steps to create a <code>pip</code>-less virtualenv and then add <code>pip</code> using <code>get-pip.py</code>. From the command-line this is not so simple:</p>
<pre><code>$ /opt/python/3.7.0/bin/python -m venv --without-pip /tmp/py37venvnopip
$ /tmp/py37venvnopip/bin/python -c "from  urllib.request import urlopen; response = urlopen('https://bootstrap.pypa.io/get-pip'); open('/tmp/tmp_get_pip.py', 'w').write(response.read())"
$ /opt/python/3.7.0/bin/python /tmp/tmp_get_pip.py
......
$ /opt/python/3.7.0/bin/pip --version
</code></pre>
<p>pip 18.0 from /opt/python/3.7.0/lib/python3.7/site-packages/pip (python 3.7)</p>
<p>What is causing <code>/opt/python/3.7.0/bin/python -m venv</code> to take that old <code>pip</code> version? Is that the version available when 3.7.0 was released? </p>
<p>How can I update my install under <code>/opt/python/3.7.0</code> in some way so that using <code>/opt/python/3.7.0/bin/python -m venv</code> creates a virtualenv with the latest <code>pip</code> version without reverting to scripts, aliases or using multiple commands? Having the latest <code>pip</code> installed under <code>/opt/python/3.7.0</code> obviously is not enough.</p>
<p>There are two bundled wheels:</p>
<pre><code>/opt/python/3.7.0/lib/python3.7/ensurepip/_bundled/setuptools-39.0.1-py2.py3-none-any.whl
/opt/python/3.7.0/lib/python3.7/ensurepip/_bundled/pip-10.0.1-py2.py3-none-any.whl
</code></pre>
<p>I suspect I need to update those. Is there a better way than updating those by hand? Some option for <code>/some/python -m venv</code> would be nice.</p>
<p>(And running <code>/some/python -m ensurepip --upgrade</code> doesn't do the trick)</p>
<hr/>
<p>Running the deprecated <code>/opt/python/3.7.0/bin/pyvenv</code> has the same old <code>pip</code> version problem. </p>
</div>
<div class="post-text" itemprop="text">
<p>It is an expected behavior. <code>python -m venv</code> calls <code>python -m ensurepip</code> to install <code>pip</code> and <a href="https://stackoverflow.com/a/28210626/5588279">This answer</a> shows that <code>ensurepip</code> would only install the bundled version even with <code>--upgrade</code> option. There isn't any official option to update the bundled <code>pip</code> and <code>setuptools</code>.</p>
<p>Well I have also no good idea to fix this problem as it just is the designed behavior. I would like to give two suggestions:</p>
<ol>
<li><p>Use <code>pipenv</code>. It is really good! And it will be the next-generation official package manager in the future(Although there is a big problem related to current Pypi's structure. In short, a package manager can only decide the dependencies with downloading the whole package. This gives a huge difficulty to building dependencies graph.).</p></li>
<li><p>Implement your custom <code>EnvBuilder</code>, actually there is an <a href="https://docs.python.org/3/library/venv.html#an-example-of-extending-envbuilder" rel="nofollow noreferrer">official example</a> about this. And in the example, it also use <code>get-pip.py</code> to install the latest <code>pip</code>.</p></li>
</ol>
</div>
<span class="comment-copy">It looks like <a href="https://bugs.python.org/issue30628" rel="nofollow noreferrer">bugs.python.org/issue30628</a> refers to this issue, but the bugs site is currently down.</span>
<span class="comment-copy">To be able to proceed without warnings I ended up creating a <a href="https://bitbucket.org/ruamel/upgrade_ensurepip/src/default/upgrade_ensurepip.py" rel="nofollow noreferrer">single file utility</a> that downloads new .whl files in <code>_bundled</code> and updates <code>ensurepip/__init__.py</code>. Also available on <a href="https://pypi.org/project/upgrade-ensurepip/" rel="nofollow noreferrer">PyPI</a></span>
<span class="comment-copy">To manually upgrade run <code>python -m pip install --upgrade pip setuptools wheel</code> Do not just run <code>pip install</code> as it will create a shebang to whatever default pip you have</span>
<span class="comment-copy">Thanks for the envbuilder link, I'll look into that. <code>pipenv</code> has quite a bit of overlap with <code>virtualenvutils</code>for my use-case, but I would still have to make links to the actual executables in <code>/usr/local/bin</code>. The announced use of <code>Pipfile</code> by <code>pipenv</code> and the horror of yet another config file in every project's root (in the superfluous TOML format to boot) makes it rather uninteresting in the longer term.</span>
<span class="comment-copy"><code>pipenv</code> does not just overlap with <code>virtualenvutils</code> but is a combination of <code>pip</code> and <code>virtualenv</code> which means it fully covers these two tools. And further, if you decide to use <code>pipenv</code>, you don't need <code>requirements.txt</code> any more :-) Actually the biggest reason I choose <code>pipenv</code> is that it can really manage dependencies instead of just list them as <code>pip freeze &gt; requirements.txt</code> do. For example, you delete one top dependency in <code>Pipfile</code> and then run <code>pipenv clean</code>, it will automatically delete all unused sub dependencies. Well, after all, it depends on personal opinion :-)</span>
<span class="comment-copy"><code>virtualenvutils</code> is not <code>virtualenv</code>, it does a bit more than that. As I already got rid of needing a <code>requirements.txt</code> (and <code>setup.cfg</code>, <code>Makefile</code>, <code>tox.ini</code>, <code>setup.py</code>, <code>dist</code>, <code>build</code>, <code>.tox</code>, etc.) anything <code>pipenv</code> puts there only clutters the development tree again. So <code>pipenv</code> (<i>for me</i>) is just extra work without benefit. Whenever I change dependencies that remove things, I save, then reinstall, a utility and its virtualenv from scratch (there is bound to be a new micro version of the used Python anyway), to get the right dependencies (and restore if that cannot be resolved).</span>
<span class="comment-copy">Guess we have different usage scenarios.</span>
