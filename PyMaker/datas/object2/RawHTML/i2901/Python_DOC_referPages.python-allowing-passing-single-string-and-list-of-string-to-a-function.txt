<div class="post-text" itemprop="text">
<p>I have a function that makes a call to a REST API. One of the parameter is a comma-separated list of names. To generate it, I do this:</p>
<pre><code>','.join(names)
</code></pre>
<p>However, I also want to allow the user to provide a single name. The problem is that if <code>names = ERII</code>, for instance, it results in <code>['E', 'R', 'I', 'I']</code>, but I need it to be <code>['ERII']</code> instead. </p>
<p>Now, I could force the user to enter a list with only one value (<code>names=['ERRI']</code> or <code>names=('ERII',)</code>. I would prefer to allow the user to provide a single String. Is there a clever way to do that without a <code>if else</code> statement checking if the provided value is an <code>Iterable</code>?</p>
<p>Alos, I am uncertain as what would be the best practice here, force to provide a list, or allow a single string?</p>
</div>
<div class="post-text" itemprop="text">
<p>Parameters that can be either a thing or an iterable or things are a code smell. It’s even worse when the thing is a string, because a string <em>is</em> an iterable, and even a sequence (so your test for <code>isinstance(names, Iterable)</code> would do the wrong thing).</p>
<p>The Python stdlib does have a few such cases—most infamously, <code>str.__mod__</code>—but most of those err in the other direction, explicitly requiring a tuple rather than any iterable, and most of them are considered to be mistakes, or at least things that wouldn’t be added to the language today. Sometimes it is still the best answer, but the smell should make you think before doing it.</p>
<p>I don’t know exactly what your use case is, but I suspect this will be a lot nicer:</p>
<pre><code>def spam(*names):
    namestr = ','.join(names)
    dostuff(namestr)
</code></pre>
<p>Now the user can call it like this:</p>
<pre><code>spam('eggs')
spam('eggs', 'cheese', 'beans')
</code></pre>
<p>Or, if they happen to have a list, it’s still easy:</p>
<pre><code>spam(*ingredients)
</code></pre>
<hr/>
<p>If that’s not appropriate, another option is keywords, maybe even keyword-only params:</p>
<pre><code>def spam(*, name=None, names=None):
    if name and names:
        raise TypeError('Not both!')
    if not names: names = [name]
</code></pre>
<hr/>
<p>But if the best design really is a string or a (non-string) iterable of strings, or a string or a tuple of strings, the standard way to do that is type switching. It may look a bit ugly, but it calls attention to the fact that you’re doing exactly what you’re doing, and it does it in the most idiomatic way.</p>
<pre><code>def spam(names):
    if isinstance(names, str):
        names = [names]
    dostuff(names)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd allow both list and single strings as arguments. Also, I don't think there's anything wrong with the if/else solution, except that you could directly check if the argument is an instance of the <code>str</code> class (rather then checking if the argument is iterable):</p>
<pre><code>def foo(arg1):
    if isinstance(arg1, str):
        print("It's a string!")
    else:
        print("It's not a string!")
</code></pre>
<p>Be careful if checking whether the argument is iterable - both strings and lists are iterable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using isinstance() to identify the type of input may provide a solution:</p>
<pre><code>def generate_names(input_term):
    output_list = []
    if isinstance(input_term,str):
        output_list.append(','.join(input_term.split()))
    elif isinstance(input_term,list):
        output_list.append(','.join(input_term))
    else:
        print('Please provide a string or a list.')
    return(output_list)
</code></pre>
<p>This will allow you to input list, string of a single name, as well as string containing several names(separated by space):</p>
<pre><code>name = 'Eric'
name1 = 'Alice John'
namelist = ['Alice', 'Elsa', 'George']
</code></pre>
<p>Apply this function:</p>
<pre><code>print(generate_names(name))
print(generate_names(name1))
print(generate_names(namelist))
</code></pre>
<p>Get:</p>
<p>['Eric']</p>
<p>['Alice,John']</p>
<p>['Alice,Elsa,George']</p>
</div>
<span class="comment-copy">@Carcigenicate, I don't have a variable <code>name</code>.</span>
<span class="comment-copy">What about taking <code>*names</code> in the params? Then the user can send you one name, or five names, without needing brackets—or, if he has a list handy, he can just <code>*lst</code> it at you.</span>
<span class="comment-copy">Thank you for that answer, I appreciate the advice on best coding practices. In my specific case, this is my function's signature : <code>def get_symbols(names=None, ids=None, id=None)</code>. I am already using the keywork pattern for ids. The only reason I am doing this for ids and not for names is because this is a python wrapper for a REST API and this is how they designed it (with those three fields) and I wanted to keep it this way so that users can refer to the their doc and still seemingly use my code.</span>
<span class="comment-copy">The <code>*</code> option seems nice too. However, I am not familiar with this kind of  structure when the function accepts multiple parameters. How does Python differentiate between the list of <code>*names</code> passed and the next params in the function's signature? Where could I find documentation on this?</span>
<span class="comment-copy">@AntoineViscardi The <code>*args</code> has to be the last parameter, except for keyword-only parameter. The <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="nofollow noreferrer">actual documentation</a> may be a bit hard to follow; first see <a href="https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions" rel="nofollow noreferrer">More on Defining Functions</a> in the official tutorial, especially the Arbitrary Argument Lists section.</span>
<span class="comment-copy">@AntoineViscardi Assuming you're using Python 3, if you do <code>def get_symbols(*names, ids=None, id=None)</code>, then <code>ids</code> and <code>id</code> will become keyword-only parameters—that is, you can still only them by name, like <code>get_symbols('spam', 'eggs', ids=[1,2,3])</code>.</span>
<span class="comment-copy">Yes I think this is what I'll do for now! And you are right, checking for Iterable was not a good idea on my part: the fact that a string is Iterable is what is causing my problem in the first place... oups :p</span>
