<div class="post-text" itemprop="text">
<p>Say if there's a class attribute that is calculated depending on another class attribute:</p>
<pre><code>class ClassA(object):
    attr1=5
    attr2=attr1+10

&gt;&gt;ClassA.attr2
15
</code></pre>
<p>And then in a child class I want to update the first class attribute to cause a change in the second one, without re-defining the second. e.g:</p>
<pre><code>class ClassB(ClassA):
    attr1=10
</code></pre>
<p>What I would like to happen is:</p>
<pre><code>&gt;&gt;ClassB.attr2
20
</code></pre>
<p>However this isn't the case since attr2 gets calculated before attr1 is re-defined. Is there a way to obtain this behaviour without redefining the second attribute?</p>
<p>(My particular use case is defining WTForms with Field attributes (format, choices, etc) that are derived from the Form class attributes, so I can subclass a base Form and change these attributes without having to re-define the entire Field.)</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no way to do this directly.</p>
<p>For instance attributes, rather than class attributes, you can simulate it pretty easily by using <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>@property</code></a>. Either calculate <code>attr2</code> on the fly every time you ask for it:</p>
<pre><code>class Spam:
    def __init__(self, a):
        self.a = a
    @property
    def twoa(self):
        return 2*self.a
</code></pre>
<p>(possibly adding a cache if calculation is expensive), or recalculate <code>attr2</code> whenever anyone modifies <code>attr1</code>:</p>
<pre><code>class Spam:
    def __init__(self, a):
        self.a = a
    @property
    def a(self):
        return self._a
    @a.setter
    def a(self):
        self._a = a
        self.twoa = 2*a
</code></pre>
<hr/>
<p>That only works because <code>property</code> creates a descriptor that you store in the class object, rather than the instance, so when someone looks up <code>twoa</code> (in the first example) or <code>a</code> (in the second) on a <code>Spam</code> instance, it falls back to finding the descriptor on the class.</p>
<p>If you want the first one for a class attribute, it works as-is when looking up values on instances, but not on the class itself (which, unfortunately, is what you're doing in your examples).</p>
<p>And if you need the second one, it won't work at all.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; class Spam:
...     a = 10
...     @property
...     def twoa(self):
...         return 2*self.a
&gt;&gt;&gt; spam = Spam()
&gt;&gt;&gt; spam.twoa
20
&gt;&gt;&gt; Spam.twoa
&lt;property at 0x12345678&gt;
&gt;&gt;&gt; class Eggs(Spam):
...     a = 5
&gt;&gt;&gt; eggs = Eggs()
&gt;&gt;&gt; eggs.twoa
10
&gt;&gt;&gt; Eggs.twoa
&lt;property at 0x12345678&gt;
</code></pre>
<p>If that's not a problem, great. But if it is, you need to put the descriptor on the class's class—that is, a metaclass:</p>
<pre><code>class MetaSpam(type):
    @property
    def twoa(cls):
        return 2 * cls.a

class Spam(metaclass=MetaSpam):
    a = 2

class Eggs(Spam):
    a = 3
</code></pre>
<p>For a simple case like <code>twoa</code> (or your <code>attr2</code>), dragging in a metaclass is horrible overkill.</p>
<p>But for a case where there's a good chance you're already dragging in custom metaclasses, like a complex forms-and-fields system, it might be appropriate.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>@classproperty</code> descriptor (similar to <code>@property</code>) if you don't want to use metaclasses.</p>
<p>Here's a simple implementation of a <code>classproperty</code> decorator</p>
<pre><code>class classproperty(object):
    def __init__(self, fget):
        self.fget = classmethod(fget)

    def __get__(self, obj, owner):
        return self.fget.__get__(None, owner)()
</code></pre>
<p>And some sample usage:</p>
<pre><code>class A(object):
    attr1 = 10

    @classproperty
    def attr2(cls):
        return cls.attr1 + 10

class B(A):
    attr1 = 8991
</code></pre>
<p>And usage of that:</p>
<pre><code>&gt;&gt;&gt; A.attr1
10
&gt;&gt;&gt; A.attr2
20
&gt;&gt;&gt; B.attr2
9001
&gt;&gt;&gt; A().attr2
20
&gt;&gt;&gt; B().attr2
9001
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, you can do those calculations in metaclass' <code>__new__</code> method:</p>
<pre><code>class MyCalculatedClassAttrsMeta(type):
    def __new__(cls, name, bases, dct):
        c = super().__new__(cls, name, bases, dct)
        c.y = c.x + 100
        return c


class A(metaclass=MyCalculatedClassAttrsMeta):
    x = 1


class B(A):
    x = 2


print(A.x, A.y)
print(B.x, B.y)
</code></pre>
<p>The output will be:</p>
<pre><code>1 101
2 202
</code></pre>
</div>
<span class="comment-copy">@snakecharmerb I know very little about wtforms, hence keeping it generic in the last paragraph ("But for a case where there's a good chance you're already dragging in custom metaclasses, like a complex forms-and-fields system, it might be appropriate.") If you can update that to make it less vague and wishy-washy, please edit the answer (or to explain it here so I can edit, if you'd prefer).</span>
<span class="comment-copy">The problem with this is that if you write <code>ClassB.attr2</code>—as you'd expect to be able to do for a class attribute—you will get the <code>property</code> descriptor itself, not 30.</span>
<span class="comment-copy">ah, class attributes, got it -- will adjust with a <code>@classproperty</code> implementation</span>
<span class="comment-copy">Unless I'm mistaken, using any <code>@classproperty</code> requires a metaclass… and once you have a metaclass, just putting a normal <code>@property</code> on it already works.</span>
<span class="comment-copy">you are mistaken, edit incoming :D</span>
<span class="comment-copy">@abarnert check it out!</span>
