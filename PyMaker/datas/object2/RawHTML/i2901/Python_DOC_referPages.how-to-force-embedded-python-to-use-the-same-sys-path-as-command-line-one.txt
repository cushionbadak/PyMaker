<div class="post-text" itemprop="text">
<p>I use <code>python</code> as embedded scripting language in Ubuntu 16 C++ application. I use <code>pip</code> to install additional modules (<code>mysql</code>, <code>regex</code>, etc). These modules work nice in command line python. However, embedded python can not load them. The reason is that <code>sys.path</code> of embedded python differs from command line one. Command line python <code>sys.path</code> follows:</p>
<pre><code>['', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-x86_64-linux-gnu', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages']
</code></pre>
<p>Here <code>/usr/lib/python2.7/dist-packages</code> is path where <code>pip</code> installs modules.</p>
<p>Embedded python <code>sys.path</code> follows:</p>
<pre><code>/usr/lib/python2.7/
/usr/lib/python2.7/plat-x86_64-linux-gnu
/usr/lib/python2.7/lib-tk
/usr/lib/python2.7/lib-old
/usr/lib/python2.7/lib-dynload
</code></pre>
<p>Of course, it is possible to hardcode <code>pip</code> directory in C++ application and call <code>PySys_SetPath</code> with hardcoded arguments. However, this way looks badly for me; this will make application not portable (I compile the same code for Ubuntu, CentOS and Windows).</p>
<p>Command line python somehow "knows" where <code>pip</code> stores modules. So, there are any configuration file that contains these additional pathes. I run <code>printenv</code>, but no environment variable contains <code>/usr/lib/python2.7/dist-packages</code> string. One way is to run diagnostics script via command line python and send its output to <code>PySys_SetPath</code>. However, <strong>are there any official, documented way to get all pathes where python installation searches for modules by calling API and not by running external process</strong>?</p>
</div>
<div class="post-text" itemprop="text">
<p>If data, scripts, and or executable(s) are included in a package, they're installed in  (their default) separate directories rather than with the Python files.</p>
<p>This command should work just fine but fails to include the other files of a package (if it has any). To include any data, scripts, or executable(s) utilize <code>--prefix</code>, <code>--install-data</code>, and <code>--install-scripts</code> also known as <a href="https://docs.python.org/3/install/index.html#alternate-installation" rel="nofollow noreferrer">alternate installation</a>.</p>
<pre><code>pip install --install-option="--install-purelib=/foobar/packages" package_name
</code></pre>
<p>To permanently change the path, edit the <code>~/.pip/pip.conf</code> file to include:</p>
<pre><code>[install]
install-option=--install-purelib=/foobar/packages
</code></pre>
<p>I highly recommend <a href="https://pip.pypa.io/en/stable/reference/pip_install/" rel="nofollow noreferrer"><code>pip wheel</code></a>. It provides more control over package installment with areas such as: setup requirements, building, installation order, etc; documentation points of interests: <a href="https://pip.pypa.io/en/stable/reference/pip_install/#examples" rel="nofollow noreferrer">examples</a>, <a href="https://pip.pypa.io/en/stable/reference/pip_install/#controlling-setup-requires" rel="nofollow noreferrer">controlling <code>setup_requires</code></a>, and <a href="https://pip.pypa.io/en/stable/reference/pip_install/#using-environment-variables" rel="nofollow noreferrer">using environment variables</a> which is probably the easiest.</p>
<p>One thing to note with <code>pip wheel</code> is:</p>
<blockquote>
<p>You have to use the <strong>POSIX format</strong> for variable names including brackets
  around the uppercase name as shown in this example: ${API_TOKEN}. pip
  will attempt to find the corresponding environment variable defined on
  the host system at runtime.</p>
</blockquote>
</div>
<span class="comment-copy">This is a combination of C++ and Python. Mostly C++, try adding that tag to your post and it should catch the eye of the right programmers. @Vitaliy</span>
<span class="comment-copy">So, what is the answer for the question: "are there any official, documented way to get all pathes where python installation searches for modules by calling API and not by running external process"?</span>
<span class="comment-copy">As much as I researched into different official ways of changing installation path, I did not find anything that fit that exact description. I'm sorry for not directly answering that in my post. I did my best to give alternatives and examples. @Vitaliy</span>
