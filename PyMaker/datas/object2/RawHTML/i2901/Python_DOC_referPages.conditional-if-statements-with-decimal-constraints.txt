<div class="post-text" itemprop="text">
<p>Say I have a condition that if a number ends with.00 add 2 to it and if a number ends with.99 add 3 to it. So if I had 5.00 and 5.99, I want to write a nested if statement that would allow me to add the right value to the original number based on its ending.</p>
<p>How to do that in R (or python)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Due to <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">floating point precision</a>, you will need to round your numbers to two decimals as values such as <code>5.99</code> cannot be represented exactly. This means a value such as <code>5.9921875</code> will have to fulfill your criterion as <em>finishing with 0.99</em>.</p>
<p>If you are fine with that, using <a href="https://docs.python.org/3/library/string.html#format-specification-mini-language" rel="nofollow noreferrer">Python's Format Specification Mini-Language</a> 
 will round implicitly and allow to extract the required decimals.</p>
<pre><code>def get_decimals(num, n=2):
    return '{0:.2f}'.format(num)[-2:]

def func(num):
    decs = get_decimals(num)

    if decs == '00':
        return num + 2
    elif decs == '99':
        return num + 3
    else: return num
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <code>python</code>.</p>
<pre><code>def func(num):
    if round(num, 2) - int(num) &lt; 0.001:
        return num + 2
    elif round(num, 2) - int(num) &gt; 0.989:
        return num + 3 
    return num
</code></pre>
<p>You can round the number to 2 decimal places, subtract it's integer component, then round the result to check if it is <em>close to</em> <code>0.00</code> or <code>0.99</code>. Simply checking if the result before rounding is 0.00 or 0.99 is unreliable because of <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" rel="nofollow noreferrer"><code>floating point numbers</code></a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>In <code>R</code> we can do</p>
<pre><code>v1 + (floor(v1) != v1) + 2
#[1] 7.00 8.99
</code></pre>
<hr/>
<p>If we are looking for last two numeric elements</p>
<pre><code>v2 &lt;- sub(".*(.{2})$", "\\1", sprintf('%0.2f', v1))
ifelse(v2 == "00", v1 + 2, ifelse(v2 == "99", v1 + 3, v1))
#[1] 7.00 8.99
</code></pre>
<h3>data</h3>
<pre><code>v1 &lt;- c(5, 5.99)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems there are other values in your list/vector you need to deal with. I will give a vectorized format:</p>
<p>in R:</p>
<pre><code>data = c(5.00,5.99,5.61)
mm = function(x){
  x = round(x,2)
  y = x-as.integer(x)
  ifelse(round(y-0.00,2)==0, x+2,ifelse(round(y-0.99,2)==0,x+3,x))
} 

mm(data)
[1] 7.00 8.99 5.61
</code></pre>
<p>In Python:  vectorized format with <code>numpy module</code></p>
<pre><code>import numpy as np
x = np.array([5.00,5.99,5.61])
def mm(x):
    x = np.round(x,2)
    y = x - np.array(x,dtype = 'i')
    return np.where(np.round(y-0.00,2)==0, x+2,np.where(np.round(y-0.99,2)==0,x+3,x))

mm(x)
array([7.  , 8.99, 5.61])
</code></pre>
</div>
<span class="comment-copy">what do you mean by right value? so do you need 7.00 and 8.99 as your answer?</span>
<span class="comment-copy">What form is your number in?  Note that if it's a float, your representation is not guaranteed to have the exact value that you expect.</span>
<span class="comment-copy">@onyambu, by "right value" I meant adding the corresponding value, so either the 2 or the 3 based on the ending of the original number.</span>
<span class="comment-copy">This is great, thank you. Any idea how i can do something similar in R?</span>
<span class="comment-copy">@Oliver nice use of f strings</span>
<span class="comment-copy">@Ef.O Unfortunately I have little if any knowledge of R.</span>
<span class="comment-copy">@modesitt This is not actually using an f-string. I wanted to, but decided to keep it simple as it is not a feature commonly used yet.</span>
<span class="comment-copy">No problem will figure it out. Thank you so much for your response, it's really helpful. - @OlivierMelançon</span>
<span class="comment-copy">Wouldn't you want to check against 0.005 instead of 0.001 and similarly for the second condition?</span>
<span class="comment-copy">I think because the float is reasonable up to 12 digits, these boundaries are tighter but sufficient @OlivierMelançon</span>
<span class="comment-copy">I toyed with your code and probably misread it at first because it actually works like a charm. Forget my previous comment</span>
<span class="comment-copy">I think Op is implying that the number should not be changed if the the number was 5.98 for example. my original solution did this too.</span>
<span class="comment-copy">@modesitt what exactly do you mean?</span>
