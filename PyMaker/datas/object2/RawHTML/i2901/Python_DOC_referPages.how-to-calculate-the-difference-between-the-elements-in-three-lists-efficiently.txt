<div class="post-text" itemprop="text">
<p>I have 3 very large lists of strings, for visualization purposes consider:</p>
<pre><code>A = ['one','four', 'nine']

B = ['three','four','six','five']

C = ['four','five','one','eleven']
</code></pre>
<p>How can I calculate the difference between this lists in order to get only the elements that are not repeating in the other lists. For example:</p>
<pre><code>A = ['nine']

B = ['three','six']

C = ['eleven']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>With sets:</h3>
<ul>
<li>convert all lists to sets</li>
<li>take the differences</li>
<li>convert back to lists</li>
</ul>
<hr/>
<pre><code>A, B, C = map(set, (A, B, C))
a = A - B - C
b = B - A - C
c = C - A - B
A, B, C = map(list, (a, b, c))
</code></pre>
<hr/>
<p>The (possible) problem with this is that the final lists are no longer ordered, e.g.</p>
<pre><code>&gt;&gt;&gt; A
['nine']
&gt;&gt;&gt; B
['six', 'three']
&gt;&gt;&gt; C
['eleven']
</code></pre>
<hr/>
<p>This could be fixed by sorting by the original indicies, but then the time complexity will dramatically increase so the benefit of using sets is almost entirely lost.</p>
<hr/>
<h3>With list-comps (for-loops):</h3>
<ul>
<li>convert lists to sets</li>
<li>use list-comps to filter out elements from the original lists that are not in the other sets</li>
</ul>
<hr/>
<pre><code>sA, sB, sC = map(set, (A, B, C))
A = [e for e in A if e not in sB and e not in sC]
B = [e for e in B if e not in sA and e not in sC]
C = [e for e in C if e not in sA and e not in sB]
</code></pre>
<p>which then produces a result that maintains the original order of the lists:</p>
<pre><code>&gt;&gt;&gt; A
['nine']
&gt;&gt;&gt; B
['three', 'six']
&gt;&gt;&gt; C
['eleven']
</code></pre>
<hr/>
<h3>Summary:</h3>
<p>In conclusion, if you don't care about the order of the result, convert the lists to sets and then take their differences (and not bother converting back to lists). However, if you do care about order, then still convert the lists to sets (hash tables) as then the lookup will still be faster when filtering them (best case <code>O(1)</code> vs <code>O(n)</code> for lists).</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Method 1</strong></p>
<p>You can arbitrarily add more lists just by changing the first line, e.g. <code>my_lists = (A, B, C, D, E)</code>.</p>
<pre><code>my_lists = (A, B, C)
my_sets = {n: set(my_list) for n, my_list in enumerate(my_lists)}
my_unique_lists = tuple(
    list(my_sets[n].difference(*(my_sets[i] for i in range(len(my_sets)) if i != n))) 
    for n in range(len(my_sets)))

&gt;&gt;&gt; my_unique_lists
(['nine'], ['six', 'three'], ['eleven'])
</code></pre>
<p><code>my_sets</code> uses a dictionary comprehension to create sets for each of the lists.  The key to the dictionary is the lists order ranking in <code>my_lists</code>.</p>
<p>Each set is then differenced with all other sets in the dictionary (barring itself) and then converted back to a list.</p>
<p>The ordering of <code>my_unique_lists</code> corresponds to the ordering in <code>my_lists</code>.</p>
<p><strong>Method 2</strong></p>
<p>You can use <a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter" rel="nofollow noreferrer"><code>Counter</code></a> to get all unique items (i.e. those that only appear in just one list and not the others), and then use a list comprehension to iterate through each list and select those that are unique.</p>
<pre><code>from collections import Counter

c = Counter([item for my_list in my_lists for item in set(my_list)])
unique_items = tuple(item for item, count in c.items() if count == 1)

&gt;&gt;&gt; tuple([item for item in my_list if item in unique_items] for my_list in my_lists)
(['nine'], ['three', 'six'], ['eleven'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iteratively go thru all lists elements adding current element to set if its not there, and if its there remove it from list. This way you will use additional up to O(n) space complexity, and O(n) time complexity but elements will remain in order.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use a function define purposely to check the difference between three list. Here's an example of such a function:</p>
<pre><code>def three_list_difference(l1, l2, l3):
    lst = []
    for i in l1:
        if not(i in l2 or i in l3):
            lst.append(i)
    return lst
</code></pre>
<p>The function <code>three_list_difference</code> takes three list and checks if an element in the first list <code>l1</code> is also in either <code>l2</code> or <code>l3</code>. The deference can be determined by simple calling the function in the right configuration:</p>
<pre><code>three_list_difference(A, B, C)
three_list_difference(B, A, C)
three_list_difference(C, B, A)
</code></pre>
<p>with outputs:</p>
<pre><code>['nine']
['three', 'six']
['eleven']
</code></pre>
<p>Using a function is advantageous because the code is reusable. </p>
</div>
<span class="comment-copy">Nice answer, but are you sure that using lower and upper case letters for variables names is a good style?</span>
<span class="comment-copy">@LevZakharov Well that's entirely up to the OP, the message is still conveyed :)</span>
