<div class="post-text" itemprop="text">
<p>I have a dataset which contains million level images and what I want to do is to do something like <code>Counter(&lt;list of images&gt;)</code> to check duplicates and count for the whole dataset. However, considering the size of images, it seems infeasible to load all into memory. Thus, is there any way to do things like this? Do I need to write my own hash function and reverse dict?</p>
<p>Edited for <code>sha1</code>:</p>
<p>I did something like </p>
<pre><code>image = Image.open("x.jpg") # PIL library
hashlib.sha1(image)
</code></pre>
<p>and got an error like </p>
<pre><code>TypeError: object supporting the buffer API required
</code></pre>
<p>What should I do now?</p>
</div>
<div class="post-text" itemprop="text">
<p>As suggested, you can use any hashing function, and use it to digest the image file as a binary. Then save the digest in a dictionary and use that to count duplicates (or store more information if you wish).</p>
<p>At the very basic, for each image you would do something like:</p>
<pre><code>import hashlib
filename = "x.jpg"
hashstr = hashlib.sha1(open(filename).read()).hexdigest()
</code></pre>
<p>That would return a hex string in <code>hashstr</code>, like <code>5fe54dee8f71c9f13579f44c01aef491e9d6e655</code> </p>
<p>As pointed out, this only works if the duplication is at the file level, byte-per-byte. If you want to weed out the same image, let's say at different resolutions, or different dimensions, the <code>hashlib</code> functions cannot help, and you would need to find a different way to determine <strong>equality</strong>.</p>
</div>
<span class="comment-copy">You can do this in <code>O(n)</code> as you say by writing a hash function (if not already done), creating a dictionary and then iterating over all images and incrementing a counter in the dictionary.</span>
<span class="comment-copy">"Do I need to write my own hash function and reverse dict?" No, just use <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer">sha1</a>.  Note that the images must be IDENTICAL, and if there has been any compression or changes in resolution or format or anything, you'll have to do something custom.</span>
<span class="comment-copy">@modesitt Yes exactly. But what I am trying to ask is whether there are existed packages that could handle this?</span>
<span class="comment-copy">@Scott Thanks for the point. Do you know whether there are existed packages that could handle tasks like this?</span>
<span class="comment-copy">yep.  Click the "sha1" link in my previous comment.  :)</span>
