<div class="post-text" itemprop="text">
<p>Here is example test:
<br/></p>
<pre><code>import a
import b
import c

import mock
from django.test import TestCase

@mock.patch.object(a, "method_a")
@mock.patch.object(b, "method_b")
@mock.patch.object(c, "method_c")
class SomeTestCase(TestCase):

    def setUp(self):
        # I want to set mock_method_a.return_value = 1 once here (or not here, but once)
        pass

    def test_one(self, mock_method_a, mock_method_b, mock_method_c):
        mock_method_a.return_value = 1
        mock_method_b.return_value = 2
        pass  # some test stuff

    def test_two(self, mock_method_a, mock_method_b, mock_method_c):
        mock_method_a.return_value = 1
        mock_method_b.return_value = 2
        pass  # some test stuff

    def test_three(self, mock_method_a, mock_method_b, mock_method_c):
        mock_method_a.return_value = 1
        mock_method_b.return_value = 2
        pass  # some test stuff
</code></pre>
<p><br/>
<strong>Queston</strong>:
<br/>
How I can avoid of duplicate code for setting "return_value" in each test in TestCase?
<br/>
<br/>
I expect something in "setUp" method or something similar.
<br/>
Is it possible?
<br/><br/>
PS: mock version mock==1.3.0, django version Django==1.8.4</p>
</div>
<div class="post-text" itemprop="text">
<p>You can set the <code>return_value</code> right there in the <code>@mock.patch.object()</code> decorators:</p>
<pre><code>@mock.patch.object(c, "method_c", return_value=3)
@mock.patch.object(b, "method_b", return_value=2)
@mock.patch.object(a, "method_a", return_value=1)
class SomeTestCase(TestCase):
    def test_one(self, mock_method_a, mock_method_b, mock_method_c):
        # do test stuff, return values have been set

    def test_two(self, mock_method_a, mock_method_b, mock_method_c):
        # do test stuff, return values have been set

    def test_three(self, mock_method_a, mock_method_b, mock_method_c):
        # do test stuff, return values have been set
</code></pre>
<p>(Note: when decorating with <code>@mock.patch</code> the decorators are applied from the bottom on up, so for <code>mock_method_a</code> to be passed in as the first argument you need to put the decorator closest to the class definition).</p>
<p>The <code>return_value</code> keyword argument to <code>mock.patch.object()</code> is passed to the <code>MagicMock()</code> constructor. See the <a href="https://docs.python.org/3/library/unittest.mock.html#patch-object" rel="nofollow noreferrer"><code>mock.patch.object()</code> documentation</a>:</p>
<blockquote>
<p>Like <code>patch()</code>, <code>patch.object()</code> takes arbitrary keyword arguments for configuring the mock object it creates.</p>
</blockquote>
<p>and the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="nofollow noreferrer"><code>mock.Mock</code> documentation</a>:</p>
<blockquote>
<p><code>Mock</code> takes several optional arguments that specify the behaviour of the <code>Mock</code> object:</p>
<ul>
<li><p><em>[...]</em></p></li>
<li><p><code>return_value</code>: The value returned when the mock is called. By default this is a new <code>Mock</code> (created on first access). See the <code>return_value</code> attribute.</p></li>
</ul>
</blockquote>
<p>If you also want to avoid setting the mocks <em>outside</em> of your test case or don't like the additional arguments to each test function, then you you can also can create <em>patchers</em> in the <code>setUp</code> method, which then are removed again when the test ends by registering a callback via the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup" rel="nofollow noreferrer"><code>unittest.TestCase.addCleanup()</code> method</a>.</p>
<p>The patchers are applied for each test, by calling <a href="https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop" rel="nofollow noreferrer">the <code>patcher.start()</code> methods</a>, which returns the new mock object:</p>
<pre><code>class SomeTestCase(TestCase):    
    def setUp(self):
        patcher_method_a = mock.patch.object(a, "method_a")
        self.mock_method_a = patcher_method_a.start()
        self.mock_method_a.return_value = 1

        patcher_method_b = mock.patch.object(b, "method_b")
        self.mock_method_b = patcher_method_b.start()
        self.mock_method_b.return_value = 2

        patcher_method_c = mock.patch.object(c, "method_c")
        self.mock_method_c = patcher_method_c.start()
        self.mock_method_c.return_value = 3

        # when the test is done, stop **all** patchers
        self.addCleanup(mock.patch.stopall)

    def test_one(self):
        # use self.mock_method_a, etc.

    def test_two(self, mock_method_a, mock_method_b, mock_method_c):
        # use self.mock_method_a, etc.

    def test_three(self, mock_method_a, mock_method_b, mock_method_c):
        # use self.mock_method_a, etc.
</code></pre>
<p>Note that the <code>mock.patch.stopall()</code> method will stop <em>all mock patchers that have started</em>. You can also pass the <code>.stop</code> attributes of each of the patchers:</p>
<pre><code>self.addCleanup(patcher_method_a.stop)
self.addCleanup(patcher_method_b.stop)
self.addCleanup(patcher_method_c.stop)
</code></pre>
<p>If you have to create a lot of such setups, you could create a helper function that'll take care of the repeated parts:</p>
<pre><code>def setup_object_patch(testcase, object, target, return_value, attrname=None):
    patcher = mock.patch.object(object, target)
    mock = patcher.start()
    mock.return_value = return_value
    setattr(testcase, attrname or f'mock_{target}', mock)
    testcase.addCleanup(patcher.stop)
</code></pre>
<p>and perhaps use this in a loop over a mapping:</p>
<pre><code>def setUp(self):
    mocks = {
        # attribute name on test -&gt; object, target, return_value
        'mock_method_a': (a, 'method_a', 1),
        'mock_method_b': (b, 'method_b', 2),
        'mock_method_c': (c, 'method_c', 3),
    }
    for attrname, params in mocks.items():
        setup_object_patch(*params, attrname=attrname)
</code></pre>
<p>The <code>patcher.start()</code> approach in a <code>TestCase.setUp()</code> method makes it easier to use <em>inheritance</em>, where a base testcase case is used as the basis for several test cases that all use the same shared mocking setup.</p>
</div>
<span class="comment-copy">Why <i>not</i> in <code>setUp</code>? You can actually set the return value when you create the patch, too.</span>
<span class="comment-copy">the patch decorator in the order <code>a b c</code>,  the mock methods should be in the order of  <code>mock_c, mock_b, mock_a</code> in theory, right?</span>
<span class="comment-copy">@Gang: yes, note that the OP got this wrong in their example too. I'll correct.</span>
