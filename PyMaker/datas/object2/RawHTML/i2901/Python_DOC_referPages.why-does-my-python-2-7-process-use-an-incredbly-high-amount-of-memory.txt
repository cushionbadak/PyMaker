<div class="post-text" itemprop="text">
<p>I am trying to understand why this python code results in a process that requires 236 MB of memory, considering that the list is only 76 MB long. </p>
<pre><code>import sys
import psutil

initial = psutil.virtual_memory().available / 1024 / 1024
available_memory = psutil.virtual_memory().available

vector_memory = sys.getsizeof([])
vector_position_memory = sys.getsizeof([1]) - vector_memory

positions = 10000000

print "vector with %d positions should use %d MB of memory " % (positions, (vector_memory + positions * vector_position_memory) / 1024 / 1024)
print "it used %d MB of memory " % (sys.getsizeof(range(0, positions)) / 1024 / 1024)

final = psutil.virtual_memory().available / 1024 / 1024

print "however, this process used in total %d MB" % (initial - final)
</code></pre>
<p>The output is:</p>
<pre><code>vector with 10000000 positions should use 76 MB of memory 
it used 76 MB of memory 
however, this process used in total 236 MB
</code></pre>
<p>Adding x10 more positions (i.e. <code>positions = 100000000</code>) results in x10 more memory. </p>
<pre><code>vector with 100000000 positions should use 762 MB of memory 
it used 762 MB of memory 
however, this process used in total 2330 MB
</code></pre>
<p>My ultimate goal is to suck as much memory as I can to create a very long list. To do this, I created this code to understand/predict how big my list could be based on available memory. To my surprise, python needs a ton of memory to manage my list, I guess.</p>
<p>Why does python use so much memory?! What is it doing with it? Any idea on how I can predict python's memory requirements to effectively create a list to use pretty much all the available memory while preventing the OS from doing swap?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/2/library/sys.html#sys.getsizeof" rel="noreferrer"><code>getsizeof</code></a> function only includes the space used by the list itself.</p>
<p>But the list is effectively just an array of pointers to int objects, and you created 10000000 of those, and each one of those takes memory as well—typically 24 bytes.</p>
<p>The first few numbers (usually up to 255) are pre-created and cached by the interpreter, so they're effectively free, but the rest are not. So, you want to add something like this:</p>
<pre><code>int_memory = sys.getsizeof(10000)

print "%d int objects should use another %d MB of memory " % (positions - 256, (positions - 256) * int_memory / 1024 / 1024)
</code></pre>
<p>And then the results will make more sense.</p>
<hr/>
<p>But notice that if you aren't creating a <code>range</code> with 10M unique ints, but instead, say, 10M random ints from 0-10000, or 10M copies of 0, that calculation will no longer be correct. So if want to handle those cases, you need to do something like stash the <code>id</code> of every object you've seen so far and skip any additional references to the same <code>id</code>.</p>
<p>The Python 2.x docs used to have a link to an old recursive <code>getsizeof</code> function that does that, and more… but that link went dead, so it was removed.</p>
<p><a href="https://docs.python.org/3/library/sys.html#sys.getsizeof" rel="noreferrer">The 3.x docs</a> have a link to <a href="https://code.activestate.com/recipes/577504" rel="noreferrer">a newer one</a>, which may or may not work in Python 2.7. (I notice from a quick glance that it uses a <code>__future__</code> statement for <code>print</code>, and falls back from <code>reprlib.repr</code> to <code>repr</code>, so it probably does.)</p>
<hr/>
<p>If you're wondering why every <code>int</code> is 24 bytes long (in 64-bit CPython; it's different for different platforms and implementations, of course):</p>
<p>CPython represents every builtin type as a C struct that contains, at least, space for a refcount and a pointer to the type. Any actual value the object needs to represent is in addition to that.<sup>1</sup> So, the smallest non-singleton type is going to take 24 bytes per instance.</p>
<hr/>
<p>If you're wondering how you can avoid using up 24 bytes per integer, the answer is to use <a href="http://www.numpy.org/" rel="noreferrer">NumPy's <code>ndarray</code></a>—or, if for some reason you can't, the stdlib's <a href="https://docs.python.org/2/library/array.html" rel="noreferrer"><code>array.array</code></a>.</p>
<p>Either one lets you specify a "native type", like <code>np.int32</code> for NumPy or <code>i</code> for <code>array.array</code>, and create an array that holds 100M of those native-type values directly. That will take exactly 4 bytes per value, plus a few dozen constant bytes of header overhead, which is a lot smaller than a <code>list</code>'s 8 bytes of pointer, plus a bit of slack at the end that scales with the length, plus an <code>int</code> object wrapping up each value.</p>
<p>Using <code>array.array</code>, you're sacrificing speed for space,<sup>2</sup> because every time you want to access one of those values, Python has to pull it out and "box" it as an <code>int</code> object.</p>
<p>Using NumPy, you're gaining <em>both</em> speed and space, because NumPy will let you perform vectorized operations over the whole array in a tightly-optimized C loop.</p>
<hr/>
<p><sub>1. What about non-builtin types, that you create in Python with <code>class</code>? They have a pointer to a dict—which you can see from Python-land as <code>__dict__</code>—that holds all the attributes you add. So they're 24 bytes according to <code>getsizeof</code>, but of course you have to also add the size of that dict.</sub></p>
<p><sub>2. Unless you aren't. Preventing your system from going into swap hell is likely to speed things up a lot more than the boxing and unboxing slows things down. And, even if you aren't avoiding that massive cliff, you may <em>still</em> be avoiding smaller cliffs involving VM paging or cache locality.</sub></p>
</div>
<span class="comment-copy">sounds likely. But it raises another question, why an int object should use 24 bytes!?</span>
<span class="comment-copy">@snoopy Every object in CPython has to include at least a refcount, and a pointer to its type. So, on a 64-bit platform, the smallest non-singleton objects are 24 bytes.</span>
<span class="comment-copy">What a darn good answer! Thank you for all the knowledge you are transmitting!</span>
