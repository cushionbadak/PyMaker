<div class="post-text" itemprop="text">
<p>I have following list with arrays:</p>
<pre><code>[array([10,  1,  7,  3]),
 array([ 0, 14, 12, 13]),
 array([ 3, 10,  7,  8]),
 array([7, 5]),
 array([ 5, 12,  3]),
 array([14,  8, 10])]
</code></pre>
<p>What I want is to mark rows as "1" or "0", conditional on whether the row matches "10" AND "7" OR "10" AND "3".</p>
<pre><code>np.where(output== 10 &amp; output == 7 ) | (output == 10 &amp; output == 3 ) | (output == 10 &amp; output == 8 ), 1, 0)
</code></pre>
<p>returns </p>
<pre><code>array(0)
</code></pre>
<p>What's the correct syntax to get into the array of the array?</p>
<p><strong>Expected output:</strong></p>
<pre><code>[ 1, 0, 1, 0, 0, 1 ]
</code></pre>
<p><em>Note:</em>
What is <code>output</code>? After training an CountVectorizer/LDA topic classifier in Scikit, the following script assigns topic probabilities to new documents. Topics above the threshold of 0.2 are then stored in an array.</p>
<pre><code>def sortthreshold(x, thresh):
    idx = np.arange(x.size)[x &gt; thresh]
    return idx[np.argsort(x[idx])]

output = []
for x in newdoc:
    y = lda.transform(bowvectorizer.transform([x]))
    output.append(sortthreshold(y[0], 0.2))
</code></pre>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <code>np.any</code> combined with <code>np.where</code>, and avoid using <code>|</code> and <code>&amp;</code> which are binary operators in python.</p>
<pre><code>import numpy as np

a = [np.array([10,  1,  7,  3]),
     np.array([ 0, 14, 12, 13]),
     np.array([ 3, 10,  7,  8]),
     np.array([7, 5]),
     np.array([ 5, 12,  3]),
     np.array([14,  8, 10])]

for output in a:
    print(np.where(((any(output == 10) and any(output == 7))) or 
                   (any(output == 10) and any(output == 3)) or
                   (any(output == 10) and any(output == 8 )), 1, 0))
</code></pre>
<h3>output:</h3>
<pre><code>1
0
1
0
0
1
</code></pre>
<p>If you want it as a list as the edited question shows:</p>
<pre><code>result = []
for output in a:
    result.append(1 if np.where(((any(output == 10) and any(output == 7))) or 
                   (any(output == 10) and any(output == 3)) or
                   (any(output == 10) and any(output == 8 )), 1, 0) == True else 0)

result
</code></pre>
<h3>result:</h3>
<pre><code>[1, 0, 1, 0, 0, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your input data is a plain Python list of Numpy arrays of unequal length, thus it can't be simply converted to a 2D Numpy array, and so it can't be directly processed by Numpy. But it can be process using the usual Python list processing tools. </p>
<p>Here's a list comprehension that uses <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.isin.html#numpy.isin" rel="nofollow noreferrer"><code>numpy.isin</code></a> to test if a row contains any of (3, 7, 8). We first use simple <code>==</code> testing to see if the row contains 10, and only call <code>isin</code> if it does so; the Python <code>and</code> operator will not evaluate its second operand if the first operand is false-ish.</p>
<p>We use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html#numpy.any" rel="nofollow noreferrer"><code>np.any</code></a> to see if any row item passes each test. <code>np.any</code> returns a Boolean value of <code>False</code> or <code>True</code>, but we can pass those values to <code>int</code> to convert them to 0 or 1.</p>
<pre><code>import numpy as np

data = [
    np.array([10, 1, 7, 3]), np.array([0, 14, 12, 13]),
    np.array([3, 10, 7, 8]), np.array([7, 5]),
    np.array([5, 12, 3]), np.array([14, 8, 10]),
]

mask = np.array([3, 7, 8])
result = [int(np.any(row==10) and np.any(np.isin(row, mask)))
    for row in data]

print(result)
</code></pre>
<p><strong>output</strong></p>
<pre><code>[1, 0, 1, 0, 0, 1] 
</code></pre>
<hr/>
<p>I've just performed some <a href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="nofollow noreferrer"><code>timeit</code></a> tests. Curiously, Reblochon Masque's code is faster on the data given in the question, presumably because of the short-circuiting behaviour of plain Python <code>any</code>, <code>and</code> &amp; <code>or</code>. Also, it appears that <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.in1d.html#numpy.in1d" rel="nofollow noreferrer"><code>numpy.in1d</code></a> is faster than <code>numpy.isin</code>, even though the docs recommend using the latter in new code.</p>
<p>Here's a new version that's about 10% slower than Reblochon's. </p>
<pre><code>mask = np.array([3, 7, 8])
result = [int(any(row==10) and any(np.in1d(row, mask)))
    for row in data]
</code></pre>
<p>Of course, the true speed on large amounts of real data may vary from what my tests indicate. And time may not be an issue: even on my slow old 32 bit single core 2GHz machine I can process the data in the question almost 3000 times in one second.</p>
<hr/>
<p>hpaulj has suggested an even faster way. Here's some <a href="https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat" rel="nofollow noreferrer">timeit test</a> info, comparing the various versions. These tests were performed on my old machine, YMMV.</p>
<pre><code>import numpy as np
from timeit import Timer

the_data = [
    np.array([10, 1, 7, 3]), np.array([0, 14, 12, 13]),
    np.array([3, 10, 7, 8]), np.array([7, 5]),
    np.array([5, 12, 3]), np.array([14, 8, 10]),
]

def rebloch0(data):
    result = []
    for output in data:
        result.append(1 if np.where((any(output == 10) and any(output == 7)) or
            (any(output == 10) and any(output == 3)) or
            (any(output == 10) and any(output == 8)), 1, 0) == True else 0)
    return result

def rebloch1(data):
    result = []
    for output in data:
        result.append(1 if np.where((any(output == 10) and any(output == 7)) or
            (any(output == 10) and any(output == 3)) or
            (any(output == 10) and any(output == 8)), 1, 0) else 0)
    return result

def pm2r0(data):
    mask = np.array([3, 7, 8])
    return [int(np.any(row==10) and np.any(np.isin(row, mask)))
        for row in data]

def pm2r1(data):
    mask = np.array([3, 7, 8])
    return [int(any(row==10) and any(np.in1d(row, mask)))
        for row in data]

def hpaulj0(data):
    mask=np.array([3, 7, 8])
    return [int(any(row==10) and any((row[:, None]==mask).flat))
        for row in data]

def hpaulj1(data, mask=np.array([3, 7, 8])):
    return [int(any(row==10) and any((row[:, None]==mask).flat))
        for row in data]

functions = (
    rebloch0,
    rebloch1,
    pm2r0,
    pm2r1,
    hpaulj0,
    hpaulj1,
)

# Verify that all functions give the same result
for func in functions:
    print('{:8}: {}'.format(func.__name__, func(the_data)))
print()

def time_test(loops, data):
    timings = []
    for func in functions:
        t = Timer(lambda: func(data))
        result = sorted(t.repeat(3, loops))
        timings.append((result, func.__name__))
    timings.sort()
    for result, name in timings:
        print('{:8}: {:.6f}, {:.6f}, {:.6f}'.format(name, *result))
    print()

time_test(1000, the_data)
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>rebloch0: [1, 0, 1, 0, 0, 1]
rebloch1: [1, 0, 1, 0, 0, 1]
pm2r0   : [1, 0, 1, 0, 0, 1]
pm2r1   : [1, 0, 1, 0, 0, 1]
hpaulj0 : [1, 0, 1, 0, 0, 1]
hpaulj1 : [1, 0, 1, 0, 0, 1]

hpaulj1 : 0.140421, 0.154910, 0.156105
hpaulj0 : 0.154224, 0.154822, 0.167101
rebloch1: 0.281700, 0.282764, 0.284599
rebloch0: 0.339693, 0.359127, 0.375715
pm2r1   : 0.367677, 0.368826, 0.371599
pm2r0   : 0.626043, 0.628232, 0.670199
</code></pre>
<p>Nice work, hpaulj!</p>
</div>
<span class="comment-copy">by mark did you mean to replace the value as 0 or 1?</span>
<span class="comment-copy">That looks like a plain Python list of Numpy arrays. What's <code>output</code>?</span>
<span class="comment-copy">Output is an array that is created out of an LDA topic model. The numbers in the array correspond to topics with a topic loading higher than a given threshold.</span>
<span class="comment-copy">How come <code>[14,  8, 10]</code> matches? It has a 10, but no 7 or 3.</span>
<span class="comment-copy">We (probably) don't need to see the original function that creates <code>output</code>. But we do need you to make the code you've shown us unambiguous and self-consistent. You keep calling <code>output</code> an array, but it looks like a list. And according to the code you just added, <code>output</code> <i>is</i> a list, not an array.</span>
<span class="comment-copy">FWIW, in Numpy, <code>&amp;</code> and <code>|</code> <i>can</i> be used for logical operations. However, unlike <code>and</code> and <code>or</code> they do not short-circuit.</span>
<span class="comment-copy">What does that mean? Can the code be improved?</span>
<span class="comment-copy">No worries. It is a little surprising. Of course, Numpy can't use the traditional C operators <code>&amp;&amp;</code> and <code>||</code> because the Python parser would reject them.</span>
<span class="comment-copy">I just did some <code>timeit</code> tests. Your code is nearly twice as fast as my original version on the OP data.</span>
<span class="comment-copy">hpaulj made a suggestion that <i>really</i> speeds things up. I've added a <code>timeit</code> test to my answer.</span>
<span class="comment-copy">A blending of these ideas is even faster: <code>int(any(arr==10) and any((arr[:,None]==[3,7,8]).flat))</code></span>
<span class="comment-copy">@hpaulj Wow, that's impressive!</span>
