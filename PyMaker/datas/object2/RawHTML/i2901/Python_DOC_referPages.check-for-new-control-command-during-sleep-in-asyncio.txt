<div class="post-text" itemprop="text">
<p>I'm looking for a pythonic asyncio "pattern" for a construct that appears quite often in my programs.</p>
<p>A worker task performs some operations usually consisting of several steps. The details of those operations are controlled by commands sent from a controlling function to the worker task. There are sleeps between individual steps and the worker is able to accept new commands only during these sleeps. A new command should wake up the worker task from sleep immediately.</p>
<p>The commands represent a desired target state. I'm using a Queue for communication. However, there can be only one target, that's why the commands do not build a real queue, but the last one replaces all previous ones. The queue has one item at most.</p>
<p>Currently I'm using other async library. I want to switch to standard <code>asyncio</code>. An example:</p>
<pre><code># warning: not asyncio code; not real code
cmd_queue = Queue()

async def worker():
    cmd = 'INIT'
    while cmd != 'STOP':
        ... do_something1 sync or async ...
        newcmd = await cmd_queue.get(timeout=SLEEPTIME1, timeout_value=None)
        if newcmd is not None:
            cmd = newcmd
            continue
        ... do_something2 sync or async ...
        newcmd = await cmd_queue.get(timeout=SLEEPTIME2, timeout_value=None)
        if newcmd is not None:
            cmd = newcmd
            continue

def controlloler():
    ...
    if newcmd:
        cmd_queue.clear() # replaces a waiting command
        cmd_queue.put(newcmd) # put_nowait() in asyncio
    ...
</code></pre>
<p>I could rewrite that form of <code>queue.get</code> to an asyncio code:</p>
<pre><code>try:
    cmd=wait_for(cmd_queue.get(), timeout=SLEEPTIME)
    continue # or process otherwise
except asyncio.TimeoutError:
    pass
</code></pre>
<p>but I think maybe there is a simpler solution. OTOH If you have asyncio experience and think a Queue with timeout is the way to go, that would help me too.</p>
<p>I tried to search, but could not find proper keywords for my problem (same holds for the question title).</p>
</div>
<div class="post-text" itemprop="text">
<p>There is certainly nothing wrong with your timeout implementation. Methods on asyncio <a href="https://docs.python.org/3/library/asyncio-sync.html" rel="nofollow noreferrer">synchronization</a> primitives intentionally don't support explicit timeout arguments, leaving it to the caller to use cancellation or <code>wait_for</code> to time out when needed.</p>
<p>As for a single-element queue  I would consider replacing it with a <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Future" rel="nofollow noreferrer"><code>Future</code></a>, which is not only designed to hold a single value, but is also very lightweight in asyncio  given that it is the basic abstraction used to build almost everything else.</p>
<p>Instead of <code>wait_for(cmd_queue.get(), ...)</code>, you'd write <code>wait_for(cmd_future, ...)</code>, and instead of <code>cmd_queue.put(value)</code>, you'd write <code>cmd_future.set_result(value)</code>. The only important difference is that a future is one-shot, so after getting an item, you need to assign a new future to <code>cmd_future</code>.</p>
</div>
