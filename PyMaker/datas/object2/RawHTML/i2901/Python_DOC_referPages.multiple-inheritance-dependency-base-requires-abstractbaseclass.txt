<div class="post-text" itemprop="text">
<p>The gist of the question: if inheriting multiple classes how can I guarantee that if one class is inherited, a compliment Abstract Base Class (abc) is also used by the child object.</p>
<p>I've been messing around with pythons inheritance trying to see what kind of cool stuff I can do and I came up with this pattern, which is kind of interesting.  </p>
<p>I've been trying to use this make implementing and testing objects that interface with my cache easier.  I've got three modules:</p>
<blockquote>
<ul>
<li>ICachable.py </li>
<li>Cacheable.py </li>
<li>SomeClass.py</li>
</ul>
</blockquote>
<p>ICacheable.py</p>
<pre><code>import abc

class ICacheable(abc.ABC):
    @property 
    @abc.abstractmethod
    def CacheItemIns(self):
        return self.__CacheItemIns
    @CacheItemIns.setter
    @abc.abstractmethod
    def CacheItemIns(self, value):
        self.__CacheItemIns = value
        return

    @abc.abstractmethod
    def Load(self):
        """docstring"""
        return

    @abc.abstractmethod
    def _deserializeCacheItem(self): 
        """docstring"""
        return

    @abc.abstractmethod
    def _deserializeNonCacheItem(self): 
        """docstring"""
        return
</code></pre>
<p>Cacheable.py</p>
<pre><code>class Cacheable:

    def _getFromCache(self, itemName, cacheType,
                          cachePath=None):
            """docstring"""

            kwargs = {"itemName" : itemName, 
                      "cacheType" : cacheType,
                      "cachePath" : cachePath}

            lstSearchResult = CacheManager.SearchCache(**kwargs)
            if lstSearchResult[0]:
                self.CacheItemIns = lstSearchResult[1]
                self._deserializeCacheItem()
            else:
                cacheItem = CacheManager.NewItem(**kwargs)
                self.CacheItemIns = cacheItem
                self._deserializeNonCacheItem()

            return
</code></pre>
<p>SomeClass.py</p>
<pre><code>import ICacheable
import Cacheable

class SomeClass(Cacheable, ICacheable):
    __valueFromCache1:str = ""
    __valueFromCache2:str = ""
    __CacheItemIns:dict = {}
    @property 
    def CacheItemIns(self):
        return self.__CacheItemIns
    @CacheItemIns.setter
    def CacheItemIns(self, value):
        self.__CacheItemIns = value
        return

    def __init__(self, itemName, cacheType):
        #Call Method from Cacheable
        self.__valueFromCache1
        self.__valueFromCache2
        self.__getItemFromCache(itemName, cacheType)
        return

    def _deserializeCacheItem(self): 
        """docstring"""
        self.__valueFromCache1 = self.CacheItemIns["val1"]
        self.__valueFromCache2 = self.CacheItemIns["val2"]
        return

    def _deserializeNonCacheItem(self): 
        """docstring"""
        self.__valueFromCache1 = #some external function
        self.__valueFromCache2 = #some external function
        return
</code></pre>
<p>So this example works, but the scary thing is that there is no gurantee that a class inherriting <code>Cacheable</code> also inherits <code>ICacheable</code>.  Which seems like a design flaw, as <code>Cacheable</code> is useless on its own.  However the ability to abstract things from my subclass/child class with this is powerful.  Is there a way to guarantee Cacheable's dependency on ICacheable?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you explicitly do not want inheritance, you can register classes as virtual subclasses of an ABC.</p>
<pre><code>@ICacheable.register
class Cacheable:
    ...
</code></pre>
<p>That means every subclass of <code>Cacheable</code> is automatically treated as subclass of <code>ICacheable</code> as well. This is mostly useful if you have an efficient implementation that would be slowed down by having non-functional Abstract Base Classes to traverse, e.g. for <code>super</code> calls.</p>
<p>However, ABCs are not just Interfaces and it is fine to inherit from them. In fact, part of the benefit of ABC is that it enforces subclasses to implement all abstract methods. An intermediate helper class, such as <code>Cacheable</code>, is fine not to implement all methods when it is never instantiated. However, any non-virtual subclass that is instantiated must be concrete.</p>
<pre><code>&gt;&gt;&gt; class FailClass(Cacheable, ICacheable):
...    ...
...
&gt;&gt;&gt; FailClass()
TypeError: Can't instantiate abstract class FailClass with abstract methods CacheItemIns, Load, _deserializeCacheItem, _deserializeNonCacheItem
</code></pre>
<p>Note that if you</p>
<ul>
<li><em>always</em> subclass as <code>class AnyClass(Cacheable, ICacheable):</code></li>
<li><em>never</em> instantiate <code>Cacheable</code></li>
</ul>
<p>that is functionally equivalent to <code>Cacheable</code> inheriting from <code>ICacheable</code>. The Method Resolution Order (i.e. the inheritance diamond) is the same.</p>
<pre><code>&gt;&gt;&gt; AnyClass.__mro__
(__main__. AnyClass, __main__.Cacheable, __main__.ICacheable, abc.ABC, object)
</code></pre>
</div>
<span class="comment-copy">Make <code>Cacheable</code> a subclass of <code>ICacheable</code>.</span>
<span class="comment-copy">@mypetlion that gets us into the age, "how do i know what methods need overridden in Cacheable".  Instead of Cacheable providing helpers that assist an implementation, it is now actually implementing ICacheable.  Suddenly were back to the same problems as C# and Java but without half of the inheritance tools they have (like the ability to declare class scope).  At least that's how i'm thinking of it.</span>
<span class="comment-copy">Why do you specify private methods, such as <code>_deserializeNonCacheItem</code>, as part of the Interface? These should never be visible, so you are practically enforcing an implementation detail. Note also that <code>__CacheItemIns</code> is a class private member subject to <i>name mangling</i> - <code>ICacheable</code> can never use it unless it declares it. See <a href="https://docs.python.org/3/tutorial/classes.html#private-variables" rel="nofollow noreferrer">docs.python.org/3/tutorial/classes.html#private-variables</a></span>
<span class="comment-copy">With a virtual subclass does that mean that Cacheable would have to impliment ICacheable?  Part of the idea here is that Cacheable doesn't implement ICacheable.</span>
<span class="comment-copy"><code>Cacheable</code> only has to fully implement <code>ICacheable</code> if <code>Cacheable</code> is a <i>concrete</i> subclass and gets instantiated. A virtual subclass does not inherit anything, including the ABC consistency checks. A concrete but incomplete subclass is just a more specialised yet still abstract base class.</span>
<span class="comment-copy">Doesn't Cacheable always get instantiated as part of the constructor chain?</span>
<span class="comment-copy">That is not how types work in Python. If you instantiate <code>SomeClass</code>, an object of type <code>SomeClass</code> is instantiated and initialised - its MRO merely <i>contains</i> <code>Cacheable</code>. Now, this instance may choose to initialise <i>itself</i> like a <code>Cacheable</code> instance (via <code>Cacheable.__init__</code> or <code>super().__init__</code>) but it is still of type <code>SomeClass</code> during all this. That means it has all the concrete methods required to satisfy <code>ICacheable</code>.</span>
<span class="comment-copy">Interesting, i'm going to play around with this today.  I'll get back and mark this post correct if I get it working. Thanks.</span>
