<div class="post-text" itemprop="text">
<p>I am still kind of a beginner with Python (I don't use it much except from data gathering which is what I am doing now).
I have a couple of CSV which basically consists in a collection of info about several machines, identified by an ID, over several years.
It is something like that:</p>
<pre><code>ID,Year,Variable1,Variable2
1,1990,x,y
1,1991,a,b
1,1992,f,g
2,2000,a,b
2,2001,a,b
</code></pre>
<p>Now my goal is to try and gather that data into a format that I can easily process. Indeed, currently the data is scattered in multiple CSVs, and I would like to make it a single JSON file. </p>
<p><strong>Edit 1:</strong> Other CSVs contain either data per year or more generic data in the format of:</p>
<pre><code>ID,VariableX,VariableY
1,X,Y
2,X,Y
</code></pre>
<p>So I guess my starting question would be concerning what kind of data structure I should use to read and store the CSV data. I thought about using a dictionary, but I don't think a dictionary could have two keys. Then I thought that I could just make some kind of list as the key, but then I don't know how to properly store the info in a JSON format. </p>
<p>That's the reason why I'm asking for your help today.</p>
<p>Thanks in advance.</p>
<p>Have a good day</p>
<p>In the end I would like my a JSON object to be about a single ID, with all the data for multiple years contained such as:</p>
<p><strong>Edit 2:</strong></p>
<pre><code>{
   "ID": "1"
   "1990": {
      "Variable1":"x"
      "Variable2":"y"
   }
   "1991": {...}
) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are several options available to you. Probably the simplest, conceptually, would be a dictionary keyed to a tuple <code>(id, year)</code>, with the values as tuples (variable1, variable2), or as a dict, eg</p>
<pre><code>&gt;&gt;&gt; {(1, 1990): {'v1': 'x', 'v2': 'y'}}
{(1, 1990): {'v1': 'x', 'v2': 'y'}}
</code></pre>
<p>I would consider creating an object to represent this data, though, since it's likely that the problem and your requirements will become more complex as you go along, and an object allows you to define methods to address new requirements as they arise. </p>
<p>An intermediate solution would be a namedtuple, of which a quick example follows:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Machine = namedtuple("Machine", ['id', 'year', 'variable1', 'variable2'])
&gt;&gt;&gt; Machine(1, 1990, 'x', 'y')
Machine(id=1, year=1990, variable1='x', variable2='y')
&gt;&gt;&gt; machines = [Machine(1, 1990, 'x', 'y'), Machine(1, 1991, 'a', 'b'), Machine(2, 2000, 'a', 'b')]
&gt;&gt;&gt; machines_dict = {(m.id, m.year): m for m in machines}
&gt;&gt;&gt; machines_dict[(2, 2000)]
Machine(id=2, year=2000, variable1='a', variable2='b')
&gt;&gt;&gt; 
</code></pre>
<p>(see the <a href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="nofollow noreferrer">documentation</a> for more info on this)</p>
<p>Note that namedtuples do not play well with json serializers, so I still incline towards a simple object which knows how to emit a dict of its data, suitable for serializing. </p>
<p>What I mean by "an object which knows how to emit a dict of its data" would normally just mean that the object has a method which produces a dict of the appropriate keys and shape, for example</p>
<pre><code>def to_dict(self):
  return {"ID": self.id, "year": self.year, "vars": (self.v1, self.v2)}
</code></pre>
<p>However, you want something a little fancier, you want to summarize the data across instances. This will require taking a list of objects (or of data blobs) and doing a little parsing to group by id and list instances by year. Something like:</p>
<pre><code>@staticmethod
def machines_to_dict(machines):
  machines_by_id = defaultdict(list)
  for m in machines:
    machines_by_id[m.id].append(m)
  # now you have machines grouped by id
  return {id: years_to_vars_dict(machines) 
     for id, machines in machines_by_id.items()}

def years_to_vars_dict(machines):
  return {machine.year: {"Var1": machine.var1, 
                         "Var2": machine.var2}
          for machine in machines}
</code></pre>
<p>should work. (but bear in mind that this is not tested and is intended as an example, not as working code) </p>
</div>
<span class="comment-copy">you should use pandas library</span>
<span class="comment-copy">pandas has direct method for <code>read_csv</code> and <code>to_csv</code> to save. same for <code>json</code></span>
<span class="comment-copy">I don't suggest <i>pandas</i> if you are not already using it for some other kind of data processing. CSVs are often read into memory as a list of dictionaries: <code>[{'id': 1, 'year': 1990 ...}]</code>. You can serialize that to JSON directly: <code>json.dumps(mylist)</code>. You don't need a key for each row (note your IDs are not unique), but if you need them, use a derived/natural key (if you can) or a surrogate key.</span>
<span class="comment-copy">agreed @jjmontes.  json.dumps() is better</span>
<span class="comment-copy">In addition, you can and should use <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer">Python CSV library</a>, which already reads CSV files into a list of dictionaries as commented above.</span>
<span class="comment-copy">I appreciate the approach but note that <i>namedtuples</i> are not handled well by the default <i>json</i> serializer (they are serialized as lists, not as dictionaries).</span>
<span class="comment-copy">That's true, but the json requirement was added while I was adding the namedtuple part. Answer edited to note this.</span>
<span class="comment-copy">Thanks for the answer. Sorry that I added the JSON requirement while you were typing. I actually accidentally posted my question before it was over. Would you mind detailing a bit more the object emitting a dict of its data part?</span>
<span class="comment-copy">I can try to sketch something, but it'll be brief and there will be pieces left for you to puzzle over</span>
<span class="comment-copy">@Jon Kiparsky fair enough :)</span>
