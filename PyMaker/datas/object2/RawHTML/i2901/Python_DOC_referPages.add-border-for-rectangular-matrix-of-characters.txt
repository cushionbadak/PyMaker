<div class="post-text" itemprop="text">
<p>I am trying to add * as borders for rectangular matrix of characters. For example, </p>
<pre><code>["abc", "ded"]
</code></pre>
<p>should return </p>
<pre><code>["*****","*abc*","*ded*","*****"]
</code></pre>
<p>What I did was I create a new matrix with 2 more rows and columns than the original one, and I filled it with *. So the problem is when I am replacing the * inside with original letters, I have an error of out of index. I couldn't quite figure out why? </p>
<pre><code>def addBorder(picture):
  m=len(picture) #number of rows
  n=len(picture[0]) #num of columns
  newpic=[['*'*(n+2)]for y in range(m+2)] 
  for x in range(1,m+1):
    for y in range(1,n+1):
     newpic[x][y]=picture[x-1][y-1]
  return newpic  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Strings are immutable, so you can not "edit" single characters inside them bey indexing into them - thats what you are trying in your <code>for x ..:  for y: ...</code> loop.</p>
<p>To keep most of your code, you can change it to:</p>
<pre><code>def addBorder(picture):
  m=len(picture) #number of rows
  n=len(picture[0]) #num of columns
  newpic=[['*'*(n+2)]for y in range(m+2)] 

  for idx,text in enumerate(picture): # get text and index here
     newpic[idx+1] = '*' + text+ '*'  # change text in +1 row in target list
  return newpic 

print(addBorder( ["abc", "ded"]))
</code></pre>
<p>Output:</p>
<pre><code>[['*****'], '*abc*', '*ded*', ['*****']]
</code></pre>
<p>Changing more code:</p>
<pre><code>def addBorder(picture):
    # slightly more compley length computation, will work for ragged text as well
    maxL = max(len(x) for x in picture) 
    patt = "*{:&lt;"+str(maxL)+"}*"   # left justified by maxL , see link below
    rv = []
    rv.append('*'*(maxL+2))    # top border

    for t in picture:
        rv.append(patt.format(t)) # text + adornment

    rv.append('*'*(maxL+2))    # bottom border

    return rv

print(addBorder( ["abc", "defgh","i"]))
</code></pre>
<p>Output:</p>
<pre><code>['*******', 
 '*abc  *', 
 '*defgh*', 
 '*i    *', 
 '*******']
</code></pre>
<p>Link:  <a href="https://docs.python.org/3/library/string.html#formatspec" rel="nofollow noreferrer">string format mini language</a></p>
<hr/>
<p><strike>Your out of index error message is somewhat misleading - you are inside the bounds of your lists, but you are trying to manipulate the string - I would have thought a <code>'str' object does not support item assignment</code> would be more appropriate here...</strike></p>
<p>Edit: see <a href="https://stackoverflow.com/a/51759697/7505395">Azats answer</a> for why your error occurs - I left text in so his post does not loose its reference.</p>
<p><a href="https://i.stack.imgur.com/H1zVV.png" rel="nofollow noreferrer"><img alt="debugging your code" src="https://i.stack.imgur.com/H1zVV.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>If I understood correctly, you are trying to </p>
<ol>
<li>Create filled with * <code>newpic</code>.</li>
<li>Modify <code>newpic[1:-1]</code> and replace * (excluding borders) with <code>picture</code> elements contents.</li>
</ol>
<p>This approach has a problem with <code>str</code> objects immutability, but even if they were mutable this seems to be inefficient to create **...** string and then mutate them character-by-character.</p>
<p>About your error: it isn't misleading as stated by @PatrickArtner, it originates from a typo (I guess), because you are creating <code>list</code>s of <code>list</code> of <code>str</code>:</p>
<pre><code>&gt;&gt;&gt; m = 3
&gt;&gt;&gt; n = 4
&gt;&gt;&gt; [['*'*(n+2)]for y in range(m+2)]
[['******'], ['******'], ['******'], ['******'], ['******']]
</code></pre>
<p>so when <code>y</code> equals to <code>1</code> you are getting this error (because each of <code>newpic</code> sublists has single <code>str</code> element inside of them).</p>
<p>Instead of trying to modify <code>list</code> of <code>str</code> we can create <code>list</code> and append <code>str</code> to it like</p>
<pre><code>def addBorder(picture,
              border_size=1):
    max_substring_length = max(map(len, picture))
    # top border
    result = ['*' * (max_substring_length + border_size * 2)]
    for substring in picture:
        diff = max_substring_length - len(substring)
        additional_length, extra = divmod(diff, 2)
        # handling non-equivalent case
        prepend = '*' * (border_size + additional_length + extra)
        append = '*' * (border_size + additional_length)
        result.append(prepend + substring + append)
    # bottom border
    result.append('*' * (max_substring_length + border_size * 2))
    return result
</code></pre>
<h1>Test</h1>
<pre><code>for string in addBorder(["abc", "ded"]):
    print(string)
</code></pre>
<p>gives us</p>
<pre><code>*****
*abc*
*ded*
*****
</code></pre>
<p>non-equivalent by size case</p>
<pre><code>for string in addBorder(["abc", "deed"]):
    print(string)
</code></pre>
<p>gives us</p>
<pre><code>******
**abc*
*deed*
******
</code></pre>
</div>
<span class="comment-copy">are you trying to mutate <code>str</code> inside of <code>newpic</code>?</span>
<span class="comment-copy">what should happen in case of <code>picture</code> with non-equivalent-by-size <code>str</code>?</span>
<span class="comment-copy">Good catch - I oversaw the <code>[[""],]</code> - I edited mybotch but left it in so yours does keep its "referecing" point into mine.</span>
