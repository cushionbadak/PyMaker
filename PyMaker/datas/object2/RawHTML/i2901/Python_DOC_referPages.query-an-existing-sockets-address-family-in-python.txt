<div class="post-text" itemprop="text">
<p>I'm passing a socket file descriptor using a UNIX domain socket to a Python 3 program. I would like to query the socket and determine its address family.</p>
<p>In this <a href="https://stackoverflow.com/a/513333/46192">answer</a> the <code>getsockname</code> system call is used to achieve the same result in C. However, Python's <code>socket.getsockname</code> function doesn't return the address family, instead assuming the caller already knows it. Furthermore, it only works on sockets, not on file descriptors, and creating a socket object from a file descriptor requires passing the address family as well.</p>
<p>Is there a way to query the address family from Python?</p>
<p>EDIT: I want to emphasize that I am looking for the address family of an already open socket, for which I have the file descriptor.</p>
</div>
<div class="post-text" itemprop="text">
<p>You just pass the file descriptor to <code>socket.socket</code>, giving it as the <code>fileno=</code> keyword attribute. The socket class figures out the type of socket corresponding to the file descriptor. You can then find the family as @klaus suggested: with <code>s.family</code>.</p>
<pre><code>import socket

s = socket.socket()
print("original socket", s)
desc = s.fileno()
print("file descriptor", type(desc), desc)
new_s = socket.socket(fileno=desc)
print("new socket", new_s.family, int(new_s.family))
</code></pre>
<p>Here I'm creating a socket in python, but then extracting the file descriptor from the socket object (producing an ordinary <code>int</code> containing the descriptor number) so as to demonstrate putting it back into a new socket object. Running the above produces:</p>
<pre><code>original socket &lt;socket.socket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('0.0.0.0', 0)&gt;
file descriptor &lt;class 'int'&gt; 3
new socket AddressFamily.AF_INET 2
</code></pre>
<p><strong>EDIT</strong><br/>
Hmm... the above method does not seem to work with <code>AF_INET6</code> sockets, at least in my python 3.5.2 version.</p>
<pre><code>s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
new_s = socket.socket(fileno=s.fileno())
print(new_s)
&lt;socket.socket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('::%1', 0, 0, 1)&gt;
</code></pre>
<p>That seems like a clear bug to me. The documentation says:</p>
<blockquote>
<p>If fileno is specified, the values for family, type, and proto are auto-detected from the specified file descriptor.</p>
</blockquote>
<p>You may need to examine <code>new_s.laddr</code> and heuristically determine the family. (For <code>AF_INET6</code>, <code>laddr</code> will be a 4-tuple, whereas <code>AF_INET</code> uses a 2-tuple). If you expect <code>AF_UNIX</code> or other families, you might need to extend that.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can query a socket's address family in python checking the .family attribute. There are other attributes saved in the sock object also</p>
<pre><code>import socket
import sys
# Create a TCP/IP socket
sock = socket.create_connection(('www.stackoverflow.com', 80))
print(sock)
print(sock.family)
</code></pre>
<p>The output is</p>
<pre><code>&lt;socket.socket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('x.x.x.x', y), raddr=('x.x.x.x', 80)&gt;
AddressFamily.AF_INET
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want information about the socket, I would suggest <code>socket.getaddrinfo</code>.</p>
<p><a href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" rel="nofollow noreferrer">Documentation</a>: </p>
<blockquote>
<p>The function returns a list of 5-tuples with the following structure:</p>
<p>(family, type, proto, canonname, sockaddr)</p>
</blockquote>
<pre><code>&gt;&gt;&gt; socket.getaddrinfo("example.org", 80, proto=socket.IPPROTO_TCP)
[(&lt;AddressFamily.AF_INET6: 10&gt;, &lt;SocketType.SOCK_STREAM: 1&gt;,
 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),
 (&lt;AddressFamily.AF_INET: 2&gt;, &lt;SocketType.SOCK_STREAM: 1&gt;,
 6, '', ('93.184.216.34', 80))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution based on ctypes I wrote so I could use older versions of Python:</p>
<pre><code>import os
import socket
from ctypes import *

libc = CDLL('libc.so.6', use_errno=True)
libc.getsockname.argtypes = [c_int, c_void_p, POINTER(c_int32)]
libc.getsockopt.argtypes = [c_int, c_int, c_int, c_void_p, POINTER(c_int32)]

def get_sock_family(fd):
    family = c_ushort(0)
    length = c_int32(sizeof(family))
    ret = libc.getsockname(fd, byref(family), length)
    if ret:
        errno = get_errno()
        raise OSError(errno, os.strerror(errno))

    return socket.AddressFamily(family.value)

def get_sock_type(fd):
    socket_type = c_int()
    length = c_int32(sizeof(socket_type))
    ret = libc.getsockopt(fd, socket.SOL_SOCKET, socket.SO_TYPE, byref(socket_type), length)
    if ret:
        errno = get_errno()
        raise OSError(errno, os.strerror(errno))

    return socket.SocketKind(socket_type.value)
</code></pre>
</div>
<span class="comment-copy">Thanks. I completely missed this part of the documentation. I see there is an open ticket about this: <a href="https://bugs.python.org/issue28134" rel="nofollow noreferrer">bugs.python.org/issue28134</a>, although I checked Python 3.7 on Linux and it worked there.</span>
<span class="comment-copy">Thanks, but as I wrote palivek, I want to find the address family of an existing socket, for which I have an open file descriptor, not to translate an address to find the selected address family.</span>
<span class="comment-copy">Thanks, but I want to find the address family of an existing socket, for which I have an open file descriptor, not to translate an address.</span>
