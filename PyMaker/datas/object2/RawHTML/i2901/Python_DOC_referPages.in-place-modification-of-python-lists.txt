<div class="post-text" itemprop="text">
<p>I am trying to perform in-place modification of a list of list on the level of the primary list. However, when I try to modify the iterating variable (<code>row</code> in the example below), it appears to create a new pointer to it rather than modifying it.</p>
<hr/>
<p>Smallest example of my problem. </p>
<pre><code>c = [1,2,3]
for x in c:
    x = x + 3
print(c) #returns [1,2,3], expected [4,5,6]
</code></pre>
<p>The above example is a trivial example of my problem. Is there a way to modify <code>x</code> elementwise, in-place and have the changes appear in C?</p>
<hr/>
<p>Less trivial example of my problem. I am switching all 0's to 1's and vice-versa.</p>
<pre><code>A =  [[1,1,0],
      [1,0,1],
      [0,0,0]]
for row in A:
    row = list(map(lambda val: 1 - val, row))
print(A)
</code></pre>
<p>Expected </p>
<pre><code>A = [[0,0,1],
     [0,1,0],
     [1,1,1]]
</code></pre>
<p>Returned</p>
<pre><code>A = [[1,1,0],
     [1,0,1],
     [0,0,0]]
</code></pre>
<hr/>
<p>update:
Great answers so far. I am interested how the iterating variable (<code>row</code> in the second example) is linked to the iterable variable (<code>A</code> in the second example).</p>
<p>If I do the following, which reverses each sublist of A, it works perfectly.</p>
<p>Why does the following example, where I modify the iterating variable works but the above examples do not?</p>
<pre><code>A =  [[1,1,0],
  [1,0,1],
  [0,0,0]]

for row in A:
    row.reverse()
print(A)

#returns, as expected
A = [[0, 1, 1],
     [1, 0, 1], 
     [0, 0, 0]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found this in the docs: <a href="https://docs.python.org/3/tutorial/controlflow.html#for" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/controlflow.html#for</a></p>
<blockquote>
<p>Pythonâ€™s for statement iterates over the items of any sequence (a list
  or a string), in the order that they appear in the sequence.</p>
<p>If you need to modify the sequence you are iterating over while inside
  the loop (for example to duplicate selected items), it is recommended
  that you first make a copy. Iterating over a sequence does not
  implicitly make a copy.</p>
</blockquote>
<p>I was wrong in my first response, when iterating through a list it returns the actual items in that list. However, it seems they cannot be edited directly while they are being iterated through. This is why iterating through the integers the length of the list works. </p>
<p>As for why the <code>.reverse()</code> function works, I think it's because it is affecting a list instead of a value. I tried to use similar built in functions on nonlist datatypes like <code>.replace()</code> on strings and it had no effect. </p>
<p>All of the other list functions I tried worked: <code>.append()</code>, <code>.remove()</code>, and <code>.reverse()</code> as you showed. I'm not sure why this is, but I hope it clears up what you can do in for loops a bit more.</p>
<p>Answer to old question below:</p>
<p>The way you are using the for loops doesn't affect the actual list, just the temporary variable that is iterating through the list. There are a few ways you can fix this. Instead of iterating through each element you can can count up to the length of the list and modify the list directly.</p>
<pre><code>c = [1,2,3]
for n in range(len(c)):
    c[n] += 3
print(c) 
</code></pre>
<p>You can also use the <code>enumerate()</code> function to iterate through both a counter and list items.</p>
<pre><code>c = [1,2,3]
for n, x in enumerate(c):
    c[n] = x + 3
print(c) 
</code></pre>
<p>In this case, n is a counter and x is the item in the list. </p>
<p>Finally, you can use list comprehension to generate a new list with desired differences in one line.</p>
<pre><code>c = [1, 2, 3]
d = [x + 3 for x in c]
print(d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The usual way to poke values into an existing list in Python is to use <a href="https://www.geeksforgeeks.org/enumerate-in-python/" rel="nofollow noreferrer"><code>enumerate</code></a> which lets you iterate over both the indices and the values at once -- then use the indices to manipulate the list:</p>
<pre><code>c = [1,2,3]
for index, value in enumerate(c):
    c[index] = value + 3
</code></pre>
<p>For your second example you'd do almost the same:</p>
<pre><code>A =  [[1,1,0],
  [1,0,1],
  [0,0,0]]

for row in A:
    for index, val in row:
        row[index] = 0 if val &gt; 0 else 1
</code></pre>
<p>In the second example the list objects in <code>A</code> become the loop variable <code>row</code> -- and since you're only mutating them (not assigning to them) you don't need <code>enumerate</code> and the index</p>
</div>
<span class="comment-copy">I've updated my answer.</span>
<span class="comment-copy">You could also do just <code>c[n] += 3</code></span>
