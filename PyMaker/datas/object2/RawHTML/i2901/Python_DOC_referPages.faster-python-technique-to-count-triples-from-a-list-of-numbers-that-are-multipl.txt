<div class="post-text" itemprop="text">
<p>Suppose we have a list of numbers, <code>l</code>. I need to COUNT all tuples of length 3 from <code>l</code>, <code>(l_i,l_j,l_k)</code> such that <code>l_i</code> evenly divides <code>l_j</code>, and <code>l_j</code> evenly divides <code>l_k</code>. With the stipulation that the indices <code>i,j,k</code> have the relationship <code>i&lt;j&lt;k</code> </p>
<p>I.e.;</p>
<p>If <code>l=[1,2,3,4,5,6]</code>, then the tuples would be <code>[1,2,6], [1,3,6],[1,2,4]</code>, so the <code>COUNT</code> would be 3.</p>
<p>If <code>l=[1,1,1]</code>, then the only tuple would be <code>[1,1,1]</code>, so the <code>COUNT</code> would be 1.</p>
<p>Here's what I've done so far, using list comprehensions:</p>
<pre><code>def myCOUNT(l):
    newlist=[[x,y,z] for x in l for y in l for z in l if (z%y==0 and y%x==0 and l.index(x)&lt;l.index(y) and l.index(y)&lt;l.index(z))]
    return len(newlist)

&gt;&gt;&gt;l=[1,2,3,4,5,6]
&gt;&gt;&gt;myCOUNT(l)
3
</code></pre>
<p>This works, but as <code>l</code> gets longer (and it can be as large as 2000 elements long), the time it takes increases too much. Is there a faster/better way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>We can count the number of triples with a given number in the middle by counting how many factors of that number are to its left, counting how many multiples of that number are to its right, and multiplying. Doing this for any given middle element is O(n) for a length-n list, and doing it for all n possible middle elements is O(n^2).</p>
<pre><code>def num_triples(l):
    total = 0
    for mid_i, mid in enumerate(l):
        num_left = sum(1 for x in l[:mid_i] if mid % x == 0)
        num_right = sum(1 for x in l[mid_i+1:] if x % mid == 0)
        total += num_left * num_right
    return total
</code></pre>
<p>Incidentally, the code in your question doesn't actually work. It's fallen into the common newbie trap of calling <code>index</code> instead of using <code>enumerate</code> to get iteration indices. More than just being inefficient, this is actually wrong when the input has duplicate elements, causing your <code>myCOUNT</code> to <a href="https://ideone.com/3Zwtzp" rel="noreferrer">return 0 instead of 1</a> on the <code>[1, 1, 1]</code> example input.</p>
</div>
<div class="post-text" itemprop="text">
<h1><em>Finding</em> all tuples in <em>O(n<sup>2</sup>)</em></h1>
<p>You algorithm iterates over all possible combinations, which makes it <em>O(n<sup>3</sup>)</em>.</p>
<p>Instead, you should precompute the division-tree of your list of numbers and recover triples from the paths down the tree.</p>
<h1>Division tree</h1>
<p>A division tree is a graph which nodes are numbers and children are the multiples of each number.</p>
<p>By example, given the list <code>[1, 2, 3, 4]</code>, the division tree looks like this.</p>
<pre><code>   1
  /|\
 2 | 3
  \|
   4
</code></pre>
<p>Computing the division tree requires to compare each number against all others, making its creation <em>O(n<sup>2</sup>)</em>.</p>
<p>Here is a basic implementation of a division-tree that can be used for your problem.</p>
<pre><code>class DivisionTree:
    def __init__(self, values):
        values = sorted(values)

        # For a division-tree to be connected, we need 1 to be its head
        # Thus we artificially add it and note whether it was actually in our numbers
        if 1 in values:
            self._has_one = True
            values = values[1:]
        else:
            self._has_one = False

        self._graph = {1: []}

        for v in values:
            self.insert(v)

    def __iter__(self):
        """Iterate over all values of the division-tree"""
        yield from self._graph

    def insert(self, n):
        """Insert value in division tree, adding it as child of each divisor"""
        self._graph[n] = []

        for x in self:
            if n != x and n % x == 0:
                self._graph[x].append(n)

    def paths(self, depth, _from=1):
        """Return a generator of all paths of *depth* down the division-tree"""
        if _from == 1:
            for x in self._graph[_from]:
                yield from self.paths(depth , _from=x)

        if depth == 1:
            yield [_from]
            return

        if _from != 1 or self._has_one:
            for x in self._graph[_from]:
                for p in self.paths(depth - 1, _from=x):
                    yield [_from, *p]
</code></pre>
<h1>Usage</h1>
<p>Once we built a <code>DivisionTree</code>, it suffices to iterate over all paths down the graph and select only those which have length 3.</p>
<h3>Example</h3>
<pre><code>l = [1,2,3,4,5,6]

dt = DivisionTree(l)

for p in dt.paths(3):
    print(p)
</code></pre>
<h3>Output</h3>
<pre><code>[1, 2, 4]
[1, 2, 6]
[1, 3, 6]
</code></pre>
<p>This solution assumes that the list of number is initially sorted, as in your example. Although, the output could be filtered with regard to the condition on indices <code>i &lt; j &lt; k</code> to provide a more general solution.</p>
<h1>Time complexity</h1>
<p>Generating the division-tree is <em>O(n<sup>2</sup>)</em>.</p>
<p>In turn, there can be up to <em>n!</em> different paths, although stopping the iteration whenever we go deeper than <em>3</em> prevents traversing them all. This makes us iterate over the following paths:</p>
<ul>
<li><p>the paths corresponding to three tuples, say there are <em>m</em> of them;</p></li>
<li><p>the paths corresponding to two tuples, there are <em>O(n<sup>2</sup>)</em> of them;</p></li>
<li><p>the paths corresponding to one tuples, there are <em>O(n)</em> of them.</p></li>
</ul>
<p>Thus this overall yields an algorithm <em>O(n<sup>2</sup> + m)</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose this solution without list comprehension will be faster (you can see analogue with list comprehension further):</p>
<pre><code>a = [1, 2, 3, 4, 5, 6]

def count(a):   
    result = 0
    length = len(a)

    for i in range(length):
        for j in range(i + 1, length):
            for k in range(j + 1, length):
                if a[j] % a[i] == 0 and a[k] % a[j] == 0:
                    result += 1

    return result

print(count(a))
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>3
</code></pre>
<p>In your solution <code>index</code> method is too expensive (requires O(n) operations). Also you don't need to iterate over full list for each <code>x</code>, <code>y</code> and <code>z</code> (<code>x = a[i]</code>, <code>y = a[j]</code>, <code>z = a[k]</code>). Notice how I use indexes in my loops for <code>y</code> and <code>z</code> because I know that <code>a.index(x) &lt; a.index(y) &lt; a.index(z)</code> is always satisfied.</p>
<hr/>
<p>You can write it as one liner too:</p>
<pre><code>def count(a):   
    length = len(a)

    return sum(1 for i in range(length)
               for j in range(i + 1, length)
               for k in range(j + 1, length)
               if a[j] % a[i] == 0 and a[k] % a[j] == 0)
</code></pre>
<hr/>
<p>P.S.
Please, don't use <code>l</code> letter for variables names because it's very similar to <code>1</code>:)</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a way to do this with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertools combinations</a>:</p>
<pre><code>from itertools import combinations 
l=[1,2,3,4,5,6] 

&gt;&gt;&gt; [(x,y,z) for x,y,z in combinations(l,3) if z%y==0 and y%x==0]
[(1, 2, 4), (1, 2, 6), (1, 3, 6)]
</code></pre>
<p>Since combinations generates the tuples in list order, you do not then need to check the index of <code>z</code>.</p>
<p>Then your <code>myCOUNT</code> function becomes:</p>
<pre><code>def cnt(li):
    return sum(1 for x,y,z in combinations(li,3) if z%y==0 and y%x==0)

&gt;&gt;&gt; cnt([1,1,1])
1
&gt;&gt;&gt; cnt([1,2,3,4,5,6])
3
</code></pre>
<hr/>
<p>This is a <a href="https://www.hackerrank.com/challenges/count-triplets-1/problem?h_l=interview&amp;playlist_slugs%5B%5D=interview-preparation-kit&amp;playlist_slugs%5B%5D=dictionaries-hashmaps" rel="nofollow noreferrer">known problem</a>.</p>
<p>Here are some timing for the solutions here:</p>
<pre><code>from itertools import combinations 

class DivisionTree:
    def __init__(self, values):    
        # For a division-tree to be connected, we need 1 to be its head
        # Thus we artificially add it and note whether it was actually in our numbers
        if 1 in values:
            self._has_one = True
            values = values[1:]
        else:
            self._has_one = False

        self._graph = {1: []}

        for v in values:
            self.insert(v)

    def __iter__(self):
        """Iterate over all values of the division-tree"""
        yield from self._graph

    def insert(self, n):
        """Insert value in division tree, adding it as child of each divisor"""
        self._graph[n] = []

        for x in self:
            if n != x and n % x == 0:
                self._graph[x].append(n)

    def paths(self, depth, _from=1):
        """Return a generator of all paths of *depth* down the division-tree"""
        if _from == 1:
            for x in self._graph[_from]:
                yield from self.paths(depth , _from=x)

        if depth == 1:
            yield [_from]
            return

        if _from != 1 or self._has_one:
            for x in self._graph[_from]:
                for p in self.paths(depth - 1, _from=x):
                    yield [_from, *p]


def f1(li):
    return sum(1 for x,y,z in combinations(li,3) if z%y==0 and y%x==0)

def f2(l):
    newlist=[[x,y,z] for x in l for y in l for z in l if (z%y==0 and y%x==0 and l.index(x)&lt;l.index(y) and l.index(y)&lt;l.index(z))]
    return len(newlist)

def f3(a):   
    result = 0
    length = len(a)

    for i in range(length):
        for j in range(i + 1, length):
            for k in range(j + 1, length):
                if a[j] % a[i] == 0 and a[k] % a[j] == 0:
                    result += 1

    return result

def f4(l):
    dt = DivisionTree(l)
    return sum(1 for _ in dt.paths(3))  

def f5(l):
    total = 0
    for mid_i, mid in enumerate(l):
        num_left = sum(1 for x in l[:mid_i] if mid % x == 0)
        num_right = sum(1 for x in l[mid_i+1:] if x % mid == 0)
        total += num_left * num_right
    return total    


if __name__=='__main__':
    import timeit
    tl=list(range(3,155))
    funcs=(f1,f2,f3,f4,f5)
    td={f.__name__:f(tl) for f in funcs}
    print(td)
    for case, x in (('small',50),('medium',500),('large',5000)):
        li=list(range(2,x))
        print('{}: {} elements'.format(case,x))
        for f in funcs:
            print("   {:^10s}{:.4f} secs".format(f.__name__, timeit.timeit("f(li)", setup="from __main__ import f, li", number=1))) 
</code></pre>
<p>And the results:</p>
<pre><code>{'f1': 463, 'f2': 463, 'f3': 463, 'f4': 463, 'f5': 463}
small: 50 elements
       f1    0.0010 secs
       f2    0.0056 secs
       f3    0.0018 secs
       f4    0.0003 secs
       f5    0.0002 secs
medium: 500 elements
       f1    1.1702 secs
       f2    5.3396 secs
       f3    1.8519 secs
       f4    0.0156 secs
       f5    0.0110 secs
large: 5000 elements
       f1    1527.4956 secs
       f2    6245.9930 secs
       f3    2074.2257 secs
       f4    1.3492 secs
       f5    1.2993 secs
</code></pre>
<p>You can see that <code>f1,f2,f3</code> are clearly O(n^3) or worse and <code>f4,f5</code> are O(n^2). <code>f2</code> took more than 90 minutes for what <code>f4</code> and <code>f5</code> did in 1.3 seconds. </p>
</div>
<div class="post-text" itemprop="text">
<h1>Solution in O(M*log(M)) for a sorted list containing positive numbers</h1>
<p>As user2357112 has answered, we can count the number of triplets in O(n^2) by calculating for every number the number of its factors and multiples. However, if instead of comparing every pair we go over its multiples smaller than the largest number and check whether they are in the list, we can change the efficiency to O(N+M*log(N)), when M is the largest number in the list.</p>
<p>Code:</p>
<pre><code>def countTriples(myList):
    counts = {} #Contains the number of appearances of every number.
    factors = {} #Contains the number of factors of every number.
    multiples = {} #Contains the number of multiples of every number.

    for i in myList: #Initializing the dictionaries.
        counts[i] = 0
        factors[i] = 0
        multiples[i] = 0

    maxNum = max(myList) #The maximum number in the list.

    #First, we count the number of appearances of every number.
    for i in myList:
        counts[i] += 1

    #Then, for every number in the list, we check whether its multiples are in the list.
    for i in counts:
        for j in range(2*i, maxNum+1, i):
            if(counts.has_key(j)):
                factors[j] += counts[i]
                multiples[i] += counts[j]

    #Finally, we count the number of triples.
    ans = 0
    for i in counts:
        ans += counts[i]*factors[i]*multiples[i] #Counting triplets with three numbers.
        ans += counts[i]*(counts[i]-1)*factors[i]/2 #Counting triplets with two larger and one smaller number.
        ans += counts[i]*(counts[i]-1)*multiples[i]/2 #Counting triplets with two smaller numbers and one larger number.
        ans += counts[i]*(counts[i]-1)*(counts[i]-2)/6 #Counting triplets with three copies of the same number.

    return ans
</code></pre>
<p>While this solution will work quickly for lists containing many small numbers, it will not work for lists containing large numbers:</p>
<pre><code>countTriples(list(range(1,1000000)) #Took 80 seconds on my computer
countTriples([1,2,1000000000000]) #Will take a very long time
</code></pre>
<h1>Fast solution with unknown efficiency for unsorted lists</h1>
<p>Another method to count the number of multiples and factors of every number in the list would be to use a binary tree data structure, with leaves corresponding to numbers. The data structure supports three operations:</p>
<p>1) Add a number to every position which is a multiple of a number.</p>
<p>2) Add a number to every position which is specified in a set.</p>
<p>3) Get the value of a position.</p>
<p>We use lazy propagation, and propagate the updates from the root to lower nodes only during queries.</p>
<p>To find the number of factors of every item in the list, we iterate over the list, query the number of factors of the current item from the data structure, and add 1 to every position which is a multiple of the item.</p>
<p>To find the number of multiples of every item, we first find for every item in the list all its factors using the algorithm described in the previous solution.</p>
<p>We then iterate over the list in the reverse order. For every item, we query the number of its multiples from the data structure, and add 1 to its factors in the data structure.</p>
<p>Finally, for every item, we add the multiplication of its factors and multiples to the answer.</p>
<p>Code:</p>
<pre><code>'''A tree that supports two operations:
    addOrder(num) - If given a number, adds 1 to all the values which are multiples of the given number. If given a tuple, adds 1 to all the values in the tuple.
    getValue(num) - returns the value of the number.
    Uses lazy evaluation to speed up the algorithm.
'''
class fen:
    '''Initiates the tree from either a list, or a segment of the list designated by s and e'''
    def __init__(this, l, s = 0, e = -1):
        if(e == -1): e = len(l)-1
        this.x1 = l[s]
        this.x2 = l[e]

        this.val = 0
        this.orders = {}

        if(s != e):
            this.s1 = fen(l, s, (s+e)/2)
            this.s2 = fen(l, (s+e)/2+1, e)
        else:
            this.s1 = None
            this.s2 = None

    '''Testing if a multiple of the number appears in the range of this node.'''
    def _numGood(this, num):
        if(this.x2-this.x1+1 &gt;= num): return True
        m1 = this.x1%num
        m2 = this.x2%num
        return m1 == 0 or m1 &gt; m2

    '''Testing if a member of the group appears in the range of this node.'''
    def _groupGood(this, group):
        low = 0
        high = len(group)
        if(this.x1 &lt;= group[0] &lt;= this.x2): return True
        while(low != high-1):
            mid = (low+high)/2;
            if(group[mid] &lt; this.x1): low = mid
            elif(group[mid] &gt; this.x2): high = mid
            else: return True
        return False

    def _isGood(this, val):
        if(type(val) == tuple):
            return this._groupGood(val)
        return this._numGood(val)

    '''Adds an order to this node.'''
    def addOrder(this, num, count = 1):
        if(not this._isGood(num)): return
        if(this.x1 == this.x2): this.val += count
        else :this.orders[num] = this.orders.get(num, 0)+count

    '''Pushes the orders to lower nodes.''' 
    def _pushOrders(this):
        if(this.x1 == this.x2): return
        for i in this.orders:
            this.s1.addOrder(i, this.orders[i])
            this.s2.addOrder(i, this.orders[i])
        this.orders = {}

    def getValue(this, num):
        this._pushOrders()
        if(num &lt; this.x1 or num &gt; this.x2):
            return 0
        if(this.x1 == this.x2):
            return this.val
        return this.s1.getValue(num)+this.s2.getValue(num)

def countTriples2(myList):
    factors = [0 for i in myList]
    multiples = [0 for i in myList]

    numSet = set((abs(i) for i in myList))
    sortedList = sorted(list(numSet))

    #Calculating factors.
    tree = fen(sortedList)
    for i in range(len(myList)):
        factors[i] = tree.getValue(abs(myList[i]))
        tree.addOrder(abs(myList[i]))

    #Calculating the divisors of every number in the group.
    mxNum = max(numSet)
    divisors = {i:[] for i in numSet}

    for i in sortedList:
        for j in range(i, mxNum+1, i):
            if(j in numSet):
                divisors[j].append(i)
    divisors = {i:tuple(divisors[i]) for i in divisors}
    #Calculating the number of multiples to the right of every number.
    tree = fen(sortedList)
    for i in range(len(myList)-1, -1, -1):
        multiples[i] = tree.getValue(abs(myList[i]))
        tree.addOrder(divisors[abs(myList[i])])

    ans = 0
    for i in range(len(myList)):
        ans += factors[i]*multiples[i]

    return ans
</code></pre>
<p>This solution worked for a list containing the numbers 1..10000 in six seconds on my computer, and for a list containing the numbers 1..100000 in 87 seconds.</p>
</div>
<span class="comment-copy">Are you looking for a faster list comprehension, or the fastest solution (even if that means not using a list comprehension)?  If the latter, what else have you tried?</span>
<span class="comment-copy">Nested <code>for</code> loops will let you avoid those costly <code>l.index</code> calls.</span>
<span class="comment-copy">You could also shortcut and not do the innermost loop for <code>l_i</code> and <code>l_j</code> that fail your criteria.</span>
<span class="comment-copy">@PatrickHaugh--could you explain in a bit more detail what you mean here? Thank you!</span>
<span class="comment-copy">Are the elements guaranteed to be sorted? Or is that just a coincidence in the example?</span>
<span class="comment-copy">It makes sense that I fell into a newbie trap, since I've only been seriously learning python for less than 6 months (and I'm teaching myself). Thank you for the help!</span>
<span class="comment-copy">I agree that this will be faster--however, I feel like there's some sort of theorem about the count of 3-tuples that satisfy the division requirement. The actual problem doesn't ask for the 3-tuples, just how many there are total. So I'm suspicious that there's a simpler answer than generating all paths and then selecting those of length 3. But this is all great stuff--I really appreciate it!</span>
<span class="comment-copy">@EmmGee I misread that you only needed to count them, then <a href="https://stackoverflow.com/a/51805205/5079316">this answer</a> is probably the best. Although, I'll leave my answer up for anyone that needs to <i>find</i> the tuples efficiently.</span>
<span class="comment-copy">You don't seem to be accounting for the i&lt;j&lt;k constraint on the indices.</span>
<span class="comment-copy">@user2357112 You are right it does not. I'll leave a note for now and fix that later</span>
<span class="comment-copy">For some reason, this returns different values for my test cases. Also, when <code>l</code> is very large (i.e.; 2000 numbers in length), it takes too long...</span>
<span class="comment-copy">But I do appreciate your solution!</span>
<span class="comment-copy">If we're concerned with speed over readability, lookups <code>a[i]</code> should be faster than slices <code>a[j+1:]</code>, especially for very large inputs</span>
<span class="comment-copy">@EmmGee This is because solution is O(n^3). I'm sure that you can't improve this asymptotic. Maybe you should try to rewrite my solution in <a href="https://github.com/python/cpython" rel="nofollow noreferrer">CPython</a> or just in C/C++. It will be reasonably faster.</span>
<span class="comment-copy">@LevZakharov I appreciate your solutions! Unfortunately, they all are seeming to take too long...I think there's probably some number-theory based solution having to do with the number of divisors of each element in <code>l</code>, so maybe I'll poke around the mathematicians and get back to this later.</span>
<span class="comment-copy">This also works, but again, takes too long. There must be a solution beyond brute forcing it...</span>
<span class="comment-copy">You seem to have forgotten to account for triples involving two or three copies of the same number.</span>
<span class="comment-copy">Also, if you want to handle negatives, it's not enough to just do <code>i = -i</code>. You also need to account for negative <i>multiples</i> of each number, and assuming the list is sorted no longer guarantees that divisors are on the left and multiples are on the right.</span>
<span class="comment-copy">Thank you for pointing out these mistakes. They are fixed now.</span>
