<div class="post-text" itemprop="text">
<p>Trying to learn to type hint in Python. Given these two functions:</p>
<pre><code>from typing import Union, TextIO


def myfunc_ok(file: TextIO):
    mydump = file.read()
    print(mydump)


def myfunc_error(file: Union[str, TextIO]):
    mydump = file.read()
    print(mydump)
</code></pre>
<p>First one is ok to mypy, but it complains about the second one with an error</p>
<pre><code>Item "str" of "Union[str, TextIO]" has no attribute "read"
</code></pre>
<p>Am I using type hinting incorrenctly in this case?
(Using python3.7 with mypy 0.610, also tested with py3.6)</p>
</div>
<div class="post-text" itemprop="text">
<p>Your signature</p>
<pre><code>def myfunc_error(file: Union[str, TextIO]):
    ...
</code></pre>
<p>says that <code>file</code> parameter can be <code>str</code> or <code>TextIO</code>, after that in function body you are trying to access <code>.read</code> attribute of <code>file</code> object, but in case of <code>file</code> being <code>str</code> there is no such attribute hence the error.</p>
<p>You have at least 3 possibilities here:</p>
<ul>
<li>do not support case with <code>file</code> being of type <code>str</code> and replace <code>Union[str, TextIO]</code> with <code>TextIO</code></li>
<li><p>add explicit type checking using <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer"><code>isinstance</code> built-in</a> in function body like</p>
<pre><code>import io
...
def myfunc_error(file: Union[str, TextIO]):
    if isinstance(file, io.TextIOWrapper):
        mydump = file.read()
    else:
        # assuming ``file`` is a required object already
        mydump = file
    print(mydump)
</code></pre>
<p>this may become difficult to maintain in the long term</p></li>
<li><p>write 2 different functions for given task: one for <code>str</code> parameter and one for <code>TextIO</code> parameter like</p>
<pre><code>def myfunc_error_str_version(file: str):
    mydump = file
    print(mydump)

def myfunc_error_text_io_version(file: TextIO):
    mydump = file.read()
    print(mydump)
</code></pre>
<p>this may cause a lot of naming problems (but it depends on the use-case)</p></li>
</ul>
<p>The last approach can be improved using <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer"><code>functools.singledispatch</code> decorator</a>: in short this will allow us to define a <a href="https://docs.python.org/3/glossary.html#term-generic-function" rel="nofollow noreferrer">generic function</a> &amp; use a name <code>myfunc_error</code> with overloads called based on the type of first positional argument (<code>file</code> in our case):</p>
<pre><code>import io
from functools import singledispatch
from typing import TextIO


@singledispatch
def myfunc_error(file: str):
    mydump = file
    print(mydump)

# using ``typing.TextIO`` will not work because it's just an interface for type annotations,
# "real" types are located at ``io`` module
@myfunc_error.register(io.TextIOWrapper)
def _(file: TextIO):
    mydump = file.read()
    print(mydump)
</code></pre>
<p><strong>Note</strong>: we can use any name we want instead of <code>_</code> except <code>myfunc_error</code>, for the latter <code>mypy</code> will raise a name conflict error.</p>
</div>
<span class="comment-copy">What is your confusion? The <code>str</code> type <i>does not</i> have a read method. Using <code>.read()</code> on a variable that <i>may be</i> <code>str</code> is therefore wrong.</span>
<span class="comment-copy">My confusion here was assuming mypy was not smart enough to test if function call (read in this case) was inside a isinstance test of the correct type... Really astounding... The aim is for my function to support either a file name or a file object and indeed it would include an isinstance test (which I removed to simplify the example)</span>
