<div class="post-text" itemprop="text">
<p>I have been trying to determine a shorter method for calculating gcd((a^n + b^n), abs(a-b)). I noticed that, if I were to calculate (using the above formula) say a = 100 and b = 4, starting from 1 and ending at n (a loop), at a certain point, the answer becomes constant. For a = 100, b = 4 and n = 100, I create a loop from 1 to n, and at each point, I apply the formula, the first answer (n = 1) is 8, thereafter it is 32 till when n becomes 100. For optimization, I break out of the loop once two equal consecutive numbers are found and the latest number (32 here), becomes the answer. Does anyone know a straightforward formula for calculating gcd((a^n + b^n), a-b), or better still, my primary concern, a global formula for finding (a^n + b^n)</p>
<p>Note:
1. 1&lt;=a,b,n&lt;=10^12</p>
<ol start="2">
<li><p>(a^n - b^n) can be simplified as <a href="https://math.stackexchange.com/questions/406703/how-to-simplify-an-bn">https://math.stackexchange.com/questions/406703/how-to-simplify-an-bn</a>. But can't find a version for (a^n + b^n)</p></li>
<li><p>Following Rory Daulton's anwser, I have implemented Exponentiation by Squaring shown below in a function</p></li>
</ol>
<p>My Python Code for the above explanation follows suite:</p>
<pre><code>a, b, n = map(int, raw_input().split()); ans = -1

if a == b:
    ans = (a**n) + (b**n)

else:
    for j in xrange(n):
        x = gcd((a**n)+(b**n),abs(a-b))

        if x != ans:
            ans = x
        else:
            break
print ans 
</code></pre>
<h1>Exponentiation by Squaring</h1>
<pre><code>def pow3(x, n):
r = 1
while n:
    if n % 2 == 1:
        r *= x
        n -= 1
    x *= x
    n /= 2
return r
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I see two ways to speed up your code.</p>
<p>First, use the mathematical fact that</p>
<pre><code>gcd(r, s) = gcd(r % s, s)
</code></pre>
<p>(if <code>s</code> is not zero). So you do not need to compute <code>a**n + b**n</code> in full, you just need it modulo <code>a - b</code>. And you can do that by finding <code>(a**n) % (a-b)</code> and <code>(b**n) % (a-b)</code> then adding those modulo <code>a - b</code>.</p>
<p>Now, find <code>a**n</code> by the <a href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring" rel="nofollow noreferrer">exponentiation by squaring method</a>. That involves a loop that executes <code>log2(n)</code> times. In each pass through the loop, take the remainder mod <code>a - b</code> to keep your numbers low and speed up the calculations.</p>
<p>So there is your algorithm. Find <code>(a**n) % (a-b)</code> and <code>(b**n) % (a-b)</code> by exponentiation by squaring and modulus at each step. Then add them and take the modulus again. Finally, find the GCD of that value with <code>a - b</code>. </p>
<hr/>
<p>In some situations, such as <code>a - b</code> prime, I can see some shortcuts. The modulus of the powers of a number do repeat, as you note. However, finding out just when they repeat is a non-trivial problem for large values of <code>a - b</code>, especially if <code>a - b</code> is composite and hard to factor. Unless you have some additional information on the values of <code>a - b</code> and your other parameters, I suggest you not use the repetitions. If the values of <code>a</code> and <code>b</code> are small and known in advance (as in your example of <code>a = 100</code> and <code>b = 4</code>, the repetitions are more attractive and you could pre-compute the values of powers modulus <code>96</code>.</p>
<hr/>
<p><strong>Rather than use this code, you should probably use Python's built-in pow function.</strong> <a href="https://docs.python.org/3/library/functions.html#pow" rel="nofollow noreferrer">See here</a> for documentation. Hat tip to @DSM.</p>
<p>By request, here is my routine for exponentiation by squaring modulo a given number. There are some variations that could be done, of course. This version does no error checking on the parameters an does a little bit-twiddling for minor efficiencies.</p>
<pre><code>def exp_by_squaring_mod(x, n, mod):
    """Calculate x**n % mod by squaring. This assumes x and n are non-
    negative integers and mod is a positive integer. This returns 1 for
    0**0.
    """
    result = 1
    x %= mod
    # Reduce n and keep constant the value of result * x**n % mod
    while n:  # while n is not zero
        if n &amp; 1:  # n is odd
            result = result * x % mod
        x = x * x % mod
        n &gt;&gt;= 1  # integer divide by 2
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try to optimize your exponentiation using this method:</p>
<pre><code>def powerBySquaring(x,n):
    if n &lt; 0:
        x = 1 / x
        n = -n
    if n == 0: return 1
    y = 1
    while n &gt; 1:
        if n % 2 == 0:
            x = x * x
            n = n / 2
        else:
            y = x * y
            x = x * x
            n = (n-1)/2
    return x * y
</code></pre>
</div>
<span class="comment-copy">If your "primary concern" is trying to find <code>a^n + b^n</code>, what's wrong with just <code>a**n + b**n</code>?</span>
<span class="comment-copy">Try computing a^n + b^n, where a, b can be up to 10^10. Takes more than 10 seconds to compute.</span>
<span class="comment-copy">If you're working with very large numbers, you should add the ranges to your question: answers are highly dependent on how large they are.</span>
<span class="comment-copy">in your square-and-multiply algorithm, I would suggest you to use bit operations instead of <code>n % 2</code> and <code>n /= 2</code></span>
<span class="comment-copy">Thanks a lot, run time is greatly optimized, but I get a DivisionbyZero error for a = 1000000, b = 1000000 n = 1000000. I am using your very first explanation.</span>
<span class="comment-copy">@CarlsonBimbuh: Perhaps I should have written the theorem in full: <code>gcd(r, s) = gcd(r % s, x)</code> unless <code>s</code> is zero, then it is <code>r</code> (assuming all those values are nonnegative integers). If you really need the correct answer for that case, calculate <code>a**n + b**n</code> in full (no modulus), and that is the GCD. It is hard to believe that those values of <code>a, b, n</code> are a real problem.</span>
<span class="comment-copy">I'm now a little confused. "exponentiaion by squaring and MODULUS at each step,"  Please, Modulus by what?</span>
<span class="comment-copy">Please sorry for bugging you one more time. I modified my comment, can you please explain again from it? And don't worry, I fully understand what modulus is.</span>
<span class="comment-copy">@CarlsonBimbuh: In your function that calculates exponentiation-by-squaring, each loop will square a value and may multiply two values. In either case, just after the squaring or multiplication, then find the remainder when divided by <code>a - b</code>. This will keep the values small and thus speeds up the squarings and multiplications. Do you want me to show you such a routine?</span>
