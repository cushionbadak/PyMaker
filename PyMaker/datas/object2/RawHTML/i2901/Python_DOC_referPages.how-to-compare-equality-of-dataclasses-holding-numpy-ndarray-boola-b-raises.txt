<div class="post-text" itemprop="text">
<p>If I create a Python dataclass containing a Numpy ndarray, I can no longer use the automatically generated <code>__eq__</code> anymore.</p>
<pre><code>import numpy as np

@dataclass
class Instr:
    foo: np.ndarray
    bar: np.ndarray

arr = np.array([1])
arr2 = np.array([1, 2])
print(Instr(arr, arr) == Instr(arr2, arr2))
</code></pre>
<blockquote>
<p>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</p>
</blockquote>
<p>This is because <code>ndarray.__eq__</code> <em>sometimes</em> returns a <code>ndarray</code> of truth values, by comparing <code>a[0]</code> to <code>b[0]</code>, and so on and so forth to the longer of the 2. This is quite complex and unintuitive, and in fact only raises an error when the arrays are different shapes, or have different values or something.</p>
<p>How do I safely compare <code>@dataclass</code>es holding Numpy arrays?</p>
<hr/>
<p><code>@dataclass</code>'s implementation of <code>__eq__</code> is generated using <code>eval()</code>. Its source is missing from the stacktrace and cannot be viewed using <code>inspect</code>, but it's actually using a <em>tuple comparison</em>, which calls bool(foo).</p>
<pre><code>import dis
dis.dis(Instr.__eq__)
</code></pre>
<p>excerpt:</p>
<blockquote>
<pre><code>  3          12 LOAD_FAST                0 (self)
             14 LOAD_ATTR                1 (foo)
             16 LOAD_FAST                0 (self)
             18 LOAD_ATTR                2 (bar)
             20 BUILD_TUPLE              2
             22 LOAD_FAST                1 (other)
             24 LOAD_ATTR                1 (foo)
             26 LOAD_FAST                1 (other)
             28 LOAD_ATTR                2 (bar)
             30 BUILD_TUPLE              2
             32 COMPARE_OP               2 (==)
             34 RETURN_VALUE
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The solution is to put in your own <code>__eq__</code> method and set <code>eq=False</code> so the dataclass doesn't generate its own (although checking the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass" rel="nofollow noreferrer">docs</a> that last step isn't necessary but I think it's nice to be explicit anyway).</p>
<pre><code>import numpy as np

def array_eq(arr1, arr2):
    return (isinstance(arr1, np.ndarray) and
            isinstance(arr2, np.ndarray) and
            arr1.shape == arr2.shape and
            (arr1 == arr2).all())

@dataclass(eq=False)
class Instr:

    foo: np.ndarray
    bar: np.ndarray

    def __eq__(self, other):
        if not isinstance(other, Instr):
            return NotImplemented
        return array_eq(self.foo, other.foo) and array_eq(self.bar, other.bar)
</code></pre>
</div>
<span class="comment-copy">You could write your own <code>__eq__</code> method on <code>Instr</code>, you can override any of the autogenerated methods. Just catch the <code>ValueError</code> and implement your own additional logic.</span>
<span class="comment-copy">For the record, the dataclass <code>.__eq__</code> source is here <a href="https://github.com/python/cpython/blob/3.7/Lib/dataclasses.py#L884" rel="nofollow noreferrer">github.com/python/cpython/blob/3.7/Lib/dataclasses.py#L884</a></span>
<span class="comment-copy">that's a bit of work, but I guess I'll have to do it.</span>
<span class="comment-copy">Well remember that before attrs/dataclasses you'd have had to do this anyway</span>
<span class="comment-copy">I ended up comparing <code>arr.tolist()</code> so I don't have to worry about arrays being falsely equal due to broadcasting shenanigans, is that a good idea?</span>
<span class="comment-copy">That will work but it's not very efficient. What broadcasting shenanigans are we talking about here?</span>
<span class="comment-copy">This is primarily for unit tests, I don't want 1 == [1] == [[[1]]] or [1,1,1] == 1.</span>
