<div class="post-text" itemprop="text">
<p>According to the <code>logging</code> module's <a href="https://docs.python.org/3/howto/logging-cookbook.html#using-logging-in-multiple-modules" rel="nofollow noreferrer">cookbook</a>:</p>
<blockquote>
<p><strong>Using logging in multiple modules</strong></p>
<p>Multiple calls to <code>logging.getLogger('someLogger')</code> return a reference to the same logger object. This is true not only within the same module, but also across modules as long as it is in the same Python interpreter process. It is true for references to the same object; additionally, application code can define and configure a parent logger in one module and create (but not configure) a child logger in a separate module, and all logger calls to the child will pass up to the parent. </p>
</blockquote>
<p>How does this work? (I tried looking at the module source code, but could not figure it out.) So far I did not know that I could define 'super-global' objects that are accessible across modules.
To help me understand how <code>logging</code> does it, could you show me how to get the following to work:</p>
<p>In a <code>foo.py</code>, do</p>
<pre><code>import my_module

my_module.set_my_value(42)
</code></pre>
<p>and in a 'bar.py', do</p>
<pre><code>import my_module

print(my_module.get_my_value())  # Should print 42
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, to do what you want is trivial. When you <code>import</code> a module, there’s only a single instance of that module object shared by anyone else who <code>import</code>s it,<sup>1</sup> and that module object’s attributes are just the module’s globals. So:</p>
<pre><code># script.py
import cheese
import eggs
cheese.beans = 10
eggs.dostuff()

# eggs.py
import cheese
print(cheese.beans)
print(cheese.ham)

# cheese.py
ham = 20
</code></pre>
<p>If you run <code>script.py</code>, it will print 10, then 20.</p>
<p>You do of course have to be careful with top-level module code, which gets run in the order the modules are first imported (which can be tricky to work out),<sup>2</sup> and with code in the script (which should never be imported as a module by anyone else)<sup>3</sup>, but otherwise, it just works, without needing any special getter and setter functions.</p>
<p>(If you do for some reason need getter and setter functions, the same <code>getattr</code> and <code>setattr</code> that work for any object work just fine on module objects.)</p>
<p>And now, how does <code>logging</code> do its magic? Simple; it just stores a dict in its globals. Since there’s only one instance of the module, there’s only one instance of its globals, and therefore only one instance of the dict.</p>
<hr/>
<p><sub>1. If you want to know how <em>that</em> works under the covers… When you execute <code>import cheese</code>, what Python does (by default, assuming you haven't installed any weird import hooks) is: first, is there a <code>sys.modules['cheese']</code>? If not, find the spec for <code>cheese</code>, use it to find a loader, use the loader to load the code, <code>exec</code> the code, and store the result as <code>sys.modules['cheese']</code>. Then just <code>return sys.modules['cheese']</code>. This is why each module only gets its top-level code run once, no matter how many times you <code>import</code> it, and it's also why everyone who <code>import</code>s it shares the same copy of the module object.</sub></p>
<p><sub>2. Your example just works with <code>my_module.my_value = 42</code> and <code>print(my_module.myvalue)</code>—if <code>foo</code> gets <code>import</code>ed before <code>bar</code>. But if <code>bar</code> gets <code>import</code>ed first, it will get an <code>AttributeError</code>, because obviously nobody has set <code>my_module.my_value</code> yet.</sub></p>
<p><sub>3. The main reason is that when you run <code>script.py</code>, it's not run as a module named <code>script</code>, but as a module named <code>__main__</code>. This is why the <code>if __name__ == '__main__':</code> guard idiom works. But if someone else does an <code>import script</code>, <code>script</code> isn't in <code>sys.modules</code>, so Python will load and execute a separate copy of <code>script.py</code>, with its own separate globals.</sub></p>
</div>
<span class="comment-copy">Now I feel a little embarassed that I did not know that (or did not think it through properly). Thank you for explaining it in detail!</span>
