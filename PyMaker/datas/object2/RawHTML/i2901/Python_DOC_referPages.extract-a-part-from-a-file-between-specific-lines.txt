<div class="post-text" itemprop="text">
<p>I would like to know, how can I extract some data from a specific range in a big data file? Is there a way to read the content beginning and ending with "buzzwords".</p>
<p>I would like to read line per line between <code>*NODE</code> and <code>**</code></p>
<pre><code>*NODE
13021145,       2637.6073002472617,       55.011929824413045,        206.0394346892517
13021146,       2637.6051226039867,        55.21115693303926,       206.05686503802065
13021147,        2634.226986419154,        54.98263035830583,        205.9520084547658
13021148,        2634.224808775879,       55.181857466932044,       205.96943880353476
**
</code></pre>
<p>Before <code>*NODE</code> and after <code>**</code> there are thousand of lines...</p>
<p>I know it should look something similar like:</p>
<pre><code>a = []

with open('file.txt') as file:
   for line in file:
      if line.startswith('*NODE'):

      # NOW THERE SHOULD FOLLOW SOMETHING LIKE:
      #   Go to next line and "a.append" till there comes the "magical"
      #   "**"
</code></pre>
<p>Any idea? I am totally new to python. Thanks for help!
I hope u know what i mean.</p>
</div>
<div class="post-text" itemprop="text">
<p>You pretty much did it - the only thing missing is that once you find the beginning, you search for the sequence end and until that happens append every line you're iterating over to your list. i.e.:</p>
<pre><code>data = None  # a placeholder to store your lines
with open("file.txt", "r") as f:  # do not shadow the built-in `file`
    for line in f:  # iterate over the lines
        if data is None:  # we haven't found `NODE*` yet
            if line[:5] == "NODE*":  # search for `NODE*` at the line beginning
                data = []  # make `data` an empty list to begin collecting
        elif line[:2] == "**":  # data initialized, we look for the sequence's end
            break  # no need to iterate over the file anymore
        else:  # data initialized but not at the end...
            data.append(line)  # append the line to our data
</code></pre>
<p>Now <code>data</code> will contain either a list of lines between <code>NODE*</code> and <code>**</code>, or <code>None</code> if the sequence was not found.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code> with open('file.txt') as file:
    a = []
    running = False  # avoid NameError when 'if' statement below isn't reached
    for line in file:
        if line.startswith('*NODE'):
            running = True  # show that we are starting to add values
            continue  # make sure we don't add '*NODE'
        if line.startswith('**'):
            running = False  # show that we're done adding values
            continue  # make sure we don't add '**'
        if running:  # only add the values if 'running' is True
            a.extend([i.strip() for i in line.split(',')])
</code></pre>
<p>The output is a list containing the following as strings:
<em>(I used <code>print('\n'.join(a))</code>)</em></p>
<p><code>
13021145
2637.6073002472617
55.011929824413045
206.0394346892517
13021146
2637.6051226039867
55.21115693303926
206.05686503802065
13021147
2634.226986419154
54.98263035830583
205.9520084547658
13021148
2634.224808775879
55.181857466932044
205.96943880353476
</code></p>
</div>
<div class="post-text" itemprop="text">
<p>We can iterate over lines until there is no any left or we've reached end of block like</p>
<pre><code>a = []

with open('file.txt') as file:
    for line in file:
        if line.startswith('*NODE'):
            # collect block-related lines
            while True:
                try:
                    line = next(file)
                except StopIteration:
                    # there is no lines left
                    break
                if line.startswith('**'):
                    # we've reached the end of block
                    break
                a.append(line)
            # stop iterating over file
            break
</code></pre>
<p>will give us</p>
<pre><code>print(a)
['13021145,       2637.6073002472617,       55.011929824413045,        206.0394346892517\n',
 '13021146,       2637.6051226039867,        55.21115693303926,       206.05686503802065\n',
 '13021147,        2634.226986419154,        54.98263035830583,        205.9520084547658\n',
 '13021148,        2634.224808775879,       55.181857466932044,       205.96943880353476\n']
</code></pre>
<p>Alternatively we can write helper predicates like</p>
<pre><code>def not_a_block_start(line):
    return not line.startswith('*NODE')


def not_a_block_end(line):
    return not line.startswith('**')
</code></pre>
<p>and then use brilliance of <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code> module</a> like</p>
<pre><code>from itertools import (dropwhile,
                       takewhile)    

with open('file.txt') as file:
    block_start = dropwhile(not_a_block_start, file)
    # skip block start line
    next(block_start)
    a = list(takewhile(not_a_block_end, block_start))
</code></pre>
<p>this will give us the same value for <code>a</code>.</p>
</div>
<span class="comment-copy">does your file start with <code>*NODE</code>?</span>
<span class="comment-copy">no there are a lot more lines before, but this word is very specific. so i have to search for, till it shows up, read content and close if there comes the **.</span>
