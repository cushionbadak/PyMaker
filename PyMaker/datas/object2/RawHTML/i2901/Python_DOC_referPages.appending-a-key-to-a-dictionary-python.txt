<div class="post-text" itemprop="text">
<p>I try to update a key in a dictionary. I use <code>.aapend()</code> method but i get following error:</p>
<pre><code>AttributeError: 'str' object has no attribute 'append'
</code></pre>
<p>Here is the code:</p>
<pre><code>class FileOwners:
@staticmethod
def group_by_owners(files):
    fileName=[]
    tempName=[]
    final={}
    for i in files:
      for j in files:
        if files.get(j) not in tempName:
          tempName.append(files.get(j))
          fileName.append(i)
          final.update({files.get(j):i})
          break
        else:
          final.setdefault(files.get(j), []).append(i)  
    return final

files = {
    'Input.txt': 'Randy',
    'Code.py': 'Stan',
    'Output.txt': 'Randy'
}
print(FileOwners.group_by_owners(files))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, yes, strings don't have an <code>append</code> method. You can see a list of all the methods <a href="https://docs.python.org/3/library/stdtypes.html#string-methods" rel="nofollow noreferrer">in the docs</a>, or by typing <code>help(str)</code> in the interactive interpreter, or even just printing out <code>dir(str)</code>.</p>
<p>The reason strings don't have an <code>append</code> method is that they're immutable—you cannot change a string value. You can only create a brand-new string value, e.g., by adding two strings together:</p>
<pre><code>&gt;&gt;&gt; 'abc' + 'def'
'abcdef'
</code></pre>
<p>However, you can still use augmented assignment on a variable or other target holding a string value:</p>
<pre><code>&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; s += 'def'
'abcdef'
</code></pre>
<p>This doesn't change the value <code>'abc'</code>, it makes a brand-new <code>'abcdef'</code> value and assigns that to <code>s</code>. But that's fine for you.</p>
<p>So, if you want to update a dict value that's a string, you can do the same:</p>
<pre><code>&gt;&gt;&gt; d = {'abc': 'def'}
&gt;&gt;&gt; d['abc'] += 'ghi'
&gt;&gt;&gt; d
{'abc': 'defghi'}
</code></pre>
<hr/>
<p>But really, you don't seem to want to append to a string in the first place; what you want is to have a dict with lists of strings for the values.</p>
<p>So, just create it that way in the first place:</p>
<pre><code>files = {
    'Input.txt': ['Randy'],
    'Code.py': ['Stan'],
    'Output.txt': ['Randy']
}
</code></pre>
<p>… and now the rest of your code will work.</p>
<p>Or, maybe, you wanted <code>files</code> to be a dict with (single) string values, and only <code>final</code> to be a dict with lists of string values. In that case, instead of this:</p>
<pre><code>final.update({files.get(j):i})
</code></pre>
<p>… do this:</p>
<pre><code>final.update({files.get(j): [i]})
</code></pre>
<p>Since I can't figure out what your code is intended to do, I don't know which fix you want. But I do know that, if you want to <code>append</code> to the values in <code>final</code>, those values have to be lists (of strings), not strings.</p>
<hr/>
<p>Meanwhile, this line of code is overcomplicated for no obvious reason:</p>
<pre><code>final.update({files.get(j):i})
</code></pre>
<p>If you just want to replace a value in a dict, just assign to it:</p>
<pre><code>final[files.get(j)] = i
</code></pre>
<p>Or, since it seems like you're expecting <code>j</code> will always be in <code>files</code>, why are you even using <code>get</code>?</p>
<pre><code>final[files[j]] = i
</code></pre>
<hr/>
<p>Finally, you have at least one other major problem: once you fix the problem with the values from <code>files</code> all being lists, you're trying to use those values as keys in <code>final</code>. But lists can't be used as dict keys.</p>
<p>The reason comes back to mutability again. Imagine you did this:</p>
<pre><code>lst = [1]
d = {lst: 3}
lst.append(2)
</code></pre>
<p>Now, should <code>d[[1]]</code> find that value, even though <code>[1] != lst</code> anymore? Or maybe <code>d[[1, 2]]</code> should find that value, even though what the dict hashed was <code>[1]</code>? Really, no option makes sense. Which is why mutable types in Python either aren't hashable, or don't consider their mutable values in their hashing and comparison functions.</p>
<p>Presumably you're actually trying to use the list as just "some kind of sequence"; when the list is mutated, you don't want <code>final</code> to change in any way.</p>
<p>If that's true, you can use a tuple of those same values as a key:</p>
<pre><code>final[tuple(files[j])] = i
</code></pre>
<hr/>
<p>But, after all of that, it seems like what you're <em>really</em> trying to do is a whole lot simpler:</p>
<pre><code>groups = {}
for file, owner in files.items():
    groups.setdefault(owner, []).append(file)
</code></pre>
<p>I'm not sure what the nested loop over the cartesian square of the <code>files</code> keys was meant to do, or what all those temporary objects are for, so it's hard to say how to fix them—but you can just get rid of them, so you don't <em>have</em> to fix them.</p>
</div>
<div class="post-text" itemprop="text">
<p>the error is with <code>final.setdefault(files.get(j), []).append(i)</code></p>
<p>.setdefault is getting the j value (if possible) and returning that. since the value for j is <code>Input.txt</code> it returns <code>'Randy'</code> which is a string and has no append function</p>
<p>Additionally, you cannot have a list as a key in a dictionary so this line will always break.</p>
</div>
<span class="comment-copy">What about <a href="https://www.safaribooksonline.com/library/view/python-cookbook/0596001673/ch01s06.html" rel="nofollow noreferrer">this</a>?</span>
<span class="comment-copy">@lonesome What about it?</span>
<span class="comment-copy">Well, if you open it you will see the appending method for dictionaries just like mine.</span>
<span class="comment-copy">@lonesome No, it appends to dictionaries whose values are lists. Your values are strings. That's exactly the difference the second section of my answer explains.</span>
<span class="comment-copy">Where did you get that idea? it says <code>normal dictionaries</code> at very beginning and all values are strings.</span>
