<div class="post-text" itemprop="text">
<p>I'd like to use part of a string ('project') that is returned from an API. The string looks like this:</p>
<pre><code>{'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}
</code></pre>
<p>I'd like to store the 'LS003942_EP...  ' part in a new variable called <code>foldername</code>. I'm thought a good way would be to use a regex to find the text after <code>Title</code>. Here's my code:</p>
<pre><code>orders = api.get_all(view='Folder', fields='Project Title', maxRecords=1)
for new in orders:
    print ("Found 1 new project")
    print (new['fields'])
    project = (new['fields'])
    s = re.search('Title(.+?)', result)
    if s:
       foldername = s.group(1)
       print(foldername)
</code></pre>
<p>This gives me an error - </p>
<blockquote>
<p>TypeError: expected string or bytes-like object. </p>
</blockquote>
<p>I'm hoping for <code>foldername = 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>ast.literal_eval</code> to safely evaluate a string containing a Python literal:</p>
<pre><code>import ast

s = "{'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}"

print(ast.literal_eval(s)['Project Title'])
# LS003942_EP - 5 Random Road, Sunny Place, SA 5000
</code></pre>
<p>It seems (to me) that you have a dictionary and not string. Considering this case, you may try:</p>
<pre><code>s = {'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}

print(s['Project Title'])
</code></pre>
<p>If you have time, take a look at <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">dictionaries</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you need a <code>regex</code> here:</p>
<pre><code>string = "{'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}"
foldername = string[string.index(":") + 2: len(string)-1]
</code></pre>
<p>Essentially, I'm finding the position of the first colon, then adding 2 to get the starting index of your foldername (which would be the apostrophe), and then I use index slicing and slice everything from the index to the second-last character (the last apostrophe).</p>
<p>However, if your string is always going to be in the form of a valid python <code>dict</code>, you could simply do <code>foldername = (eval(string).values)[0]</code>. Here, I'm treating your string as a <code>dict</code> and am getting the first value from it, which is your desired <code>foldername</code>. But, as @AKX notes in the comments, <code>eval()</code> isn't safe as somebody could pass malicious code as a string. Unless you're sure that your input strings won't contain code (which is unlikely), it's best to use ast.literal_eval() as it only evaluates literals.</p>
<p><strong>But, as @MaximilianPeters notes in the comments, your response looks like a valid JSON, so you could easily parse it using <code>json.parse()</code>.</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>You could try this pattern: <code>(?&lt;='Project Title': )[^}]+</code>.</p>
<p>Explanation: it uses positive lookbehind to assure, that match will occure after <code>'Project Title':</code>. Then it matches until <code>}</code> is encountered: <code>[^}]+</code>.</p>
<p><a href="https://regex101.com/r/mv8Uxo/5" rel="nofollow noreferrer">Demo</a></p>
</div>
<span class="comment-copy">The response looks like a JSON. Why not use <code>json.parse</code>?</span>
<span class="comment-copy">@MaximilianPeters Properly formatted JSON has double quotes around each string property and value. But yeah, probably good to replace the single-quotes with double-quotes and parse it like that</span>
<span class="comment-copy">@CertainPerformance: right, I always mix the two.</span>
<span class="comment-copy">@MaximilianPeters @CertainPerformance: That also looks like a valid Python dict, so <code>ast.literal_eval()</code> should work...</span>
<span class="comment-copy">@AKX correct, even the builtin python function <code>eval</code> should work just fine</span>
<span class="comment-copy">Thanks. This looks like a simple solution. I tried and got the following error. I'm not very sure why:     raise ValueError('malformed node or string: ' + repr(node)) ValueError: malformed node or string: {'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}</span>
<span class="comment-copy">Can you try out my updated answer.</span>
<span class="comment-copy">Awesome! Thank worked. Thanks for taking the time to explain. I'll have a look at dictionaries!</span>
<span class="comment-copy">One thing, how can i ensure the output is in quotes? E.g. the output looks like:   'LS003942_EP - 5 Random Road, Sunny Place, SA 5000' ?</span>
<span class="comment-copy">Okay, do <code>print(repr(s['Project Title']))</code>.</span>
<span class="comment-copy">Thanks. I wasn't able to figure out json.parse(). I think perhaps the lack of double quotes is the issue. I also tried your earlier suggestion but received the error below:     foldername = string[string.index(":") + 2: len(string)-1] AttributeError: 'dict' object has no attribute 'index'</span>
<span class="comment-copy">@Neil Is <code>{'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}</code> stored as a dictionary?? Your wording implied that it was stored as a string...</span>
<span class="comment-copy">I'm not entirely sure as i'm pretty new. This is the full response from the API and then i take the 'fields' part and store that.</span>
<span class="comment-copy">[{'id': 'rec52yhRTMYcetmxJ', 'fields': {'Project Title': 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'}, 'createdTime': '2018-08-03T06:29:09.000Z'}]</span>
<span class="comment-copy">Thanks. I'm trying to match the whole string e.g. 'LS003942_EP - 5 Random Road, Sunny Place, SA 5000'. This seems to match the first part correctly?</span>
<span class="comment-copy">@Neil Try updated answer.</span>
<span class="comment-copy">Thanks. It looks like the regex is right! I didn't go with it in the end as i found the other answer simpler to implement. But thank you so much.</span>
