<div class="post-text" itemprop="text">
<p>I am new to python, coming from swift and I am wondering about the following. In swift if I would like to add a functionality to an an existing class, I can do something like this (as in the book example):</p>
<pre><code>extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
</code></pre>
<p>I really like this functionality and I was wondering if there is something similar in python, or there is some other way much better that I do not see and hence this does not make any sense in python.</p>
</div>
<div class="post-text" itemprop="text">
<p>For the sake of completeness, I think this is what you should do (In Swift as well!):</p>
<pre><code>class Meter(float):
    def to_km(self): return self * 1000.0 
    def to_m (self): return self 
    def to_cm(self): return self / 100.0 
    def to_mm(self): return self / 1000.0 
    def to_ft(self): return self / 3.28084 
oneInch = Meter(25.4).to_mm()
print(oneInch)
</code></pre>
<p>Make it clear that your object represents a meter, and that you are converting it to something.</p>
<p>If you want some syntactic sugar, <strong>that I am not sure is helpful</strong>, you can override the item getter so you do not have to use <code>()</code>:</p>
<pre><code>class Meter(float):
    conversions = {
        'km':1000,
        'cm':.01,
        'mm':.001,
        'ft':1/3.28084
    }
    def __getattr__(self,x):
        try:
            return self*Meter.conversions[x]
        except KeyError:
            raise KeyError("No such conversion!")
oneInch = Meter(25.4).mm
print(oneInch)
</code></pre>
<p>Adding conversions is as simple as:</p>
<pre><code>Meter.conversions['whatever'] = 123.123
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, you can't extend builtin classes like <code>float</code> or <code>int</code>.</p>
<pre><code>&gt;&gt;&gt; int.double = lambda self: self * 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't set attributes of built-in/extension type 'int'
</code></pre>
<p>(You can modify non-builtin classes though, but you really <em>shouldn't</em>, as code doing that is hard to reason about.)</p>
<p>Your particular example is better served by an unit library like <a href="https://pint.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>pint</code></a> -- using libraries like that prevents you from making <a href="http://mentalfloss.com/article/25845/quick-6-six-unit-conversion-disasters" rel="nofollow noreferrer">$125 million mistakes doing math between metric and imperial units</a>, too.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can build child classes of parent classes.  If you're writing your own code, sometimes this is a good idea, but extending something like a pandas dataframe is probably a bad idea</p>
<p>I didn't spend much time googling for you, but this is the best I found: <a href="https://docs.python.org/3/tutorial/classes.html" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/classes.html</a></p>
<p>This is also some really bad code I wrote trying to explain class inheritance to my girlfriend.  Note that the <code>Car</code> class will still have <code>car.roll_up_windows()</code> and <code>car.roll_down_windows()</code> and the <code>__repr__</code>: </p>
<pre><code>class Plant(object):
    def __init__(self, color, seeds):
        self.color = color
        self.seeds = seeds

class Fruit(Plant):
    def __init__(self, color, defense):
        self.color = color
        self.seeds = True
        self.defense = defense

class Vehicle(object):
    def __init__(self, num_tires, engine_size, fuel_type):
        self.num_tires = num_tires
        self.engine_size = engine_size
        self.fuel_type = fuel_type
        self.windows = 'up'

    def roll_down_windows(self):
        self.windows = 'down'
    def roll_up_windows(self):
        self.windows = 'up'

    def __repr__(self):
        print("This is a vehicle. \nIt has {} tires. \nIts engine has {} liters. \nIt runs on {}. \nIt's windows are {}.".format(self.num_tires, self.engine_size, self.fuel_type, self.windows))

class Car(Vehicle):
    def __init__(self, num_tires=4, engine_size, fuel_type):
        self.num_tires = num_tires
        self.engine_size = engine_size
        self.fuel_type = fuel_type
        self.windows = 'up'
</code></pre>
</div>
<span class="comment-copy">To extend functionality of a class in Python, you usually create a new class which inherits from the one you want to extend.</span>
<span class="comment-copy">This wouldn't even be appropriate Swift. Your code assumes that Doubles are in metres, which is really easy to overlook, and will cause bugs. It's better to use a class like <code>NSMeasurement</code>, or equivalent.</span>
<span class="comment-copy">@kabanus so there's not much extension going on in python other than on your own classes?</span>
<span class="comment-copy">@kabanus Yikes. But I disagree with your conclusion on not extending built-in types. That's practically the main point of extensions. If it were just about user types, you could conceivably just write all your extensions in the main type declaration. Having functions like <code>isEven</code>, <code>isPrime</code>, <code>squared</code>, <code>isNaN</code>, etc. is incredibly invaluable. Let alone the benefits of retroactively adding protocol conformances, so that you don't waste your type writing <code>IntWrapper</code>, <code>DoubleWrapper</code>, etc. as you would in other languages</span>
<span class="comment-copy">i think my example might not be the best, but your answer is really close to what I am looking for, is there a way to change your code so that I can do oneInch = 25.to_mm or at least oneInch = Meter(25.4).to_mm?</span>
<span class="comment-copy">@dre_84w934 Just edited as you were commenting.</span>
<span class="comment-copy">python way looks cumbersome</span>
<span class="comment-copy">Just use a <code>property</code> instead of overriding <code>__getattr__</code></span>
<span class="comment-copy">I am getting the feeling that there are not that many class extensions in python, other than on your own classes</span>
