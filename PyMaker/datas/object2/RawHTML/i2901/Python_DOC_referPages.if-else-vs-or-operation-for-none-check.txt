<div class="post-text" itemprop="text">
<p>Let's say we have a dict that will always have keys first_name and last_name but they may be equal to None. </p>
<pre><code>{
    'first_name': None,
    'last_name': 'Bloggs'
}
</code></pre>
<p>We want to save the first name if it is passed in or save it as an empty string if None is passed in. </p>
<pre><code>first_name = account['first_name'] if account['first_name'] else ""
</code></pre>
<p>vs</p>
<pre><code>first_name = account['first_name'] or ""
</code></pre>
<p>Both of these work, however, what is the difference behind the scenes? Is one more efficient than the other?</p>
</div>
<div class="post-text" itemprop="text">
<p>What is the difference between the two following expressions?</p>
<blockquote>
<pre><code>first_name = account['first_name'] if account['first_name'] else ""
</code></pre>
<p>vs</p>
<pre><code>first_name = account['first_name'] or ""
</code></pre>
</blockquote>
<p>The primary difference is that the first, in Python, is the <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="noreferrer">conditional expression</a>, </p>
<blockquote>
<p>The expression <code>x if C else y</code> first evaluates the condition, <code>C</code> rather
  than <code>x</code>. If <code>C</code> is true, <code>x</code> is evaluated and its value is returned;
  otherwise, <code>y</code> is evaluated and its value is returned.</p>
</blockquote>
<p>while the second uses the <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="noreferrer">boolean operation</a>:</p>
<blockquote>
<p>The expression <code>x or y</code> first evaluates <code>x</code>; if <code>x</code> is true, its value is
  returned; otherwise, <code>y</code> is evaluated and the resulting value is
  returned.</p>
</blockquote>
<p>Note that the first may require two key lookups versus the second, which only requires one key lookup.</p>
<p>This lookup is called <a href="https://docs.python.org/3/reference/expressions.html#subscriptions" rel="noreferrer">subscript notation</a>:</p>
<pre><code>name[subscript_argument]
</code></pre>
<p>Subscript notation exercises the <code>__getitem__</code> method of the object referenced by <code>name</code>.</p>
<p>It requires both the name and the subscript argument to be loaded.</p>
<p>Now, in the context of the question, if it tests as <code>True</code> in a boolean context (which a non-empty string does, but <code>None</code> does not) it will require a second (redundant) loading of both the dictionary and the key for the conditional expression, while simply returning the first lookup for the boolean <code>or</code> operation.</p>
<p>Therefore I would expect the second, the boolean operation, to be slightly more efficient in cases where the value is not <code>None</code>.</p>
<h3>Abstract Syntax Tree (AST) breakdown</h3>
<p>Others have compared the bytecode generated by both expressions.</p>
<p>However, the AST represents the first breakdown of the language as parsed by the interpreter.</p>
<p>The following AST demonstrates that the second lookup likely involves more work (note I have formatted the output for easier parsing):</p>
<pre><code>&gt;&gt;&gt; print(ast.dump(ast.parse("account['first_name'] if account['first_name'] else ''").body[0]))
Expr(
    value=IfExp(
        test=Subscript(value=Name(id='account', ctx=Load()),
                       slice=Index(value=Str(s='first_name')), ctx=Load()),
        body=Subscript(value=Name(id='account', ctx=Load()),
                       slice=Index(value=Str(s='first_name')), ctx=Load()),
        orelse=Str(s='')
))
</code></pre>
<p>versus</p>
<pre><code>&gt;&gt;&gt; print(ast.dump(ast.parse("account['first_name'] or ''").body[0]))
Expr(
    value=BoolOp(
        op=Or(),
        values=[
            Subscript(value=Name(id='account', ctx=Load()),
                      slice=Index(value=Str(s='first_name')), ctx=Load()),
            Str(s='')]
    )
)
</code></pre>
<h3>Bytecode analysis</h3>
<p>Here we see that the bytecode for the conditional expression is much longer. This usually bodes poorly for relative performance in my experience.</p>
<pre><code>&gt;&gt;&gt; import dis   
&gt;&gt;&gt; dis.dis("d['name'] if d['name'] else ''")
  1           0 LOAD_NAME                0 (d)
              2 LOAD_CONST               0 ('name')
              4 BINARY_SUBSCR
              6 POP_JUMP_IF_FALSE       16
              8 LOAD_NAME                0 (d)
             10 LOAD_CONST               0 ('name')
             12 BINARY_SUBSCR
             14 RETURN_VALUE
        &gt;&gt;   16 LOAD_CONST               1 ('')
             18 RETURN_VALUE
</code></pre>
<p>For the boolean operation, it's almost half as long:</p>
<pre><code>&gt;&gt;&gt; dis.dis("d['name'] or ''")
  1           0 LOAD_NAME                0 (d)
              2 LOAD_CONST               0 ('name')
              4 BINARY_SUBSCR
              6 JUMP_IF_TRUE_OR_POP     10
              8 LOAD_CONST               1 ('')
        &gt;&gt;   10 RETURN_VALUE
</code></pre>
<p>Here I would expect the performance to be much quicker relative to the other. </p>
<p>Therefore, let's see if there's much difference in performance then.</p>
<h3>Performance</h3>
<p>Performance is not <em>very</em> important here, but sometimes I have to see for myself:</p>
<pre><code>def cond(name=False):
    d = {'name': 'thename' if name else None}
    return lambda: d['name'] if d['name'] else ''

def bool_op(name=False):
    d = {'name': 'thename' if name else None}
    return lambda: d['name'] or ''
</code></pre>
<p>We see that when the name is in the dictionary, the boolean operation is about 10% faster than the conditional.</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(cond(name=True), repeat=10))
0.11814919696189463
&gt;&gt;&gt; min(timeit.repeat(bool_op(name=True), repeat=10))
0.10678509017452598
</code></pre>
<p>However, when the name is not in the dictionary, we see that there is almost no difference:</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(cond(name=False), repeat=10))
0.10031125508248806
&gt;&gt;&gt; min(timeit.repeat(bool_op(name=False), repeat=10))
0.10030031995847821
</code></pre>
<h3>A note on correctness</h3>
<p>In general, I would prefer the <code>or</code> boolean operation to the conditional expression - with the following caveats:</p>
<ul>
<li>The dictionary is guaranteed to only have non-empty strings or <code>None</code>.</li>
<li>Performance here is critical.</li>
</ul>
<p>In the case where either the above is not true, I would prefer the following for correctness:</p>
<pre><code>first_name = account['first_name']
if first_name is None:
    first_name = ''
</code></pre>
<p>The upsides are that </p>
<ul>
<li>the lookup is done <em>one</em> time, </li>
<li>the check for <code>is None</code> is quite fast,</li>
<li>the code is explicitly clear, and</li>
<li>the code is easily maintainable by any Python programmer.</li>
</ul>
<p>This should also not be any less performant:</p>
<pre><code>def correct(name=False):
    d = {'name': 'thename' if name else None}
    def _correct():
        first_name = d['name']
        if first_name is None:
            first_name = ''
    return _correct
</code></pre>
<p>We see that we get quite competitive performance when the key is there: </p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(correct(name=True), repeat=10))
0.10948465298861265
&gt;&gt;&gt; min(timeit.repeat(cond(name=True), repeat=10))
0.11814919696189463
&gt;&gt;&gt; min(timeit.repeat(bool_op(name=True), repeat=10))
0.10678509017452598
</code></pre>
<p>when the key is not in the dictionary, it is not quite as good though:</p>
<pre><code>&gt;&gt;&gt; min(timeit.repeat(correct(name=False), repeat=10))
0.11776355793699622
&gt;&gt;&gt; min(timeit.repeat(cond(name=False), repeat=10))
0.10031125508248806
&gt;&gt;&gt; min(timeit.repeat(bool_op(name=False), repeat=10))
0.10030031995847821
</code></pre>
<h3>Conclusion</h3>
<p>The difference between the conditional expression and the boolean operation is two versus one lookups respectively on a <code>True</code> condition, making the boolean operation more performant.</p>
<p>For correctness's sake, however, do the lookup one time, check for identity to <code>None</code> with <code>is None</code>, and then reassign to the empty string in that case.</p>
</div>
<div class="post-text" itemprop="text">
<p>Owing to its greater flexibility, there is more going on behind the scenes in the first version. After all, <code>a if b else c</code> is an expression with 3 possibly distinct input variables/expressions, while <code>a or b</code> is binary. You can <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer">disassemble</a> the expressions to get a better idea:</p>
<pre><code>def a(x):
    return x if x else ''

def b(x):
    return x or ''

&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(a)
  2           0 LOAD_FAST                0 (x)
              2 POP_JUMP_IF_FALSE        8
              4 LOAD_FAST                0 (x)
              6 RETURN_VALUE
        &gt;&gt;    8 LOAD_CONST               1 ('')
             10 RETURN_VALUE
&gt;&gt;&gt; dis.dis(b)
  2           0 LOAD_FAST                0 (x)
              2 JUMP_IF_TRUE_OR_POP      6
              4 LOAD_CONST               1 ('')
        &gt;&gt;    6 RETURN_VALUE
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>TLDR: It does not matter. If you care about correctness, you should instead compare against <code>None</code>.</p>
<pre><code>account['first_name'] if account['first_name'] is not None else "" 
</code></pre>
<p>There is a notable impact from whether <code>account['first_name']</code> is mostly <code>None</code> or an actual value - however, this is at the nanosecond scale. It is negligible unless run in a very tight loop.</p>
<p>If you seriously require better performance, you should consider using a JIT or static compiler such as PyPy, Cython, or similar.</p>
<h2>A look at what happens</h2>
<p>Python makes many guarantees that what you write is what is executed. That means the <code>a if a else b</code> case evaluates <code>a</code> <em>at most twice</em>. In contrast, <code>a or b</code> evaluates <code>a</code> <em>exactly once</em>.</p>
<p>In their disassembly, you can see that the <code>LOAD_NAME</code>, <code>LOAD_CONST</code> and <code>BINARY_SUBSCR</code> happen twice for the first case - but only if the value is true-ish. If it is false-ish, the number of lookups is the same!</p>
<pre><code>dis.dis('''account['first_name'] if account['first_name'] else ""''')
  1           0 LOAD_NAME                0 (account)
              2 LOAD_CONST               0 ('first_name')
              4 BINARY_SUBSCR
              6 POP_JUMP_IF_FALSE       16
              8 LOAD_NAME                0 (account)
             10 LOAD_CONST               0 ('first_name')
             12 BINARY_SUBSCR
             14 RETURN_VALUE
        &gt;&gt;   16 LOAD_CONST               1 ('')
             18 RETURN_VALUE

dis.dis('''account['first_name'] or ""''')
  1           0 LOAD_NAME                0 (account)
              2 LOAD_CONST               0 ('first_name')
              4 BINARY_SUBSCR
              6 JUMP_IF_TRUE_OR_POP     10
              8 LOAD_CONST               1 ('')
        &gt;&gt;   10 RETURN_VALUE
</code></pre>
<p>Technically, the statements also perform a different check: boolean false-ness (<code>POP_JUMP_IF_FALSE</code>) versus boolean truth-ness (<code>JUMP_IF_TRUE_OR_POP</code>). Since this is a single operation, it is optimised inside the interpreter and the difference is negligible.</p>
<p>For builtin types, you can generally assume that operations are "fast" - meaning that any non-trivial control flow takes significantly more time. Unless you run this in a tight loop over thousands of accounts, it will not have a notable impact.</p>
<hr/>
<p>While in your case it does not make an observable difference, it is usually better to explicitly test <code>is not None</code>. This lets you distinguish between <code>None</code> and other false-ish values, such as <code>False</code>, <code>[]</code> or <code>""</code>, that may be valid.</p>
<pre><code>account['first_name'] if account['first_name'] is not None else ""
</code></pre>
<p>Strictly speaking, it is the least efficient. On top of the added lookup, there is an additional lookup for <code>None</code> and comparison for <code>is not</code>.</p>
<pre><code>dis.dis('''account['first_name'] if account['first_name'] is not None else ""''')
  1           0 LOAD_NAME                0 (account)
              2 LOAD_CONST               0 ('first_name')
              4 BINARY_SUBSCR
              6 LOAD_CONST               1 (None)
              8 COMPARE_OP               9 (is not)
             10 POP_JUMP_IF_FALSE       20
             12 LOAD_NAME                0 (account)
             14 LOAD_CONST               0 ('first_name')
             16 BINARY_SUBSCR
             18 RETURN_VALUE
        &gt;&gt;   20 LOAD_CONST               2 ('')
             22 RETURN_VALUE
</code></pre>
<p>Note that this test <em>can</em> actually be faster. An <code>is not None</code> test compares for identity - that is builtin pointer comparison. Especially for custom types, this is faster than looking up and evaluating a custom <code>__bool__</code> or even <code>__len__</code> method.</p>
<hr/>
<p>In practice, the added lookup will not have a noticeable performance difference. It is up to you whether you prefer the shorter <code>a or b</code> or the more robust <code>a if a is not None else b</code>. Using <code>a if a else b</code> gets you <em>neither</em> terseness nor correctness, so it should be avoided.</p>
<p>Here are the numbers from Python 3.6.4, <code>perf timeit</code>:</p>
<pre><code># a is None
a or b                       | 41.4 ns +- 2.1 ns
a if a else b                | 41.4 ns +- 2.4 ns
a if a is not None else b    | 50.5 ns +- 4.4 ns
# a is not None
a or b                       | 41.0 ns +- 2.1 ns
a if a else b                | 69.9 ns +- 5.0 ns
a if a is not None else b    | 70.2 ns +- 5.4 ns
</code></pre>
<p>As you can see, there is an impact from the value of <code>a</code> - if you care about tens of nanoseconds. The terser statement with fewer underlying instructions is faster, and more importantly stable. There is no significant penalty for the added <code>is not None</code> check.</p>
<p>Either way, if you care about performance - do not optimise for CPython! If you need speed, taking a JIT/static compiler gives significantly more gain. However, their optimisations make instruction counts as performance metrics misleading.</p>
<p>For pure-Python code, as in your case, the PyPy interpreter is an obvious choice. On top of being faster in general, it seems to optimise the <code>is not None</code> test. Here are the numbers from from PyPy 5.8.0-beta0, <code>perf timeit</code>:</p>
<pre><code># a is None
a or b                       | 10.5 ns +- 0.7 ns
a if a else b                | 10.7 ns +- 0.8 ns
a if a is not None else b    | 10.1 ns +- 0.8 ns
# a is not None
a or b                       | 11.2 ns +- 1.0 ns
a if a else b                | 11.3 ns +- 1.0 ns
a if a is not None else b    | 10.2 ns +- 0.6 ns
</code></pre>
<p>Bottom line, do not try to gain performance by optimising for byte code instructions. Even if you are sure that this is a bottleneck (by profiling your application), such optimisations are generally not worth it. A faster runtime gives significantly more gain, and may not even have the same penalties for byte code instructions.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this doesn't answer your question about efficiency or the difference behind the scenes, but I'd like to point out that I think the following code is preferable:</p>
<pre><code>first_name = account.get('first_name') or ''
</code></pre>
<p>This way you don't have to access the <code>account['first_name']</code> twice. </p>
<p>Another side effect of this solution (obviously it depends if you want this behavior or not) is you'll never get a <code>KeyError</code>, even if <code>first_name</code> is not in the <code>account</code> dict. Obviously if you prefer to see the KeyError that’s fine too.</p>
<p>The documentation for <code>dict</code>'s <code>get</code> is here: <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#dict.get</a></p>
</div>
<div class="post-text" itemprop="text">
<h3>Conditional operator</h3>
<pre><code>result = value if value else ""
</code></pre>
<p>This is the ternary <a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow noreferrer">conditional operator</a> and basically equivalent to the following if statement:</p>
<pre><code>if value:
    result = value
else:
    result = ""
</code></pre>
<p>It is very explicit and allows you to describe exactly what condition you require. In this case, it just looks at the truthy value of <code>value</code>, but you could easily expand this to make a strict test against <code>None</code> for example:</p>
<pre><code>result = value if value is not None else ""
</code></pre>
<p>This would for example retain falsy values like <code>False</code> or <code>0</code>.</p>
<h3>or operator</h3>
<pre><code>value or ""
</code></pre>
<p>This uses the <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">boolean <code>or</code> operator</a>:</p>
<blockquote>
<p>The expression <code>x or y</code> first evaluates <code>x</code>; if <code>x</code> is true, its value is returned; otherwise, <code>y</code> is evaluated and the resulting value is returned.</p>
</blockquote>
<p>So this is basically a way to get the first truthy value (defaulting to the right operand). So this does the same as the <code>value if value else ""</code>. Unless the conditional operator, it does not support other checks though, so you can only check for truthiness here.</p>
<h3>Comparison</h3>
<p>In your case, where you want to just check against <code>None</code> and fall back to an empty string, there’s no difference at all. Just choose what is most understandable to you. From a “pythonic” point of view, one would probably prefer the <code>or</code> operator, as that’s also a bit shorter.</p>
<p>From a performance standpoint, the conditional operator is slightly more expensive in this case, as this needs to evaluate the dictionary access twice. In practice that won’t be noticeable though, especially not for a dictionary access.</p>
<p>If you do believe that this <em>could</em> have an impact on your application performance, then you should not believe in numbers you get from isolated benchmarks of a single statement; instead, you should profile your application and then try to identify bottlenecks which you can then improve on. I’ll guarantee you that it will be a long way before a second dictionary access will have <em>any</em> impact.</p>
<p>So yes, you can totally ignore the performance arguments for this. Just choose whatever you prefer, what makes the most sense to you. Also consider whether you just want a truthiness check, or whether a strict check against <code>None</code> would be better.</p>
</div>
<div class="post-text" itemprop="text">
<p>For your specific case, the boolean <code>or</code> operator looks more pythonic, and also a very simple benchmark shows that it is slightly more efficient:</p>
<pre><code>import timeit
setup = "account = {'first_name': None, 'last_name': 'Bloggs'}"
statements = {
    'ternary conditional operator': "first_name = account['first_name'] if account['first_name'] else ''",
    'boolean or operator': "first_name = account['first_name'] or ''",
}
for label, statement in statements.items():
    elapsed_best = min(timeit.repeat(statement, setup, number=1000000, repeat=10))
    print('{}: {:.3} s'.format(label, elapsed_best))
</code></pre>
<p>Output:</p>
<pre><code>ternary conditional operator: 0.0303 s
boolean or operator: 0.0275 s
</code></pre>
<p>Taking into account that the numbers above are the total execution times in seconds (1000000 evaluations per each statement), in practice, there is no significant difference in efficiency at all.</p>
</div>
<span class="comment-copy">Are the first names predominantly set or not?</span>
<span class="comment-copy"><i>“If you care about performance, you should instead compare against None and use PyPy”</i> – That’s a very confusing statement. You are seriously recommending switching to PyPy on the basis of a tiny and insignificant instruction which has a 40ns difference in a benchmark?</span>
<span class="comment-copy">@poke Of course not. There <i>is no</i> performance difference between statements - especially with PyPy, the stdev makes the difference of means insignificant. That is why the <i>more correct</i> test against None should be taken. There <i>is</i> a difference between implementations, though, and that matches the factor of commonly used benchmarks. That is why the <i>objectively faster</i> PyPy should be taken <i>if</i> one cares about performance.</span>
<span class="comment-copy">When there’s no difference, then why are you <i>recommending</i> anything based on performance? If there is no performance difference, you shouldn’t even show meaningless numbers. That just gives off a wrong impression. Also, <i>“more correct test”</i> is fairly subjective when you don’t actually know the context in which OP is executing this. Yes, it is a good idea to mention that a strict check against <code>None</code> might be better for a various number of reasons but not because of performance, no. So leave it up to OP to make an educated decision based on that.</span>
<span class="comment-copy">@MisterMiyagi FWIW I think you did a decent job of editing the answer to be more balanced. Clearing up the comment trail, it's no-longer relevant :)</span>
<span class="comment-copy">Note that in OP's version, the first example does two dictionary lookups while the second example only does one.  If you're using some weird thing that looks like a dictionary but isn't, that could have side effects.</span>
<span class="comment-copy"><code>{ 'first_name': None }.get('first_name', '')</code> is <code>None</code>. So no, that won’t work.</span>
<span class="comment-copy">I don't think this will have the desired output. As @poke said it returns <code>None</code> if the key is in the dict but with a value of <code>None</code>. It should be <code>""</code></span>
<span class="comment-copy">You're right, sorry, clearly I need coffee even in the afternoons. I still prefer .get to handle the case of the key not being present, in most cases.</span>
<span class="comment-copy">This approach indeed <i>is</i> preferable - precisely because it means the input has to be better formed.</span>
