<div class="post-text" itemprop="text">
<p>The function that I want to cache is something like:</p>
<pre><code>def a(x, time='last'):
</code></pre>
<p>I have deterministic behaviour for every <code>a(x,y)</code>, except when <code>y=='last'</code>. So when <code>a(x, 'last')</code> is called, I would like to call the "real thing" and an lru_cached function for everything else.</p>
<p>I imagine this could be possible with my own decorator:</p>
<pre><code>def my_lru_cache(func):
    def function_wrapper(*args, **kwargs):
        if kwargs is not None:
            if 'time' in kwargs:
                return func(*args, **kwargs)
            else:
                return what?!?

    return function_wrapper
</code></pre>
<p>Am I completely wrong? How could this be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>Wrap the function in <code>lru_cache()</code>, then add your decorator on top and access the original uncached function via the <code>__wrapped__</code> attribute, or better still, use the <a href="https://docs.python.org/3/library/inspect.html#inspect.unwrap" rel="nofollow noreferrer"><code>inspect.unwrap()</code> function</a> to strip the function of an arbitrary number of decorators:</p>
<pre><code>from functools import wraps
from inspect import unwrap

def bypass_cache_last_time(func):
    @wraps(func)
    def function_wrapper(*args, **kwargs):
        if not 'time' in kwargs or kwargs['time'] == 'last':
            # Bypass any additional decorators and call function directly
            return unwrap(func)(*args, **kwargs)
        else:
            return func(*args, **kwargs)

        return function_wrapper
</code></pre>
<p>and use this as</p>
<pre><code>@bypass_cache_last_time
@lru_cache()
def some_function(x, time='last'):
    # ...
</code></pre>
<p>The <code>functools.wraps()</code> decorator passes the ability to unwrap the decorator again forward, as it sets the <code>__wrapped__</code> attribute on the wrapper.</p>
<p>Or make your decorator apply the <code>lru_cache()</code> decorator itself and retain your own copy of the original function when decorating:</p>
<pre><code>def my_lru_cache(func):
    cached = lru_cache()(func)

    @wraps(func)
    def function_wrapper(*args, **kwargs):
        if not 'time' in kwargs or kwargs['time'] == 'last':
            # call the function directly
            return func(*args, **kwargs)
        else:
            # use the lru_cache-wrapped version
            return cached(*args, **kwargs)

    return function_wrapper
</code></pre>
<p>use this as</p>
<pre><code>@my_lru_cache
def some_function(x, time='last'):
    # ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can call <code>lru_cache()</code> directly to get a 'wrapped' version of <code>func</code> using <code>lru_cache(&lt;args&gt;)(func)</code>. Then you can return it from your wrapper:</p>
<pre><code>def my_lru_cache(func):
    caching_func = lru_cache()(func)
    def function_wrapper(*args, **kwargs):        
        if kwargs.get('time') == 'last':
            return func(*args, **kwargs)
        return caching_func(*args, **kwargs)
    return function_wrapper
</code></pre>
</div>
<span class="comment-copy"><code>kwargs</code> will never be <code>None</code>, it is <b>always</b> going to be a dictionary, potentially empty.</span>
<span class="comment-copy">Shouldn't the test be <code>if 'time' not in kwargs or kwargs['time'] == 'last':</code>, so either <code>time</code> was not set explicitly (and the default <code>time='last'</code> applies) or <code>time='last'</code> was explicitly called.</span>
<span class="comment-copy">If you need to support <code>a(x, 'last')</code> <i>too</i>, then you also need to inspect <code>args</code>, because now the <code>'last'</code> value is passed in as a positional argument instead!</span>
<span class="comment-copy">Are parentheses really needed in <code>@my_lru_cache()</code> ?</span>
<span class="comment-copy">@EugeneYarmash: uhm, no.</span>
<span class="comment-copy">The <code>return function_wrapper</code> has the wrong indent, hasn't it?</span>
<span class="comment-copy">Thank you, I think that works :) But is there a way to get to the cache_info() function? Might be hard since some times it's there, sometimes not :s</span>
<span class="comment-copy">@MarkusGrunwald: good catch, yes, the second example had a wrong indentation for the wrapper return.</span>
