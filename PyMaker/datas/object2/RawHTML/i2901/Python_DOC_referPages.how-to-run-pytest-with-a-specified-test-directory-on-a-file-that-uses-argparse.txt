<div class="post-text" itemprop="text">
<ul>
<li>I am writing unit tests for a Python library using <strong>pytest</strong></li>
<li>I need to <strong>specify a directory</strong> for test files to avoid automatic test file discovery, because there is a large sub-directory structure, including many files in the library containing "_test" or "test_" in the name but are not intended for pytest</li>
<li>Some files in the library use <strong>argparse</strong> for specifying command-line options</li>
<li>The problem is that specifying the directory for pytest as a command-line argument seems to interfere with using command line options for argparse</li>
</ul>
<p>To give an example, I have a file in the root directory called <code>script_with_args.py</code> as follows:</p>
<pre><code>import argparse

def parse_args():
    parser = argparse.ArgumentParser(description="description")

    parser.add_argument("--a", type=int, default=3)
    parser.add_argument("--b", type=int, default=5)

    return parser.parse_args()
</code></pre>
<p>I also have a folder called <code>tests</code> in the root directory, containing a test-file called <code>test_file.py</code>:</p>
<pre><code>import script_with_args

def test_script_func():
    args = script_with_args.parse_args()
    assert args.a == 3
</code></pre>
<p>If I call <code>python -m pytest</code> from the command line, the test passes fine. If I specify the test directory from the command line with <code>python -m pytest tests</code>, the following error is returned:</p>
<pre><code>============================= test session starts =============================
platform win32 -- Python 3.6.5, pytest-3.5.1, py-1.5.3, pluggy-0.6.0
rootdir: C:\Users\Jake\CBAS\pytest-tests, inifile:
plugins: remotedata-0.2.1, openfiles-0.3.0, doctestplus-0.1.3, arraydiff-0.2
collected 1 item

tests\test_file.py F                                                     [100%]

================================== FAILURES ===================================
______________________________ test_script_func _______________________________

    def test_script_func():
        # a = 1
        # b = 2
&gt;       args = script_with_args.parse_args()

tests\test_file.py:13:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
script_with_args.py:9: in parse_args
    return parser.parse_args()
..\..\Anaconda3\lib\argparse.py:1733: in parse_args
    self.error(msg % ' '.join(argv))
..\..\Anaconda3\lib\argparse.py:2389: in error
    self.exit(2, _('%(prog)s: error: %(message)s\n') % args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ArgumentParser(prog='pytest.py', usage=None, description='description', f
ormatter_class=&lt;class 'argparse.HelpFormatter'&gt;, conflict_handler='error', add_h
elp=True)
status = 2, message = 'pytest.py: error: unrecognized arguments: tests\n'

    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
&gt;       _sys.exit(status)
E       SystemExit: 2

..\..\Anaconda3\lib\argparse.py:2376: SystemExit
---------------------------- Captured stderr call -----------------------------
usage: pytest.py [-h] [--a A] [--b B]
pytest.py: error: unrecognized arguments: tests
========================== 1 failed in 0.19 seconds ===========================
</code></pre>
<p>My question is, how do I specify the test file directory for pytest, without interfering with the command line options for argparse?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>parse_args()</code> without argument reads the <code>sys.argv[1:]</code> list.  That will include the 'tests' string.</p>
<p><code>pytests</code> also uses that <code>sys.argv[1:]</code> with its own parser.</p>
<p>One way to make your parser testable is provide an optional <code>argv</code>:</p>
<pre><code>def parse_args(argv=None):
    parser = argparse.ArgumentParser(description="description")

    parser.add_argument("--a", type=int, default=3)
    parser.add_argument("--b", type=int, default=5)

    return parser.parse_args(argv)
</code></pre>
<p>Then you can test it with:</p>
<pre><code>parse_args(['-a', '4'])
</code></pre>
<p>and use it in for real with </p>
<pre><code>parse_args()
</code></pre>
<p>Changing the <code>sys.argv</code> is also good way.  But if you are going to the work of putting the parser in a function like this, you might as well give it this added flexibility.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add to hpaulj's answer, you can also use a library like <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">unittest.mock</a> to temporarily mask the value  of <code>sys.argv</code>. That way your parse args command will run using the "mocked" argv but the <em>actual</em> <code>sys.argv</code> remains unchanged.</p>
<p>When your tests call <code>parse_args()</code> they could do it like this:</p>
<pre><code>with unittest.mock.patch('sys.argv', ['--a', '1', '--b', 2]):
    parse_args()
</code></pre>
</div>
<span class="comment-copy">Your issue is not how to avoid passing CLI args in test session, but rather how to write proper tests for CLI args parsing logic. You have two possibilities for that: mocking the <code>sys.argv</code> list or the  <code>ArgumentParser.parse_args</code> return value, or refactor your <code>parse_args</code> function so it accepts the args list. Both ways have examples in the answers to the linked question.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/18160078/how-do-you-write-tests-for-the-argparse-portion-of-a-python-module">How do you write tests for the argparse portion of a python module?</a></span>
<span class="comment-copy">@hoefling or maybe <a href="https://stackoverflow.com/questions/18668947/how-do-i-set-sys-argv-so-i-can-unit-test-it" title="how do i set sys argv so i can unit test it">stackoverflow.com/questions/18668947/â€¦</a></span>
<span class="comment-copy">This does not work for me when trying to inject cmd-line arguments for pytest tests. Unittest.mock in itself works but has no effect in changing the command-line argument to the value I inject programatically.</span>
