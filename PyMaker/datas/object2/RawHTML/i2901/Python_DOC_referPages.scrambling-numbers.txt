<div class="post-text" itemprop="text">
<p>I am trying to program an algorithm that scrambles and "unscrambles" integer numbers.</p>
<p>I need two functions <code>forward</code> and <code>backward</code></p>
<ul>
<li><code>backward(number)</code>: return a "random" number between <code>0</code> and <code>9</code>, the same input <code>number</code> always returns the same output</li>
<li><code>forward(number)</code>: return the input to <code>backward</code> that returns <code>number</code></li>
</ul>
<p>I managed to solve the problem like this:</p>
<pre><code>from random import randint

class Scrambler:

    def __init__(self):

        self.mapping = [i for i in range(10)]

        # scramble mapping
        for i in range(1000):
            r1 = randint(0, len(self.mapping) - 1)
            r2 = randint(0, len(self.mapping) - 1)
            temp = self.mapping[r1]
            self.mapping[r1] = self.mapping[r2]
            self.mapping[r2] = temp

    def backward(self, num):
        return self.mapping[num]

    def forward(self, num):
        return self.mapping.index(num)

if __name__ == '__main__':

    s = Scrambler()
    print(s.mapping)
    for i in range(len(s.mapping)):
        print(i, s.forward(i), s.backward(i), s.forward(s.backward(i)), s.backward(s.forward(i)))
</code></pre>
<p>Is there a way to do this without using the mapping list?
Can i <strong>calculate</strong> the return value of the functions <code>forward</code> and <code>backward</code>?</p>
<p>The "randomness" of the numbers does not need to be perfect.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your current solution is better than coming up with a function each time. It is a good solution. </p>
<p>Here is a generic solution for a generic key. You'd make your version using the <code>Cipher.random_range</code> method I've stuck on.</p>
<pre><code>import random

class Cipher:

    def __init__(self, key):
        """
        key is a dict of unique values (i.e. bijection)
        """
        if len(set(key.values())) != len(key):
            raise ValueError('key values are not unique')
        self._encoder = key.copy()
        self._decoder = {v: k for k, v in key.items()}

    @classmethod
    def random_range(cls, max):
        lst = list(range(max))
        random.shuffle(lst)
        return cls(dict(enumerate(lst)))

    def encode(self, num):
        return self._encoder[num]

    def decode(self, num):
        return self._decoder[num]
</code></pre>
</div>
<span class="comment-copy">Well yes, it's possible. You'd have to generate a reversible bijective function on the integer range R = [0, 9]. For example f(x) = x + 1 mod 10,  f^-1(y) = x -1 mod 10. However, these do not appear very random. Finding the functions f, f^-1 which appear random is not a simple task in general. I don't see anything wrong with your current approach (although <code>self.mapping[r1], self.mapping[r2] = self.mapping[r2], self.mapping[r1]</code> looks cleaner than using <code>temp</code>).</span>
<span class="comment-copy">You need to improve this question, is not clear what you want to achieve. If you say that <code>backward(number): return a "random" number between 0 and 9</code>, why you need a <code>number</code> argument in the first place? seems not related. <i>Just what do you think you're doing, Jonas?</i></span>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow noreferrer"><code>random.shuffle</code></a> to scramble your list. Also you can do <code>self.mapping[r1], self.mapping[r2] = self.mapping[r2], self.mapping[r1]</code> for swapping. As for the question, you can design several different bijections from [0, 9] to [0, 9] (that is, formulas to go in one direction and backwards) although the "randomness" is most likely not going to be nearly as good as that of RNG routines.</span>
<span class="comment-copy">mapping list can be set up easy by <code>self.mapping = list(range(10))</code></span>
<span class="comment-copy">@Gsk I meant random in the way, that the same input always produces the same output, but a random one. FHTMitchells formulation using the term bijective function is probably more unambiguous.</span>
