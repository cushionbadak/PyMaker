<div class="post-text" itemprop="text">
<pre><code>for line in fo:
    line = " ".join(line.split())
    line = line.strip()
</code></pre>
<p>I am getting an error  </p>
<pre><code>line = ''.join(line.split())
TypeError: sequence item 0: expected str instance, bytes found
</code></pre>
<p>its working fine in python 2.x, but not working on 3.4
kindly suggest a proper solution for that</p>
</div>
<div class="post-text" itemprop="text">
<p><code>' '</code> is a string which you're calling its <code>join</code> method with a byte sequence. As the documentation's stated, in python-3.x:</p>
<blockquote>
<p><code>str.join</code>Return a string which is the concatenation of the strings
  in the <a href="https://docs.python.org/3/glossary.html#term-iterable" rel="noreferrer">iterable</a> <em>iterable</em>. A <a href="https://docs.python.org/3/library/exceptions.html#TypeError" rel="noreferrer">TypeError</a> will be raised if there are any
  non-string values in iterable, including <a href="https://docs.python.org/3/library/functions.html#bytes" rel="noreferrer">bytes</a> objects. The separator
  between elements is the string providing this method.</p>
</blockquote>
<p>But in this case since you are dealing with byte objects you cannot use <code>str</code> related methods. The byte object itself comes with a <a href="https://docs.python.org/3/library/stdtypes.html#bytes.join" rel="noreferrer"><strong><em><code>join()</code></em></strong></a> method that can be used in the same manner as <code>str.join</code>. You can also use <code>io.BytesIO</code>, or you can do in-place concatenation with a <code>bytearray</code> object. As the documentation's mentioned <strong><em><code>bytearray</code> objects are mutable and have an efficient overallocation mechanism.</em></strong></p>
<p>So you can simply add a <code>b</code> prefix to the empty string to make it a byte object:</p>
<pre><code>line = b" ".join(line.split())
</code></pre>
<p>Also, if your file is contain strings you can simply open your file in a <code>str</code> mode (<code>'r'</code>)instead of byte (<code>'rb'</code>).</p>
<pre><code>with open("input.txt", "r") as f:
    # Do something with f
</code></pre>
<hr/>
<p>Note that despite the separation between <code>str</code> and <code>byte</code> objects in python-3.x, in python-2.x you only have <code>str</code>. You can see this by checking the type of a string with <code>b</code> prefix:</p>
<pre><code>In [2]: type(b'')
Out[2]: str
</code></pre>
<p>And that's what that makes the following snippet work:</p>
<pre><code>"".join([b'www', b'www'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should be adding a line 
lines=str(lines)</p>
<p>before running the command to avoid errors .This way you convert to string initially itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you came here searching for a solution to join a custom class implemented in C/C++, the simplest method is to add a join method to the class itself and create binding to python.</p>
<p>For example, a class that can have either list or map which should be joinable, example code in pybind11 would be something like this:</p>
<pre><code>py::class_&lt;Data&gt; _data(m, "Data");
_data.def(py::init&lt;&gt;())
    .def("join", [] (Data &amp;d, const char *j = ' ') {
        std::string ret;
        if (d.isObject())
            for (auto &amp;o: d.object())
                ret += o.first + j;
        else if (d.isList())
            for (auto &amp;o: d.list())
                ret += o.stringValue() + j;
        return ret;
    })
</code></pre>
<p>Then in python, it is a simple matter of calling the join method for the class</p>
<pre><code>data.join('_')
</code></pre>
</div>
<span class="comment-copy">What's <code>fo</code> here?</span>
<span class="comment-copy">Convert the bytes to str, might help.</span>
<span class="comment-copy">fo = open("input.txt", "rb")</span>
