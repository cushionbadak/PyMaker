<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/588004/is-floating-point-math-broken">Is floating point math broken?</a>
<span class="question-originals-answer-count">
                    28 answers
                </span>
</li>
</ul>
</div>
<p>I'm a beginner python programmer and i'm wondering why this script won't work when inputted a float of 0.30. I've tried other inputs (i.e 0.50, 1.00, 0.10 etc...) and they worked fine. There may be simpler ways to do this calculator, but I just want to know why this script in particular won't work. The script is the following:</p>
<pre><code>money = float(raw_input("Input the money: "))
twofive_count = 0
ten_count = 0
five_count = 0
one_count = 0
while money != 0.00:
    if money &gt;= 0.25:
        money -= 0.25
        twofive_count +=1
    elif money &lt; 0.25 and money &gt;= 0.10:
        money -= 0.10
        ten_count += 1
    elif money &lt; 0.10 and money &gt;= 0.05:
        money -= 0.05
        five_count += 1
    elif money &lt; 0.05 and money &gt;= 0.01:
        money -= 0.01
        one_count += 1
print "Quarters:",twofive_count
print "Dimes:",ten_count
print "Nickels:",five_count
print "Pennies:",one_count
total_change = twofive_count + ten_count + five_count + one_count
print "Total number of coins in change:",total_change
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue occurs because of how internal representation of float works, when you do -</p>
<pre><code>0.30 - 0.25
</code></pre>
<p>You get a result as -</p>
<pre><code>0.04999999999999999
</code></pre>
<p>And when you subtract <code>0.05</code> from this, you get a negative number not a 0.00 . Example to show this -</p>
<pre><code>&gt;&gt;&gt; s = float('0.30')
&gt;&gt;&gt; s
0.3
&gt;&gt;&gt; s-0.25
0.04999999999999999
&gt;&gt;&gt; s-0.05
0.25
&gt;&gt;&gt; s = s-0.25
&gt;&gt;&gt; s = s - 0.05
&gt;&gt;&gt; s
-1.3877787807814457e-17
</code></pre>
<p>I think since you are dealing with currencies, you can round the number to 2 decimal places at all times, and it should be fine.</p>
<p>Example -</p>
<pre><code>money = float(raw_input("Input the money: "))
twofive_count = 0
ten_count = 0
five_count = 0
one_count = 0
while money != 0.00:
    if money &gt;= 0.25:
        money = round(money - 0.25, 2)
        twofive_count +=1
    elif money &lt; 0.25 and money &gt;= 0.10:
        money = round(money - 0.10, 2)
        ten_count += 1
    elif money &lt; 0.10 and money &gt;= 0.05:
        money = round(money - 0.05, 2)
        five_count += 1
    elif money &lt; 0.05 and money &gt;= 0.01:
        money -= round(money - 0.01, 2)
        one_count += 1
print "Quarters:",twofive_count
print "Dimes:",ten_count
print "Nickels:",five_count
print "Pennies:",one_count
total_change = twofive_count + ten_count + five_count + one_count
print "Total number of coins in change:",total_change
</code></pre>
<hr/>
<p>Or if you do not want to round , you can use <a href="https://docs.python.org/2/library/decimal.html#decimal.Decimal" rel="nofollow"><code>decimal.Decimal</code></a> , in that case you would need to change all elements (to Decimal) , Example - </p>
<pre><code>from decimal import Decimal
money = Decimal(raw_input("Input the money: "))
twofive_count = 0
ten_count = 0
five_count = 0
one_count = 0
while money != 0.00:
    if money &gt;= Decimal('0.25'):
        money -= Decimal('0.25')
        twofive_count +=1
    elif money &lt; Decimal('0.25') and money &gt;= Decimal('0.10'):
        money -= Decimal('0.10')
        ten_count += 1
    elif money &lt; Decimal('0.10') and money &gt;= Decimal('0.05'):
        money -= Decimal('0.05')
        five_count += 1
    elif money &lt; Decimal('0.05') and money &gt;= Decimal('0.01'):
        money -= Decimal('0.01')
        one_count += 1
print "Quarters:",twofive_count
print "Dimes:",ten_count
print "Nickels:",five_count
print "Pennies:",one_count
total_change = twofive_count + ten_count + five_count + one_count
print "Total number of coins in change:",total_change
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Forget floating point, that way lies madness if you don't understand what's going on under the covers.</p>
<p>If you want exactness, turn the value into an integer as soon as possible:</p>
<pre><code>money = float(raw_input("Input the money: "))

money = int (money * 100 + 0.1)           # Make integral pennies
                                          #   avoiding 0.999999 problems
twofive_count = 0
ten_count = 0
five_count = 0
one_count = 0
while money &gt; 0:
    if money &gt;= 25:                       # Make sure you use pennies
        money -= 25
        twofive_count +=1
    elif money &gt;= 10:
        money -= 10
        ten_count += 1
    elif money &gt;= 5:
        money -= 5
        five_count += 1
    elif money &gt;= 1:
        money -= 1
        one_count += 1

print "Quarters:",twofive_count
print "Dimes:",ten_count
print "Nickels:",five_count
print "Pennies:",one_count
total_change = twofive_count + ten_count + five_count + one_count
print "Total number of coins in change:",total_change
</code></pre>
<p>You'll also notice I've cleaned up your coin detection code. There is no need to check both ends of the range (e.g., less than a nickel and at least a penny) because you're using <code>elif</code> which means the first part of that condition has already been checked.</p>
<hr/>
<p>Of course, there's often a more efficient way to do it if you think about it a bit. A first step would be breaking each step into its <em>own</em> <code>while</code> to isolate each coin count calculation, something like:</p>
<pre><code>while money &gt;= 25:
    money -= 25
    twofive_count +=1
while money &gt;= 10:
    money -= 10
    ten_count += 1
while money &gt;= 5:
    money -= 5
    five_count += 1
while money &gt;= 1:
    money -= 1
    one_count += 1
</code></pre>
<p>From there, it's a short step to realising that, once you've worked out all non-penny values, the number of pennies can be done quicker:</p>
<pre><code>while money &gt;= 25:
    money -= 25
    twofive_count +=1
while money &gt;= 10:
    money -= 10
    ten_count += 1
while money &gt;= 5:
    money -= 5
    five_count += 1
one_count = money
</code></pre>
<p>But there's <em>also</em> a way to figure out each coin count without repeated subtraction, since repeated subtraction is <em>exactly</em> why division was invented :-)</p>
<pre><code>twofive_count = int (money / 25)
money -= (twofive_count * 25)

ten_count = int (money / 10)
money -= (ten_count * 10)

five_count = int (money / 5)
money -= (five_count * 5)

one_count = money
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As said by others, floating point representation is not precise. To use more precise decimal representation use fixed point notation with the <code>Decimal</code> class from the <code>decimal</code> Python module[0].</p>
<p>[0] <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow">https://docs.python.org/3/library/decimal.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think your problem is <code>while money != 0.00:</code></p>
<p>Comparing floats is fraught with danger as binary representation of fractions aren't perfect. To compare a float properly you need to subtract one from the other and then see if the result is within some tolerance value which is reasonable for your application.</p>
<p>I think using the decimal class would solve your problem and provide a much more sensible solution than trying to make floats work for you.</p>
<p><a href="https://docs.python.org/2/library/decimal.html" rel="nofollow">https://docs.python.org/2/library/decimal.html</a></p>
<p>From the page:</p>
<ul>
<li><p>Decimal numbers can be represented exactly. In contrast, numbers like 1.1 and 2.2 do not have exact representations in binary floating point. End users typically would not expect 1.1 + 2.2 to display as 3.3000000000000003 as it does with binary floating point.</p></li>
<li><p>The exactness carries over into arithmetic. In decimal floating point, 0.1 + 0.1 + 0.1 - 0.3 is exactly equal to zero. In binary floating point, the result is 5.5511151231257827e-017. While near to zero, the differences prevent reliable equality testing and differences can accumulate. For this reason, decimal is preferred in accounting applications which have strict equality invariants.</p></li>
</ul>
</div>
<span class="comment-copy">take a look at <a href="http://stackoverflow.com/questions/588004/is-floating-point-math-broken" title="is floating point math broken">stackoverflow.com/questions/588004/â€¦</a></span>
<span class="comment-copy">print "money" at the bottom of the while loop, i.e. what happens when it equals 1 cent --&gt;   elif money &lt; 0.05 and money &gt;= 0.01:  And the while loop should be money &gt; 0 because floats are inaccurate and the result may be slightly less than zero</span>
