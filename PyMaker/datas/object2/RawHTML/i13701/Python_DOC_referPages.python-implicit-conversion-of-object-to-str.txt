<div class="post-text" itemprop="text">
<p>Given the following code</p>
<pre><code>class A:
  def __init__(self ):
    self.b = B()

  def __repr__(self):
    #return "&lt;A with {} inside&gt;".format( self.b )
    #return "&lt;A with " + repr(self.b) + " inside&gt;"
    return "&lt;A with " + self.b  + " inside&gt;" # TypeError: Can't convert 'B' object to str implicitly

class B:
  def __repr__(self):
    return "&lt;B&gt;"

a = A()
print(a)
</code></pre>
<p>I am wondering why B's <code>__repr__</code> is not called when "adding" A's <code>self.b</code> to a string.</p>
<ul>
<li><a href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" rel="noreferrer">https://docs.python.org/3/reference/datamodel.html#object.<strong>repr</strong></a></li>
<li><a href="https://docs.python.org/3/reference/lexical_analysis.html#operators" rel="noreferrer">https://docs.python.org/3/reference/lexical_analysis.html#operators</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Concatenation doesn't cause <code>self.b</code> to be evaluated as a string. You need to explicitly tell Python to coerce it into a string.</p>
<p>You could do:</p>
<pre><code>return "&lt;A with " + repr(self.b)  + " inside&gt;"
</code></pre>
<p>But using <code>str.format</code> would be better.</p>
<pre><code>return "&lt;A with {} inside&gt;".format(self.b)
</code></pre>
<p>However as jonrsharpe points out that would try to call <code>__str__</code> first (if it exists), in order to make it specifically use <code>__repr__</code> there's this syntax: <code>{!r}</code>.</p>
<pre><code>return "&lt;A with {!r} inside&gt;".format(self.b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use repr()</p>
<pre><code>class A:
    def __init__(self):
        self.b = repr(B())

    def __repr__(self):
        return "&lt;A with " + self.b + " inside&gt;"


class B:
    def __repr__(self):
        return "&lt;B&gt;"

a = A()
print(repr(a))
</code></pre>
<p>its works for me</p>
</div>
<span class="comment-copy">For the same reason that <code>"three " + 3</code> fails. Is there a way to have the object behave as a string?</span>
<span class="comment-copy">Yes, <b>explicitly</b> convert it to a string, using <code>str</code> or <code>repr</code>, or use string formatting: <code>"&lt;A with {!r} inside&gt;".format(self.b)</code>. Python is <b>strongly typed</b>, implicit conversion doesn't happen.</span>
<span class="comment-copy">OK, so there's no such thing like Ruby's operator overloading (which I had in the back of my head).</span>
<span class="comment-copy">What if you use str.format rather than concatenating the strings?</span>
<span class="comment-copy">Both commented lines (format() and repr()) do the conversion.</span>
<span class="comment-copy">This might technically produce the output required but it means that <code>self.b</code> is just set to a string instead of an object.</span>
