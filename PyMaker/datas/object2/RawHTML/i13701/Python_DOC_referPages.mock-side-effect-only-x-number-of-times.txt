<div class="post-text" itemprop="text">
<p>I have a celery retry task that I would like to test that it retries until successful.  Using mock's side_effect, I can fail it for a set number of executions and then passing <code>None</code>, clear the side effect.   However, the method the task is calling doesn't execute at that point, it just doesn't have an exception.  Is there a way to clear the side effect, and still have the method being mocked execute as normal?</p>
<p>I can test that it is called 'x' number of times (ie. repeat until successful) and then in a separate test, assert it does what is supposed to, but was wondering if there was a way to do both in one test.</p>
<p>tasks.py:</p>
<pre><code>import celery

@celery.task(max_retries=None)
def task():
    print "HERE"
    try:
        do_something("TASK")
    except Exception as exc:
        print exc
        raise task.retry(exc=exc)

def do_something(msg):
    print msg
</code></pre>
<p>Test:</p>
<pre><code>import ....

class TaskTests(test.TestCase):

    @mock.patch('tasks.do_something')
    def test_will_retry_until_successful(self, action):
        action.side_effect = [Exception("First"), Exception("Second"), Exception("Third"), None]
        tasks.task.delay()
        self.assert.... [stuff about task]
</code></pre>
<p>Results:
fails three times and then "succeeds" but <code>do_something()</code> never prints.
<code>action.call_count</code> equals 4.
I would like to see that the blank line following the last 'HERE' would be print of 'TASK'.</p>
<pre><code>-------------------- &gt;&gt; begin captured stdout &lt;&lt; ---------------------
HERE
First
HERE
Second
HERE
Third
HERE

--------------------- &gt;&gt; end captured stdout &lt;&lt; ----------------------
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You <em>mocked <code>do_something()</code></em>. A mock replaces the original entirely; your choices are to either have the side effect (raise or return a value from the iterable) or to have the normal mock operations apply (returning a new mock object).</p>
<p>In addition, adding <code>None</code> to the <code>side_effect</code> sequence doesn't reset the side effect, it merely instructs the mock to return the value <code>None</code> instead. You could add in <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.DEFAULT" rel="nofollow noreferrer"><code>mock.DEFAULT</code></a> instead; in that case the normal mock actions apply (as if the mock had been called without a side effect):</p>
<pre><code>@mock.patch('tasks.do_something')
def test_will_retry_until_successful(self, action):
    action.side_effect = [Exception("First"), Exception("Second"), Exception("Third"), mock.DEFAULT]
    tasks.task.delay()
    self.assert.... [stuff about task]
</code></pre>
<p>If you feel your test <strong>must</strong> end with calling the original, you'll have to store a reference to the original, unpatched function, then set the <code>side_effect</code> to a callable that will turn around and call the original when the time comes:</p>
<pre><code># reference to original, global to the test module that won't be patched
from tasks import do_something

class TaskTests(test.TestCase):
    @mock.patch('tasks.do_something')
    def test_will_retry_until_successful(self, action):
        exceptions = iter([Exception("First"), Exception("Second"), Exception("Third")])
        def side_effect(*args, **kwargs):
            try:
                raise next(exceptions)
            except StopIteration:
                # raised all exceptions, call original
                return do_something(*args, **kwargs)
        action.side_effect = side_effect
        tasks.task.delay()
        self.assert.... [stuff about task]
</code></pre>
<p>I cannot, however, foresee a unittesting scenario where you'd want to do that. <code>do_something()</code> is not part of the Celery task being tested, it is an external unit, so you should normally only test if it was called correctly (with the right arguments), and the correct number of times.</p>
</div>
<span class="comment-copy">Well, you did <i>mock</i> <code>do_something()</code>. Mocking a method doesn't then call the original, with our without side effects.</span>
<span class="comment-copy">What should we do in case if <code>do_something</code> is a class method. It can't be so easy saved, due to since it is a class method we somehow should be able to pass self. Any ideas? btw since it is some internal logic it couldn't be just instantiated in test suite</span>
<span class="comment-copy">@xiº: why do you need to have access to <code>do_something</code> <i>at all</i>? It is not part of the code-under-test, so from a unit-testing point of view you should just mock it. Any reference to a callable can be saved however, it doesn't matter if it is a class method.</span>
<span class="comment-copy">I need something like side_effect = [original_valid_call(), original_valid_call(), ValueError]. But can't manage how to pass an instance in valid call.</span>
<span class="comment-copy">In my case do_smth is just underlying layer.</span>
<span class="comment-copy">@xiº: why not provide mock objects instead? Otherwise, how would you <i>normally</i> call that class method?</span>
