<div class="post-text" itemprop="text">
<p>Let's say I have a bunch of coroutines. These coroutines should be called using <code>yield from</code>. How can I detect I made a mistake and directly called the coroutine like a subroutine ?</p>
<p>Here is an example code :</p>
<pre><code>import asyncio

@asyncio.coroutine
def A(msg):
    print(msg)
    yield from asyncio.sleep(1)

@asyncio.coroutine
def B():
    while True :
        yield from A('1')
        A('2')
        yield from A('3')

loop = asyncio.get_event_loop()
loop.run_until_complete(B())
</code></pre>
<p>And the output :</p>
<pre><code>1
3
1
3
1
3
...
</code></pre>
<p>Calling coroutine like subroutine does nothing, but does not raise exception or block the event loop, so the failure mode is very quiet. </p>
</div>
<div class="post-text" itemprop="text">
<p>I added a check_iterator function to your code.  If you decorate your coroutine with this function, it will print information out if your coroutine is ever directly called and is not accessed using <code>__iter__</code>.  Depending on your actual code, you may need to make a more complete implementation and wrap <code>__next__</code> as well.  That would probably be somewhat lower-performance, though.</p>
<pre><code>import asyncio
import functools

class IterWrap(object):
    def __init__(self, f, *args, **kwds):
        self.iterated = False
        self.info = [f, args, kwds]
        self.f = f(*args, **kwds)

    def __iter__(self):
        self.iterated = True
        return iter(self.f)

    def __del__(self):
        if not self.iterated:
            print("Did not yield: %s" % self.info)

def check_iterator(f):
    @functools.wraps(f)
    def wrapper(*args, **kwds):
        return IterWrap(f, *args, **kwds)
    return wrapper

@check_iterator
@asyncio.coroutine
def A(msg):
    print(msg)
    yield from asyncio.sleep(1)

@asyncio.coroutine
def B():
    while True :
        yield from A('1')
        A('2')
        yield from A('3')

loop = asyncio.get_event_loop()
loop.run_until_complete(B())
</code></pre>
<p>The results of running this on Python 3.4 are:</p>
<pre><code>1
Did not yield: [&lt;function A at 0xb6e3189c&gt;, ('2',), {}]
3
1
Did not yield: [&lt;function A at 0xb6e3189c&gt;, ('2',), {}]
3
1
Did not yield: [&lt;function A at 0xb6e3189c&gt;, ('2',), {}]
3
1
Did not yield: [&lt;function A at 0xb6e3189c&gt;, ('2',), {}]
3
</code></pre>
</div>
<span class="comment-copy">Coroutines? Are you sure this is python? Python has functions.</span>
<span class="comment-copy">@muddyfish: Python has generator functions that can be used as coroutines, in that the language supports delegation, sending messages and throwing exceptions in generator functions.</span>
<span class="comment-copy">@muddyfish, <a href="https://docs.python.org/3/library/asyncio-task.html" rel="nofollow noreferrer">do you want to know more</a>?</span>
<span class="comment-copy">@downvoters Please don't downvote this question without understanding it. Python does have coroutine (of sorts), and they will become more prominent with the advent of <a href="https://www.python.org/dev/peps/pep-0492/" rel="nofollow noreferrer">PEP 492</a>.</span>
<span class="comment-copy">I hope an example code for those out there downvoting without a comment will help there change their mind. The unclear aspect is now gone.</span>
<span class="comment-copy">Wow, this is a testimony to the power of python !</span>
