<div class="post-text" itemprop="text">
<p>Using this as a quick starting point;</p>
<p><a href="http://pandas.pydata.org/pandas-docs/stable/reshaping.html" rel="nofollow">http://pandas.pydata.org/pandas-docs/stable/reshaping.html</a></p>
<pre><code>In [1]: df
Out[1]: 
         date variable     value
0  2000-01-03        A  0.469112
1  2000-01-04        A -0.282863
2  2000-01-05        A -1.509059
3  2000-01-03        B -1.135632
4  2000-01-04        B  1.212112
5  2000-01-05        B -0.173215
6  2000-01-03        C  0.119209
7  2000-01-04        C -1.044236
8  2000-01-05        C -0.861849
9  2000-01-03        D -2.104569
10 2000-01-04        D -0.494929
11 2000-01-05        D  1.071804
</code></pre>
<p>Then isolating 'A' gives this: </p>
<pre><code>In [2]: df[df['variable'] == 'A']
Out[2]: 
        date variable     value
0 2000-01-03        A  0.469112
1 2000-01-04        A -0.282863
2 2000-01-05        A -1.509059
</code></pre>
<p>Now creating new dataframe would be:</p>
<pre><code>dfA = df[df['variable'] == 'A'] 
</code></pre>
<p>Lets say B's would be: </p>
<pre><code>dfB = df[df['variable'] == 'B'] 
</code></pre>
<p>So, Isolating the dataframes into dfA, dfB, dfC......</p>
<pre><code>dfList  = list(set(df['variable']))
dfNames = ["df" + row for row in dfList]  

for i, row in enumerate(dfList):
    dfName = dfNames[i]
    dfNew = df[df['variable'] == row]
    dfNames[i] = dfNew      
</code></pre>
<p>It runs... But when try <code>dfA</code> I get output <code>"dfA" is not defined</code></p>
</div>
<div class="post-text" itemprop="text">
<p>To answer your question literally, <code>globals()['dfA'] = dfNew</code> would define <code>dfA</code>
in the global namespace:</p>
<pre><code>for i, row in enumerate(dfList):
    dfName = dfNames[i]
    dfNew = df[df['variable'] == row]
    globals()[dfName] = dfNew   
</code></pre>
<p>However, there is never a good reason to define dynamically-named variables.</p>
<ul>
<li><p>If the names are not known until runtime -- that is, if the names are <em>truly</em>
dynamic -- then you you can't use the names in your code since your code has
to be written before runtime. So what's the point of creating a variable named
<code>dfA</code> if you can't refer to it in your code?</p></li>
<li><p>If, on the other hand, you know before hand that you will have a variable
named <code>dfA</code>, then your code isn't really dynamic. You have static variable names.
The only reason to use the loop is to cut down on boiler-plate code. However,
even in this case, there is a better alternative.
The solution is to use a dict (see below) or list<sup>1</sup>.</p></li>
<li><p>Adding dynamically-named variables pollutes the global namespace.</p></li>
<li><p>It does not generalize well. If you had 100 dynamically named variables, how
would you access them? <a href="https://stackoverflow.com/a/13096621/190597">How would you loop over them?</a></p></li>
<li><p>To "manage" dynamically named variables you would need to keep a list of their
names as strings: e.g. <code>['dfA', 'dfB', 'dfC',...]</code> and then accessed the newly
minted global variables via the <code>globals()</code> dict: e.g. <code>globals()['dfA']</code>. That
is awkward.</p></li>
</ul>
<p>So the conclusion programmers reach through bitter experience is that
dynamically-named variables are somewhere between awkward and useless and it is
much more pleasant, powerful, practical to store key/value pairs in a dict. The
name of the variable becomes a key in the dict, and the value of the variable
becomes the value associated with the key. So, instead of having a bare name <code>dfA</code>
you would have a dict <code>dfs</code> and you would access the <code>dfA</code> DataFrame via
<code>dfs['dfA']</code>:</p>
<pre><code>dfs = dict()
for i, row in enumerate(dfList):
    dfName = dfNames[i]
    dfNew = df[df['variable'] == row]
    dfs[dfName] = dfNew   
</code></pre>
<p>or, as <a href="https://stackoverflow.com/a/31927650/190597">Jianxun Li shows</a>,</p>
<pre><code>dfs = {k: g for k, g in df.groupby('variable')}
</code></pre>
<p>This is why Jon Clements and Jianxun Li answered your question by showing
alternatives to defining dynamically-named variables.  It's because we all
believe it is a terrible idea.</p>
<hr/>
<p>Using Jianxun Li's solution, to loop over <a href="https://docs.python.org/3/library/stdtypes.html#dict.items" rel="nofollow noreferrer">a dict's key/value pairs</a> you could then use:</p>
<pre><code>dfs = {k: g for k, g in df.groupby('variable')}
for key, df in dfs.items():
    ...
</code></pre>
<p>or using Jon Clements' solution, to <a href="http://pandas.pydata.org/pandas-docs/stable/groupby.html#iterating-through-groups" rel="nofollow noreferrer">iterate through groups</a> you could use: </p>
<pre><code>grouped = df.groupby('variable')
for key, df in grouped:
    ...
</code></pre>
<hr/>
<p><sup>1</sup>If the names are numbered or ordered you could use a list instead of a dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>groupby</code> and <code>get_group</code>, eg:</p>
<pre><code>grouped = df.groupby('variable')
</code></pre>
<p>Then when you want to do something with each group, access it as such:</p>
<pre><code>my_group = grouped.get_group('A')
</code></pre>
<p>Gives you:</p>
<pre><code>    date    variable    value
0   2000-01-03  A   0.469112
1   2000-01-04  A   -0.282863
2   2000-01-05  A   -1.509059
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>df.groupby('variable')</code> returns an iterator with <code>key/df</code> pairs. So to get a list/dict of subgroups,</p>
<pre><code>result = {k: g for k, g in df.groupby('variable')}

from pprint import pprint
pprint(result)

{'A':          date variable   value
0  2000-01-03        A  0.4691
1  2000-01-04        A -0.2829
2  2000-01-05        A -1.5091,
 'B':          date variable   value
3  2000-01-03        B -1.1356
4  2000-01-04        B  1.2121
5  2000-01-05        B -0.1732,
 'C':          date variable   value
6  2000-01-03        C  0.1192
7  2000-01-04        C -1.0442
8  2000-01-05        C -0.8618,
 'D':           date variable   value
9   2000-01-03        D -2.1046
10  2000-01-04        D -0.4949
11  2000-01-05        D  1.0718}


result['A']

         date variable   value
0  2000-01-03        A  0.4691
1  2000-01-04        A -0.2829
2  2000-01-05        A -1.5091
</code></pre>
</div>
<span class="comment-copy">You are writing <code>dfNew</code> into <code>dfNames[i]</code>, not <code>dfA</code>.  It's roughly equivalent to the difference between <code>dfA</code> and <code>"dfA"</code>.  I don't know if an exact solution to your question is possible in python due to the lack of macros.  You maybe could do this with a context manager? But really, I would think about doing it another way.  It might help if you could give some more context for the overall issue.</span>
<span class="comment-copy">@JohnE Thanks, Its much harder than it looks. I am trying to create everything dynamically, Segment out the smaller arrays so I can pickle them. In the above example, Simply trying to find a way to break out those four categories into separate df or array.. thanks for actually reading the code.</span>
<span class="comment-copy">@JohnE look at accepted ans.</span>
<span class="comment-copy">yep, that is thorough</span>
<span class="comment-copy">using Jianxun Li answer your modification to his ans. How would loop over the dict and isolate the the 'k' into their own dataframe... I am trying to generalize a solution so I dont know the keys ahead of time. I can drop the "df" in 'dfA'</span>
<span class="comment-copy">To loop over a dict, <code>dfs</code>, use <code>for key, values in dfs.items()</code> (in Python3), or <code>for key, values in dfs.iteritems()</code> (in Python2). I don't understand what "isolate the 'k' into their own dataframe" means. If your question is a clarification of the current question, please add it your question above. If it is a follow-up question, please consider asking it as a new question.</span>
<span class="comment-copy">Isolate each key into its own dataframe.. So, there are 4 keys, then there would be 4 dataframes.</span>
<span class="comment-copy">Then use the <code>for key, value in dfs.items()</code> loop as shown above.</span>
<span class="comment-copy">Regarding your suggested edit: My answer was really an attempt to convince you to not use <code>globals()</code>. Therefore I do not want to add <code>globals</code> there since I am NOT advocating the use of <code>globals()</code>. Once you have the <code>dict</code> as in Jianxun Li's answer, there is <b>no need for</b> using <code>globals()[key] = df</code>. Anywhere you would need <code>A</code>, you would use <code>dfs['A']</code> instead.</span>
<span class="comment-copy">does not really answer the question..  A list into multiple dataframes... Trying not to use groupby, trying to solve above question.</span>
<span class="comment-copy">Any particular reason you want to create dynamically named variables and perform a linear scan of the original dataframe as many times as the number of unique values of <code>variables</code> + 1? @Merlin?</span>
<span class="comment-copy">please read accepted ans</span>
