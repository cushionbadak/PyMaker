<div class="post-text" itemprop="text">
<p>I have a <code>score</code> function, and I want to sort a list according to it.</p>
<p>Ordinarily, this is easy (just get <code>sorted(l, key=score)</code>), but I need the scores later in the code, and <code>score</code> is computationally expensive (so I want to avoid scoring twice).</p>
<hr/>
<p>Here's my current code:</p>
<pre><code>scores= map(score, l)
new_l= [el for i,el in sorted(enumerate(l), key=lambda (i,el): scores[i])]
</code></pre>
<p>This works, but is a bit confusing and not particularly readable.</p>
<p>What's the best way to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Create a dictionary, with keys as your elements from <code>l</code> and the corresponding values will be the <code>scores</code></p>
<pre><code>&gt;&gt;&gt; scores = {el: score(el) for el in l}
</code></pre>
<p>And then use <code>scores.get</code> for the <code>key</code>, like this</p>
<pre><code>&gt;&gt;&gt; sorted(l, key=scores.get)
</code></pre>
<p><strong>Note:</strong> This technique will work only if the elements of <code>l</code> are hashable.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow"><code>functools.lru_cache</code></a> may be useful in here. As in the docs:</p>
<blockquote>
<p>Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls. It can save time when an expensive or I/O bound function is periodically called with the same arguments.</p>
</blockquote>
<p>simply, add the <code>lru_cache</code> to your function:</p>
<pre><code>@lru_cache(maxsize=32)
def score(i):
    ...
</code></pre>
</div>
<span class="comment-copy">why <code>key=lambda i,el:</code>?</span>
<span class="comment-copy">@PadraicCunningham sorry, it's actually <code>(i,el)</code>, for unpacking the tuple</span>
