<div class="post-text" itemprop="text">
<p>The Python documentation seems unclear about whether parameters are passed by reference or value, and the following code produces the unchanged value 'Original'</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.change(self.variable)
        print(self.variable)

    def change(self, var):
        var = 'Changed'
</code></pre>
<p>Is there something I can do to pass the variable by actual reference?</p>
</div>
<div class="post-text" itemprop="text">
<p>Arguments are <a href="http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="noreferrer">passed by assignment</a>. The rationale behind this is twofold:</p>
<ol>
<li>the parameter passed in is actually a <em>reference</em> to an object (but the reference is passed by value)</li>
<li>some data types are mutable, but others aren't</li>
</ol>
<p>So:</p>
<ul>
<li><p>If you pass a <em>mutable</em> object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. </p></li>
<li><p>If you pass an <em>immutable</em> object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</p></li>
</ul>
<p>To make it even more clear, let's have some examples. </p>
<h2>List - a mutable type</h2>
<p><strong>Let's try to modify the list that was passed to a method:</strong></p>
<pre><code>def try_to_change_list_contents(the_list):
    print('got', the_list)
    the_list.append('four')
    print('changed to', the_list)

outer_list = ['one', 'two', 'three']

print('before, outer_list =', outer_list)
try_to_change_list_contents(outer_list)
print('after, outer_list =', outer_list)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>before, outer_list = ['one', 'two', 'three']
got ['one', 'two', 'three']
changed to ['one', 'two', 'three', 'four']
after, outer_list = ['one', 'two', 'three', 'four']
</code></pre>
<p>Since the parameter passed in is a reference to <code>outer_list</code>, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</p>
<p><strong>Now let's see what happens when we try to change the reference that was passed in as a parameter:</strong></p>
<pre><code>def try_to_change_list_reference(the_list):
    print('got', the_list)
    the_list = ['and', 'we', 'can', 'not', 'lie']
    print('set to', the_list)

outer_list = ['we', 'like', 'proper', 'English']

print('before, outer_list =', outer_list)
try_to_change_list_reference(outer_list)
print('after, outer_list =', outer_list)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>before, outer_list = ['we', 'like', 'proper', 'English']
got ['we', 'like', 'proper', 'English']
set to ['and', 'we', 'can', 'not', 'lie']
after, outer_list = ['we', 'like', 'proper', 'English']
</code></pre>
<p>Since the <code>the_list</code> parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The <code>the_list</code> was a copy of the <code>outer_list</code> reference, and we had <code>the_list</code> point to a new list, but there was no way to change where <code>outer_list</code> pointed.</p>
<h2>String - an immutable type</h2>
<p><strong>It's immutable, so there's nothing we can do to change the contents of the string</strong></p>
<p><strong>Now, let's try to change the reference</strong></p>
<pre><code>def try_to_change_string_reference(the_string):
    print('got', the_string)
    the_string = 'In a kingdom by the sea'
    print('set to', the_string)

outer_string = 'It was many and many a year ago'

print('before, outer_string =', outer_string)
try_to_change_string_reference(outer_string)
print('after, outer_string =', outer_string)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>before, outer_string = It was many and many a year ago
got It was many and many a year ago
set to In a kingdom by the sea
after, outer_string = It was many and many a year ago
</code></pre>
<p>Again, since the <code>the_string</code> parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The <code>the_string</code> was a copy of the <code>outer_string</code> reference, and we had <code>the_string</code> point to a new string, but there was no way to change where <code>outer_string</code> pointed.</p>
<p>I hope this clears things up a little.</p>
<p><strong>EDIT:</strong> It's been noted that this doesn't answer the question that @David originally asked, "Is there something I can do to pass the variable by actual reference?". Let's work on that.</p>
<h2>How do we get around this?</h2>
<p>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</p>
<pre><code>def return_a_whole_new_string(the_string):
    new_string = something_to_do_with_the_old_string(the_string)
    return new_string

# then you could call it like
my_string = return_a_whole_new_string(my_string)
</code></pre>
<p>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</p>
<pre><code>def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):
    new_string = something_to_do_with_the_old_string(stuff_to_change[0])
    stuff_to_change[0] = new_string

# then you could call it like
wrapper = [my_string]
use_a_wrapper_to_simulate_pass_by_reference(wrapper)

do_something_with(wrapper[0])
</code></pre>
<p>Although this seems a little cumbersome.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</p>
<pre><code>a = 1
a = 2
</code></pre>
<p>You believe that <code>a</code> is a memory location that stores the value <code>1</code>, then is updated to store the value <code>2</code>. That's not how things work in Python. Rather, <code>a</code> starts as a reference to an object with the value <code>1</code>, then gets reassigned as a reference to an object with the value <code>2</code>. Those two objects may continue to coexist even though <code>a</code> doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</p>
<p>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</p>
<pre><code>def __init__(self):
    self.variable = 'Original'
    self.Change(self.variable)

def Change(self, var):
    var = 'Changed'
</code></pre>
<p><code>self.variable</code> is a reference to the string object <code>'Original'</code>. When you call <code>Change</code> you create a second reference <code>var</code> to the object. Inside the function you reassign the reference <code>var</code> to a different string object <code>'Changed'</code>, but the reference <code>self.variable</code> is separate and does not change.</p>
<p>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</p>
<pre><code>def __init__(self):         
    self.variable = ['Original']
    self.Change(self.variable)

def Change(self, var):
    var[0] = 'Changed'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.
<a href="https://i.stack.imgur.com/FdaCu.png"><img alt="enter image description here" src="https://i.stack.imgur.com/FdaCu.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh: </p>
<p><a href="http://effbot.org/zone/call-by-object.htm" rel="noreferrer">http://effbot.org/zone/call-by-object.htm</a></p>
<p>Here is a significant quote:</p>
<blockquote>
<p>"...variables [names] are <em>not</em> objects; they cannot be denoted by other variables or referred to by objects."</p>
</blockquote>
<p>In your example, when the <code>Change</code> method is called--a <a href="http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces" rel="noreferrer">namespace</a> is created for it; and <code>var</code> becomes a name, within that namespace, for the string object <code>'Original'</code>. That object then has a name in two namespaces. Next, <code>var = 'Changed'</code> binds <code>var</code> to a new string object, and thus the method's namespace forgets about <code>'Original'</code>. Finally, that namespace is forgotten, and the string <code>'Changed'</code> along with it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Think of stuff being passed <strong>by assignment</strong> instead of by reference/by value. That way, it is allways clear, what is happening as long as you understand what happens during normal assignment.</p>
<p>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list <em>inside</em> the function will not change the original list, since:</p>
<pre><code>a = [1, 2, 3]
b = a
b.append(4)
b = ['a', 'b']
print a, b      # prints [1, 2, 3, 4] ['a', 'b']
</code></pre>
<p>Since immutable types cannot be modified, they <em>seem</em> like being passed by value - passing an int into a function means assigning the int to the functions parameter. You can only ever reassign that, but it won't change the originial variables value.</p>
</div>
<div class="post-text" itemprop="text">
<p>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  <a href="http://effbot.org/zone/call-by-object.htm">http://effbot.org/zone/call-by-object.htm</a></p>
<p>Objects are allocated on the heap and pointers to them can be passed around anywhere.  </p>
<ul>
<li><p>When you make an assignment such as <code>x = 1000</code>, a dictionary entry is created that maps the string "x" in the current namespace to a pointer to the integer object containing one thousand.   </p></li>
<li><p>When you update "x" with <code>x = 2000</code>, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</p></li>
<li><p>When you do a new assignment such as <code>y = x</code>, a new dictionary entry "y" is created that points to the same object as the entry for "x".</p></li>
<li><p>Objects like strings and integers are <em>immutable</em>.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</p></li>
<li><p>Objects like lists are <em>mutable</em>.  This means that the contents of the object can be changed by anything pointing to the object.  For example, <code>x = []; y = x; x.append(10); print y</code> will print <code>[10]</code>.  The empty list was created.  Both "x" and "y" point to the same list.  The <em>append</em> method mutates (updates) the list object (like adding a record to a database) and the result is visible to both "x" and "y" (just as a database update would be visible to every connection to that database).</p></li>
</ul>
<p>Hope that clarifies the issue for you. </p>
</div>
<div class="post-text" itemprop="text">
<p>Technically, <strong>Python always uses pass by reference values</strong>. I am going to repeat <a href="https://stackoverflow.com/a/12438316/1346705">my other answer</a> to support my statement.</p>
<p>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</p>
<p>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</p>
<p>Here is the example that proves that Python uses passing by reference:</p>
<p><img alt="Illustrated example of passing the argument" src="https://i.stack.imgur.com/uzXcP.png"/></p>
<p>If the argument was passed by value, the outer <code>lst</code> could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</p>
<p>You can use the <a href="http://docs.python.org/3.3/library/functions.html#id" rel="noreferrer"><code>id()</code></a> built-in function to learn what the reference value is (that is, the address of the target object).</p>
<p>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</p>
<p>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple trick I normally use is to just wrap it in a list:</p>
<pre><code>def Change(self, var):
    var[0] = 'Changed'

variable = ['Original']
self.Change(variable)      
print variable[0]
</code></pre>
<p>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</p>
</div>
<div class="post-text" itemprop="text">
<p>(edit - Blair has updated his enormously popular answer so that it is now accurate)</p>
<p>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</p>
<p>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</p>
<p>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a "value" or a "reference") must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</p>
<p>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</p>
</div>
<div class="post-text" itemprop="text">
<h1>There are no variables in Python</h1>
<p>The key to understanding parameter passing is to stop thinking about "variables". There are names and objects in Python and together they
appear like variables, but it is useful to always distinguish the three.</p>
<ol>
<li>Python has names and objects.</li>
<li>Assignment binds a name to an object.</li>
<li>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</li>
</ol>
<p>That is all there is to it. Mutability is irrelevant for this question.</p>
<p>Example: </p>
<pre><code>a = 1
</code></pre>
<p>This binds the name <code>a</code> to an object of type integer that holds the value 1.</p>
<pre><code>b = x
</code></pre>
<p>This binds the name <code>b</code> to the same object that the name <code>x</code> is currently bound to.
Afterwards, the name <code>b</code> has nothing to do with the name <code>x</code> any more.</p>
<p>See sections <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noreferrer">3.1</a> and <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding" rel="noreferrer">4.2</a> in the Python 3 language reference.</p>
<hr/>
<p>So in the code shown in the question, the statement <code>self.Change(self.variable)</code> binds the name <code>var</code> (in the scope of function <code>Change</code>) to the object that holds the value <code>'Original'</code> and the assignment <code>var = 'Changed'</code> (in the body of function <code>Change</code>) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</p>
</div>
<div class="post-text" itemprop="text">
<p>You got some really good answers here.</p>
<pre><code>x = [ 2, 4, 4, 5, 5 ]
print x  # 2, 4, 4, 5, 5

def go( li ) :
  li = [ 5, 6, 7, 8 ]  # re-assigning what li POINTS TO, does not
  # change the value of the ORIGINAL variable x

go( x ) 
print x  # 2, 4, 4, 5, 5  [ STILL! ]


raw_input( 'press any key to continue' )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this case the variable titled <code>var</code> in the method <code>Change</code> is assigned a reference to <code>self.variable</code>, and you immediately assign a string to <code>var</code>. It's no longer pointing to <code>self.variable</code>. The following code snippet shows what would happen if you modify the data structure pointed to by <code>var</code> and <code>self.variable</code>, in this case a list:</p>
<pre><code>&gt;&gt;&gt; class PassByReference:
...     def __init__(self):
...         self.variable = ['Original']
...         self.change(self.variable)
...         print self.variable
...         
...     def change(self, var):
...         var.append('Changed')
... 
&gt;&gt;&gt; q = PassByReference()
['Original', 'Changed']
&gt;&gt;&gt; 
</code></pre>
<p>I'm sure someone else could clarify this further.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python’s pass-by-assignment scheme isn’t quite the same as C++’s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</p>
<ul>
<li>Immutable arguments are effectively passed “<strong>by value</strong>.” Objects such as integers and strings are passed by object reference instead of by copying, but because you can’t change immutable objects in place anyhow, the effect is much like making a copy.</li>
<li>Mutable arguments are effectively passed “<strong>by pointer</strong>.” Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers—mutable objects can be changed in place in the function,
much like C arrays.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</p>
<p><a href="http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="noreferrer">http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a></p>
<p>example:</p>
<pre><code>&gt;&gt;&gt; def x(y):
...     global z
...     z = y
...

&gt;&gt;&gt; x
&lt;function x at 0x00000000020E1730&gt;
&gt;&gt;&gt; y
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'y' is not defined
&gt;&gt;&gt; z
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'z' is not defined

&gt;&gt;&gt; x(2)
&gt;&gt;&gt; x
&lt;function x at 0x00000000020E1730&gt;
&gt;&gt;&gt; y
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'y' is not defined
&gt;&gt;&gt; z
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation <a href="https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python" rel="noreferrer">https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a> </p>
<p>"In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function’s body, it’s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as ‘global’.
Though a bit surprising at first, a moment’s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you’d be using global all the time. You’d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects."</p>
<p>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</p>
<pre><code>def test(l):
    print "Received", l , id(l)
    l = [0, 0, 0]
    print "Changed to", l, id(l)  # New local object created, breaking link to global l

l= [1,2,3]
print "Original", l, id(l)
test(l)
print "After", l, id(l)
</code></pre>
<p>gives:</p>
<pre><code>Original [1, 2, 3] 4454645632
Received [1, 2, 3] 4454645632
Changed to [0, 0, 0] 4474591928
After [1, 2, 3] 4454645632
</code></pre>
<p>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is the simple (I hope) explanation of the concept <code>pass by object</code> used in Python.<br/>
Whenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</p>
<pre><code>def change_me(list):
   list = [1, 2, 3]

my_list = [0, 1]
change_me(my_list)
</code></pre>
<p>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function <code>change_me</code> will try to do something like:</p>
<pre><code>[0, 1] = [1, 2, 3]
</code></pre>
<p>which obviously will not change the object passed to the function. If the function looked like this:</p>
<pre><code>def change_me(list):
   list.append(2)
</code></pre>
<p>Then the call would result in:</p>
<pre><code>[0, 1].append(2)
</code></pre>
<p>which obviously will change the object. <a href="https://stackoverflow.com/a/534509/831531">This answer</a> explains it well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.Change()
        print self.variable

    def Change(self):
        self.variable = 'Changed'
</code></pre>
<p>In instance methods, you normally refer to <code>self</code> to access instance attributes. It is normal to set instance attributes in <code>__init__</code> and read or change them in instance methods. That is also why you pass <code>self</code> als the first argument to <code>def Change</code>.</p>
<p>Another solution would be to create a static method like this:</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.variable = PassByReference.Change(self.variable)
        print self.variable

    @staticmethod
    def Change(var):
        var = 'Changed'
        return var
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</p>
<pre><code>class PassByReference:
    def __init__(self, name):
        self.name = name

def changeRef(ref):
    ref[0] = PassByReference('Michael')

obj = PassByReference('Peter')
print obj.name

p = [obj] # A pointer to obj! ;-)
changeRef(p)

print p[0].name # p-&gt;name
</code></pre>
<p>It's an ugly hack, but it works. ;-P</p>
</div>
<div class="post-text" itemprop="text">
<p>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</p>
<pre><code>a=0
b=0
c=0
def myfunc(a,b,c):
    a=1
    b=2
    c=3
    return a,b,c

a,b,c = myfunc(a,b,c)
print a,b,c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</p>
<p>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</p>
<p>One way is to use <code>global</code> (for global variables) or <code>nonlocal</code> (for local variables in a function) in a wrapper function.</p>
<pre><code>def change(wrapper):
    wrapper(7)

x = 5
def setter(val):
    global x
    x = val
print(x)
</code></pre>
<p>The same idea works for reading and <code>del</code>eting a variable.</p>
<p>For just reading there is even a shorter way of just using <code>lambda: x</code> which returns a callable that when called returns the current value of x. This is somewhat like "call by name" used in languages in the distant past.</p>
<p>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</p>
<pre><code>class ByRef:
    def __init__(self, r, w, d):
        self._read = r
        self._write = w
        self._delete = d
    def set(self, val):
        self._write(val)
    def get(self):
        return self._read()
    def remove(self):
        self._delete()
    wrapped = property(get, set, remove)

# left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal
r = ByRef(get, set, remove)
r.wrapped = 15
</code></pre>
<p>Pythons "reflection" support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</p>
<pre><code>class ByRef:
    def __init__(self, locs, name):
        self._locs = locs
        self._name = name
    def set(self, val):
        self._locs[self._name] = val
    def get(self):
        return self._locs[self._name]
    def remove(self):
        del self._locs[self._name]
    wrapped = property(get, set, remove)

def change(x):
    x.wrapped = 7

def test_me():
    x = 6
    print(x)
    change(ByRef(locals(), "x"))
    print(x)
</code></pre>
<p>Here the <code>ByRef</code> class wraps a dictionary access. So attribute access to <code>wrapped</code> is translated to a item access in the passed dictionary. By passing the result of the builtin <code>locals</code> and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</p>
<pre><code>class PassByReferenceIsh:
    def __init__(self):
        self.variable = 'Original'
        self.change('variable')
        print self.variable

    def change(self, var):
        self.__dict__[var] = 'Changed'
</code></pre>
<p>in real code you would, of course, add error checking on the dict lookup.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</p>
<pre><code>class PassByReference:
    def __init__(self):
        self.variable = 'Original'
        self.change('variable')
        print(self.variable)

    def change(self, var):
        setattr(self, var, 'Changed')

# o.variable will equal 'Changed'
o = PassByReference()
assert o.variable == 'Changed'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. </p>
<ul>
<li><strong>Java:</strong> Everything is passed by reference so all changes made in the parameter in the called function are visible to the caller.</li>
<li><strong>C++:</strong> Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</li>
<li><strong>Python:</strong> 
Python is “pass-by-object-reference”, of which it is often said: “Object references are passed by value.”[Read here]<a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="nofollow noreferrer">1</a>. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can merely use <strong>an empty class</strong> as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</p>
<pre><code>class RefsObj(object):
    "A class which helps to create references to variables."
    pass

...

# an example of usage
def change_ref_var(ref_obj):
    ref_obj.val = 24

ref_obj = RefsObj()
ref_obj.val = 1
print(ref_obj.val) # or print ref_obj.val for python2
change_ref_var(ref_obj)
print(ref_obj.val)
</code></pre>
</div>
<span class="comment-copy">For a short explanation/clarification see the first answer to <a href="http://stackoverflow.com/questions/534375/passing-values-in-python">this stackoverflow question</a>. As strings are immutable, they won't be changed and a new variable will be created, thus the "outer" variable still has the same value.</span>
<span class="comment-copy">The code in BlairConrad's answer is good, but the explanation provided by DavidCournapeau and DarenThomas is correct.</span>
<span class="comment-copy">Before reading the selected answer, please consider reading this short text <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Other languages have "variables", Python has "names"</a>. Think about "names" and "objects" instead of "variables" and "references" and you should avoid a lot of similar problems.</span>
<span class="comment-copy">Why does this needlessly use a class? This isn't Java :P</span>
<span class="comment-copy">another workaround is to create a wrapper 'reference' like this: ref = type('', (), {'n':1}) <a href="http://stackoverflow.com/a/1123054/409638">stackoverflow.com/a/1123054/409638</a></span>
<span class="comment-copy">Then the same is in C, when you pass "by reference" you're actually passing <i>by value</i> the reference... Define "by reference" :P</span>
<span class="comment-copy">I'm not sure I understand your terms. I've been out of the C game for a while, but back when I was in it, there was no "pass by reference" - you could pass things, and it was always pass by value, so whatever was in the parameter list was copied. But sometimes the thing was a pointer, which one could follow to the piece of memory (primitive, array, struct, whatever), but you couldn't change the pointer that was copied from the outer scope - when you were done with the function, the original pointer still pointed to the same address. C++ introduced references, which behaved differently.</span>
<span class="comment-copy">@Zac Bowling I don't really get how what you're saying is relevant, in a practical sense, to this answer. If a Python newcomer wanted to know about passing by ref/val, then the takeaway from this answer is: <b>1-</b> You <i>can</i> use the reference that a function receives as its arguments, to modify the 'outside' value of a variable, as long as you don't reassign the parameter to refer to a new object. <b>2-</b> Assigning to an immutable type will <i>always</i> create a new object, which breaks the reference that you had to the outside variable.</span>
<span class="comment-copy">@CamJackson, you need a better example - numbers are also immutable objects in Python. Besides, wouldn't it be true to say that <i>any</i> assignment without subscripting on the left side of the equals will reassign the name to a new object whether it is immutable or not? <code>def Foo(alist): alist = [1,2,3]</code> will <b>not</b> modify the contents of the list from the callers perspective.</span>
<span class="comment-copy">-1. The code shown is good, the explanation as to how is completely wrong.  See the answers by DavidCournapeau or DarenThomas for correct explanations as to why.</span>
<span class="comment-copy">Good succinct explanation. Your paragraph "When you call a function..." is one of the best explanations I've heard of the rather cryptic phrase that 'Python function parameters are references, passed by value.' I think if you understand that paragraph alone, everything else kind of just makes sense and flows as a logical conclusion from there. Then you just have to be aware of when you're creating a new object and when you're modifying an existing one.</span>
<span class="comment-copy">But how can you reassign the reference? I thought you can't change the address of 'var' but that your string "Changed" was now going to be stored in the 'var' memory address. Your description makes it seem like "Changed" and "Original" belong to different places in memory instead and you just switch 'var' to a different address. Is that correct?</span>
<span class="comment-copy">@Glassjawed, I think you're getting it. "Changed" and "Original" are two different string objects at different memory addresses and 'var' changes from pointing to one to pointing to the other.</span>
<span class="comment-copy">this is the best explanation and should be the accepted answer. Short, concise and clear. Others coin new, confusing terms like 'reference is passed by value', 'call be object', etc. This answer clears everything. Thanks :)</span>
<span class="comment-copy">@MinhTran in the simplest terms, a reference is something that "refers" to an object. The physical representation of that is most likely a pointer, but that's simply an implementation detail. It really is an abstract notion at heart.</span>
<span class="comment-copy">Your diagram elucidates the underlying concept well although I wouldn't call other answers <b>long and complicated</b>.</span>
<span class="comment-copy">A very elegant explanation. I think the other answers are long and complicated as well. Good job!</span>
<span class="comment-copy">It doesn't matter if A is mutable or not. If you assign something different to B, <i>A doesn't change</i>. If an object is mutable, you can mutate it, sure. But that has nothing to do with assignment directly to a name..</span>
<span class="comment-copy">Thanks for the update, much better! What confuses most people is assignment to a subscription; e.g. <code>B[0] = 2</code>, vs. direct assignment, <code>B = 2</code>.</span>
<span class="comment-copy">"A is assigned to B." Is that not ambiguous? I think in ordinary English that can mean either <code>A=B</code> or <code>B=A</code>.</span>
<span class="comment-copy">I find it hard to buy. To me is just as Java, the parameters are pointers to objects in memory, and those pointers are passed via the stack, or registers.</span>
<span class="comment-copy">This is not like java. One of the case where it is not the same is immutable objects. Think about the trivial function lambda x: x. Apply this for x = [1, 2, 3] and x = (1, 2, 3). In the first case, the returned value will be a copy of the input, and identical in the second case.</span>
<span class="comment-copy">No, it's <i>exactly</i> like Java's semantics for objects. I'm not sure what you mean by "In the first case, the returned value will be a copy of the input, and identical in the second case." but that statement seems to be plainly incorrect.</span>
<span class="comment-copy">It is exactly the same as in Java. Object references are passed by value. Anyone who thinks differently should attach the Python code for a <code>swap</code> function that can swap two references, like this:  <code>a = [42] ; b = 'Hello'; swap(a, b) # Now a is 'Hello', b is [42]</code></span>
<span class="comment-copy">It is exactly the same as Java when you pass objects in Java. However, Java also have primitives, which are passed by copying the value of the primitive. Thus they differ in that case.</span>
<span class="comment-copy">At first glance this answer seems to sidestep the original question. After a second read I've come to realize that this makes the matter quite clear. A good follow up to this "name assignment" concept may be found  here: <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables" rel="nofollow noreferrer">Code Like a Pythonista: Idiomatic Python</a></span>
<span class="comment-copy">I really appreciate learning about this from a developer. Is it true that the <code>id()</code> function returns the pointer's (object reference's) value, as pepr's answer suggests?</span>
<span class="comment-copy">@HonestAbe Yes, in CPython the <i>id()</i> returns the address.  But in other pythons such as PyPy and Jython, the <i>id()</i> is just a unique object identifier.</span>
<span class="comment-copy">this answer, plus the hint to use id() which shows when an assignment binds an existing name to a new object, is the best in the entire thread.</span>
<span class="comment-copy">Actually this is confirmed its pass by reference value. +1 for this answer although the example wasnt good.</span>
<span class="comment-copy">Inventing new terminology (such as "pass by reference value" or "call by object" is not helpful). "Call by (value|reference|name)" are standard terms. "reference" is a standard term. Passing references by value accurately describes the behavior of Python, Java, and a host of other languages, using standard terminology.</span>
<span class="comment-copy">@cayhorstmann: The problem is that <i>Python variable</i> has not the same terminology meaning as in other languages. This way, <i>call by reference</i> does not fit well here. Also, how do you <i>exactly</i> define the term <i>reference</i>? Informally, the Python way could be easily described as passing the address of the object. But it does not fit with a potentially distributed implementation of Python.</span>
<span class="comment-copy">I like this answer, but you might consider if the example is really helping or hurting the flow. Also, if you replaced 'reference value' with 'object reference' you would be using terminology that we could consider 'official', as seen here: <a href="http://docs.python.org/3.3/tutorial/controlflow.html#defining-functions" rel="nofollow noreferrer">Defining Functions</a></span>
<span class="comment-copy">There is a footnote indicated at the end of that quote, which reads: <i>"Actually, <b>call by object reference</b> would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it..."</i> I agree with you that confusion is caused by trying to fit terminology established with other languages. Semantics aside, the things that need to be understood are: dictionaries / namespaces, <a href="http://docs.python.org/3.3/reference/executionmodel.html" rel="nofollow noreferrer">name binding operations</a> and the relationship of name→pointer→object (as you already know).</span>
<span class="comment-copy">+1 for small amount of text giving the essential workaround to the problem of Python not having pass-by-reference. (As a follow-on comment/question that fits here as well as anywhere on this page: It's not clear to my why python can't provide a "ref" keyword like C# does, that simply wraps the caller's argument in a list like this, and treat references to the argument within the function as the 0th element of the list.)</span>
<span class="comment-copy">Nice. To pass by ref, wrap in [ ]'s.</span>
<span class="comment-copy">It is simply not true that all languages are call by value. In C++ or Pascal (and surely many others that I don't know), you have call by reference. For example, in C++, <code>void swap(int&amp; x, int&amp; y) { int temp = x; x = y; y = temp; }</code> will swap the variables passed to it. In Pascal, you use <code>var</code> instead of <code>&amp;</code>.</span>
<span class="comment-copy">I thought I had replied to this long ago but I don't see it. For completeness - cayhorstmann misunderstood my answer. I was not saying everything is call by value <i>in the terms that most people first learn regarding C / C++</i>. It was simply that <i>some</i> value is passed (value, name, pointer, etc.) and that the terms used in Blair's original answer were inaccurate.</span>
<span class="comment-copy">"Python has no variables" is a silly and confusing slogan, and I really wish people would stop saying it... :(   The rest of this answer is good!</span>
<span class="comment-copy">It may be shocking, but it is not silly. And I don't think it is confusing either: It hopefully opens up the recipient's mind for the explanation that is coming and puts her in a useful "I wonder what they have instead of variables" attitude. (Yes, your mileage may vary.)</span>
<span class="comment-copy">would you also say that Javascript has no variables? They work the same as Python's.  Also, Java, Ruby, PHP, ....   I think a better teaching technique is, "Python's variables work differently than C's."</span>
<span class="comment-copy">Yes, Java has variables. So does Python, and JavaScript, Ruby, PHP, etc.  You wouldn't say in Java that <code>int</code> declares a variable, but <code>Integer</code> does not.  They both declare variables.  The <code>Integer</code> variable is an object, the <code>int</code> variable is a primitive.  As an example, you demonstrated how your variables work by showing <code>a = 1; b = a; a++ # doesn't modify b</code>.  That's exactly true in Python also (using <code>+= 1</code> since there is no <code>++</code> in Python)!</span>
<span class="comment-copy">I really don't see how this answer could be helpful in light of the question. No solution is given, only the status quo of python is recited. How can you pass an argument, so that it can be changed? Most of the answers here don't give a solution. But this one, denies the existence of the obvious in the first lines, so it stands out of the pack. Sorry for the downvote, but it just made me a bit mad.</span>
<span class="comment-copy">yea, however if you do   x = [ 2, 4, 4, 5, 5],  y = x,  X[0] = 1 , print x # [1, 4 ,4, 5, 5]  print y # [1, 4, 4, 5, 5]</span>
<span class="comment-copy">I was tempted to post a similar response- the original questioner may not have known that what he wanted was in fact to use a global variable, shared among functions. Here's the link I would have shared: <a href="http://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them" title="using global variables in a function other than the one that created them">stackoverflow.com/questions/423379/…</a>  In answer to @Tim, Stack Overflow is not only a question and answer site, it's a vast repository of reference knowledge that only gets stronger and more nuanced- much like an active wiki- with more input.</span>
<span class="comment-copy">The problem is that the assignment does something else than you expect. The <code>list = [1, 2, 3]</code> causes reusing the <code>list</code> name for something else and forgeting the originally passed object. However, you can try <code>list[:] = [1, 2, 3]</code> (by the way <code>list</code> is wrong name for a variable. Thinking about <code>[0, 1] = [1, 2, 3]</code> is a complete nonsense. Anyway, what do you think means <i>the object itself is passed</i>? What is copied to the function in your opinion?</span>
<span class="comment-copy">@pepr objects aren't literals. They are objects. The only way to talk about them is giving them some names. That's why it's so simple once you grasp it, but enormously complicated to explain. :-)</span>
<span class="comment-copy">@Veky: I am aware of that. Anyway, the list literal is converted to the list object. Actually, any object in Python can exist without a name, and it can be used even when not given any name. And you can think about them as about anonymous objects. Think about objects being the elements of a lists. They need not a name. You can access them through indexing of or iterating through the list. Anyway, I insist on <code>[0, 1] = [1, 2, 3]</code> is simply a bad example. There is nothing like that in Python.</span>
<span class="comment-copy">@pepr: I don't necessarily mean Python-definition names, just ordinary names. Of course <code>alist[2]</code> counts as a name of a third element of alist. But I think I misunderstood what your problem was. :-)</span>
<span class="comment-copy">Argh. My English is obviously much worse than my Python. :-) I'll try just once more. I just said you have to give object some names just to talk about them. By that "names" I didn't mean "names as defined by Python". I know Python mechanisms, don't worry.</span>
<span class="comment-copy"><code>p</code> is reference to a mutable list object which in turn stores the object <code>obj</code>. The reference 'p', gets passed into <code>changeRef</code>. Inside <code>changeRef</code>, a new reference is created (the new reference is called <code>ref</code>) that points to the same list object that <code>p</code> points to. But because lists are mutable, changes to the list are visible by <i>both</i> references. In this case, you used the <code>ref</code> reference to change the object at index 0 so that it subsequently stores the <code>PassByReference('Michael')</code> object. The change  to the list object was done using <code>ref</code> but this change is visible to <code>p</code>.</span>
<span class="comment-copy">So now, the references <code>p</code> and <code>ref</code> point to a list object that stores the single object, <code>PassByReference('Michael')</code>. So it follows that <code>p[0].name</code> returns <code>Michael</code>. Of course, <code>ref</code> has now gone out of scope and may be garbage collected but all the same.</span>
<span class="comment-copy">You have <i>not</i> changed the private instance variable, <code>name</code>, of the original <code>PassByReference</code> object associated with the reference <code>obj</code>, though. In fact, <code>obj.name</code> will return <code>Peter</code>. The aforementioned comments assumes the definition <code>Mark Ransom</code> gave.</span>
<span class="comment-copy">Point being, I don't agree that it's a <i>hack</i> (which I take to mean to refer to something that works but for reasons unknown, untested, or unintended by the implementer). You simply replaced one <code>PassByReference</code> object with another <code>PassByReference</code> object in your list and referred to the latter of the two objects.</span>
<span class="comment-copy">Although this works. It is not pass by reference. It is 'pass by object reference'.</span>
