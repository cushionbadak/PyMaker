<div class="post-text" itemprop="text">
<p>How can a <code>int</code> be cast to an <code>enum</code> in python?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want the flexibility to convert between <code>int</code> and an enum, you can use <a href="https://docs.python.org/3/library/enum.html#intenum" rel="nofollow"><code>enum.IntEnum</code></a></p>
<pre><code>import enum

class Color(enum.IntEnum):
    green = 1
    blue = 2
    red = 3
    yellow = 4

color_code = 4
# cast to enum
color = Color(color_code)

# cast back to int
color_code = int(color)
</code></pre>
<p><em>Note: If you are using python&lt;3.4, <code>enum</code> has been backported, but you will need to install it, e.g. via <code>pip install enum</code></em></p>
<p>More on enums in python - <a href="https://docs.python.org/3/library/enum.html" rel="nofollow">https://docs.python.org/3/library/enum.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the built-in <code>Enum</code> (Python 3.4+), the <a href="https://pypi.python.org/pypi/enum34" rel="nofollow"><code>enum34</code></a>  backport, or, for more advanced needs (which this is not), the new <a href="https://pypi.python.org/pypi/aenum" rel="nofollow"><code>aenum</code></a> library.</p>
<p>If you use <code>IntEnum</code>:</p>
<pre><code>class RGB(IntEnum):
    red = 1
    green = 2
    blue = 3
</code></pre>
<p>If you have an <code>int</code> and want the matching <code>Enum</code> member:</p>
<pre><code>&gt;&gt;&gt; c = 2
&gt;&gt;&gt; c = RGB(c)
&gt;&gt;&gt; c
&lt;RGB.green: 2&gt;
</code></pre>
<p>Once you have an <code>IntEnum</code> member, it is already an <code>int</code>:</p>
<pre><code>&gt;&gt;&gt; type(c)
&lt;enum 'RGB'&gt;
&gt;&gt;&gt; isinstance(c, int)
True
</code></pre>
<p>The downside to <code>IntEnum</code> is that every <code>IntEnum</code> member will compare equal to every other <code>IntEnum</code> member that has the same value:</p>
<pre><code>class Fruit(IntEnum):
    banana = 1

&gt;&gt;&gt; Fruit.banana == Color.red
True
</code></pre>
<p>If you want to keep your <code>Enum</code>s separate, but don't want to lose the <code>int</code>ability of an <code>IntEnum</code> you could do:</p>
<pre><code>class RGB(Enum):
    red = 1
    green = 2
    blue = 3
    def __int__(self):
        return self.value
</code></pre>
<p>Lookup works the same:</p>
<pre><code>&gt;&gt;&gt; c = 2
&gt;&gt;&gt; c = RGB(c)
&gt;&gt;&gt; c
&lt;RGB.green: 2&gt;
</code></pre>
<p>But members are no longer <code>int</code>s:</p>
<pre><code>&gt;&gt;&gt; type(c)
&lt;enum 'RGB'&gt;
&gt;&gt;&gt; isinstance(c, int)
False
</code></pre>
<p>So you do have to cast it (or access the <code>value</code> attribute):</p>
<pre><code>&gt;&gt;&gt; int(c)
2
&gt;&gt;&gt; c.value
2
</code></pre>
<p>And we no longer have the problem if <code>Fruit.banana</code> being equal to <code>RGB.red</code>:</p>
<pre><code>&gt;&gt;&gt; Fruit(1) == RGB(1)
False
</code></pre>
<hr/>
<p>If you are using Python 3+ there are some cool things you can do with <code>aenum</code>, such as:</p>
<pre><code>import aenum

class RGB(aenum.Enum, start=1):
    red
    green
    blue
    def __int__(self):
        return self.value
</code></pre>
<p>which results in the same class as the last <code>Enum</code> example.</p>
</div>
<span class="comment-copy">there are no enums in stdlib on Python 2. Or do you mean you have C code that accept a enum and you want to call from Python?</span>
<span class="comment-copy">@J.F.Sebastian Well, that would be the case in some situations.</span>
