<div class="post-text" itemprop="text">
<p>I have a program that returns a set of domains with ranks like so:</p>
<pre><code>ranks = [
    {'url': 'example.com', 'rank': '11,279'},
    {'url': 'facebook.com', 'rank': '2'},
    {'url': 'google.com', 'rank': '1'}
]
</code></pre>
<p>I'm trying to sort them by ascending rank with <code>sorted</code>:</p>
<pre><code>results = sorted(ranks,key=itemgetter("rank"))
</code></pre>
<p>However, since the values of "rank" are strings, then it sorts them alphanumerically instead of by ascending value:</p>
<pre><code>1. google.com: 1

2. example.com: 11,279

3. facebook.com: 2
</code></pre>
<p>I need to convert the values of only the "rank" key to integers so that they'll sort correctly. Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are almost there. You need to convert the picked values to integers after replacing <code>,</code>, like this</p>
<pre><code>results = sorted(ranks, key=lambda x: int(x["rank"].replace(",", "")))
</code></pre>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; ranks = [
...     {'url': 'example.com', 'rank': '11,279'},
...     {'url': 'facebook.com', 'rank': '2'},
...     {'url': 'google.com', 'rank': '1'}
... ]
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(sorted(ranks, key=lambda x: int(x["rank"].replace(",", ""))))
[{'rank': '1', 'url': 'google.com'},
 {'rank': '2', 'url': 'facebook.com'},
 {'rank': '11,279', 'url': 'example.com'}]
</code></pre>
<p><strong>Note:</strong> I just used <code>pprint</code> function to pretty print the result.</p>
<p>Here, <code>x</code> will be the current object for which the <code>key</code> value being determined. We get the value of <code>rank</code> attribute from it, replace <code>,</code> with empty string and then converted that to a number with <code>int</code>.</p>
<hr/>
<p>If you don't want to replace <code>,</code> and handle it properly, then you can use <a href="https://docs.python.org/3/library/locale.html#locale.atoi"><code>locale</code> module's <code>atoi</code> function</a>, like this</p>
<pre><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; pprint(sorted(ranks, key=lambda x: int(locale.atoi(x["rank"]))))
[{'rank': '1', 'url': 'google.com'},
 {'rank': '2', 'url': 'facebook.com'},
 {'rank': '11,279', 'url': 'example.com'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just want to point out that the data structure could potentially be improved here. You have a list of mini-dictionaries but it seems like you could have a single dictionary since "rank" and "url" are implicit. Use each unique url as a key and each rank for that url as a value or count, which would take better advantage of the dictionary's capabilities IMHO. If you are getting the current data structure as an output from somewhere else, you can easily compress it into a more efficient counter dictionary with the conversion to integer ranks as values using the <code>dict()</code> function:</p>
<pre><code>&gt;&gt;&gt; ranks
[{'url': 'example.com', 'rank': '11,279'}, {'url': 'facebook.com', 'rank': '2'}, {'url': 'google.com', 'rank': '1'}]
&gt;&gt;&gt; compressed = dict([(x['url'], int(x['rank'].replace(',', ''))) for x in ranks])
&gt;&gt;&gt; compressed
{'facebook.com': 2, 'google.com': 1, 'example.com': 11279}
</code></pre>
<p>If you are going to have a lot of data this will be more compact and it is more intuitive to work with. You can use this easily for things like nice print outs based on ranks:</p>
<pre><code>&gt;&gt;&gt; print ''.join(['{k:&gt;12}: {v:,}\n'.format(k=item[0], v=item[1]) for item in sorted(compressed.items(), key=lambda i: i[1])])
  google.com: 1
facebook.com: 2
 example.com: 11,279
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>x=[{'url': 'example.com', 'rank': '11,279'}, {'url': 'facebook.com', 'rank': '2'}, {'url': 'google.com', 'rank': '1'},{'url': 'google.com', 'rank': '11,280'},{'url': 'google.com', 'rank': '12'}]

results = sorted(x,key=lambda k:ast.literal_eval(k.get("rank").replace(",","")))
print [i for i in results]
</code></pre>
<p>Guess you should use <code>ast.literal.eval</code> and then compare to be precise and accurate.</p>
<p>Output:<code>[{'url': 'google.com', 'rank': '1'}, {'url': 'facebook.com', 'rank': '2'}, {'url': 'example.com', 'rank': '11,279'}, {'url': 'google.com', 'rank': '11,280'}, {'url': 'google.com', 'rank': '12'}]
</code></p>
</div>
<span class="comment-copy">If you may create the dictionary yourself, prefer integers instead of strings.</span>
<span class="comment-copy">I have an additional question: since the OP is actually asking to convert the values into <code>int</code> only so he can sort them properly, then his issue is with the sorting I guess, and not with the type. Couldn't he sort the values after replacing <code>,</code> and expect the same result, without casting them into ints?</span>
<span class="comment-copy">@tomasyany: yes, but that sort would be lexicographic, not numerical, and <code>'11'  &lt; '9'</code> even though <code>11 &gt; 9</code>.</span>
<span class="comment-copy">Using <code>locale.atoi</code> as above I get <code>ValueError: invalid literal for int() with base 10: '11,279'</code></span>
<span class="comment-copy">@RolfofSaxony: is that because the thousands separator in Saxony is <code>"."</code>? (Actually that's probably not the reason even if it's true: it's because there's no THOUSEP in the default locale. But anyway, using locale-specific functions to parse data that isn't in a locale-specific format is a world of trouble)</span>
<span class="comment-copy">That worked perfectly. Thanks so much. :)</span>
<span class="comment-copy">Doesn't this turn 11279 into 11.279 I know that the usage of point and comma within numbers differs from country to country and that could be a problem</span>
<span class="comment-copy">@RolfofSaxony yeah right!!!! edited!thanx :)</span>
