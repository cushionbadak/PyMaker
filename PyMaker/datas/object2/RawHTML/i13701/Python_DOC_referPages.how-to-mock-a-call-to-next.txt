<div class="post-text" itemprop="text">
<p>I am trying to mock a coroutine. As such, this mock's <code>__next__()</code> and <code>close()</code> are called. While mocking <code>close()</code> works, I cannot mock <code>__next__()</code>:</p>
<pre><code>    mock_coroutine = mock.Mock()
    mock_coroutine.some_call(1, 2, 3)
    mock_coroutine.some_call.assert_called_with(1, 2, 3)
    mock_coroutine.close()
    mock_coroutine.close.assert_called_with()
    #this fails
    mock_coroutine.__next__()
    mock_coroutine.__next__.assert_called_with()
</code></pre>
<p>What am I missing? How to make sure my mock's <code>__next__()</code> method is called?</p>
<p>For now, I am using the following:</p>
<pre><code>class MockCoroutine:
    def __next__(self):
        self.called_next = True

    def close(self):
        self.called_exit = True
</code></pre>
<p>However, I very much rather use a standard mock.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <code>MagicMock</code>, not <code>Mock</code>, to have magic methods like <code>__next__</code> available by default:</p>
<pre><code>&gt;&gt;&gt; from unittest import mock
&gt;&gt;&gt; mock_coroutine = mock.MagicMock()
&gt;&gt;&gt; mock_coroutine.__next__()
&lt;MagicMock name='mock.__next__()' id='4464126552'&gt;
&gt;&gt;&gt; mock_coroutine.__next__.assert_called_with()
</code></pre>
<p>Quoting from <a href="https://docs.python.org/3/library/unittest.mock.html#quick-guide" rel="nofollow">the documentation</a>:</p>
<blockquote>
<p><code>Mock</code> allows you to assign functions (or other <code>Mock</code> instances) to magic methods and they will be called appropriately. The <code>MagicMock</code> class is just a <code>Mock</code> variant that has all of the magic methods pre-created for you (well, all the useful ones anyway).</p>
</blockquote>
<p>So, alternatively, you could still use the regular <code>Mock</code> object, but then you need to explicitly add that attribute:</p>
<pre><code>&gt;&gt;&gt; mock_coroutine = mock.Mock()
&gt;&gt;&gt; mock_coroutine.__next__ = mock.Mock()
&gt;&gt;&gt; mock_coroutine.__next__()
&lt;Mock name='mock.__next__()' id='4464139232'&gt;
</code></pre>
<p>That's because although <code>Mock</code> creates attributes on the fly as you access them, any attributes with leading and trailing underscores are explicitly exempted from that. See <a href="https://docs.python.org/3/library/unittest.mock.html#id3" rel="nofollow">this footnote</a>:</p>
<blockquote>
<p>The only exceptions are magic methods and attributes (those that have leading and trailing double underscores). Mock doesnâ€™t create these but instead raises an <code>AttributeError</code>. This is because the interpreter will often implicitly request these methods, and gets very confused to get a new Mock object when it expects a magic method. If you need magic method support see <a href="https://docs.python.org/3/library/unittest.mock.html#magic-methods" rel="nofollow">magic methods</a>.</p>
</blockquote>
<p>But note that the magic methods are usually meant to be looked up <em>on the class, not the instance</em>, so directly adding the <code>__next__</code> attribute to a <code>Mock</code> instance can still fail; the <code>MagicMock</code> class takes care of this specific issue for you.</p>
</div>
<span class="comment-copy">This works. Tanks a lot!</span>
