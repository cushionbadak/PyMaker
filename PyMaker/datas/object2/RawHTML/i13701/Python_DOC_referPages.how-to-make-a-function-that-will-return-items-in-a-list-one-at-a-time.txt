<div class="post-text" itemprop="text">
<p>I am trying to make my function return items in a list one by one each time the function is called. I have this code:</p>
<pre><code>def abc():
    ls = ['a', 'b', 'c']

    for i in ls:
        ls.append(i)
        yield i
</code></pre>
<p>I can type something like this on the terminal and keep pressing <code>next()</code> to get the next item in the list. </p>
<pre><code>    &gt;&gt;&gt;ab = abc()
    &gt;&gt;&gt;next(ab)
    'a'
    &gt;&gt;&gt;next(ab)
    'b'
    &gt;&gt;&gt;next(ab)
    'c'
    &gt;&gt;&gt;next(ab)
    'a'
    &gt;&gt;&gt;next(ab)
    'b'
</code></pre>
<p>And it should go on forever every time next is called. Instead of repeatedly typing <code>next(ab)</code> in the terminal, I want to make my function do all that (return the next item in the list) every time the function <code>abc()</code> is called.</p>
</div>
<div class="post-text" itemprop="text">
<p>Basically you're looking for a closure function:</p>
<pre><code>def func():
    seq = ['a', 'b', 'c']
    ind = [-1]
    def inner():
        ind[0] += 1   
        return seq[ind[0]%len(seq)]

    return inner

&gt;&gt;&gt; f = func() # One call is still required after that the
               # returned inner function can maintain the state.
&gt;&gt;&gt; f()
'a'
&gt;&gt;&gt; f()
'b'
&gt;&gt;&gt; f()
'c'
&gt;&gt;&gt; f()
'a'
</code></pre>
<p>In Python 3 instead of defining <code>ind</code> as a list we can use <code>nonlocal</code> keyword.</p>
<p>Or using <a href="https://docs.python.org/2/library/itertools.html#itertools.cycle" rel="nofollow"><code>itertools.cycle</code></a>:</p>
<pre><code>from itertools import cycle

def func(seq):
    return cycle(seq).next
...
&gt;&gt;&gt; f = func('abc')
&gt;&gt;&gt; f()
'a'
&gt;&gt;&gt; f()
'b'
&gt;&gt;&gt; f()
'c'
&gt;&gt;&gt; f()
'a'
&gt;&gt;&gt; f()
'b'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need a <code>queue</code>.</p>
<p>Every time a function call happens</p>
<pre><code>x=[1,2,3]
k= x.pop(0)
x.append(k)
return k
</code></pre>
<p>This will get you the desired behavior.</p>
<p>EDIT:</p>
<pre><code>ls = ['a', 'b', 'c']
def abc():

    k= ls.pop(0)
    ls.append(k)
    return k

print abc()
print abc()
print abc()
print abc()
print abc()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The function you have uses increasing amounts of memory because it appends to the list for each iteration.  An improvement is to maintain an index:</p>
<pre><code>def abc():
    ls = ['a', 'b', 'c']

    i = 0;
    while True:
        yield ls[i]
        i = (i+1) % len(ls)
</code></pre>
<p>What you have is exactly what you need.  It is a <em>generator</em>.  Normally you would not call <code>next()</code> directly.  Normally you would use a loop to process the values produced by your generator:</p>
<pre><code>for thing in abc():
    print(thing)
</code></pre>
<p>Since your generator never throws a <code>StopIteration</code> exception, the for loop will never end.</p>
</div>
<div class="post-text" itemprop="text">
<p>This calls for creating a higher order function that will use closure to create a secondary function to do what you want.</p>
<pre><code>def create_wrapper(func):
    iter = func()
    def wrapper():
        return next(iter)
    return wrapper

ab = create_wrapper(abc)
ab()
&gt;&gt;&gt; 'a'
ab()
&gt;&gt;&gt; 'b'
</code></pre>
<p>And so on.</p>
<p>Here is a quick intro to higher order functions and closures in the context of the above code -</p>
<p>In the above code, func is actually a function reference, note how we call create_wrapper(abc) without the parens after abc, so it is not actually executing abc(). Then we create an iter object and create a child function called wrapper. We refer to the iter object in the child function even though it is defined in the parent function. This usage is called closure. When we return the function reference to wrapper, create_wrapper goes out of scope and so should any variables used inside it - including iter. But because it is being referenced in the child function, which lives on beyond its parent, iter is preserved.</p>
<p>BTW - the way you create an infinite iterator by appending to the list is pretty clever :-) but it obviously runs the danger of a memory overflow. There are other ways to create infinite iterators. Check out <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow">https://docs.python.org/3/library/itertools.html</a>.</p>
</div>
<span class="comment-copy">Have a second function which calls next.</span>
<span class="comment-copy">Why do you want to do this?</span>
<span class="comment-copy">Your code is going to keep building and buliding a list, requiring ever more memory as it goes along. Obviously this will be problematic with extended usage. Have you looked instead at <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer">itertools.repeat</a>?</span>
<span class="comment-copy">@Two-BitAlchemist: I think <code>itertools.cycle</code> is closer to what the OP is after.</span>
<span class="comment-copy">@DSM Duh, of course. The one for iterables not scalars. I stand corrected.</span>
<span class="comment-copy">This at least works around the memory issue I raised in my comment.</span>
<span class="comment-copy">@vks Where do I add the code you posted to get my desired behavior of the function?</span>
<span class="comment-copy">@vks It works now !</span>
<span class="comment-copy">@mashgreat didn't this work ?</span>
<span class="comment-copy">I tried what you said but when I run the whole file in terminal it keeps on going forever. How do I make the function stop and store state after each time the whole file is called or the whole function is called?</span>
<span class="comment-copy">You asked to have it go on forever, so it does (and that's what I noted in my answer). The function does stop and store state, but then the loop causes it to resume because that is what is supposed to happen. The <code>yield</code> statement is what makes the function stop and store state.</span>
