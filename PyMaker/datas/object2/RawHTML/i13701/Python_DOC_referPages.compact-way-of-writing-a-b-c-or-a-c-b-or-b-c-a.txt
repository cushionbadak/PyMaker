<div class="post-text" itemprop="text">
<p>Is there a more compact or pythonic way to write the boolean expression</p>
<pre><code>a + b == c or a + c == b or b + c == a
</code></pre>
<p>I came up with </p>
<pre><code>a + b + c in (2*a, 2*b, 2*c)
</code></pre>
<p>but that is a little strange.</p>
</div>
<div class="post-text" itemprop="text">
<p>If we look at the Zen of Python, emphasis mine:</p>
<blockquote>
<p>The Zen of Python, by Tim Peters</p>
<p>Beautiful is better than ugly.<br/>
  Explicit is better than implicit.<br/>
<strong>Simple is better than complex.</strong><br/>
  Complex is better than complicated.<br/>
  Flat is better than nested.<br/>
  Sparse is better than dense.<br/>
<strong>Readability counts.</strong><br/>
  Special cases aren't special enough to break the rules.<br/>
  Although practicality beats purity.<br/>
  Errors should never pass silently.<br/>
  Unless explicitly silenced.<br/>
  In the face of ambiguity, refuse the temptation to guess.<br/>
<strong>There should be one-- and preferably only one --obvious way to do it.</strong><br/>
  Although that way may not be obvious at first unless you're Dutch.<br/>
  Now is better than never.<br/>
  Although never is often better than <em>right</em> now.<br/>
<strong>If the implementation is hard to explain, it's a bad idea.</strong><br/>
<strong>If the implementation is easy to explain, it may be a good idea.</strong><br/>
  Namespaces are one honking great idea -- let's do more of those!</p>
</blockquote>
<p>The most Pythonic solution is the one that is clearest, simplest, and easiest to explain:</p>
<pre><code>a + b == c or a + c == b or b + c == a
</code></pre>
<p>Even better, you don't even need to know Python to understand this code! It's <em>that</em> easy. This is, without reservation, the best solution. Anything else is intellectual masturbation.</p>
<p>Furthermore, this is likely the best performing solution as well, as it is the only one out of all the proposals that short circuits. If <code>a + b == c</code>, only a single addition and comparison is done. </p>
</div>
<div class="post-text" itemprop="text">
<p>Solving the three equalities for a:</p>
<pre><code>a in (b+c, b-c, c-b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python has an <code>any</code> function that does an <code>or</code> on all the elements of a sequence. Here I've converted your statement into a 3-element tuple.</p>
<pre><code>any((a + b == c, a + c == b, b + c == a))
</code></pre>
<p>Note that <code>or</code> is short circuiting, so if calculating the individual conditions is expensive it might be better to keep your original construct.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know you're only dealing with positive numbers, this will work, and is pretty clean:</p>
<pre><code>a, b, c = sorted((a, b, c))
if a + b == c:
    do_stuff()
</code></pre>
<p>As I said, this only works for positive numbers; but if you <em>know</em> they're going to be positive, this is a very readable solution IMO, even directly in the code as opposed to in a function.</p>
<p>You could do this, which might do a bit of repeated computation; but you didn't specify performance as your goal:</p>
<pre><code>from itertools import permutations

if any(x + y == z for x, y, z in permutations((a, b, c), 3)):
    do_stuff()
</code></pre>
<p>Or without <code>permutations()</code> and the possibility of repeated computations:</p>
<pre><code>if any(x + y == z for x, y, z in [(a, b, c), (a, c, b), (b, c, a)]:
    do_stuff()
</code></pre>
<p>I would probably put this, or any other solution, into a function. Then you can just cleanly call the function in your code.</p>
<p>Personally, unless I needed more flexibility from the code, I would just use the first method in your question. It's simple and efficient. I still might put it into a function:</p>
<pre><code>def two_add_to_third(a, b, c):
    return a + b == c or a + c == b or b + c == a

if two_add_to_third(a, b, c):
    do_stuff()
</code></pre>
<p>That's pretty Pythonic, and it's quite possibly the most efficient way to do it (the extra function call aside); although you shouldn't worry too much about performance anyway, unless it's actually causing an issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you will only be using three variables then your initial method:</p>
<pre><code>a + b == c or a + c == b or b + c == a
</code></pre>
<p>Is already very pythonic.</p>
<p>If you plan on using more variables then your method of reasoning with:</p>
<pre><code>a + b + c in (2*a, 2*b, 2*c)
</code></pre>
<p>Is very smart but lets think about why. Why does this work? 
<br> Well through some simple arithmetic we see that:</br></p>
<pre><code>a + b = c
c = c
a + b + c == c + c == 2*c
a + b + c == 2*c
</code></pre>
<p>And this will have to hold true for either a,b, or c, meaning that yes it will equal <code>2*a</code>, <code>2*b</code>, or <code>2*c</code>. This will be true for any number of variables.</p>
<p>So a good way to write this quickly would be to simply have a list of your variables and check their sum against a list of the doubled values.</p>
<pre><code>values = [a,b,c,d,e,...]
any(sum(values) in [2*x for x in values])
</code></pre>
<p>This way, to add more variables into the equation all you have to do is edit your values list by 'n' new variables, not write 'n' equations</p>
</div>
<div class="post-text" itemprop="text">
<p>The following code can be used to iteratively compare each element with the sum of the others, which is computed from sum of the whole list, excluding that element.</p>
<pre><code> l = [a,b,c]
 any(sum(l)-e == e for e in l)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't try and simplify it. Instead, <em>name</em> what you're doing with a function:</p>
<pre><code>def any_two_sum_to_third(a, b, c):
  return a + b == c or a + c == b or b + c == a

if any_two_sum_to_third(foo, bar, baz):
  ...
</code></pre>
<p>Replace the condition with something "clever" might make it shorter, but it won't make it more readable. Leaving it how it is isn't very readable either however, because it's tricky to know <em>why</em> you're checking those three conditions at a glance. This makes it absolutely crystal clear what you're checking for.</p>
<p>Regarding performance, this approach does add the overhead of a function call, but never sacrifice readability for performance unless you've found a bottleneck you absolutely must fix. And always measure, as some clever implementations are capable of optimizing away and inlining some function calls in some circumstances.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3:</p>
<pre><code>(a+b+c)/2 in (a,b,c)
(a+b+c+d)/2 in (a,b,c,d)
...
</code></pre>
<p>It scales to any number of variables:</p>
<pre><code>arr = [a,b,c,d,...]
sum(arr)/2 in arr
</code></pre>
<p>However, in general I agree that unless you have more than three variables, the original version is more readable.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>(a+b-c)*(a+c-b)*(b+c-a) == 0
</code></pre>
<p>If the sum of any two terms is equal to the third term, then one of the factors will be zero, making the entire product zero.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about just:</p>
<pre><code>a == b + c or abs(a) == abs(b - c)
</code></pre>
<p>Note that this won't work if variables are unsigned.</p>
<p>From the viewpoint of code optimization (at least on x86 platform) this seems to be the most efficient solution.</p>
<p>Modern compilers will inline both abs() function calls and avoid sign testing and subsequent conditional branch by using a <a href="http://www.strchr.com/optimized_abs_function" rel="nofollow">clever sequence of CDQ, XOR, and SUB instructions</a>. The above high-level code will thus be represented with only low-latency, high-throughput ALU instructions and just two conditionals.</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution provided by Alex Varga "a in (b+c, b-c, c-b)" is compact and mathematically beautiful, but I wouldn't actually write code that way because the next developer coming along would not immediately understand the purpose of the code.</p>
<p>Mark Ransom's solution of </p>
<pre><code>any((a + b == c, a + c == b, b + c == a))
</code></pre>
<p>is more clear but not much more succinct than </p>
<pre><code>a + b == c or a + c == b or b + c == a
</code></pre>
<p>When writing code that someone else will have to look at, or that I will have to look at a long time later when I have forgotten what I was thinking when I wrote it, being too short or clever tends to do more harm than good.  Code should be readable.  So succinct is good, but not so succinct that the next programmer can't understand it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Request is for more compact OR more pythonic - I tried my hand at more compact.</p>
<p>given</p>
<pre><code>import functools, itertools
f = functools.partial(itertools.permutations, r = 3)
def g(x,y,z):
    return x + y == z
</code></pre>
<p>This is 2 characters less than the original</p>
<pre><code>any(g(*args) for args in f((a,b,c)))
</code></pre>
<hr/>
<p>test with:</p>
<pre><code>assert any(g(*args) for args in f((a,b,c))) == (a + b == c or a + c == b or b + c == a)
</code></pre>
<hr/>
<p>additionally, given:</p>
<pre><code>h = functools.partial(itertools.starmap, g)
</code></pre>
<p>This is equivalent</p>
<pre><code>any(h(f((a,b,c))))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I want to present what I see as the most <em>pythonic</em> answer:</p>
<pre class="lang-py prettyprint-override"><code>def one_number_is_the_sum_of_the_others(a, b, c):
    return any((a == b + c, b == a + c, c == a + b))
</code></pre>
<p>The general case, non-optimized:   </p>
<pre><code>def one_number_is_the_sum_of_the_others(numbers):
    for idx in range(len(numbers)):
        remaining_numbers = numbers[:]
        sum_candidate = remaining_numbers.pop(idx)
        if sum_candidate == sum(remaining_numbers):
            return True
    return False 
</code></pre>
<p>In terms of the Zen of Python I think the emphasized statements are more followed than from other answer:</p>
<blockquote>
<p>The Zen of Python, by Tim Peters</p>
<p>Beautiful is better than ugly.<br/>
<strong>Explicit is better than implicit.</strong><br/>
<strong>Simple is better than complex.</strong><br/>
  Complex is better than complicated.<br/>
  Flat is better than nested.<br/>
  Sparse is better than dense.<br/>
<strong>Readability counts.</strong><br/>
  Special cases aren't special enough to break the rules.<br/>
  Although practicality beats purity.<br/>
  Errors should never pass silently.<br/>
  Unless explicitly silenced.<br/>
  In the face of ambiguity, refuse the temptation to guess.<br/>
  There should be one-- and preferably only one --obvious way to do it.<br/>
  Although that way may not be obvious at first unless you're Dutch.<br/>
  Now is better than never.<br/>
  Although never is often better than <em>right</em> now.<br/>
  If the implementation is hard to explain, it's a bad idea.<br/>
  If the implementation is easy to explain, it may be a good idea.<br/>
  Namespaces are one honking great idea -- let's do more of those!</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>As an old habit of my programming, I think placing complex expression at right in a clause can make it more readable like this:</p>
<pre><code>a == b+c or b == a+c or c == a+b
</code></pre>
<p>Plus <code>()</code>:</p>
<pre><code>((a == b+c) or (b == a+c) or (c == a+b))
</code></pre>
<p>And also I think using multi-lines can also make more senses like this:</p>
<pre><code>((a == b+c) or 
 (b == a+c) or 
 (c == a+b))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In a generic way,</p>
<pre><code>m = a+b-c;
if (m == 0 || m == 2*a || m == 2*b) do_stuff ();
</code></pre>
<p>if, manipulating an input variable is OK for you,</p>
<pre><code>c = a+b-c;
if (c==0 || c == 2*a || c == 2*b) do_stuff ();
</code></pre>
<p>if you want to exploit using bit hacks, you can use "!", "&gt;&gt; 1" and "&lt;&lt; 1"</p>
<p>I avoided division though it enables use to avoid two multiplications to avoid round off errors. However, check for overflows</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def any_sum_of_others (*nums):
    num_elements = len(nums)
    for i in range(num_elements):
        discriminating_map = map(lambda j: -1 if j == i else 1, range(num_elements))
        if sum(n * u for n, u in zip(nums, discriminating_map)) == 0:
            return True
    return False

print(any_sum_of_others(0, 0, 0)) # True
print(any_sum_of_others(1, 2, 3)) # True
print(any_sum_of_others(7, 12, 5)) # True
print(any_sum_of_others(4, 2, 2)) # True
print(any_sum_of_others(1, -1, 0)) # True
print(any_sum_of_others(9, 8, -4)) # False
print(any_sum_of_others(4, 3, 2)) # False
print(any_sum_of_others(1, 1, 1, 1, 4)) # True
print(any_sum_of_others(0)) # True
print(any_sum_of_others(1)) # False
</code></pre>
</div>
<span class="comment-copy">More compact? Possibly. More Pythonic? Unlikely.</span>
<span class="comment-copy">Do your future self a favor and keep it in the original form: It’s the only that that immediately tells the purpose of this. Don’t modify that. <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">“Simple is better than complex.”, “Readability counts.”. “If the implementation is hard to explain, it's a bad idea.”</a></span>
<span class="comment-copy">Pythonic == unreadable?</span>
<span class="comment-copy">@wwii They are not mutually exclusive. See a = 0, b = 0, c = 0 ;)</span>
<span class="comment-copy">What @phresnel said. Instead of trying to "simplify" the expression, wrap it in a function with a descriptive name.</span>
<span class="comment-copy">Even better, throw in some parenthesis to make the intent crystal clear.</span>
<span class="comment-copy">The intent is already crystal clear without parentheses. Parentheses would make it harder to read - why is the author using parentheses when precedence already covers this?</span>
<span class="comment-copy">One other note about trying to be too clever: you may introduce unforeseen bugs by missing conditions you didn't consider.  In other words, you may <i>think</i> your new compact solution is equivalent, but it isn't in all cases. Unless there is a compelling reason to code otherwise (performance, memory constraints, and so on), clarity is king.</span>
<span class="comment-copy">This Zen applies to all code ever.</span>
<span class="comment-copy">It depends on what the formula is for. Look at 'Explicit is better than implicit', it might be that the 'sorting first' approach more clearly expresses what the program is doing, or one of the others. I don't think we can judge from the question.</span>
<span class="comment-copy">The only problem with this is the side effects. If b or c are more complex expressions, they'll be run multiple times.</span>
<span class="comment-copy">@Kroltan My point was that I actually answered his question, which asked for a "more compact" representation. See: <a href="https://en.m.wikipedia.org/wiki/Short-circuit_evaluation" rel="nofollow noreferrer">en.m.wikipedia.org/wiki/Short-circuit_evaluation</a></span>
<span class="comment-copy">Anyone reading this code will probably curse you for being "clever".</span>
<span class="comment-copy">@SilvioMayolo The same is true of the original</span>
<span class="comment-copy">@AlexVarga, "My point was that I actually answered his question". You did; it uses 30% fewer characters (putting spaces between operators). I wasn't trying to say your answer was wrong, just commenting on how idiomatic (pythonic) it is. Nice answer.</span>
<span class="comment-copy"><code>any()</code> and <code>all()</code> short-circuit too.</span>
<span class="comment-copy">@TigerhawkT3 Not in this case though; the three expressions will be evaluated before the tuple exists, and the tuple will exist before <code>any</code> even runs.</span>
<span class="comment-copy">Ah, I see. I guess it's only when there's a generator or similar lazy iterator in there.</span>
<span class="comment-copy"><code>any</code> and <code>all</code> "short-circuit" the process of <i>examining</i> the iterable they're given; but if that iterable is a sequence rather than a generator, then it has been already been fully evaluated <i>before the function call occurs</i>.</span>
<span class="comment-copy">This has the advantage that it's easy to split over multiple lines (double-indent the arguments to <code>any</code>, single-indent the <code>):</code> in the <code>if</code> statement), which helps plenty for readability when math is involved</span>
<span class="comment-copy">especially if we can assume a, b, c are all non-negative.</span>
<span class="comment-copy">does that work with negative numbers?</span>
<span class="comment-copy">I find the phrase "doesn't always work" a little confusing. The first solution only works if you know for sure that your numbers are non-negative. For instance with (a, b, c) = (-3, -2, -1) you have a+b != c but b+c=a. Similar cases with (-1, 1, 2) and (-2, -1, 1).</span>
<span class="comment-copy">@usernumber, you know, I noticed that earlier; not sure why I didn't fix it.</span>
<span class="comment-copy">Ooh, snap. "<i>If you know you're only dealing with positive numbers</i>, this will work, and is pretty clean". All the others work for any numbers, but <i>if you know you're only dealing with positive numbers</i>, the top one is very readable/Pythonic IMO.</span>
<span class="comment-copy">What about <code>a=-1</code>, <code>b=-1</code>, <code>c=-2</code>, then <code>a+b=c</code>, but <code>a+b+c = -4</code> and <code>2*max(a,b,c)</code> is <code>-2</code></span>
<span class="comment-copy">Thank you that is true, I would need to use abs. Making that adjustment now.</span>
<span class="comment-copy">After peppering it with half a dozen <code>abs()</code> calls, it's Pythonic than the OP's snippet (I'd actually call it significantly less readable).</span>
<span class="comment-copy">That is very true, I will adjust that now</span>
<span class="comment-copy">@ThatGuyRussell In order to short circuit, you would want to use a generator... something like <code>any(sum(values) == 2*x for x in values)</code>, that way you wouldn't have to do all the doubling up front, just as necessary.</span>
<span class="comment-copy">Nice :) I think if you remove the <code>[]</code> brackets from the second line, this will even short-circuit like the original with <code>or</code>...</span>
<span class="comment-copy">which is basically <code>any(a + b + c == 2*x for x in [a, b, c])</code>, quite close to the OP's suggestion</span>
<span class="comment-copy">That is similar, however this method extends to any number of variables.   I incorporated the suggestion by @psmears about short-circuiting.</span>
<span class="comment-copy">Functions should be written only if you expect to use the same code in more than one spot or if the code is complex. There is no mention of code reuse in the original question, and writing a function for a single line of code is not only overkill but it actually impairs readability.</span>
<span class="comment-copy">Coming from the FP school of things, I pretty much have to disagree completely and state that well named one-line functions are some of the best tools for increasing readability you'll ever find. Make a function whenever the steps you're taking to do something do not immediately bring clarity to <i>what</i> you're doing, as the name of the function lets you specify the <i>what</i> better than any comment could.</span>
<span class="comment-copy">Whatever school you invoke it is bad to blindly adhere to a set of rules. Having to jump to another part of the source to read that one line of code hidden inside a function just to be able to verify that it actually does what it says in the name, and then having to switch back to the place of a call to make sure you are passing correct parameters is completely unnecessary context switching. In my opinion doing that impairs both the readability and the workflow. Finally, neither the name of a function nor the code comments are a proper replacement for code documentation.</span>
<span class="comment-copy">This returns incorrect results for some inputs because of floating point rounding errors.</span>
<span class="comment-copy">Division should be avoided for performance and accuracy reasons.</span>
<span class="comment-copy">@pts Will not any implementation return incorrect results because of floating point rounding? Even a+b==c</span>
<span class="comment-copy">@osundblad: If a, b and c are ints, then (a+b+c)/2 does rounding (and may return incorrect results), but a+b==c is accurate.</span>
<span class="comment-copy">division by 2 is simply decreasing the exponent by one, so it will be accurate for any integer that is less than 2^53 (the fraction part of a float in python), and for larger integers you can use <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">decimal</a>. For example, to check integers that are less than 2^30 run <code>[x for x in range(pow(2,30)) if x != ((x * 2)/ pow(2,1))]</code></span>
<span class="comment-copy">I was thinking exactly the same thing but I can't deny that his original proposal is way cleaner...</span>
<span class="comment-copy">@Mehrdad - Definitely.  It's really no different than <code>(a+b&lt;&gt;c) &amp;&amp; (a+c&lt;&gt;b) &amp;&amp; (b+c&lt;&gt;a) == false</code></span>
<span class="comment-copy">It is just that multiplication is more expensive than the logical expressions and basic arithmetic.</span>
<span class="comment-copy">@IgorLevicki - Yes, although that's a VERY premature optimization concern.  Is this going to be performed tens of thousands of times per second?  If yes, then you would probably want to look at something else.</span>
<span class="comment-copy">@mbeckish - Why do you think it is premature? Code should be written with optimization in mind, not optimized as an after-thought. One day some intern will copy this code snippet and paste it into some performance critical loop on an embedded platform which will then run on millions of devices not necessarily being slow for what it does, but perhaps wasting more battery power. Writing such code just encourages bad coding practices. In my opinion, what OP should have asked is whether there a way to optimize that logic expression.</span>
<span class="comment-copy">And I think <code>fabs()</code> can be used for <code>float</code> types ;).</span>
<span class="comment-copy">Honest question: why do people always assume that the next programmer will be an idiot incapable of reading code?  I personally find that idea insulting. If code must be written to be blatantly obvious to every programmer, then that implies that we as a profession are catering to the lowest common denominator, the least skilled among us. If we keep doing that, how are they ever going to improve their personal skill?  I don't see this in other professions. When was the last time you saw a composer writing a simple music score just so that every musician can play it regardless of skill level?</span>
<span class="comment-copy">The issue is that even programmers have limited mental energy, so do you want to spend your limited mental energy on the algorithm and higher level aspects of the program, or on figuring out what some complicated line of code means when it can be expressed more simply?  Programming is hard, so don't make it harder on yourself unnecessarily, just as an Olympic runner would not run a race with a heavy backpack on just because they can.  As Steve McConell says in Code Complete 2, readability is one of the most important aspects of code.</span>
<span class="comment-copy">Well, it's two characters shorter than the original, but not the one the OP gave right afterward, which he said he's currently using. The original also includes lots of whitespace, which this omits whenever possible. There's also the small matter of the function <code>g()</code> you have to define for this to work. Given all that, I'd say it's significantly larger.</span>
<span class="comment-copy">@TigerhawkT3, I interpreted it as a request for a shorter expression/line. see edit for further <i>improvement</i>.</span>
<span class="comment-copy">Very bad function names, only suitable for a code golf.</span>
<span class="comment-copy">@0xc0de - sorry I don't play. <i>Suitable</i> can be pretty subjective and dependent on circumstances - but I will defer to the community.</span>
<span class="comment-copy">I don't see how is this more compact when it has more characters than the original code.</span>
<span class="comment-copy">Functions should be written only if you expect to use the same code in more than one spot or if the code is complex. There is no mention of code reuse in the original question, and writing a function for a single line of code is not only overkill but it actually impairs readability.</span>
<span class="comment-copy">I disagree that it impairs readability; if you choose a suitable name it may improve readability (but I make no representation as to the quality of the name I chose in this answer). In addition, it can be helpful to give a name to a concept, which you will have to do as long as you force yourself to give a good name to your function. Functions are good. As to whether the functionality is complex enough to benefit from being encapsulated in a function, that's a subjective judgement.</span>
