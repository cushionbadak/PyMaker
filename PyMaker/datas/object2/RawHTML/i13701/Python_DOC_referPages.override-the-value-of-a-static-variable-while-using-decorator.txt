<div class="post-text" itemprop="text">
<p>I've created a class like the following:</p>
<pre><code>class Simon:

    name = 'Simon'

    @classmethod
    def says(cls, sentence):
        return '%s says: %s' % (cls.name, sentence)
</code></pre>
<p>If I want <em>Simon</em> say <em>sit down</em>, I can do this:</p>
<pre><code>&gt;&gt;&gt; Simon.says('sit down')
'Simon says: sit down'
</code></pre>
<p>To substitute <em>Simon</em> with another name, say, <em>Eva</em>, I can subclass it like this: </p>
<pre><code>class Eva(Simon):

    name = 'Eva'
</code></pre>
<p>And the result:</p>
<pre><code>&gt;&gt;&gt; Eva.says('stand up')
'Eva says: stand up'
</code></pre>
<p>Now I want to change <em>says</em> to <em>said</em> by creating a decorator called <code>to_past_tense</code>:</p>
<pre><code>class Eva(Simon):

    name = 'Eva'

    def to_past_tense(self, func):
        def wrapper(*arg, **kw):
            present_tense = func(*arg, **kw)
            past_tense = present_tense.replace('says', 'said')
            return past_tense
        return wrapper

    @classmethod
    def says(cls, *arg, **kw):
        return cls.to_past_tense(cls, Simon.says)(*arg, **kw)
</code></pre>
<p>If I do this:</p>
<pre><code>&gt;&gt;&gt; Eva.says('stand up')
</code></pre>
<p>what I'm expecting is this:</p>
<pre><code>'Eva said: stand up'
</code></pre>
<p>but in fact I got this</p>
<pre><code>'Simon said: stand up'
</code></pre>
<p>How can I override the value?</p>
<p>And, please, help me improve the title if it isn't precise and clear, thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using <code>Simon.says</code>, retrieving a bound class.</p>
<p>If you wanted to get the overridden class method but have it bind to the current class, use a <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow"><code>super()</code> proxy object</a>:</p>
<pre><code>@classmethod
def says(cls, *arg, **kw):
    return cls.to_past_tense(cls, super().says)(*arg, **kw)
</code></pre>
<p>The <code>super()</code> object will search the MRO of the class, find the <code>says</code> method on <code>Simon</code>, then bind it to the <code>cls</code> object for you, so the <code>cls.name</code> value is still looked up from <code>Eva</code>:</p>
<pre><code>&gt;&gt;&gt; class Simon:
...     name = 'Simon'
...     @classmethod
...     def says(cls, sentence):
...         return '%s says: %s' % (cls.name, sentence)
... 
&gt;&gt;&gt; class Eva(Simon):
...     name = 'Eva'
...     def to_past_tense(self, func):
...         def wrapper(*arg, **kw):
...             present_tense = func(*arg, **kw)
...             past_tense = present_tense.replace('says', 'said')
...             return past_tense
...         return wrapper
...     @classmethod
...     def says(cls, *arg, **kw):
...         return cls.to_past_tense(cls, super().says)(*arg, **kw)
... 
&gt;&gt;&gt; Eva.says('Hello')
'Eva said: Hello'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not entirely sure what you are trying to achieve here, but I suppose you need to pass <code>cls.says</code> to the method:</p>
<pre><code>return cls.to_past_tense(cls, cls.says)(*arg, **kw)
</code></pre>
</div>
<span class="comment-copy">See that hard-coded class name you have there: <code>return cls.to_past_tense(cls, Simon.says)(*arg, **kw)</code></span>
<span class="comment-copy">I've tried what @Daniel Roseman suggested, but with no vein.</span>
<span class="comment-copy">Should <i>Eva</i> be hard-coded anyway?</span>
<span class="comment-copy">@OwenL: the current class in which you define this method should be, yes, as that is what <code>super()</code> then uses to find the next class in the MRO. In Python 3, you can use <code>super().says</code>, so no arguments.</span>
<span class="comment-copy">@OwenL: ah, you tagged this as Python 3. Will update.</span>
<span class="comment-copy">Perfect! Thank a ton!</span>
<span class="comment-copy">but I got this: RuntimeError: maximum recursion depth exceeded</span>
<span class="comment-copy">That's because <code>cls.say</code> points to <code>Eva.say</code>, so yes, this causes the method to call itself.</span>
