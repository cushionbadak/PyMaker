<div class="post-text" itemprop="text">
<p>The question is about sport programming.
I'm getting a huge string from stdin and I have to create a byte array with one byte for each char with True value if the char equals to '.' and with False value otherwise. At the same time I should calculate amount of cases when we have two '.' symbols near each other.</p>
<p>Question 1: can be some additional calculation performed inside a generator expression to be accessible after the generator was used - sum, count, more complex calculation to avoid additional looping over the created list?</p>
<p>Question 2: can I access the previous loop result inside a generator expression? I try to perform the second solution below in one generator expression.</p>
<p>Because of this is for competition no external libraries can be used.</p>
<p>1st solution</p>
<pre><code>res = 0: prev = False
s = bytearray()
for c in (c == '.' for c in 'a' + input() + 'a'):
    res += c and prev
    prev = c
    s.append(c)
</code></pre>
<p>2nd solution</p>
<pre><code>s = bytearray(c == '.' for c in 'a' + input() + 'a')
res = sum(map(all,zip(s[1:],s[:-1])))
</code></pre>
<p>UPD: 3rd solution with itertools.tee() - unfortunately this solution faster than 1st but slower than 2nd</p>
<pre><code>i1,i2,i3 = tee((c == '.' for c in 'a' + input() + 'a'),3)
next(i1)
res = sum(a and b for a,b in zip(i1,i2))
s = bytearray(i3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Question 1: can be some additional calculation performed inside a generator expression to be accessible after the generator was used - sum, count, more complex calculation to avoid additional looping over the created list?</p>
</blockquote>
<p>No generators are one shut iterables and you can not use them after one iteration. </p>
<blockquote>
<p>Question 2: can I access the previous loop result inside a generator expression? I try to perform the second solution below in one generator expression.</p>
</blockquote>
<p>So if you want to access the previous item in a generator expression you can simply use <code>zip</code> on your iterable :</p>
<pre><code>inp='a' + input() + 'a'
(next=='.' and pre== '.' for pre,next in zip(inp,inp[1:]))  
</code></pre>
<p>But if you want to access to previous item of a generator you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow"><code>itertools.tee</code></a> to create 2 independent iterators from your generator and use <code>zip</code> function to create a new generator (in python 2 use <code>itertools.izip</code>)contain pairs with prev and next items.</p>
<pre><code>from itertools import tee
new_generator,MY_generator=tee(MY_generator)
next(new_generator)

zipped_generator = zip(new_generator,My_generator)
</code></pre>
<p>And in iteration do :</p>
<pre><code>[for pre,next in zipped_generator]
</code></pre>
</div>
<span class="comment-copy">Thanks, I even did not expect to be able to use itertools on competitions :)</span>
