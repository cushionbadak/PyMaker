<div class="post-text" itemprop="text">
<p>I'm using the <a href="https://github.com/aaugustin/websockets"><code>websockets</code></a> library to create a websocket server in Python 3.4. Here's a simple echo server:</p>
<pre class="lang-python prettyprint-override"><code>import asyncio
import websockets

@asyncio.coroutine
def connection_handler(websocket, path):
    while True:
        msg = yield from websocket.recv()
        if msg is None:  # connection lost
            break
        yield from websocket.send(msg)

start_server = websockets.serve(connection_handler, 'localhost', 8000)
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
</code></pre>
<p>Let's say we – additionally – wanted to send a message to the client whenever some event happens. For simplicity, let's send a message periodically every 60 seconds. How would we do that? I mean, because <code>connection_handler</code> is constantly waiting for incoming messages, the server can only take action <em>after</em> it has received a message from the client, right? What am I missing here?</p>
<p>Maybe this scenario requires a framework based on events/callbacks rather than one based on coroutines? <a href="http://www.tornadoweb.org/en/stable/websocket.html">Tornado</a>?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>TL;DR</strong> Use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future"><code>asyncio.ensure_future()</code></a> to run several coroutines concurrently.</p>
<hr/>
<blockquote>
<p>Maybe this scenario requires a framework based on events/callbacks rather than one based on coroutines? Tornado?</p>
</blockquote>
<p>No, you don't need any other framework for this. The whole idea the asynchronous application vs synchronous is that it doesn't block, while waiting for result. It doesn't matter how it is implemented, using coroutines or callbacks.</p>
<blockquote>
<p>I mean, because connection_handler is constantly waiting for incoming messages, the server can only take action after it has received a message from the client, right? What am I missing here?</p>
</blockquote>
<p>In synchronous application you will write something like <code>msg = websocket.recv()</code>, which would block whole application until you receive message (as you described). But in the asynchronous application it's completely different. </p>
<p>When you do <code>msg = yield from websocket.recv()</code> you say something like: suspend execution of <code>connection_handler()</code> until <code>websocket.recv()</code> will produce something. Using <code>yield from</code> inside coroutine returns control back to the event loop, so some other code can be executed, while we're waiting for result of <code>websocket.recv()</code>. Please, refer to <a href="https://docs.python.org/3/library/asyncio-task.html#coroutines">documentation</a> to better understand how coroutines work.</p>
<blockquote>
<p>Let's say we – additionally – wanted to send a message to the client whenever some event happens. For simplicity, let's send a message periodically every 60 seconds. How would we do that?</p>
</blockquote>
<p>You can use <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.async"><code>asyncio.async()</code></a> to run as many coroutines as you want, before executing blocking call for <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_forever">starting event loop</a>.</p>
<pre><code>import asyncio

import websockets

# here we'll store all active connections to use for sending periodic messages
connections = []


@asyncio.coroutine
def connection_handler(connection, path):
    connections.append(connection)  # add connection to pool
    while True:
        msg = yield from connection.recv()
        if msg is None:  # connection lost
            connections.remove(connection)  # remove connection from pool, when client disconnects
            break
        else:
            print('&lt; {}'.format(msg))
        yield from connection.send(msg)
        print('&gt; {}'.format(msg))


@asyncio.coroutine
def send_periodically():
    while True:
        yield from asyncio.sleep(5)  # switch to other code and continue execution in 5 seconds
        for connection in connections:
            print('&gt; Periodic event happened.')
            yield from connection.send('Periodic event happened.')  # send message to each connected client


start_server = websockets.serve(connection_handler, 'localhost', 8000)
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.async(send_periodically())  # before blocking call we schedule our coroutine for sending periodic messages
asyncio.get_event_loop().run_forever()
</code></pre>
<p>Here is an example client implementation. It asks you to enter name, receives it back from the echo server, waits for two more messages from server (which are our periodic messages) and closes connection.</p>
<pre><code>import asyncio

import websockets


@asyncio.coroutine
def hello():
    connection = yield from websockets.connect('ws://localhost:8000/')
    name = input("What's your name? ")
    yield from connection.send(name)
    print("&gt; {}".format(name))
    for _ in range(3):
        msg = yield from connection.recv()
        print("&lt; {}".format(msg))

    yield from connection.close()


asyncio.get_event_loop().run_until_complete(hello())
</code></pre>
<p>Important points:</p>
<ol>
<li>In Python 3.4.4 <code>asyncio.async()</code> was renamed to <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future"><code>asyncio.ensure_future()</code></a>.</li>
<li>There are special methods for scheduling <a href="https://docs.python.org/3/library/asyncio-eventloop.html#delayed-calls">delayed calls</a>, but they don't work with coroutines.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Same issue, can hardly got solution until I saw the perfect sample here: <a href="http://websockets.readthedocs.io/en/stable/intro.html#both" rel="noreferrer">http://websockets.readthedocs.io/en/stable/intro.html#both</a></p>
<pre><code> done, pending = await asyncio.wait(
        [listener_task, producer_task],
        return_when=asyncio.FIRST_COMPLETED)  # Important
</code></pre>
<p>So, I can handle multi coroutine tasks such as heartbeat and redis subscribe.</p>
</div>
<span class="comment-copy">Great answer, thank you! I understand what coroutines are, but I'm still trying to get my head around the asyncio framework. Your answer helped a lot.</span>
<span class="comment-copy">@weatherfrog Did you solve the problem? I have a similar issue over <a href="https://stackoverflow.com/questions/49871048/tornado-client-on-message-callback-is-not-responding">here</a></span>
<span class="comment-copy">I tried the link you taught. But I can not solve my problem. Please give some advice my issue over <a href="https://stackoverflow.com/questions/49871048/tornado-client-on-message-callback-is-not-responding">here</a></span>
