<div class="post-text" itemprop="text">
<p>I'd like to know the type of an instance obtained from super() function.  I tried <code>print(super())</code> and <code>__print(type(super()))__</code></p>
<pre><code>class Base:
    def __init__(self):
        pass

class Derive(Base):
    def __init__(self):
        print(super())        
        print(type(super()))        
        super().__init__()

d = Derive()
</code></pre>
<p>The result is </p>
<pre><code>&lt;super: &lt;class 'Derive'&gt;, &lt;Derive object&gt;&gt;
&lt;class 'super'&gt;
</code></pre>
<p>With those result, I was wondering how <code>super().__init__()</code> calls the correct constructor.</p>
</div>
<div class="post-text" itemprop="text">
<p>From your comments, you want to know how <code>super</code> knows which method to call next. Super inspects the mro of the instance, knows the current class method it's in, and calls the next one in line. The following demo will work in Python 2 and 3, and in Python 2, it prints the name of each class thanks to the metaclass, so I'll use that output:</p>
<p>First the imports and setup to make the printing nicer:</p>
<pre><code>import inspect

class Meta(type):
    def __repr__(cls):
        return cls.__name__
</code></pre>
<p>Next, we define a function to tell us what's going on based on the super object itself</p>
<pre><code>def next_in_line(supobj):
    print('The instance class: {}'.format(supobj.__self_class__))
    print('in this class\'s method: {}'.format(supobj.__thisclass__))
    mro = inspect.getmro(supobj.__self_class__)
    nextindex = mro.index(supobj.__thisclass__) + 1
    print('super will go to {} next'.format(mro[nextindex]))
</code></pre>
<p>Finally, we declare a class hierarchy based on the example from the wikipedia entry on <a href="https://en.wikipedia.org/wiki/C3_linearization" rel="nofollow">C3 linearization</a>, for a sufficiently complex example, note the metaclass <code>repr</code> doesn't work in Python3, but the attribute assignment won't break it. Also note that we use the full super call of <code>super(Name, self)</code> which is equivalent to <code>super()</code> in Python 3, and will still work:</p>
<pre><code>class O(object):
    __metaclass__ = Meta

    def __init__(self):
        next_in_line(super(O, self))
        super(O, self).__init__()

class A(O):
    def __init__(self):
        next_in_line(super(A, self))
        super(A, self).__init__()


class B(O):
    def __init__(self):
        next_in_line(super(B, self))
        super(B, self).__init__()


class C(O):
    def __init__(self):
        next_in_line(super(C, self))
        super(C, self).__init__()


class D(O):
    def __init__(self):
        next_in_line(super(D, self))
        super(D, self).__init__()


class E(O):
    def __init__(self):
        next_in_line(super(E, self))
        super(E, self).__init__()


class K1(A, B, C):
    def __init__(self):
        next_in_line(super(K1, self))
        super(K1, self).__init__()


class K2(D, B, E):
    def __init__(self):
        next_in_line(super(K2, self))
        super(K2, self).__init__()


class K3(D, A):
    def __init__(self):
        next_in_line(super(K3, self))
        super(K3, self).__init__()


class Z(K1, K2, K3):
    def __init__(self):
        next_in_line(super(Z, self))
        super(Z, self).__init__()
</code></pre>
<p>Now when we print the mro of Z, we get the method resolution order defined by this algorithm applied to the inheritance tree:</p>
<pre><code>&gt;&gt;&gt; print(inspect.getmro(Z))
(Z, K1, K2, K3, D, A, B, C, E, O, &lt;type 'object'&gt;)
</code></pre>
<p>And when we call Z(), because our function uses the mro, we'll visit each method in order:</p>
<pre><code>&gt;&gt;&gt; Z()
The instance class: Z
in this class's method: Z
super will go to K1 next
The instance class: Z
in this class's method: K1
super will go to K2 next
The instance class: Z
in this class's method: K2
super will go to K3 next
The instance class: Z
in this class's method: K3
super will go to D next
The instance class: Z
in this class's method: D
super will go to A next
The instance class: Z
in this class's method: A
super will go to B next
The instance class: Z
in this class's method: B
super will go to C next
The instance class: Z
in this class's method: C
super will go to E next
The instance class: Z
in this class's method: E
super will go to O next
The instance class: Z
in this class's method: O
super will go to &lt;type 'object'&gt; next
</code></pre>
<p>And we stop at <code>object.__init__</code>. From the above we can see that <code>super</code> always knows what class of the instance it is in, the class's method that it is currently in, and can deduce from the instance class's MRO where to go next. </p>
<hr/>
<blockquote>
<p><strong>I'd like to know the name of the base class?</strong></p>
</blockquote>
<p>If you only want the direct base (or more than one, in the case of multiple inheritance), you can use the <code>__bases__</code> attribute, which returns a tuple</p>
<pre><code>&gt;&gt;&gt; Derive.__bases__
(&lt;class __main__.Base at 0xffeb517c&gt;,)

&gt;&gt;&gt; Derive.__bases__[0].__name__
'Base'
</code></pre>
<p>I recommend the inspect module for getting the Method Resolution Order (which <code>super</code> follows based on the original caller's class):</p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; inspect.getmro(Derive)
(&lt;class __main__.Derive at 0xffeb51dc&gt;, &lt;class __main__.Base at 0xffeb517c&gt;)
</code></pre>
<p><strong>Getting it from super</strong></p>
<p><code>super().__self_class__</code> gives the instance class, and <code>super().__thisclass__</code> gives us the current class. We can use the instance's MRO and look up the class that comes next. I presume you wouldn't do this in the final parent, so I'm not catching an index error:</p>
<pre><code>class Base:
    def __init__(self):
        print(super().__self_class__)
        print(super().__thisclass__)


class Derive(Base):
    def __init__(self):
        print(super().__self_class__)
        print(super().__thisclass__)
        mro = inspect.getmro(super().__self_class__)
        nextindex = mro.index(super().__thisclass__) + 1
        print('super will go to {} next'.format(mro[nextindex]))
        super().__init__()


&gt;&gt;&gt; d = Derive()
&lt;class '__main__.Derive'&gt;
&lt;class '__main__.Derive'&gt;
super will go to &lt;class '__main__.Base'&gt; next
&lt;class '__main__.Derive'&gt;
&lt;class '__main__.Base'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can't do what you want with <code>super()</code> directly. Go to the class MRO (see <a href="https://docs.python.org/3/library/stdtypes.html?highlight=__mro__#class.__mro__" rel="nofollow noreferrer"><code>class.__mro__</code></a>) instead:</p>
<pre><code>class Derive(Base):
    def __init__(self):
        mro = type(self).__mro__
        parent = mro[mro.index(__class__) + 1]
        print(parent)
</code></pre>
<p>Here <code>__class__</code> is the magic closure variable<sup>*</sup> that references the class the current function was defined in; the above continues to work even when you subclass or mix in additional classes with <code>Derive</code>, even when you produce a diamond inheritance pattern.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class Base: pass
... 
&gt;&gt;&gt; class Derive(Base):
...     def __init__(self):
...         mro = type(self).__mro__
...         parent = mro[mro.index(__class__) + 1]
...         print(parent)
... 
&gt;&gt;&gt; Derive()
&lt;class '__main__.Base'&gt;
&lt;__main__.Derive object at 0x10f7476a0&gt;
&gt;&gt;&gt; class Mixin(Base): pass
... 
&gt;&gt;&gt; class Multiple(Derive, Mixin): pass
... 
&gt;&gt;&gt; Multiple()
&lt;class '__main__.Mixin'&gt;
&lt;__main__.Multiple object at 0x10f747ba8&gt;
</code></pre>
<p>Note how the <code>Multiple</code> class inherits from both <code>Derive</code> and <code>Mixin</code>, and the next class in the MRO is thus found to be <code>Mixin</code>, <em>not</em> <code>Base</code>, because <code>Mixin</code> <em>also</em> derives from <code>Base</code>.</p>
<p>This copies what <code>super()</code> does; find the next class in the MRO for the instance, relative to the current class.</p>
<hr/>
<p><sup>*</sup> For background, see <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic">Why is Python 3.x's super() magic?</a></p>
</div>
<span class="comment-copy">try self.__mro__</span>
<span class="comment-copy">@MarcusMüllerꕺꕺ I knew mro.  I'm sorry for being unclear. I changed the title and edit my question to be more specific of what I need.</span>
<span class="comment-copy">@MarcusMüllerꕺꕺ: <code>type(self).__mro__</code> will vary with subclasses. <code>__class__.__mro__</code> will capture the current.</span>
<span class="comment-copy">@AaronHall I edited the titled and the question again.  I'm sorry for misdirecting to the base class name.</span>
<span class="comment-copy">Note that <code>super()</code> can go <b>sideways</b> in a multi-inheritance scenario.</span>
<span class="comment-copy">They may well be <i>confused</i> about how <code>super()</code> and the MRO work, when it comes to multiple inheritance with a diamond pattern.</span>
<span class="comment-copy">If that's the case, it's an XY problem. I added the question-mark on what appears to be the question as stated, and directly answered it. I'm also voting to close based on that issue.</span>
<span class="comment-copy">@AaronHall Thank you for the answer.  However, as MartijnPieters said in his answer, I cannot do it directly with super(). And your solution also require another module to use with super().  Anyway, I think what I don't understand is why super().__init__() call the right constructor even super() is something like &lt;super: &lt;class 'Derive'&gt;, &lt;Derive object&gt;&gt; and type(super()) is &lt;class 'super'&gt;.</span>
<span class="comment-copy">@wannik ok, updating my answer with some more info.</span>
