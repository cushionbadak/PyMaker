<div class="post-text" itemprop="text">
<p>can someone please tell me how to get the day and month out of an integer that represents the day of the year? For example <code>32</code> should be 1st of February, <code>308</code> should be 11th of November</p>
<p>I wrote a code to return the values but is long and couldn't return two values, month and day at the same time.</p>
<pre><code>def normyear(fix):
    if fix &gt; 31 :
        if fix &gt; 59 :
            if fix &gt; 90 :
                if fix &gt; 120 :
                    if fix &gt; 151 :
                        if fix &gt; 181 :
                            if fix &gt; 212 :
                                if fix &gt; 243 :
                                    if fix &gt; 273 :
                                        if fix &gt; 304 :
                                            if fix &gt; 334 :
                                                if fix &gt; 365 :
                                                       print "Invalid id number                        please try again"
                                                else :
                                                    day = (fix - 334)
                                                    month = 12
                                            else :
                                                day = (fix - 304)
                                                month = 11
                                        else :
                                            day = (fix - 273)
                                            month = 10
                                    else :
                                        day = (fix - 243)
                                        month = 9
                                else :
                                    day = (fix - 212)
                                    month = 8
                            else :
                                day = (fix - 181)
                                month = 7
                        else :
                            day = (fix - 151)
                            month = 6
                    else :
                        day = (fix - 120)
                        month = 5
                else :
                    day = (fix - 90)
                    month = 4
            else :
                day = (fix - 59)
                month = 3
        else :
            day = (fix - 31)
            month = 2
    else :
        day = mid   
        month = 1
    return day
    return month
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You will need the year as well as the day of the year, because of leap years. That said:</p>
<pre><code>from datetime import datetime
from datetime import timedelta

def month_and_day_from_year_day(year, day):
    date = datetime(year, 1, 1) + timedelta(day - 1)
    return (date.month, date.day)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can just use <a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime" rel="nofollow">datetime.strptime</a> to parse this:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dayOfYear = 64
&gt;&gt;&gt; d = datetime.strptime('{} 2015'.format(dayOfYear), '%j %Y')
&gt;&gt;&gt; d.day
5
&gt;&gt;&gt; d.month
3
</code></pre>
<p>Note that you need to supply a year in order to handle leap years correctly. In this example, I hardcoded the current year 2015 into it.</p>
<hr/>
<p>If you wanted to go there by hand, without using the <code>datetime</code> module to handle this, you could also solve it like this:</p>
<pre><code>&gt;&gt;&gt; months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
&gt;&gt;&gt; dayOfYear = 64
&gt;&gt;&gt; for month, monthDays in enumerate(months):
        if dayOfYear - monthDays &gt; 0:
            dayOfYear -= monthDays
        else:
            print('Month:', month + 1) # +1 because it’s zero-indexed
            print('Day:', dayOfYear)
            break

Month: 3
Day: 5
</code></pre>
<p>This does a similar thing to your code except with a much simpler logic: It keeps subtracting the days of a month as long as there are more days left than the current month contains. While doing that, it counts the months that are passed (using <code>enumerate</code> here). So in the end, the remainder of days is the day of the month, and the number of months passed is the month.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code below compares the speed of various day number to day &amp; month algorithms. It also has a couple of functions useful for testing these algorithms. As well as Poke's &amp; Cyphase's algorithms I've also included one that performs the calculation using arcane arithmetic. </p>
<p>I won't go into details, but the arithmetic algorithm works by rotating the calendar to put February at the end of the year. The rotated calendar is a lot more regular than the normal one: it consists of repeating blocks of 5 months. In each block there are 153 days, with the month lengths alternating from long to short.</p>
<pre><code>#!/usr/bin/env python

''' daynum tests

Time various algorithms to compute the day &amp; month
given the year and the day number

From http://stackoverflow.com/q/32047520/4014959

Typical timing results:

daynum_to_daymon0:  Poke 1
[3.0101921558380127, 3.058804988861084, 3.0825381278991699]
daynum_to_daymon1:  PM 2Ring 
[0.1977241039276123, 0.20353794097900391, 0.20514988899230957]
daynum_to_daymon2:  Cyphase 
[0.28950190544128418, 0.29159307479858398, 0.31502914428710938]
daynum_to_daymon3:  Poke 2 
[0.36095499992370605, 0.38256311416625977, 0.4053041934967041]

'''

from datetime import datetime, timedelta
from timeit import Timer

def is_leap(year):
    return (year % 4 == 0) and (year % 100 != 0) or (year % 400 == 0)

def daynum_to_daymon0(daynum, year):
    ''' Poke 1'''
    dy = '{0} {1}'.format(daynum, year)
    d = datetime.strptime(dy, '%j %Y')
    return d.day, d.month

def daynum_to_daymon1(daynum, year):
    ''' PM 2Ring '''
    isleap = is_leap(year)
    d = (daynum - 60 - isleap) % (365 + isleap)
    mon, day = divmod(d * 5 + 2, 153)
    return day // 5 + 1, (mon + 2) % 12 + 1

def daynum_to_daymon2(day, year):
    ''' Cyphase '''
    date = datetime(year, 1, 1) + timedelta(day - 1)
    return date.day, date.month

def daynum_to_daymon3(dayOfYear, year):
    ''' Poke 2 '''
    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    months[1] += is_leap(year)
    for month, monthDays in enumerate(months):
        if dayOfYear - monthDays &gt; 0:
            dayOfYear -= monthDays
        else:
            break
    return dayOfYear, month + 1

funcs = (
    daynum_to_daymon0,
    daynum_to_daymon1,
    daynum_to_daymon2,
    daynum_to_daymon3,
)

def dump_year(daynum_to_daymon, year):
    ''' Print a list of days for each month of the year '''
    isleap = is_leap(year)
    print daynum_to_daymon.func_name
    print year, ('!=', '==')[isleap], 'leap year'

    oldm = ''
    for daynum in range(1, 1 + 365 + isleap):
        d, m = daynum_to_daymon(daynum, year)
        if m != oldm:
            if oldm:
                print oldm, buff
            oldm = m
            buff = []
        buff.append(d)

    if buff:
        print oldm, buff

def compare(func0, func1, y0, y1):
    ''' Verify that 2 functions produce the same results 
        for years in the range(y0, y1) 
    '''
    print 'Comparing %s and %s' % (func0.func_name, func1.func_name)
    print 'Testing %d to %d (inclusive)' % (y0, y1)
    for year in range(y0, y1+1):
        isleap = is_leap(year)
        for daynum in range(1, 1 + 365 + isleap):
            t0 = func0(daynum, year)
            t1 = func1(daynum, year)
            assert t0 == t1, (t0, t1)
    print 'OK'

def test(daynum_to_daymon, y0, y1):
    ''' Compute day &amp; month for all days in the given (inclusive) year range
        No output is generated because this function is used to perform 
        timeit tests
    '''
    for year in range(y0, y1+1):
        for daynum in range(1, 366 + is_leap(year)):
            t = daynum_to_daymon(daynum, year)

def time_test():
    reps, loops = 3, 60

    for func in funcs:
        fname = func.func_name
        print '%s: %s' % (fname, func.__doc__)

        setup = 'from __main__ import test, %s' % fname
        t = Timer('test(%s, 1995, 1996)' % fname, setup)
        r = t.repeat(reps, loops)
        r.sort()
        print r

if __name__ == "__main__":
    dump_year(daynum_to_daymon1, 2015)
    compare(daynum_to_daymon0, daynum_to_daymon1, 1995, 2015)
    time_test()
</code></pre>
<p><strong>typical output</strong></p>
<pre class="lang-none prettyprint-override"><code>daynum_to_daymon1
2015 != leap year
1 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
2 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]
3 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
4 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
5 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
6 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
7 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
8 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
9 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
11 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
12 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
Comparing daynum_to_daymon0 and daynum_to_daymon1
Testing 1995 to 2015 (inclusive)
OK
daynum_to_daymon0:  Poke 1
[2.8590669631958008, 2.9910919666290283, 3.0923340320587158]
daynum_to_daymon1:  PM 2Ring 
[0.20377802848815918, 0.20526909828186035, 0.21576380729675293]
daynum_to_daymon2:  Cyphase 
[0.29232597351074219, 0.29248213768005371, 0.2969820499420166]
daynum_to_daymon3:  Poke 2 
[0.34156394004821777, 0.34333705902099609, 0.34701800346374512]
</code></pre>
<p>Although the arithmetic algorithm is the fastest, I recommend using Cyphase's algorithm, unless you <em>really</em> need the speed (in which case, what are you doing using Python?). Cyphase's algorithm is much easier to read &amp; understand; the arithmetic algorithm really needs to be heavily documented to explain how &amp; why it works. Using "clever" algorithms like that goes against <a href="https://en.wikiquote.org/wiki/Brian_Kernighan" rel="nofollow">Kernighan's Maxim</a>:</p>
<blockquote>
<p>Everyone knows that debugging is twice as hard as writing a program in
  the first place. So if you're as clever as you can be when you write
  it, how will you ever debug it?</p>
</blockquote>
</div>
<span class="comment-copy">Me eyes! Protip: if you ever find yourself writing ladder code like this, you're doing something seriously wrong and there is a simpler way to express what you're trying to do.</span>
<span class="comment-copy"><code>if fix &gt; 365 :                                                        print "Invalid id number</code> what about leap year?</span>
<span class="comment-copy">@Tim More generally, after February things will get weird in leap years...</span>
<span class="comment-copy">Someone should make an <code>arrow</code> joke.</span>
<span class="comment-copy">I'm kinda new to python and i had the idea that a nested if is more easier for the pc to process than an else if. @TimCastelijns, i made a similar one for leap years but later found out that this code is unnecessary as my local id system takes into account both in the leap year calculation. Thanx peeps :D</span>
<span class="comment-copy">You might want to switch the order of month and day in the return statement to reflect the order in the method name - or vice versa. ;)</span>
<span class="comment-copy">@Falko, thanks for pointing that out. Also nice catch on the extra parens; I was going to do <code>.date()</code>, but changed my mind. Since they didn't affect anything, I missed them :).</span>
<span class="comment-copy">FWIW, this approach is around 10x faster than using <code>.strptime()</code>.</span>
<span class="comment-copy">You're forgetting leap years.</span>
<span class="comment-copy">@Cyphase Where exactly? I do mention leap years explicitely.</span>
<span class="comment-copy">Right you are, but I meant in the non-<code>datetime</code> method.</span>
<span class="comment-copy">@Cyphase My solution uses a flexible list of days per month, which you can easily adjust if you want to use the numbers of a leap year. It’s “hardcoded” value just like the 2015 which you can easily adjust.</span>
<span class="comment-copy">Sure, but in the first method it's trivial to make the year dynamic as well, whereas in the second you have to write leap year checking code. Just saying. IMO using <code>datetime</code> is better than doing it manually anyway.</span>
<span class="comment-copy">In <code>d = (daynum - 60 - isleap) % (365 + isleap)</code>, <code>d</code> will always be <code>daynum - 60 - isleap</code> for any possible year day.</span>
<span class="comment-copy">@Cyphase: What about when <code>daynum &lt; 60 + isleap</code>, i.e days in January or February? The modulus operation ensures that <code>d</code> for those days will be positive. IOW, <code>d = (daynum - 60 - isleap) % (365 + isleap)</code> rotates the calendar, putting January &amp; February at the end of the year, allowing us to exploit the 5 month pattern I mention above. It also allows us to ignore the fact that February is an extra-short month.</span>
<span class="comment-copy"><i>facepalm</i> Oh yea, negative numbers and all.. forgot about those :P.</span>
