<div class="post-text" itemprop="text">
<h3>Problem description</h3>
<p>Because of the fact that BeautifulSoup is returning a <code>soup object</code> or <code>None</code>, there have to be as much <code>if else</code> statements in a function as subsequent searches via <code>.find</code> or <code>.find_all</code> will occur.</p>
<h3>Question</h3>
<p>How can one avoid this by using a decorator (or a similar approach)?</p>
<h3>Example</h3>
<p>Lets say there are two different html sites (with these example snippets):</p>
<pre><code># example with wanted class in html file
&lt;td class='translation'&gt;
    &lt;span class='italiano'&gt;ciao&lt;/span&gt;
    &lt;span class='french'&gt;au revoir&lt;/span&gt;
    &lt;span class='polish'&gt;cześć&lt;/span&gt;
&lt;/td&gt;

# example without wanted class in another html file
&lt;td class='no_translation'&gt;
    foo
&lt;/td&gt;
</code></pre>
<p>If you doing the search below on snippets everything is ok for the first html snippet, but for the second you will get this:</p>
<pre><code>&gt;&gt;&gt; soup.find('td', class_='translation').find('span', class_='polish')
AttributeError: 'NoneType' object has no attribute 'find'
</code></pre>
<p>There are two obvious ways to handle this <code>AttributeError</code>:</p>
<pre><code># using if-else statements for every result of .find or .findall
def possibility_1():
    translation = soup.find('td', class_='translation')
    if translation:
        polish = translation.find('span', class_='polish')
        return polish
    return None

# use a try-except block for the problem
def possibility_2():
    try:
        translation = soup.find('td', class_='translation')
        polish = translation.find('span', class_='polish')
        return polish
    except AttributeError:
        return None
</code></pre>
<p>What about a third solution by using a decorator function for that? How can this be done?</p>
<pre><code>@decorator_name
def get_desired_result():
    translation = soup.find('td', class_='translation')
    polish = translation.find('span', class_='polish')
    return polish
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to the comments (nearly a discussion) made by <em>@jonrsharpe</em> and the answer by <em><a href="https://stackoverflow.com/questions/32122266/how-to-avoid-nested-if-else-statements-by-using-beautifulsoup-with-a-decorator/32127285#32127285">@Logan</a></em> I would stick to the decorator idea, but with getting information where the search will return <code>None</code>.</p>
<p>Here is my decorator as one possible solution.</p>
<pre><code>import sys
import inspect
from functools import wraps
from bs4 import BeautifulSoup

# Decorator with returning None and trace info if
# soup.find or soup.find_all fails at a certain point
def robust_soup(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except AttributeError:
            # just an example without formatting
            print inspect.getinnerframes(sys.exc_info()[2])
    return wrapper
</code></pre>
<p>now I can use</p>
<pre><code># a good working example
soup_good = BeautifulSoup("""
&lt;td class='translation'&gt;
    &lt;span class='italiano'&gt;ciao&lt;/span&gt;
    &lt;span class='french'&gt;au revoir&lt;/span&gt;
    &lt;span class='polish'&gt;cześć&lt;/span&gt;
&lt;/td&gt;""")

# an example which would lead to AttributeError if not handled
soup_bad = BeautifulSoup("""
&lt;td class='no_translation'&gt;
    something uninteresting
&lt;/td&gt;""")

@robust_soup
def get_desired_result(soup):
    translation = soup.find('td', class_='translation')
    polish = translation.find('span', class_='polish')
    print polish

&gt;&gt;&gt; # with a soup containing information
&gt;&gt;&gt; get_desired_result(soup_good)
&lt;span class='polish'&gt;cześć&lt;/span&gt;

&gt;&gt;&gt; # with a soup which normally fails
&gt;&gt;&gt; get_desired_result(soup_bad)
# some debugging output from inspect module (also
# with information where last error occured!)
None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of a decorator and manually checking for <code>None</code> via if/then, you might consider using your own function instead of <code>.find</code> and <code>.find_all</code>. </p>
<p>Also, there are 2 issues with returning plain-old <code>None</code>.</p>
<ul>
<li>You have no idea where the error is propagating from, so debugging would be hard.</li>
<li>After returning <code>None</code>, you might end up doing something like <code>soup.find_all("a")</code> or <code>link["href"]</code> on what is, in actuality, <code>None</code>. This wouldn't help you at all.</li>
</ul>
<p>So you might try something like this:</p>
<pre><code>class PseudoNone(object):
    """"
    You can call it.
    You can beat it with a stick.
    It will return PseudoNone!
    And you can trace where the None did come from!!"""
    debug = {}
    def __init__(self, created_at):
        PseudoNone.debug[self] = created_at
    def __getattr__(self, attr):
        return self
    def __call__(self, *args, **kwargs):
        return self
    def __getitem__(self, item):
        return self
    def __bool__(self):
        return False
</code></pre>
<p>This '<code>None</code>' shouldn't have those issues. Also, each instance is created with some identifier of what caused the <code>None</code>. All 'children <code>None</code>' caused by <code>PseudoNone.__call__</code> or <code>__getitem__</code> are really just the same object in memory, and thus have the same initial cause of failure in <code>PseudoNone.debug[obj]</code>. Good for debugging!</p>
<pre><code>from bs4 import BeautifulSoup

xml = """
&lt;td class='translation'&gt;
    &lt;span class='italiano'&gt;ciao&lt;/span&gt;
    &lt;span class='french'&gt;au revoir&lt;/span&gt;
    &lt;span class='polish'&gt;cześć&lt;/span&gt;
&lt;/td&gt;"""

def find_all(soup, *args, **kwargs):
    results = soup.find_all(*args, **kwargs)
    if not results:
        return PseudoNone((soup, args, kwargs))
    else:
        return results

def find(soup, *args, **kwargs):
    "As far as I know, BeautifulSoup.find is internally just BeautifulSoup.find_all(*args)[0]"
    results = find_all(soup, *args, **kwargs)
    return results[0]

soup = BeautifulSoup(xml)

translation = find(soup, 'td', class_='translation')

erroneous_translation = find(soup, 'td', class_='BADTRANSLATIONS')
</code></pre>
<p>...</p>
<pre><code>print translation
    &lt;td class="translation"&gt;
    &lt;span class="italiano"&gt;ciao&lt;/span&gt;
    &lt;span class="french"&gt;au revoir&lt;/span&gt;
    &lt;span class="polish"&gt;czeĹÄ&lt;/span&gt;
    &lt;/td&gt;

print erroneous_translation
    &lt;__main__.PseudoNone object at 0x7fd4bcc18790&gt;

print erroneous_translation("foo")
    &lt;__main__.PseudoNone object at 0x7fd4bcc18790&gt;

print erroneous_translation["baz"]
    &lt;__main__.PseudoNone object at 0x7fd4bcc18790&gt;

print find_all(erroneous_translation, "something")
    &lt;__main__.PseudoNone object at 0x7fd4bcc18790&gt;
</code></pre>
<p>Omg, this is a PseudoNone! That's not what I wanted. Where did I go wrong!!?</p>
<pre><code>print PseudoNone.debug[erroneous_translation]
    (&lt;html&gt;&lt;body&gt;&lt;td class="translation"&gt;
    &lt;span class="italiano"&gt;ciao&lt;/span&gt;
    &lt;span class="french"&gt;au revoir&lt;/span&gt;
    &lt;span class="polish"&gt;czeĹÄ&lt;/span&gt;
    &lt;/td&gt;&lt;/body&gt;&lt;/html&gt;, ('td',), {'class_': 'BADTRANSLATIONS'})
</code></pre>
<p>Notes:</p>
<ul>
<li>Use <code>isinstance(qux, PseudoNone)</code>, not <code>==None</code>. (We can't subclass<code>NoneType</code>)</li>
<li>If <code>PseudoNone.debug</code> gets too large for memory, consider hashing the <code>*args</code> and <code>**kwargs</code> in the values of PseudoNone.debug (and/or making use of <code>@functools.lru_cache</code> in python3)</li>
<li>This might be a hack.</li>
</ul>
</div>
<span class="comment-copy">You mean like <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="nofollow noreferrer"><code>contextlib.suppress</code></a>? Where is <b>your attempt</b> to implement <code>decorator_name</code>, and what is the problem with it?</span>
<span class="comment-copy">@jonrsharpe Thanks for the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.suppress" rel="nofollow noreferrer"><code>contextlib.supress</code></a>, but this works only for python &gt;= 3.4 (using 2.7). But I see, there are also possibilites with <a href="https://docs.python.org/2/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer"><code>contextlib.contextmanager</code></a>. It's little more complicated. There is yet no attempt of implementation for <code>decorator_name</code>, because I'm not sure if it's the best idea, at all. Is it more like a matter of taste using decorators or is it a good way for what I want? If yes, I can try to provide an attempt.</span>
<span class="comment-copy">What's the actual problem with using <code>try</code> and <code>except</code>?</span>
<span class="comment-copy">@jonrsharpe I will have many functions like <code>get_desired_result</code> and I don't want to write <code>try</code> and <code>except</code> for each of them. I would like to have a general solution for that with reusable code for all projects. But setting <code>try</code> and <code>except</code> maybe could be done in a decorator function to fulfill my requirements, right?</span>
<span class="comment-copy">Yes, you could do it with a decorator.</span>
<span class="comment-copy">This is quite an interesting solution. I'm not sure what <code>def __bool__(self)</code> is for. Finally, it's not really what I want, because imo it's more like a hack (ok, you mentioned it). I will keep on the decorator idea by providing an example in my edited question. I think I solved the debugging problem by using <a href="https://docs.python.org/2/library/inspect.html#the-interpreter-stack" rel="nofollow noreferrer"><code>inspect</code></a>. The second issue is apart from my problem here. For me, It's ok to have NoneType at the end of my function without proofing that each time I'm searching inside the function.</span>
