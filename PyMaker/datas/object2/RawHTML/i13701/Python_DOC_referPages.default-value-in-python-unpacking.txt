<div class="post-text" itemprop="text">
<p>Is there a way to have a default value if the number of values to unpack is too little compared to the variable list?</p>
<p>For example:</p>
<pre><code>a, b, c = read_json(request)
</code></pre>
<p>This works if <code>read_json</code> returns an array of three or more variable. If it only returns two, I get an exception while assigning <code>c</code>. So, is there a way to set <code>c</code> to a default value if it can't be unpacked properly? Something like:</p>
<pre><code>a, b, (c=2) = read_json(request)
</code></pre>
<p>Which is similar to what you do when defining a function with default arguments.</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try <code>*</code> unpacking with some post-processing:</p>
<pre><code>a, b, *c = read_json(request)
c = c[0] if c else 2
</code></pre>
<p>This will assign <code>a</code> and <code>b</code> as normal. If <code>c</code> is assigned something, it will be a <code>list</code> with one element. If only two values were unpacked, it will be an empty <code>list</code>. The second statement assigns to <code>c</code> its first element if there is one, or the default value of <code>2</code> otherwise.</p>
<pre><code>&gt;&gt;&gt; a, b, *c = 1, 2, 3
&gt;&gt;&gt; c = c[0] if c else 2
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
2
&gt;&gt;&gt; c
3
&gt;&gt;&gt; a, b, *c = 1, 2
&gt;&gt;&gt; c = c[0] if c else 2
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
2
&gt;&gt;&gt; c
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow noreferrer">chain function from itertools</a>, which is part of the Python standard library. It serve as default filler in case if there are no values in the first list. 'defaults' list variable in my example can have number of different values for each variable that you unpack (in an example I have default value for all three values as 0).</p>
<pre><code>from itertools import chain

defaults = [0] * 3
data = []

a, b, c, *_ = chain(data, defaults)
print(a, b, c)

data.append(1)
a, b, c, *_ = chain(data, defaults)
print(a, b, c)

data.append(2)
a, b, c, *_ = chain(data, defaults)
print(a, b, c)

data.append(3)
a, b, c, *_ = chain(data, defaults)
print(a, b, c)

data.append(4)
a, b, c, *_ = chain(data, defaults)
print(a, b, c)
</code></pre>
<p>Outputs:</p>
<pre><code>0 0 0
1 0 0
1 2 0
1 2 3
1 2 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In answer to the question no you can't do that.</p>
<p>Furthermore I would recommend against returning different numbers of arguments from functions - this will only cause compilcations further issues down the line (this question case in point).  Everytime you call that function you will need to test if there were 2 or 3 values returned. (Unpacking could be useful here, but you will still need to check those returned variables). eg:</p>
<pre><code>a, b, *others = read_json(request)
if others:
    c = others[0]
</code></pre>
<p>It would make more sense, assuming read_json is your function, if the function can return a dict with the default values set:</p>
<pre><code>def read_json(request):
    ret = { 'c': 2 }
    # ... set 'a' and 'b' and 'c' if possible

    return ret

res = read_json(request)
c = res['c']
</code></pre>
</div>
<span class="comment-copy">is <code>read_json()</code> your own function? If so, why cannot you make sure it always returns 3 values?</span>
<span class="comment-copy">No, there isn't; you need to make sure you get three values back, or pad and slice on the right-hand side of the assignment.</span>
<span class="comment-copy">You could go with <code>*</code> unpacking, e.g. <code>a, b, *c = read_json(request)</code>, where unpacking only two values would result in <code>c</code> being an empty <code>list</code>, but if you really need specific values, it's better to have the function <code>return</code> something a little more rigorous.</span>
<span class="comment-copy">@TigerhawkT3 and only in Python 3.x</span>
<span class="comment-copy">@jonrsharpe - of course in Python 3... everyone uses Python 3... right? Please? :P</span>
<span class="comment-copy">Doesn't work on Python 2</span>
