<div class="post-text" itemprop="text">
<p>I'm creating a game that is supposed to run on the command line. The game uses text as a the canvas ( the software prints text in a shape of a rectangle, and when the text changes, the image changes). I've created a little scrip to test how this would work</p>
<pre><code>import os

# function for printing out the game display grid
def printgrid(input):
    for i in range(len(input)):
        for j in range(len(input[0]):
            print(input[i][j], end='')
        print('') # newline after each row

grid = [['#' for x in range(10)] for x in range(10)]
while (True):
    # refresh the screen and reprint
    os.system('clear')
    printgrid(grid)
</code></pre>
<p>Unfortunately the code seems to be printing the grid too slowly resulting in a noticable scrolling effect during the printing, which would make the game unplayable.</p>
<ol>
<li><p>Is there a faster way to print text in python?</p></li>
<li><p>Could the cause of this scrolling effect just be the fact that I have not made any framerate cap on this code, and it just happens to show the current output when the computer monitor refreshes?</p></li>
<li>If my approach is completely wrong, what would be the best way to do this?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Printing to the console is usually slow, since most languages tend to wait until the message is displayed before moving on. There are ways around thid with your current approach.</p>
<p>If you use the file API, via <code>sys.stdout</code>, you can <code>write()</code> as many times as you want and call <code>flush()</code> when the screen is ready to be printed. You may also try calling <code>write()</code> as little as possible, perhaps building strings in memory and outputting them whole.</p>
<p>The frame-rate cap is definitely needed, though. The console is not a fast interface, it can't do high frame-rates. Implement a cap, and play with the number.</p>
<p>In short:</p>
<ul>
<li>Call <code>write()</code> as little as possible</li>
<li>Call <code>flush()</code> only when you're ready to render</li>
<li>Cap the frame-rate at 10, then 20, then 30. Experiment</li>
</ul>
<p>The other approach, which will <strong>definitely</strong> bring your game up to speed, is to use <code>ncurses</code>. With it, you can update only the portions of the screen that need re-rendering, instead of reprinting the screen whole.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.3 print() supports the keyword argument "flush" (<a href="https://docs.python.org/3/library/functions.html?highlight=print#print" rel="nofollow">see documentation</a>):</p>
<pre><code>print('Hello World!', flush=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're using a Unix-like OS (Linux or Mac) then the best way to do this would be using curses ( <a href="https://docs.python.org/3/howto/curses.html" rel="nofollow">https://docs.python.org/3/howto/curses.html</a> ). However, this can be a lot of effort and would probably be overkill for what you're doing.</p>
<p>If you choose to go the simple route, then you should put a delay in your repainting. Right now you're clearing immediately after finishing putting everything on the screen, which is giving you problems. Instead, you can do something like this:</p>
<pre><code>from time import sleep
while (True):
    # refresh the screen and reprint
    os.system('clear')
    printgrid(grid)

    sleep(0.1)    # sleep 0.1 seconds before clear
</code></pre>
<p>What this will do is leave the text on the screen for longer before repainting which will make it easier to see. Play with the amount of time you sleep and find what looks best for your application.</p>
</div>
<span class="comment-copy">I would join every thing and call <code>print</code> only once: <code>print('\n'.join(''.join(j) for j in input))</code></span>
<span class="comment-copy">also, on cross platform clear: <a href="http://stackoverflow.com/a/684344/671543">stackoverflow.com/a/684344/671543</a></span>
<span class="comment-copy">ncurses is absolutely the answer to this problem</span>
