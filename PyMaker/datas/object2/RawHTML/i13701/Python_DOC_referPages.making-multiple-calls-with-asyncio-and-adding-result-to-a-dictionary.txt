<div class="post-text" itemprop="text">
<p>I am having trouble wrapping my ahead around Python 3's Asyncio library. I have a list of zipcodes and I am trying to make async calls to an API to get each zipcodes corresponding city and state. I can do it successfully in sequence with a for loop but I want to make it faster in the case of a big zipcode list.</p>
<p>This is an example of my original that works</p>
<pre><code>import urllib.request, json

zips = ['90210', '60647']

def get_cities(zipcodes):
    zip_cities = dict()
    for idx, zipcode in enumerate(zipcodes):
        url = 'http://maps.googleapis.com/maps/api/geocode/json?address='+zipcode+'&amp;sensor=true'
        response = urllib.request.urlopen(url)
        string = response.read().decode('utf-8')
        data = json.loads(string)
        city = data['results'][0]['address_components'][1]['long_name']
        state = data['results'][0]['address_components'][3]['long_name']
        zip_cities.update({idx: [zipcode, city, state]})
    return zip_cities

results = get_cities(zips)
print(results)
# returns {0: ['90210', 'Beverly Hills', 'California'],
#          1: ['60647', 'Chicago', 'Illinois']}
</code></pre>
<p>This is my terrible non-functional attempt at trying to make it async</p>
<pre><code>import asyncio
import urllib.request, json

zips = ['90210', '60647']
zip_cities = dict()

@asyncio.coroutine
def get_cities(zipcodes):
    url = 'http://maps.googleapis.com/maps/api/geocode/json?address='+zipcode+'&amp;sensor=true'
    response = urllib.request.urlopen(url)
    string = response.read().decode('utf-8')
    data = json.loads(string)
    city = data['results'][0]['address_components'][1]['long_name']
    state = data['results'][0]['address_components'][3]['long_name']
    zip_cities.update({idx: [zipcode, city, state]})

loop = asyncio.get_event_loop()
loop.run_until_complete([get_cities(zip) for zip in zips])
loop.close()
print(zip_cities) # doesnt work
</code></pre>
<p>Any help is much appreciated. All of the tutorials I've come across online seem to be a tad over my head.</p>
<p>Note: I've seen some examples use <code>aiohttp</code>. I was hoping to stick with the native Python 3 libraries if possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're not going to be able to get any concurrency if you use <code>urllib</code> to do the HTTP request, because it's a synchronous library. Wrapping the function that calls into <code>urllib</code> in a <code>coroutine</code> doesn't change that. You have to use an asynchronous HTTP client that's integrated into <code>asyncio</code>, like <code>aiohttp</code>:</p>
<pre><code>import asyncio
import json
import aiohttp

zips = ['90210', '60647']
zip_cities = dict()

@asyncio.coroutine
def get_cities(zipcode,idx):
    url = 'https://maps.googleapis.com/maps/api/geocode/json?key=abcdfg&amp;address='+zipcode+'&amp;sensor=true'
    response = yield from aiohttp.request('get', url)
    string = (yield from response.read()).decode('utf-8')
    data = json.loads(string)
    print(data)
    city = data['results'][0]['address_components'][1]['long_name']
    state = data['results'][0]['address_components'][3]['long_name']
    zip_cities.update({idx: [zipcode, city, state]})

if __name__ == "__main__":        
    loop = asyncio.get_event_loop()
    tasks = [asyncio.async(get_cities(z, i)) for i, z in enumerate(zips)]
    loop.run_until_complete(asyncio.wait(tasks))
    loop.close()
    print(zip_cities)
</code></pre>
<p>I know you prefer to only use the stdlib, but the <code>asyncio</code> library doesn't include an HTTP client, so you'd have to basically re-implement pieces of <code>aiohttp</code> to recreate the functionality its providing. I suppose another option would be to make the <code>urllib</code> calls in a background thread, so that they don't block the event loop, but its kind of silly to do when <code>aiohttp</code> is available (and sort of defeats the purpose of using <code>asyncio</code> in the first place):</p>
<pre><code>import asyncio
import json
import urllib.request
from concurrent.futures import ThreadPoolExecutor

zips = ['90210', '60647']
zip_cities = dict()

@asyncio.coroutine
def get_cities(zipcode,idx):
    url = 'https://maps.googleapis.com/maps/api/geocode/json?key=abcdfg&amp;address='+zipcode+'&amp;sensor=true'
    response = yield from loop.run_in_executor(executor, urllib.request.urlopen, url)
    string = response.read().decode('utf-8')
    data = json.loads(string)
    print(data)
    city = data['results'][0]['address_components'][1]['long_name']
    state = data['results'][0]['address_components'][3]['long_name']
    zip_cities.update({idx: [zipcode, city, state]})

if __name__ == "__main__":
    executor = ThreadPoolExecutor(10)
    loop = asyncio.get_event_loop()
    tasks = [asyncio.async(get_cities(z, i)) for i, z in enumerate(zips)]
    loop.run_until_complete(asyncio.wait(tasks))
    loop.close()
    print(zip_cities)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not done much with asyncio but <code>asyncio.get_event_loop()</code> should be  what you need, you also obviously have to change what your function takes as arguments and use <code>asyncio.wait(tasks)</code> as per the <a href="https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks" rel="nofollow">docs</a>:</p>
<pre><code>zips = ['90210', '60647']
zip_cities = dict()

@asyncio.coroutine
def get_cities(zipcode):
    url = 'https://maps.googleapis.com/maps/api/geocode/json?key=abcdefg&amp;address='+zipcode+'&amp;sensor=true'
    fut = loop.run_in_executor(None,urllib.request.urlopen, url)
    response = yield  from fut
    string = response.read().decode('utf-8')
    data = json.loads(string)
    city = data['results'][0]['address_components'][1]['long_name']
    state = data['results'][0]['address_components'][3]['long_name']
    zip_cities.update({idx: [zipcode, city, state]})

loop = asyncio.get_event_loop()
tasks = [asyncio.async(get_cities(z, i)) for i, z in enumerate(zips)]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
print(zip_cities) # doesnt work
{0: ['90210', 'Beverly Hills', 'California'], 1: ['60647', 'Chicago', 'Illinois']}
</code></pre>
<p>I don't have &gt;= 3.4.4 so I had to use <code>asyncio.async</code> instead of <code>asyncio.ensure_future</code></p>
<p>Or change the logic and create the dict from  task.result from the tasks:</p>
<pre><code>@asyncio.coroutine
def get_cities(zipcode):
    url = 'https://maps.googleapis.com/maps/api/geocode/json?key=abcdefg&amp;address='+zipcode+'&amp;sensor=true'
    fut = loop.run_in_executor(None,urllib.request.urlopen, url)
    response = yield  from fut
    string = response.read().decode('utf-8')
    data = json.loads(string)
    city = data['results'][0]['address_components'][1]['long_name']
    state = data['results'][0]['address_components'][3]['long_name']
    return [zipcode, city, state]

loop = asyncio.get_event_loop()
tasks = [asyncio.async(get_cities(z)) for z in zips]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
zip_cities = {i:tsk.result() for i,tsk in enumerate(tasks)}
print(zip_cities)
{0: ['90210', 'Beverly Hills', 'California'], 1: ['60647', 'Chicago', 'Illinois']}
</code></pre>
<p>If you are looking at outside modules there is also a <a href="https://github.com/rdbhost/yieldfromRequests" rel="nofollow">port of requests</a> that works with asyncio.</p>
</div>
<span class="comment-copy">Thanks for this. The <code>aiohttp</code> way is much cleaner.</span>
<span class="comment-copy">@anthony-dandrea If your zip code list is going to be HUGE, I'd also recommend limiting the number simultaneous requests to a sane number like a 100 connections or so, otherwise you might end up getting blocked. <i>Not</i> speaking from experience ;-]</span>
<span class="comment-copy">This is still synchronous, because <code>urllib.request.urlopen</code> will block the event loop.</span>
<span class="comment-copy">@dano, yes, I overlooked that, not a big change to get it working.</span>
