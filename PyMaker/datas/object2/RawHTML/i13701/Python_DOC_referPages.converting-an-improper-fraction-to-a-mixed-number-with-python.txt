<div class="post-text" itemprop="text">
<p>I need to us python to convert an improper fraction to a mixed number or even a float to a mixed number. My code is as follows:</p>
<pre><code>from fractions import Fraction
numerator = int(input("Enter numerator ") )
denominator = int(input("Enter denominator ") )
num = numerator / denominator
num = Fraction(num) 
print(num)
</code></pre>
<p>If input is 5 and 4, the output is '5/4' not a mixed number.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the divide and modulo operators to print this:</p>
<p>The integer part is <code>numerator // denominator</code>.</p>
<p>The numerator of the proper fraction remainder is <code>numerator % denominator</code>.</p>
<p>And, of course, the denominator doesn't change.</p>
<pre><code>&gt;&gt;&gt; num = 5
&gt;&gt;&gt; den = 4
&gt;&gt;&gt; print(' %d %d/%d' % (num // den, num % den, den))
 1 1/4
</code></pre>
<p>Floats are a bit more difficult, because you have to figure out the denominator, and it's usually not going to be exact.  There are two basic ways (and several fancier variants) to do this.  You can either loop up to a maximum denominator and pick the one that gives you the lowest error, or you can choose a maximum acceptable error, and loop until you find a denominator that gives you a result below it.  Sample code to do the latter is as follows:</p>
<pre><code>def approximate_frac(src, epsilon):
    d = 0.0
    while 1:
        d += 1.0
        n = int(src * d)
        info = [(abs(n / d - src), n) for n in (n, n+1)]
        info.sort()
        err, n = info[0]
        if err &lt; epsilon:
            return n, int(d)

print(approximate_frac(1.0/3.0, 0.001))
print(approximate_frac(2.0/17.0, 0.001))
</code></pre>
<p>This results in:</p>
<pre><code>(1, 3)
(2, 17)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-python prettyprint-override"><code>from fractions import Fraction
def convert_to_mixed_numeral(num):
    """Format a number as a mixed fraction.

    Examples:
        convert_to_mixed_numeral('-55/10') # '-5 1/2'
        convert_to_mixed_numeral(-55/10) # '-5 1/2'
        convert_to_mixed_numeral(-5.5) # '-5 1/2'

    Args:
        num (int|float|str): The number to format. It is coerced into a string.

    Returns:
        str: ``num`` formatted as a mixed fraction.

    """
    num = Fraction(str(num)) # use str(num) to prevent floating point inaccuracies
    n, d = (num.numerator, num.denominator)
    m, p = divmod(abs(n), d)
    if n &lt; 0:
        m = -m
    return '{} {}/{}'.format(m, p, d) if m != 0 and p &gt; 0 \
        else '{}'.format(m) if m != 0 \
        else '{}/{}'.format(n, d)
</code></pre>
<p>The function can be used by passing it the numerator and denominator as a number, string, or Fraction instance. Or it could be modified to take in the numerator and denominator as separate variables.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try to implement it manually:</p>
<pre><code>  a = numerator // denominator 
  b = numerator % denominator
  print '{} {}/{}'.format(a, b, denominator)
</code></pre>
<p>Currently you are just printing 'x/b', if the input is a float do the adequate translation first.</p>
<p>Hope it can help.</p>
</div>
<span class="comment-copy">If you're just asking because you're looking for a way to represent precise non-whole numbers (e.g. without floating point inaccuracies) in a more comprehensible way to humans, while still storing them precisely, you might consider using <code>Decimal()</code> instead of, or in addition to, <code>fractions.Fraction()</code>. True, you won't 'see' the exact precision of say the square root of 2, but you'll be able to store the exact values, I believe, and you can use other methods to round to whatever digit you want with accuracy, for display.</span>
<span class="comment-copy">Thank you so much!</span>
<span class="comment-copy">You can use <code>Fraction</code> to get the denominator of a <code>float</code> or the string representation of a float.  For example, <code>f = Fraction('3.14159265359'); f.numerator; f.denominator</code>.</span>
<span class="comment-copy">Also, you can use <a href="https://docs.python.org/3/library/fractions.html#fractions.Fraction.limit_denominator" rel="nofollow noreferrer">Fraction.limit_denominator(max_denominator)</a> to find the closest Fraction that has a denominator which is at most <code>max_denominator</code>. The method appears to use <a href="https://en.wikipedia.org/wiki/Continued_fraction" rel="nofollow noreferrer">continued fractions</a>, so the approximation is as good as it can be for a denominator in that neighbourhood. Eg, 3.141592653589793 (an approximation of pi) when converted with a <code>max_denominator</code> of 35000 is 104348 / 33215 =  3.1415926539214212, which is accurate to 10 digits.</span>
<span class="comment-copy">I'm not clear on your code, as it gives me errors. I re-wrote the code how I think you intended it, but I'm not sure. Is this what you meant? <a href="https://pastebin.com/guSw1mQk" rel="nofollow noreferrer">pastebin.com/guSw1mQk</a></span>
<span class="comment-copy">Thanks @Shule. I updated the answer.</span>
<span class="comment-copy">There's also <code>a, b = divmod(numerator, denominator)</code> to get both in one function call.</span>
<span class="comment-copy">Negative numbers will be off by one using <code>//</code>.</span>
