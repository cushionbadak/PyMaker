<div class="post-text" itemprop="text">
<p>I'm getting confused by using Mock in my python unittests. I've made this simplified version of my problem:</p>
<p>I have this dummy class and methods:</p>
<pre><code># app/project.py

class MyClass(object):

    def method_a(self):
        print FetcherA
        results = FetcherA()
</code></pre>
<p>Which is using this class:</p>
<pre><code># app/fetch.py

class FetcherA(object):
    pass
</code></pre>
<p>And then this test:</p>
<pre><code># app/tests/test.py

from mock import patch
from django.test import TestCase
from ..project import MyClass

class MyTestCase(TestCase):

    @patch('app.fetch.FetcherA')
    def test_method_a(self, test_class):
        MyClass().method_a()
        test_class.assert_called_once_with()
</code></pre>
<p>I would expect that running this test would pass and that <code>print</code> statement, for debugging, would output something like <code>&lt;MagicMock name=...&gt;</code>. Instead it prints out <code>&lt;class 'app.fetch.FetcherA'&gt;</code> and I get:</p>
<pre><code>AssertionError: Expected to be called once. Called 0 times.
</code></pre>
<p>Why isn't <code>FetcherA</code> being patched?</p>
</div>
<div class="post-text" itemprop="text">
<p>OK, fourth time through I think I understood the <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="noreferrer">'Where to patch'</a> section of the Mock docs.</p>
<p>So, instead of:</p>
<pre><code>    @patch('app.fetch.FetcherA')
</code></pre>
<p>I should use:</p>
<pre><code>    @patch('app.project.FetcherA')
</code></pre>
<p>Because we're testing the code in <code>app.project.MyClass</code> where <code>FetcherA</code> has been imported already. So at that point <code>FetcherA</code> is availably globally(?) within <code>app.project</code>.</p>
</div>
<span class="comment-copy">Such a small but profound difference.</span>
