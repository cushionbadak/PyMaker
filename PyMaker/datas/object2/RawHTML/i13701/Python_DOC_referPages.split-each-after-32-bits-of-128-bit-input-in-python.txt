<div class="post-text" itemprop="text">
<p>I am trying to do 128 bit manipulation in Python, to split the 128 bit after 32 bit</p>
<pre><code>var = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF # var may take any value from 0x0 to  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</code></pre>
<p>I have tried the </p>
<pre><code>n = 8 # for 32 bit splitting
[var[i:i+n] for i in range(0, len(var), n)]
</code></pre>
<p>But there is no built-in length operator to find the length for <code>long</code> variable. I researched bitarray module, I don't want to use bit array in my code, is there any thing in pythonic way?</p>
<p>Expected output would be <code>[0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF]</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use bit shifting (<code>&gt;&gt;</code>) and bitwise AND (<code>&amp;</code>):</p>
<pre><code>In [10]: [(i &gt;&gt; x) &amp; 0xFFFFFFFF for x in reversed(range(0, 128, 32))]
Out[10]: [4294967295, 4294967295, 4294967295, 4294967295]
</code></pre>
<p>where <code>i</code> is your integer. The resulting list will have 4 elements (because <em>128 / 32</em> is <em>4</em>).</p>
<p>In your case the result is 4 equal numbers (<em>4294967295</em>, because <em>4294967295</em> is <em>0xFFFFFFFF</em> in hex).</p>
<p>This works well for a known number of bits (32), but I'd rather use a helper function (following the same logic as above):</p>
<pre><code>def split_bits(value, n):
    ''' Split `value` into a list of `n`-bit integers '''
    mask, parts = (1 &lt;&lt; n) - 1, []
    parts = []
    while value:
        parts.append(value &amp; mask)
        value &gt;&gt;= n
    parts.reverse()
    return parts
</code></pre>
<p>In action:</p>
<pre><code>In [14]: split_bits(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, 32)
Out[14]: [4294967295, 4294967295, 4294967295, 4294967295]

In [15]: [format(i, 'X') for i in _] # show corresponding hex representations
Out[15]: ['FFFFFFFF', 'FFFFFFFF', 'FFFFFFFF', 'FFFFFFFF']

In [16]: split_bits(0b1000100110101011, 4)
Out[16]: [8, 9, 10, 11]

In [17]: [format(i, 'b') for i in _] # show corresponding binary representations
Out[17]: ['1000', '1001', '1010', '1011']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>it's better to work with numbers instead of stirng</p>
<pre><code>var = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
[(var &amp; (0xFFFFFFFF &lt;&lt; 32*i)) &gt;&gt; (32*i) for i in range(4)]
</code></pre>
<p>eventually you can conver number to string hex representation</p>
<pre><code>format(n, 'x')
</code></pre>
</div>
<span class="comment-copy">Do you mean <code>[0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF]</code>? And are you declaring <code>var</code> with quotes?</span>
<span class="comment-copy">No, I just edited my question please look into it</span>
<span class="comment-copy">Can you use python3 instead of python2?</span>
<span class="comment-copy">Trengo Thanks !! Good to know, I will switch to python 3</span>
<span class="comment-copy">Thanks a lot. is it possible to find the length of long Interger? I may need it for future, is there any possible way?</span>
<span class="comment-copy">@Jonny yes, see <a href="https://docs.python.org/3/library/stdtypes.html#int.bit_length" rel="nofollow noreferrer"><code>int.bit_length</code></a>.</span>
<span class="comment-copy">I have already tried it, but I am puzzled its throwing this error TypeError: descriptor 'bit_length' requires a 'int' object but received a 'long'.</span>
<span class="comment-copy">@Jonny hmm, what's the version of your Python interpreter?</span>
<span class="comment-copy">Just throwing this out there, but splitting a negative value in this way produces an endless loop. <code>split_bits(-1)</code> Due to the way that Python represents numbers.</span>
<span class="comment-copy">Thankew so much farincz. I have edited my problem statement please look into it</span>
