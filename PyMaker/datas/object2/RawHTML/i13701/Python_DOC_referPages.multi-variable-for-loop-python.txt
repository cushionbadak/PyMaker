<div class="post-text" itemprop="text">
<p>I know that you can do nested for loops, for example:</p>
<pre><code>for ch in a:
    for ch2 in ch:
        print(ch2)
</code></pre>
<p>However, I've seen for loops that go like this:</p>
<pre><code>for ch, ch2 in a:
    # blah blah
</code></pre>
<p>Are these two loops equivalent? Or does the second loop do something different than the first?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, they are not.</p>
<p>The second is an example of <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow">multiple assignment</a>. If you assign to a tuple, Python unpacks the values of an iterable into the names you gave.</p>
<p>The second loop is rather equivalent to this:</p>
<pre><code>for seq in a:
    ch = seq[0]
    ch2 = seq[1]
    # blah blah
</code></pre>
<p>As @Kasramvd points out in a comment to your question, this only works if <code>a</code> is a sequence with the correct number of items. Otherwise, Python will raise a <code>ValueError</code>.</p>
<hr/>
<p>Edit to address <code>dict</code> iteration (as brought up in comment):</p>
<p>When you iterate over a Python <code>dict</code> using the normal <code>for x in y</code> syntax, <code>x</code> is the <em>key</em> relevant to each iteration.</p>
<pre><code>for x in y:   # y is a dict
    y[x]      # this retrieves the value because x has the key
</code></pre>
<p>The type of loop you are talking about is achieved as follows:</p>
<pre><code>for key, val in y.items():
    print(key, 'is the key')
    print('y[key] is', val)
</code></pre>
<p>This is still the same kind of unpacking as described above, because <code>dict.items</code> gives you a <em>list of tuples</em> corresponding to the <code>dict</code> contents. That is:</p>
<pre><code>d = {'a': 1, 'b': 2}
print(d.items())    # [('a', 1), ('b', 2)]
</code></pre>
</div>
<span class="comment-copy">They are not same.The first loop will gives a product of your iterable's items since the second one is just a multi-assignment loop which iterates over iterable <code>a</code> only works if <code>a</code> has duplex items.</span>
<span class="comment-copy">So when you do a loop, does ch go forwards from seq[0] onwards while seq[1] moves onwards from [1] ? I'm working with a dictionary here and so I'm a tad confused on the interaction of unpacking; would having two assigned variables here present the key and its value?</span>
<span class="comment-copy">@Hackxx Updated my answer to address <code>dict</code> iteration and how the above notion fits into it.</span>
<span class="comment-copy">OHHH okay so because dict.items unpacks into a duplex element tuple, the multiple assignment targets the 0th and 1st element right?</span>
<span class="comment-copy">@Hackxx Yes, precisely. If you were to iterate like <code>for x in y.items()</code>, <code>x</code> would be a <i>tuple</i> each time, but since you provide two assignment targets, Python realizes and unpacks it for you so you have the individual elements.</span>
<span class="comment-copy">I see!! So if you were to (for some unknown reason) use the for x in y.items() loop, you would have to un-tuple everything in the end assuming you want the individual element?</span>
