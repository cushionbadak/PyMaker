<div class="post-text" itemprop="text">
<p>I have a text file and two lists of strings.</p>
<p>The first list is the keyword list</p>
<pre><code>k = [hi, bob]
</code></pre>
<p>The second list is the words I want to replace the keywords with</p>
<pre><code>r = [ok, bye]
</code></pre>
<p>I want to take the text file as input, where when k appears, it's replaced with r, thus, "hi, how are you bob" would be changed to "ok, how are you bye"</p>
</div>
<div class="post-text" itemprop="text">
<p>Let's say you have already parsed your sentence:</p>
<pre><code>sentence = ['hi', 'how', 'are', 'you', 'bob']
</code></pre>
<p>What you want to do is to check whether each word in this sentence is present in <code>k</code>. If yes, replace it by the corresponding element in r; else, use the actual word. In other words:</p>
<pre><code>if word in k:
    word_index = k.index(word)    
    new_word = r[word_index]
</code></pre>
<p>This can be written in a more concise way:</p>
<pre><code>new_word = r[k.index(word)] if word in k else word
</code></pre>
<p>Using list comprehensions, here's how you go about processing the whole sentence:</p>
<pre><code>new_sentence = [r[k.index(word)] if word in k else word for word in sentence]
</code></pre>
<p><code>new_sentence</code> is now equal to <code>['ok', 'how', 'are', 'you', 'bye']</code> (which is what you want).</p>
<p>Note that in the code above we perform two equivalent search operations: <code>word in k</code> and <code>k.index(word)</code>. This is inefficient. These two operations can be reduced to one by catching exceptions from the <code>index</code> method:</p>
<pre><code>def get_new_word(word, k, r):
    try:
        word_index = k.find(word)
        return r[word_index]
    except ValueError:
        return word

new_sentence = [get_new_word(word, k, r) for word in sentence]
</code></pre>
<p>Now, you should also note that searching for <code>word</code> in sentence is a search with <code>O(n)</code> complexity (where <code>n</code> is the number of keywords). Thus the complexity of this algorithm is <code>O(n.m)</code> (where is the sentence length). You can reduce this complexity to <code>O(m)</code> by using a more appropriate data structure, as suggested by the other comments. This is left as an exercise :-p</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll assume you've got the "reading string from file" part covered, so about that "replacing multiple strings" part: First, as suggested by Martijn, you can create a dictionary, mapping keys to replacements, using <a href="https://docs.python.org/3/library/functions.html#func-dict" rel="nofollow"><code>dict</code></a> and <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a>.</p>
<pre><code>&gt;&gt;&gt; k = ["hi", "bob"]
&gt;&gt;&gt; r = ["ok", "bye"]
&gt;&gt;&gt; d = dict(zip(k, r))
</code></pre>
<p>Now, one way to replace all those keys at once would be to use a regular expression, being a disjunction of all those keys, i.e. <code>"hi|bob"</code> in your example, and <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow">using <code>re.sub</code> with a replacement function</a>, looking up the respective key in that dictionary.</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub('|'.join(k), lambda m: d[m.group()], "hi, how are you bob")
'ok, how are you bye'
</code></pre>
<p>Alternatively, you can just use a loop to replace each key-replacement pair one after the other:</p>
<pre><code>s = "hi, how are you bob"
for (x, y) in zip(k, r):
    s = s.replace(x, y)
</code></pre>
</div>
<span class="comment-copy">Hint: look up about dictionaries first.</span>
<span class="comment-copy">Learn to walk before you can run: 1. Write code that read from text file, once succeed, then 2. Replace "hi" with "ok", if that works, 3. Move on to replace pairs of strings. If you are stuck at any stage, come back here and show your work.</span>
<span class="comment-copy">Have you found an answer to your problem?</span>
