<div class="post-text" itemprop="text">
<p>Hi so I'm trying to figure out how to create an iterator object using Python that would remove duplicates or more so omit duplicates.</p>
<p>For example I have a list (1, 2, 3, 3, 4, 4, 5) and I get (1, 2, 3, 4, 5)</p>
<p>I understand that in order to get an iterator object I have to create it. So:</p>
<pre><code>Class Unique:
    def __init__(self, n):
         self.i = 0
         self.n = n  

    def __iter__(self):
         return self

    def __next__(self):
        if self.i &lt; self.n:
</code></pre>
<p>I'm actually not entirely sure what to do next in this problem. Thanks in advance for any comments or help!</p>
</div>
<div class="post-text" itemprop="text">
<p>Better create a generator function, like this</p>
<pre><code>&gt;&gt;&gt; def unique_values(iterable):
...     seen = set()
...     for item in iterable:
...         if item not in seen:
...             seen.add(item)
...             yield item
... 
</code></pre>
<p>And then you can create a tuple of unique values, like this</p>
<pre><code>&gt;&gt;&gt; tuple(unique_values((1, 2, 3, 3, 4, 4, 5)))
(1, 2, 3, 4, 5)
</code></pre>
<hr/>
<p>If you know for sure that the data will be always sorted, then you can avoid creating the set and keep track of the previous data only, like this</p>
<pre><code>&gt;&gt;&gt; def unique_values(iterable):
...     it = iter(iterable)
...     previous = next(it)
...     yield previous
...     for item in it:
...         if item != previous:
...             previous = item
...             yield item
&gt;&gt;&gt; tuple(unique_values((1, 2, 3, 3, 4, 4, 5)))
(1, 2, 3, 4, 5)
</code></pre>
<hr/>
<p>You can write an iterator object, with a class, like this</p>
<pre><code>&gt;&gt;&gt; class Unique:
...     def __init__(self, iterable):
...         self.__it = iter(iterable)
...         self.__seen = set()
... 
...     def __iter__(self):
...         return self
... 
...     def __next__(self):
...         while True:
...             next_item = next(self.__it)
...             if next_item not in self.__seen:
...                 self.__seen.add(next_item)
...                 return next_item
... 
&gt;&gt;&gt; for item in Unique((1, 2, 3, 3, 4, 4, 5)):
...     print(item)
... 
1
2
3
4
5
</code></pre>
<p>You can refer <a href="https://stackoverflow.com/a/24377/1903116">this answer</a>, and the <a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow noreferrer">Iterator Types section in Python 3 Data Model documentation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If preserving original order is not important, simply use <code>set</code>: </p>
<pre><code>values = (1, 3, 2, 5, 4, 3)
unique_values = set(values)
print unique_values
(1, 2, 3, 4, 5)
</code></pre>
</div>
<span class="comment-copy">Why create a new class instead of using a <code>set</code> or subclassing <code>set</code>?</span>
<span class="comment-copy">It more of an exercise to implement using Iterator objects (for a quiz in my class) and it helps to understand how iterators work. I understand using 'set' as a built-in function but if someone could please help me in writing this it would be greatly appreciated.</span>
<span class="comment-copy">I understand how to create the generator function but I was wondering how to create an iterator object for the same method. I'm reviewing for a test so it would be really helpful!</span>
<span class="comment-copy">Keep in mind this assumes the items in <code>iterable</code> are hashable (so that they can be added to the set).</span>
<span class="comment-copy">@thefourtheye Thanks that makes a lot of sense and thanks for the refer answer!</span>
