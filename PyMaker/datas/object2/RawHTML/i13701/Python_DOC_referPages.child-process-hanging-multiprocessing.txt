<div class="post-text" itemprop="text">
<p>I am having a problem where child processes are hanging in my python application, only 4/16 processes have finished all of these processes are adding to a multiprocessing queue. <a href="https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues" rel="nofollow">https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues</a> According to python docs:</p>
<blockquote>
<p>Warning</p>
<p>As mentioned above, if a child process has put items on a queue (and
  it has not used JoinableQueue.cancel_join_thread), then that process
  will not terminate until all buffered items have been flushed to the
  pipe.</p>
<p>This means that if you try joining that process you may get a deadlock
  unless you are sure that all items which have been put on the queue
  have been consumed. Similarly, if the child process is non-daemonic
  then the parent process may hang on exit when it tries to join all its
  non-daemonic children.</p>
<p>Note that a queue created using a manager does not have this issue.
  See Programming guidelines.</p>
</blockquote>
<p>I believe this may be my problem, however I do a get() off the queue before I join.  I am not sure what other alternatives I can take.</p>
<pre><code>def RunInThread(dictionary):
    startedProcesses = list()
    resultList = list()
    output = Queue()
    scriptList = ThreadChunk(dictionary, 16) # last number determines how many threads

    for item in scriptList:
        if __name__ == '__main__':
            proc = Process(target=CreateScript, args=(item, output))
            startedProcesses.append(proc)
            proc.start()

    while not output.empty():
        resultList.append(output.get())

    #we must wait for the processes to finish before continuing
    for process in startedProcesses:
        process.join()
        print "finished"

#defines chunk of data each thread will process
def ThreadChunk(seq, num):
  avg = len(seq) / float(num)
  out = []
  last = 0.0

  while last &lt; len(seq):
    out.append(seq[int(last):int(last + avg)])
    last += avg

  return out

def CreateScript(scriptsToGenerate, queue):
    start = time.clock()
    for script in scriptsToGenerate:
    ...
        queue.put([script['timeInterval'], script['script']])

    print time.clock() - start
    print "I have finished"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The issue with your code is that <code>while not output.empty()</code> is <strong>not reliable</strong> (see <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.empty" rel="nofollow">empty</a>). You might also run into the scenario where the interpreter hits <code>while not output.empty()</code> before the processes you created finished their initialization (thus having the Queue actually empty).</p>
<p>Since you know exactly how much items will be put in the queue (i.e. <code>len(dictionnary)</code>) you can read that number of items from the queue:</p>
<pre><code>def RunInThread(dictionary):
    startedProcesses = list()
    output = Queue()
    scriptList = ThreadChunk(dictionary, 16) # last number determines how many threads

    for item in scriptList:
        proc = Process(target=CreateScript, args=(item, output))
        startedProcesses.append(proc)
        proc.start()

    resultList = [output.get() for _ in xrange(len(dictionary))]

    #we must wait for the processes to finish before continuing
    for process in startedProcesses:
        process.join()

    print "finished"
</code></pre>
<p>If at some point you're modifying your script and don't know anymore howmuch items will be produced, you can use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.get" rel="nofollow"><code>Queue.get</code></a> with a reasonnable timeout:</p>
<pre><code>def RunInThread(dictionary):
    startedProcesses = list()
    resultList = list()
    output = Queue()
    scriptList = ThreadChunk(dictionary, 16) # last number determines how many threads

    for item in scriptList:
        proc = Process(target=CreateScript, args=(item, output))
        startedProcesses.append(proc)
        proc.start()

    try:
        while True:
            resultList.append(output.get(True, 2)) # block for a 2 seconds timeout, just in case
    except queue.Empty:
        pass # no more items produced

    #we must wait for the processes to finish before continuing
    for process in startedProcesses:
        process.join()

    print "finished"
</code></pre>
<p>You might need to adjust the timeout depending on the actual time of the computation in your <code>CreateScript</code>.</p>
</div>
<span class="comment-copy">Why is that <code>if __name__ == '__main__'</code> inside your function and not at the module level exactly? (such as <code>if __name__ == '__main__': my_dict = {..}; RunInThread(my_dict)</code>)</span>
<span class="comment-copy">Should I not have it there?  I have only just started using python myself however it doesnt seem to be a problem as my processes still start</span>
<span class="comment-copy">Even though it is harmless to have it there when you execute your script, you will start having unexpected behaviour as soon as you import it. See <a href="http://stackoverflow.com/questions/419163/what-does-if-name-main-do" title="what does if name main do">stackoverflow.com/questions/419163/what-does-if-name-main-do</a>.</span>
<span class="comment-copy">Anyway, back to the question. It seems that <code>ThreadChunk</code> is of your writing. You might need to post that too. Same goes for <code>CreateScript</code>.</span>
<span class="comment-copy">I have tried your solution with the list comprehension, could it be that there is deadlock as I am trying to create files with all these threads and some of these files may have already been created?</span>
<span class="comment-copy">Your threads might possibly be hanging in your <code>CreateScript</code> process. But itâ€™s hard to tell since you shrinked it to <code>...</code>.</span>
<span class="comment-copy">I'll add the rest in</span>
<span class="comment-copy">I have added the rest of my code in without edits</span>
