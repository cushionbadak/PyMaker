<div class="post-text" itemprop="text">
<p>I write a lot of Python code that uses external libraries.  Frequently I will write a bug, and when I run the code I get a big long traceback in the Python console.  99.999999% of the time it's due to a coding error in my code, not because of a bug in the package.  But the traceback goes all the way to the line of error in the package code, and either it takes a lot of scrolling through the traceback to find the code I wrote, or the traceback is so deep into the package that my own code doesn't even appear in the traceback.</p>
<p>Is there a way to "black-box" the package code, or somehow only show traceback lines from my code?  I'd like the ability to specify to the system which directories or files I want to see traceback from.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to print your own stacktrace, you would need to handle all unhandled exceptions yourself; this is how the <a href="https://docs.python.org/2/library/sys.html#sys.excepthook" rel="nofollow"><code>sys.excepthook</code></a> becomes handy.</p>
<p>The signature for this function is <code>sys.excepthook(type, value, traceback)</code> and its job is:</p>
<blockquote>
<p>This function prints out a given traceback and exception to <code>sys.stderr</code>.</p>
</blockquote>
<p>So as long as you can play with the traceback and only extract the portion you care about you should be fine. Testing frameworks do that very frequently; they have custom <code>assert</code> functions which usually does not appear in the traceback, in other words they skip the frames that belong to the test framework. Also, in those cases, the tests usually are started by the test framework as well.</p>
<p>You end up with a traceback that looks like this:</p>
<p><code>[ custom assert code ]</code> + <code>... [ code under test ] ...</code> + <code>[ test runner code ]</code></p>
<h2>How to identify your code.</h2>
<p>You can add a global to your code:</p>
<pre><code>__mycode = True
</code></pre>
<p>Then to identify the frames:</p>
<pre><code>def is_mycode(tb):
  globals = tb.tb_frame.f_globals
  return globals.has_key('__mycode')
</code></pre>
<h2>How to extract your frames.</h2>
<ol>
<li>skip the frames that don't matter to you (e.g. custom assert code)</li>
<li>identify how many frames are part of your code -&gt; <code>length</code></li>
<li><p>extract <code>length</code> frames</p>
<pre><code>def mycode_traceback_levels(tb):
  length = 0
  while tb and is_mycode(tb):
    tb = tb.tb_next
    length += 1
  return length
</code></pre></li>
</ol>
<h2>Example handler.</h2>
<pre><code>def handle_exception(type, value, tb):
  # 1. skip custom assert code, e.g.
  # while tb and is_custom_assert_code(tb):
  #   tb = tb.tb_next
  # 2. only display your code
  length = mycode_traceback_levels(tb)
  print ''.join(traceback.format_exception(type, value, tb, length))
</code></pre>
<p>install the handler:</p>
<pre><code>sys.excepthook = handle_exception
</code></pre>
<h2>What next?</h2>
<p>You could adjust <code>length</code> to add one or more levels if you still want some info about where the failure is outside of your own code.</p>
<p>see also <a href="https://gist.github.com/dnozay/b599a96dc2d8c69b84c6" rel="nofollow">https://gist.github.com/dnozay/b599a96dc2d8c69b84c6</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As others suggested, you could use <a href="https://docs.python.org/3/library/sys.html#sys.excepthook" rel="nofollow"><code>sys.excepthook</code></a>:</p>
<blockquote>
<p>This function prints out a given traceback and exception to <em>sys.stderr</em>.</p>
<p>When an exception is raised and uncaught, the interpreter calls <em>sys.excepthook</em> with three arguments, the exception class, exception instance, and a traceback object. In an interactive session this happens just before control is returned to the prompt; in a Python program this happens just before the program exits. <strong>The handling of such top-level exceptions can be customized by assigning another three-argument function to <em>sys.excepthook</em></strong>.</p>
</blockquote>
<p>(emphasis mine)</p>
<p>It's possible to filter a traceback extracted by <code>extract_tb</code> (or similar functions from the <a href="https://docs.python.org/3/library/traceback.html" rel="nofollow"><code>traceback</code></a> module) based on specified directories.</p>
<p>Two functions that can help:</p>
<pre><code>from os.path import join, abspath
from traceback import extract_tb, format_list, format_exception_only

def spotlight(*show):
    ''' Return a function to be set as new sys.excepthook.
        It will SHOW traceback entries for files from these directories. '''
    show = tuple(join(abspath(p), '') for p in show)

    def _check_file(name):
        return name and name.startswith(show)

    def _print(type, value, tb):
        show = (fs for fs in extract_tb(tb) if _check_file(fs.filename))
        fmt = format_list(show) + format_exception_only(type, value)
        print(''.join(fmt), end='', file=sys.stderr)

    return _print

def shadow(*hide):
    ''' Return a function to be set as new sys.excepthook.
        It will HIDE traceback entries for files from these directories. '''
    hide = tuple(join(abspath(p), '') for p in hide)

    def _check_file(name):
        return name and not name.startswith(hide)

    def _print(type, value, tb):
        show = (fs for fs in extract_tb(tb) if _check_file(fs.filename))
        fmt = format_list(show) + format_exception_only(type, value)
        print(''.join(fmt), end='', file=sys.stderr)

    return _print
</code></pre>
<p>They both use the <a href="https://docs.python.org/3/library/traceback.html#traceback.extract_tb" rel="nofollow"><code>traceback.extract_tb</code></a>. It returns <em>"a list of “pre-processed” stack trace entries extracted from the traceback object"</em>; all of them are instances of <a href="https://docs.python.org/3/library/traceback.html#traceback.FrameSummary" rel="nofollow"><code>traceback.FrameSummary</code></a> (a named tuple). Each <code>traceback.FrameSummary</code> object has a <code>filename</code> field which stores the absolute path of the corresponding file. We check if it starts with any of the directory paths provided as separate function arguments to determine if we'll need to exclude the entry (or keep it).</p>
<hr/>
<p>Here's an <strong><em>Example</em></strong>:</p>
<p>The <code>enum</code> module from the standard library doesn't allow reusing keys, </p>
<pre><code>import enum
enum.Enum('Faulty', 'a a', module=__name__)
</code></pre>
<p>yields</p>
<pre class="lang-none prettyprint-override"><code>Traceback (most recent call last):
  File "/home/vaultah/so/shadows/main.py", line 23, in &lt;module&gt;
    enum.Enum('Faulty', 'a a', module=__name__)
  File "/home/vaultah/cpython/Lib/enum.py", line 243, in __call__
    return cls._create_(value, names, module=module, qualname=qualname, type=type, start=start)
  File "/home/vaultah/cpython/Lib/enum.py", line 342, in _create_
    classdict[member_name] = member_value
  File "/home/vaultah/cpython/Lib/enum.py", line 72, in __setitem__
    raise TypeError('Attempted to reuse key: %r' % key)
TypeError: Attempted to reuse key: 'a'
</code></pre>
<p>We can restrict stack trace entries to our code (in <em>/home/vaultah/so/shadows/main.py</em>).</p>
<pre><code>import sys, enum
sys.excepthook = spotlight('/home/vaultah/so/shadows')
enum.Enum('Faulty', 'a a', module=__name__)
</code></pre>
<p>and</p>
<pre><code>import sys, enum
sys.excepthook = shadow('/home/vaultah/cpython/Lib')
enum.Enum('Faulty', 'a a', module=__name__)
</code></pre>
<p>give the same result:</p>
<pre class="lang-none prettyprint-override"><code>  File "/home/vaultah/so/shadows/main.py", line 22, in &lt;module&gt;
    enum.Enum('Faulty', 'a a', module=__name__)
TypeError: Attempted to reuse key: 'a'
</code></pre>
<p>There's a way to exclude all site directories (where 3rd party packages are installed - see <a href="https://docs.python.org/3/library/site.html#site.getsitepackages" rel="nofollow"><code>site.getsitepackages</code></a>)</p>
<pre><code>import sys, site, jinja2
sys.excepthook = shadow(*site.getsitepackages())
jinja2.Template('{%}')
# jinja2.exceptions.TemplateSyntaxError: unexpected '}'
#     Generates ~30 lines, but will only display 4
</code></pre>
<blockquote>
<p><strong><em>Note:</em></strong> Don't forget to restore <em>sys.excepthook</em> from <em>sys.__excepthook__</em>. Unfortunately, you won't be able to "patch-restore" it using a context manager.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>the traceback.extract_tb(tb) would return a tuple of error frames in the format(file, line_no, type, error_statement) , you can play with that to format the traceback. Also refer <a href="https://pymotw.com/2/sys/exceptions.html" rel="nofollow">https://pymotw.com/2/sys/exceptions.html</a></p>
<pre><code>import sys
import traceback

def handle_exception(ex_type, ex_info, tb):
    print ex_type, ex_info, traceback.extract_tb(tb)

sys.excepthook = handle_exception
</code></pre>
</div>
<span class="comment-copy">You could catch the exception in main or lower, and decide what to print. Use the  traceback module. extract_tb() can be used to retrieve the values. You can look at them to decide what to print, and what not to.</span>
<span class="comment-copy">As an alternative that wouldn't require wrapping all your existing code in try/except blocks, you could do what <a href="http://pymotw.com/2/cgitb/" rel="nofollow noreferrer">cgitb</a> does and use <a href="https://docs.python.org/2/library/sys.html#sys.excepthook" rel="nofollow noreferrer">sys.excepthook</a> to get the desired results. There might even be a way to configure cgitb to do it, but I'm not sure. (Typically it's for <i>expanding</i> traceback output.)</span>
<span class="comment-copy">@Two-BitAlchemist, the sys.excepthook method looks great in general, but I'm trying to debug a Flask application.  I can't figure out, even in debug mode where it's own error handling system is bypassed, how to overwrite the default sys.excepthook.</span>
<span class="comment-copy">Could the guy who downvoted write a comment as what makes it worth a downvote  , please ?</span>
<span class="comment-copy">I see 2 users downvoted this answer. Strictly speaking, it does not really answer the question, as in the information presented here is insufficient to solve OP's problem. Maybe you'd clarify what <i>exactly</i> does the asker need to do, rather than vaguely advising to "play with traceback.extract_tb".</span>
<span class="comment-copy">thanks for the feedback , will keep in mind !</span>
