<div class="post-text" itemprop="text">
<p>I am trying to write a code that replicates greedy algorithm and for that I need to make sure that my calculations use the highest value possible. Potential values are presented in a dictionary and my goal is to use largest value first and then move on to lower values. However since dictionary values are not sequenced, in for loop I am getting unorganized sequences. For example, out put of below code would start from 25. </p>
<p>How can I make sure that my code is using a dictionary yet following the sequence of (500,100,25,10,5)? </p>
<pre><code>a={"f":500,"o":100,"q":25,"d":10,"n":5}  
for i in a:
    print a[i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Two ideas spring to mind:</p>
<ol>
<li><p>Use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.<strong>OrderedDict</strong></code></a>, a dictionary subclass which remembers the order in which items are added. As long as you add the pairs in descending value order, looping over this dict will return them in the right order.</p></li>
<li><p>If you can't be sure the items will be added to the dict in the right order, you could construct them by sorting:</p>
<ul>
<li>Get the values of the dictionary with <code>values()</code></li>
<li>Sort by (ascending) value: this is <code>sorted()</code>, and Python will default to sorting in ascending order</li>
<li>Get them by descending value instead: this is <code>reverse=True</code></li>
</ul>
<p>Here's an example:</p>
<pre><code>for value in sorted(a.values(), reverse=True):
    print value
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries yield their keys when you iterate them normally, but you can use the <a href="https://docs.python.org/3.4/library/stdtypes.html#dict.items" rel="nofollow">items()</a> view to get tuples of the key and value. That'll be un-ordered, but you can then use <a href="https://docs.python.org/3.4/library/functions.html#sorted" rel="nofollow">sorted()</a> on the "one-th" element of the tuples (the value) with reverse set to True:</p>
<pre><code>a={"f":500,"o":100,"q":25,"d":10,"n":5}  
for k, v in sorted(a.items(), key=operator.itemgetter(1), reverse=True):
    print(v)
</code></pre>
<p>I'm guessing that you do actually need the keys, but if not, you can just use <code>values()</code> instead of <code>items()</code>: <code>sorted(a.values(), reverse=True)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use this</p>
<pre><code>&gt;&gt;&gt; a={"f":500,"o":100,"q":25,"d":10,"n":5}
&gt;&gt;&gt; for value in sorted(a.itervalues(),reverse=True):
...     print value
... 
500
100
25
10
5
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a={"f":500,"o":100,"q":25,"d":10,"n":5}
k = sorted(a, key=a.__getitem__, reverse=True)
v = sorted(a.values(), reverse=True)
sorted_a = zip(k,v)
print (sorted_a)
</code></pre>
<p>Output:</p>
<pre><code>[('f', 500), ('o', 100), ('q', 25), ('d', 10), ('n', 5)]
</code></pre>
</div>
<span class="comment-copy">Does it need to be a dictionary?</span>
<span class="comment-copy">You would need to sort the values in the dictionary first.  Consider reading up on the <code>sorted</code> function.</span>
<span class="comment-copy"><code>sorted(a.values(), reverse=True)</code>?</span>
<span class="comment-copy">...or, you know, wait for someone to just hand you the answer :)</span>
<span class="comment-copy">Yep. Sorry @larsks if you actually wanted our user to go and look something up</span>
<span class="comment-copy">It is a vending machine simulator and its goal is to pay back using least amount of changes. Types, values and quantity of available money is stored in a dictionary. In order to define the least amount of change, I run a loop and pay back the change. My loop needs to figure out the least number of changes I need.</span>
<span class="comment-copy">I don't need the keys in this case so second part of the answer will be more relevant.</span>
<span class="comment-copy"><code>key=operator.itemgetter(1)</code> is more efficient than the equivalent <code>lambda</code> expression.</span>
<span class="comment-copy">@chepner You're quite right, although in my testing, not by as much as I thought it was going to be. I'll update the answer anyway.</span>
<span class="comment-copy">@Lorientas muddyfish is correct, I was actually asking LexyStardust to explain their answer. Your answer had a good amount of explanation!</span>
<span class="comment-copy">It seems that you're doing twice as much work as is necessary by sorting the keys and the values separately. Just sort the items, as in the other answers.</span>
<span class="comment-copy">Please explain what your code does and why it will solve the problem. An answer that just contains code (even if it's working) usually wont help the OP to understand their problem.</span>
<span class="comment-copy">@SuperBiasedMan Good point! I was in a hurry and by the time I was ready to write an explanation the OP already accepted an other answer. However, I do believe that my answer could help the OP even without the explanation. And, I certainly believe that down-voting an otherwise good answer just because I didn't give an explanation  is a little bit strange.</span>
