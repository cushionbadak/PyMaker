<div class="post-text" itemprop="text">
<p>My program reads two external files one containing random words another containing the grid of the word search. My code reads the words from one file and then attempts to see if the word can be found in the grid. My code can successfully determine whether or not the word in present in the grid. I however need to print the exact location of where the word is found such as: </p>
<p>active found: row 3 col 3 to row 3 col 8</p>
<p>I am not sure as to how to get the program to locate the exact occurrence of the word.</p>
<pre><code>print ""

# To God be the Glory

gridlines = []
not_found = []
found_words = {}

# Printing the grid
def puzzle(fname) :     
    print ""    
    for line in f :       
        gridlines.append(line)  
    for line in gridlines :       
        print line,

# Searching for horizontal words    
def horizontal_search(word,gridlines) :
    x = 0  
    for line in gridlines :  
        # Seeing if the word can be found in every line of the grid      
        if word in line or word in line[::-1] : 
            return word

        x = x + 1

        elif word not in line or word not in line [::-1] :        
            return None

            # Putting all the words that are not found in a list

            not_found.append(word)


    # Asking the user to enter a file until the correct file is open

    while True : 
        try:  
            fname = input("Enter a filename between quotation marks : ") 
            with open(fname) as f:
                puzzle(fname)

         print ""        
            while True :       
                try :
                    fname2 = input("Enter a filename between quotation marks : ")

                    with open(fname2) as f:          
                        for line in f :               
                           line = word                     
                           break

        print ""

        # Giving the words from the file to the horizontal word search function

        horizontal_search(word,gridlines)

        break        
        except IOError as e :
            print""
            print("Problem opening file...")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try using <code>enumerate</code> as suggested in a comment: </p>
<pre class="lang-python prettyprint-override"><code>keyword = 'w'

gridlines = [['a', 'b', 'c'], ['d', 'e', 'f'], ['h', 'w', 'z']]

def findit(gridlines, keyword):
    for i, line in enumerate(gridlines):
        print i, line
        for j, word in enumerate(line):
            print j, word
            if word == keyword:
                return i, j
i, j = findit(gridlines, keyword)
print 'Word found at line {} and index {}'.format(i, j)

&gt;&gt;&gt; Word found at line 2 and index 1 
</code></pre>
<p>Using <code>enumerate</code> allows you to loop over a list whilst keeping track of the index at each iteration. This should allow you to find the location of what you are looking for.</p>
<p>Sorry, your question is clearer now. I have this which works for simple situations. It creates a walker which walks around the board looking for letter matches, and returns if it finds all the letters.</p>
<pre class="lang-python prettyprint-override"><code>import numpy as np

keyword = list('wol')  # Word to find in crossword

a = np.array([['w', 'b', 'l'],  # The board of the crossword
              ['d', 'o', 'f'],
              ['m', 't', 'd']])

a = np.pad(a, 1, 'constant')

search = [(0,1), (1,0), (1,1), (-1,-1), (-1,0), (0,-1), (-1,1), (1,-1)]

used = set()

starting_positions = np.where(a == keyword[0])
start = zip(starting_positions[0], starting_positions[1])

def find_route(start, search, a, keyword):
    for i in start:
        positions = [i]
        count = 0
        current = i
        for j in keyword[1:]:
            path = []
            for s in search:
                point = (s[0]+ current[0], s[1] + current[1])
                if a[point] == j:
                    path.append(s)                        
                    positions.append(point)
                    if count == len(keyword)-2:
                        return True, [(j[0]-1, j[1]-1) for j in positions]
                    current = point
                    break
                else:
                    break
            count += 1
    return False, []



print find_route(start, search, a, keyword)
&gt;&gt;&gt; (True, [(0, 0), (1, 1), (0, 2)])

print find_route(start, search, a, list('wok'))
&gt;&gt;&gt; (False, [])

print find_route(start, search, a, list('wfd'))
&gt;&gt;&gt; (False, [])
</code></pre>
<p>If you dont need diagonals, change the <code>search</code> parameters
You may need to debug/alter for more complex boards. Good luck!</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> may help ... <code>for n, line in enumerate(gridlines): ...</code> and if you split <code>line</code> the <a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer"><code>index</code></a> method of sequences might help.</span>
<span class="comment-copy">Please consider trying to produce a <a href="http://stackoverflow.com/help/mcve">MCVE</a> to get better/faster answers.</span>
<span class="comment-copy">If you read a file linewise its easy to track line numbers, then for each line (as a string) searching it with [(m.start(0), m.end(0)) for m in re.finditer(pattern, line)] gives an array of tuples of the starting and ending offsets of matches of pattern in the line.</span>
<span class="comment-copy">can you please be more clear how would I include this logic in my program and how would I search?</span>
<span class="comment-copy">In your example why have you created the variable keywords and given it a value? and then assigned it to word.</span>
