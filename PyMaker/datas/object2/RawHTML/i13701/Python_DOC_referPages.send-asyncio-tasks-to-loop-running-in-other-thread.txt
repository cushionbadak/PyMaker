<div class="post-text" itemprop="text">
<p>How can I asynchronously insert tasks to run in an <code>asyncio</code> event loop running in another thread?</p>
<p>My motivation is to support interactive asynchronous workloads in the interpreter.  I can't block the main REPL thread.</p>
<h2>Example</h2>
<p>My current flawed understanding says that the following should work.  Why doesn't it?  What is a better way to accomplish goal above?</p>
<pre><code>import asyncio
from threading import Thread

loop = asyncio.new_event_loop()

def f(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

t = Thread(target=f, args=(loop,))
t.start()    

@asyncio.coroutine
def g():
    yield from asyncio.sleep(1)
    print('Hello, world!')

asyncio.async(g(), loop=loop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You must use <code>call_soon_threadsafe</code> to schedule callbacks from different threads:</p>
<pre><code>import asyncio
from threading import Thread

loop = asyncio.new_event_loop()

def f(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

t = Thread(target=f, args=(loop,))
t.start()    

@asyncio.coroutine
def g():
    yield from asyncio.sleep(1)
    print('Hello, world!')

loop.call_soon_threadsafe(asyncio.async, g())
</code></pre>
<p>See <a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading" rel="noreferrer">https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading</a> for more information.</p>
<p><strong>EDIT:</strong> Example of an interpreter supporting asynchronous workloads</p>
<pre><code># vim: filetype=python3 tabstop=2 expandtab

import asyncio as aio
import random

@aio.coroutine
def async_eval(input_, sec):
  yield from aio.sleep(sec)
  print("")
  try:
    result = eval(input_)
  except Exception as e:
    print("&lt; {!r} does not compute &gt;".format(input_))
  else:  
    print("&lt; {!r} = {} &gt;".format(input_, result))

@aio.coroutine
def main(loop):
  while True:
    input_ = yield from loop.run_in_executor(None, input, "&gt; ")

    if input_ == "quit":
      break
    elif input_ == "":
      continue
    else:
      sec = random.uniform(5, 10)
      print("&lt; {!r} scheduled for execution in {:.02} sec&gt;".format(input_, sec))
      aio.async(async_eval(input_, sec))

loop = aio.get_event_loop()

loop.run_until_complete(main(loop))
loop.close()
</code></pre>
</div>
<span class="comment-copy">You may try <a href="https://github.com/wardi/urwid" rel="nofollow noreferrer">urwid</a> as REPL -- it works with asyncio out of the box.</span>
<span class="comment-copy">Or <a href="https://ipython.org/" rel="nofollow noreferrer">ipython</a> -- it also can run async functions right in the REPL since version 7.0.</span>
<span class="comment-copy">Nice.  How about if I wanted to get the returned result of <code>g()</code>? (if <code>g</code> actually returned something.)</span>
<span class="comment-copy">You could pass a Future into <code>g</code> and set it's result from within <code>g</code> and then you could <code>yield from that_future</code> in another event loop in the other thread. You could also just create another coroutine in which you <code>yield from g()</code> and then <code>call_soon_threadsafe</code> on that new coroutine.</span>
<span class="comment-copy">Ideally, I would just re-work the logic to do this without threads. Or even if you must use threads, try to use the <code>loop.run_in_executor</code> coroutine, which can call blocking functions in threads and still look <code>asyncio</code>ish. See my edit for my interpretation of <code>support interactive asynchronous workloads in the interpreter</code> using this approach.</span>
<span class="comment-copy">if you need to run a coroutine on the event loop in the other thread use:   <code>asyncio.run_coroutine_threadsafe(my_coro(param1), loop)</code></span>
<span class="comment-copy">Excuse my ignorance but, I don't get where we make the reference to the started thread. Correct me if I'm wrong: we start an event-loop in another thread (call it thread1). We return to the main thread (call it thread0) and run an event loop in thread0 with a coroutine or callback to be run in that thread0 (I don't see any reference to thread1 in the assigning of the coroutine). In this case, we are not starting both event loops, each in one different thread and sending a task from one thread to another (from thread0 to thread1 for example), ¿aren't we? ¿How could that be accomplished?</span>
