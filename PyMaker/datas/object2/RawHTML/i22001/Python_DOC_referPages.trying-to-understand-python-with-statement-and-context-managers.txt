<div class="post-text" itemprop="text">
<p>I am new to this, and am just trying to understand the <code>with</code> statement. I understand that it is supposed to replace the <code>try</code>/<code>except</code> block.</p>
<p>Now suppose I do something like this:</p>
<pre class="lang-py prettyprint-override"><code>try:
   name='rubicon'/2 # to raise an exception
except Exception as e:
   print "no not possible"
finally:
   print "Ok I caught you"
</code></pre>
<p>How do I replace this with a context manager?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>with</code> doesn't really replace <code>try</code>/<code>except</code>, but, rather, <code>try</code>/<code>finally</code>.  Still, you <em>can</em> make a context manager do something different in exception cases from non-exception ones:</p>
<pre><code>class Mgr(object):
    def __enter__(self): pass
    def __exit__(self, ext, exv, trb):
        if ext is not None: print "no not possible"
        print "OK I caught you"
        return True

with Mgr():
    name='rubicon'/2 #to raise an exception
</code></pre>
<p>The <code>return True</code> part is where the context manager decides to suppress the exception (as you do by not re-raising it in your <code>except</code> clause).</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/2.7/library/contextlib.html#contextlib.contextmanager" rel="noreferrer" title="python docs">contextlib.contextmanager</a> function decorator provides a handy way of providing a context manager without the need to write a full-fledged <code>ContextManager</code> class of your own (with <code>__enter__</code> and <code>__exit__</code> methods, so you don't have to remember the arguments to the <code>__exit__</code> method, or that the <code>__exit__</code> method must <code>return True</code> in order to suppress the exception).  Instead, you write a function with a single <code>yield</code> at the point you want the <code>with</code> block to run, and you trap any exceptions (that effectively come from the <code>yield</code>) as you normally would.</p>
<pre><code>from contextlib import contextmanager
@contextmanager
def handler():
    # Put here what would ordinarily go in the `__enter__` method
    # In this case, there's nothing to do
    try:
        yield # You can return something if you want, that gets picked up in the 'as'
    except Exception as e:
        print "no not possible"
    finally:
        print "Ok I caught you"

with handler():
    name='rubicon'/2 #to raise an exception
</code></pre>
<p>Why go to the extra trouble of writing a context manager?  Code re-use.  You can use the same context manager in multiple places, without having to duplicate the exception handling.  If the exception handling is unique to that situation, then don't bother with a context manager.  But if the same pattern crops up again and again (or if it might for your users, e.g., closing a file, unlocking a mutex), it's worth the extra trouble.  It's also a neat pattern to use if the exception handling is a bit complicated, as it separates the exception handling from the main line of code flow.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>with</code> in Python is intended for wrapping a set of statements where you should set up and destroy or close resources. It is in a way similar to <code>try...finally</code> in that regard as the finally clause will be executed even after an exception.</p>
<p>A context manager is an object that implements two methods: <code>__enter__</code> and <code>__exit__</code>. Those are called immediately before and after (respectively) the <code>with</code> block.</p>
<p>For instance, take a look at the classic <code>open()</code> example:</p>
<pre><code>with open('temp.txt', 'w') as f:
    f.write("Hi!")
</code></pre>
<p>Open returns a <code>File</code> object that implements <code>__enter__</code> more or less like <code>return self</code> and <code>__exit__</code> like <code>self.close()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h2>The components of context manager</h2>
<p>1.you should implement a <strong>__enter__</strong> method that return  a object
2.implement a<strong>__exit__</strong> method </p>
<h2>example</h2>
<p>I will give a simple example to show you why we need context manager.During the winter of xinjiang, china , you should close a door immediately when you open a door.if you forget 
to close it ,you will get ***.
<code>
 class Door:
     def __init__(self):
         self.doorstatus='the door was closed when you are not in home'
         print(self.doorstatus)
     def __enter__(self):
         print('i have opened the door')
         return self
     def __exit__(self,*args):
         print('pong!the door has closed')
     def fetchsomethings(self):
         print('i have fetched somethings')
</code>
when fetch a  things at home,you should open a door,fetch somethings and close the door.
<code>
 with Door() as dr:
     dr.fetchsomethings()
</code>
the output is:
<code>
the door was closed when you are not in home
i have opened the door
i have fetched somethings
pong!the door has closed
</code></p>
<h2>Explation</h2>
<p>when you initiate a Door class ,it will call<strong>__init__</strong> method that will print 
"the door was closed when you are not in home" and <strong>__enter__</strong> method that will print "i have opened the door" and return a door instance called dr. when  call <strong>self.fetchsomethings</strong> in  with block,the method will print "i have fetched somethings".when the block is finished.the context manager will invoke <strong>__exit__</strong>
method and it will print "pong!the door has closed" .when you donot use  with
keyword ,<strong>__enter__</strong>and <strong>__exit__</strong> will not be  invoked!!!!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>with</code> statements or context managers are there to aid with resources (although may be used for much more).</p>
<p>Let's say you opened a file for writing:</p>
<pre><code>f = open(path, "w")
</code></pre>
<p>You now have an open file handle. During the handling of your file, no other program can write to it. In order to let other programs write to it, you must close the file handle:</p>
<pre><code>f.close()
</code></pre>
<p>But, before closing your file an error occured:</p>
<pre><code>f = open(path, "w")
data = 3/0  # Tried dividing by zero. Raised ZeroDivisionError
f.write(data)
f.close()
</code></pre>
<p>What will happen now is that the function or entire program will exit, while leaving your file with an open handle. (CPython cleans handles on termination and handles are freed together with a program but you shouldn't count on that)</p>
<p>A with statement ensures that as soon as you leave it's indentation, it will close the file handle:</p>
<pre><code>with open(path, "w") as f:
    data = 3/0  # Tried dividing by zero. Raised ZeroDivisionError
    f.write(data)
# In here the file is already closed automatically, no matter what happened.
</code></pre>
<hr/>
<p><code>with</code> statements may be used for many more things. For example: <code>threading.Lock()</code></p>
<pre><code>lock = threading.Lock()
with lock:  # Lock is acquired
   do stuff...
# Lock is automatically released.
</code></pre>
<p><strong>Almost everything done with a context manager can be done with <code>try: ... finally: ...</code></strong> but context managers are nicer to use, more comfortable, more readable and by implementing <code>__enter__</code> and <code>__exit__</code> provide an easy to use interface.</p>
<hr/>
<p>Creating context managers is done by implementing <a href="https://docs.python.org/3/reference/datamodel.html#object.__enter__" rel="noreferrer"><code>__enter__()</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__exit__" rel="noreferrer"><code>__exit__()</code></a> in a normal class.</p>
<p><code>__enter__()</code> tells what to do when a context manager starts and <code>__exit__()</code> when a context manager exists (giving the exception to the <code>__exit__()</code> method if an exception occurred)</p>
<p>A shortcut for creating context managers can be found in <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="noreferrer">contextlib</a>. It  wraps a generator as a context manager.</p>
</div>
<span class="comment-copy">Context manager only replace try/finally block.</span>
