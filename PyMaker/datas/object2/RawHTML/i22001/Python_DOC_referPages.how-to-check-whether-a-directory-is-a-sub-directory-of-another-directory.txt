<div class="post-text" itemprop="text">
<p>I like to write a template system in Python, which allows to include files.</p>
<p>e.g.</p>
<pre>
    This is a template
    You can safely include files with safe_include`othertemplate.rst`
</pre>
<p>As you know, including files might be dangerous. For example, if I use the template system in a web application which allows users to create their own templates, they might do something like</p>
<pre>
I want your passwords: safe_include`/etc/password`
</pre>
<p>So therefore, I have to restrict the inclusion of files to files which are for example in a certain subdirectory (e.g. <code>/home/user/templates</code>)</p>
<p>The question is now: How can I check, whether <code>/home/user/templates/includes/inc1.rst</code> is in a subdirectory of <code>/home/user/templates</code>?</p>
<p>Would the following code work and be secure?</p>
<pre><code>import os.path

def in_directory(file, directory, allow_symlink = False):
    #make both absolute    
    directory = os.path.abspath(directory)
    file = os.path.abspath(file)

    #check whether file is a symbolic link, if yes, return false if they are not allowed
    if not allow_symlink and os.path.islink(file):
        return False

    #return true, if the common prefix of both is equal to directory
    #e.g. /a/b/c/d.rst and directory is /a/b, the common prefix is /a/b
    return os.path.commonprefix([file, directory]) == directory
</code></pre>
<p>As long, as <code>allow_symlink</code> is False, it should be secure, I think. Allowing symlinks of course would make it insecure if the user is able to create such links.</p>
<p><strong>UPDATE - Solution</strong>
The code above does not work, if intermediate directories are symbolic links.
To prevent this, you have to use <code>realpath</code> instead of <code>abspath</code>.</p>
<p><strong>UPDATE:</strong> adding a trailing / to directory to solve the problem with commonprefix() Reorx pointed out.</p>
<p>This also makes <code>allow_symlink</code> unnecessary as symlinks are expanded to their real destination   </p>
<pre><code>import os.path

def in_directory(file, directory):
    #make both absolute    
    directory = os.path.join(os.path.realpath(directory), '')
    file = os.path.realpath(file)

    #return true, if the common prefix of both is equal to directory
    #e.g. /a/b/c/d.rst and directory is /a/b, the common prefix is /a/b
    return os.path.commonprefix([file, directory]) == directory
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>os.path.realpath(path): Return the canonical path of the specified filename, eliminating any symbolic links encountered in the path (if they are supported by the operating system).</p>
<p>Use it on directory and subdirectory name, then check latter starts with former.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3's <code>pathlib</code> module makes this straightforward with its <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parents" rel="noreferrer">Path.parents</a> attribute. For example:</p>
<pre><code>from pathlib import Path

root = Path('/path/to/root')
child = root / 'some' / 'child' / 'dir'
other = Path('/some/other/path')
</code></pre>
<p>Then:</p>
<pre><code>&gt;&gt;&gt; root in child.parents
True
&gt;&gt;&gt; other in child.parents
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_subdir(path, directory):
    path = os.path.realpath(path)
    directory = os.path.realpath(directory)
    relative = os.path.relpath(path, directory)
    return not relative.startswith(os.pardir + os.sep)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Problems with many of the suggested methods</h3>
<p>If you're going to test for directory parentage with string comparison or <code>os.path.commonprefix</code> methods, these are prone to errors with similarly-named paths or relative paths. For example:</p>
<ul>
<li><code>/path/to/files/myfile</code> would be shown as a child path of <code>/path/to/file</code> using many of the methods.</li>
<li><code>/path/to/files/../../myfiles</code> would not be shown as a parent of <code>/path/myfiles/myfile</code> by many of the methods. In fact, it is.</li>
</ul>
<p>The <a href="https://stackoverflow.com/a/17624617/2010738">previous answer</a> by Rob Dennis provides a good way to compare path parentage without encountering these problems. Python 3.4 added the <code>pathlib</code> module which can perform these kind of path operations in a more sophisticated way, optionally without referencing the underlying OS. jme has described in <a href="https://stackoverflow.com/a/34236245/2010738">another previous answer</a> how to use <code>pathlib</code> for the purpose of accurately determining if one path is a child of another. If you prefer not to use <code>pathlib</code> (not sure why, it's pretty great) then Python 3.5 introduced a new OS-based method in <code>os.path</code> that allows you to do perform path parent-child checks in a similarly accurate and error-free manner with a lot less code.</p>
<h3>New for Python 3.5</h3>
<p>Python 3.5 introduced the function <code>os.path.commonpath</code>. This is a method that is specific to the OS that the code is running on. You can use <code>commonpath</code> in the following way to accurately determine path parentage:</p>
<pre><code>def path_is_parent(parent_path, child_path):
    # Smooth out relative path names, note: if you are concerned about symbolic links, you should use os.path.realpath too
    parent_path = os.path.abspath(parent_path)
    child_path = os.path.abspath(child_path)

    # Compare the common path of the parent and child path with the common path of just the parent path. Using the commonpath method on just the parent path will regularise the path name in the same way as the comparison that deals with both paths, removing any trailing path separator
    return os.path.commonpath([parent_path]) == os.path.commonpath([parent_path, child_path])
</code></pre>
<h3>Accurate one-liner</h3>
<p>You can combine the whole lot into a one-line if statement in Python 3.5. It's ugly, it includes unnecessary duplicate calls to <code>os.path.abspath</code> and it definitely won't fit in the PEP 8 79-character line-length guidelines, but if you like that kind of thing, here goes:</p>
<pre><code>if os.path.commonpath([os.path.abspath(parent_path_to_test)]) == os.path.commonpath([os.path.abspath(parent_path_to_test), os.path.abspath(child_path_to_test)]):
    # Yes, the child path is under the parent path
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>so, I needed this, and due to the criticisms about commonprefx, I went a different way:</p>
<pre><code>def os_path_split_asunder(path, debug=False):
    """
    http://stackoverflow.com/a/4580931/171094
    """
    parts = []
    while True:
        newpath, tail = os.path.split(path)
        if debug: print repr(path), (newpath, tail)
        if newpath == path:
            assert not tail
            if path: parts.append(path)
            break
        parts.append(tail)
        path = newpath
    parts.reverse()
    return parts


def is_subdirectory(potential_subdirectory, expected_parent_directory):
    """
    Is the first argument a sub-directory of the second argument?

    :param potential_subdirectory:
    :param expected_parent_directory:
    :return: True if the potential_subdirectory is a child of the expected parent directory

    &gt;&gt;&gt; is_subdirectory('/var/test2', '/var/test')
    False
    &gt;&gt;&gt; is_subdirectory('/var/test', '/var/test2')
    False
    &gt;&gt;&gt; is_subdirectory('var/test2', 'var/test')
    False
    &gt;&gt;&gt; is_subdirectory('var/test', 'var/test2')
    False
    &gt;&gt;&gt; is_subdirectory('/var/test/sub', '/var/test')
    True
    &gt;&gt;&gt; is_subdirectory('/var/test', '/var/test/sub')
    False
    &gt;&gt;&gt; is_subdirectory('var/test/sub', 'var/test')
    True
    &gt;&gt;&gt; is_subdirectory('var/test', 'var/test')
    True
    &gt;&gt;&gt; is_subdirectory('var/test', 'var/test/fake_sub/..')
    True
    &gt;&gt;&gt; is_subdirectory('var/test/sub/sub2/sub3/../..', 'var/test')
    True
    &gt;&gt;&gt; is_subdirectory('var/test/sub', 'var/test/fake_sub/..')
    True
    &gt;&gt;&gt; is_subdirectory('var/test', 'var/test/sub')
    False
    """

    def _get_normalized_parts(path):
        return os_path_split_asunder(os.path.realpath(os.path.abspath(os.path.normpath(path))))

    # make absolute and handle symbolic links, split into components
    sub_parts = _get_normalized_parts(potential_subdirectory)
    parent_parts = _get_normalized_parts(expected_parent_directory)

    if len(parent_parts) &gt; len(sub_parts):
        # a parent directory never has more path segments than its child
        return False

    # we expect the zip to end with the short path, which we know to be the parent
    return all(part1==part2 for part1, part2 in zip(sub_parts, parent_parts))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_in_directory(filepath, directory):
    return os.path.realpath(filepath).startswith(
        os.path.realpath(directory) + os.sep)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like the "path in other_path.parents" approached mentioned in another answer because I'm a big fan of pathlib, BUT I feel that approach is a bit heavy (it creates one Path instance for each parent to root of path). Also the case where path == other_path will fail with that approach, whereas os.commonpath would succeed on that case. </p>
<p>The following is a different approach, with its own set of pros and cons compared to other methods identified in the various answers:</p>
<pre><code>try:
   other_path.relative_to(path)
except ValueError:
   ...no common path...
else:
   ...common path...
</code></pre>
<p>which is a little more verbose but can easily be added as a function in your application's common utilities module or even add the method to Path at startup time. </p>
</div>
<div class="post-text" itemprop="text">
<p>I would test the result from commonprefix against the filename to get a better answer, something like this:</p>
<pre><code>def is_in_folder(filename, folder='/tmp/'):
    # normalize both parameters
    fn = os.path.normpath(filename)
    fd = os.path.normpath(folder)

    # get common prefix
    commonprefix = os.path.commonprefix([fn, fd])
    if commonprefix == fd:
        # in case they have common prefix, check more:
        sufix_part = fn.replace(fd, '')
        sufix_part = sufix_part.lstrip('/')
        new_file_name = os.path.join(fd, sufix_part)
        if new_file_name == fn:
            return True
        pass
    # for all other, it's False
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on another answer here, with correction, and with a user-friendlier name:</p>
<pre><code>def isA_subdirOfB_orAisB(A, B):
    """It is assumed that A is a directory."""
    relative = os.path.relpath(os.path.realpath(A), 
                               os.path.realpath(B))
    return not (relative == os.pardir
            or  relative.startswith(os.pardir + os.sep))
</code></pre>
</div>
<span class="comment-copy">The last function doesn't work also, see this input and output: <code>&gt;&gt;&gt; in_directory('/usr/var2/log', '/usr/var') True '</code>, <code>commonprefix</code> should not be trusted.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/8854421/how-to-determine-if-a-path-is-a-subdirectory-of-another/18115718#18115718" title="how to determine if a path is a subdirectory of another">stackoverflow.com/questions/8854421/…</a></span>
<span class="comment-copy">Best answer is in the question ...</span>
<span class="comment-copy">It defies common sense why <code>os.path.commonprefix(..)</code> was written to operate character-by-character, but that's indeed what the <a href="https://docs.python.org/2/library/os.path.html#os.path.commonprefix" rel="nofollow noreferrer">documentation for it</a> says.</span>
<span class="comment-copy">Ok, that makes sense, because an intermediate directory could be also a symbolic link.</span>
<span class="comment-copy">security vulnerability: see comment by Reorx on OP for example.</span>
<span class="comment-copy">actually, you need to append the os.sep (if not already included) when calling startswith, as noted by jgoeders,</span>
<span class="comment-copy">'a/b/cde' starts with 'a/b/c' but is not a subdirectory.</span>
<span class="comment-copy">@yeoman adding slashes can help</span>
<span class="comment-copy">If you consider a path to be a child / parent of itself (for example if you want to test if a path is either <code>/a/b/c</code> or a subdirectory of <code>/a/b/c</code>) then you can use <code>root in [child] + [p for p in child.parents]</code></span>
<span class="comment-copy">Most Pythonic way for Python 3, <code>pathlib</code> really makes things easier to read.  It would be worth mentioning if you're playing a lot with relative paths that you might want to call <code>.resolve()</code> before checking if <code>A in B.parents</code>.</span>
<span class="comment-copy"><code>os.path.relpath</code> does not include <code>os.sep</code> in my tests, e.g. <code>os.path.relpath("/a", "/a/b")</code>.</span>
<span class="comment-copy">@TorstenBronger Good point. Therefore, the answer is wrong as it stands, unless the last line is changed to <code>return not (relative == os.pardir or relative.startswith(os.pardir + os.sep))</code>. By the way, if we insist on <i>proper</i> subdirectory, then also check using <code>(relative == os.curdir)</code>.</span>
<span class="comment-copy">WTF would it be necessarry to take a commonpath of 1 path ?  imo:     abs_parent_path==commonpath([abs_parent_path, abs_child_path]) should suffice ...</span>
<span class="comment-copy">All the string comparison / <code>os.path.commonprefix</code> methods are prone to errors with similarly-named paths or relative paths. This is a much better way of determining if a path is a child of another path and is not subject to the same bugs. If you're using Python 3.5+, there is a new method <code>os.path.commonpath</code> which lends itself to a simpler, more elegant method which is similarly accurate and will not lead to errors when paths are named similarly or specified as relative paths. I've provided a basic implementation in a separate answer.</span>
<span class="comment-copy">Thanks, works perfect</span>
