<div class="post-text" itemprop="text">
<p>Instead of writing code like this every time I define a class:</p>
<pre><code>class Foo(object): 
     def __init__(self, a, b, c, d, e, f, g):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f
        self.g = g
</code></pre>
<p>I could use <a href="http://code.activestate.com/recipes/551763/" rel="noreferrer">this recipe for automatic attribute assignment</a>.</p>
<pre><code>class Foo(object):
     @autoassign
     def __init__(self, a, b, c, d, e, f, g):
        pass
</code></pre>
<p><strong>Two questions</strong>:</p>
<ol>
<li>Are there drawbacks or pitfalls associated with this shortcut?</li>
<li>Is there a better way to achieve similar convenience?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>There are some things about the autoassign code that bug me (mostly stylistic, but one more serious problem):</p>
<ol>
<li><p><code>autoassign</code> does not assign an
'args' attribute:</p>
<pre><code>class Foo(object):
    @autoassign
    def __init__(self,a,b,c=False,*args):
        pass
a=Foo('IBM','/tmp',True, 100, 101)
print(a.args)
# AttributeError: 'Foo' object has no attribute 'args'
</code></pre></li>
<li><p><code>autoassign</code> acts like a decorator.
But <code>autoassign(*argnames)</code> calls a
function which returns a decorator.
To achieve this magic, <code>autoassign</code>
needs to test the type of its first
argument. If given a choice, I
prefer functions not test
the type of its arguments.</p></li>
<li><p>There seems to be a considerable
amount of code devoted to setting up
<code>sieve</code>, lambdas within lambdas,
ifilters, and lots of conditions.</p>
<pre><code>if kwargs:
    exclude, f = set(kwargs['exclude']), None
    sieve = lambda l:itertools.ifilter(lambda nv: nv[0] not in exclude, l)
elif len(names) == 1 and inspect.isfunction(names[0]):
    f = names[0]
    sieve = lambda l:l
else:
    names, f = set(names), None
    sieve = lambda l: itertools.ifilter(lambda nv: nv[0] in names, l)
</code></pre>
<p>I think there might be a simpler way. (See
below).</p></li>
<li><p><code>for _ in
itertools.starmap(assigned.setdefault,
defaults): pass</code>. I don't think
<code>map</code> or <code>starmap</code> was meant to call
functions, whose only purpose is their
side effects. It could have been
written more clearly with the mundane:</p>
<pre><code>for key,value in defaults.iteritems():
    assigned.setdefault(key,value)
</code></pre></li>
</ol>
<p>Here is an alternative simpler implementation which has the same functionality as autoassign (e.g. can do includes and excludes), and which addresses the above points:</p>
<pre><code>import inspect
import functools

def autoargs(*include, **kwargs):
    def _autoargs(func):
        attrs, varargs, varkw, defaults = inspect.getargspec(func)

        def sieve(attr):
            if kwargs and attr in kwargs['exclude']:
                return False
            if not include or attr in include:
                return True
            else:
                return False

        @functools.wraps(func)
        def wrapper(self, *args, **kwargs):
            # handle default values
            if defaults:
                for attr, val in zip(reversed(attrs), reversed(defaults)):
                    if sieve(attr):
                        setattr(self, attr, val)
            # handle positional arguments
            positional_attrs = attrs[1:]
            for attr, val in zip(positional_attrs, args):
                if sieve(attr):
                    setattr(self, attr, val)
            # handle varargs
            if varargs:
                remaining_args = args[len(positional_attrs):]
                if sieve(varargs):
                    setattr(self, varargs, remaining_args)
            # handle varkw
            if kwargs:
                for attr, val in kwargs.items():
                    if sieve(attr):
                        setattr(self, attr, val)
            return func(self, *args, **kwargs)
        return wrapper
    return _autoargs
</code></pre>
<p>And here is the unit test I used to check its behavior:</p>
<pre><code>import sys
import unittest
import utils_method as um

class Test(unittest.TestCase):
    def test_autoargs(self):
        class A(object):
            @um.autoargs()
            def __init__(self,foo,path,debug=False):
                pass
        a=A('rhubarb','pie',debug=True)
        self.assertTrue(a.foo=='rhubarb')
        self.assertTrue(a.path=='pie')
        self.assertTrue(a.debug==True)

        class B(object):
            @um.autoargs()
            def __init__(self,foo,path,debug=False,*args):
                pass
        a=B('rhubarb','pie',True, 100, 101)
        self.assertTrue(a.foo=='rhubarb')
        self.assertTrue(a.path=='pie')
        self.assertTrue(a.debug==True)
        self.assertTrue(a.args==(100,101))        

        class C(object):
            @um.autoargs()
            def __init__(self,foo,path,debug=False,*args,**kw):
                pass
        a=C('rhubarb','pie',True, 100, 101,verbose=True)
        self.assertTrue(a.foo=='rhubarb')
        self.assertTrue(a.path=='pie')
        self.assertTrue(a.debug==True)
        self.assertTrue(a.verbose==True)        
        self.assertTrue(a.args==(100,101))        

    def test_autoargs_names(self):
        class C(object):
            @um.autoargs('bar','baz','verbose')
            def __init__(self,foo,bar,baz,verbose=False):
                pass
        a=C('rhubarb','pie',1)
        self.assertTrue(a.bar=='pie')
        self.assertTrue(a.baz==1)
        self.assertTrue(a.verbose==False)
        self.assertRaises(AttributeError,getattr,a,'foo')

    def test_autoargs_exclude(self):
        class C(object):
            @um.autoargs(exclude=('bar','baz','verbose'))
            def __init__(self,foo,bar,baz,verbose=False):
                pass
        a=C('rhubarb','pie',1)
        self.assertTrue(a.foo=='rhubarb')
        self.assertRaises(AttributeError,getattr,a,'bar')

    def test_defaults_none(self):
        class A(object):
            @um.autoargs()
            def __init__(self,foo,path,debug):
                pass
        a=A('rhubarb','pie',debug=True)
        self.assertTrue(a.foo=='rhubarb')
        self.assertTrue(a.path=='pie')
        self.assertTrue(a.debug==True)


if __name__ == '__main__':
    unittest.main(argv = sys.argv + ['--verbose'])
</code></pre>
<p>PS. Using <code>autoassign</code> or <code>autoargs</code> is compatible with IPython code completion.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there a better way to achieve similar convenience?</p>
</blockquote>
<p>I don't know if it is necessarily better, but you could do this:</p>
<pre><code>class Foo(object):
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


&gt;&gt;&gt; foo = Foo(a = 1, b = 'bar', c = [1, 2])
&gt;&gt;&gt; foo.a
1
&gt;&gt;&gt; foo.b
'bar'
&gt;&gt;&gt; foo.c
[1, 2]
&gt;&gt;&gt; 
</code></pre>
<p>Courtesy Peter Norvig's <a href="http://norvig.com/python-iaq.html" rel="noreferrer">Python: Infrequently Answered Questions</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One drawback: many IDEs parse <code>__init__.py</code> to discover an object's attributes. If you want automatic code completion in your IDE to be more functional, then you may be better off spelling it out the old-fashioned way.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <strong>Python 3.7+</strong> you can use a <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">Data Class</a>, which achieves what you want and more. </p>
<p>It allows you to define <em>fields</em> for your class, which are attributes automatically assigned. </p>
<p>It would look something like that: </p>
<pre><code>@dataclass
class Foo:
    a: str
    b: int
    c: str
    ...
</code></pre>
<p>The <code>__init__</code> method will be automatically created in your class, and it will assign the arguments of instance creation to those attributes (and validate the arguments). </p>
<p>Note that here <strong>type hinting is required</strong>, that is why I have used <code>int</code> and <code>str</code> in the example. If you don't know the type of your field, you can use <a href="https://docs.python.org/3/library/typing.html#typing.Any" rel="noreferrer">Any from the <code>typing</code> module</a>.  </p>
</div>
<div class="post-text" itemprop="text">
<p>If you have a lot of variables, you could pass one single configuration dict or object.</p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to the above, though not the same... the following is very short, deals with <code>args</code> and <code>kwargs</code>:</p>
<pre><code>def autoassign(lcls):
    for key in lcls.keys():
        if key!="self":
            lcls["self"].__dict__[key]=lcls[key]
</code></pre>
<p>Use like this:</p>
<pre><code>class Test(object):
    def __init__(self, a, b, *args, **kwargs):
        autoassign(locals())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This a simple implementation by <a href="https://codegists.com/snippet/python/auto_argspy_judy2k_python" rel="nofollow noreferrer">judy2k</a>:</p>
<pre><code>from inspect import signature

def auto_args(f):
    sig = signature(f)  # Get a signature object for the target:
    def replacement(self, *args, **kwargs):
        # Parse the provided arguments using the target's signature:
        bound_args = sig.bind(self, *args, **kwargs)
        # Save away the arguments on `self`:
        for k, v in bound_args.arguments.items():
            if k != 'self':
                setattr(self, k, v)
        # Call the actual constructor for anything else:
        f(self, *args, **kwargs)
    return replacement


class MyClass:
    @auto_args
    def __init__(self, a, b, c=None):
        pass

m = MyClass('A', 'B', 'C')
print(m.__dict__)
# {'a': 'A', 'b': 'B', 'c': 'C'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In <a href="https://github.com/smarie/python-classtools-autocode" rel="nofollow noreferrer">this package</a> you can now find </p>
<ul>
<li><code>@autoargs</code> inspired by <a href="https://stackoverflow.com/a/3653049/7262247">answer-3653049</a></li>
<li><code>@autoprops</code> to transform the fields generated by <code>@autoargs</code> into <a href="https://docs.python.org/3.6/library/functions.html#property" rel="nofollow noreferrer"><code>@property</code></a>, for use in combination with a validation library such as <a href="https://github.com/RussBaz/enforce" rel="nofollow noreferrer">enforce</a> or <a href="https://andreacensi.github.io/contracts/" rel="nofollow noreferrer">pycontracts</a>. </li>
</ul>
<p>Note that this has been validated for python 3.5+</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class MyClass(object):
    def __init__(self, **kwargs):
        for key, value in kwargs.iteritems():
            setattr(self, key, value)
</code></pre>
<p>You just can't use *args, but you can store in some instance list (like self.args, don't know)</p>
</div>
<span class="comment-copy">+1 this is a recurrent pattern in Python. I don't see any drawback in using the autoassign decorator, as it lets you define a list of argument <i>not</i> to assign.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1389180/python-automatically-initialize-instance-variables" title="python automatically initialize instance variables">stackoverflow.com/questions/1389180/â€¦</a></span>
<span class="comment-copy">Thanks a lot. This is very helpful.</span>
<span class="comment-copy">I also found your autoargs incredibly handy. One issue I noticed is that it seems to throw an error if <code>defaults</code> is <code>None</code>, because the call to <code>reversed</code> fails. Am I right in thinking that this should be fixable by adding an <code>if defaults:</code> in front of the line <code>for attr,val in zip(reversed(attrs),reversed(defaults)):</code>, or does that have unintended sideeffects? The unit test passes.</span>
<span class="comment-copy">@m01: Sorry for the very belated response. Thanks for the correction!</span>
<span class="comment-copy">This is a quick solution to the problem, but it has two drawbacks: 1) you have to add much more code if you want to make sure that some arguments are passed to the function; 2) the signature of the function is completely opaque, and it cannot be used to understand how to call the function; one will need to rely on the docstring instead</span>
