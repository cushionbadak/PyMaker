<div class="post-text" itemprop="text">
<p>Any tips on testing email sending? Other than maybe creating a <a href="https://mail.google.com/mail/" rel="noreferrer">gmail</a> account, especially for receiving those emails?</p>
<p>I would like to, maybe, store the emails locally, within a folder as they are sent.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <a href="http://docs.djangoproject.com/en/dev/topics/email/#file-backend" rel="noreferrer">file backend for sending emails</a> which is a very handy solution for development and testing; emails are not sent but stored in a folder you can specify!</p>
</div>
<div class="post-text" itemprop="text">
<p>Django test framework has some built in helpers to aid you with testing <a href="https://docs.djangoproject.com/en/dev/topics/testing/tools/#email-services" rel="noreferrer">e-mail service</a>.</p>
<p>Example from docs (short version):</p>
<pre><code>from django.core import mail
from django.test import TestCase

class EmailTest(TestCase):
    def test_send_email(self):
        mail.send_mail('Subject here', 'Here is the message.',
            'from@example.com', ['to@example.com'],
            fail_silently=False)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, 'Subject here')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are into unit-testing the best solution is to use the <a href="https://docs.djangoproject.com/en/1.9/topics/email/#in-memory-backend" rel="noreferrer">In-memory backend</a> provided by django.</p>
<pre><code>EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'
</code></pre>
<p>Take the case of use it as a <strong>py.test</strong> fixture</p>
<pre><code>@pytest.fixture(autouse=True)
def email_backend_setup(self, settings):
    settings.EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'  
</code></pre>
<p>In each test, the <code>mail.outbox</code> is reset with the server, so there are no side effects between tests.</p>
<pre><code>from django.core import mail

def test_send(self):
    mail.send_mail('subject', 'body.', 'from@example.com', ['to@example.com'])
    assert len(mail.outbox) == 1

def test_send_again(self):
    mail.send_mail('subject', 'body.', 'from@example.com', ['to@example.com'])
    assert len(mail.outbox) == 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For any project that doesn't require sending attachments, I use <a href="https://github.com/pinax/django-mailer" rel="nofollow noreferrer">django-mailer</a>, which has the benefit of all outbound emails ending up in a queue until I trigger their sending, and even after they've been sent, they are then logged - all of which is visible in the Admin, making it easy to quickly check what you emailing code is trying to fire off into the intertubes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Django also has an in-memory email backend. More details in the docs under <a href="https://docs.djangoproject.com/en/1.6/topics/email/#in-memory-backend" rel="nofollow">In-memory backend</a>. This is present in Django 1.6 not sure if it's present in anything earlier.</p>
</div>
<div class="post-text" itemprop="text">
<p>Patching SMTPLib for testing purposes can help test sending mails without sending them.</p>
<ul>
<li><a href="http://www.psychicorigami.com/2007/09/20/monkey-patching-pythons-smtp-lib-for-unit-testing/" rel="nofollow noreferrer">http://www.psychicorigami.com/2007/09/20/monkey-patching-pythons-smtp-lib-for-unit-testing/</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Use <strong><a href="https://github.com/mailhog/MailHog" rel="nofollow">MailHog</a></strong></p>
<blockquote>
<p>Inspired by MailCatcher, easier to install.</p>
<p>Built with Go - MailHog runs without installation on multiple platforms.</p>
</blockquote>
<p><br/></p>
<p>Also, it has a component called <strong>Jim</strong>, the <strong>MailHog Chaos Monkey</strong>, which enables you to test sending emails with various problems happening:</p>
<blockquote>
<p>What can Jim do?</p>
<ul>
<li>Reject connections</li>
<li>Rate limit connections</li>
<li>Reject authentication</li>
<li>Reject senders</li>
<li>Reject recipients</li>
</ul>
</blockquote>
<p>Read more about it <a href="https://github.com/mailhog/MailHog/blob/master/docs/JIM.md" rel="nofollow">here</a>.</p>
<p><br/></p>
<p>(Unlike original mailcatcher, which <a href="https://github.com/sj26/mailcatcher/issues/285" rel="nofollow">failed on me when sending emails with emoji, encoded in UTF-8</a> and it WASN'T really fixed in the current release, MailHog just works.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Using the file backend works well, but I find it a little a cumbersome to poke around the filesystem to look at emails.  You could use mailcatcher, <a href="https://github.com/sj26/mailcatcher" rel="nofollow">https://github.com/sj26/mailcatcher</a>, to capture emails and display them in a web UI.</p>
<p>To use mailcatcher with Django you'll need to add something like the following to your settings.py:</p>
<pre><code>EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = '127.0.0.1'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 1025
EMAIL_USE_TLS = False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not start your own really simple SMTP Server by inherit from <a href="https://docs.python.org/3/library/smtpd.html" rel="nofollow"><code>smtpd.SMTPServer</code></a> and <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow"><code>threading.Thread</code></a>:</p>
<pre><code>class TestingSMTPServer(smtpd.SMTPServer, threading.Thread):
    def __init__(self, port=25):
        smtpd.SMTPServer.__init__(
            self,
            ('localhost', port),
            ('localhost', port),
            decode_data=False
        )
        threading.Thread.__init__(self)

    def process_message(self, peer, mailfrom, rcpttos, data, **kwargs):
        self.received_peer = peer
        self.received_mailfrom = mailfrom
        self.received_rcpttos = rcpttos
        self.received_data = data

    def run(self):
        asyncore.loop()
</code></pre>
<p>process_message is called whenever your SMTP Server receive a mail request, you can do whatever you want there.</p>
<p>In the testing code, do something like this:</p>
<pre><code>smtp_server = TestingSMTPServer()
smtp_server.start()
do_thing_that_would_send_a_mail()
smtp_server.close()
self.assertIn(b'hello', smtp_server.received_data)
</code></pre>
<p>Just remember to <a href="https://docs.python.org/3/library/asyncore.html#asyncore.dispatcher.close" rel="nofollow"><code>close()</code></a> the <a href="https://docs.python.org/3/library/asyncore.html#asyncore.dispatcher" rel="nofollow"><code>asyncore.dispatcher</code></a> by calling <code>smtp_server.close()</code> to end the asyncore loop(stop the server from listening).</p>
</div>
<div class="post-text" itemprop="text">
<p>My solution is write content to a html file. This way can help you see how email look like. I leave it here <a href="https://gist.github.com/phuong/279588263161e9eae083fc6a734043a0" rel="nofollow">htmlfilebased.EmailBackend</a>.</p>
<p>Other tip: You can use <a href="https://github.com/phuong/email-template-editor/tree/master/django" rel="nofollow">django email template editor</a> which can help you edit your email template with zero inline css.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have a TomCat server available, or other servlet engine, then a nice approach is "Post Hoc" which is a small server that looks to the application exactly like a SMTP server, but it includes a user interface that allows you to view and inspect the email messages that were sent.   It is open source and freely available.   </p>
<p>Find it at: <a href="https://github.com/agilepro/posthoc" rel="nofollow noreferrer">Post Hoc GitHub Site</a></p>
<p>See the blog post:  <a href="https://agiletribe.wordpress.com/2017/07/24/posthoc-testing-apps-that-send-email/" rel="nofollow noreferrer">PostHoc: Testing Apps that Send Email</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://websocket.email" rel="nofollow noreferrer">https://websocket.email</a> provides a simple way to test email sending with minimal setup (you don't even need an account).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use Maildump.</p>
<p><a href="https://github.com/ThiefMaster/maildump" rel="nofollow">https://github.com/ThiefMaster/maildump</a></p>
<blockquote>
<p>MailDump is a python-based clone of the awesome MailCatcher tool. Its
  purpose is to provide developers a way to let applications send emails
  without actual emails being sent to anyone. Additionally lazy
  developers might prefer this over a real SMTP server simply for the
  sake of it being much easier and faster to set up.</p>
</blockquote>
<p>However it requires Python 2.</p>
</div>
<span class="comment-copy">Moderators: please lock this question. Lots of spam is being added in the answers, proposing solutions that are ridiculously complex just to promote external services.</span>
<span class="comment-copy">More info about email backends: <a href="https://docs.djangoproject.com/en/dev/topics/email/#email-backends" rel="nofollow noreferrer">docs.djangoproject.com/en/dev/topics/email/#email-backends</a>. Sometimes even simple console backend is enough..</span>
<span class="comment-copy">But is there a way to access the generated email during (automated) testing ?</span>
<span class="comment-copy">+1 Good answer. But I it's not useful for complex cases, when <code>send_mail</code> can't be used.</span>
<span class="comment-copy">More precisely the doc is here: <a href="https://docs.djangoproject.com/en/1.8/topics/email/#in-memory-backend" rel="nofollow noreferrer">docs.djangoproject.com/en/1.8/topics/email/#in-memory-backend</a></span>
<span class="comment-copy">How would you do this if your testing a function which calls send_mail and you therefore can't access <code>mail</code>?</span>
<span class="comment-copy">@MatthewDrill you can still access <code>mail.outbox</code> when <code>send_mail</code> is called in another function.</span>
<span class="comment-copy">this should be the accepted answer which is valid in most cases</span>
<span class="comment-copy">Further to that, the Message objects created by django-mailer mean you can prod them (and inspect their contents) in unit tests too (I know that there's outbound mailbox support in the test suite for a dummy mailbox, but using django-mailer doesn't send mail unless the management command sends it, which means you can't use that mailbox object)</span>
<span class="comment-copy">Update, ages on from my original answer: <a href="https://github.com/SmileyChris/django-mailer-2" rel="nofollow noreferrer">github.com/SmileyChris/django-mailer-2</a> does support attachments, too</span>
