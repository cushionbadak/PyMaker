<div class="post-text" itemprop="text">
<p>I love using the expression</p>
<pre><code>if 'MICHAEL89' in USERNAMES:
    ...
</code></pre>
<p>where <code>USERNAMES</code> is a list</p>
<hr/>
<p>Is there any way to match items with case insensitivity or do I need to use a custom method? Just wondering if there is need to write extra code for this.</p>
<p>Thanks to everyone!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>if 'MICHAEL89' in (name.upper() for name in USERNAMES):
    ...
</code></pre>
<p>Alternatively:</p>
<pre><code>if 'MICHAEL89' in map(str.upper, USERNAMES):
    ...
</code></pre>
<p>Or, yes, you can make a custom method.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would make a <em>wrapper</em> so you can be non-invasive.  Minimally, for example...:</p>
<pre><code>class CaseInsensitively(object):
    def __init__(self, s):
        self.__s = s.lower()
    def __hash__(self):
        return hash(self.__s)
    def __eq__(self, other):
        # ensure proper comparison between instances of this class
        try:
           other = other.__s
        except (TypeError, AttributeError):
          try:
             other = other.lower()
          except:
             pass
        return self.__s == other
</code></pre>
<p>Now, <code>if CaseInsensitively('MICHAEL89') in whatever:</code> should behave as required (whether the right-hand side is a list, dict, or set).  (It may require more effort to achieve similar results for string inclusion, avoid warnings in some cases involving <code>unicode</code>, etc).</p>
</div>
<div class="post-text" itemprop="text">
<p>Usually (in oop at least) you shape your object to behave the way you want. <code>name in USERNAMES</code> is not case insensitive, so <code>USERNAMES</code> needs to change:</p>
<pre><code>class NameList(object):
    def __init__(self, names):
        self.names = names

    def __contains__(self, name): # implements `in`
        return name.lower() in (n.lower() for n in self.names)

    def add(self, name):
        self.names.append(name)

# now this works
usernames = NameList(USERNAMES)
print someone in usernames
</code></pre>
<p>The great thing about this is that it opens the path for many improvements, without having to change any code outside the class. For example, you could change the <code>self.names</code> to a set for faster lookups, or compute the <code>(n.lower() for n in self.names)</code> only once and store it on the class and so on ...</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you have to write some extra code. For example:</p>
<pre><code>if 'MICHAEL89' in map(lambda name: name.upper(), USERNAMES):
   ...
</code></pre>
<p>In this case we are forming a new list with all entries in <code>USERNAMES</code> converted to upper case and then comparing against this new list.</p>
<p><strong>Update</strong> </p>
<p>As <a href="https://stackoverflow.com/users/31667/viraptor">@viraptor</a> says, it is even better to use a generator instead of <code>map</code>. See <a href="https://stackoverflow.com/users/391531/nathon">@Nathon</a>'s <a href="https://stackoverflow.com/questions/3627784/case-insensitive-in-python/3627815#3627815">answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do</p>
<pre><code>matcher = re.compile('MICHAEL89', re.IGNORECASE)
filter(matcher.match, USERNAMES) 
</code></pre>
<p>Update:  played around a bit and am thinking you could get a better short-circuit type approach using</p>
<pre><code>matcher = re.compile('MICHAEL89', re.IGNORECASE)
if any( ifilter( matcher.match, USERNAMES ) ):
    #your code here
</code></pre>
<p>The <code>ifilter</code> function is from itertools, one of my favorite modules within Python.  It's faster than a generator but only creates the next item of the list when called upon.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>str.casefold</code> is recommended for case-insensitive string matching. <a href="https://stackoverflow.com/a/3627815/9209546">@nmichaels's solution</a> can trivially be adapted.</p>
<p>Use either:</p>
<pre><code>if 'MICHAEL89'.casefold() in (name.casefold() for name in USERNAMES):
</code></pre>
<p>Or:</p>
<pre><code>if 'MICHAEL89'.casefold() in map(str.casefold, USERNAMES):
</code></pre>
<p>As per the <a href="https://docs.python.org/3/library/stdtypes.html#str.casefold" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>Casefolding is similar to lowercasing but more aggressive because it
  is intended to remove all case distinctions in a string. For example,
  the German lowercase letter 'ß' is equivalent to "ss". Since it is
  already lowercase, <code>lower()</code> would do nothing to 'ß'; <code>casefold()</code>
  converts it to "ss".</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Here's one way:</p>
<pre><code>if string1.lower() in string2.lower(): 
    ...
</code></pre>
<p>For this to work, both <code>string1</code> and <code>string2</code> objects must be of type <code>string</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>My 5 cents</p>
<blockquote>
<p>'a' in "".join(['A']).lower()</p>
</blockquote>
</div>
<span class="comment-copy"><code>if 'CaseFudge'.lower() in [x.lower() for x in list]</code></span>
<span class="comment-copy"><code>[...]</code> creates the whole list. <code>(name.upper() for name in USERNAMES)</code> would create only a generator and one needed string at a time - massive memory savings if you're doing this operation a lot. (even more savings, if you simply create a list of lowercase usernames that you reuse for checking every time)</span>
<span class="comment-copy">Prefer to lower all keys when building the dict, for performance reasons.</span>
<span class="comment-copy">if [x.lower() for x in list] is a list comprehension, is (name.upper() for name in USERNAMES) a tuple comprehension? Or does it have another name?</span>
<span class="comment-copy">@otocan It's a generator expression.</span>
<span class="comment-copy">that doesn't work for dict try if CaseInsensitively('MICHAEL89') in {'Michael89':True}:print "found"</span>
<span class="comment-copy">Xavier: You would need <code>CaseInsensitively('MICHAEL89') in {CaseInsensitively('Michael89'):True}</code> for that to work, which probably doesn't fall under "behave as required".</span>
<span class="comment-copy">So much for there being only 1 obvious way to do it. This feels heavy unless it's going to be used a lot. That said, it's very smooth.</span>
<span class="comment-copy">@Nathon, it seems to me that having to invasively alter the container is the "feels heavy" operation.  A completely non-invasive wrapper: how much "lighter" than this could one get?!  Not much;-).  @Xavier, RHS's that are dicts or sets with mixed-case keys/items need their own non-invasive wrappers (part of the short <code>etc.</code> and "require more effort" parts of my answer;-).</span>
<span class="comment-copy">My definition of heavy involves writing quite a bit of code to make something that will only be used once, where a less robust but much shorter version would do. If this is going to be used more than once, it's perfectly sensible.</span>
<span class="comment-copy">Or you could use <code>itertools</code> function <code>imap</code>.  It's much faster than a generator but accomplishes the same goal.</span>
<span class="comment-copy">Just to add, the pattern might need to be escaped, since it might contain characters like ".","?", which has specail meaning in regular expression patterns. use re.escape(raw_string) to do it</span>
<span class="comment-copy">AttributeError: 'list' object has no attribute 'lower'</span>
<span class="comment-copy">@Jeff that's because one of your elements is a list, and both objects should be a string. Which object is a list?</span>
<span class="comment-copy">I would up vote you, but I cannot unless you edit your answer. You are absolutely right.</span>
<span class="comment-copy">@Jeff I added clarification.</span>
