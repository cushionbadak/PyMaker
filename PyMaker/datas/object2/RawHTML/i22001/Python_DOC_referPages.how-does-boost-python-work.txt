<div class="post-text" itemprop="text">
<p>How is Python able to call C++ objects when the interpreter is C and has been built w/ a C compiler?</p>
</div>
<div class="post-text" itemprop="text">
<p>Boost.Python has special macros that declare functions with <code>extern "C"</code> so the Python interpreter will be able to call them.  It's kind of complicated, but you can look at the <a href="http://www.boost.org/doc/libs/1_44_0/libs/python/doc/v2/module.html#BOOST_PYTHON_MODULE-spec" rel="noreferrer">Boost documentation</a> for more info.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python declares a C-API (see <a href="http://docs.python.org/2/c-api/" rel="nofollow noreferrer">http://docs.python.org/2/c-api/</a> or <a href="http://docs.python.org/3/c-api/" rel="nofollow noreferrer">http://docs.python.org/3/c-api/</a>). This API defines a generic object type called <code>PyObject</code> which is just a normal C struct. This structure defines (nearly) everything a python object can do, e.g., what happens when do additions or comparisons on this object or simply call it like a function. </p>
<p>Because python types are also objects (and therefore are represented in C by a <code>PyObject</code> structure), defining a new type is a simple matter of defining a new <code>PyObject</code> struct like that one. When methods are called in Python, the interpreter forwards the call to C functions associated with this structure.</p>
<p>As long as a given (compiled) extension provides the correct entry points such that the Python interpreter can introspect it and find out what is available (the documentation I indicated above does explain this in details), then it can use these objects like any other object you normally have available at the prompt - which BTW, are constructed using the very same C-API. It suffices you <code>import</code> the compiled extension. </p>
<p>I hope it is somewhat clear how the Python interpreter calls stuff from compiled extensions from the above. The sole missing gap is how the C-API calls the C++ code. </p>
<p>Boost.Python does this by declaring C entry points in code along the lines as explained here: <a href="https://stackoverflow.com/questions/7281441/elegantly-call-c-from-c">Elegantly call C++ from C</a>. Every time you call, e.g., <code>boost::python::class_</code>, it does this for the type you declare to python, creating therefore a <code>PyObject</code> that represents your class, with the name you choose. As you call <code>.def</code> on this class you go filling in the internal slots of that structure, declaring more methods, operators and attributes of your new type. Each of these internal slots points to a C-style function that is nothing but a wrapper to the equivalent C++ call.</p>
</div>
<div class="post-text" itemprop="text">
<p>C++ can interoperate with C by extern "C" declarations.</p>
</div>
