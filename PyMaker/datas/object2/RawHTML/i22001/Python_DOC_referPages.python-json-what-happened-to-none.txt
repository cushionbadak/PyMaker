<div class="post-text" itemprop="text">
<p>Dumping and loading a dict with <a href="https://docs.python.org/3/library/constants.html#None" rel="noreferrer"><code>None</code></a> as key, results in a <a href="https://docs.python.org/3.7/tutorial/datastructures.html#dictionaries" rel="noreferrer">dictionary</a> with <code>'null'</code> as the key.</p>
<p>Values are un-affected, but things get even worse if a string-key <code>'null'</code> actually exists.</p>
<p>What am I doing wrong here? Why can't I serialize/deserialize a <a href="https://docs.python.org/3.7/library/stdtypes.html#dict" rel="noreferrer"><code>dict</code></a> with <code>None</code> keys?</p>
<h1>Example</h1>
<pre><code>&gt;&gt;&gt; json.loads(json.dumps({'123':None, None:'What happened to None?'}))
{u'123': None, u'null': u'What happened to None?'}
&gt;&gt;&gt; json.loads(json.dumps({'123':None, None:'What happened to None?', 'null': 'boom'}))
{u'123': None, u'null': u'boom'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>JSON objects are maps of <em>strings</em> to values.  If you try to use another type of key, they'll get converted to strings.</p>
<pre><code>&gt;&gt;&gt; json.loads(json.dumps({123: None}))
{'123': None}
&gt;&gt;&gt; json.loads(json.dumps({None: None}))
{'null': None}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="http://www.json.org/" rel="noreferrer">specification</a>, <code>None</code> is not a valid key. It would amount to a JSON object expression, which looks like</p>
<pre><code>{ ..., null: ..., ... }
</code></pre>
<p>which is not valid (i.e., cannot be generated using the syntax diagram.)</p>
<p>Arguably, the JSON module should have raised an exception upon serialization instead of silently generating a string representation of the value.</p>
<p><strong>EDIT</strong> Just saw, that the behaviour of the module is <a href="http://docs.python.org/library/json.html#basic-usage" rel="noreferrer">documented</a> (somewhat implicitly):</p>
<blockquote>
<p>If skipkeys is True (default: False), then dict keys that are not of a basic type (str, unicode, int, long, float, bool, None) will be skipped instead of raising a TypeError.</p>
</blockquote>
<p>so it seems, as if this behaviour is intentional (I still find it questionable given the current JSON specification).</p>
</div>
<div class="post-text" itemprop="text">
<p>As @dan04 shows, None is converted to 'null'.<br/>
Everything is fine, the value is stored into the dict with "null: 'What happened to None?'"<br/><br/>
But then came another Key with 'null'.<br/>
So the old value with the None/'null'-Key ("What happened to None?") is overwritten with "boom".</p>
</div>
<span class="comment-copy">Btw output of the second code seems to have been fiddled with.</span>
<span class="comment-copy">skipKeys does not have an effect on the observed behavior. "None" is a basic type so skipKeys=True would not cause a "skipping" just as skipKeys=False does not cause a TypeError.  I would have liked a small note in the documentation, something like: "For reversible encoding, only use strings as keys."</span>
<span class="comment-copy">Why the downvotes, whats wrong with this answer?</span>
