<div class="post-text" itemprop="text">
<p>I'm trying to get Python to a read line from a .txt file and write the elements of the first line into a list. The elements in the file were tab- separated so I used <code>split("\t")</code> to separate the elements. Because the .txt file has a lot of elements I saved the data found in each line into a separate list.</p>
<p>The problem I currently have is that it's showing each list like this:</p>
<pre><code>['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
</code></pre>
<p>How can I remove <code>\n</code> from the last element of the list and make it just <code>'7.3'</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to remove <code>\n</code> from the last element only, use this:</p>
<pre><code>t[-1] = t[-1].strip()
</code></pre>
<p>If you want to remove <code>\n</code> from all the elements, use this:</p>
<pre><code>t = map(lambda s: s.strip(), t)
</code></pre>
<p>You might also consider removing <code>\n</code> <strong>before</strong> splitting the line:</p>
<pre><code>line = line.strip()
# split line...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2><strong><em>From Python3 onwards</em></strong></h2>
<p><code>map</code> no longer returns a <code>list</code> but a <code>mapObject</code>, thus the answer will look something like</p>
<pre><code>&gt;&gt;&gt; map(lambda x:x.strip(),l)
&lt;map object at 0x7f00b1839fd0&gt;
</code></pre>
<p>You can read more about it on <a href="https://docs.python.org/3.0/whatsnew/3.0.html#views-and-iterators-instead-of-lists">What’s New In Python 3.0</a>.</p>
<blockquote>
<p><code>map()</code> and <code>filter()</code> return iterators. If you really need a <code>list</code>, a quick fix is e.g. <code>list(map(...))</code></p>
</blockquote>
<p><em>So now what are the ways of getting trough this?</em></p>
<hr/>
<h2><strong><em>Case 1 - The <code>list</code> call over <code>map</code> with a <code>lambda</code></em></strong></h2>
<p><code>map</code> returns an <em>iterator</em>. <a href="https://docs.python.org/3/library/functions.html#func-list"><code>list</code></a> is a function that can convert an iterator to a list. Hence you will need to wrap a <code>list</code> call around <code>map</code>. So the answer now becomes,</p>
<pre><code>&gt;&gt;&gt; l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
&gt;&gt;&gt; list(map(lambda x:x.strip(),l))
['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
<p>Very good, we get the output. Now we check the amount of time it takes for this piece of code to execute.</p>
<pre><code>$ python3 -m timeit "l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n'];list(map(lambda x:x.strip(),l))"
100000 loops, best of 3: 2.22 usec per loop
</code></pre>
<p>2.22 microseconds. That is not so bad. But are there more efficient ways?</p>
<hr/>
<h2><strong><em>Case 2 - The <code>list</code> call over <code>map</code> withOUT a <code>lambda</code></em></strong></h2>
<p><code>lambda</code> is frowned upon by many in the Python community (including <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">Guido</a>). Apart from that it will greatly reduce the speed of the program. Hence we need to avoid that as much as possible. The toplevel function <a href="https://docs.python.org/3/library/stdtypes.html#str.strip"><code>str.strip</code></a>. Comes to our aid here. </p>
<p>The <code>map</code> can be re-written without using <code>lambda</code> using <code>str.strip</code> as</p>
<pre><code>&gt;&gt;&gt; list(map(str.strip,l))
['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
<p>And now for the times. </p>
<pre><code>$ python3 -m timeit "l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n'];list(map(str.strip,l))"
1000000 loops, best of 3: 1.38 usec per loop
</code></pre>
<p>Fantastic. You can see the efficiency differences between the two ways. It is nearly 60% faster. Thus the approach without using a <code>lambda</code> is a better choice here.</p>
<hr/>
<h2><strong><em>Case 3 - Following Guidelines, The Regular way</em></strong></h2>
<p>Another important point from <a href="https://docs.python.org/3.0/whatsnew/3.0.html#views-and-iterators-instead-of-lists">What’s New In Python 3.0</a> is that it advices us to avoid <code>map</code> where possible.</p>
<blockquote>
<p>Particularly tricky is <code>map()</code> invoked for the side effects of the
  function; the correct transformation is to use a regular <code>for</code> loop
  (since creating a list would just be wasteful).</p>
</blockquote>
<p>So we can solve this problem without a <code>map</code> by using a regular <code>for</code> loop. </p>
<p>The trivial way of solving (the brute-force) would be:-</p>
<pre><code>&gt;&gt;&gt; l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
&gt;&gt;&gt; final_list = []
&gt;&gt;&gt; for i in l:
...     final_list.append(i.strip())
... 
&gt;&gt;&gt; final_list
['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
<p>The timing setup</p>
<pre><code>def f():
    l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
    final_list = []
    for i in l:
         final_list.append(i.strip())
import timeit
print(min(timeit.repeat("f()","from __main__ import f")))
</code></pre>
<p>And the result. </p>
<pre><code>1.5322505849981098
</code></pre>
<p>As you can see the brute-force is a bit slower here. But it is definitely more readable to a common programmer than a <code>map</code> clause. </p>
<hr/>
<h2><strong><em>Case 4 - List Comprehensions</em></strong></h2>
<p>A <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehension</a> here is also possible and is the same as in Python2.</p>
<pre><code>&gt;&gt;&gt; [i.strip() for i in l]
['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
<p>Now for the timings:</p>
<pre><code>$ python3 -m timeit "l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n'];[i.strip() for i in l]"
1000000 loops, best of 3: 1.28 usec per loop
</code></pre>
<p>As you can see the list-comprehension is more effective than <code>map</code> (even that without a <code>lambda</code>). <strong><em>Hence the thumb rule in Python3 is to use a list comprehension instead of <code>map</code></em></strong></p>
<hr/>
<h2><strong><em>Case 5 - In-Place mechanisms and Space Efficiency (<a href="https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff">T-M-T</a>)</em></strong></h2>
<p>A final way is to make the changes in-place within the list itself. This will save a lot of memory space. This can be done using <a href="https://docs.python.org/3/library/functions.html#enumerate"><code>enumerate</code></a>.</p>
<pre><code>&gt;&gt;&gt; l = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
&gt;&gt;&gt; for i,s in enumerate(l):
...     l[i] = s.strip()
... 
&gt;&gt;&gt; l
['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
<p>The timing result would be <code>1.4806894720022683</code>. But however this way is space effective. </p>
<hr/>
<h2><strong><em>Conclusion</em></strong></h2>
<p>A comparitive list of timings (Both Python 3.4.3 and Python 3.5.0) </p>
<pre><code>----------------------------------------------------
|Case| method          | Py3.4 |Place| Py3.5 |Place|
|----|-----------------|-------|-----|-------|-----|
| 1  | map with lambda | 2.22u | 5   | 2.85u | 5   |
| 2  | map w/o lambda  | 1.38u | 2   | 2.00u | 2   |
| 3  | brute-force     | 1.53u | 4   | 2.22u | 4   |
| 4  | list comp       | 1.28u | 1   | 1.25u | 1   |
| 5  | in-place        | 1.48u | 3   | 2.14u | 3   |
----------------------------------------------------
</code></pre>
<p>Finally note that the list-comprehension is the best way and the <code>map</code> using <code>lambda</code> is the worst. But again --- <strong><em>ONLY IN PYTHON3</em></strong></p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want something like the Perl <code>chomp()</code> function.</p>
<p>That's trivial to do in Python:</p>
<pre><code>def chomp(s):
    return s[:-1] if s.endswith('\n') else s
</code></pre>
<p>... assuming you're using Python 2.6 or later.  Otherwise just use the slightly
more verbose:</p>
<pre><code>def chomp(s):
    if s.endwith('\n'):
        return s[:-1]
    else:
        return s
</code></pre>
<p>If you want to remove all new lines from the end of a string (in the odd case where one might have multiple trailing newlines for some reason):</p>
<pre><code>def chomps(s):
    return s.rstrip('\n')
</code></pre>
<p>Obviously you should never see such a string returned by any normal Python file object's <code>readline()</code> nor <code>readlines()</code> methods.</p>
<p>I've seen people blindly remove the last characters (using <code>s[:-1]</code> slicing) from the results of file <code>readline()</code> and similar functions.  This is a bad idea because it can lead to an error on the last line of the file (in the case where a file ends with anything other than a newline).</p>
<p>At first you might be lulled into a false sense of security when blindly stripping final characters off lines you've read.  If you use a normal text editor to create your test suite files you'll have a newline silently added to the end of the last line by most of them.  To create a valid test file use code something like:</p>
<pre><code>f = open('sometest.txt', 'w')
f.write('some text')
f.close()
</code></pre>
<p>... and then if you re-open that file and use the <code>readline()</code> or <code>readlines()</code> file methods on it you'll find that the text is read without the trailing newline.</p>
<p>This failure to account for text files ending in non-newline characters has plagued many UNIX utilities and scripting languages for many years.  It's a stupid corner base bug that creeps into code just often enough to be a pest but not often enough for people to learn from it.  We could argue that "text" files without the ultimate newline are "corrupt" or non-standard; and that may be valid for some programming specifications.</p>
<p>However, it's all too easy to ignore corner cases in our coding and have that ignorance bite people who are depending on your code later.  As my wife says: when it comes to programming ... practice safe hex!</p>
</div>
<div class="post-text" itemprop="text">
<p>Using list comprehension:</p>
<pre><code>myList = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']

[(el.strip()) for el in myList]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>from this <a href="https://stackoverflow.com/questions/275018/how-can-i-remove-chomp-a-newline-in-python">link</a>:</p>
<p>you can use rstrip() method. Example</p>
<pre><code>mystring = "hello\n"    
print(mystring.rstrip('\n'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an alternate method, if you know that there are no spaces in your data, which it seems is the case, you can use split() (with no arguments). This splits on white space and uses a more efficient algorithm than the other version of split. It also strips whitespace from both ends.</p>
<pre><code>line = line.split()
</code></pre>
<p>And that's it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do -</p>
<pre><code>DELIMITER = '\t'
lines = list()
for line in open('file.txt'):
    lines.append(line.strip().split(DELIMITER))
</code></pre>
<p>The <code>lines</code> has got all the contents of your file. </p>
<p>One could also use list comprehensions to make this more compact.</p>
<pre><code>lines = [ line.strip().split(DELIMITER) for line in open('file.txt')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This will also work,</p>
<pre><code>f=open('in.txt','r')

    for line in f:
            parline = line[:-1].split(',')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>str.strip() removes the whitespace characters. you can also pass custom characters as argument to strip. The <em>strip</em> function removes the whitespace/custom characters on both ends of the string. lstrip() and rstrip() are left strip and right strip functions resp.</p>
<p>Eg:</p>
<pre><code>test_str = "Vishaka\n" 
test_str = test_str.strip()
</code></pre>
<p>test_str's now Vishaka</p>
</div>
<div class="post-text" itemprop="text">
<p>You access the last element of the set and then store the value in a variable.</p>
<p>So you have:</p>
<pre><code>fileName = '7.3\n'
</code></pre>
<p>then just do:</p>
<pre><code>fileName.strip()
</code></pre>
<p>which will leave you with <code>7.3</code>. Then store that value back in the last element of the set. </p>
<p>You can use <code>lstrip()</code> or <code>rstrip()</code> to remove just the left or right side.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works to take out the <code>\n</code> (new line) off a item in a list
it just takes the first item in string off</p>
<pre><code>def remove_end(s):
    templist=[]
    for i in s:
        templist.append(i)
    return(templist[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had this issue and solved it using the chomp function described above:</p>
<pre><code>def chomp(s):
    return s[:-1] if s.endswith('\n') else s

def trim_newlines(slist):
    for i in range(len(slist)):
        slist[i] = chomp(slist[i])
    return slist
.....
names = theFile.readlines()
names = trim_newlines(names)
....
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To handle many newline delimiters, including character combinations like <code>\r\n</code>, use <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow noreferrer">splitlines</a>.
Combine <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">join</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines" rel="nofollow noreferrer">splitlines</a> to remove/replace all newlines from a string <code>s</code>:</p>
<pre><code>''.join(s.splitlines())
</code></pre>
<p>To remove <em>exactly one <strong>trailing</strong></em></p></div>
<div class="post-text" itemprop="text">
<p>Since the OP's question is about stripping the newline character from the last element, I would reset it with <code>the_list[-1].rstrip()</code>:</p>
<pre><code>&gt;&gt;&gt; the_list = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
&gt;&gt;&gt; the_list[-1] = ls[-1].rstrip()
&gt;&gt;&gt; the_list
['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
<p>It's O(1).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_list = ['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3\n']
for i in range(len(new_list)):
    new_list[i]=new_list[i].replace('\n','')
print(new_list)
</code></pre>
<p>Output Will be like this</p>
<pre><code>['Name1', '7.3', '6.9', '6.6', '6.6', '6.1', '6.4', '7.3']
</code></pre>
</div>
<span class="comment-copy">With the data you have, just use split() (no args). It will strip the whitespace first, then split on whitespace.</span>
<span class="comment-copy">I would do a strip before splitting...i feel its more concise.</span>
<span class="comment-copy">Huzzah! It Works! Thank you very much.</span>
<span class="comment-copy">if I was going to iterate over the list, I would use <code>[s.strip() for s in t]</code> as well. I timed it and it's 5.33 msec to process <code>["s\n"]*10000</code> vs. 9.73 msec for <code>map</code>. <code>map</code> will win if it's mapping a builtin.</span>
<span class="comment-copy"><code>line = line.strip()</code> will remove ALL TRAILING WHITESPACE. This is butchery. Read Jim Dennis's answer.</span>
<span class="comment-copy">@John True.  Not only that, it'll remove all leading whitespace as well.  In many circumstances <code>line.strip()</code> would be more reasonable than <code>line.rstrip('\n')</code> and that's why I wrote it without further explanation.  However, in this case (tab-delimited values) you're 100% right: one should indeed be careful with removing leading and trailing whitespace, since an empty first or last column might "disappear".</span>
<span class="comment-copy">+1 When reading a Python text file, checking for a presence of a newline (or blindly removing it if it exists by <code>line = line.rstrip('\n')</code>) should be done as a separate step BEFORE parsing the line into fields.</span>
<span class="comment-copy">i'm using a variant of this approach to turn a file into a single line javascript variable. nice. thanks Srikar</span>
<span class="comment-copy">This seems like just a duplicate of previous answers. If it adds something, make clear what that is.</span>
