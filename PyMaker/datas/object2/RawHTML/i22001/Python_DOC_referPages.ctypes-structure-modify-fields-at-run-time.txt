<div class="post-text" itemprop="text">
<p>Is it possible to modify the <code>_fields_</code> definition of the <code>ctypes.Structure</code> after it's been imported?</p>
<p>Something like:</p>
<pre><code>from ctypes import *

class A_STRUCT(Structure):
     _fields_ = [("one",c_int)]

A_STRUCT._fields_.append(("two",c_int))

x = A_STRUCT()
print x.one
print x.two
</code></pre>
<p>Not surprisingly this fails with:</p>
<pre><code>0
Traceback (most recent call last):
  File "structEnumTest.py", line 10, in &lt;module&gt;
    print x.two
AttributeError: 'A_STRUCT' object has no attribute 'two'
</code></pre>
<p><strong>EDITS</strong></p>
<p>My use case is that I have two version of <code>A_STRUCT</code>.  Version 2 is the same with additional fields appended to the end of version one.  I was hoping to avoid having something like this.  I do not know which version of the struct is needed until run-time.</p>
<pre><code>class A_STRUCT_V1(Structure):
     _fields_ = [("one",c_int)]

class A_STRUCT_V2(Structure):
     _fields_ = [("one",c_int),("two",c_int)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, as you can see in <a href="http://svn.python.org/view/python/trunk/Modules/_ctypes/_ctypes.c?revision=81029&amp;view=markup" rel="noreferrer">the sources</a>, <code>PyCStructType_Type</code> is a custom metaclass (see lines 327ff in the C code I just pointed to) and <code>Structure</code> (lines 4136ff) uses it (as exposed in 5532ff).  The <code>class</code> statement (specifically when the <code>__new__</code> from the custom metaclass gets called to make the new class which inherits from <code>Structure</code>) is when all C-accessible fields are actually defined (and it's nice of <code>ctypes</code> to make other "smuggled in" fields inaccessible from Python as well to avoid accidents;-).</p>
<p>What problem, exactly, are you trying to solve, that you couldn't solve by rebuilding <code>A_STRUCT</code> from scratch at the time you learn about the extra fields?  For example, if your issue is that there are instances of the "old" <code>A_STRUCT</code> already around, well, obviously, those instances don't have the new fields you've just learned about, so modifying the class, even if through some incredible contortion it was feasible, wouldn't be all that useful;-).</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is a very old question, but you can solve your problem easily by subclassing:  </p>
<pre><code>class A_STRUCT_V1(Structure):
     _fields_ = [("one",c_int)]

class A_STRUCT_V2(A_STRUCT_V1):
     _fields_ = [("two",c_int)]
</code></pre>
<p>'two' will immediately follow 'one' in memory for objects of type A_STRUCT_V2</p>
<p>If the subclasses <em>fields</em> name duplicates its parent class <em>fields</em> member, the parent's <em>is not replaced</em>, it still takes the same memory (though is inaccessible with a statement like child.two, and the second member is placed after it.</p>
</div>
<span class="comment-copy">@Alex, thanks for the response.  See edits above for my use case.  Could you elaborate on what you mean by "rebuilding A_STRUCT from scratch"?</span>
<span class="comment-copy">@Mark, by "rebuilding A_STRUCT from scratch" I mean exactly that -- with either a <code>class</code> statement or a direct call to Structure's metaclass, build a "new and improved" version on the fly (and bind it to the same name A_STRUCT if you wish).  If you don't know the fields "until runtime", say the list of fields comes from a function <code>def foo():...</code>, do <code>class A_STRUCT(Structure): __fields__ = foo()</code> -- no need to build A_STRUCT first and then rebuild it later, just build it (execute its <code>class</code> statement) at the time you <b>know</b> how it needs to be.</span>
<span class="comment-copy">@Alex, thanks for all your help.  One more question, if I may.  When you say "execute its class statement", this happens on import correct?  Would I need to resort to something like this is pass the foo:   foo = lambda: [("one",ctypes.c_int)]; execfile("structTest.py",globals(),locals())?</span>
<span class="comment-copy">@Mark, the class statement, like every other, is executed when control reaches it -- that's "on import" only if you put it as one of a module's top-level statements, which is usually done if there are no special reason to do otherwise.  Just put it in a function, called when you finally have the info: that function need only contain the <code>class</code> statement and then a <code>return A_STRUCT</code>, and you can call it as <code>A_STRUCT = thefunction()</code> (or with arguments of course, or add a <code>global A_STRUCT</code> in the function or in its caller if you need to, and so forth).</span>
<span class="comment-copy">@Alex, thanks again.  Looks like I was trying to make it overly complicated.  Rolling it into a function is perfect.</span>
<span class="comment-copy">+1 this should be accepted answer. Supported by <a href="https://docs.python.org/3/library/ctypes.html#ctypes.Structure._fields_" rel="nofollow noreferrer">the ctypes docs</a>: "It is possible to defined sub-subclasses of structure types, they inherit the fields of the base class plus the <code>_fields_</code> defined in the sub-subclass, if any."</span>
