<div class="post-text" itemprop="text">
<p>In Python, strings are immutable.</p>
<p>What is the standard idiom to walk through a string character-by-character and modify it?</p>
<p>The only methods I can think of are some genuinely stanky hacks related to joining against a result string.</p>
<p>--</p>
<p>In C:</p>
<pre><code>for(int i = 0; i &lt; strlen(s); i++)
{
   s[i] = F(s[i]);
}
</code></pre>
<p>This is <em>super</em> expressive and says exactly what I am doing. That is what I am looking for. </p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use a string, use something mutable like bytearray:</p>
<pre><code>#!/usr/bin/python

s = bytearray("my dog has fleas")
for n in xrange(len(s)):
    s[n] = chr(s[n]).upper()
print s
</code></pre>
<p>Results in:</p>
<pre><code>MY DOG HAS FLEAS
</code></pre>
<p>Edit:</p>
<p>Since this is a <code>bytearray</code>, you aren't (necessarily) working with <em>characters</em>. You're working with <em>bytes</em>. So this works too:</p>
<pre><code>s = bytearray("\x81\x82\x83")
for n in xrange(len(s)):
    s[n] = s[n] + 1
print repr(s)
</code></pre>
<p>gives:</p>
<pre><code>bytearray(b'\x82\x83\x84')
</code></pre>
<p>If you want to modify characters in a Unicode string, you'd maybe want to work with <a href="http://docs.python.org/library/stdtypes.html#memoryview-type" rel="noreferrer"><code>memoryview</code></a>, though that doesn't support Unicode directly.</p>
</div>
<div class="post-text" itemprop="text">
<p>The Python analog of your C:</p>
<pre><code>for(int i = 0; i &lt; strlen(s); i++)
{
   s[i] = F(s[i]);
}
</code></pre>
<p>would be:</p>
<pre><code>s = "".join(F(c) for c in s)
</code></pre>
<p>which is also very expressive.  It says exactly what is happening, but in a functional style rather than a procedural style.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use the UserString module:</p>
<pre><code> &gt;&gt;&gt; import UserString
... s = UserString.MutableString('Python')
... print s
Python
&gt;&gt;&gt; s[0] = 'c'
&gt;&gt;&gt; print s
cython
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd say the most Pythonic way is to use <a href="http://docs.python.org/library/functions.html#map" rel="noreferrer"><code>map()</code></a>:</p>
<pre><code>s = map(func, s) # func has been applied to every character in s
</code></pre>
<p>This is the equivalent of writing:</p>
<pre><code>s = "".join(func(c) for c in s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>string.translate</code> is probably the closest function to what you're after.</p>
</div>
<div class="post-text" itemprop="text">
<p>Strings are iterable and can be walked through like lists.  Strings also have a number of basic methods such as <code>.replace()</code> that might be what you're looking for.  All string methods return a new string. So instead of modifying the string in place you can simply replace its existing value.</p>
<pre><code>&gt;&gt;&gt; mystring = 'robot drama'
&gt;&gt;&gt; mystring = mystring.replace('r', 'g')
&gt;&gt;&gt; mystring
'gobot dgama'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assigning a particular character to a particular index in a string is not a particularly common operation, so if you find yourself needing to do it, think about whether there may be a better way to accomplish the task. But if you do need to, probably the most standard way would be to convert the string to a list, make your modifications, and then convert it back to a string.</p>
<pre><code>s = 'abcdefgh'
l = list(s)
l[3] = 'r'
s2 = ''.join(l)
</code></pre>
<p><strong>EDIT:</strong> As posted in bstpierre's answer, <code>bytearray</code> is probably even better for this task than <code>list</code>, as long as you're not working with Unicode strings.</p>
<pre><code>s = 'abcdefgh'
b = bytearray(s)
b[3] = 'r'
s2 = str(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; mystring = "Th1s 1s my str1ng"
&gt;&gt;&gt; mystring.replace("1", "i")
'This is my string'
</code></pre>
<p>If you want to store this <em>new</em> string you'll have to <code>mystring = mystring.replace("1", "i")</code>. This is because in Python strings are immutable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example using translate to switch "-" with "." and uppercase "a"s</p>
<pre><code>&gt;&gt;&gt; from string import maketrans
&gt;&gt;&gt; trans_table = maketrans(".-a","-.A")
&gt;&gt;&gt; "foo-bar.".translate(trans_table)
'foo.bAr-'
</code></pre>
<p>This is much more efficient that flipping to byte array and back if you just need to do single char replacements</p>
</div>
<div class="post-text" itemprop="text">
<p>The question first states that strings are immutable and then asks for a way to change them in place. This is kind of contradictory. Anyway, as this question pops up at the top of the list when you search for "python string in-place modification", I'm adding the answer for a real in place change.</p>
<p>Strings seem to be immutable when you look at the methods of the string class. But no language with an interface to C can really provide immutable data types. The only question is whether you have to write C code in order to achieve the desired modification.</p>
<p>Here python <code>ctypes</code> is your friend. As it supports getting pointers and includes C-like memory copy functions, a python string <em>can</em> be modified in place like this:</p>
<pre><code>s = 16 * "."
print s
ctypes.memmove(ctypes.c_char_p(s), "Replacement", 11)
print s
</code></pre>
<p>Results in:</p>
<pre><code>................
Replacement.....
</code></pre>
<p>(Of course, you can calculate the replacement string at runtime by applying a function <code>F</code> to every character of the original string. Different ways how to do this have been shown in the previous answers.)</p>
<p>Note that I do not in any way encourage doing this. However, I had to write a replacement for a class that was mapped from C++ to python and included a method:</p>
<pre><code>int readData(char* data, int length)
</code></pre>
<p>(The caller is supposed to provide memory with <code>length</code> bytes and the method then writes the available data -- up to <code>length</code> -- into that memory, returning the number of bytes written.) While this is a perfectly sensible API in C/C++, it should not have been made available as method of a python class or at least the users of the API should be made aware that they may only pass mutable byte arrays as parameter. </p>
<p>As you might expect, "common usage" of the method is as shown in my example (create a string and pass it together with its length as arguments). As I did not really want to write a C/C++ extension I had to come up with a solution for implementing the behavior in my replacement class using python only.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def modifyIdx(s, idx, newchar):
    return s[:idx] + newchar + s[idx+1:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I ever need to do something like that I just convert it to a mutable list</p>
<p>For example... (though it would be easier to use sort (see second example) )</p>
<pre><code>&gt;&gt;&gt; s = "abcdfe"
&gt;&gt;&gt; s = list(s)
&gt;&gt;&gt; s[4] = "e"
&gt;&gt;&gt; s[5] = "f"
&gt;&gt;&gt; s = ''.join(s)
&gt;&gt;&gt; print s
abcdef
&gt;&gt;&gt;
# second example
&gt;&gt;&gt; s.sort()
&gt;&gt;&gt; s = ''.join(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow noreferrer">StringIO</a> class to receive file-like mutable interface of string. </p>
</div>
<span class="comment-copy">I guess since they are immutable you can't "modify it"... do you mean constructing a new string char-by-char?</span>
<span class="comment-copy">This is really rare.  Can you give a context or a use case for doing this?</span>
<span class="comment-copy">Adding noise to a message for testing.</span>
<span class="comment-copy">@Paul Nathan: "Adding noise to a message"?  As in "replacing characters at random"?  What's wrong with <code>replace</code> for this?</span>
<span class="comment-copy">@S.Lott: Replace selects against pre-known elements in the list ``mystring.replace("1", "i")`; whereas I want to iterate by index - I don't know what elements will be in the list per se. (Why does this have to be such a pain?)</span>
<span class="comment-copy">They aren't Characters, however, just bytes.  Works only for ASCII, not Unicode.</span>
<span class="comment-copy">Works for valid <i>bytes</i>, not just ASCII.</span>
<span class="comment-copy">Interesting; I sort of like it, except for the null string. Probably as good as I'm getting though.</span>
<span class="comment-copy">A significant part of the C to me is that it works in-place.</span>
<span class="comment-copy">@Joe Koberg: A significant part of the Python is that it's shorter and more clear.  "in place" is limiting because you can't make the string longer.</span>
<span class="comment-copy">I understand that, but the OP seemed to be focusing on it.  And rejected many standard python string transformation methods.  That it didn't work in-place was the only thing left.</span>
<span class="comment-copy">@JavierBadia: map() is also less performant unless you're using built-in functions, as a rule.</span>
<span class="comment-copy">Note that MutableString was deprecated in Python 2.6 and removed in Python 3 - <a href="https://docs.python.org/2/library/userdict.html#UserString.MutableString" rel="nofollow noreferrer">docs.python.org/2/library/â€¦</a></span>
<span class="comment-copy">Minor correction/point: One still needs to re-join the returned list (/iter/map-obj in Py3+). So the above should be:      <code>s = "".join(map(func, s))</code></span>
<span class="comment-copy">Interesting function - what I'm looking for, however, is to be able to adjust at a given index (or return a string that has that given index modified).</span>
<span class="comment-copy">no need to import from string, <code>str</code> objects have the <code>translate</code> method. It's usually handy to use <code>maketrans</code> from the <code>string</code> module though</span>
<span class="comment-copy">Strings are <i>immutable</i> and cannot be assigned to by member.</span>
<span class="comment-copy">Correct. All string operations return a copy of the input string. The variable name is NOT immutable, however, so by re-assigning a string operation to the same variable name, you are effectively "mutating" the string.</span>
<span class="comment-copy">"In the gage case of altegations to a stging, which do not incgease og decgease its length, it would still be useful if one could use the slice notation fog in-place adjustments: <code>myStr[0:3][:] = 'new'</code>".replace("g","r")</span>
<span class="comment-copy">And if you are working with multibyte strings you better be careful not to chop an encoded character!</span>
<span class="comment-copy">1: Don't use "string" as a variable name. 2: That doesn't modify the variable.</span>
<span class="comment-copy">That doesn't select by index and modify it.</span>
<span class="comment-copy">@bstpierre: There you go. :)</span>
<span class="comment-copy">@Paul Nathan: Where was "by index" a requirement?</span>
<span class="comment-copy">links are broken</span>
