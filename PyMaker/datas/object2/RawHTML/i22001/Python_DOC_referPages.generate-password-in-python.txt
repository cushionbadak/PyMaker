<div class="post-text" itemprop="text">
<p>I'dl like to generate some alphanumeric passwords in python. Some possible ways are:</p>
<pre><code>import string
from random import sample, choice
chars = string.letters + string.digits
length = 8
''.join(sample(chars,length)) # way 1
''.join([choice(chars) for i in range(length)]) # way 2
</code></pre>
<p>But I don't like both because:  </p>
<ul>
<li><strong>way 1</strong> only unique chars selected and you can't generate passwords where length &gt; len(chars)</li>
<li><strong>way 2</strong> we have <code>i</code> variable unused and I can't find good way how to avoid that</li>
</ul>
<p>So, any other good options?</p>
<p>P.S. So here we are with some testing with <code>timeit</code> for 100000 iterations:</p>
<pre><code>''.join(sample(chars,length)) # way 1; 2.5 seconds
''.join([choice(chars) for i in range(length)]) # way 2; 1.8 seconds (optimizer helps?)
''.join(choice(chars) for _ in range(length)) # way 3; 1.8 seconds
''.join(choice(chars) for _ in xrange(length)) # way 4; 1.73 seconds
''.join(map(lambda x: random.choice(chars), range(length))) # way 5; 2.27 seconds
</code></pre>
<p>So, the winner is <code>''.join(choice(chars) for _ in xrange(length))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<h2><strong>Python 3.6 onwards</strong></h2>
<p>You should use the <a href="https://docs.python.org/3.6/library/secrets.html" rel="noreferrer">secrets module</a> to generate cryptographically safe passwords, which is available starting in Python 3.6. Adapted from the documentation:</p>
<pre><code>import secrets
import string
alphabet = string.ascii_letters + string.digits
password = ''.join(secrets.choice(alphabet) for i in range(20)) # for a 20-character password
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the crypto-PRNG folks out there:</p>
<pre><code>def generate_temp_password(length):
    if not isinstance(length, int) or length &lt; 8:
        raise ValueError("temp password must have positive length")

    chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"
    from os import urandom
    return "".join(chars[ord(c) % len(chars)] for c in urandom(length))
</code></pre>
<p>Note that for an even distribution, the <code>chars</code> string length ought to be an integral divisor of 128; otherwise, you'll need a different way to choose uniformly from the space.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>WARNING</strong> this answer should be ignored due to critical security issues!</p>
<p>Option #2 seems quite reasonable except you could add a couple of improvements:</p>
<pre><code>''.join(choice(chars) for _ in range(length))          # in py2k use xrange
</code></pre>
<p><code>_</code> is a conventional "I don't care what is in there" variable. And you don't need list comprehension there, generator expression works just fine for <code>str.join</code>. It is also not clear what "slow" means, if it is the only <em>correct</em> way.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this'll do the trick. <code>random.SystemRandom</code> uses the same underlying crypto random function as <code>os.urandom</code> but it uses the familiar <code>random</code> interface.  This function won't be subject to the weird 128 byte thing as in Ben's answer.  </p>
<pre><code>import random
import string

def gen_random_string(char_set, length):
    if not hasattr(gen_random_string, "rng"):
        gen_random_string.rng = random.SystemRandom() # Create a static variable
    return ''.join([ gen_random_string.rng.choice(char_set) for _ in xrange(length) ])

password_charset = string.ascii_letters + string.digits
gen_random_string(password_charset, 32)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest the following for those stuck on python &lt;3.6:</p>
<pre><code>import os, math, string, struct

def generate_password(pass_len):
    symbols = string.printable.strip()
    return ''.join([symbols[x * len(symbols) / 256] for x in struct.unpack('%dB' % (pass_len,), os.urandom(pass_len))])
</code></pre>
<p>This has the advantage over Ben Mosher's solution that the each symbol from symbols has an equal change of occurring whereas using modulus slightly favors the first symbols in the alpabet. The alphabet of symbols is also larger in this suggestion.</p>
</div>
<div class="post-text" itemprop="text">
<p>I wrote a <a href="http://bitbucket.org/kniht/scraps/src/104d8782bb83/python/newpass.py" rel="nofollow">script</a> with my preferences, which mostly are concerned with avoiding mistakes when transcribing and remembering.  (For example: remove somewhat ambiguous and no repeated characters.)</p>
<pre><code>import optparse
import os
import random
import sys

DEFAULT_CHARS = "234679ADEFGHJKLMNPRTUWabdefghijkmnpqrstuwy"
DEFAULT_LEN = 18

def choices(options, length, choice=random.choice):
  return (choice(options) for _ in xrange(length))

def choices_non_repeated(options, length, choice=random.choice):
  assert len(options) &gt; 1
  last = choice(options)
  count = 0
  while count &lt; length:
    yield last
    count += 1

    while True:
      value = choice(options)
      if value != last:
        last = value
        break

def main(args):
  op = optparse.OptionParser(add_help_option=False)
  op.add_option("--help", action="help",
    help="show help message and exit")
  op.add_option("-b", "--bare", action="store_true", default=False,
    help="print passwords without trailing newline")
  op.add_option("-c", "--chars", metavar="SET", nargs=1, default=DEFAULT_CHARS,
    help="character set to use (default: %default)")
  op.add_option("--repeat", action="store_true", default=False,
    help="allow repetition")
  op.add_option("-l", "--len", dest="max", nargs=1, type="int", default=DEFAULT_LEN,
    help="max length (default: %default)")
  op.add_option("--min", nargs=1, type="int", default=None,
    help="min length (defaults to max)")
  op.add_option("-n", "--count", nargs=1, type="int", default=None,
    help="number of passwords to generate (default: %default)")
  op.add_option("--cols", type="int", default=None,
    help="number of columns to use")
  opts, args = op.parse_args(args)
  if args:
    op.error("unknown arguments")

  if os.isatty(sys.stdin.fileno()) and (
    opts.count is None and opts.cols is None
    and not opts.bare
  ):
    opts.cols = 80 // (opts.max + 1)
    opts.count = opts.cols * 25
  else:
    if opts.count is None:
      opts.count = 1
    if opts.cols is None:
      opts.cols = 1

  if opts.bare and opts.cols != 1:
    op.error("bare output requires --cols=1")

  if opts.min == None:
    opts.min = opts.max

  if any(x &lt; 1 for x in [opts.cols, opts.count, opts.min, opts.max]):
    op.error("values must be &gt;= 1")

  choices_func = choices_non_repeated
  if opts.repeat:
    choices_func = choices
  elif len(set(opts.chars)) &lt; 2:
    op.error("must allow repetition or provide a longer character set")
    return "op.error shouldn't return"

  col = 0
  for _ in xrange(opts.count):
    length = random.randint(opts.min, opts.max)
    password = "".join(choices_func(opts.chars, length))
    sys.stdout.write(password)
    if not opts.bare:
      col += 1
      if col == opts.cols:
        sys.stdout.write("\n")
        col = 0
      else:
        sys.stdout.write(" ")


if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may want to use <code>map</code> instead of list comprehensions:</p>
<pre><code>''.join(map(lambda x: random.choice(chars), range(length)))
</code></pre>
</div>
<span class="comment-copy">There's nothing really wrong with the second option. Is it <i>too</i> slow? Do you need it to be faster? Are you running out of memory?</span>
<span class="comment-copy">don't use list comprehension for the 2nd option. use generator expression.</span>
<span class="comment-copy">use <code>_</code> instead.</span>
<span class="comment-copy">@SilengGhost: Nice trick with _ If you make it as answer I'll accept it.</span>
<span class="comment-copy">Just quick FYI, the draft <a href="https://www.python.org/dev/peps/pep-0506/" rel="nofollow noreferrer">PEP 0506 -- Adding A Secrets Module To The Standard Library</a> just came out and it specifically links to this question and an answer.</span>
<span class="comment-copy">There is an example on the Python website for creating passwords using this method with password requirements such as number of digits: <a href="https://docs.python.org/3/library/secrets.html#recipes-and-best-practices" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a></span>
<span class="comment-copy">You can eliminate the list in the last line via a generator expression: <code>return "".join(chars[ord(c) % len(chars)] for c in urandom(length))</code></span>
<span class="comment-copy">This is the best answer, but you should clearify the answer so that anyone finding this via Google understands why it's the best one.</span>
<span class="comment-copy">crypto-PRNG stands for "cryptograhically-secure Pseudorandom number generator".  This answer is one of the best because it generates secure passwords. The default pseudorandom number generator in the <code>random</code> module is not secure.</span>
<span class="comment-copy">FWIW, after years of service, this code generated an obscene password. here is another post about the perils of alphanumeric password/id generation: <a href="https://softwareengineering.stackexchange.com/q/143405/32537">softwareengineering.stackexchange.com/q/143405/32537</a></span>
<span class="comment-copy">With xrange in python 2.6 it's 5% faster than with range</span>
<span class="comment-copy">You should use secure random number generators for password generation or your passwords may be easily compromised.  The default python RNG is not a secure one.  "Python uses the Mersenne Twister as the core generator. ... The Mersenne Twister ... is completely unsuitable for cryptographic purposes." -<a href="http://docs.python.org/library/random.html" rel="nofollow noreferrer">docs.python.org/library/random.html</a></span>
<span class="comment-copy">I would like to backup Fasaxc on this. Please look at @livibetter's comment, use the <a href="https://docs.python.org/3.6/library/secrets.html" rel="nofollow noreferrer">secrets</a> module from <a href="https://www.python.org/dev/peps/pep-0506/" rel="nofollow noreferrer">PEP0506</a>. As livibetter stated, this article is referenced as a bad example. I know this is an old question that I am commenting on, but it's still one of the top search results. I'd recommend someone change the accepted answer to gerrit's.</span>
<span class="comment-copy">Why would you want to set <code>rng</code> as an attribute?</span>
<span class="comment-copy">This is so you don't have to initialize <code>random.SystemRandom()</code> each time.</span>
<span class="comment-copy">throws errors like <code>invalid literal for int() with base 10: '\xba'</code> -- so need some fault tolerance added</span>
<span class="comment-copy">Huh, I can't really understand how I missed that. Updated answer with fixed code (added struct.unpack()) and also cleaned up index calculation.</span>
<span class="comment-copy">this is slow indeed.</span>
<span class="comment-copy">@SilentGhost: 8 microseconds on my PC.</span>
<span class="comment-copy">@Richie: compared to how many for generator expression?</span>
<span class="comment-copy">@SilentGhost: My point is that the ability to generate a hundred million passwords in one second is not "slow indeed".  It's fast enough - time to move on to solving a real problem.  :-)</span>
<span class="comment-copy">10% faster than way 1; 20% slower than way 2</span>
