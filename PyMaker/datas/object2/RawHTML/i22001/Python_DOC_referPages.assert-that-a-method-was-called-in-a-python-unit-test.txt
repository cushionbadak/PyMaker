<div class="post-text" itemprop="text">
<p>Suppose I have the following code in a Python unit test:</p>
<pre><code>aw = aps.Request("nv1")
aw2 = aps.Request("nv2", aw)
</code></pre>
<p>Is there an easy way to assert that a particular method (in my case <code>aw.Clear()</code>) was called during the second line of the test? e.g. is there something like this:</p>
<pre><code>#pseudocode:
assertMethodIsCalled(aw.Clear, lambda: aps.Request("nv2", aw))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I use <a href="http://pypi.python.org/pypi/mock/" rel="noreferrer">Mock</a> (which is now <a href="https://docs.python.org/dev/library/unittest.mock.html" rel="noreferrer">unittest.mock</a> on py3.3+) for this:</p>
<pre><code>from mock import patch
from PyQt4 import Qt

@patch.object(Qt.QMessageBox, 'aboutQt')
def testShowAboutQt(self, mock):
    self.win.actionAboutQt.trigger()
    self.assertTrue(mock.called)
</code></pre>
<p>For your case, it could look like this:</p>
<pre><code>import mock

def testClearWasCalled(self):
   aw = aps.Request("nv1")
   with patch.object(aw, 'Clear') as mock:
       aw2 = aps.Request("nv2", aw)

   mock.assert_called_with(42) # or mock.assert_called_once_with(42)
</code></pre>
<p>Mock supports quite a few useful features, including ways to patch an object or module, as well as checking that the right thing was called, etc etc. </p>
<p><strong><a href="https://en.wikipedia.org/wiki/Caveat_emptor" rel="noreferrer">Caveat emptor!</a></strong> (Buyer beware!)</p>
<p>If you mistype <code>assert_called_with</code> (to <code>assert_called_once</code> or <code>assert_called_wiht</code>) your test may still run, as Mock will think this is a mocked function and happily go along, unless you use <code>autospec=true</code>. For more info read <a href="http://engineeringblog.yelp.com/2015/02/assert_called_once-threat-or-menace.html" rel="noreferrer">assert_called_once: Threat or Menace</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes if you are using Python 3.3+. You can use the built-in <a href="https://docs.python.org/3/library/unittest.mock.html" rel="noreferrer"><code>unittest.mock</code></a> to assert method called. For Python 2.6+ use the rolling backport <a href="https://pypi.python.org/pypi/mock/" rel="noreferrer"><code>Mock</code></a>, which is the same thing.</p>
<p>Here is a quick example in your case:</p>
<pre><code>from unittest.mock import MagicMock
aw = aps.Request("nv1")
aw.Clear = MagicMock()
aw2 = aps.Request("nv2", aw)
assert aw.Clear.called
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm not aware of anything built-in.  It's pretty simple to implement:</p>
<pre><code>class assertMethodIsCalled(object):
    def __init__(self, obj, method):
        self.obj = obj
        self.method = method

    def called(self, *args, **kwargs):
        self.method_called = True
        self.orig_method(*args, **kwargs)

    def __enter__(self):
        self.orig_method = getattr(self.obj, self.method)
        setattr(self.obj, self.method, self.called)
        self.method_called = False

    def __exit__(self, exc_type, exc_value, traceback):
        assert getattr(self.obj, self.method) == self.called,
            "method %s was modified during assertMethodIsCalled" % self.method

        setattr(self.obj, self.method, self.orig_method)

        # If an exception was thrown within the block, we've already failed.
        if traceback is None:
            assert self.method_called,
                "method %s of %s was not called" % (self.method, self.obj)

class test(object):
    def a(self):
        print "test"
    def b(self):
        self.a()

obj = test()
with assertMethodIsCalled(obj, "a"):
    obj.b()
</code></pre>
<p>This requires that the object itself won't modify self.b, which is almost always true.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, I can give you the outline but my Python is a bit rusty and I'm too busy to explain in detail.</p>
<p>Basically, you need to put a proxy in the method that will call the original, eg:</p>
<pre><code> class fred(object):
   def blog(self):
     print "We Blog"


 class methCallLogger(object):
   def __init__(self, meth):
     self.meth = meth

   def __call__(self, code=None):
     self.meth()
     # would also log the fact that it invoked the method

 #example
 f = fred()
 f.blog = methCallLogger(f.blog)
</code></pre>
<p>This <a href="https://stackoverflow.com/questions/111234/what-is-a-callable-in-python">StackOverflow answer</a> about callable may help you understand the above.</p>
<p><strong>In more detail:</strong></p>
<p>Although the answer was accepted, due to the interesting discussion with Glenn and having a few minutes free, I wanted to enlarge on my answer:</p>
<pre><code># helper class defined elsewhere
class methCallLogger(object):
   def __init__(self, meth):
     self.meth = meth
     self.was_called = False

   def __call__(self, code=None):
     self.meth()
     self.was_called = True

#example
class fred(object):
   def blog(self):
     print "We Blog"

f = fred()
g = fred()
f.blog = methCallLogger(f.blog)
g.blog = methCallLogger(g.blog)
f.blog()
assert(f.blog.was_called)
assert(not g.blog.was_called)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can mock out <code>aw.Clear</code>, either manually or using a testing framework like <a href="http://code.google.com/p/pymox/" rel="nofollow">pymox</a>. Manually, you'd do it using something like this:</p>
<pre><code>class MyTest(TestCase):
  def testClear():
    old_clear = aw.Clear
    clear_calls = 0
    aw.Clear = lambda: clear_calls += 1
    aps.Request('nv2', aw)
    assert clear_calls == 1
    aw.Clear = old_clear
</code></pre>
<p>Using pymox, you'd do it like this:</p>
<pre><code>class MyTest(mox.MoxTestBase):
  def testClear():
    aw = self.m.CreateMock(aps.Request)
    aw.Clear()
    self.mox.ReplayAll()
    aps.Request('nv2', aw)
</code></pre>
</div>
<span class="comment-copy">+1 for discretely enlightening my world with the wonderful Mock module.</span>
<span class="comment-copy">@RonCohen: Yeah, it's pretty amazing, and getting better all the time too. :)</span>
<span class="comment-copy">While using mock is definitely the way to go, I'd advise against using assert_called_once, with simply doesn't exist :)</span>
<span class="comment-copy">it's been removed in later versions. My tests are still using it. :)</span>
<span class="comment-copy">Wrt last update and the blog I linked. Now I wonder if my tests did work properly or not. Oh well. That was 4 years ago, at another company. :-|</span>
<span class="comment-copy">I said my Python was rusty, although I did test my solution to make sure it works :-) I internalized Python before version 2.5, in fact I never used 2.5 for any significant Python as we had to freeze at 2.3 for lib compatibility. In reviewing your solution I found <a href="http://effbot.org/zone/python-with-statement.htm" rel="nofollow noreferrer">effbot.org/zone/python-with-statement.htm</a> as a nice clear description. I would humbly suggest my approach looks smaller and might be easier to apply if you wanted more than one point of logging, rather than nested "with"s. I'd really like you to explain if there are any particular benefits of yours.</span>
<span class="comment-copy">@Andy: Your answer is smaller because it's partial: it doesn't actually test the results, it doesn't restore the original function after the test so you can continue using the object, and you have to repeatedly write the code to do all that again each time you write a test.  The number of lines of support code isn't important; this class goes in its own testing module, not inline in a docstring--this takes one or two lines of code in the actual test.</span>
<span class="comment-copy">+1 for using a context manager, neat idea!</span>
<span class="comment-copy">nice. I've added a call count to methCallLogger so I can assert on it.</span>
<span class="comment-copy">This over the thorough, self-contained solution I provided?  Seriously?</span>
<span class="comment-copy">@Glenn I'm very new to Python - maybe your one is better - I just don't understand all of it yet. I'll spend a bit of time later trying it out.</span>
<span class="comment-copy">This is by far the simplest and easiest-to-understand answer. Really nice work!</span>
<span class="comment-copy">I like this approach too, although I still want old_clear to get called. This makes it obvious what's going on.</span>
