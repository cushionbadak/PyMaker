<div class="post-text" itemprop="text">
<p>I want to assign the output of a command I run using <code>os.system</code> to a variable and prevent it from being output to the screen. But, in the below code ,the output is sent to the screen and the value printed for <code>var</code> is 0, which I guess signifies whether the command ran successfully or not. Is there any way to assign the command output to the variable and also stop it from being displayed on the screen?</p>
<pre><code>var = os.system("cat /etc/services")
print var #Prints 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From "<a href="https://stackoverflow.com/questions/1410976/equivalent-of-backticks-in-python">Equivalent of Bash Backticks in Python</a>", which I asked a long time ago, what you may want to use is <code>popen</code>:</p>
<pre><code>os.popen('cat /etc/services').read()
</code></pre>
<p>From the <a href="https://docs.python.org/3.6/library/os.html#os.popen" rel="noreferrer">docs for Python 3.6</a>, </p>
<blockquote>
<p>This is implemented using subprocess.Popen; see that class’s
  documentation for more powerful ways to manage and communicate with
  subprocesses.</p>
</blockquote>
<hr/>
<p>Here's the corresponding code for <code>subprocess</code>:</p>
<pre><code>import subprocess

proc = subprocess.Popen(["cat", "/etc/services"], stdout=subprocess.PIPE, shell=True)
(out, err) = proc.communicate()
print "program output:", out
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might also want to look at the <code>subprocess</code> module, which was built to replace the whole family of Python <code>popen</code>-type calls.</p>
<pre><code>import subprocess
output = subprocess.check_output("cat /etc/services", shell=True)
</code></pre>
<p>The advantage it has is that there is a ton of flexibility with how you invoke commands, where the standard in/out/error streams are connected, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>The commands module is a reasonably high-level way to do this:</p>
<pre><code>import commands
status, output = commands.getstatusoutput("cat /etc/services")
</code></pre>
<p>status is 0, output is the contents of /etc/services.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this has already been answered, but I wanted to share a potentially better looking way to call Popen via the use of <code>from x import x</code> and functions:</p>
<pre><code>from subprocess import PIPE, Popen


def cmdline(command):
    process = Popen(
        args=command,
        stdout=PIPE,
        shell=True
    )
    return process.communicate()[0]

print cmdline("cat /etc/services")
print cmdline('ls')
print cmdline('rpm -qa | grep "php"')
print cmdline('nslookup google.com')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For python 3.5+ it is recommended that you use the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer">run function from the subprocess module</a>. This returns a <code>CompletedProcess</code> object, from which you can easily obtain the output as well as return code. Since you are only interested in the output, you can write a utility wrapper like this.</p>
<pre><code>from subprocess import PIPE, run

def out(command):
    result = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
    return result.stdout

my_output = out("echo hello world")
# Or
my_output = out(["echo", "hello world"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i do it with os.system temp file:</p>
<pre><code>import tempfile,os
def readcmd(cmd):
    ftmp = tempfile.NamedTemporaryFile(suffix='.out', prefix='tmp', delete=False)
    fpath = ftmp.name
    if os.name=="nt":
        fpath = fpath.replace("/","\\") # forwin
    ftmp.close()
    os.system(cmd + " &gt; " + fpath)
    data = ""
    with open(fpath, 'r') as file:
        data = file.read()
        file.close()
    os.remove(fpath)
    return data
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python 2.6 and 3 specifically say to avoid using PIPE for stdout and stderr.</p>
<p>The correct way is </p>
<pre><code>import subprocess

# must create a file object to store the output. Here we are getting
# the ssid we are connected to
outfile = open('/tmp/ssid', 'w');
status = subprocess.Popen(["iwgetid"], bufsize=0, stdout=outfile)
outfile.close()

# now operate on the file
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/1410976/equivalent-of-backticks-in-python">Equivalent of Backticks in Python</a></span>
<span class="comment-copy">Don't use <code>os.system</code> (nor <code>os.popen</code>, per the answer you accepted): use <code>subprocess.Popen</code>, it's <i>way</i> better!</span>
<span class="comment-copy">@AlexMartelli, one can't use a complex commands (e.g. piped) in subprocess.Popen(), but with os.system one can</span>
<span class="comment-copy">@vak, of course you can use pipes &amp;c w/<code>subprocess.Popen</code> -- just add <code>shell=True</code>!</span>
<span class="comment-copy">@AlexMartelli <code>shell=True</code> is (generally) a very bad idea! You have to be very sure of what you're executing :)</span>
<span class="comment-copy">Note that Walter's <code>subprocess.check_output</code> solution is closer to the Pythonic one-liner it seems you're looking for, as long as you don't care about <code>stderr</code>.</span>
<span class="comment-copy">@ChrisBunch Why is suprocess a better solution than <code>os.popen</code>?</span>
<span class="comment-copy">You should (almost) never use <code>shell=True</code>. See <a href="https://docs.python.org/3/library/subprocess.html#security-considerationshttps://docs.python.org/3/library/subprocess.html#security-considerations" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">I keep coming across this and every time I wonder - why is it better to have three lines of complicated code rather than one line of obvious code?</span>
<span class="comment-copy">Not only should you (almost) never use <code>shell=True</code>, but it's also incorrect in this case. <code>shell=True</code> makes the <i>shell</i> the child process rather than <code>cat</code>, so <code>out</code> and <code>err</code> are the stdout/stderr of the <i>shell</i> process rather than of the <code>cat</code> process</span>
<span class="comment-copy">note, <code>check_output</code> was added with python 2.7 <a href="https://docs.python.org/2.7/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer">docs.python.org/2.7/library/…</a></span>
<span class="comment-copy">Quoting from the <a href="http://docs.python.org/2/library/commands.html#commands" rel="nofollow noreferrer">documentation of the commands module</a>: <i>"Deprecated since version 2.6: The commands module has been removed in Python 3. Use the subprocess module instead."</i>.</span>
<span class="comment-copy">sure it's outdated but sometimes you just want to get something done quickly and easily in a few lines of code.</span>
<span class="comment-copy">@advocate check out the check_output command of subprocess. It's quick, easy, and won't depreciate soon!</span>
<span class="comment-copy">3 years later, this is what worked for me. I threw this in a separate file called <code>cmd.py</code>, and then in my main file I wrote <code>from cmd import cmdline</code> and used it as needed.</span>
<span class="comment-copy">I was getting the same issue with os.system returning 0, but I tried this method and it works great! And as a bonus it looks nice and tidy :) Thanks!</span>
