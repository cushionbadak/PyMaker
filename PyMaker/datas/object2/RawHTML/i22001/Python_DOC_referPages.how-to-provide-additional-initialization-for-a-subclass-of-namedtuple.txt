<div class="post-text" itemprop="text">
<p>Suppose I have a <code>namedtuple</code> like this:</p>
<pre><code>EdgeBase = namedtuple("EdgeBase", "left, right")
</code></pre>
<p>I want to implement a custom hash-function for this, so I create the following subclass:</p>
<pre><code>class Edge(EdgeBase):
    def __hash__(self):
        return hash(self.left) * hash(self.right)
</code></pre>
<p>Since the object is immutable, I want the hash-value to be calculated only once, so I do this:</p>
<pre><code>class Edge(EdgeBase):
    def __init__(self, left, right):
        self._hash = hash(self.left) * hash(self.right)

    def __hash__(self):
        return self._hash
</code></pre>
<p>This appears to be working, but I am really not sure about subclassing and initialization in Python, especially with tuples. Are there any pitfalls to this solution? Is there a recommended way how to do this? Is it fine? Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>edit for 2017:</strong> <a href="https://attrs.readthedocs.io/en/stable/why.html#namedtuples" rel="noreferrer">turns out <code>namedtuple</code> isn't a great idea</a>. <a href="https://attrs.readthedocs.io/en/stable/" rel="noreferrer">attrs</a> is the modern alternative.</p>
<pre><code>class Edge(EdgeBase):
    def __new__(cls, left, right):
        self = super(Edge, cls).__new__(cls, left, right)
        self._hash = hash(self.left) * hash(self.right)
        return self

    def __hash__(self):
        return self._hash
</code></pre>
<p><code>__new__</code> is what you want to call here because tuples are immutable. Immutable objects are created in <code>__new__</code> and then returned to the user, instead of being populated with data in <code>__init__</code>.</p>
<p><code>cls</code> has to be passed twice to the <code>super</code> call on <code>__new__</code> because <code>__new__</code> is, for historical/odd reasons implicitly a <code>staticmethod</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The code in the question could benefit from a super call in the <code>__init__</code> in case it ever gets subclassed in a multiple inheritance situation, but otherwise is correct.</p>
<pre><code>class Edge(EdgeBase):
    def __init__(self, left, right):
        super(Edge, self).__init__(left, right)
        self._hash = hash(self.left) * hash(self.right)

    def __hash__(self):
        return self._hash
</code></pre>
<p>While tuples are readonly only the tuple parts of their subclasses are readonly, other properties may be written as usual which is what allows the assignment to _hash regardless of whether it's done in <code>__init__</code> or <code>__new__</code>. You can make the subclass fully readonly by setting it's <code>__slots__</code> to (), which has the added benefit of saving memory, but then you wouldn't be able to assign to _hash.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.7+, you can now use <a href="https://github.com/ericvsmith/dataclasses" rel="nofollow noreferrer">dataclasses</a> to build hashable classes with ease.</p>
<p><strong>Code</strong></p>
<p>Assuming <code>int</code> types of <code>left</code> and <code>right</code>, we use the default hashing via <code>unsafe_hash</code><sup>+</sup> keyword:</p>
<pre><code>import dataclasses as dc


@dc.dataclass(unsafe_hash=True)
class Edge:
    left: int
    right: int


hash(Edge(1, 2))
# 3713081631934410656
</code></pre>
<p>Now we can use these (mutable) hashable objects as elements in a set or (keys in a dict).</p>
<pre><code>{Edge(1, 2), Edge(1, 2), Edge(2, 1), Edge(2, 3)}
# {Edge(left=1, right=2), Edge(left=2, right=1), Edge(left=2, right=3)}
</code></pre>
<hr/>
<p><strong>Details</strong></p>
<p>We can alternatively override the <code>__hash__</code> function:</p>
<pre><code>@dc.dataclass
class Edge:
    left: int
    right: int

    def __post_init__(self):
        # Add custom hashing function here
        self._hash = hash((self.left, self.right))         # emulates default

    def __hash__(self):
        return self._hash


hash(Edge(1, 2))
# 3713081631934410656
</code></pre>
<p>Expanding on @ShadowRanger's comment, the OP's custom hash function is not reliable.  In particular, the attribute values can be interchanged, e.g. <code>hash(Edge(1, 2)) == hash(Edge(2, 1))</code>, which is likely not what is intended.  </p>
<p><sub><sup>+</sup>Note, the name "unsafe" suggests the default hash will be used despite object being mutable.  This may be undesired, particularly in dict expecting immutable keys.  Immutable hashing can be turned on with the appropriate keywords.  See also more on <a href="https://github.com/ericvsmith/dataclasses/blob/d4c87c663feb0617fd8c7e6fe0a58882c4ccd468/dataclasses.py#L115" rel="nofollow noreferrer">hashing logic</a> in dataclasses and a <a href="https://bugs.python.org/issue32929" rel="nofollow noreferrer">related issue</a>.</sub></p>
</div>
<span class="comment-copy">Tests have shown that it's not worth to cache the hash value, see    <a href="https://mail.python.org/pipermail/python-bugs-list/2013-January/192363.html" rel="nofollow noreferrer">issue #9685</a></span>
<span class="comment-copy">Side-note: The canonical way to combine hashes is to compute the hash of a <code>tuple</code> of the combined values; <code>tuple</code> uses a more tested, reliable way of combining hashes than most naive solutions (significantly better than mere multiplication of hashes). So if you just didn't override hash, <code>tuple</code>'s default hash would already be correct/efficient (more efficient than anything you'll write because it doesn't execute any Python level byte code at all). Even if this wasn't a <code>namedtuple</code>, the correct solution would be <code>hash((self.left, self.right))</code>.</span>
<span class="comment-copy">@ShadowRanger good point. This was quite a while ago, but if I remember correctly, the hash-function was chosen like this because the class represented undirected edges, so in this case it the <code>tuple</code> approach wouldn't work.</span>
<span class="comment-copy">@BjörnPollex: In that case, the <code>hash</code> of a <code>frozenset</code> of the values would work. Not as good at producing unique hashes as <code>tuple</code>'s hash (<code>frozenset</code> just shuffles up the bits predictably, then xors them together), but of course, in this case, that's the goal.</span>
<span class="comment-copy">Why should I prefer this to my solution (this is not meant to be a cynical question, I really want to understand if there are any significant differences)?</span>
<span class="comment-copy">Your solution doesn't use <code>super</code>, and therefore will break in any sort of multiple inheritance situation. It doesn't matter if <i>you</i> don't use MI; if someone else does, their code will break horribly. It's not difficult to avoid this issue by just using <code>super</code> everywhere.</span>
<span class="comment-copy">It's also beneficial to add <code>__slots__ = ()</code> to the class. Otherwise <code>__dict__</code> will be created, negating memory efficiency of <code>namedtuple</code>.</span>
<span class="comment-copy">You can do slots = ('_hash',) instead of ().  Someone assigning _hash will still break this class, but you have marked it private, so you have done your job.  Also, I would use + instead of * for the hash function.</span>
<span class="comment-copy">@zwol also consider that even the python stdlib recognizes its own deficient state: <a href="https://docs.python.org/3/library/urllib.request.html#module-urllib.request" rel="nofollow noreferrer">docs.python.org/3/library/…</a> has a link to <code>requests</code>.</span>
