<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2600191/how-can-i-count-the-occurrences-of-a-list-item">How can I count the occurrences of a list item?</a>
<span class="question-originals-answer-count">
                    22 answers
                </span>
</li>
</ul>
</div>
<p>I'm new to Python and I have a simple question, say I have a list of items:</p>
<pre><code>['apple','red','apple','red','red','pear']
</code></pre>
<p>Whats the simpliest way to add the list items to a dictionary and count how many times the item appears in the list.</p>
<p>So for the list above I would like the output to be:</p>
<pre><code>{'apple': 2, 'red': 3, 'pear': 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>in 2.7 and 3.1 there is special <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noreferrer"><code>Counter</code></a> dict for this purpose.</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; Counter(['apple','red','apple','red','red','pear'])
Counter({'red': 3, 'apple': 2, 'pear': 1})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like:</p>
<pre><code>counts = dict()
for i in items:
  counts[i] = counts.get(i, 0) + 1
</code></pre>
<p>.get allows you to specify a default value if the key does not exist.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; L = ['apple','red','apple','red','red','pear']
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; for i in L:
...   d[i] += 1
&gt;&gt;&gt; d
defaultdict(&lt;type 'int'&gt;, {'pear': 1, 'apple': 2, 'red': 3})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simply use list property count\</p>
<pre><code>i = ['apple','red','apple','red','red','pear']
d = {x:i.count(x) for x in i}
print d
</code></pre>
<p>output : </p>
<pre><code>{'pear': 1, 'apple': 2, 'red': 3}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I always thought that for a task that trivial, I wouldn't want to import anything. But i may be wrong, depending on collections.Counter being faster or not.</p>
<pre><code>items = "Whats the simpliest way to add the list items to a dictionary "

stats = {}
for i in items:
    if i in stats:
        stats[i] += 1
    else:
        stats[i] = 1

# bonus
for i in sorted(stats, key=stats.get):
    print("%d×'%s'" % (stats[i], i))
</code></pre>
<p>I think this may be preferable to using count(), because it will only go over the iterable once, whereas count may search the entire thing on every iteration. I used this method to parse many megabytes of statistical data and it always was reasonably fast.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider collections.Counter (available from python 2.7 onwards). 
<a href="https://docs.python.org/2/library/collections.html#collections.Counter">https://docs.python.org/2/library/collections.html#collections.Counter</a></p>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>src = [ 'one', 'two', 'three', 'two', 'three', 'three' ]
result_dict = dict( [ (i, src.count(i)) for i in set(src) ] )
</code></pre>
<p>This results in</p>
<blockquote>
<p>{'one': 1, 'three': 3, 'two': 2}</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>L = ['apple','red','apple','red','red','pear']
d = {}
[d.__setitem__(item,1+d.get(item,0)) for item in L]
print d 
</code></pre>
<p>Gives <code>{'pear': 1, 'apple': 2, 'red': 3}</code></p>
</div>
<span class="comment-copy">you can get inspiration here: <a href="http://stackoverflow.com/questions/2870466/python-histogram-one-liner" title="python histogram one liner">stackoverflow.com/questions/2870466/python-histogram-one-liner</a></span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/13242103/how-to-compute-letter-frequency-in-a-string-using-pythons-built-in-map-and-reduc" title="how to compute letter frequency in a string using pythons built in map and reduc">stackoverflow.com/questions/13242103/…</a></span>
<span class="comment-copy">Did any one notice the order of output? Is that irrelevant?</span>
<span class="comment-copy">Yuck; enough narrow-purpose bloat in the Python library, already.</span>
<span class="comment-copy">The official line, or rather standing joke, is that Guido has a time machine ..</span>
<span class="comment-copy">@Glenn Maynard Counter is just an implementation of a <b>multiset</b> which is not an uncommon data structure IMO.  In fact, C++ has an implementation in the STL called <code>std::multiset</code> (also <code>std::tr1::unordered_multiset</code>) so Guido is not alone in his opinion of its importance.</span>
<span class="comment-copy">@awesomo: No, it's not comparable to std::multiset.  std::multiset allows storing multiple distinct but comparatively equal values, which is what makes it so useful.  (For example, you can compare a list of locations by their temperature, and use a multiset to look up all locations at a specific temperature or temperature range, while getting the fast insertions of a set.)  Counter merely counts repetitions; distinct values are lost.  That's much less useful--it's nothing more than a wrapped dict.  I question calling that a multiset at all.</span>
<span class="comment-copy">Also, it's not available in all python versions. :(</span>
<span class="comment-copy">For those new to python. This answer is better in terms of time complexity.</span>
<span class="comment-copy">This answer works even on a list of floating point numbers, where some of the numbers may be '0'</span>
<span class="comment-copy">This answer also does not require any extra imports. +1</span>
<span class="comment-copy">Probably the fastest and least-cluttered method.</span>
<span class="comment-copy">While it works, this seems like it would be inefficient.</span>
<span class="comment-copy">can you elaborate?</span>
<span class="comment-copy">You're applying <code>count</code> against the array as many times as there are array items. Your solution is <code>O(n^2)</code> where the better trivial solution is <code>O(n)</code>. See comments on <a href="https://stackoverflow.com/a/9604768/367865">riviera's answer</a> versus comments on <a href="https://stackoverflow.com/a/6582852/367865">mmdreg's answer</a>.</span>
<span class="comment-copy">Your answer deserves more credit for it's simplicity. I was struggling over this for a while, getting bewildered with the silliness of some of the other users suggesting to import new libraries etc.</span>
<span class="comment-copy">you could simplify it with a default value  like this d[key] = d.get(key, 0) + 1</span>
<span class="comment-copy">Note this is <code>O(n^2)</code> due to the <code>n</code> calls to <code>src.count()</code>.</span>
<span class="comment-copy">Would this really be O(n^2)? Given set(n) != n.</span>
