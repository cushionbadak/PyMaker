<div class="post-text" itemprop="text">
<p>I'm writing per the following, in which I try to produce a decent error message when comparing two multiline blocks of Unicode text. The interior method that does the comparison raises an assertion, but the default explanation is useless to me</p>
<p>I need to add something to code such as this below:</p>
<pre><code>def assert_long_strings_equal(one, other):
    lines_one = one.splitlines()
    lines_other = other.splitlines()
    for line1, line2 in zip(lines_one, lines_other):
        try:
            my_assert_equal(line1, line2)
        except AssertionError, error:
            # Add some information to the printed result of error??!
            raise
</code></pre>
<p>I cannot figure out how to change the printed error message in the assertionerror I catch. I always get <code>AssertionError: u'something' != 'something else'</code>, which only shows the first line of the output.</p>
<p><strong>How can I change the assertion message to print out whatever I want?</strong></p>
<p>If it's relevant, I am using <code>nose</code> to run the test.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>e.args</code>, <code>e.message</code> is deprecated.</p>
<pre><code>try:
    assert False, "Hello!"
except AssertionError as e:
    e.args += ('some other', 'important', 'information', 42)
    raise
</code></pre>
<p>This preserves the original traceback. Its last part then looks like this:</p>
<pre><code>AssertionError: ('Hello!', 'some other', 'important', 'information', 42)
</code></pre>
<p>Works in both Python 2.7 and Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>assert expression, info
</code></pre>
<p>For instance,</p>
<pre><code>&gt;&gt;&gt; assert False, "Oopsie"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AssertionError: Oopsie
</code></pre>
<hr/>
<p>From the <a href="http://docs.python.org/reference/simple_stmts.html#the-assert-statementtrace." rel="noreferrer">docs</a>:</p>
<blockquote>
<p>Assert statements are a convenient way
  to insert debugging assertions into a
  program:</p>
<pre><code>assert_stmt ::=  "assert" expression
["," expression] 
</code></pre>
<p>The simple form,
  <code>assert expression</code>, is equivalent to</p>
<pre><code>if __debug__:
    if not expression:
        raise AssertionError 
</code></pre>
<p>The extended form</p>
<pre><code>assert expression1, expression2
</code></pre>
<p>is equivalent to</p>
<pre><code>if __debug__:
    if not expression1:
        raise AssertionError(expression2)
</code></pre>
<p>These equivalences assume that
  <code>__debug__</code> and <code>AssertionError</code> refer to the built-in variables with those
  names. In the current implementation,
  the built-in variable <code>__debug__</code> is
  True under normal circumstances, False
  when optimization is requested
  (command line option -O). The current
  code generator emits no code for an
  assert statement when optimization is
  requested at compile time. Note that
  it is unnecessary to include the
  source code for the expression that
  failed in the error message; it will
  be displayed as part of the stack
  trace.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You want to take the caught exception, convert it to a string, combine it with some additional string info, and raise a new exception.</p>
<pre><code>x = 3
y = 5
try:
    assert( x == y )
except AssertionError, e:
    raise( AssertionError( "Additional info. %s"%e ) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With this method I was able to edit the message and still have the stack trace (+any other information) visible. Also newlines are displayed right.</p>
<pre><code>try:
   my_assert_equal(line1, line2)
except AssertionError as e:
   message = e.args[0]
   message += "\nThis appends the default message and can have newlines"
   e.args = (message,) #wrap it up in new tuple
   raise
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pass the desired message when creating the exception.</p>
<pre><code>raise AssertionError(line1 + ' != ' + line2)
</code></pre>
<p>Hope this helps.</p>
</div>
<span class="comment-copy">Just to clarify, I realize that the catching of an Assertion error is strange. It just so happens that <code>my_assert_equal</code> is kind of deep and I don't want to mess with it.</span>
<span class="comment-copy">Just to point out, you should have <code>except</code> not <code>catch</code>. Though I'm sure that's just a typo :p</span>
<span class="comment-copy">This just raises a type error when I try it on 2.7.</span>
<span class="comment-copy">Which type of error? I was using 2.7 when writing the answer.</span>
<span class="comment-copy">@philologon I just tried the solution (exact copy-paste of my answer) in both Python 2.7.10 and Python 3.5.1 and it works as expected. My answer has been downvoted, but I see no reason why.</span>
<span class="comment-copy">@Honza Javorek Nice solution, but may be there is a on-liner with some library?</span>
<span class="comment-copy">@matanster unlike print, assert is still a statement in the Python 3 <a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a></span>
<span class="comment-copy">Note that you can also embed newlines in the <code>info</code> string expression to make them look nice when displayed.</span>
<span class="comment-copy">Also note that you can add additional information to the string expression by using Python's string interpolation and newer string formating operations.</span>
<span class="comment-copy">Raising an exception in general is not a problem. It's catching, modifying, and re-raising an expression, that I asked.</span>
<span class="comment-copy">@Andres -- you should edit the question to say that explicitly... I don't interpret the question as saying that.</span>
<span class="comment-copy">Smacks forehead.  Now it's clear why <code>assert(condition, message)</code> breaks with an always-true warning:  assert is an operator not a function, and so that statement tests a tuple.  Instead <code>assert condition message</code></span>
<span class="comment-copy">I didn't see any of the posted answers offer the general solution of how to add information to an exception and re-raise with both the original and additional information, which I thought was what the OP was asking.</span>
<span class="comment-copy">Russel is right, this is the sort of thing I was looking for.</span>
<span class="comment-copy">This loses the traceback.</span>
<span class="comment-copy">This includes newlines and doesn't have to copy on <code>+=</code>:  <code>e.args = (u"%s\n%s" % (e.args[0], addl_message),)</code></span>
<span class="comment-copy">That's not what the OP means; <code>AssertionError</code> is (generally) raised by the <code>assert</code> statement.</span>
<span class="comment-copy">I'm not sure... but if wrapped with an <code>if</code> statement  in place of using <code>assert</code> it might be acceptable. That way you could use an <code>if else</code> block and fallback on an AssertionError with a custom message.</span>
