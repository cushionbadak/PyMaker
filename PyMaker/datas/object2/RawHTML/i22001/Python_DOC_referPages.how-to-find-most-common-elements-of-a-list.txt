<div class="post-text" itemprop="text">
<p>Given the following list</p>
<pre><code>['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 
 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 
 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 
 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 
 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 
 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 
 'Moon', 'to', 'rise.', '']
</code></pre>
<p>I am trying to count how many times each word appears and display the top 3.</p>
<p>However I am only looking to find the top three that have the first letter capitalized and ignore all words that do not have the first letter capitalized.</p>
<p>I am sure there is a better way than this, but my idea was to do the following:</p>
<ol>
<li>put the first word in the list into another list called uniquewords</li>
<li>delete the first word and all its duplicated from the original list</li>
<li>add the new first word into unique words</li>
<li>delete the first word and all its duplicated from original list.</li>
<li>etc...</li>
<li>until the original list is empty....</li>
<li>count how many times each word in uniquewords appears in the original list</li>
<li>find top 3 and print</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you are using an earlier version of Python or you have a very good reason to roll your own word counter (I'd like to hear it!), you could try the following approach using a <code>dict</code>.</p>
<pre><code>Python 2.6.1 (r261:67515, Feb 11 2010, 00:51:29) 
[GCC 4.2.1 (Apple Inc. build 5646)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; word_list = ['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 'Moon', 'to', 'rise.', '']
&gt;&gt;&gt; word_counter = {}
&gt;&gt;&gt; for word in word_list:
...     if word in word_counter:
...         word_counter[word] += 1
...     else:
...         word_counter[word] = 1
... 
&gt;&gt;&gt; popular_words = sorted(word_counter, key = word_counter.get, reverse = True)
&gt;&gt;&gt; 
&gt;&gt;&gt; top_3 = popular_words[:3]
&gt;&gt;&gt; 
&gt;&gt;&gt; top_3
['Jellicle', 'Cats', 'and']
</code></pre>
<p><strong>Top Tip</strong>: The interactive Python interpretor is your friend whenever you want to play with an algorithm like this. Just type it in and watch it go, inspecting elements along the way.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7 and above there is a class called <a href="http://docs.python.org/dev/library/collections.html#counter-objects" rel="noreferrer">Counter</a> which can help you:</p>
<pre><code>from collections import Counter
words_to_count = (word for word in word_list if word[:1].isupper())
c = Counter(words_to_count)
print c.most_common(3)
</code></pre>
<p>Result:</p>
<pre><code>[('Jellicle', 6), ('Cats', 5), ('And', 2)]
</code></pre>
<hr/>
<blockquote>
<p>I am quite new to programming so please try and do it in the most barebones fashion.</p>
</blockquote>
<p>You could instead do this using a dictionary with the key being a word and the value being the count for that word. First iterate over the words adding them to the dictionary if they are not present, or else increasing the count for the word if it is present. Then to find the top three you can either use a simple <code>O(n*log(n))</code> sorting algorithm and take the first three elements from the result, or you can use a <code>O(n)</code> algorithm that scans the list once remembering only the top three elements.</p>
<p>An important observation for beginners is that by using builtin classes that are designed for the purpose you can save yourself a lot of work and/or get better performance. It is good to be familiar with the standard library and the features it offers.</p>
</div>
<div class="post-text" itemprop="text">
<p>To just return a list containing the most common words:</p>
<pre><code>from collections import Counter
words=["i", "love", "you", "i", "you", "a", "are", "you", "you", "fine", "green"]
most_common_words= [word for word, word_count in Counter(words).most_common(3)]
print most_common_words
</code></pre>
<p>this prints:</p>
<pre><code>['you', 'i', 'a']
</code></pre>
<p>the 3 in "<code>most_common(3)</code>", specifies the number of items to print. 
<code>Counter(words).most_common()</code> returns a a list of tuples with each tuple having the word as the first member and the frequency as the second member.The tuples are ordered by the frequency of the word.</p>
<pre><code>`most_common = [item for item in Counter(words).most_common()]
print(str(most_common))
[('you', 4), ('i', 2), ('a', 1), ('are', 1), ('green', 1), ('love',1), ('fine', 1)]`
</code></pre>
<p>"the <code>word for word, word_counter in</code>", extracts only the first member of the tuple.</p>
</div>
<div class="post-text" itemprop="text">
<p>Is't it just this ....</p>
<pre><code>word_list=['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 
 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 
 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 
 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 
 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 
 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 
 'Moon', 'to', 'rise.', ''] 

from collections import Counter
c = Counter(word_list)
c.most_common(3)
</code></pre>
<p>Which should output </p>
<p><code>[('Jellicle', 6), ('Cats', 5), ('are', 3)]</code></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://nltk.org" rel="noreferrer">nltk</a> is convenient for a lot of language processing stuff. It has methods for frequency distribution built in. Something like:</p>
<pre><code>import nltk
fdist = nltk.FreqDist(your_list) # creates a frequency distribution from a list
most_common = fdist.max()    # returns a single element
top_three = fdist.keys()[:3] # returns a list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple, two-line solution to this, which does not require any extra modules is the following code:</p>
<pre><code>lst = ['Jellicle', 'Cats', 'are', 'black', 'and','white,',
       'Jellicle', 'Cats','are', 'rather', 'small;', 'Jellicle', 
       'Cats', 'are', 'merry', 'and','bright,', 'And', 'pleasant',    
       'to','hear', 'when', 'they', 'caterwaul.','Jellicle', 
       'Cats', 'have','cheerful', 'faces,', 'Jellicle',
       'Cats','have', 'bright', 'black','eyes;', 'They', 'like',
       'to', 'practise','their', 'airs', 'and', 'graces', 'And', 
       'wait', 'for', 'the', 'Jellicle','Moon', 'to', 'rise.', '']

lst_sorted=sorted([ss for ss in set(lst) if len(ss)&gt;0 and ss.istitle()], 
                   key=lst.count, 
                   reverse=True)
print lst_sorted[0:3]
</code></pre>
<p>Output:</p>
<pre><code>['Jellicle', 'Cats', 'And']
</code></pre>
<p>The term in squared brackets returns all unique strings in the list, which are not empty and start with a capital letter. The <code>sorted()</code> function then sorts them by how often they appear in the list (by using the <code>lst.count</code> key) in reverse order. </p>
</div>
<div class="post-text" itemprop="text">
<p><strong>The simple way</strong> of doing this would be (assuming your list is in 'l'):</p>
<pre><code>&gt;&gt;&gt; counter = {}
&gt;&gt;&gt; for i in l: counter[i] = counter.get(i, 0) + 1
&gt;&gt;&gt; sorted([ (freq,word) for word, freq in counter.items() ], reverse=True)[:3]
[(6, 'Jellicle'), (5, 'Cats'), (3, 'to')]
</code></pre>
<p>Complete sample:</p>
<pre><code>&gt;&gt;&gt; l = ['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 'Moon', 'to', 'rise.', '']
&gt;&gt;&gt; counter = {}
&gt;&gt;&gt; for i in l: counter[i] = counter.get(i, 0) + 1
... 
&gt;&gt;&gt; counter
{'and': 3, '': 1, 'merry': 1, 'rise.': 1, 'small;': 1, 'Moon': 1, 'cheerful': 1, 'bright': 1, 'Cats': 5, 'are': 3, 'have': 2, 'bright,': 1, 'for': 1, 'their': 1, 'rather': 1, 'when': 1, 'to': 3, 'airs': 1, 'black': 2, 'They': 1, 'practise': 1, 'caterwaul.': 1, 'pleasant': 1, 'hear': 1, 'they': 1, 'white,': 1, 'wait': 1, 'And': 2, 'like': 1, 'Jellicle': 6, 'eyes;': 1, 'the': 1, 'faces,': 1, 'graces': 1}
&gt;&gt;&gt; sorted([ (freq,word) for word, freq in counter.items() ], reverse=True)[:3]
[(6, 'Jellicle'), (5, 'Cats'), (3, 'to')]
</code></pre>
<p>With simple I mean working in nearly every version of python.</p>
<p>if you don't understand some of the functions used in this sample, you can always do this in the interpreter (after pasting the code above):</p>
<pre><code>&gt;&gt;&gt; help(counter.get)
&gt;&gt;&gt; help(sorted)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The answer from @Mark Byers is best, but if you are on a version of Python &lt; 2.7 (but at least 2.5, which is pretty old these days), you can replicate the Counter class functionality very simply via defaultdict (otherwise, for python &lt; 2.5, three extra lines of code are needed before d[i] +=1, as in @Johnnysweb's answer).</p>
<pre><code>from collections import defaultdict
class Counter():
    ITEMS = []
    def __init__(self, items):
        d = defaultdict(int)
        for i in items:
            d[i] += 1
        self.ITEMS = sorted(d.iteritems(), reverse=True, key=lambda i: i[1])
    def most_common(self, n):
        return self.ITEMS[:n]
</code></pre>
<p>Then, you use the class exactly as in Mark Byers's answer, i.e.:</p>
<pre><code>words_to_count = (word for word in word_list if word[:1].isupper())
c = Counter(words_to_count)
print c.most_common(3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's two standard library ways to find the most frequent value in a list:</p>
<p><a href="https://docs.python.org/3/library/statistics.html#statistics.mode" rel="nofollow noreferrer"><code>statistics.mode</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>from statistics import mode
most_common = mode([3, 2, 2, 2, 1, 1])  # 2
most_common = mode([3, 2])  # StatisticsError: no unique mode
</code></pre>
<ul>
<li>Raises an exception if there's no unique most frequent value</li>
<li>Only returns single most frequent value</li>
</ul>
<p><a href="https://docs.python.org/3.6/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>collections.Counter.most_common</code></a>:</p>
<pre class="lang-py prettyprint-override"><code>from collections import Counter
most_common, count = Counter([3, 2, 2, 2, 1, 1]).most_common(2)  # 2, 3
(most_common_1, count_1), (most_common_2, count_2) = Counter([3, 2, 2]).most_common(2)  # (2, 2), (3, 1)
</code></pre>
<ul>
<li>Can return multiple most frequent values</li>
<li>Returns element count as well</li>
</ul>
<p>So in the case of the question, the second one would be the right choice. As a side note, both are identical in terms of performance.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are using <em>Count</em>, or have created your own <em>Count</em>-style dict and want to show the name of the item and the count of it, you can iterate around the dictionary like so:</p>
<pre><code>top_10_words = Counter(my_long_list_of_words)
# Iterate around the dictionary
for word in top_10_words:
        # print the word
        print word[0]
        # print the count
        print word[1]
</code></pre>
<p>or to iterate through this in a template:</p>
<pre><code>{% for word in top_10_words %}
        &lt;p&gt;Word: {{ word.0 }}&lt;/p&gt;
        &lt;p&gt;Count: {{ word.1 }}&lt;/p&gt;
{% endfor %}
</code></pre>
<p>Hope this helps someone</p>
</div>
<span class="comment-copy">I like the 'Cats' reference!</span>
<span class="comment-copy">thanks for this...but how could i do it so it only looks for words with the first letter being a capital,ignoring all other.  ps. if a word appears multiple times, sometimes capitalized and other times not ccapitalized, then only count the instances when thw word's first letter is a capital.</span>
<span class="comment-copy">...then this begins to sound a lot like homework (and the question should be marked as such). Simply don't add any words starting with a lower-case letter to <code>word_counter</code>. If you update your question to show that (a) this is a requirement and (b) that you've tried to do this yourself, people are more likely to help.</span>
<span class="comment-copy">@Johnsyweb - on this same topic, I'm trying to iterate around the 'popular_words' list to show the names of the words and also their count next to them... I'm having no luck so far, could you point me in the right direction? Thanks in advance</span>
<span class="comment-copy">@andrew_ : <a href="http://stackoverflow.com/a/3594522/78845">stackoverflow.com/a/3594522/78845</a> seems to do just this.</span>
<span class="comment-copy"><code>Counter(lst)</code>?</span>
<span class="comment-copy">why am I getting ImportError (on Python 2.6.1)?   <code>ImportError: cannot import name Counter</code></span>
<span class="comment-copy">@abhiomkar: Because Python 2.6.1 isn't Python 2.7 or above.</span>
<span class="comment-copy">Thanks! upgraded to Python 2.7 in my Mac.</span>
<span class="comment-copy">If your python is less than 2.7, but you want to future-proof your code and use a Counter-like class, see my answer below. <a href="http://stackoverflow.com/a/21760074/379037">stackoverflow.com/a/21760074/379037</a></span>
<span class="comment-copy">Is it possible to return the number of occurrence through most_common function?</span>
<span class="comment-copy">Yes, almost a beginner, it can, let me edit the answer to show you how</span>
