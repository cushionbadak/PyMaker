<div class="post-text" itemprop="text">
<p>I have</p>
<pre><code>a = [1, 2]
b = ['a', 'b']
</code></pre>
<p>I want </p>
<pre><code>c = [1, 'a', 2, 'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>[j for i in zip(a,b) for j in i]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the order of the elements much match the order in your example then you can use a combination of <a href="http://docs.python.org/library/functions.html#zip" rel="noreferrer">zip</a> and <a href="http://docs.python.org/library/itertools.html#chain" rel="noreferrer">chain</a>:</p>
<pre><code>from itertools import chain
c = list(chain(*zip(a,b)))
</code></pre>
<p>If you don't care about the order of the elements in your result then there's a simpler way:</p>
<pre><code>c = a + b
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Parsing </p>
<pre><code>[j for i in zip(a,b) for j in i]
</code></pre>
<p>in your head is easy enough if you recall that the <code>for</code> and <code>if</code> clauses are done in order, followed a final append of the result:</p>
<pre><code>temp = []
for i in zip(a, b):
    for j in i:
        temp.append(j)
</code></pre>
<p>and would be easier had it have been written with more meaningful variable names:</p>
<pre><code>[item for pair in zip(a, b) for item in pair]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An alternate method using index slicing which turns out to be faster and scales better than zip:</p>
<pre><code>def slicezip(a, b):
    result = [0]*(len(a)+len(b))
    result[::2] = a
    result[1::2] = b
    return result
</code></pre>
<p>You'll notice that this only works if <code>len(a) == len(b)</code> but putting conditions to emulate zip will not scale with a or b. </p>
<p>For comparison:</p>
<pre><code>a = range(100)
b = range(100)

%timeit [j for i in zip(a,b) for j in i]
100000 loops, best of 3: 15.4 µs per loop

%timeit list(chain(*zip(a,b)))
100000 loops, best of 3: 11.9 µs per loop

%timeit slicezip(a,b)
100000 loops, best of 3: 2.76 µs per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you care about order:</p>
<pre><code>#import operator
import itertools
a = [1,2]
b = ['a','b']
#c = list(reduce(operator.add,zip(a,b))) # slow.
c = list(itertools.chain.from_iterable(zip(a,b))) # better.
</code></pre>
<p><code>print c</code> gives <code>[1, 'a', 2, 'b']</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def main():

drinks = ["Johnnie Walker", "Jose Cuervo", "Jim Beam", "Jack Daniels,"]
booze = [1, 2, 3, 4, 5]
num_drinks = []
x = 0
for i in booze:

    if x &lt; len(drinks):

        num_drinks.append(drinks[x])
        num_drinks.append(booze[x])

        x += 1

    else:

        print(num_drinks)

return
</code></pre>
<p>main()</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a standard / self-explaining solution, i hope someone will find it useful:</p>
<pre><code>a = ['a', 'b', 'c']
b = ['1', '2', '3']

c = []
for x, y in zip(a, b):
    c.append(x)
    c.append(y)

print (c)
</code></pre>
<p>output:</p>
<pre><code>['a', '1', 'b', '2', 'c', '3']
</code></pre>
<p>Of course, you can change it and do manipulations on the values if needed</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>c = []
c.extend(a)
c.extend(b)
</code></pre>
</div>
<span class="comment-copy">@cdleary's answer <a href="http://stackoverflow.com/questions/406121/flattening-a-shallow-list-in-python/408281#408281" title="flattening a shallow list in python">stackoverflow.com/questions/406121/…</a> provides performance comparison for various ways of "Flattening a shallow list in python" (flattening <code>zip(a,b)</code> gives you the answer).</span>
<span class="comment-copy">It works, but I can't parse it in my head...</span>
<span class="comment-copy">[ j for j in i for i in zip(a,b) ] though easier to parse in my head does not work!</span>
<span class="comment-copy">Does read weirdly at first :) Mentally chop off everything up to the first <code>for</code> and move it to the end, then read that: <code>for i in zip(a, b)</code>, <code>for j in i</code>, <code>j</code>.</span>
<span class="comment-copy">aaah... neat! thanks.</span>
<span class="comment-copy">Neat, but doesn't work if one list is 1 element shorter than the other (still should be able to merge).</span>
<span class="comment-copy">using this in my case: 'c = a+b' -- &gt; lists are not iterable. What then? Only chain works check my question to understand my problem: '<a href="http://stackoverflow.com/questions/40952892/extract-url-their-names-of-an-html-file-stored-on-disk-and-print-them-respecti" title="extract url their names of an html file stored on disk and print them respecti">stackoverflow.com/questions/40952892/…</a>'</span>
<span class="comment-copy">for index, row in datas.iterrows():     textF = re.findall('{{f}}(.*?)}}', row['review'])     matrixF += textF      if index==3:         break  for index in matrixF:     print index , it's still works, so it's still iterable i think ? ._.</span>
<span class="comment-copy">There is <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer">chain.from_iterable</a>: <code>list(chain.from_iterable(zip(a, b)))</code> -- perfectly lazy way to do this.</span>
<span class="comment-copy">I'm normally very comfortable with LEs, but this double looping got me all confused. Thanks for the nice explanation.</span>
<span class="comment-copy">what do you mean by "putting conditions to emulate zip will not scale with a or b"?</span>
<span class="comment-copy">I simply meant that with zip, if one list is longer than the other, the longer list gets truncated to merge it with the shorter list. One could do this by comparing the lengths of each array and then only assigning a shortened version of the longer one. This checking of lengths and truncation does not take any longer if the arrays get bigger.</span>
<span class="comment-copy">Note: This works well for bisecting purposes that favor the first list: it tolerates being the same length or one longer than the second <code>slicezip([1,2,3],[4,5])</code>, which means you don't have to handle uneven lists in that case (which is very nice)</span>
<span class="comment-copy">-1 for quadratic time. You can do this in linear time.</span>
<span class="comment-copy">@Aaron Gallagher Fixed, and yet a (subtly) unique answer.</span>
<span class="comment-copy">Please you have to explan your answer.</span>
<span class="comment-copy">Did you come up with this answer after 5 rounds?</span>
<span class="comment-copy">The desired result is entirely different.</span>
<span class="comment-copy">While this code may answer the question, providing additional context regarding how and/or why it solves the problem would improve the answer's long-term value.</span>
<span class="comment-copy">if it answers the question and is different from all other answers, why not support it? i believe there's not much context to the quesetion so any relevant answers are welcome.</span>
