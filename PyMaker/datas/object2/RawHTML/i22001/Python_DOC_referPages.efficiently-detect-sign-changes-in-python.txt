<div class="post-text" itemprop="text">
<p>I want to do exactly what this guy did:</p>
<p><a href="https://stackoverflow.com/questions/2936834/python-counting-sign-changes">Python - count sign changes</a></p>
<p>However I need to optimize it to run super fast. In brief I want to take a time series and tell every time it crosses crosses zero (changes sign). I want to record the time in between zero crossings. Since this is real data (32 bit float) I doubt I'll every have a number which is exactly zero, so that is not important. I currently have a timing program in place so I'll time your results to see who wins.</p>
<p>My solution gives (micro seconds):</p>
<pre><code>open data       8384
sign data       8123
zcd data        415466
</code></pre>
<p>As you can see the zero-crossing detector is the slow part. Here's my code.</p>
<pre><code>import numpy, datetime

class timer():
    def __init__(self):
        self.t0 = datetime.datetime.now()
        self.t = datetime.datetime.now()
    def __call__(self,text='unknown'):
        print text,'\t',(datetime.datetime.now()-self.t).microseconds
        self.t=datetime.datetime.now()

def zcd(data,t):
    sign_array=numpy.sign(data)
    t('sign data')
    out=[]
    current = sign_array[0]
    count=0
    for i in sign_array[1:]:
        if i!=current:
            out.append(count)
            current=i
            count=0
        else: count+=1
    t('zcd data')
    return out

def main():
    t = timer()
    data = numpy.fromfile('deci.dat',dtype=numpy.float32)
    t('open data')
    zcd(data,t)

if __name__=='__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What about:</p>
<pre><code>import numpy
a = [1, 2, 1, 1, -3, -4, 7, 8, 9, 10, -2, 1, -3, 5, 6, 7, -10]
zero_crossings = numpy.where(numpy.diff(numpy.sign(a)))[0]
</code></pre>
<p>Output:</p>
<pre><code>&gt; zero_crossings
array([ 3,  5,  9, 10, 11, 12, 15])
</code></pre>
<p>i.e. zero_crossings will contain the indices of elements <em>after</em> which a zero crossing occurs. If you want the elements <em>before</em>, just add 1 to that array.</p>
</div>
<div class="post-text" itemprop="text">
<p>As remarked by Jay Borseth the accepted answer does not handle arrays containing 0 correctly. </p>
<p>I propose using:</p>
<pre><code>import numpy as np
a = np.array([-2, -1, 0, 1, 2])
zero_crossings = np.where(np.diff(np.signbit(a)))[0]
print(zero_crossings)
# output: [1]
</code></pre>
<p>Since a) using numpy.signbit() is a little bit quicker than numpy.sign(), since it's implementation is simpler, I guess and b) it deals correctly with zeros in the input array. </p>
<p>However there is one drawback, maybe: If your input array starts and stops with zeros, it will find a zero crossing at the beginning, but not at the end...</p>
<pre><code>import numpy as np
a = np.array([0, -2, -1, 0, 1, 2, 0])
zero_crossings = np.where(np.diff(np.signbit(a)))[0]
print(zero_crossings)
# output: [0 2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another way to count zero crossings and squeeze just a few more milliseconds out of the code is to use <code>nonzero</code> and compute the signs directly. Assuming you have a one-dimensional array of <code>data</code>:</p>
<pre><code>def crossings_nonzero_all(data):
    pos = data &gt; 0
    npos = ~pos
    return ((pos[:-1] &amp; npos[1:]) | (npos[:-1] &amp; pos[1:])).nonzero()[0]
</code></pre>
<p>Alternatively, if you just want to count the zero crossings for a particular direction of crossing zero (e.g., from positive to negative), this is even faster:</p>
<pre><code>def crossings_nonzero_pos2neg(data):
    pos = data &gt; 0
    return (pos[:-1] &amp; ~pos[1:]).nonzero()[0]
</code></pre>
<p>On my machine these are a bit faster than the <code>where(diff(sign))</code> method (timings for an array of 10000 sine samples containing 20 cycles, 40 crossings in all):</p>
<pre><code>$ python -mtimeit 'crossings_where(data)'
10000 loops, best of 3: 119 usec per loop

$ python -mtimeit 'crossings_nonzero_all(data)'
10000 loops, best of 3: 61.7 usec per loop

$ python -mtimeit 'crossings_nonzero_pos2neg(data)'
10000 loops, best of 3: 55.5 usec per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Jim Brissom's answer fails if <strong>a</strong> contains the value 0:</p>
<pre><code>import numpy  
a2 = [1, 2, 1, 1, 0, -3, -4, 7, 8, 9, 10, -2, 1, -3, 5, 6, 7, -10]  
zero_crossings2 = numpy.where(numpy.diff(numpy.sign(a2)))[0]  
print zero_crossings2  
print len(zero_crossings2)  # should be 7
</code></pre>
<p>Output:</p>
<pre><code>[ 3  4  6 10 11 12 13 16]  
8  
</code></pre>
<p>The number of zero crossing should be 7, but because sign() returns 0 if 0 is passed, 1 for positive, and -1 for negative values, diff() will count the transition containing zero twice.</p>
<p>An alternative might be:</p>
<pre><code>a3 = [1, 2, 1, 1, 0, -3, -4, 7, 8, 9, 10, 0, -2, 0, 0, 1, 0, -3, 0, 5, 6, 7, -10]  
s3= numpy.sign(a3)  
s3[s3==0] = -1     # replace zeros with -1  
zero_crossings3 = numpy.where(numpy.diff(s3))[0]  
print s3  
print zero_crossings3  
print len(zero_crossings3)   # should be 7
</code></pre>
<p>which give the correct answer of:</p>
<pre><code>[ 3  6 10 14 15 18 21]
7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you want to time it? Or do you want to make it as fast as possible?</p>
<p>Timing is easy. Run it a zillion times, stopwatch it, and divide by a zillion.</p>
<p>To make it as fast as possible, what you need to do is find out what's taking time and that you could do in a better way. I use either 1) the random-pause technique, or 2) the single-step technique.</p>
</div>
<div class="post-text" itemprop="text">
<p>I see people using diff a lot in their solutions, but xor seems to be much faster and the result is the same for bools (a good pointer to that might also be the fact that using diff gives a deprecated warning.... :) )
Here is an example:</p>
<pre><code>positive = a2 &gt; 0
np.where(np.bitwise_xor(positive[1:], positive[:-1]))[0]
</code></pre>
<p>Time it measures it to be around one and a half faster to diff for me:)</p>
<p>If you  do not care about edge cases it might be better to use </p>
<pre><code>positive = np.signbit(a2)
</code></pre>
<p>but positive = a2 &gt;0 seems faster (and cleaner) than signbit AND checking for 0s (e.g. positive = np.bitwise_or(np.signbit(a2),np.logical_not(a2)) is slower...)</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way that might suit certain applications is to extend the evaluation of the expression <code>np.diff(np.sign(a))</code>. </p>
<p>If we compare how this expression reacts to certain cases:</p>
<ol>
<li>Rising crossing without zero: <code>np.diff(np.sign([-10, 10]))</code> returns <code>array([2])</code></li>
<li>Rising crossing with zero: <code>np.diff(np.sign([-10, 0, 10]))</code> returns <code>array([1, 1])</code></li>
<li>Falling crossing without zero: <code>np.diff(np.sign([10, -10]))</code> returns <code>array([-2])</code></li>
<li>Falling crossing with zero: <code>np.diff(np.sign([10, 0, -10]))</code> returns <code>array([-1, -1])</code></li>
</ol>
<p>So we have to evaluate <code>np.diff(...)</code> for the returned patterns in 1. and 2:</p>
<pre><code>sdiff = np.diff(np.sign(a))
rising_1 = (sdiff == 2)
rising_2 = (sdiff[:-1] == 1) &amp; (sdiff[1:] == 1)
rising_all = rising_1
rising_all[1:] = rising_all[1:] | rising_2
</code></pre>
<p>and for the cases 3. and 4.:</p>
<pre><code>falling_1 = (sdiff == -2) #the signs need to be the opposite
falling_2 = (sdiff[:-1] == -1) &amp; (sdiff[1:] == -1)
falling_all = falling_1
falling_all[1:] = falling_all[1:] | falling_2
</code></pre>
<p>After this we can easily find the indices with </p>
<pre><code>indices_rising = np.where(rising_all)[0]
indices_falling = np.where(falling_all)[0]
indices_both = np.where(rising_all | falling_all)[0]
</code></pre>
<p>This approach should be reasonable fast because it can manage without using a "slow" loop.</p>
<p>This combines the approach of several other answers.</p>
</div>
<span class="comment-copy">There is a 'timeit' module, you know? :)</span>
<span class="comment-copy">Interesting... I like mine better because it can be put throughout a function. You can drop a t() every couple of lines and find bottle necks quickly. If I just wanted to time my function I would have used the linux <code>$ time python zcd.py</code></span>
<span class="comment-copy">I am guessing the line <code>time('sign data')</code> is meant to be <code>t('sign data')</code>. Is it?</span>
<span class="comment-copy">@Muhammad Alkarouri - yeah, thanks. I'll fix that.</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/2936834/python-counting-sign-changes">Python - counting sign changes</a></span>
<span class="comment-copy">I think you have it backwards; <code>zero_crossings</code> contains the lidices of elements <i>before which</i> a zero crossing occurs, and if you want the elements <i>after</i> you add 1 to the array.  Otherwise, excellent, concise answer!</span>
<span class="comment-copy">This doesn't work when there is a zero in the array. It will detect them twice! Example: <code>a = [2,1,0,-1,2]</code> will give <code>array([1, 2, 3])</code></span>
<span class="comment-copy">Hmmm, what about $[-2,-1,0,-1,-2,0]$....no crossings just touching, yet an answer. Counting zero as positive is not the final solution either, I guess.</span>
<span class="comment-copy">@mikuszefski You are right! <code>[ 1, 2, 0, -1, 0, 0, -1, 2]</code> should yield <code>2</code> zero crossings, which it does not.</span>
<span class="comment-copy">Thanks -- I just run into this answer. I wonder if there is an easy way of knowing the <b>"sign"</b> of the zero-crossing (going above 0, or going below 0)? The slope should probably help.</span>
<span class="comment-copy">this does not take care of the case where the elements before and after a 0 are of the same sign.</span>
<span class="comment-copy">Rather than use <code>numpy.sign</code>, which returns -1, 0, or 1 for negative, zero, or positive, you should just use <code>numpy.where(numpy.diff(a2 &gt; 0))[0]</code>. Or use Dominik Neise's answer, <code>np.signbit</code>.</span>
<span class="comment-copy">Unfortunately, this solution <b>does not work with other Python container types,</b> like <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>dique</code></a> for example. This <a href="http://stackoverflow.com/a/40804510/2192488">other solution</a> does, however.</span>
<span class="comment-copy">+1 random pause is great</span>
<span class="comment-copy">Timing it is easy and it runs fast enough that you can get an accurate time by running it once. I want the script to run fast because it is part of a semi-realtime data processor.</span>
<span class="comment-copy">@dustynachos: FWIW, here's a blow-by-blow account of using random-pause to get a series of speedups compounding to over 40x. <a href="http://stackoverflow.com/questions/926266/performance-optimization-strategies-of-last-resort/927773#927773" title="performance optimization strategies of last resort">stackoverflow.com/questions/926266/…</a></span>
