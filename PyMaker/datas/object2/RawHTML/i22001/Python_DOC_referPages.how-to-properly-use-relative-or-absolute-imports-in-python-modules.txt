<div class="post-text" itemprop="text">
<p>Usage of relative imports in Python has one drawback, you will not be able to run the modules as standalones anymore because you will get an exception: <code>ValueError: Attempted relative import in non-package</code></p>
<pre><code># /test.py: just a sample file importing foo module
import foo
...

# /foo/foo.py:
from . import bar
...
if __name__ == "__main__":
   pass

# /foo/bar.py: a submodule of foo, used by foo.py
from . import foo
...
if __name__ == "__main__":
   pass
</code></pre>
<p>How should I modify the sample code in order to be able to execute all: <code>test.py</code>, <code>foo.py</code> and <code>bar.py</code></p>
<p>I'm looking for a solution that works with python 2.6+ (including 3.x).</p>
</div>
<div class="post-text" itemprop="text">
<p>First, I assume you realize what you've written would lead to a circular import issue, because foo imports bar and viceversa; try adding </p>
<pre><code>from foo import bar
</code></pre>
<p>to test.py, and you'll see it fails. The example must be changed in order to work.</p>
<p>So, what you're asking is really to fallback to absolute import when relative import fails; in fact, if you're executing foo.py or bar.py as the main module, the other modules will just lie at the root level, and if they share the name with another module on the system which one will be picked depends on the order in sys.path. Since the current dir is usually the first, local modules will be picked if available - i.e., if you've got an 'os.py' file in the current working dir, it'll be picked instead of the builtin one.</p>
<p>A possibile suggestion is:</p>
<p>foo.py</p>
<pre><code>try:
    from . import bar
except ValueError:
    import bar

if __name__ == "__main__":
    pass
</code></pre>
<p>bar.py:</p>
<pre><code>if __name__ == "__main__":
    pass
</code></pre>
<p>By the way calling scripts from the proper position is usually <em>way</em> better.</p>
<pre><code>python -m foo.bar
</code></pre>
<p>Is probably the best way to go. This <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m" rel="nofollow noreferrer">runs the module as a script</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could just start 'to run the modules as standalones' in a bit a different way:</p>
<p>Instead of:</p>
<pre><code>python foo/bar.py
</code></pre>
<p>Use:</p>
<pre><code>python -mfoo.bar
</code></pre>
<p>Of course, the <code>foo/__init__.py</code> file must be present.</p>
<p>Please also note, that you have a circular dependency between <code>foo.py</code> and <code>bar.py</code> – this won't work. I guess it is just a mistake in your example.</p>
<p>Update: it seems it also works perfectly well to use this as the first line of the <code>foo/bar.py</code>:</p>
<pre><code>#!/usr/bin/python -mfoo.bar
</code></pre>
<p>Then you can execute the script directly in POSIX systems.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ditch relative imports: you should think of your package namespace as a global one, anyway.</p>
<p>The trick to making this palatable is editing <code>sys.path</code> appropriately. Here is some food for thought:</p>
<pre>
# one directory up
_root_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
sys.path.insert(0, _root_dir)for now
</pre>
</div>
<div class="post-text" itemprop="text">
<p>You need <code>__init__.py</code> in each folder.</p>
<p>Relative import works only when you do:</p>
<pre><code>python test.py
</code></pre>
<p>test.py imports foo.py and foo.py can relative import anything from the folder of test.py and above.</p>
<p>You can't do:</p>
<pre><code>cd foo
python foo.py
python bar.py
</code></pre>
<p>It will never work.</p>
<p>You can try the sys.path.append or sys.path.insert solution but you gonna screw up the paths and you'll have problems with the f=open(filename).</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not just put the "main" in a different .py file?</p>
</div>
<div class="post-text" itemprop="text">
<p>So far the only solution I found was not to use relative imports at all. </p>
<p>Due to current limitation, I'm wondering when someone is supposed to use relative imports in python.</p>
<p>On all configurations that I used the <code>sys.path</code> contained the current directory as first argument so just use <code>import foo</code> instead of <code>from . import foo</code> because it will do the same.</p>
</div>
<span class="comment-copy">Check this thread out: <a href="http://www.velocityreviews.com/forums/t502905-relative-import-broken.html" rel="nofollow noreferrer">velocityreviews.com/forums/t502905-relative-import-broken.html</a></span>
<span class="comment-copy">Thanks, unfortunately I was aware about this old thread but I found no solution to the problem. So far I only observed lots of people complaining about this. We need a clear solution/example for this issue.</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/8348726/">How to know if python script was run using interpreter's -m option?</a></span>
<span class="comment-copy">Duplicate of <a href="http://stackoverflow.com/questions/72852/">How to do relative imports in Python?</a></span>
<span class="comment-copy">Attention: The answer with the most up-votes is the second one.</span>
<span class="comment-copy">I don't think the <code>import bar</code> in the <code>except</code> statement will work for Python 3.1+</span>
<span class="comment-copy">@John as far as I can tell there's no reason because the import in the except should not work. It works 100% in Python 3.2.</span>
<span class="comment-copy">This is an ugly hack that I consider unacceptable, specially because it makes much harder to execute them (especially on Windows)</span>
<span class="comment-copy">By the way, bogdan's example worked, even with the circular import.</span>
<span class="comment-copy">+1, this is exactly the right way to "execute stand-alone" a module <b>as part of a package</b> (which you must, if you want to use relative imports, of course).</span>
<span class="comment-copy">−1. Don't ditch relative imports; they were considered fine when the absolute import feature was designed <a href="http://mail.python.org/pipermail/python-dev/2003-December/041065.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2003-December/041065.html</a> and they're just as fine today.</span>
<span class="comment-copy">But this will cause problems when you decide you want to use a python standard or third-party module with the same name as a module in your package. That is why IMHO it is much better to use <code>from __future__ import absolute_import</code> and relative imports.</span>
