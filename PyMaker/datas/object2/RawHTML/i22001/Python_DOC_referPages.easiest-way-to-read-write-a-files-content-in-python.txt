<div class="post-text" itemprop="text">
<p>In Ruby you can read from a file using <code>s = File.read(filename)</code>. The shortest and clearest I know in Python is</p>
<pre><code>with file(filename) as f:
    s = f.read()
</code></pre>
<p>Is there any other way to do it that makes it even shorter (preferably one line) and more readable?</p>
<p>Note: initially I phrased the question as "doing this in a single line of code". As pointed by S.Lott, shorter doesn't necessary mean more readable. So I rephrased my question just to make clear what I meant. I think the Ruby code is better and more readable not necessarily because it's one line versus two (though that matters as well), but also because it's a class method as opposed to an instance method, which poses no question about who closes the file, how to make sure it gets closed even if an exception is raised, etc. As pointed in the answers below, you can rely on the GC to close your file (thus making this a one-liner), but that makes the code worse even though it's shorter. Not only by being unportable, but by making it unclear.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're open to using libraries, try installing <a href="http://pypi.python.org/pypi/forked-path" rel="noreferrer">forked-path</a> (with either easy_install or pip).</p>
<p>Then you can do:</p>
<pre><code>from path import path
s = path(filename).bytes()
</code></pre>
<p>This library is fairly new, but it's a fork of a library that's been floating around Python for years and has been used quite a bit. Since I found this library years ago, I very seldom use <code>os.path</code> or <code>open()</code> any more.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open('x.py') as f: s = f.read()
</code></pre>
<p>***grins***</p>
</div>
<div class="post-text" itemprop="text">
<p>This is same as above but does not handle errors:</p>
<pre><code>s = open(filename, 'r').read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>contents = open(filename).read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text" rel="noreferrer">pathlib</a>.</p>
<p>Python 3.5 and above:</p>
<pre><code>from pathlib import Path
contents = Path(file_path).read_text()
</code></pre>
<p>For lower versions of Python use <a href="https://pypi.python.org/pypi/pathlib2" rel="noreferrer">pathlib2</a>:</p>
<pre><code>$ pip install pathlib2
</code></pre>
<p>Then</p>
<pre><code>from pathlib2 import Path
contents = Path(file_path).read_text()
</code></pre>
<p>Writing is just as easy:</p>
<pre><code>Path(file_path).write_text('my text')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This isn't Perl; you don't want to force-fit multiple lines worth of code onto a single line.  Write a function, then calling the function takes one line of code.</p>
<pre><code>def read_file(fn):
    """
    &gt;&gt;&gt; import os
    &gt;&gt;&gt; fn = "/tmp/testfile.%i" % os.getpid()
    &gt;&gt;&gt; open(fn, "w+").write("testing")
    &gt;&gt;&gt; read_file(fn)
    'testing'
    &gt;&gt;&gt; os.unlink(fn)
    &gt;&gt;&gt; read_file("/nonexistant")
    Traceback (most recent call last):
        ...
    IOError: [Errno 2] No such file or directory: '/nonexistant'
    """
    with open(fn) as f:
        return f.read()

if __name__ == "__main__":
    import doctest
    doctest.testmod()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Slow, ugly, platform-specific... but one-liner ;-)</p>
<pre><code>import subprocess

contents = subprocess.Popen('cat %s' % filename, shell = True, stdout = subprocess.PIPE).communicate()[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I call this <em>The Neat Way:</em></p>
<pre><code>    f=open('myfile.txt')
    s=f.read()
    f.close()
</code></pre>
<p>And do whatwver you want with the content <strong>"s"</strong></p>
<blockquote>
<p>For BIG FILES I suggest go line by line: <strong>f.readlines()</strong> ....inside a WITH statement for example</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>contents = open(filename)
</code></pre>
<p>This gives you generator so you must save somewhere the values though, or </p>
<pre><code>contents = [line for line in open(filename)]
</code></pre>
<p>This does the saving to list explicit close is not then possible (at least with my knowledge of Python).</p>
</div>
<span class="comment-copy">Create your own function. Then you can use it to get the contents. The call would be one line.</span>
<span class="comment-copy">Just curious, does the Ruby statement close the file as well?</span>
<span class="comment-copy">-1: No one wins at code golf.</span>
<span class="comment-copy">My question makes sense for me. I'm trying to find a better way to write these two lines (4 lines before the <code>with</code> statement in 2.5). Maybe there is a way, maybe there isn't. I can always try to find out, right? If you don't like it, downvote and move on. :)</span>
<span class="comment-copy">The benefit of <code>File.readlines("filename")</code> is that it reads the contents of a file given its name.  There is no file handle, descriptor, or object anywhere in evidence.  All the Python "equivalents" I've seen include an explicit open/close (or worse, an implicit open that requires an explicit close).</span>
<span class="comment-copy">Looks like a nice library. I won't install it just for this, but I'll have it in mind.</span>
<span class="comment-copy">why not file(filename).read() ?</span>
<span class="comment-copy">I don't get why this was the accepted answer as it's a total hack!</span>
<span class="comment-copy">The forked-path v0.2.3 installed by pip 18.6 on Windows is not compatible with Python 3.6.4. Seems like the format used for octal constants (e.g. <code>0777</code> instead of <code>0o0777</code>) is not supported by my current python version.</span>
<span class="comment-copy">+1 to <a href="https://stackoverflow.com/a/39591068/452174">Eyal Levin's answer</a>. If pathlib or pathlib2 had existed when I originally answered this 8 years ago, I would have mentioned them rather than forked-path. I haven't used forked-path in years.</span>
<span class="comment-copy">Upvoted for trying to be funny. Not marking as accepted though. :))</span>
<span class="comment-copy">awwwwwwwwww ;^)</span>
<span class="comment-copy">what is wrong with this answer? not recommended?</span>
<span class="comment-copy">Just no reason not to write it as OP did originally.  The intent was clear.</span>
<span class="comment-copy">Not really, yours leaves the file open.</span>
<span class="comment-copy">The CPython implementation does close the file when the reference count goes to zero, but that is an implementation detail that shouldn't be relied on.</span>
<span class="comment-copy">@Glenn Maynard:  Theoretically closing can be delayed until termination of the process, and in the meantime, the open file could leak (for instance to subprocesses in case of a <code>fork()</code>).</span>
<span class="comment-copy">If your design goal is "one line of code", you've inhaled too much Perl and you need to schedule some serious un-brainwashing time.</span>
<span class="comment-copy">No, this isn't confusing in the slightest.</span>
<span class="comment-copy">And when do you close the file?</span>
<span class="comment-copy">@ionut bizau - When the return of <code>open(...)</code> is garbage collected, I think. Someone correct me if I'm wrong.</span>
<span class="comment-copy">This is the shortest way to do it. i don't know why it has no votes.</span>
<span class="comment-copy">aaaaaaaaaaargh! (excess 'a's to meet min char limit)</span>
<span class="comment-copy">Certainly matches the spirit of the question... perverse use of Python to make it resemble Bash is no worse than making it resemble Ruby or Perl.</span>
<span class="comment-copy">why no need to close?</span>
<span class="comment-copy">and with contents = ''.join(line for line in open(filename)) you have the original file contents...</span>
<span class="comment-copy">Using a file as an iterator does <i>not</i> close the file deterministically (like <code>with</code> does).  It can't, because after iteration finishes, it's still valid to seek the file and start reading again, which wouldn't work if iteration closed the file.</span>
<span class="comment-copy">@Glenn But if you use the generator in list comprehension like my example, it is not even possible to close it as it has not name.</span>
<span class="comment-copy">"Not being able to close it" is <i>not</i> the same as "don't need to close it".</span>
