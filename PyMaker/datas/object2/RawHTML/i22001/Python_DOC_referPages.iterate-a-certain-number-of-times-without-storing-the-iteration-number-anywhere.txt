<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/818828/is-it-possible-to-implement-a-python-for-range-loop-without-an-iterator-variable">Is it possible to implement a Python for range loop without an iterator variable?</a>
<span class="question-originals-answer-count">
                    15 answers
                </span>
</li>
</ul>
</div>
<p>I was wondering if it is possible to perform a certain number of operations without storing the loop iteration number anywhere.</p>
<p>For instance, let's say I want to print two <code>"hello"</code> messages to the console. Right now I know I can do:</p>
<pre><code>for i in range(2):
    print "hello"
</code></pre>
<p>but then the <code>i</code> variable is going to take the values <code>0</code> and <code>1</code> (which I don't really need). Is there a way to achieve the same thing without storing those unwanted values anywhere?</p>
</div>
<div class="post-text" itemprop="text">
<p>The idiom (shared by quite a few other languages) for an unused variable is a single underscore <code>_</code>. Code analysers typically won't complain about <code>_</code> being unused, and programmers will instantly know it's a shortcut for <code>i_dont_care_wtf_you_put_here</code>. There is no way to iterate without having an item variable - as the Zen of Python puts it, "special cases aren't special enough to break the rules".</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>exec 'print "hello";' * 2
</code></pre>
<p>should work, but I'm kind of ashamed that I thought of it.</p>
<p><strong>Update:</strong>  Just thought of another one:</p>
<pre><code>for _ in " "*10: print "hello"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well I think the forloop you've provided in the question is about as good as it gets, but I want to point out that unused variables that have to be assigned can be assigned to the variable named <code>_</code>, a convention for "discarding" the value assigned. Though the <code>_</code> reference will hold the value you gave it, code linters and other developers will understand you aren't using that reference. So here's an example:</p>
<pre><code>for _ in range(2):
    print('Hello')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Others have addressed the inability to completely avoid an iteration variable in a <code>for</code> loop, but there are options to reduce the work a tiny amount. <code>range</code> has to generate a whole bunch of numbers after all, which involves a tiny amount of work; if you want to avoid even that, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>itertools.repeat</code></a> to just get the same (ignored) value back over and over, which involves no creation/retrieval of different objects:</p>
<pre><code>from itertools import repeat

for _ in repeat(None, 200):  # Runs the loop 200 times
    ...
</code></pre>
<p>This will run faster in microbenchmarks than <code>for _ in range(200):</code>, but if the loop body does meaningful work, it's a drop in the bucket. And unlike multiplying some anonymous sequence for your loop iterable, <code>repeat</code> has only a trivial setup cost, with no memory overhead dependent on length.</p>
</div>
<div class="post-text" itemprop="text">
<p>Although I agree completely with delnan's answer, it's not impossible:</p>
<pre><code>loop = range(NUM_ITERATIONS+1)
while loop.pop():
    do_stuff()
</code></pre>
<p>Note, however, that this will not work for an arbitrary list: If the first value in the list (the last one popped) does not evaluate to <code>False</code>, you will get another iteration and an exception on the next pass: <code>IndexError: pop from empty list</code>. Also, your list (<code>loop</code>) will be empty after the loop.</p>
<p>Just for curiosity's sake. ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>This will print 'hello' 3 times without storing <code>i</code>...</p>
<pre><code>[print('hello') for i in range(3)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply do <br/>
print 2*'hello'</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for word in ['hello'] * 2:
    print word
</code></pre>
<p>It's not idiomatic Python, but neither is what you're trying to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>Sorry, but in order to iterate over anything in any language, Python and English included, an index must be stored. Be it in a variable or not. Finding a way to obscure the fact that python is internally tracking the for loop won't change the fact that it is. I'd recommend just leaving it as is.</p>
</div>
<div class="post-text" itemprop="text">
<p>It turns out that using dummy* (starting word is dummy) as a variable do the same trick as _. But you don't mess with already defined and sometimes used variable or a function. </p>
</div>
<span class="comment-copy">I don't understand why such a thing like AutoHotkey's <code>Loop, 5 { ...</code> (simply repeat an action 5 times) does not exist anywhere else. No variables required an provides better readability.</span>
<span class="comment-copy">_ is also used for <code>gettext</code> i18n and its interpreter predefined variable. <code>i</code> looks much better</span>
<span class="comment-copy">+1 for your honesty ;-)</span>
<span class="comment-copy">This is the same as the OP's original code, just presented as a list comprehension instead of a for loop.</span>
<span class="comment-copy">I think that <code>i</code> will not exist outside of the list comprehension though, which is different from the for loop</span>
<span class="comment-copy">@SamHartman: The <code>i</code> will exist outside the listcomp on Py2, but not on Py3. List comprehensions have no separate scope on Py2, but in Py3 (and for genexprs and setcomp/dictcomps on Py2) they operate in a closure scope where the iteration variable is local to the closure scope, and can't be seen outside it. The discrepancy between listcomps and all other comprehensions/genexprs was one of the things that was simplified (in a compatibility breaking way) between Py2 and Py3.</span>
<span class="comment-copy">That's a solution only for the <i>example</i> OP provides. It doesn't answer all instances.</span>
<span class="comment-copy">For example, you need an unused variable to generate a list of random numbers.</span>
<span class="comment-copy">The thing is, the variable isn't actually unused. Somebody has to keep track of how many times to iterate, and how many times the loop has been executed.</span>
<span class="comment-copy">@Nathon: Wrong. Since <code>for i in seq: stuff()</code> is equivalent to (forgive me the braces, but comments don't preverve newlines) <code>_iterator = iter(seq); while True { try { i = next(_iterator) } except StopIteration { break } stuff() }</code>, we could remove the <code>i = </code> part from the desugared version and end up with no iteration variable. All iteration state is managed by the iterator, not by the iteration variable.</span>
<span class="comment-copy">@delnan I meant down in the guts. The implementation still needs to keep track (even if it's hiding somewhere in an iterator class). There will always be some memory somewhere devoted to keeping track of where in the iteration we are. It may be inaccessible, but that doesn't make it not exist.</span>
<span class="comment-copy">@nmichaels: You can iterate without an iteration variable hidden even in guts of a CPU register e.g., <code>def g(): { while True: { if random.random() &lt; 0.1: { break } else { yield 1 } } }</code>. <code>g()</code> is a generator; at any given time there is a 1 in 10 chance that the iteration stops and there is no any iteration variable (strictly speaking <code>random.random()</code> has an internal state that you can argue is a substitute for the iteration variable but we can implement <code>random.random()</code> in terms of external source e.g., <a href="http://www.random.org/" rel="nofollow noreferrer">random.org</a> in that case nothing can predict when the iteration stops)</span>
