<div class="post-text" itemprop="text">
<p>What is the fastest way to check if a string matches a certain pattern? Is regex the best way?</p>
<p>For example, I have a bunch of strings and want to check each one to see if they are a valid IP address (valid in this case meaning correct format), is the fastest way to do this using regex? Or is there something faster with like string formatting or something. </p>
<p>Something like this is what I have been doing so far:</p>
<pre><code>for st in strs:
    if re.match('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', st) != None:
       print 'IP!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you are trying to <a href="https://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python">validate IP addresses</a>. A regular expression is probably not the best tool for this.</p>
<p>If you want to accept all valid IP addresses (including some addresses that you probably didn't even know were valid) then you can use <a href="http://pypi.python.org/pypi/IPy/" rel="noreferrer">IPy</a> <a href="https://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python/330107#330107">(Source)</a>:</p>
<pre><code>from IPy import IP
IP('127.0.0.1')
</code></pre>
<p>If the IP address is invalid it will throw an exception.</p>
<p>Or you could use <code>socket</code> <a href="https://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python/319298#319298">(Source)</a>:</p>
<pre><code>import socket
try:
    socket.inet_aton(addr)
    # legal
except socket.error:
    # Not legal
</code></pre>
<p>If you really want to only match IPv4 with 4 decimal parts then you can split on dot and test that each part is an integer between 0 and 255.</p>
<pre><code>def validate_ip(s):
    a = s.split('.')
    if len(a) != 4:
        return False
    for x in a:
        if not x.isdigit():
            return False
        i = int(x)
        if i &lt; 0 or i &gt; 255:
            return False
    return True
</code></pre>
<p>Note that your regular expression doesn't do this extra check. It would accept <code>999.999.999.999</code> as a valid address.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm normally the one of the very few Python experts who steadfastly defends regular expressions (they have quite a bad reputation in the Python community), but this is not one of those cases -- accepting (say) <code>'333.444.555.666'</code> as an "IP address" is <strong>really</strong> bad, and if you need to do more checks after matching the RE, much of the point of using a RE is lost anyway.  So, I second @Mark's recommendations heartily: <a href="http://pypi.python.org/pypi/IPy/" rel="noreferrer">IPy</a> for generality and elegance (including support of IPv6 if you want!), string operations and int checks if you only need IPv4 (but, think twice about that limitation, and then think one more -- IPv6's time has <strong>way</strong> come!-):</p>
<pre><code>def isgoodipv4(s):
    pieces = s.split('.')
    if len(pieces) != 4: return False
    try: return all(0&lt;=int(p)&lt;256 for p in pieces)
    except ValueError: return False
</code></pre>
<p>I'd far rather do that than a convoluted RE to match only numbers between 0 and 256!-)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use <strong>Python3</strong>, you can use <code>ipaddress</code> module <a href="http://docs.python.org/py3k/library/ipaddress.html" rel="noreferrer">http://docs.python.org/py3k/library/ipaddress.html</a>. Example: </p>
<pre><code>&gt;&gt;&gt; import ipaddress

&gt;&gt;&gt; ipv6 = "2001:0db8:0a0b:12f0:0000:0000:0000:0001"
&gt;&gt;&gt; ipv4 = "192.168.2.10"
&gt;&gt;&gt; ipv4invalid = "266.255.9.10"
&gt;&gt;&gt; str = "Tay Tay"

&gt;&gt;&gt; ipaddress.ip_address(ipv6)
IPv6Address('2001:db8:a0b:12f0::1')

&gt;&gt;&gt; ipaddress.ip_address(ipv4)
IPv4Address('192.168.2.10')

&gt;&gt;&gt; ipaddress.ip_address(ipv4invalid)
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.4/ipaddress.py", line 54, in ip_address
    address)
ValueError: '266.255.9.10' does not appear to be an IPv4 or IPv6 address

&gt;&gt;&gt; ipaddress.ip_address(str)
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.4/ipaddress.py", line 54, in ip_address
    address)
ValueError: 'Tay Tay' does not appear to be an IPv4 or IPv6 address
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One more validation without re:</p>
<pre><code>def validip(ip):
    return ip.count('.') == 3 and  all(0&lt;=int(num)&lt;256 for num in ip.rstrip().split('.'))

for i in ('123.233.42.12','3234.23.453.353','-2.23.24.234','1.2.3.4'):
    print i,validip(i)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your regular expression doesn't check for the end of the string, so it would match:</p>
<pre><code>123.45.67.89abc123boogabooga
</code></pre>
<p>To fix this, use:</p>
<pre><code>'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$'
</code></pre>
<p>(note the <code>$</code> at the end).</p>
<p>Finally, in Python the usual style is to use <code>is not None</code> instead of <code>!= None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Install netaddr package</p>
<pre><code>sudo pip install netaddr
</code></pre>
<p>And then you can do this</p>
<pre><code>&gt;&gt;&gt; from netaddr import valid_ipv4
&gt;&gt;&gt; valid_ipv4('11.1.1.2') 
True
&gt;&gt;&gt; valid_ipv4('11.1.1.a')
False
</code></pre>
<p>Also you create a IPAddress object from that string and a lot more ip related operations</p>
<pre><code>&gt;&gt;&gt; from netaddr import IPAddress
&gt;&gt;&gt; ip = IPAddress('11.1.1.1')
&gt;&gt;&gt; [f for f in dir(ip) if '__' not in f]
['_module', '_set_value', '_value', 'bin', 'bits', 'format', 'info', 'ipv4', 'ipv6', 'is_hostmask', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local', 'is_loopback', 'is_multicast', 'is_netmask', 'is_private', 'is_reserved', 'is_unicast', 'key', 'netmask_bits', 'packed', 'reverse_dns', 'sort_key', 'value', 'version', 'words']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you should precompile the regexp, if you use it repeatedly</p>
<pre><code>re_ip = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
# note the terminating $ to really match only the IPs
</code></pre>
<p>then use</p>
<pre><code>if re_ip.match(st):
    print '!IP'
</code></pre>
<p>but.. is e.g. '111.222.333.444' really the IP?</p>
<p>i'd look at <code>netaddr</code> or <code>ipaddr</code> libraries whether they can be used to match IPs</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are validating IP address I would suggest the following:</p>
<pre><code>import socket

try:
    socket.inet_aton(addr)
    return True
except socket.error:
    return False
</code></pre>
<p>If you just want to check if it is in the right format then you would want to do it for all <a href="http://en.wikipedia.org/wiki/IPv4#Address_representations" rel="nofollow noreferrer">legal bases</a> (not just base 10 numbering).</p>
<p>Also, are the IP address IPv4 only (and none are IPv6) then you could just look up what valid address are and use <code>split()</code> (to get individual <em>components</em> of the IP) and <code>int()</code> (to type-caste for comparison). A quick reference to valid IPv4 rules is <a href="http://en.wikipedia.org/wiki/IP_address#IP_version_4_addresses" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>We do not need any import to do this. This also works much faster</p>
<pre><code>def is_valid_ip(str_ip_addr):
   """
   :return: returns true if IP is valid, else returns False
   """
   ip_blocks = str(str_ip_addr).split(".")
   if len(ip_blocks) == 4:
       for block in ip_blocks:
           # Check if number is digit, if not checked before calling this function
           if not block.isdigit():
               return False
           tmp = int(block)
           if 0 &gt; tmp &gt; 255:
               return False
       return True
    return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Other regex answers in this page will accept an IP with a number over 255.</p>
<p>This regex will avoid this problem:</p>
<pre><code>import re

def validate_ip(ip_str):
    reg = r"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
    if re.match(reg, ip_str):
        return True
    else:
        return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can make it a little faster by compiling it:</p>
<pre><code>expression = re.compile('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
for st in strs:
    if expression.match(st):
       print 'IP!'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I cheated and used combination of multiple answers submitted by other people. I think this is pretty clear and straight forward piece of code. <code>ip_validation</code> should return <code>True</code> or <code>False</code>. Also this answer only works for IPv4 addresses</p>
<pre><code>import re
ip_match = re.match('^' + '[\.]'.join(['(\d{1,3})']*4) + '$', ip_input)
ip_validate = bool(ip_match)
if ip_validate:
    ip_validate &amp;= all(map(lambda n: 0 &lt;= int(n) &lt;= 255, ip_match.groups())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Very simple to check whether given IP is valid or not using in built library <strong><em><a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer">ipaddress</a></em></strong>. You can <strong>also validate using mask</strong> value.</p>
<pre><code>ip = '30.0.0.1'   #valid
#ip = '300.0.0.0/8'  #invalid
#ip = '30.0.0.0/8'   #valid
#ip = '30.0.0.1/8'   #invalid
#ip = 'fc00:da00::3402:69b1' #valid
#ip = 'fc00:da00::3402:69b1/128' #valid
#ip = 'fc00:da00::3402:69b1:33333' #invalid

if ip.find('/') &gt; 0:
    try:
        temp2 = ipaddress.ip_network(ip)
        print('Valid IP network')        
    except ValueError:
        print('Invalid IP network, value error')
else:        
    try:
        temp2 = ipaddress.ip_address(ip)
        print('Valid IP')
    except ValueError:
        print('Invalid IP')
</code></pre>
<p>Note: Tested in Python 3.4.3</p>
</div>
<div class="post-text" itemprop="text">
<p>This works for ipv6 addresses as well.</p>
<p>Unfortunately it Works for python3 only</p>
<pre><code>import ipaddress

def valid_ip(address):
    try: 
        print ipaddress.ip_address(address)
        return True
    except:
        return False

print valid_ip('10.10.20.30')
print valid_ip('2001:DB8::1')
print valid_ip('gibberish')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/python
import sys
def check_ip(address):
    part=address.split(".")
    temp=True
    if len(part) != 4:
            temp=False
            return temp
    for p in part:
            if not 0&lt;= int(p) &lt;= 255:
                    temp=False
                    return temp
            else:
                    temp=True
    return temp
if __name__=="__main__":
    print check_ip(sys.argv[1])
</code></pre>
<p>Save the code with some name say- <code>check_ip.py</code> and run it as <code>python check_ip.py 192.168.560.25</code><br/>
<strong>Note:-</strong>  Above code fails for the below ip address-<br/>
<code>023.65.029.33</code></p>
</div>
<div class="post-text" itemprop="text">
<p>On Python 3.6 I think is much simpler as ipaddress module is already included:</p>
<pre><code>import ipaddress

    def is_ipv4(string):
        try:
            ipaddress.IPv4Network(string)
            return True
        except ValueError:
            return False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may try the following (the program can be further optimized):</p>
<pre><code>path = "/abc/test1.txt"
fh = open (path, 'r')
ip_arr_tmp = []
ip_arr = []
ip_arr_invalid = []

for lines in fh.readlines():
    resp = re.search ("([0-9]+).([0-9]+).([0-9]+).([0-9]+)", lines)
    print resp

    if resp != None:
       (p1,p2,p3,p4) = [resp.group(1), resp.group(2), resp.group(3), resp.group(4)]       

       if (int(p1) &lt; 0 or int(p2) &lt; 0 or int(p3) &lt; 0 or int(p4) &lt;0):
           ip_arr_invalid.append("%s.%s.%s.%s" %(p1,p2,p3,p4))

       elif (int(p1) &gt; 255 or int(p2) &gt; 255 or int(p3) &gt; 255 or int(p4) &gt; 255):
            ip_arr_invalid.append("%s.%s.%s.%s" %(p1,p2,p3,p4))

       elif (len(p1)&gt;3 or len(p2)&gt;3 or len(p3)&gt;3 or len(p4)&gt;3):
            ip_arr_invalid.append("%s.%s.%s.%s" %(p1,p2,p3,p4))

       else:
           ip = ("%s.%s.%s.%s" %(p1,p2,p3,p4))
           ip_arr_tmp.append(ip)

print ip_arr_tmp

for item in ip_arr_tmp:
    if not item in ip_arr:
       ip_arr.append(item)

print ip_arr
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use regular expressions: <a href="http://www.regular-expressions.info/python.html" rel="nofollow noreferrer">http://www.regular-expressions.info/python.html</a></p>
</div>
<span class="comment-copy">Accepting this for the IPy. I ended up using IPy partly because of @Alex's IPv6 point.</span>
<span class="comment-copy">Are leading 0s considered acceptable for IP addresses? For example, is 0.0.0.1 a valid IP?</span>
<span class="comment-copy">It is worth noting that there are security concerns with the socket module, which utilises the glibc inet_aton() function which "accepts trailing garbage for historical reasons", as reported here: <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1347549" rel="nofollow noreferrer">bugzilla.redhat.com/show_bug.cgi?id=1347549</a>.  Red Had Product Security has rated this issue as having medium security impact and, as such, it's not likely to be addressed any time soon. Given this, I'd contend that a good regex <i>is</i> the the best tool for this.</span>
<span class="comment-copy">+1 for use of <code>a&lt;=x&lt;b</code> and other things that make it a bit cleaner than my attempt.</span>
<span class="comment-copy">Although I completely agree with the major point of your answer, the code posted here checks for length 4 only, whereas addresses like 127.1 are  valid (socket.inet_aton agrees, and these addresses can be pinged). This in fact strengthens the need of using IPy or socket modules.</span>
<span class="comment-copy">Methods like this should be attempted before resorting in to <code>re</code>.</span>
<span class="comment-copy">It is better to return false by default if an exception is thrown. e.g '192.168.1.abc'</span>
<span class="comment-copy">Does this code works on Windows?  <code>File "C:\Python\Codes\check_ip.py", line 17     print check_ip(sys.argv[1])                  ^ SyntaxError: invalid syntax</code></span>
<span class="comment-copy">@Sabrina not sure..you can verify it...may be some indentation error at your side...try typing the code instead of copy paste</span>
<span class="comment-copy">OP has been using a regex.</span>
<span class="comment-copy">He already is doing that.</span>
