<div class="post-text" itemprop="text">
<p>I have my own exception classes inheriting from <code>Exception</code> class. I could check if type is <code>in {..my exceptions list..}</code>, but that seems problematic in my case. Is there any other way of checking if the exception is user-defined or Python's built-in exception. Thank you!</p>
<p>EDIT: The problem is that others can write their own exceptions or rename existing exceptions in their files, which I can't possibly keep track of. I  need to log built-in exceptions, and ignore exceptions thrown because of user's fault. I need the checking in except block</p>
<pre><code>try:
    # something
except Exception as god_knows_what_ex:
    # check if built-in
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create your own custom exception class that inherits from Exception, and have your current exception classes inherit from that one.</p>
<p>So basically:</p>
<pre><code>Exception
 - MyExceptionClass
    - MyExceptionClass1
    - MyExceptionClass2
 - Built-in exceptions
</code></pre>
<p>That way, you can check if an exception is an instance of your <code>MyExceptionClass</code>.</p>
<p>Then, you could do the following if you just want to know that thrown exception is user-defined:</p>
<pre class="lang-py prettyprint-override"><code>try:
    method_that_can_throw_an_exception()
except MyExceptionClass:
    print('User-defined exception thrown')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suspect that this question is due to the fact that your code has the following anti-pattern:</p>
<pre><code>try:
    # bad code
except Exception as e:
    # catch all exceptions in the world, and try to
    # understand the type of e in superfluous ways
</code></pre>
<p>You should not (usually) check the <code>type</code> of the exception, instead you should use <code>except</code> with the minimal subset of relevant exception types:</p>
<p><br/></p>
<pre><code>try:
    # bad code
except (CustomException1, CustomException2):
    # handle exception
</code></pre>
<p>Or, if each exception type requires a different handling:</p>
<pre><code>try:
    # bad code
except CustomException1:
    # handle CustomException1
except CustomException2:
    # handle CustomException2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A good design for this case is to define a base exception for your class. If someone wants to extend your module, make it crystal clear in your documentation that they have to use your exception type or extend it. Use the base class to create <code>UserException</code>. In the logging code, ignore <code>UserException</code> and log everything else.</p>
<p>Document this behavior.</p>
<p>Your approach probably won't work. You could start with this:</p>
<pre><code>ex.__class__.__module__
</code></pre>
<p>which will return <code>__builtin__</code> for predefined exceptions but not for those which are defined in the standard Python modules (*.py files in the library).</p>
<p>Also, how do you plan to support exceptions defined by other modules which users of your code have installed with <code>pip</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Although the reasons of this question are questionable, here's an alternative that:</p>
<ul>
<li><strong>Doesn't work</strong> in <em>Python</em> terminal</li>
<li>Filters out everything that's not <strong>built-in</strong> (<a href="https://docs.python.org/3/library/exceptions.html" rel="nofollow noreferrer">[Python 3]: Built-in Exceptions</a>)</li>
</ul>
<p><em>code.py</em>:</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import json


class UserError:
    pass


class UserException(BaseException):
    pass


def builtin_exc(exc_inst):
    return getattr(getattr(exc_inst, "__class__", None), "__module__", None) == "builtins"


def main():
    user_err = UserError()
    user_exc = UserException()
    base_exc = BaseException()
    exc = Exception()
    ni_err = NotImplementedError()
    jsdec_err = json.JSONDecodeError("", "", 0)
    for item in [user_err, user_exc, base_exc, exc, ni_err, jsdec_err]:
        print("'{:s}' is builtin: {:}".format(item.__class__.__name__, builtin_exc(item)))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    main()
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>[cfati@CFATI-5510-0:e:\Work\Dev\StackOverflow\q055262562]&gt; "e:\Work\Dev\VEnvs\py_064_03.06.08_test0\Scripts\python.exe" code.py
Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 24 2018, 00:16:47) [MSC v.1916 64 bit (AMD64)] on win32

'UserError' is builtin: False
'UserException' is builtin: False
'BaseException' is builtin: True
'Exception' is builtin: True
'NotImplementedError' is builtin: True
'JSONDecodeError' is builtin: False
</code></pre>
</blockquote>
</div>
<span class="comment-copy">What's problematic about checking if it's in your exceptions list? I'd imagine that list can't be too long</span>
<span class="comment-copy">Unless your <code>userdefined exception</code> has some attributes that one can check, i'm not sure</span>
<span class="comment-copy">Alternatively, you can check that exception is built-in via <code>exc in {.. built-in exceptions list ..}</code></span>
<span class="comment-copy">@Sanyash Which is probably longer than the custom defined exceptions...</span>
<span class="comment-copy">Sounds like an XY problem. Why do you care whether the exception is built-in?</span>
<span class="comment-copy">Why would it beat the purpose DeepSpace?</span>
<span class="comment-copy">Does this offer a solution?</span>
<span class="comment-copy">@SargsyanGrigor Yes. Do not check the <code>type</code> of the exception ("<code>if type is in {..my exceptions list..}</code>". It makes no sense and exceptions are not meant to be used this way. Instead, only use the relevant exceptions in the <code>except</code> clause like my answer suggests</span>
<span class="comment-copy">@SargsyanGrigor See my updated answer</span>
<span class="comment-copy">@DeepSpace: Curious to know why that's considered an anti-pattern</span>
<span class="comment-copy">@fountainhead Because it catches all exceptions, which means this <code>except</code> clause will hide exceptions that you would like to know about. Besides, why reinvent a mechanism that exists out of the box? Further reading: <a href="https://realpython.com/the-most-diabolical-python-antipattern/" rel="nofollow noreferrer">realpython.com/the-most-diabolical-python-antipattern</a></span>
<span class="comment-copy">Doesn't work for exceptions defined in standard Python modules like <code>HTTPException</code> in httplib.</span>
<span class="comment-copy">@AaronDigulla: Is that a built in exception? (Hmm, I think the topic is "a bit" more complex than meets the eye).</span>
<span class="comment-copy">He said he wanted to filter out "ignore exceptions thrown because of user's fault". I think that means "everything but a small set". He probably wants to log ZIP and various IO exceptions that are derived from <code>Exception</code> but are defined in Python modules, not in C code.</span>
