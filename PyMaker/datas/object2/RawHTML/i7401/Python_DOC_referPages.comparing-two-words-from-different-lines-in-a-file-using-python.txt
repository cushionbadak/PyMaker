<div class="post-text" itemprop="text">
<p>I am working with a file from the protein data bank which looks something like this.</p>
<pre><code>SITE     2 AC1 15 ASN A 306  LEU A 309  ILE A 310  PHE A 313                    
SITE     3 AC1 15 ARG A 316  LEU A 326  ALA A 327  ILE A 345                    
SITE     4 AC1 15 CYS A 432  HIS A 435  HOH A 504                               
CRYST1   64.511   64.511  111.465  90.00  90.00  90.00 P 43 21 2     8          
ORIGX1      1.000000  0.000000  0.000000        0.00000                         
ORIGX2      0.000000  1.000000  0.000000        0.00000                         
ORIGX3      0.000000  0.000000  1.000000        0.00000                         
SCALE1      0.015501  0.000000  0.000000        0.00000                         
SCALE2      0.000000  0.015501  0.000000        0.00000                         
SCALE3      0.000000  0.000000  0.008971        0.00000                         
ATOM      1  N   ASP A 229      29.461  51.231  44.569  1.00 47.64           N  
ATOM      2  CA  ASP A 229      29.341  51.990  43.290  1.00 47.13           C  
ATOM      3  C   ASP A 229      30.455  51.566  42.330  1.00 45.62           C  
ATOM      4  O   ASP A 229      31.598  51.376  42.743  1.00 47.18           O  
ATOM      5  CB  ASP A 229      29.433  53.493  43.567  1.00 49.27           C  
ATOM      6  CG  ASP A 229      28.817  54.329  42.463  1.00 51.26           C  
ATOM      7  OD1 ASP A 229      27.603  54.172  42.206  1.00 53.47           O  
ATOM      8  OD2 ASP A 229      29.542  55.145  41.856  1.00 52.96           O  
ATOM      9  N   MET A 230      30.119  51.424  41.051  1.00 41.99           N  
ATOM     10  CA  MET A 230      31.092  51.004  40.043  1.00 36.38           C  
</code></pre>
<p>First I needed to extract only the fourth column of the rows labeled ATOM, which is the amino acid sequence that specific atom is a part of. I have done that here.</p>
<pre><code>import gzip
class Manual_Seq:

    def parseSeq(self, path):
        with gzip.open(path,'r') as file_content:
            for line in file_content:
                newLine = line.split(' ')[0]
                if newLine == 'ATOM':
                    AA = line[17]+line[18]+line[19]
                    print AA
</code></pre>
<p>Which produces an output of this </p>
<pre><code>ASP
ASP
ASP
.....
MET
</code></pre>
<p>But what I need now, is to output only the first ASP and the first MET and etc and concatenate them so it'll look like this. </p>
<pre><code>ASPMET
</code></pre>
<p>I was thinking maybe I'll try to iterate ahead one line and compare it until it is different from the first output, but I am unsure of how I would do this, if you have any other ideas or any improvements to my code please do feel free to submit your suggestions, thanks.
I also need to mention that there can in fact be two identical amino acids in one file so the output could be "ASP MET ASP"</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, you don't need to cherry pick characters from a line string. You can use <code>str.split()</code> to get a list of strings for each line.</p>
<p>What you could do is maintain a list and set of sequences. The set is for efficient lookup, and the list stores symbols in order. </p>
<pre><code>seq_list = []
seq_set = {}

for line in file_content:
    items = line.split()
    if items[0] == 'ATOM':
        AA = items[3]
        if AA not in seq_set:
            seq_list.append(AA)
            seq_set.add(AA)
</code></pre>
<p>Outside the loop, you may just join the list items like this:</p>
<pre><code>print(''.join(seq_list))
</code></pre>
<p>I've retained the sequences inside a list so you have fine grained access/control for each sequence, if you want to do more than just printing them out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of printing them, make a list, so</p>
<pre><code>print AA
</code></pre>
<p>Becomes</p>
<pre><code>my_list.append(AA)
</code></pre>
<p>Just don't forget to initialize the list before the loop with <code>my_list=[]</code></p>
<p>Now that you have all those values, you can loop through them and make a string out of the unique values. If the order doesn't matter to you than you can use <code>set</code> like this:</p>
<pre><code>my_string = ''.join(set(my_list))
</code></pre>
<p>But if the order is important, you have to loop through that list:</p>
<pre><code>my_string = ''
seen = []
for item in my_list:
    if item not in seen:
        seen.append(item)
        my_string += item
</code></pre>
<p>You could do it without the <code>seen</code> list, but that would be risky</p>
<p>Anyway, all that means you are looping twice on the same data, which is not needed. Instead of all of this, you could initialize <code>my_string=''</code> and <code>seen=[]</code> before your main loop, and do what I did inside your loop instead of <code>print AA</code>... That would look like this:</p>
<pre><code>def parseSeq(self, path):
    with gzip.open(path,'r') as file_content:
        my_string = ''
        seen = []
        for line in file_content:
            newLine = line.split(' ')[0]
            if newLine == 'ATOM':
                AA = line[17]+line[18]+line[19]
                if AA not in seen:
                    seen.append(AA)
                    my_string += AA
        return my_string # or print my_string
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I added a bit of code to your existing code:</p>
<pre><code>import gzip
class Manual_Seq:

def parseSeq(self, path):
    with gzip.open(path,'r') as file_content:
</code></pre>
<p>Here we define an empty list, called AAs to hold your amino acids.</p>
<pre><code>        AAs = []
        for line in file_content:
</code></pre>
<p>Next, I generalized your code a bit to split the line into fields so that we can extract various fields, as needed.</p>
<pre><code>            fields = line.split(' ')
            line_index = fields[0]
            if line_index == 'ATOM':
</code></pre>
<p>He we check to see if the amino acid is already in the list of amino acids... If not, then we add the amino acid to the list... This has the effect of deduplicating the amino acids.</p>
<pre><code>                if fields[3] not in AAs:
                    AAs.append(fields[3])
</code></pre>
<p>Lastly, we concatenate all the values into a single value using the empty string <code>''</code> and the <code>join()</code> method.</p>
<pre><code>    return ''.join(AAs)            
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just wondering did you consider using this BioPandas?</p>
<p><a href="https://rasbt.github.io/biopandas/tutorials/Working_with_PDB_Structures_in_DataFrames/" rel="nofollow noreferrer">https://rasbt.github.io/biopandas/tutorials/Working_with_PDB_Structures_in_DataFrames/</a></p>
<p>It should be easier to do what you want to do using pandas.
You just need to use:</p>
<pre><code>df.column_name.unique()
</code></pre>
<p>and then concantenate the string in the list using <code>"".join(list_name)</code>
<a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer">https://docs.python.org/3/library/stdtypes.html#str.join</a></p>
</div>
<span class="comment-copy">Just to clarify: Why are you pairing the first <code>ASP</code> with the first <code>MET</code>? Is is to do with the matching values in the third column?  i.e. are you pairing 4th column values based in the entries in the 3rd column?</span>
<span class="comment-copy">@DatHydroGuy This is in order to print out the sequence of the protein in question. As you can see, the third column is the name of the atom and the fourth column is the sequence that atom is a part of. And a sequence of ASP will always have those atoms in that specific order. So this means that ASP is the first amino acid in the sequence for that chain, so it'll be something like ASPMET...(some other amino acids). And since ASP will always have those 8 atoms in that order, we do not need to print ASP*8 rather it's implied.</span>
<span class="comment-copy">Sorry I wasn't being specific enough, I forgot to mention that it is possible for two of the same amino acids to be in the same file, so one possible output could be "ASP MET ASP MET" for example. An amino acid like ASP will always have 8 lines and after that it is another amino acid.</span>
<span class="comment-copy">Actually I am using BioPython but since there are alot of PDB files which do not specify the sequence in the header, I'll have to manually extract them for each chain. But I'll look into BioPandas if it's that simple, thanks!</span>
