<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">python documentation</a> mentions that if you override <code>__eq__</code> and the object is immutable, you should also override <code>__hash__</code> in order for the class to be properly hashable.</p>
<p>In practice, when I do this I often end up with code like</p>
<pre><code>class MyClass(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __eq__(self, other):
        if type(other) is type(self):
            return (self.a == other.a) and (self.b == other.b)
        else:
            return False

    def __hash__(self):
        return hash((self.a, self.b))
</code></pre>
<p>This is somewhat repetitive, and there is a clear risk of forgetting to update one when the other is updated.</p>
<p>Is there a recommended way of implementing these methods together?</p>
</div>
<div class="post-text" itemprop="text">
<p>Answering my own question. It seems one way of performing this is to define an auxillary <code>__members</code> function and to use that in defining <code>__hash__</code> and <code>__eq__</code>. This way, there is no duplication:</p>
<pre><code>class MyClass(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __members(self):
        return (self.a, self.b)

    def __eq__(self, other):
        if type(other) is type(self):
            return self.__members() == other.__members()
        else:
            return False

    def __hash__(self):
        return hash(self.__members())
</code></pre>
</div>
