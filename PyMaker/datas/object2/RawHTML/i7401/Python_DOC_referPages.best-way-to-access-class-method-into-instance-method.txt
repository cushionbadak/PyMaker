<div class="post-text" itemprop="text">
<pre><code>class Test(object):

    def __init__(self):
        pass

    def testmethod(self):
        # instance method
        self.task(10)      # type-1 access class method

        cls = self.__class__ 
        cls.task(20)        # type-2 access class method 

    @classmethod 
    def task(cls,val)
        print(val)
</code></pre>
<p>I have two way to access class method into instance method. </p>
<pre><code>self.task(10)
</code></pre>
<p>or</p>
<pre><code>cls = self.__class__
cls.task(20)
</code></pre>
<p>My question is which one is the best and why??</p>
<p>If both ways are not same, then which one I use in which condition?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>self.task(10)</code> is definitely the best.</p>
<p>First, both will ultimately end in same operation for class instances:</p>
<ul>
<li>__class__ is a special attribute that is guaranteed to exist for an class instance object and is is the class of the object (Ref: <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Python reference manual / Data model / The standard type hierarchy</a>)</li>
</ul>
<blockquote>
<p>Class instances <br/>...<br/>Special attributes: __dict__ is the attribute dictionary; __class__ is the instanceâ€™s class</p>
</blockquote>
<ul>
<li>calling a classmethod with a class instance object actually pass the class of the object to the method (Ref: same chapter of ref. manual):</li>
</ul>
<blockquote>
<p>...When an instance method object is created by retrieving a class method object from a class or instance, its __self__ attribute is the class itself</p>
</blockquote>
<p>But the first is simpler and does not require usage of a special attribute.</p>
</div>
<span class="comment-copy">You can also just directly call <code>Test.task(20)</code> from within that method, instead of your two-liner.</span>
<span class="comment-copy">@xgord: yes but the two are <i>not</i> equivalent. <code>Task.task(20)</code> will always call the <code>task</code> defined in <code>Task</code> whereas a <i>subclass</i> can override the method. In that case <code>self.task(20)</code> in a <code>SubTask</code> class will access <code>SubTask.task(20)</code>.</span>
<span class="comment-copy">That depends on the intended use - <code>self</code> will always refer to the current instances' methods and will persist not only through the inheritance chain (compared to calling by a class name, i.e. <code>Test.task()</code>), picking up the latest override, even a dynamic one, while referring by class type will always point to the actual class method. Nothing stops you from setting <code>your_instance.task = some_dynamic_override</code> and then <code>self.task()</code> will be calling that function.</span>
<span class="comment-copy">wouldnt it be the first one considering that self.__class__ would create an object while the first one is a direct call?</span>
<span class="comment-copy">@xgord  I want to know that both ways are same or not, if not then what is differences and when I use first type or second method</span>
