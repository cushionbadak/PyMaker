<div class="post-text" itemprop="text">
<p>There are 2 frameworks - Django and Flask. Django runs the project with REST, while Flask runs an Orchestration Layer.</p>
<p>Now there is a test, which supposed to check one of CRUD methods:</p>
<pre><code>@mock.patch('requests.post')
def test_create(self, request_mock,):
    request_mock.return_value = self.response_generator.create()
    response = self.client.post(url_for('foo.list', account='bar'),
                                content_type='application/json',
                                data=json.dumps({
                                    "name": "Foo",
                                    "type": "baz"
                                }))
    self.assertEqual(response.status_code, 201)
</code></pre>
<p><code>name</code> and <code>type</code> are mandatory fields. <code>name</code> is just a string. But <code>type</code> is a url to the type (in the REST), so when <code>baz</code> is passed it uses magic to connect to the REST and retrieve data.</p>
<p>The problem is that when running the test Django with the REST is offline, while the test still tries to connect to it resulting in timeout error.</p>
<blockquote>
<p>with ConnectionError: HTTPConnectionPool(host='10.10.10.10', port=8000): Max retries exceeded with url: /rest/accounts/bar/baz/ (Caused by NewConnectionError(': Failed to establish a new connection: [Errno 111] Connection refused',))</p>
</blockquote>
<hr/>
<p><strong>Question:</strong> now how does one mock just that <code>type</code> field, so it doesn't call offline server?</p>
</div>
<div class="post-text" itemprop="text">
<p>The very first condition for useful unit tests is mocking the external dependencies that those tests may have. Just like in your case, you should be able to run it regardless of the availability of the service you are trying to test.</p>
<p>Although I do not know what <code>self.client</code> stands for (since you did not include the code for it) I guess by the error response you posted, that you created a <a href="https://docs.python.org/3/library/urllib.html#module-urllib" rel="nofollow noreferrer">urllib</a> client. </p>
<p>However, if your intention is to test a view within your Django project, you should make use of the django test client as the <a href="https://docs.djangoproject.com/en/dev/topics/testing/tools/#making-requests" rel="nofollow noreferrer">Django docs</a> suggest. Depending on your needs you should also consider <a href="https://docs.djangoproject.com/en/dev/topics/testing/advanced/#django.test.RequestFactory" rel="nofollow noreferrer">RequestFactory</a>. </p>
<p>Therefore there would be no need of having a urllib client since the framework is providing you with the required unit testing tools.</p>
<p>There are also similar <a href="https://stackoverflow.com/questions/692802/how-to-simulate-a-http-post-request-from-a-django-view-without-a-template">questions</a></p>
</div>
