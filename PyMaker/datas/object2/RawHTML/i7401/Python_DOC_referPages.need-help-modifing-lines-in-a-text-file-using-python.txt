<div class="post-text" itemprop="text">
<p>Hello I am having trouble modifying lines of text using python. I am making a payroll app and I cannot get the modify method to work. I do not understand why the entry that I search for will not delete in the new files. I am copying the files over to a temp and then renaming the temp file but the old entry stays in.</p>
<pre><code>def modEmp():
    empFile = open("employees.txt", 'r')
    empFile2= open("temp.txt",'w')
    line1 = empFile.readline().rstrip("\n")
    name = input("Enter in your employee name that you would like to modify\n")
    while line1 != '':
        line1 = line1.split(" ") #split line into list
        name = line1[0] + ' ' + line1[1]
        if name[0] == line1[0] and name[0] == line1[0]:
            print('Enter the modified entry:\n')
            list = [0] * 4
            list [0] = input('Enter first name:\n')
            list [1] = input('Enter last name:\n')
            list [2] = input('Enter pay rate:\n')
            list [3] = input('Enter hours worked:\n')
            empFile2.write(list[0] + ' ' + list[1] + ' ' + list[2] + ' ' + list[3] + "\n")

        else:
            empFile2.write(line1 + "\n")

        line1 = empFile.readline().rstrip("\n") 
    #Close file
    empFile.close()
    empFile2.close()
    os.remove('employees.txt')
    os.rename('temp.txt','employees.txt')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are some serious issues with your code:</p>
<pre><code>name = input("Enter in your employee name that you would like to modify\n")
...
    name = line1[0] + ' ' + line1[1]
</code></pre>
<p>You overwrite <code>name</code> before looking at it, so whatever they input doesn't matter.</p>
<p>As Hugh Bothwell pointed out:</p>
<pre><code>line1 = line1.split(" ") #split line into list
    name = line1[0] + ' ' + line1[1]
    if name[0] == line1[0] and name[0] == line1[0]:
</code></pre>
<p>Tries to compare a string to the first character in that same string, which will only be True if <code>name</code> is a single character.</p>
<p>Instead, you want to do something like this: I've cleaned up a lot of the extra fluff by using <a href="https://docs.python.org/3.1/reference/compound_stmts.html#with" rel="nofollow noreferrer"><code>with</code></a> which handles closing the files for us and letting the built-in <code>for element in list:</code> loop:</p>
<p>I've also renamed your list variable as <code>lst</code>, as overwriting the built-in <code>list</code> variable is a recipe for errors.</p>
<pre><code>def modEmp():
    with open("employees.txt", 'r') as empFile, open("temp.txt", "w") as empFile2:
        name = input("Enter in your employee name that you would like to modify\n")
        for line in empFile:
            if name in line:
                print('Enter the modified entry:\n')
                lst = []
                lst.append(input('Enter first name:\n'))
                lst.append(input('Enter last name:\n'))
                lst.append(input('Enter pay rate:\n'))
                lst.append(input('Enter hours worked:\n'))
                empFile2.write("{} {} {} {}\n".format(*lst))
            else:
                empFile2.write(line)

    # I highly encourage making a backup, as sooner or later
    # someone will mess it up
    os.rename('employees.txt', 'employees.bkp')
    os.rename('temp.txt','employees.txt')
</code></pre>
<p>Please note that, should you have more than one "bill" and you search for "bill", you will be prompted to change them both. Also, there is no abort for this function and it is destructive, so you lose whatever information was already stored for these employees. In a real payroll application, this would probably be disastrous.</p>
<hr/>
<p>Additionally, if you want to make it a little more reusable, instead of specifying four elements in a list, you can:</p>
<pre><code>prompts = ["Enter first name:\n", 
           "Enter last name:\n", 
           "Enter pay rate:\n", 
           "Enter hours worked:\n"]
empFile2.write(" ".join(map(input, prompts)) + '\n')
</code></pre>
<p>Which will compile as many inputs as prompts and then store them space separated in the file as a line, although it's less obvious what you're doing.</p>
</div>
<div class="post-text" itemprop="text">
<p>As mentioned in the comments, there are a few things wrong with your code...</p>
<p>It is <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">good practice</a> to use the <code>with open(name) as f:</code> syntax in a situation such as yours.</p>
<p>Here is a solution that I believe will solve your problem.</p>
<pre><code>def modify():
    with open("employees.txt", 'r+') as employee_file:  # Opening file in read and write mode
        temp = employee_file.readlines()  # Get all lines
        employee_file.seek(0)  # Reset position in file

        name = input("Enter in your employee name that you would like to "
                     "modify\n")

        first, last = name.split(' ')  # Assuming this is what you intended

        for line in temp:
            # There's no reason to use a list here, and avoid using object names as variables
            if first in line and last in line:
                print('Enter the modified entry:\n')
                first_name = input('Enter first name:\n')
                last_name = input('Enter last name:\n')
                pay_rate = input('Enter pay rate:\n')
                hours = input('Enter hours worked:\n')

                line_to_write = ' '.join([first_name, last_name,
                                          pay_rate, hours])
                employee_file.write(line_to_write + "\n")
            else:
                employee_file.write(line + "\n")

        employee_file.truncate()
</code></pre>
</div>
<span class="comment-copy"><code>if name[0] == line1[0] and name[0] == line1[0]:</code> This doesn't make sense!!??</span>
<span class="comment-copy">Fix your indentation...</span>
<span class="comment-copy"><code>name</code> is a string, <code>line1</code> is a list of string, therefore <code>name[0] == line1[0]</code> compares a character to a string, ie only works for people with 1-letter names ;-)</span>
<span class="comment-copy">You also overwrite name so it doesn't matter what name they put in.</span>
<span class="comment-copy">You're on the right track, but there still are some issues: <code>write()</code> takes a single argument: you must format the <code>first_name, last_name,...</code> prior to passing it to write. You must also insert the newline. Breaking the name into first/last then checking for each inclusion separately is extra work. Also, the default behavior of <code>split()</code> is to work on spaces, so it's unnecessary to specify it. I would encourage you in the future to run your code to verify it's accuracy.</span>
<span class="comment-copy">@TemporalWolf Thanks for the reminder about <code>write</code>, and <code>split</code> - however, you don't have to insert a newline.</span>
<span class="comment-copy"><a href="https://repl.it/J1GA/0" rel="nofollow noreferrer">repl.it</a> disagrees. <code>file.write()</code> does not insert a trailing newline for each call.</span>
<span class="comment-copy">Nope, <a href="https://repl.it/J1GR/0" rel="nofollow noreferrer">repl.it</a> for 2.7 shows the same thing.</span>
<span class="comment-copy"><a href="https://www.tutorialspoint.com/python/file_write.htm" rel="nofollow noreferrer">tutorialspoint.com/python/file_write.htm</a> mislead me, you are correct.</span>
