<div class="post-text" itemprop="text">
<p>I have a project depending on a shared library. To make it clear from the beginning: the shared library is a pure C library and not a Python library. For reasons of simplicity I created a small demo project called <em>pkgtest</em> which I will refer to. </p>
<p>So what needs to be done is: Run a Makefile to compile the library and place the compiled shared library (called <code>libhello.so</code> here) file somewhere it can be accessed from within the depending Python package. </p>
<p>My best guess so far was to run the makefile as a preinstallation routine, copy the <code>libhello.so</code> file in the packages directory and add it to the <code>package_data</code> parameter of the setup script. When installed the shared library then gets placed in the <code>site-packages/pkgtest/</code> directory and can be accessed from the module.</p>
<p>The package directory is structure is as simple as this:</p>
<pre><code>pkgtest/
  src/
     libhello.c
     libhello.h
     Makefile
  pkgtest/
    __init__.py
    hello.py
  setup.py
</code></pre>
<p>My setup.py looks like this:</p>
<p><em>setup.py</em></p>
<pre><code>import subprocess
from setuptools import setup
from distutils.command.install import install as _install


class install(_install):
    def run(self):
        subprocess.call(['make', 'clean', '-C', 'src'])
        subprocess.call(['make', '-C', 'src'])
        _install.run(self)


setup(
    name='pkgtest',
    version='0.0.1',
    author='stefan',
    packages=['pkgtest'],
    package_data={'pkgtest': ['libhello.so']},
    cmdclass={'install': install},
)
</code></pre>
<p>The Makefile actually builds the library and copies it into the directory of my python package.</p>
<p><em>src/Makefile</em></p>
<pre><code>all: libhello.so

libhello.o: libhello.c
        gcc  -fPIC -Wall -g -c libhello.c

libhello.so: libhello.o
        gcc -shared -fPIC -o libhello.so libhello.o
        cp libhello.so ../pkgtest/libhello.so

clean:
        rm -f *.o *.so
</code></pre>
<p>So all <code>hello.py</code> is actually doing is load the library and call the <code>hello</code> function that prints some text. But for completeness I will show the code here:</p>
<p><em>pkgtest/hello.py</em></p>
<pre><code>import os
import ctypes

basedir = os.path.abspath(os.path.dirname(__file__))
libpath = os.path.join(basedir, 'libhello.so')

dll = ctypes.CDLL(libpath)

def say_hello():
    dll.hello()
</code></pre>
<p>So this actually works but what I don't like about this approach is that the shared library lives in the directory of the Python package. I figure it would be better to put it in some sort of central library directory such as <em>/usr/lib/</em>. But for this one would need root privileges on installation. Has somebody got some experience with this kind of problem and would like to share a solution or helpful idea. Would be great.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a Python package which includes shared libraries and works on (almost) any linux distro using <a href="https://github.com/pypa/manylinux" rel="nofollow noreferrer">manylinux</a>.</p>
<blockquote>
<p>The goal of the manylinux project is to provide a convenient way to distribute binary Python extensions as wheels on Linux. This effort has produced <a href="https://www.python.org/dev/peps/pep-0513/" rel="nofollow noreferrer">PEP 513</a> which defines the <code>manylinux1_x86_64</code> and <code>manylinux1_i686</code> platform tags.</p>
</blockquote>
<p>The general procedure is:</p>
<ol>
<li>Build the external library and the Python package inside one of the docker containers provided by the manylinux team
(see <a href="https://github.com/pypa/python-manylinux-demo" rel="nofollow noreferrer">python-manylinux-demo</a>) </li>
<li>Run <a href="https://pypi.python.org/pypi/auditwheel" rel="nofollow noreferrer"><code>auditwheel repair</code></a> to copy the external shared libraries that your package depends on into the Python wheel, setting the RPATH accordingly.</li>
</ol>
<p>See <a href="https://github.com/pypa/python-manylinux-demo/blob/master/.travis.yml" rel="nofollow noreferrer"><code>.travis.yml</code></a> and <a href="https://github.com/pypa/python-manylinux-demo/blob/master/travis/build-wheels.sh" rel="nofollow noreferrer"><code>build-wheels.sh</code></a> in the <code>python-manylinux-demo</code> repo for an example.</p>
</div>
<span class="comment-copy">Have you considered using a package manager like <a href="https://conda.io/miniconda.html" rel="nofollow noreferrer">conda</a>? You could create a separate package for your library and for the Python code, and specify the library as a dependency of the Python code in the <code>meta.yaml</code> file.</span>
<span class="comment-copy">I didn't think about conda, yet. You are right, this would definetly be an option, however not my first choice as I want the package to be available via <code>pip install ...</code>.</span>
<span class="comment-copy">In that case, I don't think having a compiled library file inside your python package folder is a problem. That's where <a href="https://docs.python.org/3/extending/building.html" rel="nofollow noreferrer">Python extension modules</a> and <a href="http://docs.cython.org/en/latest/index.html" rel="nofollow noreferrer">Cython</a> modules are placed. But maybe there's a better solution...</span>
<span class="comment-copy">I see no reason why to have a Makefile in the first place. Simple C object files can be compiled and installed by setuptools and the like automatically. See [<a href="https://docs.python.org/3/extending/building.html](here)" rel="nofollow noreferrer">docs.python.org/3/extending/building.html](here)</a>.</span>
<span class="comment-copy">I use the library above only for example. The actual library is more complex with multiple source files and linking. I didn't see how to to this with setuptools.</span>
<span class="comment-copy">This looks great. If I get it right the example shows how to build a Python C extension and include that in the wheel. As stated in the question the aim is not to build a Python C extension but build and include a pure C shared library. I still can't figure out how to manage that.</span>
