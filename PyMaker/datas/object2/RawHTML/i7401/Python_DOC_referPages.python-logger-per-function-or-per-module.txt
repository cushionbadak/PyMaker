<div class="post-text" itemprop="text">
<p>I am trying to start using logging in python and have read several blogs. One issue that is causing confusion for me is whether to create the logger per function or per module. In this <a href="https://fangpenlin.com/posts/2012/08/26/good-logging-practice-in-python/" rel="nofollow noreferrer">Blog: Good logging practice in Python</a> it is recommended to get a logger per function. For example:</p>
<pre><code>import logging

def foo():
    logger = logging.getLogger(__name__)
    logger.info('Hi, foo') 

class Bar(object):
    def __init__(self, logger=None):
        self.logger = logger or logging.getLogger(__name__)

    def bar(self):
        self.logger.info('Hi, bar')
</code></pre>
<p>The reasoning given is that </p>
<blockquote>
<p>The logging.fileConfig and logging.dictConfig disables existing loggers by default. So, those setting in file will not be applied to your logger. It’s better to get the logger when you need it. It’s cheap to create or get a logger.</p>
</blockquote>
<p>The recommended way I read everywhere else is like as shown below. The blog states that this approach <code>"looks harmless, but actually, there is a pitfall"</code>.</p>
<pre><code>import logging
logger = logging.getLogger(__name__)

def foo():
    logger.info('Hi, foo') 

class Bar(object):
    def bar(self):
        logger.info('Hi, bar')
</code></pre>
<p>I find the former approach to be tedious as I would have to remember to get the logger in each function. Additionally getting the logger in each function is surely more expensive than once per module. Is the author of the blog advocating a non-issue? Would following logging best practices avoid this issue?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would agree with you; getting logger in each and every function you use creates too much unnecessary cognitive overhead, to say the least.</p>
<p>The author of the blog is right about the fact that <em>you should be careful to properly initialize</em> (configure) your logger(s) before using them.</p>
<p>But the approach he suggests makes sense only in the case you have no control over your application loading and the application entry point (which usually you do).</p>
<p>To avoid premature (implicit) creation of loggers <a href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">that happens with a first call to any of the message logging functions</a> (like <code>logging.info()</code>, <code>logging.error()</code>, etc.) if a root logger hasn't been configured beforehand, <strong>simply make sure you configure your logger before logging</strong>.</p>
<p>Initializing the logger from the main thread before starting other threads is also recommended in <a href="https://docs.python.org/2/library/logging.html#logging.basicConfig" rel="nofollow noreferrer">Python docs</a>.</p>
<p>Python's logging tutorial (<a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial" rel="nofollow noreferrer">basic</a> and <a href="https://docs.python.org/3/howto/logging.html#logging-advanced-tutorial" rel="nofollow noreferrer">advanced</a>) can serve you as a reference, but for a more concise overview, have a look at the <a href="https://python-guide.readthedocs.io/en/latest/writing/logging/" rel="nofollow noreferrer">logging section of The Hitchhiker's Guide to Python</a>.</p>
<h3>A simple blueprint for logging from multiple modules</h3>
<p>Have a look at this modified <a href="https://docs.python.org/3/howto/logging.html#logging-from-multiple-modules" rel="nofollow noreferrer">example from Python's logging tutorial</a>:</p>
<pre><code># myapp.py
import logging
import mylib

# get the fully-qualified logger (here: `root.__main__`)
logger = logging.getLogger(__name__)    

def main():
    logging.basicConfig(format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                        level=logging.DEBUG)
    # note the `logger` from above is now properly configured
    logger.debug("started")
    mylib.something()

if __name__ == "__main__":
    main()
</code></pre>
<p>And</p>
<pre><code># mylib.py
import logging

# get the fully-qualified logger (here: `root.mylib`)
logger = logging.getLogger(__name__)

def something():
    logger.info("something")
</code></pre>
<p>Producing this on <code>stdout</code> (note the correct <code>name</code>):</p>
<pre><code>$ python myapp.py
2017-07-12 21:15:53,334 __main__     DEBUG    started
2017-07-12 21:15:53,334 mylib        INFO     something
</code></pre>
</div>
<span class="comment-copy"><code>The logging.fileConfig and logging.dictConfig disables existing loggers by default</code>; does this mean that if you use these functions to initialize loggers, other loggers initializing other loggers that are not configure by the dict/file will not work?</span>
<span class="comment-copy">Thank you for the great explanation. Your link to the <code>basicConfig</code> docs lead me to read <code>The functions debug(), info(), warning(), error() and critical() will call basicConfig() automatically if no handlers are defined for the root logger.</code> and <code>This function does nothing if the root logger already has handlers configured for it</code>. I also appreciate the emphasis on <i>make sure you configure your logger before logging</i>. If <code>logging.info('hello')</code> is added right before the basicConfig function the logging will print nothing.</span>
<span class="comment-copy">This answer has led me to believe getting the logger object within each function demonstrates a misunderstanding of how the logging module works. If you follow the best practice of <b>"make sure you configure your logger before logging"</b> there should be no issue with per module loggers</span>
<span class="comment-copy">You're welcome, I'm glad we got that cleared up. <code>:-)</code></span>
<span class="comment-copy">Underappreciated answer.</span>
