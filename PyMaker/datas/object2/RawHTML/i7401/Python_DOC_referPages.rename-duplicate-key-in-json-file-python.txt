<div class="post-text" itemprop="text">
<p>I have json file which has duplicate keys. </p>
<p>Example</p>
<pre><code>{
  "data":"abc",
  "data":"xyz"
}
</code></pre>
<p>I want to make this as 
    {
      "data1":"abc",
      "data2":"xyz"
    }</p>
<p>I tried using object_pairs_hook with json_loads, but it is not working. Could anyone one help me with Python solution for above problem</p>
</div>
<div class="post-text" itemprop="text">
<p>You can pass the <code>load</code> method a keyword parameter to handle pairing, there you can check for duplicates like this:</p>
<pre><code>raw_text_data = """{
  "data":"abc",
  "data":"xyz",
  "data":"xyz22"
}"""
def manage_duplicates(pairs):
    d = {}
    k_counter = Counter(defaultdict(int))
    for k, v in pairs:
        d[k+str(k_counter[k])] = v
        k_counter[k] += 1

    return d

print(json.loads(raw_text_data, object_pairs_hook=manage_duplicates))
</code></pre>
<p>I used <code>Counter</code> to count each key, if it already exists, I'm saving the key as <code>k+str(k_counter[k)</code> - so it will be added with a trailing number.</p>
<p><strong>P.S</strong></p>
<p>If you have control on the input, I would highly recommend to change your json structure to:</p>
<pre><code>{"data": ["abc", "xyz"]}
</code></pre>
<p><a href="http://tools.ietf.org/html/rfc4627#section-2.2" rel="nofollow noreferrer">The rfc 4627 for <code>application/json</code> media type</a> recommends unique keys but it doesn't forbid them explicitly:</p>
<blockquote>
<p>The names within an object SHOULD be unique.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>A quick and dirty solution using <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer"><code>re</code></a>.</p>
<pre class="lang-py prettyprint-override"><code>import re

s = '{ "data":"abc", "data":"xyz", "test":"one", "test":"two", "no":"numbering" }'

def find_dupes(s):
    keys = re.findall(r'"(\w+)":', s)
    return list(set(filter(lambda w: keys.count(w) &gt; 1, keys)))

for key in find_dupes(s):
    for i in range(1, len(re.findall(r'"{}":'.format(key), s)) + 1):
        s = re.sub(r'"{}":'.format(key), r'"{}{}":'.format(key, i), s, count=1)

print(s)
</code></pre>
<p>Prints this string:</p>
<pre><code>{
    "data1":"abc",
    "data2":"xyz",
    "test1":"one",
    "test2":"two",
    "no":"numbering"
}
</code></pre>
</div>
<span class="comment-copy">When you will consume that json, there will be no duplicates. Because of <a href="https://stackoverflow.com/questions/21832701/does-json-syntax-allow-duplicate-keys-in-an-object" title="does json syntax allow duplicate keys in an object">stackoverflow.com/questions/21832701/â€¦</a></span>
<span class="comment-copy">That's quite a strange requirement. Wouldn't you prefer <code>{"data": ["abc", "xyz"]}</code>?</span>
<span class="comment-copy">Also, how did you get such a file? Can you not fix the source?</span>
<span class="comment-copy">@AlexHall the input is not under my control. It is coming from different source. Hence I faced this issue</span>
<span class="comment-copy">Thank you so much for the help. It worked for me. As I do not have control over input, I could not change json structure</span>
<span class="comment-copy">This will be fail if the user has more than just <code>data</code> dup keys</span>
<span class="comment-copy">@OrDuan that's true, but OP asked for a simple substitution. If a universal solution was needed, I'd take my time. Nonetheless, thanks for feedback!</span>
<span class="comment-copy">@BrightOne thanks for the solution. As OrDuan mentioned it will fail if i provide more than just data duplicate keys. Could you please help address this issue</span>
<span class="comment-copy">Edited. <i>gosh, this is so ugly</i></span>
<span class="comment-copy">@BrightOne thanks for the updated answer. It is still giving one issue. It is not working for nested objects. It is working only for outer objects.</span>
