<div class="post-text" itemprop="text">
<p>I am unable to to dump <code>collections.namedtuple</code> as correct JSON.</p>
<p><strong><em>First</em></strong>, consider the <a href="https://docs.python.org/3.6/library/json.html#module-json" rel="nofollow noreferrer">official</a> example for using custom JSON serializer:</p>
<pre><code>import json

class ComplexEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, complex):
            return [obj.real, obj.imag]
        # Let the base class default method raise the TypeError
        return json.JSONEncoder.default(self, obj)

json.dumps(2 + 1j, cls=ComplexEncoder)   # works great, without a doubt
</code></pre>
<p><strong><em>Second</em></strong>, now consider the following example which tells Python how to JSONize a <code>Friend</code> object:</p>
<pre><code>import json

class Friend():
    """ struct-like, for storing state details of a friend """
    def __init__(self, _id, f_name, l_name):
        self._id = _id
        self.f_name = f_name
        self.l_name = l_name

t = Friend(21, 'Steve', 'Rogerson')

class FriendEncoder(json.JSONEncoder):
    """ take a Friend object and make it truly json """
    def default(self, aFriend):
        if isinstance(aFriend, Friend):
            return {
                "id": aFriend._id,
                "f_name": aFriend.f_name,
                "l_name": aFriend.l_name,
            }
        return super(FriendEncoder, self).default(aFriend)

json.dumps(t, cls=FriendEncoder) # returns correctly JSONized string
</code></pre>
<p><strong><em>Finally</em></strong> when we try to implement the same thing using namedtuples, <code>json.dumps(t, cls=FriendEncoder)</code> doesn't give any errors but gives the wrong output. Take a look:</p>
<pre><code>import pdb
import json
from collections import namedtuple

Friend = namedtuple("Friend", ["id", 'f_name', 'l_name'])

t = Friend(21, 'Steve', 'Rogerson')

print(t)

class FriendEncoder(json.JSONEncoder):
    """ take a Friend collections.namedtuple object and make it truly json """
    def default(self, obj):
        if True:    # if isinstance(obj, Friend):
            ans = dict(obj._asdict())
            pdb.set_trace()     # WOW!! even after commenting out the if and hardcoding True, debugger doesn't get called
            return ans
        return json.JSONEncoder.default(self, obj)

json.dumps(t, cls=FriendEncoder)
</code></pre>
<p>The output I get is not a dict-like but rather just a list of values i.e. <code>[21, 'Steve', 'Rogerson']</code></p>
<h3>Why?</h3>
<p>Is the default behavior such that information is lost?<br/>
Does json.dumps ignore the explicitly passed encoder?</p>
<hr/>
<p><strong>Edit:</strong> by correctly jsonized namedtuple I mean that json.dumps should return data like <em>exactly</em> <code>dict(nt._asdict())</code>, where <code>nt</code> is a pre defined namedtuple</p>
</div>
<div class="post-text" itemprop="text">
<p>As I said in a comment, the <code>json.JSONEncoder</code> only calls <code>default</code> when it encounters an object type it doesn't already know how to serialize itself. There's a <a href="https://docs.python.org/3/library/json.html#encoders-and-decoders" rel="nofollow noreferrer">table of them</a> in the <code>json</code> documentation. Here's a screenshot of it for easy reference:</p>
<p><a href="https://i.stack.imgur.com/8K9zu.png" rel="nofollow noreferrer"><img alt="table of types supported by default" src="https://i.stack.imgur.com/8K9zu.png"/></a></p>
<p>Note that <code>tuple</code> is on the list, and since <code>namedtuple</code> is a subclasses of <code>tuple</code>, it applies to them, as well. (i.e <code>isinstance(friend_instance, tuple)</code> ⇒ <code>True</code>).</p>
<p>This is why your code for handling instances of the <code>Friend</code> class never gets called.</p>
<p>Below is one way around the issue—namely by creating a <code>Wrapper</code> class whose instances which <em>won't</em> be a type it thinks it already knows how to handle, and then using a custom <code>JSONEncoder</code> to watch for them and does what you want. Here's what I mean:</p>
<pre><code>import json
from collections import namedtuple

class Wrapper(object):
    def __init__(self, obj):
        self.obj = obj

    def _asdict(self):
        return self.obj._asdict()

Friend = namedtuple("Friend", ["id", 'f_name', 'l_name'])
t = Friend(21, 'Steve', 'Rogerson')
print(t)

class FriendEncoder(json.JSONEncoder):
    """ Watch for objects that are Friend instances and convert them into
        dictionaries that can then be converted into a JSON formatted object
        by the built-in default JSONEncoder.
    """
    def default(self, obj):
        if isinstance(obj, Wrapper):
            return obj._asdict()
        return json.JSONEncoder.default(self, obj)

print(json.dumps(Wrapper(t), cls=FriendEncoder))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>Friend(id=21, f_name='Steve', l_name='Rogerson')
{"id": 21, "f_name": "Steve", "l_name": "Rogerson"}
</code></pre>
<p>For some additional information and insights, also check out <a href="https://stackoverflow.com/a/18561055/355230">my answer</a> to the question <a href="https://stackoverflow.com/questions/18478287/making-object-json-serializable-with-regular-encoder"><strong>Making object JSON serializable with regular encoder</strong></a>.</p>
</div>
<span class="comment-copy">The <code>default</code> method doesn't get called for subclasses of <code>tuple</code>, <code>list</code> etc.</span>
<span class="comment-copy">@vaultah I agree that <code>default</code> method isn't getting called. But can you substantiate "for subclasses of <code>tuple</code>, <code>list</code>, etc."</span>
<span class="comment-copy">The <code>json.JSONEncoder</code> only calls <code>default ()</code> on objects it doesn't already know how serialize itself, which includes <code>tuple</code>s, <code>list</code>s and <code>dict</code>s (and subclasses of them). This means that in order to do what you want, you'll need to "trick" it.</span>
<span class="comment-copy">Please describe you what think/want a <code>namedtuple</code> that has been "truly" converted to JSON would look like since such as thing is not a defined <a href="http://json.org/" rel="nofollow noreferrer">JSON object</a> Also, how do you expect it to be decoded later if it's non-standard?</span>
<span class="comment-copy">"<code>json.JSONEncoder</code> only calls <code>default ()</code> on objects it doesn't already know how serialize itself, which includes <code>tuples</code>, <code>lists</code> and ..." I can't understand the underlying source code (<code>json/encoder.py</code>) can you please explain?</span>
<span class="comment-copy">I am looking for solution on similar question. Thank you very much.</span>
