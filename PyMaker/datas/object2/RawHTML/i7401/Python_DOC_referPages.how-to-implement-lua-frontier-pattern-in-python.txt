<div class="post-text" itemprop="text">
<p>How to implement Lua <a href="http://lua-users.org/wiki/FrontierPattern" rel="nofollow noreferrer">frontier pattern</a></p>
<p><code>%f[set]</code> matches an empty string at any position such that the next character belongs to set and the previous character does not belong to set</p>
<p>in Python regex?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're probably looking for "lookahead" patterns in regular expressions. For example:</p>
<pre class="lang-py prettyprint-override"><code>import re

s = 'there is 1more 2go 3fold'
#     
pat = re.compile('(?=[12])')
for m in pat.finditer(s):
    print(m.start())
</code></pre>
<p>Yields:</p>
<pre class="lang-py prettyprint-override"><code>9
15
</code></pre>
<p>From <a href="https://docs.python.org/3/library/re.html" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>(?=...) Matches if ... matches next, but doesn’t consume any of the string. 
  This is called a lookahead assertion. For example, Isaac (?=Asimov) will match
  'Isaac ' only if it’s followed by 'Asimov'.  </p>
</blockquote>
<p>Contra one of the comments, lookahead expressions are not limited to 'fixed length strings', at least insofar as I understand that description. For example:</p>
<pre class="lang-py prettyprint-override"><code>s = 'there is 1Fmore 1Gother 21go 3fold 3slambam'

pat = re.compile('(?=(1F|2|3sl.[mn]))')
for m in pat.finditer(s):
    print(m.start(), repr(s[m.start():]))
</code></pre>
<p>Yields:</p>
<pre class="lang-py prettyprint-override"><code>9 '1Fmore 1Gother 21go 3fold 3slambam'
24 '21go 3fold 3slambam'
35 '3slambam'
</code></pre>
<p>Here the lookahead is for a fairly expansive sub-pattern of varying length and with embedded wildcards and its own subexpressions.</p>
</div>
<span class="comment-copy">Can you please expand on your explanation a bit more? I'm not really familiar with Lua and can't provide the equivalent Python regex without more information. It also probably help us understand what you want if you created an <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a> of your problem and showed what you tried.</span>
<span class="comment-copy">Do you have a specific string you're trying to match? As I said above, can you please provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>?</span>
<span class="comment-copy">Hi @ChristianDean I have added a link to Lua wiki which explains some cases. I'd like to find a unified substitution instead of solutions for a certain case.</span>
<span class="comment-copy">You'd better specify the scenarios you have. There is no exact equivalent in Python .</span>
<span class="comment-copy"><code>(?=...)</code> in Python re only supports fixed length string, while frontier patterns can be used with a complete pattern, which can't be converted easily.</span>
<span class="comment-copy">I don't understand the criticism. Added updated example with variable-length patterns as the lookahead. If you provide a more specific example of what you're trying to match, I'll try to translate. So far as I can see from the Lua examples you provided, lookahead is a very close analog of the frontier pattern.</span>
<span class="comment-copy">@JonathanEunice Frontier patterns work as both lookaheads and lookbehinds in Lua.</span>
<span class="comment-copy">You keep describing this pattern in generic terms. The document you link to provides just <i>one</i> example of the "frontier pattern" in use, and what it matches can be easily done in Python with <code>re.findall(r'\b[A-Z]+\b', "THE (QUICK) brOWN FOx JUMPS")</code>. Until you can provide an example that shows how <code>re</code> lookahead and lookbehind are insufficient, I don't see this frontier pattern as bringing anything new to the party.</span>
