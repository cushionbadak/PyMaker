<div class="post-text" itemprop="text">
<p>Consider the following scenario:</p>
<p>script.py:</p>
<pre><code>import sys
import cant_import_this

print(cant_import_this)
print(cant_import_this is sys)
</code></pre>
<p>cant_import_this.py:</p>
<pre><code>import sys
sys.modules['cant_import_this'] = sys
</code></pre>
<p>The output of <code>script.py</code> is, surprisingly:</p>
<pre><code>&lt;module 'sys' (built-in)&gt;
True
</code></pre>
<hr/>
<p>What seems to be happening is:</p>
<ol>
<li><code>import cant_import_this</code> checks if <code>cant_import_this</code> exists in <code>sys.modules</code></li>
<li><code>cant_import_this</code> can't be found in <code>sys.modules</code>, so <code>cant_import_this.py</code> is found and loaded</li>
<li>the uninitialized <code>cant_import_this</code> module is put into <code>sys.modules</code></li>
<li>the module is executed, which removes <code>cant_import_this</code> from <code>sys.modules</code> and replaces it with <code>sys</code></li>
<li>instead of returning the module itself, the result of the lookup <code>sys.modules['cant_import_this']</code> is returned</li>
</ol>
<p>Is this interpretation correct? More importantly, is this behavior documented anywhere? Could it possibly be considered a bug?</p>
</div>
<div class="post-text" itemprop="text">
<p>I found the answer in <a href="https://docs.python.org/3/reference/import.html#fnlo" rel="nofollow noreferrer">a footnote</a>:</p>
<blockquote>
<p>The importlib implementation avoids using the return value directly.
  Instead, it gets the module object by looking the module name up in
  sys.modules. The indirect effect of this is that an imported module
  may replace itself in sys.modules. This is implementation-specific
  behavior that is not guaranteed to work in other Python
  implementations.</p>
</blockquote>
<p>So it's not a bug, but it can't be relied on either.</p>
</div>
<span class="comment-copy">I think you have steps 3 and 4 reversed. Python cannot add a module to <code>sys.modules</code> until it has actually finished creating it, but by the time <code>can't_import_this</code> has been created, there is already an entry for that name in <code>sys.modules</code>, so it is left alone.</span>
<span class="comment-copy">@chepner I think we aren't on the same page about what "initialized" and "created" means. If I understand your comment correctly, you're saying that <code>cant_import_this</code> is executed <i>before</i> it is added to <code>sys.modules</code>? If so, you're incorrect - I can add <code>print(sys.modules['cant_import_this'])</code> to <code>cant_import_this.py</code> and it will run without throwing a <code>KeyError</code>.</span>
<span class="comment-copy">Hm, yes. I guess that means the <code>module</code> instance is created, but populated after the fact?</span>
<span class="comment-copy">@chepner Yes, <a href="https://docs.python.org/3/reference/import.html#loading" rel="nofollow noreferrer">the docs</a> say: <i>"The module will exist in sys.modules before the loader executes the module code. This is crucial because the module code may (directly or indirectly) import itself; adding it to sys.modules beforehand prevents unbounded recursion in the worst case and multiple loading in the best."</i></span>
