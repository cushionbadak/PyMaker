<div class="post-text" itemprop="text">
<p>I've written server and client programs with python</p>
<p><em>Server.py</em></p>
<pre><code> import socket

sock = socket.socket (socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 5555

sock.bind((host, port))

sock.listen(1)

conn, addr = sock.accept()

data = "Hello!"
data = bytes(data, 'utf-8')

conn.send(data)

sock.close()
</code></pre>
<p><em>Client.py on linux</em></p>
<pre><code>import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 5555

sock.connect((host, port))

data = sock.recv(2048)

data = str(data, "utf-8")

print(data)

sock.close()
</code></pre>
<p>When I run server and then client on local machine(Linux Mint) - It works correctly. I got "Hello!" in bash and everything is fine. BUT when I got my client program to another machine (Windows 8) and ran it (previously I ran server on Linux, of course, and change ip address in client to my static linux mint's IP) it says 
<strong><p>ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it</p></strong>
client.py on windows</p>
<pre><code>  import socket

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    host = "here is my static ip"
    port = 5555

    sock.connect((host, port))

    data = sock.recv(2048)

    data = str(data, "utf-8")

    print(data)

    sock.close()
</code></pre>
<p>I must say that I had done port forwarding in my router settings on port 5555. Earlier I had done same thing to port 80 and my own site worked correctly, but now it doesn't work to 5555 with python sockets! Why? I can't get it! And one more thing: I tried to change port to 80 in server and client files but it didn't work too. PLease, help.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have to change the <code>socket.gethostname()</code> in the server script to the empty string (or just directly call <code>socket.bind(('', port))</code>).</p>
<p>Your problem is not in the python but in the usage of sockets generally. When you create socket you just prepare your process to receive/send some data from/to another process. </p>
<h2>Server</h2>
<p>The first step for creating a socket you have to specify what kind of protocol will be used for communication between those processes. In your case it is the <code>socket.AF_INET</code> which is constant for use of IP protocol and the <code>socket.SOCK_STREAM</code> is specify reliable stream-oriented service. The reliable stream-oriented service means that you want to be sure that every single sent byte will be delivered to the other side and nothing can be lost during the communication (the underlying OS will use TCP protocol for that). From this point we are using IPv4 protocol (because we set the <code>socket.AF_INET</code>)</p>
<p>The second step is <code>bind</code> it to address. The <code>bind</code> process assign address where you expected that client will join (with your socket's settings it's a IP address and the TCP port). Your PC has multiple IP address (well at least two). It's always has <code>127.0.0.1</code> which is called callback and it works only when your applications communicate on the same PC (that is you Linux - Linux scenario in the question) and then you have IP which is used for communication with others computers (let's pretend it is <code>10.0.0.1</code>).</p>
<p>When you call <code>socket.bind(('127.0.0.1', 5555))</code> you're setting the socket to listen only for communication from the same PC. If you call <code>socket.bind(('10.0.0.1', 5555))</code> then the socket setting is ready to receive data targeted to the <code>10.0.0.1</code> address.</p>
<p>But what if you have 10 IPs or more and you want to receive everything (with right TCP port). For those scenarios you can leave the IP address in <code>bind()</code> empty and it does exactly what you want.</p>
<p>With Python's version of <code>bind()</code> you can enter also "computer name" instead of the concrete IP. The <code>socket.gethostname()</code> call return your computer's name. The problem is in the translation of "computer name" to the IP which Python makes behind your backs. The translation has some rules but generally your "computer name" can be translated into any IP address which you have set on your computer. In your case the your computer's name is converted into <code>127.0.0.1</code> and that's why communication works only between processes on the same computer.</p>
<p>After <code>socket.bind()</code> you have the socket ready to use but it is still "inactive". The <code>socket.listen()</code> activate the socket and wait while someone want to connect. When socket receives new connection request it will put into queue and wait for processing. </p>
<p>That's what <code>socket.accept()</code> do. It pulls the connection request from queue, accept it and establish the stream (remember the <code>socket.SOCK_STREAM</code> while you set up the socket) between the server and the client. The new stream is actually new socket but ready to communicate with other side. </p>
<p>What did happen with the old socket? Well it's still alive and you can call <code>socket.listen()</code> again to get another stream (connection).</p>
<h2>How is possible to have multiple sockets on the same port</h2>
<p>Every connection within computer's network is defined by flow which is 5-tuple of:</p>
<ul>
<li>L4 protocol (usually TCP or UDP)</li>
<li>Source IP address</li>
<li>Source L4 port</li>
<li>Destination IP address</li>
<li>Destination L4 port</li>
</ul>
<p>When you create new connection from client the flow can look like this <code>(TCP, 192.168.0.1, 12345, 10.0.0.1, 55555)</code>. Just for clarification the server's response flow is <code>(TCP,  10.0.0.1, 55555, 192.168.0.1, 12345)</code> but it isn't important for us. If you create another connection from client that it will differ at source TCP port (if you do it from another computer that it will differ also at the source IP). Only from this information you can distinguish every connection created to your computer.</p>
<p>When you create a server socket in your code and call <code>socket.listen()</code> it listen for any flow with this pattern <code>(TCP, *, *, *, 55555)</code> (the * means match everything). So when you get connection with <code>(TCP, 192.168.0.1, 12345, 10.0.0.1, 55555)</code> then <code>socket.accept()</code> create another socket which works only with this one concrete flow while the old socket still accepting new connections which wasn't established.</p>
<p>When operating system receives a packet it looks in the packet and check the flow. From this point it can happen a several scenarios:</p>
<ul>
<li>The packet's flow match all 5 items exactly (without usage of <code>*</code>). Then the packet's content is delivered to the queue associated with that socket (you're reading the queue when you call <code>socket.recv()</code>).</li>
<li>The packet's flow matched socket with associated flow contains <code>*</code> then it is considered as new connection and you can call <code>scoket.accept()</code>.</li>
<li>The operating system doesn't contain open socket which would match the flow. In that case the OS  refuse connection (or just ignore the packet it depends on firewall settings).</li>
</ul>
<p>Probably some example can clarify those scenarios. The operating system has something like table where it map flows to sockets. When you call <code>socket.bind()</code> it will assign flow to the socket. After the call the table can look like this:</p>
<pre><code>+=====================================+========+
|                Flow                 | Socket |
+=====================================+========+
| (TCP, *, *, *, 55555)               |      1 |
+-------------------------------------+--------+
</code></pre>
<p>When it receive packet with flow <code>(TCP, 1.1.1.1, 10, 10.0.0.1, 10)</code> then it won't match any flow (last port won't match). So the connection is refused. If it receives a packet with flow <code>(TCP, 1.1.1.1, 10, 10.0.0.1, 55555)</code> then the packet is delivered to the socket <code>1</code> (because there is a match). The <code>socket.accept()</code> call creates a new socket and record in the table.</p>
<pre><code>+=====================================+========+
|                Flow                 | Socket |
+=====================================+========+
| (TCP, 1.1.1.1, 10, 10.0.0.1, 55555) |      2 |
+-------------------------------------+--------+
| (TCP, *, *, *, 55555)               |      1 |
+-------------------------------------+--------+
</code></pre>
<p>Now you got 2 sockets for 1 port. Every received packet which match the flow associated with the socket <code>2</code> also match flow associated with socket <code>1</code> (on the contrary it does not apply). It's not a problem because the socket <code>2</code> has preciser match (is doesn't use the <code>*</code>) so any data with that flow will be delivered to socket <code>2</code>.</p>
<h2>How to server multiple connections</h2>
<p>When you want to do a "real" server than you're application should be able process multiple connection (without restarting). There are 2 basic approaches:</p>
<ol>
<li><p>sequential processing</p>
<pre><code>try:
    l = prepare_socket()
    while True:
        l.listen()
        s, a = socket.accept()
        process_connection(s) # before return you should call s.close()
except KeyboardInterrupt:
    l.close()
</code></pre>
<p>In this case you can process only one client while others clients have to wait for accept. If the <code>process_connection()</code> takes too long then others clients will timeout.</p></li>
<li><p>parallel processing</p>
<pre><code>import threading
threads = []

try:
    l = prepare_socket()
    while True:
        l.listen()
        s, a = socket.accept()
        t = threading.Thread(target=process_connection, s)
        threads.append(t)
        t.start()
except KeyboardInterrupt:
    for t in threads:
        t.join()
    l.close()
</code></pre>
<p>Now when you receive new connection it will create new thread so every connection is processed in parallel. The main disadvantage of this solution is that you have to solve common troubles with threading (like access to shared memory, deadlocks etc.).</p></li>
</ol>
<p>Beware those are only example codes and they are not complete! For example it doesn't contain code for graceful exit on unexpected exceptions.</p>
<h2>Servers in the Python</h2>
<p>The Python also contains module called <a href="https://docs.python.org/3/library/socketserver.html" rel="nofollow noreferrer"><code>socketserver</code></a> which contains shortcuts to create servers. <a href="https://docs.python.org/3/library/socketserver.html#socketserver-tcpserver-example" rel="nofollow noreferrer">Here</a> you can find example how to use it.</p>
<h2>Client</h2>
<p>With the client it's much more simpler than with the server. You just have to create socket with some settings (same as server side) and then tell it where is the server is (what is its IP and TCP port). This is accomplished through <code>socket.connect()</code> call. As bonus it also establish the stream between your client and server so from this point you can communicate.</p>
<hr/>
<p>You can find more information about socktes at the <a href="https://beej.us/guide/bgnet/output/html/multipage/index.html" rel="nofollow noreferrer">Beej's Guide to Network Programming</a>. It's written for usage with C but the concepts are the same.</p>
</div>
<span class="comment-copy">Try to replace <code>socket.gethostname()</code> with an empty string in the server script.</span>
<span class="comment-copy">@Qeek thank you very much! I am extremely new in python so can you please explain why does empty string work correctly and name of host doesn't?</span>
<span class="comment-copy">If both of your machines are located in your private network, you don't need to configure router. Have you checked that Windows machine does not have Firewall block for this particular port?</span>
<span class="comment-copy">But how does old socket (I have created firstly) live at some port while new one (that deals with certain connection already) is existing at the same port? How do they not interfere?</span>
<span class="comment-copy">@AlexanderMueller I expand the answer with explanations of how multiple sockets on the same port work.</span>
<span class="comment-copy">thank you. But there are some unclear things to me.</span>
<span class="comment-copy">1. When I call <code>socket.listen()</code> it listens to  <code>(TCP, *, *, *, 55555)</code> pattern. So current socket is on port 55555, cause we specified it when we <code>socket.bind()</code>. When something is coming new socket is created and it is on the same port (we can guess it if we look into new certain flow new socket works with: <code>(TCP, 192.168.0.1, 12345, 10.0.0.1, 55555)</code>). Okay, old socket listens to new connections, but new works with certain one, but they are on the same port! Port is a program, isn't it?</span>
<span class="comment-copy">Therefore one program works simultaneously as listener and as handler for certain connection. But I don't think so :c  2. You said that "The flow doesn't mach any socket so it will refuse connection."  If we have some packet from internet it must have destination address all (it's condition to get this packet at all) but you said, that we don't see any socket there, in the packet.</span>
