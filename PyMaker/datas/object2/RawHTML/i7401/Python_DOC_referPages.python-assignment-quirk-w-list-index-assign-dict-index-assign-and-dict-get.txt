<div class="post-text" itemprop="text">
<p>In ruby 2.4:</p>
<pre><code>x = ['a']
y = {}
x[0] = y[x[0]] = y.fetch(x[0], y.length)
puts y #=&gt; {"a"=&gt;0}
</code></pre>
<p>In python 3.5:</p>
<pre><code>x = ['a']
y = {}
x[0] = y[x[0]] = y.get(x[0], len(y))
print(y) #=&gt; {0: 0}
</code></pre>
<p>Why this?</p>
<p>ETA:</p>
<pre><code>y[x[0]] = x[0] = y.get(x[0], len(y))
</code></pre>
<p>produces expected behavior (much to my chagrin.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Ruby and Python are different languages, and make different choices. In Python assignments are <em>statements</em> and evaluates multiple assignment targets from <em>left to right</em>. Ruby made other choices; assignments are <em>expressions</em> and as a result are evaluated in the opposite order.</p>
<p>So in Ruby this happens:</p>
<ul>
<li>Evaluate <code>y.fetch(x[0], y.length)</code>, produces <code>0</code> (key is missing, <code>y</code> is empty).</li>
<li>Evaluate <code>y[x[0]] = 0</code>, so <code>y['a'] = 0</code>. This is an expression resulting in <code>0</code>.</li>
<li>Evaluate <code>x[0] = 0</code> (<code>0</code> being the result of the <code>y[x[0]] = 0</code> assignment expression).</li>
</ul>
<p>Note that in Ruby, an assignment is an <em>expression</em>. It can be nested inside other expressions, and the result of the assignment expression is the value of the target after assignment.</p>
<p>In Python this happens instead:</p>
<ul>
<li>Evaluate <code>y.get(x[0], len(y))</code>, produces <code>0</code> (key is missing, <code>y</code> is empty).</li>
<li>Evaluate <code>x[0] = 0</code>.</li>
<li>Evaluate <code>y[x[0]] = 0</code>, so <code>y[0] = 0</code>.</li>
</ul>
<p>From the Python <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">assignment statements documentation</a>:</p>
<blockquote>
<p>An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right.</p>
</blockquote>
<p>So the expression on the right-hand-side is evaluated <em>first</em>, and then assignment takes place to each target from left to right.</p>
<p>Python made assignments statements on purpose, because the difference between:</p>
<pre><code>if a = 42:
</code></pre>
<p>and</p>
<pre><code>if a == 42:
</code></pre>
<p>is so damn hard to spot, and even if intentional really hurt the readability of code. In Python, readability counts. A lot.</p>
<p>Generally speaking, you really want to avoid making assignments to names that are then also used in subsequent assignments in the same statement. Don't assign to <code>x[0]</code> and then use <code>x[0]</code> again in the same assignment, that's just hugely confusing.</p>
</div>
<span class="comment-copy">Because Python and Ruby are different languages? Python assigns to a series of assignment targets from left to right, Ruby from right to left.</span>
<span class="comment-copy">@MartijnPieters Sufficiently counterintuitive semantics are indistinguishable from compiler bugs.</span>
<span class="comment-copy">I find assignment expressions to be abhorrent, so we appear to be at an impasse. Pick a different language?</span>
<span class="comment-copy">Please stop moving the goal posts. If you have follow-up questions, make a new post.</span>
<span class="comment-copy">despite <code>x[0] = y[x[0]] = y.fetch(x[0], y.length)</code> being valid and yielding the <i>expected</i> results in Ruby, do you people write code like that? That is massively convoluted..</span>
<span class="comment-copy">But... That goes against C?! And it makes it impossible to transcribe it into <b>setitem</b> calls directly! Madness!</span>
<span class="comment-copy">@KarlDamgaardAsmussen: Why is that madness? Why should all languages make the same choice here?</span>
<span class="comment-copy">@KarlDamgaardAsmussen: and of course this is translatable to to <code>__setitem__</code> calls. You just need to adjust your evaluation order.</span>
<span class="comment-copy">@KarlDamgaardAsmussen: And most importantly: assignments in Python are statements, in C and Ruby they are expressions. That's a huge philosophical difference right there.</span>
<span class="comment-copy">Chained assignments explicitly emulate C. To deviate from C's behavior is to violate the principle of least surprise. It is definitionally unpythonic. Make it a hard error or emulate C.</span>
