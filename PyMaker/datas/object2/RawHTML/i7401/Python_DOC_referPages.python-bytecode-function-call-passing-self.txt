<div class="post-text" itemprop="text">
<p>I'm trying to understand how bytecode works.</p>
<p><code>a.func()</code> is a function call. The corresponding bytecode is roughly <code>LOAD_GLOBAL a</code>, <code>LOAD_ATTR attr</code> and then <code>CALL_FUNCTION</code> with 0 arguments.</p>
<p>This is totally fine if <code>a</code> is a module. But if <code>a</code> is an object, it has to pass the object instance itself. Since Python could NOT know whether <code>a</code> is a module or an object at compile time, naturally the bytecode is same regardless of the type of <code>a</code>. But how does the runtime system handle <code>self</code> as the first argument to <code>func</code> if <code>a</code> is an object? Is there some special handling below bytecode level that says "if it is called on an object prepend the object as the first argument"?</p>
</div>
<div class="post-text" itemprop="text">
<p>The bytecode doesn't have to vary for different object types. It is the responsibility of the object type itself to manage <em>binding behaviour</em>. This is covered in the <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor protocol</a>.</p>
<p>In short, <code>LOAD_ATTR</code> delegates attribute access to the object, via the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>object.__getattribute__</code> hook</a>:</p>
<blockquote>
<p>Called unconditionally to implement attribute accesses for instances of the class. </p>
</blockquote>
<p>For modules, <code>__getattribute__</code> simply looks up the name in the <code>__dict__</code> namespace and returns it. But for <em>classes and metaclasses</em>, the implementation will invoke the descriptor protocol if the attribute supports this. Functions support the descriptor protocol and return a <em>bound method</em> when so asked:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def method(self): pass
...
&gt;&gt;&gt; Foo().method  # access on an instance -&gt; binding behaviour
&lt;bound method Foo.method of &lt;__main__.Foo object at 0x107155828&gt;&gt;
&gt;&gt;&gt; Foo.method    # access on the class, functions just return self when bound here
&lt;function Foo.method at 0x1073702f0&gt;
&gt;&gt;&gt; Foo.method.__get__(Foo(), Foo)  # manually bind the function
&lt;bound method Foo.method of &lt;__main__.Foo object at 0x107166da0&gt;&gt;
</code></pre>
<p>This binding behaviour also underlies how <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer"><code>property</code></a>, <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a> and <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>staticmethod</code></a> objects work (the latter neuters the binding behaviour of a function by returning the function itself).</p>
</div>
<div class="post-text" itemprop="text">
<p>LOAD_ATTR does the magic via descriptors ( <a href="https://docs.python.org/2/howto/descriptor.html" rel="nofollow noreferrer">https://docs.python.org/2/howto/descriptor.html</a> ).</p>
<p>Assuming a is object of class A: 
In python functions are descriptors. When you do a.func, in reality it returns <code>A.func</code>, which is descriptor object (unbound function). It then "upgrades" itself to bound function (<code>A.func.__get__</code> is called). Unbound function must be given self argument as first explicitly. Bound function already has self argument remembered "inside" itself.</p>
<p>In python module is an object and uses exactly the same mechanism.</p>
</div>
<div class="post-text" itemprop="text">
<p>In a nutshell, <code>a.func</code> already knows which object it is bound to, and so does not require an explicit <code>self</code> (it already knows what <code>self</code> is):</p>
<pre><code>&gt;&gt;&gt; a.func
&lt;bound method A.func of &lt;__main__.A object at 0x10e810a10&gt;&gt;
</code></pre>
<p>Contrast this with <code>A.func</code> (where <code>A</code> is the class):</p>
<pre><code>&gt;&gt;&gt; A.func
&lt;unbound method A.func&gt;
</code></pre>
<p>Calling <code>A.func</code> does require an explicit <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; A.func()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unbound method func() must be called with A instance as first argument (got nothing instead)
&gt;&gt;&gt; A.func(a)
&gt;&gt;&gt;
</code></pre>
<p>Or, in bytecodes:</p>
<pre><code>          0 LOAD_GLOBAL              0 (A)
          3 LOAD_ATTR                1 (func)
          6 LOAD_GLOBAL              2 (a)
          9 CALL_FUNCTION            1
         12 POP_TOP             
</code></pre>
<p>(Note the extra <code>LOAD_GLOBAL</code>.)</p>
<p>The mechanics of bound vs unbound methods is explained in the <a href="https://docs.python.org/2/reference/datamodel.html" rel="nofollow noreferrer">Python Language Reference</a> (search for <code>im_self</code> or <code>__self__</code>).</p>
</div>
<span class="comment-copy">That's part of the attribute resolution process - the attribute you receive is a bound method that will insert the <code>self</code> argument.</span>
