<div class="post-text" itemprop="text">
<p>I have a python object that looks like this. I am trying to parse this object and turn it to a human readable string which I need to put in the logs. How can I recursively loop through this considering the object could be nested dictionaries or nested lists or dictionaries inside lists inside dictionaries etc. </p>
<pre><code>{"plugins": 
  [
    {"Chrome PDF Viewer": "mhjfbmdgcfjbbpaeojofohoefgiehjai"}, 
    {"Chrome PDF Viewer": "internal-pdf-viewer"}, 
    {"Native Client": "internal-nacl-plugin"}, 
    {"Shockwave Flash": "PepperFlashPlayer.plugin"}, 
    {"Widevine Content Decryption Module": "widevinecdmadapter.plugin"}
  ]
}
</code></pre>
<p>I want to possibly serialize the above to look something like this</p>
<pre><code>"plugins: 
     Chrome PDF Viewer": "mhjfbmdgcfjbbpaeojofohoefgiehjai, 
     Chrome PDF Viewer": "internal-pdf-viewer, 
     Native Client": "internal-nacl-plugin, 
     Shockwave Flash": "PepperFlashPlayer.plugin, 
     Widevine Content Decryption Module": "widevinecdmadapter.plugin"
</code></pre>
<p>My code so far [this works for nested dictionaries but I am not sure how I can alter this to support lists in the above object]:</p>
<pre><code>result_str = ""

def dictionary_iterator(results):
    global result_str
    for key, value in results.items():
        if isinstance(value, dict):
            result_str = result_str + key + ": \n \t"
            dictionary_iterator(value)
        else:
            result_str = result_str + key + ": " + str(value) + "\n"

    return result_str
</code></pre>
<p>I have looked over possible answers but could not find a solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>The formatting might be a bit off</p>
<pre><code>def humanizer(input, result=''):
    if type(input) == dict:
        for k, v in input.items():
            if type(v) == str:
                result += '%s:%s\n\t' % (str(k), str(v))
            elif type(v) in (dict, list):
                result += '%s:\n\t' % str(k)
                result = humanizer(v, result)
                result += '\n\t'
    elif type(input) == list:
        for item in input:
            if type(item) == str:
                result += item
                continue
            result = humanizer(item, result) + '\n\t'
    else:
        result += input + '\n\t'
    return result
</code></pre>
<p>Result:</p>
<pre><code>plugins:
        Chrome PDF Viewer:mhjfbmdgcfjbbpaeojofohoefgiehjai

        Chrome PDF Viewer:internal-pdf-viewer

        Native Client:internal-nacl-plugin

        Shockwave Flash:PepperFlashPlayer.plugin

        Widevine Content Decryption Module:widevinecdmadapter.plugin
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe the output of <a href="https://docs.python.org/3/library/pprint.html#pprint.pformat" rel="nofollow noreferrer" title="pformat">pformat</a> would suit you:</p>
<pre><code>from pprint import pformat
results_str = pformat(results)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need an elif-condition in case of type == list and a indentation tracker:</p>
<pre><code>data = {"plugins": 
  [
    {"Chrome PDF Viewer": "mhjfbmdgcfjbbpaeojofohoefgiehjai"}, 
    {"Chrome PDF Viewer": "internal-pdf-viewer"}, 
    {"Native Client": "internal-nacl-plugin"}, 
    {"Shockwave Flash": "PepperFlashPlayer.plugin"}, 
    {"Widevine Content Decryption Module": "widevinecdmadapter.plugin"}
  ],
  "anotherLevel":
    {
        "sublevel": [
            {'item1': 'value1'}
        ]
    }
}

result_str = ""
def dictionary_iterator(indent, data):
    global result_str

    if isinstance(data, dict):
        for key, value in data.items():
            result_str += indent*'\t' + key + '\n'
            indent = indent + 1
            dictionary_iterator(indent, value)

    elif isinstance(data, list):
        for item in data:
            if isinstance(item, dict) and len(list(item.keys())) == 1:
                key = list(item.keys())[0]
                value = item[key]
                result_str += indent*'\t' + key + ': ' + value + '\n'
            else:
                indent = indent + 1
                dictionary_iterator(indent, item)
    return result_str


if __name__ == '__main__':
    print(dictionary_iterator(0, data))
</code></pre>
<p>That will print out:</p>
<pre><code>plugins
    Chrome PDF Viewer: mhjfbmdgcfjbbpaeojofohoefgiehjai
    Chrome PDF Viewer: internal-pdf-viewer
    Native Client: internal-nacl-plugin
    Shockwave Flash: PepperFlashPlayer.plugin
    Widevine Content Decryption Module: widevinecdmadapter.plugin
    anotherLevel
        sublevel
            item1: value1
</code></pre>
</div>
<span class="comment-copy">The json library can do this for you: <a href="https://docs.python.org/2/library/json.html" rel="nofollow noreferrer">docs.python.org/2/library/json.html</a></span>
<span class="comment-copy">Thanks for the suggestion but I don't want to use that cause I want to do additional things that json library wont let me.</span>
<span class="comment-copy">Could you please fix indentation. Also please describe what do you want to iterate over. When you say <i>"I am trying to parse this object and turn it to a human readable string..."</i> it is not clear <i>what</i> are you trying to parse and <i>how</i> do you want parsed information to be assembled into a string. Is there anything wrong with your code? Does it work as expected but you would like to improve it?</span>
<span class="comment-copy">Why do you need <code>global result_str</code> inside this function? You are explicitly returning it!</span>
<span class="comment-copy">@smriti, post the desired result</span>
<span class="comment-copy">You could also use <a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer">isinstance</a> to validate the type.</span>
<span class="comment-copy">this wouldn't indent the serialized object though, correct?</span>
<span class="comment-copy">It does indent nested structures</span>
<span class="comment-copy">Why do you need a global var if you return it anyway? Global <i>varaibles</i> are a code smell.</span>
<span class="comment-copy">OP had it in his code ...</span>
