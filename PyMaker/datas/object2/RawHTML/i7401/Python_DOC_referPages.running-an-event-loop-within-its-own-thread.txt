<div class="post-text" itemprop="text">
<p>I'm playing with Python's new(ish) <code>asyncio</code> stuff, trying to combine its event loop with traditional threading. I have written a class that runs the event loop in its own thread, to isolate it, and then provide a (synchronous) method that runs a coroutine on that loop and returns the result. (I realise this makes it a somewhat pointless example, because it necessarily serialises everything, but it's just as a proof-of-concept).</p>
<pre><code>import asyncio
import aiohttp
from threading import Thread


class Fetcher(object):
    def __init__(self):
        self._loop = asyncio.new_event_loop()
        # FIXME Do I need this? It works either way...
        #asyncio.set_event_loop(self._loop)

        self._session = aiohttp.ClientSession(loop=self._loop)

        self._thread = Thread(target=self._loop.run_forever)
        self._thread.start()

    def __enter__(self):
        return self

    def __exit__(self, *e):
        self._session.close()
        self._loop.call_soon_threadsafe(self._loop.stop)
        self._thread.join()
        self._loop.close()

    def __call__(self, url:str) -&gt; str:
        # FIXME Can I not get a future from some method of the loop?
        future = asyncio.run_coroutine_threadsafe(self._get_response(url), self._loop)
        return future.result()

    async def _get_response(self, url:str) -&gt; str:
        async with self._session.get(url) as response:
            assert response.status == 200
            return await response.text()


if __name__ == "__main__":
    with Fetcher() as fetcher:
        while True:
            x = input("&gt; ")

            if x.lower() == "exit":
                break

            try:
                print(fetcher(x))
            except Exception as e:
                print(f"WTF? {e.__class__.__name__}")
</code></pre>
<p>To avoid this sounding too much like a "Code Review" question, what is the purpose of <code>asynchio.set_event_loop</code> and do I need it in the above? It works fine with and without. Moreover, is there a loop-level method to invoke a coroutine and return a future? It seems a bit odd to do this with a module level function.</p>
</div>
<div class="post-text" itemprop="text">
<p>You would need to use <code>set_event_loop</code> if you called <code>get_event_loop</code> anywhere and wanted it to return the loop created when you called <code>new_event_loop</code>.</p>
<p>From the <a href="https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.AbstractEventLoopPolicy.new_event_loop" rel="nofollow noreferrer">docs</a></p>
<blockquote>
<p>If thereâ€™s need to set this loop as the event loop for the current context, <code>set_event_loop()</code> must be called explicitly.</p>
</blockquote>
<p>Since you do not call <code>get_event_loop</code> anywhere in your example, you can omit the call to <code>set_event_loop</code>.</p>
</div>
<span class="comment-copy">What does "context" mean here? It can't mean "scope" as then there would be no need to call <code>set_event_loop</code> anywhere, unless for the odd case where you had multiple loops in the same scope. Is it a good idea to use <code>set_event_loop</code> regardless of the lack of <code>get_event_loop</code>, just in case the latter is called elsewhere in the codebase?</span>
<span class="comment-copy">It will vary based on the policy used, but <a href="https://docs.python.org/3/library/asyncio-eventloops.html#event-loop-policies-and-the-default-policy" rel="nofollow noreferrer">the default policy defines context as the current thread</a>. And yes, if there's a chance the same loop will be used elsewhere, then you should call <code>set_event_loop</code>.</span>
<span class="comment-copy">If the default policy "manages an event loop per thread", does that mean I don't explicitly need to call <code>asyncio.new_event_loop()</code>? That is, does each thread have an implicit event loop, which will be returned by <code>get_event_loop</code> when it's called within the same context? (Obviously, in my code above, I create a new loop <i>outside</i> the new thread, but that can be changed easily enough.)</span>
<span class="comment-copy">Correct. You can start with a call to <code>get_event_loop</code>. You only need to use <code>new_event_loop</code> when you don't want that loop or it's been closed.</span>
<span class="comment-copy">Awesome: Thanks :)</span>
