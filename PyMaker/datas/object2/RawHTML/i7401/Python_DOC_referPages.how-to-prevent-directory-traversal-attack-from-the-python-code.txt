<div class="post-text" itemprop="text">
<p>I need to prevent from <code>directory traversal attack</code> from my code using Python. I am explaining my code below.</p>
<pre><code>if request.GET.get('param') is not None and request.GET.get('param') != '':
    param = request.GET.get('param')
    startdir = os.path.abspath(os.curdir)
    requested_path = os.path.relpath(param, startdir)
    requested_path = os.path.abspath(requested_path)
    print(requested_path)
    tfile = open(requested_path, 'rb')
    return HttpResponse(content=tfile, content_type="text/plain")
</code></pre>
<p>Here I need user is running like <code>http://127.0.0.1:8000/createfile/?param=../../../../../../../../etc/passwd</code> this it should prevent the directory traversal attack.</p>
</div>
<div class="post-text" itemprop="text">
<p>Suppose the user content is all located in</p>
<pre><code>safe_dir = '/home/saya/server/content'
</code></pre>
<p>You need to verify the final request is in there:</p>
<pre><code>if os.path.commonprefix((os.path.realpath(requested_path),safe_dir)) != safe_dir: 
    #Bad user!
</code></pre>
<p>I encourage you to make sure all stuff you want accessible by the user in one place.</p>
</div>
<div class="post-text" itemprop="text">
<p>you could try the methods of <a href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.relative_to" rel="nofollow noreferrer"><code>pathlib.Path</code></a></p>
<pre><code>Path(root_dir).joinpath(param).resolve().relative_to(root_dir.resolve())
</code></pre>
<p>should return the relative path starting from the <code>root_dir</code>, or raise an <code>ValueError</code> if a directory traversal attack is tried</p>
<h1>testing</h1>
<pre><code>param = 'test_file'
Path(root_dir).joinpath(param).relative_to(root_dir)
</code></pre>
<blockquote>
<p>WindowsPath('test_file')</p>
</blockquote>
<pre><code>param = 'test_file/nested'
Path(root_dir).joinpath(param).relative_to(root_dir)
</code></pre>
<blockquote>
<p>WindowsPath('test_file/nested')</p>
</blockquote>
<pre><code>param = 'non_existing/../../data'
Path(root_dir).joinpath(param).resolve().relative_to(root_dir.resolve())
</code></pre>
<blockquote>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-26-a74379fe1817&gt; in &lt;module&gt;()
....
ValueError: 'C:\\python_scripts\\PyCharmProjects\\data' does not start with 'C:\\python_scripts\\PyCharmProjects\\testproject'
</code></pre>
</blockquote>
<pre><code>param = 'non_existing/../nested'
Path(root_dir).joinpath(param).resolve().relative_to(root_dir.resolve())
</code></pre>
<blockquote>
<p>WindowsPath('nested')</p>
</blockquote>
</div>
<span class="comment-copy">user should not be allowed to access or modify sudo directories. So check that path is not a sudo dir</span>
<span class="comment-copy">I need to prevent also that. Can you make it like this ?</span>
<span class="comment-copy">not saying that its a good solution but there are around 20 root directories so check that path does not contain any one of them like if user requests a path containing bin directory then don't allow</span>
<span class="comment-copy">this <code>safe_dir</code> will be allowed directory right ?</span>
<span class="comment-copy">You should consider adding <code>os.path.realpath()</code> to it in case there is a symlink in the safe path that points outside of it.</span>
<span class="comment-copy">@satya Correct. It's usually the best practice to make sure stuff readable by the world is in the same place.</span>
<span class="comment-copy">@zwer That's a very good point, I just used OP commands.</span>
<span class="comment-copy">Ok,Let me to implement it and let you know.</span>
