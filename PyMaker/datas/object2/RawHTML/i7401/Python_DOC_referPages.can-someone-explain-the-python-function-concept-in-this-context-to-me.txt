<div class="post-text" itemprop="text">
<p>How are you supposed to access the 10 in this? I've been informed we're returning a function in this function, but how does this make sense?</p>
<p>function([1, 2, 3, 4])(10)</p>
</div>
<div class="post-text" itemprop="text">
<p>In your expression <code>function([1, 2, 3, 4])(10)</code>, there are two <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">calls</a>, one with the argument <code>[1, 2, 3, 4]</code> and the other with the argument <code>10</code>. For this to work, <code>function</code> must be a callable that returns a callable. Python relies heavily on objects having types which define their behaviour, and callability is one of those behaviours, recursively defined by objects having a <code>__call__</code> method (which is a type of callable). Because of this dynamic behaviour, we can't tell from the expression what type <code>function</code> is. </p>
<p>We can provide examples that would make the expression valid, though. For instance:</p>
<pre><code>function = lambda x: x.__contains__
</code></pre>
<p>This creates an anonymous function using a lambda expression, which is a callable. That function returns a bound method (assuming its argument has the <code>__contains__</code> method) which in turn is callable, and the expression would evaluate to <code>False</code>. </p>
<pre><code>class function:
    def __init__(self,a):
        "Method called during object initialization"
        # Note that the return value doesn't come from this method.
        # self is created before it is called and returned after.
    def __call__(self,b):
        "Method called when the object is called"
        return "Well, the first one wasn't quite a function."
</code></pre>
<p>This makes a class named <code>function</code>, and classes are callable, which is how we instantiate them. So the first call became an object instantiation and the second call calls an object. In this example, we don't actually have a function, though we do have two methods that are called within the two calls. </p>
<p>AChampion's example uses two normal function definitions, one of which occurs inside another creating a closure over that call's <code>a</code> value. That is a more traditional approach, though we can still muddle the waters using mutable values:</p>
<pre><code>def function(a):
    def inner(b):
        return sum(a) == b
    return inner

&gt;&gt;&gt; l = [1,2,3,4]
&gt;&gt;&gt; eq = function(l)
&gt;&gt;&gt; eq(10)
True
&gt;&gt;&gt; eq(15)
False
&gt;&gt;&gt; l.append(5)
&gt;&gt;&gt; eq(15)
True
&gt;&gt;&gt; eq(10)
False
</code></pre>
<p>We see here that this isn't a pure function in the mathematical sense, as its value is affected by other state than its arguments. We frequently try to avoid such side effects, or at least expose them by prominently displaying the state container, such as in method calls. </p>
<p>Lastly, depending on the context, the expression could fail in a variety of ways including <code>NameError</code> if <code>function</code> simply isn't defined, or <code>TypeError</code> if one of the calls was attempted on a non-callable object. It's still syntactically correct Python, and both of those exceptions are possible to handle, although doing so is likely a bit of a perversion. An example might be a spreadsheet program in which the cell formulae are Python expressions; you'd <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow noreferrer">evaluate</a> them with specific namespaces (globals), and catch any error to account for mistyped formulae. </p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming a lot based on the limited information you've provided in your question.<br/>
But it looks like you trying to understand a functional closure. Here's a totally contrived example:</p>
<pre><code>def function(a):
    def inner(b):
        return sum(a) == b
    return inner

&gt;&gt;&gt; function([1,2,3,4])(10)
True
&gt;&gt;&gt; eq = function([1,2,3,4])
&gt;&gt;&gt; eq(10)
True
&gt;&gt;&gt; eq(11)
False
</code></pre>
</div>
<span class="comment-copy">This is not accessing the 10th element. The <code>function</code> function is returing a function that you then call with single parameter <code>10</code>.</span>
<span class="comment-copy">What exactly is <code>function</code>?</span>
