<div class="post-text" itemprop="text">
<p>I want to execute a sympy lambda function in parallel.
I don't know:</p>
<ul>
<li>why it works in parallel although it is a lambda function</li>
<li>why it stops working when I try executing without the pool</li>
<li>why it works if I uncomment the first return in <code>lambdify</code></li>
</ul>
<p>And apparently the markdown preprocessor needs a line of text above the code so this is the code: </p>
<pre><code>from multiprocessing import Pool

import sympy
from sympy.abc import x

def f(m):
    return m.lambdify()(1)

class Mult():
    def lambdify(self):
        # return sympy.lambdify(x, 2*x, 'numpy')
        self._lambdify = sympy.lambdify(x, 2 * x, 'numpy')
        return self._lambdify

if __name__ == '__main__':
    with Pool() as pool:
        m = Mult()
        print(pool.map(f, [m]))
        print(pool.map(f, [m]))
        print(f(m))
        print(pool.map(f, [m]))
</code></pre>
<p>It prints:</p>
<pre><code>[2]
[2]
2
PicklingError: Can't pickle &lt;function &lt;lambda&gt; at 0x000000000DF0D048&gt;: attribute lookup &lt;lambda&gt; on numpy failed
</code></pre>
<p>(I cut the traceback)</p>
<p>If I uncomment, it works normally:</p>
<pre><code>[2]
[2]
2
[2]
</code></pre>
<p>I tested only on Windows and it works exactly the same with 'numexpr' instead of 'numpy'.</p>
</div>
<div class="post-text" itemprop="text">
<p>The object <code>Mult</code> has no fields when it is created. It can thus be pickled with the stock <code>pickle</code> library. Then, when you call <code>lambdify</code>, you add a <code>_lambdify</code> attribute to the object containing a <code>lambda</code> expression, which cannot be pickled. This causes a failure in the <code>map</code> function</p>
<p>This explains why before calling <code>lambdify</code> you can pickle the object and use <code>Pool.map</code> and why it fails after the call.
When you uncomment the line in <code>lambdify</code>, you do not add the attribute to the class, and the <code>Mult</code> object can still be pickled after calling <code>lambdify</code>.</p>
</div>
<span class="comment-copy">You cannot call methods on instances of <i>live</i> objects across processes using <code>multiprocessing.Pool.map()</code> unless you go out of your way to explain the targeted subprocess how to reconstruct your <i>live</i> object on its side. For an example, check <a href="https://stackoverflow.com/a/44186168/7553525">this answer</a>.</span>
<span class="comment-copy">@zwer Of course, but it does not explain the points 2 and 3.</span>
<span class="comment-copy">It sounds like it explains everything. Do you have a reference for "you add a _lambdify attribute to the object containing a lambda expression, which cannot be pickled"?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/pickle.html#id2" rel="nofollow noreferrer">This reference</a> explain why lambda expression cannot be pickled. Note that apparently, <a href="https://github.com/uqfoundation/dill" rel="nofollow noreferrer"><code>dill</code></a> can serialize the result from <code>sympy.lambdify</code>.</span>
<span class="comment-copy">My bad, <code>dill</code> also fails to pickle <code>sympy</code> objects.</span>
<span class="comment-copy">Oh excuse me, I didn't understand what you said the first time. You are totally right. The thing that changes is that I try to pickle an object that contains a lambda.</span>
