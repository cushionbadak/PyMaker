<div class="post-text" itemprop="text">
<p>Consider the following code (not a very good design, but that's the point):</p>
<pre><code>class A(object):
    def __init__(self,filepath):
        self._access_file_system(filepath)

    def get(self):
        return self._result_dict


class B(object):
    def __init__(self,filepath1,filepath2):
        self._filepath1 = filepath1
        self._filepath2 = filepath2

    def foo(self):
        a1 = A(self._filepath1).get()
        a2 = A(self._filepath2).get()
        return a1['result']==a2['result']
</code></pre>
<p>Now, if I want to test <code>B.foo()</code>, I need to mock <code>A</code> (as it accesses the file-system inside the constructor).</p>
<p>To write a test that will make sure <code>B.foo()</code> returns <code>False</code> in case <code>a1.get()</code> and <code>a2.get()</code> provide different values, I also need to mock <code>B.get()</code>.</p>
<p>So, the test function should probably look like the following:</p>
<pre><code>import mock
mock_get = mock.MagicMock(side_effect=[{'result': 0}, {'result': 1}])

@mock.patch('__main__.A')
def test_foo(MockA):

    b = B('/file1','/file2')
    res = b.foo()
    assert res
    MockA.assert_any_call('/file1')
    MockA.assert_any_call('/file2')

    #Doesn't work -
    #the assignment doesn't propagate into the objects instantiated inside foo()
    #A.get = mock_get

    #The assigned method propagates into the class definition,
    #so it works - BUT WHY?!
    a = A(None)
    a.get = mock_get

    b = B('/file1', '/file2')
    res = b.foo()
    assert not res
</code></pre>
<p>Now, the strange point - as may be seen from the comments inside the code, if we assign <code>mock_get</code> to the class, it won't propagate, but if we create an instance and assign to it, it propagates to other instances of the class.</p>
<p>I suppose this behavior is related to internal mechanisms of <code>mock</code>, so it's important for me to understand it, to make proper usage of this library with all it's rich functionality.</p>
<p>So, does anyone has a clue?</p>
</div>
<div class="post-text" itemprop="text">
<p>On the first case I can not see anywhere that you are patching the <code>get</code> method. You should assign the mock value to the <code>get</code> method of <code>A</code> before <code>B</code> is called. For instance why does the following test fail?:</p>
<pre><code>import mock
mock_get = mock.MagicMock(side_effect=[{'result': 0}, {'result': 1}])

@mock.patch('__main__.A')
def test_foo(MockA):

    MockA.get = mock_get

    b = B('/file1','/file2')
    res = b.foo()
    assert not res
    MockA.assert_any_call('/file1')
    MockA.assert_any_call('/file2')
</code></pre>
<p>The reason for the previous behaviour is that we are forgetting to patch the return value of the object (A), in this case <code>MockA</code>, instead of the object itself (<code>MockA</code>). The <code>A</code> object is the result of instantiating the <code>A</code> class and you should access the method throgh the <code>return_value</code> of the <code>A</code> class. In your example it would be something similar to this:</p>
<pre><code>import mock
mock_get = mock.MagicMock(side_effect=[{'result': 0}, {'result': 1}])

@mock.patch('__main__.A')
def test_foo(MockA):

    MockA.return_value.get = mock_get
    b = B('/file1','/file2')
    res = b.foo()

    assert res
    MockA.assert_any_call('/file1')
    MockA.assert_any_call('/file2')
</code></pre>
<p>You can check some of the following posts for more info on common python unit testing pitfalls:</p>
<ul>
<li><a href="https://esaezgil.com/post/unittesting_pitfalls/" rel="nofollow noreferrer">https://esaezgil.com/post/unittesting_pitfalls/</a> (written by me)</li>
<li><a href="http://alexmarandon.com/articles/python_mock_gotchas/" rel="nofollow noreferrer">http://alexmarandon.com/articles/python_mock_gotchas/</a></li>
<li>And of course the docs: <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html</a></li>
</ul>
</div>
