<div class="post-text" itemprop="text">
<p>So let's say I have this bit of code:</p>
<pre><code>import coolObject

def doSomething():
   x = coolObject()
   x.coolOperation()
</code></pre>
<p>Now it's a simple enough method, and as you can see we are using an external library(<code>coolObject</code>). 
In unit tests, I have to create a mock of this object that roughly replicates it. Let's call this mock object <code>coolMock</code>. </p>
<p>My question is how would I tell the code when to use <code>coolMock</code> or <code>coolObject</code>? I've looked it up online, and a few people have suggested dependency injection, but I'm not sure I understand it correctly.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def doSomething(cool_object=None):
  cool_object = cool_object or coolObject()
  ...
</code></pre>
<p>In you test:</p>
<pre><code>def test_do_something(self):
   cool_mock = mock.create_autospec(coolObject, ...)
   cool_mock.coolOperation.side_effect = ...
   doSomthing(cool_object=cool_mock)
   ...
   self.assertEqual(cool_mock.coolOperation.call_count, ...)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As Dan's answer says, one option is to use dependency injection: have the function accept an optional argument, if it's not passed in use the default class, so that a test can pass in a moc.</p>
<p>Another option is to use the <code>mock</code> library (<a href="https://pypi.python.org/pypi/mock" rel="nofollow noreferrer">here</a> or <a href="https://docs.python.org/3/library/unittest.mock-examples.html" rel="nofollow noreferrer">here</a>) to replace your <code>coolObject</code>.</p>
<p>Let's say you have a <code>foo.py</code> that looks like</p>
<pre><code>from somewhere.else import coolObject

def doSomething():
    x = coolObject()
    x.coolOperation()
</code></pre>
<p>In your <code>test_foo.py</code> you can do:</p>
<pre><code>import mock

def test_thing():
    path = 'foo.coolObject'  # The fully-qualified path to the module, class, function, whatever you want to mock.
    with mock.patch('foo.coolObject') as m:
       doSomething()
       # Whatever you want to assert here.
       assert m.called
</code></pre>
<p>The <code>path</code> you use can include properties on objects, e.g. <code>module1.module2.MyClass.my_class_method</code>. A big gotcha is that you need to mock the object <em>in the module being tested</em>, not where it is defined. In the example above, that means using a path of <code>foo.coolObject</code> and not <code>somwhere.else.coolObject</code>.</p>
</div>
<span class="comment-copy">Did you try to search: <a href="https://stackoverflow.com/search?q=%5Bpython%5D+mock">stackoverflow.com/search?q=%5Bpython%5D+mock</a> ?</span>
<span class="comment-copy">See also <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer">docs.python.org/3/library/unittest.mock.html</a></span>
