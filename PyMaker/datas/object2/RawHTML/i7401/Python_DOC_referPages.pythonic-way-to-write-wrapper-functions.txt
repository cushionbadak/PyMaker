<div class="post-text" itemprop="text">
<p>Let's say I have a function <code>foo</code> that gets a few parameters</p>
<pre><code>def foo(width, height, depth=0):
    ...
</code></pre>
<p>I want to write a wrapper function that gets all of <code>foo</code>'s parameters and passes them on, e.g.</p>
<pre><code>def goo(width, height, depth=0):
    ...
    foo(width, height, depth)
    ...
</code></pre>
<p>But this is ugly, since I have to repeat the variables <em>and</em> the default values.</p>
<p><strong>What's the idiomatic way to do this in python?</strong></p>
<p>A few options I thought about:</p>
<ol>
<li><p>passing to <code>goo</code> a dictionary called <code>foo_params</code> and calling <code>foo(**foo_params)</code> but then is error prone since I don't know
if all the arguments are there</p></li>
<li><p>writing another wrapper for foo that checks if the params with default values are <code>None</code> and if so doesn't pass them</p></li>
<li><p>Putting the default values as constants so I won't repeat them</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>*args</code> and <code>**kwargs</code> syntax to pass an unknown amount of arguments and/or keyword arguments:</p>
<pre><code>&gt;&gt;&gt; def dec(func):
    def inner(*args, **kwargs):
        print('decorated function')
        func(*args, **kwargs)
    return inner

&gt;&gt;&gt; @dec
def func(a, b):
    return a + b

&gt;&gt;&gt; func(1, 2)
decorated function
&gt;&gt;&gt; 
</code></pre>
<p>One downside to using <code>*args</code> and <code>**kwargs</code> is that you'll lose the orginal function signature of the decorated function. eg:</p>
<pre><code>&gt;&gt;&gt; help(func)
Help on function inner in module __main__:

inner(*args, **kwargs)

&gt;&gt;&gt; 
</code></pre>
<p>The solution is to use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="noreferrer"><code>functools.wraps()</code></a>. It basically copies of the data from the decorated function to the wrapper function:</p>
<pre><code>&gt;&gt;&gt; from functools import wraps
&gt;&gt;&gt; 
&gt;&gt;&gt; def dec(func):
    @wraps(func)
    def inner(*args, **kwargs):
        print('decorated function')
        func(*args, **kwargs)
    return inner

&gt;&gt;&gt; @dec
def func(a, b):
    return a + b

&gt;&gt;&gt; func(1, 2)
decorated function
&gt;&gt;&gt; 
</code></pre>
<p>A you can see below, if you now do <code>help(func)</code> the original signature for <code>func</code> will be displayed:</p>
<pre><code>&gt;&gt;&gt; help(func)
Help on function func in module __main__:

func(a, b)

&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you are looking for <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer">functools's partial </a> function:</p>
<pre><code>from functools import partial

def foo(a,b):
    return a + b

goo = partial(foo, b = 1)

goo(5)   # returns 6
</code></pre>
</div>
<span class="comment-copy">You can just use <code>*args</code> and <code>**kwargs</code> (similar to your option 1, but no need to pass a dict to <code>goo()</code>). If a parameter is missing, the error will bubble up from <code>foo()</code> instead of <code>goo()</code>. Since they have the same function signature, that shouldn't be too confusing.</span>
<span class="comment-copy">i would recommend using <code>*args</code> and <code>**kwargs</code> as well. its the most general method and widely accepted</span>
<span class="comment-copy">@ChristianDean does this allow me to use the params in the wrapper function? I mean, without using <code>kwargs.get()</code></span>
<span class="comment-copy">@Dotan Yes. You no longer have to explicitly pass each argument and/or keyword argument to your function. All you're required to do is unpack the arguments tuple <code>args</code> and the keyword argument dictionary <code>kwargs</code> into the call to the decorated function. Python will handle the reset.</span>
<span class="comment-copy">I don't believe the OP is looking for currying, which is a different concept than wrapping</span>
