<div class="post-text" itemprop="text">
<p>I would like to pass a ByteArray variable from my Python program to my DLL written in C in order to accelerate some specific processing which is too slow in Python. I have gone through the Web, tried Ctypes with combinations of byref, cast, memoryviews, addressof, but nothing works. Is there any simple way to achieve this without copying my ByteArray into something else that will pass ?
Here is what I am trying to do:</p>
<pre><code>/* My C DLL */
__declspec(dllexport) bool FastProc(char *P, int L)
{
    /* Do some complex processing on the char buffer */
    ;
    return true;
}

# My Python program
from ctypes import *
def main(argv):
    MyData = ByteArray([1,2,3,4,5,6])
    dll = CDLL('CHELPER.dll')
    dll.FastProc.argtypes = (c_char_p, c_int)
    dll.FastProc.restype = c_bool

    Result = dll.FastProc(MyData, len(MyData))
    print(Result)
</code></pre>
<p>But I get a type error when passing the first parameter (MyData) to the C function.</p>
<p>Is there any solution that doesn't require too much overhead that would waste the benefits of my C function ?</p>
<p>Olivier</p>
</div>
<div class="post-text" itemprop="text">
<p>I'll assume that <code>ByteArray</code> is supposed to be <code>bytearray</code>. We can use <a href="https://docs.python.org/3/library/ctypes.html#ctypes.create_string_buffer" rel="nofollow noreferrer"><code>create_string_buffer</code></a> to create a mutable character buffer which is a <code>ctypes</code> array of <code>c_char</code>. But <code>create_string_buffer</code> will <em>not</em> accept a <code>bytearray</code>, we need to pass it a <code>bytes</code> object to initialize it; fortunately, casting between <code>bytes</code> and <code>bytearray</code> is fast and efficient.</p>
<p>I don't have your DLL, so to test that the array behaves correctly I'll use the <a href="https://www.gnu.org/software/libc/manual/html_node/strfry.html#index-strfry" rel="nofollow noreferrer"><code>libc.strfry</code></a> function to shuffle its chars. </p>
<pre><code>from ctypes import CDLL, create_string_buffer

libc = CDLL("libc.so.6") 

# Some test data, NUL-terminated so we can safely pass it to a str function.
mydata = bytearray([65, 66, 67, 68, 69, 70, 0])
print(mydata)

# Convert the Python bytearray to a C array of char
p = create_string_buffer(bytes(mydata), len(mydata))

#Shuffle the bytes before the NUL terminator byte, in-place.
libc.strfry(p)

# Convert the modified C array back to a Python bytearray
newdata = bytearray(p.raw)
print(newdata)
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>bytearray(b'ABCDEF\x00')
bytearray(b'BFDACE\x00')
</code></pre>
</div>
<span class="comment-copy">What is <code>ByteArray</code>? Shouldn't it be <code>bytearray</code> (all lower-case)? Are you using Python 3?</span>
<span class="comment-copy">Yes its a bytearray, sorry for the typo</span>
<span class="comment-copy">Create a ctypes array type that's the same length and pass the <code>bytearray</code> to its <a href="https://docs.python.org/3/library/ctypes.html#ctypes._CData.from_buffer" rel="nofollow noreferrer"><code>from_buffer</code></a> contsructor, e.g. <code>L = len(MyData);</code> <code>P = (ctypes.c_char * L).from_buffer(MyData);</code> <code>dll.FastProc(P, L)</code>.</span>
<span class="comment-copy">Yes, thanks eryksun, from_buffer will allow the c_char array to share its bytes with the original bytearray. I'll test as soon I am back at home. Reading further documentation I also found interfacing my C function with Cython is another option. I am going to try both options and compare the performances.</span>
<span class="comment-copy">I confirm that solution works and allows my C routine to work in-place (including modifying) on the original bytearray. Now I need to try the Python option, which I think is more elegant (direct call to the function) and more efficient.</span>
<span class="comment-copy">Mmmm, at a first glance I thought you had found the solution, but I went to the doc of create_string_buffer and my understanding is that it creates a new object and xopies the original bytearray in it. This is why at the end you print newdata instead of mydata. I would prefer by far that my function works on the original bytearray in-place, without any copy. Bytearrays being mutable that shouldn't violate Python laws. I found posts recommending SWIG to achieve what I want, I need to dig into this. Thanks very much for your help, I discovered the create_string_buffer function</span>
