<div class="post-text" itemprop="text">
<p>This is my second day of learning python (I know the basics of C++ and some OOP.), and I have some slight confusion regarding variables in python.</p>
<p>Here is how I understand them currently:</p>
<p>Python variables are references (or pointers?) to objects (which are either mutable or immutable). When we have something like <code>num = 5</code>, the immutable object <code>5</code> is created somewhere in memory, and the name-object reference pair <code>num</code> is created in a certain namespace. When we have <code>a = num</code>, nothing is being copied, but now both variables refer to the same object and <code>a</code> is added to the same namespace.</p>
<p>This is where my book, <em>Automate the boring stuff with Python</em>, confuses me. As it's a newbie book, it doesn't mention objects, namespaces, etc., and it attempts to explain the following code:</p>
<pre><code>&gt;&gt;&gt; spam = 42
&gt;&gt;&gt; cheese = spam
&gt;&gt;&gt; spam = 100
&gt;&gt;&gt; spam
100
&gt;&gt;&gt; cheese
42
</code></pre>
<p>The explanation it offers is exactly the same as that of a C++ book, which I am not happy about as we are dealing with references/pointers to objects. So in this case, I guess that in the 3rd line, as integers are immutable, <code>spam</code> is being assigned an entirely new pointer/reference to a different location in memory, i.e. the memory that it was initially pointing to wasn't modified. Hence we have <code>cheese</code> referring to the initial object referred to by <code>spam</code>. Is this the correct explanation?</p>
</div>
<div class="post-text" itemprop="text">
<p>As a C++ developer you can think of Python variables as pointers.</p>
<p>Thus when you write <code>spam = 100</code>, this means that you "assign the pointer", which was previously pointing to the object <code>42</code>, to point to the object <code>100</code>.</p>
<p>Earlier on, <code>cheese</code> was assigned to point to the same object as <code>spam</code> pointed to, which happened to be <code>42</code> at that time. Since you have not modified <code>cheese</code>, it still points to <code>42</code>.</p>
<p>Immutability has nothing to do with it in this case, since pointer assignment does not change anything about the object being pointed to.</p>
</div>
<div class="post-text" itemprop="text">
<p>The way I see it there are different views of a language.</p>
<ul>
<li>The "language lawyer" perspective. </li>
<li>The "practical programmer" perspective.</li>
<li>the "implementor" perspective.</li>
</ul>
<p>From the language lawyer perspective python variables always "point at" an object. However unlike Java and C++ the behvaiour of == &lt;= &gt;= etc depends on the runtime type of the objects that the variables point at. Furthermore in python memory management is handled by the language.</p>
<p>From a practical programmer perspective we can treat the fact that integers, strings, tuples etc are immutable* objects rather than straight values as an irrelevent detail. The exception is when storing large ammounts of numeric data we may want to use types that can store the values directly (e.g. numpy arrays) rather than types that will end up with an array full of references to tiny objects.</p>
<p>From an implementers perspective most languages have some sort of as-if rule such that if the specified behaviours are correct the implementation is correct regardless of how things are actually done under the hood.</p>
<p>So yes your explanation is correct from a language lawyer perspective. Your book is correct from a practical programmer perspective. What an implementation actually does depends on the implementation. In cpython integers are real objects though small value integers are taken from a cache pool rather than created anew. I'm not sure what the other implementations (e.g. pypy and jython) do.</p>
<p>* note the distinction between mutable and immutable objects here. With a mutable object we have to be careful about treating it "like a value" because some other code might mutate it. With an immutable object we have no such concerns.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is correct you can more or less thing of variables as pointers. However example code would help greatly with explaining <em>how</em> this actually is working.</p>
<p>First, we will heavily utilize the <a href="https://docs.python.org/3/library/functions.html#id" rel="noreferrer"><code>id</code></a> function:</p>
<blockquote>
<p>Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.</p>
</blockquote>
<p>It's likely this will return different absolute values on your machine.</p>
<p>Consider this example:</p>
<pre><code>&gt;&gt;&gt; foo = 'a string'
&gt;&gt;&gt; id(foo) 
4565302640
&gt;&gt;&gt; bar = 'a different string'
&gt;&gt;&gt; id(bar)
4565321816
&gt;&gt;&gt; bar = foo
&gt;&gt;&gt; id(bar) == id(foo)
True
&gt;&gt;&gt; id(bar)
4565302640
</code></pre>
<p>You can see that:</p>
<ul>
<li>The original foo/bar have different ids, because they point to different objects</li>
<li>When bar is assigned to foo, their ids are now the same. This is similar to them both pointing to the same location in memory that you see in making a C++ pointer</li>
</ul>
<p>when we change the value of foo, it is assigned to a different id:</p>
<pre><code>&gt;&gt;&gt; foo = 42
&gt;&gt;&gt; id(foo)
4561661488
&gt;&gt;&gt; foo = 'oh no'
&gt;&gt;&gt; id(foo)
4565257832
</code></pre>
<p>An interesting observation too is that integers implicitly have this functionality up to 256:</p>
<pre><code>&gt;&gt;&gt; a = 100
&gt;&gt;&gt; b = 100
&gt;&gt;&gt; c = 100
&gt;&gt;&gt; id(a) == id(b) == id(c)
True
</code></pre>
<p>However beyond 256 this is no longer true:</p>
<pre><code>&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; id(a) == id(b)
True
&gt;&gt;&gt; a = 257
&gt;&gt;&gt; b = 257
&gt;&gt;&gt; id(a) == id(b)
False
</code></pre>
<p>however assigning <code>a</code> to <code>b</code> will indeed keep the id the same as shown before:</p>
<pre><code>&gt;&gt;&gt; a = b
&gt;&gt;&gt; id(a) == id(b)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python is neither pass-by-reference or pass-by-value. Python variables are not pointers, they are not references, they are not values. <a href="https://eev.ee/blog/2012/05/23/python-faq-passing/" rel="noreferrer">Python variables are names</a>.</p>
<p>Think of it as "pass-by-alias" if you need the same phrase type, or possibly "pass-by-object", because you can mutate the same object from any variable that indicates it, if it's mutable, but reassignment of a variable (alias) only changes that one variable.</p>
<blockquote>
<p>If it helps: C variables are boxes that you write values into. Python names are tags that you put on values.</p>
</blockquote>
<p>A Python variable's name is a key in the global (or local) namespace, which is effectively a dictionary. The underlying value is some object in memory. Assignment gives a name to that object. Assignment of one variable to another variable means both variables are names for the same object. Re-assignment of one variable changes what object is named by that variable without changing the other variable. You've moved the tag but not changed the previous object or any other tags on it.</p>
<p>In the underlying C code of the CPython implementation, every Python object is a <code>PyObject*</code>, so you can think of it as working like C if you only ever had pointers to data (no pointers-to-pointers, no directly-passed values).</p>
<blockquote>
<p>you could say that Python is pass-by-value, where the values are pointers… or you could say Python is pass-by-reference, where the references are copies.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>When you run <code>spam = 100</code> python create one more object in the memory but not change existing. so you still have pointer <code>cheese</code> to 42 and <code>spam</code> to 100</p>
</div>
<div class="post-text" itemprop="text">
<p>What is happening in <code>spam = 100</code> line is replacement of previous value (pointer to object of type <code>int</code> with value <code>42</code>) with another pointer to another object (type <code>int</code>, value <code>100</code>)</p>
</div>
<div class="post-text" itemprop="text">
<p>As @DeepSpace mentioned in the comments, Ned Batchelder does a great job demystifying variables (names) and assignments to values in a blog, from which he delivered a talk at PyCon 2015, <a href="https://www.youtube.com/watch?v=_AEJHKGk9ns" rel="nofollow noreferrer"><em>Facts and Myths about Python names and values</em></a>.  It can be insightful for Pythonistas at any level of mastery.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you store <code>spam = 42</code> , it creates an object in the memory. Then you assign <code>cheese = spam</code> , It assigns the object referenced by <code>spam</code> to <code>cheese</code>. And finally, when you change <code>spam = 100</code>, it changes only <code>spam</code> object. So <code>cheese = 42</code>.  </p>
</div>
<span class="comment-copy"><a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">You stored <code>42</code> in <code>spam</code>, Now you stored <code>spam</code> in cheese means <code>cheese =  42</code>, After that you replaced <code>spam</code> to <code>100</code>, You didn't edited <code>cheese</code> that is why <code>cheese</code> is still <code>42</code>.</span>
<span class="comment-copy">As Jonas points out in his answer, immutability is a red herring here: you would get exactly the same result if you used a mutable object like a list. The point is that you <i>reassign</i> the variable to a new reference.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/11222440/python-variable-reference-assignment">Python variable reference assignment</a></span>
<span class="comment-copy">@mini: I prefer to think of Python variables as labels rather than buckets. You stuck the label <code>spam</code> on the number 42. Next, you stuck the label <code>cheese</code> on the thing labelled as <code>spam</code> (not on top of the label itself, mind you). Then you peeled the <code>spam</code> label off of that and put it on the number 100.</span>
<span class="comment-copy">same as objects in js</span>
<span class="comment-copy">Immutability is important because it means you can safely treat the reference as-if it was a value. Treating mutable objects as-if they were values is riskier.</span>
<span class="comment-copy">The problem with calling it "pass-by-name" is that there's already a parameter passing convention called "call by name", with an entirely different meaning. In call by name, the parameter expression is evaluated every time the function uses the parameter, and never evaluated if the function doesn't use the parameter.</span>
<span class="comment-copy">Integers are value object that are on the stack right?</span>
<span class="comment-copy">Yes, they are something like object you create using <code>new Class()</code> syntax in C++. Moreover, in Python, <i>anything</i> is an instance of <code>object</code> class/subclass.</span>
<span class="comment-copy">@GertKommer in CPython at least, all objects live on the heap. There is no distinction of a "value object". There are just objects, and <i>everything is an object</i>. That is why the size of a typical int is around 28 bytes, depending on Python version, because it has the entire Py_Object overhead. Small-ints are cached as a CPython optimization.</span>
<span class="comment-copy">"Then you assign cheese = spam , it creates another object in the memory "  No, it doesn't. It assigns the object referenced by <code>spam</code> to <code>cheese</code>. No new objects are created.</span>
