<div class="post-text" itemprop="text">
<p>I am trying to start and stop a service running as a Python web app using Flask. The service involves a loop that executes continuously, listening for microphone input and taking some action if the input surpasses a predefined threshold. I can get the program to start execution when the url is passed with a /on parameter, but once it starts, I can't find a way to stop it. I have tried using request.args.get to monitor the status of the url parameter and watch for it to change from /on to /off, but for some reason, the program doesn't register that I have changed the query string to attempt to halt the execution. Is there a better way to execute my code and have it stop when the url parameter is changed from /on to /off? Any help is greatly appreciated!</p>
<pre><code>import alsaaudio, time, audioop
import RPi.GPIO as G
import pygame
from flask import Flask
from flask import request
app = Flask(__name__)

G.setmode(G.BCM)
G.setup(17,G.OUT)
pygame.mixer.init()
pygame.mixer.music.load("/home/pi/OceanLoud.mp3")

@app.route('/autoSoothe', methods=['GET','POST'])
def autoSoothe():
        toggle = request.args.get('state')
        print(toggle)
        if toggle == 'on':
# Open the device in nonblocking capture mode. The last argument could
# just as well have been zero for blocking mode. Then we could have
# left out the sleep call in the bottom of the loop
                inp =   alsaaudio.PCM(alsaaudio.PCM_CAPTURE,alsaaudio.PCM_NONBLOCK,'null',0)

# Set attributes: Mono, 8000 Hz, 16 bit little endian samples
            inp.setchannels(1)
            inp.setrate(8000)
            inp.setformat(alsaaudio.PCM_FORMAT_S16_LE)

# The period size controls the internal number of frames per period.
# The significance of this parameter is documented in the ALSA api.
# For our purposes, it is suficcient to know that reads from the device
# will return this many frames. Each frame being 2 bytes long.
# This means that the reads below will return either 320 bytes of data
# or 0 bytes of data. The latter is possible because we are in nonblocking
# mode.
            inp.setperiodsize(160)

            musicPlay = 0

            while toggle == 'on':
                    toggle = request.args.get('state')
                    print(toggle)
                    if toggle == 'off':
                            break
    # Read data from device

                    l,data = inp.read()
                    if l:
                            try:
    # Return the maximum of the absolute value of all samples in a fragment.
                                    if audioop.max(data, 2) &gt; 20000:
                                            G.output(17,True)
                                            musicPlay = 1
                                    else:
                                            G.output(17,False)

                                    if musicPlay == 1:
                                            pygame.mixer.music.play()
                                            time.sleep(10)
                                            pygame.mixer.music.stop()
                                            musicPlay = 0

                            except audioop.error, e:
                                    if e.message != "not a whole number of frames":
                                            raise e

                            time.sleep(.001)

    return toggle

if __name__ == "__main__":
     app.run(host='0.0.0.0', port=5000, debug=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When an HTTP request is made from the client to the Flask server, the client sends one request and waits for a response from the server. This means when you send the <code>state</code> parameter, there is no way for the client to retroactively change it.</p>
<p>There are a few different ways to get your desired behavior.</p>
<p>The first that comes to my mind is to use some asynchronous code. You could have code that starts a thread/process when the <code>state</code> is "on" and then finishes the request. This thread would run your audio loop. Then the client could send another request but with the <code>state</code> being "off", which could alert the other process to gracefully stop.</p>
<p><a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">Here</a> is some information about multiproccessing; however, there is a lot of information about how to do similar things with Flask using <a href="http://flask.pocoo.org/docs/0.12/patterns/celery/" rel="nofollow noreferrer">Celery</a>, etc.</p>
</div>
<span class="comment-copy">Thanks a lot EpicDavi. I will definitely take a look at this!</span>
