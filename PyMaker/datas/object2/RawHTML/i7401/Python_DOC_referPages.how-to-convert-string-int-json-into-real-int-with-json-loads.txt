<div class="post-text" itemprop="text">
<p>I'm trying to convert a string which represents a JSON object to a real JSON object using <code>json.loads</code> but it doesn't convert the integers:</p>
<p>(in the initial string, integers are always strings)</p>
<pre><code>$&gt; python
Python 2.7.9 (default, Aug 29 2016, 16:00:38)
[GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import json
&gt;&gt;&gt; c = '{"value": "42"}'
&gt;&gt;&gt; json_object = json.loads(c, parse_int=int)
&gt;&gt;&gt; json_object
{u'value': u'42'}
&gt;&gt;&gt; json_object['value']
u'42'
&gt;&gt;&gt;
</code></pre>
<p>Instead of <code>{u'value': u'42'}</code> I'd like it becomes <code>{u'value': 42}</code>. I know I can run through the whole object, but I don't want to do that, it's not really efficient to do it manually, since this <code>parse_int</code> argument exists (<a href="https://docs.python.org/2/library/json.html#json.loads" rel="nofollow noreferrer">https://docs.python.org/2/library/json.html#json.loads</a>). </p>
<p>Thanks to Pierce's proposition:</p>
<pre><code>Python 2.7.9 (default, Aug 29 2016, 16:00:38)
[GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import json
&gt;&gt;&gt;
&gt;&gt;&gt; class Decoder(json.JSONDecoder):
...     def decode(self, s):
...         result = super(Decoder, self).decode(s)
...         return self._decode(result)
...     def _decode(self, o):
...         if isinstance(o, str) or isinstance(o, unicode):
...             try:
...                 return int(o)
...             except ValueError:
...                 try:
...                     return float(o)
...                 except ValueError:
...                     return o
...         elif isinstance(o, dict):
...             return {k: self._decode(v) for k, v in o.items()}
...         elif isinstance(o, list):
...             return [self._decode(v) for v in o]
...         else:
...             return o
...
&gt;&gt;&gt;
&gt;&gt;&gt; c = '{"value": "42", "test": "lolol", "abc": "43.4",  "dcf": 12, "xdf": 12.4}'
&gt;&gt;&gt; json.loads(c, cls=Decoder)
{u'test': u'lolol', u'dcf': 12, u'abc': 43.4, u'value': 42, u'xdf': 12.4}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As we established in the comments, there is no existing functionality to do this for you. And I read through the documentation and some examples on the JSONDecoder and it also appears to not do what you want without processing the data twice.</p>
<p>The best option, then, is something like this:</p>
<pre><code>class Decoder(json.JSONDecoder):
    def decode(self, s):
        result = super().decode(s)  # result = super(Decoder, self).decode(s) for Python 2.x
        return self._decode(result)

    def _decode(self, o):
        if isinstance(o, str) or isinstance(o, unicode):
            try:
                return int(o)
            except ValueError:
                return o
        elif isinstance(o, dict):
            return {k: self._decode(v) for k, v in o.items()}
        elif isinstance(o, list):
            return [self._decode(v) for v in o]
        else:
            return o
</code></pre>
<p>This has the downside of processing the JSON object twice — once in the <code>super().decode(s)</code> call, and again to recurse through the entire structure to fix things. Also note that <em>this will convert anything which looks like an integer into an <code>int</code></em>. Be sure to account for this appropriately.</p>
<p>To use it, you do e.g.:</p>
<pre><code>&gt;&gt;&gt; c = '{"value": "42"}'
&gt;&gt;&gt; json.loads(c, cls=Decoder)
{'value': 42}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to the Pierce response, I think you can use the json.loads <code>object_hook</code> parameter instead of <code>cls</code> one, so you don't need to walk the json object twice. </p>
<p>For example:</p>
<pre><code>def _decode(o):
    # Note the "unicode" part is only for python2
    if isinstance(o, str) or isinstance(o, unicode):
        try:
            return int(o)
        except ValueError:
            return o
    elif isinstance(o, dict):
        return {k: _decode(v) for k, v in o.items()}
    elif isinstance(o, list):
        return [_decode(v) for v in o]
    else:
        return o

# Then you can do:
json.loads(c, object_hook=_decode)
</code></pre>
<p>As @ZhanwenChen pointed out in a comment, the code above is for <a href="https://docs.python.org/2/library/json.html#json.loads" rel="nofollow noreferrer">python2</a>. For <a href="https://docs.python.org/3/library/json.html#json.loads" rel="nofollow noreferrer">python3</a> you'll need to remove the <code>or isinstance(o, unicode)</code> part in the first <code>if</code> condition.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution! I used <code>object_hook</code>, it is useful when you have nested <code>json</code></p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json_data = '{"1": "one", "2": {"-3": "minus three", "4": "four"}}'
&gt;&gt;&gt; py_dict = json.loads(json_data, object_hook=lambda d: {int(k) if k.lstrip('-').isdigit() else k: v for k, v in d.items()})

&gt;&gt;&gt; py_dict
{1: 'one', 2: {-3: 'minus three', 4: 'four'}}
</code></pre>
<p>There is filter only for parsing json key to int. You can use <code>int(v) if v.lstrip('-').isdigit() else v</code> filter for json value too.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def convert_to_int(params):
    for key in params.keys():
        if isinstance(params[key], dict):
            convert_to_int(params[key])
        elif isinstance(params[key], list):
            for item in params[key]:
                if not isinstance(item, (dict, list)):
                    item = int(item)
                else:
                    convert_to_int(item)
        else:
            params[key] = int(params[key])
    return params


print convert_to_int({'a': '3', 'b': {'c': '4', 'd': {'e': 5}, 'f': [{'g': '6'}]}})
</code></pre>
</div>
<span class="comment-copy">Why is it <code>"42"</code> instead of <code>42</code> in the first place?</span>
<span class="comment-copy">Well your JSON example <code>'{"value": "42"}'</code> has 42 as a string — not an int. Your best bet is either to fix the data coming in or (if that's not feasible) write a <a href="https://docs.python.org/2/library/json.html" rel="nofollow noreferrer">custom JSON decoder</a>.</span>
<span class="comment-copy">The <code>parse_int</code> option is only used for parts of the JSON that have the syntax of an integer. The double quotes make it a string, not an integer, so it doesn't use the <code>parse_int</code> option.</span>
<span class="comment-copy">@Barmar I'm a bit lost on that functionality. From all JSON I've worked with, <code>42</code> would be an int without <code>parse_int</code> and <code>"42"</code> would be a string. Do you have a link for a use-case on <code>parse_int</code>?</span>
<span class="comment-copy">@roganjosh The documentation suggests this use case: <b>This can be used to use another datatype or parser for JSON integers (e.g. float).</b></span>
<span class="comment-copy">Thank you Pierce you code seems right but it has some errors on <code>result = super().decode(s)</code></span>
<span class="comment-copy">@Léo I wrote this in Python 3; if you're using Python 2 you'd need <code>result = super(Decoder, self).decode(s)</code>. If that's not the issue, can you tell me what error you're seeing and I can try to help you?</span>
<span class="comment-copy">I just updated the question</span>
<span class="comment-copy">@Léo ah! I didn't realize it was doing unicode. I've updated my answer to accommodate the unicode handling, and it appears to work fine for me now!</span>
<span class="comment-copy">Well. You saved my Day! Thx a lot. :)</span>
<span class="comment-copy">in <a href="https://docs.python.org/3/howto/unicode.html#python-s-unicode-support" rel="nofollow noreferrer">Python 3, the <code>str</code> class subsumed the <code>unicode</code> class</a>, so your code would raise because <code>unicode</code> is an undefined variable. Please edit your answer.</span>
<span class="comment-copy">@ZhanwenChen Edited, thanks :)</span>
<span class="comment-copy">The issue with this is that the OP wanted to parse the value <code>"42"</code> into an <code>int</code> in Python, which your code does not account for.</span>
<span class="comment-copy">convert = lambda x: {x.keys()[0]: int(x.values()[0])} convert(json.loads('{"value": "42"}'))</span>
<span class="comment-copy">Your lambda suggestion only works for dictionaries with exactly one value. It does not solve for multi-value dictionaries or arrays, and it also does not address the Unicode problem present in Python 2. Further, it isn't advisable to set the result of a <code>lambda</code> expression to a variable; just define a function and it becomes significantly easier to maintain. See my (accepted) answer for a more robust solution.</span>
<span class="comment-copy">how about this one?</span>
<span class="comment-copy">Better, but <code>for key in params.keys()</code> assumes that <code>params</code> is a <code>dict</code>, which it may not be since you call the function recursively. Additionally, you iterate through the keys of the dictionary and then continuously do <code>params[key]</code>. Why not <code>for key, value in params.items()</code> (or <code>params.iteritems()</code> in Python 2.x)? Additionally, much of this can be done with comprehensions — like what I did in my solution. I think list/dict comprehensions lead to easier-to-read code in cases like this.</span>
