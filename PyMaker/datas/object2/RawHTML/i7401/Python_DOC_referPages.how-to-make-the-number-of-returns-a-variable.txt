<div class="post-text" itemprop="text">
<p>Lets consider a normal function:</p>
<pre><code>def function(stuff):
    return result
</code></pre>
<p>To call it and get the result in a variable:</p>
<pre><code>variable = function(stuff)
</code></pre>
<p>I can do the same with 3 (for example) results:</p>
<pre><code>def function(stuff):
    return result1, result2, result3
</code></pre>
<p>To call it and get the results in 3 variables:</p>
<pre><code>variable1, variable2, variable3 = function(stuff)
</code></pre>
<p>My question is: How can I write a function that automatically reads and changes when I set a variable called "number of results". Or, in my real case, the "number of results" will depend on the length of my variable stuff (the variable stuff is a list of arrays).</p>
<p>I hope this question was not answered before.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a <code>list</code> with the number of elements you want, then <code>return tuple(yourList)</code>.</p>
<p>However, you could then just return the <code>list</code> directly. Python idiomatically doesn't care much about the return types of stuff, so any caller that is looking for an iterable like <code>tuple</code> can iterate over the <code>list</code> just as well.</p>
<p>A <code>list</code> can be unpacked, as well:</p>
<pre><code>&gt;&gt;&gt; foo(3)
[1, 2, 3]
&gt;&gt;&gt; a, b, c = foo(3)
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
2
&gt;&gt;&gt; c
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just construct and return a <em>container</em> of results (such as a <code>tuple</code> or <code>list</code>): </p>
<p>For example:</p>
<pre><code>import random

def function(stuff):
    number_of_results = random.randrange(1, 4)
    results = tuple(random.randint(0, 100) for _ in range(number_of_results))
    return results

for _ in range(5):
    print(function(None))
</code></pre>
<p>Sample output:</p>
<pre class="lang-none prettyprint-override"><code>(0, 28)
(66,)
(62, 63, 88)
(99, 89, 67)
(87, 91)
</code></pre>
<p>If you want to assign the values <code>return</code>ed to separate variables, you can, but knowing how many the function will return will be necessary. For example, if you somehow knew <strong>in advance</strong> it was going to return three things, you could write: <code>variable1, variable2, variable3 = function(stuff)</code>. For that reason it would probably be better to just expect it to return a container and process its contents following the call to the function.</p>
</div>
<span class="comment-copy">Any time you need to deal with a varying quantity of data, the answer is to use a variable-size container such as a list.</span>
<span class="comment-copy">@LSerni that <i>is</i> returning a tuple.</span>
<span class="comment-copy">@LSerni to elaborate on the above, a tuple can be <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow noreferrer">specified</a> by just <code>val1, val2</code> without parentheses.</span>
<span class="comment-copy">You are only returning one result in both cases, one type <code>T</code> then other type <code>Tuple[T]</code>. You are using unpacking to extract the values of the tuple nto individual variables but you could have equally done <code>var = fn()</code> and then <code>var == (r1, r2, r3)</code>. Given, all <code>Iterable</code> types are variable length you could use anyone of them. But special handling will need to happen with <code>1</code> because an <code>Iterable[T]</code> is different that <code>T</code> itself.</span>
<span class="comment-copy">@AChampion: that is a great point. The syntax is a bit weird, but as an alternative to handling it specially in the function, you can unpack a single value using <code>(a,) = fn(1)</code></span>
<span class="comment-copy">Fantastic. Thank you for your reply.  I do know how many results I need. But how can I write "variable1, variable2, variable3, ..., variableK = function(stuff)" in an way that would depend on the value of "number of results = K" ?</span>
<span class="comment-copy">I believe I found a solution for this</span>
<span class="comment-copy">Then only way I can think of would be to have a series of <code>if</code>, <code>elif</code> statements for every number of results expected, and then within each one write the appropriate <code>v1 = function(stuff)</code> or <code>v1, v2 = function(stuff)</code>, <code>v1, v2, v3 = function(stuff)</code>, etc. Obviously that is going to be very tedious and ugly looking. That's why I <b>strongly</b> suggest that you instead just expect the function to always return a <code>list</code> or <code>tuple</code> of values and do any follow-on processing based on the length of that (or the expected length since that is already known).</span>
<span class="comment-copy">a = function()  for i in range(len(a)):     globals()["variable%s" % i] = a[i]  Is this the best way to do it?  Thank you again for your help</span>
<span class="comment-copy">Yes, that looks like it would work, although using globals is generally a bad idea (see <a href="http://wiki.c2.com/?GlobalVariablesAreBad" rel="nofollow noreferrer">this article</a> for why).</span>
