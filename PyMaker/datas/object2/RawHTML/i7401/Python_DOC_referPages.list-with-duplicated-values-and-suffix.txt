<div class="post-text" itemprop="text">
<p>I have a list, <code>a</code>:</p>
<pre><code>a = ['a','b','c']
</code></pre>
<p>and need to duplicate some values with the suffix <code>_ind</code> added this way (order is important):</p>
<pre><code>['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
<p>I tried:</p>
<pre><code>b = [[x, x + '_ind'] for x in a]
c = [item for sublist in b for item in sublist]
print (c)
['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
<p>I think my solution is a bit over-complicated. Is there some better, more pythonic solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could make it a generator:</p>
<pre><code>def mygen(lst):
    for item in lst:
        yield item
        yield item + '_ind'

&gt;&gt;&gt; a = ['a','b','c']
&gt;&gt;&gt; list(mygen(a))
['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
<p>You could also do it with <code>itertools.product</code>, <code>itertools.starmap</code> or <code>itertools.chain</code> or nested comprehensions but in most cases I would prefer a simple to understand, custom generator-function.</p>
<hr/>
<p>With python3.3, you can also use <code>yield from</code>—generator delegation—to make this elegant solution just a bit more concise:</p>
<pre><code>def mygen(lst):
    for item in lst:
        yield from (item, item + '_ind')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It can be shortened a little bit by moving the options to the inner for loop in the list comprehension:</p>
<pre><code>a = ['a','b','c']

[item for x in a for item in (x, x + '_ind')]
# ['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another alternative with splicing (Python2.x, 3.x):</p>
<pre><code>In [642]: result = [None] * len(a) * 2

In [643]: result[::2], result[1::2] = a, map(lambda x: x + '_ind', a)

In [644]: result
Out[644]: ['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.chain()</code>:</p>
<pre><code>import itertools

l = ['a','b','c']

new_list = list(itertools.chain.from_iterable([[i, i+"_ind"] for i in l]))

print new_list
</code></pre>
<p>Output:</p>
<pre><code>['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Before list comprehensions and generators were invented/became widespread, people used to think much simpler<sup>1</sup>:</p>
<pre><code>&gt;&gt;&gt; a = ['a', 'b', 'c']
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for x in a: b.extend([x, x+'_ind'])
... 
&gt;&gt;&gt; b
['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']
</code></pre>
<hr/>
<p><sup>*</sup> I don't mean that those constructs/tools are evil, just wanted to point out that there is a simple solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you asked for "simple", I thought I'd throw this in (albeit, maybe not the <code>pythonic</code> way):   </p>
<pre><code>for i in mylist: 
    mylist1.append(i);
    mylist1.append(i + '_ind');
</code></pre>
</div>
<span class="comment-copy">For the record, there's nothing wrong with this solution.</span>
<span class="comment-copy">Might I suggest a list comprehension version? <code>list([((yield x), (yield (x + '_ind'))) for x in a]) ; ['a', 'a_ind', 'b', 'b_ind', 'c', 'c_ind']</code></span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Wtf... never seen such "inline" yield. Played with it some more, this works as well: <code>list([(yield from (x, x + '_ind')) for x in a])</code>.</span>
<span class="comment-copy">@StefanPochmann Killer. Want to post an answer with it? If not, I'll edit mine. :p</span>
<span class="comment-copy">@StefanPochmann It's py3k only. They added yield support for list comps to allow generators to be created.</span>
<span class="comment-copy">@idjaw Oh wait, just saw the red underlines on my IDE too. xD</span>
<span class="comment-copy"><i>"Python 3.x only"</i> - Actually it's only Python 3.3 and greater. See <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">@ChristianDean Thanks. Added the link.</span>
<span class="comment-copy">@Bergi Yes, because a list comp with yield returns a generator.</span>
<span class="comment-copy">This option is most useful if you want to obfuscate your Python code.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ No, for code golf Psidom's answer wins. :)</span>
<span class="comment-copy">I would use <a href="https://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="nofollow noreferrer"><code>chain.from_iterable</code></a>. That way you don't need the unpacking with <code>*</code></span>
<span class="comment-copy">Alt: <code>list(itertools.chain(*zip(a, [x + '_ind' for x in a])) )</code> or <code>list(itertools.chain(*zip(a, map(lambda x: x + '_ind', a))))</code></span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ Agreed, but again, <code>chain.from_iterable</code> would IMHO be a bit cleaner :) <code>list(chain.from_iterable(zip(a, [i+'_ind' for i in a])))</code>. Not that it is particularly important.</span>
<span class="comment-copy">As far as I know were comprehensions and generators invented (implemented) to make these "constructs and tools" simpler (and definitely a lot faster). But I guess that's a quite opinion-based statement so YMMV.</span>
