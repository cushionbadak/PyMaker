<div class="post-text" itemprop="text">
<p>I'm trying to implement the frequent words pseudocode. According to a sample dataset I should be returning 2 frequent words but I'm only returning the first. 
Here is the pseudocode:</p>
<pre><code>FrequentWords(Text, k)
    FrequentPatterns &lt;-- an emty set
    for i &lt;-- 0 to |Text| - k
        Pattern &lt;-- the k-mer Text(i,k)
        Count(i) &lt;-- PatternCount(Text,Pattern)
    maxCount &lt;-- max value in array Count
    for i &lt;-- 0 to |Text| - k
        if Count(i) = maxCount
        add Text(i,k) to FrequentPatterns
    remove duplicates from FrequentPatterns
    return FrequentPatterns
</code></pre>
<p>And here is my implementation:</p>
<pre><code>def PatternCount(Text, Pattern):
    Count = 0
    for i in range(0, (len(Text) - len(Pattern) + 1)):
        if Text[i:i+len(Pattern)] == Pattern:
           Count = Count + 1
    return Count

def FrequentWords(Text, k):
    FrequentPatterns = [0]
    Count = [0] * (len(Text) - k + 1)
    for i in range(0, (len(Text) - k + 1)):
        Pattern = Text[i:i+k]
        Count[i] = PatternCount(Text, Pattern)
    maxCount = max(Count)    
    for i in range(0, (len(Text) - k + 1)):        
        if Count[i] == maxCount:
            FrequentPatterns = Text[i:i + k] 
            return FrequentPatterns
</code></pre>
<p>Here is the sample dataset:
ACGTTGCATGTCGCATGATGCATGAGAGCT
4</p>
<p>I should get returned from code:
CATG GCAT</p>
<p>But I'm only getting the first - CATG. Please help.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>s = 'ACGTTGCATGTCGCATGATGCATGAGAGCT'
length = 4
</code></pre>
<p>I would use a dictionary to accumulate the results. Use a slice to extract the <em>next</em> word; add one to that word's value in the dictionary; then drop the first character in the string; loop while the string has a word in it.</p>
<pre><code>result = {}
while len(s) &gt;= length:
    word = s[:length]
    result[word] = result.get(word, 0) + 1
    s = s[1:]
</code></pre>
<p>You might be able to make use of <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer">collections.Counter or collections.defaultdict</a> for that bit.  If the words cannot overlap, drop <code>length</code> characters from the front of the string. Keeping the process simple does result in a bit of inefficiency when the character(s) are removed from the string at the bottom of the loop.  Unless the data is very long or the process is performed a LOT of times it shouldn't matter.</p>
<p>Then just find the word(s) with the highest <em>frequency</em></p>
<pre><code>most = max(result.values())
frequent = []
for key, value in results:
    if value == most:
        frequent.append(key)

#frequent = [key for key, value in result.items() if value == most]
</code></pre>
<hr/>
<p>Borrowing from an <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe</a> you can make an iterator that produces <em>words</em> of the required length</p>
<pre><code>def n_wise(iterable, n=2):
    '''s -&gt; (s0,s1), (s1,s2), (s2, s3), ... for n=2'''
    tees = itertools.tee(iterable, n)
    for i, thing in enumerate(tees, 1):
        for _ in range(i):
            next(thing, None)
    return zip(*tees)
</code></pre>
<p>The counting portion of the procedure would change to </p>
<pre><code>words = n_wise(s, length)
result = {}
for word in words:
    result[word] = result.get(word, 0) + 1
</code></pre>
<p>The keys in <code>result</code> will be tuples, e.g. <code>('C', 'A', 'T', 'G')</code> but they can be reconstructed with <code>''.join(('C', 'A', 'T', 'G'))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>you should consider using list comprehensions. </p>
<pre><code>def pattern_count(text, pattern):
     matches = ([x for x in range(len(text) - len(pattern) + 1) if pattern in text[x:len(pattern) + x]])
     return len(matches)


def frequent_words(text, k):
    counts = [pattern_count(text, text[x:x + k]) for x in range(len(text) - k)]
    return set([text[x:x + k] for x in range(len(text) - k) if counts[x] == max(counts)])
</code></pre>
<p><strong>pattern_count</strong> will parse a string for a pattern. We splice the text character array, so we can check if that portion contains the pattern. This allows us to include overlapping entries in our results. For instance,</p>
<p><em>pattern_count(ABABA, ABA)</em> -&gt; results in 2, instead of 1.</p>
<pre><code>print(pattern_count("BABBASDCABCBABDDASDBBCASDBAB", "BAB"))
[0] 3
</code></pre>
<p><strong>frequent_words</strong> takes the same text but instead of a pattern, we give it an int for how long the pattern should be. Once we get a list of the number of occurrences for each pattern that meets our character <strong>k</strong> requirement, we filter it by taking the entries which occur the most frequently.  Finally, to remove any duplicates, we convert the list into a hashset which inherently prevents duplicate entries, thus returning a collection with only unique values.</p>
<p>Test:</p>
<pre><code>print(frequent_words("BABBASDCABCBABDDASDBBCASDBAB", 3))
[0] {'BAB', 'ASD'}
</code></pre>
<p>Hope that was of some use to you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>dict</code> instead:</p>
<pre><code>def FrequentWords(Text, k):
    FrequentPatterns = {}
    for i in range(0, (len(Text) - k + 1)):
        Pattern = Text[i:i+k]
        if Pattern in FrequentPatterns:
            FrequentPatterns[Pattern] += 1
        else:
            FrequentPatterns.update({Pattern: 1})
    for x in sorted(FrequentPatterns.items(), key=lambda m: m[1], reverse=True):
        print(x)
</code></pre>
</div>
<span class="comment-copy">What is a "frequent word"? Something of size 4 which can occur at an arbitrary index? How many times must the frequent word occur to be frequent?</span>
<span class="comment-copy">Accumulate the words in a container and don't return till all of the dataset has been <i>searched</i>.</span>
<span class="comment-copy">Can the patterns/words overlap?</span>
<span class="comment-copy">The frequent words are size 4 and I want the one(s) that happen the most. They can also overlap.</span>
<span class="comment-copy">So it looks like I'm returning my results too early as wwii says and should use a container to store the words to be returned.</span>
<span class="comment-copy">Thanks for your suggestions, I'll try implementing this. I did use collections.defaultdict to do the frequent words earlier, but I still wanted to do it by just using the pseudocode with no imports.</span>
<span class="comment-copy">This works nice on my sample dataset, but I need to return the max frequency because the next dataset could have thousands of words.</span>
