<div class="post-text" itemprop="text">
<p>ı have studying multithreading in python for a while, however I was confused on a few issues
Firstly ,created threads by python threading modules ,is  a user level thread.</p>
<blockquote>
<p>Books says the user threads must be mapped to kernel threads and
  Operating system runs threads via kernel threads.</p>
</blockquote>
<p>in python threading module  Which thread model is used? besides Who decides  this choice ? is it operating  system ?</p>
<p>İf many-to-one model used,ı think ,it is never real multithread,it always belongs only one kernel thread</p>
<p><a href="https://i.stack.imgur.com/QAfYU.jpg" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/QAfYU.jpg"/></a></p>
<p>is there anyway directing  operating system to must use this model for my program in python ?</p>
<p>Another point,How to shows all threads on running state separately kernel or user level  and mapping between the two levels ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Usually, you never create 'kernel level threads' directly - everything you do in user space executes in user space, otherwise even a random browser JavaScript would be executing at the kernel level guaranteeing that within seconds the whole internet would go dark.</p>
<p>Thus, in most languages, a threading interface (if supported) is far removed from the actual 'kernel threads' and depending on implementation it will either link to a lower-level threading interface (<a href="https://en.wikipedia.org/wiki/POSIX_Threads" rel="nofollow noreferrer"><code>pthreads</code></a> for example) or just simulate threading unbeknownst to the user. Going down that chain, <code>pthreads</code> may or may not link to actual 'kernel' threads (it happens to be true on Linux, but on Windows there is another level of separation) but even then, the code executes in the user space - the 'supporting' kernel thread is there to control the scheduling the code runs separately.</p>
<p>When it comes to CPython, its <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer"><code>threading</code></a> interface links to <code>pthreads</code> so, technically, there is a chain from a Python thread all the way down to the kernel threads. However, Python also has <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow noreferrer">the dreaded GIL</a> pretty much guaranteeing that, with some rare exceptions mostly related to I/O, no two threads ever execute at the same time, pretty much making its threads operate in a cooperative multitasking mode. However, since on most systems processes are also backed by kernel threads, you can still utilize them in all their glory by using the <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> interface.</p>
<p>Also, until you have multiple cores/CPUs on your system even kernel threads execute in a cooperative multitasking mode so, technically, kernel threads don't guarantee actual multi-threading as you're describing it.</p>
<p>As for how to list threads and their dependencies, you can use <code>top -H -p &lt;pid&gt;</code> to show the thread tree of a process.</p>
</div>
<span class="comment-copy">thanks man, one question about  GIL. GIL said " prevents multiple native threads from executing Python bytecodes at once".Native threads probably is kernel threads.This means ,there is no multithreading in CPython interpreter of python.Presumably  it  is only non-blocking system on  I/O  not multithreading. am I wrong ?</span>
<span class="comment-copy">@FatihAltuntaş - there is <i>some</i> actual parallel execution as not all thread operations are mutex-ed by the GIL, but that's all Python background stuff and the user doesn't get a say in that so, from a users' perspective, there is no parallel processing with Python <code>threading</code> interface. For parallel processing, you have to use the <code>multiprocessing</code> interface, but then you lose all the niceties like shared memory and such (since a big part why GIL exists in the first place is the problem of thread-safety when it comes to memory access).</span>
