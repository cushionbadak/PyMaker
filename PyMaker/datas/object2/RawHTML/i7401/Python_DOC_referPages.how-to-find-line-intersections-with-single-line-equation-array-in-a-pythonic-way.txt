<div class="post-text" itemprop="text">
<p>What would the most pythonic way be, without using for loops, of finding line intersection points in an array comprised of m,c values?</p>
<pre><code>lines=np.array([m0,c0],
               [m1,c1],
               [m2,c2],
               ....)
</code></pre>
<p>achieving the desired result with for loops would consist of something like:</p>
<pre><code>for i in lines:
 for n in lines:
   np.linalg.solve(i, n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The equation for the intersection of two lines <code>y1 = a1*x + b1</code> and <code>y2 = a2*x + b2</code> is <code>x = (b2 - b1) / (a1 - a2)</code>.</p>
<p>By making use of <a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="nofollow noreferrer">broadcasting</a> it is easy to compute all intersections between any number of lines:</p>
<pre><code>import numpy as np    

# lines of the form y = a * x + b
# with lines = [[a0, b0], ..., [aN, bN]]
lines = np.array([[1, 0], [0.5, 0], [-1, 3], [1, 2]])

slopes = lines[:, 0]  # array with slopes (shape [N])
slopes = slopes[:, np.newaxis]  # column vector (shape [N, 1])

offsets = lines[:, 1]  # array with offsets (shape [N])
offsets = offsets[:, np.newaxis]  # column vector (shape [N, 1])

# x-coordinates of intersections
xi = (offsets - offsets.T) / (slopes.T - slopes) 

# y-coordinates of intersections
yi = xi * slopes + offsets
</code></pre>
<p>This works by appling the element-wise <code>-</code> operator to a column vector of shape [N, 1] and it's transpose of shape [1, N]. The vectors are broadcast to a matrix of shape [N, N].</p>
<p>The final result are two symmetric matrices <code>xi</code> and <code>yi</code>. Each entry <code>xi[m, n]</code> is the intersection of lines <code>m</code> and <code>n</code>. 
<code>nan</code> means the lines are identical (they intersect in every point). <code>inf</code> means the lines do not intersect.</p>
<p>Let's show off the result:</p>
<pre><code>#visualize the result
import matplotlib.pyplot as plt
for l in lines:
    x = np.array([-5, 5])
    plt.plot(x, x * l[0] + l[1], label='{}x + {}'.format(l[0], l[1]))
for x, y in zip(xi, yi)    :
    plt.plot(x, y, 'ko')
plt.legend()
plt.show()
</code></pre>
<p><a href="https://i.stack.imgur.com/NXYEW.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/NXYEW.png"/></a></p>
</div>
<span class="comment-copy"><code>m</code> is the slope?</span>
<span class="comment-copy">Doesnt seem like the first argument to solve will be a square matrix in this setup; so how is that supposed to work?</span>
<span class="comment-copy">instead of the nested for-loop, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to generate the combinations</span>
<span class="comment-copy">@WillemVanOnsem, yes the m is the slope, and select any two lines in the matrix and the matrix will become square, and thanks will look into [link]<a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.combinations</a></span>
<span class="comment-copy">Might be important to highlight that when you do <code>slopes = lines[:, [0]]</code> (as opposed to <code>lines[:, 0]</code>) you're creating a 2D slice instead of the more common 1D slice.  This lets you broadcast using <code>.T</code> instead of the more verbose (but also more common) <code>[None, :]</code>.  Not everyone can parse fancy indexing in their head like that :)</span>
<span class="comment-copy">@DanielF good point :) Are you sure something like <code>lines[:, 0][:, np.newaxis]</code> or <code>lines[:, np.newaxis, 0]</code> is more readable?</span>
<span class="comment-copy">It certainly isn't more readable in 2D, but it is more explicit, and therefore more readable when you get beyond 2 dimensions (in my opinion).  For 2D your method is much more readable, but the fancy indexing used to set it up may be confusing for beginners.</span>
<span class="comment-copy">Not to confuse - normally I wouldn't construct the <code>lines</code> or <code>offsets</code> arrays to be 2D, but would do <code>xi = (offsets - offsets[none, :]) / (slopes[none, :] - slopes)</code> - making <code>xi</code> 2d explicitly during the broadcast step.  This is less readable than your method, but becomes more readable (imo) as dimensionality gets larger.</span>
<span class="comment-copy">I agree. I would even write <code>(offsets[:, None] - offsets[None, :])</code> to make it super explicit.</span>
