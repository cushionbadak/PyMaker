<div class="post-text" itemprop="text">
<p><strong>Code:</strong></p>
<pre><code>import random

x = ['A','B','C','D','E','F',
     'G','H','I','J','K','L',
     'M','N','O','P','Q','R',
     'S','T','U','V','W','X',
     'Y','Z']

y1 = random.sample(x, 2)
y2 = random.sample(x, 2)
y3 = random.sample(x, 2)
y4 = random.sample(x, 2)
y5 = random.sample(x, 2)
</code></pre>
<p><strong>Query</strong></p>
<p>As shown above, I'm selecting 5 random sample combinations and declaring them under the variables <code>y'x'</code>.</p>
<p>To improve my code, I would like to do so, but ensure that an item from the list doesn't appear more than once in all variable outputs, in which all combinations are different and non-repetitive. I would preferably like to achieve this without having to remove items from the list as it is reused later in the code.</p>
<p><strong><em>Expected Output (Example):</em></strong></p>
<pre><code>&gt;&gt;&gt; y1
['A', 'Q']
&gt;&gt;&gt; y2
['E', 'K']
&gt;&gt;&gt; y3
['C', 'O']
&gt;&gt;&gt; y4
['Z', 'X']
&gt;&gt;&gt; y5
['P', 'L']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could shuffle a copy of the list (you said you wanted to reuse it so one needs to make a copy because shuffle works in-place) and then just take 2 elements for each sample:</p>
<pre><code>import random

x_copy = x[:]  # copy
random.shuffle(x_copy)
y1 = x[:2]
y2 = x[2:4]
y3 = x[4:6]
y4 = x[6:8]
y5 = x[8:10]
</code></pre>
<p>or if you don't want to hardcode the <code>yi</code>s:</p>
<pre><code>x_copy = x[:]  # copy
random.shuffle(x_copy)
y = [x_copy[i*2: (i+1)*2] for i in range(5)]
print(y)
# [['W', 'Z'], ['A', 'Q'], ['B', 'J'], ['O', 'D'], ['X', 'E']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" rel="nofollow noreferrer"><code>numpy.random.choice</code></a>. Its purpose is to choose with (<code>replace=True</code>) or without (<code>replace=False</code>) replacement from an array-like object (which also works for your list):</p>
<pre><code>import numpy as np
x = ['A','B','C','D','E','F',
     'G','H','I','J','K','L',
     'M','N','O','P','Q','R',
     'S','T','U','V','W','X',
     'Y','Z']
np.random.choice(x, size=(5, 2), replace=False)
</code></pre>
<p>Result:</p>
<pre><code>array([['Y', 'Q'],
       ['W', 'R'],
       ['O', 'H'],
       ['Z', 'G'],
       ['L', 'M']], 
      dtype='&lt;U1')
</code></pre>
<p>This returns an array of 5 rows, which each include one of your samples of size 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could simply build a 'cache' of generated values - so the elements of <code>x</code> are not removed:</p>
<pre><code>import random

class SampleCache():
    x = ['A','B','C','D','E','F',
         'G','H','I','J','K','L',
         'M','N','O','P','Q','R',
         'S','T','U','V','W','X',
         'Y','Z']

    def __init__(self):
        self.cache = []

    def get(self):
        _iterations = 0
        while 1:
            sample = random.sample(self.x, 2)
            if not sample in self.cache:
                self.cache.append(sample)
                return sample

            if _iterations &gt; 1000: # just to prevent NOT to run into an infinite loop
                break


s = SampleCache()
for x in range(25):
    print(s.get())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample</code></a> is the correct method, you just need to call it once for 10 letters instead of 5 times with 2 letters:</p>
<pre><code>import random
import string


def random_letters(m=5, n=2):
    letters = random.sample(string.ascii_uppercase, m * n)
    return [letters[n * i:n * (i + 1)] for i in range(m)]

print(random_letters())
# [['I', 'X'], ['J', 'U'], ['O', 'W'], ['G', 'C'], ['D', 'F']]
print(random_letters())
# [['J', 'X'], ['N', 'P'], ['A', 'C'], ['O', 'Z'], ['B', 'H']]
print(random_letters())
# [['U', 'T'], ['J', 'N'], ['C', 'H'], ['D', 'I'], ['K', 'P']]
print(random_letters())
# [['U', 'G'], ['L', 'V'], ['A', 'R'], ['J', 'F'], ['S', 'C']]
print(random_letters())
# [['Y', 'C'], ['R', 'B'], ['E', 'I'], ['S', 'T'], ['H', 'X']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>random.sample</code> to generate a shuffled copy of the initial list, and a generator to yield the shuffled values as required.</p>
<pre><code>def random_sample(x, n):
    shuffled = random.sample(x, k=len(x))
    for val in range(0, len(x), n):
        yield shuffled[val: val+n]

print([sample for sample in random_sample(x, 2)])
</code></pre>
<hr/>
<p>Outputs;</p>
<pre><code>[['I', 'O'], ['V', 'T'], ['U', 'J'], ['L', 'A'], 
 ['E', 'G'], ['Q', 'F'], ['M', 'H'], ['B', 'K'], 
 ['R', 'P'], ['W', 'N'], ['D', 'S'], ['Z', 'Y'], 
 ['X', 'C']]
</code></pre>
<hr/>
<p>If you want exactly five random values then use this;</p>
<pre><code>samples = random_sample(x,  2)
five_samples = [next(samples) for _ in range(5)]
print(five_samples)
</code></pre>
<p>If want them one at a time then use,</p>
<pre><code>samples = random_sample(x,  2)
print(next(samples))
...
print(next(samples))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can loop over the sample generated and remove the elements from <code>x</code>:</p>
<pre><code>x = ['A','B','C','D','E','F',
 'G','H','I','J','K','L',
 'M','N','O','P','Q','R',
 'S','T','U','V','W','X',
 'Y','Z']

new_x = x[:]

import random
final_list = []
for i in range(5):
   the_sample = random.sample(new_x, 2)
   final_list.append(the_sample)
   for b in the_sample:
       new_x.remove(b)
</code></pre>
<p>Output:</p>
<pre><code>[['C', 'R'], ['L', 'V'], ['W', 'Y'], ['D', 'O'], ['J', 'Q']]
</code></pre>
</div>
<span class="comment-copy">That's perfect! Thank You. I don't particularly this part: <code>[i*2: (i+1)*2]</code>. Mind clarifying? ;)</span>
<span class="comment-copy">Do you mean the list-comprehension or the <code>x_copy[i*2: (i+1)*2]</code> part?</span>
<span class="comment-copy">Yeah, a lil' bit ;/ - The 'part' you referred to ;)</span>
<span class="comment-copy">A list comprehension is just an alternative to a <code>for</code>-loop. And the loop variable <code>i</code> takes the values 0-5 (5 is exclusive). In the first iteration <code>i=0</code> and therefore it appends <code>x_copy[0: 2]</code> because <code>2*i = 0</code> and <code>(i+1)*2 = 2</code>. In the second iteration <code>i=1</code> and the slice is <code>x_copy[2: 4]</code> and so on. It's just an automated version of the first variant where I hardcoded the slices. :)</span>
<span class="comment-copy">Thanks! Although, 'I would preferably like to achieve this without having to remove items from the list as it is reused later in the code.'</span>
<span class="comment-copy">Why the downvote?</span>
