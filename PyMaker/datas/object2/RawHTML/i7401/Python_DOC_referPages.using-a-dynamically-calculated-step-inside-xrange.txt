<div class="post-text" itemprop="text">
<p>Suppose I have:</p>
<pre><code>def func(n):
    for i in range(1,100000,2*n+3):
        ...
</code></pre>
<p>It is obvious that the <code>step = 2*n+3</code> part is calculated once.</p>
<p>But is this guaranteed to be the same for <code>xrange</code>?</p>
<p>According to <a href="https://stackoverflow.com/a/94962/7400903">this answer</a>, <code>xrange</code> is a sequence object that evaluates lazily.</p>
<p>So the question is basically - which part evaluates lazily?</p>
<p>Is it only the <code>start &lt;= stop</code> part, or also the <code>step</code> part?</p>
<p>I tried a simple test in order to determine the answer:</p>
<pre><code>n = 1
for a in xrange(0,100,n):
    print a
    n += 1
</code></pre>
<p>This test clearly shows that <code>n</code> is not reevaluated at every iteration.</p>
<p>But I'm suspecting that perhaps the <code>n</code> inside the <code>xrange</code> expression "lives in a different scope" than that of the <code>n</code> declared before the <code>xrange</code>.</p>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Neither <code>range()</code> nor <code>xrange()</code> care how the step value was derived; the expression is executed and the <em>result of the expression</em> is passed to the call, be that <code>range()</code>, <code>xrange()</code> or any other callable object.</p>
<p>That's because <code>(...)</code> is an expression too; it is a <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="nofollow noreferrer">call expression</a>; the arguments passed into a call are all expressions that are evaluated <em>before</em> the result is passed in to the  call. It doesn't matter what is being called here.</p>
<p>TLDR; the <code>xrange()</code> object is passed the outcome of the expression, not the expression itself. As long as that outcome is an integer object, it'll be stored by the object (as an immutable value) to base the virtual sequence of.</p>
</div>
<div class="post-text" itemprop="text">
<p>The fact that <code>xrange</code> works lazily means that the <strong><em>arguments are evaluated</em> at "construction" time</strong> of the <code>xrange</code> (in fact <code>xrange</code> never knew what the expressions were in the first place), but the <strong>elements that are emitted are generated lazily</strong>. So the <code>step</code> parameter is actually <strong>calculated before you even call <code>xrange(..)</code></strong>. As a result, <code>xrange(..)</code> does not know how the step was calcuated, and thus cannot ask to re-evaluate it.</p>
<p>Although <code>xrange(..)</code> is more complex than that (since it can work with negative steps, etc.), a very basic implementation would be:</p>
<pre><code>def xrange(frm,to,step):
    i = frm
    while i &lt; to:
        yield i
        i += step
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To add on top of the other answers: A good way to test this would be to provide a function as the step argument. If it is to be evaluated multiple times then the  function would need to be called multiple times.</p>
<pre><code>def foo():
    print 'foo was called'
    return 25

for i in xrange(0, 100, foo()):
    print i
</code></pre>
<p>The above code outputs</p>
<pre><code>foo was called
0
25
50
75
</code></pre>
<p>which shows that the step argument is evaluated exactly once.</p>
</div>
<div class="post-text" itemprop="text">
<p>when you pass the appropriate arguments into <code>xrange()</code>, Python will construct a generator object that will compute values "on the fly".</p>
<p>Once that generator object is constructed and returned, the object is set. <em><strong>It no longer cares whether a variable originally used in calculating its constructor arguments changes or not</strong></em>. </p>
<p>This same principal applies not only to <code>xrange()</code>, but to other callable objects as well. Once you pass arguments to a callable, Python calculates the expressions using the current value of any variables, and passes the result to the callable. If any variables that were used in calculating the arguments of the callable have their value changed, Python does not care because only the <em>current</em> value of the variable was used. <em><strong>Python will not keep recalculating the arguments of a function every time a variable used in an expression passed into it changes</strong></em>:</p>
<pre><code>&gt;&gt;&gt; n = 10
&gt;&gt;&gt; xr = xrange(n)
&gt;&gt;&gt; n += 1
&gt;&gt;&gt; n
11
&gt;&gt;&gt; list(xr)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lazy evaluation does not mean you can change the evaluation while it is going on; while iterating <code>xrange</code> you are dealing with a generator, that is created with the parameters you provide. It can not change its <code>step</code> during iteration, at least not with the built in one.</p>
</div>
<span class="comment-copy">Is the <code>step</code> part inside the <code>xrange</code> guaranteed to be calculated once, or can it possibly be calculated at every iteration in some cases?</span>
<span class="comment-copy">@goodvibration: it is calculated <i>before the object is created</i>. So just once, not for every step.</span>
<span class="comment-copy">I think I'm beginning to understand where my confusion derives from. I need to look at <code>range</code> as a function that returns an array, and at <code>xrange</code> as a function that returns an iterator. That pretty much solves everything. Thank you!!!</span>
<span class="comment-copy">@goodvibration: exactly. They both are callable objects (functions are the most common callable object, but classes are callable too, and so is the <code>xrange()</code> <i>type</i>). A call expression produces another result; the returned value of the function, or the new instance of a type.</span>
<span class="comment-copy">@goodvibration: if you ever needed to create a range-like object where the step was to be dynamic, you can't just pass in an expression like that; you'd have to pass in a function or other callable that produces the step size each time you need it. The object would then call it each time.</span>
<span class="comment-copy">Your depiction of <code>xrange</code> as a function made it perfectly clear to me, thank you!</span>
<span class="comment-copy">Yes, it occurred to me shortly after I had posted the question. The answers here have been very helpful though. Thanks.</span>
<span class="comment-copy">Very clear, thank you!</span>
