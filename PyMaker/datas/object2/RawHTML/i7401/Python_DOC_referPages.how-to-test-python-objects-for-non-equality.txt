<div class="post-text" itemprop="text">
<p>Lately, I have been writing lots of unit tests for the classes I have developed. This is the first time I have adopted the approach of rigorously testing my library code before releasing and I have to agree that I have 
learned a lot during the process.</p>
<p>The current challenge I face is with testing two instances for equality and non-equality.</p>
<p>Here is a simple class abstracting the library code:</p>
<pre><code>class User(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.name == other.name and self.age == other.age

        return False
</code></pre>
<p>Here are the unit tests I have written for testing the equality functionality:</p>
<pre><code>foo = User('Kshitij', 21)
bar = User('Leo', 30)

self.assertEqual(foo, User('Kshitij', 21))
self.assertNotEqual(foo, bar)
</code></pre>
<p>Both these test cases work fine. 
However, through the <code>assertNotEqual</code> method, I am testing the <code>__ne__()</code> of the <code>User</code> class. I find this somewhat misguiding since I have not implemented a custom <code>__ne__</code> method in my <code>User</code> class. </p>
<p>As a result of this dilemma, I thought of replacing the non-equality testcase with <code>self.assertFalse(foo.__eq__(bar))</code> or <code>self.assertFalse(foo == bar)</code>.</p>
<p>I understand that all these approaches perform the same task and this question might seem highly subjective at first. However, I am looking for some fundamental advice/principle about testing which can help me in similar predicaments.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">Python data model</a> is a good resource for this kind of question:</p>
<blockquote>
<p>By default, <code>__ne__()</code> delegates to <code>__eq__()</code> and inverts the result unless it is <code>NotImplemented</code>. There are no other implied relationships among the comparison operators, for example, the truth of (<code>x&lt;y</code> or <code>x==y</code>) does not imply <code>x&lt;=y</code>. To automatically generate ordering operations from a single root operation, see <code>functools.total_ordering()</code>.</p>
</blockquote>
<p>That means it's totally fine to test: <code>self.assertNotEqual(foo, bar)</code> because by implementing <code>__eq__</code> and not overriding <code>__ne__</code> you <em>implicitly</em> defined <code>__ne__</code>.</p>
<p>But you don't need to test this explicitly (but you can) because it's one of the data-model guarantees.</p>
<hr/>
<p>However there is one thing that could lead to problems (bugs) which should be covered in the unit-tests: </p>
<p>The </p>
<pre><code>if isinstance(other, self.__class__)
</code></pre>
<p>is kind of a red-flag (the <code>isinstance</code> and <code>self.__class__</code> combination).</p>
<p>In this specific case it wouldn't work if you deal with sub-classes (because then <code>self.__class__</code> can be the subclass). </p>
<p>You should either hardcode the base class:</p>
<pre><code>if isinstance(other, User):
</code></pre>
<p>or use duck-typing:</p>
<pre><code>try:
    return self.name == other.name and self.age == other.age
except AttributeError:
    return False
</code></pre>
<p>or something similar.</p>
</div>
<div class="post-text" itemprop="text">
<p>While doing objects comparison, by default Python checks something like objects' memory addresses (iirc, <code>id(obj)</code> values)</p>
<p>You should manually override both <code>__eq__()</code> and <code>__ne__()</code> methods.</p>
</div>
<span class="comment-copy">Regardless of what your tests are testing, your code is going to <i>use</i> <code>!=</code>. You need to have tests for <code>!=</code>, and if your <code>!=</code> doesn't work, you need to make it work.</span>
<span class="comment-copy">Thanks for this. Lesson learnt. But isn't explicit better than implicit? ;)</span>
<span class="comment-copy">@KshitijSaraogi In my opinion it's explicit because you <b>explicitly</b> didn't re-implemented <code>__ne__</code>. I mean the data model gives the guarantee - that should count for something. Only for a few classes it's actually useful to explicitly override <code>__ne__</code>. However I found a problem in your code regarding the <code>isinstance</code> check and updated the answer.</span>
<span class="comment-copy">@KshitijSaraogi: The original rich comparison design <i>did</i> require you to explicitly define both <code>__eq__</code> and <code>__ne__</code>. Turns out people forget and forget and forget, and in Python 3, they decided it was more practical to provide <code>__ne__</code> for people automatically. That's also when they started automatically disabling <code>__hash__</code> for you if you override <code>__eq__</code> without handling <code>__hash__</code>.</span>
<span class="comment-copy">I thank you for taking the time to reply to my query. However, this doesn't answer my question completely.</span>
