<div class="post-text" itemprop="text">
<p>I have sequence of played cards in a list. There were 4 players, so each four elements in the list represent a single trick. I have to process 4 cards together to find trick winner. I need to split the list four elements at a time. I am currently doing the following:</p>
<pre><code>cardSequnce = [
    'D7', 'D8', 'DT', 'DA',
    'H2', 'H7', 'HK', 'H5',
    'H3', 'HT', 'HA', 'HQ',
    'H8', 'D2', 'H4', 'HJ',
    'D6', 'D3'
]
four_card = []
for index, card in enumerate(cardSequnce):
    if(index % 4 == 0):
        # process four_card
        four_card = []
    four_card.append(card)
</code></pre>
<p>I think that I can do better than this using power of python. Can I access 4 cards together in a loop? Can any one help me to make my code more Pythonic?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to create lists of length of 4 from a list, this would do the trick:</p>
<pre><code>[cardSequence[i:i + 4] for i in range(0, len(cardSequence), 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>offset = 4
index = 0
while index &lt; len(YourList):
       result = YourList[index:index+offset]
       index += offset
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can make your code a bit nicer by iterating explicitly through groups of four instead of element-by-element. There are a couple of ways of doing this. The easiest would just be to increment the index by four:</p>
<pre><code>card_sequence = ...
for index in range(0, len(cardSequence), 4):
    four_card = card_sequence[index:index + 4]
    # process four_card
</code></pre>
<p>This has the advantage of not calling the processing code on an empty <code>four_card</code> when <code>index == 0</code>, as your code does. Also, I would recommend sticking to one naming convention (underscores vs CamelCase). I picked the former since that is the generally recommended Python convention.</p>
<p>You can do a slightly more complicated version using the <code>grouper</code> recipe provided by the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> documentation</a>. The advantage of this approach is that it will probably scale better:</p>
<blockquote>
<pre><code>def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
</blockquote>
<pre><code>card_sequence = ...
for four_card in grouper(card_sequence, 4):
    four_card = list(four_card)
    # Process four_card
</code></pre>
<p>Keep in mind that this implementation of <code>grouper</code> is going to fill extra elements in the last group with <code>None</code> if your input sequence does not have a multiple of four elements. It also assumes that you consume all the elements of the group in each iteration (which you do in this case). For alternative implementations, see <a href="https://stackoverflow.com/a/23926929/2988730">this wonderful answer</a>.</p>
</div>
<span class="comment-copy">Try the <code>grouper</code> recipe from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code></a>.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks">What is the most "pythonic" way to iterate over a list in chunks?</a></span>
<span class="comment-copy">this has been tagged with Python 3, change <code>xrange</code> to just <code>range</code>.</span>
<span class="comment-copy">Thanks, will do. I didn't pay attention to tags.</span>
<span class="comment-copy">Thanks, It helped. :)</span>
<span class="comment-copy">This is definitely much less Pythonic than using <code>range</code> in a <code>for</code> loop, but probably still better than OP's original solution.</span>
<span class="comment-copy">yes I agree with you</span>
