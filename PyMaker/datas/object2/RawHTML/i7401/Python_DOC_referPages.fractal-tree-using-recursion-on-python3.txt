<div class="post-text" itemprop="text">
<p>I can't understand the recursion.
The <code>main()</code> function aligns the turtle. The <code>tree()</code> function is called with <code>branchLen = 75</code>. So, it passes the "if" condition and goes up. According to my understanding, the turtle should take 5 consecutive right turns with its length decreasing as 75, 60, 45, 30, 15. After this, it won't satisfy the "if " condition anymore. The code would run only till line 5 (first recursive call). So, a single line leaning toward RHS should be displayed. There shouldn't be any left turns. 
But this does not happen, a full symmetrical tree is made. 
Please explain how.<br/>
See the link for more clarity on the question.<br/>
Thanks!<br/>
<a href="https://interactivepython.org/runestone/static/pythonds/Recursion/pythondsintro-VisualizingRecursion.html" rel="nofollow noreferrer">https://interactivepython.org/runestone/static/pythonds/Recursion/pythondsintro-VisualizingRecursion.html</a></p>
<pre><code>def tree(branchLen,t):
    if branchLen &gt; 5:
        t.forward(branchLen)
        t.right(20)
        tree(branchLen-15,t)
        t.left(40)
        tree(branchLen-15,t)
        t.right(20)
        t.backward(branchLen)

def main():
    t = turtle.Turtle()
    myWin = turtle.Screen()
    t.left(90)
    t.up()
    t.backward(100)
    t.down()
    t.color("green")
    tree(75,t)
    myWin.exitonclick()

main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's not true it is not rotating left. Notice how the same instance of the turtle is always used to draw, so the turtle always continues from the position it is in before each call.</p>
<pre><code>def tree(branchLen,t, direction="straight"):
    if branchLen &gt; 5:
        print branchLen, t.pos(), direction #debug info
        t.forward(branchLen)  #go forward branchlen
        t.right(20)           #rotate right 20
        tree(branchLen-15,t)  #call first branch of recursion
        t.left(40)            #rotate left 40 
        tree(branchLen-15,t)  #call second branch of recursion
        t.right(20)           #rotate right 20
        t.backward(branchLen) #go back branchlen - it is now reset to the original position before this call of tree
        print "reset to previous", t.pos()
</code></pre>
<p>so what essentially happens is:</p>
<ol>
<li>it goes all the way to the right as you expect - that is because it rotates to the right, and then it enters in the first branch of the recursion</li>
<li>It starts to surface from this branch, which means going backwards to each level, and then calling the second branch (which will make it go 'forward' again before resurfacing thus repeating steps 1 and 2)</li>
</ol>
<p>You have to note that when it surfaces it starts using the <code>branchLen</code> value of the function that called this branch, while t remains the same. Here's the result of the debug info:</p>
<pre><code>branchlen, position, direction called
75 (-0.00,-100.00) straight
60 (-0.00,-25.00) right
45 (20.52,31.38) right
30 (49.45,65.85) right
15 (75.43,80.85) right
0 (90.20,83.46) right # 0 does not draw
0 (90.20,83.46) left
reset to previous (75.43,80.85) #after this it will resurface 1 level, and repeat
15 (75.43,80.85) left
0 (85.07,92.34) right
0 (85.07,92.34) left
reset to previous (75.43,80.85)
reset to previous (49.45,65.85) #here it resurfaces twice
30 (49.45,65.85) left
15 (59.71,94.04) right
0 (69.35,105.54) right
0 (69.35,105.54) left
reset to previous (59.71,94.04)
15 (59.71,94.04) left
0 (59.71,109.04) right
0 (59.71,109.04) left
reset to previous (59.71,94.04)
reset to previous (49.45,65.85)
reset to previous (20.52,31.38)
45 (20.52,31.38) left
30 (20.52,76.38) right
15 (30.78,104.57) right
0 (40.42,116.06) right
0 (40.42,116.06) left
reset to previous (30.78,104.57)
15 (30.78,104.57) left
0 (30.78,119.57) right
0 (30.78,119.57) left
reset to previous (30.78,104.57)
reset to previous (20.52,76.38)
30 (20.52,76.38) left
15 (10.26,104.57) right
0 (10.26,119.57) right
0 (10.26,119.57) left
reset to previous (10.26,104.57)
15 (10.26,104.57) left
0 (0.62,116.06) right
0 (0.62,116.06) left
reset to previous (10.26,104.57)
reset to previous (20.52,76.38)
reset to previous (20.52,31.38)
reset to previous (0.00,-25.00)
60 (0.00,-25.00) left
45 (-20.52,31.38) right
30 (-20.52,76.38) right
15 (-10.26,104.57) right
0 (-0.62,116.06) right
0 (-0.62,116.06) left
reset to previous (-10.26,104.57)
15 (-10.26,104.57) left
0 (-10.26,119.57) right
0 (-10.26,119.57) left
reset to previous (-10.26,104.57)
reset to previous (-20.52,76.38)
30 (-20.52,76.38) left
15 (-30.78,104.57) right
0 (-30.78,119.57) right
0 (-30.78,119.57) left
reset to previous (-30.78,104.57)
15 (-30.78,104.57) left
0 (-40.42,116.06) right
0 (-40.42,116.06) left
reset to previous (-30.78,104.57)
reset to previous (-20.52,76.38)
reset to previous (-20.52,31.38)
45 (-20.52,31.38) left
30 (-49.45,65.85) right
15 (-59.71,94.04) right
0 (-59.71,109.04) right
0 (-59.71,109.04) left
reset to previous (-59.71,94.04)
15 (-59.71,94.04) left
0 (-69.35,105.54) right
0 (-69.35,105.54) left
reset to previous (-59.71,94.04)
reset to previous (-49.45,65.85)
30 (-49.45,65.85) left
15 (-75.43,80.85) right
0 (-85.07,92.34) right
0 (-85.07,92.34) left
reset to previous (-75.43,80.85)
15 (-75.43,80.85) left
0 (-90.20,83.46) right
0 (-90.20,83.46) left
reset to previous (-75.43,80.85)
reset to previous (-49.45,65.85)
reset to previous (-20.52,31.38)
reset to previous (0.00,-25.00)
reset to previous (0.00,-100.00)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your best bet towards understanding is to manually trace the code given that you call <code>tree(20,t)</code>.</p>
<p>You should find that the first time you enter <code>tree()</code> the condition is satisfied, but during the two recursive calls the condition is unsatisfied and the recursive calls return immediately to their call sites <strong>and carry on</strong> with the rest of the the <code>tree()</code> function.</p>
<p>To manually trace the code, you should write down, using pen and paper, each statement executed, but when you arrive at a recursive call to <code>tree()</code> you should keep writing down statements, but indent them:</p>
<pre><code>tree(20,t)
  if branchLen&gt;5
  t.forward
  t.right(20)
  tree(5,t)   &lt;--- recursive call, so start indenting next line
    if branchLen&gt;5  &lt;--- if fails, so return and unindent
  t.left(40)
  ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Each call to <code>tree</code> remembers where it is.  You are correct that the first thing to happen is a chain of forward and right turns until <code>tree (0,t)</code> is called.  That call doesn't satisfy the <code>if</code> test, so does nothing.  However, that does not affect any other <code>tree</code> call.  So, back in <code>tree(15,t)</code>, execution continues with line 6, and similarly for all the other <code>tree</code> calls.</p>
<p>As an exercise, you might try pasting a copy of <code>tree</code> each place it is called, and filling in the numbers for <code>branchLen</code>.  Each time <code>tree</code> is called, that is effectively what happens.</p>
<h2>Try 2</h2>
<p>Imagine <code>branchLen</code> were part of the function name, rather than a parameter.  You would have a family of functions <code>tree75(t)</code>, <code>tree60</code>, ... <code>tree0</code>.  <code>tree75()</code> would be:</p>
<pre><code>def tree75(t):
    # don't need an if statement since we know 75&gt;5
    t.forward(75)
    t.right(20)
    tree60(t)     # &lt;-- 75-15 = 60.  Direct call to tree60().
    t.left(40)
    tree60(t)     # ditto
    t.right(20)
    t.backward(branchLen)
</code></pre>
<p>and similarly for all the ones except <code>tree0</code>, which does nothing (the equivalent of failing the <code>if</code> statement in <code>tree</code>).  So just like any function, <code>tree75</code> calls <code>tree60</code>.  <code>tree60</code> runs from the beginning to the end of its code.  Then <code>tree75</code> keeps going from the point where it called <code>tree60</code>: it turns right and calls <code>tree60</code> again.</p>
<p>Each call to a recursive function is just like a call to any other function, in terms of how the call and return behave.  The difference is that you write recursive functions in a particular style so they make sense when calling themselves.  </p>
</div>
<span class="comment-copy">Try stepping through with <code>pdb</code> - watching what actually happens, and how the variables behave, will probably help more than getting internet strangers to write you essays about recursion.</span>
<span class="comment-copy">@Useless, what is "pdb"? I don't know what it is.</span>
<span class="comment-copy">@Useless is saying to use the debugger that comes with your python IDE.</span>
<span class="comment-copy">@scarecrow - <a href="https://docs.python.org/2/library/pdb.html" rel="nofollow noreferrer">Python 2 pdb</a> and <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">Python 3 pdb</a> are the top two matches when I search for <i>"Python pdb"</i>. (I don't know which version of Python you need, but they're the same in use anyway). It's always worth at least trying to research things before asking.</span>
<span class="comment-copy">Oh yeah, and: you've chosen the more complicated of the two examples on that page to ask about (which is one of the reasons I'm reluctant to expand the whole thing for you). Did you understand the spiral one? Why not try to figure that program out first, before getting hung up on the harder one?</span>
<span class="comment-copy">The turtle starts with: 75 -&gt; r -&gt; recursive call (True) -&gt; 60 -&gt; r -&gt; recursive call (True) -&gt; 45 -&gt; r -&gt; recursive call (True) -&gt; 30 -&gt; r -&gt; recursive call (True) -&gt; 15 -&gt; r -&gt; recursive call (False). What happens after this? In the debug info, the branchLen becomes 0. How? It should directly go to t.left(40) after the first branch returns false, shouldn't it?</span>
<span class="comment-copy">@sacrecrow it becomes 0 because of the way the function is called <code>tree(branchLen-15,t)</code>. These functions don't actually return <code>True</code> or <code>False</code>, they just move the turtle. When a function receives a <code>branchLen</code> it simply does not do anything at all, but still this call is made. You can think of it this way: at every position we must call the function going left and the function going right, but when we call the function going right, it continues until it can, and the calls to the left are done on the way back. Use the coordinates to check the depth, and you'll see they occur multiple times</span>
<span class="comment-copy">A recursive call doesn't go back to the top? For example, the recursive call on line 5 doesn't make the code run from where the function is first defined?</span>
<span class="comment-copy">@scarecrow - edited- see what you think</span>
