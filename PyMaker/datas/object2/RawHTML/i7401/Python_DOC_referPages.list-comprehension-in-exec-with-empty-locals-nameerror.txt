<div class="post-text" itemprop="text">
<p>Consider the following snippet:</p>
<pre><code>def bar():
    return 1
print([bar() for _ in range(5)])
</code></pre>
<p>It gives an expected output <code>[1, 1, 1, 1, 1]</code>.</p>
<p>However, if I try to <code>exec</code> the same snippet in empty environment (<code>locals</code> and <code>globals</code> both are set to <code>{}</code>), it gives <code>NameError</code>:</p>
<pre><code>if 'bar' in globals() or 'bar' in locals():
    del bar
# make sure we reset settings

exec("""
def bar():
    return 1
print([bar() for _ in range(5)])
""", {}, {})

NameError: name 'bar' is not defined
</code></pre>
<p>If I invoke <code>exec</code> like <code>exec(…, {})</code> or <code>exec(…)</code>, it is executed as expected.</p>
<p>Why?</p>
<p>EDIT:</p>
<p>Consider also the following snippet:</p>
<pre><code>def foo():
    def bar():
        return 1
    print('bar' in globals()) # False
    print('bar' in locals()) # True
    print(['bar' in locals() for _ in [1]]) # [False]
    print([bar() for _ in [1, 2]]) # [1, 1]
</code></pre>
<p>Just like in my first exec, we don't have bar in locals inside list comprehension. However, if we try to invoke it, it works!</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution to your problem lies here:</p>
<blockquote>
<p>In all cases, if the optional parts are omitted, the code is executed in the current scope. <strong>If only globals is provided, it must be a dictionary, which will be used for both the global and the local variables. If globals and locals are given, they are used for the global and local variables, respectively.</strong> If provided, locals can be any mapping object. <strong>Remember that at module level, globals and locals are the same dictionary.</strong> If exec gets two separate objects as globals and locals, the code will be executed as if it were embedded in a class definition.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/functions.html#exec" rel="noreferrer">https://docs.python.org/3/library/functions.html#exec</a></p>
<p>Basically, your problem is that bar is defined in the scope of <code>locals</code> and only in <code>locals</code>. Therefore, this <code>exec()</code> statement works:</p>
<pre><code>exec("""
def bar():
    return 1
print(bar())
""", {}, {})
</code></pre>
<p>The list comprehension however creates a new local scope, one in which <code>bar</code> is not defined and can therefore not be looked up.</p>
<p>This behaviour can be illustrated with:</p>
<pre><code>exec("""
def bar():
    return 1
print(bar())
print(locals())
print([locals() for _ in range(1)])
""", {}, {})
</code></pre>
<p>which returns</p>
<pre><code>1
{'bar': &lt;function bar at 0x108efde18&gt;}
[{'_': 0, '.0': &lt;range_iterator object at 0x108fa8780&gt;}]
</code></pre>
<p><strong>EDIT</strong></p>
<p>In your original example, the definition of <code>bar</code> is found in the (module level) global scope. This corresponds to</p>
<blockquote>
<p>Remember that at module level, globals and locals are the same dictionary.</p>
</blockquote>
<p>In the <code>exec</code> example, you introduce an artificial split in scopes between globals and locals by passing two different dictionaries. If you passed the same one or only the globals one (which would in turn mean that this one will be used for both <code>globals</code> and <code>locals</code>) , your example would also work.</p>
<p>As for the example introduced in the edit, this boils down to the scoping rules in python. For a detailed explanation, please read: <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="noreferrer">https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces</a></p>
<p>In short, while <code>bar</code> is not in the local scope of the list comprehension and neither in the global scope, it is in the scope of foo. And given Python scoping rules, if a variable is not found in the local scope, it will be searched for in the enclosing scopes until the global scope is reached. In your example, foo's scope sits between the local scope and the global scope, so bar will be found before reaching the end of the search.</p>
<p>This is however still different to the exec example, where the locals scope you pass in is not enclosing the scope of the list comprehension, but completely divided from it.</p>
<p>Another great explanation of scoping rules including illustrations can be found here: <a href="http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html" rel="noreferrer">http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>As Hendrik Makait found out, <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">the <code>exec</code> documentation says that</a></p>
<blockquote>
<p>If <code>exec</code> gets two separate objects as <code>globals</code> and <code>locals</code>, the code will be executed as if it were embedded in a class definition.</p>
</blockquote>
<p>You can get the same behaviour by embedding the code into a class definition:</p>
<pre><code>class Foo:
    def bar():
        return 1
    print([bar() for _ in range(5)])
</code></pre>
<p>Run it in Python 3 and you will get</p>
<pre><code>Traceback (most recent call last):
  File "foo.py", line 9, in &lt;module&gt;
    class Foo:
  File "foo.py", line 15, in Foo
    print({bar() for _ in range(5)})
  File "foo.py", line 15, in &lt;setcomp&gt;
    print({bar() for _ in range(5)})
NameError: global name 'bar' is not defined
</code></pre>
<p>The reason for the error is as Hendrik said that a <em>new implicit local scope</em> is created for list comprehensions. However Python only ever looks names up in 2 scopes: global or local. Since neither the global nor the new local scope contains the name <code>bar</code>, you get the <code>NameError</code>.</p>
<p>The code works in Python 2, because list comprehensions have a bug in Python 2 in that they do not create a new scope, and thus they leak variables into their current local scope:</p>
<pre><code>class Foo:
    [1 for a in range(5)]
    print(locals()['a'])
</code></pre>
<p>Run it in Python 2 and the output is <code>4</code>. The variable <code>a</code> is now within the locals in the class body, and retains the value from the last iteration. In Python 3 you will get a <code>KeyError</code>.</p>
<p>You can get the same error in Python 2 too though, if you use a generator expression, or a dictionary/set comprehension:</p>
<pre><code>class Foo:
    def bar():
        return 1
    print({bar() for _ in range(5)})
</code></pre>
<p>The error can be produced also by just using simply</p>
<pre><code>class Foo: 
    bar = 42
    class Bar:
        print(bar)
</code></pre>
<p>This is unlike</p>
<pre><code>def foo():
    bar = 42
    def baz():
        print(bar)
    baz()
</code></pre>
<p>because upon execution of <code>foo</code>, Python makes <code>baz</code> into a closure, which will access the <code>bar</code> variable via a special bytecode instruction.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm late to the party here, but there is a better documentation reference buried in the <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">execution model</a>.  </p>
<p>In section <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer"><strong>4.2.2 Resolution of names</strong></a>:</p>
<blockquote>
<p>Class definition blocks and arguments to <code>exec()</code> and <code>eval()</code> are special in the context of name resolution. ... </p>
</blockquote>
<p>And then in <a href="https://docs.python.org/3/reference/executionmodel.html#interaction-with-dynamic-features" rel="nofollow noreferrer"><strong>4.2.4 Interaction with dynamic features</strong></a>:</p>
<blockquote>
<p>The <code>eval()</code> and <code>exec()</code> functions do not have access to the full environment for resolving names. Names may be resolved in the local and global namespaces of the caller. Free variables are not resolved in the nearest enclosing namespace, but in the global namespace. [1] The <code>exec()</code> and <code>eval()</code> functions have optional arguments to override the global and local namespace.  If only one namespace is specified, it is used for both.</p>
</blockquote>
<p>[1] This limitation occurs because the code that is executed by these operations is not available at the time the module is compiled.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Edit</p>
</blockquote>
<p><strong>To answer your edited question</strong>, user @Hendrik Makait said <code>bar</code> is not in the scope of list comprehension:</p>
<pre><code>def foo():
    def bar():
        return 1
    print('bar' in globals()) # False, because the scope of foo and bar are diferents, foo is globals() scope, bar are in the scope of foo
    print('bar' in locals()) # True
    print(['bar' in locals() for _ in [1]]) # [False], because a new implicit scope is defined in list comprehension, as user @Antti Haapala said
    print([bar() for _ in [1, 2]]) # [1, 1]
</code></pre>
<p><strong>To answer the original question:</strong></p>
<p>If you create two different dictionaries, it wont recognize the local and globals definitions, <strong>the variables are not updated</strong> as @PM 2Ring said:  </p>
<pre><code>exec("""
def bar():
    return 1
print(bar())
print("bar" in globals())
print("bar" in locals())
print([bar() for _ in range(5)])
""", {},{})
</code></pre>
<p>it prints:</p>
<pre><code>1
False #not in globals
True
Traceback (most recent call last):
  File "python", line 17, in &lt;module&gt;
  File "&lt;string&gt;", line 7, in &lt;module&gt;
  File "&lt;string&gt;", line 7, in &lt;listcomp&gt;
NameError: name 'bar' is not defined
</code></pre>
<p>A way to do it, is update the variables, like this globals().update(locals()):</p>
<pre><code>exec("""
def bar():
    return 1
globals().update(locals())
print("bar" in globals())
print("bar" in locals())
print([bar() for _ in range(5)])
""", {}, {})
</code></pre>
<p>wich gives:</p>
<pre><code>True
True
[1, 1, 1, 1, 1]
</code></pre>
<p>But, if you remove the dictionaries, or create one and give it to the exec function as same parameter, it works:</p>
<pre><code>d={}

exec("""
def bar():
    return 1
print("bar" in globals())
print("bar" in locals())
print([bar() for _ in range(5)])
""",d,d)
</code></pre>
<p>it prints:</p>
<pre><code>True
True
[1, 1, 1, 1, 1]
</code></pre>
<p>That's why you get the error, it could't find your function in the globals </p>
<p>Or simply, don't give the parameters:</p>
<pre><code>exec("""
def bar():
    return 1
print(bar())
print("bar" in globals())
print("bar" in locals())
print([bar() for _ in range(5)])
""")
</code></pre>
<p>Cause the same efect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution!</p>
<p>We needed to get the local namespace out after the exec() to track modifications. This doesn't work with only one namespace, so we did this:</p>
<pre><code> class MagickNameSpace(UserDict, dict):
    """A magic namespace for Python 3 exec().
    We need separate global and local namespaces in exec(). This does not
    work well in Python 3, because in Python 3 the enclosing namespaces are
    not used to look up variables, which seems to be an optimization thing
    as the exec'd code isn't available at module compilation.

    So we make a MagickNameSpace that stores all new variables in a
    separate dict, conforming to the local/enclosing namespace, but
    looks up variables in both.
    """


    def __init__(self, ns, *args, **kw):
        UserDict.__init__(self, *args, **kw)
        self.globals = ns

    def __getitem__(self, key):
        try:
            return self.data[key]
        except KeyError:
            return self.globals[key]

    def __contains__(self, key):
        return key in self.data or key in self.globals
</code></pre>
<p>Replace the old code:</p>
<pre><code>exec(code, global_ns, local_ns)
return local_ns
</code></pre>
<p>with:</p>
<pre><code>ns = MagickNameSpace(global_ns)
ns.update(local_ns)
exec(code, ns)
return ns.data
</code></pre>
</div>
<span class="comment-copy">Interestingly, this weird behavior is not seen in Python 2.</span>
<span class="comment-copy">Note that if you make locals &amp; globals the same empty dict, it works: <code>d={}; exec("def bar():return 1\nprint([bar() for _ in range(5)])", d, d)</code></span>
<span class="comment-copy">LLia V Schurov, consider not give two dictionaries as parameter, in this case, the two extra parameters are not needed</span>
<span class="comment-copy">It was really hard to understand the rare behavior  behind this, but I think I fanally with help of @PM2Ring I understand whats going on</span>
<span class="comment-copy">For some excellent info about <code>exec</code>, <code>eval</code>, and <code>compile</code>, please see <a href="https://stackoverflow.com/a/29456463/4014959">stackoverflow.com/a/29456463/4014959</a></span>
<span class="comment-copy">thanks, I expected something like that. However, I'm still not sure, why it works inside function (see edit to my question).</span>
<span class="comment-copy">@IlyaV.Schurov - see edit to my answer. TL;DR: in exec you are creating an artificial scoping that does not reflect the "pure code" example's scope.</span>
<span class="comment-copy">@IlyaV.Schurov also see my edited answer please, and comment there whatever you don't understand</span>
<span class="comment-copy">@HendrikMakait we don't have 'bar' in globals() inside the function, as the first print shows. Does it mean we don't have it in global scope as well?</span>
<span class="comment-copy">@HendrikMakait it seems I understand now. In exec example, Python can't find foo in the list comprehension scope and it tries to find it in the outer scope, which appear to be the topmost one. As it is the topmost scope, Python looks in globals dictionary. Normally topmost's locals is the same as globals and objects defined in topmost scope are recorded to both topmost's locals and globals. But in exec example it is recorded only in locals, which is not scanned by Python. Am I right?</span>
<span class="comment-copy">Thanks for the answer, it clarifies a lot of ideas I didn't get at first.... I get confused in the first time I answered. +1</span>
<span class="comment-copy">Great example going into more detail on the meaning of the code being executed "as if it were embedded in a class definition".</span>
<span class="comment-copy">What Antti has tried to explain here is <a href="https://stackoverflow.com/a/45196415/674039">more clearly documented in the execution model</a>.</span>
<span class="comment-copy">Nice, I have never found <i>that</i> document.</span>
<span class="comment-copy">Finally a correct answer.</span>
<span class="comment-copy">I would like an explain to the downvotes... I really don't understand, it works perfectly to me</span>
<span class="comment-copy">@MosesKoledoye Ok, I thing I got this, check my update if you please. I like to understand this better</span>
<span class="comment-copy">I have retracted my downvote after your edit, although it still does not explain why the empty dicts don't work.</span>
<span class="comment-copy">@MosesKoledoye I made another edit explaining that, thanks for the patient, I got a little help from another expert like you :)</span>
<span class="comment-copy">"If you create two different dictionaries, it wont recognize the local and globals definitions" - Well, not really, see my answer on how locals is updated but the scope ignored.</span>
