<div class="post-text" itemprop="text">
<p>I made a python runner program and package like so:</p>
<p>The runner program takes in arguments from the command-line and uses argseparse to parse them, like:</p>
<pre><code>parser = argparse.ArgumentParser()    
parser.add_argument(...
parser.add_argument(...  
args = parser.parse_args()
</code></pre>
<p>Then it sends them into my package module like this:   </p>
<pre><code>packageObject = PackageModule(params=args)
</code></pre>
<p>Now I'm making this into a program that does not take in command-line arguments, but I want to keep initialising the PackageObject with that same line.</p>
<p>How can I make something like,</p>
<pre><code>args = ()
args.arguments_1 = 'user_name'
</code></pre>
<p>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can provide a list to <code>argparse.parse_args()</code> which does not need to come from the command line:</p>
<pre><code>args_list = ['-n', '10', 'hello']
args = parser.parse_args(args_list)
</code></pre>
<p>Then you should be able to run the rest of your script as before.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could define a new class to store the states of the arguments:</p>
<pre><code>class Args(object):
    def __init__(self, arg1, arg2):
        self.arg1 = arg1
        self.arg2 = arg2

args = Args('user_name', 'something else')
packageObject = PackageModule(params=args)
</code></pre>
<p>If you're creating multiple <code>args</code> instances, you may consider using <code>__slots__</code> in the class definition since you won't be assigning new attributes on the instance, also making the instances ligthweight:</p>
<pre><code>class Args(object):
    __slots__ = ['arg1', 'arg2']
    def __init__(self, arg1, arg2):
        self.arg1 = arg1
        self.arg2 = arg2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are several solutions:</p>
<ol>
<li>Make the <code>PackageModule</code> object accept arguments, and unpack the args object <code>PackageModule(**vars(args))</code></li>
<li>Just make a lightweight namedtuple</li>
<li>Make a lightweight class</li>
<li>Pass args as a dict <code>params=vars(args)</code>, and substitute for a normal dict</li>
</ol>
</div>
<span class="comment-copy"><code>argparse.Namespace</code>, which is the type of the object returned by <code>parse_args</code>, isn't significantly different than <code>class Namespace: pass</code>.</span>
<span class="comment-copy">If using &gt;= Python 3.3, they could use <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer"><code>types.SimpleNamespace</code></a> which lets them avoid boilerplate, and will look more like the <code>argparse.Namespace</code> if they call <code>print</code> on it.</span>
