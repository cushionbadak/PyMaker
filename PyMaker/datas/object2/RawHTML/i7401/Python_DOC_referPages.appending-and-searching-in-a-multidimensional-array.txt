<div class="post-text" itemprop="text">
<p>So my problem is that I want to append a name of something to an array, and a count.  </p>
<pre><code>test_array = []
test_array.append(['apples', 2])
test_array.append(['oranges', 5])
test_array.append(['bananas', 1])

print(*test_array)

['apples', 2]
['oranges', 5]
['bananas', 1]
</code></pre>
<p>Now I would like to search my 2d array by the name of the thing I am counting and add 1 to the second column      </p>
<pre><code>test_array['oranges'][1] = test_array['oranges'][1]+1
</code></pre>
<p>I would test for the existence of the item before adding 1 to the second column</p>
<pre><code>if test_array['string'] != None:
    test_array.append['string', ]
</code></pre>
<p>I am not sure if this is possible, or if I will just need to search the entire first column of the array for the item before appending to the list.  I am going to be doing this for 37,731,481 items so I would need a way to search strings that would hopefully not be quadratic in run time, so I would probably just sort my list by the strings and do a binary search.  </p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest you use a mapping instead of the nested lists, most preferably a <a href="https://docs.python.org/2/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> object. The items will be the keys and their counts will be values. Then searching for a key can be done in constant time - <em>O</em>(1).</p>
<pre><code>from collections import Counter

dct = Counter()
dct['apples'] = 2
dct['oranges'] = 5
dct['bananas'] = 1
print dct
# Counter({'oranges': 5, 'apples': 2, 'bananas': 1})
</code></pre>
<p>And you won't need to test for key existence to add/update values:</p>
<pre><code># updating a key (which is not in the counter)
dct['mango'] += 3
print dct
# Counter({'oranges': 5, 'apples': 2, 'mango': 3, 'bananas': 1})
</code></pre>
<p>This is so because <code>collections.Counter</code> objects unlike vanilla dicts always return zero for missing keys rather than raise a <em>KeyError</em>.</p>
<p>In case you need to manage negative counts, a <code>Counter</code> object will not be the best choice. You could use a <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> object instead making the <em>default_factory</em> the <code>int</code> function:</p>
<pre><code>from collections import defaultdict:

dct = defaultdict(int)
...
</code></pre>
<p>Works the same way as the <code>Counter</code> except negative counts are now properly handled.</p>
</div>
<span class="comment-copy">I think you'll need to search the entire first column of the array before appending. It seems like maybe a dictionary would be a better data structure for your use case?: <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">docs.python.org/3/tutorial/datastructures.html#dictionaries</a></span>
