<div class="post-text" itemprop="text">
<p>python: 3.4</p>
<p>OS: win7 / win10</p>
<p>I want to kill a running process with python and close all the files it opened:</p>
<pre><code>for proc in psutil.process_iter():
    if proc.name() == 'myprocess.exe':
        opened = proc.open_files()
        proc.kill()
        for i in opened:
            print(i.path)
            io.FileIO(i.path).close()
            print(io.FileIO(i.path).closed)
</code></pre>
<p>Somehow <code>io.IOBase(i.path).close()</code> does not work.</p>
<p>Explanation:</p>
<p>It's like I would like to kill Microsoft Word with python, but it leaves some files open. And I would like to close those files as well.</p>
<p>Microsoft Word is just an example. It is a self-written python programm. The opened files are:</p>
<ul>
<li>fonts (.ttf)</li>
<li>clr.pyd </li>
<li>and .dll-s</li>
</ul>
<p>How should I close these files?</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to close any files that were opened by the process.  That is done <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686722(v=vs.85).aspx" rel="nofollow noreferrer">automatically</a>:</p>
<blockquote>
<p>Terminating a process has the following results:</p>
<ul>
<li>Any remaining threads in the process are marked for termination.</li>
<li>Any resources allocated by the process are freed.</li>
<li>All kernel objects are closed.</li>
<li>The process code is removed from memory.</li>
<li>The process exit code is set.</li>
<li>The process object is signaled.</li>
</ul>
</blockquote>
<p>The important bit is "All kernel objects are closed."  For every open file handle, there is an associated kernel object--that's actually what a handle is, a mapping from a number to a kernel object.  When the process exits, the kernel will walk behind and close all associated file handles, sockets, etc.</p>
<p>Additionally, you're original approach has a few problems.  First, the list of open files is only a snapshot of which ones were open at that time.  In between asking for the list of open files and killing the process, the process could have opened many more, or closed and removed many as well.  Second, the Python 3 docs say that the constructor for IOBase isn't public, so using it in this way is <a href="https://docs.python.org/3/library/io.html#io.IOBase" rel="nofollow noreferrer">wrong</a>:</p>
<blockquote>
<p>class io.IOBase</p>
<p>The abstract base class for all I/O classes, acting on streams of bytes. There is no public constructor.</p>
</blockquote>
<p>Generally, you'd use something like <code>io.open()</code> which takes the path.  This leads to the third issue.  All you have to work with is the path.  In order to close a file, you really need the handle.  Those handles are process-specific.  This means in one process, 0x5555AAAA may correspond to "file1.txt", but in another process, it might correspond to "file2.txt" or maybe not even a file at all (it could be a socket or something else).  So even if you have the kernel handle, we don't really have a way of saying "close this handle in the context of this other process."  That violates some security goals of processes.  Also, it means that what you're actually doing here is creating your own handle to only turn around and close it (or in this case, it possibly does nothing at all since the object wasn't created correctly).</p>
<p>So, if you're having a problem with files still being held, perhaps the problem is that the process didn't actually die yet before trying whatever work you needed to get done.  You may need to wait for the process to exit before attempting to move on if there are files the process was using that you want to use again.  It looks like you can use <code>psutils.wait_procs()</code> to do that.</p>
<p>Also, on Windows I find that anti-virus tools often get in the way.  They hold open files accessed by applications making it look like a process is still holding onto them when it's actually the virus scanner doing its thing.  I remember one instance of having to deal with this in Subversion.  The code still exists <a href="http://svn.apache.org/viewvc/subversion/trunk/subversion/libsvn_subr/io.c?revision=1794523&amp;view=markup#l74" rel="nofollow noreferrer">today</a>.  So you might need to simply wait a bit and try again.</p>
<p><strong>Update</strong></p>
<blockquote>
<p>Microsoft Word is just an example. It is a self-written python programm. The opened files are:</p>
<ul>
<li>fonts (.ttf)</li>
<li>clr.pyd</li>
<li>and .dll-s</li>
</ul>
<p>How should I close these files?</p>
</blockquote>
<p>The answer is that you shouldn't need to.  Just make sure the process has actually exited.  It's not an instantaneous operation, so there's some time between killing it and it actually exiting that it still retains the file handles.</p>
<p>Given that you've actually written the process being killed, I think a far better approach would be to introduce a way to launch that process, have it do its work, then exit gracefully.  Then use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run()</code></a> to run the script and wait for it to exit.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>It's like I would like to kill Microsoft Word with python, but it leaves some files open. And I would like to close those files as well.</p>
</blockquote>
<p>There is some misunderstanding here. When you terminate Word with kill, all files are closed from a system point of view, but they will be <em>dirty closed</em>. When Word terminates normally, it flushes its internal buffers, removes any temporary files and mark the files as <em>clean</em>. When it crashes or is abruptely terminated, all that cleaning does not occur. Some modifications may not be written to disk, and temp files are still there, so on next execution, Word will warn you that the files have not been orderly closed and have to be repaired.</p>
<p>So you do not want to <em>kill</em> Microsoft Word, but to <em>close</em> it, meaning posting a WM_QUIT message to its main window. Unfortunately, there is no clean and neat support in Python for that. There is an example of closing Excel by the win32com module <a href="http://www.numbergrinder.com/2008/11/closing-excel-using-python/" rel="nofollow noreferrer">here</a>. The convertion for Word should be (beware untested):</p>
<pre><code>wd = win32com.client.Dispatch("Word.Application")
wd.Quit() #quit word, as if user hit the close button/clicked file-&gt;exit.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at the <code>with</code> statement syntax.  There's a brief overview <a href="http://effbot.org/zone/python-with-statement.htm" rel="nofollow noreferrer">here</a></p>
</div>
<span class="comment-copy">I posted an answer to your question, but I bet you're trying to solve a different problem.  It'd be helpful if you could describe that problem instead.</span>
<span class="comment-copy">I would like to make an autoupdater:  killing a process   delete all the files   and   copy the new files in the same order.  If there are some opened files, I cannot remve them.</span>
<span class="comment-copy">In general, that's a really hard problem, especially with something like Word where the user may actively be doing useful things.  You could cause them to lose work, or corrupt their file in some interesting way (because only part of the data was written out).  You'll need a far better strategy to make something like that work well.  It's way beyond a StackOverflow question, IMHO.</span>
<span class="comment-copy">I responded before the rest of your message made it on...</span>
<span class="comment-copy">So, you're trying to launch Word, have it do something, and then exit?  Either way, you still need to coordinate with Word.  Otherwise you potentially kill it before it's done.  Perhaps a better way would be to look at mechanisms to automate Word.  It could then do the work and exit gracefully instead, which removes a lot of headaches.</span>
<span class="comment-copy">This will definitely not help with the problem.  Closing another processes file handles is very different than closing file objects in your local process.</span>
<span class="comment-copy">@jszakmeister then it seems I've misunderstood the question.  I was under the impression that if a file was opened by a process using the <code>with</code> syntax, then ending that process (even from a different process) would automatically cause the file handle cleanup.  Are you saying that isn't so?</span>
<span class="comment-copy">You're right on that point, it's just not what is happening here.  The process being terminated is not a Python process (it was Word, in this example).  The poster has no control over that process and how it works.  So, that makes you response seem like you're talking about the local process (the one looking to terminate and close file handles in the other process).  <code>with</code> does not help in this case for several reason (some of which are outlined in my answer above).  BTW, I didn't down vote your answer (someone else did that).  I just wanted to clarify the difference.</span>
<span class="comment-copy">@jszakmeister I see your point. Thanks for clarifying. And no worries about the down vote - they're a part of life on SO, and it's understandable given my misunderstanding about the original question.</span>
