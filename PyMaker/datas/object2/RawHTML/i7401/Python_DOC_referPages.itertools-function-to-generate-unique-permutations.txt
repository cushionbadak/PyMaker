<div class="post-text" itemprop="text">
<p>I want to know if there is an <code>itertools</code> way to produce the following combinations/permutations:</p>
<pre><code>list = ['x', 'o']

# when character 'x' is allowed to occupy 1 place with total places of 4:

a = [['o','o','o','x'],
     ['o','o','x','o'],
     ['o','x','o','o'],
     ['x','o','o','o']]

# when character 'x' is allowed to occupy 2 places with total places of 4:

b = [['o','o','x','x'],
     ['o','x','x','o'],
     ['x','x','o','o'],
     ['x','o','x','o'],
     ['o','x','o','x'],
     ['x','o','o','x']]
</code></pre>
<p>I was wondering if there was a way to do this using <code>itertools.product</code> or a similar function to achieve this?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" rel="nofollow noreferrer"><code>itertools.permutations</code></a> also accepts strings as paramater:</p>
<pre><code>from itertools import permutations
&gt;&gt;&gt; list(permutations("ooox"))
[('o', 'o', 'o', 'x'), ('o', 'o', 'x', 'o'), ('o', 'o', 'o', 'x'), ('o', 'o', 'x', 'o'), ('o', 'x', 'o', 'o'), ('o', 'x', 'o', 'o'), ('o', 'o', 'o', 'x'), ('o', 'o', 'x', 'o'), ('o', 'o', 'o', 'x'), ('o', 'o', 'x', 'o'), ('o', 'x', 'o', 'o'), ('o', 'x', 'o', 'o'), ('o', 'o', 'o', 'x'), ('o', 'o', 'x', 'o'), ('o', 'o', 'o', 'x'), ('o', 'o', 'x', 'o'), ('o', 'x', 'o', 'o'), ('o', 'x', 'o', 'o'), ('x', 'o', 'o', 'o'), ('x', 'o', 'o', 'o'), ('x', 'o', 'o', 'o'), ('x', 'o', 'o', 'o'), ('x', 'o', 'o', 'o'), ('x', 'o', 'o', 'o')]
</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; list(permutations("ooxx"))
[('o', 'o', 'x', 'x'), ('o', 'o', 'x', 'x'), ('o', 'x', 'o', 'x'), ('o', 'x', 'x', 'o'), ('o', 'x', 'o', 'x'), ('o', 'x', 'x', 'o'), ('o', 'o', 'x', 'x'), ('o', 'o', 'x', 'x'), ('o', 'x', 'o', 'x'), ('o', 'x', 'x', 'o'), ('o', 'x', 'o', 'x'), ('o', 'x', 'x', 'o'), ('x', 'o', 'o', 'x'), ('x', 'o', 'x', 'o'), ('x', 'o', 'o', 'x'), ('x', 'o', 'x', 'o'), ('x', 'x', 'o', 'o'), ('x', 'x', 'o', 'o'), ('x', 'o', 'o', 'x'), ('x', 'o', 'x', 'o'), ('x', 'o', 'o', 'x'), ('x', 'o', 'x', 'o'), ('x', 'x', 'o', 'o'), ('x', 'x', 'o', 'o')]
</code></pre>
<p>To store them in a list of lists as shown in your question you can use <code>map(list, permutations("ooox"))</code>.</p>
<p>As you mentioned in the comment section, we can write a specific function for that job, that takes the inputs you want, but notice this will behave in a not so desired way when the first string is not of length 1:</p>
<pre><code>from itertools import permutations
def iterate(lst, length, places):
    return set(permutations(lst[0]*(length-places)+lst[1]*places))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(iterate(["o","x"], 4, 1))
{('o', 'o', 'o', 'x'),
 ('o', 'o', 'x', 'o'),
 ('o', 'x', 'o', 'o'),
 ('x', 'o', 'o', 'o')}
&gt;&gt;&gt; pprint(iterate(["o","x"], 4, 2))
{('o', 'o', 'x', 'x'),
 ('o', 'x', 'o', 'x'),
 ('o', 'x', 'x', 'o'),
 ('x', 'o', 'o', 'x'),
 ('x', 'o', 'x', 'o'),
 ('x', 'x', 'o', 'o')}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create your own function (or generator) based on <a href="https://docs.python.org/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a>:</p>
<pre><code>from itertools import combinations

def equivalence_permutations(x, o):
    """Create all unique permutations with `x` x'es and `o` o's."""
    total = x+o
    for indices in combinations(range(total), x):
        lst = ['o']*total
        for index in indices:
            lst[index] = 'x'
        yield lst
</code></pre>
<p>The <code>combinations</code> makes sure the indices are unique without needing to use <code>set</code> or any other greedy operation. So it should be much faster in those cases. For example:</p>
<pre><code>&gt;&gt;&gt; list(equivalence_permutations(2, 2))  # 2 x and 2 o
[['x', 'x', 'o', 'o'],
 ['x', 'o', 'x', 'o'],
 ['x', 'o', 'o', 'x'],
 ['o', 'x', 'x', 'o'],
 ['o', 'x', 'o', 'x'],
 ['o', 'o', 'x', 'x']]

&gt;&gt;&gt; list(equivalence_permutations(1, 3))  # 1 x and 3 o
[['x', 'o', 'o', 'o'],
 ['o', 'x', 'o', 'o'],
 ['o', 'o', 'x', 'o'],
 ['o', 'o', 'o', 'x']]
</code></pre>
</div>
<span class="comment-copy">Your answer seems to have many duplicates in them. We could take uniques, but I'm looking for a function where I can specify the number of places (4 in the example) and the number of places an element X can occupy (in the example I give two cases , 1 and 2)</span>
<span class="comment-copy">I don't think <code>itertools</code> have a special function for this <i>exact</i> problem. However, it's not hard to write a function that takes a list of length 2, the size and space desired and uses the line I've shown to output your list. But I guess it would be very specific.</span>
<span class="comment-copy">@user3063482 Please check my edit.</span>
<span class="comment-copy">@user3063482 Note that using <code>set</code> is likely to be very inefficient if the number of elements and number of <code>'x'</code> gets bigger. Also you'll lose the memory efficiency of a generator. But as pointed out a "carefully tailored" solution would be really specific. There's some tradeoff there. :)</span>
