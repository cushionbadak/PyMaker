<div class="post-text" itemprop="text">
<p>I am writing a program which, among other things, allows the user to specify through an argument a module to load (and then use to perform actions). I am trying to set up a way to easily pass arguments through to this inner module, and I was attempting to use ArgParse's <code>action='append'</code> to have it build a list of arguments that I would then pass through.</p>
<p>Here is a basic layout of the arguments that I am using</p>
<pre><code>parser.add_argument('-M', '--module',
                    help="Module to run on changed files - should be in format MODULE:CLASS\n\
                          Specified class must have function with the signature run(src, dest)\
                          and return 0 upon success",
                    required=True)
parser.add_argument('-A', '--module_args',
                    help="Arg to be passed through to the specified module",
                    action='append',
                    default=[])
</code></pre>
<p>However - if I then try to run this program with <code>python my_program -M module:class -A "-f filename"</code> (where I would like to pass through the <code>-f filename</code> to my module) it seems to be parsing the <code>-f</code> as its own argument (and I get the error <code>my_program: error: argument -A/--module_args: expected one argument</code></p>
<p>Any ideas?</p>
</div>
<div class="post-text" itemprop="text">
<p>With:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-M', '--module',
                    help="Module to run on changed files - should be in format MODULE:CLASS\n\
                          Specified class must have function with the signature run(src, dest)\
                          and return 0 upon success",
                    )
parser.add_argument('-A', '--module_args',
                    help="Arg to be passed through to the specified module",
                    action='append',
                    default=[])
import sys
print(sys.argv)
print(parser.parse_args())
</code></pre>
<p>I get:</p>
<pre><code>1028:~/mypy$ python stack45146728.py -M module:class -A "-f filename"
['stack45146728.py', '-M', 'module:class', '-A', '-f filename']
Namespace(module='module:class', module_args=['-f filename'])
</code></pre>
<p>This is using a linux shell.  The quoted string remains one string, as seen in the <code>sys.argv</code>, and is properly interpreted as an argument to <code>-A</code>.</p>
<p>Without the quotes the <code>-f</code> is separate and interpreted as a flag.</p>
<pre><code>1028:~/mypy$ python stack45146728.py -M module:class -A -f filename
['stack45146728.py', '-M', 'module:class', '-A', '-f', 'filename']
usage: stack45146728.py [-h] [-M MODULE] [-A MODULE_ARGS]
stack45146728.py: error: argument -A/--module_args: expected one argument
</code></pre>
<p>Are you using <code>windows</code> or some other OS/shell that doesn't handle quotes the same way?</p>
<hr/>
<p>In <a href="https://stackoverflow.com/questions/45150153/argparse-append-not-working-as-expected">Argparse `append` not working as expected</a></p>
<p>you asked about a slightly different command line:</p>
<pre><code>1032:~/mypy$ python stack45146728.py  -A "-k filepath" -A "-t"
['stack45146728.py', '-A', '-k filepath', '-A', '-t']
usage: stack45146728.py [-h] [-M MODULE] [-A MODULE_ARGS]
stack45146728.py: error: argument -A/--module_args: expected one argument
</code></pre>
<p>As I already noted <code>-k filepath</code> is passed through as one string.  Because of the space, <code>argparse</code> does not interpret that as a flag.  But it does interpret the bare '-t' as a flag.</p>
<p>There was a bug/issue about the possibility of interpreting undefined '-xxx' strings as arguments instead of flags.  I'd have to look that up to see whether anything made it into to production.</p>
<p>Details of how strings are categorized as flag or argument can be found in <code>argparse.ArgumentParser._parse_optional</code> method.  It contains a comment:</p>
<blockquote>
<pre><code>    # if it contains a space, it was meant to be a positional
    if ' ' in arg_string:
        return None
</code></pre>
</blockquote>
<p><a href="http://bugs.python.org/issue9334" rel="nofollow noreferrer">http://bugs.python.org/issue9334</a> <code>argparse does not accept options taking arguments beginning with dash (regression from optparse)</code> is an old and long bug/issue on the topic.</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution is to accept arbitrary arguments - there's an example in argparse's doc <a href="https://docs.python.org/3/library/argparse.html#nargs" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<p>argparse.REMAINDER. All the remaining command-line arguments are gathered into a list. This is commonly useful for command line utilities that dispatch to other command line utilities:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser(prog='PROG')
&gt;&gt;&gt; parser.add_argument('--foo')
&gt;&gt;&gt; parser.add_argument('command')
&gt;&gt;&gt; parser.add_argument('args', nargs=argparse.REMAINDER)
&gt;&gt;&gt; print(parser.parse_args('--foo B cmd --arg1 XX ZZ'.split()))
Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')
</code></pre>
</div>
<span class="comment-copy">Look at the <code>sys.argv</code>.  Do the quotes make it through to the parser or are they swallowed by the shell?</span>
<span class="comment-copy">Thanks for the (cross question) answer! It seems just padding these quoted args with a space and attempting to instruct my users about this workaround will have to do for now</span>
<span class="comment-copy">This is an interesting solution - however I believe it would be better (at least for my application) not to accept arbitrary command arguments. At least with the workaround of padding with a space the users still have to intentionally use the <code>-A</code> argument</span>
