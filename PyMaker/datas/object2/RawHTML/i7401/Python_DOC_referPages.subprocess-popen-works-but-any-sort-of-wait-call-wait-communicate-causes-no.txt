<div class="post-text" itemprop="text">
<p>This works: </p>
<pre><code>def letsExecute():
    import subprocess
    subpr = subprocess.Popen("python " + codeFile + spacedout)
</code></pre>
<p>This causes the program to not respond (I'm running on windows): </p>
<pre><code>def letsExecute():
    import subprocess
    subprocess.call("python " + codeFile + spacedout)
</code></pre>
<p><code>wait</code>, <code>communicate</code> and basically anything that makes the main process wait for the sub process causes the same. I want the main process to quit when the subprocess finishes successfully.</p>
<p>Also, FYI: this function is hooked to a tkinter Button, and this program uses tkinter GUI and a mainloop(). Dunno if this affects this problem, but letting you know anyway.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>There are few issues with your code.</p>
<p><a href="https://docs.python.org/2/library/subprocess.html#subprocess.call" rel="nofollow noreferrer"><code>subprocess.call()</code></a></p>
<blockquote>
<p><em>Run the command described by args. Wait for command to complete, then return the returncode attribute</em>.</p>
</blockquote>
<p><a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.wait" rel="nofollow noreferrer"><code>wait()</code></a> and <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer"><code>communicate()</code></a> are also blocking functions.</p>
<p>Use <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.poll" rel="nofollow noreferrer"><code>poll()</code></a> instead.</p>
<pre><code>subpr = subprocess.Popen(["python", codeFile, spacedout])

while subpr.poll() is None:
    print("Still working...")
    time.sleep(0.1)
</code></pre>
<p>Since you want the GUI thread to be responsive you can start the sub-process on a different thread. something like this,</p>
<pre><code>import subprocess
import threading
import time

def letsExecute():
   t = threading.Thread(target=realExec)
   t.run()

def realExec():
   proc = subprocess.Popen(["python", codeFile, spacedout])

   while proc.poll() is None:
       print("Still working...")
       time.sleep(0.1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, why you trying to <code>subprocess</code> another python script when you can just import it?</p>
<p>Anyway, you problem stems from the fact that any of <code>call</code>, <code>wait</code> and <code>communicate</code> waits for termination of <code>subprocess</code> if <code>timeout</code> parameter is ommited. Because of this <code>tkinter</code> application unable to refresh itself and <code>mainloop</code> is unreachable for code flow.</p>
<p>If you have something complicated in your mind - take a look at <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer"><code>threading</code></a>, <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> and <a href="https://stackoverflow.com/a/16031801/6634373">this</a> topic.</p>
<p>If you want just terminate the main process when the subprocess finishes - take a look at thoose snippets:</p>
<p><strong>test.py:</strong></p>
<pre><code>import time

time.sleep(5)
</code></pre>
<p><strong>main.py:</strong></p>
<pre><code>try:
    import tkinter as tk
except ImportError:
    import Tkinter as tk

import subprocess

class App(tk.Tk):
    def __init__(self, *args, **kwargs):
        tk.Tk.__init__(self, *args, **kwargs)

        self.button = tk.Button(self, text='Start', command=self.start_test_process)
        self.button.pack()
        self.process = None

    def continuous_check(self):
        status = self.process.poll()

        if status is None:
            print('busy')
            self.after(500, self.continuous_check)
        elif status == 0:
            print('successfully finished')
            self.destroy()
        else:
            print('something went wrong')

    def start_test_process(self):
        self.process = subprocess.Popen('python test.py')
        self.continuous_check()


app = App()
app.mainloop()
</code></pre>
<p>The main idea here in keep <code>mainloop</code> reachable for code with combination of <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.poll" rel="nofollow noreferrer"><code>poll</code></a> and <a href="http://effbot.org/tkinterbook/widget.htm#Tkinter.Widget.after-method" rel="nofollow noreferrer"><code>after</code></a> methods.</p>
</div>
