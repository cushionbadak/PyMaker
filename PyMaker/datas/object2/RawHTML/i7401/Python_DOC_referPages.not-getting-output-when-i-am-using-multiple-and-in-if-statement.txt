<div class="post-text" itemprop="text">
<p>Below is my simple code for matching IP in python</p>
<pre><code>import os
import sys
import re
str = "192.168.4.2"
match = re.search("(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})", str)
if (    match.group(1) &lt;= "255" and match.group(2) &lt;= "255" and
        match.group(3) &lt;= "255" and match.group(4) &lt;= "255") :
    print "yes IP matched"
else :
    print "no have not matched"
</code></pre>
<p>I am getting below output</p>
<pre><code>no have not matched
</code></pre>
<p>I am not able to find why I am getting this output. </p>
</div>
<div class="post-text" itemprop="text">
<p>Because you are comparing <code>strings</code> which will compare by the first digit, for example:</p>
<pre><code>print '4' &lt;= '255'
</code></pre>
<p>will output</p>
<pre><code>False
</code></pre>
<p>You need to type cast each of the operands to <code>int()</code> in order to compare digits</p>
</div>
<div class="post-text" itemprop="text">
<p>You're comparing the matched string with another string, comparison is <strong>lexicographical</strong>, which is not what you want.</p>
<p>You should cast the output to int and compare with an int:</p>
<pre><code>if int(match.group(1)) &lt;= 255 and ... :
    print "yes IP matched"
else :
    print "no have not matched"
</code></pre>
<p>OTOH, if on Python 3, you may consider using the <a href="https://docs.python.org/3/library/ipaddress.html" rel="nofollow noreferrer"><code>ipaddress</code></a> library:</p>
<pre><code>import ipaddress

try:
   ipaddress.IPv4Address(addr)
   print("yes IP matched")
except ipaddress.AddressValueError:
   print("no have not matched")
</code></pre>
</div>
<span class="comment-copy">I'm not 100% sure, but I think you have to remove the ticks (") around your 255</span>
<span class="comment-copy">@ThomasMey, the matched substrings are <i>strings</i>. <code>'192' &lt; 255</code> isn't more correct than <code>'192' &lt; '255'</code> is.</span>
<span class="comment-copy">@CharlesDuffy Yeah, as Moses has pointed out, he has to wrap the match.group in a int(..) too for the comparison to work.</span>
<span class="comment-copy">If you import regex, you can use this without having to do math checks. <code>r'(?|0?0?(\d)|0?([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.(?|0?0?(\d)|0?([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.(?|0?0?(\d)|0?([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.(?|0?0?(\d)|0?([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))'</code></span>
<span class="comment-copy">There's a backport for <code>ipaddress</code> in Python: <a href="https://pypi.python.org/pypi/py2-ipaddress" rel="nofollow noreferrer">py2-ipaddress</a>.</span>
