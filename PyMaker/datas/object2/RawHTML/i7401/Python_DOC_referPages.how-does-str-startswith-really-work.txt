<div class="post-text" itemprop="text">
<p>I've been playing for a bit with <code>startswith()</code> and I've discovered something interesting:</p>
<pre><code>&gt;&gt;&gt; tup = ('1', '2', '3')
&gt;&gt;&gt; lis = ['1', '2', '3', '4']
&gt;&gt;&gt; '1'.startswith(tup)
True
&gt;&gt;&gt; '1'.startswith(lis)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: startswith first arg must be str or a tuple of str, not list
</code></pre>
<p>Now, the error is obvious and casting the list into a tuple will work just fine as it did in the first place:</p>
<pre><code>&gt;&gt;&gt; '1'.startswith(tuple(lis))
True
</code></pre>
<p>Now, my question is: why the <em>first argument must be str or a tuple of str prefixes, but not a list</em> of str prefixes?</p>
<p>AFAIK, the Python code for <code>startswith()</code> might look like this:</p>
<pre><code>def startswith(src, prefix):
    return src[:len(prefix)] == prefix
</code></pre>
<p>But that just confuses me more, because even with it in mind, it still shouldn't make any difference whether is a list or tuple. What am I missing ?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is technically no reason to accept other sequence types, no. The <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/unicodeobject.c#L13301-L13344" rel="noreferrer">source code</a> roughly does this:</p>
<pre><code>if isinstance(prefix, tuple):
    for substring in prefix:
        if not isinstance(substring, str):
            raise TypeError(...)
        return tailmatch(...)
elif not isinstance(prefix, str):
    raise TypeError(...)
return tailmatch(...)
</code></pre>
<p>(where <a href="https://github.com/python/cpython/blob/v3.6.1/Objects/unicodeobject.c#L9518-L9583" rel="noreferrer"><code>tailmatch(...)</code></a> does the actual matching work).</p>
<p>So yes, any iterable would do for that <code>for</code> loop. But, all the other string test APIs (as well as <code>isinstance()</code> and <code>issubclass()</code>) that take multiple values also only accept tuples, and this tells you as a user of the API that it is safe to assume that the value <em>won't be mutated</em>. You can't mutate a tuple but the method could in theory mutate the list.</p>
<p>Also note that you <em>usually</em> test for a fixed number of prefixes or suffixes or classes (in the case of <code>isinstance()</code> and <code>issubclass()</code>); the implementation is not suited for a <em>large</em> number of elements. A tuple implies that you have a limited number of elements, while lists can be arbitrarily large.</p>
<p>Next, if any iterable or sequence type would be acceptable, then that would include strings; a single string is <em>also</em> a sequence. Should then a single string argument be treated as separate characters, or as a single prefix?</p>
<p>So in other words, it's a limitation to self-document that the sequence won't be mutated, is consistent with other APIs, it carries an implication of a limited number of items to test against, and removes ambiguity as to how a single string argument should be treated.</p>
<p>Note that this was brought up before on the Python Ideas list; see <a href="https://mail.python.org/pipermail//python-ideas/2014-January/024660.html" rel="noreferrer">this thread</a>; Guido van Rossum's main argument there is that you either special case for single strings or for only accepting a tuple. He picked the latter and doesn't see a need to change this.</p>
</div>
<div class="post-text" itemprop="text">
<p>This has already been suggested on Python-ideas a couple of years back see: <a href="https://mail.python.org/pipermail//python-ideas/2014-January/024660.html" rel="noreferrer"><code>str.startswith</code> taking any iterator instead of just tuple</a> and GvR had <a href="https://mail.python.org/pipermail//python-ideas/2014-January/024661.html" rel="noreferrer">this to say</a>:</p>
<blockquote>
<p>The current behavior is intentional, and the ambiguity of strings
  themselves being iterables is the main reason. Since <code>startswith()</code> is
  almost always called with a literal or tuple of literals anyway, I see
  little need to extend the semantics.</p>
</blockquote>
<p>In addition to that, there seemed to be no real motivation as to why to do this. </p>
<p>The current approach keeps things simple and fast, 
<a href="https://github.com/python/cpython/blob/286e1c15ceb28a76d8ef4fe7111718317c9ccaf5/Objects/unicodeobject.c#L13396" rel="noreferrer"><code>unicode_startswith</code></a> (and <code>endswith</code>) check for a tuple argument and then for a string one. They then call <a href="https://github.com/python/cpython/blob/286e1c15ceb28a76d8ef4fe7111718317c9ccaf5/Objects/unicodeobject.c#L9512" rel="noreferrer"><code>tailmatch</code></a> in the appropriate direction. This is, arguably, very easy to understand in its current state, even for strangers to C code. </p>
<p>Adding other cases will only lead to more bloated and complex code for little benefit while also requiring similar changes to any other parts of the unicode object. </p>
</div>
<div class="post-text" itemprop="text">
<p>On a similar note, here is an <a href="https://youtu.be/-TdrFjDJn5E?t=42m17s" rel="nofollow noreferrer">excerpt from a talk by core developer, Raymond Hettinger</a> discussing API design choices regarding certain string methods, including <a href="https://docs.python.org/3/library/stdtypes.html#str.startswith" rel="nofollow noreferrer">recent changes to the <code>str.startswith</code> signature</a>.  While he briefly mentions this fact that <code>str.startswith</code> accepts a string or tuple of strings and does not expound, the talk is informative on the decisions and pain points both core developers and contributors have dealt with leading up to the present API.</p>
</div>
<span class="comment-copy">To answer your title question literally, you could just look at the source code.</span>
<span class="comment-copy">You can see the source code for the implementation of CPython <a href="https://github.com/python/cpython/blob/master/Objects/unicodeobject.c?utf8=%E2%9C%93#L13395-L13438" rel="nofollow noreferrer">here</a>. It explicitly checks for tuples and unicode objects.</span>
<span class="comment-copy">No down vote, but I think Guido's argument is the more interesting reason. Once you've established that is it simpler and sufficient to support either a  string or one specific container, mutability explains why that container should be a tuple rather than a list.</span>
<span class="comment-copy">1. There idea that accepting a tuple and not a list is an indicator of whether you mutate the input seems made-up on the spot. Plenty of functions accept list inputs and don't mutate them, it's not a good reason to violate duck-typing.  2. tuples implying a limited number of elements also seems made up on the spot - they can be arbitrarily large just the same as lists can. The point that there would need to be a special-casing for string anyway (because it's also a sequence) is the important one, imo - other fluff could be removed from the answer?</span>
<span class="comment-copy">@wim: are you telling me that I make up reasons on the spot, or that the Python devs do? Also, I'll just quote Guido on this before I drop any further discussion: <a href="https://mail.python.org/pipermail//python-ideas/2014-January/024664.html" rel="nofollow noreferrer"><i>All in all I hope you will give up your push for this feature. It just doesn't seem all that important</i></a>, as I agree.</span>
<span class="comment-copy">Your reasons - there doesn't seem evidence for such claims (1., 2.) from Python dev. I'm also in agreement that it doesn't seem all that important to bother addressing such a minor annoyance.</span>
