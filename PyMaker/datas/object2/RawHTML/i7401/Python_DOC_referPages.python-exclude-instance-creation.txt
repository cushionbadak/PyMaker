<div class="post-text" itemprop="text">
<p>I have some trouble with Python class creations. My task is to create objects using some parse method. But I want to turn off basic class creation using <code>__init__</code></p>
<p>For example, I have </p>
<pre><code>class A:
   @classmethod
   def create_from_file(cls, file):
     # Create instance form file...
     return self
</code></pre>
<p>This gives me an opportunity to create object using command like this</p>
<p><code>a = A.create_from_file()</code></p>
<p>But this code provides me a chance to create instance using <code>__init__</code></p>
<p><code>a = A()</code> won't raise an exception...</p>
<p>When I try to add own <code>__init__</code> method, my parse function also raises an exception.</p>
<pre><code> class A:
   def __init__(self):
      raise NotImplementedError

   @classmethod
   def create_from_file(cls, file):
     # Create instance form file...
     return self
</code></pre>
<p>How I can fix this trouble, and what is the most Pythonic way to write this classes?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__init__</code> is not responsible for creating a instance. It is a hook method that Python calls for you <strong>after</strong> the instance is already created. You can't prevent instance creation from there. Besides, you don't want to prevent <em>all</em> instance creation, even your <code>classmethod</code> has to create an instance <em>at some point</em>.</p>
<p>Since all you want to do is raise an exception when your factory method is <em>not</em> used to create the instance, it's still fine to raise an exception in <code>__init__</code> method. That'll prevent the new instance from being assigned anywhere. What you need to do then is distinguish between direct access, and your factory method being used.</p>
<p>You could achieve this is several different ways. You could use a "secret" token that only the factory method passes in:</p>
<pre><code>_token = object()  # unique token to flag factory use

class A:
    def __init__(self, data, _from_factory=None):
        if _from_factory is not _token:
            raise TypeError(f"Can't create {type(self).__name__!r} objects directly")
        self._data = data

    @classmethod
    def create_from_file(cls, file):
        data = file.read()
        return cls(data, _from_factory=_token)
</code></pre>
<p>The <code>classmethod</code> still creates an instance, the <code>__init__</code> is still called for that instance, and no exception is raised because the right token was passed in.</p>
<p>You could make your class an implementation detail of the module and only provide a public factory <em>function</em>:</p>
<pre><code>def create_from_file(cls, file):
    data = file.read()
    return _A(data)

class _A:
    def __init__(self, data):
        self._data = data
</code></pre>
<p>Now the public API only gives you <code>create_from_file()</code>, the leading underscore tells developers that <code>_A()</code> is an internal name and should not be relied on outside of the module.</p>
<p>Actual instance creation is the responsibility of the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>object.__new__</code> method</a>; you could also use that method to prevent new instances to be created. You could use the same token approach as I showed above, <em>or</em> you could bypass it altogether by using <code>super()</code> to call the original overridden implementation:</p>
<pre><code>class A:
    def __new__(cls, *args, **kwargs):
        raise TypeError(f"Can't create {cls.__name__!r} objects directly")

    def __init__(self, data):
        self._data = data

    @classmethod
    def create_from_file(cls, file):
        data = file.read()
        # Don't use __new__ *on this class*, but on the next one in the
        # MRO. We'll have to manually apply __init__ now.
        instance = super().__new__(cls)
        instance.__init__(data)
        return instance
</code></pre>
<p>Here a direct call to <code>A()</code> will raise an exception, but by using <code>super().__new__</code> in the <code>classmethod</code> we bypass the <code>A.__new__</code> implementation.</p>
<p>Note: <code>__new__</code> is implicitly made a <code>staticmethod</code>, so we have to manually pass in the <code>cls</code> argument when we call it from the <code>classmethod</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you only have one method to create the object, just make that the constructor. That is, instead of</p>
<pre><code>@classmethod
def create_from_file(cls, file):
  # Create instance form file...
  return self
</code></pre>
<p>you would have</p>
<pre><code>def __init__(self, file):
  # Create instance form file...
</code></pre>
<p>If there are several different methods of creating an object, it's still typically going to be the case that one of them is more fundamental than any other - in other words, that the arguments to other methods can be "converted" into the arguments to the one method. For example, you might have <code>create_from_file()</code>, <code>create_from_url()</code>, and <code>create_from_string()</code>, where the former two methods basically read the content of the file or URL and then do the same thing with it that <code>create_from_string()</code> does. So just turn <code>create_from_string()</code> into <code>__init__()</code>, and have the other two methods read the file or URL and call the constructor with the content.</p>
<p>If you really don't have a single "fundamental" way of creating the object, it's probably worth considering whether you should have different subclasses of a base class.</p>
</div>
<span class="comment-copy"><code>__init__</code> doesn't create instances. It is a hook method called <b>after</b> the instance is already created. You want to look at <code>__new__</code> instead.</span>
<span class="comment-copy">In this case, I'd have the class method pass in a 'secret' sentinel object  (<code>_token = object()</code> and <code>return cls(..., _from_factory=_token)</code>) then have <code>__init__</code> check for this: <code>def __init__(..., _from_factory=None):</code> and <code>if _from_factory is not _token: raise TypeError('Can only be created with A.create_from_file()</code>)`.</span>
<span class="comment-copy">@MartijnPieters  Can you please describe more or named this trick that I can google it?</span>
<span class="comment-copy">What I would do is overwrite the <code>__init__</code> method after parsing/setup/whatever, once you're sure you won't ever need to create an instance again. For instance, at the end of your parsing, define a <code>fail</code> function that only raises a <code>NotImplementedError</code>: <code>def fail(*args, **kwargs): raise NotImplementedError</code>. Then, change the value of the <code>__init__</code> attribute of class <code>A</code>: <code>A.__init__ = fail</code>. This is valid only if there's a precise point after which you absolutely want to disallow any instanciation of the object.</span>
<span class="comment-copy">Maybe I do not describe the problem at all, but in future, I have more than one method for creating, like <code>from_file</code>, <code>from_object</code> etc. But I need to close any other instance creation methods.</span>
<span class="comment-copy">Thanks for this answer it's really helpful. In my case, this code didn't raise an exception if you want to create an instance using simple form <code>A()</code> , only that you need is to add the parameter into <code>__init__</code> -&gt; <code>A(some_file)</code>.In my case, I need to exclude this situation</span>
<span class="comment-copy">@ArtemKryvonis If you add a parameter to the constructor, as I was saying to do, it <i>will</i> raise an exception when you call <code>A()</code>. (Note that you still need the object parameter <code>self</code> as well as the passed parameter <code>file</code>.)</span>
