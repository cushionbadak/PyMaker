<div class="post-text" itemprop="text">
<p>I am fairly new to Python and would appreciate some help for a project I am working on for work.<br/>
I have a dictionary of lists and want to traverse the dictionary and check if any values of the lists are the same.  </p>
<pre><code>dict={'one':[1,2,3], 'two':[3,4,5], 'three':[5,6,7]}
</code></pre>
<p>I need to check the list value of 'one' and check to see if in 'two' and 'three', then check 'two' values are in 'three' and so on.  Then I need to print out the key and values that are the same.
ie.</p>
<pre><code>3 - 'one' 'two'
5 - 'two' 'three'
</code></pre>
<p>Not sure the best way to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can take the combination of keys using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> and find the itersection of values for pairwise keys:</p>
<pre><code>from itertools import combinations

dct = {'one':[1,2,3], 'two':[3,4,5], 'three':[5,6,7]}

for k1, k2 in combinations(dct, 2):
    s = set(dct[k1]).intersection(dct[k2])
    for x in s:
        print("{2} - '{0}' '{1}'".format(k1, k2, x))
</code></pre>
<hr/>
<pre><code>3 - 'one' 'two'
5 - 'two' 'three'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A nice way to do it in pure python is to iterate over all possible values in the resulting lists. Create a dictionary that maps each value to the keys associated with it.</p>
<pre><code>d ={'one':[1,2,3], 'two':[3,4,5], 'three':[5,6,7]}

results = dict()

for key in d.keys():
    for value in d[key]:
        if value in results:
            results[value].append(key)
        else:
            results[value] = [key]
</code></pre>
<p>Now, when you call results, you will get a dictionary that looks like</p>
<pre><code>{1: ['one'],
 2: ['one'],
 3: ['two', 'one'],
 4: ['two'],
 5: ['three', 'two'],
 6: ['three'],
 7: ['three']}
</code></pre>
<p>We can then go through the results and only print out the ones with multiple associated keys.</p>
<pre><code>for number, strings in results.items():
    if len(strings) &gt; 1:
        print number, strings
</code></pre>
<p>Giving you:</p>
<pre><code>3 ['two', 'one']
5 ['three', 'two']
</code></pre>
<p>This way of doing it should be fast since it's linear with respect to the total length of the combined lists from the original dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>new_data = {}
data_dict = {'one':[1,2,3], 'two':[3,4,5], 'three':[5,6,7]}

for key,values in data_dict.items():
   for value in values:
        new_data.setdefault(value,[]).append(key)

print new_data
</code></pre>
<p>I guess is how i would do it... theres trickier and cooler ways but this is simple to understand and i think the smallest big-O</p>
</div>
<div class="post-text" itemprop="text">
<p>You can turn the dictionary into a list of tuples then 
iteratively compare the first tuple in the list to the
remaining tuples in the list like this:</p>
<pre><code>data = {'one':[1,2,3], 'two':[3,4,5], 'three':[5,6,7]}

search = list(data.items())

while search:
    target = search.pop(0)
    for candidate in search:
         for item in target[1]:
            if item in candidate[1]:
                 print (item, target[0], candidate[0])
3 one two
5 two three        
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for v in set(sum(dict.values(), [])):
    keys = [k for k in dict if v in dict[k]]
    print("{:d} - {:s}".format(v, "'" + "' '".join(keys) + "'"))
</code></pre>
</div>
<span class="comment-copy">oh you changed the problem statement ... like almost entirely</span>
<span class="comment-copy">lol except he totally changed the problem statement (+1 all the same... I had almost this same thing typed up but ...)</span>
<span class="comment-copy">Thanks works great.</span>
<span class="comment-copy">@czach123 If you find this answer useful, you may consider accepting it.</span>
