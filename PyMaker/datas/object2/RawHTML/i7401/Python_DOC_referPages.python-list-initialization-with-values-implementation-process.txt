<div class="post-text" itemprop="text">
<p>How is the Python list initialization with square brackets implemented? Does it call some preexisting function, such as <code>__setitem__</code>, one by one until the list is created or is there a separate function that takes in a variable number of arguments and creates a list?</p>
<pre><code>l = [1, 2, 3, 4, 5]
</code></pre>
<p>For example, how is the above list created? I am interested in the process by which the list is constructed in the source code. Either the actual code itself, or the steps that are carried out to store the list into memory.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can compile that particular code snippet and examine the byte code with <code>dis</code>:</p>
<pre><code>In [1]: import dis

In [2]: code = compile('l = [1, 2, 3, 4, 5]', '', 'exec')

In [3]: dis.dis(code)
  1           0 LOAD_CONST               0 (1)
              3 LOAD_CONST               1 (2)
              6 LOAD_CONST               2 (3)
              9 LOAD_CONST               3 (4)
             12 LOAD_CONST               4 (5)
             15 BUILD_LIST               5
             18 STORE_NAME               0 (l)
             21 LOAD_CONST               5 (None)
             24 RETURN_VALUE
</code></pre>
<p>Particularly line 15, <code>BUILD_LIST</code>, where the list is actually built. No constructor or function is actually called, as is in this case:</p>
<pre><code>In [1108]: dis.dis(compile('l = list()', '', 'exec'))
  1           0 LOAD_NAME                0 (list)
              3 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
              6 STORE_NAME               1 (l)
              9 LOAD_CONST               0 (None)
             12 RETURN_VALUE
</code></pre>
<p>Where you see in line 3, <code>CALL_FUNCTION</code>, the call is made to the <code>list</code> class' constructor.</p>
<p>The grammar of the language parses the source code to build the parse tree such that, the list is created and ready to use at runtime.</p>
<hr/>
<p>For details on the implementation of list objects, have a look <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="nofollow noreferrer">here</a>.</p>
<p>Edit: Found the implementation detail for the bytecode. <a href="https://hg.python.org/cpython/file/3.3/Python/ceval.c#l790" rel="nofollow noreferrer">Here</a> it is. <code>BUILD_LIST</code>:</p>
<pre><code>TARGET(BUILD_LIST)
        x =  PyList_New(oparg);
        if (x != NULL) {
            for (; --oparg &gt;= 0;) {
                w = POP();
                PyList_SET_ITEM(x, oparg, w);
            }
            PUSH(x);
            DISPATCH();
        }
        break;
</code></pre>
<p>Contrast with <code>CALL_FUNCTION</code>:</p>
<pre><code>TARGET(CALL_FUNCTION)
        {
            PyObject **sp;
            PCALL(PCALL_ALL);
            sp = stack_pointer;
#ifdef WITH_TSC
            x = call_function(&amp;sp, oparg, &amp;intr0, &amp;intr1);
#else
            x = call_function(&amp;sp, oparg);
#endif
            stack_pointer = sp;
            PUSH(x);
            if (x != NULL)
                DISPATCH();
            break;
        }
</code></pre>
<p>The latter makes an actual function call while the former allocates the object with <code>PyList_New</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as the language spec is concerned, it builds a list, and there are no promises about how it does that. If you were hoping for a public hook to customize the process or something, nope. You can't do that.</p>
<p>If you want to see how the implementation happens to work for the Python version you're on, you can dig down. For example, on CPython 3.6, with <code>dis</code>, the Python disassembler:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(lambda: [1,2,3,4,5])
  1           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (2)
              4 LOAD_CONST               3 (3)
              6 LOAD_CONST               4 (4)
              8 LOAD_CONST               5 (5)
             10 BUILD_LIST               5
             12 RETURN_VALUE
</code></pre>
<p>You can see a <code>BUILD_LIST</code> opcode with argument <code>5</code>. This pops 5 values off the Python bytecode argument stack and builds a list out of them.</p>
<p>Looking at the 3.6 <a href="https://github.com/python/cpython/blob/3.6/Python/ceval.c#L2552" rel="nofollow noreferrer">source</a> for <code>BUILD_LIST</code>:</p>
<pre><code>TARGET(BUILD_LIST) {
    PyObject *list =  PyList_New(oparg);
    if (list == NULL)
        goto error;
    while (--oparg &gt;= 0) {
        PyObject *item = POP();
        PyList_SET_ITEM(list, oparg, item);
    }
    PUSH(list);
    DISPATCH();
}
</code></pre>
<p>we can see that it allocates the list object with <code>PyList_New</code> and sets items with <code>PyList_SET_ITEM</code>, routines that are part of the <a href="https://docs.python.org/3/c-api/list.html" rel="nofollow noreferrer">C API</a> for lists. No Python-side APIs are involved - no lookup of the <code>list</code> name, no <code>__setitem__</code> or <code>append</code>.</p>
</div>
<span class="comment-copy">Neither; it just <i>is</i> a list, like <code>5</code> is an integer and not a parameter to an integer constructor. No Python function is called. Or were you looking for CPython implementation details or something?</span>
<span class="comment-copy">I was looking for the CPython implementation details...maybe not the source code itself, but the process the code goes through to store the list in memory. I'll edit the question to clarify this.</span>
<span class="comment-copy">CPython is open source.  I believe <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c#L142" rel="nofollow noreferrer">this</a> may be what you're looking for</span>
<span class="comment-copy">I haven't fully looked through it but that is exactly what I need to answer my question, thanks!</span>
