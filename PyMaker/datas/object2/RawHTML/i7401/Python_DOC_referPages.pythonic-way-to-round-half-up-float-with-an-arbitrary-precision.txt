<div class="post-text" itemprop="text">
<p>First of all I would like to mention that this question is not a duplicate of:</p>
<p><a href="https://stackoverflow.com/questions/31258464/python-rounding-inconsistently">Python Rounding Inconsistently</a></p>
<p><a href="https://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior">Python 3.x rounding behavior</a></p>
<p>I know about IEEE 754 and I know that:</p>
<blockquote>
<p>The simple "always round 0.5 up" technique results in a slight bias toward the higher number. With large numbers of calculations, this can be significant. The Python 3.0 approach eliminates this issue.</p>
</blockquote>
<p>I agree that ROUND_HALF_UP is inferior method to the one implemented by default in Python. Nevertheless there are people who do not know that and one needs to use that method if the specs require that. Easy way to make this work is:</p>
<pre><code>def round_my(num, precission):
    exp  = 2*10**(-precission)
    temp = num * exp
    if temp%2 &lt; 1:
        return int(temp - temp%2)/exp
    else:
        return int(temp - temp%2 + 2)/exp
</code></pre>
<p>But my consideration is that <strong>this is not Pythonic</strong>... According to the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer">docs</a> I should use something like:</p>
<pre><code>def round_my(num, pricission):
    N_PLACES = Decimal(10) ** pricission       # same as Decimal('0.01')
    # Round to n places
    Decimal(num).quantize(N_PLACES)
</code></pre>
<p>The problem is that this would not pass all test cases:</p>
<pre><code>class myRound(unittest.TestCase):
    def test_1(self):
        self.assertEqual(piotrSQL.round_my(1.53, -1), 1.5)
        self.assertEqual(piotrSQL.round_my(1.55, -1), 1.6)
        self.assertEqual(piotrSQL.round_my(1.63, -1), 1.6)
        self.assertEqual(piotrSQL.round_my(1.65, -1), 1.7)
        self.assertEqual(piotrSQL.round_my(1.53, -2), 1.53)
        self.assertEqual(piotrSQL.round_my(1.53, -3), 1.53)
        self.assertEqual(piotrSQL.round_my(1.53,  0), 2)
        self.assertEqual(piotrSQL.round_my(1.53,  1), 0)
        self.assertEqual(piotrSQL.round_my(15.3,  1), 20)
        self.assertEqual(piotrSQL.round_my(157.3,  2), 200)
</code></pre>
<p>Because of the nature of conversion between float and decimal and because quantize does not seem to be working for exponents like 10 or 100. Is there a Pythonic way to do this?</p>
<p>And I know that I could just add infinitesimally small number and <code>round(num+10**(precission-20),-pricission)</code> would work but this is so wrong that "the puppies would die"...</p>
</div>
<div class="post-text" itemprop="text">
<p>As you said that doesn't work if you try to <a href="https://docs.python.org/3/library/decimal.html#decimal.Decimal.quantize" rel="nofollow noreferrer"><code>quantize</code></a> with numbers greater than <code>1</code>:</p>
<pre><code>&gt;&gt;&gt; Decimal('1.5').quantize(Decimal('10'))
Decimal('2')
&gt;&gt;&gt; Decimal('1.5').quantize(Decimal('100'))
Decimal('2')
</code></pre>
<p>But you can simply divide, quantize and multiply:</p>
<pre><code>from decimal import Decimal, ROUND_HALF_UP

def round_my(num, precision):
    N_PLACES = Decimal(10) ** precision
    # Round to n places
    return (Decimal(num) / N_PLACES).quantize(1, ROUND_HALF_UP) * N_PLACES
</code></pre>
<p>However that only passes the tests if you input <code>Decimal</code> and compare to <code>Decimal</code>:</p>
<pre><code>assert round_my('1.53', -1) == Decimal('1.5')
assert round_my('1.55', -1) == Decimal('1.6')
assert round_my('1.63', -1) == Decimal('1.6')
assert round_my('1.65', -1) == Decimal('1.7')
assert round_my('1.53', -2) == Decimal('1.53')
assert round_my('1.53', -3) == Decimal('1.53')
assert round_my('1.53',  0) == Decimal('2')
assert round_my('1.53',  1) == Decimal('0')
assert round_my('15.3',  1) == Decimal('20')
assert round_my('157.3',  2) == Decimal('200')
</code></pre>
<hr/>
<p>As noted in the comments it's possible to use scientific notation decimals as "working" quantize arguments, which simplifies the function:</p>
<pre><code>def round_my(num, precision):
    quant_level = Decimal('1e{}'.format(precision))
    return Decimal(num).quantize(quant_level, ROUND_HALF_UP) 
</code></pre>
<p>This also passes the test cases mentioned above.</p>
</div>
<span class="comment-copy">You know that for example <code>1.65</code> wouldn't qualify for "rounding up" because it's really <code>1.649999999999999911182158029987...</code>?</span>
<span class="comment-copy">I know - that is why I have written: "Because of the nature of converssion between float and decimal" - but you are right I should have been more precise. On the other hand I am now wondering that I probably should have just omitted the floats and performed all the calculations on decimal numbers...</span>
<span class="comment-copy">No, that's not the problem. The problem is that you have <code>float</code>s at all. There is no way to recover the string that created a float. Keep them as strings or Decimals throughout your code to avoid that "one" trap</span>
<span class="comment-copy">Sorry - I have eddited my reply before you have posed yours... Yes - you are correct... Your answear closes the issue.</span>
<span class="comment-copy">Quantizing with <code>Decimal('1e1')</code> rather than <code>Decimal('10')</code> should work as expected.</span>
<span class="comment-copy">@MarkDickinson That seems to work. I'm a bit surprised, do you know why that works?</span>
<span class="comment-copy">The <code>quantize</code> method uses the exponent of the second argument to determine how to quantize. It's a bit of a strange design, but it's what's in the specification that the <code>decimal</code> module is based on. (So quantizing with <code>Decimal('2e1')</code> or <code>Decimal('13e1')</code> would also work.)</span>
