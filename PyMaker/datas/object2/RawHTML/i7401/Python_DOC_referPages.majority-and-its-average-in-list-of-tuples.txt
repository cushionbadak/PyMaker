<div class="post-text" itemprop="text">
<p>Suppose the following list of tuples representing sentiment estimates from 3 different methods:</p>
<pre><code>[('pos', 0.2), ('neu', 0.1), ('pos', 0.4)]
</code></pre>
<p>I was wondering what is the most efficient way to find the majority sentiment, and for this to calculate its average, i.e.:</p>
<pre><code>result=('pos', 0.3)
</code></pre>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools

l = [('pos', 0.2), ('neu', 0.1), ('pos', 0.4)]
</code></pre>
<p>You can first group by the sentiment (note they need to be sorted first)</p>
<pre><code>sentiments = [list(j[1]) for j in itertools.groupby(sorted(l), lambda i: i[0])]
# sentiments = [[('neu', 0.1)], [('pos', 0.2), ('pos', 0.4)]]
</code></pre>
<p>Then figure out which sentiment is most common (aka has the longest group)</p>
<pre><code>majority = max(sentiments, key=len)
# majority = [('pos', 0.2), ('pos', 0.4)]
</code></pre>
<p>Then lastly compute the average</p>
<pre><code>values = [i[1] for i in majority]
average = (majority[0][0], sum(values)/len(values))
# average = ('pos', 0.30000000000000004)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections</code></a> and the <a href="https://docs.python.org/3/library/statistics.html?highlight=statistics#module-statistics" rel="nofollow noreferrer"><code>statistics</code></a> module you could do this:</p>
<pre><code>from collections import Counter
from statistics import mean

lst = [('pos', 0.2), ('neu', 0.1), ('pos', 0.4)]
count = Counter(item[0] for item in lst)  # Counter({'pos': 2, 'neu': 1})
maj = count.most_common(1)[0][0]          # pos
mn = mean(item[1] for item in lst if item[0] == maj)
result = (maj, mn)

print(result)  # ('pos', 0.30000000000000004)
</code></pre>
<p>although given you are looking for efficiency i prefer <a href="https://stackoverflow.com/a/45101900/4954037">CoryKramer's answer</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import collections

reports = [('pos', 0.2), ('neu', 0.1), ('pos', 0.4)]

oracle = collections.defaultdict(list)
for mood, score in reports:
    oracle[mood].append(score)

counts = {mood: len(scores) for mood, scores in oracle.items()}

mood = max(counts) # gives `'pos'`

sum(oracle[mood]) / len(oracle[mood]) # gives 0.3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Its better to use Dictionary. Define a nested dictionary where 'key' is the sentiment name and value is a dictionary which contains : 'numbers'(key) which is the list of sentiment values(value) and 'count'(key) for the number of sentiment's occurrence(value). example:</p>
<pre><code>sentiment['pos']['numbers'] = [0.2,0.4]
sentiment['pos']['count'] = 2
sentiment={'pos':{'numbers':[0.2,0.4],'count':2},'neu':{'numbers':`[0.1],'count:1'}}`
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>sorted_tuples = sorted(my_tuple_list, key = lambda x : x[-1] , reverse = True)

majority_sentiment=  sorted_tuples[0][0]
majority_sentiment_score = 0
num_items = 0

for sentiment_tup in sorted_tuples:
    if sentiment_tup[0] == majority_sentiment:
        majority_sentiment_score+= sentiment_tup[1]
        num_items +=1

avg_sentiment_score = majority_sentiment_score/num_items

result= (majority_sentiment,avg_sentiment_score)
</code></pre>
<p>That should do.</p>
</div>
<span class="comment-copy">Can you use NumPy or Pandas?</span>
<span class="comment-copy">In what way do you want it to be efficient? Efficient use of CPU time, memory or developer time?</span>
<span class="comment-copy">CPU time. The sentiments are fetched from thousands of API calls per second. Thanks</span>
<span class="comment-copy">Using <code>l</code> as a variable name is a leading cause of cancer.</span>
<span class="comment-copy">Thank you for this - I was wondering if a solution along the lines of <a href="https://stackoverflow.com/questions/31212260/group-and-compute-the-average-in-list-of-tuples">this answer</a> would be an overkill for this case, but apparently it's not.</span>
<span class="comment-copy">Thanks for your answer and the pointer</span>
<span class="comment-copy">Try changing <code>'neu'</code> to <code>'zeu'</code>. That breaks it.</span>
<span class="comment-copy">Thanks - that's very comprehensive</span>
<span class="comment-copy">This finds just one item from the majority and it does not compute its average. Also <code>sorted(my_tuple_list, key = lambda x : x[-1] , reverse = True)[1]</code> returns the other 'pos' element</span>
<span class="comment-copy">Ah I misread the question. Will edit.</span>
