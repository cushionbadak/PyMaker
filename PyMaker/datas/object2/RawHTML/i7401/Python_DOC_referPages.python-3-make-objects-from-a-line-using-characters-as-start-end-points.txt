<div class="post-text" itemprop="text">
<p>Consider the line below read in from a txt file:</p>
<p><strong>EDIT</strong>: The text file has thousands of lines just like the one below:      TAG1=1494947148,1,d,ble,0,2,0,0&amp;TAG2[]=0,229109531800552&amp;TAG2[]=0,22910953180055 ...</p>
<p>In the line there would be some data that corresponds to <code>TAG1</code> and lots of data that have <code>&amp;TAG2</code> at their start. </p>
<p>I want to make a dictionary that has further dictionaries within it, like</p>
<pre><code>{
  {'TAG1':1494947148,1,d,ble,0,2,0,0}
  {'TAG2:
     {'1': 0, '2':229109531800552}
     {'1': 0, '2':22910953180055}
  }
   .
   .
}
</code></pre>
<p>How do I split the string starting at <code>TAG1</code> and stopping just before the ampersand before <code>TAG2</code>? Does python allow some way to check if a certain character(s) has been encountered and stop/start there? </p>
</div>
<div class="post-text" itemprop="text">
<p>I would turn them into a dictionary of string key and list of values.  It doesn't matter if a tag has one or more items, just lists would make parsing them simple.  You can further process the result dictionary if you find that necessary.</p>
<p>The code will discard the [] in tag names, as they all turned to list anyway.</p>
<pre><code>from itertools import groupby
from operator import itemgetter
import re
s = "TAG1=1494947148,1,d,ble,0,2,0,0&amp;TAG2[]=0,229109531800552&amp;TAG2[]=0,22910953180055"
splitted = map(re.compile("(?:\[\])?=").split, s.split("&amp;"))
tag_values = groupby(sorted(splitted, key=itemgetter(0)), key=itemgetter(0))
result = {t: [c[1].split(',') for c in v] for t, v in tag_values}
</code></pre>
<p>And when you print the result, you get:</p>
<pre><code>print(result)
{'TAG2': [['0', '229109531800552'], ['0', '22910953180055']], 'TAG1': [['1494947148', '1', 'd', 'ble', '0', '2', '0', '0']]}
</code></pre>
<p><strong>How it works</strong></p>
<pre><code>splitted = map(re.compile("(?:\[\])?=").split, s.split("&amp;"))
</code></pre>
<p>first you split the line with &amp;.  That will turn the line into little chunks like "TAG2[]=0,229109531800552", then map turns each chunk into two parts removing the = or []= between them.</p>
<pre><code>tag_values = groupby(sorted(splitted, key=itemgetter(0)), key=itemgetter(0))
</code></pre>
<p>Because of the <code>map</code> function, splitted is now a iterable that will return lists of two items when consumed.  We further sort then group them with the tag(the string on the left of =).  Now we have <code>tag_values</code> with keys represent tags and each tag paired with all the matching values(including the tag).  Still an iterable though, which means all the thing we talked about haven't really happend yet, except for <code>s.split("&amp;")</code></p>
<pre><code>result = {t: [c[1].split(',') for c in v] for t, v in tag_values}
</code></pre>
<p>The last line uses both list and dictionary comprehension.  We want to turn the result into a dict of tag and list of values.  The curly brackets are dictionary comprehension.  The inner variables <code>t</code> and <code>v</code> are extracted from <code>tag_values</code> where <code>t</code> is the tag and <code>v</code> is the grouped matching values(again tag included). At the beginning of the curly bracket <code>t:</code> means use <code>t</code> as a dictionary key, after the column would be the key's matching value.</p>
<p>We want to turn the dictionary value to a list of lists.  The square brackets are the list comprehension that consumes the iterable <code>v</code> and turn it into a list.  Variable <code>c</code> represent each item in <code>v</code>, and finally because <code>c</code> has two items, the tag and the string values, by using <code>c[1].split(',')</code> we take the value part and split it right into a list. And there is your result.</p>
<p><strong>Further Reading</strong></p>
<p>You really ought to get familiar with <a href="https://docs.python.org/3/tutorial/datastructures.html#tut-listcomps" rel="nofollow noreferrer">list/dict comprehension</a> and <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-generator_expression" rel="nofollow noreferrer">generator expression</a>, also take a look at <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="nofollow noreferrer">yield</a> if you want to get more things done with python, and learn itertools, functools, operator along the way.  Basically just functional programming stuff, python is not a pure functional language though, these are just some powerful metaphors you can use.  Read up on some functional languages like haskell that would also improve your python skills.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this might what you need:</p>
<pre><code>import json
data = "TAG1=1494947148,1,d,ble,0,2,0,0&amp;TAG2[]=0,229109531800552&amp;TAG2[]=0,22910953180055"
items = data.split("&amp;")
res ={}
for item in items:
    key, value = item.split("=")
    key = key.replace("[]","")
    values = value.split(",")
    if key in res:
        res[key].append(values)
    else:
        res[key] = [values]
print(res)
print(json.dumps(res))
</code></pre>
<p>The results:</p>
<pre><code>{'TAG1': [['1494947148', '1', 'd', 'ble', '0', '2', '0', '0']], 
 'TAG2': [['0', '229109531800552'], ['0', '22910953180055']]}
{"TAG1": [["1494947148", "1", "d", "ble", "0", "2", "0", "0"]], 
 "TAG2": [["0", "229109531800552"], ["0", "22910953180055"]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may helps you </p>
<pre><code>string = 'TAG1=1494947148,1,d,ble,0,2,0,0&amp;TAG2[]=0,229109531800552'
data = map(str,string.split('&amp;'))
print data
in_data_dic= {}
for i in data:
    in_data = map(str,i.split('='))
    in_data_dic[in_data[0]] = in_data[1]
    in_data=[]

print in_data_dic
</code></pre>
<hr/>
<pre><code>output 
{'TAG2[]': '0,229109531800552', 'TAG1': '1494947148,1,d,ble,0,2,0,0'}
</code></pre>
</div>
<span class="comment-copy">Your question is not clear. Please give a complete input file and desired output that encapsulates your problem. See <a href="http://stackoverflow.com/help/mcve">How to create a Minimal, Complete, and Verifiable example</a>. Also state your assumptions explicitly. Will the character after <code>TAG1</code> definitely be an equals sign? Will the character before <code>TAG2</code> definitely be an ampersand? Is it possible those characters will have other uses in the file? And so on.</span>
<span class="comment-copy">@RoryDaulton please see edits.</span>
<span class="comment-copy">It makes sense to store list of lists as dictionary values.  There is no clear advantage using dictionary for the values.  You are using numbers as keys to dictionary, there are not so much different from using index and lists.</span>
<span class="comment-copy">This is great, but one minor issue: code works fine for <code>TAG1</code>, but for <code>TAG2</code>, it is joining all the v lists together into one big list.</span>
<span class="comment-copy">@omrakhur I've modified the code, hope that's what you want.  Every item is a list of list now.</span>
<span class="comment-copy">that's great! Could you explain the <code>result</code> line for a newbie like me? Thanks!</span>
<span class="comment-copy">@omrakhur see edit</span>
