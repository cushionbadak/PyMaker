<div class="post-text" itemprop="text">
<p>I wonder whether there is a shortcut to make a simple list out of list of lists in Python.</p>
<p>I can do that in a for loop, but maybe there is some cool "one-liner"? I tried it with <em>reduce</em>, but I get an error.</p>
<p><strong>Code</strong></p>
<pre><code>l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
reduce(lambda x, y: x.extend(y), l)
</code></pre>
<p><strong>Error message</strong></p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in &lt;lambda&gt;
AttributeError: 'NoneType' object has no attribute 'extend'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given a list of lists <code>l</code>,</p>
<p><code>flat_list = [item for sublist in l for item in sublist]</code></p>
<p>which means:</p>
<pre><code>flat_list = []
for sublist in l:
    for item in sublist:
        flat_list.append(item)
</code></pre>
<p>is faster than the shortcuts posted so far. (<code>l</code> is the list to flatten.)</p>
<p>Here is the corresponding function:</p>
<pre><code>flatten = lambda l: [item for sublist in l for item in sublist]
</code></pre>
<p>As evidence, you can use the <code>timeit</code> module in the standard library:</p>
<pre><code>$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'
10000 loops, best of 3: 143 usec per loop
$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'
1000 loops, best of 3: 969 usec per loop
$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'reduce(lambda x,y: x+y,l)'
1000 loops, best of 3: 1.1 msec per loop
</code></pre>
<p>Explanation: the shortcuts based on <code>+</code> (including the implied use in <code>sum</code>) are, of necessity, <code>O(L**2)</code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., <code>I * (L**2)/2</code>.</p>
<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="http://docs.python.org/2/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list2d = [[1,2,3],[4,5,6], [7], [8,9]]
&gt;&gt;&gt; merged = list(itertools.chain(*list2d))
</code></pre>
<p>or, on Python &gt;=2.6, use <a href="http://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable()</code></a> which doesn't require unpacking the list:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list2d = [[1,2,3],[4,5,6], [7], [8,9]]
&gt;&gt;&gt; merged = list(itertools.chain.from_iterable(list2d))
</code></pre>
<p>This approach is arguably more readable than <code>[item for sublist in l for item in sublist]</code> and appears to be faster too:</p>
<pre><code>[me@home]$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;import itertools' 'list(itertools.chain.from_iterable(l))'
10000 loops, best of 3: 24.2 usec per loop
[me@home]$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'
10000 loops, best of 3: 45.2 usec per loop
[me@home]$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'
1000 loops, best of 3: 488 usec per loop
[me@home]$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'reduce(lambda x,y: x+y,l)'
1000 loops, best of 3: 522 usec per loop
[me@home]$ python --version
Python 2.7.3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note from the author</strong>: This is inefficient. But fun, because <a href="https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science" rel="noreferrer">monoids</a> are awesome. It's not appropriate for production Python code.</p>
<pre><code>&gt;&gt;&gt; sum(l, [])
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>This just sums the elements of iterable passed in the first argument, treating second argument as the initial value of the sum (if not given, <code>0</code> is used instead and this case will give you an error).</p>
<p>Because you are summing nested lists, you actually get <code>[1,3]+[2,4]</code> as a result of <code>sum([[1,3],[2,4]],[])</code>, which is equal to <code>[1,3,2,4]</code>.</p>
<p>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>I tested most suggested solutions with <a href="https://github.com/nschloe/perfplot" rel="noreferrer">perfplot</a> (a pet project of mine, essentially a wrapper around <code>timeit</code>), and found</p>
<pre><code>functools.reduce(operator.iconcat, a, [])
</code></pre>
<p>to be the fastest solution. (<code>operator.iadd</code> is equally fast.)</p>
<p><a href="https://i.stack.imgur.com/ZJrxd.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/ZJrxd.png"/></a></p>
<hr/>
<p>Code to reproduce the plot:</p>
<pre><code>import functools
import itertools
import numpy
import operator
import perfplot


def forfor(a):
    return [item for sublist in a for item in sublist]


def sum_brackets(a):
    return sum(a, [])


def functools_reduce(a):
    return functools.reduce(operator.concat, a)


def functools_reduce_iconcat(a):
    return functools.reduce(operator.iconcat, a, [])


def itertools_chain(a):
    return list(itertools.chain.from_iterable(a))


def numpy_flat(a):
    return list(numpy.array(a).flat)


def numpy_concatenate(a):
    return list(numpy.concatenate(a))


perfplot.show(
    setup=lambda n: [list(range(10))] * n,
    kernels=[
        forfor, sum_brackets, functools_reduce, functools_reduce_iconcat,
        itertools_chain, numpy_flat, numpy_concatenate
        ],
    n_range=[2**k for k in range(16)],
    logx=True,
    logy=True,
    xlabel='num lists'
    )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from functools import reduce #python 3

&gt;&gt;&gt; l = [[1,2,3],[4,5,6], [7], [8,9]]
&gt;&gt;&gt; reduce(lambda x,y: x+y,l)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>The <code>extend()</code> method in your example modifies <code>x</code> instead of returning a useful value (which <code>reduce()</code> expects).</p>
<p>A faster way to do the <code>reduce</code> version would be</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; l = [[1,2,3],[4,5,6], [7], [8,9]]
&gt;&gt;&gt; reduce(operator.concat, l)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a general approach that applies to <strong>numbers</strong>, <strong>strings</strong>, <strong>nested</strong> lists and <strong>mixed</strong> containers.</p>
<p><strong>Code</strong></p>
<pre><code>from collections import Iterable


def flatten(items):
    """Yield items from any nested iterable; see Reference."""
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flatten(x):
                yield sub_x
        else:
            yield x
</code></pre>
<p>Note: in Python 3, <code>yield from flatten(x)</code> can replace <code>for sub_x in flatten(x): yield sub_x</code></p>
<p><strong>Demo</strong></p>
<pre><code>lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(flatten(lst))                                         # nested lists
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

mixed = [[1, [2]], (3, 4, {5, 6}, 7), 8, "9"]              # numbers, strs, nested &amp; mixed
list(flatten(mixed))
# [1, 2, 3, 4, 5, 6, 7, 8, '9']
</code></pre>
<p><strong>Reference</strong></p>
<ul>
<li>This solution is modified from a recipe in <em>Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.</em></li>
<li>Found an earlier <a href="https://stackoverflow.com/a/2158532/4531270">SO post</a>, possibly the original demonstration.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p><strong>I take my statement back. sum is not the winner. Although it is faster when the list is small. But the performance degrades significantly with larger lists.</strong> </p>
<pre><code>&gt;&gt;&gt; timeit.Timer(
        '[item for sublist in l for item in sublist]',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]] * 10000'
    ).timeit(100)
2.0440959930419922
</code></pre>
<p>The sum version is still running for more than a minute and it hasn't done processing yet!</p>
<p>For medium lists:</p>
<pre><code>&gt;&gt;&gt; timeit.Timer(
        '[item for sublist in l for item in sublist]',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]] * 10'
    ).timeit()
20.126545906066895
&gt;&gt;&gt; timeit.Timer(
        'reduce(lambda x,y: x+y,l)',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]] * 10'
    ).timeit()
22.242258071899414
&gt;&gt;&gt; timeit.Timer(
        'sum(l, [])',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]] * 10'
    ).timeit()
16.449732065200806
</code></pre>
<p>Using small lists and timeit: number=1000000</p>
<pre><code>&gt;&gt;&gt; timeit.Timer(
        '[item for sublist in l for item in sublist]',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]]'
    ).timeit()
2.4598159790039062
&gt;&gt;&gt; timeit.Timer(
        'reduce(lambda x,y: x+y,l)',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]]'
    ).timeit()
1.5289170742034912
&gt;&gt;&gt; timeit.Timer(
        'sum(l, [])',
        'l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]]'
    ).timeit()
1.0598428249359131
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to flatten a data-structure where you don't know how deep it's nested you could use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html" rel="noreferrer"><code>iteration_utilities.deepflatten</code></a><sup>1</sup></p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import deepflatten

&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; list(deepflatten(l, depth=1))
[1, 2, 3, 4, 5, 6, 7, 8, 9]

&gt;&gt;&gt; l = [[1, 2, 3], [4, [5, 6]], 7, [8, 9]]
&gt;&gt;&gt; list(deepflatten(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>It's a generator so you need to cast the result to a <code>list</code> or explicitly iterate over it.</p>
<hr/>
<p>To flatten only one level and if each of the items is itself iterable you can also use <a href="https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html" rel="noreferrer"><code>iteration_utilities.flatten</code></a> which itself is just a thin wrapper around <a href="https://docs.python.org/library/itertools.html#itertools.chain.from_iterable" rel="noreferrer"><code>itertools.chain.from_iterable</code></a>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import flatten
&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; list(flatten(l))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<hr/>
<p>Just to add some timings (based on Nico Schlömer answer that didn't include the function presented in this answer):</p>
<p><a href="https://i.stack.imgur.com/3D8uN.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/3D8uN.png"/></a></p>
<p>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</p>
<p>The results show that if the iterable contains only a few inner iterables then <code>sum</code> will be fastest, however for long iterables only the <code>itertools.chain.from_iterable</code>, <code>iteration_utilities.deepflatten</code> or the nested comprehension have reasonable performance with <code>itertools.chain.from_iterable</code> being the fastest (as already noticed by Nico Schlömer).</p>
<pre><code>from itertools import chain
from functools import reduce
from collections import Iterable  # or from collections.abc import Iterable
import operator
from iteration_utilities import deepflatten

def nested_list_comprehension(lsts):
    return [item for sublist in lsts for item in sublist]

def itertools_chain_from_iterable(lsts):
    return list(chain.from_iterable(lsts))

def pythons_sum(lsts):
    return sum(lsts, [])

def reduce_add(lsts):
    return reduce(lambda x, y: x + y, lsts)

def pylangs_flatten(lsts):
    return list(flatten(lsts))

def flatten(items):
    """Yield items from any nested iterable; see REF."""
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            yield from flatten(x)
        else:
            yield x

def reduce_concat(lsts):
    return reduce(operator.concat, lsts)

def iteration_utilities_deepflatten(lsts):
    return list(deepflatten(lsts, depth=1))


from simple_benchmark import benchmark

b = benchmark(
    [nested_list_comprehension, itertools_chain_from_iterable, pythons_sum, reduce_add,
     pylangs_flatten, reduce_concat, iteration_utilities_deepflatten],
    arguments={2**i: [[0]*5]*(2**i) for i in range(1, 13)},
    argument_name='number of inner lists'
)

b.plot()
</code></pre>
<hr/>
<p><sup>1 Disclaimer: I'm the author of that library</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>Why do you use extend?</p>
<pre><code>reduce(lambda x, y: x+y, l)
</code></pre>
<p>This should work fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>There seems to be a confusion with <code>operator.add</code>! When you add two lists together, the correct term for that is <code>concat</code>, not add. <code>operator.concat</code> is what you need to use.</p>
<p>If you're thinking functional, it is as easy as this::</p>
<pre><code>&gt;&gt;&gt; list2d = ((1, 2, 3), (4, 5, 6), (7,), (8, 9))
&gt;&gt;&gt; reduce(operator.concat, list2d)
(1, 2, 3, 4, 5, 6, 7, 8, 9)
</code></pre>
<p>You see reduce respects the sequence type, so when you supply a tuple, you get back a tuple. let's try with a list::</p>
<pre><code>&gt;&gt;&gt; list2d = [[1, 2, 3],[4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; reduce(operator.concat, list2d)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>Aha, you get back a list.</p>
<p>How about performance::</p>
<pre><code>&gt;&gt;&gt; list2d = [[1, 2, 3],[4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; %timeit list(itertools.chain.from_iterable(list2d))
1000000 loops, best of 3: 1.36 µs per loop
</code></pre>
<p>from_iterable is pretty fast! But it's no comparison to reduce with concat.</p>
<pre><code>&gt;&gt;&gt; list2d = ((1, 2, 3),(4, 5, 6), (7,), (8, 9))
&gt;&gt;&gt; %timeit reduce(operator.concat, list2d)
1000000 loops, best of 3: 492 ns per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason your function didn't work: the extend extends array in-place and doesn't return it. You can still return x from lambda, using some trick:</p>
<pre><code>reduce(lambda x,y: x.extend(y) or x, l)
</code></pre>
<p>Note: extend is more efficient than + on lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider installing the <a href="https://github.com/erikrose/more-itertools" rel="noreferrer"><code>more_itertools</code></a> package.</p>
<pre><code>&gt; pip install more_itertools
</code></pre>
<p>It ships with an implementation for <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten" rel="noreferrer"><code>flatten</code></a> (<a href="https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten" rel="noreferrer">source</a>, from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noreferrer">itertools recipes</a>):</p>
<pre><code>import more_itertools


lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(more_itertools.flatten(lst))
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>As of version 2.4, you can flatten more complicated, nested iterables with <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse" rel="noreferrer"><code>more_itertools.collapse</code></a> (<a href="https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse" rel="noreferrer">source</a>, contributed by  abarnet).</p>
<pre><code>lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
list(more_itertools.collapse(lst)) 
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

lst = [[1, 2, 3], [[4, 5, 6]], [[[7]]], 8, 9]              # complex nesting
list(more_itertools.collapse(lst))
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def flatten(l, a):
    for i in l:
        if isinstance(i, list):
            flatten(i, a)
        else:
            a.append(i)
    return a

print(flatten([[[1, [1,1, [3, [4,5,]]]], 2, 3], [4, 5],6], []))

# [1, 1, 1, 3, 4, 5, 2, 3, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An bad feature of Anil's function above is that it requires the user to always manually specify the second argument to be an empty list <code>[]</code>. This should instead be a default. Due to the way Python objects work, these should be set inside the function, not in the arguments.</p>
<p>Here's a working function:</p>
<pre><code>def list_flatten(l, a=None):
    #check a
    if a is None:
        #initialize with empty list
        a = []

    for i in l:
        if isinstance(i, list):
            list_flatten(i, a)
        else:
            a.append(i)
    return a
</code></pre>
<p>Testing:</p>
<pre><code>In [2]: lst = [1, 2, [3], [[4]],[5,[6]]]

In [3]: lst
Out[3]: [1, 2, [3], [[4]], [5, [6]]]

In [11]: list_flatten(lst)
Out[11]: [1, 2, 3, 4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Following seem simplest to me:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
&gt;&gt;&gt; print (np.concatenate(l))
[1 2 3 4 5 6 7 8 9]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>matplotlib.cbook.flatten()</code> will work for nested lists even if they nest more deeply than the example.</p>
<pre><code>import matplotlib
l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]
print(list(matplotlib.cbook.flatten(l)))
l2 = [[1, 2, 3], [4, 5, 6], [7], [8, [9, 10, [11, 12, [13]]]]]
print list(matplotlib.cbook.flatten(l2))
</code></pre>
<p>Result:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
</code></pre>
<p>This is 18x faster than underscore._.flatten:</p>
<pre><code>Average time over 1000 trials of matplotlib.cbook.flatten: 2.55e-05 sec
Average time over 1000 trials of underscore._.flatten: 4.63e-04 sec
(time for underscore._)/(time for matplotlib.cbook) = 18.1233394636
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The accepted answer did not work for me when dealing with text-based lists of variable lengths. Here is an alternate approach that did work for me.</p>
<pre><code>l = ['aaa', 'bb', 'cccccc', ['xx', 'yyyyyyy']]
</code></pre>
<h3>Accepted answer that did <em>not</em> work:</h3>
<pre><code>flat_list = [item for sublist in l for item in sublist]
print(flat_list)
['a', 'a', 'a', 'b', 'b', 'c', 'c', 'c', 'c', 'c', 'c', 'xx', 'yyyyyyy']
</code></pre>
<h3>New proposed solution that <em>did</em> work for me:</h3>
<pre><code>flat_list = []
_ = [flat_list.extend(item) if isinstance(item, list) else flat_list.append(item) for item in l if item]
print(flat_list)
['aaa', 'bb', 'cccccc', 'xx', 'yyyyyyy']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One can also use NumPy's <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html" rel="nofollow noreferrer">flat</a>:</p>
<pre><code>import numpy as np
list(np.array(l).flat)
</code></pre>
<p>Edit 11/02/2016: Only works when sublists have identical dimensions.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use numpy :<br/>
<code>flat_list = list(np.concatenate(list_of_list))</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Simple code for <a href="https://github.com/serkanyersen/underscore.py" rel="nofollow noreferrer"><code>underscore.py</code></a> package fan</p>
<pre><code>from underscore import _
_.flatten([[1, 2, 3], [4, 5, 6], [7], [8, 9]])
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>It solves all flatten problems (none list item or complex nesting)</p>
<pre><code>from underscore import _
# 1 is none list item
# [2, [3]] is complex nesting
_.flatten([1, [2, [3]], [4, 5, 6], [7], [8, 9]])
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>You can install <a href="https://github.com/serkanyersen/underscore.py" rel="nofollow noreferrer"><code>underscore.py</code></a> with pip</p>
<pre><code>pip install underscore.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def flatten(alist):
    if alist == []:
        return []
    elif type(alist) is not list:
        return [alist]
    else:
        return flatten(alist[0]) + flatten(alist[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Recursive version</p>
<pre><code>x = [1,2,[3,4],[5,[6,[7]]],8,9,[10]]

def flatten_list(k):
    result = list()
    for i in k:
        if isinstance(i,list):

            #The isinstance() function checks if the object (first argument) is an 
            #instance or subclass of classinfo class (second argument)

            result.extend(flatten_list(i)) #Recursive call
        else:
            result.append(i)
    return result

flatten_list(x)
#result = [1,2,3,4,5,6,7,8,9,10]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use <code>numpy.concatenate().tolist()</code> or <code>numpy.concatenate().ravel().tolist()</code>:</p>
<pre><code>import numpy

l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] * 99

%timeit numpy.concatenate(l).ravel().tolist()
1000 loops, best of 3: 313 µs per loop

%timeit numpy.concatenate(l).tolist()
1000 loops, best of 3: 312 µs per loop

%timeit [item for sublist in l for item in sublist]
1000 loops, best of 3: 31.5 µs per loop
</code></pre>
<p>You can find out more here in the docs <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html" rel="nofollow">numpy.concatenate</a> and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" rel="nofollow">numpy.ravel</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Fastest solution I have found (for large list anyway):</p>
<pre><code>import numpy as np
#turn list into an array and flatten()
np.array(l).flatten()
</code></pre>
<p>Done! You can of course turn it back into a list by executing list(l)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>flat_list = []
for i in list_of_list:
    flat_list+=i
</code></pre>
<p>This Code also works fine as it just extend the list all the way. Although it is much similar but only have one for loop. So It have less complexity than adding 2 for loops.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another unusual approach that works for hetero- and homogeneous lists of integers:</p>
<pre><code>from typing import List


def flatten(l: list) -&gt; List[int]:
    """Flatten an arbitrary deep nested list of lists of integers.

    Examples:
        &gt;&gt;&gt; flatten([1, 2, [1, [10]]])
        [1, 2, 1, 10]

    Args:
        l: Union[l, Union[int, List[int]]

    Returns:
        Flatted list of integer
    """
    return [int(i.strip('[ ]')) for i in str(l).split(',')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I recently came across a situation where I had a mix of strings and numeric data in sublists such as</p>
<pre><code>test = ['591212948',
['special', 'assoc', 'of', 'Chicago', 'Jon', 'Doe'],
['Jon'],
['Doe'],
['fl'],
92001,
555555555,
'hello',
['hello2', 'a'],
'b',
['hello33', ['z', 'w'], 'b']]
</code></pre>
<p>where methods like <code>flat_list = [item for sublist in test for item in sublist]</code> have not worked. So, I came up with the following solution for 1+ level of sublists</p>
<pre><code>def concatList(data):
    results = []
    for rec in data:
        if type(rec) == list:
            results += rec
            results = concatList(results)
        else:
            results.append(rec)
    return results
</code></pre>
<p>And the result</p>
<pre><code>In [38]: concatList(test)
Out[38]:
 Out[60]:
['591212948',
'special',
'assoc',
'of',
'Chicago',
'Jon',
'Doe',
'Jon',
'Doe',
'fl',
92001,
555555555,
'hello',
'hello2',
'a',
'b',
'hello33',
'z',
'w',
'b']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This may not be the most efficient way but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python3.5) and recursion.</p>
<pre><code>def make_list_flat (l):
    flist = []
    flist.extend ([l]) if (type (l) is not list) else [flist.extend (make_list_flat (e)) for e in l]
    return flist

a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]
flist = make_list_flat(a)
print (flist)
</code></pre>
<p>The output is</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
</code></pre>
<p>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable <code>flist</code> and then rolls back it to the parent. Whenever <code>flist</code> is returned, it is extended to the parent's <code>flist</code> in the list comprehension. Therefore, at the root, a flat list is returned.</p>
<p>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl <code>flist</code>, like below.</p>
<pre><code>a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]
flist = []
def make_list_flat (l):
    flist.extend ([l]) if (type (l) is not list) else [make_list_flat (e) for e in l]

make_list_flat(a)
print (flist)
</code></pre>
<p>The output is again</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
</code></pre>
<p>Although I am not sure at this time about the efficiency.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Note</strong>: Below applies to Python 3.3+ because it uses <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="nofollow noreferrer"><code>yield_from</code></a>.  <code>six</code> is also a third-party package, though it is stable.  Alternately, you could use <code>sys.version</code>.</p>
<hr/>
<p>In the case of <code>obj = [[1, 2,], [3, 4], [5, 6]]</code>, all of the solutions here are good, including list comprehension and <code>itertools.chain.from_iterable</code>.</p>
<p>However, consider this slightly more complex case:</p>
<pre><code>&gt;&gt;&gt; obj = [[1, 2, 3], [4, 5], 6, 'abc', [7], [8, [9, 10]]]
</code></pre>
<p>There are several problems here:</p>
<ul>
<li>One element, <code>6</code>, is just a scalar; it's not iterable, so the above routes will fail here.</li>
<li>One element, <code>'abc'</code>, <em>is</em> technically iterable (all <code>str</code>s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</li>
<li>The final element, <code>[8, [9, 10]]</code> is itself a nested iterable.  Basic list comprehension and <code>chain.from_iterable</code> only extract "1 level down."</li>
</ul>
<p>You can remedy this as follows:</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; from six import string_types

&gt;&gt;&gt; def flatten(obj):
...     for i in obj:
...         if isinstance(i, Iterable) and not isinstance(i, string_types):
...             yield from flatten(i)
...         else:
...             yield i


&gt;&gt;&gt; list(flatten(obj))
[1, 2, 3, 4, 5, 6, 'abc', 7, 8, 9, 10]
</code></pre>
<p>Here, you check that the sub-element (1) is iterable with <a href="https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243" rel="nofollow noreferrer"><code>Iterable</code></a>, an ABC from <code>itertools</code>, but also want to ensure that (2) the element is <em>not</em> "string-like."</p>
</div>
<div class="post-text" itemprop="text">
<p>A simple recursive method using <code>reduce</code> from <code>functools</code> and the <code>add</code> operator on lists:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; flatten = lambda lst: [lst] if type(lst) is int else reduce(add, [flatten(ele) for ele in lst])
&gt;&gt;&gt; flatten(l)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>The function <code>flatten</code> takes in <code>lst</code> as parameter. It loops all the elements of <code>lst</code> until reaching integers (can also change <code>int</code> to <code>float</code>, <code>str</code>, etc. for other data types), which are added to the return value of the outermost recursion.</p>
<p>Recursion, unlike methods like <code>for</code> loops and monads, is that it is <strong>a general solution not limited by the list depth</strong>. For example, a list with depth of 5 can be flattened the same way as <code>l</code>:</p>
<pre><code>&gt;&gt;&gt; l2 = [[3, [1, 2], [[[6], 5], 4, 0], 7, [[8]], [9, 10]]]
&gt;&gt;&gt; flatten(l2)
[3, 1, 2, 6, 5, 4, 0, 7, 8, 9, 10]
</code></pre>
</div>
<span class="comment-copy">There's an in-depth discussion of this here: <a href="http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html" rel="nofollow noreferrer">rightfootin.blogspot.com/2006/09/more-on-python-flatten.html</a>, discussing several methods of flattening arbitrarily nested lists of lists. An interesting read!</span>
<span class="comment-copy">Some other answers are better but the reason yours fails is that the 'extend' method always returns None. For a list with length 2, it will work but return None. For a longer list, it will consume the first 2 args, which returns None. It then continues with None.extend(&lt;third arg&gt;), which causes this erro</span>
<span class="comment-copy">@shawn-chin solution is the more pythonic here, but if you need to preserve the sequence type, say you have a tuple of tuples rather than a list of lists, then you should use reduce(operator.concat, tuple_of_tuples). Using operator.concat with tuples seems to perform faster than chain.from_iterables with list.</span>
<span class="comment-copy">numpy.array([[1],[2]]).flatten().tolist(), which removes the inner structure and returns the list [1,2]</span>
<span class="comment-copy">Now supported by <a href="https://github.com/MartinThoma/mpu" rel="nofollow noreferrer"><code>mpu</code></a>: <code>import mpu; mpu.datastructures.flatten([1, [2, 3], [4, [5, 6]]])</code> gives <code>[1, 2, 3, 4, 5, 6]</code></span>
<span class="comment-copy">I tried a test with the same data, using <code>itertools.chain.from_iterable</code> :         <code>$ python -mtimeit -s'from itertools import chain; l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'list(chain.from_iterable(l))'</code>.   It runs a bit more than twice as fast as the nested list comprehension that's the fastest of the alternatives shown here.</span>
<span class="comment-copy">I found the syntax hard to understand until I realized you can think of it exactly like nested for loops.  for sublist in l: for item in sublist: yield item</span>
<span class="comment-copy">@BorisChervenkov: Notice that I wrapped the call in <code>list()</code> to realize the iterator into a list.</span>
<span class="comment-copy">[leaf for tree in forest for leaf in tree] might be easier to comprehend and apply.</span>
<span class="comment-copy">@Joel, actually nowadays <code>list(itertools.chain.from_iterable(l))</code> is best -- as noticed in other comments and Shawn's answer.</span>
<span class="comment-copy">@ShawnChin BTW, piece of hardware you had when answering this question, my current workstation is half as fast and is been 4 years.</span>
<span class="comment-copy">The <code>*</code> is the tricky thing that makes <code>chain</code> less straightforward than the list comprehension. You have to know that chain only joins together the iterables passed as parameters, and the * causes the top-level list to be expanded into parameters, so <code>chain</code> joins together all those iterables, but doesn't descend further. I think this makes the comprehension more readable than the use of chain in this case.</span>
<span class="comment-copy">@TimDierks: I'm not sure "this requires you to understand Python syntax" is an argument against using a given technique in Python. Sure, complex usage could confuse, but the "splat" operator is generally useful in many circumstances, and this isn't using it in a particularly obscure way; rejecting all language features that aren't necessarily obvious to beginning users means you're tying one hand behind your back. May as well throw out list comprehensions too while you're at it; users from other backgrounds would find a <code>for</code> loop that repeatedly <code>append</code>s more obvious.</span>
<span class="comment-copy">what about <code>['abcde_', ['_abcde', ['e_abcd', ['de_abc', ['cde_ab', ['bcde_a']]]]]]</code></span>
<span class="comment-copy">This is slower than what Alex proposed, in the context below  <code>_all_altered_nbrs = {"nbr1":{"key1":"src2"},"nbr2":{"key2":"src4"}}  %timeit [ k for key in _all_altered_nbrs.itervalues() for k in key.keys() ] %timeit  reduce(lambda x, y: x.extend(y.keys()) or x, _all_altered_nbrs.itervalues(), []) %timeit  list(itertools.chain(*[src_relation.keys() for src_relation in _all_altered_nbrs.itervalues()]))</code> <code>100000 loops, best of 3: 3.47 µs per loop 		100000 loops, best of 3: 6.74 µs per loop 		100000 loops, best of 3: 12.7 µs per loop</code></span>
<span class="comment-copy">that's pretty neat and clever but I wouldn't use it because it's confusing to read.</span>
<span class="comment-copy">This is a Shlemiel the painter's algorithm <a href="http://www.joelonsoftware.com/articles/fog0000000319.html" rel="nofollow noreferrer">joelonsoftware.com/articles/fog0000000319.html</a> -- unnecessarily inefficient as well as unnecessarily ugly.</span>
<span class="comment-copy">The append operation on lists forms a <b><a href="http://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science" rel="nofollow noreferrer"><code>Monoid</code></a></b>, which is one of the most convenient abstractions for thinking of a <code>+</code> operation in a general sense (not limited to numbers only). So this answer deserves a +1 from me for (correct) treatment of lists as a monoid. <i>The performance is concerning though...</i></span>
<span class="comment-copy">@andrewrk Well, some people think that this is the cleanest way of doing it : <a href="https://www.youtube.com/watch?v=IOiZatlZtGU" rel="nofollow noreferrer">youtube.com/watch?v=IOiZatlZtGU</a> the ones who do not get why this is cool just need to wait a few decades until everybody does it this way :) let's use programming languages (and abstractions) that are discovered and not invented, Monoid is discovered.</span>
<span class="comment-copy">this is a very inefficient way because of the quadratic aspect of the sum.</span>
<span class="comment-copy">For huge nested lists,' list(numpy.array(a).flat)' is the fastest among all functions above.</span>
<span class="comment-copy"><code>reduce(operator.add, l)</code> would be the correct way to do the <code>reduce</code> version. Built-ins are faster than lambdas.</span>
<span class="comment-copy">@agf here is how:    * <code>timeit.timeit('reduce(operator.add, l)', 'import operator; l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]]', number=10000)</code> <b>0.017956018447875977</b>   * <code>timeit.timeit('reduce(lambda x, y: x+y, l)', 'import operator; l=[[1, 2, 3], [4, 5, 6, 7, 8], [1, 2, 3, 4, 5, 6, 7]]', number=10000)</code> <b>0.025218963623046875</b></span>
<span class="comment-copy">This is a Shlemiel the painter's algorithm joelonsoftware.com/articles/fog0000000319.html</span>
<span class="comment-copy">this can use only for <code>integers</code>. But what if list contains <code>string</code>?</span>
<span class="comment-copy">@Freddy: The <code>operator.add</code> function works equally well for both lists of integers and lists of strings.</span>
<span class="comment-copy">I just wrote pretty much the same, because I didn't see your solution ... here is what I looked for  "recursively flatten complete multiple lists" ... (+1)</span>
<span class="comment-copy">@MartinThoma Much appreciated.  FYI, if flattening nested iterables is a common practice for you, there are some third-party packages that handle this well.  This may save from reinventing the wheel. I've mentioned <code>more_itertools</code> among others discussed in this post.  Cheers.</span>
<span class="comment-copy">Nice - was just wondering about a <code>yield from</code> type of construction on python after learning about <code>yield *</code> in es2015.</span>
<span class="comment-copy">replace by <code>if isinstance(el, collections.Iterable) and not isinstance(el, (str, bytes)):</code> to support strings.</span>
<span class="comment-copy">Maybe <code>traverse</code> could also be a good name for this way of a tree, whereas I'd keep it less <i>universal</i> for this answer by sticking to nested lists.</span>
<span class="comment-copy">for a truly miniscule list, e.g. one with 3 sublists, maybe -- but since sum's performance goes with O(N**2) while the list comprehension's goes with O(N), just growing the input list a little will reverse things -- indeed the LC will be "infinitely faster" than sum at the limit as N grows. I was responsible for designing sum and doing its first implementation in the Python runtime, and I still wish I had found a way to effectively restrict it to summing numbers (what it's really good at) and block the "attractive nuisance" it offers to people who want to "sum" lists;-).</span>
<span class="comment-copy"><code>sum</code> no longer works on arbitrary sequences as it starts with <code>0</code>, making <code>functools.reduce(operator.add, sequences)</code> the replacement (aren't we glad they removed <code>reduce</code> from builtins?). When the types are known it might be faster to use <code>type.__add__</code>.</span>
<span class="comment-copy">@YannVernier Thanks for the information. I thought I ran these benchmarks on Python 3.6 and it worked with <code>sum</code>. Do you happen to know on which Python versions it stopped working?</span>
<span class="comment-copy">I was somewhat mistaken. <code>0</code> is just the default starting value, so it works if one uses the <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">start argument</a> to start with an empty list... but it still special cases strings and tells me to use join. It's implementing <code>foldl</code> instead of <code>foldl1</code>. The same issue pops up in 2.7.</span>
<span class="comment-copy">This probably creates many, many, intermediate lists.</span>
<span class="comment-copy">for python3 <code>from functools import reduce</code></span>
<span class="comment-copy">Sorry that's really slow see rest of answers</span>
<span class="comment-copy">This is by far the easiest to understand yet short solution that works on Python 2 and 3. I realise that a lot of Python folks are in data processing where there's huge amounts of data to process and thus care a lot about speed, but when you are writing a shell script and only have a few dozen elements in a few sub-lists, then this is perfect.</span>
<span class="comment-copy">Hmm to be fair second example should be list also (or first tuple ?)</span>
<span class="comment-copy"><code>extend</code> is better used as <code>newlist = []</code>, <code>extend = newlist.extend</code>, <code>for sublist in l: extend(l)</code> as it avoids the (rather large) overhead of the <code>lambda</code>, the attribute lookup on <code>x</code>, and the <code>or</code>.</span>
<span class="comment-copy">Doesn't work for me unless I manually specify <code>a=[]</code>: <code>&gt;&gt;&gt; flatten([[1,2,3],[4,5,6]]) [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; flatten([[1,2,3],[4,5,6]]) [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]</code></span>
<span class="comment-copy">@Jeff My answer was edited by @ deleet ... Check my original answer and it works...</span>
<span class="comment-copy">nice, thanks. I rolled back @deleet's edit</span>
<span class="comment-copy">Yes, it was buggy as I found out later! I did test it, but the bug only happens after the first run. The reason is that the default argument [] gets treated as a consistent object in Python. So next time you run the function, it begins with the list you used last time! Very nasty bug, hard to figure out. In R (which I mostly use) this would have worked due to copy semantics. Does anyone know a Python solution? Having to manually specify an empty list every time is not a good design. I need this function for my own project, so I hope someone knows. :)</span>
<span class="comment-copy">I posted a fixed version now.</span>
<span class="comment-copy">doesn't work with already flat arrays, consider: <code>import numpy as np l = [1, 2, 3] print (np.concatenate(l))</code> <code>ValueError: zero-dimensional arrays cannot be concatenated</code></span>
<span class="comment-copy">I'm not sure what you achieve by downvoting a comment that identifies a flaw in your answer. The voting system is here to help others save their time using answers that work. Yours works only partially as indicated above and makes an assumption on the input being non-flat and doesn't generalize.</span>
<span class="comment-copy">would that be the optimal solution ?</span>
<span class="comment-copy">This will work only for numerical data</span>
<span class="comment-copy">This works for numerical, strings and mixed lists also</span>
<span class="comment-copy">Similarly, you can use <a href="https://github.com/dgilland/pydash" rel="nofollow noreferrer">pydash</a>. I find this version to be much more readable than the list comprehension or any other answers.</span>
<span class="comment-copy">This is super slow.</span>
<span class="comment-copy">Why does it have a module named _? That seems like a bad name. See <a href="https://stackoverflow.com/a/5893946/6605826">stackoverflow.com/a/5893946/6605826</a></span>
<span class="comment-copy">@EL_DON: From underscore.py readme page "Underscore.py is a python port of excellent javascript library underscore.js". I think it's the reason for this name. And yes, It's not a good name for python</span>
<span class="comment-copy">This is wrong, flatten will reduce the dimensions of the nd array to one, but not concatenate the lists inside as one.</span>
<span class="comment-copy">It is already described in <a href="https://stackoverflow.com/a/45323085/4012073">this answer</a></span>
<span class="comment-copy">@ImeshaSudasingha The answer have used 2 for loops instead I am using only one</span>
<span class="comment-copy">That's just a more complicated and a bit slower way of what ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000 already posted before. I reinvented his proposal yesterday, so this approach seems quite popular these days ;)</span>
<span class="comment-copy">Not quite:  <code>wierd_list = [[1, 2, 3], [4, 5, 6], [7], [8, 9], 10]</code> &gt;&gt; <code>nice_list=[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0]</code></span>
<span class="comment-copy">my code as one liner would be :  <code>flat_list = [int(e.replace('[','').replace(']','')) for e in str(deep_list).split(',')]</code></span>
<span class="comment-copy">You are indeed right +1, ᴡʜᴀᴄᴋᴀᴍᴀᴅᴏᴏᴅʟᴇ3000's proposal won't work with multiple digit numbers, I also didn't test this before although it should be obvious. You could simplify your code and write <code>[int(e.strip('[ ]')) for e in str(deep_list).split(',')]</code>. But I'd suggest to stick with Deleet's proposal for real use cases. It doesn't contain hacky type transformations, it's faster and more versatile because it naturally also handles lists with mixed types.</span>
<span class="comment-copy">Unfortunately no. But I saw this code recently here: <a href="http://anandology.com/python-practice-book/functional-programming.html" rel="nofollow noreferrer">Python Practice Book</a> 6.1.2</span>
<span class="comment-copy">If you are still interested in Python 2 compatibility, change <code>yield from</code> to a <code>for</code> loop, e.g. <code>for x in flatten(i): yield x</code></span>
