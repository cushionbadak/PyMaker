<div class="post-text" itemprop="text">
<p>I am trying to understand recursion.</p>
<p>I have this code computes the sum between the range to 2 numbers.</p>
<pre><code>def sum(lower, upper):
    if lower &gt; upper:
       return 0
    else:
        return lower + sum(lower +1, upper)

print(sum(11, 30))
</code></pre>
<p>I am trying to understand where the value of each recursion call is stored.
So if lower is 12 and upper is 30 then where is this 42 stored ?</p>
<p>Thanks
Jason</p>
</div>
<div class="post-text" itemprop="text">
<p>Values of each recursion are stored in the call stack:</p>
<p>You can display the disassembly of your function like this:</p>
<pre><code>def my_sum(lower, upper):
    if lower &gt; upper:
        return 0
    else:
        return lower + my_sum(lower +1, upper)

import dis
dis.dis(my_sum)
</code></pre>
<p>You get:</p>
<pre><code>  2           0 LOAD_FAST                0 (lower)
              2 LOAD_FAST                1 (upper)
              4 COMPARE_OP               4 (&gt;)
              6 POP_JUMP_IF_FALSE       12

  3           8 LOAD_CONST               1 (0)
             10 RETURN_VALUE

  5     &gt;&gt;   12 LOAD_FAST                0 (lower)
             14 LOAD_GLOBAL              0 (my_sum)
             16 LOAD_FAST                0 (lower)
             18 LOAD_CONST               2 (1)
             20 BINARY_ADD
             22 LOAD_FAST                1 (upper)
             24 CALL_FUNCTION            2
             26 BINARY_ADD
             28 RETURN_VALUE
             30 LOAD_CONST               0 (None)
             32 RETURN_VALUE
</code></pre>
<p>The LOAD_FAST routine load the value from the function stack.</p>
<p>This is the same with temporary values.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python, and most other languages, uses a structure called the stack for function calls. If you're unfamiliar with the <a href="https://en.wikibooks.org/wiki/Data_Structures/Stacks_and_Queues" rel="nofollow noreferrer">stack data structure</a>, I would recommend reading up on that. It will give you a solid understanding of how stack's work. </p>
<p>I would recommend checking out <a href="https://www.cs.ucsb.edu/~pconrad/cs8/topics.beta/theStack/01/" rel="nofollow noreferrer">this tutorial for a detailed explanation</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your code written with different naming conventions...</p>
<pre><code>def compute(low, high):
    if low &gt; high:
        return 0
    else:
        return low + compute(low+1, high)
</code></pre>
<p>Given a an integer (low), and another integer that is higher than said integer (high), this code will find the sum between those two integers (inclusive), through recursion.</p>
<p>e.g. <code>&gt;&gt;&gt; compute(6, 9)</code></p>
<p>Above would return 30, by way of recursion, i.e. each time the initial condition is not met, <code>if low &gt; high:</code>, the function is called again, adding 1 to low so that eventually the condition will be met, and when it is (when low is equal to 10) recursion will set in.</p>
<p>Still with the example <code>compute(6, 9)</code> - when low = 10, 0 is returned, previously low was 9, so the expression <code>return low + compute(low+1, high)</code> at this point would be <code>return 9 + 0</code>, now on to the next recursive call, low before 9 was 8 - we just returned 9 from the previous call, so <code>return 8 + 9</code>, returning 17... I think you get the point, this process happens until the initial return statement. Think of it as unwinding a slinky, and then having it wind back to it's initial form.</p>
<p>Note that without your first condition to eventually be met, and the incremental return statement, the function would return the same thing infinitely so that the <code>if</code> condition is never met, or infinitely add 1 to low.</p>
<p>I hope this sheds a little light on recursion.</p>
</div>
<div class="post-text" itemprop="text">
<p>Think of it like a call center. One that advertises that they tell you the sum of numbers in a range you can ask for.</p>
<p>So you call someone there and ask for the sum of the numbers from 12 to 30. That person thinks "Darn that's too complicated for me" and calls the same call center itself to ask for the sum from 13 to 30. That second person still can't do it directly and calls the center <em>again</em> to ask for the sum from 14 to 30. And so on. Eventually someone will receive a call asking for the sum from 31 to 30 and directly reply "Um, that's an empty range, so zero of course". And then it all goes backwards. All the people involved in the call stack, who've been waiting for their answers, now one by one compute their own result and report it to the person who called them. So the replies are "30" (because 30+0), then "59" (because 29+30), then "87" (because 28+59), and so on. Eventually the person <em>you</em> called and asked for 12 to 30, will receive the answer that the sum of 13 to 30 is 387. They add it to 12 and reply to you "399".</p>
<p>In this analogy, there are people who keep their request data in their head while they're waiting for their own answer. Where is all this data stored when this is done in computer programming? Well, on the <a href="https://en.wikipedia.org/wiki/Call_stack" rel="nofollow noreferrer">call stack</a>. It's called a stack because like a stack of papers that you build one at a time and take off one at a time, the calls are made on top of each other and finished in reverse order. And just like that call center, the computer's call stack has a limited size. When you ask about a range that's larger than the number of people in the call center, eventually everyone in the call center will be involved in your request and the last person called will have nobody left to talk to. At this point the system somewhat breaks down. In the computer, that's called a "stack overflow". Just like this site.</p>
</div>
<span class="comment-copy">Just a comment: <code>sum</code> is a <a href="https://docs.python.org/3/library/functions.html#sum" rel="nofollow noreferrer">builtin function</a>: you should choose a different nameâ€¦</span>
<span class="comment-copy">42? Where does that come from? It's not the answer to everything. With those lower and upper, at no point will you have 42 anywhere.</span>
<span class="comment-copy">to really understand this you need to look at how a call stack works.</span>
<span class="comment-copy">yeah, and i didn't look at the code previously. there are a few flaws</span>
<span class="comment-copy">@JasonAruni Huh? No. You're not adding 12 and 30 then. You're adding 12 and the sum of the numbers from 13 to 30, i.e., you're adding 12 and 387.</span>
<span class="comment-copy">I misread the second line... the response has been edited. However it is still an incorrect statement - I believe he intended the initial arguments to be excluded from the sum.</span>
<span class="comment-copy">I think there are many people who say "between" when they mean inclusive. It bugs me a lot, but that's what it is. And I doubt he "intended" anything. That sounds like he wrote that code, which I'm certain he didn't. Btw, "compute" is a bad name as well, as it's very generic. I'd maybe call it "rangesum" (the only downside being that it isn't equivalent to Python's <code>range</code> because of the inclusive upper bound).</span>
<span class="comment-copy">I agree with you regarding his intentions, I was just trying to give him the benefit of the doubt. I wasn't trying to focus so much on naming conventions as I was trying to simplify recursion for him - but you're right, I should have used something less ambiguous. Thanks, Stefan.</span>
