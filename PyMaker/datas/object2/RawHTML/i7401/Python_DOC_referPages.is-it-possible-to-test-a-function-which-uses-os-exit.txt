<div class="post-text" itemprop="text">
<p>I want to test that a function executes <code>os._exit(2)</code> on fail. I have seen many solutions with <code>sys.exit()</code> using <code>SystemExit</code>. I have read both the <a href="https://docs.python.org/3/library/os.html#os._exit" rel="nofollow noreferrer">Python3</a> and the <a href="https://docs.python.org/2/library/os.html#os._exit" rel="nofollow noreferrer">Python2</a> documentation and it seems that <code>os._exit()</code> doesn't use <code>SystemExit</code></p>
<p>Nevertheless, I have tried <a href="https://stackoverflow.com/questions/15672151/is-it-possible-for-a-unit-test-to-assert-that-a-method-calls-sys-exit">this</a> in case it was a misunderstanding of the documentation on my side, but it just exits nosetest, it's not even a test failure :</p>
<pre><code>make: *** [test] Error 2
</code></pre>
<p>This is probably due to the function calling <code>os._exit(2)</code></p>
</div>
<div class="post-text" itemprop="text">
<p><code>os.system()</code> return value contains exit code in higher 8 bits, so you could check exit code of external script this way:</p>
<pre><code>import os

assert os.system('python script.py') &gt;&gt; 8 == 2
</code></pre>
<p>You could also mock <code>os._exit()</code> with <code>sys.exit()</code>:</p>
<pre><code>import os, sys
import script

os._exit = sys.exit
script.tested_method()  # raises SystemExit
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>unittest.mock.MagicMock</code> object makes it easy to simply check whether functions have been called without the need for them to execute their default behaviour.</p>
<pre><code>from unittest import mock
import os

def funcToTest():
    os.exit(2)

def test_func():
    os._exit = mock.MagicMock()
    funcToTest()
    assert os._exit.called
</code></pre>
</div>
<span class="comment-copy">As last resort, if you won't find better solution, just override <code>os._exit</code> method: <a href="https://repl.it/J82h/0" rel="nofollow noreferrer">repl.it/J82h/0</a></span>
<span class="comment-copy">Do you just want to test that the function <i>calls</i> <code>os._exit(2)</code>, or do you want to test the actual exiting?  If the former, you can mock the function along the lines of what bakatrouble suggests.  But if the latter, you'll probably have to write a separate program that calls that function, and test calling that program with <code>os.system</code> or something to verify that it does exit with that code.</span>
<span class="comment-copy">The function I want to test is a custom error function : once called, it logs error messages and then calls <code>os._exit(2)</code>. I would like to test both the logging part and the exiting part. As I'm only supposed to test this module, I can't really touch the code.</span>
<span class="comment-copy">As a side note: if you use <code>os._exit</code> in a function then you probably have something wrong with the architecture. Why can't you raise an exception that is caught at the top level? Killing a process somewhere down the road will backfire at you at some point because you don't finalize states.</span>
<span class="comment-copy">As I said, I'm only a tester, I am not supposed to touch the tested code. In addition, forks are used in this poroject and I've read that os._exit() is often used with forked children.</span>
<span class="comment-copy">It seems that the mock works very well with <a href="https://stackoverflow.com/questions/15672151/is-it-possible-for-a-unit-test-to-assert-that-a-method-calls-sys-exit">the solution</a> I tried. This is a neat little trick for testing I didn't know. Thank you for your help!</span>
<span class="comment-copy">Mocking will do the job, but it won't exactly replicate original behavior. You might assume that <code>os._exit()</code> is already tested via interpreter testing tools though.</span>
