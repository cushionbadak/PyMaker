<div class="post-text" itemprop="text">
<p>I'm developing/testing a package in my local directory. I want to import it in the interpreter (v2.5), but sys.path does not include the current directory. Right now I type in <code>sys.path.insert(0,'.')</code>. Is there a better way? </p>
<p>Also, </p>
<pre><code>from . import mypackage
</code></pre>
<p>fails with this error:</p>
<pre><code>ValueError: Attempted relative import in non-package
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use relative imports only from in a module that was in turn imported as part of a package -- your script or interactive interpreter wasn't, so of course <code>from . import</code> (which means "import from the same package I got imported from") doesn't work. <code>import mypackage</code> will be fine once you ensure the parent directory of <code>mypackage</code> is in <code>sys.path</code> (how you managed to get your current directory <em>away</em> from <code>sys.path</code> I don't know -- do you have something strange in site.py, or...?)</p>
<p>To get your current directory back into <code>sys.path</code> there is in fact no better way than putting it there;-).</p>
</div>
<div class="post-text" itemprop="text">
<p>See the documentation for sys.path:</p>
<p><a href="http://docs.python.org/library/sys.html#sys.path" rel="noreferrer">http://docs.python.org/library/sys.html#sys.path</a></p>
<p>To quote:</p>
<blockquote>
<p>If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), path[0] is the empty string, which directs Python to search modules in the current directory first.</p>
</blockquote>
<p>So, there's no need to monkey with sys.path if you're starting the python interpreter from the directory containing your module.</p>
<p>Also, to import your package, just do:</p>
<pre><code>import mypackage
</code></pre>
<p>Since the directory containing the package is already in sys.path, it should work fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to run an unmodified python script so it imports libraries from a specific local directory you can set the <code>PYTHONPATH</code> environment variable - e.g. in bash:</p>
<pre><code>export PYTHONPATH=/home/user/my_libs
python myscript.py
</code></pre>
<p>If you just want it to import from the current working directory use the <code>.</code> notation:</p>
<pre><code>export PYTHONPATH=.
python myscript.py
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Keep it simple:</p>
<pre><code> try:
     from . import mymodule     # "myapp" case
 except:
     import mymodule            # "__main__" case
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple way to make it work is to run your script from the parent directory using python's <code>-m</code> flag, e.g. <code>python -m packagename.scriptname</code>. Obviously in this situation you need an <code>__init__.py</code> file to turn your directory into a package.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>sys.path</code> should include current directory already.</p>
<p>Try:</p>
<pre><code>import .
</code></pre>
<p>or:</p>
<pre><code>from . import sth
</code></pre>
<p>however it may be not a good practice, so why not just use:</p>
<pre><code>import mypackage
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to import all methods from a particular package/file in the same directory, the correct way to import that is to do <code>from mypackage import *</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Inside a package if there is <strong>setup.py</strong>, then better to install it</p>
<pre><code>pip install -e .
</code></pre>
</div>
<span class="comment-copy">Where did you read that "." was a Python module?</span>
<span class="comment-copy">@Lott: It's a relative import path described here: <a href="http://docs.python.org/reference/simple_stmts.html#the-import-statement" rel="nofollow noreferrer">docs.python.org/reference/…</a></span>
<span class="comment-copy">You may want to look at this definitive guide <a href="https://chrisyeh96.github.io/2017/08/08/definitive-guide-python-imports.html" rel="nofollow noreferrer">chrisyeh96.github.io/2017/08/08/…</a></span>
<span class="comment-copy">Python 2.5 for Ubuntu 8.10 does not have the current directory (empty string) in sys.path for the interpreter. I didn't change anything, so it somehow got shipped that way. I just installed 3.0 and sys.path DOES have '' in sys.path.</span>
<span class="comment-copy">@projectshave, OK, Ubuntu's no doubt got their reasons! I haven't noticed that in 8.04 (what we currently use at work) but maybe I just wasn't paying enough attention.</span>
<span class="comment-copy">I am partially wrong. Python invoked from a shell has the current directory in sys.path. Python invoked from Emacs does not have the current directory. Strange.</span>
<span class="comment-copy">Ah well, then it's Emacs who's got their reasons as opposed to Ubuntu's (as a vim user I don't really know;-). You can conditionally insert '.' in your sys.path iff not there of course.</span>
<span class="comment-copy">@Alex Martelli: Thank you so much! I've been searching and searching for the solution to why my add-on (for Anki) needed a different import statement when being run 'locally' as a script. When I instead added a local_launch() method and imported/launched the whole thing from a script <i>outside</i> the package folder, it worked like a charm!</span>
<span class="comment-copy">It will fail if a similar file name exists somewhere else in the working env.</span>
<span class="comment-copy">@JAR.JAR.beans the current working directory should be the first thing in <code>sys.path</code> so files there should be found before files anywhere else in the working environment.</span>
<span class="comment-copy">Good point. That is, if we run the file from the local directory. In the case it's some other folder, and in the case a change to sys.path is needed - it means <code>sys.path.insert(0, new_path)</code> rather than <code>sys.path.append(new_path)</code>.</span>
<span class="comment-copy">Exporting  PYTHONPATH includes programming outside python (e.g. in bash). Additionally,  in <a href="https://docs.python.org/3/using/cmdline.html" rel="nofollow noreferrer">docs.python.org/3/using/cmdline.html</a> is clearly stated that "<i>default search path is installation dependent</i>".</span>
<span class="comment-copy">I like this solution, it is the most simple. The only remaining question is why did the "only one way to do it" rule has been deemed optional when implementing imports ... Seriously there is about 15 ways to declare and organize the packages, all of which have drawbacks</span>
<span class="comment-copy">Problem with &lt;import mypackage&gt; is that it will load the package from the global python env, it might load the package/file from the local folder, but it could just as well load some other random mypackge that is in the working env.</span>
