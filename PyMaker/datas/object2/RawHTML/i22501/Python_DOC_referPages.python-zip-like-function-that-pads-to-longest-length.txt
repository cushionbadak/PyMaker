<div class="post-text" itemprop="text">
<p>Is there a built-in function that works like <code>zip()</code> but that will pad the results so that the length of the resultant list is the length of the <em>longest</em> input rather than the <em>shortest</em> input?</p>
<pre><code>&gt;&gt;&gt; a=['a1']
&gt;&gt;&gt; b=['b1','b2','b3']
&gt;&gt;&gt; c=['c1','c2']

&gt;&gt;&gt; zip(a,b,c)
[('a1', 'b1', 'c1')]

&gt;&gt;&gt; What command goes here?
[('a1', 'b1', 'c1'), (None, 'b2', 'c2'), (None, 'b3', None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="noreferrer"><code>itertools.zip_longest</code></a></p>
<pre><code>&gt;&gt;&gt; list(itertools.zip_longest(a, b, c))
[('a1', 'b1', 'c1'), (None, 'b2', 'c2'), (None, 'b3', None)]
</code></pre>
<p>You can pad with a different value than <code>None</code> by using the <code>fillvalue</code> parameter:</p>
<pre><code>&gt;&gt;&gt; list(itertools.zip_longest(a, b, c, fillvalue='foo'))
[('a1', 'b1', 'c1'), ('foo', 'b2', 'c2'), ('foo', 'b3', 'foo')]
</code></pre>
<p>With Python 2 you can either use <a href="https://docs.python.org/2/library/itertools.html#itertools.izip_longest" rel="noreferrer"><code>itertools.izip_longest</code></a> (Python 2.6+), or you can use <code>map</code> with <code>None</code>. It is a little known <a href="https://docs.python.org/2/library/functions.html#map" rel="noreferrer">feature of <code>map</code></a> (but <code>map</code> changed in Python 3.x, so this only works in Python 2.x).</p>
<pre><code>&gt;&gt;&gt; map(None, a, b, c)
[('a1', 'b1', 'c1'), (None, 'b2', 'c2'), (None, 'b3', None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python 2.6x use <code>itertools</code> module's <a href="http://docs.python.org/library/itertools.html#itertools.izip_longest" rel="noreferrer"><code>izip_longest</code></a>.</p>
<p>For Python 3 use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="noreferrer"><code>zip_longest</code></a> instead (no leading <code>i</code>).</p>
<pre><code>&gt;&gt;&gt; list(itertools.izip_longest(a, b, c))
[('a1', 'b1', 'c1'), (None, 'b2', 'c2'), (None, 'b3', None)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>non itertools Python 3 solution:</p>
<pre><code>def zip_longest(*lists):
    def g(l):
        for item in l:
            yield item
        while True:
            yield None
    gens = [g(l) for l in lists]    
    for _ in range(max(map(len, lists))):
        yield tuple(next(g) for g in gens)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>non itertools My Python 2 solution:</p>
<pre><code>if len(list1) &lt; len(list2):
    list1.extend([None] * (len(list2) - len(list1)))
else:
    list2.extend([None] * (len(list1) - len(list2)))
</code></pre>
</div>
<span class="comment-copy">Do we not have a non itertools Python 3 solution?</span>
<span class="comment-copy">@PascalvKooten it is not required. <code>itertools</code> is a builtin C module anyway.</span>
<span class="comment-copy">In case you want to make your code both python 2 and python 3 compatible, you can use <code>six.moves.zip_longest</code> instead.</span>
