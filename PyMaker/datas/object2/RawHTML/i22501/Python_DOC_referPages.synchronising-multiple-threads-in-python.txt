<div class="post-text" itemprop="text">
<p>I have a problem where I need <code>x</code> threads to wait until they have all reached a synchronization point. My solution uses the <code>synchronise</code> method below which is called by each threaded function when they need to synchronise.</p>
<p>Is there a better way to do this?</p>
<pre><code>thread_count = 0
semaphore = threading.Semaphore()
event = threading.Event()

def synchronise(count):
    """ All calls to this method will block until the last (count) call is made """
    with semaphore:
        thread_count += 1
        if thread_count == count:
            event.set()

    event.wait()

def threaded_function():
    # Do something

    # Block until 4 threads have reached this point
    synchronise(4)

    # Continue doing something else
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are many ways to synchronize threads.  Many.</p>
<p>In addition to synchronize, you can do things like the following.</p>
<ol>
<li><p>Break your tasks into two steps around the synchronization point.  Start threads doing the pre-sync step.  Then use "join" to wait until all threads finish step 1.  Start new threads doing the post-sync step.  I prefer this, over synchronize.</p></li>
<li><p>Create a queue; acquire a synchronization lock.  Start all threads.  Each thread puts an entry in the queue and waits on the synchronization lock.  The "main" thread sits in a loop dequeueing items from the queue.  When all threads have put an item in the queue, the "main" thread releases the synchronization lock.  All other threads are now free to run again.</p></li>
</ol>
<p>There are a number of interprocess communication (IPC) techniques -- all of which can be used for thread synchronization.</p>
</div>
<div class="post-text" itemprop="text">
<p>The functionality you want is called a "<a href="http://en.wikipedia.org/wiki/Barrier_(computer_science)" rel="nofollow noreferrer">barrier</a>".  (Unfortunately that term has 2 meanings when talking about threading. So if you <a href="http://www.google.com/search?hl=en&amp;client=firefox-a&amp;rls=org.mozilla%3Aen-GB%3Aofficial&amp;hs=dq4&amp;q=barrier+threading+python&amp;btnG=Search" rel="nofollow noreferrer">Google</a> it, just ignore articles that talk about "<a href="http://en.wikipedia.org/wiki/Memory_barrier" rel="nofollow noreferrer">memory barriers</a>" - that's a very different thing).</p>
<p>Your code looks quite reasonable - it's simple and safe.</p>
<p>I couldn't find any "standard" implementations of barriers for Python, so I suggest you keep using your code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Note that Barrier has been implemented <a href="https://docs.python.org/3/whatsnew/3.2.html#threading" rel="nofollow">as of Python 3.2</a></p>
<p>Example of using barriers:</p>
<pre><code>from threading import Barrier, Thread

def get_votes(site):
    ballots = conduct_election(site)
    all_polls_closed.wait()        # do not count until all polls are closed
    totals = summarize(ballots)
    publish(site, totals)

all_polls_closed = Barrier(len(sites))
for site in sites:
    Thread(target=get_votes, args=(site,)).start()
</code></pre>
</div>
<span class="comment-copy">I explored your first suggestion but there was a need to have the threads doing both the before synchronisation and after synchronisation work without splitting the effort into 2 tasks. If I didn't have this constraint your solution would be be ideal.</span>
<span class="comment-copy">Since threads all share the exact same memory, It's not clear why your threads can't be decomposed into two steps.  The information created pre-synch should be completely available for new threads to use post-synch.</span>
