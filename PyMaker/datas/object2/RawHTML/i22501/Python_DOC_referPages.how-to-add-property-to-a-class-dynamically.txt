<div class="post-text" itemprop="text">
<p>The goal is to create a mock class which behaves like a db resultset.</p>
<p>So for example, if a database query returns, using a dict expression, <code>{'ab':100, 'cd':200}</code>, then I would like to see: </p>
<pre><code>&gt;&gt;&gt; dummy.ab
100
</code></pre>
<p>At first I thought maybe I could do it this way:</p>
<pre><code>ks = ['ab', 'cd']
vs = [12, 34]
class C(dict):
    def __init__(self, ks, vs):
        for i, k in enumerate(ks):
            self[k] = vs[i]
            setattr(self, k, property(lambda x: vs[i], self.fn_readyonly))

    def fn_readonly(self, v)
        raise "It is ready only"

if __name__ == "__main__":
    c = C(ks, vs)
    print c.ab
</code></pre>
<p>but <code>c.ab</code> returns a property object instead.</p>
<p>Replacing the <code>setattr</code> line with <code>k = property(lambda x: vs[i])</code> is of no use at all.</p>
<p>So what is the right way to create an instance property at runtime?</p>
<p>P.S. I am aware of an alternative presented in <a href="https://stackoverflow.com/questions/371753/how-is-the-getattribute-method-used"><em>How is the <code>__getattribute__</code> method used?</em></a></p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose I should expand this answer, now that I'm older and wiser and know what's going on.  Better late than never.</p>
<p>You <em>can</em> add a property to a class dynamically.  But that's the catch: you have to add it to the <em>class</em>.</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     pass
... 
&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.a = 3
&gt;&gt;&gt; Foo.b = property(lambda self: self.a + 1)
&gt;&gt;&gt; foo.b
4
</code></pre>
<p>A <code>property</code> is actually a simple implementation of a thing called a <a href="http://docs.python.org/2/reference/datamodel.html#implementing-descriptors" rel="noreferrer">descriptor</a>.  It's an object that provides custom handling for a given attribute, <em>on a given class</em>.  Kinda like a way to factor a huge <code>if</code> tree out of <code>__getattribute__</code>.</p>
<p>When I ask for <code>foo.b</code> in the example above, Python sees that the <code>b</code> defined on the class implements the <em>descriptor protocol</em>â€”which just means it's an object with a <code>__get__</code>, <code>__set__</code>, or <code>__delete__</code> method.  The descriptor claims responsibility for handling that attribute, so Python calls <code>Foo.b.__get__(foo, Foo)</code>, and the return value is passed back to you as the value of the attribute.  In the case of <code>property</code>, each of these methods just calls the <code>fget</code>, <code>fset</code>, or <code>fdel</code> you passed to the <code>property</code> constructor.</p>
<p>Descriptors are really Python's way of exposing the plumbing of its entire OO implementation.  In fact, there's another type of descriptor even more common than <code>property</code>.</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     def bar(self):
...         pass
... 
&gt;&gt;&gt; Foo().bar
&lt;bound method Foo.bar of &lt;__main__.Foo object at 0x7f2a439d5dd0&gt;&gt;
&gt;&gt;&gt; Foo().bar.__get__
&lt;method-wrapper '__get__' of instancemethod object at 0x7f2a43a8a5a0&gt;
</code></pre>
<p>The humble method is just another kind of descriptor.  Its <code>__get__</code> tacks on the calling instance as the first argument; in effect, it does this:</p>
<pre><code>def __get__(self, instance, owner):
    return functools.partial(self.function, instance)
</code></pre>
<p>Anyway, I suspect this is why descriptors only work on classes: they're a formalization of the stuff that powers classes in the first place.  They're even the exception to the rule: you can obviously assign descriptors to a class, and classes are themselves instances of <code>type</code>!  In fact, trying to read <code>Foo.b</code> still calls <code>property.__get__</code>; it's just idiomatic for descriptors to return themselves when accessed as class attributes.</p>
<p>I think it's pretty cool that virtually all of Python's OO system can be expressed in Python.  :)</p>
<p>Oh, and I wrote a <a href="http://me.veekun.com/blog/2012/05/23/python-faq-descriptors/" rel="noreferrer">wordy blog post about descriptors</a> a while back if you're interested.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>The goal is to create a mock class which behaves like a db resultset.</p>
</blockquote>
<p>So what you want is a dictionary where you can spell a['b'] as a.b?</p>
<p>That's easy:</p>
<pre><code>class atdict(dict):
    __getattr__= dict.__getitem__
    __setattr__= dict.__setitem__
    __delattr__= dict.__delitem__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It seems you could solve this problem much more simply with a <a href="http://docs.python.org/library/collections.html#collections.namedtuple" rel="noreferrer"><code>namedtuple</code></a>, since you know the entire list of fields ahead of time.</p>
<pre><code>from collections import namedtuple

Foo = namedtuple('Foo', ['bar', 'quux'])

foo = Foo(bar=13, quux=74)
print foo.bar, foo.quux

foo2 = Foo()  # error
</code></pre>
<p>If you absolutely need to write your own setter, you'll have to do the metaprogramming at the class level; <code>property()</code> doesn't work on instances.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to use a property for that. Just override <code>__setattr__</code> to make them read only.</p>
<pre><code>class C(object):
    def __init__(self, keys, values):
        for (key, value) in zip(keys, values):
            self.__dict__[key] = value

    def __setattr__(self, name, value):
        raise Exception("It is read only!")
</code></pre>
<p>Tada.</p>
<pre><code>&gt;&gt;&gt; c = C('abc', [1,2,3])
&gt;&gt;&gt; c.a
1
&gt;&gt;&gt; c.b
2
&gt;&gt;&gt; c.c
3
&gt;&gt;&gt; c.d
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'C' object has no attribute 'd'
&gt;&gt;&gt; c.d = 42
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in __setattr__
Exception: It is read only!
&gt;&gt;&gt; c.a = 'blah'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 6, in __setattr__
Exception: It is read only!
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I asked a similary question <a href="https://stackoverflow.com/questions/1264833/python-class-factory-to-produce-simple-struct-like-classes">on this Stack Overflow post</a> to create a class factory which created simple types. The outcome was <a href="https://stackoverflow.com/questions/1264833/python-class-factory-to-produce-simple-struct-like-classes/1275088#1275088">this answer</a> which had a working version of the class factory.
Here is a snippet of the answer:</p>
<pre><code>def Struct(*args, **kwargs):
    def init(self, *iargs, **ikwargs):
        for k,v in kwargs.items():
            setattr(self, k, v)
        for i in range(len(iargs)):
            setattr(self, args[i], iargs[i])
        for k,v in ikwargs.items():
            setattr(self, k, v)

    name = kwargs.pop("name", "MyStruct")
    kwargs.update(dict((k, None) for k in args))
    return type(name, (object,), {'__init__': init, '__slots__': kwargs.keys()})

&gt;&gt;&gt; Person = Struct('fname', 'age')
&gt;&gt;&gt; person1 = Person('Kevin', 25)
&gt;&gt;&gt; person2 = Person(age=42, fname='Terry')
&gt;&gt;&gt; person1.age += 10
&gt;&gt;&gt; person2.age -= 10
&gt;&gt;&gt; person1.fname, person1.age, person2.fname, person2.age
('Kevin', 35, 'Terry', 32)
&gt;&gt;&gt;
</code></pre>
<p>You could use some variation of this to create default values which is your goal (there is also an answer in that question which deals with this).</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>How to add property to a python class dynamically?</h1>
</blockquote>
<p>Say you have an object that you want to add a property to. Typically, I want to use properties when I need to begin managing access to an attribute in code that has downstream usage, so that I can maintain a consistent API. Now I will typically add them to the source code where the object is defined, but let's assume you don't have that access, or you need to truly dynamically choose your functions programmatically.</p>
<h2>Create a class</h2>
<p>Using an example based on the <a href="https://docs.python.org/2/library/functions.html#property" rel="nofollow">documentation for <code>property</code></a>, let's create a class of object with a "hidden" attribute and create an instance of it:</p>
<pre><code>class C(object):
    '''basic class'''
    _x = None

o = C()
</code></pre>
<p>In Python, we expect there to be one obvious way of doing things. However, in this case, I'm going to show two ways: with decorator notation, and without.  First, without decorator notation. This may be more useful for the dynamic assignment of getters, setters, or deleters.</p>
<h2>Dynamic (a.k.a. Monkey Patching)</h2>
<p>Let's create some for our class:</p>
<pre><code>def getx(self):
    return self._x

def setx(self, value):
    self._x = value

def delx(self):
    del self._x
</code></pre>
<p>And now we assign these to the property. Note that we could choose our functions programmatically here, answering the dynamic question:</p>
<pre><code>C.x = property(getx, setx, delx, "I'm the 'x' property.")
</code></pre>
<p>And usage:</p>
<pre><code>&gt;&gt;&gt; o.x = 'foo'
&gt;&gt;&gt; o.x
'foo'
&gt;&gt;&gt; del o.x
&gt;&gt;&gt; print(o.x)
None
&gt;&gt;&gt; help(C.x)
Help on property:

    I'm the 'x' property.
</code></pre>
<h2>Decorators</h2>
<p>We could do the same as we did above with decorator notation, but in this case, we <em>must</em> name the methods all the same name (and I'd recommend keeping it the same as the attribute), so programmatic assignment is not so trivial as it is using the above method:</p>
<pre><code>@property
def x(self):
    '''I'm the 'x' property.'''
    return self._x

@x.setter
def x(self, value):
    self._x = value

@x.deleter
def x(self):
    del self._x
</code></pre>
<p>And assign the property object with its provisioned setters and deleters to the class:</p>
<pre><code>C.x = x
</code></pre>
<p>And usage:</p>
<pre><code>&gt;&gt;&gt; help(C.x)
Help on property:

    I'm the 'x' property.

&gt;&gt;&gt; o.x
&gt;&gt;&gt; o.x = 'foo'
&gt;&gt;&gt; o.x
'foo'
&gt;&gt;&gt; del o.x
&gt;&gt;&gt; print(o.x)
None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot add a new <code>property()</code> to an instance at runtime, because properties are data descriptors.  Instead you must dynamically create a new class, or overload <code>__getattribute__</code> in order to process data descriptors on instances.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if I completely understand the question, but you can modify instance properties at runtime with the built-in <code>__dict__</code> of your class:</p>
<pre><code>class C(object):
    def __init__(self, ks, vs):
        self.__dict__ = dict(zip(ks, vs))


if __name__ == "__main__":
    ks = ['ab', 'cd']
    vs = [12, 34]
    c = C(ks, vs)
    print(c.ab) # 12
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For those coming from search engines, here are the two things I was looking for when talking about <em>dynamic</em> properties:</p>
<pre><code>class Foo:
    def __init__(self):
        # we can dynamically have access to the properties dict using __dict__
        self.__dict__['foo'] = 'bar'

assert Foo().foo == 'bar'


# or we can use __getattr__ and __setattr__ to execute code on set/get
class Bar:
    def __init__(self):
        self._data = {}
    def __getattr__(self, key):
        return self._data[key]
    def __setattr__(self, key, value):
        self._data[key] = value

bar = Bar()
bar.foo = 'bar'
assert bar.foo == 'bar'
</code></pre>
<p><code>__dict__</code> is good if you want to put dynamically created properties. <code>__getattr__</code> is good to only do something when the value is needed, like query a database. The set/get combo is good to simplify the access to data stored in the class (like in the example above).</p>
<p>If you only want one dynamic property, have a look at the <a href="https://docs.python.org/3/library/functions.html#property" rel="nofollow noreferrer">property()</a> built-in function.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to achieve is by defining <code>__slots__</code>. That way your instances can't have new attributes.</p>
<pre><code>ks = ['ab', 'cd']
vs = [12, 34]

class C(dict):
    __slots__ = []
    def __init__(self, ks, vs): self.update(zip(ks, vs))
    def __getattr__(self, key): return self[key]

if __name__ == "__main__":
    c = C(ks, vs)
    print c.ab
</code></pre>
<p>That prints <code>12</code></p>
<pre><code>    c.ab = 33
</code></pre>
<p>That gives: <code>AttributeError: 'C' object has no attribute 'ab'</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Just another example how to achieve desired effect</p>
<pre><code>class Foo(object):

    _bar = None

    @property
    def bar(self):
        return self._bar

    @bar.setter
    def bar(self, value):
        self._bar = value

    def __init__(self, dyn_property_name):
        setattr(Foo, dyn_property_name, Foo.bar)
</code></pre>
<p>So now we can do stuff like:</p>
<pre><code>&gt;&gt;&gt; foo = Foo('baz')
&gt;&gt;&gt; foo.baz = 5
&gt;&gt;&gt; foo.bar
5
&gt;&gt;&gt; foo.baz
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems to work(but see below):</p>
<pre><code>class data(dict,object):
    def __init__(self,*args,**argd):
        dict.__init__(self,*args,**argd)
        self.__dict__.update(self)
    def __setattr__(self,name,value):
        raise AttributeError,"Attribute '%s' of '%s' object cannot be set"%(name,self.__class__.__name__)
    def __delattr__(self,name):
        raise AttributeError,"Attribute '%s' of '%s' object cannot be deleted"%(name,self.__class__.__name__)
</code></pre>
<p>If you need more complex behavior, feel free to edit your answer.</p>
<h2>edit</h2>
<p>The following would probably be more memory-efficient for large datasets:</p>
<pre><code>class data(dict,object):
    def __init__(self,*args,**argd):
        dict.__init__(self,*args,**argd)
    def __getattr__(self,name):
        return self[name]
    def __setattr__(self,name,value):
        raise AttributeError,"Attribute '%s' of '%s' object cannot be set"%(name,self.__class__.__name__)
    def __delattr__(self,name):
        raise AttributeError,"Attribute '%s' of '%s' object cannot be deleted"%(name,self.__class__.__name__)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To answer the main thrust of your question, you want a read-only attribute from a dict as an immutable datasource:</p>
<blockquote>
<p>The goal is to create a mock class which behaves like a db resultset.</p>
<p>So for example, if a database query returns, using a dict expression,
  <code>{'ab':100, 'cd':200}</code>, then I would to see</p>
<pre><code>&gt;&gt;&gt; dummy.ab
100
</code></pre>
</blockquote>
<p>I'll demonstrate how to use a <code>namedtuple</code> from the <code>collections</code> module to accomplish just this:</p>
<pre><code>import collections

data = {'ab':100, 'cd':200}

def maketuple(d):
    '''given a dict, return a namedtuple'''
    Tup = collections.namedtuple('TupName', d.keys()) # iterkeys in Python2
    return Tup(**d)

dummy = maketuple(data)
dummy.ab
</code></pre>
<p>returns <code>100</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class atdict(dict):
  def __init__(self, value, **kwargs):
    super().__init__(**kwargs)
    self.__dict = value

  def __getattr__(self, name):
    for key in self.__dict:
      if type(self.__dict[key]) is list:
        for idx, item in enumerate(self.__dict[key]):
          if type(item) is dict:
            self.__dict[key][idx] = atdict(item)
      if type(self.__dict[key]) is dict:
        self.__dict[key] = atdict(self.__dict[key])
    return self.__dict[name]



d1 = atdict({'a' : {'b': [{'c': 1}, 2]}})

print(d1.a.b[0].c)
</code></pre>
<p>And the output is:</p>
<pre><code>&gt;&gt; 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following code to update class attributes using a dictionary object:</p>
<pre><code>class ExampleClass():
    def __init__(self, argv):
        for key, val in argv.items():
            self.__dict__[key] = val

if __name__ == '__main__':
    argv = {'intro': 'Hello World!'}
    instance = ExampleClass(argv)
    print instance.intro
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Extending the idea from <a href="https://stackoverflow.com/users/134107/kjfletch">kjfletch</a></p>
<pre><code># This is my humble contribution, extending the idea to serialize
# data from and to tuples, comparison operations and allowing functions
# as default values.

def Struct(*args, **kwargs):
    FUNCTIONS = (types.BuiltinFunctionType, types.BuiltinMethodType, \
                 types.FunctionType, types.MethodType)
    def init(self, *iargs, **ikwargs):
        """Asume that unamed args are placed in the same order than
        astuple() yields (currently alphabetic order)
        """
        kw = list(self.__slots__)

        # set the unnamed args
        for i in range(len(iargs)):
            k = kw.pop(0)
            setattr(self, k, iargs[i])

        # set the named args
        for k, v in ikwargs.items():
            setattr(self, k, v)
            kw.remove(k)

        # set default values
        for k in kw:
            v = kwargs[k]
            if isinstance(v, FUNCTIONS):
                v = v()
            setattr(self, k, v)

    def astuple(self):
        return tuple([getattr(self, k) for k in self.__slots__])

    def __str__(self):
        data = ['{}={}'.format(k, getattr(self, k)) for k in self.__slots__]
        return '&lt;{}: {}&gt;'.format(self.__class__.__name__, ', '.join(data))

    def __repr__(self):
        return str(self)

    def __eq__(self, other):
        return self.astuple() == other.astuple()

    name = kwargs.pop("__name__", "MyStruct")
    slots = list(args)
    slots.extend(kwargs.keys())
    # set non-specific default values to None
    kwargs.update(dict((k, None) for k in args))

    return type(name, (object,), {
        '__init__': init,
        '__slots__': tuple(slots),
        'astuple': astuple,
        '__str__': __str__,
        '__repr__': __repr__,
        '__eq__': __eq__,
    })


Event = Struct('user', 'cmd', \
               'arg1', 'arg2',  \
               date=time.time, \
               __name__='Event')

aa = Event('pepe', 77)
print(aa)
raw = aa.astuple()

bb = Event(*raw)
print(bb)

if aa == bb:
    print('Are equals')

cc = Event(cmd='foo')
print(cc)
</code></pre>
<p>Output:</p>
<pre><code>&lt;Event: user=pepe, cmd=77, arg1=None, arg2=None, date=1550051398.3651814&gt;
&lt;Event: user=pepe, cmd=77, arg1=None, arg2=None, date=1550051398.3651814&gt;
Are equals
&lt;Event: user=None, cmd=foo, arg1=None, arg2=None, date=1550051403.7938335&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although many answers are given, I couldn't find one I am happy with. I figured out my own solution which makes <code>property</code> work for the dynamic case. The source to answer the original question:</p>
<pre><code>#!/usr/local/bin/python3

INITS = { 'ab': 100, 'cd': 200 }

class DP(dict):
  def __init__(self):
    super().__init__()
    for k,v in INITS.items():
        self[k] = v 

def _dict_set(dp, key, value):
  dp[key] = value

for item in INITS.keys():
  setattr(
    DP,
    item,
    lambda key: property(
      lambda self: self[key], lambda self, value: _dict_set(self, key, value)
    )(item)
  )

a = DP()
print(a)  # {'ab': 100, 'cd': 200}
a.ab = 'ab100'
a.cd = False
print(a.ab, a.cd) # ab100 False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Only way to dynamically attach a property is to create a new class and its instance with your new property.  </p>
<pre><code>class Holder: p = property(lambda x: vs[i], self.fn_readonly)
setattr(self, k, Holder().p)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I recently ran into a similar problem, the solution that I came up with uses <code>__getattr__</code> and <code>__setattr__</code> for the properties that I want it to handle, everything else gets passed on to the originals.</p>
<pre><code>class C(object):
    def __init__(self, properties):
        self.existing = "Still Here"
        self.properties = properties

    def __getattr__(self, name):
        if "properties" in self.__dict__ and name in self.properties:
            return self.properties[name] # Or call a function, etc
        return self.__dict__[name]

    def __setattr__(self, name, value):
        if "properties" in self.__dict__ and name in self.properties:
            self.properties[name] = value
        else:
            self.__dict__[name] = value

if __name__ == "__main__":
    my_properties = {'a':1, 'b':2, 'c':3}
    c = C(my_properties)
    assert c.a == 1
    assert c.existing == "Still Here"
    c.b = 10
    assert c.properties['b'] == 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A lot of the supplied answers require so many lines per property, ie / and / or - what I'd consider an ugly or tedious implementation because of repetitiveness required for multiple properties, etc. I prefer keeping boiling things down / simplifying them until they can't be simplified anymore or until it doesn't serve much purpose to do so.</p>
<p>In short: in completed works, if I repeat 2 lines of code, I typically convert it into a single line helper function, and so on... I simplify math or odd arguments such as ( start_x, start_y, end_x, end_y ) to ( x, y, w, h ) ie x, y, x + w, y + h ( sometimes requiring min / max or if w / h are negative and the implementation doesn't like it, I'll subtract from x / y and abs w / h. etc.. ).</p>
<p>Overriding the internal getters / setters is an ok way to go, but the problem is you need to do that for every class, or parent the class to that base... This doesn't work for me as I'd prefer to be free to choose the children / parents for inheritance, child nodes, etc.</p>
<p>I have created a solution which answers the question without using a Dict data-type to supply the data as I find that to be tedious to enter the data, etc...</p>
<p>My solution requires you to add 2 extra lines above your class to create a base class for the class you want to add the properties to, then 1 line per and you have the option to add callbacks to control the data, inform you when data changes, restrict the data which can be set based on value and / or data-type, and much more.</p>
<p>You also have the option to use _object.x, _object.x = value, _object.GetX( ), _object.SetX( value ) and they are handled equivalently.</p>
<p>Additionally, the values are the only non-static data which are assigned to the class instance, but the actual property is assigned to the class meaning the things you don't want to repeat, don't need to be repeated... You can assign a default value so the getter doesn't need it each time, although there is an option to override the default default value, and there is another option so the getter returns the raw stored value by overriding default returns ( note: this method means the raw value is only assigned when a value is assigned, otherwise it is None - when the value is Reset, then it assigns None, etc.. )</p>
<p>There are many helper functions too - the first property which gets added adds 2 or so helpers to the class for referencing the instance values... They are ResetAccessors( _key, .. ) varargs repeated ( all can be repeated using the first named args ) and SetAccessors( _key, _value ) with the option of more being added to the main class to aide in efficiency - the ones planned are: a way to group accessors together, so if you tend to reset a few at a time, every time, you can assign them to a group and reset the group instead of repeating the named keys each time, and more.</p>
<p>The instance / raw stored value is stored at <em>class.</em>, the __class. references the Accessor Class which holds static vars / values / functions for the property. _class. is the property itself which is called when accessed via the instance class during setting / getting, etc.</p>
<p>The Accessor _class.__ points to the class, but because it is internal it needs to be assigned in the class which is why I opted to use __Name = AccessorFunc( ... ) to assign it, a single line per property with many optional arguments to use ( using keyed varargs because they're easier and more efficient to identify and maintain )...</p>
<p>I also create a lot of functions, as mentioned, some of which use <strong> accessor function information so it doesn't need to be called ( as it is a bit inconvenient at the moment - right now you need to use _class.</strong>.FunctionName( _class_instance, args ) - I got around using the stack / trace to grab the instance reference to grab the value by adding the functions which either run this bit marathon, or by adding the accessors to the object and using self ( named this to point out they're for the instance and to retain access to self, the AccessorFunc class reference, and other information from within the function definitions ).</p>
<p>It isn't quite done, but it is a fantastic foot-hold. Note: If you do not use __Name = AccessorFunc( ... ) to create the properties, you won't have access to the __ key even though I define it within the init function. If you do, then there are no issues.</p>
<p>Also: Note that Name and Key are different... Name is 'formal', used in Function Name Creation, and the key is for data storage and access. ie _class.x where lowercase x is key, the name would be uppercase X so that GetX( ) is the function instead of Getx( ) which looks a little odd. this allows self.x to work and look appropriate, but also allow GetX( ) and look appropriate.</p>
<p>I have an example class set up with key / name identical, and different to show. a lot of helper functions created in order to output the data ( Note: Not all of this is complete ) so you can see what is going on.</p>
<p>The current list of functions using key: x, name: X outputs as:</p>
<p>This is by no means a comprehensive list - there are a few which haven't made it on this at the time of posting...</p>
<pre><code>_instance.SetAccessors( _key, _value [ , _key, _value ] .. )                   Instance Class Helper Function: Allows assigning many keys / values on a single line - useful for initial setup, or to minimize lines.    In short: Calls this.Set&lt;Name&gt;( _value ) for each _key / _value pairing.
_instance.ResetAccessors( _key [ , _key ] .. )                                 Instance Class Helper Function: Allows resetting many key stored values to None on a single line.                                           In short: Calls this.Reset&lt;Name&gt;() for each name provided.


Note: Functions below may list self.Get / Set / Name( _args ) - self is meant as the class instance reference in the cases below - coded as this in AccessorFuncBase Class.

this.GetX( _default_override = None, _ignore_defaults = False )                 GET:            Returns    IF ISSET: STORED_VALUE .. IF IGNORE_DEFAULTS: None  .. IF PROVIDED: DEFAULT_OVERRIDE ELSE: DEFAULT_VALUE       100
this.GetXRaw( )                                                                 RAW:            Returns    STORED_VALUE                                                                                                     100
this.IsXSet( )                                                                  ISSET:          Returns    ( STORED_VALUE != None )                                                                                         True

this.GetXToString( )                                                            GETSTR:         Returns    str( GET )                                                                                                       100
this.GetXLen( _default_override = None, _ignore_defaults = False )              LEN:            Returns    len( GET )                                                                                                       3
this.GetXLenToString( _default_override = None, _ignore_defaults = False )      LENSTR:         Returns    str( len( GET ) )                                                                                                3
this.GetXDefaultValue( )                                                        DEFAULT:        Returns    DEFAULT_VALUE                                                                                                    1111

this.GetXAccessor( )                                                            ACCESSOR:       Returns    ACCESSOR_REF ( self.__&lt;key&gt; )                                                                                    [ AccessorFuncBase ] Key: x : Class ID: 2231452344344 : self ID: 2231448283848        Default: 1111       Allowed Types: {"&lt;class 'int'&gt;": "&lt;class 'type'&gt;", "&lt;class 'float'&gt;": "&lt;class 'type'&gt;"}     Allowed Values: None
this.GetXAllowedTypes( )                                                        ALLOWED_TYPES:  Returns    Allowed Data-Types                                                                                               {"&lt;class 'int'&gt;": "&lt;class 'type'&gt;", "&lt;class 'float'&gt;": "&lt;class 'type'&gt;"}
this.GetXAllowedValues( )                                                       ALLOWED_VALUES: Returns    Allowed Values                                                                                                   None

this.GetXHelpers( )                                                             HELPERS:        Returns    Helper Functions String List - ie what you're reading now...                                                     THESE ROWS OF TEXT
this.GetXKeyOutput( )                                                           Returns information about this Name / Key                                                                                                   ROWS OF TEXT
this.GetXGetterOutput( )                                                        Returns information about this Name / Key                                                                                                   ROWS OF TEXT

this.SetX( _value )                                                             SET:            STORED_VALUE Setter - ie Redirect to __&lt;Key&gt;.Set                                                                            N / A
this.ResetX( )                                                                  RESET:          Resets STORED_VALUE to None                                                                                                 N / A

this.HasXGetterPrefix( )                                                        Returns Whether or Not this key has a Getter Prefix...                                                                                      True
this.GetXGetterPrefix( )                                                        Returns Getter Prefix...                                                                                                                    Get

this.GetXName( )                                                                Returns Accessor Name - Typically Formal / Title-Case                                                                                       X
this.GetXKey( )                                                                 Returns Accessor Property Key - Typically Lower-Case                                                                                        x
this.GetXAccessorKey( )                                                         Returns Accessor Key - This is to access internal functions, and static data...                                                             __x
this.GetXDataKey( )                                                             Returns Accessor Data-Storage Key - This is the location where the class instance value is stored..                                         _x
</code></pre>
<p>Some of the data being output is:</p>
<p>This is for a brand new class created using the Demo class without any data assigned other than the name ( so it can be output ) which is _foo, the variable name I used...</p>
<pre><code>_foo         --- MyClass: ---- id( this.__class__ ): 2231452349064 :::: id( this ): 2231448475016

    Key       Getter Value        | Raw Key   Raw / Stored Value       | Get Default Value             Default Value            | Get Allowed Types             Allowed Types                                                              | Get Allowed Values            Allowed Values                                                                                                                                                                                                                   |

    Name:     _foo                | _Name:    _foo                     | __Name.DefaultValue( ):       AccessorFuncDemoClass    | __Name.GetAllowedTypes( )     &lt;class 'str'&gt;                                                              | __Name.GetAllowedValues( )    Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    x:        1111                | _x:       None                     | __x.DefaultValue( ):          1111                     | __x.GetAllowedTypes( )        (&lt;class 'int'&gt;, &lt;class 'float'&gt;)                                           | __x.GetAllowedValues( )       Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    y:        2222                | _y:       None                     | __y.DefaultValue( ):          2222                     | __y.GetAllowedTypes( )        (&lt;class 'int'&gt;, &lt;class 'float'&gt;)                                           | __y.GetAllowedValues( )       Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    z:        3333                | _z:       None                     | __z.DefaultValue( ):          3333                     | __z.GetAllowedTypes( )        (&lt;class 'int'&gt;, &lt;class 'float'&gt;)                                           | __z.GetAllowedValues( )       Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    Blah:     &lt;class 'int'&gt;       | _Blah:    None                     | __Blah.DefaultValue( ):       &lt;class 'int'&gt;            | __Blah.GetAllowedTypes( )     &lt;class 'str'&gt;                                                              | __Blah.GetAllowedValues( )    Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    Width:    1                   | _Width:   None                     | __Width.DefaultValue( ):      1                        | __Width.GetAllowedTypes( )    (&lt;class 'int'&gt;, &lt;class 'bool'&gt;)                                            | __Width.GetAllowedValues( )   Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    Height:   0                   | _Height:  None                     | __Height.DefaultValue( ):     0                        | __Height.GetAllowedTypes( )   &lt;class 'int'&gt;                                                              | __Height.GetAllowedValues( )  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)                                                                                                                                                                                                   |
    Depth:    2                   | _Depth:   None                     | __Depth.DefaultValue( ):      2                        | __Depth.GetAllowedTypes( )    Saved Value Restricted to Authorized Values ONLY                           | __Depth.GetAllowedValues( )   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)                                                                                                                                                                                                   |


this.IsNameSet( ):    True      this.GetName( ):     _foo                     this.GetNameRaw( ):    _foo                     this.GetNameDefaultValue( ):    AccessorFuncDemoClass    this.GetNameLen( ):    4    this.HasNameGetterPrefix( ):    &lt;class 'str'&gt;                                this.GetNameGetterPrefix( ):    None
this.IsXSet( ):       False     this.GetX( ):        1111                     this.GetXRaw( ):       None                     this.GetXDefaultValue( ):       1111                     this.GetXLen( ):       4    this.HasXGetterPrefix( ):       (&lt;class 'int'&gt;, &lt;class 'float'&gt;)             this.GetXGetterPrefix( ):       None
this.IsYSet( ):       False     this.GetY( ):        2222                     this.GetYRaw( ):       None                     this.GetYDefaultValue( ):       2222                     this.GetYLen( ):       4    this.HasYGetterPrefix( ):       (&lt;class 'int'&gt;, &lt;class 'float'&gt;)             this.GetYGetterPrefix( ):       None
this.IsZSet( ):       False     this.GetZ( ):        3333                     this.GetZRaw( ):       None                     this.GetZDefaultValue( ):       3333                     this.GetZLen( ):       4    this.HasZGetterPrefix( ):       (&lt;class 'int'&gt;, &lt;class 'float'&gt;)             this.GetZGetterPrefix( ):       None
this.IsBlahSet( ):    False     this.GetBlah( ):     &lt;class 'int'&gt;            this.GetBlahRaw( ):    None                     this.GetBlahDefaultValue( ):    &lt;class 'int'&gt;            this.GetBlahLen( ):    13   this.HasBlahGetterPrefix( ):    &lt;class 'str'&gt;                                this.GetBlahGetterPrefix( ):    None
this.IsWidthSet( ):   False     this.GetWidth( ):    1                        this.GetWidthRaw( ):   None                     this.GetWidthDefaultValue( ):   1                        this.GetWidthLen( ):   1    this.HasWidthGetterPrefix( ):   (&lt;class 'int'&gt;, &lt;class 'bool'&gt;)              this.GetWidthGetterPrefix( ):   None
this.IsDepthSet( ):   False     this.GetDepth( ):    2                        this.GetDepthRaw( ):   None                     this.GetDepthDefaultValue( ):   2                        this.GetDepthLen( ):   1    this.HasDepthGetterPrefix( ):   None                                         this.GetDepthGetterPrefix( ):   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
this.IsHeightSet( ):  False     this.GetHeight( ):   0                        this.GetHeightRaw( ):  None                     this.GetHeightDefaultValue( ):  0                        this.GetHeightLen( ):  1    this.HasHeightGetterPrefix( ):  &lt;class 'int'&gt;                                this.GetHeightGetterPrefix( ):  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</code></pre>
<p>And this is after assigning all of _foo properties ( except the name ) the following values in the same order: 'string ', 1.0, True, 9, 10, False</p>
<pre><code>this.IsNameSet( ):    True      this.GetName( ):     _foo                     this.GetNameRaw( ):    _foo                     this.GetNameDefaultValue( ):    AccessorFuncDemoClass    this.GetNameLen( ):    4    this.HasNameGetterPrefix( ):    &lt;class 'str'&gt;                                this.GetNameGetterPrefix( ):    None
this.IsXSet( ):       True      this.GetX( ):        10                       this.GetXRaw( ):       10                       this.GetXDefaultValue( ):       1111                     this.GetXLen( ):       2    this.HasXGetterPrefix( ):       (&lt;class 'int'&gt;, &lt;class 'float'&gt;)             this.GetXGetterPrefix( ):       None
this.IsYSet( ):       True      this.GetY( ):        10                       this.GetYRaw( ):       10                       this.GetYDefaultValue( ):       2222                     this.GetYLen( ):       2    this.HasYGetterPrefix( ):       (&lt;class 'int'&gt;, &lt;class 'float'&gt;)             this.GetYGetterPrefix( ):       None
this.IsZSet( ):       True      this.GetZ( ):        10                       this.GetZRaw( ):       10                       this.GetZDefaultValue( ):       3333                     this.GetZLen( ):       2    this.HasZGetterPrefix( ):       (&lt;class 'int'&gt;, &lt;class 'float'&gt;)             this.GetZGetterPrefix( ):       None
this.IsBlahSet( ):    True      this.GetBlah( ):     string Blah              this.GetBlahRaw( ):    string Blah              this.GetBlahDefaultValue( ):    &lt;class 'int'&gt;            this.GetBlahLen( ):    11   this.HasBlahGetterPrefix( ):    &lt;class 'str'&gt;                                this.GetBlahGetterPrefix( ):    None
this.IsWidthSet( ):   True      this.GetWidth( ):    False                    this.GetWidthRaw( ):   False                    this.GetWidthDefaultValue( ):   1                        this.GetWidthLen( ):   5    this.HasWidthGetterPrefix( ):   (&lt;class 'int'&gt;, &lt;class 'bool'&gt;)              this.GetWidthGetterPrefix( ):   None
this.IsDepthSet( ):   True      this.GetDepth( ):    9                        this.GetDepthRaw( ):   9                        this.GetDepthDefaultValue( ):   2                        this.GetDepthLen( ):   1    this.HasDepthGetterPrefix( ):   None                                         this.GetDepthGetterPrefix( ):   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
this.IsHeightSet( ):  True      this.GetHeight( ):   9                        this.GetHeightRaw( ):  9                        this.GetHeightDefaultValue( ):  0                        this.GetHeightLen( ):  1    this.HasHeightGetterPrefix( ):  &lt;class 'int'&gt;                                this.GetHeightGetterPrefix( ):  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

_foo         --- MyClass: ---- id( this.__class__ ): 2231452349064 :::: id( this ): 2231448475016

    Key       Getter Value        | Raw Key   Raw / Stored Value       | Get Default Value             Default Value            | Get Allowed Types             Allowed Types                                                              | Get Allowed Values            Allowed Values                                                                                                                                                                                                                   |

    Name:     _foo                | _Name:    _foo                     | __Name.DefaultValue( ):       AccessorFuncDemoClass    | __Name.GetAllowedTypes( )     &lt;class 'str'&gt;                                                              | __Name.GetAllowedValues( )    Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    x:        10                  | _x:       10                       | __x.DefaultValue( ):          1111                     | __x.GetAllowedTypes( )        (&lt;class 'int'&gt;, &lt;class 'float'&gt;)                                           | __x.GetAllowedValues( )       Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    y:        10                  | _y:       10                       | __y.DefaultValue( ):          2222                     | __y.GetAllowedTypes( )        (&lt;class 'int'&gt;, &lt;class 'float'&gt;)                                           | __y.GetAllowedValues( )       Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    z:        10                  | _z:       10                       | __z.DefaultValue( ):          3333                     | __z.GetAllowedTypes( )        (&lt;class 'int'&gt;, &lt;class 'float'&gt;)                                           | __z.GetAllowedValues( )       Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    Blah:     string Blah         | _Blah:    string Blah              | __Blah.DefaultValue( ):       &lt;class 'int'&gt;            | __Blah.GetAllowedTypes( )     &lt;class 'str'&gt;                                                              | __Blah.GetAllowedValues( )    Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    Width:    False               | _Width:   False                    | __Width.DefaultValue( ):      1                        | __Width.GetAllowedTypes( )    (&lt;class 'int'&gt;, &lt;class 'bool'&gt;)                                            | __Width.GetAllowedValues( )   Saved Value Restrictions Levied by Data-Type                                                                                                                                                                                     |
    Height:   9                   | _Height:  9                        | __Height.DefaultValue( ):     0                        | __Height.GetAllowedTypes( )   &lt;class 'int'&gt;                                                              | __Height.GetAllowedValues( )  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)                                                                                                                                                                                                   |
    Depth:    9                   | _Depth:   9                        | __Depth.DefaultValue( ):      2                        | __Depth.GetAllowedTypes( )    Saved Value Restricted to Authorized Values ONLY                           | __Depth.GetAllowedValues( )   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)                                                                                                                                                                                                   |
</code></pre>
<p>Note that because of restricted data-types or value restrictions, some data wasn't assigned - this is by design. The setter prohibits bad data-types or values from being assigned, even from being assigned as a default value  ( unless you override the default value protection behavior )</p>
<p>The code hasn't been posted here because I didn't have room after the examples and explanations... Also because it will change.</p>
<p>Please Note: at the time of this posting, the file is messy - this will change. But, if you run it in Sublime Text and compile it, or run it from Python, it will compile and spit out a ton of information - the AccessorDB portion isn't done ( which will be used to update the Print Getters and GetKeyOutput helper functions along with being changed to an Instance function, probably put into a single function and renamed - look for it.. )</p>
<p>Next: Not everything is required for it to run - a lot of the commented stuff at the bottom is for more information used for debugging - it may not be there when you download it. If it is, you should be able to uncomment and recompile to get more information.</p>
<p>I am looking for a work-around to needing MyClassBase: pass, MyClass( MyClassBase ): ... - if you know of a solution - post it.</p>
<p>The only thing necessary in the class are the __ lines - the <strong>str</strong> is for debugging as is the <strong>init</strong> - they can be removed from the Demo Class but you will need to comment out or remove some of the lines below ( _foo / 2 / 3 )..</p>
<p>The String, Dict, and Util classes at the top are a part of my Python library - they are not complete. I copied over a few things I needed from the library, and I created a few new ones. The full code will link to the complete library and will include it along with providing updated calls and removing the code ( actually, the only code left will be the Demo Class and the print statements - the AccessorFunc system will be moved to the library )...</p>
<p>Part of file:</p>
<pre><code>##
## MyClass Test AccessorFunc Implementation for Dynamic 1-line Parameters
##
class AccessorFuncDemoClassBase( ):
    pass
class AccessorFuncDemoClass( AccessorFuncDemoClassBase ):
    __Name      = AccessorFuncBase( parent = AccessorFuncDemoClassBase, name = 'Name',      default = 'AccessorFuncDemoClass',  allowed_types = ( TYPE_STRING ),                    allowed_values = VALUE_ANY,                 documentation = 'Name Docs',        getter_prefix = 'Get',  key = 'Name',       allow_erroneous_default = False,    options = { } )
    __x         = AccessorFuncBase( parent = AccessorFuncDemoClassBase, name = 'X',         default = 1111,                     allowed_types = ( TYPE_INTEGER, TYPE_FLOAT ),       allowed_values = VALUE_ANY,                 documentation = 'X Docs',           getter_prefix = 'Get',  key = 'x',          allow_erroneous_default = False,    options = { } )
    __Height    = AccessorFuncBase( parent = AccessorFuncDemoClassBase, name = 'Height',    default = 0,                        allowed_types = TYPE_INTEGER,                       allowed_values = VALUE_SINGLE_DIGITS,       documentation = 'Height Docs',      getter_prefix = 'Get',  key = 'Height',     allow_erroneous_default = False,    options = { } )
</code></pre>
<p>This beauty makes it incredibly easy to create new classes with dynamically added properties with AccessorFuncs / callbacks / data-type / value enforcement, etc.</p>
<p>For now, the link is at ( This link should reflect changes to the document. ): <a href="https://www.dropbox.com/s/6gzi44i7dh58v61/dynamic_properties_accessorfuncs_and_more.py?dl=0" rel="nofollow noreferrer">https://www.dropbox.com/s/6gzi44i7dh58v61/dynamic_properties_accessorfuncs_and_more.py?dl=0</a></p>
<p>Also: If you don't use Sublime Text, I recommend it over Notepad++, Atom, Visual Code, and others because of proper threading implementations making it much, much faster to use... I am also working on an IDE-like code mapping system for it - take a look at: <a href="https://bitbucket.org/Acecool/acecoolcodemappingsystem/src/master/" rel="nofollow noreferrer">https://bitbucket.org/Acecool/acecoolcodemappingsystem/src/master/</a> ( Add Repo in Package Manager first, then Install Plugin - when version 1.0.0 is ready, I'll add it to the main plugin list... )</p>
<p>I hope this solution helps... and, as always:</p>
<p>Just because it works, doesn't make it right - Josh 'Acecool' Moser</p>
</div>
<span class="comment-copy">There are a few typos in your code: definition of fn_readonly needs a <code>:</code> and <code>__init__</code> references <code>self.fn_readyonly</code>.</span>
<span class="comment-copy">You are right. I added that setter function in last minute in order to underline the reason of creating a property in runtime.</span>
<span class="comment-copy">Nice to know there is a workaround!</span>
<span class="comment-copy">No need to add the add_property method. <code>setattr (Foo, 'name', property (func))</code></span>
<span class="comment-copy">Your "But that's the catchâ€¦" just saved me several hours of work. Thank you.</span>
<span class="comment-copy">If you want to define a property on a single instance, you can <a href="https://gist.github.com/Wilfred/49b0409c6489f1bdf5a5c98a488b31b5" rel="nofollow noreferrer">create a class at runtime and modify __class__</a>.</span>
<span class="comment-copy">what about @myproperty.setter? How to add it dinamically?</span>
<span class="comment-copy">in a more general setup, this serves limited purpose. if the dict has multilevel hierarchy, like d = {'a1': {'b': 'c'}, 'a2': ...}, then while you can do d.a1 or d.a2, you can't do d.a1.b</span>
<span class="comment-copy">One thing to keep in mind is that this allows setting attribute values for attributes with the same name as dict methods or attributes, but does not allow retrieving the values the same way again: <code>d.items = 1</code>,  <code>d.items</code> returns <code>&lt;built-in method items of atdict object at ...&gt;</code>. You could still do <code>d["items"]</code> or use <code>__getattribute__</code> instead of <code>__getattr__</code>, but this prevents using most of the dict's methods.</span>
<span class="comment-copy">Great idea. Unfortunately I am stuck with python 2.4 at the moment.</span>
<span class="comment-copy"><a href="http://code.activestate.com/recipes/500261/" rel="nofollow noreferrer">Named tuple recipe adapted for Python 2.4</a></span>
<span class="comment-copy">The guy who wrote <code>namedtuple</code> deserves a prize for making it smooth and elegant to be faithful object-oriented principles.</span>
<span class="comment-copy">Sorry, at best, this answer is only applicable to the special case where one wanteda class consisting of only read-only attributes all know in advance. In other words I don't think it addresses the broader question of how to add general properties -- not just read-only ones -- to a class at runtime (nor does the current version of the other "add-on" answer also posted by the author).</span>
<span class="comment-copy">@martineau so...  pass more arguments to <code>property()</code>?  there's nothing in either answer that's specific to read-only properties.</span>
<span class="comment-copy">This is wrong. You can add the property to the class then access it from the method.</span>
<span class="comment-copy">In essence my question is to find out if it is possible to create a new property in runtime. The consensus seems to be negative. Your suggestion is certainly simple and practical. (Same to other answers that uses <b>dict</b>)</span>
<span class="comment-copy">this does not appear to work. it will assign the result of the property, not the property itself.</span>
<span class="comment-copy">I wanted to add a quick display of what the class looked like so you don't need to open the code file but comments don't appear to support it..</span>
