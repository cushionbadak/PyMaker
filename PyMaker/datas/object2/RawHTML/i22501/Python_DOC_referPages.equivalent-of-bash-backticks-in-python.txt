<div class="post-text" itemprop="text">
<p>What is the equivalent of the backticks found in Ruby and Perl in Python? That is, in Ruby I can do this:</p>
<pre><code>foo = `cat /tmp/baz`
</code></pre>
<p>What does the equivalent statement look like in Python? I've tried <code>os.system("cat /tmp/baz")</code> but that puts the result to standard out and returns to me the error code of that operation.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>output = os.popen('cat /tmp/baz').read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The most flexible way is to use the <a href="http://docs.python.org/library/subprocess.html" rel="nofollow noreferrer"><code>subprocess</code></a> module:</p>
<pre><code>import subprocess

out = subprocess.run(["cat", "/tmp/baz"], capture_output=True)
print("program output:", out)
</code></pre>
<p><code>capture_output</code> was introduced in Python 3.7, for older versions the special function <code>check_output()</code> can be used instead:</p>
<pre><code>out = subprocess.check_output(["cat", "/tmp/baz"])
</code></pre>
<p>You can also manually construct a subprocess object if you need fine grained control:</p>
<pre><code>proc = subprocess.Popen(["cat", "/tmp/baz"], stdout=subprocess.PIPE)
(out, err) = proc.communicate()
</code></pre>
<p>All these functions support <a href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments" rel="nofollow noreferrer">keyword parameters</a> to customize how exactly the subprocess is executed. You can for example use <code>shell=True</code> to execute the program through the shell, if you need things like file name expansions of <code>*</code>, but that comes with <a href="https://docs.python.org/3/library/subprocess.html#security-considerations" rel="nofollow noreferrer">limitations</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/1410997/456814">sth is right</a>. You can also use os.popen(), but where available (Python 2.4+) subprocess is generally preferable.</p>
<p>However, unlike some languages that encourage it, it's generally considered bad form to spawn a subprocess where you can do the same job inside the language. It's slower, less reliable and platform-dependent. Your example would be better off as:</p>
<pre><code>foo= open('/tmp/baz').read()
</code></pre>
<p>eta:</p>
<blockquote>
<p>baz is a directory and I'm trying to get the contents of all the files in that directory</p>
</blockquote>
<p>? cat on a directory gets me an error.</p>
<p>If you want a list of files:</p>
<pre><code>import os
foo= os.listdir('/tmp/baz')
</code></pre>
<p>If you want the contents of all files in a directory, something like:</p>
<pre><code>contents= []
for leaf in os.listdir('/tmp/baz'):
    path= os.path.join('/tmp/baz', leaf)
    if os.path.isfile(path):
        contents.append(open(path, 'rb').read())
foo= ''.join(contents)
</code></pre>
<p>or, if you can be sure there are no directories in there, you could fit it in a one-liner:</p>
<pre><code>path= '/tmp/baz'
foo= ''.join(open(os.path.join(path, child), 'rb').read() for child in os.listdir(path))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>foo = subprocess.check_output(["cat", "/tmp/baz"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From Python 3.5 onward, the recommended way is to use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noreferrer"><code>subprocess.run</code></a>.  To get the same behaviour as you describe, you would use:</p>
<pre><code>output = subprocess.run("ls", shell=True, stdout=subprocess.PIPE).stdout
</code></pre>
<p>This will return a <code>bytes</code> object.  You might want to append <code>.decode("ascii")</code> or <code>.decode("utf-8")</code> to the end to get a <code>str</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way is to use commands package.</p>
<pre><code>import commands

commands.getoutput("whoami")
</code></pre>
<p>Output:</p>
<blockquote>
<p>'bganesan'</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
foo = os.popen('cat /tmp/baz', 'r').read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm using</p>
<blockquote>
<p>(6:0)$ python --version
  Python 2.7.1</p>
</blockquote>
<p>One of the examples above is:</p>
<pre><code>import subprocess
proc = subprocess.Popen(["cat", "/tmp/baz"], stdout=subprocess.PIPE, shell=True)
(out, err) = proc.communicate()
print "program output:", out
</code></pre>
<p>For me, this failed to access the directory /tmp.  After looking at the doc string for subprocess I replaced </p>
<blockquote>
<p>[ "prog", "arg"]</p>
</blockquote>
<p>with </p>
<blockquote>
<p>"prog arg" </p>
</blockquote>
<p>and got the shell expansion behavior that was desired (a la Perl's `prog arg`)</p>
<blockquote>
<p>print subprocess.Popen("ls -ld /tmp/v*", stdout=subprocess.PIPE, shell=True).communicate()[0]</p>
</blockquote>
<hr/>
<p>I quit using python a while back because I was annoyed with the difficulty of of doing the equivalent of perl `cmd ...`.  I'm glad to find Python has made this reasonable.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you use subprocess.Popen, remember to specify bufsize. The default is 0, which means "unbuffered", not "choose a reasonable default".</p>
</div>
<div class="post-text" itemprop="text">
<p>This will not work in python3, but in python2 you can extend <code>str</code> with a custom <code>__repr__</code> method that calls your shell command and returns it like so:</p>
<pre><code>#!/usr/bin/env python

import os

class Command(str):
    """Call system commands"""

    def __repr__(cmd):
        return os.popen(cmd).read()
</code></pre>
<p>Which you can use like</p>
<pre><code>#!/usr/bin/env python
from command import Command

who_i_am = `Command('whoami')`

# Or predeclare your shell command strings
whoami = Command('whoami')
who_i_am = `whoami`
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/2924310/whats-a-good-equivalent-to-pythons-subprocess-check-call-that-returns-the-conte" title="whats a good equivalent to pythons subprocess check call that returns the conte">stackoverflow.com/questions/2924310/â€¦</a></span>
<span class="comment-copy">Not sure how I would use this outside of the OP's example. None of the answers here seem to address the pure question. eg. how to perform <code>some function resulting in a string</code>.somemethod" without lambda functions.</span>
<span class="comment-copy">@mckenzm The question is about capturing the output of an external process. Capturing the output of a Python function would be a quite different question.</span>
<span class="comment-copy">yes, this is the only sane way, you could wrap it in a function so you can call something like execute("command")</span>
<span class="comment-copy">This actually doesn't work for me, as in this case, baz is a directory and I'm trying to get the contents of all the files in that directory. (doing cat /tmp/baz/* works in ticks but not via the method described here)</span>
<span class="comment-copy">re: "*" does not work; use subprocess.Popen(["cat", "/tmp/baz"], stdout=subprocess.PIPE, shell=True) instead. Since glob (star) expansion is handled by shell, subprocessing module must use shell expansion in this case (provided by /bin/sh).</span>
<span class="comment-copy">From <a href="http://docs.python.org/2/library/subprocess.html#popen-constructor" rel="nofollow noreferrer">docs.python.org/2/library/subprocess.html#popen-constructor</a> : "(with shell=True) If args is a sequence, the first item specifies the command string, and any additional items will be treated as additional arguments to the shell itself." So, if you're going to use shell=True, then the first arg should probably be the string "cat /tmp/baz". Alternatively, if you want to use a sequence as the first arg then you should use shell=False</span>
<span class="comment-copy">@gerrit: it is not deprecated. The docs <i>recommend</i> <code>subprocess.run()</code> (I don't know whether it is deserved) if you don't need to support earlier versions or if you don't need the flexibility provided by <code>Popen()</code>.</span>
<span class="comment-copy">Although this wasn't an answer to the question, it's the best answer for educating users.</span>
<span class="comment-copy">The question title is "what is the equivalent of backticks". I assumed that "cat" was just an example command. This answer does not help with the general case.</span>
<span class="comment-copy">Best way to do it. :)</span>
<span class="comment-copy">This is the most straightforward way now. "subprocess.check_output" was added in Python 2.7, which was released in July 2010, after the other "popen" answers were given.</span>
<span class="comment-copy">Very easy, but the module is now deprecated.</span>
<span class="comment-copy">This is the equivalent of Ruby's backticks, but if your problem is to list the contents of a directory then this is not the best way to do it.</span>
<span class="comment-copy">Also you should probably not do this*</span>
