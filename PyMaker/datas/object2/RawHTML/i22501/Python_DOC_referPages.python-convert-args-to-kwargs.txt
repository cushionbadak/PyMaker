<div class="post-text" itemprop="text">
<p>I am writing a decorator that needs to call other functions prior to call of the function that it is decorating.  The decorated function may have positional arguments, but the functions the decorator will call can only accept keyword arguments.  Does anyone have a handy way of converting positional arguments into keyword arguments?</p>
<p>I know that I can get a list of the variable names of the decorated function:</p>
<pre><code>&gt;&gt;&gt; def a(one, two=2):
...    pass

&gt;&gt;&gt; a.func_code.co_varnames
('one', 'two')
</code></pre>
<p>But I can't figure out how to tell what was passed in positionally and what was as keyword.</p>
<p>My decorator looks like this:</p>
<pre><code>class mydec(object):
    def __init__(self, f, *args, **kwargs):
        self.f = f

    def __call__(self, *args, **kwargs):
        hozer(**kwargs)
        self.f(*args, **kwargs)
</code></pre>
<p>Is there a way other than just comparing kwargs and co_varnames, adding to kwargs anything not in there, and hoping for the best?</p>
</div>
<div class="post-text" itemprop="text">
<p>Note - co_varnames will include local variables as well as keywords.  This probably won't matter, as zip truncates the shorter sequence, but may result in confusing error messages if you pass the wrong number of args.</p>
<p>You can avoid this with <code>func_code.co_varnames[:func_code.co_argcount]</code>, but better is to use the <a href="http://docs.python.org/library/inspect.html" rel="noreferrer">inspect</a> module.  ie:</p>
<pre><code>import inspect
argnames, varargs, kwargs, defaults = inspect.getargspec(func)
</code></pre>
<p>You may also want to handle the case where the function defines <code>**kwargs</code> or <code>*args</code> (even if just to raise an exception when used with the decorator).  If these are set, the second and third result from <code>getargspec</code> will return their variable name, otherwise they will be None.</p>
</div>
<div class="post-text" itemprop="text">
<p>Any arg that was passed positionally will be passed to *args. And any arg passed as a keyword will be passed to **kwargs.
If you have positional args values and names then you can do:</p>
<pre><code>kwargs.update(dict(zip(myfunc.func_code.co_varnames, args)))
</code></pre>
<p>to convert them all into keyword args.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python &gt;= 2.7 <code>inspect.getcallargs()</code> does this for you out of the box. You'd just pass it the decorated function as the first argument, and then the rest of the arguments exactly as you plan to call it. Example:</p>
<pre><code>&gt;&gt;&gt; def f(p1, p2, k1=None, k2=None, **kwargs):
...     pass
&gt;&gt;&gt; from inspect import getcallargs
</code></pre>
<p>I'm planning to do <code>f('p1', 'p2', 'p3', k2='k2', extra='kx1')</code> (note that k1 is being passed positionally as p3), so...</p>
<pre><code>&gt;&gt;&gt; call_args = getcallargs(f, 'p1', 'p2', 'p3', k2='k2', extra='kx1')
&gt;&gt;&gt; call_args
{'p2': 'p2', 'k2': 'k2', 'k1': 'p3', 'p1': 'p1', 'kwargs': {'extra': 'kx1'}}
</code></pre>
<p>If you know the decorated function won't use <code>**kwargs</code>, then that key won't appear in the dict, and you're done (and I'm assuming there's no <code>*args</code>, since that would break the requirement that everything have a name). If you <em>do</em> have <code>**kwargs</code>, as I have in this example, and want to include them with the rest of the named arguments, it takes one more line:</p>
<pre><code>&gt;&gt;&gt; call_args.update(call_args.pop('kwargs'))
&gt;&gt;&gt; call_args
{'p2': 'p2', 'k2': 'k2', 'k1': 'p3', 'p1': 'p1', 'extra': 'kx1'}
</code></pre>
<p>Update: for Python &gt;= 3.3, see <a href="https://docs.python.org/3/library/inspect.html#inspect.Signature.bind" rel="nofollow noreferrer"><code>inspect.Signature.bind()</code></a> and the related <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer"><code>inspect.signature</code> function</a> for functionality similar to (but more robust than) <code>inspect.getcallargs()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, this may be overkill.  I wrote it for the dectools package (on PyPi), so you can get updates there.  It returns the dictionary taking into account positional, keyword, and default arguments.  There is a test suite in the package (test_dict_as_called.py):</p>
<pre><code> def _dict_as_called(function, args, kwargs):
""" return a dict of all the args and kwargs as the keywords they would
be received in a real function call.  It does not call function.
"""

names, args_name, kwargs_name, defaults = inspect.getargspec(function)

# assign basic args
params = {}
if args_name:
    basic_arg_count = len(names)
    params.update(zip(names[:], args))  # zip stops at shorter sequence
    params[args_name] = args[basic_arg_count:]
else:
    params.update(zip(names, args))    

# assign kwargs given
if kwargs_name:
    params[kwargs_name] = {}
    for kw, value in kwargs.iteritems():
        if kw in names:
            params[kw] = value
        else:
            params[kwargs_name][kw] = value
else:
    params.update(kwargs)

# assign defaults
if defaults:
    for pos, value in enumerate(defaults):
        if names[-len(defaults) + pos] not in params:
            params[names[-len(defaults) + pos]] = value

# check we did it correctly.  Each param and only params are set
assert set(params.iterkeys()) == (set(names)|set([args_name])|set([kwargs_name])
                                  )-set([None])

return params
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a newer method to solve this using <code>inspect.signature</code> (for Python 3.3+). I'll give an example that can be run / tested yourself first and then show how to modify the original code with it.</p>
<p>Here's a test function which just sums up any args/kwargs given to it; at least one argument is required (<code>a</code>) and there's one keyword-only argument with a default value (<code>b</code>), just to test different aspects of function signatures.</p>
<pre class="lang-py prettyprint-override"><code>def silly_sum(a, *args, b=1, **kwargs):
    return a + b + sum(args) + sum(kwargs.values())
</code></pre>
<p>Now let's make a wrapper for <code>silly_sum</code> which can be called in the same way as <code>silly_sum</code> (with an exception which we'll get to) but that only passes in kwargs to the wrapped <code>silly_sum</code>.</p>
<pre class="lang-py prettyprint-override"><code>def wrapper(f):
    sig = inspect.signature(f)
    def wrapped(*args, **kwargs):
        bound_args = sig.bind(*args, **kwargs)
        bound_args.apply_defaults()
        print(bound_args) # just for testing

        all_kwargs = bound_args.arguments
        assert len(all_kwargs.pop("args")) == 0
        all_kwargs.update(all_kwargs.pop("kwargs"))
        return f(**all_kwargs)
    return wrapped
</code></pre>
<p><code>sig.bind</code> returns a <code>BoundArguments</code> object, but this doesn't take defaults into account unless you call <code>apply_defaults</code> explicitly. Doing so will also generate an empty tuple for args and an empty dict for kwargs if no <code>*args</code>/<code>**kwargs</code> were given.</p>
<pre class="lang-py prettyprint-override"><code>sum_wrapped = wrapper(silly_sum)
sum_wrapped(1, c=9, d=11)
# prints &lt;BoundArguments (a=1, args=(), b=1, kwargs={'c': 9, 'd': 11})&gt;
# returns 22
</code></pre>
<p>Then we just get the dictionary of arguments and add any <code>**kwargs</code> in. The exception to using this wrapper is that <code>*args</code> can't be passed to the function. This is because there are no names for these, so we can't convert them into kwargs. If passing them through as a kwarg named args is acceptable, that could be done instead.</p>
<hr/>
<p>Here is how this can be applied to the original code:</p>
<pre class="lang-py prettyprint-override"><code>import inspect


class mydec(object):
    def __init__(self, f, *args, **kwargs):
        self.f = f
        self._f_sig = inspect.signature(f)

    def __call__(self, *args, **kwargs):
        bound_args = self._f_sig.bind(*args, **kwargs)
        bound_args.apply_defaults()
        all_kwargs = bound_args.arguments
        assert len(all_kwargs.pop("args")) == 0
        all_kwargs.update(all_kwargs.pop("kwargs"))
        hozer(**all_kwargs)
        self.f(*args, **kwargs)
</code></pre>
</div>
<span class="comment-copy">Why do you you need to know what args were positional?</span>
<span class="comment-copy">Because I need to convert them to kwargs to call in the hozer function.  This function only accepts kwargs, but it needs to know about all the arguments originally called. So depending on whether or not people call the decorated function with positional or named arguments the hozer function may or may not get all the data it needs.</span>
<span class="comment-copy">In fact, <code>kwargs.update(zip(myfunc.func_code.co_varnames, args))</code> is enough. <code>dict.update</code> handles 2D iterables too.</span>
<span class="comment-copy">This is the right way to do it (if you have Python 2.7 or later, which virtually everyone does).</span>
<span class="comment-copy">I've seen this copied and pasted into dozens of open source projects.   This should be moved up to a function people can call more easily!</span>
