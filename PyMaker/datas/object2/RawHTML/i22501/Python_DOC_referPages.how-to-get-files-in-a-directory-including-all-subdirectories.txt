<div class="post-text" itemprop="text">
<p>I'm trying to get a list of all log files (.log) in directory, including all subdirectories.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
import os.path

for dirpath, dirnames, filenames in os.walk("."):
    for filename in [f for f in filenames if f.endswith(".log")]:
        print os.path.join(dirpath, filename)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use the glob module along with os.walk.</p>
<pre><code>import os
from glob import glob

files = []
start_dir = os.getcwd()
pattern   = "*.log"

for dir,_,_ in os.walk(start_dir):
    files.extend(glob(os.path.join(dir,pattern))) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Checkout <a href="http://ssscripting.wordpress.com/2009/03/03/python-recursive-directory-walker/" rel="noreferrer">Python Recursive Directory Walker</a>. In short os.listdir() and os.walk() are your friends.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have a solution:</p>
<pre><code>import os
for logfile in os.popen('find . -type f -name *.log').read().split('\n')[0:-1]:
      print logfile
</code></pre>
<p>or</p>
<pre><code>import subprocess
(out, err) = subprocess.Popen(["find", ".", "-type", "f", "-name", "*.log"], stdout=subprocess.PIPE).communicate()
for logfile in out.split('\n')[0:-1]:
  print logfile
</code></pre>
<p>These two take the advantage of <code>find . -type f -name *.log</code>.</p>
<p>The first one is simpler but not guaranteed 
for white-space when add <code>-name *.log</code>, 
but worked fine for simply <code>find ../testdata -type f</code> 
(in my OS X environment).</p>
<p>The second one using subprocess seems more complicated, but this is the white-space safe one (again, in my OS X environment).</p>
<p>This is inspired by Chris Bunch, 
in the answer
<a href="https://stackoverflow.com/a/3503909/2834102">https://stackoverflow.com/a/3503909/2834102</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If You want to list in current directory, You can use something like:</p>
<pre><code>import os

for e in os.walk(os.getcwd()):
    print e
</code></pre>
<p>Just change the</p>
<pre><code>os.getcwd()
</code></pre>
<p>to other path to get results there.</p>
</div>
<span class="comment-copy">This has already been asked: <a href="http://stackoverflow.com/questions/837606/find-the-oldest-file-recursively-in-a-directory" title="find the oldest file recursively in a directory">stackoverflow.com/questions/837606/â€¦</a>, as well as a few others (search 'Python walk' in the search box)</span>
<span class="comment-copy">If you want to search in a different directory from "." you could pass the direcotry as sys.argv[1] and call os.walk(sys.argv[1]).</span>
<span class="comment-copy">Additional improvement: Use a generator instead of list comprehension: for filename in (f for f ...)</span>
<span class="comment-copy">If you want to exclude a certain directory, e.g., <code>old_logs</code>, you can simply remove it from <code>dirnames</code> and it won't be searched: <code>if "old_logs" in dirnames: dirnames.remove("old_logs")</code></span>
<span class="comment-copy">What do the underscores do in the for-loop? '_'</span>
<span class="comment-copy">@nueverest <code>os.walk</code> returns a 3-tuple <code>(dirpath, dirnames, filenames)</code> at each iteration, and we're only interested in <code>dirpath</code> (assigned to <code>dir</code> above); the underscores are just used as placeholders for the other 2 values we're not interested in (i.e. <code>dirnames</code>, and then <code>filenames</code>, are being assigned to the variable <code>_</code>, which we will never use).</span>
<span class="comment-copy">Why run <code>glob</code> and do extra I/O, when you already have the list of <code>filenames</code> which you could filter with <a href="https://docs.python.org/3/library/fnmatch.html#fnmatch.filter" rel="nofollow noreferrer"><code>fnmatch.filter</code></a>?</span>
<span class="comment-copy">This answer doesn't address the OP's question and isn't relevant to most people who would be seeking the same answer.</span>
