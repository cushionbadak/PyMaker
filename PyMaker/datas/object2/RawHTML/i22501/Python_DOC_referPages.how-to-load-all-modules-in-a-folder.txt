<div class="post-text" itemprop="text">
<p>Could someone provide me with a good way of importing a whole directory of modules?<br/>
I have a structure like this:</p>
<pre><code>/Foo
    bar.py
    spam.py
    eggs.py
</code></pre>
<p>I tried just converting it to a package by adding <code>__init__.py</code> and doing <code>from Foo import *</code> but it didn't work the way I had hoped.</p>
</div>
<div class="post-text" itemprop="text">
<p>List all python (<code>.py</code>) files in the current folder and put them as <code>__all__</code> variable in <code>__init__.py</code></p>
<pre><code>from os.path import dirname, basename, isfile
import glob
modules = glob.glob(dirname(__file__)+"/*.py")
__all__ = [ basename(f)[:-3] for f in modules if isfile(f) and not f.endswith('__init__.py')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Add the <code>__all__</code> Variable to <code>__init__.py</code> containing:</p>
<pre><code>__all__ = ["bar", "spam", "eggs"]
</code></pre>
<p>See also <a href="http://docs.python.org/tutorial/modules.html" rel="noreferrer">http://docs.python.org/tutorial/modules.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Update: Today you probably want to use <code>importlib</code> instead.</p>
<p>Make the Foo directory a package by adding an <code>__init__.py</code>. In that <code>__init__.py</code> add:</p>
<pre><code>import bar
import eggs
import spam
</code></pre>
<p>Since you want it dynamic (which may or may not be a good idea), list all py-files with list dir and import them with something like this:</p>
<pre><code>import os
for module in os.listdir(os.path.dirname(__file__)):
    if module == '__init__.py' or module[-3:] != '.py':
        continue
    __import__(module[:-3], locals(), globals())
del module
</code></pre>
<p>Then, from your code do this:</p>
<pre><code>import Foo
</code></pre>
<p>You can now access the modules with</p>
<pre><code>Foo.bar
Foo.eggs
Foo.spam
</code></pre>
<p>etc. from Foo import * is not a good idea for several reasons, including name clashes and making it hard to analyze the code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on Mihail's answer, I believe the non-hackish way (as in, not handling the file paths directly) is the following:</p>
<ol>
<li>create an empty <code>__init__.py</code> file under <code>Foo/</code></li>
<li>Execute</li>
</ol>
<pre class="lang-py prettyprint-override"><code>import pkgutil
import sys


def load_all_modules_from_dir(dirname):
    for importer, package_name, _ in pkgutil.iter_modules([dirname]):
        full_package_name = '%s.%s' % (dirname, package_name)
        if full_package_name not in sys.modules:
            module = importer.find_module(package_name
                        ).load_module(full_package_name)
            print module


load_all_modules_from_dir('Foo')
</code></pre>
<p>You'll get:</p>
<pre><code>&lt;module 'Foo.bar' from '/home/.../Foo/bar.pyc'&gt;
&lt;module 'Foo.spam' from '/home/.../Foo/spam.pyc'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Python, include all files under a directory:</h2>
<p>For newbies who just can't get it to work who need their hands held.</p>
<ol>
<li><p>Make a folder /home/el/foo and make a file <code>main.py</code> under /home/el/foo  Put this code in there:</p>
<pre><code>from hellokitty import *
spam.spamfunc()
ham.hamfunc()
</code></pre></li>
<li><p>Make a directory <code>/home/el/foo/hellokitty</code></p></li>
<li><p>Make a file <code>__init__.py</code> under <code>/home/el/foo/hellokitty</code> and put this code in there:</p>
<pre><code>__all__ = ["spam", "ham"]
</code></pre></li>
<li><p>Make two python files: <code>spam.py</code> and <code>ham.py</code> under <code>/home/el/foo/hellokitty</code></p></li>
<li><p>Define a function inside spam.py:</p>
<pre><code>def spamfunc():
  print "Spammity spam"
</code></pre></li>
<li><p>Define a function inside ham.py:</p>
<pre><code>def hamfunc():
  print "Upgrade from baloney"
</code></pre></li>
<li><p>Run it:</p>
<pre><code>el@apollo:/home/el/foo$ python main.py 
spammity spam
Upgrade from baloney
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>I got tired of this problem myself, so I wrote a package called automodinit to fix it. You can get it from <a href="http://pypi.python.org/pypi/automodinit/" rel="nofollow">http://pypi.python.org/pypi/automodinit/</a>. </p>
<p>Usage is like this:</p>
<ol>
<li>Include the <code>automodinit</code> package into your <code>setup.py</code> dependencies.</li>
<li>Replace all __init__.py files like this:</li>
</ol>
<pre>
__all__ = ["I will get rewritten"]
# Don't modify the line above, or this line!
import automodinit
automodinit.automodinit(__name__, __file__, globals())
del automodinit
# Anything else you want can go after here, it won't get modified.
</pre>
<p>That's it! From now on importing a module will set __all__ to
a list of .py[co] files in the module and will also import each
of those files as though you had typed:</p>
<pre><code>for x in __all__: import x
</code></pre>
<p>Therefore the effect of "from M import *" matches exactly "import M".</p>
<p><code>automodinit</code> is happy running from inside ZIP archives and is therefore ZIP safe.</p>
<p>Niall</p>
</div>
<div class="post-text" itemprop="text">
<p>I know I'm updating a quite old post, and I tried using <code>automodinit</code>, but found out it's setup process is broken for python3. So, based on Luca's answer, I came up with a simpler answer - which might not work with .zip - to this issue, so I figured I should share it here:</p>
<p>within the <code>__init__.py</code> module from <code>yourpackage</code>:</p>
<pre><code>#!/usr/bin/env python
import os, pkgutil
__all__ = list(module for _, module, _ in pkgutil.iter_modules([os.path.dirname(__file__)]))
</code></pre>
<p>and within another package below <code>yourpackage</code>:</p>
<pre><code>from yourpackage import *
</code></pre>
<p>Then you'll have all the modules that are placed within the package loaded, and if you write a new module, it'll be automagically imported as well. Of course, use that kind of things with care, with great powers comes great responsibilities.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have also encountered this problem and this was my solution:</p>
<pre><code>import os

def loadImports(path):
    files = os.listdir(path)
    imps = []

    for i in range(len(files)):
        name = files[i].split('.')
        if len(name) &gt; 1:
            if name[1] == 'py' and name[0] != '__init__':
               name = name[0]
               imps.append(name)

    file = open(path+'__init__.py','w')

    toWrite = '__all__ = '+str(imps)

    file.write(toWrite)
    file.close()
</code></pre>
<p>This function creates a file (in the provided folder) named <code>__init__.py</code>, which contains an <code>__all__</code> variable that holds every module in the folder. </p>
<p>For example, I have a folder named <code>Test</code>
which contains:</p>
<pre><code>Foo.py
Bar.py
</code></pre>
<p>So in the script I want the modules to be imported into I will write:</p>
<pre><code>loadImports('Test/')
from Test import *
</code></pre>
<p>This will import everything from <code>Test</code> and the <code>__init__.py</code> file in <code>Test</code> will now contain:</p>
<pre><code>__all__ = ['Foo','Bar']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Anurag's example with a couple of corrections:</p>
<pre><code>import os, glob

modules = glob.glob(os.path.join(os.path.dirname(__file__), "*.py"))
__all__ = [os.path.basename(f)[:-3] for f in modules if not f.endswith("__init__.py")]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/1057534/281545">Anurag Uniyal answer</a> with suggested improvements!</p>
<pre><code>#!/usr/bin/python
# -*- encoding: utf-8 -*-

import os
import glob

all_list = list()
for f in glob.glob(os.path.dirname(__file__)+"/*.py"):
    if os.path.isfile(f) and not os.path.basename(f).startswith('_'):
        all_list.append(os.path.basename(f)[:-3])

__all__ = all_list  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import pkgutil
__path__ = pkgutil.extend_path(__path__, __name__)
for imp, module, ispackage in pkgutil.walk_packages(path=__path__, prefix=__name__+'.'):
  __import__(module)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>See that your <code>__init__.py</code> defines <code>__all__</code>. The <a href="http://docs.python.org/tutorial/modules.html#packages" rel="nofollow noreferrer">modules - packages</a> doc says </p>
<blockquote>
<p>The <code>__init__.py</code> files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, <code>__init__.py</code> can just be an empty file, but it can also execute initialization code for the package or set the <code>__all__</code> variable, described later.</p>
<p>...</p>
<p>The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a package’s <code>__init__.py</code> code defines a list named <code>__all__</code>, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package. For example, the file <code>sounds/effects/__init__.py</code> could contain the following code:</p>
<p><code>__all__ = ["echo", "surround", "reverse"]</code></p>
<p>This would mean that <code>from sound.effects import *</code> would import the three named submodules of the sound package.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This is the best way i've found so far:</p>
<pre><code>from os.path import dirname, join, isdir, abspath, basename
from glob import glob
pwd = dirname(__file__)
for x in glob(join(pwd, '*.py')):
    if not x.startswith('__'):
        __import__(basename(x)[:-3], globals(), locals())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Look at the pkgutil module from the standard library. It will let you do exactly what you want as long as you have an <code>__init__.py</code> file in the directory. The <code>__init__.py</code> file can be empty.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've created a module for that, which doesn't rely on <code>__init__.py</code> (or any other auxiliary file) and makes me type only the following two lines:</p>
<pre><code>import importdir
importdir.do("Foo", globals())
</code></pre>
<p>Feel free to re-use or contribute: <a href="http://gitlab.com/aurelien-lourot/importdir" rel="nofollow">http://gitlab.com/aurelien-lourot/importdir</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Just import them by <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer">importlib</a> and add them to <code>__all__</code> (<code>add</code> action is optional) in recurse in the <code>__init__.py</code> of package.</p>
<pre><code>/Foo
    bar.py
    spam.py
    eggs.py
    __init__.py

# __init__.py
import os
import importlib
pyfile_extes = ['py', ]
__all__ = [importlib.import_module('.%s' % filename, __package__) for filename in [os.path.splitext(i)[0] for i in os.listdir(os.path.dirname(__file__)) if os.path.splitext(i)[1] in pyfile_extes] if not filename.startswith('__')]
del os, importlib, pyfile_extes
</code></pre>
</div>
<span class="comment-copy">The <b>init</b>.py way is pretty correct. Can you post the code that didn't work?</span>
<span class="comment-copy">Can you define "didn't work"? What happened?  What error message did you get?</span>
<span class="comment-copy">Is this Pythonic or recommended?  <a href="https://www.python.org/dev/peps/pep-0020/#id3" rel="nofollow noreferrer">"Explicit is better than implicit."</a></span>
<span class="comment-copy">Basically so I can drop python files into a directory with no further configuration and have them be executed by a script running somewhere else.</span>
<span class="comment-copy">@NiallDouglas this answer is for a specific question which OP asked, he  didn't have a zip file and pyc files can be included easily, and you are forgetting .pyd or .so libs etc too</span>
<span class="comment-copy">The only thing i would add is <code>if not os.path.basename(f).startswith('_')</code> or at the very least <code>if not f.endswith('__init__.py')</code> to the end of the list comprehension</span>
<span class="comment-copy">To make it more robust, also make sure <code>os.path.isfile(f)</code> is <code>True</code>. That would filter out broken symlinks and directories like <code>somedir.py/</code> (corner-case, I admit, but still...)</span>
<span class="comment-copy">Add <code>from . import *</code> after setting <code>__all__</code> if you want submodules to be available using <code>.</code> (e.g. as <code>module.submodule1</code>, <code>module.submodule2</code>, etc.).</span>
<span class="comment-copy">Yes, yes, but is there any way of having it be dynamic?</span>
<span class="comment-copy">Combination of <code>os.listdir()</code>, some filtering, stripping of <code>.py</code> extension and <code>__all__</code>.</span>
<span class="comment-copy">Not working for me as sample code here <a href="https://github.com/namgivu/python-import-all/blob/master/error_app.py" rel="nofollow noreferrer">github.com/namgivu/python-import-all/blob/master/error_app.py</a> . Maybe I miss something there?</span>
<span class="comment-copy">I found out myself - to use the variable/object defined in those modules, we have to use the full reference path e.g. <code>moduleName.varName</code> ref. <a href="https://stackoverflow.com/a/710603/248616">stackoverflow.com/a/710603/248616</a></span>
<span class="comment-copy">@NamGVU: This code in <a href="https://stackoverflow.com/a/14428820/355230">my answer</a> to a related question will import all the public sub-modules' names into the the package's namespace.</span>
<span class="comment-copy">Not bad, but don't forget that you can import .pyc and .pyo files too.</span>
<span class="comment-copy">add <code>del os</code>, too</span>
<span class="comment-copy">tbh, i find <code>__import__</code> hackish, i think it would be better to add the names to <code>__all__</code> and then put <code>from . import *</code> at the bottom of the script</span>
<span class="comment-copy">That would be pointless.</span>
<span class="comment-copy"><code>__import__</code> is not for general uses, it  used by <code>interpreter</code>, use <code>importlib.import_module()</code> instead.</span>
<span class="comment-copy">This is most of the way there to a correct answer - it handles ZIP archives, but doesn't write <b>init</b> nor import. See automodinit below.</span>
<span class="comment-copy">Another thing: the above example doesn't check sys.modules to see if the module is already loaded. Without that check the above will load the module a second time :)</span>
<span class="comment-copy">Thanks, now it's fixed :)</span>
<span class="comment-copy">When I run load_all_modules_from_dir('Foo/bar') with your code I get "RuntimeWarning: Parent module 'Foo/bar' not found while handling absolute import" - to suppress this, I have to set full_package_name = '.'.join(dirname.split(os.path.sep) + package_name]) and also import Foo.bar</span>
<span class="comment-copy">Those <code>RuntimeWarning</code> messages can also be avoided by not using full_package_name at all: <code>importer.find_module(package_name).load_module(package_name)</code>.</span>
<span class="comment-copy">pip can't download automodinit because there's nothing uploaded on pypi for it.</span>
<span class="comment-copy">Thanks for the bug report on github. I've fixed this in v0.13. Niall</span>
<span class="comment-copy">perfect, exactly what i am looking</span>
<span class="comment-copy">Where is pyfile_extes defined?</span>
<span class="comment-copy">sorry for missing it, now fixed. It is the extention of python file you want to import, usually just <code>py</code></span>
