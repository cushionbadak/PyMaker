<div class="post-text" itemprop="text">
<p>In Python 2.x when you want to mark a method as abstract, you can define it like so:</p>
<pre><code>class Base:
    def foo(self):
        raise NotImplementedError("Subclasses should implement this!")
</code></pre>
<p>Then if you forget to override it, you get a nice reminder exception. Is there an equivalent way to mark a field as abstract? Or is stating it in the class docstring all you can do?</p>
<p>At first I thought I could set the field to NotImplemented, but when I looked up what it's actually for (rich comparisons) it seemed abusive.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, you can. Use the <code>@property</code> decorator. For instance, if you have a field called "example" then can't you do something like this:</p>
<pre><code>class Base(object):

    @property
    def example(self):
        raise NotImplementedError("Subclasses should implement this!")
</code></pre>
<p>Running the following produces a <code>NotImplementedError</code> just like you want.</p>
<pre><code>b = Base()
print b.example
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternate answer:</p>
<pre><code>@property
def NotImplementedField(self):
    raise NotImplementedError

class a(object):
    x = NotImplementedField

class b(a):
    # x = 5
    pass

b().x
a().x
</code></pre>
<p>This is like Evan's, but concise and cheap--you'll only get a single instance of NotImplementedField.</p>
</div>
<div class="post-text" itemprop="text">
<p>A better way to do this is using <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer">Abstract Base Classes</a>:</p>
<pre><code>import abc

class Foo(abc.ABC):

    @property
    @abc.abstractmethod
    def demo_attribute(self):
        raise NotImplementedError

    @abc.abstractmethod
    def demo_method(self):
        raise NotImplementedError

class BadBar(Foo):
    pass

class GoodBar(Foo):

    demo_attribute = 'yes'

    def demo_method(self):
        return self.demo_attribute

bad_bar = BadBar()
# TypeError: Can't instantiate abstract class BadBar \
# with abstract methods demo_attribute, demo_method

good_bar = GoodBar()
# OK
</code></pre>
<p>Note that you should still have <code>raise NotImplementedError</code> instead of something like <code>pass</code>, because there is nothing preventing the inheriting class from calling <code>super().demo_method()</code>, and if the abstract <code>demo_method</code> is just <code>pass</code>, this will fail silently.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def require_abstract_fields(obj, cls):
    abstract_fields = getattr(cls, "abstract_fields", None)
    if abstract_fields is None:
        return

    for field in abstract_fields:
        if not hasattr(obj, field):
            raise RuntimeError, "object %s failed to define %s" % (obj, field)

class a(object):
    abstract_fields = ("x", )
    def __init__(self):
        require_abstract_fields(self, a)

class b(a):
    abstract_fields = ("y", )
    x = 5
    def __init__(self):
        require_abstract_fields(self, b)
        super(b, self).__init__()

b()
a()
</code></pre>
<p>Note the passing of the class type into <code>require_abstract_fields</code>, so if multiple inherited classes use this, they don't all validate the most-derived-class's fields.  You might be able to automate this with a metaclass, but I didn't dig into that.  Defining a field to None is accepted.</p>
</div>
<div class="post-text" itemprop="text">
<p>And here is my solution:</p>
<pre class="lang-py prettyprint-override"><code>def not_implemented_method(func):
    from functools import wraps
    from inspect import getargspec, formatargspec

    @wraps(func)
    def wrapper(self, *args, **kwargs):
        c = self.__class__.__name__
        m = func.__name__
        a = formatargspec(*getargspec(func))
        raise NotImplementedError('\'%s\' object does not implement the method \'%s%s\'' % (c, m, a))

    return wrapper


def not_implemented_property(func):
    from functools import wraps
    from inspect import getargspec, formatargspec

    @wraps(func)
    def wrapper(self, *args, **kwargs):
        c = self.__class__.__name__
        m = func.__name__
        raise NotImplementedError('\'%s\' object does not implement the property \'%s\'' % (c, m))

    return property(wrapper, wrapper, wrapper)
</code></pre>
<p>It can be used as</p>
<pre class="lang-py prettyprint-override"><code>class AbstractBase(object):
    @not_implemented_method
    def test(self):
        pass

    @not_implemented_property
    def value(self):
        pass

class Implementation(AbstractBase):
    value = None

    def __init__(self):
        self.value = 42

    def test(self):
        return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An interesting pattern to handle this is to set attribute to <code>None</code> in the parent class and to access the attribute with a function that ensure it has been set in the child class.</p>
<p>Here is an example from <a href="https://github.com/encode/django-rest-framework/blob/0e10d32fb122619a7977909536b642d09603192a/rest_framework/generics.py#L26" rel="nofollow noreferrer">django-rest-framework</a>:</p>
<pre><code>class GenericAPIView(views.APIView):

    [...]

    serializer_class = None

    [...]

    def get_serializer_class(self):
        assert self.serializer_class is not None, (
            "'%s' should either include a `serializer_class` attribute, "
            "or override the `get_serializer_class()` method."
            % self.__class__.__name__
        )

        return self.serializer_class
</code></pre>
</div>
<span class="comment-copy">It still works, even if it's original intent was for rich comparisons.  What's wrong with it?</span>
<span class="comment-copy">The first problem is you can read the field from the object (myvar = Base.field) and next thing you know there are NotImplementeds all over the place until some other part tries to use it and gets a mysterious AttributeError.</span>
<span class="comment-copy">The second problem is that IMO it hampers readability ("What's that rich comparison thing doing there? Did I miss something?)  Evan's solution expresses exactly what is going on in a familiar way.</span>
<span class="comment-copy">@Kiv: Please do not comment on your question.  Please update your question with the specific points you're raising.</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/2736255/abstract-attributes-in-python" title="abstract attributes in python">stackoverflow.com/questions/2736255/â€¦</a></span>
<span class="comment-copy">This is simpler, but I like how my version throws immediately and not only if the attribute happens to be used.</span>
<span class="comment-copy">But Glenn, what if the property <code>example</code> got set at some other point? If it throws it immediately, then it may never get a chance to be set through other means.   Remember that fields and methods can be set to a class at any time and not just when the class is defined.</span>
<span class="comment-copy">Ah, this is what I was after.</span>
<span class="comment-copy">If I'm defining a base class which expects a method (or field) to be defined by the user, I expect it to be defined at all times when the base class is active, from <b>init</b> onward.  I'd consider defining it later to be an error, because I might want to access them from <b>init</b>.  You can define your classes with different rules, of course, but this seems the clearest.  (Of course, as I'm originally a C++ programmer, I like nice, strict, well-defined interface rules.)</span>
<span class="comment-copy">@Glenn, two comments up: that sounds like the C++ philosophy, whereas the Python philosophy is much looser - you only care about what you get when you try to access a property. When you're not trying to access it, it can be anything, including undefined. (Of course this is no requirement, it's just the way a lot of Python code is written, and I think it's the intent of the language creators/maintainers that it be that way.)</span>
<span class="comment-copy">Clever, Glenn. :)   The only downside I can see is that you can't specify different messages to be shown when NotImplementedError gets thrown.</span>
<span class="comment-copy">You could define NotImplementedField as a function taking a message to display.  You'd have to get a little clever to keep it using a single instance of the function when no message is attached--cache a singleton for no message--but that's about it.</span>
<span class="comment-copy">@umbrae: See my previous comment (of two years ago); that's easy to implement if you want it.</span>
<span class="comment-copy">What is the difference between <code>raise NotImplementedError</code> and <code>raise NotImplementedError(something)</code>. On the face of it, the former raises a class, and the latter raises an instance. Is that ambiguity an issue / problem?</span>
<span class="comment-copy">@Reb.Cabin Both are valid. Typically, you would raise <code>NotImplementedError</code> when you are not providing any arguments and <code>raise NotImplementedError("something")</code> if you are providing arguments. See: <a href="https://stackoverflow.com/a/16709222/2063031">stackoverflow.com/a/16709222/2063031</a>.</span>
