<div class="post-text" itemprop="text">
<p>What is this language construct called?</p>
<p>In Python I can say:</p>
<pre><code>def a(b,c): return b+c
a(*[4,5])
</code></pre>
<p>and get 9. Likewise in Ruby:</p>
<pre><code>def a(b,c) b+c end
a(*[4,5])
</code></pre>
<p>What is this called, when one passes a single array to a function which otherwise requires multiple arguments?</p>
<p>What is the name of the <code>*</code> operator?</p>
<p>What other languages support this cool feature?</p>
</div>
<div class="post-text" itemprop="text">
<p>The Python docs call this <a href="http://docs.python.org/tutorial/controlflow.html#unpacking-argument-lists" rel="noreferrer">Unpacking Argument Lists</a>. It's a pretty handy feature. In Python, you can also use a double asterisk (**) to unpack a dictionary (hash) into keyword arguments. They also work in reverse. I can define a function like this:</p>
<pre><code>def sum(*args):
    result = 0
    for a in args:
        result += a
    return result

sum(1,2)
sum(9,5,7,8)
sum(1.7,2.3,8.9,3.4)
</code></pre>
<p>To pack all arguments into an arbitrarily sized list.</p>
</div>
<div class="post-text" itemprop="text">
<p>In ruby, it is often called "splat".</p>
<p>Also in ruby, you can use it to mean 'all of the other elements in the list'.</p>
<pre><code>a, *rest = [1,2,3,4,5,6]
a     # =&gt; 1
rest  # =&gt; [2, 3, 4, 5, 6]
</code></pre>
<p>It can also appear on either side of the assignment operator:</p>
<pre><code>a  = d, *e
</code></pre>
<p>In this usage, it is a bit like scheme's cdr, although it needn't be all but the head of the list.</p>
</div>
<div class="post-text" itemprop="text">
<p>The typical terminology for this is called "applying a function to a list",
or "apply" for short. </p>
<p>See <a href="http://en.wikipedia.org/wiki/Apply" rel="noreferrer">http://en.wikipedia.org/wiki/Apply</a></p>
<p>It has been in LISP since pretty much its inception back in 1960 odd.
Glad python rediscovered it :-}</p>
<p>Apply is typically on a <em>list</em> or a representation of a list such
as an array.  However, one can apply functions to arguments that
come from other palces, such as structs.   Our PARLANSE language
has fixed types (int, float, string, ...) and structures.
Oddly enough, a function argument list looks a lot like a structure
definintion, and in PARLANSE, it <em>is</em> a structure definition,
and you can "apply" a PARLANSE function to a compatible structure.
You can "make" structure instances, too, thus:</p>
<pre>

 (define S
    (structure [t integer]
               [f float]
               [b (array boolean 1 3)]
    )structure
 )define s

  (= A (array boolean 1 3 ~f ~F ~f))

  (= s (make S -3 19.2 (make (array boolean 1 3) ~f ~t ~f))


  (define foo (function string S) ...)

  (foo +17 3e-2 A) ; standard function call

  (foo s) ; here's the "apply"

</pre>
<p>PARLANSE looks like lisp but isn't.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ruby calls it <strong>splat</strong>, though David Black has also come up with the neat <strong>unar{,ra}y operator</strong> (i.e. <strong>unary unarray operator</strong>)</p>
</div>
<div class="post-text" itemprop="text">
<p>I've been calling it "list expansion", but I don't think that's standard terminology (I don't think there's any...).  Lisp in all versions (Scheme included), and Haskell and other functional languages, can do it easily enough, but I don't think it's easy to do in "mainstream" languages (maybe you can pull it off as a "reflection" stunt in some!-).</p>
</div>
<div class="post-text" itemprop="text">
<p>Haskell has it too (for pairs), with the <code>uncurry</code> function:</p>
<pre><code>ghci&gt; let f x y = 2*x + y
f :: (Num a) =&gt; a -&gt; a -&gt; a
ghci&gt; f 1 2
4
ghci&gt; f 10 3
23
ghci&gt; uncurry f (1,2)
4
ghci&gt; uncurry f (10,3)
23
</code></pre>
<p>You can also make it into an operator, so it's more splat-like:</p>
<pre><code>ghci&gt; f `uncurry` (1,2)
4
ghci&gt; let (***) = uncurry
(***) :: (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
ghci&gt; f *** (10,3)
23
</code></pre>
<p>And though it'd be easy to define similar functions for the 3-tuple, 4-tuple, etc cases, there isn't any general function for <code>n</code>-tuples (like splat works in other languages) because of Haskell's strict typing.</p>
</div>
<div class="post-text" itemprop="text">
<p>The majority of the questions have already been answered, but as to the question "What is the name of the * operator?": the technical term is "asterisk" (comes from the Latin word <em>asteriscum</em>, meaning "little star", which, in turn, comes from the Greek <em>ἀστερίσκος</em>). Often, though, it will be referred to as "star" or, as stated above, "splat".</p>
</div>
<span class="comment-copy">Duplicate <a href="http://stackoverflow.com/questions/918449/what-is-the-operator-doing-to-this-string-in-ruby/918475" title="what is the operator doing to this string in ruby">stackoverflow.com/questions/918449/…</a></span>
<span class="comment-copy">@seth: No, not a duplicate. The question you linked to is about the <i>semantics</i> of this operator (in Ruby); this question is about <i>terminology</i>.</span>
<span class="comment-copy">I've known about this for awhile, and blindly used it once and awhile but never really understood it.  Nice clear and simple explanation.</span>
<span class="comment-copy">+1 "Argument unpacking" is the general term I've always heard for it.</span>
<span class="comment-copy">the repacking trick works the same in ruby</span>
<span class="comment-copy">Notably, the **kwargs feature has no direct analog in ruby, although it can be almost approximated by having a Hash as the last argument.  There are some differences with this, however.</span>
<span class="comment-copy">I wish I could accept multiple answers--credit needs to go also to Matthew Schinckel and Alex Martelli for answering the Ruby side of the question. Thanks to everyone who participated!</span>
<span class="comment-copy">The splat operator is the term used in The Ruby Programming Language, which is supposedly co-written by Matz (create of Ruby)</span>
<span class="comment-copy">The "all of the other elements in the list" syntax (having a starred name on the left side of the assignment) was added in Python 3—your example will work unmodified.  Also (in Python 3), the starred variable doesn't have to be last: <code>a, b, *middle, y, z = range(10)</code> works.  It can't appear on the right side of an assignment, though, but it's not really needed, since you can do <code>l = list(a, *b)</code>.</span>
<span class="comment-copy">Yeah, I think I remember reading that.  I still use python 2.4-2.6 at work (and will continue to do so, I suspect).  I just did a test with ruby 1.8, and the *var must be the last in the list.</span>
<span class="comment-copy">@Miles It does work but I couldn't find it in the documentation, or anywhere but here in that matter. There are also no explanations of why <code>a, *b = (1,2,3)</code> yields <code>b==[2,3]</code> instead of <code>(2,3)</code>.</span>
<span class="comment-copy">@Evpok specification is here: <a href="http://www.python.org/dev/peps/pep-3132/" rel="nofollow noreferrer">python.org/dev/peps/pep-3132</a> but for the most part it doesn't seem to have made it into the documentation proper, except for a brief mention in <a href="http://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">the reference manual</a> and in the <a href="http://docs.python.org/3/whatsnew/3.0.html#new-syntax" rel="nofollow noreferrer">release notes</a>.</span>
<span class="comment-copy">Calling a varargs syntax "applying a function to a list" is just plain wrong, IMO. The reference to PARLANSE doesn't seem to make a contribution either.</span>
<span class="comment-copy">@Thomas: OP clearly said, "passes an array to a function for multiple arguments". LIke it or not, that's applying a function to a representation of a list.  OP also asked for other languages "with this cool feature"; the PARLANSE example is similar but different and is provided as a contrast.</span>
<span class="comment-copy">I would argue (like ThomasH) that there is a significant difference between apply, which executes the same function n times on the items of a list, and splat/var-args which calls the function once with the elements of the list as the parameters.</span>
<span class="comment-copy">@Matthew: You are confusing "map" with "apply". See this reference: <a href="http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html" rel="nofollow noreferrer">n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html</a></span>
<span class="comment-copy">Yes, you are correct.  I meant map.</span>
<span class="comment-copy">I don't know of any standard terminology either, but I've always pronounced '*args' as 'star args' and '**kwargs' 'kay word args'.  I'm sure others have their own terminology, and I'm curious to hear it it.</span>
<span class="comment-copy">+1 for the laugh, even if it wasn't intended.</span>
