<div class="post-text" itemprop="text">
<p>I'm wondering if Python has anything like the C# anonymous classes feature. To clarify, here's a sample C# snippet:</p>
<pre><code>var foo = new { x = 1, y = 2 };
var bar = new { y = 2, x = 1 };
foo.Equals(bar); // "true"
</code></pre>
<p>In Python, I would imagine something like this:</p>
<pre><code>foo = record(x = 1, y = 2)
bar = record(y = 2, x = 1)
foo == bar  # true
</code></pre>
<p>The specific requirement is being able to create an object with specified fields in expression context (e.g. usable in lambdas and other places where statements aren't allowed), with no additional external declarations, and ability to access individual components by name via the normal member access syntax <code>foo.bar</code>. The created object should also implement structural comparison <em>by component names</em>  (not by position, as tuples do).</p>
<p>In particular: tuples isn't it because their components are not named; classes isn't it because they require a declaration; dicts isn't it because they have undesired <code>foo["bar"]</code> syntax to access components.</p>
<p><a href="http://docs.python.org/library/collections.html?highlight=namedtuples#namedtuple-factory-function-for-tuples-with-named-fields" rel="noreferrer">namedtuple</a> isn't it, because it still requires a name even if you define the type inline, and the comparison is position-based, not name-based. In particular:</p>
<pre><code> def foo(): return namedtuple("Foo", "x y")(x = 1, y = 2)
 def bar(): return namedtuple("Foo", "y x")(x = 1, y = 2)
 foo() == bar()   # False because fields are compared in order, and not by name
                  # True would be desired instead
</code></pre>
<p>I know how to write such a thing in Python if needed. But I would like to know if there's anything like that in the Python standard library, or any popular third-party libraries.</p>
<h2>[EDIT]</h2>
<p>Just for the sake of it, here's a single-expression solution that combines two very informative answers by Ken and alanlcode, yielding structural equality without any extra outside declarations:</p>
<pre><code>type("", (), { \
    "__init__": (lambda self, **kwargs: self.__dict__.update(kwargs)), \
    "__eq__": (lambda self, other: self.__dict__ == other.__dict__) } \
)(x = 1, y = 2)
</code></pre>
<p>Technically, it satisfies all the requirements of the question, but I sincerely hope that no-one ever uses it (I definitely won't).</p>
</div>
<div class="post-text" itemprop="text">
<p>The pythonic way would be to use a <code>dict</code>:</p>
<pre><code>&gt;&gt;&gt; foo = dict(x=1, y=2)
&gt;&gt;&gt; bar = dict(y=2, x=1)
&gt;&gt;&gt; foo == bar
True
</code></pre>
<p>Meets all your requirements except that you still have to do <code>foo['x']</code> instead of <code>foo.x</code>. </p>
<p>If that's a problem, you could easily define a class such as:</p>
<pre><code>class Bunch(object):
    def __init__(self, **kwds):
        self.__dict__.update(kwds)

    def __eq__(self, other):
        return self.__dict__ == other.__dict__
</code></pre>
<p>Or, a nice and short one</p>
<pre><code>class Bunch(dict):
    __getattr__, __setattr__ = dict.get, dict.__setitem__
</code></pre>
<p>(but note that this second one has problems as Alex points out in his comment!)</p>
</div>
<div class="post-text" itemprop="text">
<p>1) See <a href="http://uszla.me.uk/space/blog/2008/11/06" rel="noreferrer">http://uszla.me.uk/space/blog/2008/11/06</a>.  You can create an anonymous object with slightly ugly syntax by using the <code>type</code> built-in function:</p>
<pre><code> anon_object_2 = type("", (), {})()
</code></pre>
<p>where the 3rd parameter is the dict that will contain the fields of your object.</p>
<pre><code> foo = type("", (), dict(y=1))()
 foo.y == 1
</code></pre>
<p>2) Another variation is proposed by Peter Norvig at <a href="http://norvig.com/python-iaq.html" rel="noreferrer">http://norvig.com/python-iaq.html</a>.  It is also similar to the answer posted by Ken.</p>
<pre><code>class Struct:
    def __init__(self, **entries): self.__dict__.update(entries)

&gt;&gt;&gt; options = Struct(answer=42, linelen = 80, font='courier')
&gt;&gt;&gt; options.answer
42
</code></pre>
<p>The benefit of this method is that you can implement equality by contents of the dict, which the first option doesn't have.</p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like Python 3.3 has added exactly this thing in the form of <a href="http://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer"><code>types.SimpleNamespace</code></a> class.</p>
</div>
<div class="post-text" itemprop="text">
<p>The type(...) form will fail the structural comparison requirement (without getting really ugly).  The dict(...) form doesn't meet the attribute accessor requirement.</p>
<p>The <a href="http://code.activestate.com/recipes/361668/" rel="noreferrer">attrdict</a> seems to fall in the middle somewhere:</p>
<pre><code>class attrdict(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.__dict__ = self

a = attrdict(x=1, y=2)
b = attrdict(y=2, x=1)

print a.x, a.y
print b.x, b.y
print a == b
</code></pre>
<p>But it means defining a special class.</p>
<p>OK, I just noticed the update to the question.  I'll just note that you can specify <code>dict</code> for the bases parameter and only need to specify the constructor then (in the icky type expression).  I prefer attrdict. :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't remember offhand if there's a built-in but writing it yourself is shorter than typing your question.  :-)</p>
<pre><code>class record(object):
  def __init__(self, **kwargs): self.__dict__ = kwargs
  def __eq__(self, r2): return self.__dict__ == r2.__dict__
  def __ne__(self, r2): return self.__dict__ != r2.__dict__

foo = record(x=1, y=2)
bar = record(y=2, x=1)
foo == bar  # =&gt; true
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want the instance to be anonymous as well (using the object directly in an expression), then you're bound to use the type-expression. However in many cases the instance will not be anonymous, but assigned to a variable. This case can be handled in a reasonable way in python by using metaclasses or decorators. </p>
<p>An example using decorator:</p>
<pre><code>def anonymous(cls):
    return cls()

@anonymous
class foo:
     x = 42

     def bar(self):
          return self.x
</code></pre>
<p>The decorator in this case causes the class <code>foo</code> to be instantiated an put into the variable <code>foo</code> instead of the class itself. The class itself will not be accessible from any namespace although it has a name:</p>
<pre><code>&gt;&gt;&gt; foo
&lt;__main__.foo instance at 0x7fd2938d8320&gt;
&gt;&gt;&gt; foo.bar()
42
</code></pre>
<p>Another feature in python that accomodates for many use cases is that it's legal to define classes locally, which means that they would become a symbol local to that function, which in turns gives it some degree of anonymity.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quoted from <a href="http://norvig.com/python-iaq.html" rel="nofollow noreferrer">this page</a>:</p>
<pre><code> class Struct:
     def __init__(self, **entries): self.__dict__.update(entries)
     def __eq__(self, other): return self.__dict__ == other.__dict__
     def __ne__(self, other): return self.__dict__ != other.__dict__

 options = Struct(answer=42, linelen = 80, font='courier')
 options.answer
 &gt;&gt;&gt; 42
 options.answer = 'plastics'
 vars(options)
 &gt;&gt;&gt; {'answer': 'plastics', 'font': 'courier', 'linelen': 80}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://i.stack.imgur.com/UdljI.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/UdljI.png"/></a></p>
<p>As show above, I get a good intellisense from pycharm for this and I love this solution...</p>
<pre><code>&gt;&gt;&gt; def anonymous(cls):
...     return cls()
&gt;&gt;&gt; class fooo:
...     @anonymous
...     class c:
...             D=10
&gt;&gt;&gt; fooo.c.D
10
</code></pre>
</div>
<span class="comment-copy">sounds like dictionaries should do the job.  I find it's best to find the python way to do it than fit another language in to python.  BTW -- if you don't like the dictionary, foo["bar"] access method an alternative is to use the get method: foo.get("bar")</span>
<span class="comment-copy">Given that this is trivially implementable in Python if needed, I don't see any particular reason not to do so, and definitely don't consider it "fitting another language in to Python". Especially as it seems pretty close to the existing <code>namedtuple</code> in intent.</span>
<span class="comment-copy">I find it bizarre to ask a question if language X has the feature of language Y, and then require everything to be exactly the same. Languages are not exactly the same. Python does not have anonymous functions, but they have dictionaries, and they work just as well. Yes, the access syntax is different. Big friggin deal.</span>
<span class="comment-copy">I'm not asking for feature to be exactly the same - if I did, I'd be asking for static typing and immutability as well ;) I'm merely asking for syntax which I view as more natural and convenient.</span>
<span class="comment-copy">I to had a tendency to create objects so I could stick data on them for attribute access in the beginning. You'll get used to dicts soon.</span>
<span class="comment-copy">From the question - " ... dicts isn't it because they have undesired foo["bar"] syntax to access components."</span>
<span class="comment-copy">this works, except to access things it is foo['x'], not foo.x</span>
<span class="comment-copy">Nonetheless, the request is what it is, and this doesn't answer it. I also fail to see how it is "un-Pythonic", considering the existence of <code>namedtuple</code>, which gives most of the syntactic sugar that I want.</span>
<span class="comment-copy">I think "Bunch" (first form) is the right answer (but I'm biased since I coined the name, 8+ years ago -- see <a href="http://code.activestate.com/recipes/52308/" rel="nofollow noreferrer">code.activestate.com/recipes/52308</a> which btw is the top google hit for the search [bunch python];-). The second form has deep and somewhat subtle problems, do x=Bunch(update=23) and see what x.update <i>IS</i>;-) -- you call that NICE?-)</span>
<span class="comment-copy">@Alex: How about setting <code>__getattribute__ = dict.get</code>? Ugly, yes, but does it still have problems?</span>
<span class="comment-copy">I like the 'struct' class.  Very useful to me, as my problem didn't require any special methods or operators.   In a nutshell, I am using suds/soap and most of the time suds will build a 'reply' object for me, who's structure defined by a WSDL. If you get bad XML, the sax parser throws an exception leaving you with no reply object. I 'fake' a reply object with the Struct class above (setting only properties 'error' and 'message' per my application) and pass this downstream.   If error handling ever expects more properties (or methods?) It's easy to add (extend?) this class to match.  WIN.</span>
<span class="comment-copy">This answer should be at the top.</span>
<span class="comment-copy">Setting self.__dict__ = self causes a memory leak, so I'd advise against this. <a href="http://bugs.python.org/issue1469629" rel="nofollow noreferrer">bugs.python.org/issue1469629</a></span>
<span class="comment-copy">Isn't the <code>__init__</code> call supposed to look like this <code>super(attrdict, self).__init__(*args, **kwargs)</code>?</span>
<span class="comment-copy">@rmmh That bug is marked as fixed.</span>
<span class="comment-copy">Neat (I knew how to do this in general, but didn't realize it's that simple). Now, on to the real question: would you be willing to submit a PEP for the above? :)</span>
<span class="comment-copy">By the way, is <code>__neq__</code> really needed? Isn't the default definition as <code>not __eq__</code> provided automatically?</span>
<span class="comment-copy">Pavel: that's what I initially thought, but when I tried it, it didn't seem to work that way (though it's quite possible I screwed up).</span>
<span class="comment-copy"><code>__neq__</code> should be <code>__ne__</code>, and no it is not provided automatically.</span>
<span class="comment-copy">it's not <b>neq</b> it's <b>ne</b></span>
<span class="comment-copy">@skyking using you hint and I love this... I which I had more provisions on stackoverflow</span>
