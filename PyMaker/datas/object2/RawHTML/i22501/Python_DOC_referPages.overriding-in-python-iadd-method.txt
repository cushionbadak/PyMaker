<div class="post-text" itemprop="text">
<p>Is it possible to override += in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, override the <a href="https://docs.python.org/3/reference/datamodel.html?highlight=iadd#object.__iadd__" rel="noreferrer"><code>__iadd__</code></a> method. Example:</p>
<pre><code>def __iadd__(self, other):
    self.number += other.number
    return self    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In addition to what's correctly given in answers above, it is worth explicitly clarifying that when <code>__iadd__</code> is overriden, the <code>x += y</code> operation does NOT end with the end of <code>__iadd__</code> method.</p>
<p>Instead, it ends with <code>x = x.__iadd__(y)</code>. In other words, Python assigns the return value of your <code>__iadd__</code> implementation to the object you're "adding to", AFTER the implementation completes.</p>
<p>This means it is possible to mutate the left side of the <code>x += y</code> operation so that the final implicit step fails. Consider what can happen when you are adding to something that's within a list:</p>
<p><code>&gt;&gt;&gt; x[1] += y # x has two items</code></p>
<p>Now, if your <code>__iadd__</code> implementation (a method of an object at <code>x[1]</code>) erroneously or on purpose removes the first item (<code>x[0]</code>) from the beginning of the list, Python will then run your <code>__iadd__</code> method) &amp; try to assign its return value to <code>x[1]</code>. Which will no longer exist (it will be at <code>x[0]</code>), resulting in an <code>ÌndexError</code>. </p>
<p>Or, if your <code>__iadd__</code> inserts something to beginning of <code>x</code> of the above example, your object will be at <code>x[2]</code>, not <code>x[1]</code>, and whatever was earlier at <code>x[0]</code> will now be at <code>x[1]</code>and be assigned the return value of the <code>__iadd__</code> invocation.</p>
<p>Unless one understands what's happening, resulting bugs can be a nightmare to fix.</p>
</div>
<div class="post-text" itemprop="text">
<p>In addition to overloading <code>__iadd__</code> (remember to return self!), you can also fallback on <code>__add__</code>, as x += y will work like x = x + y. (This is one of the pitfalls of the += operator.)</p>
<pre><code>&gt;&gt;&gt; class A(object):
...   def __init__(self, x):
...     self.x = x
...   def __add__(self, other):
...     return A(self.x + other.x)
&gt;&gt;&gt; a = A(42)
&gt;&gt;&gt; b = A(3)
&gt;&gt;&gt; print a.x, b.x
42 3
&gt;&gt;&gt; old_id = id(a)
&gt;&gt;&gt; a += b
&gt;&gt;&gt; print a.x
45
&gt;&gt;&gt; print old_id == id(a)
False
</code></pre>
<p>It even <a href="https://stackoverflow.com/questions/1045344/how-do-you-create-an-incremental-id-in-a-python-class/1045368#1045368">trips up experts</a>:</p>
<pre><code>class Resource(object):
  class_counter = 0
  def __init__(self):
    self.id = self.class_counter
    self.class_counter += 1

x = Resource()
y = Resource()
</code></pre>
<p>What values do you expect <code>x.id</code>, <code>y.id</code>, and <code>Resource.class_counter</code> to have?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/reference/datamodel.html#emulating-numeric-types" rel="noreferrer">http://docs.python.org/reference/datamodel.html#emulating-numeric-types</a></p>
<blockquote>
<p>For instance, to execute the statement
  x += y, where x is an instance of a
  class that has an __iadd__() method,
  x.__iadd__(y) is called.</p>
</blockquote>
</div>
<span class="comment-copy">Exact duplicate of <a href="http://stackoverflow.com/questions/728361/is-there-a-way-to-overload-in-python" title="is there a way to overload in python">stackoverflow.com/questions/728361/…</a></span>
<span class="comment-copy">yes, but using the site search for: += python  gives no results. putting quotes around "+=" gives results but mostly irrelevant judging by the headlines. found this via a Google search though.</span>
<span class="comment-copy">You shouldn't implement <code>__iadd__</code> if your class represents immutable objects. In that case just implement <code>__add__</code> which will be used to override <code>+=</code> instead. For example you can use <code>+=</code> on immutable types such as strings and integers, which couldn't be done using <code>__iadd__</code>.</span>
<span class="comment-copy">@ScottGriffiths, so are you saying that if you've implemented <code>__add__</code> you don't necessarily have to implement <code>__iadd__</code>? I read the duplicate question you linked but I just got confused because I don't understand why you would implement <code>__add__</code> so that it mutates the object</span>
<span class="comment-copy">@ScottGriffiths meant ask "you don't necessarily have to implement <code>__iadd__</code> <b>to use +=</b>?"</span>
<span class="comment-copy">@JosieThompson: If you don't implement <code>__iadd__</code> then it will use <code>__add__</code> if available, which is usually just fine. So in that case <code>a += b</code> would be equivalent to <code>a = a + b</code>, which assigns a new value to <code>a</code> instead of changing <code>a</code> itself. Having a separate <code>__iadd__</code> is typically a nice optimisation rather than something you need to use the <code>+=</code> operator.</span>
<span class="comment-copy">@ScottGriffiths Is the same true for <code>__imul__</code>?</span>
<span class="comment-copy">Your second example has nothing to do with iadd or +=.  The same result occurs if you use self.class_counter = self.class_counter + 1  It's just a scoping issue, using self when Resource should be used.</span>
<span class="comment-copy">It's an example of how using += can lead to problems. If you're overloading <b>iadd</b>, then you're opening users of your class (including yourself) to this, and, at the very least, you should know the issue exists beforehand.</span>
<span class="comment-copy">@FogleBird: It is a gotcha because <code>foo += bar</code> can either mean "mutate the existing object that <code>foo</code> refers to" or "assign <code>foo</code> to the object resulting from the expression <code>foo + bar</code>". And which happens depends on whether <code>foo</code> has an <code>__iadd__</code> method.</span>
