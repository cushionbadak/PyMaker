<div class="post-text" itemprop="text">
<p>Let's say I have the following:</p>
<pre><code>def with_connection(f):
    def decorated(*args, **kwargs):
        f(get_connection(...), *args, **kwargs)
    return decorated

@with_connection
def spam(connection):
    # Do something
</code></pre>
<p>I want to test the <code>spam</code> function without going through the hassle of setting up a connection (or whatever the decorator is doing).</p>
<p>Given <code>spam</code>, how do I strip the decorator from it and get the underlying "undecorated" function?</p>
</div>
<div class="post-text" itemprop="text">
<p>In the general case, you can't, because</p>
<pre><code>@with_connection
def spam(connection):
    # Do something
</code></pre>
<p>is equivalent to</p>
<pre><code>def spam(connection):
    # Do something

spam = with_connection(spam)
</code></pre>
<p>which means that the "original" spam might not even exist anymore. A (not too pretty) hack would be this:</p>
<pre><code>def with_connection(f):
    def decorated(*args, **kwargs):
        f(get_connection(...), *args, **kwargs)
    decorated._original = f
    return decorated

@with_connection
def spam(connection):
    # Do something

spam._original(testcon) # calls the undecorated function
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>balpha's solution can be made more generalizable with this meta-decorator:</p>
<pre><code>def include_original(dec):
    def meta_decorator(f):
        decorated = dec(f)
        decorated._original = f
        return decorated
    return meta_decorator
</code></pre>
<p>Then you can decorate your decorators with @include_original, and every one will have a testable (undecorated) version tucked away inside it.</p>
<pre><code>@include_original
def shout(f):
    def _():
        string = f()
        return string.upper()
    return _



@shout
def function():
    return "hello world"

&gt;&gt;&gt; print function()
HELLO_WORLD
&gt;&gt;&gt; print function._original()
hello world
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's been a bit of an update for this question. If you're using Python 3, you can use <code>__wrapped__</code> property for decorators from stdlib.</p>
<p>Here's an example from <a href="https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch09.html#_unwrapping_a_decorator" rel="noreferrer">Python Cookbook, 3rd edition, section 9.3 Unwrapping decorators</a></p>
<pre><code>&gt;&gt;&gt; @somedecorator
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; orig_add = add.__wrapped__
&gt;&gt;&gt; orig_add(3, 4)
7
&gt;&gt;&gt;
</code></pre>
<p>If you are trying to unwrap a function from custom decorator, the decorator function needs to use <code>wraps</code> function from <code>functools</code> See discussion in <a href="https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch09.html#decoratormeta" rel="noreferrer">Python Cookbook, 3rd edition, section 9.2 Preserving function metadata when writing decorators</a></p>
<pre><code>&gt;&gt;&gt; from functools import wraps
&gt;&gt;&gt; def somedecoarator(func):
...    @wraps(func)
...    def wrapper(*args, **kwargs):
...       # decorator implementation here
...       # ...
...       return func(*args, kwargs)
...
...    return wrapper
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Behold, FuglyHackThatWillWorkForYourExampleButICantPromiseAnythingElse:</p>
<pre><code> orig_spam = spam.func_closure[0].cell_contents
</code></pre>
<p><strong>Edit</strong>: For functions/methods decorated more than once and with more complicated decorators you can try using the following code. It relies on the fact, that decorated functions are __name__d differently than the original function.</p>
<pre><code>def search_for_orig(decorated, orig_name):
    for obj in (c.cell_contents for c in decorated.__closure__):
        if hasattr(obj, "__name__") and obj.__name__ == orig_name:
            return obj
        if hasattr(obj, "__closure__") and obj.__closure__:
            found = search_for_orig(obj, orig_name)
            if found:
                return found
    return None

 &gt;&gt;&gt; search_for_orig(spam, "spam")
 &lt;function spam at 0x027ACD70&gt;
</code></pre>
<p>It's not fool proof though. It will fail if the name of the function returned from a decorator is the same as the decorated one. The order of hasattr() checks is also a heuristic,  there are decoration chains that return wrong results in any case.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can now use the <a href="https://pypi.python.org/pypi/undecorated" rel="nofollow noreferrer">undecorated</a> package:</p>
<pre><code>&gt;&gt;&gt; from undecorated import undecorated
&gt;&gt;&gt; undecorated(spam)
</code></pre>
<p>It goes through the hassle of digging through all the layers of different decorators until it reaches the bottom function and doesn't require changing the original decorators. It works on both Python 2 and Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of doing...</p>
<pre><code>def with_connection(f):
    def decorated(*args, **kwargs):
        f(get_connection(...), *args, **kwargs)
    return decorated

@with_connection
def spam(connection):
    # Do something

orig_spam = magic_hack_of_a_function(spam)
</code></pre>
<p>You could just do...</p>
<pre><code>def with_connection(f):
    ...

def spam_f(connection):
    ...

spam = with_connection(spam_f)
</code></pre>
<p>...which is all the <code>@decorator</code> syntax does - you can then obviously access the original <code>spam_f</code> normally.</p>
</div>
<div class="post-text" itemprop="text">
<p>The usual approach to testing such functions is to make any dependencies, such as get_connection, configurable. Then you can override it with a mock while testing. Basically the same as dependency injection in the Java world but a lot simpler thanks to Pythons dynamic nature.</p>
<p>Code for it might look something like this:</p>
<pre><code># decorator definition
def with_connection(f):
    def decorated(*args, **kwargs):
        f(with_connection.connection_getter(), *args, **kwargs)
    return decorated

# normal configuration
with_connection.connection_getter = lambda: get_connection(...)

# inside testsuite setup override it
with_connection.connection_getter = lambda: "a mock connection"
</code></pre>
<p>Depending on your code you could find a better object than the decorator to stick the factory function on. The issue with having it on the decorator is that you'd have to remember to restore it to the old value in the teardown method.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's good practice to decorate decorators with <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a> like so:</p>
<pre><code>import functools

def with_connection(f):
    @functools.wraps(f)
    def decorated(*args, **kwargs):
        f(get_connection(...), *args, **kwargs)
    return decorated

@with_connection
def spam(connection):
    # Do something
</code></pre>
<p>As of Python 3.2, this will automatically add a <code>__wrapped__</code> attribute that lets you retrieve the original, undecorated function:</p>
<pre><code>&gt;&gt;&gt; spam.__wrapped__
&lt;function spam at 0x7fe4e6dfc048&gt;
</code></pre>
<p>However, instead of manually accessing the <code>__wrapped__</code> attribute, it's better to use <a href="https://docs.python.org/3/library/inspect.html#inspect.unwrap" rel="nofollow noreferrer"><code>inspect.unwrap</code></a>:</p>
<pre><code>&gt;&gt;&gt; inspect.unwrap(spam)
&lt;function spam at 0x7fe4e6dfc048&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the original function is stored in <code>spam.__closure__[0].cell_contents</code>.<br/>
Decorator uses closure to bind original function with extra layer of functionality. The original function must be stored in a closure cell kept by one of the functions in the nested structure of decorator.<br/>
Example:</p>
<pre><code>&gt;&gt;&gt; def add(f):
...     def _decorator(*args, **kargs):
...             print('hello_world')
...             return f(*args, **kargs)
...     return _decorator
... 
&gt;&gt;&gt; @add
... def f(msg):
...     print('f ==&gt;', msg)
... 
&gt;&gt;&gt; f('alice')
hello_world
f ==&gt; alice
&gt;&gt;&gt; f.__closure__[0].cell_contents
&lt;function f at 0x7f5d205991e0&gt;
&gt;&gt;&gt; f.__closure__[0].cell_contents('alice')
f ==&gt; alice
</code></pre>
<p>this is the core principle of <a href="https://github.com/lolyu/undecorated/blob/master/undecorated.py" rel="nofollow noreferrer">undecorated</a>, you could refer to the source code for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>Add a do-nothing decorator:</p>
<pre><code>def do_nothing(f):
    return f
</code></pre>
<p>After defining or importing with_connection but before you get to the methods that use it as a decorator, add:</p>
<pre><code>if TESTING:
    with_connection = do_nothing
</code></pre>
<p>Then if you set the global TESTING to True, you will have replaced with_connection with a do-nothing decorator.</p>
</div>
<span class="comment-copy">If you going to modify the code to call <code>_original</code> you might as well comment off the decorator.</span>
<span class="comment-copy">@eduffy: That's the point of the question.</span>
<span class="comment-copy">You're right .. I didn't think about it in a testing sense.</span>
<span class="comment-copy">Now we're talking. metadecoration FTW.</span>
<span class="comment-copy">Is there a way to extend this so that the deepest level original is accessible at the outermost decorated function, so I don't have to do ._original._original._original for a function wrapped in three decorators?</span>
<span class="comment-copy">@jcdyer What exactly does <b>decorate your decorators</b> mean? Can I do something like \@include_original (next line) \@decorator_which_I_dont_control (next line) function_definition ?</span>
<span class="comment-copy">@Harshdeep: You'd want to do something like <code>now_i_control = include_original(decorator_i_dont_control)</code>, and then decorate your function with <code>@now_i_control\ndef function():</code>.  Note that <code>y = foo(y)</code> is syntactically equivalent to <code>@foo\ndef y():</code>.  If you tried your suggestion, you end up with <code>include_original(decorator_i_dont_control(function))</code>, when what you want is <code>include_original(decorator_i_dont_control)(function)</code></span>
<span class="comment-copy">@Harshdeep I just edited my response with example usage.  Again, if you didn't define the decorator yourself, you can wrap it with <code>decorator = include_original(decorator)</code></span>
<span class="comment-copy">Python3 for the win!</span>
<span class="comment-copy">This is untrue. The decorated function only has a <code>__wrapped__</code> attribute if you decorate it with <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer"><code>functools.wraps</code></a>. Also, the link is dead.</span>
<span class="comment-copy">I fixed link to the book and expanded the answer for the cases when implementing own decorator.</span>
<span class="comment-copy"><code>func_closure</code> is being replaced by <code>__closure__</code> in 3.x and it's already in 2.6</span>
<span class="comment-copy">I saw that when I was playing around with functions, but it sort of gets complicated if you are using more than one decorator on a function. You wind up calling <code>.func_closure[0].cell_contents</code> until <code>cell_contents is None</code>. I was hoping for a more elegant solution.</span>
<span class="comment-copy">Probably won't work, if the decorator uses functools.wraps</span>
<span class="comment-copy">Came up with the same solution, kudos ^^   @EvgeniiPuchkaryov it seems to work with functools.wrap</span>
<span class="comment-copy">Note that this might fail if the decorator is a class...</span>
<span class="comment-copy">this is exactly what I've been looking for!</span>
<span class="comment-copy">Nice approach, so clever!</span>
<span class="comment-copy">The whole point of using a decorator is reusing it simply. This doesn't scale if I have code all over the place that needs the decorator.</span>
