<div class="post-text" itemprop="text">
<pre><code>import sys
print(sys.platform)
print(2**100)
raw_input()
</code></pre>
<p>I am using Python 3.1 and can't get the <code>raw_input</code> to "freeze" the dos pop-up. The book I'm reading is for Python 2.5 and I'm using Python 3.1</p>
<p>What should I do to fix this?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>raw_input()</code> was renamed to <code>input()</code></p>
<p>From <a href="http://docs.python.org/dev/py3k/whatsnew/3.0.html" rel="noreferrer">http://docs.python.org/dev/py3k/whatsnew/3.0.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>This works in Python 3.x and 2.x:</p>
<pre><code># Fix Python 2.x.
try: input = raw_input
except NameError: pass
print("Hi " + input("Say something: "))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A reliable way to address this is</p>
<pre><code>from six.moves import input
</code></pre>
<p><a href="http://pythonhosted.org/six/" rel="noreferrer">six</a> is a module which patches over many of the 2/3 common code base pain points.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.xx you just need <code>input()</code> not <code>raw_input()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>As others have indicated, the <code>raw_input</code> function has been renamed to <code>input</code> in Python 3.0, and you really would be better served by a more up-to-date book, but I want to point out that there are better ways to see the output of your script.</p>
<p>From your description, I think you're using Windows, you've saved a <code>.py</code> file and then you're double-clicking on it to run it. The terminal window that pops up closes as soon as your program ends, so you can't see what the result of your program was. To solve this, your book recommends adding a <code>raw_input</code> / <code>input</code> statement to wait until the user presses enter. However, as you've seen, if something goes wrong, such as an error in your program, that statement won't be executed and the window will close without you being able to see what went wrong. You might find it easier to use a command-prompt or IDLE.</p>
<h2>Use a command-prompt</h2>
<p>When you're looking at the folder window that contains your Python program, hold down shift and right-click anywhere in the white background area of the window. The menu that pops up should contain an entry "Open command window here". (I think this works on Windows Vista and Windows 7.) This will open a command-prompt window that looks something like this:</p>
<pre><code>    Microsoft Windows [Version 6.1.7601]
    Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

    C:\Users\Weeble\My Python Program&gt;_
</code></pre>
<p>To run your program, type the following (substituting your script name):</p>
<pre><code>    python myscript.py
</code></pre>
<p>...and press enter. (If you get an error that "python" is not a recognized command, see <a href="http://showmedo.com/videotutorials/video?name=960000&amp;fromSeriesID=96">http://showmedo.com/videotutorials/video?name=960000&amp;fromSeriesID=96</a> ) When your program finishes running, whether it completes successfully or not, the window will remain open and the command-prompt will appear again for you to type another command. If you want to run your program again, you can press the up arrow to recall the previous command you entered and press enter to run it again, rather than having to type out the file name every time.</p>
<h2>Use IDLE</h2>
<p>IDLE is a simple program editor that comes installed with Python. Among other features it can run your programs in a window. Right-click on your <code>.py</code> file and choose "Edit in IDLE". When your program appears in the editor, press F5 or choose "Run module" from the "Run" menu. Your program will run in a window that stays open after your program ends, and in which you can enter Python commands to run immediately.</p>
</div>
<div class="post-text" itemprop="text">
<p>Timmerman's solution works great when running the code, but if you don't want to get <code>Undefined name</code> errors when using pyflakes or a similar linter you could use the following instead:</p>
<pre><code>try:
    import __builtin__
    input = getattr(__builtin__, 'raw_input')
except (ImportError, AttributeError):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a piece of code I put in my scripts that I wan't to run in py2/3-agnostic environment:</p>
<pre><code># Thank you, python2-3 team, for making such a fantastic mess with
# input/raw_input :-)
real_raw_input = vars(__builtins__).get('raw_input',input)
</code></pre>
<p>Now you can use real_raw_input. It's quite expensive but short and readable. Using raw input is usually time expensive (waiting for input), so it's not important.</p>
<p>In theory, you can even assign raw_input instead of real_raw_input but there might be modules that check existence of raw_input and behave accordingly. It's better stay on the safe side.</p>
</div>
<div class="post-text" itemprop="text">
<p>Probably not the best solution, but before I came here I just made this on the fly to keep working without having a quick break from study.</p>
<pre><code>def raw_input(x):
  input(x)
</code></pre>
<p>Then when I run <code>raw_input('Enter your first name: ')</code> on the script I was working on, it captures it as does <code>input()</code> would.</p>
<p>There may be a reason not to do this, that I haven't come across yet!</p>
</div>
<span class="comment-copy">hm, I'm getting NameError: name 'raw_input' is not defined when I'm trying to use your code. don't you get the same?</span>
<span class="comment-copy">Check out <a href="http://docs.python.org/library/2to3.html" rel="nofollow noreferrer">docs.python.org/library/2to3.html</a> and <a href="http://docs.python.org/3.0/whatsnew/3.0.html" rel="nofollow noreferrer">docs.python.org/3.0/whatsnew/3.0.html</a></span>
<span class="comment-copy">There has changed a lot in Python 3, so probably you shouldn't try to master it using a book for 2.5 (which is really old).</span>
<span class="comment-copy">raw_input was renamed to input in python 3</span>
<span class="comment-copy">There was originally a function input() which acted something like the current eval(input()).  It was a leftover from when Python was less security conscious.  The change simplified the language.  See also "import this" for a deeper explanation.    Would you prefer a dead language to one that evolves?  There are plenty of those around.</span>
<span class="comment-copy">I'm learning python as well and found one difference between <code>input()</code> and <code>raw_input()</code>.   <code>a = input()</code> will take the user input and put it in the correct type. Eg: if user types 5 then the value in <code>a</code> is integer 5.   <code>a = raw_input()</code> will take the user input and put it as a string. Eg: if user types 5 then the value in <code>a</code> is string '5' and not an integer.  Thought it might be good info to newbies in python like myself.</span>
<span class="comment-copy">@VishnuNarang Yep, that is correct in Python 2. But in Python 3, this behavior changed, and input does what raw_input did in Python 2.</span>
<span class="comment-copy">@balpha : Just verified. You are correct. I have python 2.7 (Can't edit the answer to mention that...)</span>
<span class="comment-copy">@meawoppl Moving from python 2 to 3 was meant to be breaking. It doesn't mean it had to be. A language can evolve without dying and without changing the function signature. It helps if you have no global functions. Start out with some hindsight from other languages. Etc. Removing functions is not off the table either.</span>
<span class="comment-copy">I was getting a <a href="http://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">scope issue</a> with this approach. Fixed it with a <code>global input</code> at the top of the calling function.</span>
<span class="comment-copy">This seems a bit cleaner to me:  <code>import __builtin__; input = getattr(__builtin__, 'raw_input', input)</code></span>
<span class="comment-copy">Python 3 has no module named <code>__builtin__</code>.</span>
<span class="comment-copy">@mbarkhau: it is too global. What if you call a library that doesn't expect it? <code>__builtin__</code> is renamed to <code>builtins</code> in Python 3. Both are available as <code>__builtins__</code> in CPython.</span>
<span class="comment-copy"><code>getattr(__builtins__, 'raw_input', input)</code> returns the default when imported in Python 2.7.2.</span>
<span class="comment-copy">Good idea... and if you do <code>from six.moves import input as raw_input</code>, you can keep <code>raw_input</code> in your script and run using both Python versions.</span>
<span class="comment-copy">Is IDLE installed with Windows?  Running IDLE or idle in my terminal comes up empty.</span>
<span class="comment-copy">IDLE is installed with Python on Windows. It appears as a shortcut in the start menu and as a file association for .py files, but I don't think there's any 'idle' command added to your path by default. If you want to start it from the command-line, you can run <code>pythonw -m idlelib.idle</code></span>
<span class="comment-copy">That explains it.  I only touch Windows to make money, not as an OS.  I would then say that your "Use IDLE" section is then biased.  You should mention the selectivity, perhaps.</span>
<span class="comment-copy">I'm not sure I understand. The question was Windows-specific. It talks about a "DOS popup". IDLE is installed as part of Python, but some distributors may separate it out. For example, in Ubuntu it seems you have to install it as a separate package. The answer is already suggesting a different approach than the questioner asked for, so I'd rather not add further tangents to it. FWIW I use Linux at home and only use Windows where I have to for work.</span>
<span class="comment-copy">DOS being an acronym for several closely related operating systems that dominated the IBM PC compatible market between 1981 and 1995, or until about 2000 including the partially DOS-based Microsoft Windows versions 95, 98, and Millennium Edition.</span>
<span class="comment-copy">Eh, I am still getting lots of errors in pylint: <code>Redefining built-in 'input' (redefined-builtin)</code>, <code>Unable to import '__builtin__' (import-error)</code>, <code>Invalid constant name "input" (invalid-name)</code>.</span>
<span class="comment-copy">@BabkenVardanyan pylint is notoriously strict when it comes to code style. I would recommend <code>flake8</code> or <code>pyflakes</code> so as to not take up all your day with meaningless warnings.</span>
<span class="comment-copy">I get this when I tried it:           inputcons = vars(<b>builtins</b>).get('raw_input', input)         TypeError: vars() argument must have <b>dict</b> attribute</span>
