<div class="post-text" itemprop="text">
<p>I am parsing a webpage which has Unicode representations of fractions.  I would like to be able to take those strings directly and convert them to floats.  For example:</p>
<p>"⅕" would become 0.2</p>
<p>Any suggestions of how to do this in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want to use the <a href="http://docs.python.org/library/unicodedata.html" rel="noreferrer">unicodedata</a> module:</p>
<pre><code>import unicodedata
unicodedata.numeric(u'⅕')
</code></pre>
<p>This will print:</p>
<pre><code>0.20000000000000001
</code></pre>
<p>If the character does not have a numeric value, then <code>unicodedata.numeric(unichr[, default])</code> will return default, or if default is not given will raise ValueError.</p>
</div>
<div class="post-text" itemprop="text">
<p>Those Unicode representations of floats are called <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:Decomposition_Type=Fraction:]" rel="nofollow noreferrer">Vulgar Fractions</a></p>
<p>You can covert them to floats using <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.numeric" rel="nofollow noreferrer">unicodedata.numeric(char)</a></p>
<p>However, <code>numeric(char)</code> won't work on something like <code>3¾</code>. That takes a bit more effort:</p>
<pre><code>from unicodedata import numeric

samples = ["3¼","19¼","3 ¼","10"]

for i in samples:
    if len(i) == 1:
        v = numeric(i)
    elif i[-1].isdigit():
        # normal number, ending in [0-9]
        v = float(i)
    else:
        # Assume the last character is a vulgar fraction
        v = float(i[:-1]) + numeric(i[-1])
    print(i, v)
</code></pre>
<p>Output:</p>
<pre><code>3¼ 3.25
19¼ 19.25
3 ¼ 3.25
10 10.0
</code></pre>
<p>You might also be interested isolating these vulgar fractions from broader user input using regular expressions. You can do so using ranges of their unicode character codes:</p>
<pre><code>/[\u2150-\u215E\u00BC-\u00BE]/g
</code></pre>
<p>Sample: <a href="https://regexr.com/3p8nd" rel="nofollow noreferrer">https://regexr.com/3p8nd</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Since there are only a fixed number of fractions defined in Unicode, a dictionary seems appropriate:</p>
<pre><code>Fractions = {
    u'¼': 0.25,
    u'½': 0.5,
    u'¾': 0.75,
    u'⅕': 0.2,
    # add any other fractions here
}
</code></pre>
<p>Update: the <code>unicodedata</code> module is a much better solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>Maybe you could decompose the fraction using the <a href="http://docs.python.org/library/unicodedata.html" rel="nofollow noreferrer">"unicodedata" module</a> and then look for the <a href="http://www.fileformat.info/info/unicode/char/2044/index.htm" rel="nofollow noreferrer">FRACTION SLASH character</a> and then it's just a matter of simple division.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; unicodedata.lookup('VULGAR FRACTION ONE QUARTER')
u'\xbc'
&gt;&gt;&gt; unicodedata.decomposition(unicodedata.lookup('VULGAR FRACTION ONE QUARTER'))
'&lt;fraction&gt; 0031 2044 0034'
</code></pre>
<p><strong>Update:</strong> I'll leave this answer here for reference but using unicodedata.numeric() as per Karl's answer is a much better idea.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.1, you don't need the 'u', and it will produce 0.2 instead of 0.20000000000000001
.</p>
<pre><code>&gt;&gt;&gt; unicodedata.numeric('⅕')
0.2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm stating the obvious here, but it's very simple to extend this for cases when people write "1¾" meaning "1.75", so I'm just going to share it here for quick reference:</p>
<pre><code>import unicodedata

# Assuming that the unicode is always the last character. You always going to see stuff like "3¼", or "19¼" whereas stuff like "3¼5"
# does not have a clear interpretation 

def convertVulgarFractions(vulgarFraction):

    if (len(vulgarFraction) == 1):
        return unicodedata.numeric(vulgarFraction)

    if (len(vulgarFraction) &gt; 1) &amp; (not (vulgarFraction[:len(vulgarFraction)-1].isdigit())):
        raise ArithmeticError("The format needs to be numbers ending with a vulgar fraction. The number inserted was " + 
                              str(vulgarFraction))

    if vulgarFraction[len(vulgarFraction)-1].isdigit():
        return float(vulgarFraction)
    else:
        return float(vulgarFraction[:len(vulgarFraction)-1]) + unicodedata.numeric(vulgarFraction[len(vulgarFraction)-1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Although not exactly what asked, perhaps someone wants it converted to a fraction rather than to a float.  After all, a fraction is what it really represents.</p>
<p><code>unicodedata.normalize("NFKC", "⅕")</code> results in <code>"1⁄5"</code>.  This is not (presently) understood by <code>fractions.Fraction</code>, which expects a fraction described with <code>/</code> rather than <code>⁄</code>.  However, that is easy to replace:</p>
<pre><code>In [313]: def unifrac_to_frac(s):
     ...:     return fractions.Fraction(unicodedata.normalize("NFKC", s).replace("⁄", "/"))
     ...: 

In [315]: unifrac_to_frac("⅕")
Out[315]: Fraction(1, 5)

In [316]: unifrac_to_frac("½")
Out[316]: Fraction(1, 2)

In [317]: unifrac_to_frac("↉")
Out[317]: Fraction(0, 1)
</code></pre>
</div>
<span class="comment-copy">Hey, that's pretty cool!</span>
<span class="comment-copy">Python should get a new slogan by borrowing from Apple: "There's a module for that".</span>
<span class="comment-copy">Yup batteries included.</span>
<span class="comment-copy">I didn't realize it until I just read the docs that ftp.unicode.org has a UnicodeData.txt file which is where the unicodedata module is getting all its data from.</span>
<span class="comment-copy">For the morbidly curious it seems the python implementation of numeric is basically just a big lookup table, see python/trunk/Objects/unicodectype.c  Also, there are obviously a lot more unicode characters with numeric values than just the standard fractions ... check out <a href="http://www.fileformat.info/info/unicode/char/0f2e/index.htm" rel="nofollow noreferrer">fileformat.info/info/unicode/char/0f2e/index.htm</a> for example!</span>
<span class="comment-copy">Specifically, you're looking at characters U+00BC-E (<a href="http://www.unicode.org/charts/PDF/U0080.pdf" rel="nofollow noreferrer">unicode.org/charts/PDF/U0080.pdf</a>) and U+2153-E (<a href="http://www.unicode.org/charts/PDF/U2150.pdf" rel="nofollow noreferrer">unicode.org/charts/PDF/U2150.pdf</a>). Just search the index (<a href="http://www.unicode.org/Public/UNIDATA/Index.txt" rel="nofollow noreferrer">unicode.org/Public/UNIDATA/Index.txt</a>) for "vulgar".</span>
<span class="comment-copy">assert (0.2 == 0.20000000000000001) ... What you possibly meant to say is that the float produced by the unicodedata.numeric() has NOT changed, but repr() has been enhanced to produce a less frightening but still computationally equivalent answer where possible.</span>
