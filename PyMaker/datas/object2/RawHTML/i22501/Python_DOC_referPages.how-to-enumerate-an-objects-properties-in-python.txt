<div class="post-text" itemprop="text">
<p>I C# we do it through reflection. In Javascript it is simple as:</p>
<pre><code>for(var propertyName in objectName)
    var currentPropertyValue = objectName[propertyName];
</code></pre>
<p>How to do it in Python?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for property, value in vars(theObject).iteritems():
    print property, ": ", value
</code></pre>
<p>Be aware that in some rare cases there's a <code>__slots__</code> property, such classes often have no <code>__dict__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>See <a href="http://docs.python.org/library/inspect.html#inspect.getmembers" rel="noreferrer"><code>inspect.getmembers(object[, predicate])</code></a>.</p>
<blockquote>
<p>Return all the members of an object in a list of (name, value) pairs sorted by name. If the optional predicate argument is supplied, only members for which the predicate returns a true value are included.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; [name for name,thing in inspect.getmembers([])]
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', 
'__delslice__',    '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', 
'__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', 
'__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__','__reduce_ex__', 
'__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', 
'__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 
'insert', 'pop', 'remove', 'reverse', 'sort']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/functions.html#dir" rel="noreferrer"><code>dir()</code></a> is the simple way. See here:</p>
<p><a href="https://www.ibm.com/developerworks/library/l-pyint/index.html" rel="noreferrer">Guide To Python Introspection</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__dict__</code> property of the object is a dictionary of all its other defined properties. Note that Python classes can override <a href="http://docs.python.org/reference/datamodel.html#object.__getattr__" rel="noreferrer"><strong>getattr</strong></a>
and make things that look like properties but are not in<code>__dict__</code>. There's also the builtin functions <code>vars()</code> and <code>dir()</code> which are different in subtle ways. And <code>__slots__</code> can replace <code>__dict__</code> in some unusual classes.</p>
<p>Objects are complicated in Python. <code>__dict__</code> is the right place to start for reflection-style programming. <code>dir()</code> is the place to start if you're hacking around in an interactive shell.</p>
</div>
<div class="post-text" itemprop="text">
<p>georg scholly shorter version </p>
<pre><code>print vars(theObject)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're looking for reflection of all properties, the answers above are great.</p>
<p>If you're simply looking to get the keys of an object, use</p>
<p><code>my_dict.keys()</code></p>
<pre><code>my_dict = {'abc': {}, 'def': 12, 'ghi': 'string' }
my_dict.keys() 
&gt; ['abc', 'def', 'ghi']
</code></pre>
</div>
<span class="comment-copy">linking this: <a href="http://stackoverflow.com/questions/1911281/how-do-you-get-list-of-methods-in-a-python-class">How do you get list of methods in a python class?</a></span>
<span class="comment-copy">now how to change the value? in Javascript you could do: object[property] = newValue. How to do it in Python?</span>
<span class="comment-copy">use setattr() instead.</span>
<span class="comment-copy">@Nelson Could you elaborate why that's a better option? Is it just shorter, or are there additional considerations?</span>
<span class="comment-copy">@Hugo: First because it's "pythonic", in other words that's the syntax a large majority of the community is expecting to see. The other syntax would likely unnecessarily give pause to anyone reading your code. Second, some types implement a setter <code>__setattr__()</code>. Setting values directly on the dictionary bypasses the object's setter (and/or its parents'). It's quite common in python that more things than meet the eye are happening in the background during attribute setting (e.g. sanitation), using <code>setattr()</code> ensures that you don't miss out, or are forced to handle them explicitly yourself.</span>
<span class="comment-copy">@Hi-Angel That <i>does</i> work. What isn't working, however, is the constellation of preconceptions and assumptions you have surrounding status versus dynamic object members in Python. <code>vars()</code> only returns <b>static members</b> (i.e., object attributes and methods registered with that object's <code>__dict__</code>). It does <i>not</i> return <b>dynamic members</b> (i.e., object attributes and methods dynamically defined by that object's <code>__getattr__()</code> method or similar magic). In all likelihood, your desired <code>file.ImplementationName</code> property is defined dynamically and hence <i>not</i> available to <code>vars()</code> or <code>dir()</code>.</span>
<span class="comment-copy">Yeah, this answer is great; never used this module before. getmembers() is implemented by just walking the results of dir(object), btw.</span>
<span class="comment-copy">Can you elaborate why this is better than accessing <b>dict</b>? The Python documentation is less than helpful, especially because normally it uses the term <code>attributes</code> instead of <code>members</code> (is there any difference between the two?). They could have fixed the name in Python 3.0 to make it consistent.</span>
<span class="comment-copy">Oops, meant <code>__dict__</code>, sorry.</span>
<span class="comment-copy">@nikow: inspect.getmembers() is guaranteed to keep working even if the internal details change.</span>
<span class="comment-copy">@NicholasKnight <code>inspect.getmembers()</code> wraps <code>dir()</code> with the (mostly negligible) side benefits of <b>(A)</b> including <a href="https://docs.python.org/3/library/types.html#types.DynamicClassAttribute" rel="nofollow noreferrer">dynamic class attributes</a> and <a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">metaclass attributes</a> and <b>(B)</b> excluding members <i>not</i> matching the passed predicate. <i>Yawn, right?</i> <code>inspect.getmembers()</code> is appropriate for third-party libraries generically supporting all possible object types. For standard use cases, however, <code>dir()</code> absolutely suffices.</span>
<span class="comment-copy">Something to note from the Python docs, <i>because dir() is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, metaclass attributes are not in the result list when the argument is a class.</i></span>
<span class="comment-copy">this answer is the best when doing scratch work on the cli.</span>
<span class="comment-copy"><code>print vars.__doc__</code> indicates that <code>With an argument, equivalent to object.__dict__</code> So what would the subtle differences be?</span>
<span class="comment-copy">should be accepted answer</span>
<span class="comment-copy">even though it's my answer, I don't think it should be the accepted answer: the keys of an object are different from the property of an object instance of a class. They're accessed differently (<code>obj['key']</code> vs. <code>obj.property</code>) and the question was about object properties. I put my answer here because there is easy confusion between the two.</span>
<span class="comment-copy">have to be accepted answer</span>
