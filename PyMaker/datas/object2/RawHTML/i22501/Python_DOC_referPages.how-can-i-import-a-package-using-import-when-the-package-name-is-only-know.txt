<div class="post-text" itemprop="text">
<p>I have a messages folder(package) with <code>__init__.py</code> file and another module <code>messages_en.py</code> inside it. In <code>__init__.py</code> if I import <code>messages_en</code> it works, but <code>__import__</code> fails with "ImportError: No module named messages_en"</p>
<pre><code>import messages_en # it works
messages = __import__('messages_en') # it doesn't ?
</code></pre>
<p>I used to think 'import x' is just another way of saying <code>__import__('x')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Adding the globals argument is sufficient for me:</p>
<pre><code>__import__('messages_en', globals=globals())
</code></pre>
<p>In fact, only <code>__name__</code> is needed here:</p>
<pre><code>__import__('messages_en', globals={"__name__": __name__})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it is a path problem, you should use the <code>level</code> argument (from <a href="http://docs.python.org/2/library/functions.html?highlight=__import__#__import__" rel="noreferrer">docs</a>):</p>
<pre><code>__import__(name, globals={}, locals={}, fromlist=[], level=-1) -&gt; module

Level is used to determine whether to perform
absolute or relative imports.  -1 is the original strategy of attempting
both absolute and relative imports, 0 is absolute, a positive number
is the number of parent directories to search relative to the current module.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__import__</code> is an internal function called by import statement. In everyday coding you don't need (or want) to call <code>__import__</code></p>
<p>from python documentation:</p>
<p>For example, the statement <code>import spam</code> results in bytecode resembling the following code:</p>
<pre><code>spam = __import__('spam', globals(), locals(), [], -1)
</code></pre>
<p>On the other hand, the statement <code>from spam.ham import eggs, sausage as saus</code> results in</p>
<pre><code>_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], -1)
eggs = _temp.eggs
saus = _temp.sausage
</code></pre>
<p>more info:
<a href="http://docs.python.org/library/functions.html" rel="noreferrer">http://docs.python.org/library/functions.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Be sure to append the modules directory to your python path.</p>
<p>Your path (the list of directories Python goes through to search for modules and files) is stored in the path attribute of the sys module. Since the path is a list you can use the append method to add new directories to the path. </p>
<p>For instance, to add the directory /home/me/mypy to the path:</p>
<pre><code>import sys
sys.path.append("/home/me/mypy") 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try this:</p>
<pre><code>messages == __import__('Foo.messages_en', fromlist=['messages_en'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to manually import the top package of your dynamic package path.</p>
<p>For example in the beginning of the file i write:</p>
<pre><code>import sites
</code></pre>
<p>then later in code this works for me:</p>
<pre><code>target = 'some.dynamic.path'
my_module = __import__ ('sites.%s.fabfile' % target, fromlist=["sites.%s" % target])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I understand that this question is about the <code>__import__()</code> function but I think the <code>importlib</code> package is best suited for run-time package imports if you are using Python 2.7 or above as advised in the <a href="https://docs.python.org/3/library/importlib.html#importlib.__import__" rel="nofollow noreferrer">doc</a>:</p>
<blockquote>
<p>Note: Programmatic importing of modules should use import_module() instead of this function. </p>
</blockquote>
<p>Possible Gotcha: <a href="https://docs.python.org/2/library/importlib.html" rel="nofollow noreferrer">This was introduced in python 2.7:</a> </p>
<blockquote>
<p>New in version 2.7.</p>
<p>This module is a minor subset of what is available in the more full-featured package of the same name from Python 3.1 that provides a complete implementation of import. What is here has been provided to help ease in transitioning from 2.7 to 3.1.</p>
</blockquote>
<p>In your case, you may use:</p>
<pre><code>import importlib

messages = importlib.import_module('messages_en')
</code></pre>
<p>Also, if you wanted to specify the package name, then <code>from messages import messages_en</code> may be written as:</p>
<p><code>importlib.import_module('.messages_en', 'messages')</code></p>
<p>Note the <code>.</code> in <code>.messages_en</code> used for relative path resolution as described <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer">here</a>:</p>
<blockquote>
<p>... The name argument specifies what module to import in absolute or relative terms (e.g. either pkg.mod or ..mod). If the name is specified in relative terms, then the package argument must be set to the name of the package which is to act as the anchor for resolving the package name (e.g. import_module('..mod', 'pkg.subpkg') will import pkg.mod).</p>
</blockquote>
</div>
<span class="comment-copy">Thanks for the <code>globals={"__name__": __name__}</code></span>
<span class="comment-copy">but I wonder what was the reason , because default level is -1, and I am still passing -1, so only extra are global/local dict, how that makes a difference</span>
<span class="comment-copy">Why is this the accepted answer? It does neither answer the question nor fix the problem.</span>
<span class="comment-copy">This answer is wrong. The OP's problem is not related to <code>level</code> in any way. Two options to fix it: Either supply the module's globals as <code>messages = __import__('messages_en', globals())</code> as Eric points out or give the package name as Lennart suggests.</span>
<span class="comment-copy">in Python 3, level must be &gt;=0. set it to 1 in this case.</span>
<span class="comment-copy">+1 and thanks for explanation, but could you describe exactly why OP's example doesn't work?  He seems to be trying to alias messages_en to messages, which seems (naively to me) to be reasonable.</span>
<span class="comment-copy">As 'wr' explained it was due to level, and I know <b>import</b> shouldn't be usually used but in this case i have to dynamically read language from a config file append to messages and import that file</span>
<span class="comment-copy">This example was very helpful, especially if you're trying to load modules from subdirectories.  It helped me fix my "Attribute not found" error.</span>
<span class="comment-copy">@AnuragUniyal no, your example didn't work due to the missing <code>globals()</code>, the default value for <code>level</code> is fine.</span>
<span class="comment-copy">That's not safe since it makes the package not relocatable. It will only work if the package is in this hard coded path.</span>
