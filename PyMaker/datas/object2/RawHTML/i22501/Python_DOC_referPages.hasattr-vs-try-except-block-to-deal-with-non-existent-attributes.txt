<div class="post-text" itemprop="text">
<pre><code>if hasattr(obj, 'attribute'):
    # do somthing
</code></pre>
<p>vs</p>
<pre><code>try:
    # access obj.attribute
except AttributeError, e:
    # deal with AttributeError
</code></pre>
<p>Which should be preferred and why?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>hasattr</code> internally and rapidly performs the same task as the <code>try/except</code> block: it's a very specific, optimized, one-task tool and thus should be preferred, when applicable, to the very general-purpose alternative.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Any benches that illustrate difference in performance?</em></p>
<p>timeit it's your friend</p>
<pre><code>$ python -mtimeit -s 'class C(object): a = 4
c = C()' 'hasattr(c, "nonexistent")'
1000000 loops, best of 3: 1.87 usec per loop
$ python -mtimeit -s 'class C(object): a = 4
c = C()' 'hasattr(c, "a")'
1000000 loops, best of 3: 0.446 usec per loop
$ python -mtimeit -s 'class C(object): a = 4
c = C()' 'try:
 c.a
except:
 pass'
1000000 loops, best of 3: 0.247 usec per loop
$ python -mtimeit -s 'class C(object): a = 4
c = C()' 'try:
 c.nonexistent
except:
 pass'
100000 loops, best of 3: 3.13 usec per loop
$

       |positive|negative
hasattr|  0.446 |  1.87 
try    |  0.247 |  3.13
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I almost always use <code>hasattr</code>: it's the correct choice for most cases.</p>
<p>The problematic case is when a class overrides <code>__getattr__</code>: <code>hasattr</code> will <strong>catch all exceptions</strong> instead of catching just <code>AttributeError</code> like you expect. In other words, the code below will print <code>b: False</code> even though it would be more appropriate to see a <code>ValueError</code> exception:</p>
<pre><code>class X(object):
    def __getattr__(self, attr):
        if attr == 'a':
            return 123
        if attr == 'b':
            raise ValueError('important error from your database')
        raise AttributeError

x = X()
print 'a:', hasattr(x, 'a')
print 'b:', hasattr(x, 'b')
print 'c:', hasattr(x, 'c')
</code></pre>
<p>The important error has thus disappeared. This has been <a href="http://docs.python.org/3/whatsnew/3.2.html" rel="noreferrer">fixed in Python 3.2</a> (<a href="http://bugs.python.org/issue9666" rel="noreferrer">issue9666</a>) where <code>hasattr</code> now only catches <code>AttributeError</code>.</p>
<p>An easy workaround is to write a utility function like this:</p>
<pre><code>_notset = object()

def safehasattr(thing, attr):
    return getattr(thing, attr, _notset) is not _notset
</code></pre>
<p>This let's <code>getattr</code> deal with the situation and it can then raise the appropriate exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a third, and often better, alternative:</p>
<pre><code>attr = getattr(obj, 'attribute', None)
if attr is not None:
     print attr
</code></pre>
<p>Advantages:</p>
<ol>
<li><p><code>getattr</code> does not have the bad <a href="https://stackoverflow.com/a/16186050/243712">exception-swallowing behavior pointed out by Martin Geiser</a> - in old Pythons, <code>hasattr</code> will even swallow a <code>KeyboardInterrupt</code>.</p></li>
<li><p>The normal reason you're checking if the object has an attribute is so that you can use the attribute, and this naturally leads in to it.</p></li>
<li><p>The attribute is read off atomically, and is safe from other threads changing the object.  (Though, if this is a major concern you might want to consider locking the object before accessing it.)</p></li>
<li><p>It's shorter than <code>try/finally</code> and often shorter than <code>hasattr</code>.</p></li>
<li><p>A broad <code>except AttributeError</code> block can catch other <code>AttributeErrors</code> than the one you're expecting, which can lead to confusing behaviour.</p></li>
<li><p>Accessing an attribute is slower than accessing a local variable (especially if it's not a plain instance attribute).  (Though, to be honest, micro-optimization in Python is often a fool's errand.)</p></li>
</ol>
<p>One thing to be careful of is if you care about the case where <code>obj.attribute</code> is set to None, you'll need to use a different sentinel value.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would say it depends on whether your function may accept objects without the attribute <strong>by design</strong>, e.g. if you have two callers to the function, one providing an object with the attribute and the other providing an object without it. </p>
<p>If the only case where you'll get an object without the attribute is due to some error, I would recommend using the exceptions mechanism even though it may be slower, because I believe it is a cleaner design. </p>
<p>Bottom line: I think it's a design and readability issue rather than an efficiency issue. </p>
</div>
<div class="post-text" itemprop="text">
<p>If it's just one attribute you're testing, I'd say use <code>hasattr</code>.  However, if you're doing <em>several</em> accesses to attributes which may or may not exist then using a <code>try</code> block may save you some typing.</p>
</div>
<div class="post-text" itemprop="text">
<p>If not having the attribute is <strong>not</strong> an error condition, the exception handling variant has a problem: it would catch also AttributeErrors that might come <em>internally</em> when accessing obj.attribute (for instance because attribute is a property so that accessing it calls some code).</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest option 2. Option 1 has a race condition if some other thread is adding or removing the attribute.</p>
<p>Also python has an <a href="http://jaynes.colorado.edu/PythonIdioms.html" rel="nofollow noreferrer">Idiom</a>, that EAFP ('easier to ask forgiveness than permission') is better than LBYL ('look before you leap').</p>
</div>
<div class="post-text" itemprop="text">
<p>From a practical point of view, in most languages using a conditional will always be consderably faster than handling an exception.</p>
<p>If you're wanting to handle the case of an attribute not existing somewhere outside of the current function, the exception is the better way to go. An indicator that you may want to be using an exception instead of a conditional is that the conditional merely sets a flag and aborts the current operation, and something elsewhere checks this flag and takes action based on that.</p>
<p>That said, as Rax Olgud points out, communication with others is one important attribute of code, and what you want to say by saying "this is an exceptional situation" rather than "this is is something I expect to happen" may be more important.</p>
</div>
<div class="post-text" itemprop="text">
<p>This subject was covered in the EuroPython 2016 talk <em><a href="https://youtu.be/YjHsOrOOSuI?t=766" rel="nofollow noreferrer">Writing faster Python</a></em> by Sebastian Witowski. Here's a reproduction of his slide with the performance summary. He also uses the terminology <em>look before you leap</em> in this discussion, worth mentioning here to tag that keyword.</p>
<blockquote>
<p>If the attribute is actually missing then begging for forgiveness will
  be slower than asking for permissions. So as a rule of thumb you can
  use the ask for permission way if know that it is very likely that the
  attribute will be missing or other problems that you can predict.
  Otherwise if you expect code will result in most of the times readable
  code</p>
</blockquote>
<h1>3 PERMISSIONS OR FORGIVENESS?</h1>
<pre><code># CASE 1 -- Attribute Exists
class Foo(object):
    hello = 'world'
foo = Foo()

if hasatter(foo, 'hello'):
    foo.hello
## 149ns ##

try:
    foo.hello
except AttributeError:
    pass
## 43.1 ns ##
## 3.5 times faster


# CASE 2 -- Attribute Absent
class Bar(object):
    pass
bar = Bar()

if hasattr(bar, 'hello'):
    bar.hello
## 428 ns ##

try:
    bar.hello
except AttributeError :
    pass
## 536 ns ##
## 25% slower
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The first.</p>
<p>Shorter is better. Exceptions should be exceptional.</p>
</div>
<div class="post-text" itemprop="text">
<p>At least when it is up to just what's going on in the program, leaving out the human part of readability, etc. (which is actually most of the time more imortant than performance (at least in this case - with that performance span), as Roee Adler and others pointed out).</p>
<p>Nevertheless looking at it from that perspective,
it then becomes a matter of choosing between</p>
<pre><code>try: getattr(obj, attr)
except: ...
</code></pre>
<p>and</p>
<pre><code>try: obj.attr
except: ...
</code></pre>
<p>since <code>hasattr</code> just uses the first case to determine the result.
Food for thought ;-)</p>
</div>
<span class="comment-copy">Duplicate: <a href="http://stackoverflow.com/questions/598157/cheap-exception-handling-in-python" title="cheap exception handling in python">stackoverflow.com/questions/598157/…</a>, <a href="http://stackoverflow.com/questions/610883/how-to-know-if-an-object-has-an-attribute-in-python" title="how to know if an object has an attribute in python">stackoverflow.com/questions/610883/…</a></span>
<span class="comment-copy">Except you still need the try/catch block to handle race conditions (if you are using threads).</span>
<span class="comment-copy">Or, the special case I just came across: a django OneToOneField with no value: hasattr(obj, field_name) returns False, but there is an attribute with field_name: it just raises a DoesNotExist error.</span>
<span class="comment-copy">Note that <code>hasattr</code> will <b>catch all exceptions</b> in Python 2.x. See <a href="http://stackoverflow.com/a/16186050/110204">my answer</a> for an example and the trivial workaround.</span>
<span class="comment-copy">An interesting <a href="http://stackoverflow.com/a/21025020/1959808">comment</a>: <code>try</code> can convey that the operation <i>should</i> work. Though <code>try</code>'s intent is not always such, it is common, so it might be considered more readable.</span>
<span class="comment-copy">Check out this <a href="http://stackoverflow.com/a/9748715/198720">answer here</a>.</span>
<span class="comment-copy">+1 for providing interesting, tangible numbers.  In fact, the "try" is efficient when it contains the common case (i.e. when a Python exception is really exceptional).</span>
<span class="comment-copy">I'm not sure how to interpret these results. Which is faster here, and by how much?</span>
<span class="comment-copy">@StevenM.Vascellaro: If the attribute exists, <code>try</code> is about twice as fast as <code>hasattr()</code>.  If it doesn't, <code>try</code> is about 1.5x slower than <code>hasattr()</code> (and both are substantially slower than if the attribute does exist).  This is probably because, on the happy path, <code>try</code> hardly does anything (Python is already paying for the overhead of exceptions regardless of whether you use them), but <code>hasattr()</code> requires a name lookup and function call.  On the unhappy path, they both have to do some exception handling and a <code>goto</code>, but <code>hasattr()</code> does it in C rather than Python bytecode.</span>
<span class="comment-copy">This was also <a href="http://hg.python.org/cpython/rev/4c8375574aa9/" rel="nofollow noreferrer">improved a bit</a> in Python2.6 so that <code>hasattr</code> will at least not catch <code>KeyboardInterrupt</code> etc.</span>
<span class="comment-copy">Or, rather than <code>safehasattr</code>, just use <code>getattr</code> to copy the value in to a local variable if you're going to use it, which you almost always are.</span>
<span class="comment-copy">@poolie That's nice, I didn't know that <code>hasattr</code> had been improved like that.</span>
<span class="comment-copy">Yes, it is good.  I didn't know that either until today when I was about to tell someone to avoid <code>hasattr</code>, and went to check.  We had some funny bzr bugs where hasattr just swallowed ^C.</span>
<span class="comment-copy">+1 - This is in league with dict.get('my_key', 'default_value') and should be more widely known about</span>
<span class="comment-copy">Great for common use case where you want to check the existance and use the attribute with default value.</span>
<span class="comment-copy">+1 for insisting on why "try" has a meaning for people who read the code. :)</span>
<span class="comment-copy">this is a major problem that has been largely ignored, in my opinion.</span>
<span class="comment-copy">+1 for insisting on the fact that "try" can be interpreted as "this is an exceptional situation", compared to the conditional test. :)</span>
<span class="comment-copy">Exceptions are very common in Python -- there's one at the end of every <code>for</code> statement, and <code>hasattr</code> uses one, too. However, "shorter is better" (and "simpler is better"!) DO apply, so the simpler, shorter, more-specific hasattr is indeed preferable.</span>
<span class="comment-copy">@Alex just because the Python parser transforms those statements to have 1 doesn't mean its very common. There's a reason why they made that syntactic sugar: so you aren't stuck with the cruftiness of typing the try except block.</span>
<span class="comment-copy">If the exception is exceptional, then "explicit is better", and the original poster's 2nd option is better, I'd say…</span>
