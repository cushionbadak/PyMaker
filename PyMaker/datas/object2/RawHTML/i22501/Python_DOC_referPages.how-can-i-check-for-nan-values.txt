<div class="post-text" itemprop="text">
<p><code>float('nan')</code> results in Nan (not a number). But how do I check for it? Should be very easy, but I cannot find it.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/math.html#math.isnan" rel="noreferrer">math.isnan()</a></p>
<blockquote>
<p>Checks if the float x is a NaN (not a number). NaNs are part of the IEEE 754 standards. Operation like but not limited to inf * 0, inf / inf or any operation involving a NaN, e.g. nan * 1, return a NaN.</p>
<p><em>New in version 2.6.</em></p>
</blockquote>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; x=float('nan')
&gt;&gt;&gt; math.isnan(x)
True
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The usual way to test for a NaN is to see if it's equal to itself:</p>
<pre><code>def isNaN(num):
    return num != num
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>numpy.isnan(number)</code> tells you if it's <code>NaN</code> or not in Python 2.5.</p>
</div>
<div class="post-text" itemprop="text">
<p>I actually just ran into this, but for me it was checking for nan, -inf, or inf. I just used</p>
<pre><code>if float('-inf') &lt; float(num) &lt; float('inf'):
</code></pre>
<p>This is true for numbers, false for nan and both inf, and will raise an exception for things like strings or other types (which is probably a good thing). Also this does not require importing any libraries like math or numpy (numpy is so damn big it doubles the size of any compiled application).</p>
</div>
<div class="post-text" itemprop="text">
<p>here is an answer working with:</p>
<ul>
<li>python <em>non-unique</em> NaN: <code>float('nan')</code></li>
<li>numpy <em>unique</em> NaN (singleton) : <code>np.nan</code></li>
<li>any other objects: string or whatever (does not raise exceptions if encountered)</li>
</ul>
<p>Here it is:</p>
<pre><code>import numpy as np

def is_nan(x):
    return (x is np.nan or x != x)
</code></pre>
<p>And some examples:</p>
<pre><code>values = [float('nan'), np.nan, 55, "string", lambda x : x]
for value in values:
    print "{:&lt;8} : {}".format(repr(value), is_nan(value))
</code></pre>
<p>Output:</p>
<pre><code>nan      : True
nan      : True
55       : False
'string' : False
&lt;function &lt;lambda&gt; at 0x000000000927BF28&gt; : False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/math.html#math.isnan" rel="noreferrer">math.isnan()</a></p>
<p>or compare the number to itself. NaN is always != NaN, otherwise (e.g. if it <em>is</em> a number) the comparison should succeed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another method if you're stuck on &lt;2.6, you don't have numpy, and you don't have IEEE 754 support:</p>
<pre><code>def isNaN(x):
    return str(x) == str(1e400*0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well I entered this post, because i've had some issues with the function:</p>
<pre><code>math.isnan()
</code></pre>
<p>There are problem when you run this code:</p>
<pre><code>a = "hello"
math.isnan(a)
</code></pre>
<p>It raises exception.
My solution for that is to make another check:</p>
<pre><code>def is_nan(x):
    return isinstance(x, float) and math.isnan(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With python &lt; 2.6 I ended up with</p>
<pre><code>def isNaN(x):
    return str(float(x)).lower() == 'nan'
</code></pre>
<p>This works for me with python 2.5.1 on a Solaris 5.9 box and with python 2.6.5 on Ubuntu 10 </p>
</div>
<div class="post-text" itemprop="text">
<h1>Here are three ways where you can test a variable is "NaN" or not.</h1>
<pre><code>import pandas as pd
import numpy as np
import math

#For single variable all three libraries return single boolean
x1 = float("nan")

print(f"It's pd.isna  : {pd.isna(x1)}")
print(f"It's np.isnan  : {np.isnan(x1)}")
print(f"It's math.isnan : {math.isnan(x1)}")
</code></pre>
<p><strong>Output</strong></p>
<pre><code>It's pd.isna  : True
It's np.isnan  : True
It's math.isnan  : True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am receiving the data from a web-service that sends <code>NaN</code> as a string <code>'Nan'</code>. But there could be other sorts of string in my data as well, so a simple <code>float(value)</code> could throw an exception. I used the following variant of the accepted answer:</p>
<pre><code>def isnan(value):
  try:
      import math
      return math.isnan(float(value))
  except:
      return False
</code></pre>
<p>Requirement:</p>
<pre><code>isnan('hello') == False
isnan('NaN') == True
isnan(100) == False
isnan(float('nan')) = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>All the methods to tell if the variable is NaN or None:</p>
<p><strong>None type</strong></p>
<pre><code>In [1]: from numpy import math

In [2]: a = None
In [3]: not a
Out[3]: True

In [4]: len(a or ()) == 0
Out[4]: True

In [5]: a == None
Out[5]: True

In [6]: a is None
Out[6]: True

In [7]: a != a
Out[7]: False

In [9]: math.isnan(a)
Traceback (most recent call last):
  File "&lt;ipython-input-9-6d4d8c26d370&gt;", line 1, in &lt;module&gt;
    math.isnan(a)
TypeError: a float is required

In [10]: len(a) == 0
Traceback (most recent call last):
  File "&lt;ipython-input-10-65b72372873e&gt;", line 1, in &lt;module&gt;
    len(a) == 0
TypeError: object of type 'NoneType' has no len()
</code></pre>
<p><strong>NaN type</strong></p>
<pre><code>In [11]: b = float('nan')
In [12]: b
Out[12]: nan

In [13]: not b
Out[13]: False

In [14]: b != b
Out[14]: True

In [15]: math.isnan(b)
Out[15]: True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>How to remove NaN (float) item(s) from a list of mixed data types</h1>
<p>If you have mixed types in an iterable, here is a solution that does not use numpy:</p>
<pre><code>from math import isnan

Z = ['a','b', float('NaN'), 'd', float('1.1024')]

[x for x in Z if not (
                      type(x) == float # let's drop all float values…
                      and isnan(x) # … but only if they are nan
                      )]
</code></pre>
<pre>['a', 'b', 'd', 1.1024]</pre>
<p>Short-circuit evaluation means that <code>isnan</code> will not be called on values that are not of type 'float' as (<code>False and …</code> quickly evaluates to <code>False</code> without having to evaluate the right-hand side.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>For nan of type float  </p>
</blockquote>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; value = float(nan)
&gt;&gt;&gt; type(value)
&gt;&gt;&gt; &lt;class 'float'&gt;
&gt;&gt;&gt; pd.isnull(value)
True
&gt;&gt;&gt;
&gt;&gt;&gt; value = 'nan'
&gt;&gt;&gt; type(value)
&gt;&gt;&gt; &lt;class 'str'&gt;
&gt;&gt;&gt; pd.isnull(value)
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>for strings in panda take pd.isnull:</p>
<pre><code>if not pd.isnull(atext):
  for word in nltk.word_tokenize(atext):
</code></pre>
<p>the function as feature extraction for NLTK</p>
<pre><code>def act_features(atext):
features = {}
if not pd.isnull(atext):
  for word in nltk.word_tokenize(atext):
    if word not in default_stopwords:
      features['cont({})'.format(word.lower())]=True
return features
</code></pre>
</div>
<span class="comment-copy">For some history of NaN in Python, see PEP 754. <a href="http://www.python.org/dev/peps/pep-0754/" rel="nofollow noreferrer">python.org/dev/peps/pep-0754</a></span>
<span class="comment-copy"><code>numpy.isnan(numpy.nan)</code> will then return <code>True</code>. And obviously, <code>import numpy</code> before doing that. :)</span>
<span class="comment-copy">new in version 2.6</span>
<span class="comment-copy">this fails if the string that is being tested to be a number, isn't a number.  Need to use isdigit in those cases.</span>
<span class="comment-copy">@charlie-parker : In Python3, math.isnan is still a part of the math module. <a href="https://docs.python.org/3/library/math.html#math.isnan" rel="nofollow noreferrer">docs.python.org/3/library/math.html#math.isnan</a> . Use numpy.isnan if you wish, this answer is just a suggestion.</span>
<span class="comment-copy">is <code>math.isnan</code> preferred to <code>np.isnan()</code> ?</span>
<span class="comment-copy">@TMWP possibly... <code>import numpy</code> takes around 15 MB of RAM, whereas <code>import math</code> takes some 0,2 MB</span>
<span class="comment-copy">Word of warning: quoting Bear's comment below "For people stuck with python &lt;= 2.5. Nan != Nan did not work reliably. Used numpy instead." Having said that, I've not actually ever seen it fail.</span>
<span class="comment-copy">I'm sure that, given operator overloading, there are lots of ways I could confuse this function.  go with math.isnan()</span>
<span class="comment-copy">It says in the 754 spec mentioned above that NaN==NaN should always be false, although it is not always implemented as such. Isn't is possible this is how math and/or numpy check this under the hood anyway?</span>
<span class="comment-copy">Thanks . this is also 15-20x times faster than using np.isnan if doing operation on a scalar</span>
<span class="comment-copy">Works in python version 2.7 too.</span>
<span class="comment-copy"><code>numpy.all(numpy.isnan(data_list))</code> is also useful if you need to determine if all elements in the list are nan</span>
<span class="comment-copy">No need for NumPy: <code>all(map(math.isnan, [float("nan")]*5))</code></span>
<span class="comment-copy">When this answer was written 6 years ago, Python 2.5 was still in common use - and math.isnan was not part of the standard library. Now days I'm really hoping that's not the case in many places!</span>
<span class="comment-copy">note that np.isnan() doesn't handle decimal.Decimal type (as many numpy's function). math.isnan() does handle.</span>
<span class="comment-copy"><code>math.isfinite</code> was not introduced until Python 3.2, so given the answer from @DaveTheScientist was posted in 2012 it was not exactly "reinvent[ing] the wheel" - solution still stands for those working with Python 2.</span>
<span class="comment-copy">The series I'm checking is strings with missing values are 'nans' (???) so this solution works where others failed.</span>
<span class="comment-copy">For people stuck with python &lt;= 2.5. Nan != Nan did not work reliably. Used numpy instead.</span>
<span class="comment-copy">Clever idea. And I learned something.</span>
<span class="comment-copy">It was probably downvoted because isnan() takes a float, not a string. There's nothing wrong with the function, and the problems are only in his attempted use of it. (For that particular use case his solution is valid, but it's not an answer to this question.)</span>
<span class="comment-copy">Be careful with checking for types in this way. This will not work e.g. for numpy.float32 NaN's. Better to use a try/except construction:  <code>def is_nan(x):     try:         return math.isnan(x)     except:         return False</code></span>
<span class="comment-copy">NaN does <i>not</i> mean that a value is not a valid number. It is part of IEEE floating point representation to specify that a particular result is undefined. e.g. 0 / 0. Therefore asking if "hello" is nan is meaningless.</span>
<span class="comment-copy">this is better because NaN can land in any list of strings,ints or floats, so useful check</span>
<span class="comment-copy">This isn't too portable, as Windows sometimes calls this <code>-1.#IND</code></span>
<span class="comment-copy">I like this answer because of multiple solutions in one, but it was full of mistakes. Edited.</span>
<span class="comment-copy">or <code>try: int(value)</code></span>
<span class="comment-copy">@chwi so what does your suggestion tell about <code>value</code> being <code>NaN</code> or not?</span>
<span class="comment-copy">Well, being "not a number", anything that can not be casted to an int I guess is in fact not a number, and the try statement will fail? Try, return true, except return false.</span>
<span class="comment-copy">@chwi Well, taking "not a number" literally, you are right, but that's not the point here. In fact, I am looking exactly for what the semantics of <code>NaN</code> is (like in python what you could get from <code>float('inf') * 0</code>), and thus although the string 'Hello' is not a number, but it is also not <code>NaN</code> because <code>NaN</code> is still a numeric value!</span>
<span class="comment-copy">What for this reduction?</span>
