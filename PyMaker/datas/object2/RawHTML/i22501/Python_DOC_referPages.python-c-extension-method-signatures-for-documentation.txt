<div class="post-text" itemprop="text">
<p>I am writing C extensions, and I'd like to make the signature of my methods visible for introspection.</p>
<pre><code>static PyObject* foo(PyObject *self, PyObject *args) {

    /* blabla [...] */

}

PyDoc_STRVAR(
    foo_doc,
    "Great example function\n"
    "Arguments: (timeout, flags=None)\n"
    "Doc blahblah doc doc doc.");

static PyMethodDef methods[] = {
    {"foo", foo, METH_VARARGS, foo_doc},
    {NULL},
};

PyMODINIT_FUNC init_myexample(void) {
    (void) Py_InitModule3("_myexample", methods, "a simple example module");
}
</code></pre>
<p>Now if (after building it...) I load the module and look at its help:</p>
<pre><code>&gt;&gt;&gt; import _myexample
&gt;&gt;&gt; help(_myexample)
</code></pre>
<p>I will get:</p>
<pre><code>Help on module _myexample:

NAME
    _myexample - a simple example module

FILE
    /path/to/module/_myexample.so

FUNCTIONS
    foo(...)
        Great example function
        Arguments: (timeout, flags=None)
        Doc blahblah doc doc doc.
</code></pre>
<p>I would like to be even more specific and be able to replace <strong>foo(...)</strong> by <strong>foo(timeout, flags=None)</strong></p>
<p>Can I do this? How?</p>
</div>
<div class="post-text" itemprop="text">
<p>My usual approach to finding out about things like this is: "use the source".</p>
<p>Basically, I would presume that the standard modules of python would use such a feature when available. Looking at the source (<a href="http://svn.python.org/view/python/branches/release26-maint/Modules/fcntlmodule.c?revision=72888&amp;view=markup" rel="noreferrer">for example here</a>) should help, but in fact even the standard modules add the prototype after the automatic output. Like this:</p>
<pre>torsten@pulsar:~$ python2.6
&gt;&gt;&gt; import fcntl
&gt;&gt;&gt; help(fcntl.flock)
flock(...)
    flock(fd, operation)

    Perform the lock operation op on file descriptor fd.  See the Unix [...]
</pre>
<p>So as upstream is not using such a feature, I would assume it is not there. :-)</p>
<p>Okay, I just checked current python3k sources and this is still the case. That signature is generated in <code>pydoc.py</code> in the python sources here: <a href="http://svn.python.org/view/python/trunk/Lib/pydoc.py?revision=73529&amp;view=markup" rel="noreferrer">pydoc.py</a>. Relevant excerpt starting in line 1260:</p>
<pre>
        if inspect.isfunction(object):
            args, varargs, varkw, defaults = inspect.getargspec(object)
            ...
        else:
            argspec = '(...)'
</pre>
<p>inspect.isfunction checks if the object the documentation is requested for is a Python function. But C implemented functions are considered builtins, therefore you will always get <code>name(...)</code> as the output.</p>
</div>
<div class="post-text" itemprop="text">
<p>It has been 7 years <strong>but you can include the signature for C-extension function and classes</strong>.</p>
<p>Python itself uses the <a href="https://docs.python.org/3/howto/clinic.html" rel="noreferrer">Argument Clinic</a> to dynamically generate signatures. Then some mechanics create a <code>__text_signature__</code> and this can be introspected (for example with <code>help</code>). @MartijnPieters explained this process quite well in <a href="https://stackoverflow.com/a/25847066/5393381">this answer</a>. </p>
<p>You may actually get the argument clinic from python and do it in a dynamic fashion but I prefer the manual way: Adding the signature to the docstring:</p>
<p>In your case:</p>
<pre><code>PyDoc_STRVAR(
    foo_doc,
    "foo(timeout, flags=None, /)\n"
    "--\n"
    "\n"
    "Great example function\n"
    "Arguments: (timeout, flags=None)\n"
    "Doc blahblah doc doc doc.");
</code></pre>
<p>I made heavy use of this in my package: <a href="https://github.com/MSeifert04/iteration_utilities/tree/master/src" rel="noreferrer"><code>iteration_utilities/src</code></a>. So to demonstrate that it works I use one of the C-extension functions exposed by this package:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import minmax
&gt;&gt;&gt; help(minmax)
Help on built-in function minmax in module iteration_utilities._cfuncs:

minmax(iterable, /, key, default)
    Computes the minimum and maximum values in one-pass using only
    ``1.5*len(iterable)`` comparisons. Recipe based on the snippet
    of Raymond Hettinger ([0]_) but significantly modified.

    Parameters
    ----------
    iterable : iterable
        The `iterable` for which to calculate the minimum and maximum.
[...]
</code></pre>
<p>The docstring for this function is defined <a href="https://github.com/MSeifert04/iteration_utilities/blob/master/src/_globaldocs.c" rel="noreferrer">this file</a>.</p>
<p>It is important to realize that this <strong>isn't possible for python &lt; 3.4</strong> and you need to follow some rules:</p>
<ul>
<li><p>You need to include <code>--\n\n</code> after the signature definition line.</p></li>
<li><p>The signature must be in the first line of the docstring.</p></li>
<li><p>The signature must be valid, i.e. <code>foo(a, b=1, c)</code> fails because it's not possible to define positional arguments after arguments with default.</p></li>
<li><p>You can only provide one signature. So it doesn't work if you use something like:</p>
<pre><code>foo(a)
foo(x, a, b)
--

Narrative documentation
</code></pre></li>
</ul>
</div>
<span class="comment-copy">Does this work with <code>inspect.signature</code>?</span>
<span class="comment-copy">@Eric Yes, as long as it follows the rules of <code>__text_signature__</code> I mentioned above.</span>
<span class="comment-copy">Sounds like a thing that <code>numpy</code> needs a patch for</span>
<span class="comment-copy"><a href="https://github.com/numpy/numpy/issues/8734" rel="nofollow noreferrer">github.com/numpy/numpy/issues/8734</a></span>
