<div class="post-text" itemprop="text">
<p>I want to take two lists and find the values that appear in both.</p>
<pre><code>a = [1, 2, 3, 4, 5]
b = [9, 8, 7, 6, 5]

returnMatches(a, b)
</code></pre>
<p>would return <code>[5]</code>, for instance.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not the most efficient one, but by far the most obvious way to do it is:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; b = [9, 8, 7, 6, 5]
&gt;&gt;&gt; set(a) &amp; set(b)
{5}
</code></pre>
<p>if order is significant you can do it with list comprehensions like this:</p>
<pre><code>&gt;&gt;&gt; [i for i, j in zip(a, b) if i == j]
[5]
</code></pre>
<p>(only works for equal-sized lists, which order-significance implies).</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/library/stdtypes.html#set.intersection" rel="noreferrer">set.intersection()</a>, it's fast and readable.</p>
<pre><code>&gt;&gt;&gt; set(a).intersection(b)
set([5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A quick performance test showing Lutz's solution is the best:</p>
<pre><code>import time

def speed_test(func):
    def wrapper(*args, **kwargs):
        t1 = time.time()
        for x in xrange(5000):
            results = func(*args, **kwargs)
        t2 = time.time()
        print '%s took %0.3f ms' % (func.func_name, (t2-t1)*1000.0)
        return results
    return wrapper

@speed_test
def compare_bitwise(x, y):
    set_x = frozenset(x)
    set_y = frozenset(y)
    return set_x &amp; set_y

@speed_test
def compare_listcomp(x, y):
    return [i for i, j in zip(x, y) if i == j]

@speed_test
def compare_intersect(x, y):
    return frozenset(x).intersection(y)

# Comparing short lists
a = [1, 2, 3, 4, 5]
b = [9, 8, 7, 6, 5]
compare_bitwise(a, b)
compare_listcomp(a, b)
compare_intersect(a, b)

# Comparing longer lists
import random
a = random.sample(xrange(100000), 10000)
b = random.sample(xrange(100000), 10000)
compare_bitwise(a, b)
compare_listcomp(a, b)
compare_intersect(a, b)
</code></pre>
<p>These are the results on my machine:</p>
<pre><code># Short list:
compare_bitwise took 10.145 ms
compare_listcomp took 11.157 ms
compare_intersect took 7.461 ms

# Long list:
compare_bitwise took 11203.709 ms
compare_listcomp took 17361.736 ms
compare_intersect took 6833.768 ms
</code></pre>
<p>Obviously, any artificial performance test should be taken with a grain of salt, but since the <code>set().intersection()</code> answer is <em>at least as fast</em> as the other solutions, and also the most readable, it should be the standard solution for this common problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>I prefer the set based answers, but here's one that works anyway</p>
<pre><code>[x for x in a if x in b]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way to do that is to use <a href="http://docs.python.org/library/stdtypes.html#set-types-set-frozenset" rel="noreferrer">sets</a>:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; b = [9, 8, 7, 6, 5]
&gt;&gt;&gt; set(a) &amp; set(b)
set([5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; s = ['a','b','c']   
&gt;&gt;&gt; f = ['a','b','d','c']  
&gt;&gt;&gt; ss= set(s)  
&gt;&gt;&gt; fs =set(f)  
&gt;&gt;&gt; print ss.intersection(fs)   
   **set(['a', 'c', 'b'])**  
&gt;&gt;&gt; print ss.union(fs)        
   **set(['a', 'c', 'b', 'd'])**  
&gt;&gt;&gt; print ss.union(fs)  - ss.intersection(fs)   
   **set(['d'])**
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Quick way:</p>
<pre><code>list(set(a).intersection(set(b)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Also you can try this,by keeping common elements in a new list. </p>
<pre><code>new_list = []
for element in a:
    if element in b:
        new_list.append(element)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you want duplicates? If not maybe you should use sets instead:</p>
<pre><code>
&gt;&gt;&gt; set([1, 2, 3, 4, 5]).intersection(set([9, 8, 7, 6, 5]))
set([5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>another a bit more functional way to check list equality for list 1 (lst1) and list 2 (lst2) where objects have depth one and which keeps the order is:</p>
<pre><code>all(i == j for i, j in zip(lst1, lst2))   
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can use itertools.product too.</p>
<pre><code>&gt;&gt;&gt; common_elements=[]
&gt;&gt;&gt; for i in list(itertools.product(a,b)):
...     if i[0] == i[1]:
...         common_elements.append(i[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use </p>
<pre><code>def returnMatches(a,b):
       return list(set(a) &amp; set(b))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use:</p>
<pre><code>a = [1, 3, 4, 5, 9, 6, 7, 8]
b = [1, 7, 0, 9]
same_values = set(a) &amp; set(b)
print same_values
</code></pre>
<p>Output:</p>
<pre><code>set([1, 7, 9])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [1, 2, 3, 4, 5]
b = [9, 8, 7, 6, 5]

lista =set(a)
listb =set(b)   
print listb.intersection(lista)   
returnMatches = set(['5']) #output 

print " ".join(str(return) for return in returnMatches ) # remove the set()   

 5        #final output 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a boolean value:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; b = [9, 8, 7, 6, 5]
&gt;&gt;&gt; set(b) == set(a)  &amp; set(b) and set(a) == set(a) &amp; set(b)
False
&gt;&gt;&gt; a = [3,1,2]
&gt;&gt;&gt; b = [1,2,3]
&gt;&gt;&gt; set(b) == set(a)  &amp; set(b) and set(a) == set(a) &amp; set(b)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following solution works for any order of list items and also supports both lists to be different length.</p>
<pre><code>import numpy as np
def getMatches(a, b):
    matches = []
    unique_a = np.unique(a)
    unique_b = np.unique(b)
    for a in unique_a:
        for b in unique_b:
            if a == b:
                matches.append(a)
    return matches
print(getMatches([1, 2, 3, 4, 5], [9, 8, 7, 6, 5, 9])) # displays [5]
print(getMatches([1, 2, 3], [3, 4, 5, 1])) # displays [1, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>__and__</code> attribute method also works.</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; b = [9, 8, 7, 6, 5]
&gt;&gt;&gt; set(a).__and__(set(b))
set([5])
</code></pre>
<p>or simply</p>
<pre><code>&gt;&gt;&gt; set([1, 2, 3, 4, 5]).__and__(set([9, 8, 7, 6, 5]))
set([5])
&gt;&gt;&gt;    
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>you can | for set union and &amp; for set intersection.
for example:

    set1={1,2,3}
    set2={3,4,5}
    print(set1&amp;set2)
    output=3

    set1={1,2,3}
    set2={3,4,5}
    print(set1|set2)
    output=1,2,3,4,5

curly braces in the answer.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I just used the following and it worked for me:</p>
<pre><code>group1 = [1, 2, 3, 4, 5]
group2 = [9, 8, 7, 6, 5]

for k in group1:
    for v in group2:
        if k == v:
            print(k)
</code></pre>
<p>this would then print 5 in your case. Probably not great performance wise though.</p>
</div>
<span class="comment-copy">The answers below all seem wrong to me. What happens if a number is repeated in either list, surely you'd want to know that (?)  (eg., say both lists have '5' twice) Any solution using sets will immediately remove all repeated items and you'll lose that info.</span>
<span class="comment-copy">A note of caution, the list comprehension is <i>not</i> necessarily the faster option. For larger sets (where performance is most likely to matter) the bitwise comparison (<code>&amp;</code>) or <code>set(a).intersection(b)</code> will be as fast or faster than list comprehension.</span>
<span class="comment-copy">Another note of caution: the list comprehension finds the values that appear in both at the SAME positions (this is what SilentGhost meant by "order is significant"). The set intersection solutions will also find matches at DIFFERENT positions. These are answers to 2 quite different questions... (the op's question is ambiguous as to which it is asking)</span>
<span class="comment-copy">How do you do this if your lists are lists of lists i.e. a = [[0,0], [1,0]] and b = [[2,3],[0,0]]</span>
<span class="comment-copy">What would be the time complexity of the first example <code>set(a) &amp; set(b)</code> ?</span>
<span class="comment-copy">This answer has good algorithmic performance, as only one of the lists (shorter should be preferred) is turned into a set for quick lookup, and the other list is traversed looking up its items in the set.</span>
<span class="comment-copy"><code>bool(set(a).intersection(b))</code> for <code>True</code> or <code>False</code></span>
<span class="comment-copy">This answer is more flexible and readable, since people may need <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.difference" rel="nofollow noreferrer"><code>difference</code></a> or <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.union" rel="nofollow noreferrer"><code>union</code></a>.</span>
<span class="comment-copy">What if I have objects as list elements and only want partial matches, i.e., only some attributes have to match for it to be considered as matching object?</span>
<span class="comment-copy">The accepted answer does not work for lists that contain strings. This one does.</span>
<span class="comment-copy">If you really want lists, <a href="http://www.java2s.com/Code/Python/List/Functiontointersecttwolists.htm" rel="nofollow noreferrer">java2s.com/Code/Python/List/Functiontointersecttwolists.htm</a> &gt;&gt;&gt; intersect([1, 2, 3, 4, 5], [9, 8, 7, 6, 5]) [5]</span>
<span class="comment-copy">According to the doc - <i>... precludes error-prone constructions like Set('abc') &amp; 'cbs' in favor of the more readable Set('abc').intersection('cbs').</i> - <a href="http://docs.python.org/library/sets.html" rel="nofollow noreferrer">docs.python.org/library/sets.html</a></span>
<span class="comment-copy">how is this different to the accepted answer from 6+ years ago?</span>
<span class="comment-copy">Well, I wrote the complete detail with output and good for beginner python</span>
<span class="comment-copy">While this code may answer the question, providing additional context regarding how and/or why it solves the problem would improve the answer's long-term value.</span>
<span class="comment-copy">The question was for list and no set. use of the <code>&amp;</code> operator on set is already answer by SilentGhost in the accepted answer</span>
