<div class="post-text" itemprop="text">
<p>I have a list of objects in Python and I want to shuffle them. I thought I could use the <code>random.shuffle</code> method, but this seems to fail when the list is of objects. Is there a method for shuffling object or another way around this?</p>
<pre><code>import random

class a:
    foo = "bar"

a1 = a()
a2 = a()
b = [a1,a2]

print random.shuffle(b)
</code></pre>
<p>This will fail.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/library/random.html#random.shuffle" rel="noreferrer"><code>random.shuffle</code></a> should work.  Here's an example, where the objects are lists:</p>
<pre><code>from random import shuffle
x = [[i] for i in range(10)]
shuffle(x)

# print x  gives  [[9], [2], [7], [0], [4], [5], [3], [1], [8], [6]]
# of course your results will vary
</code></pre>
<p>Note that shuffle works <strong>in place</strong>, and returns None.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you learned the in-place shuffling was the problem. I also have problem frequently, and often seem to forget how to copy a list, too. Using <code>sample(a, len(a))</code> is the solution, using <code>len(a)</code> as the sample size. See <a href="https://docs.python.org/3.6/library/random.html#random.sample" rel="noreferrer">https://docs.python.org/3.6/library/random.html#random.sample</a> for the Python documentation.</p>
<p>Here's a simple version using <code>random.sample()</code> that returns the shuffled result as a new list.</p>
<pre><code>import random

a = range(5)
b = random.sample(a, len(a))
print a, b, "two list same:", a == b
# print: [0, 1, 2, 3, 4] [2, 1, 3, 4, 0] two list same: False

# The function sample allows no duplicates.
# Result can be smaller but not larger than the input.
a = range(555)
b = random.sample(a, len(a))
print "no duplicates:", a == list(set(b))

try:
    random.sample(a, len(a) + 1)
except ValueError as e:
    print "Nope!", e

# print: no duplicates: True
# print: Nope! sample larger than population
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It took me some time to get that too. But the documentation for shuffle is very clear:</p>
<blockquote>
<p>shuffle list x <strong>in place</strong>; return None.</p>
</blockquote>
<p>So you shouldn't <code>print random.shuffle(b)</code>. Instead do <code>random.shuffle(b)</code> and then <code>print b</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>#!/usr/bin/python3

import random

s=list(range(5))
random.shuffle(s) # &lt;&lt; shuffle before print or assignment
print(s)

# print: [2, 4, 1, 3, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you happen to be using numpy already (very popular for scientific and financial applications) you can save yourself an import.</p>
<pre><code>import numpy as np    
np.random.shuffle(b)
print(b)
</code></pre>
<p><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html">http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; a = ['hi','world','cat','dog']
&gt;&gt;&gt; random.shuffle(a,random.random)
&gt;&gt;&gt; a
['hi', 'cat', 'dog', 'world']
</code></pre>
<p>It works fine for me.  Make sure to set the random method.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have multiple lists, you might want to define the permutation (the way you shuffle the list / rearrange the items in the list) first and then apply it to all lists:</p>
<pre><code>import random

perm = list(range(len(list_one)))
random.shuffle(perm)
list_one = [list_one[index] for index in perm]
list_two = [list_two[index] for index in perm]
</code></pre>
<h2>Numpy / Scipy</h2>
<p>If your lists are numpy arrays, it is simpler:</p>
<pre><code>import numpy as np

perm = np.random.permutation(len(list_one))
list_one = list_one[perm]
list_two = list_two[perm]
</code></pre>
<h2>mpu</h2>
<p>I've created the small utility package <a href="https://github.com/MartinThoma/mpu" rel="noreferrer"><code>mpu</code></a> which has the <a href="http://mpu.readthedocs.io/en/latest/mpu.html#mpu.consistent_shuffle" rel="noreferrer"><code>consistent_shuffle</code></a> function:</p>
<pre><code>import mpu

# Necessary if you want consistent results
import random
random.seed(8)

# Define example lists
list_one = [1,2,3]
list_two = ['a', 'b', 'c']

# Call the function
list_one, list_two = mpu.consistent_shuffle(list_one, list_two)
</code></pre>
<p>Note that <code>mpu.consistent_shuffle</code> takes an arbitrary number of arguments. So you can also shuffle three or more lists with it.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from random import random
my_list = range(10)
shuffled_list = sorted(my_list, key=lambda x: random())
</code></pre>
<p>This alternative may be useful for some applications where you want to swap the ordering function.</p>
</div>
<div class="post-text" itemprop="text">
<p>'print func(foo)' will print the return value of 'func' when called with 'foo'.
'shuffle' however has None as its return type, as the list will be modified in place, hence it prints nothing.
Workaround:</p>
<pre><code># shuffle the list in place 
random.shuffle(b)

# print it
print(b)
</code></pre>
<p>If you're more into functional programming style you might want to make the following wrapper function:</p>
<pre><code>def myshuffle(ls):
    random.shuffle(ls)
    return ls
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In some cases when using numpy arrays, using <code>random.shuffle</code> created duplicate data in the array. </p>
<p>An alternative is to use <code>numpy.random.shuffle</code>. If you're working with numpy already, this is the preferred method over the generic <code>random.shuffle</code>. </p>
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.shuffle.html" rel="noreferrer">numpy.random.shuffle</a></p>
<p><strong>Example</strong></p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import random
</code></pre>
<p>Using <code>random.shuffle</code>:</p>
<pre><code>&gt;&gt;&gt; foo = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; foo

array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])


&gt;&gt;&gt; random.shuffle(foo)
&gt;&gt;&gt; foo

array([[1, 2, 3],
       [1, 2, 3],
       [4, 5, 6]])
</code></pre>
<p>Using <code>numpy.random.shuffle</code>:</p>
<pre><code>&gt;&gt;&gt; foo = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; foo

array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])


&gt;&gt;&gt; np.random.shuffle(foo)
&gt;&gt;&gt; foo

array([[1, 2, 3],
       [7, 8, 9],
       [4, 5, 6]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One can define a function called <code>shuffled</code> (in the same sense of <code>sort</code> vs <code>sorted</code>)</p>
<pre><code>def shuffled(x):
    import random
    y = x[:]
    random.shuffle(y)
    return y

x = shuffled([1, 2, 3, 4])
print x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random

class a:
    foo = "bar"

a1 = a()
a2 = a()
a3 = a()
a4 = a()
b = [a1,a2,a3,a4]

random.shuffle(b)
print(b)
</code></pre>
<p><code>shuffle</code>  is in place, so do not print result, which is <code>None</code>, but the list. </p>
</div>
<div class="post-text" itemprop="text">
<p>For one-liners, use<code>random.sample(list_to_be_shuffled, length_of_the_list)</code> with an example:</p>
<pre><code>import random
random.sample(list(range(10)), 10)
</code></pre>
<p>outputs:
[2, 9, 7, 8, 3, 0, 4, 1, 6, 5]</p>
</div>
<div class="post-text" itemprop="text">
<p>Make sure you are not naming your source file random.py, and that there is not a file in your working directory called random.pyc..  either could cause your program to try and import your local random.py file instead of pythons random module.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can go for this:</p>
<pre><code>&gt;&gt;&gt; A = ['r','a','n','d','o','m']
&gt;&gt;&gt; B = [1,2,3,4,5,6]
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.sample(A+B, len(A+B))
[3, 'r', 4, 'n', 6, 5, 'm', 2, 1, 'a', 'o', 'd']
</code></pre>
<p>if you want to go back to two lists, you then split this long list into two.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def shuffle(_list):
    if not _list == []:
        import random
        list2 = []
        while _list != []:
            card = random.choice(_list)
            _list.remove(card)
            list2.append(card)
        while list2 != []:
            card1 = list2[0]
            list2.remove(card1)
            _list.append(card1)
        return _list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you could build a function that takes a list as a parameter and returns a shuffled version of the list:</p>
<pre><code>from random import *

def listshuffler(inputlist):
    for i in range(len(inputlist)):
        swap = randint(0,len(inputlist)-1)
        temp = inputlist[swap]
        inputlist[swap] = inputlist[i]
        inputlist[i] = temp
    return inputlist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>""" to shuffle random, set random= True """

def shuffle(x,random=False):
     shuffled = []
     ma = x
     if random == True:
         rando = [ma[i] for i in np.random.randint(0,len(ma),len(ma))]
         return rando
     if random == False:
          for i in range(len(ma)):
          ave = len(ma)//3
          if i &lt; ave:
             shuffled.append(ma[i+ave])
          else:
             shuffled.append(ma[i-ave])    
     return shuffled
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>you can either use shuffle or sample . both of which come from random module.</p>
<pre><code>import random
def shuffle(arr1):
    n=len(arr1)
    b=random.sample(arr1,n)
    return b
</code></pre>
<p>OR</p>
<pre><code>import random
def shuffle(arr1):
    random.shuffle(arr1)
    return arr1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import random
class a:
    foo = "bar"

a1 = a()
a2 = a()
b = [a1.foo,a2.foo]
random.shuffle(b)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>The shuffling process is "with replacement"</strong>, so the occurrence of each item may change! At least when when items in your list is also list. </p>
<p>E.g.,</p>
<pre><code>ml = [[0], [1]] * 10
</code></pre>
<p>After, </p>
<pre><code>random.shuffle(ml)
</code></pre>
<p>The number of [0] may be 9 or 8, but not exactly 10.</p>
</div>
<div class="post-text" itemprop="text">
<p>Plan: Write out the shuffle without relying on a library to do the heavy lifting. Example: Go through the list from the beginning starting with element 0; find a new random position for it, say 6, put 0’s value in 6 and 6’s value in 0. Move on to element 1 and repeat this process, and so on through the rest of the list</p>
<pre><code>import random
iteration = random.randint(2, 100)
temp_var = 0
while iteration &gt; 0:

    for i in range(1, len(my_list)): # have to use range with len()
        for j in range(1, len(my_list) - i):
            # Using temp_var as my place holder so I don't lose values
            temp_var = my_list[i]
            my_list[i] = my_list[j]
            my_list[j] = temp_var

        iteration -= 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It works fine. I am trying it here with functions as list objects:</p>
<pre><code>    from random import shuffle

    def foo1():
        print "foo1",

    def foo2():
        print "foo2",

    def foo3():
        print "foo3",

    A=[foo1,foo2,foo3]

    for x in A:
        x()

    print "\r"

    shuffle(A)
    for y in A:
        y()
</code></pre>
<p>It prints out:
foo1 foo2 foo3 
foo2 foo3 foo1
(the foos in the last row have a random order)</p>
</div>
<span class="comment-copy">Can you give an example how it fails? random.shuffle should work invariant to the type of the objects in the list.</span>
<span class="comment-copy">&gt;&gt;&gt; a1 = a() &gt;&gt;&gt; a2 = a() &gt;&gt;&gt; b = [a1,a2] &gt;&gt;&gt; b [&lt;__main__.a instance at 0xb7df9e6c&gt;, &lt;__main__.a instance at 0xb7df9e2c&gt;] &gt;&gt;&gt; print random.shuffle(b) None</span>
<span class="comment-copy">As stated below, random.shuffle doesn't return a new shuffled list; it shuffles the list in place.  So you shouldn't say "print random.shuffle(b)" and should instead do the shuffle on one line and print b on the next line.</span>
<span class="comment-copy">If you are trying to shuffle numpy arrays, see my answer below.</span>
<span class="comment-copy">is there an option that doesn't mutate the original array but return a new shuffled array?</span>
<span class="comment-copy">@seokhoonlee Neither. It is a pseduo-random number generator which, when possible, is seeded by a source of real randomness from the OS. For all but cryptography purposes it is random "enough". This is laid out in detail in the <a href="https://docs.python.org/3/library/random.html" rel="nofollow noreferrer"><code>random</code> module's documentation</a>.</span>
<span class="comment-copy">use clone for a new list</span>
<span class="comment-copy">is there an option that doesn't mutate the original array but return a new shuffled array?</span>
<span class="comment-copy">@CharlieParker: Not that I know of. You could use <code>random.sample(x, len(x))</code> or just make a copy and <code>shuffle</code> that.  For <code>list.sort</code> which has a similar issue, there's now <code>list.sorted</code>, but there's not a similar variant for <code>shuffle</code>.</span>
<span class="comment-copy">@seokhonlee for crypto-secure randomness, use <code>from random import SystemRandom</code> instead; add <code>cryptorand = SystemRandom()</code> and change row 3 to <code>cryptorand.shuffle(x)</code></span>
<span class="comment-copy">thanks for this - it's what I was looking for but didn't know how to express...</span>
<span class="comment-copy">is there an option that doesn't mutate the original array but return a new shuffled array?</span>
<span class="comment-copy">just copy the list @CharlieParker: <code>old = [1,2,3,4,5]; new = list(old); random.shuffle(new); print(old); print(new)</code> (replace ; with newlines)</span>
<span class="comment-copy"><code>old[:]</code> also could do a shallow copy for list <code>old</code>.</span>
<span class="comment-copy">Still does not work for me, see my example code in the edited question.</span>
<span class="comment-copy">this code didn't work, <code>random.shuff(ls)</code> returns <code>None</code></span>
<span class="comment-copy">The second parameter defaults to random.random. It's perfectly safe to leave it out.</span>
<span class="comment-copy">@alvas random.shuffle(a) doesn't return any thing i.e. it returns None . So you have to check a not return value .</span>
<span class="comment-copy">Also, note that thanks to <code>sorted</code>, this is a functional shuffle (if you're into that sort of thing).</span>
<span class="comment-copy">This doesn't truly randomly distribute the values due to the stability of Timsort. (Values with the same key are left in their original order.) EDIT: I suppose it doesn't matter since the risk of collision with 64-bit floats is quite minimal.</span>
<span class="comment-copy">Since this passes a reference to the list, the original gets modified. You might want to copy the list before shuffling using <a href="http://docs.python.org/2/library/copy.html" rel="nofollow noreferrer">deepcopy</a></span>
<span class="comment-copy">@shivram.ss In this case, you'd want something like <code>random.sample(ls, len(ls))</code> if you really want to go down that route.</span>
<span class="comment-copy">Also, <code>numpy.random.permutation</code> may be of interest: <a href="http://stackoverflow.com/questions/15474159/shuffle-vs-permute-numpy" title="shuffle vs permute numpy">stackoverflow.com/questions/15474159/shuffle-vs-permute-numpy</a></span>
<span class="comment-copy">Do you have an example of duplicated data being created in an array when using random.shuffle?</span>
<span class="comment-copy">Yes - it's included in my answer. See the section entitled "Example". ;)</span>
<span class="comment-copy">Nevermind, I saw three elements and thought it was the same. Nice find</span>
<span class="comment-copy">This function can help you if you don't want to use random module</span>
<span class="comment-copy">It does use the random module...</span>
<span class="comment-copy">This solution is not only verbose but inefficient (runtime is proportional to the square of the list size).</span>
<span class="comment-copy">The second loop could be replaced by <code>_list.extend(list2)</code>, which is more succinct AND more efficient.</span>
<span class="comment-copy">A Python function that modifies a parameter should never return a result. It's just a convention, but a useful one: People often lack the time to look at the implementation of all the functions that they call, so anybody who just sees your function's name and that it has a result will be very surprised to see the function update its parameter.</span>
<span class="comment-copy">a small introduction or explanation would be helpful?</span>
<span class="comment-copy">the function is helpful for shuffling activity, imagine you have to shuffle a list of numbers for three times and in the three times you require random shuffle to occur then just turn the random argument to True else if you don't require randomness and you want same shuffling order to be preserved then don't make any changes, just run the code.</span>
<span class="comment-copy">Since there is no use case where the caller of this function would decide at runtime whether he wants the random or the non-random shuffle, this function should be split into two.</span>
<span class="comment-copy">There is no description what the non-random shuffle is supposed to do. (On a tangent, it is not an answer so the question, so it does not serve the purpose of Stack Overflow.)</span>
<span class="comment-copy">you can swap variables in python like this: <code>my_list[i], my_list[j] = my_list[j], my_list[i]</code></span>
<span class="comment-copy">This question was correctly answered 5 years ago.</span>
