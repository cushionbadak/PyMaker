<div class="post-text" itemprop="text">
<p>I have a class <code>MyClass</code>, which contains two member variables <code>foo</code> and <code>bar</code>:</p>
<pre><code>class MyClass:
    def __init__(self, foo, bar):
        self.foo = foo
        self.bar = bar
</code></pre>
<p>I have two instances of this class, each of which has identical values for <code>foo</code> and <code>bar</code>:</p>
<pre><code>x = MyClass('foo', 'bar')
y = MyClass('foo', 'bar')
</code></pre>
<p>However, when I compare them for equality, Python returns <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; x == y
False
</code></pre>
<p>How can I make python consider these two objects equal?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should implement the method <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" rel="nofollow noreferrer"><code>__eq__</code></a>:</p>
<pre><code>class MyClass:
    def __init__(self, foo, bar):
        self.foo = foo
        self.bar = bar

    def __eq__(self, other): 
        if not isinstance(other, MyClass):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return self.foo == other.foo and self.bar == other.bar
</code></pre>
<p>Now it outputs:</p>
<pre><code>&gt;&gt;&gt; x == y
True
</code></pre>
<p>Note that implementing <code>__eq__</code> will automatically make instances of your class unhashable, which means they can't be stored in sets and dicts. If you're not modelling an immutable type (i.e. if the attributes <code>foo</code> and <code>bar</code> may change value within the lifetime of your object), then it's recommend to just leave your instances as unhashable.</p>
<p>If you are modelling an immutable type, you should also implement the datamodel hook <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code></a>:</p>
<pre><code>class MyClass:
    ...

    def __hash__(self):
        # necessary for instances to behave sanely in dicts and sets.
        return hash((self.foo, self.bar))
</code></pre>
<p>A general solution, like the idea of looping through <code>__dict__</code> and comparing values, is not advisable - it can never be truly general because the <code>__dict__</code> may have uncomparable or unhashable types contained within.</p>
<p>N.B.: be aware that before Python 3, you may need to use <a href="https://portingguide.readthedocs.io/en/latest/comparisons.html#rich-comparisons" rel="nofollow noreferrer"><code>__cmp__</code></a> instead of <code>__eq__</code>.  Python 2 users may also want to implement <a href="https://docs.python.org/2/reference/datamodel.html#object.__ne__" rel="nofollow noreferrer"><code>__ne__</code></a>, since a sensible default behaviour for inequality (i.e. inverting the equality result) will not be automatically created in Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>You override the <a href="https://docs.python.org/2.7/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">rich comparison operators</a> in your object.</p>
<pre><code>class MyClass:
 def __lt__(self, other):
      # return comparison
 def __le__(self, other):
      # return comparison
 def __eq__(self, other):
      # return comparison
 def __ne__(self, other):
      # return comparison
 def __gt__(self, other):
      # return comparison
 def __ge__(self, other):
      # return comparison
</code></pre>
<p>Like this:</p>
<pre><code>    def __eq__(self, other):
        return self._id == other._id
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Implement the <code>__eq__</code> method in your class; something like this:</p>
<pre><code>def __eq__(self, other):
    return self.path == other.path and self.title == other.title
</code></pre>
<p>Edit: if you want your objects to compare equal if and only if they have equal instance dictionaries:</p>
<pre><code>def __eq__(self, other):
    return self.__dict__ == other.__dict__
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a summary : </p>
<ol>
<li>It's advised to implement <code>__eq__</code> rather than <code>__cmp__</code>, except if you run python &lt;= 2.0 (<code>__eq__</code> has been added in 2.1)</li>
<li>Don't forget to also implement <code>__ne__</code> (should be something like <code>return not self.__eq__(other)</code> or <code>return not self == other</code> except very special case)</li>
<li>Don`t forget that the operator must be implemented in each custom class you want to compare (see example below).</li>
<li><p>If you want to compare with object that can be None, you must implement it. The interpreter cannot guess it ... (see example below)</p>
<pre><code>class B(object):
  def __init__(self):
    self.name = "toto"
  def __eq__(self, other):
    if other is None:
      return False
    return self.name == other.name

class A(object):
  def __init__(self):
    self.toto = "titi"
    self.b_inst = B()
  def __eq__(self, other):
    if other is None:
      return False
    return (self.toto, self.b_inst) == (other.toto, other.b_inst)
</code></pre></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>When comparing instances of objects, the <a href="http://docs.python.org/reference/datamodel.html#object.__cmp__" rel="nofollow noreferrer"><code>__cmp__</code></a> function is called.</p>
<p>If the == operator is not working for you by default, you can always redefine the <code>__cmp__</code> function for the object.</p>
<p>Edit:</p>
<p>As has been pointed out, the <code>__cmp__</code> function is deprecated since 3.0.
Instead you should use the <a href="http://docs.python.org/reference/datamodel.html#object.__lt__" rel="nofollow noreferrer">“rich comparison”</a> methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to get an attribute-by-attribute comparison, and see if and where it fails, you can use the following list comprehension:</p>
<pre><code>[i for i,j in 
 zip([getattr(committed_vans_events[0][0].request, attr) 
      for attr in dir(committed_vans_events[0][0].request)],
     [getattr(self.vans_states[0].onboard_passengers[0], attr) 
      for attr in dir(self.vans_states[0].onboard_passengers[0])]) 
 if not i==j]
</code></pre>
<p>The extra advantage here is that you can squeeze it one line and enter in the "Evaluate Expression" window when debugging in PyCharm.</p>
</div>
<div class="post-text" itemprop="text">
<p>I tried the initial example (see 7 above) and it did not work in ipython. Note that cmp(obj1,obj2) returns a "1" when implemented using two identical object instances. Oddly enough when I modify one of the attribute values and recompare, using  cmp(obj1,obj2) the object continues to return a "1".  (sigh...)</p>
<p>Ok, so what you need to do is iterate two objects and compare each attribute using the == sign.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instance of a class when compared with == comes to non-equal. The best way is to ass the <strong>cmp</strong> function to your class which will do the stuff. </p>
<p>If you want to do comparison by the content you can simply use cmp(obj1,obj2)</p>
<p>In your case cmp(doc1,doc2) It will return -1 if the content wise they are same.</p>
</div>
<span class="comment-copy">You almost got it, but you don't need to loop other <b>dict</b> because Python is able to check the equality between built-in types itself. Check my answer for a simple snippet.</span>
<span class="comment-copy">Note that with this technique, a Test instance will also compare equal to any other instance who's dictionary compares equal. You may also want "isinstance(other, self.__class__)" in <b>eq</b>.</span>
<span class="comment-copy">That would kill the nice duck typing we got here. It's not like there is a big likely hood that two classes have the exact same signature and that your willingly compare it to each other. And without knowing it.</span>
<span class="comment-copy">One caveat: defining <code>__eq__</code> does not automatically add support for the != operator, so in this case <code>(Test("foo", 42) != Test("foo", 42))</code> will equal <code>True</code>.  You have to define <code>__ne__</code> as well:  <code>def __ne__(self, other): return not self == other</code></span>
<span class="comment-copy">what happens when one of these attributes is a list of primitive types? what happens when an attribute is another object?</span>
<span class="comment-copy">Don't forget to implement <code>__hash__(self)</code> as well. Elsewhere you will have unexpected behaviors while using the objects as dictionary key or in sets! If you need <code>__eq__()</code> you will soon use the objects in sets or dictionaries!! A good practice is to systematically implement <code>__hash__()</code> along with <code>__eq__()</code>. This rule actually applies to any programming language.</span>
<span class="comment-copy">Note that in Python 2.5 and onwards, the class must define <code>__eq__()</code>, but only one of <code>__lt__()</code>, <code>__le__()</code>, <code>__gt__()</code>, or <code>__ge__()</code> is needed in addition to that. From that, Python can infer the other methods. See <a href="http://docs.python.org/2/library/functools.html" rel="nofollow noreferrer"><code>functools</code></a> for more information.</span>
<span class="comment-copy">@kba, I don't think that's true. This may work for the <code>functools</code> module, but <b>does not work</b> for standard comparators: <code>MyObj1 != Myobj2</code> will only work if the <code>__ne__()</code> method is implemented.</span>
<span class="comment-copy">the specific tip about functools should be to use the <code>@functools.total_ordering</code> decorator on your class, then as above you can define just <code>__eq__</code> and one other and the rest will be derived</span>
<span class="comment-copy">Perhaps you mean <code>self is other</code> to see if they are the same object.</span>
<span class="comment-copy">-1. Even if this is two dictionary instance, Python will compare them by keys / values automatically. This is not Java...</span>
<span class="comment-copy">The first solution can raise an <code>AttributeError</code>. You have to insert the line <code>if hasattr(other, "path") and hasattr(other, "title"):</code> (like <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" rel="nofollow noreferrer">this nice example</a> in the Python documentation).</span>
<span class="comment-copy">The <b>cmp</b> function is deprecated for 3.0+</span>
<span class="comment-copy">Yes, see <a href="http://stackoverflow.com/questions/1061283/style-why-lt-instead-of-cmp" title="style why lt instead of cmp">stackoverflow.com/questions/1061283/style-why-lt-instead-of-cmp</a></span>
<span class="comment-copy">Ah!You learn something new everyday;d</span>
<span class="comment-copy">I laughed and then I cried...</span>
<span class="comment-copy">In Python 2.7 at least, objects are compared by identity by default. That means for CPython in practical words they compare by they memory address. That's why cmp(o1, o2) returns 0 only when "o1 is o2" and consistently 1 or -1 depending upon the values of id(o1) and id(o2)</span>
