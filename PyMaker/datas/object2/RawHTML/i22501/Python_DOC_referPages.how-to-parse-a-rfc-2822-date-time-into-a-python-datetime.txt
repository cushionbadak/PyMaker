<div class="post-text" itemprop="text">
<p>I have a date of the form specified by RFC 2822 -- say <code>Fri, 15 May 2009 17:58:28 +0000</code>, as a string. Is there a quick and/or standard way to get it as a <code>datetime</code> object in Python 2.5? I tried to produce a strptime format string, but the +0000 timezone specifier confuses the parser.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that parsedate will ignore the offset.</p>
<p>Do this instead:</p>
<pre><code>from email.utils import parsedate_tz
print parsedate_tz('Fri, 15 May 2009 17:58:28 +0700')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to elaborate on previous answers. <code>email.utils.parsedate</code> and <code>email.utils.parsedate_tz</code> both return tuples, since the OP needs a <code>datetime.datetime</code> object, I'm adding these examples for completeness:</p>
<pre><code>from email.utils import parsedate
from datetime import datetime
import time

t = parsedate('Sun, 14 Jul 2013 20:14:30 -0000')
d1 = datetime.fromtimestamp(time.mktime(t))
</code></pre>
<p>Or:</p>
<pre><code>d2 = datetime.datetime(*t[:6])
</code></pre>
<p>Note that <code>d1</code> and <code>d2</code> are both naive datetime objects, there's no timezone information stored. If you need aware datetime objects, check the <code>tzinfo</code> <code>datetime()</code> arg.</p>
<p>Alternatively you could use the <a href="https://pypi.python.org/pypi/python-dateutil" rel="noreferrer">dateutil</a> module</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from email.utils import parsedate
print parsedate('Fri, 15 May 2009 17:58:28 +0000')
</code></pre>
<p><a href="http://docs.python.org/library/email.util.html#email.utils.parsedate" rel="noreferrer">Documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a parsedate function in <a href="http://docs.python.org/library/email.util.html" rel="nofollow noreferrer">email.util</a>.
It parses all valid RFC 2822 dates and some special cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>It looks like Python 3.3 going forward has a new method <code>parsedate_to_datetime</code> in email.utils that takes care of the intermediate steps:</p>
<blockquote>
<p><strong>email.utils.parsedate_to_datetime(date)</strong> </p>
<p>The inverse of format_datetime(). Performs the same function as parsedate(), but on
  success returns a datetime. If the input date has a timezone of -0000,
  the datetime will be a naive datetime, and if the date is conforming
  to the RFCs it will represent a time in UTC but with no indication of
  the actual source timezone of the message the date comes from. If the
  input date has any other valid timezone offset, the datetime will be
  an aware datetime with the corresponding a timezone tzinfo.</p>
<p>New in version 3.3.</p>
</blockquote>
<p><a href="http://python.readthedocs.org/en/latest/library/email.util.html#email.utils.parsedate_to_datetime" rel="noreferrer">http://python.readthedocs.org/en/latest/library/email.util.html#email.utils.parsedate_to_datetime</a></p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/email.util.html#email.utils.parsedate_tz" rel="nofollow noreferrer"><code>email.utils.parsedate_tz(date)</code></a> is the function to use. Following are some variations.</p>
<h1>Email date/time string (<a href="https://tools.ietf.org/html/rfc5322#section-3.3" rel="nofollow noreferrer">RFC 5322</a>, <a href="https://tools.ietf.org/html/rfc2822#section-3.3" rel="nofollow noreferrer">RFC 2822</a>, <a href="https://tools.ietf.org/html/rfc1123#page-55" rel="nofollow noreferrer">RFC 1123</a>) to unix timestamp in float seconds:</h1>
<pre class="lang-py prettyprint-override"><code>import email.utils
import calendar
def email_time_to_timestamp(s):
    tt = email.utils.parsedate_tz(s)
    if tt is None: return None
    return calendar.timegm(tt) - tt[9]

import time
print(time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(email_time_to_timestamp("Wed, 04 Jan 2017 09:55:45 -0800"))))
# 2017-01-04T17:55:45Z
</code></pre>
<p>Make sure you <strong>do not use</strong> <a href="https://docs.python.org/3/library/time.html#time.mktime" rel="nofollow noreferrer"><code>mktime</code></a> (which interprets the time_struct in your computer’s local time, not UTC); use <a href="https://docs.python.org/3/library/calendar.html#calendar.timegm" rel="nofollow noreferrer"><code>timegm</code></a> or <a href="https://docs.python.org/3/library/email.util.html#email.utils.mktime_tz" rel="nofollow noreferrer"><code>mktime_tz</code></a> instead (but beware caveat for <code>mktime_tz</code> in the next paragraph).</p>
<p>If you are sure that you have python version 2.7.4, 3.2.4, 3.3, or newer, then you can use <a href="https://docs.python.org/3/library/email.util.html#email.utils.mktime_tz" rel="nofollow noreferrer"><code>email.utils.mktime_tz(tt)</code></a> instead of <code>calendar.timegm(tt) - tt[9]</code>. Before that, <code>mktime_tz</code> gave incorrect times when invoked during the local time zone’s fall daylight savings transition (<a href="http://bugs.python.org/issue14653" rel="nofollow noreferrer">bug 14653</a>).</p>
<p>Thanks to @j-f-sebastian for <a href="https://stackoverflow.com/questions/1790795/parsing-date-with-timezone-from-an-email#comment35349147_1790885">caveats about mktime and mktime_tz</a>.</p>
<h1>Email date/time string (<a href="https://tools.ietf.org/html/rfc5322#section-3.3" rel="nofollow noreferrer">RFC 5322</a>, <a href="https://tools.ietf.org/html/rfc2822#section-3.3" rel="nofollow noreferrer">RFC 2822</a>, <a href="https://tools.ietf.org/html/rfc1123#page-55" rel="nofollow noreferrer">RFC 1123</a>) to “aware” <code>datetime</code> on python 3.3:</h1>
<p>On python 3.3 and above, use <a href="https://docs.python.org/3/library/email.util.html#email.utils.parsedate_to_datetime" rel="nofollow noreferrer"><code>email.utils.parsedate_to_datetime</code></a>, which returns an aware <code>datetime</code> with the original zone offset:</p>
<pre class="lang-py prettyprint-override"><code>import email.utils
email.utils.parsedate_to_datetime(s)

print(email.utils.parsedate_to_datetime("Wed, 04 Jan 2017 09:55:45 -0800").isoformat())
# 2017-01-04T09:55:45-08:00
</code></pre>
<p>Caveat: this will throw <code>ValueError</code> if the time falls on a leap second e.g. <code>email.utils.parsedate_to_datetime("Sat, 31 Dec 2016 15:59:60 -0800")</code>.</p>
<h1>Email date/time string (<a href="https://tools.ietf.org/html/rfc5322#section-3.3" rel="nofollow noreferrer">RFC 5322</a>, <a href="https://tools.ietf.org/html/rfc2822#section-3.3" rel="nofollow noreferrer">RFC 2822</a>, <a href="https://tools.ietf.org/html/rfc1123#page-55" rel="nofollow noreferrer">RFC 1123</a>) to “aware” <code>datetime</code> in UTC zone:</h1>
<p>This just converts to timestamp and then to UTC <code>datetime</code>:</p>
<pre class="lang-py prettyprint-override"><code>import email.utils
import calendar
import datetime
def email_time_to_utc_datetime(s):
    tt = email.utils.parsedate_tz(s)
    if tt is None: return None
    timestamp = calendar.timegm(tt) - tt[9]
    return datetime.datetime.utcfromtimestamp(timestamp)

print(email_time_to_utc_datetime("Wed, 04 Jan 2017 09:55:45 -0800").isoformat())
# 2017-01-04T17:55:45
</code></pre>
<h1>Email date/time string (<a href="https://tools.ietf.org/html/rfc5322#section-3.3" rel="nofollow noreferrer">RFC 5322</a>, <a href="https://tools.ietf.org/html/rfc2822#section-3.3" rel="nofollow noreferrer">RFC 2822</a>, <a href="https://tools.ietf.org/html/rfc1123#page-55" rel="nofollow noreferrer">RFC 1123</a>) to python “aware” <code>datetime</code> with original offset:</h1>
<p>Prior to python 3.2, python did not come with tzinfo implementations, so here an example using <a href="https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.tzoffset" rel="nofollow noreferrer"><code>dateutil.tz.tzoffset</code></a> (<code>pip install dateutil</code>):</p>
<pre class="lang-py prettyprint-override"><code>import email.utils
import datetime
import dateutil.tz
def email_time_to_datetime(s):
    tt = email.utils.parsedate_tz(s)
    if tt is None: return None
    tz = dateutil.tz.tzoffset("UTC%+02d%02d"%(tt[9]//60//60, tt[9]//60%60), tt[9])
    return datetime.datetime(*tt[:5]+(min(tt[5], 59),), tzinfo=tz)

print(email_time_to_datetime("Wed, 04 Jan 2017 09:55:45 -0800").isoformat())
# 2017-01-04T09:55:45-08:00
</code></pre>
<p>If you are using python 3.2, you can use the builtin <code>tzinfo</code> implementation <a href="https://docs.python.org/3/library/datetime.html#datetime.timezone" rel="nofollow noreferrer"><code>datetime.timezone</code></a>: <code>tz = datetime.timezone(datetime.timedelta(seconds=tt[9]))</code> instead of the third-party <a href="https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.tzoffset" rel="nofollow noreferrer"><code>dateutil.tz.tzoffset</code></a>.</p>
<p>Thanks to @j-f-sebastian again <a href="https://stackoverflow.com/questions/1697815/how-do-you-convert-a-python-time-struct-time-object-into-a-datetime-object#comment44370541_1697838">for note on clamping the leap second</a>.</p>
</div>
<span class="comment-copy">+1 I didn't know about this function, really neat.</span>
<span class="comment-copy">Thank you; that does the trick. :)</span>
