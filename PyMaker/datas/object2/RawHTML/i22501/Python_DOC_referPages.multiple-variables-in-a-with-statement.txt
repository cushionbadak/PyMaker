<div class="post-text" itemprop="text">
<p>Is it possible to declare more than one variable using a <code>with</code> statement in Python?</p>
<p>Something like:</p>
<pre><code>from __future__ import with_statement

with open("out.txt","wt"), open("in.txt") as file_out, file_in:
    for line in file_in:
        file_out.write(line)
</code></pre>
<p>... or is cleaning up two resources at the same time the problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible in <a href="http://docs.python.org/3.1/reference/compound_stmts.html#with" rel="noreferrer">Python 3 since v3.1</a> and  <a href="http://docs.python.org/dev/whatsnew/2.7.html#other-language-changes" rel="noreferrer">Python 2.7</a>. The new <a href="https://docs.python.org/3/reference/compound_stmts.html" rel="noreferrer"><code>with</code> syntax</a> supports multiple context managers:</p>
<pre><code>with A() as a, B() as b, C() as c:
    doSomething(a,b,c)
</code></pre>
<p>Unlike the <code>contextlib.nested</code>, this guarantees that <code>a</code> and <code>b</code> will have their <code>__exit__()</code>'s called even if <code>C()</code> or it's <code>__enter__()</code> method raises an exception.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/library/contextlib.html#contextlib.nested" rel="nofollow noreferrer"><code>contextlib.nested</code></a> supports this:</p>
<pre><code>import contextlib

with contextlib.nested(open("out.txt","wt"), open("in.txt")) as (file_out, file_in):

   ...
</code></pre>
<p><strong>Update:</strong><br/>
To quote the documentation, regarding <a href="http://docs.python.org/2/library/contextlib.html#contextlib.nested" rel="nofollow noreferrer"><code>contextlib.nested</code></a>:</p>
<blockquote>
<p><em>Deprecated since version 2.7</em>: The with-statement now supports this
  functionality directly (without the confusing error prone quirks).</p>
</blockquote>
<p>See <a href="https://stackoverflow.com/a/1073814/1217270">Rafa≈Ç Dowgird's answer</a> for more information. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think you want to do this instead:</p>
<pre><code>from __future__ import with_statement

with open("out.txt","wt") as file_out:
    with open("in.txt") as file_in:
        for line in file_in:
            file_out.write(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note that if you split the variables into lines, you must use backslashes to wrap the newlines.</p>
<pre><code>with A() as a, \
     B() as b, \
     C() as c:
    doSomething(a,b,c)
</code></pre>
<p>Parentheses don't work, since Python creates a tuple instead.</p>
<pre><code>with (A(),
      B(),
      C()):
    doSomething(a,b,c)
</code></pre>
<p>Since tuples lack a <code>__enter__</code> attribute, you get an error (undescriptive and does not identify class type):</p>
<blockquote>
<pre><code>AttributeError: __enter__
</code></pre>
</blockquote>
<p>If you try to use <code>as</code> within parentheses, Python catches the mistake at parse time:</p>
<pre><code>with (A() as a,
      B() as b,
      C() as c):
    doSomething(a,b,c)
</code></pre>
<blockquote>
<p>SyntaxError: invalid syntax</p>
</blockquote>
<p><a href="https://bugs.python.org/issue12782" rel="nofollow noreferrer">https://bugs.python.org/issue12782</a> seems to be related to this issue.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since Python 3.3, you can use the class <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer"><code>ExitStack</code></a> from the <a href="https://docs.python.org/3/library/contextlib.html#module-contextlib" rel="noreferrer"><code>contextlib</code></a> module.</p>
<p>It can manage a <em>dynamic</em> number of context-aware objects, which means that it will prove especially useful if you don't know how many files you are going to handle.</p>
<p>The canonical use-case that is mentioned in the documentation is managing a dynamic number of files.</p>
<pre><code>with ExitStack() as stack:
    files = [stack.enter_context(open(fname)) for fname in filenames]
    # All opened files will automatically be closed at the end of
    # the with statement, even if attempts to open files later
    # in the list raise an exception
</code></pre>
<p>Here is a generic example:</p>
<pre><code>from contextlib import ExitStack

class X:
    num = 1

    def __init__(self):
        self.num = X.num
        X.num += 1

    def __repr__(self):
        cls = type(self)
        return '{cls.__name__}{self.num}'.format(cls=cls, self=self)

    def __enter__(self):
        print('enter {!r}'.format(self))
        return self.num

    def __exit__(self, exc_type, exc_value, traceback):
        print('exit {!r}'.format(self))
        return True

xs = [X() for _ in range(3)]

with ExitStack() as stack:
    print(stack._exit_callbacks)
    nums = [stack.enter_context(x) for x in xs]
    print(stack._exit_callbacks)
print(stack._exit_callbacks)
print(nums)
</code></pre>
<p>Output:</p>
<pre><code>deque([])
enter X1
enter X2
enter X3
deque([&lt;function ExitStack._push_cm_exit.&lt;locals&gt;._exit_wrapper at 0x7f5c95f86158&gt;, &lt;function ExitStack._push_cm_exit.&lt;locals&gt;._exit_wrapper at 0x7f5c95f861e0&gt;, &lt;function ExitStack._push_cm_exit.&lt;locals&gt;._exit_wrapper at 0x7f5c95f86268&gt;])
exit X3
exit X2
exit X1
deque([])
[1, 2, 3]
</code></pre>
</div>
<span class="comment-copy">Maybe like this:  with [expr1,expr2] as f:  and then use f[0] and f[1].</span>
<span class="comment-copy">Would have been nice because no need to import something.... but it doesn't work   AttributeError: 'list' object has no attribute '<b>exit</b>'</span>
<span class="comment-copy">If python just had closures, you wouldn't need the with statement</span>
<span class="comment-copy">Many of these answers don't deal with the need for more than two with statements. Theoretically there may be applications that need to open tens of contexts, the nesting falls apart very quickly is any line length limitations are imposed.</span>
<span class="comment-copy">@Mark Amery. Yup, but I asked first :)</span>
<span class="comment-copy">is it possible set fields equal to something in with statement as in <code>with open('./file') as arg.x = file:</code>?</span>
<span class="comment-copy">Also, it is possible: with A() as a, B(a) as b, C(a,b) as c:</span>
<span class="comment-copy">class test2: x=1; t2=test2() with open('f2.txt') as t2.x:   for l1 in t2.x.readlines():     print(l1); # Charlie Parker # tested in python 3.6</span>
<span class="comment-copy">please note, <code>as</code> is optional.</span>
<span class="comment-copy">I am sorry to say that, but I think that the <code>nested</code> context manager is a mistake and should never be used. In this example, if opening the second file raises an exception, the first file won't be closed at all, thus totally destroying the purpose of using context managers.</span>
<span class="comment-copy">Why do you say that? The documentation says that using nested is equivalent to nested 'with's</span>
<span class="comment-copy">@Rafal: a glance at the manual seems to indicate that python properly nests the with statements. The real problem is if the second file throws an exception upon closing.</span>
<span class="comment-copy">@James: No, the equivalent code in the docs at <a href="http://docs.python.org/library/contextlib.html#contextlib.nested" rel="nofollow noreferrer">docs.python.org/library/contextlib.html#contextlib.nested</a> differs from the standard nested <code>with</code> blocks. The managers are created in order <i>before</i> entering the with blocks:  m1, m2, m3 = A(), B(), C()  If B() or C() fails with exception, then your only hope of properly finalizing A() is the garbage collector.</span>
<span class="comment-copy"><a href="http://docs.python.org/2/library/contextlib.html#contextlib.nested" rel="nofollow noreferrer">Deprecated since version 2.7</a>. Note: The with-statement now supports this functionality directly (without the confusing error prone quirks).</span>
<span class="comment-copy">That's how I currently do it, but then the nesting is twice as deep as I want (mean) it to be...</span>
<span class="comment-copy">I think this is the cleanest approach though - any other approach is going to be harder to read.  Alex Martelli's answer seems to be closer to what you want but is much less readable.  Why is nesting such a concern?</span>
<span class="comment-copy">Not a big deal, admittedly, but, per "import this" (aka "Zen of Python"), "flat is better than nested" -- that's why we added contextlib.nested to the standard library. BTW, 3.1 might have a new syntax "with A() as a, B() as b:" (the patch is in, no BDFL pronouncement about it so far though) for more direct support (so clearly the library solution isn't considered perfect... but avoiding unwanted nesting is definitely a widely shared goal among core Python developers).</span>
<span class="comment-copy">@Alex: Very true but we must also consider that "Readability counts".</span>
<span class="comment-copy">@Andrew: I think one level of indentation better expresses the intended logic of the program, which is to "atomically" create two variables, and clean them up later together (I realise this isn't actually what happens). Think the exception issue is a deal breaker though</span>
