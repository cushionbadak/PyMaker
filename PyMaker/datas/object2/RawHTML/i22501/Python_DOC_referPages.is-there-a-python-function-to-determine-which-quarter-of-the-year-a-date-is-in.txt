<div class="post-text" itemprop="text">
<p>Sure I could write this myself, but before I go reinventing the wheel is there a function that already does this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Given an instance <code>x</code> of <a href="http://docs.python.org/library/datetime.html?highlight=datetime#datetime.date" rel="noreferrer">datetime.date</a>, <code>(x.month-1)//3</code> will give you the quarter (0 for first quarter, 1 for second quarter, etc -- add 1 if you need to count from 1 instead;-).</p>
<hr/>
<p>Originally two answers, multiply upvoted and even originally accepted (both currently deleted), were buggy -- not doing the <code>-1</code> before the division, and dividing by 4 instead of 3.  Since <code>.month</code> goes 1 to 12, it's easy to check for yourself what formula is right:</p>
<pre class="lang-py prettyprint-override"><code>for m in range(1, 13):
  print m//4 + 1,
print
</code></pre>
<p>gives <code>1 1 1 2 2 2 2 3 3 3 3 4</code> -- two four-month quarters and a single-month one (eep).</p>
<pre class="lang-py prettyprint-override"><code>for m in range(1, 13):
  print (m-1)//3 + 1,
print
</code></pre>
<p>gives <code>1 1 1 2 2 2 3 3 3 4 4 4</code> -- now doesn't this look vastly preferable to you?-)</p>
<p>This proves that the question is well warranted, I think;-).</p>
<p>I don't think the datetime module should necessarily have every possible useful calendric function, but I do know I maintain a (well-tested;-) <code>datetools</code> module for the use of my (and others') projects at work, which has many little functions to perform all of these calendric computations -- some are complex, some simple, but there's no reason to do the work over and over (even simple work) or risk bugs in such computations;-).</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>IF</strong> you are already using <code>pandas</code>, it's quite simple.</p>
<pre><code>import datetime as dt
import pandas as pd

quarter = pd.Timestamp(dt.date(2016, 2, 29)).quarter
assert quarter == 1
</code></pre>
<p>If you have a <code>date</code> column in a dataframe, you can easily create a new <code>quarter</code> column:</p>
<pre><code>df['quarter'] = df['date'].dt.quarter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest another arguably cleaner solution. If X is a <code>datetime.datetime.now()</code> instance, then the quarter is:</p>
<pre><code>import math
Q=math.ceil(X.month/3.)
</code></pre>
<p>ceil has to be imported from math module as it can't be accessed directly. </p>
</div>
<div class="post-text" itemprop="text">
<p>For anyone trying to get the quarter of the <em>fiscal</em> year, which may differ from the <em>calendar</em> year, I wrote a Python module to do just this.</p>
<p>Installation is simple. Just run:</p>
<pre><code>$ pip install fiscalyear
</code></pre>
<p>There are no dependencies, and <code>fiscalyear</code> should work for both Python 2 and 3.</p>
<p>It's basically a wrapper around the built-in <a href="https://docs.python.org/3/library/datetime.html" rel="noreferrer">datetime</a> module, so any <code>datetime</code> commands you are already familiar with will work. Here's a demo:</p>
<pre><code>&gt;&gt;&gt; from fiscalyear import *
&gt;&gt;&gt; a = FiscalDate.today()
&gt;&gt;&gt; a
FiscalDate(2017, 5, 6)
&gt;&gt;&gt; a.fiscal_year
2017
&gt;&gt;&gt; a.quarter
3
&gt;&gt;&gt; b = FiscalYear(2017)
&gt;&gt;&gt; b.start
FiscalDateTime(2016, 10, 1, 0, 0)
&gt;&gt;&gt; b.end
FiscalDateTime(2017, 9, 30, 23, 59, 59)
&gt;&gt;&gt; b.q3
FiscalQuarter(2017, 3)
&gt;&gt;&gt; b.q3.start
FiscalDateTime(2017, 4, 1, 0, 0)
&gt;&gt;&gt; b.q3.end
FiscalDateTime(2017, 6, 30, 23, 59, 59)
</code></pre>
<p><code>fiscalyear</code> is hosted on <a href="https://github.com/adamjstewart/fiscalyear" rel="noreferrer">GitHub</a> and <a href="https://pypi.python.org/pypi/fiscalyear/" rel="noreferrer">PyPI</a>. Documentation can be found at <a href="https://fiscalyear.readthedocs.io/en/latest/" rel="noreferrer">Read the Docs</a>. If you're looking for any features that it doesn't currently have, let me know!</p>
</div>
<div class="post-text" itemprop="text">
<p>if <code>m</code> is the month number...</p>
<pre><code>import math
math.ceil(float(m) / 3)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is an old question but still worthy of discussion.</p>
<p>Here is my solution, using the excellent <a href="http://labix.org/python-dateutil" rel="nofollow">dateutil</a> module.</p>
<pre><code>  from dateutil import rrule,relativedelta

   year = this_date.year
   quarters = rrule.rrule(rrule.MONTHLY,
                      bymonth=(1,4,7,10),
                      bysetpos=-1,
                      dtstart=datetime.datetime(year,1,1),
                      count=8)

   first_day = quarters.before(this_date)
   last_day =  (quarters.after(this_date)
                -relativedelta.relativedelta(days=1)
</code></pre>
<p>So <code>first_day</code> is the first day of the quarter, and <code>last_day</code> is the last day of the quarter (calculated by finding the first day of the next quarter, minus one day).</p>
</div>
<div class="post-text" itemprop="text">
<p>For those, who are looking for financial year quarter data,
using pandas,</p>
<pre><code>import datetime
today_date = datetime.date.today()
quarter = pd.PeriodIndex(today_date, freq='Q-MAR').strftime('Q%q')
</code></pre>
<p>reference: 
<a href="https://stackoverflow.com/questions/37632766/python-pandas-get-fiscal-quarter-from-fiscal-year-and-month-for-uk">pandas period index</a></p>
</div>
<div class="post-text" itemprop="text">
<p>hmmm so calculations can go wrong, here is a better version (just for the sake of it)</p>
<pre><code>first, second, third, fourth=1,2,3,4# you can make strings if you wish :)

quarterMap = {}
quarterMap.update(dict(zip((1,2,3),(first,)*3)))
quarterMap.update(dict(zip((4,5,6),(second,)*3)))
quarterMap.update(dict(zip((7,8,9),(third,)*3)))
quarterMap.update(dict(zip((10,11,12),(fourth,)*3)))

print quarterMap[6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a verbose, but also readable solution that will work for datetime and date instances</p>
<pre><code>def get_quarter(date):
    for months, quarter in [
        ([1, 2, 3], 1),
        ([4, 5, 6], 2),
        ([7, 8, 9], 3),
        ([10, 11, 12], 4)
    ]:
        if date.month in months:
            return quarter
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This method works for any mapping:</p>
<pre><code>month2quarter = {
        1:1,2:1,3:1,
        4:2,5:2,6:2,
        7:3,8:3,9:3,
        10:4,11:4,12:4,
    }.get
</code></pre>
<p>We have just generated a function <code>int-&gt;int</code></p>
<pre><code>month2quarter(9) # returns 3
</code></pre>
<p>This method is also fool-proof</p>
<pre><code>month2quarter(-1) # returns None
month2quarter('July') # returns None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example of a function that gets a datetime.datetime object and returns a unique string for each quarter:</p>
<pre><code>from datetime import datetime, timedelta

def get_quarter(d):
    return "Q%d_%d" % (math.ceil(d.month/3), d.year)

d = datetime.now()
print(d.strftime("%Y-%m-%d"), get_q(d))

d2 = d - timedelta(90)
print(d2.strftime("%Y-%m-%d"), get_q(d2))

d3 = d - timedelta(180 + 365)
print(d3.strftime("%Y-%m-%d"), get_q(d3))
</code></pre>
<p>And the output is:</p>
<pre><code>2019-02-14 Q1_2019
2018-11-16 Q4_2018
2017-08-18 Q3_2017
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>using dictionaries, you can pull this off by </p>
<pre><code>def get_quarter(month):
    quarter_dictionary = {
        "Q1" : [1,2,3],
        "Q2" : [4,5,6],
        "Q3" : [7,8,9],
        "Q4" : [10,11,12]
    }

    for key,values in quarter_dictionary.items():
        for value in values:
            if value == month:
                return key

print(get_quarter(3))
</code></pre>
</div>
<span class="comment-copy">Question VERY warranted even though the early answers seem a tad dismissive ("just a matter of", "seems pretty simple"): two of the answers (including an UPVOTED one!) are horribly buggy, showing it's NOT all that simple or "just"...</span>
<span class="comment-copy">I'm sure he'll come back and fix this</span>
<span class="comment-copy">This question very helpful in 2018 :D</span>
<span class="comment-copy">Thanks Alex. This is why there should be a function. Look how many people got it wrong.</span>
<span class="comment-copy">I think you proved your point. It's unnecessary to pollute the entire page with repeated comments.</span>
<span class="comment-copy">@Jason, yes, exactly -- that's why I upvoted your question once I saw the other buggy answers (currently deleted), even though somebody else seem to have downvoted to counted my upvote, ah well.</span>
<span class="comment-copy">@JG, what "repeated comments"? As the buggy answers were deleted, the comments went away with them, so I brought their contents into the answer -- it's important to be aware of how easy it is to be distracted or hurried and get an avoidable bug even in a simple computation, and it has consequences (in terms of making and solidly testing reusable functions) for programming best-practices; this case is a good example (which I think proves the question was warranted).</span>
<span class="comment-copy">Can also use: <code>(m+2)//3</code> instead of <code>(m-1)//3 + 1</code></span>
<span class="comment-copy">The best one so far. Thanks a ton!</span>
<span class="comment-copy">Probably should wrap this in an int()</span>
<span class="comment-copy">Like @garbanzio answer suggests. I needed to put the month argument through the float function to get this to work <code>math.ceil(float(4)/3) = 2.0</code> while <code>math.ceil(4/3) = 1.0</code></span>
<span class="comment-copy">Ignore me I didn't realise what the <code>.</code> after the 3 did. <code>math.ceil(4/3.) = 2.0</code></span>
<span class="comment-copy">calculations can only go wrong if the math is wrong.</span>
<span class="comment-copy">@RussBradberry in this case may be you right, but sometimes readability and being explicit counts and leads to less errors, instead of a terse calculation</span>
<span class="comment-copy">@RussBradberry also see deleted answers and comments on that, see a simple calculation can be tricky for good programmers too and it is difficult to see correctness except by testing it, in my solution you can see and be sure that it will work</span>
<span class="comment-copy">just as you said <code>"it is difficult to see correctness except by testing it"</code>. You should be writing tests, as all good developers should.  Tests are what help to keep you from making mistakes, and catch the ones you do. A developer should never sacrifice performance and readability, to prevent themselves from making a mistake. Also, this is less readable than if you would just made a static dict using literals.</span>
<span class="comment-copy">don't get me wrong <code>(m-1)//3 + 1</code> is not all that readable either, not many people know what <code>//</code> does.  My original comment was just on the statement of <code>"calculations can go wrong"</code> which just sounds odd to me.</span>
