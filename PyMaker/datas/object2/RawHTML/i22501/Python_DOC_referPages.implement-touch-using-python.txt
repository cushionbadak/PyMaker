<div class="post-text" itemprop="text">
<p><code>touch</code> is a Unix utility that sets the modification and access times of files to the current time of day.  If the file doesn't exist, it is created with default permissions.</p>
<p>How would you implement it as a Python function? Try to be cross platform and complete.</p>
<p>(Current Google results for "python touch file" are not that great, but point to <a href="http://docs.python.org/library/os.html#os.utime" rel="noreferrer">os.utime</a>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Looks like this is new as of Python 3.4 - <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch" rel="noreferrer"><code>pathlib</code></a>.</p>
<pre><code>from pathlib import Path

Path('path/to/file.txt').touch()
</code></pre>
<p>This will create a <code>file.txt</code> at the path.</p>
<p>--</p>
<blockquote>
<p>Path.touch(mode=0o777, exist_ok=True)</p>
<p>Create a file at this given path. If mode is given, it is combined with the processâ€™ umask value to determine the file mode and access flags. If the file already exists, the function succeeds if exist_ok is true (and its modification time is updated to the current time), otherwise FileExistsError is raised.  </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This tries to be a little more race-free than the other solutions.  (The <code>with</code> keyword is new in Python 2.5.)</p>
<pre><code>import os
def touch(fname, times=None):
    with open(fname, 'a'):
        os.utime(fname, times)
</code></pre>
<p>Roughly equivalent to this.</p>
<pre><code>import os
def touch(fname, times=None):
    fhandle = open(fname, 'a')
    try:
        os.utime(fname, times)
    finally:
        fhandle.close()
</code></pre>
<p>Now, to really make it race-free, you need to use <a href="http://www.kernel.org/doc/man-pages/online/pages/man3/lutimes.3.html" rel="noreferrer"><code>futimes</code></a> and change the timestamp of the open filehandle, instead of opening the file and then changing the timestamp on the filename (which may have been renamed).  Unfortunately, Python doesn't seem to provide a way to call <code>futimes</code> without going through <code>ctypes</code> or similar...</p>
<hr/>
<p><strong>EDIT</strong></p>
<p>As noted by <a href="https://stackoverflow.com/users/34910/nate-parsons">Nate Parsons</a>, Python 3.3 will <a href="http://bugs.python.org/issue10812" rel="noreferrer">add</a> <a href="http://docs.python.org/dev/library/os.html#path-fd" rel="noreferrer">specifying a file descriptor</a> (when <a href="http://docs.python.org/dev/library/os.html#os.supports_fd" rel="noreferrer"><code>os.supports_fd</code></a>) to functions such as <a href="http://docs.python.org/dev/library/os.html#os.utime" rel="noreferrer"><code>os.utime</code></a>, which will use the <code>futimes</code> syscall instead of the <code>utimes</code> syscall under the hood.  In other words:</p>
<pre><code>import os
def touch(fname, mode=0o666, dir_fd=None, **kwargs):
    flags = os.O_CREAT | os.O_APPEND
    with os.fdopen(os.open(fname, flags=flags, mode=mode, dir_fd=dir_fd)) as f:
        os.utime(f.fileno() if os.utime in os.supports_fd else fname,
            dir_fd=None if os.supports_fd else dir_fd, **kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def touch(fname):
    if os.path.exists(fname):
        os.utime(fname, None)
    else:
        open(fname, 'a').close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not try this?:</p>
<pre><code>import os

def touch(fname):
    try:
        os.utime(fname, None)
    except OSError:
        open(fname, 'a').close()
</code></pre>
<p>I believe this eliminates any race condition that matters.  If the file does not exist then an exception will be thrown.</p>
<p>The only possible race condition here is if the file is created before open() is called but after os.utime().  But this does not matter because in this case the modification time will be as expected since it must have happened during the call to touch().</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's some code that uses ctypes (only tested on Linux):</p>
<pre><code>from ctypes import *
libc = CDLL("libc.so.6")

#  struct timespec {
#             time_t tv_sec;        /* seconds */
#             long   tv_nsec;       /* nanoseconds */
#         };
# int futimens(int fd, const struct timespec times[2]);

class c_timespec(Structure):
    _fields_ = [('tv_sec', c_long), ('tv_nsec', c_long)]

class c_utimbuf(Structure):
    _fields_ = [('atime', c_timespec), ('mtime', c_timespec)]

utimens = CFUNCTYPE(c_int, c_char_p, POINTER(c_utimbuf))
futimens = CFUNCTYPE(c_int, c_char_p, POINTER(c_utimbuf)) 

# from /usr/include/i386-linux-gnu/bits/stat.h
UTIME_NOW  = ((1l &lt;&lt; 30) - 1l)
UTIME_OMIT = ((1l &lt;&lt; 30) - 2l)
now  = c_timespec(0,UTIME_NOW)
omit = c_timespec(0,UTIME_OMIT)

# wrappers
def update_atime(fileno):
        assert(isinstance(fileno, int))
        libc.futimens(fileno, byref(c_utimbuf(now, omit)))
def update_mtime(fileno):
        assert(isinstance(fileno, int))
        libc.futimens(fileno, byref(c_utimbuf(omit, now)))

# usage example:
#
# f = open("/tmp/test")
# update_mtime(f.fileno())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><sup>This answer is compatible with all versions since Python-2.5 when keyword <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code></a> has been released.</sup></p>
<p><strong>1. Create file if does not exist + Set current time</strong><br/>
(exactly same as command <code>touch</code>)</p>
<pre><code>import os

fname = 'directory/filename.txt'
with open(fname, 'a'):     # Create file if does not exist
    os.utime(fname, None)  # Set access/modified times to now
                           # May raise OSError if file does not exist
</code></pre>
<p>A more robust version:</p>
<pre><code>import os

with open(fname, 'a'):
  try:                     # Whatever if file was already existing
    os.utime(fname, None)  # =&gt; Set current time anyway
  except OSError:
    pass  # File deleted between open() and os.utime() calls
</code></pre>
<p><strong>2. Just create the file if does not exist</strong><br/>
(does not update time) </p>
<pre><code>with open(fname, 'a'):  # Create file if does not exist
    pass
</code></pre>
<p><strong>3. Just update file access/modified times</strong><br/>
(does not create file if not existing)</p>
<pre><code>import os

try:
    os.utime(fname, None)  # Set access/modified times to now
except OSError:
    pass  # File does not exist (or no permission)
</code></pre>
<p>Using <code>os.path.exists()</code> does not simplify the code:</p>
<pre><code>from __future__ import (absolute_import, division, print_function)
import os

if os.path.exists(fname):
  try:
    os.utime(fname, None)  # Set access/modified times to now
  except OSError:
    pass  # File deleted between exists() and utime() calls
          # (or no permission)
</code></pre>
<p><strong>Bonus:</strong> Update time of all files in a directory</p>
<pre><code>from __future__ import (absolute_import, division, print_function)
import os

number_of_files = 0

#   Current directory which is "walked through"
#   |     Directories in root
#   |     |  Files in root       Working directory
#   |     |  |                     |
for root, _, filenames in os.walk('.'):
  for fname in filenames:
    pathname = os.path.join(root, fname)
    try:
      os.utime(pathname, None)  # Set access/modified times to now
      number_of_files += 1
    except OSError as why:
      print('Cannot change time of %r because %r', pathname, why)

print('Changed time of %i files', number_of_files)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simplistic:</p>
<pre><code>def touch(fname):
    open(fname, 'a').close()
    os.utime(fname, None)
</code></pre>
<ul>
<li>The <code>open</code> ensures there is a file there</li>
<li>the <code>utime</code> ensures that the timestamps are updated</li>
</ul>
<p>Theoretically, it's possible someone will delete the file after the <code>open</code>, causing utime to raise an exception. But arguably that's OK, since something bad did happen.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>with open(file_name,'a') as f: 
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Complex (possibly buggy):</p>
<pre><code>def utime(fname, atime=None, mtime=None)
    if type(atime) is tuple:
        atime, mtime = atime

    if atime is None or mtime is None:
        statinfo = os.stat(fname)
        if atime is None:
            atime = statinfo.st_atime
        if mtime is None:
            mtime = statinfo.st_mtime

    os.utime(fname, (atime, mtime))


def touch(fname, atime=None, mtime=None):
    if type(atime) is tuple:
        atime, mtime = atime

    open(fname, 'a').close()
    utime(fname, atime, mtime)
</code></pre>
<p>This tries to also allow setting the access or modification time, like GNU touch.</p>
</div>
<div class="post-text" itemprop="text">
<p>It might seem logical to create a string with the desired variables, and pass it to os.system:</p>
<pre><code>touch = 'touch ' + dir + '/' + fileName
os.system(touch)
</code></pre>
<p>This is inadequate in a number of ways (e.g.,it doesn't handle whitespace), so don't do it.  </p>
<p>A more robust method is to use subprocess :</p>
<p><code>subprocess.call(['touch', os.path.join(dirname, fileName)])</code></p>
<p>While this is much better than using a subshell (with os.system), it is still only suitable for quick-and-dirty scripts; use the accepted answer for cross-platform programs.</p>
</div>
<div class="post-text" itemprop="text">
<p>"open(file_name, 'a').close()"  did not work for me in Python 2.7 on Windows.  "os.utime(file_name, None)" worked just fine.</p>
<p>Also, I had a need to recursively touch all files in a directory with a date older than some date.  I created hte following based on ephemient's very helpful response.  </p>
<pre><code>def touch(file_name):
    # Update the modified timestamp of a file to now.
    if not os.path.exists(file_name):
        return
    try:
        os.utime(file_name, None)
    except Exception:
        open(file_name, 'a').close()

def midas_touch(root_path, older_than=dt.now(), pattern='**', recursive=False):
    '''
    midas_touch updates the modified timestamp of a file or files in a 
                directory (folder)

    Arguements:
        root_path (str): file name or folder name of file-like object to touch
        older_than (datetime): only touch files with datetime older than this 
                   datetime
        pattern (str): filter files with this pattern (ignored if root_path is
                a single file)
        recursive (boolean): search sub-diretories (ignored if root_path is a 
                  single file)
    '''
    # if root_path NOT exist, exit
    if not os.path.exists(root_path):
        return
    # if root_path DOES exist, continue.
    else:
        # if root_path is a directory, touch all files in root_path
        if os.path.isdir(root_path):
            # get a directory list (list of files in directory)
            dir_list=find_files(root_path, pattern='**', recursive=False)
            # loop through list of files
            for f in dir_list:
                # if the file modified date is older thatn older_than, touch the file
                if dt.fromtimestamp(os.path.getmtime(f)) &lt; older_than:
                    touch(f)
                    print "Touched ", f
        # if root_path is a file, touch the file
        else:
            # if the file modified date is older thatn older_than, touch the file
            if dt.fromtimestamp(os.path.getmtime(f)) &lt; older_than:
                touch(root_path)
</code></pre>
</div>
<span class="comment-copy">Please consider updating the accepted answer now that this functionality is built into the Python stdlib.</span>
<span class="comment-copy">@Miles The accepted answer does exactly what the question asked for - it actually implemented the function in Python instead of using a library.</span>
<span class="comment-copy">@styrofoamfly The standard library <b>is</b> part of Python. It's really likely that the what the question asker really wants to know (and most people arriving at this question via Google) is how to achieve <code>touch</code>-like functionality in their Python programs, not how to re-implement it from scratch; those people are best served by scrolling down to the <code>pathlib</code> solution. Even though it's now built-in, this answer has a much better Google ranking for "python touch file" than <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch" rel="nofollow noreferrer">the relevant documentation</a>.</span>
<span class="comment-copy">@miles Python 2 is (unfortunately) still more widely used than 3, so I think the accepted answer is still the more relevant one. But your comment does a good job of pointing people to the second answer.</span>
<span class="comment-copy">Python 2 is EOL at the end of this year.</span>
<span class="comment-copy">On Python2.7: <code>pip install pathlib</code></span>
<span class="comment-copy">note to self: use <code>Path('/some/path').mkdir()</code> if the directory containing the file to be <code>touch()</code>ed does not yet exist.</span>
<span class="comment-copy">I think we should use <code>pathlib2</code> instead of <code>pathlib</code> because <code>pathlib</code> is bugfix-only now. Therefore, on Python 2.7: <code>pip install pathlib2</code> and then <code>from pathlib2 import Path</code>.</span>
<span class="comment-copy">This is the real solution--and this is how touch(1) in coreutils does it, unless futimes() isn't available.  futimes isn't a portable function and doesn't even exist on older 2.6 Linux kernels, so you need to deal with ENOSYS and fall back to utime even if you do use it.</span>
<span class="comment-copy">(Proofreading error above: "This" = open("a") + futimes.)  Fortunately, it's hard to think of a case where the race condition of not using futimes actually matters.  The "wrong" case you might end up with is the file being renamed between open() and utime(), in which case you'll neither create a new file nor touch the old one.  That can matter, but most of the time it won't.</span>
<span class="comment-copy">cygwin touch can do its magic on read-only files, but this code cannot.  However it seems to work if I surround it with try: &lt;code&gt; except IOError as e: (check e.errno) os.utime(filename, times)</span>
<span class="comment-copy">FYI, it seems like futimes was added in 3.3</span>
<span class="comment-copy">Note: the built-in <code>file</code> function was removed from Python 3, and <code>open</code> has to be used instead. I totally missed this because the syntax highlighting of the editor I am using (gedit) is still targeting Python 2.</span>
<span class="comment-copy">There's a potential race condition in this solution: If the file doesn't exist, and is created by another process before this function reaches the <code>open()</code> call, then the contents of the file will be truncated. Suggest using mode <code>'a'</code> instead.</span>
<span class="comment-copy">Agreed. Proper solution is just:  def touch(fname):     open(fname, 'wa').close()</span>
<span class="comment-copy">@Greg, while it solves the potential racing condition issue, <code>open(fname, 'a').close()</code> won't change atime.</span>
<span class="comment-copy">@SilentGhost: That's true, but that's okay because if the file exists then it was <i>just</i> created. Of course you'd leave the call to <code>os.utime()</code> in there for pre-existing files.</span>
<span class="comment-copy">Why not just open to make sure it exists, then call utime?</span>
<span class="comment-copy"><b>Fail</b>: <code>with open(fn,'a'): pass</code> or alternative <code>open(fn, 'a').close()</code> do not change the modified time using Python 2.7.5 on Red Hat 7 (filesystem is XFS). On my platform, these solutions just create an empty file if does not exist. :-/</span>
<span class="comment-copy">This isn't very safe: what happens when there is a space in the filename?</span>
<span class="comment-copy"><code>subprocess.call(['touch', os.path.join(dirname, fileName)])</code> is much better than using a subshell (with <code>os.system</code>). But still, use this only for quick-and-dirty scripts, use the accepted answer for cross-platform programs.</span>
<span class="comment-copy"><code>touch</code> is not a cross-platform available command (e.g. Windows)</span>
