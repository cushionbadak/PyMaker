<div class="post-text" itemprop="text">
<p>I'm trying to write a simple unit test that will verify that, under a certain condition, a class in my application will log an error via the standard logging API.  I can't work out what the cleanest way to test this situation is.</p>
<p>I know that nose already captures logging output through it's logging plugin, but this seems to be intended as a reporting and debugging aid for failed tests.  </p>
<p>The two ways to do this I can see are:</p>
<ul>
<li>Mock out the logging module, either in a piecemeal way (mymodule.logging = mockloggingmodule) or with a proper mocking library.</li>
<li>Write or use an existing nose plugin to capture the output and verify it.</li>
</ul>
<p>If I go for the former approach, I'd like to know what the cleanest way to reset the global state to what it was before I mocked out the logging module.</p>
<p>Looking forward to your hints and tips on this one...</p>
</div>
<div class="post-text" itemprop="text">
<p>I used to mock loggers, but in this situation I found best to use logging handlers, so I wrote this one based on <a href="http://www.fubar.si/2009/3/4/mocking-logging-python-module-for-unittests" rel="noreferrer">the document suggested by jkp</a>:</p>
<pre><code>class MockLoggingHandler(logging.Handler):
    """Mock logging handler to check for expected logs."""

    def __init__(self, *args, **kwargs):
        self.reset()
        logging.Handler.__init__(self, *args, **kwargs)

    def emit(self, record):
        self.messages[record.levelname.lower()].append(record.getMessage())

    def reset(self):
        self.messages = {
            'debug': [],
            'info': [],
            'warning': [],
            'error': [],
            'critical': [],
        }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From python 3.4 on, the standard <em>unittest</em> library offers a new test assertion context manager, <code>assertLogs</code>. From the <a href="https://docs.python.org/3.4/library/unittest.html#unittest.TestCase.assertLogs">docs</a>:</p>
<pre><code>with self.assertLogs('foo', level='INFO') as cm:
    logging.getLogger('foo').info('first message')
    logging.getLogger('foo.bar').error('second message')
    self.assertEqual(cm.output, ['INFO:foo:first message',
                                 'ERROR:foo.bar:second message'])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Fortunately this is not something that you have to write yourself; the <code>testfixtures</code> package provides a context manager that captures all logging output that occurs in the body of the <code>with</code> statement. You can find the package here:</p>
<p><a href="http://pypi.python.org/pypi/testfixtures">http://pypi.python.org/pypi/testfixtures</a></p>
<p>And here are its docs about how to test logging:</p>
<p><a href="http://testfixtures.readthedocs.org/en/latest/logging.html">http://testfixtures.readthedocs.org/en/latest/logging.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>UPDATE</strong>: No longer any need for the answer below. Use the <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs" rel="noreferrer">built-in Python way</a> instead!</p>
<p>This answer extends the work done in <a href="https://stackoverflow.com/a/1049375/1286628">https://stackoverflow.com/a/1049375/1286628</a>. The handler is largely the same (the constructor is more idiomatic, using <code>super</code>). Further, I add a demonstration of how to use the handler with the standard library's <code>unittest</code>.</p>
<pre><code>class MockLoggingHandler(logging.Handler):
    """Mock logging handler to check for expected logs.

    Messages are available from an instance's ``messages`` dict, in order, indexed by
    a lowercase log level string (e.g., 'debug', 'info', etc.).
    """

    def __init__(self, *args, **kwargs):
        self.messages = {'debug': [], 'info': [], 'warning': [], 'error': [],
                         'critical': []}
        super(MockLoggingHandler, self).__init__(*args, **kwargs)

    def emit(self, record):
        "Store a message from ``record`` in the instance's ``messages`` dict."
        try:
            self.messages[record.levelname.lower()].append(record.getMessage())
        except Exception:
            self.handleError(record)

    def reset(self):
        self.acquire()
        try:
            for message_list in self.messages.values():
                message_list.clear()
        finally:
            self.release()
</code></pre>
<p>Then you can use the handler in a standard-library <code>unittest.TestCase</code> like so:</p>
<pre><code>import unittest
import logging
import foo

class TestFoo(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        super(TestFoo, cls).setUpClass()
        # Assuming you follow Python's logging module's documentation's
        # recommendation about naming your module's logs after the module's
        # __name__,the following getLogger call should fetch the same logger
        # you use in the foo module
        foo_log = logging.getLogger(foo.__name__)
        cls._foo_log_handler = MockLoggingHandler(level='DEBUG')
        foo_log.addHandler(cls._foo_log_handler)
        cls.foo_log_messages = cls._foo_log_handler.messages

    def setUp(self):
        super(TestFoo, self).setUp()
        self._foo_log_handler.reset() # So each test is independent

    def test_foo_objects_fromble_nicely(self):
        # Do a bunch of frombling with foo objects
        # Now check that they've logged 5 frombling messages at the INFO level
        self.assertEqual(len(self.foo_log_messages['info']), 5)
        for info_message in self.foo_log_messages['info']:
            self.assertIn('fromble', info_message)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Brandon's answer:</p>
<pre><code>pip install testfixtures
</code></pre>
<p>snippet:</p>
<pre><code>import logging
from testfixtures import LogCapture
logger = logging.getLogger('')


with LogCapture() as logs:
    # my awesome code
    logger.error('My code logged an error')
assert 'My code logged an error' in str(logs)
</code></pre>
<p>Note: the above does not conflict with calling <strong>nosetests</strong> and getting the output of logCapture plugin of the tool</p>
</div>
<div class="post-text" itemprop="text">
<p>As a follow up to Reef's answer, I took a liberty of coding up an example using <a href="http://code.google.com/p/pymox/" rel="nofollow noreferrer">pymox</a>.
It introduces some extra helper functions that make it easier to stub functions and methods.</p>
<pre><code>import logging

# Code under test:

class Server(object):
    def __init__(self):
        self._payload_count = 0
    def do_costly_work(self, payload):
        # resource intensive logic elided...
        pass
    def process(self, payload):
        self.do_costly_work(payload)
        self._payload_count += 1
        logging.info("processed payload: %s", payload)
        logging.debug("payloads served: %d", self._payload_count)

# Here are some helper functions
# that are useful if you do a lot
# of pymox-y work.

import mox
import inspect
import contextlib
import unittest

def stub_all(self, *targets):
    for target in targets:
        if inspect.isfunction(target):
            module = inspect.getmodule(target)
            self.StubOutWithMock(module, target.__name__)
        elif inspect.ismethod(target):
            self.StubOutWithMock(target.im_self or target.im_class, target.__name__)
        else:
            raise NotImplementedError("I don't know how to stub %s" % repr(target))
# Monkey-patch Mox class with our helper 'StubAll' method.
# Yucky pymox naming convention observed.
setattr(mox.Mox, 'StubAll', stub_all)

@contextlib.contextmanager
def mocking():
    mocks = mox.Mox()
    try:
        yield mocks
    finally:
        mocks.UnsetStubs() # Important!
    mocks.VerifyAll()

# The test case example:

class ServerTests(unittest.TestCase):
    def test_logging(self):
        s = Server()
        with mocking() as m:
            m.StubAll(s.do_costly_work, logging.info, logging.debug)
            # expectations
            s.do_costly_work(mox.IgnoreArg()) # don't care, we test logging here.
            logging.info("processed payload: %s", 'hello')
            logging.debug("payloads served: %d", 1)
            # verified execution
            m.ReplayAll()
            s.process('hello')

if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use mocking, as someday You might want to change Your logger to a, say, database one. You won't be happy if it'll try to connect to the database during nosetests.</p>
<p>Mocking will continue to work even if standard output will be suppressed.</p>
<p>I have used <a href="http://code.google.com/p/pymox/wiki/MoxDocumentation" rel="nofollow noreferrer">pyMox</a>'s stubs. Remember to unset the stubs after the test.</p>
</div>
<div class="post-text" itemprop="text">
<p>Found <a href="http://www.fubar.si/2009/3/4/mocking-logging-python-module-for-unittests" rel="nofollow noreferrer">one answer</a> since I posted this.  Not bad.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>ExpectLog</code> class implemented in tornado is a great utility:</p>
<pre><code>with ExpectLog('channel', 'message regex'):
    do_it()
</code></pre>
<p><a href="http://tornado.readthedocs.org/en/latest/_modules/tornado/testing.html#ExpectLog" rel="nofollow">http://tornado.readthedocs.org/en/latest/_modules/tornado/testing.html#ExpectLog</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Keying off @Reef's answer, I did tried the code below. It works well for me both for Python 2.7 (if you install <a href="https://pypi.python.org/pypi/mock" rel="nofollow">mock</a>) and for Python 3.4.</p>
<pre><code>"""
Demo using a mock to test logging output.
"""

import logging
try:
    import unittest
except ImportError:
    import unittest2 as unittest

try:
    # Python &gt;= 3.3
    from unittest.mock import Mock, patch
except ImportError:
    from mock import Mock, patch

logging.basicConfig()
LOG=logging.getLogger("(logger under test)")

class TestLoggingOutput(unittest.TestCase):
    """ Demo using Mock to test logging INPUT. That is, it tests what
    parameters were used to invoke the logging method, while still
    allowing actual logger to execute normally.

    """
    def test_logger_log(self):
        """Check for Logger.log call."""
        original_logger = LOG
        patched_log = patch('__main__.LOG.log',
                            side_effect=original_logger.log).start()

        log_msg = 'My log msg.'
        level = logging.ERROR
        LOG.log(level, log_msg)

        # call_args is a tuple of positional and kwargs of the last call
        # to the mocked function.
        # Also consider using call_args_list
        # See: https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.call_args
        expected = (level, log_msg)
        self.assertEqual(expected, patched_log.call_args[0])


if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<span class="comment-copy">There is now a built in way to do this: <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">The above link is dead, and I was wondering if someone could post on how to use this code. When I try to add this logging handler I keep getting the error when trying to use it as <code>AttributeError: class MockLoggingHandler has no attribute 'level'</code>.</span>
<span class="comment-copy">Answered here for others' reference: <a href="http://stackoverflow.com/a/20524288/576333">stackoverflow.com/a/20524288/576333</a></span>
<span class="comment-copy">I give a usage example below at <a href="http://stackoverflow.com/a/20553331/1286628">stackoverflow.com/a/20553331/1286628</a></span>
<span class="comment-copy">This solution not only looked more elegant as in fact worked for me while the others did not (my log comes from multiple threads).</span>
<span class="comment-copy">Thanks for explaining how to utilize Gustavo's answer and extending it.</span>
<span class="comment-copy">There is now a built in way to do this: <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">In setUpClass, the foo_log.addHandler() call has a missing underscore before the <code>foo_log_handler</code> variable</span>
<span class="comment-copy">This is still useful for python 2.x.</span>
<span class="comment-copy">Presumably any code written in Python 2 that is still in use has already been tested by now. If you’re in the test writing phase of a project, probably better just to switch to Python 3 now. Python 2 will lose support (including security updates) in a year and a half or so.</span>
<span class="comment-copy">I like your innovative use of a contextmanager decorator to implement "scoped mocking".  Nice.</span>
<span class="comment-copy">PS: it's a real shame about PyMOX's lack of pep8 conformance.</span>
<span class="comment-copy">+1 Some of the benefits of AOP. Rather than wrapping every backend in a generic-style class/object.</span>
<span class="comment-copy">Working link: <a href="http://www.domenkozar.com/2009/03/04/mocking-logging-module-for-unittests/" rel="nofollow noreferrer">domenkozar.com/2009/03/04/mocking-logging-module-for-unittests</a></span>
