<div class="post-text" itemprop="text">
<p>What are advantages of using <strong>UserDict</strong> class?</p>
<p>I mean, what I really get if instead of</p>
<pre><code>class MyClass(object):
    def __init__(self):
        self.a = 0
        self.b = 0
...
m = MyClass()
m.a = 5
m.b = 7
</code></pre>
<p>I will write the following:</p>
<pre><code>class MyClass(UserDict):
    def __init__(self):
        UserDict.__init__(self)
        self["a"] = 0
        self["b"] = 0
...
m = MyClass()
m["a"] = 5
m["b"] = 7
</code></pre>
<p><strong>Edit</strong>: If I understand right I can add new fields to an object in a runtime in both cases?</p>
<pre><code>m.c = "Cool"
</code></pre>
<p>and</p>
<pre><code>m["c"] = "Cool"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/userdict.html?#UserDict.UserDict" rel="noreferrer"><code>UserDict.UserDict</code></a> has no substantial added value since Python 2.2, since, as @gs mention, you can now subclass <code>dict</code> directly -- it exists only for backwards compatibility with Python 2.1 and earlier, when builtin types could not be subclasses. Still, it was kept in Python 3 (now in its proper place in the <code>collections</code> module) since, as <a href="http://docs.python.org/3.1/library/collections.html?#collections.UserDict" rel="noreferrer">the docs</a> now mention,</p>
<blockquote>
<p>The need for this class has been
  partially supplanted by the ability to
  subclass directly from dict; however,
  this class can be easier to work with
  because the underlying dictionary is
  accessible as an attribute.</p>
</blockquote>
<p><code>UserDict.DictMixin</code>, in Python 2, is quite handy -- as the docs say,</p>
<blockquote>
<p>The module defines a mixin, DictMixin,
  defining all dictionary methods for
  classes that already have a minimum
  mapping interface. This greatly
  simplifies writing classes that need
  to be substitutable for dictionaries
  (such as the shelve module).</p>
</blockquote>
<p>You subclass it, define some fundamental methods (at least <code>__getitem__</code>, which is sufficient for a read-only mapping without the ability to get keys or iterate; also <code>keys</code> if you need those abilities; possibly <code>__setitem__</code>, and you have a R/W mapping without the ability of removing items; add <code>__delitem__</code> for full capability, and possibly override other methods for reasons of performance), and get a full-fledged implementation of <code>dict</code>'s rich API (<code>update</code>, <code>get</code>, and so on). A great example of the <a href="http://en.wikipedia.org/wiki/Template_method_pattern" rel="noreferrer">Template Method</a> design pattern.</p>
<p>In Python 3, <code>DictMixin</code> is gone; you can get <em>almost</em> the same functionality by relying on <code>collections.MutableMapping</code> instead (or just <code>collections.Mapping</code> for R/O mappings). It's a bit more elegant, though not QUITE as handy (see <a href="http://bugs.python.org/issue5402" rel="noreferrer">this issue</a>, which was closed with "won't fix"; the short discussion is worth reading).</p>
</div>
<div class="post-text" itemprop="text">
<p>Subclassing the dict gives you all the features of a dict, like <code>if x in dict:</code>. You normally do this if you want to extend the features of the dict, creating an ordered dict for example.</p>
<p>BTW: In more recent Python versions you can subclass <code>dict</code> directly, you don't need <code>UserDict</code>.</p>
</div>
<span class="comment-copy">since '09 things moved a bit in python 3, and DictMixin is back: <a href="http://docs.python.org/library/userdict.html#UserDict.DictMixin" rel="nofollow noreferrer">docs.python.org/library/userdict.html#UserDict.DictMixin</a> - though MutableMapping is indeed suggest for most uses.</span>
<span class="comment-copy">Is this still valid?  Reading "Fluent Python", the author recommends subclassing UserDict because "major caveat: the code of the built-ins (written in C) does not call special (magic) methods overridden by user-defined classes".  This books covers 3.x but does this warning not apply to 2.7 as well?</span>
<span class="comment-copy">@Stefano: There is not now, and I'm pretty sure there has never been, any DictMixin in Python 3's standard library. The link you gave was at the time a link to the Python 2.7.2 documentation (currently a 404).</span>
<span class="comment-copy">@Kundor you seem to be right, though I am left wondering why would I have posted a py2 doc link at the time. There's <a href="https://docs.python.org/3/library/collections.html#collections.UserDict" rel="nofollow noreferrer">docs.python.org/3/library/collections.html#collections.UserDict</a> in py3, maybe I got confused. Thanks for pointing that out!</span>
