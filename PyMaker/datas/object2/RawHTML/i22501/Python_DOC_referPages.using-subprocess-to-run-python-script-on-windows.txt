<div class="post-text" itemprop="text">
<p>Is there a simple way to run a Python script on Windows/Linux/OS X?</p>
<p>On the latter two, <code>subprocess.Popen("/the/script.py")</code> works, but on Windows I get the following error:</p>
<pre><code>Traceback (most recent call last):
  File "test_functional.py", line 91, in test_functional
    log = tvnamerifiy(tmp)
  File "test_functional.py", line 49, in tvnamerifiy
    stdout = PIPE
  File "C:\Python26\lib\subprocess.py", line 595, in __init__
    errread, errwrite)
  File "C:\Python26\lib\subprocess.py", line 804, in _execute_child
    startupinfo)
WindowsError: [Error 193] %1 is not a valid Win32 application
</code></pre>
<hr/>
<blockquote>
<p><em><a href="https://stackoverflow.com/users/24718/monkut">monkut's</a> comment</em>: The use case isn't clear. Why use subprocess to run a python script? Is there something preventing you from importing the script and calling the necessary function?</p>
</blockquote>
<p>I was writing a quick script to test the overall functionality of a Python-command-line tool (to test it on various platforms). Basically it had to create a bunch of files in a temp folder, run the script on this and check the files were renamed correctly.</p>
<p>I could have imported the script and called the function, but since it relies on <code>sys.argv</code> and uses <code>sys.exit()</code>, I would have needed to do something like..</p>
<pre><code>import sys
import tvnamer
sys.argv.append("-b", "/the/folder")
try:
    tvnamer.main()
except BaseException, errormsg:
    print type(errormsg)
</code></pre>
<p>Also, I wanted to capture the stdout and stderr for debugging incase something went wrong.</p>
<p>Of course a better way would be to write the script in more unit-testable way, but the script is basically "done" and I'm doing a final batch of testing before doing a "1.0" release (after which I'm going to do a rewrite/restructure, which will be far tidier and more testable)</p>
<p>Basically, it was much easier to simply run the script as a process, after finding the <code>sys.executable</code> variable. I would have written it as a shell-script, but that wouldn't have been cross-platform. The final script can be found <a href="http://github.com/dbr/tvdb_api/blob/c8d7b356cd1a7bb2ab22b510ea74e03a7d27fad6/tests/test_functional.py" rel="nofollow noreferrer">here</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Just found <a href="https://docs.python.org/library/sys.html#sys.executable" rel="nofollow noreferrer"><code>sys.executable</code></a> - the full path to the current Python executable, which can be used to run the script (instead of relying on the shbang, which obviously doesn't work on Windows)</p>
<pre><code>import sys
import subprocess

theproc = subprocess.Popen([sys.executable, "myscript.py"])
theproc.communicate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>import sys
import subprocess

theproc = subprocess.Popen("myscript.py", shell = True)
theproc.communicate()                   # ^^^^^^^^^^^^
</code></pre>
<p>This tells <code>subprocess</code> to use the OS shell to open your script, and works on anything that you can just run in cmd.exe.</p>
<p>Additionally, this will search the PATH for "myscript.py" - which could be desirable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes <code>subprocess.Popen(cmd, ..., shell=True)</code> works like a charm.  On Windows the <code>.py</code> file extension is recognized, so Python is invoked to process it (on *NIX just the usual shebang).  The path environment controls whether things are seen.  So the first arg to <code>Popen</code> is <em>just the name of the script</em>.</p>
<pre><code>subprocess.Popen(['myscript.py', 'arg1', ...], ..., shell=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like windows tries to run the script using its own EXE framework rather than call it like </p>
<pre><code>python /the/script.py
</code></pre>
<p>Try,</p>
<pre><code>subprocess.Popen(["python", "/the/script.py"])
</code></pre>
<p>Edit: "python" would need to be on your path.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are using a pathname separator which is platform dependent. Windows uses "\" and Unix uses "/".</p>
</div>
<div class="post-text" itemprop="text">
<p>For example, to execute following with command prompt or BATCH file we can use this: </p>
<pre><code>C:\Python27\python.exe "C:\Program files(x86)\dev_appserver.py" --host 0.0.0.0 --post 8080 "C:\blabla\"
</code></pre>
<p>Same thing to do with Python, we can do this:</p>
<pre><code>subprocess.Popen(['C:/Python27/python.exe', 'C:\\Program files(x86)\\dev_appserver.py', '--host', '0.0.0.0', '--port', '8080', 'C:\\blabla'], shell=True)
</code></pre>
<p>or</p>
<pre><code>subprocess.Popen(['C:/Python27/python.exe', 'C:/Program files(x86)/dev_appserver.py', '--host', '0.0.0.0', '--port', '8080', 'C:/blabla'], shell=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you are running a python script on windows in subprocess you should use python in front of the script name.  Try:</p>
<pre><code>process = subprocess.Popen("python /the/script.py")
</code></pre>
</div>
<span class="comment-copy">The use case isn't clear.  Why use subprocess to run a python script?  Is there something preventing you from importing the script and calling the necessary function?</span>
<span class="comment-copy">Had the same problem when running nodejs modules from python. subprocess.call([r'..\nodejs\npm'], shell=True) solved the problem.</span>
<span class="comment-copy">you could use <code>subprocess.check_call([sys.executable, "myscript.py"])</code> instead.</span>
<span class="comment-copy">Or better yet, in Python 3.5+, use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run</code></a>: <code>subprocess.run([sys.executable, 'myscript.py'], check=True)</code></span>
<span class="comment-copy">I think that'll function the same, if I recall right shell=True just stops subprocess from escaping any special characters (so "mycmd &gt; somefile.txt" redirects text to somefile.txt, rather than trying to execute a file called "mycmd &gt; somefile.txt")</span>
<span class="comment-copy">Here's a situation in which the two are significantly different. Suppose "myscript.py" is in the system PATH, and not in the current directory. If you use "shell = True" the script will be found on the PATH, but if you use "sys.executable" it won't.</span>
<span class="comment-copy">Ahh I see what you mean (although the script I was trying to run was always going to be in the current directory)</span>
<span class="comment-copy">Fixed my error, by the way it works without shell = True on python3 and fails randonly on 2.7, don't know why.</span>
<span class="comment-copy"><code>shell=True # do not show the command prompt then true, if false show it</code></span>
<span class="comment-copy">The python.org Windows installer doesn't seem to put the "python" command in PATH, and I think it would have the .exe suffix (which would break the other platforms)</span>
<span class="comment-copy">ah, I guess the .exe would break things, yes..</span>
<span class="comment-copy">Hm, it seems you can exclude the .exe on Windows as long as it's in PATH, but you have to manually add Python to it</span>
<span class="comment-copy">So use "cmd /S /C" instead of "python" - it's always on the path and will run the script so long as the extension is registered.</span>
<span class="comment-copy">Good point, although in the actual script that caused the error I used os.path.join() (although I should have mentioned that)</span>
<span class="comment-copy">Of course the forward slash has been valid on Windows since prehistoric times and still is, so that's not a problem.</span>
<span class="comment-copy">@romkyns not really: subprocess.call([r'..\nodejs\npm'], shell=True) works, while subprocess.call(['../nodejs/npm'], shell=True) gives '..' is not recognized as internal or external command</span>
<span class="comment-copy">@Stefan, that would be the shell complaining and not the underlying Windows API.</span>
