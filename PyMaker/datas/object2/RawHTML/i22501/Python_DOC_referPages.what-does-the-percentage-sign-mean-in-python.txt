<div class="post-text" itemprop="text">
<p>In the tutorial there is an example for finding prime numbers:</p>
<pre><code>&gt;&gt;&gt; for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')
...
</code></pre>
<p>I understand that the double <code>==</code> is a test for equality, but I don't understand the <code>if n % x</code> part. Like I can verbally walk through each part and say what the statement does for the example. But I don't understand how the percentage sign falls in. </p>
<p>What does <code>if n % x</code> actually say?</p>
</div>
<div class="post-text" itemprop="text">
<p>Modulus operator; gives the remainder of the left value divided by the right value.  Like:</p>
<p><code>3 % 1</code> would equal zero (since 3 divides evenly by 1)</p>
<p><code>3 % 2</code> would equal 1 (since dividing 3 by 2 results in a remainder of 1).</p>
</div>
<div class="post-text" itemprop="text">
<p>The % does two things, depending on its arguments.  In this case, it acts as the modulo operator, meaning when its arguments are numbers, it divides the first by the second and returns the <em>remainder</em>.  <code>34 % 10 == 4</code> since 34 divided by 10 is three, with a remainder of four.  </p>
<p>If the first argument is a string, it formats it using the second argument.  This is a bit involved, so I will refer to the <a href="http://docs.python.org/3.3/library/stdtypes.html#printf-style-string-formatting" rel="noreferrer">documentation</a>, but just as an example: </p>
<pre><code>&gt;&gt;&gt; "foo %d bar" % 5
'foo 5 bar'
</code></pre>
<p>However, the string formatting behavior is supplemented as of <a href="http://docs.python.org/3.0/whatsnew/2.6.html#pep-3101-advanced-string-formatting" rel="noreferrer">Python 3.1</a> in favor of the <em>string</em><code>.format()</code> mechanism:</p>
<blockquote>
<p>The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer <a href="http://docs.python.org/3.3/library/string.html#format-string-syntax" rel="noreferrer"><code>str.format()</code></a> interface helps avoid these errors, and also provides a generally more powerful, flexible and extensible approach to formatting text.</p>
</blockquote>
<p>And thankfully, almost all of the new features are also available from python 2.6 onwards.</p>
</div>
<div class="post-text" itemprop="text">
<p>While this is slightly off-topic, since people will find this by searching for "percentage sign in Python" (as I did), I wanted to note that the % sign is also used to prefix a "magic" function in iPython: <a href="https://ipython.org/ipython-doc/3/interactive/tutorial.html#magic-functions" rel="noreferrer">https://ipython.org/ipython-doc/3/interactive/tutorial.html#magic-functions</a></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>What does the percentage sign mean?</p>
</blockquote>
<p>It's an operator in Python that can mean several things depending on the context. A lot of what follows was already mentioned (or hinted at) in the other answers but I thought it could be helpful to provide a more extensive summary.</p>
<h2><code>%</code> for Numbers: Modulo operation / Remainder / Rest</h2>
<p>The percentage sign is an <a href="https://docs.python.org/library/stdtypes.html#numeric-types-int-float-complex" rel="nofollow noreferrer">operator in Python</a>. It's described as:</p>
<blockquote>
<pre><code>x % y       remainder of x / y
</code></pre>
</blockquote>
<p>So it gives you the <a href="https://en.wikipedia.org/wiki/Modulo_operation" rel="nofollow noreferrer">remainder/rest that</a> <em>remains</em> if you "floor divide" x by y. Generally (at least in Python) given a number <code>x</code> and a divisor <code>y</code>:</p>
<pre><code>x == y * (x // y) + (x % y)
</code></pre>
<p>For example if you divide 5 by 2:</p>
<pre><code>&gt;&gt;&gt; 5 // 2
2
&gt;&gt;&gt; 5 % 2
1

&gt;&gt;&gt; 2 * (5 // 2) + (5 % 2)
5
</code></pre>
<p>In general you use the modulo operation to test if a number divides evenly by another number, that's because multiples of a number modulo that number returns 0:</p>
<pre><code>&gt;&gt;&gt; 15 % 5  # 15 is 3 * 5
0

&gt;&gt;&gt; 81 % 9  # 81 is 9 * 9
0
</code></pre>
<p>That's how it's used in your example, it cannot be a prime if it's a multiple of another number (except for itself and one), that's what this does:</p>
<pre><code>if n % x == 0:
    break
</code></pre>
<p>If you feel that <code>n % x == 0</code> isn't very descriptive you could put it in another function with a more descriptive name:</p>
<pre><code>def is_multiple(number, divisor):
    return number % divisor == 0

...

if is_multiple(n, x):
    break
</code></pre>
<p>Instead of <code>is_multiple</code> it could also be named <code>evenly_divides</code> or something similar. That's what is tested here.</p>
<p>Similar to that it's often used to determine if a number is "odd" or "even":</p>
<pre><code>def is_odd(number):
    return number % 2 == 1

def is_even(number):
    return number % 2 == 0
</code></pre>
<p>And in some cases it's also used for array/list indexing when wrap-around (cycling) behavior is wanted, then you just modulo the "index" by the "length of the array" to achieve that:</p>
<pre><code>&gt;&gt;&gt; l = [0, 1, 2]
&gt;&gt;&gt; length = len(l)
&gt;&gt;&gt; for index in range(10):
...     print(l[index % length])
0
1
2
0
1
2
0
1
2
0
</code></pre>
<p>Note that there is also a function for this operator in the standard library <a href="https://docs.python.org/library/operator.html#operator.mod" rel="nofollow noreferrer"><code>operator.mod</code></a> (and the alias <a href="https://docs.python.org/library/operator.html#operator.__mod__" rel="nofollow noreferrer"><code>operator.__mod__</code></a>):</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; operator.mod(5, 2)  # equivalent to 5 % 2
1
</code></pre>
<p>But there is also the augmented assignment <code>%=</code> which assigns the result back to the variable:</p>
<pre><code>&gt;&gt;&gt; a = 5
&gt;&gt;&gt; a %= 2  # identical to: a = a % 2
&gt;&gt;&gt; a
1
</code></pre>
<h2><code>%</code> for strings: <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting" rel="nofollow noreferrer"><code>printf</code>-style String Formatting</a></h2>
<p>For strings the meaning is completely different, there it's <em>one way</em> (in my opinion the most limited and ugly) for doing string formatting:</p>
<pre><code>&gt;&gt;&gt; "%s is %s." % ("this", "good") 
'this is good'
</code></pre>
<p>Here the <code>%</code> in the string represents a placeholder followed by a formatting specification. In this case I used <code>%s</code> which means that it expects a string. Then the string is followed by a <code>%</code> which indicates that the string on the left hand side will be formatted by the right hand side. In this case the first <code>%s</code> is replaced by the first argument <code>this</code> and the second <code>%s</code> is replaced by the second argument (<code>good</code>).</p>
<p>Note that there are much better (probably opinion-based) ways to format strings:</p>
<pre><code>&gt;&gt;&gt; "{} is {}.".format("this", "good")
'this is good.'
</code></pre>
<h2><code>%</code> in Jupyter/IPython: magic commands</h2>
<p>To quote the <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#built-in-magic-commands" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>To Jupyter users: Magics are specific to and provided by the IPython kernel. Whether magics are available on a kernel is a decision that is made by the kernel developer on a per-kernel basis. To work properly, Magics must use a syntax element which is not valid in the underlying language. For example, the IPython kernel uses the <code>%</code> syntax element for magics as <code>%</code> is not a valid unary operator in Python. While, the syntax element has meaning in other languages.</p>
</blockquote>
<p>This is regularly used in Jupyter notebooks and similar:</p>
<pre><code>In [1]:  a = 10
         b = 20
         %timeit a + b   # one % -&gt; line-magic

54.6 ns ± 2.7 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [2]:  %%timeit  # two %% -&gt; cell magic 
         a ** b

362 ns ± 8.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
</code></pre>
<h2>The <code>%</code> operator on arrays (in the NumPy / Pandas ecosystem)</h2>
<p>The <code>%</code> operator is still the modulo operator when applied to these arrays, but it returns an array containing the remainder of each element in the array:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

&gt;&gt;&gt; a % 2
array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1])
</code></pre>
<h2>Customizing the <code>%</code> operator for your own classes</h2>
<p>Of course you can customize how your own classes work when the <code>%</code> operator is applied to them. Generally you <em>should</em> only use it to implement modulo operations! But that's a guideline, not a hard rule.</p>
<p>Just to provide a simple example that shows how it works:</p>
<pre><code>class MyNumber(object):
    def __init__(self, value):
        self.value = value

    def __mod__(self, other):
        print("__mod__ called on '{!r}'".format(self))
        return self.value % other

    def __repr__(self):
        return "{self.__class__.__name__}({self.value!r})".format(self=self)
</code></pre>
<p>This example isn't really useful, it just prints and then delegates the operator to the stored value, but it shows that <a href="https://docs.python.org/reference/datamodel.html#object.__mod__" rel="nofollow noreferrer"><code>__mod__</code></a> is called when <code>%</code> is applied to an instance:</p>
<pre><code>&gt;&gt;&gt; a = MyNumber(10)
&gt;&gt;&gt; a % 2
__mod__ called on 'MyNumber(10)'
0
</code></pre>
<p>Note that it also works for <code>%=</code> without explicitly needing to implement <code>__imod__</code>:</p>
<pre><code>&gt;&gt;&gt; a = MyNumber(10)
&gt;&gt;&gt; a %= 2
__mod__ called on 'MyNumber(10)'

&gt;&gt;&gt; a
0
</code></pre>
<p>However you could also implement <code>__imod__</code> explicitly to overwrite the augmented assignment:</p>
<pre><code>class MyNumber(object):
    def __init__(self, value):
        self.value = value

    def __mod__(self, other):
        print("__mod__ called on '{!r}'".format(self))
        return self.value % other

    def __imod__(self, other):
        print("__imod__ called on '{!r}'".format(self))
        self.value %= other
        return self

    def __repr__(self):
        return "{self.__class__.__name__}({self.value!r})".format(self=self)
</code></pre>
<p>Now <code>%=</code> is explicitly overwritten to work in-place:</p>
<pre><code>&gt;&gt;&gt; a = MyNumber(10)
&gt;&gt;&gt; a %= 2
__imod__ called on 'MyNumber(10)'

&gt;&gt;&gt; a
MyNumber(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In python 2.6 the '%' operator performed a modulus. I don't think they changed it in 3.0.1</p>
<p>The modulo operator tells you the remainder of a division of two numbers. </p>
</div>
<div class="post-text" itemprop="text">
<p>It checks if the modulo of the division. For example, in the case you are iterating over all numbers from 2 to n and checking if n is divisible by any of the numbers in between. Simply put, you are checking if a given number n is prime. (Hint: You could check up to n/2).</p>
</div>
<div class="post-text" itemprop="text">
<p>The modulus operator. The remainder when you divide two number.</p>
<p>For Example:</p>
<pre><code>&gt;&gt;&gt; 5 % 2 = 1 # remainder of 5 divided by 2 is 1
&gt;&gt;&gt; 7 % 3 = 1 # remainer of 7 divided by 3 is 1
&gt;&gt;&gt; 3 % 1 = 0 # because 1 divides evenly into 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Blockquote
  x % n ==0
  which means the x/n and the value of reminder will taken as a result and compare with zero....</p>
</blockquote>
<p>example:
4/5==0</p>
<p>4/5 reminder is 1</p>
<p>1==0 (False)</p>
</div>
<span class="comment-copy">FYI, it's called Euclidean Division</span>
<span class="comment-copy">At the risk of being pedantic, thought I should clarify that modulus (%) isn't the same as remainder for negative numbers. Remainder of -2 / 3 would be -2, but -2 % 3 = 1</span>
<span class="comment-copy">I believe the string formatting operator was removed in Python 3.</span>
<span class="comment-copy">@David: it was just deprecated.</span>
<span class="comment-copy">I'd thought that too, but couldn't find it when i looked around.  A second look turned it up.  Edit explains.</span>
<span class="comment-copy">The docs say: "the % operator is <i>supplemented</i> by a more powerful string formatting method, format()." I don't think that means removed/deprecated.</span>
<span class="comment-copy">@Leftium <a href="http://docs.python.org/3/whatsnew/3.0.html#pep-3101-a-new-approach-to-string-formatting" rel="nofollow noreferrer">docs.python.org/3/whatsnew/…</a> states that <code>%</code> will be deprecated in python 3.1 and 'removed from the language at some later time'.   However, that page is quite old.  I can't find any mention of it in the python 3.2 or 3.3 docs.  I hope that the devs have changed their mind and decided to keep <code>%</code> as-is.   <code>format()</code> is nice and powerful but <code>%</code> is a lot more convenient for basic usages.</span>
