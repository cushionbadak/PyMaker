<div class="post-text" itemprop="text">
<p>How are "keyword arguments" different from regular arguments? Can't all arguments be passed as <code>name=value</code> instead of using positional syntax?</p>
</div>
<div class="post-text" itemprop="text">
<p>there are two related concepts, both called "keyword arguments".</p>
<p>On the calling side, which is what other commenters have mentioned, you have the ability to specify some function arguments by name. You have to mention them after all of the arguments without names (positional arguments), and there must be default values for any parameters which were not mentioned at all.</p>
<p>The other concept is on the function definition side: You can define a function that takes parameters by name -- and you don't even have to specify what those names are. These are pure keyword arguments, and can't be passed positionally. The syntax is</p>
<pre><code>def my_function(arg1, arg2, **kwargs)
</code></pre>
<p>Any keyword arguments you pass into this function will be placed into a dictionary named kwargs. You can examine the keys of this dictionary at run-time, like this:</p>
<pre><code>def my_function(**kwargs):
    print str(kwargs)

my_function(a=12, b="abc")

{'a': 12, 'b': 'abc'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is one last language feature where the distinction is important. Consider the following function:</p>
<pre><code>def foo(*positional, **keywords):
    print "Positional:", positional
    print "Keywords:", keywords
</code></pre>
<p>The <code>*positional</code> argument will store all of the positional arguments passed to <code>foo()</code>, with no limit to how many you can provide.</p>
<pre><code>&gt;&gt;&gt; foo('one', 'two', 'three')
Positional: ('one', 'two', 'three')
Keywords: {}
</code></pre>
<p>The <code>**keywords</code> argument will store any keyword arguments:</p>
<pre><code>&gt;&gt;&gt; foo(a='one', b='two', c='three')
Positional: ()
Keywords: {'a': 'one', 'c': 'three', 'b': 'two'}
</code></pre>
<p>And of course, you can use both at the same time:</p>
<pre><code>&gt;&gt;&gt; foo('one','two',c='three',d='four')
Positional: ('one', 'two')
Keywords: {'c': 'three', 'd': 'four'}
</code></pre>
<p>These features are rarely used, but occasionally they are very useful, and it's important to know which arguments are positional or keywords.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using keyword arguments is the same thing as normal arguments except order doesn't matter. For example the two functions calls below are the same:</p>
<pre><code>def foo(bar, baz):
    pass

foo(1, 2)
foo(baz=2, bar=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Positional Arguments</h1>
<p>They have no keywords before them. The order is important!</p>
<pre><code>func(1,2,3, "foo")
</code></pre>
<h1>Keyword Arguments</h1>
<p>They have keywords in the front. They can be in any order!</p>
<pre><code>func(foo="bar", baz=5, hello=123)

func(baz=5, foo="bar", hello=123)
</code></pre>
<p>You should also know that if you use default arguments and neglect to insert the keywords, then the order will then matter!</p>
<pre><code>def func(foo=1, baz=2, hello=3): ...
func("bar", 5, 123)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two ways to assign argument values to function parameters, both are used.</p>
<ol>
<li><p>By Position.  Positional arguments do not have keywords and are assigned first.</p></li>
<li><p>By Keyword.  Keyword arguments have keywords and are assigned second, after positional arguments.</p></li>
</ol>
<p>Note that <em>you</em> have the option to use positional arguments.</p>
<p>If <em>you</em> don't use positional arguments, then -- yes -- everything <em>you</em> wrote turns out to be a keyword argument.</p>
<p>When <em>you</em> call a function you make a decision to use position or keyword or a mixture.  You can choose to do all keywords if you want.  Some of us do not make this choice and use positional arguments.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm surprised that no one seems to have pointed out that one can pass a dictionary of keyed argument parameters, that satisfy the formal parameters, like so.</p>
<pre><code>&gt;&gt;&gt; def func(a='a', b='b', c='c', **kwargs):
...    print 'a:%s, b:%s, c:%s' % (a, b, c)
... 
&gt;&gt;&gt; func()
a:a, b:b, c:c
&gt;&gt;&gt; func(**{'a' : 'z', 'b':'q', 'c':'v'})
a:z, b:q, c:v
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <strong>Python 3</strong> you can have both required and non-required keyword <a href="https://docs.python.org/3/reference/expressions.html#calls" rel="noreferrer">arguments</a>:</p>
<p><strong>Optional</strong>: (default value defined for 'b')</p>
<pre><code>def func1(a, *, b=42):
    ...
func1(value_for_a) # b is optional and will default to 42
</code></pre>
<p><strong>Required</strong> (no default value defined for 'b'):</p>
<pre><code>def func2(a, *, b):
    ... 
func2(value_for_a, b=21) # b is set to 21 by the function call
func2(value_for_a) # ERROR: missing 1 required keyword-only argument: 'b'`
</code></pre>
<p>This can help in cases where you have a many similar arguments next to each other especially when of the same type, in that case I prefer using named arguments or I create a custom class if arguments belong together.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm surprised no one has mentioned the fact that you can mix positional and keyword arguments to do sneaky things like this using <code>*args</code> and <code>**kwargs</code> (<a href="http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/" rel="noreferrer">from this site</a>):</p>
<pre><code>def test_var_kwargs(farg, **kwargs):
    print "formal arg:", farg
    for key in kwargs:
        print "another keyword arg: %s: %s" % (key, kwargs[key])
</code></pre>
<p>This allows you to use arbitrary keyword arguments that may have keys you don't want to define upfront.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was looking for an example that had default kwargs using type annotation:</p>
<pre><code>def test_var_kwarg(a: str, b: str='B', c: str='', **kwargs) -&gt; str:
     return ' '.join([a, b, c, str(kwargs)])
</code></pre>
<p>example:</p>
<pre><code>&gt;&gt;&gt; print(test_var_kwarg('A', c='okay'))
A B okay {}
&gt;&gt;&gt; d = {'f': 'F', 'g': 'G'}
&gt;&gt;&gt; print(test_var_kwarg('a', c='c', b='b', **d))
a b c {'f': 'F', 'g': 'G'}
&gt;&gt;&gt; print(test_var_kwarg('a', 'b', 'c'))
a b c {}
</code></pre>
</div>
<span class="comment-copy">You might also want to read PEP 3102 -- they're tidying up some of this stuff in Python 3. See: <a href="http://www.python.org/dev/peps/pep-3102/" rel="nofollow noreferrer">python.org/dev/peps/pep-3102</a></span>
<span class="comment-copy">And whether or not there is a default value has nothing to do with it (except whether or not you need pass a value for it), right?</span>
<span class="comment-copy">Read more about <a href="http://symfony-world.blogspot.com/2013/07/python-positional-arguments-and-keyword.html" rel="nofollow noreferrer">python positional/keyword arguments</a></span>
<span class="comment-copy">@Ben Hoyt Added an answer below covering Python 3, required keyword arguments</span>
<span class="comment-copy">+1 and accepted: You're the only one who talked about both types of positional+keyword arguments, everyone else either thought I was talking about the first or the second (but they were still good posts). Thanks!</span>
<span class="comment-copy">The wording is unclear: Normally you speak of arguments on the calling side while of parameters on the called side.</span>
<span class="comment-copy">Does the parameter name has to be <code>kwargs</code> or I can rename it to sth. like <code>options</code> (<code>def my_fuction(arg1, arg2, **options)</code>)?</span>
<span class="comment-copy">The name can be anything, though <code>kwargs</code> is the convention when there isn't a more appropriate name</span>
<span class="comment-copy">Excellent answer! Just a note that required positional arguments can be passed before <code>*positional</code>and <code>**keywords</code> if we change function definition like <code>def foo(arg1, *positional, **keywords):</code>. Here <code>arg1</code> is positional and required. Please note that positional in answer means optional and variable number of positional arguments.</span>
<span class="comment-copy">Yes fine answer. Another note: If you call your function <code>foo(bar=True)</code> you can get the values using <code>bar = keywords.pop('bar')</code> same as <code>bar = keywords.pop('bar', None)</code>. For default value, use <code>bar = keywords.pop('bar', False)</code></span>
<span class="comment-copy">Thanks for this. It's incredibly useful that I can <b>both</b> specify a keyword arg as a positional arg, <b>and</b> a positional arg as a keyword arg.</span>
<span class="comment-copy">IMHO, the 3rd example (default arguments) is not clear. I think you are talking about what happens when one or more parameters declare default values, and the call uses positional notation, but supplies LESS than the number of declared parameters. However, your example has 3 declared, and 3 in the call, so the default values have no effect at all!  Did you intend to omit the 3rd arg. e.g. <code>func("bar", 5)</code>? And then say that <code>hello</code> gets its default value of <code>3</code>.</span>
<span class="comment-copy">Ohh, I was thinking that of parameters, when what it actually is is the arguments (what <i>I</i> pass). Thanks!</span>
<span class="comment-copy">If I could accept two yours would be next.</span>
<span class="comment-copy">+1 for a useful technique. Your point would be clearer, without <code>, **kwargs</code>. That would demonstrate that even a simple func def, with a fixed # of parameters, can be supplied a dictionary. That is, it doesn't require anything fancy in the definition. THEN you might add a second example, WITH **kwargs in definition, and show how EXTRA items in dictionary are available via that.</span>
<span class="comment-copy">I have seen this happen in various libraries' source code and was so confused. Thanks for clearing it up!</span>
<span class="comment-copy">The fourth formal parameter above - **kwargs is necessary if you ever call func with a dictionary that contains keys other than 'a', 'b' and 'c'.</span>
<span class="comment-copy">The <i>required</i> variant is quite useful. It urges to give the args by name without providing defaults, which often makes no sense.</span>
<span class="comment-copy">Default values look nice and can help you save time when you start out, but on the long run default values can be a PITA.</span>
