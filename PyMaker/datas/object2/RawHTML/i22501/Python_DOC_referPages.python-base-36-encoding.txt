<div class="post-text" itemprop="text">
<p>How can I encode an integer with base 36 in Python and then decode it again?</p>
</div>
<div class="post-text" itemprop="text">
<p>Have you tried Wikipedia's sample code?</p>
<pre><code>def base36encode(number, alphabet='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):
    """Converts an integer to a base36 string."""
    if not isinstance(number, (int, long)):
        raise TypeError('number must be an integer')

    base36 = ''
    sign = ''

    if number &lt; 0:
        sign = '-'
        number = -number

    if 0 &lt;= number &lt; len(alphabet):
        return sign + alphabet[number]

    while number != 0:
        number, i = divmod(number, len(alphabet))
        base36 = alphabet[i] + base36

    return sign + base36

def base36decode(number):
    return int(number, 36)

print base36encode(1412823931503067241)
print base36decode('AQF8AA0006EH')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wish I had read this before. Here is the answer:</p>
<pre><code>def base36encode(number):
    if not isinstance(number, (int, long)):
        raise TypeError('number must be an integer')
    if number &lt; 0:
        raise ValueError('number must be positive')

    alphabet, base36 = ['0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', '']

    while number:
        number, i = divmod(number, 36)
        base36 = alphabet[i] + base36

    return base36 or alphabet[0]


def base36decode(number):
    return int(number, 36)

print(base36encode(1412823931503067241))
print(base36decode('AQF8AA0006EH'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from numpy import base_repr

num = base_repr(num, 36)
num = int(num, 36)
</code></pre>
<p>Here is information about <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.base_repr.html" rel="nofollow noreferrer"><code>numpy.base_repr</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>terrible answer, but was just playing around with this an thought i'd share.</p>
<pre><code>import string, math

int2base = lambda a, b: ''.join(
    [(string.digits + string.lowercase + string.uppercase)[(a/b**i)%b]
     for i in xrange(int(math.log(a, b)), -1, -1)]
    )

num = 1412823931503067241
test = int2base(num, 36)
test2 = int(test, 36)
print test2 == num
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use numpy's <a href="https://docs.python.org/3/library/functions.html#int" rel="noreferrer"><code>base_repr(...)</code></a> for this.</p>
<pre><code>import numpy as np

num = 2017

num = np.base_repr(num, 36)
print(num)  # 1K1

num = int(num, 36)
print(num)  # 2017
</code></pre>
<p>Here is some information about <a href="http://www.numpy.org" rel="noreferrer">numpy</a>, <a href="https://docs.python.org/3/library/functions.html#int" rel="noreferrer"><code>int(x, base=10)</code></a>, and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.base_repr.html" rel="noreferrer"><code>np.base_repr(number, base=2, padding=0)</code></a>.</p>
<p>(This answer was originally submitted as an edit to @christopher-beland's answer, but was rejected in favor of its own answer.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://github.com/tonyseek/python-base36" rel="noreferrer">https://github.com/tonyseek/python-base36</a>.</p>
<pre><code>$ pip install base36
</code></pre>
<p>and then</p>
<pre><code>&gt;&gt;&gt; import base36
&gt;&gt;&gt; assert base36.dumps(19930503) == 'bv6h3'
&gt;&gt;&gt; assert base36.loads('bv6h3') == 19930503
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works if you only care about positive integers.</p>
<pre><code>def int_to_base36(num):
    """Converts a positive integer into a base36 string."""
    assert num &gt;= 0
    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    res = ''
    while not res or num &gt; 0:
        num, i = divmod(num, 36)
        res = digits[i] + res
    return res
</code></pre>
<p>To convert back to int, just use <code>int(num, 36)</code>. For a conversion of arbitrary bases see <a href="https://gist.github.com/mbarkhau/1b918cb3b4a2bdaf841c" rel="nofollow">https://gist.github.com/mbarkhau/1b918cb3b4a2bdaf841c</a></p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/561486/how-to-convert-an-integer-to-the-shortest-url-safe-string-in-python">How to convert an integer to the shortest url-safe string in Python?</a></span>
<span class="comment-copy">Christ if they can do str-&gt;int in any base, you'd think they'd let you do int-&gt;str in any base with a builtin...</span>
<span class="comment-copy">to make it even more pythonic, add import of <code>string</code> and replace alphabet value with <code>string.digits+string.lowercase</code></span>
<span class="comment-copy">interface between <code>base36encode</code> and <code>base36decode</code> is broken, the latter will fail (possibly silently) to decode anything encoded with custom <code>alphabet</code> argument</span>
<span class="comment-copy">The encoding function allows the user to specify an alphabet, while the decoding function does not, therefore the decoding function is not a true inverse of the encoding function as it relies on the default alphabet.</span>
<span class="comment-copy">For including lowercase alphabet see <a href="http://stackoverflow.com/questions/561486/how-to-convert-an-integer-to-the-shortest-url-safe-string-in-python/561704#561704">How to convert an integer to the shortest url-safe string in Python?</a></span>
<span class="comment-copy">@Tadeck: Because then you have to reverse <code>base36</code> before you return it.</span>
<span class="comment-copy">@JohnY: My mistake, that would not be the same.</span>
<span class="comment-copy">I attempted to improve this answer by making it runnable with example data, and adding more documentation resources. The edit was for some reason rejected with the explanation that it was more suitable as its own answer. Thus I've added my improved version of your answer below: <a href="http://stackoverflow.com/questions/1181919/python-base-36-encoding/42331616#42331616" title="python base 36 encoding">stackoverflow.com/questions/1181919/python-base-36-encoding/â€¦</a></span>
<span class="comment-copy">I like this quite a bit, but perhaps I just have a weakness for shorter code.</span>
<span class="comment-copy">math.log returns a limited-precision float, so round to 14 digits before truncating the fractional part. This avoids turning 5.999999999999999 into 5.0, for instance.</span>
<span class="comment-copy">math.log() fails when a==0 and using it sucks anyway.</span>
<span class="comment-copy">This is the right answer. I don't know why everyone else wants to reinvent the wheel.</span>
<span class="comment-copy">@MichaelScheper Because dependencies are hard. See <code>leftpad</code>. Copy and pasting a trivial function to a file that does what you want is sometimes better than adding a new external dependency.</span>
<span class="comment-copy">@mbarkhau You could download third dependencies to your repository vendor or your private PyPI mirror (just like Golang projects). It may be better than just copy-paste code snippets, for separated test coverage and release plan.</span>
