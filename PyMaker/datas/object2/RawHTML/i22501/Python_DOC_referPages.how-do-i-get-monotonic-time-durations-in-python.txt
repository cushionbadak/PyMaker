<div class="post-text" itemprop="text">
<p>I want to log how long something takes in real walltime. Currently I'm doing this:</p>
<pre><code>startTime = time.time()
someSQLOrSomething()
print "That took %.3f seconds" % (time.time() - startTime)
</code></pre>
<p>But that will fail (produce incorrect results) if the time is adjusted while the SQL query (or whatever it is) is running.</p>
<p>I don't want to just benchmark it. I want to log it in a live application in order to see trends on a live system.</p>
<p>I want something like clock_gettime(CLOCK_MONOTONIC,...), but in Python. And preferably without having to write a C module that calls clock_gettime().</p>
</div>
<div class="post-text" itemprop="text">
<p>That function is simple enough that you can use ctypes to access it:</p>
<pre><code>#!/usr/bin/env python

__all__ = ["monotonic_time"]

import ctypes, os

CLOCK_MONOTONIC_RAW = 4 # see &lt;linux/time.h&gt;

class timespec(ctypes.Structure):
    _fields_ = [
        ('tv_sec', ctypes.c_long),
        ('tv_nsec', ctypes.c_long)
    ]

librt = ctypes.CDLL('librt.so.1', use_errno=True)
clock_gettime = librt.clock_gettime
clock_gettime.argtypes = [ctypes.c_int, ctypes.POINTER(timespec)]

def monotonic_time():
    t = timespec()
    if clock_gettime(CLOCK_MONOTONIC_RAW , ctypes.pointer(t)) != 0:
        errno_ = ctypes.get_errno()
        raise OSError(errno_, os.strerror(errno_))
    return t.tv_sec + t.tv_nsec * 1e-9

if __name__ == "__main__":
    print monotonic_time()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Now, in Python 3.3 you would use <a href="http://www.python.org/dev/peps/pep-0418/#time-monotonic">time.monotonic</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out in <a href="https://stackoverflow.com/questions/3657289/linux-clock-gettimeclock-monotonic-strange-non-monotonic-behavior">this question</a>, avoiding NTP readjustments on Linux requires CLOCK_MONOTONIC_RAW. That's defined as 4 on Linux (since 2.6.28).</p>
<p>Portably getting the correct constant #defined in a C header from Python is tricky; there is h2py, but that doesn't really help you get the value at runtime.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how I get monotonic time in Python 2.7:</p>
<p>Install the <code>monotonic</code> package:</p>
<pre><code>pip install monotonic
</code></pre>
<p>Then in Python:</p>
<pre><code>import monotonic; mtime = monotonic.time.time #now mtime() can be used in place of time.time()

t0 = mtime()
#...do something
elapsed = mtime()-t0 #gives correct elapsed time, even if system clock changed.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>time.monotonic()</code> might be useful:</p>
<blockquote>
<p>Return the value (in fractional seconds) of a monotonic clock, i.e. a clock that cannot go backwards. The clock is not affected by system clock updates. The reference point of the returned value is undefined, so that only the difference between the results of consecutive calls is valid.</p>
</blockquote>
</div>
<span class="comment-copy">Well I don't really know how often it's actually adjusted. I run NTP. But with a mononotic clock I won't have to run into stuff like the Oracle RAC bug where it rebooted the system if the time was set backwards. Besides small NTP adjustments there are leap seconds that can go back and forward.</span>
<span class="comment-copy">S.Lott: incorrect. "A leap second is a positive or negative one-second adjustment [...]". It's trivial to look up. It's the first sentence on the "Leap second" article on Wikipedia. So when a leap second is added, NTP will readjust you system time backwards (because your system is fast. It didn't count 23:59:60), meaning a time.time()-based measurment can be negative. Trust me, many Oracle servers rebooted due to the bug I mentioned above last newyears. And I just used Oracle as an example where some programs can't handle time readjustments.</span>
<span class="comment-copy">I don't know why (unpatched) Oracle 10 does that. It just does, and Oracle (the company) confirms it.</span>
<span class="comment-copy">Just wanted to add a comment here of a use case that we encountered. Within our setup that consists of a number of vmware systems, we have noticed that time "adjustments" do happen regularly enough in the guest vms, especially with the host's load avg. is high. This results in things like <code>supervisord</code> that appear to depend on time.time() crashing resulting in orphaning the processes that it started. We've ^fixed^ this issue by applying the patch - <a href="https://github.com/Supervisor/supervisor/pull/468" rel="nofollow noreferrer">github.com/Supervisor/supervisor/pull/468</a></span>
<span class="comment-copy">@Thomas: In theory, there could be negative leap seconds. In practice, all leap seconds are positive. See <a href="https://www.cl.cam.ac.uk/~mgk25/time/metrologia-leapsecond.pdf" rel="nofollow noreferrer">The leap second: its history and possible future</a>.</span>
<span class="comment-copy">Wow. Remove "self." and it worked perfectly. Very impressive. It requires ctypes which is add-on for Python 2.4, but it will do quite nicely. Thanks.</span>
<span class="comment-copy">Oh, and CLOCK_MONOTONIC seems to be 4 on FreeBSD and 1 on Linux.</span>
<span class="comment-copy">Nice solution. Is there any reason you use ctypes.pointer instead of ctypes.byref?</span>
<span class="comment-copy">use <code>CLOCK_MONOTONIC_RAW==4</code> (since Linux 2.6.28; Linux-specific) to avoid NTP adjustments.</span>
<span class="comment-copy">Thanks @ArminRonacher for your answer, I've incorporated it into a Windows/Linux-compatible module I posted here: <a href="http://stackoverflow.com/a/38319607/4561887">stackoverflow.com/a/38319607/4561887</a></span>
<span class="comment-copy">In CPython, I assume this internally uses <code>CLOCK_MONOTONIC</code> and <b>not</b> <code>CLOCK_MONOTONIC_RAW</code>, with the latter not even being available in Python 3.3.</span>
<span class="comment-copy">@A-B-B: <a href="http://hg.python.org/cpython/file/e20f98a8ed71/Modules/timemodule.c#l1377" rel="nofollow noreferrer"><code>time</code> module knows about <code>CLOCK_MONOTONIC_RAW</code></a> though it doesn't use it as far as I can see. You could <a href="https://gist.github.com/zed/5073409" rel="nofollow noreferrer">define clock that uses it via <code>ctypes</code> even on Python 2.7</a></span>
<span class="comment-copy">If I am reading the documentation right, it appears that in Python 3.3 you can get <code>CLOCK_MONOTONIC_RAW</code> by calling <code>time.clock_gettime(time.CLOCK_MONOTONIC_RAW)</code>, which is great so when you use it to measure small time intervals you never get error introduced when the network updates the time via NTP (Network Time Protocol) adjustments. Python time reference: <a href="https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW" rel="nofollow noreferrer">docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW</a>. &lt;-- NOTE: FOR UNIX/LINUX ONLY. For Windows, just call <code>time.clock()</code>, which already has microsecond or better resolution since it uses the QueryPerformanceCounter().</span>
<span class="comment-copy">I believe the chosen answer was incorrect and did not explain the jumps, see <a href="http://stackoverflow.com/questions/3657289/linux-clock-gettimeclock-monotonic-strange-non-monotonic-behavior#comment12057005_3657385">my comment on it</a>. Both CLOCK_MONOTONIC and CLOCK_MONOTONIC_RAW are monotonic, and the only way they differ is that the former corrects hardware clock speed using NTP.</span>
