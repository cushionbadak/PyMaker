<div class="post-text" itemprop="text">
<p>I want to know the number of CPUs on the local machine using Python. The result should be <code>user/real</code> as output by <code>time(1)</code> when called with an optimally scaling userspace-only program.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have python with a version &gt;= 2.6 you can simply use</p>
<pre><code>import multiprocessing

multiprocessing.cpu_count()
</code></pre>
<p><a href="http://docs.python.org/library/multiprocessing.html#multiprocessing.cpu_count" rel="noreferrer">http://docs.python.org/library/multiprocessing.html#multiprocessing.cpu_count</a></p>
</div>
<div class="post-text" itemprop="text">
<p>If you're interested into the number of processors <em>available</em> to your current process, you have to check <a href="http://man7.org/linux/man-pages/man7/cpuset.7.html" rel="noreferrer">cpuset</a> first. Otherwise (or if cpuset is not in use), <a href="http://docs.python.org/library/multiprocessing.html#multiprocessing.cpu_count" rel="noreferrer"><code>multiprocessing.cpu_count()</code></a> is the way to go in Python 2.6 and newer. The following method falls back to a couple of alternative methods in older versions of Python:</p>
<pre><code>import os
import re
import subprocess


def available_cpu_count():
    """ Number of available virtual or physical CPUs on this system, i.e.
    user/real as output by time(1) when called with an optimally scaling
    userspace-only program"""

    # cpuset
    # cpuset may restrict the number of *available* processors
    try:
        m = re.search(r'(?m)^Cpus_allowed:\s*(.*)$',
                      open('/proc/self/status').read())
        if m:
            res = bin(int(m.group(1).replace(',', ''), 16)).count('1')
            if res &gt; 0:
                return res
    except IOError:
        pass

    # Python 2.6+
    try:
        import multiprocessing
        return multiprocessing.cpu_count()
    except (ImportError, NotImplementedError):
        pass

    # https://github.com/giampaolo/psutil
    try:
        import psutil
        return psutil.cpu_count()   # psutil.NUM_CPUS on old versions
    except (ImportError, AttributeError):
        pass

    # POSIX
    try:
        res = int(os.sysconf('SC_NPROCESSORS_ONLN'))

        if res &gt; 0:
            return res
    except (AttributeError, ValueError):
        pass

    # Windows
    try:
        res = int(os.environ['NUMBER_OF_PROCESSORS'])

        if res &gt; 0:
            return res
    except (KeyError, ValueError):
        pass

    # jython
    try:
        from java.lang import Runtime
        runtime = Runtime.getRuntime()
        res = runtime.availableProcessors()
        if res &gt; 0:
            return res
    except ImportError:
        pass

    # BSD
    try:
        sysctl = subprocess.Popen(['sysctl', '-n', 'hw.ncpu'],
                                  stdout=subprocess.PIPE)
        scStdout = sysctl.communicate()[0]
        res = int(scStdout)

        if res &gt; 0:
            return res
    except (OSError, ValueError):
        pass

    # Linux
    try:
        res = open('/proc/cpuinfo').read().count('processor\t:')

        if res &gt; 0:
            return res
    except IOError:
        pass

    # Solaris
    try:
        pseudoDevices = os.listdir('/devices/pseudo/')
        res = 0
        for pd in pseudoDevices:
            if re.match(r'^cpuid@[0-9]+$', pd):
                res += 1

        if res &gt; 0:
            return res
    except OSError:
        pass

    # Other UNIXes (heuristic)
    try:
        try:
            dmesg = open('/var/run/dmesg.boot').read()
        except IOError:
            dmesgProcess = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE)
            dmesg = dmesgProcess.communicate()[0]

        res = 0
        while '\ncpu' + str(res) + ':' in dmesg:
            res += 1

        if res &gt; 0:
            return res
    except OSError:
        pass

    raise Exception('Can not determine number of CPUs on this system')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option is to use the <a href="https://github.com/giampaolo/psutil" rel="noreferrer"><code>psutil</code></a> library, which always turn out useful in these situations:</p>
<pre><code>&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.cpu_count()
2
</code></pre>
<p>This should work on any platform supported by <code>psutil</code>(Unix and Windows).</p>
<p>Note that in some occasions <code>multiprocessing.cpu_count</code> may raise a <code>NotImplementedError</code> while <code>psutil</code> will be able to obtain the number of CPUs. This is simply because <code>psutil</code> first tries to use the same techniques used by <code>multiprocessing</code> and, if those fail, it also uses other techniques.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4+: <a href="https://docs.python.org/3/library/os.html#os.cpu_count">os.cpu_count()</a>.</p>
<p><code>multiprocessing.cpu_count()</code> is implemented in terms of this function but raises <code>NotImplementedError</code> if <code>os.cpu_count()</code> returns <code>None</code> ("can't determine number of CPUs").</p>
</div>
<div class="post-text" itemprop="text">
<p>platform independent:</p>
<blockquote>
<p>psutil.cpu_count(logical=False)</p>
</blockquote>
<p><a href="https://github.com/giampaolo/psutil/blob/master/INSTALL.rst">https://github.com/giampaolo/psutil/blob/master/INSTALL.rst</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os

print(os.cpu_count())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>multiprocessing.cpu_count()</code> will return the number of logical CPUs, so if you have a quad-core CPU with hyperthreading, it will return <code>8</code>.  If you want the number of physical CPUs, use the python bindings to hwloc:</p>
<pre><code>#!/usr/bin/env python
import hwloc
topology = hwloc.Topology()
topology.load()
print topology.get_nbobjs_by_type(hwloc.OBJ_CORE)
</code></pre>
<p>hwloc is designed to be portable across OSes and architectures.</p>
</div>
<div class="post-text" itemprop="text">
<p>Can't figure out how to add to the code or reply to the message but here's support for jython that you can tack in before you give up:</p>
<pre><code># jython
try:
    from java.lang import Runtime
    runtime = Runtime.getRuntime()
    res = runtime.availableProcessors()
    if res &gt; 0:
        return res
except ImportError:
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use "joblib" for this purpose. </p>
<pre><code>import joblib
print joblib.cpu_count()
</code></pre>
<p>This method will give you the number of cpus in the system. joblib needs to be installed though. More information on joblib can be found here       <a href="https://pythonhosted.org/joblib/parallel.html" rel="nofollow">https://pythonhosted.org/joblib/parallel.html</a></p>
<p>Alternatively you can use numexpr package of python. It has lot of simple functions helpful for getting information about the system cpu.</p>
<pre><code>import numexpr as ne
print ne.detect_number_of_cores()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong><code>len(os.sched_getaffinity(0))</code> is what you usually want</strong></p>
<p><code>os.sched_getaffinity(0)</code> (added in Python 3) returns the set of CPUs available considering the <a href="https://stackoverflow.com/questions/10490756/how-to-use-sched-getaffinity-and-sched-setaffinity-in-linux-from-c/50117787#50117787"><code>sched_setaffinity</code> Linux system call</a>, which limits which CPUs a process and its children can run on.</p>
<p><code>multiprocessing.cpu_count()</code> on the other hand just returns the total number of physical CPUs.</p>
<p>We can see the difference by restricting the affinity with the <code>taskset</code> utility.</p>
<p>For example, if I restrict Python to just 1 core (core 0) in my 16 core system:</p>
<pre><code>taskset -c 0 ./main.py
</code></pre>
<p>with the test script:</p>
<p>main.py</p>
<pre><code>#!/usr/bin/env python3

import multiprocessing
import os

print(multiprocessing.cpu_count())
print(len(os.sched_getaffinity(0)))
</code></pre>
<p>then the output is:</p>
<pre><code>16
1
</code></pre>
<p>This is especially important because certain cluster management systems such as <a href="https://en.wikipedia.org/wiki/Platform_LSF" rel="nofollow noreferrer">Platform LSF</a> limit job CPU usage with <code>sched_getaffinity</code>.</p>
<p>Therefore, if you use <code>multiprocessing.cpu_count()</code>, your script might try to use way more cores than it has available, which may lead to individual tasks timing out.</p>
<p><code>nproc</code> respects affinity by default:</p>
<pre><code>taskset -c 0 nproc
</code></pre>
<p>outputs:</p>
<pre><code>1
</code></pre>
<p>and <code>man nproc</code> makes that quite explicit:</p>
<blockquote>
<p>print the number of processing units available</p>
</blockquote>
<p><code>nproc</code> has the <code>--all</code> flag for the less common case that you want to get the physical CPU count:</p>
<pre><code>taskset -c 0 nproc --all
</code></pre>
<p>Tested in Ubuntu 16.04, Python 3.5.2.</p>
</div>
<div class="post-text" itemprop="text">
<h1>This is the function cpu_count from multiprocessing</h1>
<h1>:}</h1>
<pre><code>import os
import sys

def cpu_count():
    '''
    Returns the number of CPUs in the system
    '''
    if sys.platform == 'win32':
        try:
            num = int(os.environ['NUMBER_OF_PROCESSORS'])
        except (ValueError, KeyError):
            num = 0
    elif 'bsd' in sys.platform or sys.platform == 'darwin':
        comm = '/sbin/sysctl -n hw.ncpu'
        if sys.platform == 'darwin':
            comm = '/usr' + comm
        try:
            with os.popen(comm) as p:
                num = int(p.read())
        except ValueError:
            num = 0
    else:
        try:
            num = os.sysconf('SC_NPROCESSORS_ONLN')
        except (ValueError, OSError, AttributeError):
           num = 0

    if num &gt;= 1:
        return num
    else:
        raise NotImplementedError('cannot determine number of cpus')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option if you don't have Python 2.6:</p>
<pre><code>import commands
n = commands.getoutput("grep -c processor /proc/cpuinfo")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since I cannot comment yet:</p>
<p>These give you the "physical" CPU count</p>
<ol>
<li>multiprocessing.cpu_count()</li>
<li>os.cpu_count()</li>
</ol>
<p>These give you the virtual machine CPU count</p>
<ol>
<li>psutil.cpu_count()</li>
<li>numexpr.detect_number_of_cores()</li>
</ol>
<p>Only matters if you works on VMs.</p>
</div>
<span class="comment-copy">You should keep cpusets (in Linux) in mind. If you're in a cpuset, the solutions below will still give the number of real CPUs in the system, not the number available to your process. <code>/proc/&lt;PID&gt;/status</code> has some lines that tell you the number of CPUs in the current cpuset: look for <code>Cpus_allowed_list</code>.</span>
<span class="comment-copy">@Casey Yes, it does, using sysctl -n.</span>
<span class="comment-copy">multiprocessing is also supported in 3.x</span>
<span class="comment-copy">I want to add that this doesn't work in IronPython which raises a NotImplementedError.</span>
<span class="comment-copy">This gives the number of CPUs on available... not in use by the program!</span>
<span class="comment-copy">On Python 3.6.2 I could only use <code>os.cpu_count()</code></span>
<span class="comment-copy">I guess you mean subprocess.PIPE and not Popen.PIPE, right?</span>
<span class="comment-copy">@EOL Yes, of course. Looks like a replace gone wild. Corrected.</span>
<span class="comment-copy"><code>open('/proc/self/status').read()</code> forgets to close the file. Use <code>with open('/proc/self/status') as f: f.read()</code> instead</span>
<span class="comment-copy"><code>os.cpu_count()</code></span>
<span class="comment-copy">@amcgregor In this case it's acceptable, agreed, just file handles being left open which I guess is ok if you're not writing a long running daemon/process; which I fear might end up hitting a max open file handles of the OS. It's worse when writing to a file that needs to get read again before the process ends, but that's not the case here so that's a moot point. Still a good idea to have a habit of using <code>with</code> for when you do encounter a case where you need it.</span>
<span class="comment-copy">See also the documentation of <code>cpu_count</code>. <code>len(os.sched_getaffinity(0))</code> might be better, depending on the purpose.</span>
<span class="comment-copy">@Albert yes, the number of CPUs in the system (<code>os.cpu_count()</code>—what OP asks) may differ from the number of CPUs that are available to the current process (<code>os.sched_getaffinity(0)</code>).</span>
<span class="comment-copy">I know. I just wanted to add that for other readers, who might miss this difference, to get a more complete picture from them.</span>
<span class="comment-copy">What is difference between a logical CPU and not not a logical one? on my laptop: <code>psutil.cpu_count(logical=False) #4</code> <code>psutil.cpu_count(logical=True) #8</code> and <code>multiprocessing.cpu_count() #8</code></span>
<span class="comment-copy">a logical is a 'simulated cpu': <a href="https://en.wikipedia.org/wiki/Hyper-threading" rel="nofollow noreferrer">en.wikipedia.org/wiki/Hyper-threading</a></span>
<span class="comment-copy">@user305883 assuming you have a x86 CPU, you have <a href="https://en.wikipedia.org/wiki/Hyper-threading" rel="nofollow noreferrer">hyperthreading</a> on this machine, i.e. each physical core corresponds to two hyperthreads ('logical' cores). Hyperthreading allows the physical core to be used to execute instructions from thread B when parts of it are idle for thread A (e.g. waiting for data being fetched from the cache or memory). Depending on your code one can get one or a few tens of percents of additional core utilization but it is far below the performance of a real physical core.</span>
<span class="comment-copy">Not avaible on python 2 (only for python 3)</span>
<span class="comment-copy">In this case, I want the number of logical CPUs (i.e. how many threads should I start if this program scales really well), but the answer may be helpful nonetheless.</span>
<span class="comment-copy">or <code>psutil.cpu_count(logical=False)</code></span>
<span class="comment-copy">joblib uses the underlying multiprocessing module. It's probably best to call into multiprocessing directly for this.</span>
<span class="comment-copy">Thanks! This is only available on Linux though, and already included <a href="http://stackoverflow.com/a/1006301/35070">in my answer</a>.</span>
