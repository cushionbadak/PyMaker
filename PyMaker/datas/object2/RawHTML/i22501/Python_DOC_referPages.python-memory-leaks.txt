<div class="post-text" itemprop="text">
<p>I have a long-running script which, if let to run long enough, will consume all the memory on my system.</p>
<p>Without going into details about the script, I have two questions:</p>
<ol>
<li>Are there any "Best Practices" to follow, which will help prevent leaks from occurring?</li>
<li>What techniques are there to debug memory leaks in Python?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Have a look at this article: <a href="http://www.lshift.net/blog/2008/11/14/tracing-python-memory-leaks" rel="noreferrer">Tracing python memory leaks</a></p>
<p>Also, note that the <a href="http://docs.python.org/library/gc.html" rel="noreferrer">garbage collection module</a> actually can have debug flags set. Look at the <code>set_debug</code> function. Additionally, look at <a href="https://stackoverflow.com/questions/1641231/python-working-around-memory-leaks/1641280#1641280">this code by Gnibbler</a> for determining the types of objects that have been created after a call.</p>
</div>
<div class="post-text" itemprop="text">
<p>I tried out most options mentioned previously but found this small and intuitive package to be the best: <a href="https://github.com/pympler/pympler">pympler</a></p>
<p>It's quite straight forward to trace objects that were not garbage-collected, check this small example:</p>
<p>install package via <code>pip install pympler</code></p>
<pre><code>from pympler.tracker import SummaryTracker
tracker = SummaryTracker()

# ... some code you want to investigate ...

tracker.print_diff()
</code></pre>
<p>The output shows you all the objects that have been added, plus the memory they consumed.</p>
<p>Sample output:</p>
<pre><code>                                 types |   # objects |   total size
====================================== | =========== | ============
                                  list |        1095 |    160.78 KB
                                   str |        1093 |     66.33 KB
                                   int |         120 |      2.81 KB
                                  dict |           3 |       840 B
      frame (codename: create_summary) |           1 |       560 B
          frame (codename: print_diff) |           1 |       480 B
</code></pre>
<p>This package provides a number of more features. Check <a href="https://pythonhosted.org/Pympler/">pympler's documentation</a>, in particular the section <a href="https://pythonhosted.org/Pympler/muppy.html">Identifying memory leaks</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let me recommend <a href="https://pypi.python.org/pypi/mem_top">mem_top</a> tool,<br/>
that helped me to solve a similar issue.</p>
<p>It just instantly shows top suspects for memory leaks in a Python program.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should specially have a look on your global or static data (long living data).</p>
<p>When this data grows without restriction, you can also get troubles in Python.</p>
<p>The garbage collector can only collect data, that is not referenced any more. But your static data can hookup data elements that should be freed.</p>
<p>Another problem can be memory cycles, but at least in theory the Garbage collector should find and eliminate cycles -- at least as long as they are not hooked on some long living data.</p>
<p>What kinds of long living data are specially troublesome? Have a good look on any lists and dictionaries -- they can grow without any limit. In dictionaries you might even don't see the trouble coming since when you access dicts, the number of keys in the dictionary might not be of big visibility to you ...</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/tracemalloc.html" rel="noreferrer">Tracemalloc module</a> was integrated as a built-in module starting from Python 3.4, and appearently, it's also available for prior versions of Python as <a href="https://pytracemalloc.readthedocs.io/" rel="noreferrer">a third-party library</a> (haven't tested it though).</p>
<p>This module is able to output the precise files and lines that allocated the most memory. IMHO, this information is infinitly more valuable than the number of allocated instances for each type (which ends up being a lot of tuples 99% of the time, which is a clue, but barely helps in most cases).</p>
<p>I recommend you use tracemalloc in combination with <a href="https://pyrasite.readthedocs.io/en/latest/" rel="noreferrer">pyrasite</a>. 9 times out of 10, running the <a href="https://docs.python.org/3/library/tracemalloc.html#display-the-top-10" rel="noreferrer">top 10 snippet</a> in a <a href="https://pyrasite.readthedocs.io/en/latest/Shell.html" rel="noreferrer">pyrasite-shell</a> will give you enough information and hints to to fix the leak within 10 minutes. Yet, if you're still unable to find the leak cause, pyrasite-shell in combination with the other tools mentioned in this thread will probably give you some more hints too. You should also take a look on all the extra helpers provided by pyrasite (such as the memory viewer).</p>
</div>
<div class="post-text" itemprop="text">
<p>To detect and locate memory leaks for long running processes, e.g. in production environments, you can now use <a href="https://github.com/stackimpact/stackimpact-python" rel="noreferrer">stackimpact</a>. It uses <a href="https://docs.python.org/3/library/tracemalloc.html" rel="noreferrer">tracemalloc</a> underneath. More info in <a href="https://stackimpact.com/blog/detecting-and-locating-memory-leaks-in-production-python-applications/" rel="noreferrer">this post</a>.</p>
<p><a href="https://i.stack.imgur.com/UbGks.png" rel="noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/UbGks.png"/></a></p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure about "Best Practices" for memory leaks in python, but python should clear it's own memory by it's garbage collector. So mainly I would start by checking for circular list of some short, since they won't be picked up by the garbage collector.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is by no means exhaustive advice. But number one thing to keep in mind when writing with the thought of avoiding future memory leaks (loops) is to make sure that anything which accepts a reference to a call-back, should store that call-back as a weak reference.</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as best practices, keep an eye for recursive functions. In my case I ran into issues with recursion (where there didn't need to be). A simplified example of what I was doing:</p>
<pre><code>def my_function():
    # lots of memory intensive operations
    # like operating on images or huge dictionaries and lists
    .....
    my_flag = True
    if my_flag:  # restart the function if a certain flag is true
        my_function()

def main():
    my_function()
</code></pre>
<p>operating in this recursive manner won't trigger the garbage collection and clear out the remains of the function, so every time through memory usage is growing and growing.</p>
<p>My solution was to pull the recursive call out of my_function() and have main() handle when to call it again. this way the function ends naturally and cleans up after itself.</p>
<pre><code>def my_function():
    # lots of memory intensive operations
    # like operating on images or huge dictionaries and lists
    .....
    my_flag = True
    .....
    return my_flag

def main():
    result = my_function()
    if result:
        my_function()
</code></pre>
</div>
<span class="comment-copy">I have found <a href="http://code.activestate.com/recipes/65333/" rel="nofollow noreferrer">this recipe</a> helpful.</span>
<span class="comment-copy">It seems to print out way too much data to be useful</span>
<span class="comment-copy">@Casebash: If that function prints anything you're seriously doing it wrong. It lists objects with <code>__del__</code> method that are no longer referenced except for their cycle. The cycle cannot be broken, because of issues with <code>__del__</code>. Fix it!</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/552744/how-do-i-profile-memory-usage-in-python">How do I profile memory usage in Python?</a></span>
<span class="comment-copy">Funny thing ... my memory leak actually disappeared when I started using pympler to try tracking it. Probably some garbage collection problem ...</span>
<span class="comment-copy">It's worth noting that <code>pympler</code> can be <b>SLOW</b>. If you're doing something semi-realtime, it can completely cripple your application performance.</span>
<span class="comment-copy">@sebpiq strangely, the same happens to me... do you have any idea <i>why</i> this is happening? A quick look at the source code gave no real insights.</span>
<span class="comment-copy">that's true... but it gives very little in the way of usage/results explanation</span>
<span class="comment-copy">@me_ , this tool has both "Usage" and "Explaining result" sections documented. Should I add explanation like "refs is count of references from the object, types is count of objects of this type, bytes is size of the object" - wouldn't it be too obvious to document this?</span>
<span class="comment-copy">the tool's usage docs give a single line saying "from time to time: logging.debug(mem_top())", while its explanation of results is the author's real life error tracking experience without context...  that's not a technical specification that tells a dev exactly what they are looking at...  I'm not knocking your answer... it shows high level suspects as billed...  it doesn't give adequate documentation to fully comprehend the result of use...  for example, in the "Explaining Results" output why is the "GearmanJobRequest" obviously a problem? no explanation for why...</span>
<span class="comment-copy">i guess i'm inadvertently knocking your tool, you are the author...  no offense was intended...</span>
<span class="comment-copy">@me_ , I've just added the next step to "Usage", added "Counters" section, added explanation why exactly Gearman was a suspect in that real life example, documented each optional parameter of "mem_top()" in the code, and uploaded this all as v0.1.7 - please take a look if anything else could be improved. Thank you! )</span>
<span class="comment-copy">or references to objects that are being kept forever, etc</span>
<span class="comment-copy">Can you guys please provide examples of circular lists and objects that are being kept forever?</span>
<span class="comment-copy">Using recursion in this manner will also break if you hit the recursion depth limit because Python doesn't optimize tail calls. By default, this is 1000 recursive calls.</span>
