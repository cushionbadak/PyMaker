<div class="post-text" itemprop="text">
<p>It looks like the lists returned by <code>keys()</code> and <code>values()</code> methods of a dictionary are always a 1-to-1 mapping (assuming the dictionary is not altered between calling the 2 methods).</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; d = {'one':1, 'two': 2, 'three': 3}
&gt;&gt;&gt; k, v = d.keys(), d.values()
&gt;&gt;&gt; for i in range(len(k)):
    print d[k[i]] == v[i]

True
True
True
</code></pre>
<p>If you do not alter the dictionary between calling <code>keys()</code> and calling <code>values()</code>, is it wrong to assume the above for-loop will always print True?  I could not find any documentation confirming this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Found this:</p>
<blockquote>
<p>If <code>items()</code>, <code>keys()</code>, <code>values()</code>,
  <code>iteritems()</code>, <code>iterkeys()</code>, and
  <code>itervalues()</code> are called with no
  intervening modifications to the
  dictionary, the lists will directly
  correspond.</p>
</blockquote>
<p>On <a href="https://docs.python.org/2/library/stdtypes.html#dict.items" rel="noreferrer">2.x documentation</a> and <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">3.x documentation</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, what you observed is indeed a guaranteed property -- keys(), values() and items() return lists in congruent order if the dict is not altered.  iterkeys() &amp;c also iterate in the same order as the corresponding lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes it is <a href="https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">guaranteed in python 2.x</a>:</p>
<blockquote>
<p>If keys, values and items views are iterated over with no  intervening
  modifications to the dictionary, the order of  items will directly
  correspond.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>According to <a href="http://docs.python.org/dev/py3k/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">http://docs.python.org/dev/py3k/library/stdtypes.html#dictionary-view-objects</a> , the keys(), values() and items() methods of a dict will return corresponding iterators whose orders correspond. However, I am unable to find a reference to the official documentation for python 2.x for the same thing.</p>
<p>So as far as I can tell, the answer is yes, but only in python 3.0+</p>
</div>
<div class="post-text" itemprop="text">
<p>For what it's worth, some heavy used production code I have written is based on this assumption and I never had a problem with it. I know that doesn't make it true though :-)</p>
<p>If you don't want to take the risk I would use iteritems() if you can.</p>
<pre><code>for key, value in myDictionary.iteritems():
    print key, value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Good references to the docs. Here's how you can guarantee the order regardless of the documentation / implementation:</p>
<pre><code>k, v = zip(*d.iteritems())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes. Starting with CPython 3.6, dictionaries <a href="https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation" rel="nofollow noreferrer">return items in the order you inserted them</a>. </p>
<p>The documentation hasn't been updated yet, ignore the part that says this is an implementation detail. This is already guaranteed in CPython 3.6 and will be required for all other Python implementations <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="nofollow noreferrer">starting with Python 3.7</a>. </p>
</div>
<div class="post-text" itemprop="text">
<p>I wasn't satisfied with these answers since I wanted to ensure the exported values had the same ordering even when using different dicts.</p>
<p>Here you specify the key order upfront, the returned values will always have the same order even if the dict changes, or you use a different dict.</p>
<pre><code>keys = dict1.keys()
ordered_keys1 = [dict1[cur_key] for cur_key in keys]
ordered_keys2 = [dict2[cur_key] for cur_key in keys]
</code></pre>
</div>
<span class="comment-copy">Side note: to generate a list of the values you'd have to go through the list of keys, anyway. ;)</span>
<span class="comment-copy">All of the answers clearly indicate that the answer is "yes, always the same order", but what order is that? Obviously the order of the hash function, but is that at all predictable?</span>
<span class="comment-copy">@naught101 the order of the hash function is <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">not meant to be depended on</a>.  If order is desired an <a href="https://docs.python.org/3.6/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> would be the way to go.</span>
<span class="comment-copy">In CPython 3.7 (and up, presumably) you may rely on the iteration order of a dictionary matching insertion order. <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2017-December/151283.html</a></span>
<span class="comment-copy">apparently the statement in the 3.x documentation is clearer: "the order of items will directly correspond"</span>
<span class="comment-copy">This text is missing in the 3.7 documentation. I can only assume it's because "Dict keeps insertion order" in 3.7: <a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" rel="nofollow noreferrer">mail.python.org/pipermail/python-dev/2017-December/151283.html</a></span>
<span class="comment-copy">However, in case the list <i>is</i> altered, Pandas <code>dataframe</code> offers an alternative where items can be updated or deleted, and the order and the index locations of the items in a dict-like structure remain fixed.</span>
<span class="comment-copy">In python3.x, use dict.items()</span>
