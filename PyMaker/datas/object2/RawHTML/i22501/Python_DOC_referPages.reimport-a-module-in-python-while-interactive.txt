<div class="post-text" itemprop="text">
<p>I know it can be done, but I never remember how.</p>
<p>How can you reimport a module in python? 
The scenario is as follows: I import a module interactively and tinker with it, but then I face an error. I fix the error in the .py file and then I want to reimport the fixed module without quitting python. How can I do it ?</p>
</div>
<div class="post-text" itemprop="text">
<p>This should work:</p>
<pre><code>reload(my.module)
</code></pre>
<p>From the <a href="http://docs.python.org/library/functions.html#reload" rel="noreferrer">Python docs</a></p>
<blockquote>
<p>Reload a previously imported module. The argument must be a module object, so it must have been successfully imported before. This is useful if you have edited the module source file using an external editor and want to try out the new version without leaving the Python interpreter.</p>
</blockquote>
<p>If running Python 3.4 and up, do <code>import importlib</code>, then do <code>importlib.reload(nameOfModule)</code>.</p>
<p>Don't forget the caveats of using this method: </p>
<ul>
<li><p>When a module is reloaded, its dictionary (containing the module’s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains.</p></li>
<li><p>If a module imports objects from another module using <code>from ... import ...</code>, calling <code>reload()</code> for the other module does not redefine the objects imported from it — one way around this is to re-execute the from statement, another is to use <code>import</code> and qualified names (<code>module.*name*</code>) instead.</p></li>
<li><p>If a module instantiates instances of a class, reloading the module that defines the class does not affect the method definitions of the instances — they continue to use the old class definition. The same is true for derived classes.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>In python 3, <code>reload</code> is no longer a built in function.</p>
<p>If you are using python 3.4+ you should use <a href="https://docs.python.org/3/library/importlib.html#importlib.reload" rel="noreferrer"><code>reload</code></a> from the <a href="https://docs.python.org/3/library/importlib.html" rel="noreferrer"><code>importlib</code></a> library instead:</p>
<pre><code>import importlib
importlib.reload(some_module)
</code></pre>
<p>If you are using python 3.2 or 3.3 you should:</p>
<pre><code>import imp  
imp.reload(module)  
</code></pre>
<p>instead. See <a href="http://docs.python.org/3.0/library/imp.html#imp.reload" rel="noreferrer">http://docs.python.org/3.0/library/imp.html#imp.reload</a></p>
<p>If you are using <a href="https://ipython.org" rel="noreferrer"><code>ipython</code></a>, definitely consider using the <a href="https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html" rel="noreferrer"><code>autoreload</code></a> extension:</p>
<pre><code>%load_ext autoreload
%autoreload 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually, in Python 3 the module <code>imp</code> is marked as DEPRECATED. Well, at least that's true for 3.4.</p>
<p>Instead the <code>reload</code> function from the <code>importlib</code> module should be used:</p>
<p><a href="https://docs.python.org/3/library/importlib.html#importlib.reload">https://docs.python.org/3/library/importlib.html#importlib.reload</a></p>
<p>But be aware that this library had some API-changes with the last two minor versions.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/437589/how-do-i-unload-reload-a-python-module">How do I unload (reload) a Python module?</a></span>
<span class="comment-copy"><a href="https://stackoverflow.com/a/437591/6521116">reimport python module</a></span>
<span class="comment-copy"><b>Don't forget the caveats of using this method</b> : When a module is reloaded, its dictionary (containing the module’s global variables) <b>is retained</b> . Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains.</span>
<span class="comment-copy"><b>Don't forget the caveats of using this method</b> : If a module imports objects from another module using <code>from ... import ...</code>, calling <code>reload()</code> for the other module <b>does not redefine the objects imported from it</b> — one way around this is to re-execute the <code>from</code> statement, another is to use <code>import</code> and qualified names (<code>module.*name*</code>) instead.</span>
<span class="comment-copy"><b>Don't forget the caveats of using this method</b> : If a module instantiates instances of a class, reloading the module that defines the class <b>does not affect the method definitions of the instances</b> — they <b>continue to use the <i>old</i> class definition</b>. The same is true for derived classes.</span>
<span class="comment-copy">if I load my modules using <code>from filename import *</code>. How to reload?</span>
<span class="comment-copy"><b>Those running Python 3.4 and up please see funky-future's answer.</b> Do <code>import importlib</code>, then do <code>importlib.reload(nameOfModule)</code>.</span>
<span class="comment-copy">Although much Python code is written in Python 2, Python 3 is becoming more viable an option every day.  Thanks for the tip!</span>
<span class="comment-copy"><code>imp.reload</code> is deprecated since Python 3.4, use <a href="http://docs.python.org/3.4/library/importlib.html#importlib.reload" rel="nofollow noreferrer"><code>importlib.reload</code> function</a> instead.</span>
<span class="comment-copy">@Andrew thanks! I used the %autoreload, it's wonderful, my already created objects got automatically the corrected implementation of the class methods without having to recreate them</span>
