<div class="post-text" itemprop="text">
<p>This is a rather useless assertion error; it does not tell the values of the expression involved (assume constants used are actually variable names): </p>
<pre><code>$ python -c "assert 6-(3*2)"
[...]
AssertionError
</code></pre>
<p>Is there a better <code>assert</code> implementation in Python that is more fancy? It must not introduce additional overhead over execution (except when assert fails) .. and must turn off if <code>-O</code> flag is used.</p>
<p><strong>Edit</strong>: I know about assert's second argument as a string. I don't want to write one .. as that is encoded in the expression that is being asserted. DRY (Don't Repeat Yourself).</p>
</div>
<div class="post-text" itemprop="text">
<p>Install your of function as <code>sys.excepthook</code> -- see <a href="http://docs.python.org/library/sys.html#sys.excepthook" rel="noreferrer">the docs</a>. Your function, if the second argument is <code>AssertionError</code>, can introspect to your heart's contents; in particular, through the third argument, the traceback, it can get the frame and exact spot in which the assert failed, getting the failing exception through the source or bytecode, the value of all relevant variables, etc. Module <a href="http://docs.python.org/library/inspect.htmlt#module-inspect" rel="noreferrer">inspect</a> helps.</p>
<p>Doing it in full generality is quite a piece of work, but depending on what constraints you're willing to accept in how you write your <code>assert</code>s it can be lightened substantially (e.g. restricting them to only local or global variables makes introspection easier than if nonlocal variables of a closure could be involved, and so forth).</p>
</div>
<div class="post-text" itemprop="text">
<p>As <a href="https://stackoverflow.com/questions/1308607/python-assert-improved-introspection-of-failure/1308835#1308835">@Mark Rushakoff said</a> <code>nose</code> can evaluate failed asserts. It works on the standard <code>assert</code> too.</p>
<pre><code># test_error_reporting.py
def test():
    a,b,c = 6, 2, 3
    assert a - b*c
</code></pre>
<p><code>nosetests</code>' help:</p>
<pre><code>$ nosetests --help|grep -B2 assert
  -d, --detailed-errors, --failure-detail
                        Add detail to error output by attempting to evaluate
                        failed asserts [NOSE_DETAILED_ERRORS]
</code></pre>
<p>Example:</p>
<pre><code>$ nosetests -d
F
======================================================================
FAIL: test_error_reporting.test
----------------------------------------------------------------------
Traceback (most recent call last):
  File "..snip../site-packages/nose/case.py", line 183, in runTest
    self.test(*self.arg)
  File "..snip../test_error_reporting.py", line 3, in test
    assert a - b*c
AssertionError:
    6,2,3 = 6, 2, 3
&gt;&gt;  assert 6 - 2*3


----------------------------------------------------------------------
Ran 1 test in 0.089s

FAILED (failures=1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can attach a message to an <code>assert</code>:</p>
<pre><code>assert 6-(3*2), "always fails"
</code></pre>
<p>The message can also be built dynamically:</p>
<pre><code>assert x != 0, "x is not equal to zero (%d)" % x
</code></pre>
<p>See <a href="http://docs.python.org/reference/simple_stmts.html#the-assert-statement" rel="noreferrer">The <code>assert</code> statement</a> in the Python documentation for more information.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://somethingaboutorange.com/mrl/projects/nose/0.11.1/plugins/failuredetail.html" rel="nofollow noreferrer">The nose testing suite applies introspection to asserts</a>. </p>
<p>However, AFAICT, you have to call <em>their</em> asserts to get the introspection:</p>
<pre><code>import nose
def test1():
    nose.tools.assert_equal(6, 5+2)
</code></pre>
<p>results in</p>
<pre>
C:\temp\py&gt;C:\Python26\Scripts\nosetests.exe -d test.py
F
======================================================================
FAIL: test.test1
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Python26\lib\site-packages\nose-0.11.1-py2.6.egg\nose\case.py", line
183, in runTest
    self.test(*self.arg)
  File "C:\temp\py\test.py", line 3, in test1
    nose.tools.assert_equal(6, 5+2)
AssertionError: 6 != 7
&gt;&gt;  raise self.failureException, \
          (None or '%r != %r' % (6, 7))
</pre>
<p>Notice the AssertionError there. When my line was just <code>assert 6 == 5+2</code>, I would get:</p>
<pre>
C:\temp\py&gt;C:\Python26\Scripts\nosetests.exe -d test.py
F
======================================================================
FAIL: test.test1
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Python26\lib\site-packages\nose-0.11.1-py2.6.egg\nose\case.py", line
183, in runTest
    self.test(*self.arg)
  File "C:\temp\py\test.py", line 2, in test1
    assert 6 == 5 + 2
AssertionError:
&gt;&gt;  assert 6 == 5 + 2

</pre>
<p>Also, I'm not sure offhand if their asserts are skipped with <code>-O</code>, but that would be a very quick check.</p>
</div>
<div class="post-text" itemprop="text">
<p>Add a message to your assertion, which will be displayed if the assertion fails:</p>
<pre><code>$ python -c "assert 6-(3*2), '6-(3*2)'"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
AssertionError: 6-(3*2)
</code></pre>
<p>The only way I can think of to provide this automatically would be to contain the assertion in a procedure call, and then inspect the stack to get the source code for that line. The additional call would, unfortunately, introduce overhead into the test and would not be disabled with <code>-O</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like what you really want to do is to set up a debugger breakpoint just before the <code>assert</code> and inspect from your favorite debugger as much as you like.</p>
</div>
<div class="post-text" itemprop="text">
<p>I coded a replacement for <code>sys.excepthook</code> (which is called for any unhandled exception) which is a bit more fancy than the standard one. It will analyze the line where the exception occured and print all variables which are referred to in this line (it does not print all local variables because that might be too much noise - also, maybe the important var is global or so).</p>
<p>I called it py_better_exchook (perfect name) and it's <a href="https://github.com/albertz/py_better_exchook" rel="nofollow noreferrer">here</a>.</p>
<p>Example file:</p>
<pre><code>a = 6

def test():
    unrelated_var = 43
    b,c = 2, 3
    assert a - b*c

import better_exchook
better_exchook.install()

test()
</code></pre>
<p>Output:</p>
<pre><code>$ python test_error_reporting.py 
EXCEPTION
Traceback (most recent call last):
  File "test_error_reporting.py", line 12, in &lt;module&gt;
    line: test()
    locals:
      test = &lt;local&gt; &lt;function test at 0x7fd91b1a05f0&gt;
  File "test_error_reporting.py", line 7, in test
    line: assert a - b*c
    locals:
      a = &lt;global&gt; 6
      b = &lt;local&gt; 2
      c = &lt;local&gt; 3
AssertionError
</code></pre>
<p>There are a few other alternatives:</p>
<ul>
<li>(Presented here) <a href="https://github.com/albertz/py_better_exchook/" rel="nofollow noreferrer">https://github.com/albertz/py_better_exchook/</a></li>
<li><a href="https://github.com/patrys/great-justice" rel="nofollow noreferrer">https://github.com/patrys/great-justice</a></li>
<li>Nose does something similar for assertion failures, <a href="http://nose.readthedocs.io/en/latest/plugins/failuredetail.html" rel="nofollow noreferrer">see here</a>.</li>
<li>IPython has something similar (<a href="https://github.com/ipython/ipython/blob/master/IPython/core/ultratb.py" rel="nofollow noreferrer">this</a>). Do this: <code>from IPython.core import ultratb; sys.excepthook = ultratb.VerboseTB()</code>.</li>
<li>Ka-Ping Yee's "cgitb.py", which is part of Python, <a href="https://docs.python.org/3/library/cgitb.html" rel="nofollow noreferrer">see here</a>, <a href="https://github.com/python/cpython/blob/3.7/Lib/cgitb.py" rel="nofollow noreferrer">code here</a>.</li>
</ul>
</div>
<span class="comment-copy">Good. Now is there a Python library for this .. or do I have to write my own? :-) (I probably won't .. as this is a low-prio task for me)</span>
<span class="comment-copy">Unfortunately I don't know of existing Python libraries doing all of this, except ones oriented to testing (which might have to be adapted for the purpose of using them on production code).</span>
<span class="comment-copy">The question is regarding the use of assert in application code (which is directly invoked by the user, for eg., ./foo.py .. or clicking on 'foo.pyw' on Windows Explorer), and not test code .. for which I am actually happy with py.test's assert output.</span>
<span class="comment-copy">@srid: In this case write: <code>__debug__ and your_fancy_assert(expression)</code> -- no overhead on '-O'.</span>
<span class="comment-copy">That's sounds interesting; too bad Python doesn't have a <code>macro</code> feature.</span>
<span class="comment-copy">@SridharRatnakumar: it has (now) <a href="https://github.com/lihaoyi/macropy#smart-asserts" rel="nofollow noreferrer"><code>macropy</code></a></span>
<span class="comment-copy">For the introspection to work, you also need to leave out the optional <code>msg</code> parameter.</span>
<span class="comment-copy">Of course, I knew this. I don't want to write one as that is encoded in the expression that is being asserted. DRY.</span>
<span class="comment-copy">I see what you mean. I don't believe Python has a way to do this.</span>
<span class="comment-copy">Good enough for test cases, but for production code .. there is function call overhead (even with -O option)</span>
<span class="comment-copy">Ordinary asserts work too. See <a href="http://stackoverflow.com/questions/1308607/python-assert-improved-introspection-of-failure/1309039#1309039" title="python assert improved introspection of failure">stackoverflow.com/questions/1308607/…</a></span>
<span class="comment-copy">Precisely. It is disabling this 'introspection' on -O that is the key to the question.</span>
<span class="comment-copy">.. BUT this is not an overhead if this function is called only during assertion errors (not assertion calls).</span>
