<div class="post-text" itemprop="text">
<p>By which I mean a structure with:</p>
<ul>
<li>O(log n) complexity for <code>x.push()</code> operations</li>
<li>O(log n) complexity to find an element</li>
<li>O(n) complexity to compute <code>list(x)</code> which will be sorted</li>
</ul>
<p>I also had a related question about performance of <code>list(...).insert(...)</code> which is now <a href="https://stackoverflow.com/questions/1110332/performance-of-list-insert">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The standard Python list is not sorted in any form. The standard <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer">heapq</a> module can be used to append in O(log n) to an existing list and remove the smallest one in O(log n), but isn't a sorted list in your definition.</p>
<p>There are various implementations of balanced trees for Python that meet your requirements, e.g. <a href="http://pypi.python.org/pypi/rbtree/" rel="nofollow noreferrer">rbtree</a>, <a href="http://newcenturycomputers.net/projects/rbtree.html" rel="nofollow noreferrer">RBTree</a>, or <a href="http://sourceforge.net/projects/pyavl/" rel="nofollow noreferrer">pyavl</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Is there a particular reason for your big-O requirements? Or do you just want it to be fast? The <a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="noreferrer">sortedcontainers</a> module is pure-Python and fast (as in fast-as-C implementations like blist and rbtree).</p>
<p>The <a href="http://www.grantjenks.com/docs/sortedcontainers/performance.html" rel="noreferrer">performance comparison</a> shows it benchmarks faster or on par with blist's sorted list type. Note also that rbtree, RBTree, and PyAVL provide sorted dict and set types but don't have a sorted list type.</p>
<p>If performance is a requirement, always remember to benchmark. A module that substantiates the claim of being fast with Big-O notation should be suspect until it also shows benchmark comparisons.</p>
<p><strong>Disclaimer:</strong> I am the author of the Python sortedcontainers module.</p>
<hr/>
<p>Installation:</p>
<pre><code>pip install sortedcontainers
</code></pre>
<p>Usage:</p>
<pre><code>&gt;&gt;&gt; from sortedcontainers import SortedList
&gt;&gt;&gt; l = SortedList()
&gt;&gt;&gt; l.update([0, 4, 1, 3, 2])
&gt;&gt;&gt; l.index(3)
3
&gt;&gt;&gt; l.add(5)
&gt;&gt;&gt; l[-1]
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Though I have still never checked the "big O" speeds of basic Python list operations, 
the <code>bisect</code> standard module is probably also worth mentioning in this context:  </p>
<pre><code>import bisect
L = [0, 100]

bisect.insort(L, 50)
bisect.insort(L, 20)
bisect.insort(L, 21)

print L
## [0, 20, 21, 50, 100]

i = bisect.bisect(L, 20)
print L[i-1], L[i]
## 20, 21
</code></pre>
<p>PS. Ah, sorry, <code>bisect</code> is mentioned in the referenced question. Still, I think it won't be much harm if this information will be here )</p>
<p>PPS. And <a href="http://jjinux.blogspot.com/2008/03/pycon-core-python-containers-under-hood.html" rel="noreferrer">CPython lists are actually arrays</a> (not, say, skiplists or etc) . Well, I guess they have to be something simple, but as for me, the name is a little bit misleading.</p>
<hr/>
<p>So, if I am not mistaken, the bisect/list speeds would probably be:</p>
<ul>
<li>for a push(): O(n) for the worst case ;</li>
<li>for a search: if we consider the speed of array indexing to be O(1), search should be an O(log(n)) operation ;</li>
<li>for the list creation: O(n) should be the speed of the list copying, otherwise it's O(1) for the same list )  </li>
</ul>
<p><strong>Upd.</strong> Following a discussion in the comments, let me link here these SO questions: <a href="https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented">How is Python's List Implemented</a> and <a href="https://stackoverflow.com/questions/1005590/what-is-the-runtime-complexity-of-python-list-functions">What is the runtime complexity of python list functions</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Though it does not (yet) provide a custom search function, the <a href="http://docs.python.org/3.0/library/heapq.html" rel="noreferrer"><code>heapq</code></a> module may suit your needs. It implements a heap queue using a regular list. You'd have to write your own efficient membership test that makes use of the queue's internal structure (that can be done in <em>O(log n)</em>, I'd say...). There is one downside: extracting a sorted list has complexity <em>O(n log n)</em>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import bisect

class sortedlist(list):
    '''just a list but with an insort (insert into sorted position)'''
    def insort(self, x):
        bisect.insort(self, x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would use the <code>biscect</code> or <code>sortedcontainers</code> modules. I don't really am experienced, but I think the <code>heapq</code> module works. It contains a <code>Heap Queue</code></p>
</div>
<div class="post-text" itemprop="text">
<p>It may not be hard to implement your own sortlist on Python. Below is a proof of concept:</p>
<pre><code>import bisect

class sortlist:
    def __init__(self, list):
        self.list = list
        self.sort()
    def sort(self):
        l = []
        for i in range(len(self.list)):
            bisect.insort(l, self.list[i])
        self.list = l
        self.len = i
    def insert(self, value):
        bisect.insort(self.list, value)
        self.len += 1
    def show(self):
        print self.list
    def search(self,value):
        left = bisect.bisect_left(self.list, value)
        if abs(self.list[min([left,self.len-1])] - value) &gt;= abs(self.list[left-1] - value):
            return self.list[left-1]
        else:
            return self.list[left]

list = [101, 3, 10, 14, 23, 86, 44, 45, 45, 50, 66, 95, 17, 77, 79, 84, 85, 91, 73]
slist = sortlist(list)
slist.show()
slist.insert(99)
slist.show()
print slist.search(100000000)
print slist.search(0)
print slist.search(56.7)
</code></pre>
<p>========= Results ============</p>
<p>[3, 10, 14, 17, 23, 44, 45, 45, 50, 66, 73, 77, 79, 84, 85, 86, 91, 95, 101]</p>
<p>[3, 10, 14, 17, 23, 44, 45, 45, 50, 66, 73, 77, 79, 84, 85, 86, 91, 95, 99, 101]</p>
<p>101</p>
<p>3</p>
<p>50</p>
</div>
<span class="comment-copy"><code>memcpy</code> is still a <i>O(n)</i> operation. I am not sure how Python implements lists <i>exactly</i>, but my bet would be that they are stored in contiguous memory (certainly not as a linked list). If that is indeed so, the insertion using <code>bisect</code> which you demonstrate will have complexity <i>O(n)</i>.</span>
<span class="comment-copy">...and then the example was gone ;)</span>
<span class="comment-copy">@stephan202: Sorry, I thought it deserves a qeustion in itself as a completely separate issue!</span>
<span class="comment-copy">Sadly not out the box. But Grant Jenk's <a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="nofollow noreferrer">sortedcontainers</a> library is excellent. <a href="http://stackoverflow.com/a/22616929/284795">stackoverflow.com/a/22616929/284795</a></span>
<span class="comment-copy">+1 for rbtree, it works very well (but contains native code; not pure python, not so easy to deploy perhaps)</span>
<span class="comment-copy"><a href="http://www.grantjenks.com/docs/sortedcontainers/" rel="nofollow noreferrer">sortedcontainers</a> is pure-Python and fast-as-C (like rbtree) with a performance comparison.</span>
<span class="comment-copy">"isn't a sorted list in your definition." How so?</span>
<span class="comment-copy">heapq only allows to find the smallest element; the OP was asking for a structure that can find any element in O(log n), which heaps are not.</span>
<span class="comment-copy">Indeed I compared sortedcontainers against bisect: <code>0.0845024989976</code> for SortedList.add() vs <code>0.596589182518</code> for bisect.insort(), thus a difference of 7x in speed! And I expect the speed gap to increase with the list length since sortedcontainers insertion sort works in O(log n) while bisect.insort() in O(n).</span>
<span class="comment-copy">@gaborous because bisect still uses a list, so the insertion remains <code>O(n)</code></span>
<span class="comment-copy">push() should be in O(log n) since the list is already sorted.</span>
<span class="comment-copy">may be I should have said <a href="http://docs.python.org/library/bisect.html#bisect.insort_left" rel="nofollow noreferrer">"for an insert op"</a>. anyway, that was about a year ago so now I can easily mix things up or miss something</span>
<span class="comment-copy">You can always insert a value into a sorted list in O(log n), see binary search. push() is defined as an insert operation.</span>
<span class="comment-copy">True. But while <i>finding</i> the insert location would indeed take O(log n) ops, the actual insert (i.e. adding the element to the data structure) probably depends on that structure (think inserting an element in a sorted array). And as <a href="http://www.laurentluce.com/posts/python-list-implementation/" rel="nofollow noreferrer">Python lists are actually arrays</a>, this may take O(n). Due to the size limit for the comments, I will link two related SO questions from the text of the answer (see above).</span>
<span class="comment-copy">Good argument. I wasn't aware list where handled as arrays in Python.</span>
<span class="comment-copy">It's nice but hard to bisect.</span>
<span class="comment-copy">How can there be an O(log n) membership test in a heap? If you are looking for value x, you can stop looking down a branch if you find something larger than x, but for a random value of x it is 50% likely to be at a leaf, and you probably can't prune much.</span>
