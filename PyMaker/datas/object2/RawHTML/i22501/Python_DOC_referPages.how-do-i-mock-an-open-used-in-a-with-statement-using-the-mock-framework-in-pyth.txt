<div class="post-text" itemprop="text">
<p>How do I test the following code with mocks (using mocks, the patch decorator and sentinels provided by <a href="http://www.voidspace.org.uk/python/mock/" rel="noreferrer">Michael Foord's Mock framework</a>):</p>
<pre><code>def testme(filepath):
    with open(filepath, 'r') as f:
        return f.read()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The way to do this has changed in mock 0.7.0 which finally supports mocking the python protocol methods (magic methods), particularly using the MagicMock:</p>
<p><a href="http://www.voidspace.org.uk/python/mock/magicmock.html">http://www.voidspace.org.uk/python/mock/magicmock.html</a></p>
<p>An example of mocking open as a context manager (from the examples page in the mock documentation):</p>
<pre><code>&gt;&gt;&gt; open_name = '%s.open' % __name__
&gt;&gt;&gt; with patch(open_name, create=True) as mock_open:
...     mock_open.return_value = MagicMock(spec=file)
...
...     with open('/some/path', 'w') as f:
...         f.write('something')
...
&lt;mock.Mock object at 0x...&gt;
&gt;&gt;&gt; file_handle = mock_open.return_value.__enter__.return_value
&gt;&gt;&gt; file_handle.write.assert_called_with('something')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is lot of noise in these answers; almost all are correct but outdated and not neat. <a href="https://docs.python.org/3/library/unittest.mock.html#mock-open" rel="noreferrer"><code>mock_open</code></a> is part of <a href="https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock" rel="noreferrer"><code>mock</code></a> framework and is very simple to use. <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="noreferrer"><code>patch</code></a> used as context returns the object used to replace the patched one: you can use it to make your test simpler.</p>
<h1>Python 3.x</h1>
<p>Use <code>builtins</code> instead of <code>__builtin__</code>.</p>
<pre><code>from unittest.mock import patch, mock_open
with patch("builtins.open", mock_open(read_data="data")) as mock_file:
    assert open("path/to/open").read() == "data"
    mock_file.assert_called_with("path/to/open")
</code></pre>
<h1>Python 2.7</h1>
<p><code>mock</code> is not part of <code>unittest</code> and you should patch <code>__builtin__</code></p>
<pre><code>from mock import patch, mock_open
with patch("__builtin__.open", mock_open(read_data="data")) as mock_file:
    assert open("path/to/open").read() == "data"
    mock_file.assert_called_with("path/to/open")
</code></pre>
<h1>Decorator case</h1>
<p>If you would use <code>patch</code> as decorator using <code>mock_open()</code>'s result as the <code>new</code> <code>patch</code>'s argument can be a little bit weird. </p>
<p>In this case is better to use the <code>new_callable</code> <code>patch</code>'s argument and remember that every extra arguments that <code>patch</code> doesn't use will be passed to <code>new_callable</code> function as described in <a href="https://docs.python.org/3/library/unittest.mock.html#patch" rel="noreferrer"><code>patch</code> documentation</a>.</p>
<blockquote>
<p>patch() takes arbitrary keyword arguments. These will be passed to the Mock (or new_callable) on construction.</p>
</blockquote>
<p>For instance decorated version for <strong>Python 3.x</strong> is:</p>
<pre><code>@patch("builtins.open", new_callable=mock_open, read_data="data")
def test_patch(mock_file):
    assert open("path/to/open").read() == "data"
    mock_file.assert_called_with("path/to/open")
</code></pre>
<p>Remember that in this case <code>patch</code> will add the mock object as argument of you test function.</p>
</div>
<div class="post-text" itemprop="text">
<p>With the latest versions of mock, you can use the really useful <a href="http://www.voidspace.org.uk/python/mock/helpers.html#mock-open">mock_open</a> helper:</p>
<blockquote>
<p><strong>mock_open(mock=None, read_data=None)</strong> </p>
<p>A helper function to create a
  mock to replace the use of open. It works for open called directly or
  used as a context manager.</p>
<p>The mock argument is the mock object to configure. If None (the
  default) then a MagicMock will be created for you, with the API
  limited to methods or attributes available on standard file handles.</p>
<p>read_data is a string for the read method of the file handle to
  return. This is an empty string by default.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; from mock import mock_open, patch
&gt;&gt;&gt; m = mock_open()
&gt;&gt;&gt; with patch('{}.open'.format(__name__), m, create=True):
...    with open('foo', 'w') as h:
...        h.write('some stuff')

&gt;&gt;&gt; m.assert_called_once_with('foo', 'w')
&gt;&gt;&gt; handle = m()
&gt;&gt;&gt; handle.write.assert_called_once_with('some stuff')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To use <a href="https://docs.python.org/3.3/library/unittest.mock.html#mock-open" rel="nofollow noreferrer">mock_open</a> for a simple file <code>read()</code> (the original mock_open snippet <a href="https://stackoverflow.com/a/19146253/552793">already given on this page</a> is geared more for write):</p>
<pre><code>my_text = "some text to return when read() is called on the file object"
mocked_open_function = mock.mock_open(read_data=my_text)

with mock.patch("__builtin__.open", mocked_open_function):
    with open("any_string") as f:
        print f.read()
</code></pre>
<p>Note as per docs for mock_open, this is specifically for <code>read()</code>, so won't work with common patterns like <code>for line in f</code>, for example.</p>
<p>Uses python 2.6.6 / mock 1.0.1</p>
</div>
<div class="post-text" itemprop="text">
<p>I might be a bit late to the game, but this worked for me when calling <code>open</code> in another module without having to create a new file.</p>
<p>test.py</p>
<pre><code>import unittest
from mock import Mock, patch, mock_open
from MyObj import MyObj

class TestObj(unittest.TestCase):
    open_ = mock_open()
    with patch.object(__builtin__, "open", open_):
        ref = MyObj()
        ref.save("myfile.txt")
    assert open_.call_args_list == [call("myfile.txt", "wb")]
</code></pre>
<p>MyObj.py</p>
<pre><code>class MyObj(object):
    def save(self, filename):
        with open(filename, "wb") as f:
            f.write("sample text")
</code></pre>
<p>By patching the <code>open</code> function inside the <code>__builtin__</code> module to my <code>mock_open()</code>, I can mock writing to a file without creating one.</p>
<p>Note: If you are using a module that uses cython, or your program depends on cython in any way, you will need to import <a href="https://docs.python.org/2/library/__builtin__.html" rel="nofollow">cython's <code>__builtin__</code> module</a> by including <code>import __builtin__</code> at the top of your file. You will not be able to mock the universal <code>__builtin__</code> if you are using cython.</p>
</div>
<div class="post-text" itemprop="text">
<p>The top answer is useful but I expanded on it a bit.</p>
<p>If you want to set the value of your file object (the <code>f</code> in <code>as f</code>) based on the arguments passed to <code>open()</code> here's one way to do it:</p>
<pre><code>def save_arg_return_data(*args, **kwargs):
    mm = MagicMock(spec=file)
    mm.__enter__.return_value = do_something_with_data(*args, **kwargs)
    return mm
m = MagicMock()
m.side_effect = save_arg_return_array_of_data

# if your open() call is in the file mymodule.animals 
# use mymodule.animals as name_of_called_file
open_name = '%s.open' % name_of_called_file

with patch(open_name, m, create=True):
    #do testing here
</code></pre>
<p>Basically, <code>open()</code> will return an object and <code>with</code> will call <code>__enter__()</code> on that object.</p>
<p>To mock properly, we must mock <code>open()</code> to return a mock object. That mock object should then mock the <code>__enter__()</code> call on it (<code>MagicMock</code> will do this for us) to return the mock data/file object we want (hence <code>mm.__enter__.return_value</code>). Doing this with 2 mocks the way above allows us to capture the arguments passed to <code>open()</code> and pass them to our <code>do_something_with_data</code> method.</p>
<p>I passed an entire mock file as a string to <code>open()</code> and my <code>do_something_with_data</code> looked like this:</p>
<pre><code>def do_something_with_data(*args, **kwargs):
    return args[0].split("\n")
</code></pre>
<p>This transforms the string into a list so you can do the following as you would with a normal file:</p>
<pre><code>for line in file:
    #do action
</code></pre>
</div>
<span class="comment-copy">@Daryl Spitzer: could you leave off the meta-question ("I know the answer...")  It's confusing.</span>
<span class="comment-copy">In the past when I've left it off, people have complained that I'm answering my own question.  I'll try moving that to my answer.</span>
<span class="comment-copy">@Daryl: The best way to avoid complaints about answering one's own question, which usually stem from worries of "karma whoring", is to mark the question and/or answer as a "community wiki".</span>
<span class="comment-copy">If answering your own question is considered Karma Whoring, the FAQ should be clarified on that point I think.</span>
<span class="comment-copy"><a href="http://meta.stackexchange.com/questions/15007/why-could-it-be-considered-gaming-the-system-if-you-answer-your-own-question" title="why could it be considered gaming the system if you answer your own question">meta.stackexchange.com/questions/15007/â€¦</a></span>
<span class="comment-copy">The "latter approach" is showing how to do it <i>without</i> using a MagicMock (i.e. it is just an example of how Mock supports magic methods). If you use a MagicMock (as above) then <b>enter</b> and <b>exit</b> are preconfigured for you.</span>
<span class="comment-copy">you could point to your <a href="http://www.voidspace.org.uk/python/weblog/arch_d7_2010_10_02.shtml#e1188" rel="nofollow noreferrer">blog post</a> where you explain in more details why/how that works</span>
<span class="comment-copy">This should be the accepted answer.</span>
<span class="comment-copy">In Python 3, 'file' is not defined (used in the MagicMock spec), so I'm using io.IOBase instead.</span>
<span class="comment-copy">Note: in Python3 the builtin <code>file</code> is gone!</span>
<span class="comment-copy">Sorry for asking, can the <code>with patch("builtins.open", mock_open(read_data="data")) as mock_file:</code> be converted into decorator syntax? I've tried, but I am not sure what I need to pass into <code>@patch("builtins.open", ...)</code>  as second argument.</span>
<span class="comment-copy">@DrunkenMaster Updateted.. thanks for pointed it. Using decorator is not trivial in this case.</span>
<span class="comment-copy">Grazie! My problem was a bit more complex (I had to channel the <code>return_value</code> of <code>mock_open</code> into another mock object and assert the second mock's <code>return_value</code>), but it worked by adding <code>mock_open</code> as <code>new_callable</code>.</span>
<span class="comment-copy">@ArthurZopellaro take a look to <code>six</code> module to have a consistent <code>mock</code> module. But I don't know if it map also <code>builtins</code> in a common module.</span>
<span class="comment-copy">How do you find the correct name to patch? I.e. how do yo find the first argument to @patch ('builtins.open' in this case) for an arbitrary function?</span>
<span class="comment-copy">how do you check if there are multiple <code>.write</code> calls?</span>
<span class="comment-copy">@naxa One way is to pass each expected parameter to <code>handle.write.assert_any_call()</code>. You can also use <code>handle.write.call_args_list</code> to get each call if the order is important.</span>
<span class="comment-copy"><code>m.return_value.write.assert_called_once_with('some stuff')</code> is better imo. Avoids registering a call.</span>
<span class="comment-copy">Manually asserting about <code>Mock.call_args_list</code> is safer than calling any of the <code>Mock.assert_xxx</code>, methods. If you mis-spell any of the latter, being attributes of Mock, they will always silently pass.</span>
<span class="comment-copy">Looks good, but I can't get it to work with <code>for line in opened_file:</code> type of code. I tried experimenting with iterable StringIO that implements <code>__iter__</code> and using that instead of <code>my_text</code>, but no luck.</span>
<span class="comment-copy">@EvgeniiPuchkaryov This works specifically for <code>read()</code> so won't work in your <code>for line in opened_file</code> case; I've edited the post to clarify</span>
<span class="comment-copy">@EvgeniiPuchkaryov <code>for line in f:</code> support can be achieved by mocking the return value of <code>open()</code> as <a href="http://stackoverflow.com/a/24325868/696485">a StringIO object instead</a>.</span>
<span class="comment-copy">To clarify, the system under test (SUT) in this example is:     <code>with open("any_string") as f:         print f.read()</code></span>
<span class="comment-copy">A variation of this approached worked for me, as the majority of the code under test was in other modules as shown here.  I did need to make sure to add <code>import __builtin__</code> to my test module.  This article helped clarify why this technique works as well as it does: <a href="http://www.ichimonji10.name/blog/6/" rel="nofollow noreferrer">ichimonji10.name/blog/6</a></span>
<span class="comment-copy">If the code being tested handles the file in a different way, for example by calling its function "readline", you can return any mock object you want in the function "do_something_with_data" with the desired attributes.</span>
