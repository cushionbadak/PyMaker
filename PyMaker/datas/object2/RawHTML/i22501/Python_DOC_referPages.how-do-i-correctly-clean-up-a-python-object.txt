<div class="post-text" itemprop="text">
<pre><code>class Package:
    def __init__(self):
        self.files = []

    # ...

    def __del__(self):
        for file in self.files:
            os.unlink(file)
</code></pre>
<p><code>__del__(self)</code> above fails with an AttributeError exception.  I understand <a href="http://docs.python.org/reference/datamodel.html#customization" rel="noreferrer">Python doesn't guarantee</a> the existence of "global variables" (member data in this context?) when <code>__del__()</code> is invoked.  If that is the case and this is the reason for the exception, how do I make sure the object destructs properly?</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd recommend using Python's <code>with</code> statement for managing resources that need to be cleaned up.  The problem with using an explicit <code>close()</code> statement is that you have to worry about people forgetting to call it at all or forgetting to place it in a <code>finally</code> block to prevent a resource leak when an exception occurs.</p>
<p>To use the <code>with</code> statement, create a class with the following methods:</p>
<pre><code>  def __enter__(self)
  def __exit__(self, exc_type, exc_value, traceback)
</code></pre>
<p>In your example above, you'd use </p>
<pre><code>class Package:
    def __init__(self):
        self.files = []

    def __enter__(self):
        return self

    # ...

    def __exit__(self, exc_type, exc_value, traceback):
        for file in self.files:
            os.unlink(file)
</code></pre>
<p>Then, when someone wanted to use your class, they'd do the following:</p>
<pre><code>with Package() as package_obj:
    # use package_obj
</code></pre>
<p>The variable package_obj will be an instance of type Package (it's the value returned by the <code>__enter__</code> method).  Its <code>__exit__</code> method will automatically be called, regardless of whether or not an exception occurs.</p>
<p>You could even take this approach a step further.  In the example above, someone could still instantiate Package using its constructor without using the <code>with</code> clause.  You don't want that to happen.  You can fix this by creating a PackageResource class that defines the <code>__enter__</code> and <code>__exit__</code> methods.  Then, the Package class would be defined strictly inside the <code>__enter__</code> method and returned.  That way, the caller never could instantiate the Package class without using a <code>with</code> statement:</p>
<pre><code>class PackageResource:
    def __enter__(self):
        class Package:
            ...
        self.package_obj = Package()
        return self.package_obj

    def __exit__(self, exc_type, exc_value, traceback):
        self.package_obj.cleanup()
</code></pre>
<p>You'd use this as follows:</p>
<pre><code>with PackageResource() as package_obj:
    # use package_obj
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The standard way is to use <a href="https://docs.python.org/3/library/atexit.html#atexit.register" rel="noreferrer"><code>atexit.register</code></a>:</p>
<pre><code># package.py
import atexit
import os

class Package:
    def __init__(self):
        self.files = []
        atexit.register(self.cleanup)

    def cleanup(self):
        print("Running cleanup...")
        for file in self.files:
            print("Unlinking file: {}".format(file))
            # os.unlink(file)
</code></pre>
<p>But you should keep in mind that this will persist all created instances of <code>Package</code> until Python is terminated.</p>
<p>Demo using the code above saved as <em>package.py</em>:</p>
<pre><code>$ python
&gt;&gt;&gt; from package import *
&gt;&gt;&gt; p = Package()
&gt;&gt;&gt; q = Package()
&gt;&gt;&gt; q.files = ['a', 'b', 'c']
&gt;&gt;&gt; quit()
Running cleanup...
Unlinking file: a
Unlinking file: b
Unlinking file: c
Running cleanup...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an appendix to <a href="https://stackoverflow.com/a/865272/321973">Clint's answer</a>, you can simplify <code>PackageResource</code> using <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="noreferrer"><code>contextlib.contextmanager</code></a>:</p>
<pre><code>@contextlib.contextmanager
def packageResource():
    class Package:
        ...
    package = Package()
    yield package
    package.cleanup()
</code></pre>
<p>Alternatively, though probably not as Pythonic, you can override <code>Package.__new__</code>:</p>
<pre><code>class Package(object):
    def __new__(cls, *args, **kwargs):
        @contextlib.contextmanager
        def packageResource():
            # adapt arguments if superclass takes some!
            package = super(Package, cls).__new__(cls)
            package.__init__(*args, **kwargs)
            yield package
            package.cleanup()

    def __init__(self, *args, **kwargs):
        ...
</code></pre>
<p>and simply use <code>with Package(...) as package</code>.</p>
<p>To get things shorter, name your cleanup function <code>close</code> and use <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing" rel="noreferrer"><code>contextlib.closing</code></a>, in which case you can either use the unmodified <code>Package</code> class via <code>with contextlib.closing(Package(...))</code> or override its <code>__new__</code> to the simpler</p>
<pre><code>class Package(object):
    def __new__(cls, *args, **kwargs):
        package = super(Package, cls).__new__(cls)
        package.__init__(*args, **kwargs)
        return contextlib.closing(package)
</code></pre>
<p>And this constructor is inherited, so you can simply inherit, e.g.</p>
<pre><code>class SubPackage(Package):
    def close(self):
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think that it's possible for instance members to be removed before <code>__del__</code> is called. My guess would be that the reason for your particular AttributeError is somewhere else (maybe you mistakenly remove self.file elsewhere).</p>
<p>However, as the others pointed out, you should avoid using <code>__del__</code>. The main reason for this is that instances with <code>__del__</code> will not be garbage collected (they will only be freed when their refcount reaches 0). Therefore, if your instances are involved in circular references, they will live in memory for as long as the application run. (I may be mistaken about all this though, I'd have to read the gc docs again, but I'm rather sure it works like this).</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem could be in <code>__init__</code> if there is more code than shown?</p>
<p><code>__del__</code> will be called even when <code>__init__</code> has not been executed properly or threw an exception.</p>
<p><a href="http://www.algorithm.co.il/blogs/programming/python-gotchas-1-__del__-is-not-the-opposite-of-__init__/" rel="nofollow noreferrer">Source</a></p>
</div>
<div class="post-text" itemprop="text">
<p>A better alternative is to use <a href="https://docs.python.org/3.6/library/weakref.html#weakref.finalize" rel="noreferrer">weakref.finalize</a>. See the examples at <a href="https://docs.python.org/3.6/library/weakref.html#finalizer-objects" rel="noreferrer">Finalizer Objects</a> and <a href="https://docs.python.org/3.6/library/weakref.html#comparing-finalizers-with-del-methods" rel="noreferrer">Comparing finalizers with __del__() methods</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just wrap your destructor with a try/except statement and it will not throw an exception if your globals are already disposed of.</p>
<p><strong>Edit</strong></p>
<p>Try this:</p>
<pre><code>from weakref import proxy

class MyList(list): pass

class Package:
    def __init__(self):
        self.__del__.im_func.files = MyList([1,2,3,4])
        self.files = proxy(self.__del__.im_func.files)

    def __del__(self):
        print self.__del__.im_func.files
</code></pre>
<p>It will stuff the file list in the <strong>del</strong> function that is guaranteed to exist at the time of call. The weakref proxy is to prevent Python, or yourself from deleting the self.files variable somehow (if it is deleted, then it will not affect the original file list). If it is not the case that this is being deleted even though there are more references to the variable, then you can remove the proxy encapsulation.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems that the idiomatic way to do this is to provide a <code>close()</code> method (or similar), and call it explicitely.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a minimal working skeleton:</p>
<pre><code>class SkeletonFixture:

    def __init__(self):
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def method(self):
        pass


with SkeletonFixture() as fixture:
    fixture.method()
</code></pre>
<p>Important: <strong>return self</strong></p>
<hr/>
<p>If you're like me, and overlook the <code>return self</code> part (of <a href="https://stackoverflow.com/a/865272/2394284">Clint Miller's correct answer</a>), you will be staring at this nonsense:</p>
<pre><code>Traceback (most recent call last):
  File "tests/simplestpossible.py", line 17, in &lt;module&gt;                                                                                                                                                          
    fixture.method()                                                                                                                                                                                              
AttributeError: 'NoneType' object has no attribute 'method'
</code></pre>
<p>I spent half a day on this. Hope it helps the next person.</p>
</div>
<span class="comment-copy">Reading what you linked, global variables going away doesn't seem to apply here unless you're talking about when you program is exiting, during which I guess according to what you linked it might be POSSIBLE that the os module itself is already gone.  Otherwise, I don't think it applies to member variables in a __del__() method.</span>
<span class="comment-copy">The exception is thrown long before my program exits.  The AttributeError exception I get is Python saying it doesn't recognize self.files as being an attribute of Package.  I may be getting this wrong, but if by "globals" they don't mean variables global to methods (but possibly local to class) then I don't know what causes this exception.  Google hints Python reserves the right to clean up member data before __del__(self) is called.</span>
<span class="comment-copy">The code as posted seems to work for me (with Python 2.5). Can you post the actual code that is failing - or a simplified (the simpler the better version that still causes the error?</span>
<span class="comment-copy">@ wilhelmtell can you give a more concrete example? In all my tests, the <b>del</b> destructor works perfectly.</span>
<span class="comment-copy">If anyone wants to know: <a href="http://www.algorithm.co.il/blogs/programming/python-gotchas-1-__del__-is-not-the-opposite-of-__init__/" rel="nofollow noreferrer">This article</a> elaborates why <code>__del__</code> should not be used as the counterpart of <code>__init__</code>. (I.e., it is not a "destructor" in the sense that <code>__init__</code> is a constructor.</span>
<span class="comment-copy">Technically speaking, one could call PackageResource().__enter__() explicitly and thus create a Package that would never be finalized... but they'd really have to be trying to break the code. Probably not something to worry about.</span>
<span class="comment-copy">By the way, if you're using Python 2.5, you'll need to do    from <b>future</b> import with_statement  to be able to use the with statement.</span>
<span class="comment-copy">I found an article which helps to show why __del__() acts the way it does and give credence to using a context manager solution: <a href="http://www.andy-pearce.com/blog/posts/2013/Apr/python-destructor-drawbacks/" rel="nofollow noreferrer">andy-pearce.com/blog/posts/2013/Apr/python-destructor-drawbacks</a></span>
<span class="comment-copy">How to use that nice and clean construct if you want to pass parameters? I would like to be able to do <code>with Resource(param1, param2) as r: # ...</code></span>
<span class="comment-copy">@snooze92 you could give the Resource an __init__ method that stores *args and **kwargs in self, and then passes them on to the inner class in the enter method. When using the with statement, __init__ is called before __enter__</span>
<span class="comment-copy">The nice thing about the atexit.register approach is you don't have to worry about what the user of the class does (did they use <code>with</code>? did they explicitly call <code>__enter__</code>?) The downside is of course if you need the cleanup to happen before python exits, it won't work. In my case, I don't care if it is when the object goes out of scope or if it isn't until python exits. :)</span>
<span class="comment-copy"><b>This is awesome.</b> I particularly like the last example. It's unfortunate that we can't avoid the four-line boilerplate of the <code>Package.__new__()</code> method, however. <i>Or maybe we can.</i> We could probably define either a class decorator or metaclass genericizing that boilerplate for us. Food for Pythonic thought.</span>
<span class="comment-copy">@CecilCurry Thanks, and good point. Any class inheriting from <code>Package</code> should also do this (though I haven't tested that yet), so no metaclass should be required. Though I <i>have</i> found some pretty curious ways to use metaclasses in the past...</span>
<span class="comment-copy">@CecilCurry Actually, the constructor is inherited, so you can use <code>Package</code> (or better a class named <code>Closing</code>) as your class parent instead of <code>object</code>. But don't ask me how multiple inheritance messes up with this...</span>
<span class="comment-copy">Objects with <code>__del__</code> can be garbage collected if their reference count from other objects with <code>__del__</code> is zero and they are unreachable. This means if you have a reference cycle between objects with <code>__del__</code>, none of those will be collected. Any other case, however, should be resolved as expected.</span>
<span class="comment-copy">Sounds very likely. The best way to avoid this problem when using <code>__del__</code> is to explicitly declare all members at class-level, ensuring that they always exist, even if <code>__init__</code> fails. In the given example, <code>files = ()</code> would work, though mostly you'd just assign <code>None</code>; in either case, you still need to assign the real value in <code>__init__</code>.</span>
<span class="comment-copy">Used this today and it works flawlessly, better than other solutions. I have multiprocessing-based communicator class which opens a serial port and then I have a <code>stop()</code> method to close the ports and <code>join()</code> the processes. However, if the programs exits unexpectedly <code>stop()</code> is not called - I solved that with a finalizer. But in any case I call <code>_finalizer.detach()</code> in the stop method to prevent calling it twice (manually and later again by the finalizer).</span>
<span class="comment-copy">IMO, this is really the best answer. It combines the possibility of cleaning up at garbage collection with the possibility of cleaning up at exit. The caveat is that python 2.7 doesn't have weakref.finalize.</span>
<span class="comment-copy">The problem is that if the member data is gone it's too late for me.  I need that data.  See my code above:  I need the filenames to know which files to remove.  I simplified my code though, there are other data I need to clean up myself (i.e. the interpreter won't know how to clean).</span>
<span class="comment-copy">This solution worked remarkably well in my case.</span>
<span class="comment-copy">This is the approach I used before, but I ran into other problems with it.  With exceptions thrown all over the place by other libraries, I need Python's help in cleaning up the mess in the case of an error.  Specifically, I need Python to call the destructor for me, because otherwise the code becomes quickly unmanageable, and I will surely forget an exit-point where a call to .close() should be.</span>
