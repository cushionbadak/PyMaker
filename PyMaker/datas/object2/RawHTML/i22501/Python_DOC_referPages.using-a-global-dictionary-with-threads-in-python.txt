<div class="post-text" itemprop="text">
<p>Is accessing/changing dictionary values thread-safe?</p>
<p>I have a global dictionary <code>foo</code> and multiple threads with ids <code>id1</code>, <code>id2</code>, ... , <code>idn</code>. Is it OK to access and change <code>foo</code>'s values without allocating a lock for it if it's known that each thread will only work with its id-related value, say thread with <code>id1</code> will only work with <code>foo[id1]</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming CPython: Yes and no. It is actually safe to fetch/store values from a shared dictionary in the sense that multiple concurrent read/write requests won't corrupt the dictionary. This is due to the global interpreter lock ("GIL") maintained by the implementation. That is:</p>
<p>Thread A running:</p>
<pre><code>a = global_dict["foo"]
</code></pre>
<p>Thread B running:</p>
<pre><code>global_dict["bar"] = "hello"
</code></pre>
<p>Thread C running:</p>
<pre><code>global_dict["baz"] = "world"
</code></pre>
<p>won't corrupt the dictionary, even if all three access attempts happen at the "same" time. The interpreter will serialize them in some undefined way.</p>
<p>However, the results of the following sequence is undefined:</p>
<p>Thread A:</p>
<pre><code>if "foo" not in global_dict:
   global_dict["foo"] = 1
</code></pre>
<p>Thread B: </p>
<pre><code>global_dict["foo"] = 2
</code></pre>
<p>as the test/set in thread A is not atomic ("time-of-check/time-of-use" race condition). So, it is generally best, if you lock things:</p>
<pre><code>from threading import RLock

lock = RLock()

def thread_A():
    lock.acquire()
    try:
        if "foo" not in global_dict:
            global_dict["foo"] = 1
    finally:
        lock.release()

def thread_B():
    lock.acquire()
    try:
        global_dict["foo"] = 2
    finally:
        lock.release()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best, safest, portable way to have each thread work with independent data is:</p>
<pre><code>import threading
tloc = threading.local()
</code></pre>
<p>Now each thread works with a totally independent <code>tloc</code> object even though it's a global name. The thread can get and set attributes on <code>tloc</code>, use <code>tloc.__dict__</code> if it specifically needs a dictionary, etc.</p>
<p>Thread-local storage for a thread goes away at end of thread; to have threads record their final results, have them <code>put</code> their results, before they terminate, into a common instance of <code>Queue.Queue</code> (which is intrinsically thread-safe). Similarly, initial values for data a thread is to work on could be arguments passed when the thread is started, or be taken from a <code>Queue</code>.</p>
<p>Other half-baked approaches, such as hoping that operations that look atomic are indeed atomic, may happen to work for specific cases in a given version and release of Python, but could easily get broken by upgrades or ports. There's no real reason to risk such issues when a proper, clean, safe architecture is so easy to arrange, portable, handy, and fast.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since I needed something similar, I landed here. I sum up your answers in this short snippet :</p>
<pre><code>#!/usr/bin/env python3

import threading

class ThreadSafeDict(dict) :
    def __init__(self, * p_arg, ** n_arg) :
        dict.__init__(self, * p_arg, ** n_arg)
        self._lock = threading.Lock()

    def __enter__(self) :
        self._lock.acquire()
        return self

    def __exit__(self, type, value, traceback) :
        self._lock.release()

if __name__ == '__main__' :

    u = ThreadSafeDict()
    with u as m :
        m[1] = 'foo'
    print(u)
</code></pre>
<p>as such, you can use the <code>with</code> construct to hold the lock while fiddling in your <code>dict()</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://docs.python.org/glossary.html?highlight=gil#term-global-interpreter-lock" rel="nofollow noreferrer">GIL</a> takes care of that, if you happen to be using <code>CPython</code>.</p>
<blockquote>
<p><strong>global interpreter lock</strong></p>
<p>The lock used by Python threads to assure that only one thread executes in the CPython virtual machine at a time. This simplifies the CPython implementation by assuring that no two processes can access the same memory at the same time. Locking the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of much of the parallelism afforded by multi-processor machines. Efforts have been made in the past to create a “free-threaded” interpreter (one which locks shared data at a much finer granularity), but so far none have been successful because performance suffered in the common single-processor case.</p>
</blockquote>
<p>See <a href="https://stackoverflow.com/questions/105095/are-locks-unnecessary-in-multi-threaded-python-code-because-of-the-gil">are-locks-unnecessary-in-multi-threaded-python-code-because-of-the-gil</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>How it works?:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; demo = {}
&gt;&gt;&gt; def set_dict():
...     demo['name'] = 'Jatin Kumar'
...
&gt;&gt;&gt; dis.dis(set_dict)
  2           0 LOAD_CONST               1 ('Jatin Kumar')
              3 LOAD_GLOBAL              0 (demo)
              6 LOAD_CONST               2 ('name')
              9 STORE_SUBSCR
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE
</code></pre>
<p>Each of the above instructions is executed with GIL lock hold and <a href="https://docs.python.org/3/library/dis.html#opcode-STORE_SUBSCR" rel="nofollow">STORE_SUBSCR</a> instruction adds/updates the key+value pair in a dictionary. So you see that dictionary update is atomic and hence thread safe.</p>
</div>
<span class="comment-copy">You <b>are</b> using CPython, right?</span>
<span class="comment-copy">@voyager: yes, I'm using CPython.</span>
<span class="comment-copy">Would <code>global_dict.setdefault("foo", 1)</code> in <code>Thread A</code> make the need for a lock unnecessary?</span>
<span class="comment-copy">Am I understanding this correctly. As long as im adding to the dictionary without modification, it is safe. ie dict['a'] = 1 in thread a and dict['b'] = 2 in thread b is okay because keys a and b are not the same?</span>
<span class="comment-copy">@user1048138 -- No. What's safe and what's not depends on your application. Think about a class, which has the fields <code>a</code> and <code>b</code> and the invariant, that exactly one of those fields is not <code>None</code> and the other is <code>None</code>. Unless access is properly interlocked, any random combination of <code>a is [not] None</code> and <code>b is [not] None</code> may be observable in clear violation of the invariant, if only a "naive" getter/setter is used (think: <code>def set_a(self,a): self.a = a; self.b =  None if a is not None else self.b</code> -- a concurrent thread may observe illegal states during the execution)</span>
<span class="comment-copy">is there a way for me to place the lock on the dictionary datastructure's write/update/delete?</span>
<span class="comment-copy">@Claudiu: <code>setdefault</code> will initialize atomically in CPython if the key is composed entirely of builtins implemented in C. The GIL protects you from races so long as the mutating part of an operation occurs with no byte codes in between beginning the mutation and completing it, and in the case of key insertion, you get that behavior when the <code>__eq__</code> and <code>__hash__</code> of an object are implemented in C, not Python level code.</span>
<span class="comment-copy">That only concerns CPython though.</span>
<span class="comment-copy">Unless he happens to be using Jython or IronPython.</span>
<span class="comment-copy">@Bastien Léonard: Beat me to it :)</span>
<span class="comment-copy">This doesn't mean that you can rely on the GIL. The key could be an instance of a class with a <code>__hash__</code>  method, so more than 1 Python bytecode instruction is executed and the thread can switch <i>anyway</i>. Then there are I/O operations and native code sections that release the GIL. Locks are still very much a requirement for thread-safe code.</span>
