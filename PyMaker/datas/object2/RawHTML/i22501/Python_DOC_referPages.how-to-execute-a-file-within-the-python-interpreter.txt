<div class="post-text" itemprop="text">
<p>I'm trying to execute a file with python commands from within the interpreter. </p>
<p>EDIT: I'm trying to use variables and settings from that file, not to invoke a separate process.</p>
</div>
<div class="post-text" itemprop="text">
<p>Several ways.</p>
<p>From the shell</p>
<pre><code>python someFile.py
</code></pre>
<p>From inside IDLE, hit <strong>F5</strong>.</p>
<p>If you're typing interactively, try this.</p>
<pre><code>&gt;&gt;&gt; variables= {}
&gt;&gt;&gt; execfile( "someFile.py", variables )
&gt;&gt;&gt; print variables # globals from the someFile module
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>For Python 2:</strong></p>
<pre><code>&gt;&gt;&gt; execfile('filename.py')
</code></pre>
<p><strong>For Python 3:</strong></p>
<pre><code>&gt;&gt;&gt; exec(open("filename.py").read())
</code></pre>
<p>See <a href="http://docs.python.org/library/functions.html#execfile" rel="noreferrer">the documentation</a>. If you are using Python 3.0, see <a href="https://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3-0">this question</a>.</p>
<p>See answer by @S.Lott for an example of how you access globals from filename.py after executing it.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 2 + Python 3</h2>
<pre><code>exec(open("./path/to/script.py").read(), globals())
</code></pre>
<p>This will execute a script and put all it's global variables in the interpreter's global scope (the normal behavior in most scripting environments).</p>
<p><a href="https://docs.python.org/3/library/functions.html#exec" rel="noreferrer">Python 3 <code>exec</code> Documentation</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Surprised I haven't seen this yet. You can execute a file and then leave the interpreter open after execution terminates using the <code>-i</code> option:</p>
<pre><code>| foo.py |
----------
testvar = 10

def bar(bing):
  return bing*3

--------



$ python -i foo.py
&gt;&gt;&gt; testvar 
10
&gt;&gt;&gt; bar(6)
18
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I'm trying to use variables and settings from that file, not to invoke a separate process.</p>
</blockquote>
<p>Well, simply importing the file with <code>import filename</code> (minus .py, needs to be in the same directory or on your <code>PYTHONPATH</code>) will run the file, making its variables, functions, classes, etc. available in the <code>filename.variable</code> namespace.</p>
<p>So if you have <code>cheddar.py</code> with the variable spam and the function eggs â€“ you can import them with <code>import cheddar</code>, access the variable with <code>cheddar.spam</code> and run the function by calling <code>cheddar.eggs()</code></p>
<p>If you have code in <code>cheddar.py</code> that is outside a function, it will be run immediately, but building applications that runs stuff on import is going to make it hard to reuse your code. If a all possible, put everything inside functions or classes.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not an expert but this is what I noticed:</p>
<p>if your code is mycode.py for instance, and you type just 'import mycode', Python will execute it but it will not make all your variables available to the interpreter.  I found that you should type actually 'from mycode import *' if you want to make all variables available to the interpreter. </p>
</div>
<div class="post-text" itemprop="text">
<p>For python3 use either with <code>xxxx = name</code> of <code>yourfile</code>. </p>
<pre><code>exec(open('./xxxx.py').read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>From my view, the best way is:</p>
<pre><code>import yourfile
</code></pre>
<p>and after modifying yourfile.py</p>
<pre><code>reload(yourfile)   
</code></pre>
<p>or </p>
<pre><code>import imp; 
imp.reload(yourfile) in python3
</code></pre>
<p>but this will make the function and classes looks like that:
yourfile.function1, yourfile.class1.....</p>
<p>If you cannot accept those, 
the finally solution is:</p>
<pre><code>reload(yourfile)
from yourfile import *
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>For Python 3:</strong></p>
<pre><code>&gt;&gt;&gt; exec(open("helloworld.py").read())
</code></pre>
<p>Make sure that you're in the correct directory before running the command.</p>
<p>To run a file from a different directory, you can use the below command:</p>
<pre><code>with open ("C:\\Users\\UserName\\SomeFolder\\helloworld.py", "r") as file:
    exec(file.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just do,</p>
<pre><code>from my_file import *
</code></pre>
<p>Make sure not to add .py extension. If your .py file in subdirectory use,</p>
<pre><code>from my_dir.my_file import *
</code></pre>
</div>
<span class="comment-copy">os module, and I'm checking the other answers.</span>
<span class="comment-copy">Suggested os.system; And deleted answer when I read the EDIT :-/</span>
<span class="comment-copy"><code>python</code> does not work if you are running python 3, <code>python3</code> is used instead.</span>
<span class="comment-copy">Execfile no longer exists in python3, and exec() doesn't seem to be working somehow...not sure what I'm doing wrong. could you update the answer?</span>
<span class="comment-copy">is there any way to provide <code>stdin</code> from a file like using <code>&lt;</code> to the executing script with in the <code>execfile()</code>.? @s-lott</span>
<span class="comment-copy">@pzkpfw python can point to any version of python. I have seen environments with <i>only</i> python v3 where <code>python</code> points to <code>python3</code>.</span>
<span class="comment-copy">@pzkpfw That depends on what <code>python</code> executable the system finds when looking through the folders in the environment variable <code>PATH</code>.</span>
<span class="comment-copy">What does read method do? Unfortunately the official documentation site doesn't provide a clear example and explanation.</span>
<span class="comment-copy">You are my hero! I have been fighting with some really weird stuff for days where os.getcwd() said one thing, but glob("*") worked in another directory... Thank you! Thank you!</span>
<span class="comment-copy">Is there a way to pass a parameter to the script?  the following doesn't work:   exec(open"setup.py  install").read(), globals())</span>
<span class="comment-copy">@ben that won't work because <code>open</code> directly reads the code from the script. To pass arguments, look at <a href="https://stackoverflow.com/a/18675453/5888301">this answer</a>, but instead of <code>execfile</code>, obviously use <code>exec</code> and <code>open</code> as shown above.</span>
<span class="comment-copy">That won't use the global namespace, as the question requires. Use instead <code>from filename import *</code></span>
<span class="comment-copy">The question does not specifically mention using a global namespace, that may be what the OP wants, but it is not obvious from the question.</span>
<span class="comment-copy">Plus, it should be a comment, not an answer.</span>
