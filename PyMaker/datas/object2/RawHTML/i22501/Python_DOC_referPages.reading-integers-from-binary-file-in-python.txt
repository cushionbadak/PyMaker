<div class="post-text" itemprop="text">
<p>I'm trying to read a <a href="http://en.wikipedia.org/wiki/BMP_file_format" rel="noreferrer">BMP</a> file in Python. I know the first two bytes 
indicate the BMP firm. The next 4 bytes are the file size. When I execute:</p>
<pre><code>fin = open("hi.bmp", "rb")
firm = fin.read(2)  
file_size = int(fin.read(4))  
</code></pre>
<p>I get:</p>
<blockquote>
<p>ValueError: invalid literal for int() with base 10: 'F#\x13'</p>
</blockquote>
<p>What I want to do is reading those four bytes as an integer, but it seems Python is reading them as characters and returning a string, which cannot be converted to an integer. How can I do this correctly?  </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>read</code> method returns a sequence of bytes as a string. To convert from a string byte-sequence to binary data, use the built-in <code>struct</code> module: <a href="http://docs.python.org/library/struct.html" rel="noreferrer">http://docs.python.org/library/struct.html</a>. </p>
<pre><code>import struct

print(struct.unpack('i', fin.read(4)))
</code></pre>
<p>Note that <code>unpack</code> always returns a tuple, so <code>struct.unpack('i', fin.read(4))[0]</code> gives the integer value that you are after.</p>
<p>You should probably use the format string <code>'&lt;i'</code> (&lt; is a modifier that indicates little-endian byte-order and standard size and alignment - the default is to use the platform's byte ordering, size and alignment). According to the BMP format spec, the bytes should be written in Intel/little-endian byte order.</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative method which does not make use of 'struct.unpack()' would be to use <a href="http://en.wikipedia.org/wiki/NumPy">NumPy</a>:</p>
<pre><code>import numpy as np

f = open("file.bin", "r")
a = np.fromfile(f, dtype=np.uint32)
</code></pre>
<p>'dtype' represents the datatype and can be int#, uint#, float#, complex# or a user defined type. See <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfile.html"><code>numpy.fromfile</code></a>.</p>
<p>Personally prefer using NumPy to work with array/matrix data as it is a lot faster than using Python lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>As of Python 3.2+, you can also accomplish this using the <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="noreferrer"><code>from_bytes</code></a> native int method:</p>
<pre><code>file_size = int.from_bytes(fin.read(2), byteorder='big')
</code></pre>
<p>Note that this function requires you to specify whether the number is encoded in big- or little-endian format, so you will have to determine the endian-ness to make sure it works correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Except <code>struct</code> you can also use <code>array</code> module</p>
<pre><code>import array
values = array.array('l') # array of long integers
values.read(fin, 1) # read 1 integer
file_size  = values[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you are reading  the binary file, you need to unpack it into a integer, so use struct module for that</p>
<pre><code>import struct
fin = open("hi.bmp", "rb")
firm = fin.read(2)  
file_size, = struct.unpack("i",fin.read(4))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you read from a binary file, a data type called bytes is used. This is a bit like list or tuple, except it can only store integers from 0 to 255.</p>
<p>Try:</p>
<pre><code>file_size = fin.read(4)
file_size0 = file_size[0]
file_size1 = file_size[1]
file_size2 = file_size[2]
file_size3 = file_size[3]
</code></pre>
<p>Or:</p>
<pre><code>file_size = list(fin.read(4))
</code></pre>
<p>Instead of:</p>
<pre><code>file_size = int(fin.read(4))
</code></pre>
</div>
<span class="comment-copy">If your goal is to <i>use</i> the bitmap instead of spending time writing your own BMP library (not that that doesn't sound like fun...) you can use PIL <a href="http://www.pythonware.com/products/pil/" rel="nofollow noreferrer">pythonware.com/products/pil</a> which you may already have installed. Try: import Image</span>
<span class="comment-copy">Thanks Jared, but I wanted to read the bmp manually only to have fun! :)</span>
<span class="comment-copy">Instead of writing <code>i = struct.unpack(...)[0]</code> I often write <code>i, = struct.unpack(...)</code></span>
<span class="comment-copy">@Otto Is there any reason you prefer one way over the other? Is there any logical difference?</span>
<span class="comment-copy">I find it very surprising that there isn't a built-in function to read integers (or Shorts etc) from a file in Python. I'm no Java expert but I believe it has native functions such as readUnsignedShort() to do this.</span>
<span class="comment-copy">@codeape Could you define what the [0] is doing please or at least what type of language element it is. It isn't immediately apparent and it is almost impossible to search for in the Python documentation.</span>
<span class="comment-copy">For lists and tuples, obj[N] means: get the Nth element of obj. See <a href="http://docs.python.org/tutorial/introduction.html#lists" rel="nofollow noreferrer">docs.python.org/tutorial/introduction.html#lists</a></span>
<span class="comment-copy">File opening can be skiped : <code>a = np.fromfile('file.bin', dtype=np.uint32)</code></span>
<span class="comment-copy">Good point.  But this solution is not as flexible as that of the struct module, since all elements read through values.read() must be long integers (it is not convenient to read a long integer, a byte, and then a long integer, with the array module).</span>
<span class="comment-copy">I agree. <code>array</code> is an efficient way to read a binary file but not very flexible when we have to deal with structure, as you correctly mentioned.</span>
<span class="comment-copy">array.read is deprecated in favor of array.fromfile since 1.51</span>
<span class="comment-copy">struct.unpack returns a tuple</span>
<span class="comment-copy">@luc, thanks, fixed</span>
