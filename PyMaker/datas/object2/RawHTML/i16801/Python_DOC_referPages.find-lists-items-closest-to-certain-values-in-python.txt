<div class="post-text" itemprop="text">
<p>I have a list of sorted floats <code>y</code>, as well as a list of unsorted floats <code>x</code>. </p>
<p>Now, I need to find out for every element in <code>x</code> between which values of <code>y</code> it lies, preferably by index of <code>y</code>. So for example, if </p>
<pre><code>y=[1,2,3,4,5]

x[0]=3.5 
</code></pre>
<p>I would need the output for index <code>0</code> of <code>x</code> to be <code>(2,3)</code>, because <code>3.5</code> is between <code>y[2]</code> and <code>y[3]</code>.</p>
<p>Basically, it is the same as seeing <code>y</code> as bin edges and sorting <code>x</code> to those bins, I guess. </p>
<p>What would be the easiest way yo accomplish that?</p>
</div>
<div class="post-text" itemprop="text">
<p>I would use <a href="https://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip</code></a> (<a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="noreferrer"><code>itertools.izip</code></a> in Python 2.x) to accomplish this:</p>
<pre><code>from itertools import islice#, izip as zip # if Python 2.x

def nearest_neighbours(x, lst):
    for l1, l2 in zip(lst, islice(lst, 1, None)):
        if l1 &lt;= x &lt;= l2:
            return l1, l2
    else:
        # ?
</code></pre>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; nearest_neighbours(3.5, range(1, 6))
(3, 4)
</code></pre>
<p>You will have to decide what you want to happen if <code>x</code> isn't between any pair in <code>lst</code> (i.e. replace <code># ?</code>!) If you want indices (although your example isn't using them), have a play with <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="noreferrer"><code>enumerate</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks - I'm aware of how to code that step-by-step. However, I was looking for a pretty/easy/elegant solution and now I am using numpy.digitize(), wich looks pretty to me and works nicely.</p>
</div>
<div class="post-text" itemprop="text">
<p>Q: What would be the easiest way yo accomplish that?</p>
<p>Instead of giving you the code, I think you should see this pseudo-code and <strong>try to write your own code! Don't just copy paste code from the internet, if you want to educate yourself!</strong></p>
<p>Pseudocode:</p>
<pre><code>// Assume that when you have a tie,
// you put the number in the smallest range
// Here, b is between 2.1 and 3.5, instead of
// 3.5 and 4.1
float a[5] = {0.1, 1.1, 2.1, 3.5, 4.1}; // your y
float b = 3.5;                          // your x

// counter for the loop and indexes. Init i to second element
integer i = 1, prev = -1, next;

// while we are not in the end of the array
while(i &lt; 5) {
    // if b is in the range of ( a(i-1), a(i) ]
    if(b &lt;= a[i] &amp;&amp; b &gt; a[i - 1]) {
    // mark the indexes
        prev = i - 1;
        next = i;
    }

    // go to next element
    i++;
}

if(prev = -1)
    print "Number is not between some numbers"
else
    print "prev, next"
</code></pre>
<p>I think that this can make you understand the point and then be able to select the easiest way for you.</p>
</div>
<span class="comment-copy">Try writing some code first. You might surprise yourself and find the easiest way.</span>
<span class="comment-copy">Have you tried actually sorting x?</span>
