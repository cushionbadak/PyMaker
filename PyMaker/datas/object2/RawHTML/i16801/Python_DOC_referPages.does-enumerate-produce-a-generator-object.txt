<div class="post-text" itemprop="text">
<p>As a complete Python newbie, it certainly looks that way. Running the
following...</p>
<pre><code>x = enumerate(['fee', 'fie', 'foe'])
x.next()
# Out[1]: (0, 'fee')

list(x)
# Out[2]: [(1, 'fie'), (2, 'foe')]

list(x)
# Out[3]: []
</code></pre>
<p>... I notice that: (a) <code>x</code> does have a <code>next</code> method, as seems to be
required for generators, and (b) <code>x</code> can only be iterated over once, a
characteristic of generators emphasized in <a href="https://stackoverflow.com/a/231855/980833">this famous <code>python</code>-tag
answer</a>.</p>
<p>On the other hand, the two most highly-upvoted answers to <a href="https://stackoverflow.com/questions/6416538/how-to-check-if-an-object-is-a-generator-object-in-python">this
question</a>
about how to determine whether an object is a generator would seem to
indicate that <code>enumerate()</code> does <strong>not</strong> return a generator.</p>
<pre><code>import types
import inspect

x = enumerate(['fee', 'fie', 'foe'])

isinstance(x, types.GeneratorType)
# Out[4]: False

inspect.isgenerator(x)
# Out[5]: False
</code></pre>
<p>... while a third <a href="https://stackoverflow.com/a/10644028/980833">poorly-upvoted answer</a> to that question would seem to indicate that <code>enumerate()</code> <strong>does</strong> in fact return a generator:</p>
<pre><code>def isgenerator(iterable):
    return hasattr(iterable,'__iter__') and not hasattr(iterable,'__len__')

isgenerator(x)
# Out[8]: True
</code></pre>
<p>So what's going on? Is <code>x</code> a generator or not? Is it in some sense
"generator-like", but not an actual generator? Does Python's use of
duck-typing mean that the test outlined in the final code block above
is actually the best one?</p>
<p>Rather than continue to write down the possibilities running through my
head, I'll just throw this out to those of you who will immediately
know the answer. </p>
</div>
<div class="post-text" itemprop="text">
<p>While the Python documentation says that <code>enumerate</code> is functionally equivalent to:</p>
<pre><code>def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
</code></pre>
<p>The real <code>enumerate</code> function returns an <strong>iterator</strong>, but not an actual generator. You can see this if you call <code>help(x)</code> after doing creating an <code>enumerate</code> object:</p>
<pre><code>&gt;&gt;&gt; x = enumerate([1,2])
&gt;&gt;&gt; help(x)
class enumerate(object)
 |  enumerate(iterable[, start]) -&gt; iterator for index, value of iterable
 |  
 |  Return an enumerate object.  iterable must be another object that supports
 |  iteration.  The enumerate object yields pairs containing a count (from
 |  start, which defaults to zero) and a value yielded by the iterable argument.
 |  enumerate is useful for obtaining an indexed list:
 |      (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
 |  
 |  Methods defined here:
 |  
 |  __getattribute__(...)
 |      x.__getattribute__('name') &lt;==&gt; x.name
 |  
 |  __iter__(...)
 |      x.__iter__() &lt;==&gt; iter(x)
 |  
 |  next(...)
 |      x.next() -&gt; the next value, or raise StopIteration
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __new__ = &lt;built-in method __new__ of type object&gt;
 |      T.__new__(S, ...) -&gt; a new object with type S, a subtype of T
</code></pre>
<p>In Python, generators are basically a specific type of iterator that's implemented by using a <code>yield</code> to return data from a function. However, <code>enumerate</code> is actually implemented in C, not pure Python, so there's no <code>yield</code> involved. You can find the source here: <a href="http://hg.python.org/cpython/file/2.7/Objects/enumobject.c">http://hg.python.org/cpython/file/2.7/Objects/enumobject.c</a></p>
</div>
<div class="post-text" itemprop="text">
<h3>Testing for enumerate types:</h3>
<p>I would include this important test in an exploration of the enumerate type and how it fits into the Python language:</p>
<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; e = enumerate('abc')
&gt;&gt;&gt; isinstance(e, enumerate)
True
&gt;&gt;&gt; isinstance(e, collections.Iterable)
True
&gt;&gt;&gt; isinstance(e, collections.Iterator)
True
</code></pre>
<p>But we see that:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; isinstance(e, types.GeneratorType)
False
</code></pre>
<p>So we know that enumerate objects are not generators.</p>
<h3>The Source:</h3>
<p>In the <a href="http://hg.python.org/cpython/file/2.7/Objects/enumobject.c" rel="nofollow">source (of Python 2.7),</a> we can see that the enumerate object (<a href="http://hg.python.org/cpython/file/2.7/Objects/enumobject.c#l170" rel="nofollow">PyEnum_Type</a>) that iteratively returns <a href="http://hg.python.org/cpython/file/2.7/Objects/enumobject.c#l53" rel="nofollow">the tuple</a>, and in the <a href="http://hg.python.org/cpython/file/2.7/Lib/_abcoll.py#l73" rel="nofollow">ABC module we can see that any item with a <code>next</code> and <code>__iter__</code> method (actually, attribute) is defined to be an iterator.</a> (<a href="https://docs.python.org/3/library/stdtypes.html#iterator-types" rel="nofollow"><code>__next__</code> in Python 3.</a>)</p>
<h3>The Standard Library Test</h3>
<p>So the Abstract Base Class library uses the following test:</p>
<pre><code>&gt;&gt;&gt; hasattr(e, 'next') and hasattr(e, '__iter__')
True
</code></pre>
<p>So we know that enumerate types are iterators. <a href="http://hg.python.org/cpython/file/2.7/Lib/types.py#l47" rel="nofollow">But we see that a Generator type is created by a function with yield</a> <a href="https://docs.python.org/2/reference/expressions.html#yieldexpr" rel="nofollow">in the documentation</a> <a href="https://docs.python.org/reference/expressions.html#generator-expressions" rel="nofollow">or a generator expression</a>. So generators are iterators, because they have the <code>next</code> and <code>__iter__</code> methods, but not all iterators are necessarily generators, as we've seen with this enumerate object. </p>
<h3>So what do we know about <code>enumerate</code>?</h3>
<p>From the docs and the source, we know that enumerate returns an enumerate object, and we know by definition that it is an iterator, even if our testing states that it is explicitly not a generator. </p>
<p>We also know from the documentation that generator types simply "<a href="https://docs.python.org/3/library/stdtypes.html#generator-types" rel="nofollow">provide a convenient way to implement the iterator protocol.</a>" Therefore, generators are a subset of iterators. Furthermore, this allows us to derive the following generalization:</p>
<blockquote>
<p><em>All generators are iterators, but not all iterators are generators.</em></p>
</blockquote>
<p>So while we can make our enumerate object into a generator:</p>
<pre><code>&gt;&gt;&gt; g = (i for i in e)
&gt;&gt;&gt; isinstance(g, types.GeneratorType)
True
</code></pre>
<p>We can't expect that it is a generator itself, so this would be the wrong test.</p>
<h3>So What to Test?</h3>
<p>And what this means is that you should not be testing for a generator, and you should probably use the first of the tests I provided, and not reimplement the Standard Library (which I hope I can be excused from doing today.):</p>
<p>If you require an enumerate type, you'll probably want to allow for iterables or iterators of tuples with integer indexes, and the following will return <code>True</code>:</p>
<pre><code>isinstance(g, collections.Iterable)
</code></pre>
<p>If you only want specifically an enumerate type:</p>
<pre><code>isinstance(e, enumerate)
</code></pre>
<p><sub>PS In case you're interested, here's the source implementation of generators: <a href="http://hg.python.org/cpython/file/785e29d8ce13/Objects/genobject.c" rel="nofollow">http://hg.python.org/cpython/file/785e29d8ce13/Objects/genobject.c</a> </sub></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is it in some sense "generator-like", but not an actual generator?</p>
</blockquote>
<p>Yes, it is.  You shouldn't really care if it <em>is</em> a duck, but only if it walks, talks, and smells like one.  It just as well <em>be</em> a generator, shouldn't make a real difference.</p>
<p>It is typical to have generator-like types instead of actual generators, when you want to extend the functionality. E.g. <code>range</code> is also generator-like, but it also supports things like <code>y in range(x)</code> and <code>len(range(x))</code> (<code>xrange</code> in python2.x). </p>
</div>
<div class="post-text" itemprop="text">
<p>You can try a few things out to prove to yourself that it's neither a generator nor a subclass of a generator:</p>
<pre><code>&gt;&gt;&gt; x = enumerate(["a","b","c"])
&gt;&gt;&gt; type(x)
&lt;type 'enumerate'&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; issubclass(type(x), types.GeneratorType)
False
</code></pre>
<p>As Daniel points out, it is its own type, <code>enumerate</code>. That type happens to be iterable. Generators are also iterable. That second, down-voted answer you reference basically just points that out somewhat indirectly by talking about the <code>__iter__</code> method. </p>
<p>So they implement some of the same methods by virtue of both being iterable. Just like lists and generators are both iterable, but are not the same thing. </p>
<p>So rather than say that something of type <code>enumerate</code> is "generator-like", it makes more sense to simply say that both the <code>enumerate</code> and <code>GeneratorType</code> classes are iterable (along with lists, etc.). <em>How</em> they iterate over data (and shape of the data they store) might be quite different, but the interface is the same.</p>
<p>Hope that helps!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>enumerate</code> generates an enumerate-object. It is a iterator, like a generator. </p>
</div>
<span class="comment-copy">does it quack like a duck?</span>
<span class="comment-copy">kinda similar to how <code>xrange()</code> is not a <code>GeneratorType</code> either, but it sure behaves like a generator</span>
<span class="comment-copy">This might be useful: <a href="http://stackoverflow.com/questions/2776829/difference-between-python-generators-vs-iterators" title="difference between python generators vs iterators">stackoverflow.com/questions/2776829/â€¦</a> -- it looks like Python distinguishes between iterators and generators</span>
<span class="comment-copy">"As a complete Python newbie" it certainly looks like you're overly concerned with exact types. ;)</span>
<span class="comment-copy">Very interesting. Just to be sure I've got this straight, iterators (or iterables) are defined by their behavior, whereas there are actual "generator" and "enumerate" classes that define those objects. "enumerate"-class objects share many behaviors with "generator"-class objects, but so do objects of many other classes. Is there an simple way to find out whether any one of these "generalized generator" classes generates its elements on the fly (like a true generator), rather than storing them in memory?</span>
<span class="comment-copy">@JoshO'Brien A little nitpick: an "iterable" is any object that can be iterated over, e.g. list, dict, str, file. An "iterator" is the object that's actually created to iterate over an iterable. For most Python containers, you get it by calling <code>iter(obj)</code>. This happens implicitly when you do <code>for x in obj</code>. Edit: I see John Y. beat me to this point :)</span>
<span class="comment-copy">@dano: Your comment is better. I just deleted mine as you were editing yours to mention mine. Here's the <a href="https://docs.python.org/2/glossary.html" rel="nofollow noreferrer">glossary link</a> again though, as that is useful regardless.</span>
<span class="comment-copy">@JoshO'Brien I'm not aware of any way to determine if the data being returned by a given iterator is obtained lazily or if it's loaded completely into memory. An iterator just provides a way to iterate over an object once (and only once) one step at a time, by exposing a <code>next()</code> method. Exactly what goes on inside <code>next()</code> is unknown to the caller.</span>
<span class="comment-copy">@JohnY -- Thanks for leaving the glossary link in place. Both of your comments help a lot. Was just off comparing <code>iter(range(9))</code>, <code>iter(xrange(9))</code>, <code>iter([2,1])</code>, <code>iter((2,1))</code>, and <code>iter(enumerate([2,1]))</code>, which was quite enlightening. Still not totally sure why <code>enumerate</code> and <code>generator</code> objects get "used up" by being iterated across whereas the other types don't, but I suppose that's just a matter of their implementation and of decisions on the part of their authors that that behavior was desirable. Edit: OK -- scratch that  final bit. I just figured it out. Now it all makes good sense</span>
<span class="comment-copy">Thanks, that does help quite a bit.</span>
