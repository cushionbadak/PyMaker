<div class="post-text" itemprop="text">
<p>I got an error for a simple print statement, what could be the possible error, have changed to float and tried but still error persist.</p>
<pre><code>if __name__ == '__main__':
    print (i*i for i in range(5))
</code></pre>
<p>error: </p>
<pre><code>&lt;generator object &lt;genexpr&gt; at 0x0000000002731828&gt;
</code></pre>
<p>Thanks in advance...</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, print() is a function, not a statement.</p>
<p>A generator expression is like a list comprehension, except it creates an object that produces results <em>when you iterate over it</em>, not when you create it. For example,</p>
<pre><code>[i*i for i in range(5)]
</code></pre>
<p>produces a list, [0, 1, 4, 9, 16], while</p>
<pre><code>(i*i for i in range(5))
</code></pre>
<p>produces a generator object that will produce those numbers when you iterate over it.</p>
<p>If you give a function only one argument and it is a generator expression, you can omit the parentheses around the generator expression, so you do not have to do myfunc((i + 1 for i in something)).</p>
<p>So you are creating a generator object, and passing it to the print() function, which prints its representation. Itâ€™s doing exactly what you asked for, just not what you meant to ask for.</p>
<p>You can initialize a list from a generator expression:</p>
<pre><code>print(list(i*i for i in range(5)))
</code></pre>
<p>but it is easier to use the list comprehension:</p>
<pre><code>print([i*i for i in range(5)])
</code></pre>
<p>A simple example of how you might use the generator object is:</p>
<pre><code>for value in (i * i for i in range(5)):
    print value
</code></pre>
<p>although in that simple example it would obviously be easier to write:</p>
<pre><code>for i in range(5):
    print i * i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no error. I think you are simply trying to print a list. Use <code>[]</code> to get a list instead of a generator:</p>
<pre><code>if __name__ == '__main__':
    print([i*i for i in range(5)])
</code></pre>
<p>Output:</p>
<pre><code>[0, 1, 4, 9, 16]
</code></pre>
<p>To print on separate lines, you would do:</p>
<pre><code>if __name__ == '__main__':
    print('\n'.join([str(i*i) for i in range(5)]))
</code></pre>
<p>This uses the <code>'delimiter'.join(list)</code> approach to join all the elements of the list with the specified delimiter (in this case a newline: <code>\n</code>)</p>
<p>Output:</p>
<pre><code>0
1
4
9
16
</code></pre>
<p>Or as @MartijnPieters suggested (for python3 only), you can also do:</p>
<pre><code>print(*(i*i for i in range(5)), sep='\n')
</code></pre>
</div>
<span class="comment-copy">no my friend, just this "&lt;generator object &lt;genexpr&gt; at 0x0000000002731828&gt;"</span>
<span class="comment-copy">It is <b>NOT</b> an error.  The statement returns a generator.  What are you trying to do?</span>
<span class="comment-copy">using Python 3.3 at windows 64-bit operating system</span>
<span class="comment-copy">You are confusing an object representation with an exception. This is Python telling you you just created a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a>.</span>
<span class="comment-copy">How would I get see the results like this [0 1 4 9 16]? thanks</span>
<span class="comment-copy">Python 2 would produce the same output; it doesn't matter here if <code>print</code> is a statement or function, really.</span>
<span class="comment-copy">True, the semantics of the parentheses in <code>print(list(i*i for i in range(5)))</code> differs in Python 2 and 3 (whether they belong to the print function or to the generator expression), but the result is the same.</span>
<span class="comment-copy">@MartijnPieters, Ah right. Thank you so much. Hard to keep track of the little but important errors :)</span>
<span class="comment-copy">Thanks Martjin, I have got it, it worked, thanks for your time...</span>
<span class="comment-copy">Another tip: you can use <code>print(*(i*i for i in range(5)), sep='\n')</code> to get the same output too.</span>
<span class="comment-copy">Your version with join will <b>not</b> work, however, not without adding <code>str()</code> calls: <code>print('\n'.join([str(i*i) for i in range(5)]))</code></span>
<span class="comment-copy">@MartijnPieters, Ah yes the python3 printing style. Thank you. I have updated answer based on both comments.</span>
