<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/6473679/transpose-list-of-lists">Transpose list of lists</a>
<span class="question-originals-answer-count">
                    10 answers
                </span>
</li>
</ul>
</div>
<p>Let's say I have a SINGLE list <code>[[1,2,3],[4,5,6]]</code></p>
<p>How do I transpose them so they will be: <code>[[1, 4], [2, 5], [3, 6]]</code>?</p>
<p>Do I have to use the <code>zip</code> function? Is the <code>zip</code> function the easiest way?</p>
<pre><code>def m_transpose(m):
    trans = zip(m)
    return trans
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> and <a href="https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer"><code>*splat</code></a> is the easiest way in pure Python.</p>
<pre><code>&gt;&gt;&gt; list_ = [[1,2,3],[4,5,6]]
&gt;&gt;&gt; zip(*list_)
[(1, 4), (2, 5), (3, 6)]
</code></pre>
<p>Note that you get tuples inside instead of lists.  If you need the lists, use <code>map(list, zip(*l))</code>.  </p>
<p>If you're open to using <code>numpy</code> instead of a list of lists, then using the <code>.T</code> attribute is even easier:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; print(*a)
[1 2 3] [4 5 6]
&gt;&gt;&gt; print(*a.T)
[1 4] [2 5] [3 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow">map</a> with <code>None</code> as the first parameter:</p>
<pre><code>&gt;&gt;&gt; li=[[1,2,3],[4,5,6]]
&gt;&gt;&gt; map(None, *li)
[(1, 4), (2, 5), (3, 6)]
</code></pre>
<p>Unlike <code>zip</code> it works on uneven lists:</p>
<pre><code>&gt;&gt;&gt; li=[[1,2,3],[4,5,6,7]]
&gt;&gt;&gt; map(None, *li)
[(1, 4), (2, 5), (3, 6), (None, 7)]
&gt;&gt;&gt; zip(*li)
[(1, 4), (2, 5), (3, 6)]
#                      ^^ 7 missing...
</code></pre>
<p>Then call map again with <code>list</code> as the first parameter if you want the sub elements to be lists instead of tuples:</p>
<pre><code>&gt;&gt;&gt; map(list, map(None, *li))
[[1, 4], [2, 5], [3, 6]]
</code></pre>
<p>(Note: the use of map with <code>None</code> to transpose a matrix is not supported in Python 3.x. Use <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow">zip_longest</a> from itertools to get the same functionality...)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>zip()</code> doesn't seem to do what you wanted, using <code>zip()</code>  you get a <code>list</code> of <code>tuples</code>. This should work though:</p>
<pre><code>&gt;&gt;&gt; new_list = []
&gt;&gt;&gt; old_list = [[1,2,3],[4,5,6]]
&gt;&gt;&gt; for index in range(len(old_list[0])):
...     new_list.append([old_list[0][index], old_list[1][index]])
... 
&gt;&gt;&gt; new_list
[[1, 4], [2, 5], [3, 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The exact way of use <code>zip()</code> and get what you want is:</p>
<pre><code>&gt;&gt;&gt; l = [[1,2,3],[4,5,6]]
&gt;&gt;&gt; [list(x) for x in zip(*l)]
&gt;&gt;&gt; [[1, 4], [2, 5], [3, 6]]
</code></pre>
<p>This code use <code>list</code> keyword for casting the <code>tuples</code> returned by <code>zip</code> into <code>lists</code>.</p>
</div>
