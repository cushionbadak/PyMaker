<div class="post-text" itemprop="text">
<p>I'm trying to write a mini-game that allows me to practice my python threading skill. The game itself involves with timed bombs and citys that have them. </p>
<p>Here is my code:</p>
<pre><code>class City(threading.Thread):

    def __init__(self, name):
        super().__init__()
        self.name = name
        self.bombs = None
        self.activeBomb = None
        self.bombID = 0
        self.exploded = False

    def addBomb(self, name, time, puzzle, answer, hidden=False):
        self.bombs.append(Bomb(name, self.bombID, time, puzzle, answer, hidden))
        self.activeBomb.append(self.bombID)
        self.bombID += 1

    def run(self):
        for b in self.bombs:
            b.start()
        while True:
            # listen to the bombs in the self.bombs # The part that I dont know how

            # if one explodes
            #   print(self.name + ' has been destroyed')
            #   break
            # if one is disarmed
            #   remove the bombID from the activeBomb
            # if all bombs are disarmed (no activeBomb left)
            #       print('The city of ' + self.name + ' has been cleansed')
            #   break


class Bomb(threading.Thread):

    def __init__(self, name, bombID, time, puzzle, answer, hidden=False):
        super(Bomb, self).__init__()
        self.name = name
        self.bombID = bombID
        self._timer = time
        self._MAXTIME = time
        self._disarmed = False
        self._puzzle = puzzle
        self._answer = answer
        self._denoted = False
        self._hidden = hidden

    def run(self):
        # A bomb goes off!!
        if not self._hidden:
            print('You have ' + str(self._MAXTIME)
                  + ' seconds to solve the puzzle!')
            print(self._puzzle)
        while True:
            if self._denoted:
                print('BOOM')
                // Communicate to city that bomb is denoted
                break
            elif not self._disarmed:
                if self._timer == 0:
                    self._denoted = True
                else:
                    self._timer -= 1
                    sleep(1)
            else:
                print('You have successfully disarmed bomb ' + str(self.name))
                // Communicate to city that this bomb is disarmed
                break

    def answerPuzzle(self, ans):
        print('Is answer ' + str(ans) + ' ?')
        if ans == self._answer:
            self._disarmed = True
        else:
            self._denotaed = True

    def __eq__(self, bomb):
        return self.bombID == bomb.bombID

    def __hash__(self):
        return id(self)
</code></pre>
<p>I currently don't know what is a good way for the City class to effectively keep track of the 
bomb status.</p>
<p>The first thought I had was to use a for loop to have the City to check all the bombs in the 
City, but I found it being too stupid and inefficient</p>
<p>So here is the question:</p>
<p>What is the most efficient way of implementing the bomb and City so that the city immediately know the state change of a bomb without having to check it every second?</p>
<p>PS: I do NOT mean to use this program to set off real bomb, so relax :D</p>
</div>
<div class="post-text" itemprop="text">
<p>A good case to use queue. Here is an example of the so-called producer - consumer pattern.</p>
<p>The work threads will run forever till your main program is done (that is what the daemon part and the "while True" is for). They will diligently monitor the in_queue for work packages. They will process the package until none is left. So when the in_queue is joined, your work threads' jobs are done. The out_queue here is an optional downstream processing step. So you can assemble the pieces from the work threads to a summary form. Useful when they are in a function.</p>
<p>If you need some outputs, like each work thread will print the results out to the screen or write to one single file, don't forget to use semaphore! Otherwise, your output will stumble onto each other.</p>
<p>Good luck!</p>
<pre><code>from threading import Thread
import Queue

in_queue = Queue.Queue()
out_queue = Queue.Queue()

def work():
    while True:
        try:
            sonId = in_queue.get()
        ###do your things here
            result = sonID + 1

        ###you can even put your thread results again in another queue here
            out_queue.put(result)   ###optional


        except:
            pass
        finally:
            in_queue.task_done()

for i in range(20):

    t = Thread(target=work)
    t.daemon = True
    t.start()


for son in range(10):    
    in_queue.put(son)


in_queue.join()

while not out_queue.empty():

    result = out_queue.get()

    ###do something with your result here

    out_queue.task_done()

out_queue.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The standard way of doing something like this is to use a queue - one thread watches the queue and waits for an object to handle (allowing it to idle happily), and the other thread pushes items onto the queue.</p>
<p>Python has <a href="https://docs.python.org/3/library/queue.html" rel="nofollow">the <code>queue</code> module</a> (<a href="https://docs.python.org/2/library/queue.html" rel="nofollow"><code>Queue</code> in 2.x</a>). Construct a queue in your listener thread and <code>get()</code> on it - this will block until something gets put on.</p>
<p>In your other thread, when a relevant event occurs, push it onto the queue and the listener thread will wake up and handle it. If you do this in a loop, you have the behaviour you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way would be to use a scheduler library.  E.g. <a href="https://docs.python.org/2/library/sched.html" rel="nofollow">https://docs.python.org/2/library/sched.html</a>. Using this you can simply schedule bombs to call a function or method at the time they go off.  This is what I would recommend if you did not wanted to learn about threads.</p>
<p>E.g.</p>
<pre><code>import sched
s = sched.scheduler(time.time, time.sleep)
class Bomb():
    def explode(self):
        if not self._disarmed:
            print "BOOM"

    def __init__(self, time):
        s.enter(self._MAXTIME, 1, self.explode)
</code></pre>
<p>However, that way you will not learn about threads.</p>
<p>If you really want to use threads directly, then you can simply let the bombs call sleep until it is their time to go off. E.g. </p>
<pre><code>class Bomb(threading.Thread)
    def run(self):
        time.sleep.(self._MAXTIME)
        if not self._disarmed:
            print "BOOM"
</code></pre>
<p>However, this is not a nice way to handle threads, since the threads will block your application. You will not be able to exit the application until you stop the threads. You can avoid this by making the thread a daemon thread. <code>bomb.daemon = True</code>. </p>
<p>In some cases, the best way to handle this is to actually "wake up" each second and check the status of the world. This may be the case when you need to perform some cleanup actions when the thread is stopped. E.g. You may need to close a file. Checking each second may seem wasteful, but it is actually the proper way to handle such problems. Modern desktop computers are mostly idle. To be interrupted for a few milliseconds each second will not cause them much sweat.</p>
<pre><code>class Bomb(threading.Thread)
    def run(self):
        while not self._disarmed:
            if time.now() &gt; self.time_to_explode:
                print "BOOM"
                break
            else:
                time.sleep.(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Before you start "practising threading with python", I think it is important to understand Python threading model - it is Java threading model, but comes with a more restrictive option:</p>
<p><a href="https://docs.python.org/2/library/threading.html" rel="nofollow noreferrer">https://docs.python.org/2/library/threading.html</a></p>
<blockquote>
<p>The design of this module is loosely based on Java’s threading model.
  However, where Java makes locks and condition variables basic behavior
  of every object, they are separate objects in Python. Python’s Thread
  class supports a subset of the behavior of Java’s Thread class;
  currently, there are no priorities, no thread groups, and threads
  cannot be destroyed, stopped, suspended, resumed, or interrupted. The
  static methods of Java’s Thread class, when implemented, are mapped to
  module-level functions.</p>
</blockquote>
<p>Locks being in separate objects, and not per-object, following the diagram below, means less independent scheduling even when different objects are accessed - because possibly even same locks are necessary.</p>
<p><a href="https://i.stack.imgur.com/FI1ZB.png" rel="nofollow noreferrer"><img alt="Java Threading Model" src="https://i.stack.imgur.com/FI1ZB.png"/></a></p>
<p>For some python implementation - threading is not really fully concurrent:</p>
<p><a href="http://uwpce-pythoncert.github.io/EMC-Python300-Spring2015/html_slides/07-threading-and-multiprocessing.html#slide-5" rel="nofollow noreferrer">http://uwpce-pythoncert.github.io/EMC-Python300-Spring2015/html_slides/07-threading-and-multiprocessing.html#slide-5</a></p>
<blockquote>
<p>A thread is the entity within a process that can be scheduled for
  execution</p>
<p>Threads are lightweight processes, run in the address space of an OS
  process.</p>
<p>These threads share the memory and the state of the process. This
  allows multiple threads access to data in the same scope.</p>
<p>Python threads are true OS level threads</p>
<p>Threads can not gain the performance advantage of multiple processors
  due to the Global Interpreter Lock (GIL)</p>
</blockquote>
<p><a href="http://uwpce-pythoncert.github.io/EMC-Python300-Spring2015/html_slides/07-threading-and-multiprocessing.html#slide-6" rel="nofollow noreferrer">http://uwpce-pythoncert.github.io/EMC-Python300-Spring2015/html_slides/07-threading-and-multiprocessing.html#slide-6</a></p>
<p>And this (from above slide):</p>
<p><a href="https://i.stack.imgur.com/tlryj.png" rel="nofollow noreferrer"><img alt="GIL in action" src="https://i.stack.imgur.com/tlryj.png"/></a></p>
</div>
