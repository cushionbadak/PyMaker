<div class="post-text" itemprop="text">
<p>As part of my journey into learning python I am implementing Bulls and Cows.<br/>
I have a working implementation that uses list comprehension but I figured it might be a nice solution to solve this using a generator and <code>reduce()</code>-ing the final result.</p>
<p>So I have my generator:</p>
<pre><code>def bullsandcows(given, number):
    for i in range(given.__len__()):
        if given[i] == number[i]:
            yield (given[i], None)
        elif given[i] in number:
            yield (None, given[i])
</code></pre>
<p>And my reduce implementation:</p>
<pre><code>(bulls, cows) = reduce(\
    lambda (bull, cow), (b, c): \
        (bull + 1, cow + 1), bullsandcows(given, number), (0, 0))
</code></pre>
<p>Where <code>given</code> is the user input and <code>number</code> is the randomly generated number for the user to guess.</p>
<p>As you can see, this is not exactly a working implementation, this will just return the counts of the <code>yield</code>ed tuples.</p>
<p>What I need is a replacement for <code>(bull + 1, cow + 1)</code>, I have no idea how to construct this.</p>
<ul>
<li><code>number</code> is a randomly generated number, say: <code>1234</code> </li>
<li><code>given</code> is entered by the user, say: <code>8241</code> </li>
<li>The result of <code>bullsandcows(given, number)</code> would be: <code>[('2', None), (None, '4'), (None, '1']</code> </li>
<li>The result of the <code>reduce</code> should be: <code>(1, 2)</code>, which is the count of all non-<code>None</code> values of the first element and count of all non-<code>None</code> values of the second element</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If I understood the process correctly, you want to count what <code>bull</code>s are not <code>None</code>, and how many <code>cow</code>s are not <code>None</code>:</p>
<pre><code>reduce(lambda (bcount, ccount), (b, c): (bcount + (b is not None), ccount + (c is not None)),
       bullsandcows(given, number), (0, 0))
</code></pre>
<p>This increments a counter only if the <code>bull</code> or <code>cow</code> value is not <code>None</code>. The test produces a boolean, which is a subclass of <code>int</code> with <code>False == 0</code> and <code>True == 1</code>; summing an integer and a boolean results in another integer.</p>
<p>Since you are feeding it non-empty strings, you could simplify it to:</p>
<pre><code>reduce(lambda (bcount, ccount), (b, c): (bcount + bool(b), ccount + bool(c)),
       bullsandcows(given, number), (0, 0))
</code></pre>
<p>I'd rewrite <code>bullsandcows()</code> to:</p>
<pre><code>def bullsandcows(given, number):
    given, number = map(str, (given, number))
    for g, n in zip(given, number):
        if g == n:
            yield (g, None)
        elif g in number:
            yield (None, g)
</code></pre>
<p>e.g. use <code>zip()</code> to pair up the digits of <code>given</code> and <code>number</code>.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def bullsandcows(given, number):
...     given, number = map(str, (given, number))
...     for g, n in zip(given, number):
...         if g == n:
...             yield (g, None)
...         elif g in number:
...             yield (None, g)
... 
&gt;&gt;&gt; given, number = 8241, 1234
&gt;&gt;&gt; list(bullsandcows(given, number))
[('2', None), (None, '4'), (None, '1')]
&gt;&gt;&gt; reduce(lambda (bcount, ccount), (b, c): (bcount + bool(b), ccount + bool(c)),
...        bullsandcows(given, number), (0, 0))
(1, 2)
</code></pre>
<p>Note that unpacking in function arguments was removed from Python 3 and the <code>reduce()</code> built-in has been delegated to library function; your code is decidedly Python 2 only.</p>
<p>To make it work in Python 3 you need to import <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>functools.reduce()</code></a> and adjust the lambda to not use unpacking:</p>
<pre><code>from functools import reduce

reduce(lambda counts, bc: (counts[0] + bool(bc[0]), counts[1] + bool(bc[1])),
       bullsandcows(given, number), (0, 0))
</code></pre>
</div>
<span class="comment-copy">Don't use <code>.__len__()</code> when <code>len(given)</code> is clearer, and don't use a <code>range()</code> when you could use <code>zip()</code> instead.</span>
<span class="comment-copy">You are right, fixed that. It doesn't <i>seem</i> to ignore the output of <code>bullsandcows</code>. The result is always a two-element tuple containing the number of results from the generator</span>
<span class="comment-copy">You are ignoring the <code>(b, c)</code> tuple in your lambda.</span>
<span class="comment-copy">That's correct and it's also exactly my problem :)</span>
<span class="comment-copy">It isn't clear to me what the input is, and what output you expect.</span>
<span class="comment-copy"><code>elif g in str(number):</code></span>
<span class="comment-copy">@mtadd: was getting to that. :-)</span>
<span class="comment-copy">Thanks! This solves my problem completely. I wish I could give you another up-vote for going the extra mile by explaining how and why I could improve my code</span>
