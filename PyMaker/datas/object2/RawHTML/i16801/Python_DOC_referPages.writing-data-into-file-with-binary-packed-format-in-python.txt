<div class="post-text" itemprop="text">
<p>I am reading some value for file and wants to write modified value into file. My file is .ktx format [binary packed format].  </p>
<p>I am using struct.pack() but seems that something is going wrong with that:</p>
<pre><code>bytes = file.read(4)
bytesAsInt = struct.unpack("l",bytes)
number=1+(bytesAsInt[0])
number=hex(number)
no=struct.pack("1",number)

outfile.write(no)
</code></pre>
<p>I want to write in both ways little-endian and big-endian.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>no_little =struct.pack("&gt;1",bytesAsInt)
no_big =struct.pack("&lt;1",bytesAsInt) # i think this is default ...
</code></pre>
<p>again you can check the docs and see the format characters you need 
<a href="https://docs.python.org/3/library/struct.html" rel="nofollow">https://docs.python.org/3/library/struct.html</a></p>
<pre><code>&gt;&gt;&gt; struct.unpack("l","\x05\x04\x03\03")
(50529285,)
&gt;&gt;&gt; struct.pack("l",50529285)
'\x05\x04\x03\x03'
&gt;&gt;&gt; struct.pack("&lt;l",50529285)
'\x05\x04\x03\x03'
&gt;&gt;&gt; struct.pack("&gt;l",50529285)
'\x03\x03\x04\x05'
</code></pre>
<p>also note that it is a lowercase <code>L</code> , not a one (as also covered in the docs)</p>
</div>
<div class="post-text" itemprop="text">
<p>I haven't tested this but the following function should solve your problem. At the moment it reads the file contents completely, creates a buffer and then writes out the updated contents. You could also modify the file buffer directly using <code>unpack_from</code> and <code>pack_into</code> but it might be slower (again, not tested). I'm using the <code>struct.Struct</code> class since you seem to want to unpack the same number many times.</p>
<pre><code>import os
import struct

from StringIO import StringIO

def modify_values(in_file, out_file, increment=1, num_code="i", endian="&lt;"):
    with open(in_file, "rb") as file_h:
        content = file_h.read()
    num = struct.Struct(endian + num_code)
    buf = StringIO()
    try:
        while len(content) &gt;= num.size:
            value = num.unpack(content[:num.size])[0]
            value += increment
            buf.write(num.pack(value))
            content = content[num.size:]
    except Exception as err:
        # handle
    else:
        buf.seek(0)
        with open(out_file, "wb") as file_h:
            file_h.write(buf.read())
</code></pre>
<p>An alternative is to use the <a href="https://docs.python.org/2/library/array.html" rel="nofollow"><code>array</code></a> which makes it quite easy. I don't know how to implement endianess with an <code>array</code>.</p>
<pre><code>def modify_values(filename, increment=1, num_code="i"):
    with open(filename, "rb") as file_h:
        arr = array("i", file_h.read())
    for i in range(len(arr)):
        arr[i] += increment
    with open(filename, "wb") as file_h:
        arr.tofile(file_h)
</code></pre>
</div>
<span class="comment-copy">what do you mean about little-endian and big-endian ... you only do one or the other</span>
<span class="comment-copy">Thanks for your reply. I have added these lines: no=struct.pack("&lt;1",number) outfile.write(no) here number is my modified hex value which I want to write to file. now i get error "struct.error: pack requires exactly 0 arguments" with that code</span>
<span class="comment-copy">thats because it is a lowercase L not a one ...</span>
