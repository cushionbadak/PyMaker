<div class="post-text" itemprop="text">
<p>Let's say I have a couple of Python packages.</p>
<pre><code>/package_name
    __init__.py
    /dohickey
        __init__.py
        stuff.py
        other_stuff.py
        shiny_stuff.py
    /thingamabob
        __init__.py
        cog_master.py
        round_cogs.py
        teethless_cogs.py
    /utilities
        __init__.py
        important.py
        super_critical_top_secret_cog_blueprints.py
</code></pre>
<p>What's the best way to utilize the utilites package? Say shiny_stuff.py needs to import important.py, what's the best way to go about that?</p>
<p>Currently I'm thinking</p>
<pre><code>from .utilities import important
</code></pre>
<p>But is that the best way? Would it make more sense to add utilities to the path and import it that way?</p>
<pre><code>import sys
sys.path.append(os.path.basename(os.path.basename(__file__)))

import utilities.super_critical_top_secret_cog_blueprints
</code></pre>
<p>That seems clunky to add to each of my files. </p>
</div>
<div class="post-text" itemprop="text">
<p>I think the safest way is always to use absolute import, so in you case:</p>
<pre><code>from package_name.utilities import important
</code></pre>
<p>This way you won't have to change your code if you decide to move your shiny_stuff.py in some other package (assuming that package_name will still be in your sys.path).</p>
</div>
<div class="post-text" itemprop="text">
<p>According to Nick Coghlan (who is a Python core developer):</p>
<p><a href="https://ncoghlan_devs-python-notes.readthedocs.org/en/latest/python_concepts/import_traps.html" rel="nofollow"><strong>"“Never add a package directory, or any directory inside a package, directly to the Python path.”</strong></a> (Under the heading "The double import trap")</p>
<p>Adding the package directory to the path gives two separate ways for the module to be referred to.  The link above is an excellent blog post about the Python import system.  Adding it to the path directly means <em>you can potentially have two copies of a single module,</em> which you don't want.  Your relative import <code>from .utilities import important</code> is fine, and an absolute import <code>import package_name.utilities.important</code> is also fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>A "best" out-of-context choice probably doesn't exist, but you can have some criteria choosing which is better for your use cases, and for such a judgment one should know are the different possible approaches and their characteristics. Probably the best source of information is the <a href="http://legacy.python.org/dev/peps/pep-0328/" rel="nofollow">PEP 328</a>  itself, which contains some rationale about declaring distinct possibilities for that.</p>
<p>A common approach is to use the "absolute import", in your case it would be something like:</p>
<pre><code>from package_name.utilities import important
</code></pre>
<p>This way, you can make this file it a script. It is somewhat independent from other modules and packages, fixed mainly by its location. If you have a package structure and need to change one single module from its location, having absolute path would help this single file to be kept unchanged, but all the ones which uses this module it should change. Of course you can also import the <code>__init__.py</code> files as:</p>
<pre><code>from package_name import utilities
</code></pre>
<p>And these imports have the same characteristics. Be careful that <code>utilities.important</code> try to find a variable <code>important</code> within <code>__init__.py</code>, not from important.py, so having a "import important" <code>__init__.py</code> would help avoiding a mistake due to the distinction between file structure and namespace structure.</p>
<p>Another way to do that is the relative approach, by using:</p>
<pre><code>from ..utilities import important
</code></pre>
<p>The first dot (<code>from .stuff import ___</code> or <code>from . import ___</code>) says "the module in this [sub]package", or <code>__init__.py</code> when there's only the dot. From the second dot we are talking about parent directories. Generally, starting with dots in any import isn't allowed in a script/executable, but you can read about <a href="http://legacy.python.org/dev/peps/pep-0366/" rel="nofollow">explicit relative imports (PEP 366)</a> if you care about scripts with relative imports.</p>
<p>A justification for relative import can be found on the PEP 328 itself:</p>
<blockquote>
<p>With the shift to absolute imports, the question arose whether relative imports should be allowed at all. Several use cases were presented, the most important of which is being able to rearrange the structure of large packages without having to edit sub-packages. In addition, a module inside a package can't easily import itself without relative imports.</p>
</blockquote>
<p>Either case, the modules are tied to the subpackages in the sense that <code>package_name</code> is imported first no matter which the user tried to import first, unless you use sys.path to search for subpackages as packages (i.e., use the package root inside sys.path)...but that sounds weird, why would one do that?</p>
<p>The <code>__init__.py</code> can auto-import module names, for that one should care about its namespace contents. For example, say <code>important.py</code> has an object called <code>top_secret</code>, which is a dictionary. To find it from anywhere you would need</p>
<pre><code>from package_name.utilities.important import top_secret
</code></pre>
<p>Perhaps you want be less specific:</p>
<pre><code>from package_name.utilities import top_secret
</code></pre>
<p>That would be done with an <code>__init__.py</code> with the following line inside it:</p>
<pre><code>from .important import top_secret
</code></pre>
<p>That's perhaps mixing the relative and absolute imports, but for a <code>__init__.py</code> you probably know that subpackage makes sense as a subpackage, i.e., as an abstraction by itself. If it's just a bunch of files located in the same place with the need for a explicit module name, probably the <code>__init__.py</code> would be empty (or almost empty). But for avoiding explicit module names for the user, the same idea can be done on the root <code>__init__.py</code>, with</p>
<pre><code>from .utilities import top_secret
</code></pre>
<p>Completely indirect, but the namespace gets flat this way while the files are nested for some internal organization. For example, the <code>wx</code> package (wxPython) do that: everything can be found <code>from wx import ___</code> directly.</p>
<p>You can also use some metaprogramming for finding the contents if you want to follow this approach, for example, using <code>__all__</code> to detect all names a module have, or looking for the file location to know which modules/subpackages are available there to import. However, some simpler code completion utilities might get lost when doing that.</p>
<p>For some contexts you might have other kind of constraints. For example, <a href="https://github.com/lihaoyi/macropy" rel="nofollow">macropy</a> makes some "magic" with imports and doesn't work on the file you call as a script, so you'll need at least 2 modules just to use this package.</p>
<p>Anyhow, you should always ask whether nesting into subpackages is really needed for you code or API organization. The <a href="http://legacy.python.org/dev/peps/pep-0020/" rel="nofollow">PEP 20</a> tells us that "Flat is better than nested", which isn't a law but a point-of-view that suggests you should keep a flat package structure unless nesting is needed for some reason. Likewise, you don't need a module for each class nor anything alike.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use absolute import in case you need to move to a different location.</p>
</div>
<span class="comment-copy">My preference, which I give without rational justification, is for relative imports (so <code>from ..utilities import important</code> in your example).</span>
<span class="comment-copy">You should never modify <code>sys.path</code>, though, unless you know what you're doing.</span>
<span class="comment-copy">But what if package_name isn't on the path already?</span>
<span class="comment-copy">That of course depends on what are you trying to do.   From your example it seems like you are building a library, in this case you should leave the sys.path issue to your testing environment (say a virtualenv or ipython).  If this is a standalone application, you should consider rearranging your project's internal structure to be in 'cascade'.</span>
<span class="comment-copy">I guess where I get confused is that package_name isn't on the path, so doing <code>from package_name import utilities</code> bombs. If the script being run is <code>shiny_stuff.py</code> then I know dohickey will be in the path, but <code>import package_name</code> won't do anything, will it?</span>
<span class="comment-copy">You should install your package to use it, usually <a href="https://docs.python.org/3/distutils/introduction.html?highlight=distutils" rel="nofollow noreferrer">creating a setup.py file</a> and using its <code>install</code> command (which install the package by copying/creating files) or its <code>develop</code> command (which "install" by creating a symlink to the development directory). If the package_name isn't a child directory of any directory in the sys.path, then you simply can't use it this way.</span>
