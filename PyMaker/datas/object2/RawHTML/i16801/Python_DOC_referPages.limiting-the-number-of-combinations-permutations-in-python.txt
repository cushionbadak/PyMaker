<div class="post-text" itemprop="text">
<p>I was going to generate some combination using the itertools, when i realized that as the number of elements increase the time taken will increase exponentially. Can i limit or indicate the maximum number of permutations to be produced so that itertools would stop after that limit is reached.</p>
<p>What i mean to say is:</p>
<p>Currently i have </p>
<pre><code>#big_list is a list of lists
permutation_list = list(itertools.product(*big_list))
</code></pre>
<p>Currently this permutation list has over 6 Million permutations. I am pretty sure if i add another list, this number would hit the billion mark.</p>
<p>What i really need is a significant amount of permutations (lets say 5000). Is there a way to limit the size of the permutation_list that is produced?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to use <a href="https://docs.python.org/2/library/itertools.html#itertools.islice"><code>itertools.islice</code></a>, like this</p>
<pre><code>itertools.islice(itertools.product(*big_list), 5000)
</code></pre>
<p>It doesn't create the entire list in memory, but it returns an iterator which consumes the actual iterable lazily. You can convert that to a list like this</p>
<pre><code>list(itertools.islice(itertools.product(*big_list), 5000))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools.islice</code> has many benefits such as ability to set <code>start</code> and <code>step</code>.  Solutions below aren't that flexible and you should use them only if <code>start</code> is 0 and <code>step</code> is 1. On the other hand, they don't require any imports.</p>
<hr/>
<p>You could create a tiny wrapper around <code>itertools.product</code></p>
<pre><code>it = itertools.product(*big_list)
pg = (next(it) for _ in range(5000)) # generator expression
</code></pre>
<p><code>(next(it) for _ in range(5000))</code> returns a generator not capable of producing more than 5000 values. Convert it to <code>list</code> by using the <code>list</code> constructor</p>
<pre><code>pl = list(pg)
</code></pre>
<p>or by wrapping the generator expression with square brackets (instead of round ones)</p>
<pre><code>pl = [next(it) for _ in range(5000)] # list comprehension
</code></pre>
<p>Another solution, which is just as efficient as the first one, is</p>
<pre><code>pg = (p for p, _ in zip(itertools.product(*big_list), range(5000))
</code></pre>
<p>Works in Python 3+, where <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> returns an iterator that stops when the shortest iterable is exhausted. Conversion to <code>list</code> is done as in the first solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try out this method to get particular number of permutations number of results a permutation produce is n! where n stands for the number of elements in a list for example if you want to get only 2 results then you can try the following:</p>
<p>Use any temporary variable and limit it</p>
<pre><code>    from itertools import permutations
    m=['a','b','c','d']
    per=permutations(m)
    temp=1
    for i in list(per):
        if temp&lt;=2:    #2 is the limit set
           print (i)
           temp=temp+1
        else:
           break
</code></pre>
</div>
<span class="comment-copy">Do you really need the list? An iterator takes very little memory and it is as fast as (or more than) a list.</span>
<span class="comment-copy">+1, This is by far the best solution.</span>
<span class="comment-copy">This is the correct solution, because it also lets you set start and stop easily.</span>
<span class="comment-copy">@frostnational. Nice solution, works very well. Unfortunately i can only mark one answer as accepted. But this works just as well. Thank you</span>
<span class="comment-copy">Or you can skip the <code>permutation_generator</code> totally and use list comprehension. Or even simpler, <code>[x for _, x in zip(xrange(5000), iterator)]</code></span>
