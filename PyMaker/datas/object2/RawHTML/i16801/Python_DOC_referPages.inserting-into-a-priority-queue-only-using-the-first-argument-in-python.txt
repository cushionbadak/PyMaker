<div class="post-text" itemprop="text">
<p>How do I insert items into a priority queue, but ensure that it only takes as it's priority the first argument given.  For example:</p>
<pre><code>    #push up
    if((pacman_r != 0 ) and (cellGrid[pacman_r-1][pacman_c].what != '%')):
        priorityQueue.put((4, pacman_r-1, pacman_c))
    #push left 
    if ((pacman_c != 0) and (cellGrid[pacman_r][pacman_c-1].what != '%')):
        priorityQueue.put((4, pacman_r, pacman_c-1))
    #push right
    if ((pacman_c != c) and (cellGrid[pacman_r][pacman_c+1].what != '%')):
        priorityQueue.put((9, pacman_r, pacman_c+1))
    #push down
    if((pacman_r != r ) and (cellGrid[pacman_r+1][pacman_c].what != '%')):
        priorityQueue.put((1, pacman_r+1, pacman_c))
</code></pre>
<p>I would like the top two if statements to be placed into <code>priorityQueue</code> LIFO.  How would I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Pass the arguments as a separate tuple:</p>
<pre><code> priorityQueue.put( (4, (pacman_r-1, pacman_c)) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want equal priority elements to be returned in a LIFO order, you should add a count value to your keys:</p>
<pre><code># put this with your other import statements
from itertools import count

# put this near where you define your priority queue
counter = count()

#later, add the counter's latest value as a second key value:
#push up
if((pacman_r != 0 ) and (cellGrid[pacman_r-1][pacman_c].what != '%')):
    priorityQueue.put((4, -next(counter), pacman_r-1, pacman_c))
#push left 
if ((pacman_c != 0) and (cellGrid[pacman_r][pacman_c-1].what != '%')):
    priorityQueue.put((4, -next(counter), pacman_r, pacman_c-1))
#push right
if ((pacman_c != c) and (cellGrid[pacman_r][pacman_c+1].what != '%')):
    priorityQueue.put((9, -next(counter), pacman_r, pacman_c+1))
#push down
if((pacman_r != r ) and (cellGrid[pacman_r+1][pacman_c].what != '%')):
    priorityQueue.put((1, -next(counter), pacman_r+1, pacman_c))
</code></pre>
<p>This makes your values be four-tuples, rather than three-tuples (so you'll need to update the code you use to access the values). The second value will be steadily decreasing (<code>count</code> yields successively increasing integers forever, and we're negating them). If the first values of two tuples in the queue are equal, the second values will be compared and the most recently added one will always be the smallest (and so selected by the queue).</p>
<p>By the way, unless you're using your queue to synchronize data between multiple threads, you should probably be using the <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow"><code>heapq</code> module</a>'s functions on a regular <code>list</code>, rather than using a <code>queue.PriorityQueue</code> instance. The latter uses <code>heapq</code> to implement its logic internally, but it also does a bunch of locking that you probably don't need (for single threaded code it is pointless overhead).</p>
</div>
<span class="comment-copy">I tried this out but it just seems to use the second tuple as the priority key, using the values of the string... Can I make it ignore the second tuple?</span>
<span class="comment-copy">Then change the order: <code>priorityQueue.put( ((pacman_r-1, pacman_c), 4) )</code></span>
<span class="comment-copy">It then uses the "(pacman_r-1, pacman_c)" string as the priority key.</span>
