<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/34113609/why-does-python-preemptively-hang-when-trying-to-calculate-a-very-large-number">Why does Python “preemptively” hang when trying to calculate a very large number?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I was playing around with big numbers, and wrote the following code:</p>
<pre><code>import time

def ispow2(n):
    return not n &amp; n - 1

start = time.clock()
ispow2(2**100000000)
end = time.clock()

print(end - start)
</code></pre>
<p>Surprisingly, this outputs <code>0.016864107385627148</code>, and insanely short amount of time. However, it actually takes about <code>8</code> seconds, not <code>0.02</code>.</p>
<p>Why is the time module reporting such a fast time when it clearly takes longer than that to run the code?</p>
<hr/>
<p>According to <a href="https://docs.python.org/3/library/time.html#time.clock" rel="nofollow"><code>time</code></a>, <code>clock()</code> is deprecated, so I switched it out for <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="nofollow"><code>process_time()</code></a>. I get near identical results. Same with <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow"><code>perf_counter()</code></a>.</p>
<hr/>
<p>Note: this is running from IDLE. When I ran from command line, the time seemed accurately reported. Perhaps pythonw.exe has something to do with this, but what?</p>
<p>However, when I add another <code>0</code> to the end of <code>2**10...</code>, it takes ~7 seconds on command line, but reported <code>0.1781140373572865</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>python.exe</code> and <code>pythonw.exe</code> are optimizing the code before running. It seems that the <code>2**100000000</code> is being pre-computed. This small edit to the code:</p>
<pre><code>import time

print("program entered")

def ispow2(n):
    return not n &amp; n - 1

start = time.perf_counter()
ispow2(2**100000000)
end = time.perf_counter()

print(end - start)
</code></pre>
<p>Produces the following output completely after the wait:</p>
<pre><code>program entered
0.01701506924359556
</code></pre>
<p>So the program doesn't even run until after the majority of the wait.</p>
<p>Data that suggests that this is with the <code>2**...</code> part (running from command line):</p>
<pre><code>power of two|approximate wait time|reported time
1000000000  | 6  seconds          |0.1637752267742188
10000000000 | 62 seconds          |1.6400543291627092
</code></pre>
<p>On that last run, there was a clear ~<code>1.5</code> second wait between the output of <code>program entered</code> and <code>1.6400543291627092</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The constant is precomputed:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(lambda: 2**100)
1           0 LOAD_CONST               3 (1267650600228229401496703205376)
            3 RETURN_VALUE
</code></pre>
<p>Compare:</p>
<pre><code>$ ./python -mtimeit "2**1000"
10000000 loops, best of 3: 0.0601 usec per loop
$ ./python -mtimeit "2**10000"
10000000 loops, best of 3: 0.0584 usec per loop
</code></pre>
<p>vs.:</p>
<pre><code>$ ./python -mtimeit -s "p=1000" "2**p"
100000 loops, best of 3: 6.89 usec per loop
$ ./python -mtimeit -s "p=10000" "2**p"
10000 loops, best of 3: 94.2 usec per loop
</code></pre>
<p>In the first case the time doesn't change after increasing the power 10 times. It is changed as it should in the second case there the power is a variable.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best way to time small bits of code is with <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow">timeit</a></p>
<p>If I use timeit on my computer and compare to yours, I get a similar number using Python 3.4:</p>
<pre><code>import time
import timeit

def ispow2(n):
    return not n &amp; n - 1

n=10

start = time.time()
for i in range(n):
    ispow2(2**100000000)
end = time.time()

print(end - start)

print(timeit.Timer('ispow2(2**100000000)', setup="from __main__ import ispow2").timeit(number=n))
</code></pre>
<p>Prints:</p>
<pre><code>0.1257798671722412
0.12608672981150448
</code></pre>
<p>I used <a href="https://docs.python.org/2/library/time.html#time.time" rel="nofollow">time.time()</a> vs <a href="https://docs.python.org/2/library/time.html#time.clock" rel="nofollow">time.clock()</a> but both seem to work. </p>
</div>
<span class="comment-copy">Even lesser on my machine. But it didn't take 8 seconds.</span>
<span class="comment-copy">@thefourtheye It took ~8 seconds, most of which IDLE was not responding. Trying out CMD.</span>
<span class="comment-copy">I'm seeing about 80 ms in the Python 2.7 interactive console, after wrapping your test up in a function. Interestingly, after pressing enter after the last line of the function, the console hung for a second or two... even though nothing was executing.</span>
<span class="comment-copy">@JonathonReinhart exactly what I was seeing: the console hung for ~8 seconds.</span>
<span class="comment-copy">for performance measurements you could use <code>from timeit import default_timer as timer</code>: it chooses the best timer for your platform, Python version.</span>
<span class="comment-copy"><a href="http://hg.python.org/cpython/file/04f714765c13/Python/peephole.c#l331" rel="nofollow noreferrer"><code>PyCode_Optimize</code></a> detects the bytecode pattern <code>LOAD_CONST</code>, <code>LOAD_CONST</code>, <code>BINOP</code>, and calls <a href="http://hg.python.org/cpython/file/04f714765c13/Python/peephole.c#l138" rel="nofollow noreferrer"><code>fold_binops_on_constants</code></a> to evaluate the operation and replace it with a single <code>LOAD_CONST</code>. If you import the script, the module's code object is cached in the <code>__pycache__</code> directory, where you'll see that it's several megabytes, in agreement with <code>sys.getsizeof(2**100000000)</code>.</span>
