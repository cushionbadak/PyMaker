<div class="post-text" itemprop="text">
<p>I have a list of numbers in Python.  It looks like this:</p>
<pre><code>a = [87, 84, 86, 89, 90, 2014, 1000, 1002, 997, 999]
</code></pre>
<p>I want to keep all the numbers which are within + or - 7 of each other and discard the rest.  Is there a simple way to do this in Python?  I have read about the list filter method but am not sure how to get what I want working with it.</p>
<p>I am new to Python.</p>
<p><strong>Update</strong></p>
<p>Output would ideally be [84, 86, 87, 89, 90] and another list [997, 999, 1000, 1002].  I want to retrieve the sequences and not the outliers.  Hope this makes sense.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is algorithm problem, try this:</p>
<pre><code>def get_blocks(values):
    mi, ma = 0, 0
    result = []
    temp = []
    for v in sorted(values):
        if not temp:
            mi = ma = v
            temp.append(v)
        else:
            if abs(v - mi) &lt; 7 and abs(v - ma) &lt; 7:
                temp.append(v)
                if v &lt; mi:
                    mi = v
                elif v &gt; ma:
                    ma = v
            else:
                if len(temp) &gt; 1:
                    result.append(temp)
                mi = ma = v
                temp = [v]
    return result

a = [87, 84, 86, 89, 90, 2014, 1000, 1002, 997, 999]
print get_blocks(a)
</code></pre>
<p>Output:</p>
<pre><code>[[84, 86, 87, 89, 90], [997, 999, 1000, 1002]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your problems allows transitive relations, i.e. x is in the group as long as it's at most 7 away from <em>any</em> element in the group, then this seems to me like a <a href="http://en.wikipedia.org/wiki/Graph_theory" rel="nofollow">graph theory</a> problem. To be more specific, you need to find all <a href="http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29" rel="nofollow">connected components</a>.</p>
<p>The problem itself is pretty easy to solve with a recursive algorithms. You would first create a dictionary in which every key would be one of the elements and every value would be a list of elements which are at most 7 apart from that element. For your example, you would have something like this:</p>
<pre><code>for element in elements:
    connections[element] = []
    visited[element] = False
    for another in elements:
        if abs(element - another) &lt;= limit:
            connections[element].append(another)
</code></pre>
<p>Which would give you something like this</p>
<pre><code>{
    84: [86, 87, 89, 90],
    86: [84, 87, 89, 90],
    ...
    997: [999, 1000, 1002]
    ...
    2014: []
}
</code></pre>
<p>Now you need to write a recursive function which will take as input an element and a list, and it will keep adding elements in a list as long as it can find an element which is at most 7 apart from the current element.</p>
<pre><code>def group_elements(element, group):
    if visited[element]:
        return
    visited[element] = True
    group.append(element)
    for another in connections[element]:
        group_elements(another, group)
</code></pre>
<p>Somewhere in the code you also need to remember which elements you have already visited to make sure that you don't get into an infinite loop.</p>
<pre><code>visited = {}
</code></pre>
<p>You need to call that function for every element in your list.</p>
<pre><code>groups = []
for element in elements:
    if not visited[element]:
        group = []
        group_elements(element, group)
        groups.append(group)
print group
</code></pre>
<p>This code should give the following output for your input:</p>
<pre><code>[[87, 84, 86, 89, 90], [2014], [1000, 1002, 997, 999]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a = [87, 84, 86, 89, 90, 2014, 1000, 1002, 997, 999]
temp=a[0]
result=[]
temp1=[]
counter =len(a)

for i in a:
    if i in range(temp-7,temp+7):


        temp1.append(i)
        if counter==1:
            result.append(temp1)

    else:


        if temp1:
            result.append(sorted(temp1))
        temp1=[]
        temp=i
    counter=counter-1

print result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For any problem like this my first port of call is the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow">Python itertools module</a>.  The <em>pairwise</em> function from that link that I use in the code is available in the <a href="https://pypi.python.org/pypi/more-itertools" rel="nofollow">more-itertools module</a>.</p>
<pre><code>from more_itertools import pairwise
results = []
chunk = []
a = [87, 84, 86, 89, 90, 2014, 1000, 1002, 997, 999]
a.sort()
for v1, v2 in pairwise(a):
    if v2 - v1 &lt;= 7:
        chunk.append(v1)
    elif chunk:
        chunk.append(v1)
        results.append(chunk)
        chunk = []
print(results)
[[84, 86, 87, 89, 90], [997, 999, 1000, 1002]]
</code></pre>
<p>I haven't tested for edge cases, so it's buyer beware :)</p>
</div>
<span class="comment-copy">what is ur expected output of above list</span>
<span class="comment-copy">Output would ideally be [84, 86, 87, 89, 90] and another list [997, 999, 1000, 1002]</span>
<span class="comment-copy">Please update your question with the expected output. Is there a minimal size of that list? If no <code>[2014]</code> would be a solution too.</span>
<span class="comment-copy">how to find which is middle element ..like 87 . we have to consider first element as middle element when v start searching.</span>
<span class="comment-copy">what about such a list: [2,5,8,10,12]?</span>
