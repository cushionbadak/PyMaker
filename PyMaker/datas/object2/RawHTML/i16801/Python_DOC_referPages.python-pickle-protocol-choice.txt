<div class="post-text" itemprop="text">
<p>I an using python 2.7 and trying to pickle an object. I am wondering what the real difference is between the pickle protocols.</p>
<pre><code>import numpy as np
import pickle
class data(object):
    def __init__(self):
        self.a = np.zeros((100, 37000, 3), dtype=np.float32)

d = data()
print "data size: ", d.a.nbytes/1000000.
print "highest protocol: ", pickle.HIGHEST_PROTOCOL
pickle.dump(d,open("noProt", 'w'))
pickle.dump(d,open("prot0", 'w'), protocol=0)
pickle.dump(d,open("prot1", 'w'), protocol=1)
pickle.dump(d,open("prot2", 'w'), protocol=2)


out &gt;&gt; data size:  44.4
out &gt;&gt; highest protocol:  2
</code></pre>
<p>then I found that the saved files have different sizes on disk:</p>
<ul>
<li><code>noProt</code>: 177.6MB  </li>
<li><code>prot0</code>: 177.6MB  </li>
<li><code>prot1</code>: 44.4MB  </li>
<li><code>prot2</code>: 44.4MB</li>
</ul>
<p>I know that <code>prot0</code> is a human readable text file, so I don't want to use it.
I guess protocol 0 is the one given by default.</p>
<p>I wonder what's the difference between protocols 1 and 2, is there a reason why I should chose one or another?</p>
<p>What's is the better to use, <code>pickle</code> or <code>cPickle</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/2/library/pickle.html#data-stream-format" rel="noreferrer"><code>pickle</code> module data format documentation</a>:</p>
<blockquote>
<p>There are currently 3 different protocols which can be used for pickling.</p>
<ul>
<li>Protocol version 0 is the original ASCII protocol and is backwards compatible with earlier versions of Python.</li>
<li>Protocol version 1 is the old binary format which is also compatible with earlier versions of Python.</li>
<li>Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of new-style classes.</li>
</ul>
<p>[...]</p>
<p>If a <em>protocol</em> is not specified, protocol 0 is used. If <em>protocol</em> is specified as a negative value or <code>HIGHEST_PROTOCOL</code>, the highest protocol version available will be used.</p>
</blockquote>
<p>Stick with protocol version 2, <em>especially</em> if you are using custom classes derived from <code>object</code> (new-style classes). Which most modern code does, these days.</p>
<p>Unless you need to maintain backwards compatibility with older Python versions, it's easiest to just stick with the highest protocol version you can lay your hands on:</p>
<pre><code>with open("prot2", 'wb') as pfile:
    pickle.dump(d, pfile, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
<p>Because this is a binary format, make sure to use <code>'wb'</code> as the file mode!</p>
<p><code>cPickle</code> and <code>pickle</code> are mostly compatible; the differences lie in the API offered. For most use-cases, just stick with <code>cPickle</code>; it is faster. Quoting the <a href="https://docs.python.org/2/library/pickle.html#module-cPickle" rel="noreferrer">documentation</a> again:</p>
<blockquote>
<p>First, <code>cPickle</code> can be up to 1000 times faster than pickle because the former is implemented in C. Second, in the <code>cPickle</code> module the callables <code>Pickler()</code> and <code>Unpickler()</code> are functions, not classes. This means that you cannot use them to derive custom pickling and unpickling subclasses. Most applications have no need for this functionality and should benefit from the greatly improved performance of the <code>cPickle</code> module.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>For people using Python 3, there are, as of Python 3.5, five possible protocols to choose from:</p>
<p>There are currently 5 different protocols which can be used for pickling. The higher the protocol used, the more recent the version of Python needed to read the pickle produced [<a href="https://docs.python.org/3/library/pickle.html" rel="noreferrer" title="doc">doc</a>]:</p>
<blockquote>
<ul>
<li><p>Protocol version 0 is the original “human-readable” protocol and is backwards compatible with earlier versions of Python.</p></li>
<li><p>Protocol version 1 is an old binary format which is also compatible with earlier versions of Python.</p></li>
<li>Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of new-style classes. Refer to PEP 307 for
  information about improvements brought by protocol 2.</li>
<li>Protocol version 3 was added in Python 3.0. It has explicit support for bytes objects and cannot be unpickled by Python 2.x. This
  is the default protocol, and the recommended protocol when
  compatibility with other Python 3 versions is required.</li>
<li>Protocol version 4 was added in Python 3.4. It adds support for very large objects, pickling more kinds of objects, and some data
  format optimizations. Refer to PEP 3154 for information about
  improvements brought by protocol 4.</li>
</ul>
</blockquote>
<p>A general rule is that you should use the highest possible protocol that is backward compatible with what you want to use it for. So if you want it to be backward compatible with Python 2, then protocol version 2 is a good choice, if you want it to be backward compatible with all Python versions then version 1 is good. If you do not care about backward compatibility then using <code>pickle.HIGHEST_PROTOCOL</code> automatically gives you the highest protocol for your Python version. </p>
<p>Also in Python 3, importing <code>pickle</code> automatically imports the C implementation. </p>
<p>Another point to note in terms of compatibility is that, by default protocols 3 and 4 use unicode encoding of strings whereas earlier protocols do not. So in Python 3, if you load a pickled file which was pickled in Python 2, you will probably have to explicitly specify the encoding in order to load it properly. </p>
</div>
<span class="comment-copy">"pick" would be a good synonym for "choice" in this title :)</span>
<span class="comment-copy">@chepner "Picking python pickle protocol pointers?" :)</span>
<span class="comment-copy">@JonClements: ooh, I am <i>so</i> tempted to just edit the title now!</span>
<span class="comment-copy">@JonClements Better than the "Preferred python pickle protocol" I came up with later :)</span>
<span class="comment-copy">Oh, and +1 despite my lack of constructive comments.</span>
<span class="comment-copy"><code>pickle</code> is the C version in Python 3, and Python 3.4 uses protocol 3 which is <a href="http://stackoverflow.com/a/26860404/819417">twice as fast as protocol 2</a>.</span>
<span class="comment-copy">@CeesTimmerman: provided you don't <a href="http://stackoverflow.com/questions/24097507/why-pickle-version-4-is-slower-than-version-3">write individual small integers</a> and thus hobble the framing speed improvements, otherwise it is slower. :-) This answer is geared towards Python 2, as that is what the OP is asking about.</span>
<span class="comment-copy">I see &amp; have added the <code>python-2.7</code> tag. Isn't that benchmark comparing 3 and 4 instead of 2 and 3?</span>
<span class="comment-copy">@CeesTimmerman: sure, but it shows that even version 4 can be hobbled if used incorrectly.</span>
<span class="comment-copy">Thanks for the binary mode hint! As a developer solely using Unix for my own systems, I tend to forget to specify the IO modes, and therefore got problems with my pickle-using code on Windows.</span>
