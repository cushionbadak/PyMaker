<div class="post-text" itemprop="text">
<p>I am trying to create a <code>dict</code> which contains only a limited number of MRU entries (for helping in caching the output of a costly C function I call via ctypes). Here is the code:</p>
<pre><code>from collections import OrderedDict

class MRUDict(OrderedDict):

    def __init__(self, capacity = 64):
        super().__init__()
        self.__checkAndSetCapacity(capacity)

    def capacity(self):
        return self.__capacity

    def setCapacity(self, capacity):
        self.__checkAndSetCapacity(capacity)
        for i in range(len(self) - capacity):
            self.__evict() # will execute only if len &gt; capacity

    def __getitem__(self, key):
        value = super().__getitem__(key)
        # if above raises IndexError, next line won't execute
        print("Moving key {} to last i.e. MRU position".format(key))
        super().move_to_end(key)
        return value

    def __setitem__(self, key, value):
        if key in self:
            super().move_to_end(key)
        else: # new key
            if len(self) == self.__capacity:
                self.__evict()
        super().__setitem__(key, value)

    def __evict(self):
        key, value = self.popitem(last = False) # pop first i.e. oldest item
        print("Capacity exceeded. Evicting ({}, {})".format(key, value))

    def __checkAndSetCapacity(self, capacity):
        if not isinstance(capacity, int):
            raise TypeError("Capacity should be an int.")
        if capacity == 0:
            raise ValueError("Capacity should not be zero.")
        self.__capacity = capacity
</code></pre>
<p>... and here is the testing code:</p>
<pre><code>def printkeys(d):
    print("Current keys in order:", tuple(d)) # here d means d.keys()
    print()

from mrudict import MRUDict
print("Creating MRUDict with capacity 5.")
d = MRUDict(5)
print("Adding keys 0 to 7 with values:")
for i in range(8): d[i] = i + 0.1
printkeys(d)

print("Calling str on object:")
print(d) # test of default __repr__ (since probably __str__ is the same here)
printkeys(d)

print("Accessing existing key 4:")
print(4, d[4]) # test of __getitem__
printkeys(d)

try:
    print("Accessing non-existing key 20:")
    print(20, d[20]) # test of __getitem__
except:
    print("Caught exception: key does not exist.")
printkeys(d)

print("Updating value of existing key 6:")
d[6] = 6.6 # test of __setitem__ with existing key
printkeys(d)

print("Adding new key, value pair:")
d[10] = 10.1 # test of __setitem__ with non-existing key
printkeys(d)

print("Testing for presence of key 3:")
print(3 in d)
printkeys(d)

print("Trying to loop over the items:")
for k in d: print(k, d[k])
printkeys(d)

print("Trying to loop over the items:")
for k, v in d.items(): print(k, v)
printkeys(d)
</code></pre>
<p>Now from the output it seems I am being kind of naive in implementing the <code>__getitem__</code> function because both <code>__repr__</code> and <code>for ... in</code> (which, I'm guessing here, call <code>__iter__</code> and then <code>__getitem__</code>) causes the first item to be moved to the last as MRU, but cannot proceed further because there is no "next" item for the iterator since it now points to the last element. But I am not sure what I can do to fix the situation. Should I reimplement <code>__iter__</code>?</p>
<p>I am not sure how to distinguish between the user's calling <code>__getitem__</code> and an internal call to the same. Of course, a workaround is to make the user to use a <code>find()</code> method which would do the move-to-end thing, but I'd really like to be able to use the regular syntax <code>d[k]</code>.</p>
<p>Please advise on how to fix this. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>For complex changes of behaviour like these, it pays to study the <a href="http://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py#l26" rel="nofollow"><code>OrderedDict</code> source code</a>.</p>
<p>The actual <code>__iter__</code> method loops <em>directly</em> over the internal structure, the doubly linked list that maintains the item order. It'll never directly use <code>__getitem__</code>, instead just returning the keys from the linked list.</p>
<p>The actual problem that you are having is that you are <em>directly</em> accessing the items <em>while looping</em>:</p>
<pre><code>for k in d: print(k, d[k])
</code></pre>
<p>There is a <code>d[k]</code> in there; it is <em>that</em> access that moves item 5 from start to end. This updates the linked list, so when asking for the next item the <code>curr.next</code> reference is now the root and iteration stops.</p>
<p>The work-around would be to <em>not do that</em>. Add a dedicated method to access items without triggering the MRU update. Or you could re-use <code>dict.get()</code> for example:</p>
<pre><code>&gt;&gt;&gt; for k in d: print(k, d.get(k))
... 
5 5.1
7 7.1
4 4.1
6 6.6
10 10.1
</code></pre>
<p>You <em>will</em> have a problem with the <code>.items()</code> method; <code>OrderedDict</code> reuses <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableMapping" rel="nofollow"><code>collections.abc.MutableMapping</code></a>'s <code>.items()</code> method, which returns a <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.ItemsView" rel="nofollow"><code>collections.abc.ItemsView()</code></a> instance; see the <a href="http://hg.python.org/cpython/file/6d2982ff441f/Lib/_collections_abc.py#l387" rel="nofollow"><code>collections.abc</code> source code</a>.</p>
<p>You'll have to replace that behaviour:</p>
<pre><code>from collections.abc import ItemsView


class MRUDictItemsView(ItemsView):
    def __contains__(self, item):
        key, value = item
        v = self._mapping.get(key, object())
        return v == value

    def __iter__(self):
        for key in self._mapping:
            yield (key, self._mapping.get(key))


class MRUDict(OrderedDict):
    # ...

    def items(self):
        return MRUDictItemsView(self)
</code></pre>
<p>You'd have to do the same for the <code>.keys()</code> and <code>.values()</code> methods.</p>
</div>
<span class="comment-copy">Could you explain the problem more clearly, please; how does the output you get from your current testing differ from what you wanted/expected?</span>
<span class="comment-copy">@jonrsharpe: <code>__getitem__</code> modifies the order.. So when iterating, the first item moves to the last and iteration apparently breaks.</span>
<span class="comment-copy">Internally, <code>OrderedDict</code> uses chained list. <code>__iter__</code> goes over that chained list directly, no <code>__getitem__</code> is being called.</span>
<span class="comment-copy">Ah, <code>.items()</code> reuses <code>MutableMapping.items()</code>, returning a <code>ItemsView()</code> object that <i>does</i> use <code>__getitem__</code> on your custom class. Replace <i>that</i> to not use <code>__getitem__</code> but some other internal method.</span>
<span class="comment-copy">I updated my answer now that I had some time to actually parse your test suite. For future reference: do try to reduce your sample code to something that immediately demonstrates the issue. Most of your test suite is extraneous to your problem.</span>
<span class="comment-copy">Hello thank you very much for your detailed reply and sorry about the extra stuff in the test suite. Now I understand I have to reimplement the <code>ItemsView</code> to avoid using <code>[]</code> i.e. <code>__getitem__</code> and to use <code>.get()</code> instead, and from the <code>collections.abc</code> link you give it is clear I have to reimplement <code>ValuesView</code> too, but given that <code>KeysView</code> doesn't seem to use <code>[]</code> I don't need to reimplement that, right?</span>
<span class="comment-copy">OK what I did on top of what Martijn gave as code above was to just to add a <code>, ValuesView</code> to the <code>from collections.abc import</code> line and to add a <code>MRUDictValuesView</code> at module level replacing the <code>[]</code> in the <code>ValuesView</code> methods by <code>.get()</code>, and to add a <code>.values()</code> to <code>MRUDict</code> and it works now. Thank you very much Martijn!</span>
<span class="comment-copy">Right, <code>KeysView</code> indeed won't trigger <code>__getitem__</code>.</span>
