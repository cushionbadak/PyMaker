<div class="post-text" itemprop="text">
<p>I've simplified my import problems down to this simple base case. Say I have a Python package:</p>
<pre><code>mypkg/
   __init__.py
   a.py
   b.py
</code></pre>
<p>a.py contains:</p>
<pre><code>def echo(msg):
    return msg
</code></pre>
<p>b.py contains:</p>
<pre><code>from mypkg import a       # possibility 1, doesn't work
#import a                 # possibility 2, works
#from mypkg.a import echo  # import also fails

print(a.echo())
</code></pre>
<p>Running <code>python b.py</code> produces <code>ImportError: No module named mypkg</code> on both Python 2.7.6 and Python 3.3.5. I have also tried adding <code>from __future__ import absolute_import</code> in both cases, same issue. </p>
<h3>Expected:</h3>
<p>I expect possibility 1 to work just fine.</p>
<h3>Why do I want to do this:</h3>
<p>Possibility 2 is less desirable. Hypothetically, the standard library could introduce a package called <code>a</code> (unlikely in this case, but you get the idea). While Python 2 searches the <a href="https://docs.python.org/2/tutorial/modules.html#intra-package-references" rel="noreferrer">current package first</a>, Python 3+ includes absolute import changes so that the standard library is checked first.
No matter what my reason, possibility 1 is supposed to work, no? I could swear I've done it thousands of times before.</p>
<p>Note: If you write a script external to <code>mypkg</code>, <code>from mypkg import a</code> works without issue.</p>
<p>My question is similar to <a href="https://stackoverflow.com/questions/11951941/python-absolute-import-for-module-in-the-same-directory#">python - absolute import for module in the same directory</a>, but the author implies that what I have should be working.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>from mypkg import a</code> is the correct form. Don't run scripts from inside the Python package directory, it makes the same module available using multiple names that may lead to bugs. Run <code>pythonÂ -m mypkg.b</code> from the directory that contains <code>mypkg</code> instead.</p>
<p>To be able to run from any directory, <code>mypkg</code> should be in pythonpath.      </p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem comes from the fact that you don't have a reference to <em>mypkg</em> inside the <em>mypkg</em> folder. Look at what Python is doing  when I try to run your example (using the verbose option):</p>
<pre><code># trying /vagrant/mypkg/mypkg.py
</code></pre>
<p>That's why it can find the module, because it doesn't exist. One hack you could do is to have a file called <em>mypkg.py</em> with the line</p>
<pre><code>import a
</code></pre>
<p>but that's just your 2nd possibility above in another jacket. Without knowing what you want to accomplish, I would choose the first example on the <a href="https://docs.python.org/2/tutorial/modules.html#intra-package-references" rel="nofollow">Intra-package Reference</a> text. I would write <em>b.py</em> as such:</p>
<pre><code>from a import echo

print(echo('message'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes it will not work, because at the moment you call <code>print(mypkg.a.echo())</code>, <code>mypkg</code> is still loading (<code>mypkg.__init__</code> -&gt; <code>mypkg.b</code>). This is because Python loads parent modules first. <a href="https://docs.python.org/3/reference/import.html#searching" rel="nofollow noreferrer">https://docs.python.org/3/reference/import.html#searching</a></p>
<p>What you can do is wrap <code>print(mypkg.a.echo())</code> into a function:</p>
<pre><code>def echo():
   mypkg.a.echo()
</code></pre>
<p>And then:</p>
<pre><code>import mypkg.b
mypkg.b.echo()
</code></pre>
<p>Or even:</p>
<pre><code>print(sys.modules['mypkg.a'].echo())
</code></pre>
<p>Also you can help Python to find your module:</p>
<pre><code>import importlib
mypkg.a = importlib.import_module('mypkg.a')
mypkg.a.echo()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>import sys
import os
this_dir = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.dirname(this_dir))

from mypkg import a
print(a.echo())
</code></pre>
</div>
<span class="comment-copy">The absolute path to the same folder is not needed. See the <a href="http://stackoverflow.com/a/11952026/2886003">answer</a>  to the cited question.</span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/23177615/4279">how to use relative import within python spyder IDE</a> (see the links in my answer: they apply to the absolute imports too)</span>
<span class="comment-copy">This <i>works</i>, but is frowned upon.  If it's your own script and you're not sharing it, this is fine.  But you don't want to be making packages that mess with users' <code>$PATH</code> environment variables.</span>
