<div class="post-text" itemprop="text">
<p>I am looking for a function who do:</p>
<pre><code>def unsignedToByteString(size, value):
  // ...
  return output

unsignedToByteString(2, 0x5678) = '\x56\x78'
unsignedToByteString(4,   1234) = '\x00\x00\x04\xd2'
</code></pre>
<p>Argument:</p>
<ul>
<li>size: len of the string</li>
<li>value: the value to convert to hexadecimal string</li>
</ul>
<p>Is there any built-in function to do that.
If not how can that be easily done.</p>
<p>Update: I found <code>chr</code> function for having a value less than 126 to a hexadecimal character. (I guess i can use that to build a string)</p>
<pre><code>chr(0xab) = '\xab'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can start by using <code>hex</code> function. It will turn <code>1234</code> input into <code>'0x4d2'</code> and <code>0x5678</code> will stay <code>'0x5678'</code>. Then you can use <code>zfill</code> method to get it to the required size. And then all is left is to use <code>decode('hex')</code> on it. Here is the code:</p>
<pre><code>def unsignedToHexaString(size, value):
    output = hex(value)
    output = output[2:].zfill(size*2)
    return output.decode('hex')
</code></pre>
<p>If your value fits into 1, 2, 4 or 8 bytes, you can use the <a href="https://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('H', 0x5678)
b'xV'
&gt;&gt;&gt; struct.pack('H', 0xbeef)
b'\xef\xbe'
&gt;&gt;&gt; struct.pack('!H', 0xbeef) # big-endian byte order
b'\xbe\xef'
&gt;&gt;&gt; struct.pack('!L', 0xbeef)
b'\x00\x00\xbe\xef'
</code></pre>
<p>If you need to encode larger values, you have to split it into smaller chunks yourself. For example, with 128 bits:</p>
<pre><code>&gt;&gt;&gt; struct.pack('!QQ', *divmod(0xdeadbeef0cafe0deadbeef, 2**64))
b'\x00\x00\x00\x00\x00\xde\xad\xbe\xef\x0c\xaf\xe0\xde\xad\xbe\xef'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a one-liner:</p>
<pre class="lang-py prettyprint-override"><code>unsignedToHexaString = lambda s, v: (("%%0%dx" % (s * 2)) % v).decode("hex")
</code></pre>
</div>
<span class="comment-copy">What research have you done to show there isn't a function that does this? What code have you tried to solve this problem?</span>
<span class="comment-copy">I did not find any on python official documentation nor in stackoverflow nor in google, this is why I am posting in stackoverflow... I found <code>chr(0xab) = '\xab'</code> which can be used but I didn't find any for value more than 255 (1B) which would produce a string.</span>
<span class="comment-copy">What is the <code>size</code> variable controlling ? How many pairs of hex digits in the output?</span>
<span class="comment-copy">Sorry about that, I forgot to add the explanation, It is the output string size. I will update the ticket</span>
<span class="comment-copy">@Phong: to help you with your terminology: you do not want a "hexadecimal string", ie. something like "deadbeef", you want a simple "byte string" containing the same byte values as your integer. it's hard to explain in a comment, but think about this: in this case "hexadecimal" only comes into play when you <i>display</i> the string.</span>
<span class="comment-copy">I have tried this out, and it looks like it is working pretty fine.  I guess <code>decode('hex')</code> was the function I was looking for.</span>
<span class="comment-copy">And to check if there is no overflow, I guess you can compare <code>len(output) == size * 2</code></span>
<span class="comment-copy">You actually figured out why i needed that function. I wanted to use struct but the size of the value was quite unconventional (16B) that I needed a conversion function.</span>
<span class="comment-copy">@Phong: you asked the wrong question, then. didn't you?</span>
<span class="comment-copy">@Phong: in an inelegant way</span>
<span class="comment-copy"><i>"the value to convert to hexadecimal string"</i>, is that so?</span>
<span class="comment-copy">Is there any misunderstanding in my post ? (my output wanted value is '\x12\x34' and not '0x1234')</span>
<span class="comment-copy">@Phong: yes, very much so</span>
<span class="comment-copy">could you fix it for me (or telling me how to fix it ?). I guess my terminology is quite wrong</span>
