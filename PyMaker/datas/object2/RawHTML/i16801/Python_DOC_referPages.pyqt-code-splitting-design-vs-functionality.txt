<div class="post-text" itemprop="text">
<p>Am struggling to comprehend how to split code in (Py)Qt.  The aim is to have the design &amp; navigation tabs in QMainWindow, each tab triggering code in other files.  So far it only launches with the ActionClass in the same document / putting in an external document causes 'app not defined' when clicking the tab.  The below works without errors, but is clunky.  </p>
<pre><code>class Main(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)

        self.u = Ui_MainWindow()
        self.u.setupUi(self)

        self.u.tabs.currentChanged.connect(self.TabsChanged)

    def TabsChanged(self, i):
        if i == self.u.tabs.indexOf(self.u.tabFirst): ActionClass.__init__


class ActionClass(Main):
    def __init__(self):
        app.u.lineEdit.setText("test")

app = Main()
app.show()
sys.exit(app.exec_())
</code></pre>
<p>The examples I keep seeing have all code in one document.  Is there another way to do this e.g. where the ActionClass is in another file/writing u.lineEdit.setText instead of app.u.lineEdit.setText.  It seems inheritance &amp; an instance of Main can't be accessed from the ActionClasses doc, so I can't see how they would communicate back to the Main?  </p>
<p>Much appreciated        </p>
</div>
<div class="post-text" itemprop="text">
<p>As suggest @M4rtini you  can separate your code into <a href="https://docs.python.org/3/tutorial/modules.html" rel="nofollow">python modules</a>. And then <strong>import</strong> them (use them) in your main module.</p>
<p>For instance the code you posted can be separated in to files:</p>
<pre><code># actions_class.py

class ActionClass(Main):
    def __init__(self):
        app.u.lineEdit.setText("test")
</code></pre>
<p>and </p>
<pre><code># main.py

from action_class import ActionClass  # This line no need much explanation ;)

class Main(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)

        self.u = Ui_MainWindow()
        self.u.setupUi(self)

        self.u.tabs.currentChanged.connect(self.TabsChanged)

    def TabsChanged(self, i):
        if i == self.u.tabs.indexOf(self.u.tabFirst): ActionClass.__init__

app = Main()
app.show()
sys.exit(app.exec_())
</code></pre>
<p>In order to understand how <strong>import</strong> works see the link I left you above.</p>
<p><strong>More explanation</strong></p>
<p>Lest's see:</p>
<p>The correct way of executin code inside a <code>__init__</code> method is creating an instance. See the example below.</p>
<pre><code>class A:
    def __init__(self):
        print("Executing A.__init__")

print("Doing things wrong")
A.__init__     # This don't print enything
print("Doing things well")
A()            # This works as expected.
</code></pre>
<p>So, you line reads:</p>
<pre><code>if i == self.u.tabs.indexOf(self.u.tabFirst): ActionClass.__init__
</code></pre>
<p>and should reads:</p>
<pre><code>if i == self.u.tabs.indexOf(self.u.tabFirst): ActionClass()
</code></pre>
<p>On the other hand, is a bad practice put code that's not for initialize the instance inside the <code>__init__</code> methods.
If you don't need the instance but yet you want to store the functions inside a class (something like a c++ namespace) you creating
use <code>@staticmethod</code>  decorator.</p>
<pre><code>class A:

    @staticmethod
    def foo():
        print("Oh, wow, a static method in Python!")

A.foo()
</code></pre>
<p>So, your <code>ActionClass</code> could be rewritten as:</p>
<pre><code>class ActionClass(Main):

    @staticmethod
    def do_action:
        app.u.lineEdit.setText("test")
</code></pre>
<p>ans then you can use it like this:</p>
<pre><code> if i == self.u.tabs.indexOf(self.u.tabFirst): ActionClass.do_action()
</code></pre>
</div>
<span class="comment-copy">You can't just put stuff in different files and expect them to automagically know of each other. You need to import them into the main file that is run. This is not a specific pyqt problem. But a general python problem.</span>
<span class="comment-copy">Hey M4rtini.  Many thanks for the comment.  Import statements have been included at the top of both documents, but it fails when trying to import the 'Main' class into the external code document, and thus can't be used for inheritance of 'Main'.</span>
<span class="comment-copy">Raydel.  Thank you so much for your reply, it means a lot.  Have applied the code.  Running main.py gives 'Main is not defined'.  Adding 'from main import Main (or import *)' to action_class.py still gives the error.  Both files are in the same directory.  Have tested this dual-importing with separate/non-Qt files, and it gives the same error when each is importing the other, like it's importing the whole document but gets stuck thinking the others content doesn't exist. Even single variables in each document similarly failed.  Any ideas?  Regards</span>
<span class="comment-copy">You have imported <code>QMainWindow</code> in <code>main.py</code> too right?</span>
<span class="comment-copy">It would be nice if you post all your code.</span>
<span class="comment-copy">There is something rare about all this. You say the error is <code>Cannot import name Main</code> but I can't see you're importing anyhing called <code>Main</code> in your example. Besides you are running into a well known problem, your imports are <b>recursive</b> in your <code>classes</code> module you're importing <code>classImports</code> and in <code>classImports</code> you're importing <code>classes</code> there are many question about that here in <b>StackOverflow</b>.</span>
<span class="comment-copy">No, the problem is that when you put code in the <code>__init__</code> method <b>the correct way for executing that code</b> is creating an instance of thr class. See the answer Edit for more explanation.</span>
