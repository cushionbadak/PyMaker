<div class="post-text" itemprop="text">
<p>I need to execute a line of python code that is entered by the user.
If it is a statement I want to execute it, but if it is an expression, I want the result to be returned and do some fancy stuff with it.
The problem is that python has two different functions for that, namely <code>exec</code> and <code>eval</code>.</p>
<p>Currently I just try to evaluate the string that the user entered.
If that raises a SyntaxError, this may indicate that the string is an statement instead, so I try to execute it.</p>
<pre><code>try:
    result = eval(command, scope)
except SyntaxError:
    # Probably command is a statement, not an expression
    try:
        exec(command, scope)
    except Exception as e:
        return command + ' : ' + str(e)
except Exception as e:
    return command + ' : ' + str(e)
else:
    pass # Some fancy stuff
</code></pre>
<p>This feels rather hacky. Is there a neater, more pythonic way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>While I think your existing code is probably reasonably Pythonic (under the doctrine that it's "easier to ask forgiveness than permission"), I suspect the best alternative approach is to use the <a href="https://docs.python.org/3/library/ast.html" rel="nofollow"><code>ast</code></a> module to inspect the code in your string:</p>
<pre><code>tree = ast.parse(some_input_string)
if len(tree.body) == 1 and isinstance(tree.body[0], ast.Expr):
    result = eval(some_input_string, scope)
else:
    exec(some_input_string, scope)
    result = None
</code></pre>
<p>Note that some common statements are really "expression statements". So, an input string like <code>'do_stuff("args")'</code> will use the <code>eval</code> branch of the code above, rather than the <code>exec</code> branch. I don't think this will have any adverse consequences, but you never know.</p>
<p>It is also possible to compile the <code>tree</code> that has been parsed and then pass the result into the <code>eval</code> or <code>exec</code> calls later. I found it rather fiddly to get right though (you need to wrap the <code>ast.Expr</code>'s <code>value</code> attribute in an <code>ast.Expression</code> in the top branch) and so I went with the simpler (to read and understand) alternative of just passing in the string and letting Python parse it again.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can refactor the try-except a bit. There's no real context in your example, but assuming you want to be able to execute <code>a=1</code> and then evaluate <code>a</code> afterwards and get <code>1</code>, then you could do something like...</p>
<pre><code>from code import InteractiveConsole
interpreter = InteractiveConsole()

def run(code):

    try: return eval(code.strip(), interpreter.locals)
    except: pass

    try: interpreter.runcode(code)
    except Exception as error: return error
</code></pre>
<p>This should work for more than one line of code too.</p>
<p>Without knowing a bit more about your objective it's difficult to say how to do it best, but what you have is fine in principle, it just needs tidying up. This similar <a href="https://stackoverflow.com/a/12248814/1253428">answer</a> includes a minimal version of the same try-except logic again, with a focus on mimicking the interpreter more faithfully.</p>
</div>
<div class="post-text" itemprop="text">
<p>you missed one, actually there are <em>three</em> functions related to executing code, and the one you missed is <a href="https://docs.python.org/3.4/library/functions.html#compile" rel="nofollow"><code>compile()</code></a>.</p>
<p><code>compile()</code> takes three required arguments, the code to be compiled, the name of the module being compiled, which will appear in tracebacks originating from that code, and a "mode".  The mode argument should be one of "exec", for compiling whole modules, "eval" for compiling simple expressions, and "single", which should be a single line of interactive input!</p>
<p>In all three cases, you pass the returned <code>code</code> object to <code>eval</code>, with the desired context:</p>
<pre><code>&gt;&gt;&gt; c = compile("if 1 &lt; 2:\n    print(3)", "&lt;string&gt;", "single")
&gt;&gt;&gt; eval(c)
3
&gt;&gt;&gt; 
</code></pre>
</div>
<span class="comment-copy">Blindly executing user-supplied code is a dangerous game.</span>
<span class="comment-copy">Yep, I'm aware of that.  But I'm implementing an embedded interpreter. Notice that I supply the scope though.</span>
<span class="comment-copy">Close voter: this is not opinion based. I'm asking for the pythonic way, which is a generally accepted question on this site.</span>
<span class="comment-copy">You probably want <a href="https://docs.python.org/2/library/code.html" rel="nofollow noreferrer">the code module</a>.</span>
<span class="comment-copy">@Lattyware I've looked at it and I'm not sure how. It seems that those functions do extra stuff like printing the eval result, which is not what I want.</span>
<span class="comment-copy">Note that <code>eval</code> is returning <code>None</code> in your example, not <code>3</code>. The <code>3</code> is being displayed because of the <code>print</code> call.</span>
<span class="comment-copy">indeed, even simple expressions, will "return" <code>None</code> when compiled with "single", but will invoke <code>sys.displayhook</code>.</span>
<span class="comment-copy">As explained in the question, when evaluating an expression, I need the result to be returned, not printed. So even when you use <code>compile</code>, still the decision has to be made whether to pass 'exec' or 'eval'.</span>
