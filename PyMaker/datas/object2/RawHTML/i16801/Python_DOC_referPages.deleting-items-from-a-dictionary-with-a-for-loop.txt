<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/11939207/deleting-entries-in-a-dictionary-based-on-a-condition">deleting entries in a dictionary based on a condition</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>I'm trying to drop items from a dictionary if the value of the key is below a certain threshold. For a simple example to what I mean:</p>
<pre><code>my_dict = {'blue': 1, 'red': 2, 'yellow': 3, 'green': 4}

for color in my_dict:
    threshold_value = 3
    if my_dict[color] &lt; threshold_value:
        del my_dict[color]

print(my_dict)
</code></pre>
<p>Now, I get a <code>RuntimeError: dictionary changed size during iteration</code> error. No big surprises there. The reason I'm posting this question is:</p>
<ol>
<li><p>Find out if there's an elegant solution that doesn't require creating a new dictionary (that holds only the keys with values &gt;= threshold).</p></li>
<li><p>Try to understand Python's rationale here. The way I read it to myself is: "go to the first key. Is the value of that key &lt; x ? if yes - del this key:value item and continue on the the next key in the dictionary, if no - continue to next key without doing anything". In other words, what happened historically to previous keys shouldn't affect where I go next. I'm looking forward to the next items, regardless of the past.
I know it's a funny (some might say stupid, I'll give you that) but what's Python's "way of thinking" about this loop? Why doesn't it work? How would Python read it out loud to itself? Just trying to get a better understanding of the language...</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Due to the fact that Python dictionaries are implemented as hash tables, you shouldn't rely on them having any sort of an order. Key order may change unpredictably (but only after insertion or removal of a key). Thus, it's impossible to predict the next key. Python throws the <code>RuntimeError</code> to be safe, and to prevent people from running into unexpected results.</p>
<p>Python 2's <a href="https://docs.python.org/2/library/stdtypes.html#dict.items" rel="nofollow noreferrer"><code>dict.items</code></a> method returns a <em>copy</em> of key-value pairs, so you can safely iterate over it and delete values you don't need by keys, as <a href="https://stackoverflow.com/users/674039/wim">@wim</a> suggested in comments. Example:</p>
<pre><code>for k, v in my_dict.items():
    if v &lt; threshold_value:
        del my_dict[k]
</code></pre>
<p>However, Python 3's <code>dict.items</code> returns a <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">view object</a> that reflects all changes made to the  dictionary. This is the reason the solution above only works in Python 2. You may convert <code>my_dict.items()</code> to <code>list</code> (<code>tuple</code> etc.) to make it Python 3-compatible.</p>
<p>Another  way to approach the problem is to select keys you want to delete and <em>then</em> delete them</p>
<pre><code>keys = [k for k, v in my_dict.items() if v &lt; threshold_value]
for x in keys:
    del my_dict[x]
</code></pre>
<p>This works in both Python 2 and Python 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries are unordered. By deleting one key nobody can say, what the next key is. So python in general disallow to add or remove keys from a dictionary, over that is iterated.</p>
<p>Just create a new one:</p>
<pre><code>my_dict = {"blue":1,"red":2,"yellow":3,"green":4}
new_dict = {k:v for k,v in my_dict.iteritems() if v &gt;= threshold_value}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I guess that modifying a collection while iterating over it is a hard thing to do to implement properly. Consider following exaple: </p>
<pre><code>&gt;&gt;&gt; list = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; for ii in range(len(list)):
  print list[ii]; 
  if list[ii] == 3:
    del list[ii]      
 1
 2
 3
 5
 6
</code></pre>
<p>Notice that in this example 4 was altogether omitted. It is very similat in dictionaries, deleting/adding entries might invalidate internal structures that define order of iteration (for example you deleted enough entries so hash map bucket size changed). </p>
<p>To solve your case --- just create new dictionary and copy items there. As to</p>
</div>
<span class="comment-copy">as I said in the OP, I don't want to create a new dict.</span>
<span class="comment-copy">You asked for an elegant way. But you can program whatever you like.</span>
