<div class="post-text" itemprop="text">
<p>This seems to be simple but I cannot find a way to do it. I need to show whether the cube root of an integer is integer or not. I used <code>is_integer()</code> float method in Python 3.4 but that wasn't successful. As</p>
<pre><code>x = (3**3)**(1/3.0) 
is_integer(x)    
True
</code></pre>
<p>but</p>
<pre><code>x = (4**3)**(1/3.0) 
is_integer(x)    
False
</code></pre>
<p>I tried <code>x%1 == 0</code>,<code>x == int(x)</code> and <code>isinstance(x,int)</code> with no success. </p>
<p>I'd appreciate any comment.</p>
</div>
<div class="post-text" itemprop="text">
<p>For small numbers (&lt;~10<sup>13</sup> or so), you can use the following approach:</p>
<pre><code>def is_perfect_cube(n):
    c = int(n**(1/3.))
    return (c**3 == n) or ((c+1)**3 == n)
</code></pre>
<p>This truncates the floating-point cuberoot, then tests the two nearest integers.</p>
<p>For larger numbers, one way to do it is to do a binary search for the true cube root using integers only to preserve precision:</p>
<pre><code>def find_cube_root(n):
    lo = 0
    hi = n
    while lo &lt; hi:
        mid = (lo+hi)//2
        if mid**3 &lt; n:
            lo = mid+1
        else:
            hi = mid
    return lo

def is_perfect_cube(n):
    return find_cube_root(n)**3 == n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In SymPy there is also the <code>integer_nthroot</code> function which will quickly find the integer nth root of a number and tell you whether it was exact, too:</p>
<pre><code>&gt;&gt;&gt; integer_nthroot(primorial(12)+1,3)
(19505, False)
</code></pre>
<p>So your function could be </p>
<pre><code>def is_perfect_cube(x): return integer_nthroot(x, 3)[1]
</code></pre>
<p>(And because SymPy is open source, you can look at the routine to see how <code>integer_nthroot</code> works.)</p>
</div>
<div class="post-text" itemprop="text">
<p>If your numbers aren't big, I would do:</p>
<pre><code>def is_perfect_cube(number):
    return number in [x**3 for x in range(15)]
</code></pre>
<p>Of course, <code>15</code> could be replaced with something more appropriate.</p>
<p>If you do need to deal with big numbers, I would use the <a href="http://pypi.python.org/pypi/sympy/0.7.5" rel="nofollow"><code>sympy</code></a> library to get more accurate results.</p>
<pre><code>from sympy import S, Rational

def is_perfect_cube(number):
    # change the number into a sympy object
    num = S(number)
    return (num**Rational(1,3)).is_Integer
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you should use the <a href="https://docs.python.org/2/library/functions.html#round" rel="nofollow"><code>round</code></a> function to get the answer. If I had to write a function then it will be as follows:</p>
<pre><code>def cube_integer(n):
    if round(n**(1.0/3.0))**3 == n:
        return True
    return False
</code></pre>
<p>You can use something similar to <code>int(n**(1.0/3.0)) == n**(1.0/3.0)</code>, but in python because of some issues with the computation of the value of cube root, it is not exactly computed. For example <code>int(41063625**(1.0/3.0))</code> will give you 344, but the value should be 345.</p>
<p>Hope I have answered your question. If you have any doubt, then feel free to <a href="http://radiusofcircle.blogspot.com" rel="nofollow">contact me</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>To elaborate on the answer by @nneonneo, one could write a more general kth-root function to use instead of cube_root,</p>
<pre><code>def kth_root(n,k):
    lb,ub = 0,n #lower bound, upper bound
    while lb &lt; ub:
        guess = (lb+ub)//2
        if pow(guess,k) &lt; n: lb = guess+1
        else: ub = guess
    return lb

def is_perfect_cube(n):
    return kth_root(n,3) == n
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is another approach using the <a href="https://docs.python.org/3/library/math.html" rel="nofollow noreferrer">math module</a>.</p>
<pre><code>import math
num = int(input('Enter a number: '))
root = int(input('Enter a root: '))
nth_root = math.pow(num, (1/root))
nth_root = round(nth_root, 10)
print('\nThe {} root of {} is {}.'.format(root, num, nth_root))
decimal, whole = math.modf(nth_root)
print('The decimal portion of this cube root is {}.'.format(decimal))
decimal == 0
</code></pre>
<p>Line 1: Import math module.<br/>
Line 2: Enter the number you would like to get the root of.<br/>
Line 3: Enter the nth root you are looking for.<br/>
Line 4: Use the power function.<br/>
Line 5: Rounded to 10 significant figures to account for <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">floating point approximations</a>.<br/>
Line 6: Print a preview of the nth root of the selected number.<br/>
Line 7: Use the modf function to get the fractional and integer parts.<br/>
Line 8: Print a preview of decimal part of the cube root value.<br/>
Line 9: Return <strong><em>True</em></strong> if the cube root is an integer. Return <strong><em>False</em></strong> if the cube root value contains fractional numbers.</p>
</div>
<span class="comment-copy">Unfortunately that's not a sane way to do it.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams Ok!Is there any sane way then?</span>
<span class="comment-copy">Not especially. I'd put/find an upper limit and keep a list.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams but it wouldn't be accurate in some extent.</span>
<span class="comment-copy">I suspect you're encountering floating point rounding issues with your cube root. If your value differs from an integer by some tiny fraction, you'll see it as a non-integer. Try using a more float-appropriate test: <code>abs((x-round(x))/x) &lt; epsilon</code> (for some small epsilon).</span>
<span class="comment-copy">That seems good, but unfortunately my numbers are a bit bigger that $10^{13}.$</span>
<span class="comment-copy">Then use the binary search approach.</span>
<span class="comment-copy">@nneoneo, you're right, I will.</span>
<span class="comment-copy">For the binary search you can take the logarithm of the input and use it to compute an initial <code>lo</code> and <code>hi</code>, to restrict the search space.</span>
<span class="comment-copy"><code>abs(n)  &lt; 2**n.bit_length()</code> -&gt; <code>abs(n)**(1/3) &lt; 2**((n.bit_length() + 2)  // 3)</code> -&gt; <code>hi = 2**((n.bit_length() + 2)  // 3)</code> e.g., for <code>n=10**13</code> -&gt; <code>hi = 2**15 = 32768</code></span>
