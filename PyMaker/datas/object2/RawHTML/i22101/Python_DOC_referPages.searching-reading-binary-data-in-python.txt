<div class="post-text" itemprop="text">
<p>I'm reading in a binary file (a jpg in this case), and need to find some values in that file. For those interested, the binary file is a jpg and I'm attempting to pick out its dimensions by looking for the binary structure as <a href="http://www.anttikupila.com/flash/getting-jpg-dimensions-with-as3-without-loading-the-entire-file/" rel="noreferrer">detailed here</a>. </p>
<p>I need to find FFC0 in the binary data, skip ahead some number of bytes, and then read 4 bytes (this should give me the image dimensions).</p>
<p>What's a good way of searching for the value in the binary data? Is there an equivalent of 'find', or something like re?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could actually load the file into a string and search that string for the byte sequence <code>0xffc0</code> using the <code>str.find()</code> method. It works for any byte sequence.</p>
<p>The code to do this depends on a couple things. If you open the file in binary mode and you're using Python 3 (both of which are probably best practice for this scenario), you'll need to search for a byte string (as opposed to a character string), which means you have to prefix the string with <code>b</code>.</p>
<pre><code>with open(filename, 'rb') as f:
    s = f.read()
s.find(b'\xff\xc0')
</code></pre>
<p>If you open the file in text mode in Python 3, you'd have to search for a character string:</p>
<pre><code>with open(filename, 'r') as f:
    s = f.read()
s.find('\xff\xc0')
</code></pre>
<p>though there's no particular reason to do this. It doesn't get you any advantage over the previous way, and if you're on a platform that treats binary files and text files differently (e.g. Windows), there is a chance this will cause problems.</p>
<p>Python 2 doesn't make the distinction between byte strings and character strings, so if you're using that version, it doesn't matter whether you include or exclude the <code>b</code> in <code>b'\xff\xc0'</code>. And if your platform treats binary files and text files identically (e.g. Mac or Linux), it doesn't matter whether you use <code>'r'</code> or <code>'rb'</code> as the file mode either. But I'd still recommend using something like the first code sample above just for forward compatibility - in case you ever do switch to Python 3, it's one less thing to fix.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="http://packages.python.org/bitstring/" rel="nofollow noreferrer">bitstring</a> module was designed for pretty much this purpose. For your case the following code (which I haven't tested) should help illustrate:</p>
<pre><code>from bitstring import ConstBitStream
# Can initialise from files, bytes, etc.
s = ConstBitStream(filename='your_file')
# Search to Start of Frame 0 code on byte boundary
found = s.find('0xffc0', bytealigned=True)
if found:
    print("Found start code at byte offset %d." % found[0])
    s0f0, length, bitdepth, height, width = s.readlist('hex:16, uint:16, 
                                                        uint:8, 2*uint:16')
    print("Width %d, Height %d" % (width, height))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of reading the entire file into memory, searching it and then writing a new file out to disk you can use the mmap module for this. mmap will <em>not</em> store the entire file in memory and it allows for in-place modification. </p>
<pre><code>#!/usr/bin/python

import mmap

with open("hugefile", "rw+b") as f:
    mm = mmap.mmap(f.fileno(), 0)
    print mm.find('\x00\x09\x03\x03')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>re</code> module <strong>does</strong> work with both string <strong>and binary</strong> data (<code>str</code> in Python 2 and <code>bytes</code> in Python 3), so you can use it as well as <code>str.find</code> for your task.</p>
</div>
<div class="post-text" itemprop="text">
<p>Well, obviously there is <a href="http://www.pythonware.com/products/pil/" rel="nofollow noreferrer">PIL</a> The Image module has size as an attribute. If you are wanting to get the size exactly how you suggest and without loading the file you are going to have to go through it line by line. Not the nicest way to do it but it would work.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#str.find" rel="nofollow"><code>find()</code></a> method should be used only if you need to know the position of sub, if not, you can use the <code>in</code> operator, for example:</p>
<pre><code>with open("foo.bin", 'rb') as f:
    if b'\x00' in f.read():
        print('The file is binary!')
    else:
        print('The file is not binary!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.x you can search a byte string by another byte string like this:</p>
<pre><code>&gt;&gt;&gt; byte_array = b'this is a byte array\r\n\r\nXYZ\x80\x04\x95 \x00\x00\x00\x00\x00'
&gt;&gt;&gt; byte_array.find('\r\n\r\n'.encode())
20
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For Python &gt;=3.2:</p>
<pre><code>import re

f = open("filename.jpg", "rb")
byte = f.read()
f.close()

matchObj = re.match( b'\xff\xd8.*\xff\xc0...(..)(..).*\xff\xd9', byte, re.MULTILINE|re.DOTALL)
if matchObj:
    # http://stackoverflow.com/questions/444591/convert-a-string-of-bytes-into-an-int-python
    print (int.from_bytes(matchObj.group(1), 'big')) # height
    print (int.from_bytes(matchObj.group(2), 'big')) # width
</code></pre>
</div>
<span class="comment-copy">have you ever looked into imagick? IIRC there is also a python library for it.</span>
<span class="comment-copy">I have, and it works great, but it's quite heavy for just finding the dimensions of the file.</span>
<span class="comment-copy">you should use a module appropriate for something like this <a href="http://snippets.dzone.com/posts/show/1021" rel="nofollow noreferrer">snippets.dzone.com/posts/show/1021</a></span>
<span class="comment-copy">If it's a really big file, it's not such a good idea to read it into a string all at once.</span>
<span class="comment-copy">I doubt it's so big it's going to be a problem.</span>
<span class="comment-copy">Since I'm only looking for the first frame I'll likely be able to read some small part of the file and process that instead of reading the whole file.</span>
<span class="comment-copy">@icktoofay: good point, but I would point out that you can do exactly what Parand is saying, just read the first N bytes and search those. If you did have to search all of a large file for a byte sequence, it could be done iteratively so you wouldn't have to keep the whole thing in memory at once, but the code would be a little more involved, and I didn't think it'd be necessary to get into that here.</span>
<span class="comment-copy">Exactly. I was just saying that it would be better to read/scan it in small chunks.</span>
<span class="comment-copy">So <code>Bits.find</code> returns just a boolean and sets the <code>Bits.bytepos</code> attribute? Perhaps in the module documentation you should warn that <code>bitstring</code> is not thread-safe (not that it matters in this answer, of course).</span>
<span class="comment-copy">@ΤΖΩΤΖΙΟΥ: Yes you have a good point. I don't find it surprising that mutating methods or reading methods aren't thread safe, but using 'find' on a bit-wise immutable object could reasonably be expected to be. To be honest it's never cropped up before but it is something to think about...</span>
<span class="comment-copy">Just an idea: <code>find</code> could return an object with all necessary information, à la <code>re.match</code> and <code>re.search</code>. You could have this “BitMatch” class be a subclass of <code>bool</code>, for backwards compatibility.</span>
<span class="comment-copy">@ΤΖΩΤΖΙΟΥ: Thanks, that's a reasonable idea although I'm in a good position to break backward compatibility slightly and maybe just have it return the bit position as a single item tuple if found or an empty tuple if not found. I guess anything's better than returning -1 if not found :)</span>
<span class="comment-copy">This did it for me - I was trying to compare a string to a byte string.  All I had to do was put the b in front of my search term and it was found within the byte string.</span>
