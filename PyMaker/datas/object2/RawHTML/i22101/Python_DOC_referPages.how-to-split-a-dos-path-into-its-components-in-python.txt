<div class="post-text" itemprop="text">
<p>I have a string variable which represents a dos path e.g:</p>
<p><code>var = "d:\stuff\morestuff\furtherdown\THEFILE.txt"</code></p>
<p>I want to split this string into:</p>
<p><code>[ "d", "stuff", "morestuff", "furtherdown", "THEFILE.txt" ]</code></p>
<p>I have tried using <code>split()</code> and <code>replace()</code> but they either only process the first backslash or they insert hex numbers into the string.</p>
<p>I need to convert this string variable into a raw string somehow so that I can parse it.</p>
<p>What's the best way to do this?</p>
<p>I should also add that the contents of <code>var</code> i.e. the path that I'm trying to parse, is actually the return value of a command line query. It's not path data that I generate myself. Its stored in a file, and the command line tool is not going to escape the backslashes.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've been bitten loads of times by people writing their own path fiddling functions and getting it wrong. Spaces, slashes, backslashes, colons -- the possibilities for confusion are not endless, but mistakes are easily made anyway. So I'm a stickler for the use of <code>os.path</code>, and recommend it on that basis.</p>
<p>(However, the path to virtue is not the one most easily taken, and many people when finding this are tempted to take a slippery path straight to damnation. They won't realise until one day everything falls to pieces, and they -- or, more likely, somebody else -- has to work out why everything has gone wrong, and it turns out somebody made a filename that mixes slashes and backslashes -- and some person suggests that the answer is "not to do that". Don't be any of these people. Except for the one who mixed up slashes and backslashes -- you could be them if you like.)</p>
<p>You can get the drive and path+file like this:</p>
<pre><code>drive, path_and_file = os.path.splitdrive(path)
</code></pre>
<p>Get the path and the file:</p>
<pre><code>path, file = os.path.split(path_and_file)
</code></pre>
<p>Getting the individual folder names is not especially convenient, but it is the sort of honest middling discomfort that heightens the pleasure of later finding something that actually works well:</p>
<pre><code>folders = []
while 1:
    path, folder = os.path.split(path)

    if folder != "":
        folders.append(folder)
    else:
        if path != "":
            folders.append(path)

        break

folders.reverse()
</code></pre>
<p>(This pops a <code>"\"</code> at the start of <code>folders</code> if the path was originally absolute. You could lose a bit of code if you didn't want that.)</p>
</div>
<div class="post-text" itemprop="text">
<p>I would do</p>
<pre><code>import os
path = os.path.normpath(path)
path.split(os.sep)
</code></pre>
<p>First normalize the path string into a proper string for the OS. Then <code>os.sep</code> must be safe to use as a delimiter in string function split.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use the most Pythonic approach (IMHO):</p>
<pre><code>import os

your_path = r"d:\stuff\morestuff\furtherdown\THEFILE.txt"
path_list = your_path.split(os.sep)
print path_list
</code></pre>
<p>Which will give you:</p>
<pre><code>['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
</code></pre>
<p>The clue here is to use <code>os.sep</code> instead of <code>'\\'</code> or <code>'/'</code>, as this makes it system independent.</p>
<p>To remove colon from the drive letter (although I don't see any reason why you would want to do that), you can write:</p>
<pre><code>path_list[0] = path_list[0][0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python &gt;=3.4 this has become much simpler. You can now use <a href="https://docs.python.org/3/library/pathlib.html#accessing-individual-parts" rel="noreferrer"><code>pathlib.Path.parts</code></a> to get all the parts of a path.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; Path('C:/path/to/file.txt').parts
('C:\\', 'path', 'to', 'file.txt')
&gt;&gt;&gt; Path(r'C:\path\to\file.txt').parts
('C:\\', 'path', 'to', 'file.txt')
</code></pre>
<p>On a Windows install of Python 3 this will assume that you are working with Windows paths, and on *nix it will assume that you are working with posix paths. This is usually what you want, but if it isn't you can use the classes <code>pathlib.PurePosixPath</code> or <code>pathlib.PureWindowsPath</code> as needed:</p>
<pre><code>&gt;&gt;&gt; from pathlib import PurePosixPath, PureWindowsPath
&gt;&gt;&gt; PurePosixPath('/path/to/file.txt').parts
('/', 'path', 'to', 'file.txt')
&gt;&gt;&gt; PureWindowsPath(r'C:\path\to\file.txt').parts
('C:\\', 'path', 'to', 'file.txt')
&gt;&gt;&gt; PureWindowsPath(r'\\host\share\path\to\file.txt').parts
('\\\\host\\share\\', 'path', 'to', 'file.txt')
</code></pre>
<p>Edit:
There is also a backport to python 2 available: <a href="https://pypi.python.org/pypi/pathlib2/" rel="noreferrer">pathlib2</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here starts with how you're creating the string in the first place.</p>
<pre><code>a = "d:\stuff\morestuff\furtherdown\THEFILE.txt"
</code></pre>
<p>Done this way, Python is trying to special case these: <code>\s</code>, <code>\m</code>, <code>\f</code>, and <code>\T</code>.  In your case, <code>\f</code> is being treated as a formfeed (0x0C) while the other backslashes are handled correctly.  What you need to do is one of these:</p>
<pre><code>b = "d:\\stuff\\morestuff\\furtherdown\\THEFILE.txt"      # doubled backslashes
c = r"d:\stuff\morestuff\furtherdown\THEFILE.txt"         # raw string, no doubling necessary
</code></pre>
<p>Then once you split either of these, you'll get the result you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>For a somewhat more concise solution, consider the following:</p>
<pre><code>def split_path(p):
    a,b = os.path.split(p)
    return (split_path(a) if len(a) and len(b) else []) + [b]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I can't actually contribute a real answer to this one (as I came here hoping to find one myself), but to me the number of differing approaches and all the caveats mentioned is the surest indicator that Python's os.path module desperately needs this as a built-in function.</p>
</div>
<div class="post-text" itemprop="text">
<p>It works for me:</p>
<pre><code>&gt;&gt;&gt; a=r"d:\stuff\morestuff\furtherdown\THEFILE.txt"
&gt;&gt;&gt; a.split("\\")
['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
</code></pre>
<p>Sure you might need to also strip out the colon from the first component, but keeping it makes it possible to re-assemble the path.</p>
<p>The <code>r</code> modifier marks the string literal as "raw"; notice how embedded backslashes are not doubled.</p>
</div>
<div class="post-text" itemprop="text">
<p>Let assume you have have a file <code>filedata.txt</code> with content:</p>
<pre><code>d:\stuff\morestuff\furtherdown\THEFILE.txt
d:\otherstuff\something\otherfile.txt
</code></pre>
<p>You can read and split the file paths:</p>
<pre><code>&gt;&gt;&gt; for i in open("filedata.txt").readlines():
...     print i.strip().split("\\")
... 
['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
['d:', 'otherstuff', 'something', 'otherfile.txt']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The stuff about about <code>mypath.split("\\")</code> would be better expressed as <code>mypath.split(os.pathsep)</code>. <code>pathsep</code> is the path separator for your particular platform (e.g., <code>\</code> for Windows, <code>/</code> for Unix, etc.), and the Python build knows which one to use. If you use <code>pathsep</code>, then your code will be platform agnostic.</p>
</div>
<div class="post-text" itemprop="text">
<p>re.split() can help a little more then string.split()</p>
<pre><code>import re    
var = "d:\stuff\morestuff\furtherdown\THEFILE.txt"
re.split( r'[\\/]', var )
['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
</code></pre>
<p>If you also want to support Linux and Mac paths, just add filter(None,result), so it will remove the unwanted '' from the split() since their paths starts with '/' or '//'. for example '//mount/...' or '/var/tmp/'</p>
<pre><code>import re    
var = "/var/stuff/morestuff/furtherdown/THEFILE.txt"
result = re.split( r'[\\/]', var )
filter( None, result )
['var', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The functional way, with a <em>generator</em>.</p>
<pre><code>def split(path):
    (drive, head) = os.path.splitdrive(path)
    while (head != os.sep):
        (head, tail) = os.path.split(head)
        yield tail
</code></pre>
<p>In action:</p>
<pre><code>&gt;&gt;&gt; print([x for x in split(os.path.normpath('/path/to/filename'))])
['filename', 'to', 'path']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can recursively <code>os.path.split</code> the string</p>
<pre><code>import os
def parts(path):
    p,f = os.path.split(path)
    return parts(p) + [f] if f else [p]
</code></pre>
<p>Testing this against some path strings, and reassembling the path with <code>os.path.join</code></p>
<pre><code>&gt;&gt;&gt; for path in [
...         r'd:\stuff\morestuff\furtherdown\THEFILE.txt',
...         '/path/to/file.txt',
...         'relative/path/to/file.txt',
...         r'C:\path\to\file.txt',
...         r'\\host\share\path\to\file.txt',
...     ]:
...     print parts(path), os.path.join(*parts(path))
... 
['d:\\', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt'] d:\stuff\morestuff\furtherdown\THEFILE.txt
['/', 'path', 'to', 'file.txt'] /path\to\file.txt
['', 'relative', 'path', 'to', 'file.txt'] relative\path\to\file.txt
['C:\\', 'path', 'to', 'file.txt'] C:\path\to\file.txt
['\\\\', 'host', 'share', 'path', 'to', 'file.txt'] \\host\share\path\to\file.txt
</code></pre>
<p>The first element of the list may need to be treated differently depending on how you want to deal with drive letters, UNC paths and absolute and relative paths. Changing the last <code>[p]</code> to <code>[os.path.splitdrive(p)]</code> forces the issue by splitting the drive letter and directory root out into a tuple.</p>
<pre><code>import os
def parts(path):
    p,f = os.path.split(path)
    return parts(p) + [f] if f else [os.path.splitdrive(p)]

[('d:', '\\'), 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
[('', '/'), 'path', 'to', 'file.txt']
[('', ''), 'relative', 'path', 'to', 'file.txt']
[('C:', '\\'), 'path', 'to', 'file.txt']
[('', '\\\\'), 'host', 'share', 'path', 'to', 'file.txt']
</code></pre>
<p>Edit: I have realised that this answer is very similar to <a href="https://stackoverflow.com/a/15050936/5002578">that given above</a> by <a href="https://stackoverflow.com/users/1556435/user1556435">user1556435</a>. I'm leaving my answer up as the handling of the drive component of the path is different.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just like others explained - your problem stemmed from using <code>\</code>, which is escape character in string literal/constant. OTOH, if you had that file path string from another source (read from file, console or returned by os function) - there wouldn't have been problem splitting on '\\' or r'\'.</p>
<p>And just like others suggested, if you want to use <code>\</code> in program literal, you have to either duplicate it <code>\\</code> or the whole literal has to be prefixed by <code>r</code>, like so <code>r'lite\ral'</code> or <code>r"lite\ral"</code> to avoid the parser converting that <code>\</code> and <code>r</code> to CR (carriage return) character.</p>
<p>There is one more way though - just don't use backslash <code>\</code> pathnames in your code! Since last century Windows recognizes and works fine with pathnames which use forward slash as directory separator <code>/</code>! Somehow not many people know that.. but it works:</p>
<pre><code>&gt;&gt;&gt; var = "d:/stuff/morestuff/furtherdown/THEFILE.txt"
&gt;&gt;&gt; var.split('/')
['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']
</code></pre>
<p>This by the way will make your code work on Unix, Windows and Mac... because all of them do use <code>/</code> as directory separator... even if you don't want to use the predefined constants of module <code>os</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I use the following as since it uses the os.path.basename function it doesn't add any slashes to the returned list. It also works with any platform's slashes: i.e window's \\ or unix's /. And furthermore, it doesn't add the \\\\ that windows uses for server paths :)</p>
<pre><code>def SplitPath( split_path ):
    pathSplit_lst   = []
    while os.path.basename(split_path):
        pathSplit_lst.append( os.path.basename(split_path) )
        split_path = os.path.dirname(split_path)
    pathSplit_lst.reverse()
    return pathSplit_lst
</code></pre>
<p>So for '\\\\server\\folder1\\folder2\\folder3\\folder4'</p>
<p>you get</p>
<p>['server','folder1','folder2','folder3','folder4']</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not actually sure if this fully answers the question, but I had a fun time writing this little function that keeps a stack, sticks to os.path-based manipulations, and returns the list/stack of items.</p>
<pre><code>  9 def components(path):
 10     ret = []
 11     while len(path) &gt; 0:
 12         path, crust = split(path)
 13         ret.insert(0, crust)
 14
 15     return ret
 16
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <code>ntpath.split()</code></p>
</div>
<span class="comment-copy">As you review these answers, remember that <code>os.path.split</code> is not working for you because you aren't escaping that string properly.</span>
<span class="comment-copy">@brone - I prefer to use this solution, than having to worry about escaping the backslash. thanks!</span>
<span class="comment-copy">I'll echo your sentiment - os.path should be used any time you're not just writing a one-off.</span>
<span class="comment-copy">@brone - I thought that if I selected your answer you would get the bounty?? Sorry, it looks like SO autoselected the answer for the bounty - the points were meant to go to you.</span>
<span class="comment-copy">I'd be happy to be proved wrong but it seems to me suggested solution does not work if a path such as this "C:\usr\rs0\my0\in111102.log" is used (unless the initial input is a raw string) ?</span>
<span class="comment-copy">It looks like this will not properly split a path if it only contains a directory in OSX such as "/path/to/my/folder/", in order to achieve that you'd want to add these two lines to the beginning: <code>if path.endswith("/"):</code> and <code>path = path[:-1]</code>.</span>
<span class="comment-copy">The one true answer: <i>it has emerged</i>. The canonical solution is the simplest, of course. <b>Behold!</b> For it is elegant and contumely and has no insufferable edge cases.</span>
<span class="comment-copy">As a one-liner, <code>os.path.normpath(a_path).split(os.path.sep)</code></span>
<span class="comment-copy">This doesn't seem to work for path = root.  In that case, the result of path.split is ['','']. In fact in general, this split() solution gives a leftmost directory with empty-string name (which could be replaced by the appropriate slash).  The core problem is that a single slash (forward or backward depending on the OS) is the <i>name</i> of the root directory, whereas elsewhere in the path it is a <i>separator</i>.</span>
<span class="comment-copy">Will it work better with an lstrip then? <code>os.path.normpath(path).lstrip(os.path.sep).split(os.path.sep)</code></span>
<span class="comment-copy">@user60561 That's because on Linux, backslash is an allowed character in filenames, whereas on Windows a forward slash isn't. That's why on Windows, <code>normpath</code> will recognize forward slash as a separator. On Linux, <code>normpath</code> will simply assume that you have a directory called <code>\1\2</code> and a file or directory inside it called <code>3</code>.</span>
<span class="comment-copy">This works <code>some times</code>. Other times (on windows at least) you will find paths that look like <code>folder\folder2\folder3/file.txt</code>. Its better to first normalize (os.path.normpath) the path and then split that.</span>
<span class="comment-copy">thanks! Works really well for URL paths</span>
<span class="comment-copy"><b>This answer was <i>almost</i> there.</b> As <a href="https://stackoverflow.com/users/790439/vikki">vikki</a> suggests, the failure to normalize pathnames before string splitting spells doom on commonplace edge-cases (e.g., <code>/foo//bar</code>). See <a href="https://stackoverflow.com/users/2107536/tompa">Tompa</a>'s <a href="https://stackoverflow.com/users/2107536/tompa">answer</a> for a more robust solution.</span>
<span class="comment-copy">This deserves more upvotes.</span>
<span class="comment-copy">Path.parts is what I've always wanted, but I've never known it existed until today.</span>
<span class="comment-copy">@W. Craig Trader - thanks, but this path is not one that I generate myself - it comes back to me from another program and I have to store this data in a variable. I am not sure how to convert data stored in a variable into "raw text".</span>
<span class="comment-copy">There isn't such thing as a "raw text"... it's just how you represent it in the source. Either prepend r"" to the string, or pass it through .replace('\\', '/')</span>
<span class="comment-copy">@BeeBand, how are you getting the data back from the other program?  Are you reading it from a file, a pipe, a socket?  If so, then you don't need to do anything fancy; the only reason for doubling backslashes or using raw strings is to place string constants into Python code.  On the other hand, if the other program is generating doubled-backslashes, then you'd want to clean that up before splitting your path.</span>
<span class="comment-copy">@W. Craig Trader - i'm reading it from a file, that gets written by another program. I couldn't get <code>split()</code> or <code>replace()</code> to work for some reason - I kept getting hex values. You're right though, I think I was barking up the wrong tree with the raw string idea - I think I was just using <code>split()</code> incorrectly. Because I tried some of these solutions using <code>split()</code> and they work for me now.</span>
<span class="comment-copy">Maybe the file is UTF-8/UTF-16 (unicode) encoded?</span>
<span class="comment-copy">+1, Very nice!!!</span>
<span class="comment-copy">This is my favourite solution to this problem. Very nice.</span>
<span class="comment-copy">This does not work if the path ends with <code>/</code>. Also, gives you an empty string at the beginning of the list if your path starts with <code>/</code></span>
<span class="comment-copy">@unwind - the <code>r</code> in front of your string, what does that refer to?</span>
<span class="comment-copy">r means raw string - it auto-escapes <code>\ </code> characters. It's useful to use whenever you're doing paths.</span>
<span class="comment-copy">@BeeBand: you don't need to care; the r"" is just something that matters during compilation/parsing of the code, it's not something that becomes a property of the string once parsed. It just means "here's a string literal, but don't interpret any backslashes as having any other meaning than being backslashes".</span>
<span class="comment-copy">I think it might be helpful to mention you minus well do it more ambiguous using     a.split(os.sep)  instead of hard coding it?</span>
<span class="comment-copy">I have to downvote you for missing a chance to explain <code>os.path.split</code> and <code>os.pathsep</code>, considering both of those are far more portable than what you have written. It might not matter to OP now, but it will when he's writing something that needs to move platforms.</span>
<span class="comment-copy">this does indeed work, thanks! But I chose brone's solution because I prefer not to worry about escaping the backslash.</span>
<span class="comment-copy">Not pythonic since it is filesystem dependent.</span>
<span class="comment-copy">Or <code>os.path.split</code>. You want to be careful with <code>os.pathsep</code>, because it's <code>:</code> on my version of Python in OS X (and <code>os.path.split</code> properly handles <code>/</code>).</span>
<span class="comment-copy">You mean <a href="http://docs.python.org/library/os#os.sep" rel="nofollow noreferrer"><code>os.sep</code></a>, not <a href="http://docs.python.org/library/os#os.pathsep" rel="nofollow noreferrer"><code>os.pathsep</code></a>. Follow the wisdom in the <code>os.sep</code> docs: <i>Note that knowing this is not sufficient to be able to parse or concatenate pathnames — use os.path.split() and os.path.join().</i></span>
<span class="comment-copy">Unfortunately the data is being returned to me from another program that I run from my python script. I don't have any control over whether to use '\' or '/' - it is the third party program that determines this ( probably on a platform basis ).</span>
<span class="comment-copy">@BeeBand: Ah, then you won't have the problem you experienced during testing, when you provided the string as literal in your program. Or you can do the following evil hack after receiving the path: <code>var = var.replace('\\','/')</code> - replace \ with / and proceed working with forward slashes only :)</span>
<span class="comment-copy">that is indeed an evil hack :o)</span>
<span class="comment-copy">@BeeBand: that's why i warned. When i say something is evil, i don't necessarily mean it should never be used - but one should <i>very much</i> be aware why they are using it and alert of unintended consequences. In this case, a very unlikely consequence is that if this is used on Unix file system with `` use in file or directory name (it's really hard but possible) - this code will 'break'</span>
<span class="comment-copy">That doesn't follow the invariant that passing your result to <code>os.path.join()</code> should return the original string. I'd say the correct output for your example input is <code>[r'\\','server','folder1','folder2','folder3','folder4']</code>. I.e. what <code>os.path.split()</code> does.</span>
<span class="comment-copy">I see, thanks :)</span>
<span class="comment-copy">when i use os.path.split() I get, (<code>d:\\stuff</code>, <code>morestuff\x0curtherdown\thefile.mux</code>)</span>
<span class="comment-copy">As BeeBand pointed out, os.path.split() really doesn't do the desired thing.</span>
<span class="comment-copy">sorry I just realized os.path only works depending on your os.  ntpath will parse dos paths.</span>
<span class="comment-copy">even with ntpath I still get <code>d:\\stuff, morestuff\x0curtherdown\thefile.mux</code></span>
<span class="comment-copy">@BeeBand: your having issues with escaping your string.  <code>'\x0c'</code> is the form feed character.  The way to create the form feed character is '\f'.  If you really want the literal string '\f' you have two options: <code>'\\f'</code> or <code>r'\f'</code>.</span>
