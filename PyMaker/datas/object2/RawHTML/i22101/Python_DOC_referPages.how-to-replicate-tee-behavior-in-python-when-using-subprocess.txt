<div class="post-text" itemprop="text">
<p>I'm looking for a Python solution that will allow me to save the output of a command in a file without hiding it from the console.</p>
<p>FYI: I'm asking about <a href="https://en.wikipedia.org/wiki/Tee_%28command%29" rel="noreferrer">tee</a> (as the Unix command line utility) and not the function with the same name from Python intertools module.</p>
<h3>Details</h3>
<ul>
<li>Python solution (not calling <code>tee</code>, it is not available under Windows)</li>
<li>I do not need to provide any input to stdin for called process</li>
<li>I have no control over the called program. All I know is that it will output something to stdout and stderr and return with an exit code.</li>
<li>To work when calling external programs (subprocess)</li>
<li>To work for both <code>stderr</code> and <code>stdout</code></li>
<li>Being able to differentiate between stdout and stderr because I may want to display only one of the to the console or I could try to output stderr using a different color - this means that <code>stderr = subprocess.STDOUT</code> will not work.</li>
<li>Live output (progressive) - the process can run for a long time, and I'm not able to wait for it to finish.</li>
<li>Python 3 compatible code (important)</li>
</ul>
<h3>References</h3>
<p>Here are some incomplete solutions I found so far:</p>
<ul>
<li><a href="http://devlishgenius.blogspot.com/2008/10/logging-in-real-time-in-python.html" rel="noreferrer">http://devlishgenius.blogspot.com/2008/10/logging-in-real-time-in-python.html</a> (mkfifo works only on Unix)</li>
<li><a href="http://blog.kagesenshi.org/2008/02/teeing-python-subprocesspopen-output.html" rel="noreferrer">http://blog.kagesenshi.org/2008/02/teeing-python-subprocesspopen-output.html</a> (doesn't work at all)</li>
</ul>
<p><a href="http://blog.i18n.ro/wp-content/uploads/2010/06/Drawing_tee_py.png" rel="noreferrer">Diagram http://blog.i18n.ro/wp-content/uploads/2010/06/Drawing_tee_py.png</a></p>
<h3>Current code (second try)</h3>
<pre><code>#!/usr/bin/python
from __future__ import print_function

import sys, os, time, subprocess, io, threading
cmd = "python -E test_output.py"

from threading import Thread
class StreamThread ( Thread ):
    def __init__(self, buffer):
        Thread.__init__(self)
        self.buffer = buffer
    def run ( self ):
        while 1:
            line = self.buffer.readline()
            print(line,end="")
            sys.stdout.flush()
            if line == '':
                break

proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
stdoutThread = StreamThread(io.TextIOWrapper(proc.stdout))
stderrThread = StreamThread(io.TextIOWrapper(proc.stderr))
stdoutThread.start()
stderrThread.start()
proc.communicate()
stdoutThread.join()
stderrThread.join()

print("--done--")

#### test_output.py ####

#!/usr/bin/python
from __future__ import print_function
import sys, os, time

for i in range(0, 10):
    if i%2:
        print("stderr %s" % i, file=sys.stderr)
    else:
        print("stdout %s" % i, file=sys.stdout)
    time.sleep(0.1)
</code></pre>

Real output

<pre><code>stderr 1
stdout 0
stderr 3
stdout 2
stderr 5
stdout 4
stderr 7
stdout 6
stderr 9
stdout 8
--done--
</code></pre>
<p>Expected output was to have the lines ordered. Remark, modifying the Popen to use only one PIPE is not allowed because in the real life I will want to do different things with stderr and stdout.</p>
<p>Also even in the second case I was not able to obtain real-time like out, in fact all the results were received when the process finished. By default, Popen should use no buffers (bufsize=0).</p>
</div>
<div class="post-text" itemprop="text">
<p>I see that this is a rather old post but just in case someone is still searching for a way to do this:</p>
<pre><code>proc = subprocess.Popen(["ping", "localhost"], 
                        stdout=subprocess.PIPE, 
                        stderr=subprocess.PIPE)

with open("logfile.txt", "w") as log_file:
  while proc.poll() is None:
     line = proc.stderr.readline()
     if line:
        print "err: " + line.strip()
        log_file.write(line)
     line = proc.stdout.readline()
     if line:
        print "out: " + line.strip()
        log_file.write(line)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Finally I had to implement <code>tee()</code> command in Python myself. </p>
<p>You can get it from here <a href="http://github.com/pycontribs/tendo/blob/master/tendo/tee.py" rel="noreferrer">http://github.com/pycontribs/tendo/blob/master/tendo/tee.py</a></p>
<p>Currently it does allow you to do things like:</p>
<pre><code> tee("python --v") # works just like os.system()

 tee("python --v", "log.txt") # file names

 tee("python --v", file_handle)

 import logging
 tee("python --v", logging.info) # receive a method
</code></pre>
<p>The only current limitation is that it is not able to differentiate between <code>stderr</code> and <code>stdout</code>, meaning that it will merge both of them.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a straightforward port of <a href="http://linux.die.net/man/1/tee" rel="nofollow noreferrer"><code>tee</code></a> to Python.</p>
<pre><code>import sys
sinks = sys.argv[1:]
sinks = [open(sink, "w") for sink in sinks]
sinks.append(sys.stderr)
while True:
  input = sys.stdin.read(1024)
  if input:
    for sink in sinks:
      sink.write(input)
  else:
    break
</code></pre>
<p>I'm running on Linux right now but this ought to work on most platforms.</p>
<hr/>
<p>Now for the <code>subprocess</code> part, I don't know how you want to 'wire' the subprocess's <code>stdin</code>, <code>stdout</code> and <code>stderr</code> to your <code>stdin</code>, <code>stdout</code>, <code>stderr</code> and file sinks, but I know you can do this:</p>
<pre><code>import subprocess
callee = subprocess.Popen( ["python", "-i"],
                           stdin = subprocess.PIPE,
                           stdout = subprocess.PIPE,
                           stderr = subprocess.PIPE
                         )
</code></pre>
<p>Now you can access <a href="http://docs.python.org/library/subprocess.html#subprocess.Popen.stdin" rel="nofollow noreferrer"><code>callee.stdin</code></a>, <a href="http://docs.python.org/library/subprocess.html#subprocess.Popen.stdout" rel="nofollow noreferrer"><code>callee.stdout</code></a> and <a href="http://docs.python.org/library/subprocess.html#subprocess.Popen.stderr" rel="nofollow noreferrer"><code>callee.stderr</code></a> like normal files, enabling the above "solution" to work. If you want to get the <a href="http://docs.python.org/library/subprocess.html#subprocess.Popen.returncode" rel="nofollow noreferrer"><code>callee.returncode</code></a>, you'll need to make an extra call to <a href="http://docs.python.org/library/subprocess.html#subprocess.Popen.poll" rel="nofollow noreferrer"><code>callee.poll()</code></a>.</p>
<p>Be careful with writing to <code>callee.stdin</code>: if the process has exited when you do that, an error may be rised (on Linux, I get <code>IOError: [Errno 32] Broken pipe</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to interact with the process you can use the subprocess module just fine.</p>
<p>Example:</p>
<p>tester.py</p>
<pre><code>import os
import sys

for file in os.listdir('.'):
    print file

sys.stderr.write("Oh noes, a shrubbery!")
sys.stderr.flush()
sys.stderr.close()
</code></pre>
<p>testing.py</p>
<pre><code>import subprocess

p = subprocess.Popen(['python', 'tester.py'], stdout=subprocess.PIPE,
                     stdin=subprocess.PIPE, stderr=subprocess.PIPE)

stdout, stderr = p.communicate()
print stdout, stderr
</code></pre>
<p>In your situation you can simply write stdout/stderr to a file first. You can send arguments to your process with communicate as well, though I wasn't able to figure out how to continually interact with the subprocess.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are subtle problems/bugs in python related to subprocess.PIPE:
<a href="http://bugs.python.org/issue1652" rel="nofollow">http://bugs.python.org/issue1652</a></p>
<p>Apparently this was fixed in python3+, but not in python 2.7 and older. For that you need to use:
code.google.com/p/python-subprocess32/</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this :</p>
<pre><code>import sys

class tee-function :

    def __init__(self, _var1, _var2) :

        self.var1 = _var1
        self.var2 = _var2

    def __del__(self) :

        if self.var1 != sys.stdout and self.var1 != sys.stderr :
            self.var1.close()
        if self.var2 != sys.stdout and self.var2 != sys.stderr :
            self.var2.close()

    def write(self, text) :

        self.var1.write(text)
        self.var2.write(text)

    def flush(self) :

        self.var1.flush()
        self.var2.flush()

stderrsav = sys.stderr

out = open(log, "w")

sys.stderr = tee-function(stderrsav, out)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wrote a thing that wraps shell commands in Python. </p>
<p>Key advantages:</p>
<ol>
<li>This util captures stdout/stderr always</li>
<li>This util provides an option to echo stdout/stderr to stdout/stderr for the process</li>
<li>When echoing stdout/stderr the out/err there is no delay</li>
</ol>
<p>Key disadvantage:</p>
<ul>
<li>Only works on bash/unix</li>
</ul>
<p>source: <a href="https://gist.github.com/AndrewHoos/9f03c74988469b517a7a" rel="nofollow">https://gist.github.com/AndrewHoos/9f03c74988469b517a7a</a> </p>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/4984428/4279">Python subprocess get children's output to file and terminal?</a></span>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/17190221/4279">Subprocess.Popen: cloning stdout and stderr both to terminal and variables</a></span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/15535240/python-popen-write-to-stdout-and-log-file-simultaneously">Python Popen: Write to stdout AND log file simultaneously</a> Voting this way because this is a community wiki :-)</span>
<span class="comment-copy">This worked for me, though I found <code>stdout, stderr = proc.communicate()</code> easier to use.</span>
<span class="comment-copy">-1: This solution leads to a deadlock for any subprocess that can generate enough output on stdout or stderr and where stdout/stderr are not perfectly in sync.</span>
<span class="comment-copy">@J.F.Sebastian: True, but you can workaround that problem by replacing <code>readline()</code> with <code>readline(size)</code>.  I have done something similar in other languages.  Ref: <a href="https://docs.python.org/3/library/io.html#io.TextIOBase.readline" rel="nofollow noreferrer">docs.python.org/3/library/io.html#io.TextIOBase.readline</a></span>
<span class="comment-copy">@kevinarpe wrong. <code>readline(size)</code> won't fix the deadlock. stdout/stderr should be read concurrently. See links under the question that show solutions using threads or asyncio.</span>
<span class="comment-copy">@J.F.SebastianDoes this problem exist if I'm only interested in reading one of the streams?</span>
<span class="comment-copy">Try here: <a href="https://tendo.readthedocs.org/en/latest/#module-tendo.tee" rel="nofollow noreferrer">tendo.readthedocs.org/en/latest/#module-tendo.tee</a></span>
<span class="comment-copy">This is suboptimal in Linux, since Linux provides an ad-hoc <a href="http://linux.die.net/man/2/tee" rel="nofollow noreferrer"><code>tee(f_in, f_out, len, flags)</code></a> API, but that's not the point right?</span>
<span class="comment-copy">I updated the question, the problem is that I was not able to find how to use subprocess in order to get the data from the two pipes gradually and not all at once at the end of the process.</span>
<span class="comment-copy">@Sorin, what if you replaced <code>read(1024)</code> with <code>read(1)</code>?</span>
<span class="comment-copy">I know that your code should work but there is a small requirement that does break the entire logic: I want to be able to distinguish between stdout and stderr and this means that I have to read from both of them but I do not know which will get new data. Please take a look at the example code.</span>
<span class="comment-copy">@Sorin, that means you'll have to either use two threads. One reads on <code>stdout</code>, one reads on <code>stderr</code>. If you are going to write both to the same file, you can acquire a lock on the sinks when you start reading and release it after writing a line terminator. :/</span>
<span class="comment-copy">This doesn't show you error messages in STDERR in context of STDOUT, which can make debugging shell-scripts etc nearly impossible.</span>
<span class="comment-copy">Meaning...? In this script anything delivered through STDERR is printed to the screen along with STDOUT. If you're referring to return codes, just use <code>p.poll()</code> to retrieve them.</span>
<span class="comment-copy">This is exactly the approach I was about to suggest. Also worth adding some of the file data-descriptors, like <code>closed</code>.</span>
<span class="comment-copy">Just tried it, <code>subprocess.Popen</code> calls <code>fileno()</code>, triggering an exception.</span>
