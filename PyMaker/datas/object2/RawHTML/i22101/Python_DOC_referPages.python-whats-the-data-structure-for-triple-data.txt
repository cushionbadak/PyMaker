<div class="post-text" itemprop="text">
<p>I've got a set of data that has three attributes, say A, B, and C, where A is kind of the index (i.e., A is used to look up the other two attributes.)  What would be the best data structure for such data? </p>
<p>I used two dictionaries, with A as the index of each. However, there's key errors when the query to the data doesn't match any instance of A.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>AtoB = {"A1":"B1", "A2":"B2"}
AtoB.get("A3", None)
=&gt; None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Could you use a dictionary with A as the key, and the item in the dictionary as a 2-item tuple or list? If you're working with any of that data in a consistent way, you could also consider storing a class that has 2 properties in the dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>As an alternative to a dict of tuples, you could use an object to store B and C:</p>
<pre><code>class Thing:
    def __init__(self, B=None, C=None):
        self.B = B
        self.C = C

stuff = {A1: Thing(B1, C1)}
B1 = stuff[A1].B

processTriple(A1, stuff[A1].B, stuff[A1].C)

nothing = stuff.get(A2)
</code></pre>
<p>While it's a tiny bit wasteful, you could store A in the object too so that each instance represents a complete triple.  Then you can pass those around more effectively than the sample above.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would suggest using a dictionary with A keyed to (B, C), so <code>d = {A : (B, C)}</code>.</p>
<p>Your problem of nonexistent keys resulting in errors can be solved in the following manner (thanks to intuited for the has_key function I forgot about):</p>
<pre><code>if d.has_key(A):
    # do whatever you want
else:
    # A does not exist in your dictionary and you can handle this properly
</code></pre>
<p>Another option is the to do it in a <code>try: except:</code> block, but I tend to agree with intuited that if keys will be missing at a rate that isn't completely unusual, <code>has_key</code> will show better performance and (arguably) make better conceptual sense.</p>
</div>
<span class="comment-copy">What's the application?  What do you need to extract it for?  How are you going to process it?</span>
<span class="comment-copy">all A,B, and C are plain text.</span>
<span class="comment-copy">This is probably the best answer if you know that your dictionary will never contain a specific value, here it's <code>None</code></span>
<span class="comment-copy">actually, just AtoB.get('A3') will be enough, since None is the default and he said keys/vals are strings. The only difference hence will be that while AtoB[] throws exception, .get() will return None instead</span>
<span class="comment-copy">Or similarly use a named tuple <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a> . Either way, storing all three in the tuple or object makes sense for a known "Thing" with three attributes. If A is an arbitrary key then it is technically not an attribute of Thing and the dictionary using A as key pointing to some collection B &amp; C makes sense, but if A is not arbitrary then all 3 belong together.</span>
<span class="comment-copy">Wouldn't you rather follow the python EAFP?  try:   a in d.keys() catch KeyError:   pass</span>
<span class="comment-copy">If it's not exceptional for a key to be missing from the dictionary, then it seems more appropriate to check first.  d.has_key(A) is going to be a more efficient way to check, since it doesn't create a list of the entire key set.  Also using a namedtuple (collections.namedtuple) can be a convenient and efficient way to allow readable references to B and C.</span>
<span class="comment-copy">If there's a reasonable default value then <code>d.get(A)</code> would be the best pattern, and also the fastest.  Otherwise it is best/fastest/easiest-to-read-and-type to just test like you do, except to use <code>A in d</code> which is a more modern convention.  (You definitely should <i>not</i> use <code>A in d.keys()</code> as that enumerates all the keys into a list <i>every</i> time you run that test.)</span>
<span class="comment-copy">You dont even need to generate the key list(<code>d.keys()</code>), just use the syntax <code>if key in dict</code>.</span>
<span class="comment-copy">In the comments above: <code>try ... catch KeyError ...</code> should be <code>try: ... except KeyError: ...</code>. There is no <code>catch</code> keyword in python.</span>
