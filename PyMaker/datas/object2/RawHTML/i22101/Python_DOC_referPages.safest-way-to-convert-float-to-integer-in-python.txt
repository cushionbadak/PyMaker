<div class="post-text" itemprop="text">
<p>Python's math module contain handy functions like <code>floor</code> &amp; <code>ceil</code>. These functions take a floating point number and return the nearest integer below or above it. However these functions return the answer as a floating point number. For example:</p>
<pre><code>import math
f=math.floor(2.3)
</code></pre>
<p>Now <code>f</code> returns:</p>
<pre><code>2.0
</code></pre>
<p>What is the safest way to get an integer out of this float, without running the risk of rounding errors (for example if the float is the equivalent of 1.99999) or perhaps I should use another function altogether?</p>
</div>
<div class="post-text" itemprop="text">
<p>All integers that can be represented by floating point numbers have an exact representation. So you can safely use <code>int</code> on the result. Inexact representations occur only if you are trying to represent a rational number with a denominator that is not a power of two.</p>
<p>That this works is not trivial at all! It's a property of the IEEE floating point representation that int∘floor = ⌊⋅⌋ if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1.</p>
<p>To quote from <a href="http://en.wikipedia.org/w/index.php?title=Floating_point&amp;oldid=376101741#IEEE_754:_floating_point_in_modern_computers" rel="noreferrer">Wikipedia</a>,</p>
<blockquote>
<p>Any integer with absolute value less than or equal to 2<sup>24</sup> can be exactly represented in the single precision format, and any integer with absolute value less than or equal to 2<sup>53</sup> can be exactly represented in the double precision format.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>int(your non integer number)</code> will nail it.</p>
<pre><code>print int(2.3) # "2"
print int(math.sqrt(5)) # "2"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use the round function.  If you use no second parameter (# of significant digits) then I think you will get the behavior you want.</p>
<p>IDLE output.</p>
<pre><code>&gt;&gt;&gt; round(2.99999999999)
3
&gt;&gt;&gt; round(2.6)
3
&gt;&gt;&gt; round(2.5)
3
&gt;&gt;&gt; round(2.4)
2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Combining two of the previous results, we have:</p>
<pre><code>int(round(some_float))
</code></pre>
<p>This converts a float to an integer fairly dependably.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>That this works is not trivial at all! It's a property of the IEEE floating point representation that int∘floor = ⌊⋅⌋ if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1.</p>
</blockquote>
<p><em>This post explains why it works in that range</em>.</p>
<p>In a double, you can represent 32bit integers without any problems. There <em>cannot</em> be any rounding issues. More precisely, doubles can represent <strong><em>all</em></strong> integers between and including <em>2<sup>53</sup></em> and <em>-2<sup>53</sup></em>.</p>
<p><strong>Short explanation</strong>: A double can store up to 53 binary digits. When you require more, the number is padded with zeroes on the right.</p>
<p>It follows that 53 ones is the largest number that can be stored without padding. Naturally, all (integer) numbers requiring less digits can be stored accurately.</p>
<p>Adding one to <em>111(omitted)111</em> (53 ones) yields 100...000, (53 zeroes). As we know, we can store 53 digits, that makes the rightmost zero padding.</p>
<p>This is where 2<sup>53</sup> comes from.</p>
<hr/>
<p><strong>More detail:</strong> We need to consider how IEEE-754 floating point works.</p>
<pre><code>  1 bit    11 / 8     52 / 23      # bits double/single precision
[ sign |  exponent | mantissa ]
</code></pre>
<p>The number is then calculated as follows (excluding special cases that are irrelevant here):</p>
<blockquote>
<p><em>-1<sup>sign</sup> × 1.mantissa ×2<sup>exponent - bias</sup></em></p>
</blockquote>
<p>where <em>bias = 2<sup>exponent - 1</sup> - 1</em>, i.e. 1023 and 127 for double/single precision respectively.</p>
<p>Knowing that multiplying by <em>2<sup>X</sup></em> simply shifts all bits <em>X</em> places to the left, it's easy to see that any integer must have all bits in the mantissa that end up right of the decimal point to zero.</p>
<p>Any integer except zero has the following form in binary:</p>
<blockquote>
<p><em>1x...x</em> where the <em>x</em>-es represent the bits to the right of the MSB (most significant bit).</p>
</blockquote>
<p>Because we excluded zero, there will <em>always</em> be a MSB that is one—which is why it's not stored. To store the integer, we must bring it into the aforementioned form: <em>-1<sup>sign</sup> × 1.mantissa ×2<sup>exponent - bias</sup></em>.</p>
<p>That's saying the same as shifting the bits over the decimal point until there's only the MSB towards the left of the MSB. All the bits right of the decimal point are then stored in the mantissa.</p>
<p>From this, we can see that we can store at most 52 binary digits apart from the MSB.</p>
<p>It follows that the highest number where all bits are explicitly stored is</p>
<pre><code>111(omitted)111.   that's 53 ones (52 + implicit 1) in the case of doubles.
</code></pre>
<p>For this, we need to set the exponent, such that the decimal point will be shifted 52 places. If we were to increase the exponent by one, we cannot know the digit right to the left after the decimal point.</p>
<pre><code>111(omitted)111x.
</code></pre>
<p>By convention, it's 0. Setting the entire mantissa to zero, we receive the following number:</p>
<pre><code>100(omitted)00x. = 100(omitted)000.
</code></pre>
<p>That's a 1 followed by 53 zeroes, 52 stored and 1 added due to the exponent.</p>
<p>It represents <em>2<sup>53</sup></em>, which marks the boundary (both negative and positive) between which we can accurately represent all integers. If we wanted to add one to <em>2<sup>53</sup></em>, we would have to set the implicit zero (denoted by the <code>x</code>) to one, but that's impossible.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>math.floor</code> will always return an integer number and thus <code>int(math.floor(some_float))</code> will never introduce rounding errors.</p>
<p>The rounding error might already be introduced in <code>math.floor(some_large_float)</code>, though, or even when storing a large number in a float in the first place. (Large numbers may lose precision when stored in floats.)</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need to convert a string float to an int you can use this method.</p>
<p>Example: <code>'38.0'</code> to <code>38</code></p>
<p>In order to convert this to an int you can cast it as a float then an int. This will also work for float strings or integer strings.</p>
<pre><code>&gt;&gt;&gt; int(float('38.0'))
38
&gt;&gt;&gt; int(float('38'))
38
</code></pre>
<p><strong>Note</strong>: This will strip any numbers after the decimal.</p>
<pre><code>&gt;&gt;&gt; int(float('38.2'))
38
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another code sample to convert a real/float to an integer using variables.
"vel" is a real/float number and converted to the next highest INTEGER, "newvel".</p>
<pre><code>import arcpy.math, os, sys, arcpy.da
.
.
with arcpy.da.SearchCursor(densifybkp,[floseg,vel,Length]) as cursor:
 for row in cursor:
    curvel = float(row[1])
    newvel = int(math.ceil(curvel))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you're asking for the 'safest' way, I'll provide another answer other than the top answer.</p>
<p>An easy way to make sure you don't lose any precision is to check if the values would be equal after you convert them. </p>
<pre><code>if int(some_value) == some_value:
     some_value = int(some_value)
</code></pre>
<p>If the float is 1.0 for example,  1.0 is equal to 1. So the conversion to int will execute. And if the float is 1.1, int(1.1) equates to 1, and 1.1 != 1. So the value will remain a float and you won't lose any precision.</p>
</div>
<span class="comment-copy"><code>math.floor</code> <a href="https://docs.python.org/2/library/math.html" rel="nofollow noreferrer">returns a float in v2.6</a>, but <a href="https://docs.python.org/3.0/library/math.html" rel="nofollow noreferrer">it returns an integer in v3</a>. At this point (almost six years after the OP), this issue might show up rarely.</span>
<span class="comment-copy">however numpy still returns float, so the question is valid.</span>
<span class="comment-copy">+1 for going a bit deeper. You could also throw in a brief explanation as to why: <a href="http://en.wikipedia.org/wiki/Floating_point" rel="nofollow noreferrer">en.wikipedia.org/wiki/Floating_point</a> :D</span>
<span class="comment-copy">In Python 2, an "int" is the same as a C "int".  In Python 3, it appears there is no limit to the size of an "int, <a href="https://stackoverflow.com/questions/13795758/what-is-sys-maxint-in-python-3" title="what is sys maxint in python 3">stackoverflow.com/questions/13795758/…</a>.  The meaning of "int" is also dependent on the operating system and underlying hardware.  See <a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models" rel="nofollow noreferrer">en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models</a>.  If you are programming with the C-API, python 3 you have to be very careful in what the definition of long and size_t is on your platform. <a href="https://docs.python.org/3/c-api/long.html" rel="nofollow noreferrer">docs.python.org/3/c-api/long.html</a></span>
<span class="comment-copy">This won't work for negative numbers: <code>floor</code> rounds down whereas <code>int</code> rounds towards 0.</span>
<span class="comment-copy">@jochen I tested <code>int(-2.3)</code> in Python distribution Canopy 2.7.6 and got <code>-2</code> as expected. Integer numbers can be negative, the same way in  formal Math definition.</span>
<span class="comment-copy">I agree, <code>int(-2.3)</code> gives <code>-2</code> as you say, because it rounds towards <code>0</code>, <i>i.e.</i> up in this case.  In contrast, the original question used <code>math.floor</code>, which always rounds down: <code>math.floor(-2.3)</code> gives <code>-3.0</code>.</span>
<span class="comment-copy">That is not really a problem.  OP just wants an integer out of the result of <code>math.floor</code>, and this answer shows how to convert a float into an integer.  Take the float from <code>math.floor</code> and pipe it through <code>int</code>, problem solved: <code>int(math.floor(2.3))</code></span>
<span class="comment-copy">Did you even read the question? He is aware of the <b>int()</b> function, but has asked if you may run into trouble with 1.9999 instead of 2.0. Your answer is not even close to an answer at all, you missed the whole point...</span>
<span class="comment-copy"><code>round</code> returns a float number as well, at least in Python 2.6.</span>
<span class="comment-copy">In Python 3.1.2, round returns an int.</span>
<span class="comment-copy">Indeed, both <code>round</code> and <code>floor</code> return integers in Python 3.x. So I suppose that the question concerns Python 2.x.</span>
<span class="comment-copy">and since (it appears that) the OP is using IPython which isn't available for py3k, that's probably a valid supposition, Phillip.</span>
<span class="comment-copy">so maybe <code>int(round(2.65))</code> ?</span>
<span class="comment-copy">What happens if you try to round a very long float? Will this at least raise an exception?</span>
<span class="comment-copy">@Agostino What do you mean "very long float"?</span>
<span class="comment-copy">@kralyk I mean a <code>float</code> representing a number bigger than what a normal <code>int</code> can hold. In Python 2, are there <code>float</code> values that you can only represent using a <code>long</code> (after rounding)?</span>
<span class="comment-copy">@Agostino Apparently, in python 2, those are converted as the <code>long</code> type...</span>
<span class="comment-copy">@kralyk you mean, after the round? So, would casting them to int raise an exception, or just truncate them?</span>
<span class="comment-copy">From: <a href="http://docs.python.org/2/library/math.html" rel="nofollow noreferrer">docs.python.org/2/library/math.html</a> - math.floor(x) - Return the floor of x as a float, the largest integer value less than or equal to x.</span>
<span class="comment-copy">Could somebody explain the downvotes, please?</span>
<span class="comment-copy">Why do you need to do call math.floor when int already does the same thing?</span>
<span class="comment-copy">@Alex: <code>int</code> and <code>floor</code> return different values for negative numbers, of course.</span>
