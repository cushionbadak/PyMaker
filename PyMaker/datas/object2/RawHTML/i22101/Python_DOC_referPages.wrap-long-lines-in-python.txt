<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1874592/how-to-write-very-long-string-that-conforms-with-pep8-and-prevent-e501">How to write very long string that conforms with PEP8 and prevent E501</a>
<span class="question-originals-answer-count">
                    8 answers
                </span>
</li>
</ul>
</div>
<p>How do I wrap long lines in Python without sacrificing indentation? </p>
<p>For example: </p>
<pre><code>def fun():
    print '{0} Here is a really long sentence with {1}'.format(3, 5)
</code></pre>
<p>Suppose this goes over the 79 character recommended limit. The way I read it, here is how to indent it:</p>
<pre><code>def fun():
    print '{0} Here is a really long \
sentence with {1}'.format(3, 5)
</code></pre>
<p>However, with this approach, the indentation of the continued line matches the indentation of the <code>fun()</code>. This looks kinda ugly. If someone was to go through my code, it would look bad to have uneven indentation because of this <code>print</code> statement.</p>
<p>How do I indent lines like this effectively without sacrificing code readability?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def fun():
    print(('{0} Here is a really long '
           'sentence with {1}').format(3, 5))
</code></pre>
<p>Adjecent string literals are concatenated at compile time, just as in C. <a href="http://docs.python.org/reference/lexical_analysis.html#string-literal-concatenation" rel="noreferrer">http://docs.python.org/reference/lexical_analysis.html#string-literal-concatenation</a> is a good place to start for more info.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two approaches which are not mentioned above, but both of which solve the problem in a way which complies with <a href="http://www.python.org/dev/peps/pep-0008/" rel="noreferrer">PEP 8</a> <em>and</em> allow you to make better use of your space. They are:</p>
<pre><code>msg = (
    'This message is so long, that it requires '
    'more than {x} lines.{sep}'
    'and you may want to add more.').format(
        x=x, sep=2*'\n')
print(msg)
</code></pre>
<p>Notice how the parentheses are used to allow us not to add plus signs between pure strings, and spread the result over multiple lines without the need for explicit line continuation '\' (ugly and cluttered).
The advantages are same with what is described below, the difference is that you can do it anywhere.
Compared to the previous alternative, it is visually better when inspecting code, because it outlines the start and end of <code>msg</code> clearly (compare with <code>msg +=</code> one every line, which needs one additional thinking step to deduce that those lines add to the same string - and what if you make a typo, forgetting a <code>+</code> on one random line ?).</p>
<p>Regarding this approach, many times we have to build a string using iterations and checks within the iteration body, so adding its pieces within the function call, as shown later, is not an option.</p>
<p>A close alternative is:</p>
<pre><code>msg = 'This message is so long, that it requires '
msg += 'many lines to write, one reason for that\n'
msg += 'is that it contains numbers, like this '
msg += 'one: ' + str(x) +', which take up more space\n'
msg += 'to insert. Note how newlines are also included '
msg += 'and can be better presented in the code itself.'
print(msg)
</code></pre>
<p>Though the first is preferable.</p>
<p>The other approach is like the previous ones, though it starts the message on the  line below the <code>print</code>.
The reason for this is to gain space on the left, otherwise the <code>print(</code> itself "pushes" you to the right. This consumption of indentation is the inherited by the rest of the lines comprising the message, because according to PEP 8 they must align with the opening parenthesis of <code>print</code> above them. So if your message was already long, this way it's forced to be spread over even more lines.</p>
<p>Contrast:</p>
<pre><code>raise TypeError('aaaaaaaaaaaaaaaa' +
                'aaaaaaaaaaaaaaaa' +
                'aaaaaaaaaaaaaaaa')
</code></pre>
<p>with this (suggested here):</p>
<pre><code>raise TypeError(
    'aaaaaaaaaaaaaaaaaaaaaaaa' +
    'aaaaaaaaaaaaaaaaaaaaaaaa')
</code></pre>
<p>The line spread was reduced. Of course this last approach does no apply so much to <code>print</code>, because it is a short call. But it does apply to exceptions.</p>
<p>A variation you can have is:</p>
<pre><code>raise TypeError((
    'aaaaaaaaaaaaaaaaaaaaaaaa'
    'aaaaaaaaaaaaaaaaaaaaaaaa'
    'aaaaa {x} aaaaa').format(x=x))
</code></pre>
<p>Notice how you don't need to have plus signs between pure strings. Also, the indentation guides the reader's eyes, no stray parentheses hanging below to the left. The replacements are very readable. In particular, such an approach makes writing code that generates code or mathematical formulas a very pleasant task.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use the following code where indentation doesn't matter:</p>
<pre><code>&gt;&gt;&gt; def fun():
        return ('{0} Here is a really long'
        ' sentence with {1}').format(3, 5)
</code></pre>
<p>You just need to enclose string in the parentheses.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the fact that Python concatenates string literals which appear adjacent to each other:</p>
<pre><code>&gt;&gt;&gt; def fun():
...     print '{0} Here is a really long ' \
...           'sentence with {1}'.format(3, 5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd probably split the long statement up into multiple shorter statements so that the program logic is separated from the definition of the long string:</p>
<pre><code>&gt;&gt;&gt; def fun():
...     format_string = '{0} Here is a really long ' \
...                     'sentence with {1}'
...     print format_string.format(3, 5)
</code></pre>
<p>If the string is only just too long and you choose a short variable name then by doing this you might even avoid having to split the string:</p>
<pre><code>&gt;&gt;&gt; def fun():
...     s = '{0} Here is a really long sentence with {1}'
...     print s.format(3, 5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm surprised no one mentioned the implicit style above.  My preference is to use parens to wrap the string while lining the string lines up visually.  Personally I think this looks cleaner and more compact than starting the beginning of the string on a tabbed new line.</p>
<p>Note that these parens are not part of a method call — they're only <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation" rel="nofollow noreferrer">implicit string literal concatenation</a>.</p>
<p>Python 2:</p>
<pre><code>def fun():
    print ('{0} Here is a really '
           'long sentence with {1}').format(3, 5)
</code></pre>
<p>Python 3 (with parens for print function):</p>
<pre><code>def fun():
    print(('{0} Here is a really '
           'long sentence with {1}').format(3, 5))
</code></pre>
<p>Personally I think it's cleanest to separate concatenating the long string literal from printing it:</p>
<pre><code>def fun():
    s = ('{0} Here is a really '
         'long sentence with {1}').format(3, 5)
    print(s)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If it's for long string(for example for SQL query),use triple code</p>
<pre><code>'''
hello this is me 
'''
</code></pre>
</div>
<span class="comment-copy">Also take a look at this related question - <a href="http://stackoverflow.com/questions/53162/how-can-i-do-a-line-break-line-continuation-in-python" title="how can i do a line break line continuation in python">stackoverflow.com/questions/53162/…</a></span>
<span class="comment-copy">Actually, the "\" is redundant and can be omitted.</span>
<span class="comment-copy">@DanielReis I'm not sure that's true of all platforms or Python distributions.  I received some output from a user where everything after the first line was not printed.  My code was like the above, sans backslash.</span>
<span class="comment-copy">Unicode strings need the backslash in python 2.x</span>
<span class="comment-copy">Within parentheses line continuation is implicit, so a <code>+</code> instead suffices. Note that avoiding Parentheses hinders portability to Python 3.x, imagine a code whose only need for <code>2to3</code> are <code>print</code> statements, but would otherwise w/o requiring any conversion.</span>
<span class="comment-copy">This won't work for python 3, compared to <a href="http://stackoverflow.com/a/18160132/1959808">this alternative</a>.</span>
<span class="comment-copy">Does it have any downsides (first approach)? Because to me it is way better than others.</span>
<span class="comment-copy">My experience with it until now says that it doesn't have any downsides. It's an all-weather, very readable pattern that can be used everywhere, from messages to compiler backends.</span>
<span class="comment-copy">Will the PEP 8 solution cause line breaks to be entered if I intend to put this text in a <code>.csv</code> file or other output file format besides the terminal? My fear is that I'll numerous lines when I expected only 1.</span>
<span class="comment-copy">There are no newlines other than the explicit <code>\n</code> introduced by <code>sep</code> (just define <code>sep</code> differently). The strings are simply concatenated.</span>
<span class="comment-copy">Thanks. This should work for me.</span>
<span class="comment-copy">Warning for python rookies: this code is not PEP8 compliant and ought not to be indented this way.</span>
<span class="comment-copy">Yes I had considered this approach also. It is indeed a viable one.</span>
<span class="comment-copy">Actually missing out the <code>+</code> would work here too, as pointed out by the other answers and would be an improvement to my answer. The difference in my answer from the others is that I'm not trying to do everything in one statement. I think it helps readability to split long statements up into multiple shorter ones.</span>
<span class="comment-copy">The only downside to this would be I have to declare a separate string for this. I have no problem with that but I guess the parenthesis approach should work, imo.</span>
<span class="comment-copy">Since you already accepted, I updated my answer to include the idea from the accepted answer.</span>
<span class="comment-copy">Yes I had seriously considered your approach but then I decided to ask here. Since print and format itself take space, this works.</span>
<span class="comment-copy">This is incorrect because adds \n as part of the string</span>
<span class="comment-copy">@zac edited it :)</span>
