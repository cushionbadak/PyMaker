<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/893333/multiple-variables-in-a-with-statement">Multiple variables in a 'with' statement?</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>Suppose you have three objects you acquire via context manager, for instance A lock, a db connection and an ip socket.
You can acquire them by:</p>
<pre><code>with lock:
   with db_con:
       with socket:
            #do stuff
</code></pre>
<p>But is there a way to do it in one block? something like</p>
<pre><code>with lock,db_con,socket:
   #do stuff
</code></pre>
<p>Furthermore, is it possible, given an array of unknown length of objects that have context managers, is it possible to somehow do:</p>
<pre><code>a=[lock1, lock2, lock3, db_con1, socket, db_con2]
with a as res:
    #now all objects in array are acquired
</code></pre>
<p>If the answer is "no", is it because the need for such a feature implies bad design, or maybe I should suggest it in a pep? :-P</p>
</div>
<div class="post-text" itemprop="text">
<p>In <strong>Python 2.7 and 3.1 and above</strong>, you can write:</p>
<pre><code>with A() as X, B() as Y, C() as Z:
    do_something()
</code></pre>
<p>This is normally the best method to use, but if you have an unknown-length list of context managers you'll need one of the below methods.</p>
<hr/>
<p>In <strong>Python 3.3</strong>, you can enter an unknown-length list of context managers by using <a href="http://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="noreferrer">contextlib.ExitStack</a>:</p>
<pre><code>with ExitStack() as stack:
    for mgr in ctx_managers:
        stack.enter_context(mgr)
    # ...
</code></pre>
<p>This allows you to create the context managers as you are adding them to the <code>ExitStack</code>, which prevents the possible problem with <code>contextlib.nested</code> (mentioned below).</p>
<p><a href="https://pypi.python.org/pypi/contextlib2" rel="noreferrer">contextlib2</a> provides <a href="https://contextlib2.readthedocs.io/en/stable/#contextlib2.ExitStack" rel="noreferrer">a backport of <code>ExitStack</code></a> for Python 2.6 and 2.7.</p>
<hr/>
<p>In <strong>Python 2.6 and below</strong>, you can use <a href="https://docs.python.org/2/library/contextlib.html#contextlib.nested" rel="noreferrer"><code>contextlib.nested</code></a>:</p>
<pre><code>from contextlib import nested

with nested(A(), B(), C()) as (X, Y, Z):
    do_something()
</code></pre>
<p>is equivalent to:</p>
<pre><code>m1, m2, m3 = A(), B(), C()
with m1 as X:
    with m2 as Y:
        with m3 as Z:
            do_something()
</code></pre>
<p>Note that this isn't exactly the same as normally using nested <code>with</code>, because <code>A()</code>, <code>B()</code>, and <code>C()</code> will all be called initially, before entering the context managers. This will not work correctly if one of these functions raises an exception.</p>
<p><code>contextlib.nested</code> is deprecated in newer Python versions in favor of the above methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>The first part of your question is possible in <a href="http://docs.python.org/py3k/reference/compound_stmts.html#with" rel="noreferrer">Python 3.1</a>.</p>
<blockquote>
<p>With more than one item, the context managers are processed as if multiple with statements were nested:</p>
<pre><code>with A() as a, B() as b:
    suite
</code></pre>
<p>is equivalent to</p>
<pre><code>with A() as a:
    with B() as b:
        suite
</code></pre>
<p><em>Changed in version 3.1</em>: Support for multiple context expressions</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>@interjay's Answer is correct. However, if you need to do this for long context managers, for example mock.patch context managers, then you quickly realize you want to break this across lines. Turns out you can't wrap them in parens, so you have to use backslashes. Here's what that looks like:</p>
<pre><code>with mock.patch('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as a, \
        mock.patch('bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb') as b, \
        mock.patch('cccccccccccccccccccccccccccccccccccccccccc') as c:
    do_something()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The second part of your question is solved with <code>contextlib.ExitStack</code> in <a href="http://docs.python.org/dev/library/contextlib.html">Python 3.3</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Following on from @sage88's response you can always assign those patches to have meaningful variable names before you enter into them.</p>
<p>You could create those patches in multiple lines </p>
<pre><code>a_patch = mock.patch('aaaaaaa') 
b_patch = mock.patch('bbbbbbb')
c_patch = mock.patch('ccccccc') 
with a_patch as a, b_patch as b, as c:    
    do_something()
</code></pre>
</div>
<span class="comment-copy">I've started <a href="https://meta.stackoverflow.com/q/378616/8117067">a meta discussion about reversing the duplicate target for this question</a>.</span>
<span class="comment-copy">@timgeb I've <a href="https://meta.stackoverflow.com/q/378616/8117067">started a discussion about this duplicate closure</a>. My apologies for  not @-notifying you sooner; it slipped my mind.</span>
<span class="comment-copy">@noam: No, in fact the docstring for <code>nested</code> in 3.1 says: "The one advantage of this function over the multiple manager form of the with statement is that argument unpacking allows it to be used with a variable number of context managers as follows: <code>with nested(*managers): do_something()</code>"</span>
<span class="comment-copy">Odd, on one hand it's deprecated, but on the other they acknowledge an advantage of the deprecated module over the replacement?</span>
<span class="comment-copy"><i>But usually this makes no difference</i>. It makes a <b>huge</b> difference if <code>B()</code> or <code>C()</code> raises an exception. The nested <code>with</code> statement will call <code>A().__exit__()</code>, but the <code>contextlib.nested()</code> setup will not!</span>
<span class="comment-copy">One issue: Using the simple "with open(A) as a, open(B) as b:" style syntax, line breaks make pep8 compliance as reported by standard tools seemingly impossible.  I use a backslash to signify the line break, because surrounding the comma-separated expressions with parentheses results in the report of a syntax error.  With the backslash, I get an "E127 continuation line over-indented" warning.  I have yet to find a way to use this syntax while suppressing all warnings.</span>
<span class="comment-copy">@DarrenRinger I had this same problem. I, too, used backslashes, which I abhor, to accomplish this. Double indent all the context managers after the initial with line. Only single indent the content being wrapped. It passes flake8 for me.</span>
<span class="comment-copy">thanks! but that still didn't answer my whole question: what about the 2nd case I mentioned, where the context managers are given in an array, without knowing how many mangers are there in the array. will it be possible in some python3.X to do <code>with [cm1,cm2,cm3,cm4,cm5] as result: ....</code></span>
<span class="comment-copy">@noam: To solve the second part of your question you could write a class to wrap a number of resources and implement <code>__enter__</code> and <code>__exit__</code> for that class. I'm not sure if there's a standard library class that does this already.</span>
<span class="comment-copy">@Mark I don't think it is that easy - that's why <code>contextlib.nested()</code> is deprecated. If something happens between the generation of the other things and the activation of the context manager, it might happen that the cleanup doesn't happen as wanted.</span>
