<div class="post-text" itemprop="text">
<p>I noticed that the Python 2.7 documentation includes yet another command-line parsing module.  In addition to <code>getopt</code> and <code>optparse</code> we now have <code>argparse</code>.</p>
<p>Why has yet another command-line parsing module been created?  Why should I use it instead of <code>optparse</code>?  Are there new features that I should know about?</p>
</div>
<div class="post-text" itemprop="text">
<p>As of python <code>2.7</code>, <a href="https://docs.python.org/2/library/optparse.html" rel="noreferrer"><code>optparse</code></a> is deprecated, and will hopefully go away in the future.</p>
<p><a href="https://docs.python.org/3/library/argparse.html" rel="noreferrer"><code>argparse</code></a> is better for all the reasons listed on its original page (<a href="https://code.google.com/archive/p/argparse/" rel="noreferrer">https://code.google.com/archive/p/argparse/</a>):</p>
<ul>
<li>handling positional arguments</li>
<li>supporting sub-commands</li>
<li>allowing alternative option prefixes like <code>+</code> and <code>/</code></li>
<li>handling zero-or-more and one-or-more style arguments</li>
<li>producing more informative usage messages</li>
<li>providing a much simpler interface for custom types and actions</li>
</ul>
<p>More information is also in <a href="http://www.python.org/dev/peps/pep-0389/" rel="noreferrer">PEP 389</a>, which is the vehicle by which <code>argparse</code> made it into the standard library.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why should I use it instead of
  optparse? Are their new features I
  should know about?</p>
</blockquote>
<p>@Nicholas's answer covers this well, I think, but not the more "meta" question you start with:</p>
<blockquote>
<p>Why has yet another command-line
  parsing module been created?</p>
</blockquote>
<p>That's the dilemma number one when any useful module is added to the standard library: what do you do when a substantially better, but backwards-incompatible, way to provide the same kind of functionality emerges?</p>
<p>Either you stick with the old and admittedly surpassed way (typically when we're talking about complicated packages: asyncore vs twisted, tkinter vs wx or Qt, ...) or you end up with multiple incompatible ways to do the same thing (XML parsers, IMHO, are an even better example of this than command-line parsers -- but the <code>email</code> package vs the myriad old ways to deal with similar issues isn't too far away either;-).</p>
<p>You may make threatening grumbles in the docs about the old ways being "deprecated", but (as long as you need to keep backwards compatibility) you can't really take them away without stopping large, important applications from moving to newer Python releases.</p>
<p>(Dilemma number two, not directly related to your question, is summarized in the old saying "the standard library is where good packages go to die"... with releases every year and a half or so, packages that aren't very, <strong>very</strong> stable, <strong>not</strong> needing releases any more often than that, can actually suffer substantially by being "frozen" in the standard library... but, that's really a different issue).</p>
</div>
<div class="post-text" itemprop="text">
<p>The best source for rationale for a Python addition would be its PEP: <a href="http://www.python.org/dev/peps/pep-0389/" rel="noreferrer">PEP 389: argparse - New Command Line Parsing Module</a>, in particular, the section entitled, <a href="http://www.python.org/dev/peps/pep-0389/#why-aren-t-getopt-and-optparse-enough" rel="noreferrer">Why aren't getopt and optparse enough?</a></p>
</div>
<div class="post-text" itemprop="text">
<p>There are also new kids on the block!</p>
<ul>
<li>Besides the already mentioned deprecated <strong>optparse</strong>. [DO NOT USE]</li>
<li><strong>argparse</strong> was also mentioned, which is a solution for people not willing to include external libs.</li>
<li><strong>docopt</strong> is an external lib worth looking at, which uses a documentation string as the parser for your input.</li>
<li><strong>click</strong> is also external lib and uses decorators for defining arguments. (My source recommends: <a href="http://click.pocoo.org/5/why/" rel="nofollow noreferrer">Why Click</a>)</li>
<li><strong>python-inquirer</strong> For selection focused tools and based on Inquirer.js (<a href="https://github.com/magmax/python-inquirer" rel="nofollow noreferrer">repo</a>)</li>
</ul>
<p>If you need a more in-depth comparison please read <a href="https://realpython.com/blog/python/comparing-python-command-line-parsing-libraries-argparse-docopt-click/" rel="nofollow noreferrer">this</a> and you may end up using <strong>docopt</strong> or <strong>click</strong>. Thanks to Kyle Purdon!</p>
</div>
<div class="post-text" itemprop="text">
<p>At first I was as reluctant as @fmark to switch from optparse to argparse, because: </p>
<ol>
<li>I thought the difference was not that huge.</li>
<li>Quite some VPS still provides Python 2.6 by default.</li>
</ol>
<p>Then I saw this doc, argparse outperforms optparse, especially when talking about generating meaningful help message: <a href="http://argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html" rel="nofollow">http://argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html</a></p>
<p>And then I saw "<a href="http://code.google.com/p/argparse/" rel="nofollow">argparse vs. optparse</a>" by @Nicholas, saying we can have argparse available in python &lt;2.7  (Yep, I didn't know that before.)</p>
<p>Now my two concerns are well addressed. I wrote this hoping it will help others with a similar mindset.</p>
</div>
<span class="comment-copy">Or maybe use none because since 2012 Python has an easy, powerful and really <i>cool</i> module for argument parsing called docopt. <a href="http://docopt.org" rel="nofollow noreferrer">docopt.org</a></span>
<span class="comment-copy">try click it is wrapper around optparse.</span>
<span class="comment-copy">A much simpler interface for custom types... but a more complex interface overall.  I really do wonder why I even switched to optparse, because <i>drumroll</i> getopt will <i>stay</i>.  Yup, no deprecation for that dinosaur.  Sheeesh.</span>
<span class="comment-copy">The mention of "purity" of <code>optparse</code> in the PEP then later arguments about how complex it is to add on to makes it sound like it was coded to be as flexible as rock (poorly).</span>
<span class="comment-copy">The subcommands interface is poor. Default output is not useful and changing it is hard.</span>
<span class="comment-copy">Note that code.google.com will go on Maintenance in few days. Differences with more details are available here: <a href="https://argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html" rel="nofollow noreferrer">argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html</a></span>
<span class="comment-copy">Admittedly, you can include argparse.py for python installations before 2.7 and not worry about backwards-incompatible changes. Extra thing to track, but it is still maintained outside of the standard library at argparse.googlecode.com</span>
<span class="comment-copy">Argparse is substantially better only for some (niche?) uses.  It's not really better in absolute terms, it's <i>different</i>.  It can do things optparse can't, but it also has regressions.  One example I just ran into: optparse handled "--" by default (not sure it did what this is supposed to do) while argparse doesn't know anything of it.</span>
<span class="comment-copy">while this is a worthwhile comment, it still is a comment more than an answer.. no downvote but no upvote for me either! Expand your answer with a valuable summary of the article to make it into a real answer!: <a href="https://meta.stackexchange.com/a/8259/172394">meta.stackexchange.com/a/8259/172394</a></span>
<span class="comment-copy">I tried to include a summary of my link I hope now it is worth a good stackoverflow answer.</span>
