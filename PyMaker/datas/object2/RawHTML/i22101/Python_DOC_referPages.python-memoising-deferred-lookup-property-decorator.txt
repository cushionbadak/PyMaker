<div class="post-text" itemprop="text">
<p>Recently I've gone through an existing code base containing many classes where instance attributes reflect values stored in a database. I've refactored a lot of these attributes to have their database lookups be deferred, ie. not be initialised in the constructor but only upon first read. These attributes do not change over the lifetime of the instance, but they're a real bottleneck to calculate that first time and only really accessed for special cases. Hence they can also be cached after they've been retrieved from the database (this therefore fits the definition of <em>memoisation</em> where the input is simply "no input").</p>
<p>I find myself typing the following snippet of code over and over again for various attributes across various classes:</p>
<pre><code>class testA(object):

  def __init__(self):
    self._a = None
    self._b = None

  @property
  def a(self):
    if self._a is None:
      # Calculate the attribute now
      self._a = 7
    return self._a

  @property
  def b(self):
    #etc
</code></pre>
<p>Is there an existing decorator to do this already in Python that I'm simply unaware of? Or, is there a reasonably simple way to define a decorator that does this?</p>
<p>I'm working under Python 2.5, but 2.6 answers might still be interesting if they are significantly different.</p>
<h2>Note</h2>
<p>This question was asked before Python included a lot of ready-made decorators for this. I have updated it only to correct terminology.</p>
</div>
<div class="post-text" itemprop="text">
<p>For all sorts of great utilities I'm using <a href="http://boltons.readthedocs.io/en/latest/index.html" rel="noreferrer">boltons</a>.</p>
<p>As part of that library you have <a href="http://boltons.readthedocs.io/en/latest/cacheutils.html?highlight=lazy#boltons.cacheutils.cachedproperty" rel="noreferrer">cachedproperty</a>:</p>
<pre><code>from boltons.cacheutils import cachedproperty

class Foo(object):
    def __init__(self):
        self.value = 4

    @cachedproperty
    def cached_prop(self):
        self.value += 1
        return self.value


f = Foo()
print(f.value)  # initial value
print(f.cached_prop)  # cached property is calculated
f.value = 1
print(f.cached_prop)  # same value for the cached property - it isn't calculated again
print(f.value)  # the backing value is different (it's essentially unrelated value)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an example implementation of a lazy property decorator:</p>
<pre><code>import functools

def lazyprop(fn):
    attr_name = '_lazy_' + fn.__name__

    @property
    @functools.wraps(fn)
    def _lazyprop(self):
        if not hasattr(self, attr_name):
            setattr(self, attr_name, fn(self))
        return getattr(self, attr_name)

    return _lazyprop


class Test(object):

    @lazyprop
    def a(self):
        print 'generating "a"'
        return range(5)
</code></pre>
<p>Interactive session:</p>
<pre><code>&gt;&gt;&gt; t = Test()
&gt;&gt;&gt; t.__dict__
{}
&gt;&gt;&gt; t.a
generating "a"
[0, 1, 2, 3, 4]
&gt;&gt;&gt; t.__dict__
{'_lazy_a': [0, 1, 2, 3, 4]}
&gt;&gt;&gt; t.a
[0, 1, 2, 3, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I wrote this one for myself... To be used for true <em>one-time</em> calculated lazy properties.  I like it because it avoids sticking extra attributes on objects, and once activated does not waste time checking for attribute presence, etc.:</p>
<pre><code>import functools

class lazy_property(object):
    '''
    meant to be used for lazy evaluation of an object attribute.
    property should represent non-mutable data, as it replaces itself.
    '''

    def __init__(self, fget):
        self.fget = fget

        # copy the getter function's docstring and other attributes
        functools.update_wrapper(self, fget)

    def __get__(self, obj, cls):
        if obj is None:
            return self

        value = self.fget(obj)
        setattr(obj, self.fget.__name__, value)
        return value


class Test(object):

    @lazy_property
    def results(self):
        calcs = 1  # Do a lot of calculation here
        return calcs
</code></pre>
<p>Note: The <code>lazy_property</code> class is a <a href="https://docs.python.org/3/howto/descriptor.html#descriptor-protocol" rel="noreferrer">non-data descriptor</a>, which means it is read-only. Adding a <code>__set__</code> method would prevent it from working correctly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a callable that takes an optional timeout argument, in the <code>__call__</code> you could also copy over the <code>__name__</code>, <code>__doc__</code>, <code>__module__</code> from func's namespace:</p>
<pre><code>import time

class Lazyproperty(object):

    def __init__(self, timeout=None):
        self.timeout = timeout
        self._cache = {}

    def __call__(self, func):
        self.func = func
        return self

    def __get__(self, obj, objcls):
        if obj not in self._cache or \
          (self.timeout and time.time() - self._cache[key][1] &gt; self.timeout):
            self._cache[obj] = (self.func(obj), time.time())
        return self._cache[obj]
</code></pre>
<p>ex:</p>
<pre><code>class Foo(object):

    @Lazyproperty(10)
    def bar(self):
        print('calculating')
        return 'bar'

&gt;&gt;&gt; x = Foo()
&gt;&gt;&gt; print(x.bar)
calculating
bar
&gt;&gt;&gt; print(x.bar)
bar
...(waiting 10 seconds)...
&gt;&gt;&gt; print(x.bar)
calculating
bar
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>property</code> is a class. A <a href="http://docs.python.org/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor</a> to be exact. Simply derive from it and implement the desired behavior.</p>
<pre><code>class lazyproperty(property):
   ....

class testA(object):
   ....
  a = lazyproperty('_a')
  b = lazyproperty('_b')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you <em>really</em> want is the <a href="http://docs.pylonsproject.org/projects/pyramid/en/latest/_modules/pyramid/decorator.html#reify" rel="nofollow noreferrer"><code>reify</code> (source linked!)</a> decorator from Pyramid:</p>
<blockquote>
<p>Use as a class method decorator. It operates almost exactly like the Python <code>@property</code> decorator, but it puts the result of the method it decorates into the instance dict after the first call, effectively replacing the function it decorates with an instance variable. It is, in Python parlance, a non-data descriptor. The following is an example and its usage:</p>
<pre><code>&gt;&gt;&gt; from pyramid.decorator import reify

&gt;&gt;&gt; class Foo(object):
...     @reify
...     def jammy(self):
...         print('jammy called')
...         return 1

&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; v = f.jammy
jammy called
&gt;&gt;&gt; print(v)
1
&gt;&gt;&gt; f.jammy
1
&gt;&gt;&gt; # jammy func not called the second time; it replaced itself with 1
&gt;&gt;&gt; # Note: reassignment is possible
&gt;&gt;&gt; f.jammy = 2
&gt;&gt;&gt; f.jammy
2
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>There is a mix up of terms and/or confusion of concepts both in question and in answers so far.</p>
<p>Lazy evaluation just means that something is evaluated at runtime at the last possible moment when a value is needed. <s>The standard <code>@property</code> decorator does just that.</s>(*) The decorated function is evaluated only and every time you need the value of that property. (see wikipedia article about lazy evaluation)

<p>(*)Actually a true lazy evaluation (compare e.g. haskell) is very hard to achieve in python (and results in code which is far from idiomatic). </p>
<p>Memoization is the correct term for what the asker seems to be looking for. Pure functions that do not depend on side effects for return value evaluation can be safely memoized and there is actually a decorator in <a href="https://docs.python.org/3/library/functools.html" rel="nofollow">functools</a> <code>@functools.lru_cache</code> so no need for writing own decorators unless you need specialized behavior.</p>
</p></div>
<div class="post-text" itemprop="text">
<p>You can do this nice and easily by building a class from Python native property:</p>
<pre><code>class cached_property(property):
    def __init__(self, func, name=None, doc=None):
        self.__name__ = name or func.__name__
        self.__module__ = func.__module__
        self.__doc__ = doc or func.__doc__
        self.func = func

    def __set__(self, obj, value):
        obj.__dict__[self.__name__] = value

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        value = obj.__dict__.get(self.__name__, None)
        if value is None:
            value = self.func(obj)
            obj.__dict__[self.__name__] = value
        return value
</code></pre>
<p>We can use this property class like regular class property ( It's also support item assignment as you can see)</p>
<pre><code>class SampleClass():
    @cached_property
    def cached_property(self):
        print('I am calculating value')
        return 'My calculated value'


c = SampleClass()
print(c.cached_property)
print(c.cached_property)
c.cached_property = 2
print(c.cached_property)
print(c.cached_property)
</code></pre>
<p>Value only calculated first time and after that we used our saved value</p>
<p>Output:</p>
<pre><code>I am calculating value
My calculated value
My calculated value
2
2
</code></pre>
</div>
<span class="comment-copy">I'm using Python 2.7, and I don't see anything about ready-made decorators for this. Can you provide a link to the ready-made decorators that are mentioned in the question?</span>
<span class="comment-copy">@Bamcclur sorry, there used to be other comments detailing them, not sure why they got deleted. The only one I can find right now is a Python 3 one: <a href="https://docs.python.org/3.5/library/functools.html?highlight=cache#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache()</code></a>.</span>
<span class="comment-copy">Not sure there are built-ins (at least Python 2.7), but there's the Boltons library's <a href="http://boltons.readthedocs.io/en/latest/cacheutils.html?highlight=lazy#boltons.cacheutils.cachedproperty" rel="nofollow noreferrer">cachedproperty</a></span>
<span class="comment-copy">@guyarad I didn't see this comment until now. That is a fantastic library! Post that as an answer so I can upvote it.</span>
<span class="comment-copy">Can someone recommend an appropriate name for the inner function? I'm so bad at naming things in the morning...</span>
<span class="comment-copy">I usually name the inner function the same as the outer function with a preceding underscore. So "_lazyprop" - follows the "internal use only" philosophy of pep 8.</span>
<span class="comment-copy">This works great :) I don't know why it never occurred to me to use a decorator on a nested function like that, too.</span>
<span class="comment-copy">+1: I love decorators!</span>
<span class="comment-copy">given the non-data descriptor protocol, this one is much slower and less elegant than the answer below using <code>__get__</code></span>
<span class="comment-copy">This took a little while to understand but is an absolutely stunning answer.  I like how the function itself is replaced by the value it calculates.</span>
<span class="comment-copy">For posterity: other versions of this have been proposed in other answers since (ref <a href="http://stackoverflow.com/a/18289908/313063">1</a>and <a href="http://stackoverflow.com/a/17487613/313063">2</a>).  Seems this is a popular one in Python web frameworks (derivatives exist in Pyramid and Werkzeug).</span>
<span class="comment-copy">Thanks for noting that Werkzeug has werkzeug.utils.cached_property: <a href="http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.cached_property" rel="nofollow noreferrer">werkzeug.pocoo.org/docs/utils/#werkzeug.utils.cached_property</a></span>
<span class="comment-copy">I found this method to be 7.6 times faster than the selected answer. (2.45 Âµs / 322 ns) <a href="http://nbviewer.ipython.org/gist/croepha/9278416" rel="nofollow noreferrer">See ipython notebook</a></span>
<span class="comment-copy">NB: this <i>does not prevent assignment</i> to <code>fget</code> the way <code>@property</code> does. To ensure immutability/idempotence, you need to add a <code>__set__()</code> method that raises <code>AttributeError('can\'t set attribute')</code> (or whatever exception/message suits you, but this is what <code>property</code> raises). This unfortunately comes with a performance impact of a fraction of a microsecond because <code>__get__()</code> will be called on each access rather than pulling fget value from <b>dict</b> on second and subsequent access. Well worth it in my opinion to maintain immutability/idempotence, which is key for my use cases, but YMMV.</span>
<span class="comment-copy">Nice one, does exactly what I needed... although Pyramid might be a big dependency for one decorator <code>:)</code></span>
<span class="comment-copy">@detly The decorator implementation is simple, and you could implement it yourself, no need for the <code>pyramid</code> dependency.</span>
<span class="comment-copy">Hence the link says "source linked" :D</span>
<span class="comment-copy">@AnttiHaapala I noticed, but thought I'd highlight that it's simple to implement for those that don't follow the link.</span>
<span class="comment-copy">I used the term "lazy" because in the original implementation, the member was computed/retrieved from a DB at the time of object initialisation, and I want to defer that computation until the property was actually used in a template. This seemed to me to match the definition of laziness. I agree that since my question already assumes a solution using <code>@property</code>, "lazy" doesn't make a lot of sense at that point. (I also thought of memoisation as a map of inputs to cached outputs, and since these properties have only one input, nothing, a map seemed like more complexity than necessary.)</span>
<span class="comment-copy">Note that all of the decorators that people have suggested as "out of the box" solutions didn't exist when I asked this, either.</span>
<span class="comment-copy">I agree with Jason, this is a question about caching/memoization not lazy evaluation.</span>
<span class="comment-copy">@poindexter - Caching doesn't <i>quite</i> cover it; it does not distinguish looking the value up at object init time and caching it from looking the value up and caching it when the property is accessed (which is the key feature here). What should I call it? "Cache-after-first-use" decorator?</span>
<span class="comment-copy">@detly Memoize. You should call it Memoize.  <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">en.wikipedia.org/wiki/Memoization</a></span>
