<div class="post-text" itemprop="text">
<p>Suppose I have a numpy array <code>x = [5, 2, 3, 1, 4, 5]</code>, <code>y = ['f', 'o', 'o', 'b', 'a', 'r']</code>. I want to select the elements in <code>y</code> corresponding to elements in <code>x</code> that are greater than 1 and less than 5.</p>
<p>I tried</p>
<pre><code>x = array([5, 2, 3, 1, 4, 5])
y = array(['f','o','o','b','a','r'])
output = y[x &gt; 1 &amp; x &lt; 5] # desired output is ['o','o','a']
</code></pre>
<p>but this doesn't work. How would I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your expression works if you add parentheses:</p>
<pre><code>&gt;&gt;&gt; y[(1 &lt; x) &amp; (x &lt; 5)]
array(['o', 'o', 'a'], 
      dtype='|S1')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>IMO OP does not actually want <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.bitwise_and.html" rel="noreferrer"><code>np.bitwise_and()</code> (aka <code>&amp;</code>)</a> but actually wants <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_and.html" rel="noreferrer"><code>np.logical_and()</code></a> because they are comparing logical values such as <code>True</code> and <code>False</code> - see this SO post on <a href="https://stackoverflow.com/questions/8418295/logical-vs-bitwise">logical vs. bitwise</a> to see the difference.</p>
<pre><code>&gt;&gt;&gt; x = array([5, 2, 3, 1, 4, 5])
&gt;&gt;&gt; y = array(['f','o','o','b','a','r'])
&gt;&gt;&gt; output = y[np.logical_and(x &gt; 1, x &lt; 5)] # desired output is ['o','o','a']
&gt;&gt;&gt; output
array(['o', 'o', 'a'],
      dtype='|S1')
</code></pre>
<p>And equivalent way to do this is with <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.all.html" rel="noreferrer"><code>np.all()</code></a> by setting the <code>axis</code> argument appropriately.</p>
<pre><code>&gt;&gt;&gt; output = y[np.all([x &gt; 1, x &lt; 5], axis=0)] # desired output is ['o','o','a']
&gt;&gt;&gt; output
array(['o', 'o', 'a'],
      dtype='|S1')
</code></pre>
<p>by the numbers:</p>
<pre><code>&gt;&gt;&gt; %timeit (a &lt; b) &amp; (b &lt; c)
The slowest run took 32.97 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 1.15 µs per loop

&gt;&gt;&gt; %timeit np.logical_and(a &lt; b, b &lt; c)
The slowest run took 32.59 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.17 µs per loop

&gt;&gt;&gt; %timeit np.all([a &lt; b, b &lt; c], 0)
The slowest run took 67.47 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 5.06 µs per loop
</code></pre>
<p>so using <code>np.all()</code> is slower, but <code>&amp;</code> and <code>logical_and</code> are about the same.</p>
</div>
<div class="post-text" itemprop="text">
<p>Add one detail to @J.F. Sebastian's and @Mark Mikofski's answers:<br/>
If one wants to get the corresponding indices (rather than the actual values of array), the following code will do:</p>
<p>For satisfying multiple (all) conditions:</p>
<pre><code>select_indices = np.where( np.logical_and( x &gt; 1, x &lt; 5) )[0] #   1 &lt; x &lt;5
</code></pre>
<p>For satisfying multiple (or) conditions:</p>
<pre><code>select_indices = np.where( np.logical_or( x &lt; 1, x &gt; 5 ) )[0] # x &lt;1 or x &gt;5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I like to use <code>np.vectorize</code> for such tasks. Consider the following:</p>
<pre><code>&gt;&gt;&gt; # Arrays
&gt;&gt;&gt; x = np.array([5, 2, 3, 1, 4, 5])
&gt;&gt;&gt; y = np.array(['f','o','o','b','a','r'])

&gt;&gt;&gt; # Function containing the constraints
&gt;&gt;&gt; func = np.vectorize(lambda t: t&gt;1 and t&lt;5)

&gt;&gt;&gt; # Call function on x
&gt;&gt;&gt; y[func(x)]
&gt;&gt;&gt; array(['o', 'o', 'a'], dtype='&lt;U1')
</code></pre>
<p>The advantage is you can add many more types of constraints in the vectorized function.</p>
<p>Hope it helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Actually I would do it this way:</p>
<p>L1 is the index list of elements satisfying condition 1;(maybe you can use <code>somelist.index(condition1)</code> or <code>np.where(condition1)</code> to get L1.)</p>
<p>Similarly, you get L2, a list of elements satisfying condition 2;</p>
<p>Then you find intersection using <code>intersect(L1,L2)</code>.</p>
<p>You can also find intersection of multiple lists if you get multiple conditions to satisfy.</p>
<p>Then you can apply index in any other array, for example, x.</p>
</div>
<div class="post-text" itemprop="text">
<p>For 2D arrays, you can do this. Create a 2D mask using the condition. Typecast the condition mask to int or float, depending on the array, and multiply it with the original array.</p>
<pre><code>In [8]: arr
Out[8]: 
array([[ 1.,  2.,  3.,  4.,  5.],
       [ 6.,  7.,  8.,  9., 10.]])

In [9]: arr*(arr % 2 == 0).astype(np.int) 
Out[9]: 
array([[ 0.,  2.,  0.,  4.,  0.],
       [ 6.,  0.,  8.,  0., 10.]])
</code></pre>
</div>
<span class="comment-copy">That is nice.. vecMask=1&lt;x generates a vector mask like vecMask=(False, True, ...), which can be just combined with other vector masks. Each element is the condition for taking the elements of a source vector (True) or not (False). This can be used also with the full version numpy.extract(vecMask, vecSrc), or numpy.where(vecMask, vecSrc, vecSrc2).</span>
<span class="comment-copy">omg this is so weird</span>
<span class="comment-copy">@JennyYueJin: It happens because of precedence. (Bitwise) <code>&amp;</code> has higher precedence than <code>&lt;</code> and <code>&gt;</code>, which in turn have higher precedence than (logical) <code>and</code>. <code>x &gt; 1 and x &lt; 5</code> evaulates the inequalities first and then the logical conjunction; <code>x &gt; 1 &amp; x &lt; 5</code> evaluates the bitwise conjunction of <code>1</code> and (the values in) <code>x</code>, then the inequalities. <code>(x &gt; 1) &amp; (x &lt; 5)</code> forces the inequalities to evaluate first, so all of the operations occur in the intended order and the results are all well-defined. <a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="nofollow noreferrer">See docs here.</a></span>
<span class="comment-copy">@ru111 It works on Python 3.6 too (there is no reason for it to stop working).</span>
<span class="comment-copy">I get "ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()"</span>
<span class="comment-copy">You need to be a little careful about how you speak about what's evaluated.  For example, in <code>output = y[np.logical_and(x &gt; 1, x &lt; 5)]</code>, <code>x &lt; 5</code> <i>is</i> evaluated (possibly creating an enormous array), even though it's the second argument, because that evaluation happens outside of the function.  IOW, <code>logical_and</code> gets passed two already-evaluated arguments.  This is different from the usual case of <code>a and b</code>, in which <code>b</code> isn't evaluated if <code>a</code> is truelike.</span>
<span class="comment-copy">there is no difference between bitwise_and() and logical_and() for boolean arrays</span>
<span class="comment-copy">Note that numpy.where will not just return an array of the indices, but will instead return a tuple (the output of condition.nonzero()) containing arrays - in this case, <code>(the array of indices you want,)</code>, so you'll need <code>select_indices = np.where(...)[0]</code> to get the result you want and expect.</span>
