<div class="post-text" itemprop="text">
<p>On the surface, this is pretty simple, and I could implement it myself easily.  Just successively call dirname() to go up each level in the file's path and check each one to see if it's the directory we're checking for.</p>
<p>But symlinks throw the whole thing into chaos.  Any directory along the path of either the file or directory being checked could be a symlink, and any symlink could have an arbitrary chain of symlinks to other symlinks.  At this point my brain melts and I'm not sure what to do.  I've tried writing the code to handle these special cases, but it soon gets too complicated and I assume I'm doing it wrong.  Is there a reasonably elegant way to do this?</p>
<p>I'm using Python, so any mention of a library that does this would be cool.  Otherwise, this is a pretty language-neutral problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/os.path.html#os.path.realpath" rel="nofollow noreferrer"><code>os.path.realpath</code></a> and <a href="https://docs.python.org/3/library/os.path.html#os.path.commonprefix" rel="nofollow noreferrer"><code>os.path.commonprefix</code></a>:</p>
<pre><code>os.path.commonprefix(['/the/dir/', os.path.realpath(filename)]) == "/the/dir/"
</code></pre>
<p><code>os.path.realpath</code> will expand any symlinks as well as <code>..</code> in the filename. <code>os.path.commonprefix</code> is a bit fickle -- it doesn't really test for paths, just plain string prefixes, so you should make sure your directory ends in a directory separator. If you don't, it will claim <code>/the/dirtwo/filename</code> is also in <code>/the/dir</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3.5 has the useful function <a href="https://docs.python.org/3/library/os.path.html#os.path.commonpath" rel="nofollow"><code>os.path.commonpath</code></a>:</p>
<blockquote>
<p>Return the longest common sub-path of each pathname in the sequence paths. Raise ValueError if paths contains both absolute and relative pathnames, or if paths is empty. Unlike <code>commonprefix()</code>, this returns a valid path.</p>
</blockquote>
<p>So to check if a file is a descendant of a directory, you could do this:</p>
<pre><code>os.path.commonpath(["/the/dir", os.path.realpath(filename)]) == "/the/dir"
</code></pre>
<p>Unlike <code>commonprefix</code>, you don't need to worry if the inputs have trailing slashes or not. The return value of <code>commonprefix</code> always lacks a trailing slash.</p>
</div>
<span class="comment-copy">Maybe the edge cases are all in my head.  I could swear that symlinks make this approach fail in some cases, but I can't come up with examples to prove it.  I feel like I'm fighting a ghost...</span>
<span class="comment-copy">Since every hierarchical file system I can think of requires a single, unique, canonical, real named directories, this actually works. Although it may be counter-intuitive that you could get from here to there, for directories the "one real parent" has to be true or bad things ensue.</span>
<span class="comment-copy">Well, it's good news to hear this.  Now I just need to check four cases (realpath and non-realpath for both dir and file).  Thanks!</span>
