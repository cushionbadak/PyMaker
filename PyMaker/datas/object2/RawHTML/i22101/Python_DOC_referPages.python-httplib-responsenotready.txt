<div class="post-text" itemprop="text">
<p>I'm writing a REST client for elgg using python, and even when the request succeeds, I get this in response:</p>
<pre><code>Traceback (most recent call last):
  File "testclient.py", line 94, in &lt;module&gt;
    result = sendMessage(token, h1)
  File "testclient.py", line 46, in sendMessage
    res = h1.getresponse().read()
  File "C:\Python25\lib\httplib.py", line 918, in getresponse
    raise ResponseNotReady()
httplib.ResponseNotReady
</code></pre>
<p>Looking at the header, I see ('content-length', '5749'), so I know there is a page there, but I can't use .read() to see it because the exception comes up. What does ResponseNotReady mean and why can't I see the content that was returned?</p>
</div>
<div class="post-text" itemprop="text">
<p>Make sure you don't reuse the same object from a previous connection. You will hit this once the server <em>keep-alive</em> ends and the socket closes.</p>
</div>
<div class="post-text" itemprop="text">
<p>Previous answers are correct, but there's another case where you could get that exception:</p>
<p>Making multiple requests without reading any intermediate responses completely.</p>
<p>For instance:</p>
<pre><code>conn.request('PUT',...)
conn.request('GET',...)
# will not work: raises ResponseNotReady

conn.request('PUT',...)
r = conn.getresponse()
r.read() # &lt;-- that's the important call!
conn.request('GET',...)
r = conn.getresponse()
r.read() # &lt;-- same thing
</code></pre>
<p>and so on.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was running into this same exception today, using this code:</p>
<pre><code>    conn = httplib.HTTPConnection(self._host, self._port)
    conn.putrequest('GET',
        '/retrieve?id={0}'.format(parsed_store_response['id']))
    retr_response = conn.getresponse()
</code></pre>
<p>I didn't notice that I was using <code>putrequest</code> rather than <code>request</code>; I was mixing my interfaces.  <code>ResponseNotReady</code> is raised because I haven't actually sent the request yet.</p>
</div>
<div class="post-text" itemprop="text">
<p>Additionally, errors like this can occur when the server sends a response without a Content-Length header, which will cripple the state of the HTTP client if Keep-Alive is used and another request is sent over the same socket.</p>
</div>
<div class="post-text" itemprop="text">
<p>This can also occur if a firewall blocks the connection.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unable to add comment to @Bokeh 's answer; as I do not have the requisite reputation yet on this platform.</p>
<p>So, adding as answer: Bokeh's answer worked for me.</p>
<p>I was trying to pipeline multiple requests sequentially over the same connection object. For few of the responses I wanted to process the response later, hence missed to read the response.</p>
<p>From my experience, I second Bokeh's answer:</p>
<p>response.read() is a must after each request. Even if you wish to process response or not.</p>
<p>From my standpoint this question would have been incomplete without Bokeh's answer. 
Thanks @Bokeh</p>
</div>
<span class="comment-copy">Are you re-using the connection?</span>
<span class="comment-copy">Indeed. Oddly, sometimes it works and sometimes it doesn't. I can't determine what behavior determines that though.</span>
<span class="comment-copy">Generally, as a rule, I don't bother trying to reuse HttpRequest objects unless I have a specific, performance-driven need to do so. Just single-shot 'em</span>
<span class="comment-copy">In my case, adding <code>preload_content=False</code> solved the issue. Here is the snippet: <code>http = urllib3.PoolManager(threadsNo, maxsize=threadsNo, block=True); request = http.request('GET', queryUrl, preload_content=False)</code> It looks like <code>request.release_conn()</code> does not really release the previous connection object unless above parameter is passed to http.request. More details here: <a href="https://urllib3.readthedocs.org/en/latest/pools.html" rel="nofollow noreferrer">urllib3.readthedocs.org/en/latest/pools.html</a></span>
<span class="comment-copy">Thats what I was needing .read() so I can reuse my connection.</span>
<span class="comment-copy">is .read() expensive. What if I don't care about the response? Can I make it run faster ?&gt;</span>
<span class="comment-copy">@ronnefeldt, Python docs at  <a href="https://docs.python.org/3/library/http.client.html" rel="nofollow noreferrer">docs.python.org/3/library/http.client.html</a>  has the following note: "Note that you must have read the whole response before you can send a new request to the server.".</span>
<span class="comment-copy">If you hadn't said this I would have had a very upsetting next few hours maybe even days. THANK YOU</span>
