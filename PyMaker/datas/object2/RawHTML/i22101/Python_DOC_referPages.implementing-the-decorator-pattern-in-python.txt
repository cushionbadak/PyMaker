<div class="post-text" itemprop="text">
<p>I want to implement the <a href="http://en.wikipedia.org/wiki/Decorator_pattern" rel="noreferrer">decorator pattern</a> in Python, and I wondered if there is a way to write a decorator that just implements the function it wants to modify, without writing boiler-plate for all the functions that are just forwarded to the decorated object. Like so:</p>
<pre><code>class foo(object):
    def f1(self):
        print "original f1"
    def f2(self):
        print "original f2"

class foo_decorator(object):
    def __init__(self, decoratee):
        self._decoratee = decoratee
    def f1(self):
        print "decorated f1"
        self._decoratee.f1()
    def f2(self):              # I would like to leave that part out
        self._decoratee.f2()
</code></pre>
<p>I would like to have calls to <code>foo_decorator.f2</code> forwarded to <code>decoratee.f2</code> automatically. Is there a way to write a generic method that forwards all unimplemented function-calls to <code>decoratee</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>__getattr__</code>:</p>
<pre><code>class foo(object):
    def f1(self):
        print "original f1"
    def f2(self):
        print "original f2"

class foo_decorator(object):
    def __init__(self, decoratee):
        self._decoratee = decoratee
    def f1(self):
        print "decorated f1"
        self._decoratee.f1()
    def __getattr__(self, name):
        return getattr(self._decoratee, name)

u = foo()
v = foo_decorator(u)
v.f1()
v.f2()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As an addendum to Philipp's answer; if you need to not only decorate, but preserve the <em>type</em> of an object, Python allows you to subclass an instance at runtime:</p>
<pre><code>class foo(object):
    def f1(self):
        print "original f1"

    def f2(self):
        print "original f2"


class foo_decorator(object):
    def __new__(cls, decoratee):
        cls = type('decorated',
                   (foo_decorator, decoratee.__class__),
                   decoratee.__dict__)
        return object.__new__(cls)

    def f1(self):
        print "decorated f1"
        super(foo_decorator, self).f1()


u = foo()
v = foo_decorator(u)
v.f1()
v.f2()
print 'isinstance(v, foo) ==', isinstance(v, foo)
</code></pre>
<p>This is a bit more involved than strictly necessary for your example, where you know the class being decorated in advance.</p>
<p>This <em>might</em> suffice:</p>
<pre><code>class foo_decorator(foo):
    def __init__(self, decoratee):
        self.__dict__.update(decoratee.__dict__)

    def f1(self):
        print "decorated f1"
        super(foo_decorator, self).f1()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's arguably not the best practice, but you can add functionality to instances, as I've done to help transition my code from Django's ORM to SQLAlachemy, as follows:</p>
<pre><code>def _save(self):
    session.add(self)
    session.commit()
setattr(Base,'save',_save)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The UML diagram in the linked Wikipedia article is wrong and so is your code.</p>
<p>If you follow the "decorator pattern", the decorator class is derived from the base decorated class. (In the UML diagram an inheritance arrow from the WindowDecorator to Window is missing).</p>
<p>with</p>
<pre><code>class foo_decorator(foo):
</code></pre>
<p>you don't need to implement undecorated methods.</p>
<p>BTW: In strong typed languages there is one more reason, why the decorator must be derived from the decorated class: Otherwise you wouldnt be able to chain decorators.</p>
</div>
<div class="post-text" itemprop="text">
<p>To complement @Alec Thomas reply. I modified his answer to follow the decorator pattern. This way you don't need to know the class you're decorating in advance.</p>
<pre><code>class Decorator(object):
    def __new__(cls, decoratee):
        cls = type('decorated',
                   (cls, decoratee.__class__),
                   decoratee.__dict__)
        return object.__new__(cls)
</code></pre>
<p>Then, you can use it as:</p>
<pre><code>class SpecificDecorator(Decorator):
    def f1(self):
        print "decorated f1"
        super(foo_decorator, self).f1()

class Decorated(object):
    def f1(self):
        print "original f1"


d = SpecificDecorator(Decorated())
d.f1()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In one of my projects, I also needed to do one particular thing, that is that even the underlying object should actually execute the method that was reimplemented in the decorator. It is actually quite easy to do if you know where to target it.</p>
<p>The use case is:</p>
<ul>
<li>I have an object X with methods A and B.</li>
<li>I create a decorator class Y that overrides A.</li>
<li>If I instantiate Y(X) and call A, it will use the decorated A as expected.</li>
<li>If B calls A, then if I instantiate Y(X) and call B on the decorator, the call from within B then goes to the old A on the original object which was undesirable. I want the old B to call the new A as well.</li>
</ul>
<p>It is possible to reach this behaviour like this:</p>
<pre class="lang-py prettyprint-override"><code>import inspect
import six      # for handling 2-3 compatibility

class MyBaseDecorator(object):
    def __init__(self, decorated):
        self.decorated = decorated

    def __getattr__(self, attr):
       value = getattr(self.decorated, attr)
       if inspect.ismethod(value):
           function = six.get_method_function(value)
           value = function.__get__(self, type(self))
       return value

class SomeObject(object):
    def a(self):
        pass

    def b(self):
        pass

class MyDecorator(MyBaseDecorator):
    def a(self):
        pass

decorated = MyDecorator(SomeObject())
</code></pre>
<p>This may not work out of the box as I typed everything else apart from the getattr method from top of my head.</p>
<p>The code looks up the requested attribute in the decorated object, and if it is a method (doesn't work for properties now, but the change to support them should not be too difficult), the code then pulls the actual function out of the method and using the descriptor interface invocation it "rebinds" the function as a method, but on the decorator. Then it is returned and most likely executed.</p>
<p>The effect of this is that if <code>b</code> ever calls <code>a</code> on the original object, then when you have the object decorated and there is any method call coming from the decorator, the decorator makes sure that all methods accessed are bound to the decorator instead, therefore looking up things using the decorator and not the original object, therefore the methods specified in the decorator taking precedence.</p>
<p>P.S.: Yes I know it looks pretty much like inheritance, but this done in the sense of composition of multiple objects.</p>
</div>
<span class="comment-copy">Can you give a example where simply subclassing wouldnt work? You can subclass dynamically too - this pattern seems like a workaround for languages that can't do that or don't support multiple inheritage.</span>
<span class="comment-copy">I want to decorate objects at runtime. I want to apply different decorators to an object and be able to remove them again. Subclassing cannot change an instance after it has been created, or can it?</span>
<span class="comment-copy">If you have class <code>A</code> and change <code>A</code>, ie adding a new method, <code>A.foo = lambda self: self</code> this will reflect on all instances of A .. because <i>everything</i> is determined at runtime. Great way to produce absolutely unmaintainable code.</span>
<span class="comment-copy">@THC4K: The decorator pattern (as opposed to python decorators) is used to add behavior to an <i>object</i> at runtime. This is actually very maintainable, when done correctly, which is why I posted this question. I wanted to find the way to this in Python.</span>
<span class="comment-copy">This is a great idea. It should be noted, however, that if you use Abstract Base Classes (ie import abc and use <b>metaclass</b> = abc.ABCMeta to define abstract methods and properties) then it will not work.</span>
<span class="comment-copy">This doesn't work for functions like <b>str</b>. What is happening there?</span>
<span class="comment-copy">@JohnKitchin: The redirection doesn't work for double underscore methods, because these must (for performance reasons) be defined on the class, not the instance. <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">(more info)</a> I believe the only workaround is to explicitly define and redirect methods like <code>__str__</code>.</span>
<span class="comment-copy">Is this really the "accepted" way of setting up the decorator pattern? Overwriting a "double underscore" method feels hacky.</span>
<span class="comment-copy">This seems to execute the decoratee's __init__() again, passing it <code>decoratee</code>, which is probably not desired.</span>
<span class="comment-copy">I considered this as well, but it feels very wrong to me. Maybe that is because I come from C++?</span>
<span class="comment-copy">It's fair to feel wrong about it.  It could be considered monkey patching. However it works well with little code, it's a very different world with more possibilities from C when everything is dynamic &amp; by reference.</span>
<span class="comment-copy">I like it. For this example, anything else would just introduce more complexity IMO.</span>
<span class="comment-copy">The UML diagram shows both inheritance and aggregation (two essential parts for decorator pattern) of the base class.  You inherit from the base class, so you look like the original, and you hold a reference to an instance of the base class where you can insulate access to it.  The wikipedia article says this in steps 1 and 2: "(1) Subclass the original Component, (2) add a Component pointer as a field".  So the original question is actually about Python duck typing, and neither about the decorator patter, nor Python decorators!</span>
