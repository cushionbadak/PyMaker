<div class="post-text" itemprop="text">
<p>I'd like to have several of the doctests in a file share test data and/or functions.  Is there a way to do this without locating them in an external file or within the code of the file being tested?</p>
<h3>update</h3>
<pre><code>"""This is the docstring for the module ``fish``.

I've discovered that I can access the module under test
  from within the doctest, and make changes to it, eg


&gt;&gt;&gt; import fish
&gt;&gt;&gt; fish.data = {1: 'red', 2: 'blue'}
"""

def jef():
    """
    Modifications made to the module will persist across subsequent tests:

    &gt;&gt;&gt; import fish
    &gt;&gt;&gt; fish.data[1]
    'red'
    """
    pass

def seuss():
    """
    Although the doctest documentation claims that
      "each time doctest finds a docstring to test,
       it uses a shallow copy of M‘s globals",
      modifications made to the module by a doctest
      are not imported into the context of subsequent docstrings:

    &gt;&gt;&gt; data
    Traceback (most recent call last):
      ...
    NameError: name 'data' is not defined
    """
    pass
</code></pre>
<p>So I guess that <code>doctest</code> copies the module once, and then copies the copy for each docstring?</p>
<p>In any case, importing the module into each docstring seems usable, if awkward.</p>
<p>I'd prefer to use a separate namespace for this, to avoid accidentally trampling on actual module data that will or will not be imported into subsequent tests in an possibly undocumented manner.</p>
<p>It's occurred to me that it's (theoretically) possible to dynamically create a module in order to contain this namespace.  However as yet I've not gotten any direction on how to do that from <a href="https://stackoverflow.com/questions/2931950/dynamic-module-creation">the question I asked</a> about that a while back.  Any information is quite welcome!  (as a response to the appropriate question)</p>
<p>In any case I'd prefer to have the changes be propagated directly into the namespace of subsequent docstrings.  So my original question still stands, with that as a qualifier.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the sort of thing that causes people to turn away from doctests: as your tests grow in complexity, you need real programming tools to be able to engineer your tests just as you would engineer your product code.</p>
<p>I don't think there's a way to include shared data or functions in doctests other than defining them in your product code and then using them in the doctests.</p>
<p>You are going to need to use real code to define some of your test infrastructure.  If you like doctests, you can use that infrastructure from your doctests.</p>
</div>
<div class="post-text" itemprop="text">
<p>This <em>is</em> possible, albeit perhaps not advertised as loudly.</p>
<p>To obtain literate modules with tests that all use a shared execution context (i.e. individual tests can share and re-use their results), one has to look at <a href="https://docs.python.org/3/library/doctest.html#what-s-the-execution-context" rel="nofollow">the relevant part of documentation</a> which says:</p>
<blockquote>
<p>... each time <code>doctest</code> finds a docstring to test, it uses a <em>shallow</em> <strong>copy</strong> of <code>M</code>‘s globals, so that running tests doesn’t change the module’s real globals, and so that one test in <code>M</code> can’t leave behind crumbs that accidentally allow another test to work. </p>
<p>...</p>
<p>You can <strong>force use of <em>your own</em> dict</strong> as the execution context by passing <code>globs=your_dict</code> to <code>testmod()</code> or <code>testfile()</code> instead.</p>
</blockquote>
<p>Given this, <a href="https://gist.github.com/kernc/0dccae6542465d59a331" rel="nofollow">I managed to reverse-engineer</a> from <code>doctest</code> module that besides using copies (i.e. the <code>dict</code>'s <code>copy()</code> method), it also clears the globals dict (using <code>clear()</code>) after each test.</p>
<p>Thus, one can patch their own globals dictionary with something like:</p>
<pre><code>class Context(dict):
    def clear(self):
        pass
    def copy(self):
        return self 
</code></pre>
<p>and then use it as: </p>
<pre><code>import doctest
from importlib import import_module

module = import_module('some.module')
doctest.testmod(module,
                # Make a copy of globals so tests in this
                # module don't affect the tests in another
                glob=Context(module.__dict__.copy()))
</code></pre>
</div>
<span class="comment-copy">Agreed. Doctests are great for illustrating basic usage and testing the API, but for deeper tests you need more traditional unit tests. On the plus side, you can run your doctests from the main unit testing frameworks.</span>
<span class="comment-copy">The point was not to use doctests for testing, but to be able to reuse objects in usage examples across various functions or classes.</span>
<span class="comment-copy">Doctests rule! <a href="http://stackoverflow.com/a/35242381/1090455">There <i>is</i> a way</a>.</span>
