<div class="post-text" itemprop="text">
<p>What is an efficient way to repeat a string to a certain length? Eg: <code>repeat('abc', 7) -&gt; 'abcabca'</code></p>
<p>Here is my current code:</p>
<pre><code>def repeat(string, length):
    cur, old = 1, string
    while len(string) &lt; length:
        string += old[cur-1]
        cur = (cur+1)%len(old)
    return string
</code></pre>
<p>Is there a better (more pythonic) way to do this? Maybe using list comprehension?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def repeat_to_length(string_to_expand, length):
   return (string_to_expand * ((length/len(string_to_expand))+1))[:length]
</code></pre>
<p>For python3:</p>
<pre><code>def repeat_to_length(string_to_expand, length):
    return (string_to_expand * (int(length/len(string_to_expand))+1))[:length]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Jason Scheirer's answer is correct but could use some more exposition.</p>
<p>First off, to repeat a string an integer number of times, you can use overloaded multiplication:</p>
<pre><code>&gt;&gt;&gt; 'abc' * 7
'abcabcabcabcabcabcabc'
</code></pre>
<p>So, to repeat a string until it's <em>at least</em> as long as the length you want, you calculate the appropriate number of repeats and put it on the right-hand side of that multiplication operator:</p>
<pre><code>def repeat_to_at_least_length(s, wanted):
    return s * (wanted//len(s) + 1)

&gt;&gt;&gt; repeat_to_at_least_length('abc', 7)
'abcabcabc'
</code></pre>
<p>Then, you can trim it to the exact length you want with an array slice:</p>
<pre><code>def repeat_to_length(s, wanted):
    return (s * (wanted//len(s) + 1))[:wanted]

&gt;&gt;&gt; repeat_to_length('abc', 7)
'abcabca'
</code></pre>
<p>Alternatively, as suggested in <a href="https://stackoverflow.com/a/3391233/215487">pillmod's answer</a> that probably nobody scrolls down far enough to notice anymore, you can use <a href="https://docs.python.org/3/library/functions.html#divmod" rel="noreferrer"><code>divmod</code></a> to compute the number of full repetitions needed, and the number of extra characters, all at once:</p>
<pre><code>def pillmod_repeat_to_length(s, wanted):
    a, b = divmod(wanted, len(s))
    return s * a + s[:b]
</code></pre>
<p>Which is better? Let's benchmark it:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.repeat('scheirer_repeat_to_length("abcdefg", 129)', globals=globals())
[0.3964178159367293, 0.32557755894958973, 0.32851039397064596]
&gt;&gt;&gt; timeit.repeat('pillmod_repeat_to_length("abcdefg", 129)', globals=globals())
[0.5276265419088304, 0.46511475392617285, 0.46291469305288047]
</code></pre>
<p>So, pillmod's version is something like 40% slower, which is too bad, since personally I think it's much more readable.  There are several possible reasons for this, starting with its compiling to about 40% more bytecode instructions.</p>
<p>Note: these examples use the new-ish <code>//</code> operator for truncating integer division.  This is often <em>called</em> a Python 3 feature, but according to <a href="https://www.python.org/dev/peps/pep-0238/" rel="noreferrer">PEP 238</a>, it was introduced all the way back in Python 2.2.  You only <em>have</em> to use it in Python 3 (or in modules that have <code>from __future__ import division</code>) but you <em>can</em> use it regardless.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is pretty pythonic:</p>
<pre><code>newstring = 'abc'*5
print newstring[0:6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def rep(s, m):
    a, b = divmod(m, len(s))
    return s * a + s[:b]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import cycle, islice
def srepeat(string, n):
   return ''.join(islice(cycle(string), n))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about <code>string * (length / len(string)) + string[0:(length % len(string))]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps not the most efficient solution, but certainly short &amp; simple:</p>
<pre><code>def repstr(string, length):
    return (string * length)[0:length]

repstr("foobar", 14)
</code></pre>
<p>Gives "foobarfoobarfo".  One thing about this version is that if length &lt; len(string) then the output string will be truncated.  For example:</p>
<pre><code>repstr("foobar", 3)
</code></pre>
<p>Gives "foo".</p>
<p>Edit: actually to my surprise, this is faster than the currently accepted solution (the 'repeat_to_length' function), at least on short strings:</p>
<pre><code>from timeit import Timer
t1 = Timer("repstr('foofoo', 30)", 'from __main__ import repstr')
t2 = Timer("repeat_to_length('foofoo', 30)", 'from __main__ import repeat_to_length')
t1.timeit()  # gives ~0.35 secs
t2.timeit()  # gives ~0.43 secs
</code></pre>
<p>Presumably if the string was long, or length was very high (that is, if the wastefulness of the <code>string * length</code> part was high) then it would perform poorly.  And in fact we can modify the above to verify this:</p>
<pre><code>from timeit import Timer
t1 = Timer("repstr('foofoo' * 10, 3000)", 'from __main__ import repstr')
t2 = Timer("repeat_to_length('foofoo' * 10, 3000)", 'from __main__ import repeat_to_length')
t1.timeit()  # gives ~18.85 secs
t2.timeit()  # gives ~1.13 secs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>i use this: </p>
<pre><code>def extend_string(s, l):
    return (s*l)[:l]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not that there haven't been enough answers to this question, but there is a repeat function; just need to make a list of and then join the output:</p>
<pre><code>from itertools import repeat

def rep(s,n):
  ''.join(list(repeat(s,n))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Yay recursion!</strong></p>
<pre><code>def trunc(s,l):
    if l &gt; 0:
        return s[:l] + trunc(s, l - len(s))
    return ''
</code></pre>
<p>Won't scale forever, but it's fine for smaller strings. And it's pretty.</p>
<p>I admit I just read the Little Schemer and I like recursion right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is one way to do it using a list comprehension, though it's increasingly wasteful as the length of the <code>rpt</code> string increases.</p>
<pre><code>def repeat(rpt, length):
    return ''.join([rpt for x in range(0, (len(rpt) % length))])[:length]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another FP aproach:</p>
<pre><code>def repeat_string(string_to_repeat, repetitions):
    return ''.join([ string_to_repeat for n in range(repetitions)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def extended_string (word, length) :

    extra_long_word = word * (length//len(word) + 1)
    required_string = extra_long_word[:length]
    return required_string

print(extended_string("abc", 7))
</code></pre>
</div>
<span class="comment-copy">Looks like this is taking advantage of integer division. Doesn't that need to be <code>//</code> in Python 3? Or dropping the <code>+1</code> and using an explicit call to a ceiling function would suffice. Also, a note: the string generated actually has an extra repetition when it divides evenly; the extra gets cut off by the splice. That confused me at first.</span>
<span class="comment-copy"><code>int()</code> does the same thing here, but yea, <code>//</code> might be microscopically faster, because it does the divide &amp; floor in one command instead of two.</span>
<span class="comment-copy">No, OP wants the result to be of length 7 (which is not a multiple of 3).</span>
<span class="comment-copy">What was the name of this feature? Repeated concat ???</span>
<span class="comment-copy">I'm a bit conflicted because this isn't the correct answer for OP but is the correct answer for me and 489 other people...</span>
<span class="comment-copy">@MattFletcher You've just pushed me over the line from "I ought to rewrite this as an explainer of the accepted answer" to "I <i>will</i> rewrite this..." ;-)</span>
<span class="comment-copy"><code>0:7</code> if you want 7 chars like OP.</span>
<span class="comment-copy">This is what I use when I only need to iterate over the string (no join needed then). Let the python libraries do the job.</span>
<span class="comment-copy"><code>length / len(string)</code> needs to be wrapper in parenthesis, and you're missing the last <code>]</code>.</span>
<span class="comment-copy">The most readable/intuitive so far, in my opinion. I think you need to use <code>//</code> for integer division in Python 3. The <code>0</code> in the splice is optional. (The colon is required, of course.)</span>
<span class="comment-copy">You could add a switch between the two versions based on the input and output lengths for maximum optimization.</span>
