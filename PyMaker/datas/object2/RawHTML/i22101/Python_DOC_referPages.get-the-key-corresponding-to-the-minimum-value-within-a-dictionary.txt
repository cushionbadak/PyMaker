<div class="post-text" itemprop="text">
<p>If I have a Python dictionary, how do I get the key to the entry which contains the minimum value?</p>
<p>I was thinking about something to do with the <code>min()</code> function...</p>
<p>Given the input:</p>
<pre><code>{320:1, 321:0, 322:3}
</code></pre>
<p>It would return <code>321</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Best: <code>min(d, key=d.get)</code> -- no reason to interpose a useless <code>lambda</code> indirection layer or extract items or keys!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an answer that actually gives the solution the OP asked for:</p>
<pre><code>&gt;&gt;&gt; d = {320:1, 321:0, 322:3}
&gt;&gt;&gt; d.items()
[(320, 1), (321, 0), (322, 3)]
&gt;&gt;&gt; # find the minimum by comparing the second element of each tuple
&gt;&gt;&gt; min(d.items(), key=lambda x: x[1]) 
(321, 0)
</code></pre>
<p>Using <a href="http://docs.python.org/library/stdtypes.html#dict.iteritems" rel="noreferrer"><code>d.iteritems()</code></a> will be more efficient for larger dictionaries, however.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>min(d.items(), key=lambda x: x[1])[0]</code></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; d = {320:1, 321:0, 322:3}
&gt;&gt;&gt; min(d, key=lambda k: d[k]) 
321
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the case where you have multiple minimal keys and want to keep it simple</p>
<pre><code>def minimums(some_dict):
    positions = [] # output variable
    min_value = float("inf")
    for k, v in some_dict.items():
        if v == min_value:
            positions.append(k)
        if v &lt; min_value:
            min_value = v
            positions = [] # output variable
            positions.append(k)

    return positions

minimums({'a':1, 'b':2, 'c':-1, 'd':0, 'e':-1})

['e', 'c']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are not sure that you have not multiple minimum values, I would suggest:</p>
<pre><code>d = {320:1, 321:0, 322:3, 323:0}
print ', '.join(str(key) for min_value in (min(d.values()),) for key in d if d[key]==min_value)

"""Output:
321, 323
"""
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edit:</strong> this is an answer to the OP's <em>original</em> question about the minimal key, not the minimal answer.</p>
<hr/>
<p>You can get the keys of the dict using the <code>keys</code> function, and you're right about using <code>min</code> to find the minimum of that list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach to addressing the issue of multiple keys with the same min value:</p>
<pre><code>&gt;&gt;&gt; dd = {320:1, 321:0, 322:3, 323:0}
&gt;&gt;&gt;
&gt;&gt;&gt; from itertools import groupby
&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt;
&gt;&gt;&gt; print [v for k,v in groupby(sorted((v,k) for k,v in dd.iteritems()), key=itemgetter(0)).next()[1]]
[321, 323]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For multiple keys which have equal lowest value, you can use a list comprehension:</p>
<pre><code>d = {320:1, 321:0, 322:3, 323:0}

minval = min(d.values())
res = [k for k, v in d.items() if v==minval]

[321, 323]
</code></pre>
<p>An equivalent functional version:</p>
<pre><code>res = list(filter(lambda x: d[x]==minval, d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>min</code> with an iterator (for python 3 use <code>items</code> instead of <code>iteritems</code>); instead of lambda use the <code>itemgetter</code> from operator, which is faster than lambda.</p>
<pre><code>from operator import itemgetter
min_key, _ = min(d.iteritems(), key=itemgetter(1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>d={}
d[320]=1
d[321]=0
d[322]=3
value = min(d.values())
for k in d.keys(): 
    if d[k] == value:
        print k,d[k]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I compared how the following three options perform:</p>
<pre><code>    import random, datetime

myDict = {}
for i in range( 10000000 ):
    myDict[ i ] = random.randint( 0, 10000000 )



# OPTION 1

start = datetime.datetime.now()

sorted = []
for i in myDict:
    sorted.append( ( i, myDict[ i ] ) )
sorted.sort( key = lambda x: x[1] )
print( sorted[0][0] )

end = datetime.datetime.now()
print( end - start )



# OPTION 2

start = datetime.datetime.now()

myDict_values = list( myDict.values() )
myDict_keys = list( myDict.keys() )
min_value = min( myDict_values )
print( myDict_keys[ myDict_values.index( min_value ) ] )

end = datetime.datetime.now()
print( end - start )



# OPTION 3

start = datetime.datetime.now()

print( min( myDict, key=myDict.get ) )

end = datetime.datetime.now()
print( end - start )
</code></pre>
<p>Sample output:</p>
<pre><code>#option 1
236230
0:00:14.136808

#option 2
236230
0:00:00.458026

#option 3
236230
0:00:00.824048
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>to create an orderable class you have to override 6 special functions, so that it would be called by the min() function</p>
<p>these methods are<code>__lt__ , __le__, __gt__, __ge__, __eq__ , __ne__</code> in order they are less than, less than or equal, greater than, greater than or equal, equal, not equal.
for example you should implement <code>__lt__</code> as follows:</p>
<pre><code>def __lt__(self, other):
  return self.comparable_value &lt; other.comparable_value
</code></pre>
<p>then you can use the min function as follows:</p>
<pre><code>minValue = min(yourList, key=(lambda k: yourList[k]))
</code></pre>
<p>this worked for me.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code># python 
d={320:1, 321:0, 322:3}
reduce(lambda x,y: x if d[x]&lt;=d[y] else y, d.iterkeys())
  321
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Is this what you are looking for?</p>
<pre><code>d = dict()
d[15.0]='fifteen'
d[14.0]='fourteen'
d[14.5]='fourteenandhalf'

print d[min(d.keys())]
</code></pre>
<p>Prints 'fourteen'</p>
</div>
<span class="comment-copy">Typo in your stated return?  Otherwise, why 321? Shouldn't it be 320?</span>
<span class="comment-copy">@myself:  Okay, now I see - what is wanted is the key to the entry where the value of the entry is the minimum.  Better wording to the question please, as others obviously thought the same as I did.</span>
<span class="comment-copy">Data structure awareness day: if you only ever query (or remove) the minimum element, consider using a priority queue or heap.</span>
<span class="comment-copy">@SilentGhost: You wouldn't, I'm not sure what I was thinking.</span>
<span class="comment-copy">@KarelBÃ­lek it means you passed in as "d" a list e.g. <code>[11, 22, 33]</code>, instead of a dictionary e.g. <code>{1: 11, 2:22, 3:33}</code>. 'd.get' is valid for a dictionary, but not for a list.</span>
<span class="comment-copy">what if two different keys have the same value? and they happen to both be the smallest value? how can you make it return both?</span>
<span class="comment-copy">Can this technique be used if the dict values are lists, ex: <code>d={"a":[10, None], "b":[20, None]}</code>, where the min is calculated from d[key][0] ?</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer">get method in py3doc</a></span>
<span class="comment-copy">Instead of the lambda you can use <code>operator.itemgetter(1)</code>.</span>
<span class="comment-copy">instead lamda use d.get</span>
<span class="comment-copy">This does not return the key as asked, but the (key, value) pair.</span>
<span class="comment-copy">did you actually run this?</span>
<span class="comment-copy">It works, but gives the result 321, not (321, 0) ?</span>
<span class="comment-copy">@SilentGhost, @blob8108: D'oh!  Copy-and-paste snafu.  Fixed now.</span>
<span class="comment-copy">Fine solution I think, but the anonymous function only adds a layer of indirection: <code>key=d.get</code> is better.</span>
<span class="comment-copy">Not really deserving a downvote, as the poster's original question wasn't as clear as it might have been.</span>
<span class="comment-copy">@Space_C0wb0y: perhaps you can be so kind to notice that the OP edited his question to mean something different, after I answered</span>
<span class="comment-copy">Any idea how to work out the smallest value ABOVE zero?</span>
<span class="comment-copy">-1 for reduce in python</span>
<span class="comment-copy">@miked: why the reduce-hate?</span>
<span class="comment-copy">1)Reduce is generally slower than itertools. 2)Most implementations of reduce can be done simpler with any or all. 3)I am a giant mouthpiece for GvR. 4)The operator module makes most simple lambdas unnecessary, and complex lambdas should be defined as real functions anyway. Maybe I'm just scared of functional programming. ;)</span>
<span class="comment-copy">@miked: tell me more. what's gvr and what's the operator module? could you post links? i may know others, but i'm still just an intermediate in python. willing to learn! :-)</span>
<span class="comment-copy">GvR is Guido van Rossum, Python's benevolent dictator for life. Here's a <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">five year old post</a> from him explaining why lisp-isms (map,filter,reduce,lambda) don't have much of a place in python going forward, and those reasons are still true today. The operator module has replacements for <a href="http://docs.python.org/library/operator.html#operator.attrgetter" rel="nofollow noreferrer">extracting members</a>: "lambda x: x[1]" compared to "itemgetter(1)" is a character longer and arguably takes longer to understand. I'm out of space, but ask questions!</span>
<span class="comment-copy">-1: not what the question asked. You're returning the value with the minimum key, OP wants key with the minimum value</span>
