<div class="post-text" itemprop="text">
<p>I have a list of product codes in a text file, on each like is the product code that looks like:</p>
<p>abcd2343
abw34324
abc3243-23A</p>
<p>So it is letters followed by numbers and other characters.</p>
<p>I want to split on the first occurrence of a number.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>In [32]: import re

In [33]: s='abcd2343 abw34324 abc3243-23A'

In [34]: re.split('(\d+)',s)
Out[34]: ['abcd', '2343', ' abw', '34324', ' abc', '3243', '-', '23', 'A']
</code></pre>
<p>Or, if you want to split on the first occurrence of a digit:</p>
<pre><code>In [43]: re.findall('\d*\D+',s)
Out[43]: ['abcd', '2343 abw', '34324 abc', '3243-', '23A']
</code></pre>
<hr/>
<ul>
<li><code>\d+</code> matches 1-or-more digits.</li>
<li><code>\d*\D+</code> matches 0-or-more digits followed by 1-or-more non-digits.</li>
<li><code>\d+|\D+</code> matches 1-or-more digits <em>or</em> 1-or-more non-digits.</li>
</ul>
<p>Consult <a href="https://docs.python.org/3/library/re.html#regular-expression-syntax" rel="noreferrer">the docs</a> for more about Python's regex syntax.</p>
<hr/>
<p><code>re.split(pat, s)</code> will split the string <code>s</code> using <code>pat</code> as the delimiter.  If <code>pat</code> begins and ends with parentheses (so as to be a "capturing group"), then <code>re.split</code> will return the substrings matched by <code>pat</code> as well. For instance, compare:</p>
<pre><code>In [113]: re.split('\d+', s)
Out[113]: ['abcd', ' abw', ' abc', '-', 'A']   # &lt;-- just the non-matching parts

In [114]: re.split('(\d+)', s)
Out[114]: ['abcd', '2343', ' abw', '34324', ' abc', '3243', '-', '23', 'A']  # &lt;-- both the non-matching parts and the captured groups
</code></pre>
<p>In contrast, <code>re.findall(pat, s)</code> returns only the parts of <code>s</code> that match <code>pat</code>:</p>
<pre><code>In [115]: re.findall('\d+', s)
Out[115]: ['2343', '34324', '3243', '23']
</code></pre>
<p>Thus, if <code>s</code> ends with a digit, you could avoid ending with an empty string by using <code>re.findall('\d+|\D+', s)</code> instead of <code>re.split('(\d+)', s)</code>: </p>
<pre><code>In [118]: s='abcd2343 abw34324 abc3243-23A 123'

In [119]: re.split('(\d+)', s)
Out[119]: ['abcd', '2343', ' abw', '34324', ' abc', '3243', '-', '23', 'A ', '123', '']

In [120]: re.findall('\d+|\D+', s)
Out[120]: ['abcd', '2343', ' abw', '34324', ' abc', '3243', '-', '23', 'A ', '123']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re

m = re.match(r"(?P&lt;letters&gt;[a-zA-Z]+)(?P&lt;the_rest&gt;.+)$",input)

m.group('letters')
m.group('the_rest')
</code></pre>
<p>This covers your corner case of abc3243-23A and will output <code>abc</code> for the letters group and 3243-23A for <code>the_rest</code></p>
<p>Since you said they are all on individual lines you'll obviously need to put a line at a time in <code>input</code></p>
</div>
<div class="post-text" itemprop="text">
<p>To partition on the first digit</p>
<pre><code>parts = re.split('(\d.*)','abcd2343')      # =&gt; ['abcd', '2343', '']
parts = re.split('(\d.*)','abc3243-23A')   # =&gt; ['abc', '3243-23A', '']
</code></pre>
<p>So the two parts are always parts[0] and parts[1].</p>
<p>Of course, you can apply this to multiple codes:</p>
<pre><code>&gt;&gt;&gt; s = "abcd2343 abw34324 abc3243-23A"
&gt;&gt;&gt; results = [re.split('(\d.*)', pcode) for pcode in s.split(' ')]
&gt;&gt;&gt; results
[['abcd', '2343', ''], ['abw', '34324', ''], ['abc', '3243-23A', '']]
</code></pre>
<p>If each code is in an individual line then instead of <code>s.split( )</code> use <code>s.splitlines()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def firstIntIndex(string):
    result = -1
    for k in range(0, len(string)):
        if (bool(re.match('\d', string[k]))):
            result = k
            break
    return result
</code></pre>
</div>
<span class="comment-copy">If you use '(\d+)', and a digit is the last character of the string, the last entry in the list will be an empty string. How do we avoid that?</span>
<span class="comment-copy">IIUC, you could use <code>re.findall('(\d+|\D+)', 'abcd2343 abw34324 abc3243-23')</code>, which returns <code>['abcd', '2343', ' abw', '34324', ' abc', '3243', '-', '23']</code>.</span>
