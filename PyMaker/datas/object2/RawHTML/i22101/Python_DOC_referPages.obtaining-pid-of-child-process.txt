<div class="post-text" itemprop="text">
<p>I am using python's multiprocessing module to spawn new process</p>
<p>as follows :</p>
<pre><code>import multiprocessing
import os
d = multiprocessing.Process(target=os.system,args=('iostat 2 &gt; a.txt',))
d.start()
</code></pre>
<p>I want to obtain pid of iostat command or the command executed using multiprocessing
  module </p>
<p>When I execute :</p>
<pre><code> d.pid 
</code></pre>
<p>it gives me pid of subshell in which this command is running .</p>
<p>Any help will be valuable .</p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>Similar to @rakslice, you can use <strong>psutil</strong>:</p>
<pre><code>import signal, psutil
def kill_child_processes(parent_pid, sig=signal.SIGTERM):
    try:
      parent = psutil.Process(parent_pid)
    except psutil.NoSuchProcess:
      return
    children = parent.children(recursive=True)
    for process in children:
      process.send_signal(sig)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you appear to be using Unix, you can use a quick <code>ps</code> command to get the details of the child processes, like I did here (this is Linux-specific):</p>
<pre><code>import subprocess, os, signal

def kill_child_processes(parent_pid, sig=signal.SIGTERM):
        ps_command = subprocess.Popen("ps -o pid --ppid %d --noheaders" % parent_pid, shell=True, stdout=subprocess.PIPE)
        ps_output = ps_command.stdout.read()
        retcode = ps_command.wait()
        assert retcode == 0, "ps command returned %d" % retcode
        for pid_str in ps_output.split("\n")[:-1]:
                os.kill(int(pid_str), sig)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For your example you may use the <code>subprocess</code> package. By default it executes the command without shell (like <code>os.system()</code>) and provides a PID:</p>
<pre><code>from subprocess import Popen
p = Popen('iostat 2 &gt; a.txt', shell=True)
processId = p.pid
p.communicate() # to wait until the end
</code></pre>
<p>The <code>Popen</code> also provides ability to connect to standard input and output of the process.</p>
<p>note: before using <code>shell=True</code> be aware of the <a href="https://docs.python.org/3/library/subprocess.html#security-considerations" rel="nofollow noreferrer">security considerations</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think with the multiprocess module you might be out of luck since you are really forking python directly and are given that Process object instead of the process you are interested in at the bottom of the process tree.</p>
<p>An alternative way, but perhaps not optimal way, to get that pid is to use the <a href="http://code.google.com/p/psutil/" rel="nofollow noreferrer">psutil</a> module to look it up using the pid obtained from your Process object.  Psutil, however, is system dependent and will need to be installed separately on each of your target platforms.  </p>
<p>Note:  I'm not currently at a machine I typically work from, so I can't provide working code nor play around to find a better option, but will edit this answer when I can to show how you might be able to do this.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>[me@localhost ~]$ echo $$
30399
[me@localhost ~]$ cat iostat.py 
#!/usr/bin/env python3.4 

import multiprocessing
import os
d = multiprocessing.Process(target=os.system,args=('iostat 2 &gt; a.txt',))
d.start()

[me@localhost ~]$ ./iostat.py &amp;
[1] 31068
[me@localhost ~]$ watch -n 3 'pstree -p 30399'
[me@localhost ~]$ 
</code></pre>
<p>This gave me the PID of <code>iostat</code> See image. <a href="https://i.stack.imgur.com/a7Vpz.png" rel="nofollow noreferrer"><img alt="process tree" src="https://i.stack.imgur.com/a7Vpz.png"/></a></p>
</div>
<span class="comment-copy">Why do <code>os.kill(pid.pid, sig)</code> instead of <code>pid.send_signal(sig)</code>? As in, why not use the API psutil gives you already? Also, <code>pid.send_signal</code> is supposedly safer as it should avoid race conditions such as when the original process with the given PID finishes and another one uses the same PID.</span>
<span class="comment-copy">Agree. pid.send_signal(sig) seems safer. Thank you.</span>
<span class="comment-copy">On a Mac: <code>ps -o pid,ppid -ax | grep &lt;PPID&gt; | cut -f 1 -d " " | tail -1</code></span>
<span class="comment-copy">Gah, yeah, my answer's probably Linux-specific.</span>
<span class="comment-copy">To get all children recursively, you can instead use: <code>subprocess.Popen('pstree -p %d | perl -ne \'print "$1 " while /\((\d+)\)/g\'' % parent_pid, shell=True, stdout=subprocess.PIPE)</code></span>
<span class="comment-copy">If you want to use subprocess.Popen without the shell option, you can't give it a shell command (like the single string with multiple parameters and a redirection shown here).</span>
