<div class="post-text" itemprop="text">
<p>In python if you write something like</p>
<pre><code>foo==bar and spam or eggs
</code></pre>
<p>python appears to return spam if the boolean statement is true and eggs otherwise. Could someone explain this behaviour? Why is the expression not being evaluated like one long boolean?</p>
<p>Edit: Specifically, I'm trying to figure out the mechanism why 'spam' or 'eggs' is being returned as the result of the expression.</p>
</div>
<div class="post-text" itemprop="text">
<p>The operators <code>and</code> and <code>or</code> are short-circuiting which means that if the result of the expression can be deduced from evaluating only the first operand, the second is not evaluated. For example if you have the expression <code>a or b</code> and <code>a</code> evaluates to true then it doesn't matter what <code>b</code> is, the result of the expression is true so <code>b</code> is not evaluated. They actually work as follows:</p>
<ul>
<li><code>a and b</code>: If a is falsey, b is not evaluated and a is returned, otherwise b is returned.</li>
<li><code>a or b</code>: If a is truthy, b is not evaluated and a is returned, otherwise b is returned.</li>
</ul>
<p>Falsey and truthy refer to values that evaluate to false or true in a boolean context.</p>
<p>However this and/or idiom was useful back in the days when there was no better alternative, but now there is a better way:</p>
<pre><code>spam if foo==bar else eggs
</code></pre>
<p>The problem with the and/or idiom (apart from it being confusing to beginners) is that it gives the wrong result if the condition is true but spam evaluates to a falsey value (e.g. the empty string). For this reason you should avoid it.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is how the Python boolean operators work.</p>
<p>From <a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">the documentation</a> (the last paragraph explains why it is a good idea that the operators work the way they do):</p>
<blockquote>
<p>In the context of Boolean operations,
  and also when expressions are used by
  control flow statements, the following
  values are interpreted as false:
  <code>False</code>, <code>None</code>, numeric zero of all
  types, and empty strings and
  containers (including strings, tuples,
  lists, dictionaries, sets and
  frozensets). All other values are
  interpreted as true. (See the
  <code>__nonzero__()</code> special method for a way to change this.)</p>
<p>The operator <code>not</code> yields <code>True</code> if its
  argument is false, <code>False</code> otherwise.</p>
<p>The expression <code>x and y</code> first evaluates
  <code>x</code>; if <code>x</code> is false, its value is
  returned; otherwise, <code>y</code> is evaluated
  and the resulting value is returned.</p>
<p>The expression <code>x or y</code> first evaluates
  <code>x</code>; if <code>x</code> is true, its value is
  returned; otherwise, y is evaluated
  and the resulting value is returned.</p>
<p>(Note that neither <code>and</code> nor <code>or</code> restrict
  the value and type they return to
  <code>False</code> and <code>True</code>, but rather return the
  last evaluated argument. This is
  sometimes useful, e.g., if <code>s</code> is a
  string that should be replaced by a
  default value if it is empty, the
  expression <code>s or 'foo'</code> yields the
  desired value. Because <code>not</code> has to
  invent a value anyway, it does not
  bother to return a value of the same
  type as its argument, so e.g., <code>not 'foo'</code> yields <code>False</code>, not <code>''</code>.)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The reason is that Python evaluates boolean expression using the actual values of the variables involved, instead of restricting them to <code>True</code> and <code>False</code> values. The following values are considered to be false:</p>
<ul>
<li><code>None</code></li>
<li><code>False</code></li>
<li>0 of any numeric type</li>
<li>empty sequence or set (<code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>)</li>
<li>user-defined types with <code>__nonzero__()</code> or <code>__len__()</code> method that returns 0 or <code>False</code></li>
</ul>
<p>See the <a href="http://docs.python.org/library/stdtypes.html#truth-value-testing" rel="nofollow noreferrer">Truth Value Testing</a> section of the Python documentation for more information. In particular: </p>
<blockquote>
<p>Operations and built-in functions that have a Boolean result always return <code>0</code> or <code>False</code> for false and <code>1</code> or <code>True</code> for true, unless otherwise stated. (Important exception: the Boolean operations <code>or</code> and <code>and</code> always return one of their operands.)</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Try using parentheses to make the expression non-ambiguous. The way it is, you're getting:</p>
<pre><code>(foo == bar and spam) or eggs
</code></pre>
</div>
<span class="comment-copy">'spam if foo==bar or eggs' shows a syntax error in python 2.6.5, but 'spam if foo==bar else eggs' works as intended.</span>
<span class="comment-copy">@Zxaos: Sorry about that. It should have been <code>else</code> not <code>or</code>. Fixed now.</span>
<span class="comment-copy">In "the wrong result... if foo evaluates to a falsey value" did you mean "spam evaluates to a falsey value"?</span>
<span class="comment-copy">@~unutbu: Erm, yep. Thanks. Another stupid error... :(</span>
<span class="comment-copy">Reference: <a href="https://docs.python.org/3.7/reference/expressions.html#boolean-operations" rel="nofollow noreferrer">docs.python.org/3.7/reference/â€¦</a></span>
<span class="comment-copy">+1 for link to docs.</span>
<span class="comment-copy">Ok, so assume foo and bar are equal. The interpreter should then evaluate True and spam, which should evaluate to True, so why is spam being returned?  Edit: Ah, ok. I see from the docs.</span>
<span class="comment-copy">@Zxaos: I've updated my answer with the quote from the documentation that explains the reason why.</span>
<span class="comment-copy">+1 for beating me to it</span>
<span class="comment-copy">I understand that it's being short circuited, but I'm unsure why spam or eggs are being returned as the result of the evaluation.</span>
