<div class="post-text" itemprop="text">
<p>I need to replace some characters as follows: <code>&amp;</code> -&gt; <code>\&amp;</code>, <code>#</code> -&gt; <code>\#</code>, ...</p>
<p>I coded as follows, but I guess there should be some better way. Any hints?</p>
<pre><code>strs = strs.replace('&amp;', '\&amp;')
strs = strs.replace('#', '\#')
...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Replacing two characters</h1>
<p>I timed all the methods in the current answers along with one extra.</p>
<p>With an input string of <code>abc&amp;def#ghi</code> and replacing &amp; -&gt; \&amp; and # -&gt; #, the fastest was to chain together the replacements like: <code>text.replace('&amp;', '\&amp;').replace('#', '\#')</code>.</p>
<p>Timings for each function:</p>
<ul>
<li>a) 1000000 loops, best of 3: 1.47 μs per loop</li>
<li>b) 1000000 loops, best of 3: 1.51 μs per loop</li>
<li>c) 100000 loops, best of 3: 12.3 μs per loop</li>
<li>d) 100000 loops, best of 3: 12 μs per loop</li>
<li>e) 100000 loops, best of 3: 3.27 μs per loop</li>
<li><strong>f) 1000000 loops, best of 3: 0.817 μs per loop</strong></li>
<li>g) 100000 loops, best of 3: 3.64 μs per loop</li>
<li><strong>h) 1000000 loops, best of 3: 0.927 μs per loop</strong></li>
<li><strong>i) 1000000 loops, best of 3: 0.814 μs per loop</strong></li>
</ul>
<p>Here are the functions:</p>
<pre><code>def a(text):
    chars = "&amp;#"
    for c in chars:
        text = text.replace(c, "\\" + c)


def b(text):
    for ch in ['&amp;','#']:
        if ch in text:
            text = text.replace(ch,"\\"+ch)


import re
def c(text):
    rx = re.compile('([&amp;#])')
    text = rx.sub(r'\\\1', text)


RX = re.compile('([&amp;#])')
def d(text):
    text = RX.sub(r'\\\1', text)


def mk_esc(esc_chars):
    return lambda s: ''.join(['\\' + c if c in esc_chars else c for c in s])
esc = mk_esc('&amp;#')
def e(text):
    esc(text)


def f(text):
    text = text.replace('&amp;', '\&amp;').replace('#', '\#')


def g(text):
    replacements = {"&amp;": "\&amp;", "#": "\#"}
    text = "".join([replacements.get(c, c) for c in text])


def h(text):
    text = text.replace('&amp;', r'\&amp;')
    text = text.replace('#', r'\#')


def i(text):
    text = text.replace('&amp;', r'\&amp;').replace('#', r'\#')
</code></pre>
<p>Timed like this:</p>
<pre><code>python -mtimeit -s"import time_functions" "time_functions.a('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.b('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.c('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.d('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.e('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.f('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.g('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.h('abc&amp;def#ghi')"
python -mtimeit -s"import time_functions" "time_functions.i('abc&amp;def#ghi')"
</code></pre>
<hr/>
<h1>Replacing 17 characters</h1>
<p>Here's similar code to do the same but with more characters to escape (\`*_{}&gt;#+-.!$):</p>
<pre><code>def a(text):
    chars = "\\`*_{}[]()&gt;#+-.!$"
    for c in chars:
        text = text.replace(c, "\\" + c)


def b(text):
    for ch in ['\\','`','*','_','{','}','[',']','(',')','&gt;','#','+','-','.','!','$','\'']:
        if ch in text:
            text = text.replace(ch,"\\"+ch)


import re
def c(text):
    rx = re.compile('([&amp;#])')
    text = rx.sub(r'\\\1', text)


RX = re.compile('([\\`*_{}[]()&gt;#+-.!$])')
def d(text):
    text = RX.sub(r'\\\1', text)


def mk_esc(esc_chars):
    return lambda s: ''.join(['\\' + c if c in esc_chars else c for c in s])
esc = mk_esc('\\`*_{}[]()&gt;#+-.!$')
def e(text):
    esc(text)


def f(text):
    text = text.replace('\\', '\\\\').replace('`', '\`').replace('*', '\*').replace('_', '\_').replace('{', '\{').replace('}', '\}').replace('[', '\[').replace(']', '\]').replace('(', '\(').replace(')', '\)').replace('&gt;', '\&gt;').replace('#', '\#').replace('+', '\+').replace('-', '\-').replace('.', '\.').replace('!', '\!').replace('$', '\$')


def g(text):
    replacements = {
        "\\": "\\\\",
        "`": "\`",
        "*": "\*",
        "_": "\_",
        "{": "\{",
        "}": "\}",
        "[": "\[",
        "]": "\]",
        "(": "\(",
        ")": "\)",
        "&gt;": "\&gt;",
        "#": "\#",
        "+": "\+",
        "-": "\-",
        ".": "\.",
        "!": "\!",
        "$": "\$",
    }
    text = "".join([replacements.get(c, c) for c in text])


def h(text):
    text = text.replace('\\', r'\\')
    text = text.replace('`', r'\`')
    text = text.replace('*', r'\*')
    text = text.replace('_', r'\_')
    text = text.replace('{', r'\{')
    text = text.replace('}', r'\}')
    text = text.replace('[', r'\[')
    text = text.replace(']', r'\]')
    text = text.replace('(', r'\(')
    text = text.replace(')', r'\)')
    text = text.replace('&gt;', r'\&gt;')
    text = text.replace('#', r'\#')
    text = text.replace('+', r'\+')
    text = text.replace('-', r'\-')
    text = text.replace('.', r'\.')
    text = text.replace('!', r'\!')
    text = text.replace('$', r'\$')


def i(text):
    text = text.replace('\\', r'\\').replace('`', r'\`').replace('*', r'\*').replace('_', r'\_').replace('{', r'\{').replace('}', r'\}').replace('[', r'\[').replace(']', r'\]').replace('(', r'\(').replace(')', r'\)').replace('&gt;', r'\&gt;').replace('#', r'\#').replace('+', r'\+').replace('-', r'\-').replace('.', r'\.').replace('!', r'\!').replace('$', r'\$')
</code></pre>
<p>Here's the results for the same input string <code>abc&amp;def#ghi</code>:</p>
<ul>
<li>a) 100000 loops, best of 3: 6.72 μs per loop</li>
<li>b) <strong>100000 loops, best of 3: 2.64 μs per loop</strong></li>
<li>c) 100000 loops, best of 3: 11.9 μs per loop</li>
<li>d) 100000 loops, best of 3: 4.92 μs per loop</li>
<li>e) <strong>100000 loops, best of 3: 2.96 μs per loop</strong></li>
<li>f) 100000 loops, best of 3: 4.29 μs per loop</li>
<li>g) 100000 loops, best of 3: 4.68 μs per loop</li>
<li>h) 100000 loops, best of 3: 4.73 μs per loop</li>
<li>i) 100000 loops, best of 3: 4.24 μs per loop</li>
</ul>
<p>And with a longer input string (<code>## *Something* and [another] thing in a longer sentence with {more} things to replace$</code>):</p>
<ul>
<li>a) 100000 loops, best of 3: 7.59 μs per loop</li>
<li>b) 100000 loops, best of 3: 6.54 μs per loop</li>
<li>c) 100000 loops, best of 3: 16.9 μs per loop</li>
<li>d) 100000 loops, best of 3: 7.29 μs per loop</li>
<li>e) 100000 loops, best of 3: 12.2 μs per loop</li>
<li>f) <strong>100000 loops, best of 3: 5.38 μs per loop</strong></li>
<li>g) 10000 loops, best of 3: 21.7 μs per loop</li>
<li>h) <strong>100000 loops, best of 3: 5.7 μs per loop</strong></li>
<li>i) <strong>100000 loops, best of 3: 5.13 μs per loop</strong></li>
</ul>
<p>Adding a couple of variants:</p>
<pre><code>def ab(text):
    for ch in ['\\','`','*','_','{','}','[',']','(',')','&gt;','#','+','-','.','!','$','\'']:
        text = text.replace(ch,"\\"+ch)


def ba(text):
    chars = "\\`*_{}[]()&gt;#+-.!$"
    for c in chars:
        if c in text:
            text = text.replace(c, "\\" + c)
</code></pre>
<p>With the shorter input:</p>
<ul>
<li>ab) 100000 loops, best of 3: 7.05 μs per loop</li>
<li>ba) 100000 loops, best of 3: 2.4 μs per loop</li>
</ul>
<p>With the longer input:</p>
<ul>
<li>ab) 100000 loops, best of 3: 7.71 μs per loop</li>
<li>ba) 100000 loops, best of 3: 6.08 μs per loop</li>
</ul>
<p>So I'm going to use <code>ba</code> for readability and speed.</p>
<h1>Addendum</h1>
<p>Prompted by haccks in the comments, one difference between <code>ab</code> and <code>ba</code> is the <code>if c in text:</code> check. Let's test them against two more variants:</p>
<pre><code>def ab_with_check(text):
    for ch in ['\\','`','*','_','{','}','[',']','(',')','&gt;','#','+','-','.','!','$','\'']:
        if ch in text:
            text = text.replace(ch,"\\"+ch)

def ba_without_check(text):
    chars = "\\`*_{}[]()&gt;#+-.!$"
    for c in chars:
        text = text.replace(c, "\\" + c)
</code></pre>
<p>Times in μs per loop on Python 2.7.14 and 3.6.3, and on a different machine from the earlier set, so cannot be compared directly.</p>
<pre><code>╭────────────╥──────┬───────────────┬──────┬──────────────────╮
│ Py, input  ║  ab  │ ab_with_check │  ba  │ ba_without_check │
╞════════════╬══════╪═══════════════╪══════╪══════════════════╡
│ Py2, short ║ 8.81 │    4.22       │ 3.45 │    8.01          │
│ Py3, short ║ 5.54 │    1.34       │ 1.46 │    5.34          │
├────────────╫──────┼───────────────┼──────┼──────────────────┤
│ Py2, long  ║ 9.3  │    7.15       │ 6.85 │    8.55          │
│ Py3, long  ║ 7.43 │    4.38       │ 4.41 │    7.02          │
└────────────╨──────┴───────────────┴──────┴──────────────────┘
</code></pre>
<p>We can conclude that:</p>
<ul>
<li><p>Those with the check are up to 4x faster than those without the check</p></li>
<li><p><code>ab_with_check</code> is slightly in the lead on Python 3, but <code>ba</code> (with check) has a greater lead on Python 2</p></li>
<li><p>However, the biggest lesson here is <strong>Python 3 is up to 3x faster than Python 2</strong>! There's not a huge difference between the slowest on Python 3 and fastest on Python 2!</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; string="abc&amp;def#ghi"
&gt;&gt;&gt; for ch in ['&amp;','#']:
...   if ch in string:
...      string=string.replace(ch,"\\"+ch)
...
&gt;&gt;&gt; print string
abc\&amp;def\#ghi
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simply chain the <code>replace</code> functions like this</p>
<pre><code>strs = "abc&amp;def#ghi"
print strs.replace('&amp;', '\&amp;').replace('#', '\#')
# abc\&amp;def\#ghi
</code></pre>
<p>If the replacements are going to be more in number, you can do this in this generic way</p>
<pre><code>strs, replacements = "abc&amp;def#ghi", {"&amp;": "\&amp;", "#": "\#"}
print "".join([replacements.get(c, c) for c in strs])
# abc\&amp;def\#ghi
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Are you always going to prepend a backslash? If so, try</p>
<pre><code>import re
rx = re.compile('([&amp;#])')
#                  ^^ fill in the characters here.
strs = rx.sub('\\\\\\1', strs)
</code></pre>
<p>It may not be the most efficient method but I think it is the easiest.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a python3 method using <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="noreferrer"><code>str.translate</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="noreferrer"><code>str.maketrans</code></a>:</p>
<pre><code>s = "abc&amp;def#ghi"
print(s.translate(str.maketrans({'&amp;': '\&amp;', '#': '\#'})))
</code></pre>
<p>The printed string is <code>abc\&amp;def\#ghi</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You may consider writing a generic escape function:</p>
<pre><code>def mk_esc(esc_chars):
    return lambda s: ''.join(['\\' + c if c in esc_chars else c for c in s])

&gt;&gt;&gt; esc = mk_esc('&amp;#')
&gt;&gt;&gt; print esc('Learn &amp; be #1')
Learn \&amp; be \#1
</code></pre>
<p>This way you can make your function configurable with a list of character that should be escaped.</p>
</div>
<div class="post-text" itemprop="text">
<p>FYI, this is of little or no use to the OP but it may be of use to other readers (please do not downvote, I'm aware of this).</p>
<p>As a somewhat ridiculous but interesting exercise, wanted to see if I could use python functional programming to replace multiple chars. I'm pretty sure this does NOT beat just calling replace() twice. And if performance was an issue, you could easily beat this in rust, C, julia, perl, java, javascript and maybe even awk. It uses an external 'helpers' package called <a href="https://toolz.readthedocs.org/en/latest/" rel="nofollow">pytoolz</a>, accelerated via cython (<a href="https://pypi.python.org/pypi/cytoolz" rel="nofollow">cytoolz, it's a pypi package</a>).</p>
<pre><code>from cytoolz.functoolz import compose
from cytoolz.itertoolz import chain,sliding_window
from itertools import starmap,imap,ifilter
from operator import itemgetter,contains
text='&amp;hello#hi&amp;yo&amp;'
char_index_iter=compose(partial(imap, itemgetter(0)), partial(ifilter, compose(partial(contains, '#&amp;'), itemgetter(1))), enumerate)
print '\\'.join(imap(text.__getitem__, starmap(slice, sliding_window(2, chain((0,), char_index_iter(text), (len(text),))))))
</code></pre>
<p>I'm not even going to explain this because no one would bother using this to accomplish multiple replace. Nevertheless, I felt somewhat accomplished in doing this and thought it might inspire other readers or win a code obfuscation contest.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using reduce which is available in python2.7 and python3.* you can easily replace mutiple substrings in a clean and pythonic way.</p>
<pre><code># Lets define a helper method to make it easy to use
def replacer(text, replacements):
    return reduce(
        lambda text, ptuple: text.replace(ptuple[0], ptuple[1]), 
        replacements, text
    )

if __name__ == '__main__':
    uncleaned_str = "abc&amp;def#ghi"
    cleaned_str = replacer(uncleaned_str, [("&amp;","\&amp;"),("#","\#")])
    print(cleaned_str) # "abc\&amp;def\#ghi"
</code></pre>
<p>In python2.7 you don't have to import reduce but in python3.* you have to import it from the functools module.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; a = '&amp;#'
&gt;&gt;&gt; print a.replace('&amp;', r'\&amp;')
\&amp;#
&gt;&gt;&gt; print a.replace('#', r'\#')
&amp;\#
&gt;&gt;&gt; 
</code></pre>
<p>You want to use a 'raw' string (denoted by the 'r' prefixing the replacement string), since raw strings to not treat the backslash specially. </p>
</div>
<div class="post-text" itemprop="text">
<p>Late to the party, but I lost a lot of time with this issue until I found my answer.</p>
<p><strong>Short and sweet, <code>translate</code> is superior to <code>replace</code></strong>. If you're more interested in funcionality over time optimization, do not use <code>replace</code>. </p>
<p><em>Also use <code>translate</code> if you don't know if the set of characters to be replaced overlaps the set of characters used to replace.</em> </p>
<p>Case in point:</p>
<p>Using <code>replace</code> you would naively expect the snippet <code>"1234".replace("1", "2").replace("2", "3").replace("3", "4")</code> to return <code>"2344"</code>, but it will return in fact <code>"4444"</code>. </p>
<p>Translation seems to perform what OP originally desired. </p>
</div>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/3367809/efficiently-carry-out-multiple-string-replacements-in-python" title="efficiently carry out multiple string replacements in python">stackoverflow.com/questions/3367809/…</a> and <a href="http://stackoverflow.com/questions/3411006/fastest-implementation-to-do-multiple-string-substitutions-in-python" title="fastest implementation to do multiple string substitutions in python">stackoverflow.com/questions/3411006/…</a></span>
<span class="comment-copy">Why isn't this the excepted answer?</span>
<span class="comment-copy">Is <code>if c in text:</code> necessary in <code>ba</code>?</span>
<span class="comment-copy">@haccks It's not necessary, but it's 2-3x quicker with it.   Short string, with: <code>1.45 usec per loop</code>, and without: <code>5.3 usec per loop</code>,  Long string, with: <code>4.38 usec per loop</code> and without: <code>7.03 usec per loop</code>. (Note these aren't directly comparable with the results above, because it's a different machine etc.)</span>
<span class="comment-copy">@Hugo;  I think this difference in time is because of <code>replace</code> is called only when <code>c</code> is found in <code>text</code> in case of <code>ba</code> while it is called in every iteration in <code>ab</code>.</span>
<span class="comment-copy">@haccks Thanks, I've updated my answer with further timings: adding the check is better for both, but the biggest lesson is Python 3 is up to 3x faster!</span>
<span class="comment-copy">Why was a double backslash needed? Why doesn't just "\" work?</span>
<span class="comment-copy">The double backslash escapes the backslash, otherwise python would interpret "\" as a literal quotation character within a still-open string.</span>
<span class="comment-copy">Why do you need to <code>string=string.replace(ch,"\\"+ch)</code>? Isn't just <code>string.replace(ch,"\\"+ch)</code> enough?</span>
<span class="comment-copy">@MattSom replace() doesn't modify the original string, but returns a copy. So you need the assignment for the code to have any effect.</span>
<span class="comment-copy">why are you using <code>string</code> as a variable name?</span>
<span class="comment-copy">@SeanGeoffreyPietz Are you talking about the <code>replace</code> one?</span>
<span class="comment-copy">not suitable for word, like replacing i' with ì</span>
<span class="comment-copy">Thank you!!!! great answer!</span>
<span class="comment-copy">aarrgghh try <code>r'\\\1'</code></span>
<span class="comment-copy">This is a good answer, but in practice doing one <code>.translate()</code> appears to be slower than three chained <code>.replace()</code> (using CPython 3.6.4).</span>
<span class="comment-copy">@Changaco Thanks for timing it 👍 In practice I would use <code>replace()</code> myself, but I added this answer for the sake of completeness.</span>
<span class="comment-copy">For large strings and many replacements this should be faster, though some testing would be nice...</span>
<span class="comment-copy">Well, its not on my  machine (same for 2 and 17 replacements).</span>
<span class="comment-copy">"functional programming" doesn't mean "using as many functions as possible", you know.</span>
<span class="comment-copy">This is a perfectly good, pure functional multi-char replacer: <a href="https://gist.github.com/anonymous/4577424f586173fc6b91a215ea2ce89e" rel="nofollow noreferrer">gist.github.com/anonymous/4577424f586173fc6b91a215ea2ce89e</a>  No allocations, no mutations, no side effects. Readable, too.</span>
