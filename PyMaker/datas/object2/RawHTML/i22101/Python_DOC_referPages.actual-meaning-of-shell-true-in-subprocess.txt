<div class="post-text" itemprop="text">
<p>I am calling different processes with the <code>subprocess</code> module. However, I have a question.</p>
<p>In the following codes:</p>
<pre><code>callProcess = subprocess.Popen(['ls', '-l'], shell=True)
</code></pre>
<p>and </p>
<pre><code>callProcess = subprocess.Popen(['ls', '-l']) # without shell
</code></pre>
<p>Both work. After reading the docs, I came to know that <code>shell=True</code> means executing the code through the shell. So that means in absence, the process is directly started. </p>
<p>So what should I prefer for my case - I need to run a process and get its output. What benefit do I have from calling it from within the shell or outside of it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The benefit of not calling via the shell is that you are not invoking a 'mystery program.'  On POSIX, the environment variable <code>SHELL</code> controls which binary is invoked as the "shell."  On Windows, there is no bourne shell descendent, only cmd.exe.</p>
<p>So invoking the shell invokes a program of the user's choosing and is platform-dependent.  Generally speaking, avoid invocations via the shell.</p>
<p>Invoking via the shell does allow you to expand environment variables and file globs according to the shell's usual mechanism.  On POSIX systems, the shell expands file globs to a list of files.  On Windows, a file glob (e.g., "*.*") is not expanded by the shell, anyway (but environment variables on a command line <em>are</em> expanded by cmd.exe).</p>
<p>If you think you want environment variable expansions and file globs, research the <code>ILS</code> attacks of 1992-ish on network services which performed subprogram invocations via the shell.  Examples include the various <code>sendmail</code> backdoors involving <code>ILS</code>.</p>
<p>In summary, use <code>shell=False</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; subprocess.call('echo $HOME')
Traceback (most recent call last):
...
OSError: [Errno 2] No such file or directory
&gt;&gt;&gt;
&gt;&gt;&gt; subprocess.call('echo $HOME', shell=True)
/user/khong
0
</code></pre>
<blockquote>
<p>Setting the shell argument to a true value causes subprocess to spawn an intermediate shell process, and tell it to run the command. In other words, using an intermediate shell means that variables, glob patterns, and other special shell features in the command string are processed before the command is run. Here, in the example, $HOME was processed before the echo command. Actually, this is the case of command with shell expansion while the command ls -l considered as a simple command.</p>
</blockquote>
<p>source: <a href="http://www.bogotobogo.com/python/python_subprocess_module.php" rel="noreferrer">Subprocess Module</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Executing programs through the shell means that all user input passed to the program is interpreted according to the syntax and semantic rules of the invoked shell.  At best, this only causes inconvenience to the user, because the user has to obey these rules.  For instance, paths containing special shell characters like quotation marks or blanks must be escaped.  At worst, it causes security leaks, because the user can execute arbitrary programs.</p>
<p><code>shell=True</code> is sometimes convenient to make use of specific shell features like word splitting or parameter expansion.  However, if such a feature is required, make use of other modules are given to you (e.g. <code>os.path.expandvars()</code> for parameter expansion or <code>shlex</code> for word splitting).  This means more work, but avoids other problems.</p>
<p>In short: Avoid <code>shell=True</code> by all means.</p>
</div>
<div class="post-text" itemprop="text">
<p>An example where things could go wrong with Shell=True is shown here</p>
<pre><code>&gt;&gt;&gt; from subprocess import call
&gt;&gt;&gt; filename = input("What file would you like to display?\n")
What file would you like to display?
non_existent; rm -rf / # THIS WILL DELETE EVERYTHING IN ROOT PARTITION!!!
&gt;&gt;&gt; call("cat " + filename, shell=True) # Uh-oh. This will end badly...
</code></pre>
<p>Check the doc here: <a href="https://docs.python.org/2/library/subprocess.html#frequently-used-arguments">subprocess.call()</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The other answers here adequately explain the security caveats which are also mentioned in the <code>subprocess</code> documentation.  But in addition to that, the overhead of starting a shell to start the program you want to run is often unnecessary and definitely silly for situations where you don't actually use any of the shell's functionality.  Moreover, the additional hidden complexity should scare you, <em>especially</em> if you are not very familiar with the shell or the services it provides.</p>
<p>Wildcard expansion, variable interpolation, and redirection are all simple to replace with native Python constructs.  A complex shell pipeline where parts or all cannot be reasonably rewritten in Python (specialized external tools, perhaps closed source?) would be the one situation where perhaps you could consider using the shell.  You should still feel bad about it.</p>
<p>In the trivial case, simply replace</p>
<pre><code>subprocess.Popen("command -with -options 'like this' and\\ an\\ argument", shell=True)
</code></pre>
<p>with</p>
<pre><code>subprocess.Popen(['command', '-with','-options', 'like this', 'and an argument'])
</code></pre>
<p>Notice how the first argument is a list of strings to pass to <code>execvp()</code>, and how quoting strings and backslash-escaping shell metacharacters is generally not necessary (or useful, or correct).</p>
<p>As an aside, you very often want to avoid <code>Popen</code> if one of the simpler wrappers in the <code>subprocess</code> package does what you want. If you have a recent enough Python, you should probably use <a href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="nofollow noreferrer"><code>subprocess.run</code></a>.</p>
<ul>
<li>With <code>check=True</code> it will fail if the command you ran failed.</li>
<li>With <code>stdout=subprocess.PIPE</code> it will capture the command's output.</li>
<li>Somewhat obscurely, with <code>universal_newlines=True</code> it will decode output into a proper Unicode string (it's just <code>bytes</code> in the system encoding otherwise, on Python 3).</li>
</ul>
<p>If not, for many tasks, you want <a href="https://docs.python.org/2/library/subprocess.html#subprocess.check_output" rel="nofollow noreferrer"><code>check_output</code></a> to obtain the output from a command, whilst checking that it succeeded, or <a href="https://docs.python.org/2/library/subprocess.html#subprocess.check_call" rel="nofollow noreferrer"><code>check_call</code></a> if there is no output to collect.</p>
<p>I'll close with a quote from David Korn: "It's easier to write a portable shell than a portable shell script." Even <code>subprocess.run('echo "$HOME"', shell=True)</code> is not portable to Windows.</p>
</div>
<span class="comment-copy">the first command is incorrect: <code>-l</code> is passed to <code>/bin/sh</code> (the shell) instead of <code>ls</code> program <a href="http://docs.python.org/2/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">on Unix if <code>shell=True</code></a>.  String argument should be used with <code>shell=True</code> in most cases instead of a list.</span>
<span class="comment-copy">re "the process is directly started": Wut?</span>
<span class="comment-copy">The statement "Both work." about those 2 calls is incorrect and misleading. The calls work differently. Just switching from <code>shell=True</code> to <code>False</code> and vice versa is an error. From <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="nofollow noreferrer">docs</a>: "On POSIX with shell=True, (...) If args is a sequence, the first item specifies the command string, and any additional items will be treated as additional arguments to the shell itself.". On Windows there's <a href="https://docs.python.org/3/library/subprocess.html#converting-argument-sequence" rel="nofollow noreferrer">automatic conversion</a>, which might be undesired.</span>
<span class="comment-copy">Thanks for the answer. Though I am really not at that stage where I should worry about exploits, but I understand what you are getting at.</span>
<span class="comment-copy">If you're careless in the beginning, no amount of worry will help you catch up later.  ;)</span>
<span class="comment-copy">What if you want to limit max memory of the subprocess? <a href="http://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess" title="actual meaning of shell true in subprocess">stackoverflow.com/questions/3172470/â€¦</a></span>
<span class="comment-copy">the statement about <code>$SHELL</code> is not correct. To quote subprocess.html: "On Unix with <code>shell=True</code>, the shell defaults to <code>/bin/sh</code>." (not <code>$SHELL</code>)</span>
<span class="comment-copy">@user2428107: Yes, if you use backtick invocation on Perl, you're using shell invocation and opening up the same issues. Use 3+ arg <code>open</code> if you want secure ways to invoke a program and capture the output.</span>
<span class="comment-copy">Don't know why this is not the selected answer. By far the one that actually match the question</span>
<span class="comment-copy">This is the clearest statement of <code>shell=True</code> I've read.</span>
<span class="comment-copy">agree. this is a good example for me to understand what shell=True means.</span>
<span class="comment-copy"><i>Setting the shell argument to a true value causes subprocess to spawn an intermediate shell process, and tell it to run the command</i>  Oh god this tells it all. Why this answer is not accepted??? why?</span>
<span class="comment-copy">I think the issue is the first argument to call is a list, not a string, but that gives the error if shell is False. Changing the command to a list will make this work</span>
<span class="comment-copy">The link is very useful. As the link stated: <i>Executing shell commands that incorporate unsanitized input from an untrusted source makes a program vulnerable to shell injection, a serious security flaw which can result in arbitrary command execution. For this reason, the use of shell=True is strongly discouraged in cases where the command string is constructed from external input.</i></span>
<span class="comment-copy">I thought the quote was from Larry Wall but Google tells me otherwise.</span>
<span class="comment-copy">That's high talk - but no technical suggestion for replacement:  Here I am, on OS-X, trying to acquire the pid of a Mac App I launched via 'open':     process = subprocess.Popen('/usr/bin/pgrep -n ' + app_name, shell=False, stdout=subprocess.PIPE,  stderr=subprocess.PIPE) app_pid, err = process.communicate() --- but it doesn't work unless I'll use shell=True. Now what?</span>
<span class="comment-copy">There are a ton of questions about <i>how</i> to avoid <code>shell=True</code>, many with excellent answers. You happened to pick the one which is about <i>why</i> instead.</span>
<span class="comment-copy">@MottiShneor Thanks for the feedback; added  simple example</span>
<span class="comment-copy">Perhaps see also <a href="/a/51950538/874188">my answer to a general question about <code>subprocess</code></a></span>
