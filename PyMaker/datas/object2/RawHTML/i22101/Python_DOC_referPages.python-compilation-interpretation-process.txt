<div class="post-text" itemprop="text">
<p>I'm trying to understand the python compiler/interpreter process more clearly. Unfortunately, I have not taken a class in interpreters nor have I read much about them.</p>
<p>Basically, what I understand right now is that Python code from .py files is first compiled into python bytecode (which i assume are the .pyc files i see occasionally?). Next, the bytecode is compiled into machine code, a language the processor actually understands.
Pretty much, I've read this thread <a href="https://stackoverflow.com/questions/888100/why-python-compile-the-source-to-bytecode-before-interpreting">Why python compile the source to bytecode before interpreting?</a></p>
<p>Could somebody give me a good explanation of the whole process keeping in mind that my knowledge of compilers/interpreters is almost non-existent? Or, if that's not possible, maybe give me some resources that give quick overviews of compilers/interpreters?</p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>The bytecode is not actually interpreted to machine code, unless you are using some exotic implementation such as pypy.</p>
<p>Other than that, you have the description correct. The bytecode is loaded into the Python runtime and interpreted by a virtual machine, which is a piece of code that reads each instruction in the bytecode and executes whatever operation is indicated. You can see this bytecode with the <code>dis</code> module, as follows:</p>
<pre><code>&gt;&gt;&gt; def fib(n): return n if n &lt; 2 else fib(n - 2) + fib(n - 1)
... 
&gt;&gt;&gt; fib(10)
55
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(fib)
  1           0 LOAD_FAST                0 (n)
              3 LOAD_CONST               1 (2)
              6 COMPARE_OP               0 (&lt;)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
             13 LOAD_FAST                0 (n)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             
             18 LOAD_GLOBAL              0 (fib)
             21 LOAD_FAST                0 (n)
             24 LOAD_CONST               1 (2)
             27 BINARY_SUBTRACT     
             28 CALL_FUNCTION            1
             31 LOAD_GLOBAL              0 (fib)
             34 LOAD_FAST                0 (n)
             37 LOAD_CONST               2 (1)
             40 BINARY_SUBTRACT     
             41 CALL_FUNCTION            1
             44 BINARY_ADD          
             45 RETURN_VALUE        
&gt;&gt;&gt; 
</code></pre>
<h2>Detailed explanation</h2>
<p>It is quite important to understand that the above code is never executed by your CPU; nor is it ever converted into something that is (at least, not on the official C implementation of Python). The CPU executes the virtual machine code, which performs the work indicated by the bytecode instructions. When the interpreter wants to execute the <code>fib</code> function, it reads the instructions one at a time, and does what they tell it to do. It looks at the first instruction, <code>LOAD_FAST 0</code>, and thus grabs parameter 0 (the <code>n</code> passed to <code>fib</code>) from wherever parameters are held and pushes it onto the interpreter's stack (Python's interpreter is a stack machine). On reading the next instruction, <code>LOAD_CONST 1</code>, it grabs constant number 1 from a collection of constants owned by the function, which happens to be the number 2 in this case, and pushes that onto the stack. You can actually see these constants:</p>
<pre><code>&gt;&gt;&gt; fib.func_code.co_consts
(None, 2, 1)
</code></pre>
<p>The next instruction, <code>COMPARE_OP 0</code>, tells the interpreter to pop the two topmost stack elements and perform an inequality comparison between them, pushing the Boolean result back onto the stack. The fourth instruction determines, based on the Boolean value, whether to jump forward five instructions or continue on with the next instruction. All that verbiage explains the <code>if n &lt; 2</code> part of the conditional expression in <code>fib</code>. It will be a highly instructive exercise for you to tease out the meaning and behaviour of the rest of the <code>fib</code> bytecode. The only one, I'm not sure about is <code>POP_TOP</code>; I'm guessing <code>JUMP_IF_FALSE</code> is defined to leave its Boolean argument on the stack rather than popping it, so it has to be popped explicitly.</p>
<p>Even more instructive is to inspect the raw bytecode for <code>fib</code> thus:</p>
<pre><code>&gt;&gt;&gt; code = fib.func_code.co_code
&gt;&gt;&gt; code
'|\x00\x00d\x01\x00j\x00\x00o\x05\x00\x01|\x00\x00S\x01t\x00\x00|\x00\x00d\x01\x00\x18\x83\x01\x00t\x00\x00|\x00\x00d\x02\x00\x18\x83\x01\x00\x17S'
&gt;&gt;&gt; import opcode
&gt;&gt;&gt; op = code[0]
&gt;&gt;&gt; op
'|'
&gt;&gt;&gt; op = ord(op)
&gt;&gt;&gt; op
124
&gt;&gt;&gt; opcode.opname[op]
'LOAD_FAST'
&gt;&gt;&gt; 
</code></pre>
<p>Thus you can see that the first byte of the bytecode is the <code>LOAD_FAST</code> instruction. The next pair of bytes, <code>'\x00\x00'</code> (the number 0 in 16 bits) is the argument to <code>LOAD_FAST</code>, and tells the bytecode interpreter to load parameter 0 onto the stack.</p>
</div>
<div class="post-text" itemprop="text">
<p>To complete the great <a href="https://stackoverflow.com/a/3299724/2291710">Marcelo Cantos's answer</a>, here is just a small column-by-column summary to explain the output of disassembled bytecode.</p>
<p>For example, given this function:</p>
<pre><code>def f(num):
    if num == 42:
        return True
    return False
</code></pre>
<p>This may be disassembled into (Python 3.6):</p>
<pre class="lang-erlang prettyprint-override"><code>(1)|(2)|(3)|(4)|          (5)         |(6)|  (7)
---|---|---|---|----------------------|---|-------
  2|   |   |  0|LOAD_FAST             |  0|(num)
   |--&gt;|   |  2|LOAD_CONST            |  1|(42)
   |   |   |  4|COMPARE_OP            |  2|(==)
   |   |   |  6|POP_JUMP_IF_FALSE     | 12|
   |   |   |   |                      |   |
  3|   |   |  8|LOAD_CONST            |  2|(True)
   |   |   | 10|RETURN_VALUE          |   |
   |   |   |   |                      |   |
  4|   |&gt;&gt; | 12|LOAD_CONST            |  3|(False)
   |   |   | 14|RETURN_VALUE          |   |
</code></pre>
<p>Each column has a specific purpose:</p>
<ol>
<li>The corresponding <strong>line number</strong> in the source code</li>
<li>Optionally indicates the <strong>current instruction</strong> executed (when the bytecode comes from a <a href="https://docs.python.org/3/library/inspect.html#the-interpreter-stack" rel="nofollow noreferrer">frame object</a> for example)</li>
<li>A label which denotes a possible <strong><code>JUMP</code> from an earlier instruction</strong> to this one</li>
<li>The <strong>address</strong> in the bytecode which corresponds to the byte index (those are multiples of 2 because Python 3.6 use 2 bytes for each instruction, while it could vary in previous versions)</li>
<li>The instruction name (also called <strong>opname</strong>), each one is briefly explained in <a href="https://docs.python.org/3.6/library/dis.html#python-bytecode-instructions" rel="nofollow noreferrer">the <code>dis</code> module</a> and their implementation can be found in <a href="https://github.com/python/cpython/blob/master/Python/ceval.c" rel="nofollow noreferrer"><code>ceval.c</code></a> (the core loop of CPython)</li>
<li>The <strong>argument</strong> (if any) of the instruction which is used internally by Python to fetch some constants or variables, manage the stack, jump to a specific instruction, etc.</li>
<li>The <strong>human-friendly interpretation</strong> of the instruction argument</li>
</ol>
</div>
<span class="comment-copy">You do not "interpret into machine code" — that's what compilers do. Python interpreter just executes the bytecode. (And it's .pyc for bytecode.)</span>
<span class="comment-copy">On a side note, you might find helpful to know that the last modification time of the original .py file is encoded in the .pyc file. This allows Python to figure out if a new .pyc file needs to be created or not. The purpose of .pyc files is, of course, to avoid parsing the whole script each time the script is invoked. A Python program will not run faster if the .pyc is used. Only the loading time changes.</span>
<span class="comment-copy">The interpreter/VM is in C. It is (to oversimplify somewhat) a loop that uses the current byte to choose one of many cases in a huge switch statement. Somewhere in the middle of the switch, there is a <code>case LOAD_FAST:</code> followed by code that reads the next two bytes, looks up the specified parameter in some "parameters" collection, and pushes it onto a stack object. To interact with the outside world, Python allows calls to extension modules, which act like Python code and objects, but are really compiled code and can thus talk to graphics cards, etc., directly, on behalf of your script(s).</span>
<span class="comment-copy">To be a bit more explicit about your last question: there is no Python opcode for "talk to the graphics card". There is an opcode for "call this function in this module", and if the module is a graphics programming extension module, the interpreter will call the library's entry point for the requested function, passing it some parameters. The C library (assuming it's C) teases out the parameters, converting them from Python objects into C values and structs, and forwards the call onto a bona-fide graphics library, which then plonks a colorful triangle on your screen, or whatever.</span>
<span class="comment-copy">@Moondra CPython never translates bytecode into switch cases. The C code I linked to is the code that gets compiled into machine code. That machine code is a CPU-ready representation of the C code. You should think of the C code and the machine code as being different representations of exactly the same thing. The C is a human-readable form, while the machine code is a machine-readable form. A key point to understand is that the C program (in its compiled machine code form) is the only thing the CPU sees as code.</span>
<span class="comment-copy">… The Python bytecode, in contrast, is seen by the CPU as just data. The C code <i>interprets</i> that data as code to be executed, hence the name <i>interpreter</i>.</span>
<span class="comment-copy">It might help to think of the Python bytecode as a cooking recipe, and the C code as a cooking robot that reads and follows recipes in order to cook food. The robot itself has code inside it, which could well be C code, and the recipes are just data read in through the robot's eyes in order to know how to execute a particular cooking procedure. At one level, the recipe is code — a set of instructions to follow. At another level, it's just data to be fed to the robot's brain. hth</span>
<span class="comment-copy">How to read the  implementation speed from it? There's no timing.</span>
<span class="comment-copy">@YumiTada What do you mean by "implementation speed"? This is just compiled bytecode and not (yet) executed, so timing is irrelevant here.</span>
<span class="comment-copy">very good tutorial of your answer</span>
