<div class="post-text" itemprop="text">
<p>Sometimes it makes sense to cluster related data together.  I tend to do so with a dict, e.g.,</p>
<pre><code>self.group = dict(a=1, b=2, c=3)
print self.group['a']
</code></pre>
<p>One of my colleagues prefers to create a class</p>
<pre><code>class groupClass(object):
    def __init__(a, b, c):
        self.a = a
        self.b = b
        self.c = c
self.group = groupClass(1, 2, 3)
print self.group.a
</code></pre>
<p>Note that we are not defining any class methods.</p>
<p>I like to use a dict because I like to minimize the number of lines of code.  My colleague thinks the code is more readable if you use a class, and it makes it easier to add methods to the class in the future.</p>
<p>Which do you prefer and why?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're really never defining any class methods, a dict or a <a href="http://docs.python.org/library/collections.html#collections.namedtuple" rel="noreferrer">namedtuple</a> make far more sense, in my opinion.  Simple+builtin is good! To each his own, though.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Background</strong></p>
<p>A summary of alternative attribute-based, data containers was presented by R. Hettinger at the SF Python's 2017 Holiday meetup.  See his <a href="https://twitter.com/raymondh/status/939232481047277569" rel="nofollow noreferrer">tweet</a> and his <a href="https://www.dropbox.com/s/cxxz4d2hwj4hm4d/HettingerHolidaySF2017.pdf" rel="nofollow noreferrer">slide deck</a>.  He also gave a <a href="https://www.youtube.com/watch?v=T-TwcmT6Rcw" rel="nofollow noreferrer">talk</a> at PyCon 2018 on dataclasses.</p>
<p>Other data container types are mentioned in this <a href="https://github.com/topper-123/Articles/blob/master/New-interesting-data-types-in-Python3.rst" rel="nofollow noreferrer">article</a> and predominantly in Python 3 documentation (see links below).</p>
<p>Here is a discussion on the <a href="https://mail.python.org/pipermail/python-ideas/2018-September/053158.html" rel="nofollow noreferrer">python-ideas</a> mailing list on adding <code>recordclass</code> to the standard library.</p>
<p><strong>Options</strong></p>
<p><em>Alternatives in the Standard Library</em></p>
<ul>
<li><a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer"><code>collections.namedtuple</code></a>: tuple with attributes (see seminal <a href="https://code.activestate.com/recipes/500261-named-tuples/" rel="nofollow noreferrer">recipe</a>)</li>
<li><a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><code>typing.NamedTuple</code></a>: sub-classable tuple (see this <a href="https://stackoverflow.com/a/50767206/4531270">post</a> comparing it with <code>namedtuple</code>)</li>
<li><a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="nofollow noreferrer"><code>types.SimpleNamespace</code></a>: simple class w/optional class declaration</li>
<li><a href="https://docs.python.org/3/library/types.html#types.MappingProxyType" rel="nofollow noreferrer"><code>types.MappingProxy</code></a>: read-only dict</li>
<li><a href="https://docs.python.org/3/library/enum.html" rel="nofollow noreferrer"><code>enum.Enum</code></a>: constrained collection of related constants (does behave like a class)</li>
<li><a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer"><code>dataclasses.dataclass</code></a>: mutable namedtuple with default/boilerplate-less classes</li>
</ul>
<p><em>External options</em></p>
<ul>
<li><a href="https://code.activestate.com/recipes/576555-records/?in=user-2591466" rel="nofollow noreferrer">records</a>: mutable namedtuple (see also <a href="https://pypi.org/project/recordclass/" rel="nofollow noreferrer">recordclass</a>)</li>
<li><a href="https://changelog.com/posts/bunch-lets-use-python-dict-like-object" rel="nofollow noreferrer">bunches</a>: add attribute access to dicts (inspiration for <code>SimpleNamedspace</code>)</li>
<li><a href="https://github.com/cdgriffith/Box/tree/development" rel="nofollow noreferrer">box</a>: wrap dicts with <a href="https://code.activestate.com/recipes/576586-dot-style-nested-lookups-over-dictionary-based-dat/" rel="nofollow noreferrer">dot-style lookup</a> functionality</li>
<li><a href="https://pypi.org/project/attrdict/" rel="nofollow noreferrer">attrdict</a>: access elements from a mapping as keys or attributes</li>
<li><a href="https://pypi.org/project/fields/" rel="nofollow noreferrer">fields</a>: remove boilerplate from container classes.</li>
<li><a href="https://pypi.org/project/namedlist/" rel="nofollow noreferrer">namedlist</a>: mutable, tuple-like containers with defaults by E. Smith</li>
</ul>
<p><strong>Which one?</strong></p>
<p>Deciding which option to use depends on the situation (see Examples below).  Usually an old fashioned mutable dictionary or immutable namedtuple is good enough.  Data classes are the newest addition (Python 3.7a) offering both mutability and <a href="https://www.python.org/dev/peps/pep-0557/#id39" rel="nofollow noreferrer">optional immutability</a>, with promise of reduced boilerplate as inspired by the <a href="https://github.com/python-attrs/attrs" rel="nofollow noreferrer">attrs</a> project.</p>
<hr/>
<p><strong>Examples</strong></p>
<pre><code>import typing as typ
import collections as ct
import dataclasses as dc


# Problem: You want a simple container to hold personal data.
# Solution: Try a NamedTuple.
&gt;&gt;&gt; class Person(typ.NamedTuple):
...     name: str
...     age: int
&gt;&gt;&gt; a = Person("bob", 30)
&gt;&gt;&gt; a
Person(name='bob', age=30)
</code></pre>
<p></p>
<pre><code># Problem: You need to change age each year, but namedtuples are immutable. 
# Solution: Use assignable attributes of a traditional class.
&gt;&gt;&gt; class Person:
...     def __init__(self, name, age):
...         self.name = name
...         self.age = age
&gt;&gt;&gt; b = Person("bob", 30)
&gt;&gt;&gt; b.age = 31
&gt;&gt;&gt; b
&lt;__main__.Person at 0x4e27128&gt;
</code></pre>
<p> </p>
<pre><code># Problem: You lost the pretty repr and want to add comparison features.
# Solution: Use included repr and eq features from the new dataclasses.
&gt;&gt;&gt; @dc.dataclass(eq=True)
... class Person:
...     name: str
...     age: int
&gt;&gt;&gt; c = Person("bob", 30)
&gt;&gt;&gt; c.age = 31
&gt;&gt;&gt; c
Person(name='bob', age=31)
&gt;&gt;&gt; d = Person("dan", 31)
&gt;&gt;&gt; c != d
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prefer to follow <a href="http://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it" rel="noreferrer">YAGNI</a> and use a dict.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a new proposal that aims to implement exactly what you are looking for, called <a href="https://www.python.org/dev/peps/pep-0557/" rel="noreferrer">data classes</a>. Take a look at it. </p>
<p>Using a class over a dict is a matter of preference. Personally I prefer using a dict when the keys are not known a priori. (As a mapping container). </p>
<p>Using a class to hold data means you can provide documentation to the class attributes. </p>
<p>Personally, perhaps the biggest reason for me to use a class is to make use of the IDEs auto-complete feature! (technically a lame reason, but very useful in practise)</p>
</div>
<div class="post-text" itemprop="text">
<p>Your way is better. Don't try to anticipate the future too much as you are not likely to succeed.</p>
<p>However, <a href="http://docs.python.org/tutorial/classes.html#odds-and-ends" rel="noreferrer">it may make sense sometimes to use something like a C struct</a>, for example if you want to identify different types rather than use dicts for everything.</p>
</div>
<div class="post-text" itemprop="text">
<p>By the way, I think Python 3.7 implemented @<a href="https://www.python.org/dev/peps/pep-0557/" rel="nofollow noreferrer">dataclass</a> is the simplest and most efficient way to implement classes as data containers. </p>
<pre><code>@dataclass
class Data:
    a: list
    b: str    #default variables go after non default variables
    c: bool = False

def func():
    return A(a="hello")

print(func())
</code></pre>
<p>The output would be :<code>hello</code></p>
<p>It is too similar to Scala like case class and the easiest way to use a class as a container. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can combine advantages of dict and class together, using some wrapper class inherited from dict. You do not need to write boilerplate code, and at the same time can use dot notation.</p>
<pre><code>class ObjDict(dict):
    def __getattr__(self,attr):
        return self[attr]
    def __setattr__(self,attr,value):
        self[attr]=value

self.group = ObjDict(a=1, b=2, c=3)
print self.group.a
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I disagree that the code is more readable using a class with no methods. You usually expect functionality from a class, not only data.</p>
<p>So, I'd go for a dict until the need for functionality arises, and then the constructor of the class could receive a dict :-)</p>
</div>
<div class="post-text" itemprop="text">
<p>In a language which supports it, I would use a <code>struct</code>. A dictionary would be closest to a structure in Python, at least as far as I see it.</p>
<p>Not to mention, you could add a method to a dictionary anyway if you <em>really</em> wanted to ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>A dict is obviously appropriate for that situation. It was designed specifically for that use case. Unless you are actually going to use the class as a class, there's no use in reinventing the wheel and incurring the additional overhead / wasting the space of a class that acts as a bad dictionary (no dictionary features).</p>
</div>
<div class="post-text" itemprop="text">
<p>What about <a href="https://github.com/ramazanpolat/prodict" rel="nofollow noreferrer">Prodict</a>:</p>
<pre><code>group = Prodict(a=1, b=2, c=3)
group.d = 4
</code></pre>
<p>And if you want auto type conversion and auto code complete(intelli-sense):</p>
<pre><code>class Person(Prodict):
    name: str
    email: str
    rate: int

john = Person(name='John', email='john@appleseed.com')
john.rate = 7
john.age = 35  # dynamic
</code></pre>
</div>
<span class="comment-copy">minor nitpick: you would use <code>print self.group['a']</code></span>
<span class="comment-copy">@Jesse: No he's not a new programmer (and he's a good programmer), but he does more Java than Python so he likes to add a lot of code (getters, etc) that I think is unnecessary.  I also may not be representing his position well.</span>
<span class="comment-copy">your colleague should find <a href="http://dirtsimple.org/2004/12/python-is-not-java.html" rel="nofollow noreferrer">this</a> useful then.</span>
<span class="comment-copy">Related post <a href="https://stackoverflow.com/questions/29290359/existence-of-mutable-named-tuple-in-python" title="existence of mutable named tuple in python">stackoverflow.com/questions/29290359/â€¦</a></span>
<span class="comment-copy">namedtuple's are great; just remember they're immutable. And don't forget if you do need to add class methods later, you can always just inherit from the result of namedtuple. E.g. <code>class Point(namedtuple('Point', 'x y')): ...</code></span>
<span class="comment-copy">Great answers all around.  I picked this one because I like the suggestion to try a namedtuple.</span>
<span class="comment-copy">An example of how to use <code>namedtuple</code> with the OP code may be nice.</span>
<span class="comment-copy">In Python 3.7 there is the @dataclass decorator which solves some problems with namedtuples and other former alternatives.</span>
<span class="comment-copy">I agree, except that I really enjoy the convenience of attribute access (as in JavaScript), so I prefer to use an <a href="http://stackoverflow.com/questions/4984647/accessing-dict-keys-like-an-attribute-in-python">AttributeDict</a>.</span>
<span class="comment-copy">The proposal is now official in Python 3.7</span>
<span class="comment-copy">Does anyone know if there is a shim or something that allows usage of  "data classes" in Python 3.6?</span>
<span class="comment-copy">Just do pip install Dataclasses</span>
<span class="comment-copy">I don't know if "most efficient" is true as they have a fairly large memory footprint.  They are arguablly "more convenient" however.</span>
