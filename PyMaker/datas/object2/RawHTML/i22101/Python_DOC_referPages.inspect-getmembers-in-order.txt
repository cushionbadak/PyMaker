<div class="post-text" itemprop="text">
<pre><code>inspect.getmembers(object[, predicate])
</code></pre>
<blockquote>
<p>Return all the members of an object in a list of (name, value) pairs sorted by name.</p>
</blockquote>
<p>I want to use this method, but I don't want the members to be sorted. I want them returned in the same order they were defined. Is there an alternative to this method?</p>
<hr/>
<p><strong>Use case:</strong></p>
<p>Creating a form like so:</p>
<pre><code>class RegisterForm(Form):
    username = Field(model_field='username', filters=validators.minlength(3))
    password1 = Field(model_field='password', widget=widgets.PasswordInput)
    password2 = Field(widget=widgets.PasswordInput)
    first_name = Field(model_field='first_name')
    last_name = Field(model_field='last_name')
    address = SubForm(form=AddressForm, model_field='address')
</code></pre>
<p>I want the fields to be rendered in the same order they are defined.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can dig around to find the line number for methods, not sure about other members:</p>
<pre><code>import inspect

class A:
    def one(self):
        pass

    def two(self):
        pass

    def three(self):
        pass

    def four(self):
        pass

def linenumber_of_member(m):
    try:
        return m[1].im_func.func_code.co_firstlineno
    except AttributeError:
        return -1

a = A()
l = inspect.getmembers(a)
print l
l.sort(key=linenumber_of_member)
print l
</code></pre>
<p>prints:</p>
<pre><code>[('__doc__', None), ('__module__', '__main__'), ('four', &lt;bound method A.four of &lt;__main__.A instance at 0x0179F738&gt;&gt;), ('one', &lt;bound method A.one of &lt;__main__.A instance at 0x0179F738&gt;&gt;), ('three', &lt;bound method A.three of &lt;__main__.A instance at 0x0179F738&gt;&gt;), ('two', &lt;bound method A.two of &lt;__main__.A instance at 0x0179F738&gt;&gt;)]
[('__doc__', None), ('__module__', '__main__'), ('one', &lt;bound method A.one of &lt;__main__.A instance at 0x0179F738&gt;&gt;), ('two', &lt;bound method A.two of &lt;__main__.A instance at 0x0179F738&gt;&gt;), ('three', &lt;bound method A.three of &lt;__main__.A instance at 0x0179F738&gt;&gt;), ('four', &lt;bound method A.four of &lt;__main__.A instance at 0x0179F738&gt;&gt;)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The attributes (methods and other members) of an object is usually looked up through an object's special <code>__dict__</code> attribute which is a standard Python dictionary. It doesn't guarantee any specific ordering.</p>
<p>If an attribute is not found in the object's <code>__dict__</code> the class's is searched instead (where methods usually reside) and so on until the whole inheritance chain has been traversed.</p>
<p>Here is some custom inspection done in the interactive prompt to illustrate this (Python 3.1):</p>
<pre><code>&gt;&gt;&gt; class Klass():
...     def test(self):
...             pass
...
&gt;&gt;&gt; k = Klass()
&gt;&gt;&gt; k.__dict__
{}
&gt;&gt;&gt; k.__class__.__dict__.items()
[('test', &lt;function test at 0x00000000024113C8&gt;), ('__dict__', &lt;attribute '__dic
t__' of 'Klass' objects&gt;), ('__module__', '__main__'), ('__weakref__', &lt;attribut
e '__weakref__' of 'Klass' objects&gt;), ('__doc__', None)]
</code></pre>
<p>Would I have put a constructor (<code>__init__</code>) in Klass and set an attribute through <code>self</code> it would've shown up in <code>k.__dict__</code>.</p>
<p>You can circumvent this by using a custom metaclass. The documentation contains an example which does exactly what you want.</p>
<p>See the bottom of this page for the <a href="http://docs.python.org/py3k/reference/datamodel.html#customizing-class-creation" rel="nofollow noreferrer">OrderedClass example</a>.</p>
<p><em>Don't know what version of Python you have so I assumed latest.</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think Python 2.6 has a <code>__prepare__</code> method, so I can't swap out the default <code>dict</code> for an ordered one. I can, however, replace it using a <code>metaclass</code> and the <code>__new__</code> method. Instead of inspecting line numbers, I <em>think</em> its easier and more efficient to just use a creation counter.</p>
<pre><code>class MetaForm(type):
    def __new__(cls, name, bases, attrs):
        attrs['fields'] = OrderedDict(
            sorted(
                [(name, attrs.pop(name)) for name, field in attrs.items() if isinstance(field, Field)],
                key=lambda t: t[1].counter
            )
        )
        return type.__new__(cls, name, bases, attrs)

class Form(object):
    __metaclass__ = MetaForm

class Field(object):
    counter = 0
    def __init__(self):
        self.counter = Field.counter
        Field.counter += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In reference to Ned Batchelder's answer above, in Python 3 line numbers of a method m can be gotten with <code>m.__func__.__code__.co_firstlineno</code></p>
<p><a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">https://docs.python.org/3/library/inspect.html</a></p>
</div>
<div class="post-text" itemprop="text">
<pre><code>members = []
for name, obj in inspect.getmembers(module):
    source, start_line = inspect.getsourcelines(obj)
    members.append([name, obj, start_line])

def _line_order(value):
    return value[2]

members.sort(key = _line_order)
</code></pre>
</div>
<span class="comment-copy">Why the -1? What's wrong with this Q?</span>
<span class="comment-copy">Why do you want to do this?</span>
<span class="comment-copy">@Daenyth: Updated Q w/ use case.</span>
<span class="comment-copy">+1. Interesting idea.</span>
<span class="comment-copy">Python 2.6. So I have to use a metaclass to keep the members in order?</span>
<span class="comment-copy">@Mark: I should've added, you still can't use inspect or dir, since the <code>type</code> object will use a straight up dictionary in the end. But they circumvent that through a custom attribute on subclasses called <code>members</code> which is ordered.</span>
<span class="comment-copy">@Skurmedel: Couldn't we explicitly replace <code>__dict__</code> with an ordered dict No matter though, I'm fine having an ordered member variable.</span>
<span class="comment-copy">@Mark: Sadly no, I think <code>type</code> is expecting a <code>dict</code> and it seems that if I pass an OrderedDict it will end up a dict anyway, perhaps through <code>dict(x)</code>. I need to read up some more, but maybe <code>type</code> is implemented in C and needs the default dictionary type.</span>
<span class="comment-copy">@Mark: Python 2.6.5 source for <code>type</code>: <a href="http://svn.python.org/view/python/tags/r265/Objects/typeobject.c?view=markup" rel="nofollow noreferrer">svn.python.org/view/python/tags/r265/Objects/â€¦</a> I've been reading the (frankly huge) function <code>type_new</code> and I think it's copying the passed in dictionary to a new <code>dict</code>, which would explain why it ends up as a <code>dict</code> no matter what in my tests.</span>
<span class="comment-copy">This doesn't work if you have different classes of objects and want to maintain order between all of them... I guess I could make them all inherit from the same <code>OrderedObject</code> though.</span>
<span class="comment-copy">Thanks, this is a brilliant idea, exactly what I needed for my project</span>
