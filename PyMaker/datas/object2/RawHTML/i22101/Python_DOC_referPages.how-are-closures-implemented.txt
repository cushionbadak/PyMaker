<div class="post-text" itemprop="text">
<p>"Learning Python, 4th Ed." mentions that:</p>
<blockquote>
<p>the enclosing scope variable is looked up when the nested functions
  are later called..</p>
</blockquote>
<p>However, I thought that when a function exits, all of its local references disappear.</p>
<pre><code>def makeActions():
    acts = []
    for i in range(5): # Tries to remember each i
        acts.append(lambda x: i ** x) # All remember same last i!
return acts
</code></pre>
<p><code>makeActions()[n]</code> is the same for every <code>n</code> because the variable <code>i</code> is somehow looked up at call time. How does Python look up this variable? Shouldn't it not exist at all because makeActions has already exited? Why doesn't Python do what the code intuitively suggests, and define each function by replacing i with its current value within the for loop as the loop is running?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think it's pretty obvious what happens when you think of <code>i</code> as a <em>name</em> not some sort of <em>value</em>. Your lambda function does something like "take x: look up the value of i, calculate i**x" ... so when you actually run the function, it looks up <code>i</code> <em>just then</em> so <code>i</code> is <code>4</code>.</p>
<p>You can also use the current number, but you have to make Python bind it to another name:</p>
<pre><code>def makeActions():
    def make_lambda( j ):
        return lambda x: j * x # the j here is still a name, but now it wont change anymore

    acts = []
    for i in range(5):
        # now you're pushing the current i as a value to another scope and 
        # bind it there, under a new name
        acts.append(make_lambda(i))
    return acts
</code></pre>
<p>It might seem confusing, because you often get taught that a variable and it's value are the same thing -- which is true, but only in languages that actually use variables. Python has no variables, but names instead.</p>
<p>About your comment, actually i can illustrate the point a bit better:</p>
<pre><code>i = 5 
myList = [i, i, i] 
i = 6
print(myList) # myList is still [5, 5, 5].
</code></pre>
<p>You said you <em>changed i to 6</em>, that is not what actually happend: <code>i=6</code> means "i have a value, <code>6</code> and i want to name it <code>i</code>". The fact that you already used <code>i</code> as a name matters nothing to Python, it will just <em>reassign the name</em>, not <em>change it's value</em> (that only works with variables).</p>
<p>You could say that in <code>myList = [i, i, i]</code>, whatever value <code>i</code> currently points to (the number 5) gets three new names: <code>mylist[0], mylist[1], mylist[2]</code>. That's the same thing that happens when you call a function: The arguments are given new names. But that is probably going against any intuition about lists ...</p>
<p>This can explain the behavior in the example: You assign <code>mylist[0]=5</code>, <code>mylist[1]=5</code>, <code>mylist[2]=5</code> - no wonder they don't change when you reassign the <code>i</code>. If <code>i</code> was something muteable, for example a list, then changing <code>i</code> would reflect on all entries in <code>myList</code> too, because you just have <em>different names for the same value</em>!</p>
<p>The simple fact that you can use <code>mylist[0]</code> on the left hand of a <code>=</code> proves that it is indeed a name. I like to call <code>=</code> the <em>assign name operator</em>: It takes a name on the left, and a expression on the right, then evaluates the expression (call function, look up the values behind names) until it has a value and finally gives the name to the value. It does <strong>not change anything</strong>.</p>
<h3>For Marks comment about compiling functions:</h3>
<p>Well, references (and pointers) only make sense when we have some sort of addressable memory. The values are stored somewhere in memory and references lead you that place. Using a reference means going to that place in memory and doing something with it. The problem is that <em>none</em> of these concepts are used by Python!</p>
<p>The Python VM has no concept of memory - values <em>float somewhere in space</em> and names are little tags connected to them (by a little red string). Names and values exist in separate worlds!</p>
<p>This makes a big difference when you compile a function. If you have references, you know the memory location of the object you refer to. Then you can simply replace then reference with this location.
Names on the other hand have no location, so what you have to do (during runtime) is follow that little red string and use whatever is on the other end. That is the way Python compiles functions: Where
ever there is a name in the code, it adds a instruction that will figure out what that name stands for.</p>
<p>So basically Python does fully compile functions, but names are compiled as lookups in the nesting namespaces, <em>not</em> as some sort of reference to memory.</p>
<p>When you use a name, the Python compiler will try to figure out where to which namespace it belongs to. This results in a instruction to load that name from the namespace it found. </p>
<p>Which brings you back to your original problem: In <code>lambda x:x**i</code>, the <code>i</code> is compiled as a lookup in the <code>makeActions</code> namespace (because <code>i</code> was used there). Python has no idea, nor does it care about the value behind it (it does not even have to be a valid name). One that code runs the <code>i</code> gets looked up in it's original namespace and gives the more or less expected value.</p>
</div>
<div class="post-text" itemprop="text">
<p>What happens when you create a closure:</p>
<ul>
<li>The closure is constructed with a pointer to the <em>frame</em> (or roughly, <em>block</em>) that it was created in: in this case, the <code>for</code> block.</li>
<li>The closure actually assumes shared ownership of that frame, by incrementing the frame's ref count and stashing the pointer to that frame in the closure. That frame, in turn, keeps around references to the frames it was enclosed in, for variables that were captured further up the stack.</li>
<li>The value of <code>i</code> in that frame keeps changing as long as the for loop is running – each assignment to <code>i</code> updates the binding of <code>i</code> in that frame.</li>
<li>Once the for loop exits, the frame is popped off the stack, but it isn't thrown away as it might usually be! Instead, it's kept around because the closure's reference to the frame is still active. At this point, though, the value of <code>i</code> is no longer updated.</li>
<li>When the closure is invoked, it picks up whatever value of <code>i</code> is in the parent frame at the time of invocation. Since in the for loop you <em>create</em> closures, but don't actually <em>invoke</em> them, the value of <code>i</code> upon invocation will be the last value it had after all the looping was done.</li>
<li>Future calls to <code>makeActions</code> will create different frames. You won't reuse the for loop's previous frame, or update that previous frame's <code>i</code> value, in that case.</li>
</ul>
<p>In short: frames are garbage-collected just like other Python objects, and in this case, an extra reference is kept around to the frame corresponding to the <code>for</code> block so it doesn't get destroyed when the for loop goes out of scope.</p>
<p>To get the effect you want, you need to have a new frame created for each value of <code>i</code> you want to capture, and each lambda needs to be created with a reference to that new frame. You won't get that from the <code>for</code> block itself, but you could get that from a call to a helper function which will establish the new frame. See THC4k's answer for one possible solution along these lines.</p>
</div>
<div class="post-text" itemprop="text">
<p>The local references persist because they're contained in the local scope, which the closure keeps a reference to.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I thought that when a function exits, all of its local references disappear.</p>
</blockquote>
<p>Except for those locals which are closed over in a closure. Those do not disappear, even when the function to which they are local has returned.</p>
</div>
<div class="post-text" itemprop="text">
<p>Intuitively one might think <code>i</code> would be captured in its current state but that is not the case. Think of each layer as a dictionary of name value pairs.</p>
<pre>
    Level 1:
        acts
        i
    Level 2:
        x
</pre>
<p>Every time you create a closure for the inner lambda you are capturing a <em>reference</em> to level one. I can only assume that the run-time will perform a look-up of the variable <code>i</code>, starting in <em>level 2</em> and making its way to <em>level 1</em>. Since you are not executing these functions immediately they will all use the final value of <code>i</code>.</p>
<p>Experts?</p>
</div>
<span class="comment-copy">Does Python have block level scoping?</span>
<span class="comment-copy">@ChaosPandion: nope</span>
<span class="comment-copy">@Mark : If you're still in school, take a programming language class - or look for any class that builds an interpreter.  It's illuminating :)</span>
<span class="comment-copy">hmmm I answered with a link to Eric Lippert's answer to this question regarding C# (<a href="http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx" rel="nofollow noreferrer">blogs.msdn.com/b/ericlippert/archive/2009/11/12/…</a>), but in retrospect, some of the arguments don't work as well for Python.</span>
<span class="comment-copy">I guess I'm just confused about the motivation behind this. It seems like when encountering the lambda x: i ** x, Python should use "LGEP" and find the variable i in the enclosing for loop. This variable i points to a certain integer in memory somewhere. Python should then create the lambda function in memory and append it to the list "acts." Each pass through the loop, the variable i references a different integer in memory, so a different function should be created. Why is Python not fully creating the lambda function when it has all the information it needs to do so?</span>
<span class="comment-copy"><code>i</code> will be 4, not 6 by then.</span>
<span class="comment-copy">I think this way of thinking of references is inconsistent with the way references usually work in Python. Consider:            i = 5;     myList = [i, i, i];     i = 6;     print(myList);  Although i has changed to 6, myList is still [5, 5, 5]. Creation of a function, to me, should be similar to a creation of a list. The index references of the list point to a spot in memory upon creation of the list. Why don't the variables of a lambda function point to spots in memory upon creation of a lambda function? (Sorry I can't seem to do markdown in a comment.)</span>
<span class="comment-copy">@Mark - In your example <code>i = 5; myList = [i, i, i]; i = 6;</code> the value of <code>i</code> will be resolved and assigned to a new name.</span>
<span class="comment-copy">@ChaosPandion - Shouldn't the case with lambda functions / closures do the same thing? Whenever I define an object (including functions) using the reference i, Python should look up where i points to in memory right?</span>
<span class="comment-copy">@Mark - The problem is that you are not immediately calling the lambda so the name <code>i</code> will remain unresolved until you do. By that point the value of <code>i</code> is already 4.</span>
<span class="comment-copy">So for loops are actually objects in Python? Could you please recommend some resources where I could learn about frames? This answer is more along the lines of what I was looking for, thanks.</span>
<span class="comment-copy">For Python, I looked at the source code (search for the word closure). In general, I learned this from this professor and textbook: <a href="https://rads.stackoverflow.com/amzn/click/com/0521780985" rel="nofollow noreferrer">amazon.com/gp/product/0521780985/…</a> which gently covers a lot of interesting topics in how language features are implemented.</span>
<span class="comment-copy">This is not how the implementation works. Closures don't keep a pointer to the stack frame they were created in. Also, blocks don't have their own stack frames. Python implements closures using <a href="https://docs.python.org/3/c-api/cell.html" rel="nofollow noreferrer">closure cell objects</a>. A cell object holds a pointer to the variable contents, and everything that needs to use the variable gets a pointer to the cell object. This allows individual closure variables to have their own lifetimes without unnecessarily keeping alive entire stack frames and all their contents.</span>
<span class="comment-copy">It's possible that you got the closure variable mechanism mixed up with <code>f_back</code>, which is a frame object's reference to the caller's stack frame, not the stack frame where a closure was created. (I don't think any released CPython version ever kept entire stack frames around to implement closures.)</span>
<span class="comment-copy">that's correct -- each lambda function keeps a reference to the same <code>i</code>.</span>
