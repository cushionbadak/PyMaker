<div class="post-text" itemprop="text">
<p>I have been doing some functional programming and had a question. Perhaps I might be missing something but is there any way to stop a "reduce()" function midway? Lets say when I reach a certain condition? The idea somehow seems anti functional. I haven't seen any such option in python or F#, </p>
<p>As an example, lets say I have a list such as [1,2,3,4,5]. I want to sum the elements in this list until the sum is not greater than some number (lets say 8), and return/mark/store/identify somehow, the number of elements I have actually added.</p>
<p>If we looked at python for example for I might try something like</p>
<pre><code>reduce(lambda a,b : a if a + b &gt; 8 else a + b, input)
</code></pre>
<p>This gives me the right answer 6, but how do I find that I had added 3 elements to get here. There is no counter as such. I can't do assignments inside lambdas. I think F# has the same situation.</p>
<p>I know I can use a for loop or use a function that can store state etc. But what would be the functional way of doing/thinking about this. Reduce() wants to run until the end, but somewhere along this line of processing, we either want to stop it (because we don't care about processing the rest of the elements) or at least make a note of the place where we stopped caring.</p>
</div>
<div class="post-text" itemprop="text">
<p>Reduce is often used in combination with map. Google for example has developed a map-reduce framework for querying their databases and this map-reduce pattern is now used in several other projects (e.g. CouchDB, Hadoop, etc).</p>
<p>First, you need to map the <code>input</code> variables <code>[2, 1, 3, 4, 5]</code> to something like:</p>
<pre><code>[(1, 2), (1, 1), (1, 3), (1, 4), (1, 5)]
</code></pre>
<p>In that case, <code>x[0]</code> will represent the number of the elements to get the sum <code>x[1]</code>. Of course, the number of elements is <code>1</code> at the beginning for each single element.</p>
<p>The next thing then, is to operate on those tuples:</p>
<pre><code>reduce(
    lambda a, b: a if a[1] + b[1] &gt; 8 else (a[0] + b[0], a[1] + b[1]),
    map(lambda x: (1, x), input))
</code></pre>
<p>This will return <code>(3, 6)</code>, meaning the partial sum is <code>6</code> using <code>3</code> elements.</p>
<p>I hope you got the idea behind map-reduce-algorithms.</p>
<p>Regards,<br/>
Christoph</p>
</div>
<div class="post-text" itemprop="text">
<p>I agree with JaredPar that writing your own recursive function that behaves similarly to <code>fold</code>, but allows you to stop the computation earlier is the best approach. The way I would write it is a bit more general (so that you can use the function for any situation where you need <em>folding</em> that can <em>stop earlier</em>):</p>
<pre><code>// Generalized 'fold' function that allws you to stop the execution earlier
// The function 'f' has a type 'State -&gt; 'T -&gt; Option&lt;'State&gt;
// By returning 'None' we can stop the execution (and return the 
// current state), by returning Some(newState), we continue folding
let rec foldStop f state input = 
  match input with
  | x::xs -&gt; 
      match f state x with
      | None -&gt; state
      | Some(newState) -&gt; foldStop f newState xs
  | [] -&gt; state

// Example that stops folding after state is larger than 10
foldStop (fun st n -&gt; if st &gt; 10 then None else Some(st + n)) 0 [ 1 .. 10 ]
</code></pre>
<p>This is a very general function and you can use it for all similar scenarios. The nice thing about writing it is that you will never need to write similar explicit recursion again (because you can just use <code>foldStop</code> once you have it).</p>
<p>Note that you can use <code>foldStop</code> to implement <code>fold</code> by always wrapping the result of the accumulation function in 'Some' (so it is more general):</p>
<pre><code>let fold f state input = 
  foldStop (fun st n -&gt; Some(f st n)) state input
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's imagine Python had two functions, <a href="http://gnosis.cx/publish/programming/charming_python_b13.html" rel="nofollow noreferrer">ireduce</a> (similar to <em>reduce</em> but it would yield intermediate values; it's called scanl in some languages) and <a href="https://stackoverflow.com/questions/2138873/cleanest-way-to-get-last-item-from-python-iterator">ilast</a> (get last item of an iterable):</p>
<pre><code>from itertools import takewhile
from operator import add
xs = [1, 2, 3, 4, 5]
pair = ilast(enumerate(takewhile(lambda x: x &lt; 8, ireduce(add, xs, 0))))
# (3, 6)
</code></pre>
<p>In Haskell:</p>
<pre><code>last $ zip [0..] (takeWhile (&lt; 8) (scanl (+) 0 xs))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think that the 'most functional' way to do this is probably via lazy evaluation.  If you're in a lazy language like Haskell, or in an eager language but using a lazy list data structure (like <code>LazyList</code> in the F# PowerPack), you can create e.g. a 'scan' of the running sums, and then leave it in the hands of the consumer of the list to decide how much she wants/needs to evaluate.</p>
<p>Or, you know, write a simple recursive function, like @JaredPar's answer.  For some reason I often get a mental block on that, preventing me from noticing that "not everything has to be a <code>fold</code>, you can in fact write your own recursive functions" :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Try the following</p>
<pre><code>let sumUntil list stopAfter = 
    let rec inner list sum = 
        if sum &gt;= stopAfter then sum
        else 
            match list with
            | [] -&gt; sum
            | h::t-&gt; inner t (sum + h)
    inner list 0    
</code></pre>
<p>F# interactive result</p>
<pre><code>&gt; sumUntil [1;2;3;4;5] 8;;
val it : int = 10
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a function that implements that functional program:</p>
<pre><code>&gt;&gt;&gt; def limited_reduce(reducer, pred, lst):
...  i = 0
...  y = lst[0]
...  while pred(y) and i &lt; len(lst):
...    i += 1
...    y = reducer(lst[i], y)
...  return (i, y)
</code></pre>
<p>or recursively:</p>
<pre><code>&gt;&gt;&gt; def limited_reduce(reducer, pred, lst):
...   def helper(i, accum, rest):
...     if not rest or not pred(accum): return (i, accum)
...     return helper(i+1, reducer(rest[0], accum), rest[1:])
...   return helper(0, lst[0], lst[1:])
</code></pre>
<p>There's probably a way to clean it up a bit, but you would use it like this:</p>
<pre><code>&gt;&gt;&gt;&gt; limited_reduce(lambda x,y: x+y, lambda r: r &lt; 6, [1,2,1,3,2])
(3, 7)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think this does what you are after, using functions built-in to the F# Seq module:</p>
<pre><code>let answer =
    [1; 2; 3; 4; 5]
    |&gt; Seq.scan (fun (count,sum) x -&gt; (count+1, sum + x) ) (0,0)
    |&gt; Seq.find (fun (_,x) -&gt; x &gt; 8)
</code></pre>
<p>The "scan" function is similar to "fold", but returns a sequence containing intermediate (and final) states, rather than just the final state.  In this case, the state is a tuple containing a count and sum of items thus far processed, starting with (0,0).  This gets computed and fed, one at a time, into the "find" function, which returns the first element which matches the supplied condition (v&gt;8), in this case (4,10).</p>
<p>The only issue you'd need to handle with the above is the case where the "find" condition is never satisfied, in which case a KeyNotFoundException is thrown.  You could use "tryFind" which returns an option value.  However, I can't see a graceful way to return the last element computed if no earlier state matches the condition, short of pre-computing the length of the sequence:</p>
<pre><code>let xs = [1; 2; 3; 4; 5]
let len = Seq.length xs
let answer =
    xs
    |&gt; Seq.scan (fun (count,acc) v -&gt; (count+1, v + acc) ) (0,0)
    |&gt; Seq.find (fun (count,v) -&gt; v &gt; 99 || count = len)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another functional approch could be using a "continution"-based version of reduce/fold:</p>
<pre><code>let rec foldC fn acc cont = function
    | []      -&gt; acc
    | x :: xs -&gt; fn x acc (fun acc -&gt; foldC fn acc cont xs) 
</code></pre>
<p>Call with 'id' (fun x -&gt; x) as 'initial continuation':</p>
<pre><code>foldC (fun x sum c -&gt; 
           if (sum + x) &gt; 8 
           then sum 
           else c (sum + x))
      0
      (fun x -&gt; x) 
      [1; 2; 3; 4; 5]
</code></pre>
<p>And you will get your '6'. </p>
<p>Note that this version of <code>foldC</code> is not tail recursive - or otherwise recommended - thought...  </p>
</div>
<div class="post-text" itemprop="text">
<p>The only way to get out of the builtin <code>reduce</code> part way through is to throw an exception. Fortunately it's not hard to get the desired result this way:</p>
<pre><code>def interruptible_reduce(fn, *args):
    try:
        return reduce(fn, *args)
    except StopIteration, e:
        return e.args[0]

def reducefn(a, b):
    total = a[1] + b[1]
    if total &gt; 8:
        raise StopIteration(a)
    return (a[0]+b[0], total)

input = [2, 1, 3, 4, 5]

&gt;&gt;&gt; from itertools import imap
&gt;&gt;&gt; interruptible_reduce(reducefn, imap(lambda x: (1,x), input))
(3, 6)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I know you're specifically interested in python, but I thought I would chime in with respect to how Clojure accomplishes this, since it solves the problem quite elegantly and directly.</p>
<p>Clojure has a <a href="https://clojuredocs.org/clojure.core/reduced" rel="nofollow"><code>reduced</code> function</a> that returns a version of whatever it is passed, such that this version will immediately terminate within a call to reduce. This makes it trivially simple to do something like this:</p>
<pre><code>(reduce (fn [a v]
          (if (&lt; a 100) 
            (+ a v)
            (reduced a)))
        (range 20))
;; =&gt; 105
</code></pre>
<p>This returns the first sum which is greater than or equal to a hundred, or the greatest sum reached if none exceeds. And it's worth noting that it does this without consuming/iterating through the entirety of the collection being reduced over, which could be very large or even infinite lazy sequence. Moreover, this has a definite advantage over applying some filter operation first, as you can have your termination condition dependent on the value being constructed, not just by individual values in the collection being reduced.</p>
<p>You mention this idea seems somehow "anit-functional". This <em>might</em> seem to be the case in python, where it's unclear how you would accomplish it without resorting to some messy outside state (or at best an alternate version of <code>reduce</code>). However, this works cleanly and functionally (even purely so) in Clojure because it's been <em>baked into</em> the language. The key is that <code>reduce</code> knows to look for <code>reduced</code> values, and objects can carry that information around with them (either as a wrapped value of as metadata; not sure which actually...).</p>
<p>It's certainly a handy feature I've been glad to have when I've needed it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a slight variation of Stephen's code, using <code>foldl</code> instead of <code>foldr</code> (I hope) and not requiring a sequence:</p>
<pre><code>#!/usr/bin/env python

import operator
import functools

def limited_reduce(op, it, start, pred):
    if not pred(start):
        return 0, start
    for i, x in enumerate(it):
        y = op(start, x)
        if pred(y):
            start = y
        else:
            break
    return i, start

print limited_reduce(operator.add, xrange(1, 6), 0,
                     functools.partial(operator.gt, 8))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to avoid carrying out unnecessary computations (which you still will with a map-reduce algorithm), write your own reduce and catch <code>StopIteration</code>:</p>
<pre><code>from functools import reduce as _reduce

def stop_iter(rv=None):
    raise StopIteration(rv)

def reduce(*args):
    try: return _reduce(*args)
    except StopIteration as e: return e.args[0]
</code></pre>
<p>Then, write a step function that wraps the return value in a call to <code>stop_iter</code> when you reach a certain condition.  Using your original lambda:</p>
<pre><code>reduce(lambda a, b : stop_iter(a) if a + b &gt; 8 else a + b, input)
</code></pre>
<p>Similar to Duncan's answer, but allows you to use lambdas (no manually raising exceptions).</p>
</div>
<div class="post-text" itemprop="text">
<p>First, in F#. What's the first triangle number greater than 100?</p>
<pre><code>&gt; [1..1000] |&gt; Seq.scan (+) 0 |&gt; Seq.find (fun x -&gt; x &gt; 100);;
val it : int = 105
</code></pre>
<p>Note that <a href="https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e" rel="nofollow noreferrer">Seq.scan</a> is lazy, so triangle numbers beyond the solution are never calculated.</p>
<p>To find the ordinal of the solution, we exchange <code>find</code> for <code>findIndex</code></p>
<pre><code>&gt; [1..1000] |&gt; Seq.scan (+) 0 |&gt; Seq.findIndex (fun x -&gt; x &gt; 100);;
val it : int = 14
</code></pre>
<hr/>
<p>In Python, the analogue of F#'s List.scan is <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer">itertools.accumulate</a>, introduced Python 3.2 (2011).</p>
<pre><code>&gt;&gt;&gt; from itertools import accumulate
&gt;&gt;&gt; next(x for x in accumulate(range(0,1000)) if x &gt; 100)
105
&gt;&gt;&gt; next(i for (i,x) in enumerate(accumulate(range(0,1000))) if x &gt; 100)
14
</code></pre>
</div>
<span class="comment-copy">What's important to you, the 3 or the 6?  Or both?  How would you want to use this function?  Return a tuple - <code>(num_items, result)</code>?  It's a neat idea, but I think a loop is the most straightforward code.</span>
<span class="comment-copy">They are both important. I want to know I can take 3 elements and that the closest I can get to my limit is 6. Yes, a loop would be pretty straight forward, but I wanted to see how a functional programmer would attack it / think about it. I can't return a tuple, because reduce needs another int from the function to add to the next element in the list.</span>
<span class="comment-copy">Regarding Python, it could be possible to write a <code>filtered_reduce</code> function, but Python remains to be an imperative language whose functional-like features should not be overestimated. In Python the call to <code>reduce</code> is translated into a simple loop anyway, so you gain nothing from it.</span>
<span class="comment-copy">Oooohhhh.... niiice. I had read about map reduce, but I guess I didn't fully grok it. Very nicely done.</span>
<span class="comment-copy">Here are two links which might interest you: Google's Map-Reduce paper (<a href="http://labs.google.com/papers/mapreduce.html" rel="nofollow noreferrer">labs.google.com/papers/mapreduce.html</a>) and a course Map Reduce in a Week (<a href="http://code.google.com/edu/submissions/mapreduce/listing.html" rel="nofollow noreferrer">code.google.com/edu/submissions/mapreduce/listing.html</a>).</span>
<span class="comment-copy">And a Python framework (based on Erlang) for doing efficient map-reduce computing is Disco. With that you can use multiple cores / computers and work with (nearly) unlimited data sets... <a href="http://discoproject.org/" rel="nofollow noreferrer">discoproject.org</a></span>
<span class="comment-copy">I'm not downvoting, but this can hardly be idiomatic FP..?  Chaitanya has picked his golden hammer, and you're helping him/her use it to bash a square peg into a round hole.</span>
<span class="comment-copy">Nice description of map/reduce, but if the input contained a million values and we hit the exit condition after three of them that's a lot of empty work being done. When you hit the exit condition use an exception to exit the loop.</span>
<span class="comment-copy">But I want to return the final state when I stopped as well as place where I stopped as well. My F# isn't fluent enough, but this would require changing the state and the input function as follows :  foldStop (fun (st,i) n  -&gt; if st &gt; 10 then None else Some(st + n, i + 1)) (0,0) [ 1 .. 10 ]</span>
<span class="comment-copy">@Chaitanya: Yes, that would require changing the code a little bit (or you would need to update the condition to stop on the next state). Alternatively, you could use <code>Choice</code> instead of <code>Option</code> (that allows you to return the state, but still break the computation by returning a speical case).</span>
<span class="comment-copy">Hmmm ... Haskell one of those languages I keep wanting to learn but never get around to it</span>
<span class="comment-copy"><code>itertools.dropwhile</code> is also similarly useful together with <code>next</code> to return the first item in an iterable.</span>
<span class="comment-copy">Indeed. I am in that block now ... I keep thinking there's gotta be a way to fold or partially fold this thing. I know there are other ways of doing it, but fold/reduce keeps beckoning me</span>
<span class="comment-copy">In other words, not use reduce at all? I just keep thinking there must be someway in the lambda/function thats passed to a reduce that there should be a way to make some state changes and/or stop abort the processing</span>
<span class="comment-copy">Right, <code>reduce</code> is no good for this.  It has the wrong type signature, and it always processes the entire list.</span>
<span class="comment-copy">This is only returning the sum though. Not the number of elements that we had added up. But I guess it would be easy to change the inner recursive loop to take a counter and thread that counter through while incrementing it every time we call the inner recursive loop</span>
<span class="comment-copy">Good solution, +1 from me. But note that your <code>reduce</code> is <code>foldr</code> and requires a sequence, unlike the builtin <code>reduce</code>.</span>
<span class="comment-copy">@Philipp : Thanks! Good point about the sequence.  Now you've got me reading about <code>foldr</code> :)</span>
<span class="comment-copy">And to complete your solution in order to match the accepted one in python from @tux21b, you can add a counter in the accumulator and get both the sum and the count:  (reduce (fn [[a c] v]           (if (&lt; a 100)             [(+ a v) (inc c)]             (reduced [a c])))         [0 0]         (range 20))</span>
