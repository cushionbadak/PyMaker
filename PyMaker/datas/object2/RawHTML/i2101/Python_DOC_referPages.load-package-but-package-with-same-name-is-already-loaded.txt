<div class="post-text" itemprop="text">
<p>I have two versions of the same Python package. I need from a module in a subpackage in the current version to be able to call a function inside the old version of the package (which copied itself in the past)</p>
<p>Where I am now:</p>
<pre><code>now/
  package/
    __init__.py
    subpackage/
      __init__.py
      module.py -&gt; "import package.subpackage.... &lt;HERE&gt;"
    subpackage2/
      ...
    ...
</code></pre>
<p>The old version:</p>
<pre><code>past/
  package/
    __init__.py
    subpackage/
      __init__.py
      module.py -&gt; "import package.subpackage; from . import module2; .... def f(x) ..."
      module2.py
    subpackage2/
      ...
    ...
</code></pre>
<p>I need to import in <code>&lt;HERE&gt;</code> the "old" <code>f</code> and run it. </p>
<p>Ideally </p>
<ul>
<li>the function <code>f</code> should live its life inside the old package without knowing anything about the new version of the package</li>
<li>the module in the new package should call it, let it live its life, get the results and then forget altogether about the existence of the old package (so calling "import package.subpackage2" after letting <code>f</code> do her thing should run the "new" version)</li>
<li>doing that should not be terribly complex</li>
</ul>
<p>The underlying idea is to improve reproducibility by saving the code that I used for some task along with the output data, and then being able to run parts of it.</p>
<p>Sadly, I understood this is not a simple task with Python 3, so I am prepared to accept some sort of compromise. I am prepared to accept, for example that after running the old <code>f(x)</code> the name <code>package</code> in the "new" code will be bound to the old.</p>
<p>EDIT</p>
<p>I tried in two ways using <code>importlib</code>. The idea was to create an object <code>mod</code> and then doing <code>f = getattr(mod,  "f")</code>, but it doesn't work</p>
<ol>
<li>Changing <code>sys.path</code> to <code>['.../past/package/subpackage']</code> and then calling <code>importlib.import_module('package.subpackage.module')</code>  . The problem is that it will load the one in "now" even with the changed <code>sys.path</code>, probably because the name <code>package</code> is already in <code>sys.modules</code></li>
<li><code>spec = importlib.util.spec_from_file_location("module", "path..to..past..module.py"))
module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(module)
</code> In that case relative imports (<code>from . import module2.py</code>) won't work, giving the error "attempted relative import with no known parent package"</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>There is one way this could work quite simply, but you will have to make a few modifications to your old package.</p>
<p>You can simply create a file in <code>now/package/old/__init__.py</code> containing:</p>
<pre><code>__path__ = ['/absolute/path/to/old/package']
</code></pre>
<p>In the new package, you can then do:</p>
<pre><code>from package.old.package.subpackage.module import f as old_f
</code></pre>
<p>The catch here is that the old package tries to import its own packages using absolute import, it is going to load stuff from the new packages instead. So the old package will have to only use relative imports when importing stuffs from its own package or you'll have to prepend package.old to all absolute imports that the old package was doing.</p>
<p>If you are fine with modifying the old packages in this way, then that should be fine. If that limitation would not work for you, then read on.</p>
<p>If you are really, really sure that for some reasons don't want to modify the old packages. Then let's do some black magic, you'd want to replace <code>builtins.__import__</code> with your own version that returns different modules depending on who is doing the importing. You can figure out who is doing the importing by inspecting the call stack.</p>
<p>For example, this is how you might do it (tested on Python 3.6):</p>
<pre><code>import builtins
import inspect
import package.old

old_package_path = package.old.__path__[0]

OUR_PACKAGE_NAME = 'package'
OUR_PACKAGE_NAME_WITH_DOT = OUR_PACKAGE_NAME + '.'


def import_module(name, globs=None, locs=None, fromlist=(), level=0):
    # only intercept imports for our own package from our old module
    if not name.startswith(OUR_PACKAGE_NAME_WITH_DOT) or \
            not inspect.stack()[1].filename.startswith(old_package_path):
        return real_import(name, globs, locs, fromlist, level)

    new_name = OUR_PACKAGE_NAME + '.old.' + name[len(OUR_PACKAGE_NAME_WITH_DOT):]
    mod = real_import(new_name, globs, locs, fromlist, level)
    return mod.old

# save the original __import__ since we'll need it to do the actual import
real_import = builtins.__import__
builtins.__import__ = import_module
</code></pre>
<p><code>builtins.__import__</code> gets called on any import statements encountered by the interpreter, and the call is not cached so you can return different things every time it is called even when they use the same name.</p>
<hr/>
<p><strong>The following is my old answer, here for historical purpose only</strong></p>
<p>I don't quite get what you're trying to do, but this is likely possible to do in Python 3 by using <a href="https://docs.python.org/3/library/importlib.html" rel="nofollow noreferrer">importlib</a>. </p>
<p>You would just create a module loader that loads your module from an explicit filepath.</p>
<p>There's also an <code>invalidate_caches()</code> and <code>reload()</code> function which may be useful, though you may not need them.</p>
</div>
<span class="comment-copy">that's generally not recommended as old versions of packages generally have inter-dependencies on other packages and the version of python they're being run against.  I'd suggest something like pickling parameters, spinning up a new interpreter in a different <code>virtualenv</code>, then unpicking and running in that</span>
<span class="comment-copy">Why isn't regular import working for you in this case? I don't think there's any bulletproof way to do this and guarantee there will be no import namespace clashes between the two versions of the package. I don't know of any library that is designed to coexist with other versions of the same library.</span>
<span class="comment-copy">I don't understand: Are you trying to use two versions of <code>module.py</code> at the same time? I'm assuming the <code>def x(x):</code> function definition is instead it.</span>
<span class="comment-copy">This is a <i>bad idea</i> ™.  You should not use multiple versions of the same library at the same time.</span>
<span class="comment-copy">@HåkenLid because it won't import <code>package.subpackage.module</code> from the old directory even if I change <code>sys.path</code> if I have already done <code>import package.subpackage2</code> in the new directory. I believe it is connected to <code>sys.modules</code> containing <code>'package'</code></span>
<span class="comment-copy">Thanks but it is not enough. I edited the question with more details about what happens with importlib</span>
<span class="comment-copy">@FiatLux: I've updated my answer with how you could do this</span>
