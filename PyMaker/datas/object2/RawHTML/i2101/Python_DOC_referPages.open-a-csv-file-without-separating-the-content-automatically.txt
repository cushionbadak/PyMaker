<div class="post-text" itemprop="text">
<p>I have a <code>csv</code> which contains text like </p>
<pre><code>AAABBBBCCCDDDDDDD
EEEFFFRRRTTTHHHYY
</code></pre>
<p>when I run the code like below:</p>
<pre><code>rows = csv.reader(csvfile)
  for row in rows:
    print(" ".join('%s' %row for row in rows))
</code></pre>
<p>it will project as follow:</p>
<pre><code>['AAABBBBCCCDDDDDDD']
['EEEFFFRRRTTTHHHYY']
</code></pre>
<p>But I want to display as a series of words like below:</p>
<pre><code>AAABBBBCCCDDDDDDDEEEFFFRRRTTTHHHYY
</code></pre>
<p>Is there anything wrong in the code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your example looks like you simply need</p>
<pre><code>with open(csvfile) as inputfile: # misnomer; not really proper CSV
    for row in inputfile:
        print(row.rstrip('\n'), end='')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The example you provided doesn't look like a csv file. It looks like a simple text file. The you could have something as simple as : </p>
<p><strong>Input.txt</strong></p>
<pre><code>AAABBBBCCCDDDDDDD
EEEFFFRRRTTTHHHYY
</code></pre>
<p><strong>Solution.py</strong></p>
<pre><code>input_filename = "Input.txt"

with open(input_filename) as input_file:
    print("".join(x.rstrip('\n') for x in input_file))
</code></pre>
<p>This is taking advantage of:</p>
<ul>
<li>A file object can be iterated on. This will give you a new line from each iteration</li>
<li>Every line received from the file will have newline character at its end. Since you seem to not want it we use the method <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="nofollow noreferrer"><code>.rstrip()</code></a> to remove it</li>
<li>The <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>.join()</code></a> method can accept any iterable even a...</li>
<li><a href="https://docs.python.org/3.6/tutorial/classes.html#generator-expressions" rel="nofollow noreferrer">Generator expression</a> which will help us create an iterable that will accepted by <code>.join()</code> using <code>.rstrip()</code> to format every line coming from the input file.</li>
</ul>
<p>EDIT: OK let's decompose further my answer:</p>
<ul>
<li>When you open a file you can iterate over it. In the most simple way to explain it, let's say that it means that you do a loop over it (<code>for line in input_file: ...</code>). </li>
<li>But not only that, but with an iterator you can create another iterator by transforming each element. This is what a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> or, in the case I have chosen, a <a href="https://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> does. So the expression <code>(x.rstrip() for x in input_file)</code> will be a iterator that takes every element of <code>input_file</code> and applies to it <a href="https://docs.python.org/3/library/stdtypes.html#str.rstrip" rel="nofollow noreferrer"><code>.rstrip()</code></a></li>
<li>The string method <a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="nofollow noreferrer"><code>.join()</code></a> will glue together the elements provided by an iterator using that string as a separator. Since I use here an empty string there won't be a seperator. I have used the iterator defined before for this.</li>
<li>I then <code>print()</code> the string provided by the <code>.join()</code> operation explained before.</li>
</ul>
<p>I did a minor correction on my answer because there is the edge case that if there are space or tab characters at the end of a line in the input file they would have been removed if I use <code>x.rstrip()</code> instead of <code>x.rstrip('\n')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You could start with an empty string, and for every row read from the csv file, remove the newline at the end and add the contents to the empty string.</p>
<pre><code>joined = ""

with open(csvfile) as f:
    for row in f:
        joined = joined + row.replace("\n","")

print(joined)
</code></pre>
<p>Output:</p>
<pre><code>&gt;&gt; AAABBBBCCCDDDDDDDEEEFFFRRRTTTHHHYY
</code></pre>
</div>
<span class="comment-copy">You're iterating over <code>rows</code> twice because of the list comprehension. You're iterating over the entire file for every row in the file. You meant to do <code>print(" ".join('%s' % item for item in row))</code>. You also don't need that list comprehension, just do <code>print(" ".join(row))</code>.</span>
<span class="comment-copy">If there are no comma-separated values, it's not CSV. This looks like just a basic text file.</span>
<span class="comment-copy">Also, why are you joining on a space if you don't want a space between the joined values?</span>
<span class="comment-copy">A csv is a text file, but not all text files are csv. This one is not, so it doesn't make sense to use the csv module on it. Just process it as plain text.</span>
<span class="comment-copy">I used this method and it works! Just not sure the logic of  "".join(x.rstrip()</span>
<span class="comment-copy">This seems identical to my answer, except the inefficient and unattractive detail of reading the entire input file into memory at once.</span>
<span class="comment-copy">@New learner: I have modified my answer to give you more detail. Tell us if it helps you understand better. If it does would you consider <a href="https://stackoverflow.com/help/someone-answers">accepting this answer</a>?</span>
<span class="comment-copy">@tripleee: You are not entirely wrong but we don't how big the input file is. If the file is not really big it is faster to have the entire input file in memory and then print it once. So for the moment I can't tell if your solution is better than mine.</span>
<span class="comment-copy">I am in fact entirely right. That doesn't mean you can't get away with reading the entire file into memory as long as you have enough of it; but a common beginner mistake is to assume it doesn't matter, and then they are baffled because their program works on toy inputs but is unusable in production.</span>
