<div class="post-text" itemprop="text">
<p>I have a python class A with <code>with</code> statement and class B with <code>with</code> statement. Now it works like:</p>
<pre><code>with A() as a:
    with B() as b:
        do_things()
</code></pre>
<p>How can I build a class C that wrap class A and class B so that I can call it like:   </p>
<pre><code> with C() as c:
        do_things()
</code></pre>
<p>has the identical funtions</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to suggest an alternative. You can initialise both <code>a</code> and <code>b</code> on the same line:</p>
<pre><code>with A() as a, B() as b:
    do_things()
</code></pre>
<p>This is more concise and reduces the amount of indentation in deeply nested code. </p>
<p>However, if you absolutely must use a class, then override the <code>__enter__</code> and <code>__exit__</code> methods:</p>
<pre><code>class C:
    def __enter__(self):
        self._a = A()
        self._b = B()
        return (self._a.__enter__(), self._b.__enter__())

    def __exit__(self ,type, value, traceback):
        # Cleanup code here.
        self._b.__exit__(type, value, traceback)
        self._a.__exit__(type, value, traceback)
</code></pre>
<p>And then use <code>C</code> inside a context manager like this:</p>
<pre><code>with C() as (a, b):
    do_things()
</code></pre>
<p>If you don't want to reference <code>a</code> and <code>b</code>, or if you don't plan on doing anything with them, then</p>
<pre><code>with C():
    do_things()
</code></pre>
<p>Will also work. This should be enough to get started, but please note there are drawbacks as kindly mentioned by users in the comments. The main one being that if <code>self._b.__enter__</code> throws errors, <code>self._a.__enter__</code> will need to be cleaned up (this can be done using try-except-finally). Furthermore, some context managers may need to be treated differently based on what resource is being managed.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Short answer</strong>: it is <em>possible</em>. But context-managers allow to implement some logic, which makes it "tricky" to implemented it exactly the right way. Below you see a "Proof of Concept", but I do not guarantee that it has <em>exactly</em> the same behavior. Therefore I really advise to work with nested <code>with</code>s.</p>
<p><strong>What is not covered here</strong>: the <code>__init__</code>, or <code>__enter__</code> can raise exceptions as well, and these are then handled by the "outer" context managers. This makes it of course rather complicated. You basically would need to "build" a stack in the <code>__enter__</code>, and then "pop" the stack in case one of the <code>__enter__</code>s fails. This scenario is <em>not</em> covered here.</p>
<p>We can make a "composite" context manager:</p>
<pre><code>class C:

    def __init__(self, *ctxs):
        self.ctxs = ctxs

    def __enter__(self):
        return tuple(ctx.__enter__() for ctx in self.ctxs)

    def __exit__(self, self, exception_type, exception_value, traceback):
        for ctx in reversed(self.ctxs):
            try:
                if ctx.__exit__(exception_type, exception_value, traceback):
                    (exception_type, exception_value, traceback) = (None,) * 3
            except Exception as e:
                exception_value = e
                traceback = e.__traceback__
                exception_type = type(e)
        return exception_value is None
</code></pre>
<p>The <code>__exit__</code> part is tricky. First of all, we need to exit in <em>reverse</em> order. But the exception handling is even more complicated: if an <code>__exit__</code> silenced an exception, by returning a "truthful" value, then we should pass <code>(None, None, None)</code> as <code>(exception_type, exeption_value, traceback)</code>, but a problem that can occur is that an <code>__exit__</code> on the other hand triggers an exception itself, and thus then introduces a new exception.</p>
<p>We can then use the context processor like:</p>
<pre><code>with C(A(), B()) as (a,b):
    # ...
    pass
</code></pre>
<p>The above thus allows to implement a context manager for an arbitrary number of "sub-contextmanagers". We can subclass this to generate a specific one, like:</p>
<pre><code>class ContextAB(C):

    def __init__(self):
        super(ContextAB, self).__init__(A(), B())
</code></pre>
<p>and then use this as:</p>
<pre><code>with ContextAB() as (a, b):
    # ...
    pass
</code></pre>
<p>But long story short: use nested <code>with</code> statements. It also makes it more explicit what is going on here. Right now the <code>C</code> encapsulate all sorts of logic, which are better made explicit. If <em>entering</em> <code>B</code> fails, then this should result in an exception that is handled by the <code>__exit__</code> of <code>A</code>, etc. This makes it very cumbersome to get the "details" completely equivalent to the semantics of the <code>with</code> statement.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your reason for doing this is to reduce indentation or merge the <code>with</code> statements, you don't need to. You can just do</p>
<pre><code>with A() as a, B() as b:
    ...
</code></pre>
<p>entering multiple context managers on a single line.</p>
<p>If your <code>C</code> has other reasons to exist, you need to be careful about handling the case where one context manager fails after another context manager has been created and/or entered. <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>contextlib.ExitStack</code></a> can help you implement this robustly, or <a href="https://pypi.org/project/contextlib2/" rel="nofollow noreferrer"><code>contextlib2.ExitStack</code></a> if you're still on Python 2:</p>
<pre><code>import contextlib

class C(object):
    def __enter__(self):
        with contextlib.ExitStack() as stack:
            stack.enter_context(A())
            stack.enter_context(B())
            self._stack = stack.pop_all()
        return self
    def __exit__(self, exc_type, exc_value, exc_tb):
        return self._stack.__exit__(exc_type, exc_value, exc_tb)
</code></pre>
</div>
<span class="comment-copy"><code>C</code> must become a context manager, meaning it implements some special methods. Specification is in <a href="https://www.python.org/dev/peps/pep-0343/#specification-the-with-statement" rel="nofollow noreferrer">PEP 343</a></span>
<span class="comment-copy">Note that you can also do <code>with A() as a, B as b:</code> and avoid double nesting in python3, if you are in python2 you can use <a href="https://docs.python.org/2.7/library/contextlib.html#contextlib.nested" rel="nofollow noreferrer"><code>contextlib.nested</code></a>. In python3.3 there is <a href="https://docs.python.org/3.7/library/contextlib.html#contextlib.ExitStack" rel="nofollow noreferrer"><code>ExitStack</code></a> which might be useful. If you actually want to have your own class then you just need to implement <code>__enter__</code> and <code>__exit__</code> method accordingly.</span>
<span class="comment-copy">Right, c = (a, b)</span>
<span class="comment-copy">@Bakuriu: You can also use <code>with A() as a, B() as b:</code> in Python 2.7. <code>contextlib.nested</code> is error-prone and should be avoided whenever possible.</span>
<span class="comment-copy">@user2357112 I did not say python2.7 but python2. Unfortunately some people are still using python2.6 or less for some legacy systems (me included)....</span>
<span class="comment-copy">Your <code>__enter__</code> method exits the <code>a</code> and <code>b</code> context managers.</span>
<span class="comment-copy">@user2357112 Thank you and good point... I am not sure how to get around that.</span>
<span class="comment-copy">That doesn't look quite right. You'd probably want to delegate both the enter and exit methods explicitly in C.</span>
<span class="comment-copy">Shouldn't the <code>__exit__</code>s be called in reverse order?</span>
<span class="comment-copy">@coldspeed: well, a +1 is well deserved :)</span>
<span class="comment-copy">This is basically a reimplementation of <a href="https://docs.python.org/2.7/library/contextlib.html#contextlib.nested" rel="nofollow noreferrer"><code>contextlib.nested</code></a>, with the same error-prone quirks that led to the removal of <code>contextlib.nested</code> in Python 3, particularly the failure to clean up earlier context managers if later context managers fail in <code>__init__</code> or <code>__enter__</code>.</span>
<span class="comment-copy">@user2357112: well I definitely agree this is not a good idea. And you are correct that there is indeed some extra work to check if the <code>__init__</code> or <code>__enter__</code> fails.</span>
