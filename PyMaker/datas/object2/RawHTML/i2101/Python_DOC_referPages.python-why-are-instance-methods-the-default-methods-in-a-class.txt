<div class="post-text" itemprop="text">
<p>Functions in a python class can be either <em>instance</em> methods, <em>class</em> methods or <em>static</em> methods.</p>
<p>The former is characterised by the <code>self</code> as its first (implicit) argument, acts directly on the instance of the class, and does not require any decorators to be treated as such.</p>
<p>The other two, however, need decorators <code>@classmethod</code> and <code>@staticmethod</code> before the name of the method - this is why I refer to the instance method as the "default" one, i.e. the one for which a wrapper is not needed.</p>
<hr/>
<p>My question is: <br/> suppose I am in a class, and I am breaking up my calculation into several functions for readibility. Only one of these methods will need access to the <code>self.something</code> variables that I share instance-wise, but most of the others do not need to know about the class they belong to - they are just there for "housekeeping".</p>
<p>Should make these functions (the ones that do not need any <code>self.something</code> knowledge) all <code>@staticmethod</code>? <br/> Doing so would require a decorator and hence an <em>extra</em> step. <br/> It would be <em>easier</em> (not requiring the extra step of using a decotrator) for every method to just be an instance method, thus inheritig a lot of potential but also waisting it since it is not needed for the scope of the functions in question.</p>
<p>Why is the instance method the "default"? <br/> Why not have every method a static method by default, and give it the extra functionality associated with being a instance method with a wrapper?</p>
</div>
<div class="post-text" itemprop="text">
<p>The reason to default to instance methods is because that's usually what you want when you're doing object oriented programming. I can't think of a single language that claims to support OOP and has methods default to anything but instance methods. Classes are templates for "data with behaviors", so the default is to make methods that provide behaviors to each instantiation of the class. If you just want a collection of functions, you can just define them at the top level of a module and save the unnecessary class after all.</p>
<p>In general, <code>@staticmethod</code> is used to mean "I know this isn't a behavior of the class or its instances, but it helps implement the real behaviors and isn't very useful outside the class, so I'll namespace it inside it." If the features are useful outside the class, you'd just make it a plain top-level function rather putting it inside the class at all. It is advantageous to use <code>@staticmethod</code> where appropriate; it's a little faster to call than an instance method, so if you don't need the instance, <code>@staticmethod</code> will speed up your code a bit (note: This may not be true in 3.7+, where <a href="https://docs.python.org/3/whatsnew/3.7.html#optimizations" rel="nofollow noreferrer">they added an optimization to avoid the creation of bound methods</a>, which may speed up instance/class methods).</p>
<p><code>@classmethod</code> basically has two use cases:</p>
<ol>
<li>(Primary) Defining alternate constructors in a subclass friendly way (the <code>cls</code> it receives is the actual subclass, if applicable, not just the class it was defined in)</li>
<li>(Mostly unnecessary) As an alternative to <code>@staticmethod</code> when the method needs to call other static methods and you'd rather not have to refer to the class by name over and over</li>
</ol>
<p>Point is, <code>@staticmethod</code> is mostly for when you're opting out of OOP, and <code>@classmethod</code>s are for niche use cases; instance methods are just more useful, so they're the default. Beyond that, as a historical note, static and class methods were introduced later, so making them the default would have broken <em>all</em> existing Python code, for no real benefit.</p>
<p>The main reason to use <code>@staticmethod</code> over instance methods with an ignored <code>self</code> (when <code>self</code> isn't needed) is that it will continue to work when called on the class itself, not just on instances of the class; if you tried to call <code>MyClass.notreallystatic()</code>, it would die for lack of a <code>self</code>, while <code>MyClass.actuallystatic()</code> would work.</p>
</div>
<span class="comment-copy">If it doesn't need the instance, why is it part of the class? And why do you have so many helpers that don't need the instance?</span>
<span class="comment-copy">Because I am using the class just to bunch functions together, that perform calculations towards the same goal.</span>
<span class="comment-copy">"Because I am using the class just to bunch functions together" - well that explains why you're so confused. That's not what classes are for.</span>
<span class="comment-copy">@user2357112: Although admittedly, that's basically what <code>@staticmethod</code> is for: "I have helper functions that aid with class functionality, but aren't very useful outside the class, and have no direct reliance on the class or its instances, so we'll namespace them inside the class to make it clear they're class helpers." It's just that that's the unusual case, so there is no reason to make it the default behavior.</span>
<span class="comment-copy">@SeanPianka: That said, if the class doesn't have any instance attributes or methods, you could just skip the class-as-namespace and make all the functions top-level functions of a module. If the static methods aren't <i>helping</i> the class instances in some way, they don't need to be on a class at all.</span>
