<div class="post-text" itemprop="text">
<p>i am trying to grasp Regexp using python. I am trying to match patterns wherein the first character of the block of characters cant be a number while the rest can be any number or character or _. The first char can only be _ or characters. e.g</p>
<pre><code>7lucky is invalid
_lucky is valid
_7lucky is valid
lucky.john is valid
</code></pre>
<p>My code: </p>
<pre><code>exp=re.compile(r"(\b[_a-z][-a-z0-9.]*\b)")
name="-john"
result= exp.search(name)
</code></pre>
<p>This accepts <code>-john</code> too whereas it should only accept <code>_</code> or <code>a-z</code> in first place.</p>
</div>
<div class="post-text" itemprop="text">
<p>This would find nothing for <code>-john</code> but find <code>_john</code>:</p>
<pre><code>import re
exp=re.compile(r"^(\b[_a-z][-a-z0-9.]*\b)")
names=["john","-john","7john","_john"]
for n in names:
    if exp.search(n): 
        print(n)
    else:
        print("not found in :"+n)
</code></pre>
<p>Output:</p>
<pre><code>john
not found in :-john
not found in :7john
_john
</code></pre>
<p>The difference is I prepended <code>^</code> to the pattern, meaning: beginning of line.</p>
<hr/>
<p>From the doku: <a href="https://docs.python.org/3/library/re.html#re.search" rel="nofollow noreferrer">https://docs.python.org/3/library/re.html#re.search</a></p>
<blockquote>
<p><code>re.search(pattern, string, flags=0)</code>  Scan through string looking for
  the first location where the regular expression pattern produces a
  match, and return a corresponding match object. Return None if no
  position in the string matches the pattern; note that this is
  different from finding a zero-length match at some point in the
  string.</p>
</blockquote>
<p><code>re.search</code> is not contstrained to find at the begin of a string - use <code>re.match(pattern, string, flags=0)</code> for an implicit "find at string beginning" search:</p>
<pre><code>exp=re.compile(r"(\b[_a-z][-a-z0-9.]*\b)")  # works as well, using match
names=["john","-john","7john","_john"]
for n in names:
    if exp.match(n): 
        print(n)
    else:
        print("not found in :"+n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Problem here lies in your boundary: it matches the boundary between <code>-</code> and a letter.<br/>
You have to rework it another way.</p>
<p>I chose to use a lookbehind to match only when not preceded by a non spacing character, replacing <code>\b</code> by <code>(?&lt;!\S)</code>:<br/>
<a href="https://regex101.com/r/Nk2voU/1" rel="nofollow noreferrer"><code>(?&lt;!\S)[_a-z][-a-z0-9.]*</code></a></p>
<p>NB: The trailing word boundary is useless, as trying to match <code>[-a-z0-9.]*</code> will always stop when no more is met.</p>
</div>
<span class="comment-copy">It works but if we are finding such patterns in a string where there are no of such patterns it is not working e.g name='-john should not be done _john 7should ". It should return all words except -john and 7should.kindly update</span>
