<div class="post-text" itemprop="text">
<p>I want to optimize the operation of a <a href="https://en.wikipedia.org/wiki/Cogeneration" rel="nofollow noreferrer">CHP plant</a> over a requested power profile. Therefore I define a power profile, which should be followed by the CHP plant as much as possible.
Multiple bounds and constraints must be applied to represent the realistic operation of a CHP plant. This for example includes that the CHP can bei either on or off and while on, its power modulation can only be set to a specific percentage range.</p>
<p>Here is a minimum working example with short explanations:</p>
<pre><code>import scipy.optimize as opt
import numpy as np

x = np.arange(200)  # dummy x vector
poly_profile = np.array(  # 7th degree polynome fit of profile
    [-2.14104340e-11,  1.85108903e-08, -6.66697810e-06,  1.29239710e-03,
     -1.45110876e-01,  9.40324129e+00, -3.24548750e+02,  4.60006330e+03])
poly_fun = np.poly1d(poly_profile)  # make poly fun
profile = poly_fun(x[65:196])
x0 = np.zeros_like(profile)  # all zeros as starting values

def optifun(x, profile):  # define minimization fun
    return - np.sum(profile * x)

bnds_hi = opt.Bounds(0.3, 1)  # upper bounds
bnds_lo = opt.Bounds(0, 0)  # lower bounds

res = opt.minimize(
    optifun, x0, args=(profile), bounds=bnds_hi,
    constraints={'type': 'eq', 'fun': lambda x:  np.sum(x*40) - 2000},
    method='SLSQP')
plt.plot(res.x)
plt.plot(profile)
</code></pre>
<p>So these are the bounds I want to use:</p>
<ul>
<li><code>(x == 0) or (0.3 &lt;= x &lt;= 1)</code>, for any value in the array <code>x</code><br/>
This means that x, the modulation degree of the total CHP power, can be either 0 (switched off) or <code>&gt;0.3</code> and <code>&lt;= 1</code>. But I can either specify the lower bounds <strong>OR</strong> the upper bounds. Only specifying the upper bounds makes it impossible to "switch the CHP off", while setting the lower bounds to
<code>bnds_lo = opt.Bounds(0, 1)</code><br/>
will enable the CHP plant to operate in a non-realistic operation point (between 0% and 30% of power modulation).<br/>
Is there any way to make this work with the bounds as specified in the minimum working example? Specifically: Can I set two kinds of bounds at the same time, like <code>bounds=[bnds_lo, bnds_hi]</code>?<br/>
I guess this is a mixed integer linear programming problem, but shouldn't COBYLA or SLSQP be able to handle this? If not: Is there any workaround?</li>
</ul>
<p>And the constraints I want to use:</p>
<ul>
<li><code>np.sum(x*40) - 450</code><br/>
Limits the thermal output to some thermal storage capacity. Here 40 is the thermal output power while 450 is the remaining storage capacity. This is fairly easy to implement.</li>
<li><p>Limit the number of starts of the CHP plant. As an example let's assume</p>
<pre><code>bnds_lo = opt.Bounds(0, 1)  # lower bounds
res = opt.minimize(
    optifun, x0, args=(profile), bounds=bnds_lo,
    constraints={'type': 'eq', 'fun': lambda x:  np.sum(x*40) - 1000},
    method='SLSQP')
</code></pre>
<p>This leads to 3 periods of CHP plant operation. Is there any way to limit this? I was thinking about adding a specific constraints function which counts the positive diffs after a leading 0, but I was not able to make anything like this work (for example since most <code>x</code> are not exactly 0, since bounds are set to <code>(0, 1)</code>. But other issues may also be the reason)...</p></li>
<li>Set a minimum consecutive run time of the CHP plant. That means that it should be favourable to have at least, let's say 5, consecutive <code>x != 0</code>. I thought about trying something similar as in my last point (limiting the number of starts), but was also not able to work out something useful. This is by far the least important problem.</li>
</ul>
<p>To solve these issues I also tried using
<code>scipy.optimize.LinearConstraings</code> and <code>NonlinearConstraings</code>
But <code>method='trust-constr'</code> requires a jac (as far as I read on github this seems to be a bug) and thus I wasn't able to make it work.</p>
<p>Is there any way I can make this work? Especially specifying multiple bounds is important.</p>
<p>Thanks in advance!</p>
<p>Sincerely,
Scotty</p>
</div>
<div class="post-text" itemprop="text">
<p><code>profile * x0</code> in your code gives<br/>
"ValueError: operands could not be broadcast together with shapes (131,) (200,)".  </p>
<p>Just guessing, is <code>x_t</code> a product <code>onoff_t * xon_t</code><br/>
with <code>onoff_t</code> = 0 or 1<br/>
and <code>0.3 &lt;= xon_t &lt;= 1</code> at each <code>t</code> in <code>0 .. T</code> ?<br/>
I.e. for <code>T = 5</code> there are 2^5 possible <code>onoff</code> sequences, 00000 00001 00010 .. 11111 ?</p>
<p>If so, maximizng <code>sum 0:T  w_t * onoff_t * xon_t</code>
with a fixed weight function <code>w_t</code> is trivial:<br/>
where <code>w_t &lt;= 0</code>: <code>onoff_t = 0</code>, off<br/>
where <code>w_t &gt; 0</code>: <code>onoff_t = 1</code>, on, and <code>xon_t = 1</code>, max.<br/>
So that can't be your question -- please clarify.</p>
<p>If <code>onoff_t</code> is further constrained to switch only twice, 0... 1... 0...,
then the number of possible sequences is small enough to just try them all,
along the lines:</p>
<pre><code>def pulse_generator( T=200, minwidth=5 ):
    """ -&gt; arrays of T floats, 0... 1... 0... """
    for t0 in xrange( 1, T ):
        for t1 in xrange( t0 + minwidth, T ):
            pulse = np.zeros( T )
            pulse[t0:t1] = 1
            yield pulse

for pulse in pulse_generator( T ):
    print "pulse:", pulse
    optimize myfunction( pulse * xon ), 0.3 &lt;= xon &lt;= 1
</code></pre>
<p>Switching 4 times, 0... 1... 0... 1... 0..., is similar.
(How many such pulses are there for a given <code>T</code> ?
See wikipedia <a href="https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)" rel="nofollow noreferrer">Stars and bars</a> --
amazing.)</p>
<p><hr/>
Added: I'm no expert, but isn't on-off aka
<a href="https://en.wikipedia.org/wiki/Bang-bang_control" rel="nofollow noreferrer">bang-bang control</a>
<em>very</em> sensitive to tiny changes, a bit earlier or later ?
A program(mer) can spend a lot of time dithering, down in the noise.
How about 2 phases, coarse-grid then fine-grid --</p>
<ol>
<li>split the time 0:T into say 10 pieces, run all 2^10 = 1024 on-off sequences<br/>
1a. look at the best ones closely -- any pattern ?</li>
<li>move their edges by half steps, T / 20.</li>
</ol>
<p>See also:
google "discrete optimization" multigrid ... and
<a href="https://en.wikipedia.org/wiki/Hyperparameter_optimization#Grid_search" rel="nofollow noreferrer">Grid search</a>.</p>
</div>
<span class="comment-copy">These type of power scheduling models are often solved with <b>mixed integer programming</b> models because of the discrete nature of the problem (on-off decisions). The bounds <code>(x = 0) or (0.3 &lt;= x &lt;= 1)</code> are usually described as x being a <b>semi-continuous variable</b>.</span>
<span class="comment-copy">Thanks for your answer. I'd like to avoid MILP tools like pyomo, to reduce the dependency of my program of other modules. This optimization is called every few steps steps from within a much larger simulation program and will be used to set some variables in the simulation. Thus I'd really like to avoid using too complex optimization to also retain a good performance. If there is no direct way to implement the discrete bounds, I can still clip these manually after optimization. This is of course the worst-case, but still ok, since the optimization is executed every few steps and thus errors</span>
<span class="comment-copy">will be small. But I also can't work out how to limit the number of starts. Any idea on how to do this?</span>
<span class="comment-copy">Focusing on just the constraint <code>(x == 0) or (0.3 &lt;= x &lt;= 1)</code>:  the scipy minimizers can't handle this type of constraint.  To use scipy for this, you would have to do the minimization twice, once with <code>x == 0</code> and again with <code>0.3 &lt;= x &lt;= 1</code>, and then pick the best answer.</span>
<span class="comment-copy">Ok, so I guess I'll just have to do it with <code>0 &lt;= x &lt;= 1</code> or with milp optimizer. Thanks! Any advice for dealing with the constraints?</span>
<span class="comment-copy">Hi denis. Thanks alot for your help. Yes, now that you gave me an example with separating <code>x</code> in <code>onoff_t</code> and <code>xon_t</code> it seems trivial. But I didn't think about this possibility when I was trying to solve it on my own. :) Also the pulse generator is really helpful. But I can't make it work for an arbitrary number of pulses, where only the maximum number of pulses is limited, but using less pulses is allowed. For example a maximum of 4 pulses, but where the optimal solution only uses 2 pulses.Shall I open a new question on this topic?</span>
<span class="comment-copy"><code>profile * x0</code> does not raise any error in my code. It seems like you are using python 2.x. Perhaps there is some difference in using numpy arrays between Python 3 and 2.x. Because the lines <code>profile = poly_fun(x[65:196])</code> <code>x0 = np.zeros_like(profile)</code> should clearly avoid any shape mismatch of <code>profile</code> and <code>x0</code>.</span>
<span class="comment-copy">@Scotty1- Say you define <code>pulsegen2</code> and <code>pulsegen3</code> as above. One way to run them both is: <code>for pulse in list(pulesegen2) + list(pulsegen3): ...</code> A fancier way that uses less memory for big generators is <code>itertools.chain</code>, see <a href="https://docs.python.org/3/howto/functional.html" rel="nofollow noreferrer">Functional Programming Howto</a>. Any number of pulses is code golf, first do 2 3 4.  Also, "fixed weight function... trivial" ?</span>
<span class="comment-copy">Thanks for your additional information. Yes, bang-bang control is not really a nice way to deal with controls, but in many fields it is still a common control strategy. Furthermore, as you proposed, superimposing a "bang-bang" pulse generator with a continuous variable sounds like an acceptable workaround, since the optimization problem in this case is fairly small and the result is being fed into a system of mostly non-stiff ODEs with high inertia, resulting in a low sensitivity of the total system for abrupt changes of the optimization results.</span>
<span class="comment-copy">Regarding functional programming: In my understanding functional programming would imply writing a general pulse generator function which can be reused in a pulse generator for an arbitrary number of pulses without having to write a pulse generator for a specific number of pulses. <code>Itertools.chain</code> still seems like a good way to deal with the pulse generators for specific numbers of pulses.</span>
