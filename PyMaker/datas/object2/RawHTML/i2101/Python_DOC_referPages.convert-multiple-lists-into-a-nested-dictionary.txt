<div class="post-text" itemprop="text">
<pre><code>abc/pqr123/xy2/yes//T  
abc/pqr245/kl3/yes//T  
abc/ijk123/op5/yes//T  
abc/pqr245/kl4/yes//T
</code></pre>
<p>These are the input values that I want to convert to a nested dictionary.Each value such as 
    abc, pqr123, xy2, yes, T 
represents the name of a product.</p>
<p>My output should look something like this:  </p>
<pre><code>{"abc":{"pqr123":{"xy2":{"yes":{"T":[]}},"pqr245":"kl3":{"yes":{"T": 
[]}},"kl4":{"yes":{"T":[]}},"ijk123":{"op5":{"yes":{"T":[]}}}  
</code></pre>
<p>So I need a nested dictionary of all unique values and at the last key of the dictionary should have a value of empty list.</p>
<p>Below is my snippet of code that generates the output I require, but I want to do it more dynamically so it is best suited even
if the length of the input grows or shrinks. Please do let me know if are any better solution for this problem.    </p>
<pre><code>data_dict={}
for item in meta_line.split(','):
    item = item.replace('//','/')
    item = str(item) 
    item = item.split('/')
    if item[0] == "":
       continue  

    if item[0] not in data_dict.keys():
       data_dict[item[0]] = {}
    if item[1] not in data_dict[item[0]].keys():
       data_dict[item[0]][item[1]] = {}
    if item[2] not in data_dict[item[0]][item[1]].keys():
       data_dict[item[0]][item[1]][item[2]] = {}
    if item[3] not in data_dict[item[0]][item[1]][item[2]].keys():
       data_dict[item[0]][item[1]][item[2]][item[3]] = {}
    if item[4] not in data_dict[item[0]][item[1]][item[2]][item[3]].keys():
       data_dict[item[0]][item[1]][item[2]][item[3]][item[4]] = []
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You probably want something that's not dependent on so many massively nested brackets. This is a problem that using references to a mutable object will work well on.</p>
<pre><code>meta_line = 'abc/pqr123/xy2/yes//T,abc/pqr245/kl3/yes//T,abc/ijk123/op5/yes//T,abc/pqr245/kl4/yes//T'

data = dict()
for item in meta_line.split(','):
    dref = data
    dict_tree = item.strip().replace('//', '/').split('/')
    for i, val in enumerate(dict_tree):
        if val in dref:
            pass
        elif i != len(dict_tree) - 1:
            dref[val] = dict()
        elif i == len(dict_tree) - 1:
           dref[val] = list()
        dref = dref[val]
</code></pre>
<p>Every iteration of the inner loop will move the reference <code>dref</code> down a level, and then reset it on every iteration of the outer loop. At the end, <code>data</code> should hold your nested dict.</p>
<p>Edit: Sorry, I just noticed that you wanted the last level to be a list. This is one solution to that problem, but isn't the best (it will create errors if there's a list in a spot that a later data entry wants to be a dict instead). I would probably choose to build my nested dict and then recursively replace any empty dicts with empty lists afterwards to avoid that problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use The <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" rel="nofollow noreferrer"><code>dict.setdefault</code></a> method in a loop to build the nested dictionary. I'll use the <a href="https://docs.python.org/3/library/pprint.html#module-pprint" rel="nofollow noreferrer"><code>pprint</code></a> module to display the output. Note that <code>pprint.pprint</code> sorts dictionary keys before the output is computed.</p>
<pre><code>from pprint import pprint

data = '''\
abc/pqr123/xy2/yes//T
abc/pqr245/kl3/yes//T
abc/ijk123/op5/yes//T
abc/pqr245/kl4/yes//T
'''.splitlines()

nested_dict = {}

for row in data:
    d = nested_dict
    keys = [s for s in row.split('/') if s]
    for key in keys[:-1]:
        d = d.setdefault(key, {})
    d[keys[-1]] = []

pprint(nested_dict)
</code></pre>
<p><strong>output</strong></p>
<pre><code>{'abc': {'ijk123': {'op5': {'yes': {'T': []}}},
         'pqr123': {'xy2': {'yes': {'T': []}}},
         'pqr245': {'kl3': {'yes': {'T': []}}, 'kl4': {'yes': {'T': []}}}}}
</code></pre>
</div>
<span class="comment-copy">BTW, your expected output isn't nested correctly.</span>
<span class="comment-copy">Thank you. I really appreciate it. Will try this out.</span>
