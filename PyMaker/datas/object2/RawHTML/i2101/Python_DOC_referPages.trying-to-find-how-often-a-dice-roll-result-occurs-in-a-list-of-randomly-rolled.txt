<div class="post-text" itemprop="text">
<p>I am trying to find the occurrences of each number for sides going 1 up to the number of sides on a dice roll. I would like the program to find the number of occurrences for each number that is in <code>listRolls</code>. </p>
<p>Example: if there were a 6 sided dice then it would be 1 up to 6 and the list would roll the dice x amount of times and I would like to find how many times the dice rolled a 1 so on and so forth. </p>
<p>I am new to python and trying to learn it! Any help would be appreciated!</p>
<pre><code>import random
listRolls = []

# Randomly choose the number of sides of dice between 6 and 12
# Print out 'Will be using: x sides' variable = numSides
def main() :
   global numSides
   global numRolls

   numSides = sides()
   numRolls = rolls()

rollDice()

counterInputs()

listPrint()


def rolls() :
#    for rolls in range(1):
###################################
##    CHANGE 20, 50 to 200, 500  ##
##
    x = (random.randint(20, 50))
    print('Ran for: %s rounds' %(x))
    print ('\n')
    return x

def sides():
#    for sides in range(1):
    y = (random.randint(6, 12))
    print ('\n')
    print('Will be using: %s sides' %(y))
    return y

def counterInputs() :
    counters = [0] * (numSides + 1)   # counters[0] is not used.
    value = listRolls

#    if value &gt;= 1 and value &lt;= numSides :
#         counters[value] = counters[value] + 1

for i in range(1, len(counters)) :
  print("%2d: %4d" % (i, value[i]))

print ('\n')

#  Face value of die based on each roll (numRolls = number of times die is 
thrown).
#  numSides = number of faces)
def rollDice():     
    i = 0
    while (i &lt; numRolls):
        x = (random.randint(1, numSides))
        listRolls.append(x)
#            print (x)   
        i = i + 1
#        print ('Done')

def listPrint():
    for i, item in enumerate(listRolls):
        if (i+1)%13 == 0:
            print(item)
    else:
        print(item,end=', ')
print ('\n')





main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Fastest way (I know of) is using <code>Counter()</code> from collections (see bottom for dict-only replacement):</p>
<pre><code>import random

from collections import Counter

# create our 6-sided dice
sides = range(1,7)  
num_throws = 1000

# generates num_throws random values and counts them
counter = Counter(random.choices(sides, k = num_throws))

print (counter) # Counter({1: 181, 3: 179, 4: 167, 5: 159, 6: 159, 2: 155})
</code></pre>
<ul>
<li><p><a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter([iterable-or-mapping])</code></a>) is a specialized dictionary that counts the occurences in the iterable you give it. </p></li>
<li><p><a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices(population, weights=None, *, cum_weights=None, k=1)</code></a> uses the given iterable (a range(1,7) == 1,2,3,4,5,6 and draws <code>k</code> things from it, returning them as list. </p></li>
<li><p><a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer"><code>range(from,to[,steps])</code></a> generates a immutable sequence and makes <code>random.choices</code> perform even better then when using a list.</p></li>
</ul>
<hr/>
<p>As more complete program including inputting facecount and throw-numbers with validation:</p>
<pre><code>def inputNumber(text,minValue):
    """Ask for numeric input using 'text' - returns integer of minValue or more. """
    rv = None
    while not rv:
        rv = input(text)
        try:
            rv = int(rv)
            if rv &lt; minValue:
                raise ValueError
        except:
            rv = None
            print("Try gain, number must be {} or more\n".format(minValue))
    return rv


from collections import Counter
import random

sides = range(1,inputNumber("How many sides on the dice? [4+] ",4)+1)  
num_throws = inputNumber("How many throws? [1+] ",1)
counter = Counter(random.choices(sides, k = num_throws))

print("")
for k in sorted(counter):
    print ("Number {} occured {} times".format(k,counter[k])) 
</code></pre>
<p>Output:</p>
<pre><code>How many sides on the dice? [4+] <b>1</b>
Try gain, number must be 4 or more  

How many sides on the dice? [4+] <b>a</b>
Try gain, number must be 4 or more  

How many sides on the dice? [4+] <b>5</b>
How many throws? [1+] <b>-2</b>
Try gain, number must be 1 or more  

How many throws? [1+] <b>100</b>    

Number 1 occured 22 times
Number 2 occured 20 times
Number 3 occured 22 times
Number 4 occured 23 times
Number 5 occured 13 times</code></pre>
<p>You are using python 2.x way of formatting string output, read about <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>format(..)</code></a> and its <a href="https://docs.python.org/3/library/string.html#format-examples" rel="nofollow noreferrer">format examples</a>.</p>
<p>Take a look at the very good answers for validating input from user: <a href="https://stackoverflow.com/questions/23294658/asking-the-user-for-input-until-they-give-a-valid-response">Asking the user for input until they give a valid response</a></p>
<hr/>
<p>Replacement for <code>Counter</code> if you aren't allowed to use it:</p>
<pre><code># create a dict
d = {}

# iterate over all values you threw
for num in [1,2,2,3,2,2,2,2,2,1,2,1,5,99]:
    # set a defaultvalue of 0 if key not exists
    d.setdefault(num,0)
    # increment nums value by 1
    d[num]+=1

print(d)  # {1: 3, 2: 8, 3: 1, 5: 1, 99: 1}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could trim this down a bit using a <code>dictionary</code>. For stuff like dice I think a good option is to use <code>random.choice</code> and just draw from a list that you populate with the sides of the dice.  So to start, we can gather <code>rolls</code> and <code>sides</code> from the user using <code>input()</code>. Next we can use the <code>sides</code> to generate our list that we pull from, you could use <code>randint</code> method in place of this, but for using <code>choice</code> we can make a list in <code>range(1, sides+1)</code>.  Next we can initiate a dictionary using <code>dict</code> and make a dictionary that has all the sides as keys with a value of <code>0</code>.  Now looks like this <code>d = {1:0, 2:0...n+1:0}</code>.From here now we can use a <code>for</code> loop to populate our dictionary adding <code>1</code> to whatever side is rolled.  Another for loop will let us print out our dictionary. Bonus. I threw in a <code>max</code> function that takes the items in our <code>dictionary</code> and sorts them by their <code>values</code> and returns the largest <code>tuple</code> of <code>(key, value)</code>. We can then print a most rolled statement.</p>
<pre><code>from random import choice

rolls = int(input('Enter the amount of rolls: '))
sides = int(input('Enter the amound of sides: '))
die = list(range(1, sides+1))
d = dict((i,0) for i in die) 

for i in range(rolls):
    d[choice(die)] += 1

print('\nIn {} rolls, you rolled: '.format(rolls))
for i in d:
    print('\tRolled {}: {} times'.format(i, d[i]))

big = max(d.items(), key=lambda x: x[1])
print('{} was rolled the most, for a total of {} times'.format(big[0], big[1]))
</code></pre>
<blockquote>
<pre><code>Enter the amount of rolls: 5
Enter the amound of sides: 5

In 5 rolls, you rolled: 
  Rolled 1: 1 times
  Rolled 2: 2 times
  Rolled 3: 1 times
  Rolled 4: 1 times
  Rolled 5: 0 times
2 was rolled the most, for a total of 2 times
</code></pre>
</blockquote>
</div>
<span class="comment-copy">What if you didn’t want the user input and it was to be randomly generated for all of them?</span>
<span class="comment-copy">@Shakespeareeee You could just assign whatever you want to <code>rolls =</code> and <code>sides =</code>  still will function the same</span>
<span class="comment-copy">I’m trying to make the output say “1: x amount of times rolled 2: x amount of times rolled” so on and so forth... I’ve been stuck on it for quite a while. I’m at a loss unfortunately.</span>
<span class="comment-copy">@Shakespeareeee updated</span>
