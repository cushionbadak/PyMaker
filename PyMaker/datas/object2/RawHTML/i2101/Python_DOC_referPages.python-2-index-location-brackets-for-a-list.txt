<div class="post-text" itemprop="text">
<pre><code>list1 = [1, 2, 3, 4]  
element = list1[1:][1]   
print(element)
</code></pre>
<p>Why does it print 3? </p>
<p>How is this evaluated? Does it first take the elements of list1 that are from index 1: then it takes the 1 index of that?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">Python's grammar</a> specifies how it is evaluated, since it constructs a syntax tree of your program.</p>
<p>Without going much into technical detail, such indexing is <em>left recursive</em>. This means that:</p>
<pre><code>foo[bar][qux]
</code></pre>
<p>is short for:</p>
<pre><code>(foo[bar])[qux]
</code></pre>
<p>so such indices are evaluated left-to-right.</p>
<p>It is evaluated  like:</p>
<pre><code>list1 = [1, 2, 3, 4]
temp = list1[1:]    # create a sublist starting from the second item (index is 1)
element = temp[1]   # obtain the second item of temp (index is 1)
</code></pre>
<p>(of course in reality, no <code>temp</code> <em>variable</em> is created, but the list itself is a real <em>object</em> stored in memory, and thus also might change state, etc.).</p>
<p>So first we slice starting from the second item, this results in a list <code>[2, 3, 4]</code>, and then we obtain the <em>second</em> item of <em>that</em> list, so <code>3</code>.</p>
</div>
<span class="comment-copy">python evaluates from left to right in that case.</span>
<span class="comment-copy">Which part don't you understand, <code>[1:]</code> or <code>[1]</code>?  I think that you think <code>list1[1:]</code> is <code>[3, 4]</code>, which it's not.</span>
<span class="comment-copy"><code>[1:]</code> is a slice of your list that starts at index one and goes to the end of the list (indices start at zero normally). So this produces <code>[2,3,4]</code> but then you ask for the middle element of that list with <code>[1]</code>, which is <code>3</code>. Recall that the list index starts at <code>0</code>.</span>
<span class="comment-copy">Thank you for explaining, very helpful!</span>
<span class="comment-copy"><i>of course in reality, no temp variable is created</i> - well it <i>is</i> created but isn't bound to anything so just doesn't remain available at the end of the statement.</span>
<span class="comment-copy">@JonClements: well I think it does not create a <i>variable</i>, only an <i>accumulator</i>. For example you can not inspect the call-stack and see the intermediate result as a (named) identifier.</span>
<span class="comment-copy">@WillemVanOnsem nope... a new list is created by slicing - so if you had a 1000 element list, you create a new one that's 999 elements, then index in to that... the 999 list isn't bound to anything so is free to be garbage collected at the end of the statement... but it's still created...</span>
<span class="comment-copy">@JonClements: yes, but that is - I think - an object, not a <i>variable</i>. A variable - based on how I learned it in computer science classes - is a "symbolic name associated to a value".</span>
