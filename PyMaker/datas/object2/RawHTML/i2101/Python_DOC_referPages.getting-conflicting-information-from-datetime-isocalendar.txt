<div class="post-text" itemprop="text">
<p>I have a list that gives me the weekday (1-7 as if Monday-Sunday) and the week number for a given year. I need to convert that info to a given date.</p>
<p>So, I wrote a simple script that takes three arguments:
1. year
2. weekday
3. weeknumber</p>
<p>and then finds out the date.</p>
<p>My script basically iterates over all days of the given year, and creates a datetime object where I then extract isocalendar()[1] to compare it to the weeknumber.</p>
<p>I found that if I give the input 2017 7 52 I get two outputs!</p>
<p>In its most basic essence this is what happens:</p>
<pre><code>#!/Library/Frameworks/Python.framework/Versions/3.7/bin/python3

import datetime

def print_dt(year, month, day):
    dt = datetime.date(year, month, day)
    print("%d-%d-%d (%d) -&gt; week# %d" % (year, month, day, dt.weekday(), dt.isocalendar()[1]))

print_dt(2017, 1, 1)
print_dt(2017, 12, 31)
</code></pre>
<p>And the output is the same:</p>
<pre><code>Anibals-iMac:RPEG anibal$ ./findDate-fixed-date.py
2017-1-1 (6) -&gt; week# 52
2017-12-31 (6) -&gt; week# 52
</code></pre>
<p>How's that possible? That would mean that week 52 in year 2017 has two day #6, i.e., two different Sundays. This situation is causing problems for my script. </p>
<p>Any idea on how to get around this? </p>
<p>My original problem is that I have events given in YYYYMMDD and I need to group them by week# by year. So, that I can say that X number of events occurred on week#4 of year 2017. With the situation above it doesn't work when it comes down to week 52 since there's more than one solution to a YYYYMMDD.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are mixing up ISO calendar years and Gregorian calendar years.  </p>
<p>The date <code>2017-1-1</code> is day 7 of week 52 of year 2016 in the ISO calendar.  </p>
<p>The ISO calendar defines the first week of an ISO calendar year to be the one containing the first Thursday of the corresponding Gregorian calendar year.  This could be anywhere from 1st to 7th January.  As ISO numbers days with Monday = 1 to Sunday = 7, this means that for up to three days around each New Year the Gregorian calendar year and ISO calendar year of a date do not agree. </p>
<p>January 1st 2015 fell on a Thursday, so the Monday, Tuesday and Wednesday before it have ISO calendar year 2015 despite being in December 2014.  Similarly, January 7th 2016 fell on a Thursday, and Friday January 1st to Sunday January 3rd 2016 have ISO calendar year 2015 despite being in 2016.</p>
<p>Your script appears to be taking a year in the Gregorian calendar, iterating through all days of this Gregorian calendar year and looking for the day with the matching day-of-week and ISO week-number.  What you have found out is that the three values (Gregorian year, ISO week-number ISO day-of-week) do not uniquely identify a date.  Your script needs to take into account the fact that ISO calendar years and Gregorian calendar years do not always agree and match on ISO calendar year instead of Gregorian calendar year.  One way to do this is to:</p>
<ul>
<li>include the last three days of the previous Gregorian calendar year and the first three days of the next Gregorian calendar year in the range of dates you search through, and</li>
<li>as well as matching on ISO week number and ISO day of week, ensure that the ISO year matches too.  The ISO year is in <code>dt.isocalendar()[0]</code>.</li>
</ul>
<p>Or, as an alternative, you could avoid the ISO calendar system altogether and instead consider something like the following:</p>
<pre><code>def get_week_and_day(year, month, day):
    wday_of_jan_1 = datetime.date(year, 1, 1).timetuple().tm_wday
    daytuple = datetime.date(year, month, day).timetuple()
    wday = daytuple.tm_wday
    week = (daytuple.tm_yday - 1 + wday_of_jan_1) // 7 + 1
    return (week, wday)
</code></pre>
<p>Given a year, month and day this will return the week-of-the-year and day-of-week, with weeks starting on Monday (as per <a href="https://docs.python.org/3/library/time.html#time.struct_time" rel="nofollow noreferrer"><code>time.struct_time</code></a>) and week 1 being the week that January 1 falls in.  Weeks normally go up to 53 but if December 31 of a leap year falls on a Monday (as it did in 2012) this day will have week number 54.</p>
<p>This works by using the <a href="https://docs.python.org/3/library/datetime.html#datetime.date.timetuple" rel="nofollow noreferrer"><code>date.timetuple()</code></a> method to get the weekday and day-of-year of a date, plus also the day-of-the-week of January 1 of that year.  In the calculation of <code>week</code>, we:</p>
<ul>
<li>Subtract 1 from the day-of-the-year of the given date (<code>daytuple.tm_yday</code>), so that January 1 is <code>0</code>, January 2 is <code>1</code> and so on.</li>
<li>Add to this the day-of-the-week of January 1.  We do this because the day-of-the-week of January 1 is also the number of days in the first week of the year that are 'lost' to the previous year.  For example, if January 1 falls on a Wednesday, <code>wday_of_jan_1</code> will be 2, the Monday and Tuesday before it will be missing from week 1 and hence the first week will only have 5 days in it.</li>
<li>The calculations so far give us number of days between the given date and the first Monday on or before January 1.  We can then divide this by 7 to get the number of whole weeks since this Monday, and finally add 1 so that January 1 is in week 1 rather than week 0.</li>
</ul>
<p>This approach also avoids looping over an entire year's worth of dates and performing calculations on them.</p>
</div>
<span class="comment-copy">It looks like an ISO weeks near the beginning and end of a given year can include days in the previous or next one.  Look closely at the illustrations <a href="https://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm" rel="nofollow noreferrer">shown here</a> (and read the associated text, of course).</span>
<span class="comment-copy">But I'm using the same call. I'm not looking at the Gregorian calendar here. I'm looking at the ISO calendar (since there doesn't seem to be a way to get the Gregorian one). If you look at my code, I'm using the same code (ISO) and given two different inputs I get the same output - which shouldn't be the case.</span>
<span class="comment-copy">@AnibalJodorcovsky: I've expanded my answer to explain a bit more about ISO and Gregorian calendar years, and how you could modify your script to fix the problem you have.</span>
<span class="comment-copy">wow, nice answer. I understand now better what's happening, although I'm not sure how to fix my issue. I have events that occur in YYYYMMDD format. I need to know how many events occur per week per year. So, I create a datetime object, extract the week number and then create a map where the key is the year-week#-weekday. However, due to this issue with isocalendar I end up counting events in 2017-1-1 and 2017-12-31 together when I shouldn't. Is there another method I can use so that I don't have this problem?</span>
<span class="comment-copy">@AnibalJodorcovsky: you can try the function I've included in another edit to my answer.  It avoids the ISO calendar altogether, which you seem to be fighting against anyway.  Maybe it's of interest to you, maybe it isn't.</span>
