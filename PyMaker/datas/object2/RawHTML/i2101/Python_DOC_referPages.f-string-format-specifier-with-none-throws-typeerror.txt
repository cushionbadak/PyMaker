<div class="post-text" itemprop="text">
<p>Using plain f-strings with a NoneType object works:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; a = None
&gt;&gt;&gt; f'{a}'
'None'
</code></pre>
<p>However, when using a format specifier, it breaks---as does str.format():</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; f'{a:&gt;6}'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported format string passed to NoneType.__format__

&gt;&gt;&gt; '{:&gt;6}'.format(a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported format string passed to NoneType.__format__
</code></pre>
<p>Unexpectedly, (for me, at least) the old C-style string formatting works:</p>
<pre class="lang-py prettyprint-override"><code>&gt;&gt;&gt; '%10s' % a
'      None'
</code></pre>
<p>What is going on here? I don't understand why <code>f'{a:&gt;6}'</code> doesn't evaluate to <code>'  None'</code>. Why should a format specifier break it?</p>
<p>Is this a bug in python? If it is a bug, how would I fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>None</code> doesn't support format specifiers. It's up to each object type to determine how it wants to handle format specifiers, and <a href="https://docs.python.org/3/reference/datamodel.html#object.__format__" rel="nofollow noreferrer">the default is to reject them</a>:</p>
<blockquote>
<p>The <code>__format__</code> method of <code>object</code> itself raises a TypeError if passed any non-empty string.</p>
</blockquote>
<p><code>None</code> inherits this default.</p>
<p>You seem to be expecting <code>None</code> to handle format specifiers the same way strings do, where <code>'{:&gt;6}'.format('None') == '  None'</code>. It kind of sounds like you expect all types to handle format specifiers the way strings do, or you expect the string behavior to be the default. The way strings handle format specifiers is specific to strings; other types have their own handling.</p>
<hr/>
<p>You might be thinking, hey, why doesn't <code>%10s</code> fail too? First, the <code>s</code> requests that the argument be converted to a string by <code>str</code> before any further processing. Second, all conversion specifier handling in printf-style string formatting is performed by <code>str.__mod__</code>; it never delegates to the arguments to figure out what a conversion specifier means.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>None</code> is not a string, so <code>f'{None:&gt;6}'</code> makes no sense.  You can convert it to a string with <code>f'{None!s:&gt;6}'</code>.  <code>!a</code>, <code>!s</code>, and <code>!r</code> call <code>ascii()</code>, <code>str()</code>, and <code>repr()</code> respectively on an object.</p>
</div>
<span class="comment-copy">I bet your answer is in 'NoneType.__format__'</span>
<span class="comment-copy">@JeffCharter do you know where that is defined in the python source? I tried searching and couldn't find it</span>
<span class="comment-copy">It's not clear what you're trying to ask. None of this is a bug, if that's what you're wondering.</span>
<span class="comment-copy">@user2357112 I don't understand why this should be expected behavior. <code>None.__repr__()</code> and <code>None.__str__()</code> give <code>'None'</code>, so it seems to me that the f-string should be able to handle a format specifier.</span>
<span class="comment-copy">cpython/Objects/object.c:1491</span>
<span class="comment-copy">Dates and times are a great example of your last point.</span>
<span class="comment-copy">I have a good workaround, but just for the sake of learning, is there a way to override <code>NoneType.__format__</code>? I assume not, since <code>None</code> is a singleton.</span>
<span class="comment-copy">@reynoldsnlp: You can't, not because <code>None</code> is a singleton, but because it's implemented in C. (If you keep looking, you'll find suggestions to use the <code>forbiddenfruit</code> module. That module is fairly naively implemented and doesn't know how to fix some of the deeper internals it breaks, like C-level slots and the type attribute cache; you'll get a lot of weird segfaults and heisenbugs if you rely on it.)</span>
<span class="comment-copy">To agree, <code>%s</code> is roughly equivalent to <code>{!s}</code>, but by no means <code>{}</code> for the general case.</span>
