<div class="post-text" itemprop="text">
<p>How to make the following code more compact and efficient.</p>
<p>Here, the code was to find the position where certain numerical value resides in the list.
For example, given set of number</p>
<pre><code>ListNo = [[100,2,5], [50,10], 4, 1, [6,6,500]]
</code></pre>
<p>The value of 100, 50 and 500 was in the position of 0,3 and 9, respectively.</p>
<p>The testing code was as follows</p>
<pre><code>ListNo = [[100,2,5], [50,10], 4, 1, [6,6,500]]
NumberedList = ListNo
Const = 0
items = 0

for i, item in enumerate(ListNo):
    MaxRange = len(item) if isinstance(item, list) else 1

    for x in range(0, MaxRange):
        if MaxRange &gt; 1:
            NumberedList[i][x] = Const
        else:
            NumberedList[i] = Const
        Const = Const + 1

print(NumberedList)
</code></pre>
<blockquote>
<blockquote>
<p>[[0, 1, 2], [3, 4], 5, 6, [7, 8, 9]]</p>
</blockquote>
</blockquote>
<p>My question is, whether there is another option to make this code more compact and efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.count</code>:</p>
<pre><code>from itertools import count
i = count()
print([[next(i) for _ in range(len(l))] if isinstance(l, list) else next(i) for l in ListNo])
</code></pre>
<p>This outputs:</p>
<pre><code>[[0, 1, 2], [3, 4], 5, 6, [7, 8, 9]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A recursive solution would be more elegant, and handle more cases:</p>
<pre><code>def nested_list_ordinal_recurse(l, it):
    if isinstance(l, list):
        return [nested_list_ordinal_recurse(item, it) for item in l]
    else:
        return next(it)

def nested_list_ordinal(l, _it=None):
    return nested_list_ordinal_recurse(l, itertools.count())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>ListNo = [[100,2,5], [50,10], 4, 1, [6,6,500]];
count=-1
def counter(l=[]):
     global count
     if l:
      return [counter() for i in l]
     else:
         count+=1
         return count
print [counter(item) if isinstance(item, list) else counter()  for item in ListNo ]
</code></pre>
<p>Without iter tools </p>
</div>
<span class="comment-copy">Fails for <code>ListNo = [1, [2], 3]</code></span>
<span class="comment-copy">I dont get you, I can run the code w/o problem at my side</span>
<span class="comment-copy">What exactly are you trying to do? Find the index of a certain item in a list?</span>
<span class="comment-copy">@RodneyPetrusbalandong: It outputs <code>[0, 1, 2]</code>, but should output <code>[0, [1], 2]</code></span>
<span class="comment-copy">Thanks, that look more elegant</span>
<span class="comment-copy">Just curious, why the need of, i = count(), instead of i=0?</span>
<span class="comment-copy">This is to make use of the iterator that <code>itertools.count()</code> returns, so that when <code>next(i)</code> is called, the next number in the sequence is returned. Please refer to the <a href="https://docs.python.org/3/library/itertools.html#itertools.count" rel="nofollow noreferrer">documentation</a> of <code>itertools.count()</code> for details.</span>
<span class="comment-copy">haha just arrived at the same solution. Yours is a bit more readable. Nice!</span>
