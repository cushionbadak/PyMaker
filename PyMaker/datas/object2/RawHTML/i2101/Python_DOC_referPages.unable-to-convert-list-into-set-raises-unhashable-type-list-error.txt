<div class="post-text" itemprop="text">
<p>So I'm trying to find all sub-lists of a list and here is what I have now. I'm new to Python and I don't understand why " Q3_ans=set(ans)" raises an error. I've tried to convert a list to set before and it works.</p>
<pre><code>def f2(seq):
    '''
    This is the base case of the recursion from function all_sublists
    '''
    assert len(seq)==2
    assert isinstance(x,list)
    a,b=seq
    return [[a],[b],[a,b]]


def all_sublists(x):
    '''
    This function will generate all of the sublists of a list, not including the empty one, using recursion
    '''
    assert isinstance(x,list)
    ans=[]
    for i in range(0,len(x)-1):
        for j in range(1,len(x)):
            temp=[x[i],x[j]]
            temp=[f2(temp)]
            ans.extend(temp)
    Q3_ans=set(ans) 
    return Q3_ans
</code></pre>
<p>Here is the error when I run my code
    y=[1,2,3,4,5]</p>
<pre><code>all_sublists(y)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-108-f8b1bb0a7001&gt; in &lt;module&gt;
----&gt; 1 all_sublists(y)

&lt;ipython-input-106-84f4f752e98e&gt; in all_sublists(x)
     10             temp=[f2(temp)]
     11             ans.extend(temp)
---&gt; 12     Q3_ans=set(ans)
     13     return Q3_ans

TypeError: unhashable type: 'list'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you can figure out why, immutable types like lists can't be hashable, so can't be converted to a <code>set</code>. You can try returning <code>tuple</code> instead; an immutable counterpart for <code>list</code>:</p>
<pre><code>def f2(seq):
    assert len(seq)==2
    assert isinstance(x, tuple) # what's `x` actually?
    a, b = seq
    return ((a), (b), (a,b))

def all_sublists(x):
    assert isinstance(x, list)
    ans = []
    for i in range(0, len(x) - 1):
        for j in range(1, len(x)):
            temp = (x[i], x[j])
            temp = [f2(temp)]
            ans.extend(temp)
    Q3_ans = set(tuple(ans))
    return Q3_ans
</code></pre>
<p>then</p>
<pre><code>all_sublists([1, 2, 3])
</code></pre>
<p>You can read more about <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow noreferrer"><code>tuple</code></a> type in the documentation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the essence of the problem:</p>
<pre><code>&gt;&gt;&gt; set([[["a"],["b"],["a","b"]]])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>So, what does that mean?</p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>set([iterable])</code></a></p>
<blockquote>
<p>Return a new set ... object whose elements are taken from iterable. <strong>The elements of a set must be hashable</strong>.</p>
</blockquote>
<p><a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow noreferrer"><em>hashable</em></a></p>
<blockquote>
<p>An object is hashable if it has a hash value which never changes
  during its lifetime (it needs a <code>__hash__()</code> method), and can be
  compared to other objects (it needs an <code>__eq__()</code> method). Hashable
  objects which compare equal must have the same hash value.</p>
<p>Hashability makes an object usable as a dictionary key and a set
  member, because these data structures use the hash value internally.</p>
<p>All of Pythonâ€™s immutable built-in objects are hashable; <strong>mutable
  containers (such as lists or dictionaries) are not</strong>.</p>
</blockquote>
<p>The keywords here are <a href="https://docs.python.org/3/glossary.html#term-mutable" rel="nofollow noreferrer"><em>mutable</em></a></p>
<blockquote>
<p>Mutable objects can change their value but keep their id(). </p>
</blockquote>
<p>and <a href="https://docs.python.org/3/glossary.html#term-immutable" rel="nofollow noreferrer"><em>immutable</em></a></p>
<blockquote>
<p>An object with a fixed value. Immutable objects include numbers,
  strings and tuples. Such an object cannot be altered. A new object has
  to be created if a different value has to be stored. They play an
  important role in places where a constant hash value is needed, for
  example as a key in a dictionary.</p>
</blockquote>
<p>So, you can't use a <code>list</code> as <code>set</code> element. A <code>tuple</code> would work:</p>
<pre><code>&gt;&gt;&gt; set([(("a"),("b"),("a","b"))])
{('a', 'b', ('a', 'b'))}
</code></pre>
</div>
<span class="comment-copy">I wanted to do recursion at first but then I changed my mind, please don't mind the comment</span>
<span class="comment-copy">What's the error you see? Please provide full traceback <a href="https://stackoverflow.com/posts/52805262/edit">in your question</a>.</span>
<span class="comment-copy">Your list contains lists, which are not hashable.</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/13675296/python-typeerror-unhashable-type-list">Python: TypeError: unhashable type: 'list'</a></span>
