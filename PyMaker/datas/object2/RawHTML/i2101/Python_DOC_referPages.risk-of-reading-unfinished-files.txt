<div class="post-text" itemprop="text">
<p>I have been executing a piece of code for a while now and it never ran into an error. There is however a seemingly dangerous part in the code and since it is a multi threaded program it might be sheer luck that it has not crashed yet.</p>
<p>My program contains two threads. One is writing files and the other is constantly scanning for these files which it then reads and processes further. My concern is that the second thread might try to read a file that the first thread has not yet fully written to the disk, causing it to crash.</p>
<p>It seems to be going alright though. Is this sheer luck or is the filename only appearing once the file has been fully written to the disk?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, it sounds like you have a <a href="https://en.wikipedia.org/wiki/Race_condition#Software" rel="nofollow noreferrer">race condition</a>. You need to ensure that the reader does not try to read more than has been written, or at least handle that error in some way.</p>
<p>My preferred way of solving this sort of problem is to use a threadsafe <a href="https://docs.python.org/3/library/queue.html?highlight=queue" rel="nofollow noreferrer"><code>queue</code></a>. The writing thread can place the name or path of the file onto the queue <em>after</em> it has finished writing. The reading thread waits for a new filename on the queue (using <code>queue.get()</code>) and then processes the file.</p>
<p>You probably want some mechanism of safely shutting down the reader thread after all files have been processed. A good mechanism is to put a sentinel value on the queue, which will indicate to the reader that its work is done. A common choice for a sentinel is <code>None</code>. So the reading thread would have something like:</p>
<pre><code>while True:
    filename = q.get()
    if filename is None:
        break
    process_file(filename)
</code></pre>
<p>while the writing thread would have a loop that looks like:</p>
<pre><code>for filename in filenames:
    write_file(filename)
    q.put(filename)
q.put(None)
</code></pre>
</div>
<span class="comment-copy">i believe its luck and that the file is created before being written to. so it may be a good idea to have a list or variable thats shared between the 2 threads that says used_file="foo.txt" and if the read thread tries to read filename == used_file, wait till filename != used file? i may be completely wrong and this could be a bad suggestion though!</span>
<span class="comment-copy">I might also try to solve this by using a try. In case the reading of the file fails it will try again on the next run</span>
<span class="comment-copy">the try will handle read errors (which is a good idea) but not the race condition you'd face. ie reading the incomplete file before its finished</span>
<span class="comment-copy">just fyi, this solution wont work where the reader is reading files that have been created before the script was run (or created from another source)</span>
