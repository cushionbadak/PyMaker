<div class="post-text" itemprop="text">
<p>I would like to get a unique process names, PIDs and listening ports from <code>psutil</code>.</p>
<p>I currently have the following code:</p>
<pre><code>names, pids, ports = zip(*[(
    proc.info['name'],
    proc.info['pid'],
    port.laddr.port)
    for proc in psutil.process_iter(attrs=['name', 'pid']) if 'java' in proc.info['name']
    for port in proc.connections() if port.status == psutil.CONN_LISTEN
])
</code></pre>
<p>The problem is that process names and PIDs are duplicated to match the number of items from the nested for loop (ports):</p>
<pre><code>&gt;&gt;&gt; names
('java', 'java', 'java', 'java', 'java', 'java', 'java', 'java')
&gt;&gt;&gt; pids
(15208, 15208, 15208, 15208, 15208, 15208, 15208, 15748)
&gt;&gt;&gt; ports
(7574, 7574, 9462, 9463, 9461, 60588, 9463, 3875)
</code></pre>
<p>I guess I could convert them to <code>sets</code> afterwards but I hope there is a better, more pythonic way to do it without wasting resources.</p>
<p><strong>Update: Thu 11 Oct 14:36:33 UTC 2018</strong></p>
<p>Based on the answer from @Rouven B. I've got the following code now:</p>
<pre><code>names = set()
pids = set()
ports = set()
for proc in psutil.process_iter(attrs=['name', 'pid']):
    if 'java' not in proc.info['name']:
        continue
    names.add(proc.info['name'])
    pids.add(proc.info['pid'])
    for port in proc.connections():
        if port.status == psutil.CONN_LISTEN:
            ports.add(port.laddr.port)
</code></pre>
<p>But I still wonder if there is some another approach, perhaps using one of the functions from <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a list comprehension to get rid of duplicates</p>
<pre><code>names, pids, ports = zip(*[
    (proc.info['name'], proc.info['pid'], port.laddr.port)
    for proc in psutil.process_iter(attrs=['name', 'pid']) if 'java' in proc.info['name']
    if any([port.status == psutil.CONN_LISTEN for port in proc.connections()])
]*)
</code></pre>
<p>But this is not easy to read. How about this</p>
<pre><code>names = []
pids = []
ports = []
for proc in psutil.process_iter(attrs=['name', 'pid']):
    if 'java' not in proc.info['name']:
        continue
    for port in proc.connections():
        if port.status == psutil.CONN_LISTEN:
            names.append(proc.info['name'])
            pids.append(proc.info['pid'])
            ports.append(port.laddr.port)
            break
</code></pre>
<p>But using <code>set</code> to get rid of the duplicates is also a quite pythonic solution I'd say. It shouldn't be too slow and doesn't change the time complexity (in O terms) of the algorithm.</p>
<p><strong>EDIT</strong>: I misunderstood what you wanted to achieve. Here goes another compact approach (still not really readable)</p>
<pre><code>names, pids, ports = zip(*[(
    proc.info['name'],
    proc.info['pid'],
    [conn.laddr.port for conn in proc.connections()
     if conn.status == psutil.CONN_LISTEN])
    for proc in psutil.process_iter(attrs=['name', 'pid'])
    if 'java' in proc.info['name']
])
ports = list(sum(o, ()))  # flatten list of lists of ports
</code></pre>
</div>
<span class="comment-copy">I think using sets is a quite pythonic way of getting unique lists.</span>
<span class="comment-copy">You could also use a for loop instead of a list comprehension and <code>break</code> as soon as you found a connected port. This way you would only add each process once.</span>
<span class="comment-copy">thanks for your help. Your first solutions will return a single random port that can be in any state but I need all <code>listening</code> ports for all collected processes. Your <a href="https://stackoverflow.com/revisions/52759175/2">edit</a> for list comprehension will also change the output to: <code>[('name', PID, random port), (...)]</code> but I need to group them together: <code>[('names'), (PIDs), (ports)]</code></span>
<span class="comment-copy">Oh seem like I misunderstood the problem you want to solve. I've added a new list comprehension that should do what you are looking for. However there can still be duplicates if processes have the same name. To get rid of those you should use sets.</span>
