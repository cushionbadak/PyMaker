<div class="post-text" itemprop="text">
<pre><code>def merge(list1, list2):
    results = []
    while list1 and list2:
        if list1[0] &lt; list2[0]:
            results.append(list1.pop(0))
        else:
            results.append(list2.pop(0))
    results.extend(list1)
    results.extend(list2)
    return results
</code></pre>
<p>Here is the standard algorithm to merge 2 sorted lists into 1. However, how can we merge multiple sorted lists into 1? </p>
<pre><code>l = [[8, 10, 12], [4, 5, 9], [2, 11]]  
merge(l)  
&gt;&gt;&gt; [2, 4, 5, 8, 9, 10, 11, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use your own <code>merge</code> with <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>reduce</code></a>:</p>
<pre><code>from functools import reduce

l = [[8, 10, 12], [4, 5, 9], [2, 11]]

merged = reduce(merge, l)
print(merged)
# [2, 4, 5, 8, 9, 10, 11, 12]
</code></pre>
<p>This has running time <em>O(kn)</em>. You could merge (unique) pairs until you have 1 final list left, which would improve it to <em>O(n log k)</em> (as the number of lists to merge reduces by half every time).</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just sort it using <code>sorted()</code>:</p>
<pre><code>from itertools import chain

l = [[8, 10, 12], [4, 5, 9], [2, 11]]

sorted(chain(*l))
</code></pre>
<p>Gives result:</p>
<pre><code>[2, 4, 5, 8, 9, 10, 11, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could implement <a href="https://en.wikipedia.org/wiki/K-way_merge_algorithm#Direct_k-way_merge" rel="nofollow noreferrer">direct k-way merge</a> using a <a href="https://docs.python.org/3/library/heapq.html" rel="nofollow noreferrer">heap</a> and <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">queues</a>:</p>
<pre><code>import heapq
from collections import deque


def k_merge(*lists):
    queues = [queue for queue in map(deque, lists)]

    heap = []
    for i, lst in enumerate(queues):
        heap.append((lst.popleft(), i))

    heapq.heapify(heap)

    result = []
    while heap:
        value, index = heapq.heappop(heap)
        result.append(value)

        if queues[index]:
            heapq.heappush(heap, (queues[index].popleft(), index))

    return result


print(k_merge(*[[8, 10, 12], [4, 5, 9], [2, 11]]))
</code></pre>
<p><strong>Output</strong></p>
<pre><code>[2, 4, 5, 8, 9, 10, 11, 12]
</code></pre>
<p>If you have <code>k</code> lists and <code>n</code> elements this approach is <code>O(nlogk)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Flatten with list comprehension and then sort   </p>
<pre><code>print(sorted([j for i in l for j in i]))
# [2, 4, 5, 8, 9, 10, 11, 12]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from Queue import PriorityQueue

class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        head = point = ListNode(0)
        q = PriorityQueue()
        for l in lists:
            if l:
                q.put((l.val, l))
        while not q.empty():
            val, node = q.get()
            point.next = ListNode(val)
            point = point.next
            node = node.next
            if node:
                q.put((node.val, node))
        return head.next
</code></pre>
<p>Using a Priority Queue optimizes the comparison process</p>
<ol>
<li><p>Time Complexity: O(n log(k)) where k is the number of linked lists:</p>
<ul>
<li>The comparison cost will be reduced to O(log k) for every pop and insertion to priority queue. But finding the node with the smallest value just costs O(1) time.</li>
</ul></li>
<li><p>Space Complexity:</p>
<ul>
<li>O(n) Creating a new linked list costs O(n) space</li>
<li>O(k) The code above present applies in-place method which cost O(1) space.</li>
<li>And the priority queue(often implemented with heaps) costs O(k) space (it's far less than N in most situations)</li>
</ul></li>
</ol>
</div>
<span class="comment-copy"><a href="https://en.wikipedia.org/wiki/K-way_merge_algorithm" rel="nofollow noreferrer">en.wikipedia.org/wiki/K-way_merge_algorithm</a></span>
<span class="comment-copy">sorting is faster when k approaches sqrt(n)</span>
<span class="comment-copy">@ChristianSloper <i>O(n log k)</i> will always we be at least as good as or better than <i>O(n log n)</i> (as <i>k &lt;= n</i>). But yes, <i>O(kn)</i> with a simple <code>reduce</code> is not that great for large <i>k</i>. The problem with sorting all over again is that you're not taking advantage of the fact that the sub lists are already sorted.</span>
<span class="comment-copy">Agreed, my comment was in response to the code, I didn't see your comment improving to n log k.</span>
<span class="comment-copy">Although, this is O(nlog(n))</span>
<span class="comment-copy">@OlivierMelan√ßon Updated the answer!</span>
