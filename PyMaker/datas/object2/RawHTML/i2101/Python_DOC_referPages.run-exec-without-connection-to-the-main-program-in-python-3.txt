<div class="post-text" itemprop="text">
<p>I am trying to create a python 3 IDE and text editor in python to learn more about <code>tkinter</code>. In it (because it <em>is</em> an IDE) I am attempting to run code entered by the user. The best way that I could find was to use <code>exec()</code>. This works, as show in the IDLE below:</p>
<pre><code>&gt;&gt;&gt; exec(input('PROMPT: '))
PROMPT: print('Hello World') #Entered in by user, this could be anything.
Hello World # &lt;-- Output
</code></pre>
<p>Yet, the <code>exec()</code> function knows about its surroundings.</p>
<pre><code>&gt;&gt;&gt; important_variable = 'important value' #Say that this is important.
&gt;&gt;&gt; exec(input('PROMPT: '))
PROMPT: important_variable = 'meaningless value' #In the IDE, user unknowingly re-assigns to a meaningless value
&gt;&gt;&gt; important_variable #look at the value
'meaningless value' #Yes, the value was changed.
</code></pre>
<p>This is not what I want. I want no connection to the main program, other then values I put in. (for example, changing the <code>sys.stdin</code>, <code>sys.stdout</code>, and <code>sys.stderr</code> values to a <code>tkinter</code> GUI)</p>
<p>My idea was to use the extended use of the <code>exec()</code> function (brought to you be <code>help()</code>):</p>
<pre><code>exec(source, globals=None, locals=None, /)
    Execute the given source in the context of globals and locals.

    The source may be a string representing one or more Python statements
    or a code object as returned by compile().
    The globals must be a dictionary and locals can be any mapping,
    defaulting to the current globals and locals.
    If only globals is given, locals defaults to it.
</code></pre>
<p>I tried to use a empty dict for globals, and I left locals blank. This seems to work at a first look.</p>
<pre><code>&gt;&gt;&gt; important_variable = 'important value'
&gt;&gt;&gt; exec_globals = {} #create a black dict of globals
&gt;&gt;&gt; exec(input('PROMPT: '), exec_globals) #pass in the blank dict
PROMPT: important_variable = 'meaningless value' #change to value?
&gt;&gt;&gt; important_variable #look at the value
'important value' #value is kept!
</code></pre>
<p>However, the program the code was run by is seen in exceptions:</p>
<pre><code>&gt;&gt;&gt; exec_globals = {} #create a black dict of globals
&gt;&gt;&gt; exec(input('PROMPT: '), exec_globals) #pass in the blank dict
PROMPT: THIS SHALL CAUSE A ERROR!
Traceback (most recent call last):
  File "&lt;pyshell#288&gt;", line 1, in &lt;module&gt;
    exec(input('PROMPT: '), exec_globals) # &lt;-- YOU CAN SEE THE CODE
  File "&lt;string&gt;", line 1
    THIS SHALL CAUSE A ERROR!
             ^
SyntaxError: invalid syntax
</code></pre>
<p>How do I prevent this from happening and remove any connection to the program as seen from the code that is entered by the user. I would still like some control in the program however, like changing the values of <code>sys.stdin</code>, <code>sys.stdout</code>, and <code>sys.stderr</code>. Is <code>exec(source, blank_dict)</code> the way to go, or is there a better way to do it?</p>
</div>
<div class="post-text" itemprop="text">
<p>After a lot of digging around, I found the answer to my question.</p>
<p>The answer is in the <code>code</code> module. As the <a href="https://docs.python.org/3/library/code.html" rel="nofollow noreferrer">python documentation on the code module</a> states:</p>
<blockquote>
<p>The code module provides facilities to implement read-eval-print loops in Python.</p>
</blockquote>
<p>Basically tools to simulate code running. The function that the code module gives doesn't only just help with a read-eval-print loop, but it can also run code without a connection to the main program. Take this program called <code>runcode.py</code> for a example:</p>
<pre><code>import code

important_variable = 'important value'

program = '\n'.join([
            'for n in range(10):',
            '    print(n)',
            'important_variable = None',
            'def error(): raise Exception()',
            'error()',
            ])

interpreter = code.InteractiveInterpreter()
interpreter.runsource(program, '&lt;FAKE MEANINGLESS FILE NAME&gt;', 'exec')

print()
print(important_variable)
</code></pre>
<p>Which outputs the following:</p>
<pre><code>0
1
2
3
4
5
6
7
8
9
Traceback (most recent call last):
  File "&lt;FAKE MEANINGLESS FILE NAME&gt;", line 5, in &lt;module&gt; #No connection!
  File "&lt;FAKE MEANINGLESS FILE NAME&gt;", line 4, in error #No connection!
Exception

important value
</code></pre>
<p>If you are reading from a real file, replace <code>'&lt;FAKE MEANINGLESS FILE NAME&gt;'</code> with the absolute path to the file. This will give you a more advanced traceback (error message will include what was on the line)</p>
<p>The great thing is that this works with a setup and end scripts, like so:</p>
<pre><code>import code

program = '\n'.join([
            'for n in range(10):',
            '    print(n)',
            'def error(): raise Exception()',
            'error()',
            ])

interpreter = code.InteractiveInterpreter()

#Setup code. This could change sys.stdin, stdout, etc. and setup variables!
interpreter.runsource('setup_stuff = None', 'whatever name you want', 'exec')

#Run code
interpreter.runsource(program, '&lt;FAKE MEANINGLESS FILE NAME&gt;', 'exec')

#Process Code now that the program is done, this might get the values in local() or something like that.
interpreter.runsource(program, 'whatever name you want', 'exec')
</code></pre>
<p>And that's it!</p>
</div>
