<div class="post-text" itemprop="text">
<p>I was using the below python code:</p>
<pre><code>class A(object):
   def __getattr__(self, name):
       print "__getattr__ : %s" % name
       setattr(self, name, A())
       print self.__dict__
       print getattr(self, name)

 x = A()
 x.a = 1 .  # Works fine.
 print x.a

 x.b.c = 2 # Throws error.
 print x.b.c
</code></pre>
<p>The last part throws the following error:</p>
<pre class="lang-none prettyprint-override"><code>NoneType object has no attribute c.
</code></pre>
<p>Can anyone explain what the error is in the above code as <code>print self.__dict__</code> clearly shows that both <code>a</code> and <code>b</code> have been inserted into the object's dictionary.</p>
<p>My use case is to have an object for which attributes can be dynamically added as and when required. Like I should be able to use:</p>
<pre><code>x = A()
x.a = 1
x.b.c = 2
x.d.e.f.g = 3
</code></pre>
<p>Also, is there any other way to achieve my goal?</p>
<p>Update: Found the error, <code>__getattr__</code> should return a value.</p>
<p><strong>Correct code</strong></p>
<pre><code>class A(object):
   def __getattr__(self, name):
       print "__getattr__ : %s" % name
       x = A()
       setattr(self, name, x)
       print self.__dict__
       print getattr(self, name)
       return x # getattr(self, name)

 x = A()
 x.a = 1 .  # Works fine.
 print x.a

 x.b.c = 2 # Works fine.
 print x.b.c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>__getattr__</code> is called when an attribute is requested for get but is not available from the asked object.</p>
<p>Assuming that <code>x</code> hasn't an <code>a</code>, a call like</p>
<p><code>result = x.a</code></p>
<p>is functionally equivalent to</p>
<p><code>result = getattr(x, "a")</code></p>
<p>which is functionally equivalent to</p>
<p><code>result = type(x).__getattr__(x, "a")</code></p>
<p>which is normally the same as</p>
<p><code>result = x.__getattr__("a")</code></p>
<p>Last two variants only differ if the <code>__getattr__</code> is bound to the object instead of the class (<a href="https://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow noreferrer">which may not work</a>)</p>
<p>As you can see here, <code>__getattr__</code> should return the value that <code>a</code> is meant to have.</p>
<p>It can also set the attribute directly so that further get requests do not call <code>__getattr__</code> again but are handled by Python directly. It depends on the particular use case if this makes sense (in your use case it does).</p>
<p><code>x.b.c = 2</code> translates here normally to something like</p>
<p><code>setattr(x.__getattr__("b"), "c", 2)</code></p>
<p>Again, <code>__getattr__</code> must return here the object on which attribute <code>c</code> is set.</p>
</div>
<span class="comment-copy"><code>__getattr__</code> must return the value of the attribute (the newly created <code>A</code> object)</span>
<span class="comment-copy">@MichaelButscher Thanks a lot, everything works fine now. I wasn't aware <code>__getattr__</code> should return something. Basically i went through this example: <a href="https://chase-seibert.github.io/blog/2013/04/12/getattr-setattr.html" rel="nofollow noreferrer">chase-seibert.github.io/blog/2013/04/12/getattr-setattr.html</a></span>
<span class="comment-copy">@MichaelButscher can you check if the above is the correct way of writing the code as per python standards or some improvements are there?</span>
<span class="comment-copy">Usually, you would here just do something like <code>a = A()</code>, then <code>setattr(self, name, a)</code> and finally <code>return a</code> which is more efficient but your code is ok.</span>
<span class="comment-copy">Thanks for all the help @MichaelButscher.</span>
