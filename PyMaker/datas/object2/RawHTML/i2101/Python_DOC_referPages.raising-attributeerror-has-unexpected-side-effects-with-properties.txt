<div class="post-text" itemprop="text">
<p>Given a contrived Python class:</p>
<pre><code>class Item(object):
    def __getattr__(self, name):
        print("In __getattr__ looking for '{}'".format(name))
        if name.startswith("exists"):
            return "Here's a dummy string"
        message = "'{}' object has no attribute '{}'".format(type(self).__name__, name)
        raise AttributeError(message)

    def thing_a(self):
        return self.thing_b()

    def thing_b(self):
        return self.nonexistent_thing()
</code></pre>
<p>Calling <code>Item().thing_a()</code> produces the expected output:</p>
<pre class="lang-none prettyprint-override"><code>In __getattr__ looking for 'nonexistent_thing'
Traceback (most recent call last):
  File "debug.py", line 13, in &lt;module&gt;
    Item().thing_a()
  File "debug.py", line 8, in thing_a
    return self.thing_b()
  File "debug.py", line 11, in thing_b
    return self.nonexistent_thing()
  File "debug.py", line 5, in __getattr__
    raise AttributeError(message)
AttributeError: 'Item' object has no attribute 'nonexistent_thing'
</code></pre>
<p>However, I really want <code>thing_a</code>, <code>thing_b</code>, and <code>nonexistent_thing</code> to be properties. So, if I change my code to:</p>
<pre><code>class Item(object):
    def __getattr__(self, name):
        print("In __getattr__ looking for '{}'".format(name))
        if name.startswith("exists"):
            return "Here's a dummy string"
        message = "'{}' object has no attribute '{}'".format(type(self).__name__, name)
        raise AttributeError(message)

    @property
    def thing_a(self):
        return self.thing_b

    @property
    def thing_b(self):
        return self.nonexistent_thing
</code></pre>
<p>and call <code>Item().thing_a</code>, I get an unexpected result:</p>
<pre class="lang-none prettyprint-override"><code>In __getattr__ looking for 'nonexistent_thing'
In __getattr__ looking for 'thing_b'
In __getattr__ looking for 'thing_a'
Traceback (most recent call last):
  File "debug.py", line 15, in &lt;module&gt;
    Item().thing_a
  File "debug.py", line 5, in __getattr__
    raise AttributeError(message)
AttributeError: 'Item' object has no attribute 'thing_a'
</code></pre>
<p>Uh-oh... the <code>print()</code> output appears to be the reverse of the execution order, and the message for <code>AttributeError</code> is for <code>thing_a</code>, which does exist.</p>
<p>During my experimentation to figure this out, I discovered that changing <code>AttributeError</code> to a plain old <code>Exception</code> makes everything work ok:</p>
<pre class="lang-none prettyprint-override"><code>In __getattr__ looking for 'nonexistent_thing'
Traceback (most recent call last):
  File "debug.py", line 15, in &lt;module&gt;
    Item().thing_a
  File "debug.py", line 9, in thing_a
    return self.thing_b
  File "debug.py", line 13, in thing_b
    return self.nonexistent_thing
  File "debug.py", line 5, in __getattr__
    raise Exception(message)
Exception: 'Item' object has no attribute 'nonexistent_thing'
</code></pre>
<p>So, it seems <code>AttributeError</code> itself doesn't play well with <code>@property</code>, possibly because it's being caught somewhere by the <code>property</code> object. But <code>AttributeError</code> appears to be the most appropriate exception for <code>__getattr__</code> to raise, and it's not ideal to raise an <code>Exception</code> without subclassing.</p>
<p>Is anyone able to shed some light on this problem, and know of a way to have <code>@property</code> and <code>__getattr__</code> with <code>AttributeError</code> work together in harmony?</p>
<p>I've tried this in Python 2.7 and 3.6.</p>
<p><strong>EDIT:</strong> Added (contrived) logic for <code>__getattr__</code> to respond to if <code>name</code> starts with <code>"exists"</code>. I <strong>do</strong> want it to fail for <code>nonexistent_thing</code>, but I want it to raise <code>AttributeError</code> at the correct time with the correct <code>name</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The missing piece to the puzzle is that <code>@property</code> is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a> (an object which implements <code>__get__</code> / <code>__set__</code> / <code>__del__</code> to participate in attribute lookup).</p>
<p>Implementation of descriptors is done via the <code>__getattribute__</code> magic method.</p>
<p>The important bit of the implementation here from <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer">the docs</a> (emphasis mine):</p>
<blockquote>
<p>Called unconditionally to implement attribute accesses for instances of the class. If the class also defines <code>__getattr__()</code>, the latter will not be called unless <code>__getattribute__()</code> either calls it explicitly <strong>or raises an AttributeError</strong>.</p>
</blockquote>
<p>To illustrate with your example a little further:</p>
<pre><code>class Item(object):
    def __getattribute__(self, name):
        print(f'__getattribute__ {name}')
        try:
            return super().__getattribute__(name)
        except Exception as e:
            print(f'{e} during __getattribute__ {name}')
            raise

    def __getattr__(self, name):
        print("In __getattr__ looking for '{}'".format(name))
        # useful logic here which might return a value...
        message = "'{}' object has no attribute '{}'".format(type(self).__name__, name)
        raise AttributeError(message)

    @property
    def thing_a(self):
        return self.thing_b

    @property
    def thing_b(self):
        return self.nonexistent_thing


Item().thing_a
</code></pre>
<p>The call sequence goes:</p>
<pre><code>- __getattribute__(thing_a)
  - property.__get__(...)
    - thing_a
      - __getattriute__(thing_b)
        - property.__get__(...)
          - thing_B
            - __getattribute__(nonexistent_thing)
            - (raised AE) -&gt; __getattr__(nonexistent_thing)
      - (raised AE) -&gt; __getattr_(thing_b)
- (raised AE) -&gt; getattr(thing_a)
</code></pre>
<p>The calls to <code>__getattr__</code> are in response to <code>AttributeError</code>s during descriptor resolution in <code>__getattribute__</code>.</p>
<p>Here's the output of the above python snippet:</p>
<pre><code>__getattribute__ thing_a
__getattribute__ thing_b
__getattribute__ nonexistent_thing
'Item' object has no attribute 'nonexistent_thing' during __getattribute__ nonexistent_thing
In __getattr__ looking for 'nonexistent_thing'
'Item' object has no attribute 'nonexistent_thing' during __getattribute__ thing_b
In __getattr__ looking for 'thing_b'
'Item' object has no attribute 'thing_b' during __getattribute__ thing_a
In __getattr__ looking for 'thing_a'
Traceback (most recent call last):
  File "t.py", line 25, in &lt;module&gt;
    Item().thing_a
  File "t.py", line 14, in __getattr__
    raise AttributeError(message)
AttributeError: 'Item' object has no attribute 'thing_a'
</code></pre>
</div>
<span class="comment-copy">@jedwards, given that this is a contrived example, I didn't flesh out <code>__getattr__</code> fully. I've added a comment to show where the real logic would go. (Edit: @jedwards has since deleted their comment)</span>
<span class="comment-copy">Pretty important to show that actual logic. In particular, whether it calls the super implementation of not is pretty crucial.</span>
<span class="comment-copy">@MadPhysicist the code is a minimal working example and will fail in and of itself. But, FWIW, my real code doesn't call <code>super()</code>.</span>
<span class="comment-copy">There's nothing special about property being a descriptor. Methods are  descriptors too</span>
<span class="comment-copy">@MadPhysicist there is in this case though, methods don't raise in the <code>__get__</code> call</span>
<span class="comment-copy">You're right. I hadn't considered that.</span>
<span class="comment-copy">Thanks both @Anthony Sottile and @Mad Physicist for the great answers explaining how this problem comes about. Is there a canonical way to fix it, other than using another subclass of <code>Exception</code> instead of <code>AttributeError</code>?</span>
<span class="comment-copy">@tristanm. I am not sure you really have a problem here. If you do <code>x.thing_a</code>, you do <i>not</i> expect to see an error message saying "attribute blah_blah_blah not found". You should not be exposing implementation details and the user should not care <i>why</i> they can't access <code>thing_a</code>. In that sense, the existing error message is correct. If you really want a detailed exception, though, just don't raise an <code>AttributeError</code>.</span>
