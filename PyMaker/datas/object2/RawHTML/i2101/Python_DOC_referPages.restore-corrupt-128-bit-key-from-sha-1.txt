<div class="post-text" itemprop="text">
<p>Disclaimer: This is a section from a uni assignment</p>
<p>I have been given the following AES-128-CBC key and told that up to 3 bits in the key have been changed/corrupt.</p>
<pre><code>d9124e6bbc124029572d42937573bab4
</code></pre>
<p>The original key's SHA-1 hash is provided;  </p>
<pre><code>439090331bd3fad8dc398a417264efe28dba1b60
</code></pre>
<p>and I have to find the original key by trying all combinations of up to 3 bit flips.</p>
<p>Supposedly this is possible in 349633 guesses however I don't have a clue where that number came from; I would have assumed it would be closer to 128*127*126 which would be over 2M combinations, that's where my first problem lies.<br/>
Secondly, I created the python script below containing a triple nested loop (I know, far from the best code...) to iterate over all 2M possibilities however, after completion an hour later, it hadn't found any matches which I really don't understand. </p>
<p>Hoping someone can atleast point me in the right direction, cheers</p>
<pre><code>#!/usr/bin/python2

import sys
import commands

global binary

def inverseBit(index):
    global binary
    if binary[index] == "0":
        return "1"
    return "0"

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print "Usage: bitflip.py &lt;hex&gt; &lt;sha-1&gt;"
        sys.exit()

    global binary
    binary = ""

    sha = str(sys.argv[2])
    binary = str(bin(int(sys.argv[1], 16)))
    binary = binary[2:]
    print binary

    b2 = binary
    tries = 0
    file = open("shas", "w")

    for x in range(-2, 128):
        for y in range(-1,128):
            for z in range(0,128):
                if x &gt;= 0:
                    b2 = b2[:x] + inverseBit(x) + b2[x+1:]
                if y &gt;= 0:
                    b2 = b2[:y] + inverseBit(y) + b2[y+1:]
                b2 = b2[:z] + inverseBit(z) + b2[z+1:]
                #print b2
                hexOut = hex(int(b2,2))
                command = "echo -n \"" + hexOut + "\" | openssl sha1"
                cmdOut = str(commands.getstatusoutput(command))
                cmdOut = cmdOut[cmdOut.index('=')+2:]
                cmdOut = cmdOut[:cmdOut.index('\'')]
                file.write(str(hexOut) + " | " + str(cmdOut) + "\n")
                if len(cmdOut) != 40:
                    print cmdOut
                if cmdOut == sha:
                    print "Found bit reversals in " + str(tries) + " tries. Corrected key:"
                    print hexOut
                    sys.exit()
                b2 = binary
                tries = tries + 1
                if tries % 10000 == 0:
                    print tries
</code></pre>
<p>EDIT:<br/>
Changing for loop to</p>
<pre><code>for x in range(-2, 128):
            for y in range(x+1,128):
                for z in range(y+1,128):
</code></pre>
<p>drastically cuts down on the number of guesses while (I think?) still covering the whole space. Still getting some duplicates and still no luck finding the match though..</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code, if not very efficient, looks fine except for one thing:</p>
<pre><code>hexOut = hex(int(b2,2))
</code></pre>
<p>as the output of <code>hex</code></p>
<pre><code>&gt;&gt;&gt; hex(int('01110110000101',2))
'0x1d85'
</code></pre>
<p>starts with <code>'Ox'</code>, which shouldn't be part of the key. So, you should be fine by removing these two characters.</p>
<p>For the number of possible keys to try, you have:</p>
<ul>
<li>1 with no bit flipped</li>
<li>128 with 1 bit flipped</li>
<li>128*127/2 = 8128 with 2 bits flipped (128 ways to choose the first one, 127 ways to choose the second, and each pair will appear twice)</li>
<li>128*127*126/6 = 341376 with 3 bits flipped (each triplet appears 6 times). This is the number of combinations of 128 bits taken 3 at a time.</li>
</ul>
<p>So, the total is 1 + 128 + 8128 + 341376 = 349633 possibilities.</p>
<p>Your code tests each of them many times. You could avoid a the useless repetitions by looping like this (for 3 bits):</p>
<pre><code>for x in range (0, 128):
    for y in range(x+1, 128):
        for z in range(y+1, 128):
            .....
</code></pre>
<p>You could adapt your trick of starting at -2 with:</p>
<pre><code>for x in range (-2, 128):
    for y in range(x+1, 128):
        for z in range(y+1, 128):
            .... same code you used ...
</code></pre>
<hr/>
<p>You could also generate the combinations with <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertools.combinations</a>:</p>
<pre><code>from itertools import combinations
for x, y, z in combinations(range(128), 3):  # for 3 bits
    ......
</code></pre>
<p>but you'd need a bit more work to manage the cases with 0, 1, 2 and 3 flipped bits in this case.</p>
</div>
<span class="comment-copy">cheers, removing the 0x worked. Also had to remove the trailing 'L'  that was appended to all the hex values for some reason. Looks like I worked out the better method of looping shortly before you made the post, added it in an Edit that you may have missed :)</span>
