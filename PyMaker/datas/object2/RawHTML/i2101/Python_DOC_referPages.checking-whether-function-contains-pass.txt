<div class="post-text" itemprop="text">
<p>I have one parent class <code>P</code> and several child classes. The parent class contains the method <code>doSomething(x)</code> defined only as:</p>
<pre><code>def doSomething(self, x):
    pass
</code></pre>
<p>Now, some of <code>P</code>'s subclasses may have implemented this method, and some have not. Is there any way I can check if <code>doSomething(x)</code> is going to do nothing but <code>pass</code>, at runtime (e.g. if it is implemented, execute it, if not, skip it)?</p>
</div>
<div class="post-text" itemprop="text">
<p>There is no need to do <em>anything</em> here other than just calling <code>doMethod()</code> on the instance. Calling a no-op method is not so costly that detecting when a child class has implemented an override is going to save you anything.</p>
<p>So your number 1 option is to <em>just call the method</em>, and don't worry about it being an empty method. That's what <code>pass</code> is <em>for</em>, to give you an easy parent class method that does nothing.</p>
<p>Next, you state</p>
<blockquote>
<p>Parent class contains method <code>doSomething(x)</code></p>
</blockquote>
<p>You can use this to detect if you have that method still; the underlying function for the bound method is going to be the same object:</p>
<pre><code>hook = instance.doSomething
if hook.__func__ is ParentClass.doSomething:
    # they didn't override the method, so nothing needs to be done.
</code></pre>
<p>Again, I'm not sure why anyone would want to do that, because that test is not going to save you anything over just using <code>instance.doSomething()</code>.</p>
<p>Next, a function that consists solely of the statement <code>pass</code> will be compiled to the same bytecode, always; it's the same bytecode as <code>return None</code>. Compare the bytecode if you must know if a function is empty:</p>
<pre><code>_RETURN_NONE = (lambda: None).__code__.co_code

def is_pass(f):
    return f.__code__.co_code == _RETURN_NONE
</code></pre>
<p>This can be applied to any function or method that, in essence, only ever returns <code>None</code> and does nothing else.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; class P:
...     def doSomething(self, x):
...         pass
...
&gt;&gt;&gt; class Child1(P):
...     def doSomething(self, x):
...         print("We are doing something with {!r}!".format(x))
...
&gt;&gt;&gt; class Child2(P):
...     pass
...
&gt;&gt;&gt; instance1 = Child1()
&gt;&gt;&gt; instance2 = Child2()
&gt;&gt;&gt; instance1.doSomething(42)
We are doing something with 42!
&gt;&gt;&gt; instance2.doSomething(42)
&gt;&gt;&gt; instance1.doSomething.__func__ is P.doSomething
False
&gt;&gt;&gt; instance2.doSomething.__func__ is P.doSomething
True
&gt;&gt;&gt; is_pass(instance1.doSomething)
False
&gt;&gt;&gt; is_pass(instance2.doSomething)
True
&gt;&gt;&gt; def unrelated_function():
...     return 42
...
&gt;&gt;&gt; def another_unrelated_function():
...     pass
...
&gt;&gt;&gt; is_pass(unrelated_function)
False
&gt;&gt;&gt; is_pass(another_unrelated_function)
True
</code></pre>
<p>Note how <code>is_pass()</code> works on any function that uses <code>pass</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your parent method is defined as </p>
<pre><code>def doSomething(x):
    pass
</code></pre>
<p>It does nothing - it is cheaper to just call it instead of verifying if it has been overriden or not. It will be automatically "skipped" because it does nothing in first place.</p>
<p>That said, if you really want to test for it, you can do something like this</p>
<pre><code>if type(some_instance).doSomething is ParentClass.doSomething:
     print('Not overriden')
else:
     print('Function has been overriden, call it'):
     some_instance.doSomething()
</code></pre>
</div>
<span class="comment-copy">Why skip it? It does nothing, so why bother?</span>
<span class="comment-copy">And the ABC module would not help you detect no-op methods either.</span>
<span class="comment-copy">You could return <a href="https://docs.python.org/3/library/constants.html#NotImplemented" rel="nofollow noreferrer"><code>NotImplemented</code></a> instead, or raise a <a href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" rel="nofollow noreferrer"><code>NotImplementedError</code></a>.  The docs for <code>NotImplementedError</code> also mention setting the method to <code>None</code> if that class will never support that method.</span>
