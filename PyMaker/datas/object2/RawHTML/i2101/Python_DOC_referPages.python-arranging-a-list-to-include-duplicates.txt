<div class="post-text" itemprop="text">
<p>I have a list in Python that is similar to:</p>
<pre><code>x = [1,2,2,3,3,3,4,4]
</code></pre>
<p>Is there a way using pandas or some other list comprehension to make the list appear like this, similar to a queue system:</p>
<pre><code>x = [1,2,3,4,2,3,4,3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible, by using <code>cumcount</code> </p>
<pre><code>s=pd.Series(x)
s.index=s.groupby(s).cumcount()
s.sort_index()
Out[11]: 
0    1
0    2
0    3
0    4
1    2
1    3
1    4
2    3
dtype: int64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you split your list into one separate list for each value (groupby), you can then use the <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools recipe</a> <code>roundrobin</code> to get this behavior:</p>
<pre><code>x = ([1, 2, 2, 3, 3, 3, 4, 4])
roundrobin(*(g for _, g in groupby(x)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I'm understanding you correctly, you want to retain all duplicates, but then have the list arranged in an order where you create what are in essence separate lists of unique values, but they're all concatenated into a single list, in order.</p>
<p>I don't think this is possible in a listcomp, and nothing's occurring to me for getting it done easily/quickly in pandas.</p>
<p>But the straightforward algorithm is:</p>
<ul>
<li>Create a different list for each set of unique values: For i in x: if x not in list1, add to list 1; else if not in list2, add to list2; else if not in list3, ad to list3; and so on. There's certainly a way to do this with recursion, if it's an unpredictable number of lists.</li>
<li>Evaluate the lists based on their values, to determine the order in which you want to have them listed in the final list. It's unclear from your post exactly what order you want them to be in. Querying by the value in the 0th position could be one way. Evaluating the entire lists as &gt;= each other is another way.</li>
<li>Once you have that set of lists and their orders, it's straightforward to concatenate them in order, in the final list.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>essentially what you want is pattern, this pattern is nothing but the order in which we found unique numbers while traversing the <code>list x</code> for eg: if <code>x = [4,3,1,3,5]</code> then <code>pattern = 4 3 1 5</code> and this will now help us in filling <code>x</code> again such that <code>output will be [4,3,1,5,3]</code></p>
<pre><code>from collections import defaultdict
x =  [1,2,2,3,3,3,4,4]

counts_dict = defaultdict(int)
for p in x:
    counts_dict[p]+=1

i =0
while i &lt; len(x):
    for p,cnt in counts_dict.items():
        if i &lt; len(x):  
            if cnt &gt; 0:
                x[i] = p
                counts_dict[p]-=1
                i+=1
            else:
                continue
        else:
            # we have placed all the 'p'
            break

print(x) # [1, 2, 3, 4, 2, 3, 4, 3]
</code></pre>
<p><strong>note:</strong> python 3.6+ dict respects insertion order and I am assuming that you are using python3.6+ .</p>
<p>This is what I thought of doing at first but It fails in some cases..</p>
<pre><code>'''
x = [3,7,7,7,4]

i = 1
while i &lt; len(x):
    if x[i] == x[i-1]:
        x.append(x.pop(i))
        i = max(1,i-1)
    else:    
        i+=1

print(x) # [1, 2, 3, 4, 2, 3, 4, 3]


# x =    [2,2,3,3,3,4,4]
# output [2, 3, 4, 2, 3, 4, 3]

# x =    [3,7,1,7,4]
# output [3, 7, 1, 7, 4]

# x =    [3,7,7,7,4]
# output time_out

'''
</code></pre>
</div>
