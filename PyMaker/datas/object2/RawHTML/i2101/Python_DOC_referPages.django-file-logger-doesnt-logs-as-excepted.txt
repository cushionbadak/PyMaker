<div class="post-text" itemprop="text">
<p>I have written a simple django LOGGING in my settings.py and I excepted that to log all error with a traceback in my file. But it doesn't and it just logs errors and everything in one line, but tracebacks are logged into the console.
here is my LOGGING:</p>
<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
            'simple': {
                'format': '{levelname} {asctime} {name} {module}.{funcName}:{lineno} {message}',
                'style': '{',
            },
        },
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': 'logs/debug.log',
            'formatter': 'simple'
        },
    },
    'loggers': {
        '': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}
</code></pre>
<p>can anybody help me to understand why and what to do?
thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>The formatter you are using is "simple" (as defined on the config:</p>
<pre><code> 'formatters': {
        'simple': {
            'format': '{levelname} {asctime} {name} {module}.{funcName}:{lineno} {message}',
            'style': '{',
        },
    },
</code></pre>
<p>So playing around with this is the trick: Have a look at this: <a href="https://docs.python.org/3/library/logging.html#logrecord-attributes" rel="nofollow noreferrer">https://docs.python.org/3/library/logging.html#logrecord-attributes</a></p>
<p>The one you probably want is: <code>{stack_info}</code> </p>
</div>
<div class="post-text" itemprop="text">
<p>To achieve this you can add a custom format and then write a custom filter for it to populate its value:</p>
<pre><code>'formatters': {

    'simple_trace': {
        'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s - %(trace)s'
    },
</code></pre>
<p>Now, CustomFilter should be inherited from logging.Filter something like:</p>
<pre><code>class CustomFilter(logging.Filter):

    def filter(self, log_record):

        def _get_trace():
            trace = ""
            if log_record.levelname in ['ERROR', 'CRITICAL']:
                # Get the recent stack-trace
                trace = traceback.format_exc().strip()
            return json.dumps(trace)

        log_record.trace = _get_trace()
</code></pre>
<p>Like this you can add other format too and just add it's value in log_record.</p>
<p>Finally, we need to inherit handler (in your case-  logging.FileHandler ) and add this custom filter to it.</p>
<pre><code>class CustomHandler(logging.FileHandler):    

    def __init__(self, *args, **kwargs):
        logging.FileHandler.__init__(self, *args, **kwargs)
        self.addFilter(CustomFilter())
</code></pre>
<p>while setting handlers we need to put our CustomHandler in class:</p>
<pre><code>'handlers': {
    'file': {
        'level': 'DEBUG',
        'class': 'logging_custom.CustomHandler', # path to CustomHandler defination
        'filename': 'logs/debug.log',
        'formatter': 'simple_trace'
    },
},
</code></pre>
</div>
<span class="comment-copy">thanks. it worked! but it is written in that link You shouldnâ€™t need to format this yourself. and the other question I have is why it logs in the console too? I haven't difined any console log handler here... @Jmons</span>
<span class="comment-copy">Mm, what it means is that if you use that variable, you don't pass a second formatter in: i.e. if you use something like "line number" you could hten pass in the second level formatter to specify things like leading 0's etc. the "Format" of the <i>logger</i> is different- you're saying which fields you want to be printed out in that log line. <i>generally speaking</i> you dont want a full stack trace on every log line - thats a sign you're doing logging 'wrong', i.e. most log lines are informational rather then just exceptions.</span>
