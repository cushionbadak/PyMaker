<div class="post-text" itemprop="text">
<p>I answered a question here: <a href="https://stackoverflow.com/questions/52719472/comprehension-list-in-python2-works-fine-but-i-get-an-error-in-python3">comprehension list in python2 works fine but i get an error in python3</a></p>
<p>OP's error was using the same variables for max range and indices:</p>
<pre><code>x = 12
y = 10
z = 12
n = 100

ret_list = [ (x,y,z) for x in range(x+1) for y in range(y+1) for z in range(z+1) if x+y+z!=n ]
</code></pre>
<p>This is a Python-3 error only, and related to the scopes that were added to the comprehension to avoid the variables defined here "leaking". Changing the variable names fixes that.</p>
<p>The error is:</p>
<pre><code>UnboundLocalError: local variable 'y' referenced before assignment
</code></pre>
<p>because outer, global <code>y</code> is shadowed by the local scope.</p>
<p>My question is: why do I get the error on <code>y</code> and not on <code>z</code> or <code>x</code> ?</p>
<p>EDIT: If I remove the loop on <code>x</code>, the error moves to <code>z</code>:</p>
<pre><code>&gt;&gt; ret_list = [ (x,y,z) for y in range(y+1) for z in range(z+1) if x+y+z!=n ]
UnboundLocalError: local variable 'z' referenced before assignment
</code></pre>
<p>If I just do one loop:</p>
<pre><code>ret_list = [ (x,y,z) for y in range(y+1) if x+y+z!=n ]
</code></pre>
<p>it works. So I'm suspecting that the first <code>range</code> function is evaluated <em>before</em> all the other expressions, which leaves the value of <code>x</code> intact. But the exact reason is still to be found. Using Python 3.4.3.</p>
</div>
<div class="post-text" itemprop="text">
<p>This behaviour is (implicitly) described in the <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="noreferrer">reference documentation</a> (emphasis mine).</p>
<blockquote>
<p>However, aside from the iterable expression in the leftmost <code>for</code> clause, the comprehension is executed in a separate implicitly nested scope. This ensures that names assigned to in the target list don’t “leak” into the enclosing scope.</p>
<p><strong>The iterable expression in the leftmost <code>for</code> clause is evaluated directly in the enclosing scope and then passed as an argument to the implictly [sic] nested scope.</strong> Subsequent <code>for</code> clauses and any filter condition in the leftmost <code>for</code> clause cannot be evaluated in the enclosing scope as they may depend on the values obtained from the leftmost iterable. For example: <code>[x*y for x in range(10) for y in range(x, x+10)]</code>.</p>
</blockquote>
<p>This means that:</p>
<pre><code>list_ = [(x, y) for x in range(x) for y in range(y)]
</code></pre>
<p>equivalent to: </p>
<pre><code>def f(iter_):
    for x in iter_:
        for y in range(y):
            yield x, y

list_ = list(f(iter(range(x))))
</code></pre>
<p>As the name <code>x</code> in for the leftmost iterable is read in the enclosing scope as opposed to the nested scope then there is no name conflict between these two uses of <code>x</code>. The same is not true for <code>y</code>, which is why it is where the <code>UnboundLocalError</code> occurs.</p>
<p>As to why this happens: a list comprehension is more-or-less syntactic sugar for <code>list(&lt;generator expression&gt;)</code>, so it's going to be using the same code path as a generator expression (or at least behave in the same way). Generator expressions evaluate the iterable expression in the leftmost <code>for</code> clause to make error handling when the generator expression somewhat saner. Consider the following code:</p>
<pre><code>y = None                             # line 1
gen = (x + 1 for x in range(y + 1))  # line 2
item = next(gen)                     # line 3
</code></pre>
<p><code>y</code> is clearly the wrong type and so the addition will raise a <code>TypeError</code>. By evaluating <code>range(y + 1)</code> immediately that type error is raised on line 2 rather than line 3. Thus, it is easier to diagnose where and why the problem occurred. Had it occurred on line 3 then you might mistakenly assume that it was the <code>x + 1</code> statement that caused the error.</p>
<p>There is a bug report <a href="https://bugs.python.org/issue31126" rel="noreferrer">here</a> that mentions this behaviour. It was resolved as "not a bug" for reason that it is desirable that list comprehensions and generator expressions have the same behaviour. </p>
</div>
<span class="comment-copy">This is weird on so many levels. No matter what I changed (different combinations of global vars definition order, the order of the variables in the tuple and the order of the for loops) the error stays the same.</span>
<span class="comment-copy">I thought that <code>range(x+1)</code> was evaluated first, and x afterwards which would have "delayed" the error on y but that makes no sense since it should be the same for <code>y</code>...</span>
<span class="comment-copy">Note that <code>[x for x in range(x)]</code> produces no unbound local error. If you look at the output of <code>dis.dis(compile(src, '&lt;string&gt;', 'eval'))</code> you can see that <code>range(x)</code> is passed to list comprehension as an argument. This means the list comprehension never has to load <code>x</code> before it is assigned to. Due to the repeated invocations of <code>range(y)</code> this is not true for <code>y</code> and so <code>y</code> must be first read in side the comprehension. Seems like a possible bug in python.</span>
<span class="comment-copy">It's an explanation, but I don't think it's an answer. The behaviour is counter-intuitive and I want to go see if it's already in the python bug tracker first.</span>
