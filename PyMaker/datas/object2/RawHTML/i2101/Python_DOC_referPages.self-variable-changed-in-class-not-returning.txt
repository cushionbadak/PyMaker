<div class="post-text" itemprop="text">
<p>I tried to use <code>len(self.inbox)</code> before to return how many elements are in the list that holds the tuples, however, I couldn't get that to work, so I'm trying to make it so when a new element is added to <code>inbox</code> list, it will add one to <code>x</code> which will basically take the role of <code>len()</code>.</p>
<pre><code>class inbox:
    """Inbox class:
       add_new_arrival, message_count, get_unread_indexes, get_message, delete, clear"""
    def __init__(self):
        self.inbox = []
        self.x = 0

    def add_new_arrival(self, from_number, time_arrived, text_of_SMS):
        # Makes new SMS tuple, inserts it after other messages in the store.
        # When creating this message, its has_been_viewed status is set to False.
        self.x += 1
        self.inbox.append(tuple([from_number, time_arrived, text_of_SMS, False]))

    def message_count(self):
        # Returns the number of sms messages in inbox
        return self.x

inbox().add_new_arrival("from number", "time arrived", "text")
print(inbox().message_count())
</code></pre>
<p>However, when I run the program, the print at the end will return 0, even though I add a new message with <code>inbox().add_new_arrival(...)</code>.</p>
<p>It should return <code>1</code> but it doesn't, and I'm not understanding.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are running <code>message_count()</code> on a new instance of your inbox class (<code>inbox()</code>), which is instantiated with an inbox of length zero.</p>
<p>You might consider assigning an instance of your inbox class to a variable, using that object as you need.:</p>
<pre><code>class inbox:
    """
    Inbox class: add_new_arrival, message_count, 
    get_unread_indexes, get_message, delete, clear
    """
    def __init__(self):
        self.inbox = []

    def add_new_arrival(self, from_number, time_arrived, text_of_SMS):
        # Makes new SMS tuple, inserts it after other messages in the store.
        # When creating this message, its has_been_viewed status is set to False.
        self.inbox.append(tuple([from_number, time_arrived, text_of_SMS, False]))

    def message_count(self):
        # Returns the number of sms messages in inbox
        return len(self.inbox)

my_inbox = inbox()
my_inbox.add_new_arrival("from number", "time arrived", "text")
print(my_inbox.message_count())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your inbox class is basically a wrapper around a list, you could make it a subclass of <a href="https://docs.python.org/3/library/collections.html#collections.UserList" rel="nofollow noreferrer">UserList</a> and have access to all list methods.</p>
<pre><code>from collections import UserList

class Inbox(UserList):
    """
    Inbox class: add_new_arrival, message_count, 
    get_unread_indexes, get_message, delete, clear
    """

    def add_new_arrival(self, from_number, time_arrived, text_of_SMS):
        """Makes new SMS tuple, inserts it after other messages in the store.
        When creating this message, its has_been_viewed status is set to False"""
        self.append((from_number, time_arrived, text_of_SMS, False))

my_inbox = Inbox()
my_inbox.add_new_arrival("from number", "time arrived", "text")
print(len(my_inbox))
</code></pre>
</div>
<span class="comment-copy">You keep instantiating <b>new objects</b>: <code>inbox()</code></span>
