<div class="post-text" itemprop="text">
<p>I am currently trying to implement a Python module using C++. Official Python 3 docs provide an example <a href="https://docs.python.org/3/extending/newtypes_tutorial.html#providing-finer-control-over-data-attributes" rel="nofollow noreferrer">here</a>, but to my surprise the code provided there throws errors in my Visual Studio 2017!</p>
<p>If you take a look at <code>Custom_init</code> function implementation, you will see a function call <code>PyArg_ParseTupleAndKeywords</code> that takes several arguments, including a keyword array <code>kwlist</code> declared 3 lines above (Example copy-pasted below):</p>
<pre><code>static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"first", "last", "number", NULL};
    PyObject *first = NULL, *last = NULL, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|UUi", kwlist,
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        tmp = self-&gt;first;
        Py_INCREF(first);
        self-&gt;first = first;
        Py_DECREF(tmp);
    }
    if (last) {
        tmp = self-&gt;last;
        Py_INCREF(last);
        self-&gt;last = last;
        Py_DECREF(tmp);
    }
    return 0;
}
</code></pre>
<p>However upon trying to declare a <code>kwlist</code> of my own like in example above, VS2017 throws the following error:</p>
<p><strong><em>a value of type "const char *" cannot be used to initialize an entity of type "char *"</em></strong></p>
<p>The simple thing would be to declare my own <code>kwlist</code> as <code>const</code>, but <code>PyArg_ParseTupleAndKeywords</code> expects <code>kwlist</code> as <code>char *</code>. (Documentation <a href="https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTupleAndKeywords" rel="nofollow noreferrer">here</a>)</p>
<p>Is there a way to deal with this without resorting to extremes like <code>const_cast</code>?</p>
<p>Thank you.</p>
<p><strong>EDIT:</strong></p>
<p>One of the comments below suggested to simply copy from <code>const char*</code> to <code>char*</code> and I believe that will be the simplest approach to resolve this.</p>
</div>
<div class="post-text" itemprop="text">
<p>I cannot think of anything less horrible than </p>
<pre><code>static char first[] = "first";
static char last[] = "last";
static char number[] = "number";
static char *kwlist[] = {first, last, number, NULL};
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can store the strings as <code>std::string</code>s, and then use <code>std::string::data</code> to get your <code>char *</code>s</p>
<pre><code>static int
Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
{
    static std::array&lt;std::string, 4&gt; keywords { "first", "last", "number", "" };
    std::array&lt;char *, 4&gt; kwlist;
    std::transform(keywords.begin(), keywords.end(), kwlist.begin(), [](auto &amp; str){ return str.data(); });

    PyObject *first = nullptr;
    PyObject *last = nullptr;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|UUi", kwlist.data(),
                                     &amp;first, &amp;last,
                                     &amp;self-&gt;number))
        return -1;

    if (first) {
        auto tmp = self-&gt;first;
        Py_INCREF(first);
        self-&gt;first = first;
        Py_DECREF(tmp);
    }
    if (last) {
        auto tmp = self-&gt;last;
        Py_INCREF(last);
        self-&gt;last = last;
        Py_DECREF(tmp);
    }
    return 0;
}
</code></pre>
<p>Alternatively, you can use offsets into a single string literal</p>
<pre><code>static char keywords[] = "first\0last\0number\0\0";
static char * kwlist = { keywords, keywords + 6, keywords + 11, keywords + 18  };
</code></pre>
</div>
<span class="comment-copy">Yuck. I hate it when this happens. Python is new enough that this shouldn't happen.</span>
<span class="comment-copy">You can always copy your <code>const char*[]</code> into a new local <code>char *[]</code> to pass to Python.  But it does seem odd that Python requires a non-const keyword list.</span>
<span class="comment-copy">@0x5453 I cannot believe I've missed this! (D'oh!) Updated question.</span>
