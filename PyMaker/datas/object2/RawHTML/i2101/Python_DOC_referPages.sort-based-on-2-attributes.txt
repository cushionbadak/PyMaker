<div class="post-text" itemprop="text">
<p>I'm trying to sort numbers in lexicographical (reverse) order and from shortest to longest number. 
So for example the numbers <code>9989, 989, 9</code> should be rearanged as <code>9, 9989, 989</code>.</p>
<p>I'm trying this code:</p>
<pre><code>a.sort(key=lambda x:([x[i] for i in range(len(x))],len(x)), reverse=True)
</code></pre>
<p>but it only does a right job when the numbers have the same length. How should I fix it so that shorter numbers would come before longer numbers (i.e., 9 before 99)?</p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this?</p>
<pre><code>a = ['9989', '989', '999', '8', '9'] 
max_a = len(max(a, key=len))  
sorted(a, key=lambda x: x + 'a'*(max_a - len(x)), reverse=True)
# ['9', '999', '9989', '989', '8']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is what I came up with, similar idea to <a href="https://stackoverflow.com/users/2945357/andyk">@Andyk's solution</a> but avoiding a double sort and using <code>int</code> input. It requires importing <code>math.inf</code> to handle, for example, <code>[9989, 989, 999, 9, 99]</code>.</p>
<pre><code>from math import inf
from functools import partial

a = [9989, 989, 9]

def sort_algo(x, k):
    x_str = list(str(x))
    return list(map(int, x_str)) + [inf]*(k-len(x_str))

n = max(map(len, map(str, a)))
sorter = partial(sort_algo, k=n)
a.sort(key=sorter, reverse=True)

print(a)

[9, 9989, 989]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can hardly write a <strong>meaningful</strong> <em>key</em> function in Python 3 for this type of sorting without resorting to a comparator function and then using <a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="nofollow noreferrer"><code>functools.comp_to_key</code></a> to make it into a key function.</p>
<p>Check which of the items is larger up to their minimum length (using <code>zip</code> to iterate on both stops at min length), if both are same, check their lengths:</p>
<pre><code>from functools import cmp_to_key

def comparator(x, y):
   if x == y: return 0
   for i, j in zip(x, y):
      if i != j:
         return int(j)-int(i) # the reversal is done here
   return 1 if len(x) &gt; len(y) else -1


t = '9989', '989', '9'
print(sorted(t, key=cmp_to_key(comparator)))
# ['9', '9989', '989']

t = '888', '9989', '989', '9', '8'
print(sorted(t, key=cmp_to_key(comparator)))
# ['9', '9989', '989', '8', '888']
</code></pre>
<p>The sort function is quite readable, does not process further when the items are equal, and with <code>zip</code>, stops on the min length; <strong>adaptive</strong>.</p>
</div>
<span class="comment-copy">Why does 9989 come before 989?</span>
<span class="comment-copy">because their first integer is 9 we move to check the second integer which is 9 and 8 respectively so 9989 is before 989 (pay attention to the fact that i stated reverse=True)</span>
<span class="comment-copy">So by your description, 999 will come before 8?</span>
<span class="comment-copy">@MosesKoledoye exactly</span>
<span class="comment-copy">Yes indeed, thnx for the suggestion Patrick.</span>
<span class="comment-copy">I had to change sorted(a,...) to sorted(sorted(a),...) because it would fail for ['999', '9'] as '9' comes after '999' and we compare '999' with '999' (for '9'+'9'*2).</span>
<span class="comment-copy">Nifty solution, but sorting twice to handle an edge case isn't very nice.</span>
<span class="comment-copy">Ok, fixed that. We can fill strings with e.g. 'a' instead of '9' because 'a'&gt;'9'. So we don't need to sort twice.</span>
<span class="comment-copy">Fair enough, +1</span>
