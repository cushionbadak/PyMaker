<div class="post-text" itemprop="text">
<p>I was trying to understand the math behind calculations using / and // and % operators by doing some trials and found the results are similar to calculator only when using Decimal() but without it the results kinda confusing, i tried to add comments <code>#No Idea</code>to my code to mark the points i don't understand,for example:</p>
<ol>
<li><p>in this trial for % operator by applying signed and unsigned number the results and with and without Decimal() the results are :</p>
<pre><code>&gt;&gt;&gt; 9%5    #This result will be the reminder
4         
&gt;&gt;&gt; (-9)%5    #No Idea
1
&gt;&gt;&gt; Decimal(9)% Decimal(5)    #This result will be the reminder
Decimal('4')  
&gt;&gt;&gt; Decimal(-9)% Decimal(5)    #The result will be the signed reminder
Decimal('-4')
</code></pre></li>
<li><p>in this trial for // operator and using signed and unsigned number with and without Decimal() the results are :</p>
<pre><code>&gt;&gt;&gt; 9//5    #int result
1
&gt;&gt;&gt; -9//5    #No Idea
-2
&gt;&gt;&gt; Decimal(9)/Decimal(5)    #Same result as using calculator
Decimal('1.8')
&gt;&gt;&gt; Decimal(-9)//Decimal(5)    #No Idea
Decimal('-1')
</code></pre></li>
</ol>
<p>Please consider that this question is not a duplicate and i have done some research to get an answer but i found some answered questions that explain only about // operator using only positive signed numbers and doesn't include information about negative signed numbers or using the Decimal() and doesn't have answer about % operator.</p>
<p>so,It will be helpful if someone knows why the results are different and how they are calculated.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I understand the question, the OP is asking about the different behavior between Python integers and <code>Decimal</code>s. I don't think there is any good reason for it. Both choices are possible, but it is a bit confusing for the user that they differ.</p>
<p>Let's call the numerator <code>n</code>, the denominator <code>d</code> and split the result in the interger result <code>i</code> and the remainder <code>r</code>. This means that</p>
<pre><code>n // d = i
n % d = r
</code></pre>
<p>For the operations to make sense, we need</p>
<pre><code>i * d + r == n
</code></pre>
<p>For <code>n = -9</code> and <code>d = 5</code> we see that this is uphold for both <code>i = -1, r = -4</code> and for <code>i = -2, r = 1</code> as can be seen by</p>
<pre><code>(i = -1, r = -4) =&gt; -1 * 5 + -4 == -9
(i = -2, r = 1) =&gt; -2 * 5 + 1 == -9
</code></pre>
<p>Now, in Python integer division is defined as always truncate towards minus infinity (down) and the <code>Decimal</code> implementation has chosen to round towards zero. That means that positive values are truncated/rounded down, whereas negative values are rounded up.</p>
<p>Rounding towards zero is the choice made also made in the C language. However, my personal opinion is that the Python choice is much more sane, specifically coming from a hardware background. And given that this is the choice made in Python, I think it is strange (and bad) that <code>Decimal</code> has chosen to do as in the C language.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Explanation for the  behaviour of integers</h2>
<p>From <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer">python documentation</a>:</p>
<blockquote>
<p>Division of integers yields a float, while floor division of integers
  results in an integer; the result is that of mathematical division
  with the ‘floor’ function applied to the result.</p>
</blockquote>
<p>Therefore, an integer division (<code>//</code>) of negative negative and positive number works as follows:</p>
<pre><code>-9 // 5 == floor(-9 / 5) == floor(-1.8) == -2
</code></pre>
<p>The modulo operator is the remainder of the integer division, i.e. <code>x % y = x - x // y * y</code>. In your example:</p>
<pre><code>-9 % 5 == -9 - (-9 // 5 * 5) == (-9) - (-2 * 5) == (-9) - (-10) == 1
</code></pre>
<p>The documentation also says:</p>
<blockquote>
<p>The modulo operator always yields a result with the same sign as its
  second operand (or zero); the absolute value of the result is strictly
  smaller than the absolute value of the second operand.</p>
</blockquote>
<p>But that comes naturally from the formula above, e.g.:</p>
<pre><code>9 % -5 == 9 - (9 // (-5) * (-5)) == 9 - (-2 * (-5)) == 9 - 10 == -1
</code></pre>
<hr/>
<h2><code>decimal.Decimal</code> is different</h2>
<p><a href="https://docs.python.org/2/library/decimal.html#decimal.Decimal" rel="nofollow noreferrer">The documentation</a> explains the difference well:</p>
<blockquote>
<p>There are some small differences between arithmetic on Decimal objects
  and arithmetic on integers and floats. When the remainder operator <code>%</code>
  is applied to Decimal objects, the sign of the result is the sign of
  the dividend rather than the sign of the divisor:</p>
<pre><code>&gt;&gt;&gt; (-7) % 4
1
&gt;&gt;&gt; Decimal(-7) % Decimal(4)
Decimal('-3')
</code></pre>
<p>The integer division operator <code>//</code> behaves analogously, returning the
  integer part of the true quotient (truncating towards zero) rather
  than its floor, so as to preserve the usual identity <code>x == (x // y) * y
  + x % y</code>:</p>
<pre><code>&gt;&gt;&gt; -7 // 4
-2
&gt;&gt;&gt; Decimal(-7) // Decimal(4)
Decimal('-1')
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/183853/in-python-2-what-is-the-difference-between-and-when-used-for-division">In Python 2, what is the difference between '/' and '//' when used for division?</a></span>
<span class="comment-copy">See the beginning of the <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer">Binary arithmetic operations</a> section of the documentation, especially the part about the sign of result that the <code>%</code> (modulo) operator yields. When you're doing  research, the documentation is often a good place to look—at least with Python.</span>
<span class="comment-copy">I don't think thi duplication is correct, as this question handles the difference between the built-in integer and the <code>Decimal</code> class primarily.</span>
<span class="comment-copy">"I don't think there is any good reason for it." Not sure about "good", but there's definitely a reason. The <code>decimal</code> module follows a <a href="http://speleotrove.com/decimal/" rel="nofollow noreferrer">standard</a>. That standard specifies a <a href="http://speleotrove.com/decimal/daops.html#refremain" rel="nofollow noreferrer">remainder</a> operation where the sign of the result matches that of the dividend (unlike the behaviour of % with integers, where the sign of the result matches that of the divisor). So it's somewhat natural to have <code>%</code> for the <code>Decimal</code> type correspond to that remainder operation.</span>
<span class="comment-copy">The standard also specifies <a href="http://speleotrove.com/decimal/daops.html#refdivint" rel="nofollow noreferrer">divide-integer</a>, with semantics matching those of <code>//</code> for <code>Decimal</code> objects.</span>
<span class="comment-copy">@MarkDickinson Yes, it follows <i>a</i> standard. But it is strange choise of standard when you get different results for the standard arithmetic operations.</span>
<span class="comment-copy">Shrug. It's not as though there was a huge variety of standards to choose from back in 2003 when the <code>decimal</code> module was planned, and it's definitely better to follow a standard than to just make up all the corner cases. So maybe it wasn't the perfect standard; it was just better than the few other options. :-)</span>
<span class="comment-copy">@MarkDickinson Well, there was also the option to follow the behavior of Python integers, which would lead to fewer surprises. That I personally happen to prefer the way it is in Python, would just be a bonus. :-)</span>
