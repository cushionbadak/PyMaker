<div class="post-text" itemprop="text">
<p>In C language, for example,</p>
<pre><code>typedef struct People_S
{
    int age;
    int grade;
}People;

People tmp[10] = {0};
</code></pre>
<p>Then I can use <code>tmp[0].grade</code> to access the data.</p>
<p>In Python, however, I have no ideal how to do it. If using list <code>tmp = [[10,60],[11,50]]</code>, i can get the <code>grade</code> by <code>tmp[0][1]</code>. But too much magic number is not good for reading.</p>
<p>Thanks for your helf!</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are fine with using iteration on a list, you could as well use dictionaries if you do not like full fledged classes:</p>
<pre><code>dictList = []
for i in range(5):
    dictList.append({"age":i+10,"grade": i//3})

print(dictList)
print( dictList[2]["grade"], dictList[2]["age"] )

for e in dictList:
    print(e)
</code></pre>
<p>Output:</p>
<pre><code>[{'grade': 0, 'age': 10}, {'grade': 0, 'age': 11}, {'grade': 0, 'age': 12}, 
 {'grade': 1, 'age': 13}, {'grade': 1, 'age': 14}]

(0, 12)

{'age': 10, 'grade': 0}
{'age': 11, 'grade': 0}
{'age': 12, 'grade': 0}
{'age': 13, 'grade': 1}
{'age': 14, 'grade': 1}
</code></pre>
<p>Or the previously mentioned classes (see <a href="http://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes" rel="nofollow noreferrer">PyTut: A first look at classes</a>):</p>
<pre><code>class People:
    def __init__(self,age,grade):
        self.age=age
        self.grade=grade

    def __str__(self):
        return f"Age {self.age} Grade {self.grade}"

classList = []
for i in range(5):
    classList.append( People(i+10,i//3))

print(*classList,sep="\n")
</code></pre>
<p>Output:</p>
<pre><code>Age 10 Grade 0
Age 11 Grade 0
Age 12 Grade 0
Age 13 Grade 1
Age 14 Grade 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another option besides classes or dictionaries is <code>namedtuple</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; People = namedtuple('People','age grade')
&gt;&gt;&gt; People(10,60)
People(age=10, grade=60)
&gt;&gt;&gt; p = People(10,60)
&gt;&gt;&gt; p.age
10
&gt;&gt;&gt; p.grade
60
</code></pre>
<p>A way to populate a <code>People</code> list:</p>
<pre><code>&gt;&gt;&gt; tmp = [[10,60],[11,50]]
&gt;&gt;&gt; p = [People(age,grade) for age,grade in tmp]
&gt;&gt;&gt; p
[People(age=10, grade=60), People(age=11, grade=50)]
</code></pre>
</div>
<span class="comment-copy">See data classes of python 3.7</span>
<span class="comment-copy">Python has classes. <code>class Person:\n def __init__(self, age, grade):self.age,self.grade = age,grade</code></span>
<span class="comment-copy">Thank you very much!</span>
<span class="comment-copy">I like namedtuples: easy to set up, easy to use, very clear.  And if your program grows in complexity you may be glad that converting a namedtuple to a class is also pretty easy.</span>
<span class="comment-copy">didn't know about named tuples - nice feature.</span>
<span class="comment-copy">Note: <code>namedtuple</code>s <i>are</i> classes, they're just ones that Python generates for you (that subclass <code>tuple</code> to provide immutability guarantees and interoperability). Also note that as of 3.5, there is <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><code>typing.NamedTuple</code></a>, a replacement for <code>collections.namedtuple</code> which allows for safe typing, and added more flexibility as well in 3.6, which in turn paved the way for 3.7's <a href="https://docs.python.org/3/library/dataclasses.html" rel="nofollow noreferrer"><code>dataclasses</code> module</a>, which provides maximally flexible class generation capabilities.</span>
