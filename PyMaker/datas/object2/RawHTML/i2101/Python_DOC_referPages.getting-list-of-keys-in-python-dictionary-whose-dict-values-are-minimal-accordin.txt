<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/9944963/python-get-key-with-the-least-value-from-a-dictionary-but-multiple-minimum-valu">Python: get key with the least value from a dictionary BUT multiple minimum values</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p>I have a dictionary such as:</p>
<pre><code>d = {'a':[0,0], 'b':[0,0], 'c':[0,1], 'd':[1,1]}
</code></pre>
<p>There's an order on the values, basically the lexicographic one, such that <code>[0, 0] &lt; [0,1] &lt; [1,1]</code>.</p>
<p>I'm interested in retrieving the keys whose values are minimal according to this order. In this case the desired result is:</p>
<pre><code>result = ['a', 'b']
</code></pre>
<p>I can do this by (1) getting the values of the dict, (2) converting it to a list L, (3) sorting L with:</p>
<pre><code>L.sort(key = str),
</code></pre>
<p>then (4) getting the minimal element m of the sorted L, and finally (5) retrieving the keys whose values are m.</p>
<p>I can think of other variations of this procedure, but they all involve going through the dictionary and comparing things, and they're all perhaps too convoluted. </p>
<p>My question is if there's some simpler, more elegant (and more efficient) way of doing this. Should I be using a different data structure instead of a dictionary in the first place?</p>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way is to use the <code>min()</code> function to find the minimum value, then select the keys corresponding to that minimum using a list comprehension:</p>
<pre><code>d = {'a': [0, 0], 'b': [0, 0], 'c': [0, 1], 'd': [1, 1]}
min_value = min(d.values())
keys = [key for key, val in d.items() if val == min_value]
</code></pre>
<p>This solution has the <code>O(n)</code> time complexity.</p>
<p>You could also use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>, although this would require sorting the dictionary by values (and thus runs in <code>O(n log n)</code> time):</p>
<pre><code>from itertools import groupby
keys = next(list(g) for k, g in groupby(sorted(d, key=d.get), key=d.get))
</code></pre>
</div>
<span class="comment-copy">You can compare lists directly when sorting, no need to convert them to strings.</span>
