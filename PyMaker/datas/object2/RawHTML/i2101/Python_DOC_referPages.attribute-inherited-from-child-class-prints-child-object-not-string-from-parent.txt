<div class="post-text" itemprop="text">
<p>I know many topics around class inheritance in Python have been addressed, but I could not find a thread that addressed this specific issue.</p>
<p>Edit: I'm running Python 3.5.5.</p>
<p>Code:</p>
<pre><code>class Parent():
    def __init__(self, parentParam="parent param"):
        self.parentParam = parentParam

class Child(Parent):
    def __init__(self, childParam = "child param"):
        self.childParam = childParam
        super().__init__(self)

child = Child()
print(child.childParam)
print(child.parentParam)
</code></pre>
<p>Output:</p>
<pre><code>child param
&lt;__main__.Child object at 0x0000017CE7C0CAC8&gt;
</code></pre>
<p>Why does does <code>child.parentParam</code> return the child object and not the string <code>"parent param"</code>? I feel like it should print out the default string set for the Parent class.  This appears to be the same syntax as I have been following in <a href="https://www.digitalocean.com/community/tutorials/understanding-class-inheritance-in-python-3" rel="nofollow noreferrer">this tutorial</a>.</p>
<p>Thanks, everyone.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because you provide the instance of child (aka <code>self</code>) to the super call:</p>
<pre><code>class Child(Parent):
    def __init__(self, childParam = "child param"):
        self.childParam = childParam
        super().__init__(self) # here you override the default by supplying this instance
</code></pre>
<p>Use: </p>
<pre><code>class Child(Parent):
    def __init__(self, childParam = "child param"):
        self.childParam = childParam
        super().__init__() 
</code></pre>
<p>instead and you get this output instead:</p>
<pre><code>child param
parent param
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your call to <code>super</code> is wrong. It's not necessary to explicitly pass a <code>self</code> argument when using it to delegate a method call to a superclass (see the typical usage example shown in the <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer">documentation</a>). </p>
<p>In Python 3, calls to <code>super()</code> with no arguments are equivalent to <code>super(CurrentClass, self).method(arg)</code>—which was the only way it could be done in Python 2—making it no longer necessary to specify it at all when making calls to superclass methods.</p>
<p>So what's happening, since you passed it in your code, is that it gets interpreted as overriding the default value specified for the <code>parentParam</code> argument. </p>
<p>Here's doing it properly and the result:</p>
<pre><code>class Parent:
    def __init__(self, parentParam="parent param"):
        self.parentParam = parentParam


class Child(Parent):
    def __init__(self, childParam="child param"):
        self.childParam = childParam
        super().__init__()  # NO NEED TO PASS self.


child = Child()
print(child.childParam)   # -&gt; child param
print(child.parentParam)  # -&gt; parent param
</code></pre>
</div>
<span class="comment-copy">Thank you for you succinct answer.  I see the issue now.</span>
