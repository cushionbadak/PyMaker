<div class="post-text" itemprop="text">
<p>consider the following list:</p>
<pre><code>["abc", "abx", "axx", "abx", "abc"]
</code></pre>
<p>now consider every element of the list as an vertex of a graph.Two vertexes are connected if the two elements only differ in one character:</p>
<pre><code>abc &gt; abx
abc &gt; abx
</code></pre>
<p>ans so on.So the final result would be:</p>
<pre><code>{"0":["1","3"],"1":["0","2","4"],"2":["1","3"],"3":["0","3","4"],"4":["1","3"]}
</code></pre>
<p>the numbers are the indices.I already made a function to check whether or not the<br/>
vertexes should be connected(it returns Boolean values) but the main problem is when there are more than one of some elements in the list(in my example two "abc" and two "abx").The problem with this is when I want to find the index of and element like "abc".Python automatically returns the smaller index(that is 0)but when comparing "abx" with "abc" both indices (0 and 3) are important.It gets awful since there are C(5,2) = 10 pairs that should be checked.
I think somehow I should tell python to check whether or not there are more than one of each element and also remember how many times it used them.I really don't know how to develop that idea more(also whether it is useful or not) and how to execute it in code.
Thank you for your attention. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do the following:</p>
<pre><code>from itertools import combinations as comb
from collections import defaultdict

# a,b are strings from the list, i,j are their respective indexes
edges = [(i,j) for (i,a),(j,b) in comb(enumerate(lst), 2) if len(set(a)-set(b))==1]
# [(0, 1), (0, 3), (1, 2), (1, 4), (2, 3), (3, 4)]

dd = defaultdict(list)
for i, j in edges:
    dd[i].append(j)
    dd[j].append(i)
# {0: [1, 3], 1: [0, 2, 4], 2: [1, 3], 3: [0, 2, 4], 4: [1, 3]}
</code></pre>
<p>This uses <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> to get the indexes, <a href="https://docs.python.org/3.6/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to get all possible pairs.  <a href="https://docs.python.org/2/library/sets.html#set-objects" rel="nofollow noreferrer">Set difference</a> is utilised in the <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">conditional comprehension</a> to filter out all the pairings differing in  exactly 1 letter and a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> for convenience to build the final data structure from these edges.</p>
</div>
