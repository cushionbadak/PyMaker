<div class="post-text" itemprop="text">
<p>I have a set of lists similar to this one:</p>
<pre><code>list = [datetime.datetime(1900, 1, 1, 16, 5), 'NA', 'NA', 'NA', 
    'NA', datetime.datetime(1900, 1, 1, 16, 49)]
</code></pre>
<p>I want to obtain the maximum value in each list without taking in consideration the <code>'NA'</code> values.</p>
<p>When I use the max() function I got following error:</p>
<blockquote>
<p>TypeError: '&gt;' not supported between instances of 'str' and 'datetime.datetime'</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>you can use a <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow noreferrer">generator expression</a> to exclude items you do not want to compare:</p>
<pre><code>import datetime

lst = [datetime.datetime(1900, 1, 1, 16, 5), 
       'NA', 'NA', 'NA', 'NA', datetime.datetime(1900, 1, 1, 16, 49)]

print(max(item for item in lst if item != 'NA'))
</code></pre>
<p>note that <a href="https://docs.python.org/3/tutorial/datastructures.html?highlight=list#more-on-lists" rel="nofollow noreferrer"><code>list</code></a> is not a good variable in python. you overwrite the built-in <code>list</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do something like this:</p>
<pre><code>new_list = [i for i in list if i != 'NA']
print(max(new_list))
</code></pre>
<p>By doing this you are creating a new list that will contain only datetime elements, and then you can easily get the maximum value by using the <code>max()</code> function.</p>
<p>Or if you don't want to create a new list at all you can just do this:</p>
<pre><code>print(max(i for i in list if i != 'NA'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may opt to <code>filter</code> the wrong elements first:</p>
<pre><code>l=[datetime.datetime(1900, 1, 1, 16, 5), 'NA', 'NA', 'NA', 'NA', datetime.datetime(1900, 1, 1, 16, 49)]
max(filter(lambda x: x!= 'NA', l))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are open to use pandas, you can let a library decide what is error and what is not.</p>
<pre><code>import pandas as pd
import datetime

list1 = [datetime.datetime(1900, 1, 1, 16, 5), 'NA', 'NA', 'NA', 'NA', datetime.datetime(1900, 1, 1, 16, 49)]
print(pd.to_datetime(list1, errors='coerce').max().to_pydatetime())
</code></pre>
<p>returns:</p>
<pre><code>1900-01-01 16:49:00
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take elements from list ignoring <code>'NA'</code> and do a <code>max()</code>:</p>
<pre><code>print(max(x for x in lst if x != 'NA'))
# 1900-01-01 16:49:00
</code></pre>
<p>Note that I used <code>lst</code> instead of <code>list</code> because it shadows the built-in <a href="https://docs.python.org/3/library/functions.html#func-list" rel="nofollow noreferrer">list</a>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import datetime
dates_list=[datetime.datetime(1900, 1, 1, 16, 5), 'NA', 'NA', 'NA', 'NA', datetime.datetime(1900, 1, 1, 16, 49)]
# Efficient to use generators rather than producing entire list
print(max((x for x in dates_list if x != 'NA'))) # Notice () instead of []
</code></pre>
<p>Output:<br/>
1900-01-01 16:49:00</p>
</div>
<span class="comment-copy">Don't name a variable <code>list</code> !</span>
<span class="comment-copy">Use list comprehension or filter to get ride of 'NA'</span>
<span class="comment-copy">There is a difference between a String and a DateTime object. Please do not mix them. Make sure that all the elements in a set should be of same type. OK, you can have all the kinds of items inherited by same parent class, but for comparing two elements either string or a number, both should be strictly of same type, so that the underlying logic compiles it successfully.</span>
<span class="comment-copy">There are comprehensions to use instead of <code>filter</code> and <code>lambda</code> nowadays. ;-)</span>
