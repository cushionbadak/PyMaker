<div class="post-text" itemprop="text">
<p>I'm a python student (by myself), and as an exercise I decided to try making a script to 'encrypt/decrypt' a message.
The 'encryption algo' that I'm using is very simple, I learned during military service and it was used for troops in the field to encrypt radio messages only.
I assume it's not a secure way to encrypt stuff. (If someone can comment on that, I would love to know more)
Anyway, I'm doing it as an exercise for programming logic, but I've been stuck for a while now.</p>
<p>Here it's how it works:</p>
<p>You get a keyword/phrase (More often used with 2 words (vertical and horizontal) but for now I'm coding the 1 keyword only).
Let's use 'PASSWORD' as key and the message: 'This is a sample message'. I would make a table with PASSWORD as colum index, and fill the table with the message:</p>
<pre><code>P   A   S   S   W   O   R   D
t   h   i   s   i   s   a   s
a   m   p   l   e   m   e   s
s   a   g   e   x   y   z   x
</code></pre>
<p>[Since the message didn't complete all the columns we completed it with letters that won't cause issues]<br/>
Then, we determine the order for the scramble, deriving it alphabetically  from the key:</p>
<pre><code>4   1   6   7   8   3   5   2
P   A   S   S   W   O   R   D
[a,d,o,p,r,s,s,w]
</code></pre>
<p>So line by line, letter by letter, we would take the letters from the message according to the key-order, and form the encrypted message:
'hsstaisi' for the first line, 'msmaeple' and 'axyszgex' for the second and third line.
So the message would be 'hsstaisimsmaepleaxyszgex' [Usually transmitted as "hssta isims maepl eaxys zgex" to make it easier for the radio operator]</p>
<p><strong>Now the code:</strong>
I manage to make it work (kind of...), here is how:</p>
<p>I get the message and key, remove spaces, make both them into lists. I create a dictionary where every letter from the key(list) becomes a key in the dict, and the value is a number (from 0 to lenght of the key), like an iterator. </p>
<blockquote>
<p>{ 'p':0, a':1, 's':2,... } #[Here is my problem]</p>
</blockquote>
<p>After that we sort the key(list) alphabetically and use it as iterator to call for the key(dict) that will call for a number that will be a index from the message list. (My explanation is confusing, may be easier to understand by checking the code bellow).
Letter by letter the message is scrambled and appended in a new list, and then presented as 'encrypted'. </p>
<p><strong>It works! Except if the keyphrase has repeated letters</strong> (like ours 'password'). In that situation the corresponding value of a repeated dictionary key gets overwritten, because dict keys are unique. </p>
<p>I've written several different versions for the same code, but I always get stuck in the dict problem, at some point or the other.</p>
<p>Here is the piece of code:</p>
<pre><code>key = ['p','a','s','s','w','o','r','d']
msg = ['t','h','i','s','i','s','a','s','a','m','p','l','e','m','e','s','s','a','g','e']
def encrypt(key_list,msg_list):
       while len(msg_list) % len(key_list) != 0:
           rest = len(key_list) - (len(msg_list) % len(key_list))
           for i in range(rest):
               if msg_list[-1] == 'z':
                   msg_list.append('x')
               else:
                   msg_list.append('z')
       key_dict = {}
       for i in range(len(key_list)):
           key_dict[key_list[i]] = i
       key_list.sort() 
       qnty_rows = len(msg_list) // len(key_list)
       cloop = 0
       scramble_list = []
       while cloop &lt; qnty_rows:
           for i in range(len(key_list)):
               scramble_list.append(msg_list[key_dict[key_list[i]]+(cloop*len(key_list))])
           cloop +=1
       encrypted_msg = "".join(scramble_list)
       print(encrypted_msg)
</code></pre>
<p>Can someone help me find a solution to this, or point me at the right direction? </p>
<p>Considering that I'm still learning to code, any constructive criticism for the code in general is welcomed. </p>
</div>
<div class="post-text" itemprop="text">
<p>Your error lies in how you assign column numbers to each of the key characters, using a dictionary:</p>
<pre><code>for i in range(len(key_list)):
    key_dict[key_list[i]] = i
</code></pre>
<p>For repeated letters, only the last index remains; <code>s</code> from <code>password</code> maps first to 2, then to 3, so <code>key_dict['s']</code> ends up being <code>3</code>:</p>
<pre><code>i = 0, key_list[i] == 'p', key_dict['p'] = 0
i = 1, key_list[i] == 'a', key_dict['a'] = 1
i = 2, key_list[i] == 's', key_dict['s'] = 2
i = 3, key_list[i] == 's', key_dict['s'] = 3  # replacing 2
i = 4, key_list[i] == 'w', key_dict['w'] = 4
# etc.
</code></pre>
<p>Don't use a dictionary; generate a list of paired index and character values, sort this by letter, then extract just the indices:</p>
<pre><code>indices = [i for i, c in sorted(enumerate(key_list, key=lambda p: p[1]))]
</code></pre>
<p>I used the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code> function</a> to generate the indices; it's achieves the same thing as your <code>range(len(key_list))</code> loop in a more compact form.</p>
<p>Because <code>enumerate()</code> produces <code>(index, value)</code> pairs and we want to sort on the values (the characters), the above code uses a <em>sort key</em> extracting the values (<code>p[1]</code>).</p>
<p>Note that you <em>don't need your key to be a list even</em>, the above would work directly on a string too; strings are sequences just like lists are.</p>
<p>Here's how this works:</p>
<pre><code>&gt;&gt;&gt; keyphrase = 'password'
&gt;&gt;&gt; list(enumerate(keyphrase))  # add indices
[(0, 'p'), (1, 'a'), (2, 's'), (3, 's'), (4, 'w'), (5, 'o'), (6, 'r'), (7, 'd')]
&gt;&gt;&gt; sorted(enumerate(keyphrase), key=lambda p: p[1])  # sorted on the letter
[(1, 'a'), (7, 'd'), (5, 'o'), (0, 'p'), (6, 'r'), (2, 's'), (3, 's'), (4, 'w')]
&gt;&gt;&gt; [i for i, c in sorted(enumerate(keyphrase), key=lambda p: p[1])]  # just the indices
[1, 7, 5, 0, 6, 2, 3, 4]
</code></pre>
<p>Now you can use these indices to remap chunks of the plaintext input to encrypted output.</p>
<p>What you have is a called a <a href="http://crypto.interactive-maths.com/columnar-transposition-cipher.html" rel="nofollow noreferrer"><em>columnar transposition cipher</em></a>. For modern computers such a cipher is rather trivial to break. See <a href="https://crypto.stackexchange.com/questions/40119/how-to-solve-columnar-transposition-cipher-without-a-key">https://crypto.stackexchange.com/questions/40119/how-to-solve-columnar-transposition-cipher-without-a-key</a> for a discussion on how to approach cracking such a ciphertext.</p>
</div>
<span class="comment-copy">It would make it easier for anyone trying to help you if you used English variable names in your code.</span>
<span class="comment-copy">The cryptographic question (<i>is this secure</i>) is really off-topic, but no, the cypher only alters ordering of the message letters, something that can quite easily be reversed.</span>
<span class="comment-copy">@Martijn Pieters  Changed the variable names, thank you.</span>
