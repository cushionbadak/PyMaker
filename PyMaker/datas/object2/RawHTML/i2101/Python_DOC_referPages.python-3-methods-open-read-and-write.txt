<div class="post-text" itemprop="text">
<pre><code>from sys import argv

script, filename = argv

print ("We're going to erase %r" % filename)
print ("If you don't want to do that, press CTRL-C (^C)")
print ("If you do want that, hit RETURN.")

input("?")

print ("Opening the file...")
target = open(filename, 'r+')

print ("Truncating the file. Goodbye!")
target.truncate()

print ("Enter two lines: ")
line1 = input("Line 1: ")
line2 = input("Line 2: ")

print ("I'm going to write those to the file")

target.write(line1)
target.write('\n')
target.write(line2)

print (target.read()) 

print ("Closing file")
target.close()
</code></pre>
<p>When I run the script, compiler acts like there is no print (target.read()) line. If I close target before that line, and make new variable like lets say txt = open(filename, 'r+') and then print (txt.read()) it works. Can someome explain why it doesn't work like I did it above?</p>
</div>
<div class="post-text" itemprop="text">
<p>Think of working with files as having 2 pointers, one is the variable for the file itself, and the second as a pointer to where in the file you are currently at.</p>
<p>You first <code>target.truncate</code> the file to empty the contents, pointer is at the first character in the file.</p>
<p>Then you give 3 <code>target.write</code> commands, to which the pointer will move to the end of each line as that command is finished.</p>
<p>Finally, you attempt a <code>target.read</code>. At this point the cursor is at the end of the file, and there is nothing to read from that point, moving forward. If you want to read the contents of the file, then you will either need to close and reopen the file, or perform a <a href="https://python-reference.readthedocs.io/en/latest/docs/file/seek.html" rel="nofollow noreferrer"><code>target.seek(0)</code></a> to move the pointer to the beginning of the file to the 0th byte before you actually perform a <code>target.read</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you are writing and reading something in a file you change the file pointer. In this case you are reading the last position in file.</p>
<p>You can add this line before read(), that change the pointer for the first position in file.</p>
<pre><code>target.seek(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Looks like it works to me.</p>
<pre><code>from sys import argv

script, filename = argv

print ("We're going to erase %r" % filename)
print ("If you don't want to do that, press CTRL-C (^C)")
print ("If you do want that, hit RETURN.")

input("?")

print ("Opening the file...")
with open(filename, 'w') as target:
  print ("Enter two lines: ")
  line1 = input("Line 1: ")
  line2 = input("Line 2: ")
  print ("I'm going to write those to the file")
  target.write(line1)
  target.write('\n')
  target.write(line2)

with open(filename, 'r') as target:
  print (target.read())

input ("Closing file")
</code></pre>
</div>
<span class="comment-copy">Wouldn't it be easier to open the file as <code>with open(filename, 'w') as target:</code> which erases any data, write the two input lines, then <code>with open(filename, 'r') as target:</code> and read?</span>
<span class="comment-copy">Did it at first, but then I was changing code to try to figure out why that line isn't working</span>
<span class="comment-copy">So that happens after every writing? I mean, after I write to file, I should close it and reopen?</span>
<span class="comment-copy">Ideally, you should keep operations logically separated. You can utilize the <a href="https://docs.python.org/3/reference/compound_stmts.html#the-with-statement" rel="nofollow noreferrer"><code>with</code></a> statement to self-close a file once you're done with a logical operation.</span>
<span class="comment-copy">Understood it, thank you!</span>
