<div class="post-text" itemprop="text">
<p>I am learning programming from scratch first time in my life. I am learning the Python language. My first difficult task is to write algorythm which checks if the number is the prime number. </p>
<p>The script should work in very simple way. You enter:</p>
<blockquote>
<p>is_prime(29)</p>
</blockquote>
<p>and you should get output like this:</p>
<blockquote>
<p>The number 29 is the prime number.</p>
</blockquote>
<p>or</p>
<blockquote>
<p>The number 29 is NOT the prime number.</p>
</blockquote>
<p>I did not check any solution on the internet. I did it by myself. My assumptions was as follows:</p>
<ol>
<li>from the school I remember that the prime number is divided only by 1 and by itself</li>
<li>'0' and '1' are not the prime number</li>
</ol>
<p>So I wrote the code which checks if the given number is divided by all numbers from 2 to (number-1). For example if the given value is '6', the script checks first if the 6 is divided by 2. If this is true that means the number is NOT a prime number. If 6 would be not divided by 2, the script checks if 6 is divided by 3. If so, that means the number is NOT a prime number. In case of '7'number the script checks 7/2, then 7/3, then 7/4 then 7/5, then 7/6.</p>
<p>The code is like this:</p>
<pre><code>def is_prime(number):
    if number == 0 or number == 1:
        print(f"The number {number} is NOT the prime number.")
    elif number == 2:
        print(f"The number {number} is the prime number.")
    else:
        for i in range(2, number):
            if number % i == 0:
                check = "is NOT"
                break
            else:
                check = "is"
        print(f"The number {number} {check} the prime number.")
</code></pre>
<p>But then, I actually realized three things:</p>
<ol>
<li>If the number is divided by 2, definitely it is not the prime number</li>
<li>If the number is not divided by 2, it can be divided by 3 or by 5.</li>
<li>If the number is not divided by 2, is not divided by 3 and is not divided by 5 that means that this number is the prime number. The only exceptions from this rules are these three numbers 2,3 and 5.</li>
</ol>
<p>And that's it. So I wrote the code as follows</p>
<pre><code>def is_prime(number):
    if number &gt; 1:
        if (number %2 == 0 and number != 2) or (number %3 == 0 and number != 3 ) or(number %5 == 0 and number != 5):
            print(f"The number {number} is NOT the prime number. ")
        else:
            print(f"The number {number} is the prime number. ")

    else:
        print(f"The number {number} is NOT the prime number. ")
</code></pre>
<p>I think that both solutions are ok. <strong>Please correct me if I am wrong</strong>
But I would like to ask you which solution is better from the programming point of view?</p>
</div>
<div class="post-text" itemprop="text">
<p>Even though your first is correct and the second is not, you would gain speed in the algorithm by:</p>
<ol>
<li>Don't try to test for divisibility if the number you are trying
to divide with is already a factor of the previous numbers, e.g.
when you have tried to divide with 2, you only need to try odd
numbers. If a number is not divisible by 2, it is clearly not
divisible by 4.</li>
<li>You only need to test up to the square root of
the number. At least one of the factors needs to be less than or
equal to the square root.</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Your original code looks correct. The second one doesn't rule out numbers like <code>49</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>One more thing about my first solution which you confirmed is correct.
The range to check inside the 'for' loop is: </p>
<pre><code>for i in range(2, number)
</code></pre>
<p>But correct me if I am wrong, I think that it is enough to have range = (2, number/2)</p>
<p>For example let us consider the number 541 which is the prime number. My code will check modulo as follows:</p>
<p>541/2
541/3
541/4
.
.
.
541/538
541/539
541/540</p>
<p>But it is completely useless to check dividors greater than value 270 (which is almost the half of 541). If the 541 is not divided by 270 , it is obvious that it can not be divided by 271, 272, 273, 274, 275 and so on.</p>
<p>So I think it is enough to have:</p>
<pre><code>for i in range(2, round(number/2)+1)
</code></pre>
<p>I had to add + 1 because otherwise I get error when I run the function for the number 3.</p>
<p>What do you think? 
Am I right that it is enough to have range for check (2, number/2) instead of (2, number) ?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_prime(number):

    count = 0

    for i in range(1,number+1):

        if number%i == 0:
            count +=1

    if count == 2:

        print('The number {0} is the prime number.'.format(number))

    else:

        print('The number {0} is NOT the prime number.'.format(number))
</code></pre>
</div>
<span class="comment-copy">What if <code>number % 7 == 0</code>? Also, is 179_426_549 prime, according to your second function?</span>
<span class="comment-copy">@ForceBru is right ! Your code will consider 49 as prime while it is not.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/tutorial/controlflow.html" rel="nofollow noreferrer">docs.python.org/3/tutorial/controlflow.html</a> section 4.4</span>
<span class="comment-copy">Also, check <a href="https://www.mersenne.org/primes/press/M77232917.html" rel="nofollow noreferrer">this</a> out. The largest known prime number can be <i>verified</i> to be prime in 34 <b>hours</b> on a modern GPU. Your code, on the contrary, will be lightning fast, but give a result just as incorrect. If you'd created such a super fast algorithm for primality check, you'd've gotten some kind of prize for sure.</span>
<span class="comment-copy">179 is the prime, 426 is not the prime and 549 is not the prime according to the second code. I have checked it right now. I think this is correct. It is not? But you are right that 49 is indicated as the prime, which is of course wrong.</span>
<span class="comment-copy">You are absolutely right. For example when the number is 79 and the first check says that it is not divided by 2, it is completely unnecessary to check if the number is divided by 4, 8, 16, 32. You are absolutely right. But how can I achieve something like this in the code? How can I bypass checking divisibility by 2^n if the value is not divided by 2. Is it possible?</span>
<span class="comment-copy">You don't need to check for 2*n, i.e. 4, 6, 8, 10, 12, ...</span>
<span class="comment-copy">There are algorithms for checking that a number "likely" is a prime number. As far as I know, the best way to actually check if the number is prime is to build a table of prime numbers and check divisibility for prime numbers up to the square root of the number. The table is most easily built recursively starting from the first prime number, i.e. 2.</span>
<span class="comment-copy">This is not true. The second code tells correctly that 7, 11, 13 are the prime numbers. I have checked it.</span>
<span class="comment-copy">I guess that matt means is that it will say numbers with those factors are prime. eg 7*7 = 49</span>
<span class="comment-copy">This is the correct answer. A prime number is a number that is divisible only by itself and 1. In that case count == 2</span>
<span class="comment-copy">If you use <code>(2,number)</code> then <code>count is 0 for a prime number. If you use </code>(2,math.sqrt(number))<code>, it's even faster. And you should stop as soon as you find a </code>0` modulo. No need to go to the end.</span>
