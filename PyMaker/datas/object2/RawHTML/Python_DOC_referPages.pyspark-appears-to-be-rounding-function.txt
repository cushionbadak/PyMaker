<div class="post-text" itemprop="text">
<p>I was trying to normalize a set of numbers from -100 to 0 to a range of 10-100 and was having problems only to notice that even with no variables at all, this does not evaluate the way I would expect it to:</p>
<pre><code>&gt;&gt;&gt; (20-10) / (100-10)
0
</code></pre>
<p>Float division doesn't work either:</p>
<pre><code>&gt;&gt;&gt; float((20-10) / (100-10))
0.0
</code></pre>
<p>If either side of the division is cast to a float it will work:</p>
<pre><code>&gt;&gt;&gt; (20-10) / float((100-10))
0.1111111111111111
</code></pre>
<p>Each side in the first example is evaluating as an int which means the final answer will be cast to an int. Since 0.111 is less than .5, it rounds to 0.  It is not transparent in my opinion, but I guess that's the way it is.</p>
<p>What is the explanation?</p>
</div>
<div class="post-text" itemprop="text">
<p>You're using Python 2.x, where integer divisions will truncate instead of becoming a floating point number.</p>
<pre><code>&gt;&gt;&gt; 1 / 2
0
</code></pre>
<p>You should make one of them a <code>float</code>:</p>
<pre><code>&gt;&gt;&gt; float(10 - 20) / (100 - 10)
-0.1111111111111111
</code></pre>
<p>or <code>from __future__ import division</code>, which the forces <code>/</code> to adopt Python 3.x's behavior that always returns a float.</p>
<pre><code>&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; (10 - 20) / (100 - 10)
-0.1111111111111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're <a href="http://docs.python.org/reference/expressions.html#binary-arithmetic-operations" rel="noreferrer">putting Integers in so Python is giving you an integer back</a>:</p>
<pre><code>&gt;&gt;&gt; 10 / 90
0
</code></pre>
<p>If if you cast this to a float afterwards the rounding will have already been done, in other words, 0 integer will always become 0 float.</p>
<p>If you use floats on either side of the division then Python will give you the answer you expect.</p>
<pre><code>&gt;&gt;&gt; 10 / 90.0
0.1111111111111111
</code></pre>
<p>So in your case:</p>
<pre><code>&gt;&gt;&gt; float(20-10) / (100-10)
0.1111111111111111
&gt;&gt;&gt; (20-10) / float(100-10)
0.1111111111111111
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need to change it to a float BEFORE you do the division. That is:</p>
<pre><code>float(20 - 10) / (100 - 10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It has to do with the version of python that you use. Basically it adopts the C behavior: if you divide two integers, the results will be rounded down to an integer. Also keep in mind that Python does the operations from left to right, which plays a role when you typecast.</p>
<p>Example:
Since this is a question that always pops in my head when I am doing arithmetic operations (should I convert to float and which number), an example from that aspect is presented:</p>
<pre><code>&gt;&gt;&gt; a = 1/2/3/4/5/4/3
&gt;&gt;&gt; a
0
</code></pre>
<p>When we divide integers, not surprisingly it gets lower rounded.</p>
<pre><code>&gt;&gt;&gt; a = 1/2/3/4/5/4/float(3)
&gt;&gt;&gt; a
0.0
</code></pre>
<p>If we typecast the last integer to float, we will still get zero, since by the time our number gets divided by the float has already become 0 because of the integer division.</p>
<pre><code>&gt;&gt;&gt; a = 1/2/3/float(4)/5/4/3
&gt;&gt;&gt; a
0.0
</code></pre>
<p>Same scenario as above but shifting the float typecast a little closer to the left side.</p>
<pre><code>&gt;&gt;&gt; a = float(1)/2/3/4/5/4/3
&gt;&gt;&gt; a
0.0006944444444444445
</code></pre>
<p>Finally, when we typecast the first integer to float, the result is the desired one, since beginning from the first division, i.e. the leftmost one, we use floats.</p>
<p>Extra 1: If you are trying to answer that to improve arithmetic evaluation, you should check <a href="https://stackoverflow.com/questions/3264345">this</a> </p>
<p>Extra 2: Please be careful of the following scenario:</p>
<pre><code>&gt;&gt;&gt; a = float(1/2/3/4/5/4/3)
&gt;&gt;&gt; a
0.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.7, the <code>/</code> operator is an integer division if inputs are integers:</p>
<pre><code>&gt;&gt;&gt;20/15
1

&gt;&gt;&gt;20.0/15.0
1.33333333333

&gt;&gt;&gt;20.0/15
1.33333333333
</code></pre>
<p>In Python 3.3, the <code>/</code> operator is a float division even if the inputs are integer.</p>
<pre><code>&gt;&gt;&gt; 20/15
1.33333333333

&gt;&gt;&gt;20.0/15
1.33333333333
</code></pre>
<p>For integer division in Python 3, we will use the <code>//</code> operator.</p>
<p>The <code>//</code> operator is an integer division operator in both Python 2.7 and Python 3.3.</p>
<p>In Python 2.7 and Python 3.3:</p>
<pre><code>&gt;&gt;&gt;20//15
1
</code></pre>
<p>Now, see the comparison</p>
<pre><code>&gt;&gt;&gt;a = 7.0/4.0
&gt;&gt;&gt;b = 7/4
&gt;&gt;&gt;print a == b
</code></pre>
<p>For the above program, the output will be False in Python 2.7 and True in Python 3.3.</p>
<p>In Python 2.7 a = 1.75 and b = 1.</p>
<p>In Python 3.3 a = 1.75 and b = 1.75, just because <code>/</code> is a float division.</p>
</div>
<div class="post-text" itemprop="text">
<p>Specifying a float by placing a '.' after the number will also cause it to default to float. </p>
<pre><code>&gt;&gt;&gt; 1 / 2
0

&gt;&gt;&gt; 1. / 2.
0.5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Make at least one of them float, then it will be float division, not integer:</p>
<pre><code>&gt;&gt;&gt; (20.0-10) / (100-10)
0.1111111111111111
</code></pre>
<p>Casting the result to float is too late.</p>
</div>
<div class="post-text" itemprop="text">
<p>In python <code>cv2</code> not updated the division calculation. so, you must include <code>from __future__ import division</code>  in first line of the program.</p>
</div>
<div class="post-text" itemprop="text">
<p>Either way, it's integer division.  10/90 = 0.  In the second case, you're merely casting 0 to a float.</p>
<p>Try casting one of the operands of "/" to be a float:</p>
<pre><code>float(20-10) / (100-10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You're casting to float after the division has already happened in your second example. Try this:</p>
<pre><code>float(20-10) / float(100-10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'm somewhat surprised that no one has mentioned that the original poster might have liked <em>rational</em> numbers to result.  Should you be interested in this, the Python-based program <a href="http://sagecell.sagemath.org/?z=eJzTMDLQNTTQVNBX0DA0ADMBHa4DIQ==&amp;lang=sage" rel="nofollow noreferrer">Sage has your back</a>.  (Currently still based on Python 2.x, though 3.x is under way.)</p>
<pre><code>sage: (20-10) / (100-10)
1/9
</code></pre>
<p>This isn't a solution for everyone, because it does do some preparsing so these numbers aren't <code>int</code>s, but Sage <code>Integer</code> class elements.  Still, worth mentioning as a part of the Python ecosystem.</p>
</div>
<div class="post-text" itemprop="text">
<p>Personally I preferred to insert a <code>1. *</code> at the very beginning. So the expression become something like this:</p>
<pre><code>1. * (20-10) / (100-10)
</code></pre>
<p>As I always do a division for some formula like:</p>
<pre><code>accuracy = 1. * (len(y_val) - sum(y_val)) / len(y_val)
</code></pre>
<p>so it is impossible to simply add a <code>.0</code> like <code>20.0</code>. And in my case, wrapping with a <code>float()</code> may lose a little bit readability.</p>
</div>
<span class="comment-copy">See also: <a href="http://stackoverflow.com/questions/1787249/why-doesnt-this-division-work-in-python/1787255#1787255">Why doesnâ€™t this division work in python?</a></span>
<span class="comment-copy">Adam, I still don't like your explanation. The first example is integer division, which simply returns 0. The second example is parenthesized wrongly for the effect you want.</span>
<span class="comment-copy">@GregS The first example was the problem.  The second example is explanatory and was written after the first question. All the answers below explain the issue very well, especially @KennyTM 's.  It's important to note that my original problem is only an issue on Python 2.x, not 3.  It's a little disconcerting that the behavior will change like that but now that I know, I'll use from <b>future</b> import division and use the 3.x behavior.  Cheers.</span>
<span class="comment-copy">Adam, please correct your last EDIT. The right side has nothing special to it; in order for a division to be float, either the numerator or the denominator (or both) needs to be float. If you think you read in the docs that the right hand side needs to be float, then either the documentation is badly phrased and should be corrected, or you misunderstood it. Did you see an example, perhaps, and then extrapolate a rule out of it?</span>
<span class="comment-copy">If you use <code>from __future__ import division</code> you can get the old C-style division behavior by using two slashes (e.g. <code>1 // 2</code> will result in 0).  See <a href="http://www.python.org/dev/peps/pep-0238/" rel="nofollow noreferrer">Pep 238 Changing the Division Operator</a></span>
<span class="comment-copy">@User No need for the import from <code>__future__</code>. In both Python 2 and 3 <code>//</code> refers to <code>__floordiv__()</code> by default.</span>
<span class="comment-copy">@Adam Nelson: Works correctly for me.  Check your parentheses.</span>
<span class="comment-copy">Actually, I'm wrong - but after looking at the docs, one should cast the right side first.</span>
<span class="comment-copy">@Adam: It doesn't matter which side first.</span>
<span class="comment-copy">I've learned that python has conversions, not casts.</span>
