<div class="post-text" itemprop="text">
<p>I need to write a class that implements 32-bit unsigned integers the same way they work in C programming language. What I care about most are the binary shifts, but I generally want my class to:</p>
<ol>
<li>Have the same interface <code>int</code> has and works with <code>int</code> properly</li>
<li>Any operation with my <code>U32</code> class (int + <code>U32</code>, <code>U32</code> + int etc) also return U32</li>
<li>Be pure-python - I don't want to use NumPy, ctypes, etc.</li>
</ol>
<p>As can be found in <a href="https://stackoverflow.com/a/19611147/1091116">this answer</a>, I got a solution that works under Python 2. Recently I tried to run it under Python 3 and noticed that while the following test code works fine under older versions of Python, Python 3 raises an error:</p>
<pre><code>class U32:
    """Emulates 32-bit unsigned int known from C programming language."""

    def __init__(self, num=0, base=None):
        """Creates the U32 object.

        Args:
            num: the integer/string to use as the initial state
            base: the base of the integer use if the num given was a string
        """
        if base is None:
            self.int_ = int(num) % 2**32
        else:
            self.int_ = int(num, base) % 2**32

    def __coerce__(self, ignored):
        return None

    def __str__(self):
        return "&lt;U32 instance at 0x%x, int=%d&gt;" % (id(self), self.int_)

    def __getattr__(self, attribute_name):
        print("getattr called, attribute_name=%s" % attribute_name)
        # you might want to take a look here:
        # https://stackoverflow.com/q/19611001/1091116
        r = getattr(self.int_, attribute_name)
        if callable(r):  # return a wrapper if integer's function was requested
            def f(*args, **kwargs):
                if args and isinstance(args[0], U32):
                    args = (args[0].int_, ) + args[1:]
                ret = r(*args, **kwargs)
                if ret is NotImplemented:
                    return ret
                if attribute_name in ['__str__', '__repr__', '__index__']:
                    return ret
                ret %= 2**32
                return U32(ret)
            return f
        return r

print(U32(4) / 2)
print(4 / U32(2))
print(U32(4) / U32(2))
</code></pre>
<p>And here's the error:</p>
<pre><code>Traceback (most recent call last):
  File "u32.py", line 41, in &lt;module&gt;
    print(U32(4) / 2)
TypeError: unsupported operand type(s) for /: 'U32' and 'int'
</code></pre>
<p>It looks like the <code>getattr</code> trick doesn't get called at all in Python 3. Why is that? How can I get this code working both under Python 2 and 3?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your Python 2 solution relied on <em>old style class</em> behaviour. Your Python 2 code would fail in the same manner as Python 3 were you to make your class inherit from <code>object</code>:</p>
<pre><code>class U32(object):
</code></pre>
<p>This is because special methods are looked up on the <em>type</em>, not the object itself, for new-style classes. This behaviour change fixed several corner cases with the old model.</p>
<p>In practice this means that methods like <code>__div__</code> are looked up directly on <code>U32</code> itself, not as attributes on <em>instances</em> of <code>U32</code>, and the <code>__getattr__</code> hook is not consulted.</p>
<p>Unfortunately, special method lookups also <em>bypass</em> any <code>__getattr__</code> or <code>__getattribute__</code> hooks. See the <a href="http://docs.python.org/3/reference/datamodel.html#special-method-lookup" rel="nofollow">documentation on Special Method lookups</a>:</p>
<blockquote>
<p>In addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the <code>__getattribute__()</code> method even of the objectâ€™s metaclass:</p>
<p><em>[...]</em></p>
<p>Bypassing the <code>__getattribute__()</code> machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method must be set on the class object itself in order to be consistently invoked by the interpreter).</p>
</blockquote>
<p>Your only option then, is to set all special methods dynamically on your class. A class decorator would do fine here:</p>
<pre><code>def _build_delegate(name, attr, cls, type_):
    def f(*args, **kwargs):
        args = tuple(a if not isinstance(a, cls) else a.int_ for a in args)
        ret = attr(*args, **kwargs)
        if not isinstance(ret, type_) or name == '__hash__':
            return ret
        return cls(ret)
    return f

def delegated_special_methods(type_):
    def decorator(cls):
        for name, value in vars(type_).items():
            if (name[:2], name[-2:]) != ('__', '__') or not callable(value):
                continue
            if hasattr(cls, name) and not name in ('__repr__', '__hash__'):
                continue
            setattr(cls, name, _build_delegate(name, value, cls, type_))
        return cls
    return decorator

@delegated_special_methods(int)
class U32(object):
    def __init__(self, num=0, base=None):
        """Creates the U32 object.

        Args:
            num: the integer/string to use as the initial state
            base: the base of the integer use if the num given was a string
        """
        if base is None:
            self.int_ = int(num) % 2**32
        else:
            self.int_ = int(num, base) % 2**32
    def __coerce__(self, ignored):
        return None
    def __str__(self):
        return "&lt;U32 instance at 0x%x, int=%d&gt;" % (id(self), self.int_)
</code></pre>
<p>I updated the proxy function to handle multiple arguments correctly, and to auto-coerce back to your custom class if <code>int</code> is returned.</p>
</div>
<span class="comment-copy">Could you please show an example of <code>__getattr__</code> metaclass?</span>
<span class="comment-copy">After that, the answer will be complete and I'll be happy to accept it.</span>
<span class="comment-copy">@d33tah: I was getting to it. :-) I'll write you a specific one, in the meantime, take a look at this <a href="http://stackoverflow.com/a/11281744">older answer of mine</a>.</span>
<span class="comment-copy">Thank you for the link and for your time. Looking forward to the specific one :)</span>
<span class="comment-copy">@d33tah: Actually, I forgot about the fact that <code>__special__</code> special method lookups also ignore <code>__getattribute__</code> and <code>__getattr__</code>. Updated to give you an alternative.</span>
