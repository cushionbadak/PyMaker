<div class="post-text" itemprop="text">
<p>I understand that IPython is not <a href="http://rodesia.org/2012/09/04/making-ipython-virtualenv-aware/" rel="noreferrer">virtualenv-aware</a> and that the most logical solution to this is to install ipython in each virtualenv seperately using </p>
<pre><code>pip install ipython
</code></pre>
<p>So far so good. One thing I noticed is that if the system-wide copy of IPython is called from within a virtualenv using <code>$&gt; ipython</code> before IPython is installed under this virtualenv, subsequent <code>$&gt; ipython</code> commands will continue to bring up the system-wide ipython copy. </p>
<p>On the other hand, if ipython is <strong>not</strong> called prior to installing it under a virtualenv <code>$&gt; ipython</code> will bring up the newly installed copy. </p>
<p>What is the explanation for this?</p>
<p>It also makes me wonder if this behavior means I should expect some trouble down the way? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>alias ipy="python -c 'import IPython; IPython.terminal.ipapp.launch_new_instance()'"</code></p>
<p>This is a great way of always being sure that the ipython instance always belongs to the virtualenv's python version. </p>
<p>This works only on ipython &gt;2.0.</p>
<p><a href="https://coderwall.com/p/xdox9a">Source</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can force IPython to use a virtual environment if available by adding file below to <code>~/.ipython/profile_default/startups</code>:</p>
<pre><code>import os
import sys

if 'VIRTUAL_ENV' in os.environ:
    py_version = sys.version_info[:2] # formatted as X.Y 
    py_infix = os.path.join('lib', ('python%d.%d' % py_version))
    virtual_site = os.path.join(os.environ.get('VIRTUAL_ENV'), py_infix, 'site-packages')
    dist_site = os.path.join('/usr', py_infix, 'dist-packages')

    # OPTIONAL: exclude debian-based system distributions sites
    sys.path = filter(lambda p: not p.startswith(dist_site), sys.path)

    # add virtualenv site
    sys.path.insert(0, virtual_site)
</code></pre>
<p>I recommend naming it <code>00-virtualenv.py</code> so changes will be made as early as possible.</p>
<p>Note: Make sure ipython is installed in the new virtual environment to get this to work.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answer given by @SiddharthaRT is good! Following this approach, it is simpler for me just:</p>
<pre><code>python -m IPython
</code></pre>
<p>This will use the module IPython through the python bin, ensuring that it refers to the bin from the virtual env.</p>
</div>
<div class="post-text" itemprop="text">
<p>As others mentioned, recent versions of ipython are virtualenv aware, so you can use your virtualenv bin <a href="https://virtualenv.pypa.io/en/stable/userguide/#activate-script" rel="noreferrer">activate</a> script to run ipython using your virtualenv, e.g.</p>
<pre><code>$ source venv/bin/activate
(venv) $ ipython
WARNING: Attempting to work in a virtualenv. If you encounter problems, please install IPython inside the virtualenv.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're trying to open a notebook, even ipython 5 won't help - ipython will disregard the virtualenv (at least on my machine/setup).
You'll need to use rgtk's script, but please make sure to modify the optional filter part and the sys.path.insert as below:</p>
<pre><code>import os
import sys

if 'VIRTUAL_ENV' in os.environ:
    py_version = sys.version_info[:2] # formatted as X.Y 
    py_infix = os.path.join('lib', ('python%d.%d' % py_version))
    virtual_site = os.path.join(os.environ.get('VIRTUAL_ENV'), py_infix, 'site-packages')
    dist_site = os.path.join('/usr', py_infix, 'dist-packages')

    # OPTIONAL: exclude debian-based system distributions sites
    # ADD1: sys.path must be a list
    sys.path = list(filter(lambda p: not p.startswith(dist_site), sys.path))

    # add virtualenv site
    # ADD2: insert(0 is wrong and breaks conformance of sys.path
    sys.path.insert(1, virtual_site)
</code></pre>
<ul>
<li>ADD1: in the original script we get back a filter object, we would break sys.path and insert below would fail</li>
<li>ADD2: see <a href="https://stackoverflow.com/questions/10095037/why-use-sys-path-appendpath-instead-of-sys-path-insert1-path">this question</a> and <a href="https://docs.python.org/3/library/sys.html#sys.path" rel="nofollow noreferrer">python documentation</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>(Debian/Ubuntu) assuming some version (x) of Python3 is installed, then:</p>
<pre><code>$ sudo apt-get install -y ipython
$ virtualenv --python=python3.x .venv
$ source .venv/bin/activate
$ pip3 install ipython
$ ipython3
</code></pre>
<p>will launch ipython running your version of Python3.</p>
</div>
<span class="comment-copy">Recent versions of IPython should recognise virtualenvs without needing to be installed separately - you'll see a "trying to work in a virtualenv" message when it starts. The 'sticky' command you see is bash caching the location of the <code>ipython</code> executable somewhere (<a href="http://unix.stackexchange.com/questions/5609/how-do-i-clear-bashs-cache-of-paths-to-executables">see this question</a>).</span>
<span class="comment-copy">Thomas, thanks for the link about bash caching, it seems that this is exactly what happens. IPython 1.1.0 shows me an 'Attempting to work in a virtualenv' warning but it does not recognise the virtualenv unless installed within a virtualenv - but that's fine I just wanted to make sure the procedure is unproblematic.</span>
<span class="comment-copy">what version of virtualenv are you using, and how are you activating the env? The command you are missing is <code>hash -r</code>, which drops the cache of previously run commands, which is typically executed as part of activating an env. Check for <code>hash -r</code> in ENV/bin/activate.</span>
<span class="comment-copy">yes, true! As Thomas pointed out, this was a bash caching issue and running <code>hash -r</code> before activating an env resolves the problem. FYI I was working with virtualenv 1.10.1</span>
<span class="comment-copy">BTW, profile name can be passed via kwargs. Thanks for that answer!</span>
<span class="comment-copy">This works great in Python 2 environments, but in version 3 envs I get an ImportError stating theres no module named "IPython". Running ipython3 outside the environment works, do you know what I'm missing here?</span>
<span class="comment-copy">So many downvotes.  If this doesn't work for you, please comment with an error message and output of <code>ipython --version; cat /etc/issue</code></span>
<span class="comment-copy">This will work with IPython's console, but will not work with other things, for example IPython kernel.</span>
