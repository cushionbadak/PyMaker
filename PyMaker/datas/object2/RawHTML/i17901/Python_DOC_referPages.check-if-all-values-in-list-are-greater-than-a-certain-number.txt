<div class="post-text" itemprop="text">
<pre><code>my_list1 = [30,34,56]
my_list2 = [29,500,43]
</code></pre>
<p>How to I check if all values in list are &gt;= 30? <code>my_list1</code> should work and <code>my_list2</code> should not.</p>
<p>The only thing I could think of doing was:</p>
<pre><code>boolean = 0
def func(ls):
    for k in ls:
        if k &gt;= 30:
            boolean = boolean + 1
        else:
            boolean = 0
    if boolean &gt; 0:
        print 'Continue'
    elif boolean = 0:
        pass
</code></pre>
<h1>Update 2016:</h1>
<p>In hindsight, after dealing with bigger datasets where speed actually matters and utilizing <code>numpy</code>...I would do this:</p>
<pre><code>&gt;&gt;&gt; my_list1 = [30,34,56]
&gt;&gt;&gt; my_list2 = [29,500,43]

&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; A_1 = np.array(my_list1)
&gt;&gt;&gt; A_2 = np.array(my_list2)

&gt;&gt;&gt; A_1 &gt;= 30
array([ True,  True,  True], dtype=bool)
&gt;&gt;&gt; A_2 &gt;= 30
array([False,  True,  True], dtype=bool)

&gt;&gt;&gt; ((A_1 &gt;= 30).sum() == A_1.size).astype(np.int)
1
&gt;&gt;&gt; ((A_2 &gt;= 30).sum() == A_2.size).astype(np.int)
0
</code></pre>
<p>You could also do something like: </p>
<pre><code>len([*filter(lambda x: x &gt;= 30, my_list1)]) &gt; 0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/3/library/functions.html#all" rel="noreferrer"><code>all()</code> function</a> with a generator expression:</p>
<pre><code>&gt;&gt;&gt; my_list1 = [30, 34, 56]
&gt;&gt;&gt; my_list2 = [29, 500, 43]
&gt;&gt;&gt; all(i &gt;= 30 for i in my_list1)
True
&gt;&gt;&gt; all(i &gt;= 30 for i in my_list2)
False
</code></pre>
<p>Note that this tests for greater than <em>or equal to</em> 30, otherwise <code>my_list1</code> would not pass the test either.</p>
<p>If you wanted to do this in a function, you'd use:</p>
<pre><code>def all_30_or_up(ls):
    for i in ls:
        if i &lt; 30:
            return False
    return True
</code></pre>
<p>e.g. as soon as you find a value that proves that there is <em>a</em> value below 30, you return <code>False</code>, and return <code>True</code> if you found no evidence to the contrary.</p>
<p>Similarly, you can use the <a href="http://docs.python.org/3/library/functions.html#any" rel="noreferrer"><code>any()</code> function</a> to test if <em>at least 1</em> value matches the condition.</p>
</div>
<div class="post-text" itemprop="text">
<p>...any reason why you can't use <code>min()</code>?</p>
<pre><code>def above(my_list, minimum):
    if min(my_list) &gt;= minimum:
        print "All values are equal or above", minimum
    else:
        print "Not all values are equal or above", minimum
</code></pre>
<p>I don't know if this is exactly what you want, but technically, this is what you asked for...</p>
</div>
<div class="post-text" itemprop="text">
<p>There is a builtin function <code>all</code>:</p>
<pre><code>all (x &gt; limit for x in my_list)
</code></pre>
<p>Being limit the value greater than which all numbers must be.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>all()</code>:</p>
<pre><code>my_list1 = [30,34,56]
my_list2 = [29,500,43]
if all(i &gt;= 30 for i in my_list1):
    print 'yes'
if all(i &gt;= 30 for i in my_list2):
    print 'no'
</code></pre>
<p>Note that this includes all numbers equal to 30 or higher, not strictly above 30.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do the following:</p>
<pre><code>def Lists():

    my_list1 = [30,34,56]
    my_list2 = [29,500,43]

    for element in my_list1:
        print(element &gt;= 30)

    for element in my_list2:
        print(element &gt;= 30)

Lists()
</code></pre>
<p>This will return the values that are greater than 30 as True, and the values that are smaller as false.</p>
</div>
<div class="post-text" itemprop="text">
<p>The overall winner between using the np.sum, np.min, and all seems to be np.min in terms of speed for large arrays:</p>
<pre><code>N = 1000000
def func_sum(x):
    my_list = np.random.randn(N)
    return np.sum(my_list &lt; x )==0

def func_min(x):
    my_list = np.random.randn(N)
    return np.min(my_list) &gt;= x

def func_all(x):
    my_list = np.random.randn(N)
    return all(i &gt;= x for i in my_list)
</code></pre>
<p>(i need to put the np.array definition inside the function, otherwise the np.min function remembers the value and does not do the computation again when testing for speed with timeit)</p>
<p>The performance of "all" depends very much on when the first element that does not satisfy the criteria is found, the np.sum needs to do a bit of operations, the np.min is the lightest in terms of computations in the general case.</p>
<p>When the criteria is almost immediately met and the all loop exits fast, the all function is winning just slightly over np.min:</p>
<pre><code>&gt;&gt;&gt; %timeit func_sum(10)
10 loops, best of 3: 36.1 ms per loop

&gt;&gt;&gt; %timeit func_min(10)
10 loops, best of 3: 35.1 ms per loop

&gt;&gt;&gt; %timeit func_all(10)
10 loops, best of 3: 35 ms per loop
</code></pre>
<p>But when "all" needs to go through all the points, it is definitely much worse, and the np.min wins:</p>
<pre><code>&gt;&gt;&gt; %timeit func_sum(-10)
10 loops, best of 3: 36.2 ms per loop

&gt;&gt;&gt; %timeit func_min(-10)
10 loops, best of 3: 35.2 ms per loop

&gt;&gt;&gt; %timeit func_all(-10)
10 loops, best of 3: 230 ms per loop
</code></pre>
<p>But using</p>
<pre><code>np.sum(my_list&lt;x)
</code></pre>
<p>can be very useful is one wants to know how many values are below x.</p>
</div>
<div class="post-text" itemprop="text">
<p>I write this function</p>
<pre><code>def larger(x, than=0):
    if not x or min(x) &gt; than:
        return True
    return False
</code></pre>
<p>Then</p>
<pre><code>print larger([5, 6, 7], than=5)  # False
print larger([6, 7, 8], than=5)  # True
print larger([], than=5)  # True
print larger([6, 7, 8, None], than=5)  # False
</code></pre>
<p><br/></p>
<p>Empty list on <a href="https://docs.python.org/2/library/functions.html#min" rel="nofollow noreferrer">min()</a> will raise ValueError. So I added <code>if not x</code> in condition.</p>
</div>
<span class="comment-copy">A general issues to be aware of: 1) the assigned <code>boolean</code> variable is <i>local</i> to the function (as there is no appropriate <a href="http://stackoverflow.com/questions/4693120/use-of-global-keyword-in-python"><code>global</code> annotation</a>), and 2) <code>boolean = 0</code> is an <i>assignment</i>, not a comparison.</span>
<span class="comment-copy">Note that your <code>my_list1</code> has <i>one</i> value that is <i>not</i> above 30. It is instead equal to 30. Should that be 31 instead, or are you testing for greater than <i>or equal to</i> 30 here?</span>
<span class="comment-copy">What is the advantage of using <code>all_30_or_up</code> over <code>all</code>? Shouldn't <code>all</code> also stop consuming the iterator as soon as a negative has been found? Would be quite dumb otherwise, wouldn't it?</span>
<span class="comment-copy">@Hyperboreus: both stop as soon as a negative has been found. I wanted to give the OP a different way of looking at the problem, giving them a function to replace the one they were writing.</span>
<span class="comment-copy">@MartijnPieters, Mucho &lt;3</span>
<span class="comment-copy">The disadvantage of this solution is, that each item of list must be touched.</span>
<span class="comment-copy">I did a little profiling on this. <code>all</code> shortcircuits, so it's much faster if the list does not qualify. But if the list is all 30+, <code>min</code> can be faster. I tested with two 1000-element lists of random integers, one filled with <code>random.randint(0, 100)</code> (failing) and one filled with <code>random.randint(30, 100)</code>. Using <code>min</code> took slightly less than half the time on the 30-100 list. But <code>all</code> took about 2% of the time that <code>min</code> did on the 0-100 list, so it probably wins unless failing lists are very rare.</span>
<span class="comment-copy">You are both right! Thanks!</span>
<span class="comment-copy">As it turned out, the first element of my 0-100 list was below 30, so my test was kind of degenerate. Forcing the first sub-30 element to be halfway through the list, <code>min</code> comes out a bit faster - 0.25s for 10000 repetitions rather than 0.32s for <code>all</code>. So which is faster depends on the nature of the data, as you'd expect.</span>
<span class="comment-copy">As <code>my_list1</code> should test <code>True</code>, the test should almost certainly be <code>&gt;= 30</code>, not <code>&gt; 30</code>.</span>
<span class="comment-copy">Well, when OP's question text contradicts itself, who am I to judge which is the correct limit.</span>
<span class="comment-copy">As <code>my_list1</code> should test <code>True</code>, the test should almost certainly be <code>&gt;= 30</code>, not <code>&gt; 30</code>.</span>
<span class="comment-copy">@MartijnPieters thanks, now updated. Question mentions above 30 but <code>&gt;= 30</code> seems intended.</span>
<span class="comment-copy">I know, that's why I made that explicit. :-)</span>
