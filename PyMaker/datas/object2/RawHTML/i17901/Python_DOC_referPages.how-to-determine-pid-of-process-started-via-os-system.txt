<div class="post-text" itemprop="text">
<p>I want to start several subprocesses with a programm, i.e. a module <code>foo.py</code> starts several instances of <code>bar.py</code>.</p>
<p>Since I sometimes have to terminate the process manually, I need the process id to perform a kill command.</p>
<p>Even though the whole setup is pretty “dirty”, is there a good pythonic way to obtain a process’ <code>pid</code>, if the process is started via <code>os.system</code>?</p>
<p><code>foo.py:</code></p>
<pre><code>import os
import time
os.system("python bar.py \"{0}\ &amp;".format(str(argument)))
time.sleep(3)
pid = ???
os.system("kill -9 {0}".format(pid))
</code></pre>
<p><code>bar.py:</code></p>
<pre><code>import time
print("bla")
time.sleep(10) % within this time, the process should be killed
print("blubb")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>os.system</code> return exit code. It does not provide pid of the child process.</p>
<p>Use <a href="http://docs.python.org/3/library/subprocess.html"><code>subprocess</code></a> module.</p>
<pre><code>import subprocess
import time
argument = '...'
proc = subprocess.Popen(['python', 'bar.py', argument], shell=True)
time.sleep(3) # &lt;-- There's no time.wait, but time.sleep.
pid = proc.pid # &lt;--- access `pid` attribute to get the pid of the child process.
</code></pre>
<p>To terminate the process, you can use <a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen.terminate"><code>terminate</code></a> method or <a href="http://docs.python.org/3/library/subprocess.html#subprocess.Popen.kill"><code>kill</code></a>. (No need to use external <code>kill</code> program)</p>
<pre><code>proc.terminate()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sharing my solution in case it can help others:</p>
<p>I took the info from this page to run a fortran exe in the background. I tried to use os.forkpty to get the pid of it, but it didnt give the pid of my process. I cant use subprocess, because I didnt find out how it would let me run my process on the background.</p>
<p>With help of a colleague I found this:</p>
<pre><code>exec_cmd = 'nohup ./FPEXE &amp; echo $! &gt; /tmp/pid'

os.system(exec_cmd)
</code></pre>
<p>In case of wanting to append pids to the same file, use double arrow.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>os.forkpty()</code> instead, which, as result code, gives you the pid and fd for the pseudo terminal. More documentation here: <a href="http://docs.python.org/2/library/os.html#os.forkpty" rel="nofollow">http://docs.python.org/2/library/os.html#os.forkpty</a></p>
</div>
<span class="comment-copy"><i>"therefore the subprocess <code>Popen(["python", "bar.py", "arguments"])</code> is too slow."</i> -- have you actually measured it? <a href="http://stackoverflow.com/questions/10888846/python-subprocess-module-much-slower-than-commands-deprecated">The question that you've linked</a> shows different case and anyway the time difference is a couple of milliseconds.</span>
<span class="comment-copy">Yes, I have measured it. It was around 20 to 30ms, which was in my specific case too slow, since I had a scrolling graphic, which had to be updated multiple times per second. <code>os.spawnl</code> gave me the desired functionality, even though it added around one second to start each process, but without stopping my main process. It is still not the ideal solution, but for my case bettern than <code>subprocess.Popen</code>.</span>
<span class="comment-copy">You should've mentioned it in the question (ideally, with a complete minimal code example that other people can try). Beware <code>spawn</code> inherits all inheritable file descriptors (<code>Popen</code> closes them (Python 3)). Can you start processes before hand and pause them and then only unpause them (send input or a signal)? Why can't you use <code>bar.py</code> script in the same process? btw, why <code>spawn</code> would add a whole second to the starting of a process compared to <code>Popen</code>?</span>
<span class="comment-copy">Some details about my program: A continously (several times per second) updated diagram scrolls from right to left side. In <code>bar.py</code>, several time-consuming calculations are made. While the calculations are not done, it is written “calculating” in the diagram. If the user makes any input, the calculations have to be terminated and new calculations have to be started. It is less important, that the results of calculations are made quickly, than that the diagram does move smoothly. The reason for the extra second remains unclear to me.</span>
<span class="comment-copy">After having made several other changes, I realized, that I cannot reproduce either the longer time for starting a process via Popen nor the extra second when starting a process via Popen. I will alter the question to make the accepted answer fit and revoke my solution. Sorry for bothering you all – I have no idea, where my previous results came from.</span>
<span class="comment-copy">This is my current configuration, but subprocess.Popen is a bit too slow...</span>
<span class="comment-copy">@SebastianWerk, According to <a href="http://docs.python.org/3/library/os.html#os.spawnl" rel="nofollow noreferrer"><code>os.spawn*</code> documentation</a>, "Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. ..."</span>
<span class="comment-copy">I know, therefor I used it in first place, but it takes around 20ms to start one process on my computer, and this is a bit too long ):</span>
<span class="comment-copy">@SebastianWerk, How about posting <b>EDIT</b> part of your question as answer and accepting it instead of trying to close your question?</span>
<span class="comment-copy">Ok, thank you anyway.</span>
<span class="comment-copy">Thanks, I will use this as a fallback, if <code>os.spawnl(...)</code> fails</span>
