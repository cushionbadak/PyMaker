<div class="post-text" itemprop="text">
<p>I have a directory with a python package as follows:</p>
<pre><code>--docs/index.rst
--docs/...
--app/__init__.py
--app/foo.py
</code></pre>
<p>and I'm using sphinx with autodocs for documenting the app (in python 3.3).</p>
<p>Now, in the <code>conf.py</code> (inside <code>docs/</code>), I have</p>
<pre><code>sys.path.insert(0, os.path.abspath('../app'))
</code></pre>
<p>I <code>cd</code> into <code>docs/</code>, run</p>
<pre><code>make html
</code></pre>
<p>which gives me </p>
<p>SystemError: Parent module '' not loaded, cannot perform relative import</p>
<p>to all the modules that have a </p>
<pre><code>from .foo import Bar
</code></pre>
<p>I have a clean virtualenv installation of Sphinx using </p>
<pre><code>pip install Sphinx
</code></pre>
<p>after I created the (clean) environment for python 3.3.</p>
<p>What am I missing?</p>
<p>I was moving the project from python 2.* to python 3.* when this happened. All the project is working, but this...</p>
</div>
<div class="post-text" itemprop="text">
<p>Your <code>app</code> directory is a package. A package is a directory with <code>__init.py__</code> and other files inside it.</p>
<p>If you put a package directory on your <code>sys.path</code>, all kinds of things go wrong.</p>
<p>Let's take an example:</p>
<pre><code>root/
    app/
        app/__init__.py
        app/spam.py
        app/eggs.py
</code></pre>
<hr/>
<p>If you have <code>root</code> on your <code>sys.path</code> (because it's your current working directory, or because you do it explicitly, or because you've installed things correctly to your <code>site-packages</code>), then <code>app</code> is a package, <code>app.spam</code> is a module, and, within <code>app.eggs</code>, <code>.spam</code> is that module. So, everything works.</p>
<p>If you have <code>app</code> on your <code>sys.path</code>, then <code>app</code> is not a package, <code>spam</code> is a module, and, within <code>eggs</code>, <code>.spam</code> isn't anything. So, you can't use relative imports.</p>
<p>If you have <em>both</em> on your <code>sys.path</code>, then <code>app</code> is a package, <code>spam</code> and <code>app.spam</code> are both different modules (with the same contents, executed twice), and within <code>app.eggs</code>, <code>.spam</code> is a module, but within <code>eggs</code>, <code>.spam</code> isn't anything. This will cause you no end of problems.</p>
<hr/>
<p>So, most likely, the fix you want is this:</p>
<pre><code>sys.path.insert(0, os.path.abspath('..'))
</code></pre>
<p>If there are other packages, or directories full of Python code that aren't packages, in <code>..</code> that you don't want to autodoc (e.g., a <code>tests</code> directory with <code>tests/test_spam.py</code>), then you will need to restructure your directories to put <code>app</code> into some directory that doesn't have any other Python code in it, like this:</p>
<pre><code>root/
    src/
        app/
    tests/
    doc/
</code></pre>
<hr/>
<p>Alternatively, if you didn't want <code>app</code> to be a package, but rather to be a sys.path root directory, then kill the <code>__init__.py</code>, and leave <code>app</code> directly in <code>sys.path</code>. But in that case, you can't use intra-package relative imports; all of the modules in <code>app</code> are top-level modules, and have to be imported as such.</p>
<hr/>
<p>The <a href="http://docs.python.org/3/tutorial/modules.html#packages" rel="noreferrer">Packages</a> section of the tutorial (and the rest of the chapter above it) explains some of this, but there's probably better introductory documentation out there.</p>
<p>For full details, in 3.3+, <a href="http://docs.python.org/3/reference/import.html" rel="noreferrer">The import system</a> has everything, nicely organized; for older versions, the reference docs are muddy, incomplete, and scattered; you have to start at <a href="http://docs.python.org/2.7/reference/simple_stmts.html#the-import-statement" rel="noreferrer">The <code>import</code> statement</a>, and then read <a href="http://legacy.python.org/doc/essays/packages.html" rel="noreferrer">The Knights Who Say Neeeow ... Wum ... Ping!</a> (which is basically a PEP but 1.5 didn't have PEPs yet), and possibly even the <code>ni</code> documentation, if you can find it, plus various PEPs and minor change log entries that explain how things have changed between 1.5 and 2.7 or 3.2 or whatever.</p>
</div>
<span class="comment-copy">Is <code>app</code> a top-level package itself, or the directory that your top-level packages are in?</span>
<span class="comment-copy">I'm not sure I understood your question @abarnert. <code>app</code> doesn't have a directory inside, just a set of <code>*.py</code>, including <code>__init__.py</code>. sphinx only documents app dir.</span>
<span class="comment-copy">If <code>app</code> has <code>__init__.py</code> inside, then it's a package. And that's your problem. Let me write an answer to explain.</span>
<span class="comment-copy">By the way, you may be confused that the word "package" has two conflicting meanings in Python: it's "a thing you can import with other things you can import inside it", and it's also "a thing you put in <code>site-packages</code> or distribute on, e.g., PyPI".</span>
<span class="comment-copy">Very good answer. Thank you. You made me realise I have a lot to learn about the new system.</span>
<span class="comment-copy">@J.C.Leitão: If you were doing the same thing in Python 2.x, it was wrong there as well. It's just that 2.7 lets you get away with writing stuff that's halfway between Python 1.5-style and Python-3.3 style and sometimes it works…</span>
