<div class="post-text" itemprop="text">
<p>I solved the project euler <a href="http://projecteuler.net/problem=21" rel="nofollow">problem 21</a> using the following approach using python.</p>
<pre><code>ans = 0;
for i in range(1,10000):
    s = 0;
    su = 0;
    for j in range(1,i):
        if(i%j==0):
            s = s + j;
    if(i!=s):

        for k in range(1,s):
            if(s%k==0):
                su = su+k;
        if(su == i):
            ans=ans+i;
            print(ans);
</code></pre>
<p>It took around 35 seconds. I was wondering whether there is a better approach. How can I improve my algorith</p>
</div>
<div class="post-text" itemprop="text">
<p>To get more speed you need a better algorithm. Let's start with a function that finds the factors of <em>n</em> using a prime wheel, which is faster than naive trial division and suitable when <em>n</em> is small:</p>
<pre><code>def factors(n):
    wheel = [1,2,2,4,2,4,2,4,6,2,6]
    f, fs, next = 2, [], 0
    while f*f &lt;= n:
        while n % f == 0:
            fs.append(f)
            n /= f
        f += wheel[next]
        next += 1
        if next == 11: next = 4
    if n &gt; 1: fs.append(n)
    return fs
</code></pre>
<p>Then we use the factors of <em>n</em> to compute the sum of the divisors of <em>n</em>, without computing the divisors themselves; note the sum includes <em>n</em> itself:</p>
<pre><code>def d(n):
    mult, sum, prev = 2, 1, 0
    for fact in factors(n):
        if fact == prev:
            mult += 1
        elif prev &gt; 0:
            sum *= (prev**mult - 1) // (prev - 1)
            mult = 2
        prev = fact
    return sum * (prev**mult - 1) // (prev - 1)
</code></pre>
<p>Now it's just a matter of computing all the sums of divisors less than the limit, saving them in an array. If the sum of divisors of <em>n</em> is less than <em>n</em>, we check the previously-computed sum of divisors of the sum of divisors, and report those that are equal:</p>
<pre><code>def euler21a(limit):
    sum, sumDiv = 0, [0] * limit
    for n in range(2,limit):
        sumDiv[n] = d(n) - n
        if sumDiv[n] &lt; n and sumDiv[sumDiv[n]] == n:
            print sumDiv[n], n
            sum += sumDiv[n] + n
    return sum
</code></pre>
<p>Now we can run it:</p>
<pre><code>&gt;&gt;&gt; euler21a(10000)
220 284
1184 1210
2620 2924
5020 5564
6232 6368
31626
</code></pre>
<p>I didn't time it, but it obviously takes less than a second. There are five amicable pairs less than ten thousand, including 220 and 284 which were used in the example.</p>
<p>An even faster approach uses a sieve, similar to the Sieve of Eratosthenes, to accumulate the divisors of a range of numbers:</p>
<pre><code>def sieve(n):
    sumDiv = [0] * n
    for i in range(1,n):
        for j in range(i,n,i):
            sumDiv[j] += i
    return sumDiv
</code></pre>
<p>That computes the <em>sumDiv</em> array, which can be used in the solution:</p>
<pre><code>def euler21b(limit):
    sum, sumDiv = 0, sieve(limit)
    for n in range(2,limit):
        sumDiv[n] -= n
        if sumDiv[n] &lt; n and sumDiv[sumDiv[n]] == n:
            print sumDiv[n], n
            sum += sumDiv[n] + n
    return sum
</code></pre>
<p>And here is the solution, which appears instantly when my finger presses the Enter button:</p>
<pre><code>&gt;&gt;&gt; euler21b(10000)
220 284
1184 1210
2620 2924
5020 5564
6232 6368
31626
</code></pre>
<p>If you want to know more, I explain <a href="http://programmingpraxis.com/2009/05/08/wheel-factorization/" rel="nofollow">wheel factorization</a>, the <a href="http://programmingpraxis.com/2010/11/26/divisors-and-totatives/" rel="nofollow">sum of divisors</a> computation, and the <a href="http://programmingpraxis.com/2012/02/14/divisors/" rel="nofollow">sieving method</a> at my blog.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can improve the algorithm by noting that you need not loop through all possible numbers smaller than <code>i</code> to find an amicable pair.</p>
<p>Note that the problem of finding amicable pairs can be reformulated to the following 2 conditions:</p>
<ul>
<li><code>sum(factors(sum(factors(i)))) = i</code></li>
<li><code>sum(factors(i)) != i</code></li>
</ul>
<p>I don't claim the following is the fastest possible, but it's an improvment over 35 seconds:</p>
<pre><code>def factorize(n):
    factors = [1]
    for i in xrange(2, int(n**0.5)+1):
        if n%i==0:
            factors.append(i)
            factors.append(n/i)
    factors.append(n)

    return factors

def amicable(N=10000):
    s = 0
    for i in range(1, N):
        a = sum(factorize(i)) - i 
        b = sum(factorize(a)) - a
        if b==i and i!=a:
            s+=i
            print 'Found pair: ', i, a
    print 'Sum is: ', s
</code></pre>
<p>Note: we need to subtract <code>i</code> from <code>sum(factorize(i)) - i</code> due to my factorize function also including the number itself in the list of factors, while amicable numbers only require 'proper divisors'</p>
</div>
<div class="post-text" itemprop="text">
<p>The other answers work great, but here is yet another algorithm that touches on a topic you might find useful later in the PE series. This is an optimization on the sieve that user448810 posted. Here's the algorithm outline.</p>
<ul>
<li>Find <strong>prime</strong> factors of all numbers using a sieve</li>
<li>Calculate the multiplicity of each factor using a <a href="http://mathworld.wolfram.com/RulerFunction.html" rel="nofollow">Ruler Function</a></li>
<li>Sum the divisors using <a href="http://planetmath.org/FormulaForSumOfDivisors" rel="nofollow">this formula</a>.</li>
</ul>
<p>The initial code would look like this</p>
<pre><code>UPPERLIM = 10001
is_prime = [True] * UPPERLIM
sum_divs = [1] * UPPERLIM

for p in itertools.chain([2], range(3, UPPERLIM, 2)):
    # Iterate over possible primes, ie. 2 + all odd numbers
    if not is_prime[p]:
        continue

    for m in range(p, UPPERLIM, p):
        # Mark multiples of p as composite
        is_prime[m] = False
        v = times_p_divides_m(p, m)
        sum_divs[m] *= (p ** (v + 1) - 1) // (p - 1)

    # We marked p as composite in the loop above
    # remark as prime
    is_prime[p] = True

sum_divisors = [m-n for m, n in enumerate(sum_divisors)]
</code></pre>
<p>So far so good, except how do we calculate <code>v</code> which is defined as the number of times <code>p</code> divides into <code>m</code>. The naive solution would be to write:</p>
<pre><code>def time_p_divides_m(p, m):
    result = 0
    while m % p == 0:
        m = m // p
        result += 1
    return result
</code></pre>
<p>But this <strong>greatly</strong> increases the time complexity of our program. Instead we take advantage of the fact that we are calculating this for <strong>all multiples of p in order</strong>.</p>
<p>Really, I want how many powers of p are in p, 2p, 3p, 4p... Which is sometimes referred to as a generalized <a href="http://mathworld.wolfram.com/RulerFunction.html" rel="nofollow">ruler function</a>. For example with p = 2 we want to find the v's below.</p>
<pre><code>p   2
m   2   4   6   8  10  12  14  16  18  20  ...
v   1   2   1   3   1   2   1   4   1   2  ...
</code></pre>
<p>Thankfully, generating this sequence is much easier than counting how many times we can divide a number. So we define a ruler generator as follows</p>
<pre><code>def ruler(p, n):
    # Generates the values of the ruler function for a prime p
    # n is the value of ruler function at which to stop
    # ie. ruler(2, 4) will generate [1, 2, 1, 3, 1, 2, 1] and
    # stop because the next value is 4.

    if n == 1:
        # All rulers are "seeded" with 1 repeated p-1 times
        yield from (1 for m in range(p - 1))
        raise StopIteration

    # the next "chunk" of a ruler is always
    # chunk(n-1) n .. repeat p-1 times .. chunk(n-1)
    for i in range(p - 1):
        yield from ruler(p, n - 1)
        yield n
    yield from ruler(p, n - 1)
</code></pre>
<p>So the final code becomes:</p>
<pre><code>UPPERLIM = 10001
is_prime = [True] * UPPERLIM
sum_divs = [1] * UPPERLIM

def ruler(p, n):
    if n == 1:
        yield from (1 for m in range(p-1))
        raise StopIteration
    for i in range(p-1):
        yield from ruler(p, n-1)
        yield n
    yield from ruler(p, n-1)

for p in itertools.chain([2], range(3, UPPERLIM, 2)):
    if not is_prime[p]:
        continue

    multiples = range(p, UPPERLIM, p)
    powers = ruler(p, int(math.log(UPPERLIM, p)+1))
    for m, v in zip(multiples, powers):
        is_prime[m] = False
        sum_divs[m] *= (p ** (v + 1) - 1) // (p - 1)
    is_prime[p] = True

sum_divisors = [(n-m) for m, n in enumerate(sum_divisors)]

result = set()
for n in range(2, UPPERLIM):
    b = sum_divs[n]
    if b &lt; UPPERLIM and b != n and n == sum_divisors[b]:
        print('Amicable pair\t{0}\t{1}'.format(n, b))
        result.add(n)
print('Total: {0}'.format(sum(result)))
</code></pre>
<p>Which gives the output</p>
<pre><code>Amicable pair   220     284
Amicable pair   284     220
Amicable pair   1184    1210
Amicable pair   1210    1184
Amicable pair   2620    2924
Amicable pair   2924    2620
Amicable pair   5020    5564
Amicable pair   5564    5020
Amicable pair   6232    6368
Amicable pair   6368    6232
Total: 31626
</code></pre>
</div>
<span class="comment-copy">Now put it in C, it'll take 1.5 seconds ;) (joke)</span>
<span class="comment-copy">@Julius wonder if it will</span>
<span class="comment-copy">I generally use a <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="nofollow noreferrer">Sieve of Eratosthenes</a></span>
<span class="comment-copy">I'm not a Python expert. On my system, on both Python 2 and Python 3, the <code>yield from</code> that appears twice in the <code>ruler</code> function causes a compilation error. How can I make this run?</span>
<span class="comment-copy"><a href="http://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer">yield from</a> was added in python3.3, if it's not available then you can substitute <code>yield from my_generator</code> with <code>for item in my_generator: yield item</code></span>
