<div class="post-text" itemprop="text">
<p>from <a href="https://wiki.python.org/moin/HowTo/Sorting/#The_Old_Way_Using_the_cmp_Parameter">python wiki</a>: 
<code>In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods).</code></p>
<p>I do not understand the reasoning why cmp is removed in py3.0</p>
<p>consider this example:</p>
<pre><code>&gt;&gt;&gt; def numeric_compare(x, y):
        return x - y
&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]
</code></pre>
<p>and now consider this version (recommended and compatible with 3.0):</p>
<pre><code>def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &gt;= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return K

&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]
</code></pre>
<p>The latter is very verbose and the same purpose is achieved in the former with just one line. On another note, I am writing my custom class for which I want to write the <code>__cmp__</code> method. from my little reading across web, it is recommended to write <code>__lt__,__gt__,__eq__,__le__,__ge__,__ne__ and not __cmp__</code>
Again, why this recommendation? can I not just define <code>__cmp__</code> making life simpler?</p>
</div>
<div class="post-text" itemprop="text">
<p>For two objects <code>a</code> and <code>b</code>, <code>__cmp__</code> requires that <em>one of</em> <code>a &lt; b</code>, <code>a == b</code>, and <code>a &gt; b</code> is true.  But that might not be the case: consider sets, where it's very common that <em>none of those</em> are true, e.g. <code>{1, 2, 3}</code> vs <code>{4, 5, 6}</code>.</p>
<p>So <code>__lt__</code> and friends were introduced.  But that left Python with two separate ordering mechanisms, which is kind of ridiculous, so the less flexible one was removed in Python 3.</p>
<p>You don't actually have to implement all six comparison methods.  You can use the <a href="http://docs.python.org/3/library/functools.html#functools.total_ordering"><code>@total_ordering</code> decorator</a> and only implement <code>__lt__</code> and <code>__eq__</code>.</p>
<p>edit: Also note that, in the case of sorting, <code>key</code> functions can be more efficient than <code>cmp</code>: in the example you gave, Python may have to call your Python comparison function O(n²) times.  But a <code>key</code> function only needs to be called O(n) times, and if the return value is then a builtin type (as it very often is), the O(n²) pairwise comparisons go through C.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>cmp</code> was removed because the <code>key</code> attribute to <code>.sort()</code> and <code>sorted()</code> is superior in most cases. It was a hold-over from C more than anything, and was confusing to boot. Having to implement a separate <code>__cmp__</code> method <em>next</em> to the rich comparison operators (<code>__lt__</code>, <code>__gt__</code>, etc.) was befuddling and unhelpful.</p>
<p>You can always use <a href="http://docs.python.org/3/library/functools.html#functools.cmp_to_key" rel="noreferrer"><code>functools.cmp_to_key()</code></a> to adapt an existing <code>cmp</code> function.</p>
<p>Your specific example could have been implemented <em>without</em> a <code>key</code> function, of course, as integers are already orderable; just add <code>reverse=True</code>.</p>
<p>For custom classes, use the <a href="http://docs.python.org/3/library/functools.html#functools.total_ordering" rel="noreferrer"><code>@functools.total_ordering</code> decorator</a> to expand a <code>__eq__</code> and <em>one</em> comparison operator method (e.g. <code>__lt__</code>, or <code>__gt__</code>, etc.) into a full ordering implementation.</p>
</div>
<span class="comment-copy">You're asking about two different things, the <code>__cmp__</code> method to make classes comparable, and the <code>cmp</code> keyword argument to sorting functions to customize the sorting. Of course they're not totally unrelated, but they're not the same thing by any means. When you write a <code>cmp</code> function that compares your objects, it doesn't care whether it's using <code>__cmp__</code> or <code>__lt__</code> to do so; when you write a <code>key</code> function that creates key values for your objects, it doesn't care whether it's using <code>__cmp__</code> or <code>__lt__</code> (or neither) to do so. So, which of the two questions are you asking?</span>
<span class="comment-copy">(Actually, there's a third thing you may be confusing, the <a href="http://docs.python.org/2/library/functions.html#cmp" rel="nofollow noreferrer"><code>cmp</code></a> function, also removed in 3.x.)</span>
<span class="comment-copy">all of kinds of cmp are removed in 3.X or it is not recommended to use..correct?</span>
<span class="comment-copy">@user2708477: Right, the <code>__cmp__</code> special method is never called, there is no <code>cmp</code> parameter to any of the sorting-related functions, and there is no builtin <code>cmp</code> function.</span>
<span class="comment-copy">@user2708477: Exactly.</span>
<span class="comment-copy">@user1988876: Rich comparison methods solve the problem because <code>__lt__</code> and <code>__gt__</code> can <i>both</i> return <code>False</code> (and <code>__le__</code> and <code>__ge__</code> and <code>__eq__</code> also return <code>False</code>, of course, so only <code>__ne__</code> returns <code>True</code>). That directly represents the fact that the first set is neither less than, greater than, or equal to the second.</span>
<span class="comment-copy">@user1988876: Also, this answer assumes that you know what comparing sets does in Python, but I suspect you don't actually know that. <code>a &lt; b</code> for sets means that <code>a</code> is a proper subset of <code>b</code>. Which makes it obvious why you should get the results you do for <code>{1, 2, 3} &lt; {4, 5, 6}</code>.</span>
<span class="comment-copy">@user1988876 and this is the problem with <code>__cmp__</code>: you have to choose one of the three possible answers, and your first instinct is to <i>make up</i> something that lets you do that, but none of them are correct for those two sets.  (you can't compare sets by their first elements because they're unordered!)</span>
<span class="comment-copy">Something that I just realized (and imho can be a better example than comparison between disjoint sets): <code>cmp(float('nan'), float('nan'))</code> yields <code>-1</code> even if obviously <code>float('nan') &lt; float('nan')</code> is <code>False</code></span>
<span class="comment-copy">We should accept that <code>cmp</code> function is more flexible that <code>key</code> function, even though we can convert our <code>cmp</code> to <code>key</code> in 99% of times easily, in some cases we can never do this for sure (not in a clean way), specially when compatibility with C code is what matters. while C is still using <code>strcmp</code>, Python drops all types of <code>cmp</code>.</span>
<span class="comment-copy">And, in the same vein, <code>functools.total_ordering</code> could be helpful for the second bit -- Although I always thought it should live in a <code>classtools</code> module instead :)</span>
<span class="comment-copy">for custom classes, why is it recommended not to use <code>cmp</code>? but instead <code>__ge__, __lt__</code> etc..</span>
<span class="comment-copy">@user1988876: Besides the answer I gave to that same question on the comments on the other answer, there's the fact that <code>__cmp__</code> is deprecated, and will never be called if a superclass or subclass defines any of the four rich comparisons (which can lead to some fun bugs), and of course doesn't work at all in 3.x. Also, you're still confusing <code>cmp</code> with <code>__cmp__</code>.</span>
<span class="comment-copy">This can't be implemented without a <code>key</code>, because he's comparing in <i>reverse</i>. (In this case, the <code>key</code> could just be <code>neg</code>, or <code>lambda x: -x</code>.) Well, it can be implemented without a <code>key</code> if you use the <code>reverse</code> keyword instead, but you need one of the two.</span>
<span class="comment-copy">@user1988876: <code>@functools.total_ordering</code> is indeed a class decorator.</span>
