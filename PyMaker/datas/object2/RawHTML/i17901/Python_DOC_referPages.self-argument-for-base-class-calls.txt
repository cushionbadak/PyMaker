<div class="post-text" itemprop="text">
<p>I'm working through Dusty Philip's "Python 3 Object Oriented Programming", which is excellent by the way, and I'm working through the diamond inheritance problem. Conceptually, it was a piece of cake, but there was a code snippet which I'm not 100% sure I understand. </p>
<pre><code>class BaseClass(object):
    num_base_calls = 0
    def call_me(self):
        print('Calling method on Base Class')
        self.num_base_calls += 1

class LeftSubClass(BaseClass):
    num_left_calls = 0
    def call_me(self):
        BaseClass.call_me(self)
        print("Calling method on Left Subclass")
        self.num_left_calls += 1

class RightSubClass(BaseClass):
    num_right_calls = 0
    def call_me(self):
        BaseClass.call_me(self)
        print("Calling method on Right Subclass")
        self.num_right_calls += 1

class SubClass(LeftSubClass,RightSubClass):
    num_sub_calls = 0
    def call_me(self):
        LeftSubClass.call_me(self)
        RightSubClass.call_me(self)
        print("Calling method on SubClass")
        self.num_sub_calls += 1
</code></pre>
<p>My question is, why do all the calls to the base classes in the subclasses include the self argument? As far as I can see, if we created an object instance:</p>
<pre><code>a = BaseClass()
a.call_me()
</code></pre>
<p>should work because the self argument is implicit. So why in the sub classes do we need </p>
<pre><code>BaseClass.call_me(self)? 
</code></pre>
<p>Is it because, strictly speaking, we haven't created an instance of BaseClass but an instance of the SubClass, and hence if you call BaseClass.call_me() from within the subclass there is no implicit self argument to pass to it? </p>
</div>
<div class="post-text" itemprop="text">
<p>In this case you are passing self, (the current class instance), as a parameter to the parent class so that it can make use of it, save it or otherwise access it. Normally this would actually be called as BaseClass(self, self) but in this case it can be read as *which_base_class*.function(param) especially in the last example.  </p>
<p>It is important to note that the example is <strong>partial</strong> as without an <code>__init__(self)</code> class member to each class <code>self</code> is just another name with no special meaning.</p>
<p>Ideally the example should have used <code>super</code> and new style classes - it is worth reading <a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow">this</a> article as well as the <a href="http://docs.python.org/3/library/functions.html#super" rel="nofollow">documents on super</a>.</p>
</div>
<span class="comment-copy">But that's slightly confusing, because the argument list for call_me in the Base Class is only self. With what you're saying, it should be something like call_me(self, otherclassinstance)? I can see why it works, don't get me wrong, but it feels a little implicit and dirty.</span>
<span class="comment-copy">My bad I have clarified above.</span>
<span class="comment-copy">Just to your last point - this example is illustrating why we SHOULD use super() - it's an example showing the problem where the base class gets initalised twice because of the lack of using super().  I understand that fine, I was just confused about the use of the self argument in this case and wanted to clarify.</span>
