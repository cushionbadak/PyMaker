<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/7891277/why-does-setattr-fail-on-a-bound-method">Why does setattr fail on a bound method</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I'm wondering if it is possible to use setattr to set an attribute to a method within a class like so because when I try I get an error which is going to be shown after the code:</p>
<pre><code>class Test:
    def getString(self, var):
        setattr(self.getString, "string", var)
        return self.getString
test = Test()
test.getString("myString").string
</code></pre>
<p>Which errors <code>AttributeError: 'method' object has no attribute 'string'</code> so I tried it without putting <code>.string</code> and just tried <code>test.getString("myString")</code> Same error, but then I tried it without the using the class just like this</p>
<pre><code>def getString(var):
    setattr(getString, "string", var)
    return getString

getString("myString").string
</code></pre>
<p>It returned "myString" like I wanted it to, so how would I do this within a class and why does it work outside of one but inside of one? </p>
</div>
<div class="post-text" itemprop="text">
<p><code>type( test.getString )</code> is <code>builtins.method</code> and from the documentations ( <a href="http://docs.python.org/3/library/stdtypes.html#methods" rel="nofollow">methods</a> ), </p>
<blockquote>
<p>since method attributes are actually stored on the underlying function
  object (<code>meth.__func__</code>), setting method attributes on bound methods is
  disallowed. Attempting to set an attribute on a method results in an
  <code>AttributeError</code> being raised.</p>
</blockquote>
<p>There are (at least) two possible solutions depending on which behaviour you are looking for. One is to set the attribute on the class method:</p>
<pre><code>class Test:
    def getString(self, var):
        setattr(Test.getString, "string", var)
        return self.getString

test = Test()
test.getString("myString").string  # &gt; "myString"

test2 = Test()
test2.getString.string # &gt; this is also "myString"
</code></pre>
<p>and the other is to use function objects:</p>
<pre><code>class Test:
    class getStringClass:
        def __call__ ( self, var ):
            setattr( self, "string", var )
            return self

    def __init__( self ):
        self.getString = Test.getStringClass( )

test = Test( )
test.getString( "myString" ).string   # &gt; "myString"

test2 = Test()
test2.getString.string  # &gt; this is error, because it does not
                        # have the attribute 'string' yet
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Functions are like most other objects in that you can freely add attributes to them. Methods, on the other hand... conceptually they're just functions, but they behave slightly differently (implicity pass <code>self</code>) and therefore are implemented with a bit of extra glue around functions.</p>
<p>Every time <code>self.getString</code> is evaluated, a new (bound) method object is created, which is a thin wrapper around the underlying function (which you can access as <code>Test.getString</code>). These method objects don't allow adding attributes, and even if they did, your code would not work because it juggles multiple distinct method objects (though they all wrap the same function).</p>
<p>You can't make this work with bound methods. Since you presumably want the string to be attached to the <code>Test</code> object (indirectly, by being attached to its method), you can make it an attribute of <code>Test</code>. You could even create your own object that behaves like a method but allows attributes (you'd have to explicitly add it in <code>__init__</code>), but honestly there's probably a better way that keeps data and methods separated. If, on the other hand, you want to attach this attribute to the underlying function (which would mean it's shared by all <code>Test</code> instances), you can just set the attribute on <code>Test.getString</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>So, I found a way but it's not really how I wanted to do it personally. If anyone does find another way to do the following code feel free to comment on how to do it. </p>
<pre><code>class Test:
    def getString(self, string):
        setattr(self,"newString",self)
        self.newString.string = string
    return self.newString
</code></pre>
<p>Like I said, I don't feel like I accomplished anything by doing it that way, but it works for what I need and if you do find another way comment below.</p>
</div>
<span class="comment-copy">Why did you use <code>setattr</code> for your experiment instead of <code>self.getString.string = var</code>?</span>
<span class="comment-copy">Related: <a href="http://stackoverflow.com/questions/7034063/adding-attributes-to-instancemethods-in-python">Adding attributes to instancemethods in Python</a></span>
<span class="comment-copy">@user2357112 not sure, just personal preference I guess, but it still would give the same error I'm just wondering on how I would set something up like that.</span>
<span class="comment-copy">Ah, I see thank you for your explanation of why it did not work.</span>
<span class="comment-copy">This method can be written more simply as <code>self.string = string; return self</code>. The <code>newString</code> is a self-reference and doesn't buy you anything.</span>
<span class="comment-copy">Yeah, that is true, but I would rather assign one variable if I wanted multiple attributes like if the method accepted multiple objects you could do <code>test.getString("hello","world").stringOne</code> or the opposite <code>test.getString("hello","world").stringTwo</code> I would rather use one thing but thats just personal preference they would both do the same thing.</span>
<span class="comment-copy">I don't think you fully understood. With your code, <code>test.getString("a")</code> sets (in addition to <code>test.newString</code>) the attribute <code>test.string</code>. An equivalent two-argument function would add the attributes <code>newString</code>, <code>stringOne</code> and <code>stringTwo</code> to <code>test</code>. The only thing my simplification removes is <code>test.newString</code>, which is redundant as it's always the same as <code>test</code>.</span>
<span class="comment-copy">Yeah, I just prefer having it for what I was trying to do not necessarily for my example code though, but anyways I choose a different route of using <code>setattr(Test.getString,"string",string)</code> since it eliminates the problem of test.myString.string and test.string doing the same thing it gives an error with the other way.</span>
