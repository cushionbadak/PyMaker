<div class="post-text" itemprop="text">
<p>Using Django 1.5.1:</p>
<pre><code>DEBUG = False

LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(message)s'
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        # root logger
        '': {
            'handlers': ['console'],
        },
        #'django.request': {
        #    'handlers': ['console'],
        #    'level': 'DEBUG',
        #    'propagate': False,
        #},
    }
}
</code></pre>
<p>If I uncomment the commented lines and call a view which has <code>1/0</code>, the traceback is printed to the console:</p>
<pre><code>ERROR 2013-11-29 13:33:23,102 base Internal Server Error: /comment/*******/
Traceback (most recent call last):
  ...
  File "*****/comments/views.py", line 10, in post
    1/0
ZeroDivisionError: integer division or modulo by zero
WARNING 2013-11-29 13:33:23,103 csrf Forbidden (CSRF cookie not set.): /comment/******/
[29/Nov/2013 13:33:23] "POST /comment/******/ HTTP/1.0" 500 27
</code></pre>
<p>But if the lines stay commented, no traceback is printed to the console, just:</p>
<pre><code>[29/Nov/2013 13:33:23] "POST /comment/******/ HTTP/1.0" 500 27
</code></pre>
<p>I thought if <code>django.request</code> logger is not configured, it would propagate to the root logger, which prints everything to console.</p>
<p>I didn't find any information that <code>django.request</code> is special.</p>
<p>Why it doesn't work?</p>
<p><a href="https://docs.djangoproject.com/en/dev/topics/logging/#django-s-default-logging-configuration">Here</a> I read:</p>
<blockquote>
<p>Prior to Django 1.5, the LOGGING setting always overwrote the default Django logging configuration. From Django 1.5 forward, it is possible to get the project’s logging configuration merged with Django’s defaults, hence you can decide if you want to add to, or replace the existing configuration.</p>
<p>If the disable_existing_loggers key in the LOGGING dictConfig is set to True (which is the default) the default configuration is completely overridden. Alternatively you can redefine some or all of the loggers by setting disable_existing_loggers to False.</p>
</blockquote>
<p>In <code>django/utils/log.py</code>:</p>
<pre><code># Default logging for Django. This sends an email to the site admins on every
# HTTP 500 error. Depending on DEBUG, all other log records are either sent to
# the console (DEBUG=True) or discarded by mean of the NullHandler (DEBUG=False).
DEFAULT_LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console':{
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
        },
        'null': {
            'class': 'django.utils.log.NullHandler',
        },
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
        },
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': False,
        },
        'py.warnings': {
            'handlers': ['console'],
        },
    }
}
</code></pre>
<p>So by default <code>django.request</code> has <code>propagate = False</code>. But In my case I have <code>'disable_existing_loggers': True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The solution is to prevent Django from configuring logging and handle it ourselves. Fortunately this is easy. In <code>settings.py</code>:</p>
<pre><code>LOGGING_CONFIG = None
LOGGING = {...}  # whatever you want, as you already have

import logging.config
logging.config.dictConfig(LOGGING)
</code></pre>
<p><strong>UPDATE ~March 2015</strong>: Django has <a href="https://github.com/django/django/pull/4362" rel="noreferrer">clarified</a> their <a href="https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-logging" rel="noreferrer">documentation</a>:</p>
<blockquote>
<p>If the disable_existing_loggers key in the LOGGING dictConfig is set
  to True then all loggers from the default
  configuration will be disabled. Disabled loggers are not the same as
  removed; the logger will still exist, but will silently discard
  anything logged to it, not even propagating entries to a parent
  logger. Thus you should be very careful using
  'disable_existing_loggers': True; it’s probably not what you want.
  Instead, you can set disable_existing_loggers to False and redefine
  some or all of the default loggers; or you can set LOGGING_CONFIG to
  None and handle logging config yourself.</p>
</blockquote>
<p><strong>For posterity and detail:</strong> The explanation? Most of the confusion I think comes down to Django's poor <a href="https://docs.djangoproject.com/en/1.6/topics/logging/#configuring-logging" rel="noreferrer">explanation</a> of <code>disable_existing_loggers</code>, which says that when True, "the default configuration is completely overridden". In your own answer you discovered that is not correct; what's happening is that the existing loggers, which Django already configures, are <strong>disabled</strong> not replaced.</p>
<p>The Python logging <a href="http://docs.python.org/2/library/logging.config.html#logging.config.fileConfig" rel="noreferrer">documentation</a> explains it better (emphasis added):</p>
<blockquote>
<p>disable_existing_loggers – If specified as False, loggers which exist
  when this call is made are left alone. The default is True because
  this enables old behaviour in a backward-compatible way. This
  behaviour is to <em>disable</em> any existing loggers unless they or their
  ancestors are explicitly named in the logging configuration.</p>
</blockquote>
<p>Based on Django docs we think, "override the defaults with my own LOGGING configuration and anything I don't specify will <em>bubble up</em>". I've tripped over this expectation as well. The behavior we expect is along the lines of <strong>replace_existing_loggers</strong> (which isn't a real thing). Instead the Django loggers are <em>shut up</em> not <em>bubbled up</em>.</p>
<p>We need to prevent the setup of these Django loggers in the first place and here the Django <a href="https://docs.djangoproject.com/en/1.6/topics/logging/#disabling-logging-configuration" rel="noreferrer">docs</a> are more helpful:</p>
<blockquote>
<p>If you don’t want to configure logging at all (or you want to manually
  configure logging using your own approach), you can set LOGGING_CONFIG
  to None. This will disable the configuration process.</p>
<p>Note: Setting LOGGING_CONFIG to None only means that the configuration
  process is disabled, not logging itself. If you disable the
  configuration process, Django will still make logging calls, falling
  back to whatever default logging behavior is defined.</p>
</blockquote>
<p>Django will still use its loggers but since they are not handled (and then disabled) by the configuration, those loggers will bubble up as expected. A simple test with the above settings:</p>
<pre><code>manage.py shell
&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.warning('root logger')
WARNING 2014-03-11 13:35:08,832 root root logger
&gt;&gt;&gt; l = logging.getLogger('django.request')
&gt;&gt;&gt; l.warning('request logger')
WARNING 2014-03-11 13:38:22,000 django.request request logger
&gt;&gt;&gt; l.propagate, l.disabled
(1, 0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Ok, so the behavior is "correct", but not expected. <code>django/conf/__init__.py:65</code>:</p>
<pre><code>def _configure_logging(self):
    ...
    if self.LOGGING_CONFIG:
        from django.utils.log import DEFAULT_LOGGING
        # First find the logging configuration function ...
        logging_config_path, logging_config_func_name = self.LOGGING_CONFIG.rsplit('.', 1)
        logging_config_module = importlib.import_module(logging_config_path)
        logging_config_func = getattr(logging_config_module, logging_config_func_name)

        logging_config_func(DEFAULT_LOGGING)

        if self.LOGGING:
            # Backwards-compatibility shim for #16288 fix
            compat_patch_logging_config(self.LOGGING)

            # ... then invoke it with the logging settings
            logging_config_func(self.LOGGING)
</code></pre>
<p>What is happening is that default logging configuration is applied and <code>django.request</code> logger is created. Then my custom <code>LOGGING</code> configuration is applied with <code>disable_existing_loggers = True</code>, but Python doesn't delete already existing logger <code>django.request</code>, but only disables it.</p>
<p>So I have to manually reconfigure <code>django.request</code> logger in my configuration. :(</p>
</div>
<div class="post-text" itemprop="text">
<p>For Django-2.1 I found that the logging configuration is more concise:</p>
<pre><code>$ ./manage.py shell

&gt;&gt;&gt; import logging
&gt;&gt;&gt; # Grub all Django loggers
&gt;&gt;&gt; loggers = [
        name for name in logging.root.manager.loggerDict 
        if 'django' in name
    ]
&gt;&gt;&gt; for each in loggers:
        logger = logging.getLogger(each)
        print(
            'Logger Name: {0}\nLogger Handlers: {1}\n'
            'Logger Propagates: {2}\n\n'.format(
                each, 
                logger.handlers, 
                logger.propagate
            )
        )

Logger Name: django.db
Logger Handlers: []
Logger Propagates: True


Logger Name: django.request
Logger Handlers: []
Logger Propagates: True


Logger Name: django.template
Logger Handlers: []
Logger Propagates: True


Logger Name: django.db.backends
Logger Handlers: []
Logger Propagates: True


Logger Name: django.db.backends.schema
Logger Handlers: []
Logger Propagates: True


Logger Name: django.security.csrf
Logger Handlers: []
Logger Propagates: True


Logger Name: django
Logger Handlers: [&lt;logging.StreamHandler object at 0x7f706d5dd780&gt;, &lt;django.utils.log.AdminEmailHandler object at 0x7f706d740cf8&gt;]
Logger Propagates: True


Logger Name: django.contrib.gis
Logger Handlers: []
Logger Propagates: True


Logger Name: django.contrib
Logger Handlers: []
Logger Propagates: True


Logger Name: django.security
Logger Handlers: []
Logger Propagates: True


Logger Name: django.server
Logger Handlers: [&lt;logging.StreamHandler object at 0x7f706d59eba8&gt;]
Logger Propagates: False
</code></pre>
<p>As quoted <a href="https://docs.djangoproject.com/en/dev/topics/logging/#django-s-default-logging-configuration" rel="nofollow noreferrer">in the docs</a>:</p>
<blockquote>
<p>All loggers except django.server propagate logging to their parents, up to the root django logger. The console and mail_admins handlers are attached to the root logger to provide the behavior described above.</p>
</blockquote>
<p>This is in accordance with the docs of <a href="https://docs.python.org/3/library/logging.html#logging.Logger.propagate" rel="nofollow noreferrer"><code>propagate</code></a> which state that: </p>
<blockquote>
<p>Note</p>
<p>If you attach a handler to a logger and one or more of its ancestors,
  it may emit the same record multiple times. In general, you should not
  need to attach a handler to more than one logger - if you just attach
  it to the appropriate logger which is highest in the logger hierarchy,
  then it will see all events logged by all descendant loggers, provided
  that their propagate setting is left set to True. A common scenario is
  to attach handlers only to the root logger, and to let propagation
  take care of the rest.</p>
</blockquote>
<p>Therefore I decided not to prevent Django from configuring logging. I wanted to stop sending emails to the admins because I use <a href="https://sentry.io/welcome/" rel="nofollow noreferrer">sentry</a>, and I just configured the root logger to use the <code>console</code> and <code>file</code> handlers, according to the django docs <a href="https://docs.djangoproject.com/en/dev/topics/logging/#examples" rel="nofollow noreferrer">examples</a>:</p>
<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'file': {
            'level': 'INFO',
            'filters': ['require_debug_false'],
            'class': 'logging.FileHandler',
            'filename': os.path.join(LOGGING_DIR, 'django.log'),
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
    }
}
</code></pre>
<p>Which results in:</p>
<pre><code>Logger Name: django
Logger Handlers: [&lt;logging.FileHandler object at 0x7f5aa0fd1cc0&gt;, &lt;logging.StreamHandler object at 0x7f5aa0fd1ef0&gt;]
Logger Propagates: True
</code></pre>
<p>Not tested in production yet, but it seems that it will work as expected.</p>
</div>
<span class="comment-copy">thanks for bringing this issue upfront on stackoverflow. May I also ask you that according to the default logging config, the key 'propagate' was set to false, so, in your case it did not propagate to root logger but did it then send the mail to admins about the error?</span>
<span class="comment-copy">Thank you so much for this, I've been banging my head on this problem for an hour. LOGGING_CONFIG = None does the trick.</span>
<span class="comment-copy">I've been banging my head on this problem (on and off) for years! ;) This is amazing, I finally managed to set up a logging configuration that I understand myself!</span>
<span class="comment-copy">Also, a good tool to analyze the current logging configuration is <a href="http://rhodesmill.org/brandon/2012/logging_tree/" rel="nofollow noreferrer">logging_tree</a></span>
