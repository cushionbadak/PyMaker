<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/526125/why-is-python-ordering-my-dictionary-like-so">Why is python ordering my dictionary like so? [duplicate]</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>When I run this code the dictionary that is produced does not match the dates in the strings that I am extracting the dates from. How do I put this dictionary in order by date?  past  to future.  Also why is the dictionary out of order?</p>
<pre><code>page = str('&lt;OPTION VALUE="08/25/2013" &gt;08/25/2013&lt;/OPTION&gt;&lt;OPTION VALUE="09/01/2013"&gt;09/01/2013&lt;/OPTION&gt;&lt;OPTION VALUE="09/08/2013" &gt;09/08/2013&lt;/OPTION&gt;&lt;OPTION VALUE="09/15/2013" &gt;09/15/2013&lt;/OPTION&gt;&lt;OPTION VALUE="09/22/2013" &gt;09/22/2013&lt;/OPTION&gt;&lt;OPTION VALUE="09/29/2013" &gt;09/29/2013&lt;/OPTION&gt;&lt;OPTION VALUE="10/06/2013" &gt;10/06/2013&lt;/OPTION&gt;&lt;OPTION VALUE="10/13/2013" &gt;10/13/2013&lt;/OPTION&gt;&lt;OPTION VALUE="10/20/2013"&gt;10/20/2013&lt;/OPTION&gt;&lt;OPTIONVALUE="10/27/2013"&gt;10/27/2013&lt;/OPTION&gt;&lt;OPTION VALUE="11/03/2013" &gt;11/03/2013&lt;/OPTION&gt;&lt;OPTION VALUE="11/10/2013" &gt;11/10/2013&lt;/OPTION&gt;&lt;OPTION VALUE="11/17/2013" &gt;11/17/2013&lt;/OPTION&gt;&lt;OPTION VALUE="11/24/2013" &gt;11/24/2013&lt;/OPTION&gt;&lt;OPTION VALUE="12/01/2013" &gt;12/01/2013&lt;/OPTION&gt;&lt;OPTION VALUE="12/08/2013" &gt;12/08/2013&lt;/OPTION&gt;&lt;OPTION VALUE="12/15/2013" &gt;12/15/2013&lt;/OPTION&gt;OPTION VALUE="12/22/2013" &gt;12/22/2013&lt;/OPTION&gt;&lt;OPTION VALUE="12/29/2013" &gt;12/29/2013&lt;/OPTION&gt;&lt;OPTION VALUE="01/05/2014" &gt;01/05/2014&lt;/OPTION&gt;&lt;OPTION VALUE="01/12/2014" &gt;01/12/2014&lt;/OPTION&gt;&lt;OPTION VALUE="01/19/2014" &gt;01/19/2014&lt;/OPTION&gt;&lt;OPTION VALUE="01/26/2014" &gt;01/26/2014&lt;/OPTION&gt;&lt;OPTION VALUE="02/02/2014" &gt;02/02/2014&lt;/OPTION&gt;&lt;OPTION VALUE="02/09/2014" &gt;02/09/2014&lt;/OPTION&gt;&lt;OPTION VALUE="02/16/2014" &gt;02/16/2014&lt;/OPTION&gt;&lt;OPTION VALUE="02/23/2014" &gt;02/23/2014&lt;/OPTION&gt;&lt;OPTION VALUE="03/02/2014" &gt;03/02/2014&lt;/OPTION&gt;&lt;OPTION VALUE="03/09/2014" &gt;03/09/2014&lt;/OPTION&gt;&lt;OPTION VALUE="03/16/2014" &gt;03/16/2014&lt;/OPTION&gt;&lt;OPTION VALUE="03/23/2014" &gt;03/23/2014&lt;/OPTION&gt;&lt;OPTION VALUE="03/30/2014" &gt;03/30/2014&lt;/OPTION&gt;&lt;OPTION VALUE="04/06/2014" &gt;04/06/2014&lt;/OPTION&gt;&lt;OPTION VALUE="04/13/2014" &gt;04/13/2014&lt;/OPTION&gt;&lt;OPTION VALUE="04/20/2014" &gt;04/20/2014&lt;/OPTION&gt;&lt;OPTION VALUE="04/27/2014" &gt;04/27/2014&lt;/OPTION&gt;&lt;OPTION VALUE="05/04/2014" &gt;05/04/2014&lt;/OPTION&gt;&lt;OPTION VALUE="05/11/2014" &gt;05/11/2014&lt;/OPTION&gt;&lt;OPTION VALUE="05/18/2014" &gt;05/18/2014&lt;/OPTION&gt;&lt;OPTION VALUE="05/25/2014" &gt;05/25/2014&lt;/OPTION&gt;&lt;OPTION VALUE="06/01/2014" &gt;06/01/2014&lt;/OPTION&gt;&lt;OPTION VALUE="06/08/2014" &gt;06/08/2014&lt;/OPTION&gt;&lt;OPTION VALUE="06/15/2014" &gt;06/15/2014&lt;/OPTION&gt;')


def web_link (enter_web_link):
#11%2F10%2F2013
    enter_web_link =  enter_web_link.replace("/","%") #00%00%0000
    add_twoF = enter_web_link[:3]+"2F"+ enter_web_link[3:]  #00%2F00%0000
    add_twoF_everywhere = add_twoF[:8] +"2F"+add_twoF[8:]
    add_twoF_everywhere = str(add_twoF_everywhere)
    return  add_twoF_everywhere

def search_13(page):
    starter = '&lt;OPTION VALUE="' # find the postion where this starts
    start_link = page.find(starter)
    starter = len(starter)
    if start_link == -1:
        return None, 0 
    start_link = start_link + starter
    end_date = start_link + 10
    datetext  = page[start_link: end_date]
    str_date = str(datetext) #this is hte actuall normal looking date dd/mm/yyyy
    enter_web_link = str_date 
    endoflinkdate = web_link(enter_web_link)
    return str_date , end_date,  endoflinkdate


def getalllinks(page):
    links = {}  
    while True:
        str_date,end_date,endoflinkdate = search_13(page)
        if str_date:
            links[str_date] ='dont want you to have this link' +  endoflinkdate
            page = page[end_date:]
        else:
            break
    return links



work = getalllinks(page)
print work
</code></pre>
<p>I heard the sort function only works for lists and also each date is a string. 
I would rather have a way that does not use a library.</p>
<p>when I try using:</p>
<pre><code>class OrderedCounter(Counter, OrderedDict):
     'Counter that remembers the order elements are first encountered'

     def __repr__(self):
         return '%s(%r)' % (self.__class__.__name__, OrderedDict(self))

     def __reduce__(self):
         return self.__class__, (OrderedDict(self),)
</code></pre>
<p>it i get an eror Counter is not defined. How am I supposed to use this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Dictionaries are by definition unordered. If you care about the (insertion) order, you can use <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow">collections.OrderedDict</a>. Otherwise you could iterate over the keys in order and then access the elements of the dict:</p>
<pre><code>for key in sorted(d.keys()):
    print(d[key])
</code></pre>
</div>
<span class="comment-copy">Dictionaries are not a ordered type. Use an <a href="http://docs.python.org/2/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> if you really want ordering.</span>
<span class="comment-copy">The documentation is clear on the subject. You should make sure you read it.</span>
