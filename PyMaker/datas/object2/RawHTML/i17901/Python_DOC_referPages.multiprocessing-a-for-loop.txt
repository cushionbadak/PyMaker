<div class="post-text" itemprop="text">
<p>I have an array (called <code>data_inputs</code>) containing the names of hundreds of astronomy images files. These images are then manipulated. My code works and takes a few seconds to process each image. However, it can only do one image at a time because I'm running the array through a <code>for</code> loop:</p>
<pre><code>for name in data_inputs:
    sci=fits.open(name+'.fits')
    #image is manipulated
</code></pre>
<p>There is no reason why I have to modify an image before any other, so is it possible to utilise all 4 cores on my machine with each core running through the for loop on a different image?</p>
<p>I've read about the <code>multiprocessing</code> module but I'm unsure how to implement it in my case.
I'm keen to get <code>multiprocessing</code> to work because eventually I'll have to run this on 10,000+ images.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="noreferrer"><code>multiprocessing.Pool</code></a>:</p>
<pre><code>from multiprocessing import Pool

def process_image(name):
    sci=fits.open('{}.fits'.format(name))
    &lt;process&gt;

if __name__ == '__main__':
    pool = Pool()                         # Create a multiprocessing Pool
    pool.map(process_image, data_inputs)  # process data_inputs iterable with pool
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>multiprocessing.Pool</code>:</p>
<pre class="lang-python prettyprint-override"><code>from multiprocessing import Pool
class Engine(object):
    def __init__(self, parameters):
        self.parameters = parameters
    def __call__(self, filename):
        sci = fits.open(filename + '.fits')
        manipulated = manipulate_image(sci, self.parameters)
        return manipulated

try:
    pool = Pool(8) # on 8 processors
    engine = Engine(my_parameters)
    data_outputs = pool.map(engine, data_inputs)
finally: # To make sure processes are closed in the end, even if errors happen
    pool.close()
    pool.join()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively</p>
<pre><code>with Pool() as pool: 
    pool.map(fits.open, [name + '.fits' for name in datainput])
</code></pre>
</div>
<span class="comment-copy">It might be better to use: <code>pool = Pool(os.cpu_count())</code>  This is a more generic way of using multiprocessing.</span>
<span class="comment-copy">Note: <code>os.cpu_count()</code> was added in Python 3.4.  For Python 2.x, use <code>multiprocessing.cpu_count()</code>.</span>
<span class="comment-copy"><code>Pool()</code> is the same as <code>Pool(os.cpu_count())</code></span>
<span class="comment-copy">To elaborate on @Tim's comment - <code>Pool()</code> called without a value for <code>processes</code> is the same as <code>Pool(processes=cpu_count())</code> regardless of whether you are using Python 3 or 2 - so the best practice in EITHER version is to use <code>Pool()</code>. <a href="https://docs.python.org/2/library/multiprocessing.html" rel="nofollow noreferrer">docs.python.org/2/library/multiprocessing.html</a></span>
<span class="comment-copy">@LiorMagen , if I'm not mistaken, using Pool(os.cpu_count()) will make the OS freeze until the processing is over, as you don't leave the OS any free cores. For a lot of users Pool(os.cpu_count() - 1) might be a better choice</span>
<span class="comment-copy">I am unable to understand what is "data_inputs" here. You haven't defined it. What value should I give it?</span>
<span class="comment-copy">It actually stems from alko's answer, I'm citing his comment (see the code block): "proces data_inputs iterable with pool". So <code>data_inputs</code> is an iterable (like in a standard <code>map</code>).</span>
<span class="comment-copy"><code>TypeError: 'Pool' object is not callable</code></span>
<span class="comment-copy">Sorry my mistake it is "pool.map" not just "pool". I fixed it.</span>
