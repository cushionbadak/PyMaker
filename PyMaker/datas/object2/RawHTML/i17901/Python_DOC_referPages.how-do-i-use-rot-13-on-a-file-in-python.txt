<div class="post-text" itemprop="text">
<p>im trying to rewrite every character in a file with rot 13 and im stuck, im not sure how to go through the file and look at every character and not worry about the spaces between paragraphs</p>
<pre><code># [import statements]
import q2fun
# [constants]

# [rest of program code]
f = open("rot-13.txt", "w", encoding="utf-8")
result = q2fun.rot13(f)

def rot13(f):

    f.seek(0)
#   y = 0
    result = ""
    for char in f:
        x = ord(char)
        if 97 &lt;= x &lt; 110 or 65 &lt;= x &lt; 78:
#           string[y]=char.replace(char, chr(x+13))
            char = char.replace(char, chr(x + 13))
            result = result + char
            print(char)
            continue
#           y+=1
        elif x &gt;= 110 or 78 &lt;= x &lt; 91:
#           string[y]=char.replace(char, chr(x-13))
            char = char.replace(char, chr(x - 13))
            print(char)
            result = result + char
            continue
#           y+=1
        result = result + char
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just want to do this as easily as possible, use the <code>rot_13</code> codec, as described in Joran Beasley's answer.</p>
<p>If you want to know how to do it manually, or what was wrong with your existing code, I can explain. You're actually very close.</p>
<p>If <code>f</code> is a file, <code>for char in f:</code> iterates over the <em>lines</em> of the file, not the <em>characters</em>. If you want to iterate over the characters one by one, either loop around <code>f.read(1)</code>, or read the whole thing into a string with <code>s = f.read()</code> and then iterate over <code>s</code>.</p>
<p>If you fix that, your program now works as written. However, it's more complicated than necessary.</p>
<p>First, <code>char = char.replace(char, chr(x + 13))</code> is unnecessary. <code>str.replace</code> searches the string, substitutes the replacement character for all instances of the search character, and returns the resulting string. But you don't need any of that—you're searching all one character, replacing the one instance of the search character with the resulting character, and returning the resulting character as a one-character string—in other words, the same string you already had. All you want to do here is <code>char = chr(x + 13)</code>.</p>
<p>Also, you can remove the three separate <code>result = result + char</code> and <code>continue</code>; all three conditions lead to the same thing.</p>
<p>Also, instead of comparing <code>x</code> to ordinal values (which are hard to read, and easy to get wrong), you can just compare <code>char</code> to character values. So:</p>
<pre><code>def rot13(f):
    s = f.read()
    result = ""
    for char in s:
        x = ord(char)
        if 'a' &lt;= char &lt;= 'm' or 'A' &lt;= char &lt;= 'M':
            char = chr(x + 13)
        elif 'n' &lt;= char &lt;= 'z' or 'N' &lt;= char &lt;= 'Z':
            char = chr(x - 13)
        result = result + char
    return result
</code></pre>
<p>You can simplify your comparisons further by using <code>str.lower</code>:</p>
<pre><code>        if 'a' &lt;= char.lower() &lt;= 'm':
</code></pre>
<p>(This replaces the <code>if 'a'…</code> line in the above code, and you do the same thing for the <code>elif 'n'…</code> line.)</p>
<p>You can simplify things even further by using the collections in the <code>string</code> class:</p>
<pre><code>        if char in string.ascii_letters:
            if char.lower() &lt;= 'm':
                char = chr(x + 13)
            else:
                char = chr(x - 13)
</code></pre>
<p>(This replaces the whole <code>if</code>/<code>elif</code> block.)</p>
<p>Or, if you know that the <code>%</code> (mod/remainder) operator does, you can simplify it even further: <code>rot13(ch)</code> is just <code>(ch+13) % 26</code> (where <code>ch</code> is a letter number from <code>0</code> to <code>25</code>, which you can get with <code>ord(char) % 32</code>). The usual C implementations take advantage of this, and you can write them more clearly with the <code>divmod</code> function in Python. But I'll leave that as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import codecs


with open("plaintext.txt") as f_in, open("rot-13.txt", "w") as f_out:
    f_out.write(codecs.encode(f_in.read(),"rot_13"))

with open("rot-13.txt") as encoded:
    print (codecs.decode(encoded.read(),"rot_13"))
</code></pre>
<p>See the documentation on the <a href="http://docs.python.org/3/library/codecs.html" rel="nofollow"><code>codecs</code></a> module, or the built-in <code>help</code> in the interactive interpreter, for an explanation of these functions. See the documentation on the <a href="http://docs.python.org/3/library/codecs.html#standard-encodings" rel="nofollow">Standard Encodings</a> (and following sections), or import the <code>encodings</code> module and use the built-in <code>help</code>, to see a list of encodings you can use with these functions.</p>
</div>
<span class="comment-copy">Are you trying to learn how to do this manually, or just looking for the easiest way to do it?</span>
<span class="comment-copy">both would work</span>
<span class="comment-copy">Well, you're already pretty close; your <code>rot13</code> algorithm is actually correct, it's just that you're not reading files correctly. So, it's worth learning how to fix it. But it's also worth learning how to use the "batteries included" in Python, and if you need this for a real use rather than just for learning, it's better to use the batteries. So, without knowing which one you want, the question really needs two answers…</span>
<span class="comment-copy">whats the differnce</span>
<span class="comment-copy">What's the difference between writing it yourself and using something that's already built in? Using something built in means less work for you. It means you get code that's been debugged in various edge cases you didn't think about, and sometimes optimized as well. It means someone reading your code can look up the function you call in the docs instead of having to find and read the implementation. But writing it yourself means you get to learn how it works and what it really does.</span>
<span class="comment-copy">meh you have more patience than me :) great answer</span>
<span class="comment-copy">so isthe third one like the first one or do you need both</span>
<span class="comment-copy">@user2980776: The simplifications don't replace the entire function; they just replace part of the code. I've added comments in parentheses to explain exactly what parts you replace.</span>
<span class="comment-copy">i did it and it says that s=f.read() is io.UnsupportedOperation: not readable</span>
<span class="comment-copy">@user2980776: Well, what <code>f</code> are you passing it? It has to be an open, readable file object. In your original code, you're passing it a file opened in write-only mode (<code>'w'</code>), which will raise this exception. You may need to go over <a href="http://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" rel="nofollow noreferrer">Reading and Writing Files</a> in the tutorial to get the basics.</span>
<span class="comment-copy">@user2980776: For Python 3.x compatibility, use <code>import codecs; codecs.encode(f_in.read(), 'rot_13')</code> instead.</span>
<span class="comment-copy">there noow it will work in python 3 :) .. and it will work just as well for rot15 ;P</span>
<span class="comment-copy">@JoranBeasley: No. According to <a href="http://stackoverflow.com/questions/3269686/short-rot13-function">stackoverflow.com/questions/3269686/short-rot13-function</a>, string.maketrans was removed in Python 3.2. It only works if directly applied to a string object.</span>
<span class="comment-copy">@user2980776: Obviously you have to have a file named <code>plaintext.txt</code> in your current working directory if you want to encode a file named <code>plaintext.txt</code>. If you want to use a different file, use a different filename.</span>
<span class="comment-copy">It would be better to show this using a <code>with</code> statement. Besides being a good habit to instill in novices, it also turns this from four lines of file management plus one line of actual work into one line of file management plus one line of actual work, making it clearer what's important here.</span>
