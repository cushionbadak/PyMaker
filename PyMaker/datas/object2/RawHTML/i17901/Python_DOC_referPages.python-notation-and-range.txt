<div class="post-text" itemprop="text">
<p>I've been tasked with converting some python code over to Java. I came across some notation I'm not familiar with and can't seem to find any information on. I'm guessing this is a lack of keywords on my part.</p>
<p>I've sanitized the code and hard coded some basic values for simplicity.</p>
<pre><code>index_type = c_int * 1000 #size of int, basically 1000 integers?
indexes = index_type() # not entirely sure what this does
indexes[:] = range(2000, 3000)[:] # no idea
# c_int equals 4
</code></pre>
<p>The logic doesn't really matter to me, I'm just trying to figure out what's going on in terms of datatypes and converting to Java.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is called "slicing". See the tutorial sections on <a href="http://docs.python.org/3/tutorial/introduction.html#strings" rel="nofollow">Strings</a> and Lists for a good description of how it works. (In your example, it's actually a <code>ctypes</code> array that's being sliced, not a list, but they work the same way. So, for simplicity, let's talk about lists.)</p>
<p>The notation <code>indexes[:]</code> is a slice of the entire list. So, you can do this:</p>
<pre><code>a = [1, 2, 3]
b = a[:]
</code></pre>
<p>… to get a copy of the whole list, and this:</p>
<pre><code>a[:] = [4, 5, 6]
</code></pre>
<p>… to replace the contents of the whole list.</p>
<hr/>
<p>You may wonder how this is different from just using <code>a</code> itself. The difference is that in the first case, <code>b = a</code> doesn't copy the list, it just makes another reference to the same list, and in the second case, <code>a = [4, 5, 6]</code> doesn't mutate the list, it rebinds <code>a</code> to refer to a new list. Here's an example that shows the difference:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a           # b is now the same list as a
&gt;&gt;&gt; a[0] = 10       # so changing that list is visible to b
&gt;&gt;&gt; b
[10, 2, 3]

&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a[:]        # b is now a new list, with a copy of a
&gt;&gt;&gt; a[0] = 10       # so changing the original list doesn't affect b
&gt;&gt;&gt; b
[1, 2, 3]

&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a           # b is now the same list as a
&gt;&gt;&gt; a = [4, 5]      # but now a is a different list
&gt;&gt;&gt; a[0] = 10
&gt;&gt;&gt; b
[1, 2, 3]

&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a           # b is now the same list as a
&gt;&gt;&gt; a[:] = [4, 5]   # and we've replaced the contents
&gt;&gt;&gt; b
[4, 5]
</code></pre>
<hr/>
<p>You may wonder why anyone would use <code>range(2000, 3000)[:]</code> on the right side of the assignment.</p>
<p>Well, I wonder the same thing.</p>
<p>If this is Python 2.x, <code>range(2000, 3000)</code> is a brand-new list. You replace the contents of <code>indexes</code> with the contents of that range list, then give up your only reference to the range list. There is no way anyone could possibly end up sharing it, so there is no good reason to make an extra copy of it, unless you're worried that your computer has too much CPU and too much RAM and might be getting bored.</p>
<p>If this is Python 3.x, <code>range(2000, 3000)</code> is a smart range object. And <code>range(2000, 3000)[:]</code> is a new and equal range object. The copying this time is a lot cheaper, but it's exactly as unnecessary.</p>
</div>
<div class="post-text" itemprop="text">
<p>The other answers are talking about what <code>x[:]</code> means as an expression.  But when this notation is used as the <em>target</em> of an assignment (i.e., on the left side of the <code>=</code>), it means something different.  It is still a slice of the object, but it doesn't create a copy; rather, it assigns the given value (the right hand side) to the specified "part" of the object.  If you use <code>[:]</code>, the slice is the whole object, so its contents will be replaced by what you pass.</p>
<p>An example:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x[:] = [8, 8]
&gt;&gt;&gt; x
[8, 8]
</code></pre>
<p>Notice that you can replace the contents by new contents of different length.</p>
<p>If you use a partial slice, only part of the contents will be replaced:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; x[1:3] = [8, 8, 88]
&gt;&gt;&gt; x
[1, 8, 8, 88, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The notation:</p>
<pre><code>[a:b]
</code></pre>
<p>Is a range that starts at <code>a</code> and ends at <code>b</code>. When you leave one of them blank, it counts as "beginning" and "end", respectively.</p>
<p>Basically, your <code>indexes</code> is a list of values, each one has a number to associate with it that shows its order inside <code>indexes</code>. It starts at <code>0</code> and progresses until the end. The line of code:</p>
<pre><code>indexes[:]
</code></pre>
<p>Simply means</p>
<pre><code>"first value of indexes to last value of indexes"
</code></pre>
<p>I hope this helps,
happy coding!</p>
</div>
<div class="post-text" itemprop="text">
<p>It means getting a <strong><em>COPY</em></strong> of the original list, since lists are mutable in python, for example</p>
<pre><code>&gt;&gt;a = [1,2,3]
&gt;&gt;b = a
&gt;&gt;a[0] = 3
&gt;&gt;a
[3, 2, 3]
&gt;&gt;b
[3, 2, 3]
&gt;&gt;b = a[:]
&gt;&gt;a[0] = 0
&gt;&gt;a
[0, 2, 3]
&gt;&gt;b
[3, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>[:]</code> is an example of slice notation, Python's way to specify any number of items in a sequence.  <code>[:]</code> specifies the entire sequence.  The notation is succinct and powerful in what it can express. Some other possible forms are: </p>
<pre><code>sequence[n]    #an index to one item (not a slice)
sequence[n:]   #the nth item to the end of the sequence
sequence[:n]   #all items until the nth item (exclusive)
sequence[m:n]  #the mth item until the nth item (exclusive)
sequence[:]    #all items
sequence[::2]  #every other item
sequence[::-1] #all items in reverse order
</code></pre>
<p>When slicing is used to modify items in a sequence, the item(s) are modified:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; a[0:1] = [4]  #same as a[0] = 4
&gt;&gt;&gt; a
[4, 2, 3]
&gt;&gt;&gt; a[:] = [1, 2, 3, 4] #the sequence can be made larger
&gt;&gt;&gt; a
[1, 2, 3, 4]

&gt;&gt;&gt; a[:] = [] #or smaller
&gt;&gt;&gt; a
[]
</code></pre>
<p>When slicing is used to read items in a sequence, a shallow copy of the item(s) are returned instead of a reference to the item.  The term shallow copy means that if a copied item is itself a sequence, the item will refer to the original sequence, not a copy of it:</p>
<p>For instance:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a[0]
&gt;&gt;&gt; b  #b has the same value as, but does not reference the same object as a[0]
1  #this is a copy of a[0]

&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; b  #b has the same values as, but does not reference the same object as a
[1, 2, 3]  #this is a copy of list a

&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [a, 2, 3]
&gt;&gt;&gt; c = b[:] #c is a hallow copy of b
&gt;&gt;&gt; c
[[1, 2, 3], 2, 3]
&gt;&gt;&gt; b[:] = [] # modifying b does not affect c
&gt;&gt;&gt; c
[[1, 2, 3], 2, 3]
&gt;&gt;&gt; a[0] = 4 # modifying a will affect a in c
&gt;&gt;&gt; c
[[4, 2, 3], 2, 3]
</code></pre>
</div>
<span class="comment-copy">As a side note, this code appears to be using <code>ctypes</code> to talk directly to some C library, which means you haven't even gotten to the hard part (translating the whole C interface to JNI)…</span>
<span class="comment-copy">Meanwhile, <code>c_int</code> is a <code>ctypes</code> type that wraps the C type <code>int</code> as a Python class. And <code>c_int * 1000</code> is a type that wraps the C type <code>int[1000]</code>. And then <code>indexes = index_type()</code> just constructs and instance of that class, meaning <code>indexes</code> is a wrapper around a (default-constructed) <code>int[1000]</code>.</span>
<span class="comment-copy">We've been experimenting with JNA to implement the DLL. Most of it is already completed, but the python syntax here made me do a double-take.</span>
<span class="comment-copy">So if I've understood correctly, the first 2 statements are basically memory allocation. Then, worded out, the third one is saying "replace all the values in indexes with all of the integers between 2000 and 3000?</span>
<span class="comment-copy">@user2936683: Exactly. You're allocating a C <code>int[1000]</code> array and a Python wrapper around that C array, and then we're replacing the values in that array with the integers between 2000 and 3000.</span>
<span class="comment-copy">@user2936683: Meanwhile, you'll need to read a good chunk of the relatively long <a href="http://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer"><code>ctypes</code></a> documentation. The basic idea is similar to JNI in Java, although the details are pretty different.</span>
<span class="comment-copy">Awesome, thanks for the clarification. And thanks to everyone else posting.</span>
<span class="comment-copy">Did you not read my answer, or is it just not clear enough what <code>a[:] = [4, 5, 6]</code> to replace the contents of the list` means?</span>
<span class="comment-copy">@abarnert: I didn't see that part of your answer initially, and in your examples the crucial case is hidden among other ones that just demonstrate expression slicing.  I do think it's important to foreground the difference between the two.  Slicing as expression and slicing as assignment target are really two very different things, because one copies the object while the other modifies it in-place.  But I now upvoted your answer too.</span>
<span class="comment-copy">His question has slicing on both sides of the assignment, so an answer has to explain what it means on both sides. You can't highlight one of the two without "burying" the other (or just ignoring it, as some of the other answers do, and as yours comes very close to doing).</span>
<span class="comment-copy">This isn't what it means on the left-hand side of an assignment.</span>
<span class="comment-copy">Where does the <code>b</code> come from in your first example? I assume you meant to define it as <code>b = a[:]</code> before doing all that slice assignment on <code>a</code>? But if so, what is that meant to show? It <i>doesn't</i> have the same values as <code>a</code> anymore, because the whole point is that <code>a</code>'s values have changed since then and <code>b</code>'s haven't.</span>
<span class="comment-copy">And at the top of your second example, <code>b</code> <i>does</i> reference the same object as <code>a[0]</code>, not a copy of it. (Plus, <code>a[0]</code> isn't slicing at all, just indexing.)</span>
<span class="comment-copy">@abarnet, <code>b</code> should not have been in first example.  Thanks for pointing it out.  For the second example, if you change the values in <code>a</code>, <code>b</code>'s value will remain unchanged.  I did point out that <code>a[0]</code> is an index in the first section, but the behavior is the same regardless.</span>
