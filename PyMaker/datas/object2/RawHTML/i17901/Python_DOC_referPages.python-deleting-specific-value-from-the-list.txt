<div class="post-text" itemprop="text">
<p>Let say if</p>
<pre><code># Displaying old and reference in columns for better visual #

old=      [2,2,6,6,2,4, 6, 6, 8,2]
reference=[7,1,6,2,4,9,10,16,12,5]
ID=2
</code></pre>
<p>What is faster way to remove the variable ID from reference list and delete 
old[ reference[ID match] ] from the old list?</p>
<p>I happens to developed this solution while asking my question... but is there better way to do this?</p>
<pre><code>def List_Value_Removal(old,reference,ID):
    counter=0
    new=[]
    for test in reference:
        if ID!=test:
           new.append(old[counter])
        checker+=1
    return new
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/3/library/functions.html#zip" rel="noreferrer"><code>zip()</code> function</a> to pair up the lists, then a list comprehension to only <em>keep</em> values where the reference value does not match <code>ID</code>:</p>
<pre><code>def List_Value_Removal(old, reference, ID):
    return [v for v, ref in zip(old, reference) if ref != ID]

 values, references = List_Value_Removal(values, references, some_id)
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; old = [2, 2, 6, 6, 2, 4, 6, 6, 8, 2]
&gt;&gt;&gt; reference = [7, 1, 6, 2, 4, 9, 10, 16, 12, 5]
&gt;&gt;&gt; ID = 2
&gt;&gt;&gt; [v for v, ref in zip(old, reference) if ref != ID]
[2, 2, 6, 2, 4, 6, 6, 8, 2]
</code></pre>
<p>If you need to update <code>reference</code> as well, return two lists:</p>
<pre><code>def List_Value_Removal(old, reference, ID):
    return zip(*((v, ref) for v, ref in zip(old, reference) if ref != ID))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; new, newref = zip(*((v, ref) for v, ref in zip(old, reference) if ref != ID))
&gt;&gt;&gt; new
(2, 2, 6, 2, 4, 6, 6, 8, 2)
&gt;&gt;&gt; newref
(7, 1, 6, 4, 9, 10, 16, 12, 5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also do:</p>
<pre><code>old=      [2,2,6,6,2,4,6,6,8,2]
reference=[7,1,6,2,4,9,10,16,12,5]
ID=2

new = [old[i] for i in range(len(old)) if reference[i] != ID]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just considering both the list are of same length and only one index to remove, btw we can make it more generic :</p>
<pre><code>&gt;&gt;&gt; old = [2,2,6,6,2,4, 6, 6, 8,2]
&gt;&gt;&gt; reference=[7,1,6,2,4,9,10,16,12,5]
&gt;&gt;&gt; id = 2
&gt;&gt;&gt; del old[(reference.index(id))]
&gt;&gt;&gt; old
[2, 2, 6, 2, 4, 6, 6, 8, 2]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def List_Value_Removal(old,ref, id):
    new = old[:]
    ind = ref.index(id)
    new.pop(ind)
    return new
</code></pre>
<p>Not sure if there is a particular reason that you are using two arrays?
If you used a dict:</p>
<pre><code>ref = {7:2,1:2,6:6,2:6,4:2,9:4,10:6,16:6,12:8,5:2}
</code></pre>
<p>You could just:</p>
<pre><code>ref.pop(id)
</code></pre>
</div>
<span class="comment-copy">Ugh! I used Array Again! Fixing it now</span>
<span class="comment-copy">you mean <code>if ID!=test</code> there?</span>
<span class="comment-copy">Yes, Editted to show that</span>
<span class="comment-copy">You have <code>counter</code> and <code>checker</code>; I suspect the latter should be called <code>counter</code> too. Also, you probably meant <code>new.append(old[counter])</code> here (square brackets to index into <code>old</code>).</span>
<span class="comment-copy">Ah, I missed that as well</span>
<span class="comment-copy">This is one good solution to do it. Does you know any other ways to do it as well?</span>
<span class="comment-copy">This is the best way. You could use <code>enumerate()</code> instead of <code>counter</code> in your method, but the list comprehension is going to win it on speed anyway.</span>
<span class="comment-copy">@Bugboy1028 Sorry, do you need to remove those entries from the reference list then?</span>
<span class="comment-copy">@Roberto, does rest of the answer to my question and comments gave you the answer to your question? If not, please clarify.</span>
<span class="comment-copy">Does this answer applied to Python 2.7.x as well?</span>
<span class="comment-copy">Why not use <code>[v for i, v in enumerate(old) if reference[i] != ID]</code>? But the <code>zip()</code> version is more efficient because it doesn't have to have an additional item lookup.</span>
<span class="comment-copy">That's nice, but is it just equivalent or better for some reason?</span>
<span class="comment-copy">It is faster; try it with <code>timeit</code>.</span>
<span class="comment-copy">Cool!Heh you replied even before I asked</span>
<span class="comment-copy">What is timeit, @MartijnPieters ?</span>
<span class="comment-copy">This only works if there is only <b>one</b> occurence of <code>ID</code> in `reference. If there are 0 or more than 1, this will not work correctly.</span>
<span class="comment-copy">Actually, no. If I do this way, it will delete first value it saw</span>
<span class="comment-copy">Ok right, let me think again.</span>
<span class="comment-copy">@MartijnPieters, reference will exactly one value for one id... say if you are doing ID=10 , it will delete value of 6 from ID=6 instead of ID=10 value.</span>
<span class="comment-copy">Why does this function doesn't have return? Global and Local variables is separated. This function will return None for varible new that I gave you. I didn't meant to use arrays at all in this question.</span>
