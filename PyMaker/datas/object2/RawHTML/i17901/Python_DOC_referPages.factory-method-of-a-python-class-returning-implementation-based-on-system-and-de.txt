<div class="post-text" itemprop="text">
<h1>1) Introduction</h1>
<p>I have started the implementation of a tool in Python that gathers several system metrics (e.g. cpu utilisation, cpu saturation, memory errors etc.) and presents them to the end-user. This tool should ideally support as many platforms as possible (Linux, FreeBSD, Windows etc.).</p>
<p>I have completed the implementation of this tool for a Linux system for a few metrics I consider important and I have just started to implement the same metrics for a FreeBSD system. This tool must be designed in a way that allows support for more <strong>system metrics</strong> and for more <strong>platforms</strong> in the future. Moreover, a <strong>web-interface</strong> will soon be added and will <strong>receive data</strong> from my tool.</p>
<h1>2) My design decisions so far</h1>
<p>For the above reasons, I have decided to implement the tool in <strong>Python</strong> (convenient to read data from different sources on many systems and ,well, I am somewhat more familiar with it :)) and I am following a <strong>class structure</strong> for each system metric (inheritance is important as some systems share features so there is no need to rewrite code). Moreover, I have decided that I have a valid use case for using a <strong>factory method</strong>.</p>
<h2>2.1) Class structure</h2>
<p>Here is an example class diagram for CPU Metrics (simplified for the sake of the question):</p>
<pre><code>                  CpuMetrics        (Abstract Base Class)
                 /      |    \
                /       |     \
               /        |      \
              /         |       \
             /          |        \
            /           |         \
LinuxCpuMetrics  FreeBSDCpuMetrics WindowsCPUMetrics   (per OS)
           /  \ 
          /    \
         /      \
        /        \
       /          \
      /            \
     /              \
ArchLinuxCpuMetrics  DebianLinuxCpuMetrics             (sometimes important per Distro or Version)
</code></pre>
<h2>2.2) Factory Method</h2>
<p>In the Abstract Base Class called <strong>CpuMetrics</strong> there are some abstract methods defined that should be implemented by inheriting classes and a <strong>factory method</strong> called get_impl(). I have done some research on when I should use a Factory Method (for example, answers such as <a href="https://stackoverflow.com/a/14992545/2568511">this</a>) and I believe it is valid to use one in my case.</p>
<p>For example, I want a client (e.g. my web interface) to call my tool to get CPU Utilisation metrics like this:</p>
<pre><code>cpu_metrics = CpuMetrics.get_impl() # factory method as an alternative constructor
cpu_metrics.get_cpu_util() # It is completely transparent for the client which get_cpu_util() is returned.
</code></pre>
<h1>3) My concern and my question (finally)</h1>
<p>Following the above analyzed design, it is very important for my factory method to be informed about which system are we on now ("is this Linux, Windows? Which implementation should I bring now?"). Therefore, I have to <strong>heavily rely</strong> on functions such as <code>platform.system()</code> or its alternatives. So what my factory method does is (roughly again): </p>
<pre><code>def get_impl():
    """Factory method returning the appropriate implementation depending on system."""
    try:
        system = platform.system() # This returns: { Linux, Windows, FreeBSD, ... }
        system_class = getattr("cpu", system + "CpuMetrics" )
    except AttributeError, attr_err:
        print ("Error: No class named " + system + "CpuMetrics in module cpu. ")
        raise attr_err
    return system_class()
</code></pre>
<p>I feel <strong>very uncomfortable</strong> with this for two reasons:</p>
<p>1) I force a future programmer (or even myself) to follow a naming convention for his class. For example, if someone decides to extend my system, say, for Solaris he <strong>absolutely has to</strong> name his class <code>SolarisCpuMetrics</code>.</p>
<p>2) If  in a future version of Python the values of <code>platform.system()</code> (or an other alternative I will choose to use) are modifiled, then I have to change my naming convention and modify my factory method a lot.</p>
<p>So my <strong>question</strong> : is there a workaround for my concern ? Will my code become unreadable or my concern is not valid? If you believe there is one workaround, how much do I need to modify / refactor my code and change my design?</p>
<p>I don not have experience in designing projects from scratch, so I could use any advice. Also, I have some more experience in Java. I try to think in a as much pythonic way as possible when writing Python, but sometimes fail to do a proper seperation between the two. Your constructive criticism is very desirable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a class decorator to enumerate classes. And override the <a href="http://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow">allocator</a>.</p>
<pre><code>sysmap = {}

class metric:
  def __init__(self, system):
    self.system = system
  def __call__(self, cls):
    sysmap[self.system] = cls
    return cls

class CpuMetrics:
  def __new__(self):
    cls = sysmap.get(platform.system)
    if not cls:
      raise RuntimeError('No metric class found!')
    else:
      return cls()
   ...
</code></pre>
<p>...</p>
<pre><code>@metric('Linux')
class SomeLinuxMetrics(CpuMetrics):
   ...
</code></pre>
<p>...</p>
<pre><code>metrics = CpuMetrics()
</code></pre>
</div>
<span class="comment-copy">Thank you for your answer. It works great. I would just like to add that the subclasses (e.g. <code>SomeLinuxMetrics</code> ) must also override the allocator <code>__new__</code> to avoid infinite recursion. I guess you probably meant it :)</span>
<span class="comment-copy">@ArtemTsikiridis: Yeah, I forgot to check if <code>cls is self</code>.</span>
