<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/2/c-api/buffer.html" rel="nofollow">http://docs.python.org/2/c-api/buffer.html</a></p>
<blockquote>
<p>int ndim</p>
<p>The number of dimensions the memory represents as a multi-dimensional array. If it is 0, strides and suboffsets must be NULL.</p>
</blockquote>
<p>What's the real world usage for this? Is it used for scatter gather vector buffers?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>ndim</code> and <code>shape</code> is primarily for multidimensional fixed-shape arrays. For example, if you wanted to build something like <a href="http://www.numpy.org" rel="nofollow">NumPy</a> from scratch, you might build it around the buffer API. There are also variations to make things easy for NumPy, PIL, and modules that wrap typical C and Fortran array-processing libraries.</p>
<p>If you read a bit further down, the next two values both say "See <a href="http://docs.python.org/3/c-api/buffer.html#complex-arrays" rel="nofollow">complex arrays</a> for more information." If you click that link, it gives you an example of doing something like NumPy, and describes how it works.</p>
<p>Also see <a href="http://www.python.org/dev/peps/pep-3118/" rel="nofollow">PEP 3118</a> for some rationale.</p>
<p>It's <em>not</em> (primarily) for jagged-shaped arrays, like the scatter/gather use. While you <em>can</em> use PIL-style suboffsets for that, it's generally simpler to just use a list or array of buffers (unless you're trying to interface with PIL, of course).</p>
<p>(The old-style buffer API <em>did</em> support a mode designed specifically for scatter/gather-like use, but it was dropped in Python 3.x, and deprecated in 2.6+ once the 3.x API was backported, basically because nobody ever used it.)</p>
</div>
<span class="comment-copy">thanks a million! I am noob to scatter/gather, any recommend/related info to get started with? (preparing to write network/file IO tasks for exercise.)</span>
<span class="comment-copy">@est: Python 2.x doesn't provide any scatter/gather APIs. Python 3 has <a href="http://docs.python.org/3.3/library/socket.html#socket.socket.recvmsg_into" rel="nofollow noreferrer"><code>recvmsg_into</code></a> and <a href="http://docs.python.org/3.3/library/socket.html#socket.socket.sendmsg" rel="nofollow noreferrer"><code>sendmsg</code></a> on its sockets, but they work by just providing an iterable of 1D buffers (a <code>list</code> of <code>bytearray</code>s works fine), so there's no need for anything more fancy. If you're using some third-party library, or <code>ctypes</code>-ing direct to platform-specific functions like <code>sendv</code>, then… well, each one will have different requirements.</span>
<span class="comment-copy">@est: For example, on most *nix platforms with <code>sendv</code> and/or <code>writev</code>, you have to create an array of <code>struct iovec</code> objects, each of which has a buffer pointer and a length. No Python type has exactly that shape, so you have to build it out of a <code>ctypes.Structure</code>.</span>
<span class="comment-copy">Could you explain how to implement jagged-shaped arrays using suboffsets? The length of the second dimension is constant even if you have PIL-style pointer list in the first dimension isn't it?</span>
<span class="comment-copy">@molnarg: <a href="http://pastebin.com/Z7jQU9DR" rel="nofollow noreferrer">Here</a> is an implementation of the relevant parts (with incomplete error handling—e.g., if you run out of memory halfway through allocating the Jagged, you'll leak all the buffers allocated so far).</span>
