<div class="post-text" itemprop="text">
<p>I am trying to create a backtrace function the will return a list of the order of the shortest path from the root to the <code>GOAL</code></p>
<p>My path_holder:</p>
<pre><code>path_holder = {
   'node1':['node2','node3','node5'],  
   'node2':['node1','node8','node10'],
   'node3':['node4','node6']},
   'node4':['node2','node1','node3'],
   'node5':['DEADEND'],
   'node6':['GOAL']
    ....
    }
</code></pre>
<p>In my <code>path_holder</code> input, it is the output of a BFS so the first node is the root and the last node is the goal. Because the <code>path_holder</code> input is the output of a BFS, it stops when the <code>GOAL</code> is found so all the nodes that are branches of the previous nodes required to search for <code>GOAL</code> are added to <code>path_holder</code> as well. </p>
<p>Currently I am getting stuck in the while loop where an infinite loop occurs. My general strategy to is to start from the <code>GOAL</code> node and use the key of this node to find where this key is located in another key's(node) list. Once I found that node (where it's list contains the key), I set the node's key to be the new goal. (Confusing sentence sorry) </p>
<p>This graph may contain cycles which might be why I am also getting infinite loops.</p>
<p>my backtrace function:</p>
<pre><code>def backtrace(path_holder, root, goal):
    dct = {}
    for d in path_holder:
            dct.update(d)
    rootnode = root.keys()[0]
    goal = goal.keys()[0]
    #x = len(path_holder)
    path = []
    path.append(goal)
    #for i in reversed(xrange(x):
    #   path_holder[i].keys()
    while goal != rootnode: 
        # find key that contains goal in list
        for i in dct:
            #print i
            for j in dct[i] :
                if j not in path:
                    if j == goal:
                        path.append(i)
                        goal = i
        # append key that has goal in the list
        # set goal to be the key that was appended
        # repeat
    return path
</code></pre>
<p>ex: output</p>
<pre><code>path = ['node1','node3','node6']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>1. Bugs</h3>
<ol>
<li><p>When I run your code I get the following error:</p>
<pre><code>&gt;&gt;&gt; backtrace(path_holder, 'node1', 'GOAL')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "q20349609.py", line 13, in backtrace
    dct.update(d)
ValueError: dictionary update sequence element #0 has length 1; 2 is required
</code></pre>
<p>That's because when you iterate over a dictionary like this:</p>
<pre><code>for d in path_holder:
</code></pre>
<p>what you get are the <em>keys</em> of the dictionary. So <code>d</code> takes values <code>'node1'</code>, <code>'node2'</code> and so on, and you can't pass these to the <code>dict.update</code> method.</p>
<p>But what are you trying to do here anyway? If you're trying to copy <code>path_holder</code> into <code>dct</code>, you could just write:</p>
<pre><code>dct = dict(path_holder)
</code></pre>
<p>but why bother making a copy? Why not just use <code>path_holder</code>?</p></li>
<li><p>With bug #1 fixed, the program runs but get stuck in an infinite loop. That's because of these lines:</p>
<pre><code>if j not in path:
    if j == goal:
        path.append(i)
</code></pre>
<p>These lines mean that you only add a node to the path if it has a neighbour <code>j</code> which is not yet in the path, but is equal to the goal. But hang on a second, <code>goal</code> is already in the path at this point. So both conditions cannot be satisfied at the same time. Hence nothing ever gets added to the path!</p>
<p>Clearly the line: </p>
<pre><code>if j not in path:
</code></pre>
<p>should be:</p>
<pre><code>if i not in path:
</code></pre>
<p>since <code>i</code> is the node we are considering adding to the path.</p></li>
<li><p>With bugs #1 and #2 fixed, the program makes some progress but still gets stuck in an infinite loop. If we add the line <code>print(path)</code> after <code>path.append(i)</code> then we get the following output up to the point where it gets stuck:</p>
<pre><code>&gt;&gt;&gt; backtrace(path_holder, 'node1', 'GOAL')
['GOAL', 'node6']
['GOAL', 'node6', 'node3']
['GOAL', 'node6', 'node3', 'node4']
</code></pre>
<p>You can see that the search has made a mistake: from <code>node3</code> it has gone to <code>node4</code>, but there is no route from <code>node4</code> to <code>GOAL</code> except for the one that goes through <code>node3</code>. And the search will never consider adding <code>node3</code> to the path, because it's already there.</p></li>
</ol>
<h3>2. What to do instead</h3>
<p>When you find a path to a node like <code>node4</code>, you can't know whether or not that node will be on the shortest path from <code>GOAL</code> to <code>node1</code>. All you can know at this point is that <em>if</em> <code>node4</code> is on the shortest path from <code>GOAL</code> to <code>node1</code>, <em>then</em> you'll get there via <code>node3</code>. So that's all that you must record.</p>
<p>Here's how I'd implement this, using the dictionary <code>visited</code> to record for each node the previous node on the shortest path from <code>start</code> to that node, and a <a href="http://docs.python.org/3/library/collections.html#collections.deque" rel="noreferrer"><code>collections.deque</code></a> to maintain a queue of nodes whose neighbours we may not have visited yet.</p>
<pre><code>from collections import deque

class NotFound(Exception): pass

def search(graph, start, goal):
    """Find the shortest path from start to goal in graph (which must be a
    map from a node to an iterable of adjacent nodes), using
    breadth-first search.

        &gt;&gt;&gt; graph = {
        ...     1: [2, 4, 5],  
        ...     2: [1],
        ...     3: [4, 6],
        ...     4: [2, 1, 3],
        ...     5: [],
        ...     6: [7],
        ...     7: [],
        ... }
        &gt;&gt;&gt; search(graph, 1, 7)
        [1, 4, 3, 6, 7]
        &gt;&gt;&gt; search(graph, 1, 1)
        [1]
        &gt;&gt;&gt; search(graph, 5, 1) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
            ...
        NotFound: No path from 5 to 1

    """
    visited = {start: None}
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node == goal:
            path = []
            while node is not None:
                path.append(node)
                node = visited[node]
            return path[::-1]
        for neighbour in graph[node]:
            if neighbour not in visited:
                visited[neighbour] = node
                queue.append(neighbour)
    raise NotFound('No path from {} to {}'.format(start, goal))
</code></pre>
<p>Notes:</p>
<ol>
<li><p>Your variable <code>path_holder</code> contains a data structure that is known as a <a href="https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29" rel="noreferrer"><em>graph</em></a> in <a href="https://en.wikipedia.org/wiki/Adjacency_list" rel="noreferrer"><em>adjacency list representation</em></a>. So I have called this variable <code>graph</code>.</p></li>
<li><p>I've written a docstring explaining what the function does and how to call it. The docstring also contains embedded code examples that can be run using the <a href="http://docs.python.org/3/library/doctest.html" rel="noreferrer"><code>doctest</code></a> module.</p></li>
<li><p>Your function searches backwards from the goal to the start. But this is just the same as searching forwards from the start to the goal with all the edges reversed. So I've kept things simple by searching forwards.</p></li>
</ol>
</div>
<span class="comment-copy">Why don't you try with <code>while goal != rootnode:</code>?</span>
<span class="comment-copy">The shortest path between two nodes should be acyclic unless you have negative-cost edges.</span>
<span class="comment-copy">@IceArdor I think the line <code>if j not in path</code> helps ignore cycles and allows full searches without getting stuck in a loop. correct me if im wrong</span>
<span class="comment-copy">@Liondancer What are the inputs being passed?</span>
<span class="comment-copy">@thefourtheye for <code>path_holder</code> it is a list of dictionaries that contain a list. ex: <code>a = [    {'node1':['node2','node3','node5']},      {'node2':['node1','node8','node10']},    {'node3':['node4','node2']},    {'node4':['node2','node1','node3']},    {'node5':['DEADEND']},    {'node6':['GOAL']}     ....     ]</code> However I converted them to one big dictionary. For <code>root</code> and <code>goal</code> they are both dicionaries. EX of goal would be <code>{'nodex':['GOAL']}</code> and root would be <code>{'node 1':['node2','node3','node4]'}</code></span>
