<div class="post-text" itemprop="text">
<p>Retrieving the order of key-word arguments passed via **kwargs would be extremely useful in the particular project I am working on. It is about making a kind of n-d numpy array with meaningful dimensions (right now called dimarray), particularly useful for geophysical data handling.</p>
<p>For now say we have:</p>
<pre><code>import numpy as np
from dimarray import Dimarray   # the handy class I am programming

def make_data(nlat, nlon):
    """ generate some example data
    """
    values = np.random.randn(nlat, nlon)
    lon = np.linspace(-180,180,nlon)
    lat = np.linspace(-90,90,nlat)
    return lon, lat, values
</code></pre>
<p>What works:</p>
<pre><code>&gt;&gt;&gt; lon, lat, values = make_data(180,360)
&gt;&gt;&gt; a = Dimarray(values, lat=lat, lon=lon)
&gt;&gt;&gt; print a.lon[0], a.lat[0]
-180.0 -90.0
</code></pre>
<p>What does not:</p>
<pre><code>&gt;&gt;&gt; lon, lat, data = make_data(180,180) # square, no shape checking possible !
&gt;&gt;&gt; a = Dimarray(values, lat=lat, lon=lon)
&gt;&gt;&gt; print a.lon[0], a.lat[0] # is random 
-90.0, -180.0  # could be (actually I raise an error in such ambiguous cases)
</code></pre>
<p>The reason is that Dimarray's <code>__init__</code> method's signature is <code>(values, **kwargs)</code> and since <code>kwargs</code> is an unordered dictionary (dict) the best it can do is check against the shape of <code>values</code>. </p>
<p>Of course, I want it to work for any kind of dimensions:</p>
<pre><code>a = Dimarray(values, x1=.., x2=...,x3=...)
</code></pre>
<p>so it has to be hard coded with <code>**kwargs</code>
The chances of ambiguous cases occurring increases with the number of dimensions.
There are ways around that, for instance with a signature <code>(values, axes, names, **kwargs)</code> it is possible to do:</p>
<pre><code>a = Dimarray(values, [lat, lon], ["lat","lon"]) 
</code></pre>
<p>but this syntax is cumbersome for <em>interactive</em> use (ipython), since I would like this package to really be a part of my (and others !!) daily use of python, as an actual replacement of numpy arrays in geophysics.</p>
<p>I would be VERY interested in a way around that. The best I can think of right now is to use inspect module's stack method to parse the caller's statement: </p>
<pre><code>import inspect
def f(**kwargs):
    print inspect.stack()[1][4]
    return tuple([kwargs[k] for k in kwargs])

&gt;&gt;&gt; print f(lon=360, lat=180)
[u'print f(lon=360, lat=180)\n']
(180, 360)

&gt;&gt;&gt; print f(lat=180, lon=360)
[u'print f(lat=180, lon=360)\n']
(180, 360)
</code></pre>
<p>One could work something out from that, but there are unsolvable issues since stack()  catches everything on the line:</p>
<pre><code>&gt;&gt;&gt; print (f(lon=360, lat=180), f(lat=180, lon=360))
[u'print (f(lon=360, lat=180), f(lat=180, lon=360))\n']
[u'print (f(lon=360, lat=180), f(lat=180, lon=360))\n']
((180, 360), (180, 360))
</code></pre>
<p>Is there any other inspect trick I am not aware of, which could solve this problem ? (I am not familiar with this module) I would imagine getting the piece of code which is right between the brackets <code>lon=360, lat=180</code> should be something feasible, no?? </p>
<p>So I have the feeling for the first time in python to hit a hard wall in term of doing something which is theoretically feasible based on all available information (the ordering provided by the user IS valuable information !!!). </p>
<p>I read interesting suggestions by Nick there: <a href="https://mail.python.org/pipermail/python-ideas/2011-January/009054.html" rel="nofollow">https://mail.python.org/pipermail/python-ideas/2011-January/009054.html</a>
and was wondering whether this idea has moved forward somehow?</p>
<p>I see why it is not desirable to have an ordered **kwargs in general, but a patch for these rare cases would be neat. Anyone aware of a reliable hack?</p>
<p>NOTE: this is not about pandas, I am actually trying to develop a light-weight alternative for it, whose usage remains very close to numpy. Will soon post the gitHub link.</p>
<p>EDIT: Note I this is relevant for <strong>interactive</strong> use of dimarray. The dual syntax is needed anyway. </p>
<p>EDIT2: I also see counter arguments that knowing the data is <strong>not</strong> ordered could also be seen as valuable information, since it leaves Dimarray the freedom to check <code>values</code> shape and adjust the order automatically. It could even be that not remembering the dimension of the data occurs more often than having the same size for two dimensions. So right now, I guess it is fine to raise an error for ambiguous cases, asking the user to provide the <code>names</code> argument. Nevertheless, it would be neat to have the freedom to make that kind of choices (how Dimarray class should behave), instead of being constrained by a missing feature of python.</p>
<p><strong>EDIT 3</strong>, SOLUTIONS: after the suggestion of kazagistar:</p>
<p>I did not mention that there are other optional attribute parameters such as <code>name=""</code> and <code>units=""</code>, and a couple of other parameters related to slicing, so the <code>*args</code> construct would need to come with keyword name testing on <code>kwargs</code>. </p>
<p>In summary, there are many possibilities:</p>
<p>*Choice a: keep current syntax</p>
<pre><code>a = Dimarray(values, lon=mylon, lat=mylat, name="myarray")
a = Dimarray(values, [mylat, mylon], ["lat", "lon"], name="myarray")
</code></pre>
<p>*Choice b: kazagistar's 2nd suggestion, dropping axis definition via <code>**kwargs</code></p>
<pre><code>a = Dimarray(values, ("lat", mylat), ("lon",mylon), name="myarray")
</code></pre>
<p>*Choice c: kazagistar's 2nd suggestion, with optional axis definition via <code>**kwargs</code> 
(note this involves <code>names=</code> to be extracted from <code>**kwargs</code>, see background below)</p>
<pre><code>a = Dimarray(values, lon=mylon, lat=mylat, name="myarray")
a = Dimarray(values, ("lat", mylat), ("lon",mylon), name="myarray")
</code></pre>
<p>*Choice d: kazagistar's 3nd suggestion, with optional axis definition via <code>**kwargs</code></p>
<pre><code>a = Dimarray(values, lon=mylon, lat=mylat, name="myarray")
a = Dimarray(values, [("lat", mylat), ("lon",mylon)], name="myarray")
</code></pre>
<p>Hmm, it comes down to aesthetics, and to some design questions (Is lazy ordering an important feature in interactive mode?). I am hesitating between b) and c). I am not sure the **kwargs really brings something. Ironically enough, what I started to criticize became a <em>feature</em> when thinking more about it...</p>
<p>Thanks very much for the answers. I will mark the question as answered, but you are most welcome to vote for a), b) c) or d) ! </p>
<p>=====================</p>
<p><strong>EDIT 4</strong> :  <strong>better solution</strong>:  choice a) !!, but adding a from_tuples class method. The reason for that is to allow one more degree of freedom. If the axis names are not provided, they will be generated automatically as "x0", "x1" etc... To use really just like pandas, but with axis naming. This also avoids mixing up axes <em>and</em> attributes  into **kwargs, and leaving it only for the axes. There will be more soon as soon as I am done with the doc.</p>
<pre><code>a = Dimarray(values, lon=mylon, lat=mylat, name="myarray")
a = Dimarray(values, [mylat, mylon], ["lat", "lon"], name="myarray")
a = Dimarray.from_tuples(values, ("lat", mylat), ("lon",mylon), name="myarray")
</code></pre>
<p><strong>EDIT 5</strong> : <strong>more pythonic solution?</strong> : similar to EDIT 4 above in term of the user api, but via a wrapper dimarray, while being very strict with how Dimarray is instantiated. This is also in the spirit of what kazagistar proposed. </p>
<pre><code> from dimarray import dimarray, Dimarray 

 a = dimarray(values, lon=mylon, lat=mylat, name="myarray") # error if lon and lat have same size
 b = dimarray(values, [("lat", mylat), ("lon",mylon)], name="myarray")
 c = dimarray(values, [mylat, mylon, ...], ['lat','lon',...], name="myarray")
 d = dimarray(values, [mylat, mylon, ...], name="myarray2")
</code></pre>
<p>And from the class itself:</p>
<pre><code> e = Dimarray.from_dict(values, lon=mylon, lat=mylat) # error if lon and lat have same size
 e.set(name="myarray", inplace=True)
 f = Dimarray.from_tuples(values, ("lat", mylat), ("lon",mylon), name="myarray")
 g = Dimarray.from_list(values, [mylat, mylon, ...], ['lat','lon',...], name="myarray")
 h = Dimarray.from_list(values, [mylat, mylon, ...], name="myarray")
</code></pre>
<p>In the cases d) and h) axes are automatically named "x0", "x1", and so on, unless mylat, mylon actually belong to the Axis class (which I do not mention in this post, but Axes and Axis do their job, to build axes and deal with indexing).</p>
<p>Explanations:</p>
<pre><code>class Dimarray(object):
    """ ndarray with meaningful dimensions and clean interface
    """
    def __init__(self, values, axes, **kwargs):
        assert isinstance(axes, Axes), "axes must be an instance of Axes"
        self.values = values
        self.axes = axes
        self.__dict__.update(kwargs)

    @classmethod
    def from_tuples(cls, values, *args, **kwargs):
        axes = Axes.from_tuples(*args)
        return cls(values, axes)

    @classmethod
    def from_list(cls, values, axes, names=None, **kwargs):
        if names is None:
            names = ["x{}".format(i) for i in range(len(axes))]
        return cls.from_tuples(values, *zip(axes, names), **kwargs)

    @classmethod
    def from_dict(cls, values, names=None,**kwargs):
        axes = Axes.from_dict(shape=values.shape, names=names, **kwargs)
        # with necessary assert statements in the above
        return cls(values, axes)
</code></pre>
<p>Here is the trick (schematically):</p>
<pre><code>def dimarray(values, axes=None, names=None, name=..,units=..., **kwargs):
    """ my wrapper with all fancy options
    """
    if len(kwargs) &gt; 0:
        new = Dimarray.from_dict(values, axes, **kwargs) 

    elif axes[0] is tuple:
        new = Dimarray.from_tuples(values, *axes, **kwargs) 

    else:
        new = Dimarray.from_list(values, axes, names=names, **kwargs) 

    # reserved attributes
    new.set(name=name, units=units, ..., inplace=True) 

    return new
</code></pre>
<p>The only thing we loose is indeed *args syntax, which could not accommodate for so many 
options. But that's fine.</p>
<p>And its make it easy for sub-classing, too. How does it sound to the python experts here?</p>
<p>(this whole discussion could be split in two parts really)</p>
<p>=====================</p>
<p>A bit of background (EDIT: in part outdated, for cases a), b), c), d) only), just in case you are interested:</p>
<p>*Choice a involves:</p>
<pre><code>def __init__(self, values, axes=None, names=None, units="",name="",..., **kwargs):
    """ schematic representation of Dimarray's init method
    """
    # automatic ordering according to values' shape (unless names is also provided)
    # the user is allowed to forget about the exact shape of the array
    if len(kwargs) &gt; 0:
        axes = Axes.from_dict(shape=values.shape, names=names, **kwargs)

    # otherwise initialize from list
    # exact ordering + more freedom in axis naming 
    else:
        axes = Axes.from_list(axes, names)

    ...  # check consistency

    self.values = values
    self.axes = axes
    self.name = name
    self.units = units         
</code></pre>
<p>*Choices b) and c) impose:</p>
<pre><code>def __init__(self, values, *args, **kwargs):
    ...
</code></pre>
<p>b) all attributes are naturally passed via kwargs, with <code>self.__dict__.update(kwargs)</code>. This is clean.</p>
<p>c) Need to filter key-word arguments:</p>
<pre><code>def __init__(self, values, *args, **kwargs):
   """ most flexible for interactive use
   """
   # filter out known attributes
   default_attrs = {'name':'', 'units':'', ...} 
   for k in kwargs:
       if k in 'name', 'units', ...:
           setattr(self, k) = kwargs.pop(k)
       else:
           setattr(self, k) = default_attrs[k]

   # same as before
   if len(kwargs) &gt; 0:
       axes = Axes.from_dict(shape=values.shape, names=names, **kwargs)

   # same, just unzip
   else:
       names, numpy_axes = zip(*args)
       axes = Axes.from_list(numpy_axes, names)
</code></pre>
<p>This is actually quite nice and handy, the only (minor) drawback is that default parameters for name="", units="" and some other more relevant parameters are not accessible by inspection or  completion. </p>
<p>*Choice d:  clear <code>__init__</code></p>
<pre><code>def __init__(self, values, axes, name="", units="", ..., **kwaxes)
</code></pre>
<p>But is a bit verbose indeed.</p>
<p>==========</p>
<p><strong>EDIT, FYI</strong>: I ended up using a list of tuples for the <code>axes</code> parameter, or alternatively the parameters <code>dims=</code> and <code>labels=</code> for axis name and axis values, respectively. The related project dimarray is on github. Thanks again at kazagistar.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, you cannot know the order in which items were added to a dictionary, since doing this increases the complexity of implementing the dicionary significantly. (For when you really really need this, <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow">collections.OrderedDict</a> has you covered).</p>
<p>However, have you considered some basic alternative syntax? For example:</p>
<pre><code>a = Dimarray(values, 'lat', lat, 'lon', lon)
</code></pre>
<p>or (probably the best option)</p>
<pre><code>a = Dimarray(values, ('lat', lat), ('lon', lon))
</code></pre>
<p>or (most explicit)</p>
<pre><code>a = Dimarray(values, [('lat', lat), ('lon', lon)])
</code></pre>
<p>At some level though, that need ordering are inherently positional. **kwargs is often abused for labeling, but argument name generally shouldn't be "data", since it is a pain to set programatically. Just make the two parts of the data that are associated clear with a tuple, and use a list to make the ordering preserved, and provide strong assertions + error messages to make it clear when the input is invalid and why.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is module especially made to handle this :</p>
<p><a href="https://github.com/claylabs/ordered-keyword-args" rel="nofollow">https://github.com/claylabs/ordered-keyword-args</a> </p>
<h2>without using module</h2>
<pre><code>def multiple_kwarguments(first , **lotsofothers):
    print first

    for i,other in lotsofothers.items():
         print other
    return True

multiple_kwarguments("first", second="second", third="third" ,fourth="fourth" ,fifth="fifth")
</code></pre>
<p>output:    </p>
<pre><code>first
second
fifth
fourth
third
</code></pre>
<h2>On using orderedkwargs module</h2>
<pre><code>from orderedkwargs import ordered kwargs  
@orderedkwargs  
def mutliple_kwarguments(first , *lotsofothers):
    print first

    for i, other in lotsofothers:
        print other
    return True


mutliple_kwarguments("first", second="second", third="third" ,fourth="fourth" ,fifth="fifth")
</code></pre>
<p>Output:</p>
<pre><code>first
second
third
fourth
fifth
</code></pre>
<p>Note: Single asterik is required while using this module with decorator above the function. </p>
</div>
<span class="comment-copy">what would be order if it's called as <code>d = {}; d['lat']=180; d['lon']=360; f(**d)</code>?</span>
<span class="comment-copy">If order matters, the caller must communicate the desired order in some fashion. A kwargs-style signature does not serve that purpose, so it's the wrong interface. The caller is going to have to type a few extra keystrokes ... unless you do something crazy like make <code>Dimarray</code> objects callable: <code>a = Dimarray(values)(lat = lat)(lon = lon)</code>. Same N of characters as a the kwargs-style -- w00t! ;)</span>
<span class="comment-copy">I will definitely avoid this :) !</span>
<span class="comment-copy">@alko: d is unordered, and **d destroyed the order anyway even with OrderedDict.</span>
<span class="comment-copy">This is a good suggestion, thanks. For some reason I had not considered that. It is indeed much easier to type than the (axes=..., names=...) alternative, especially for high dimensional cases. It is easy to type/read and is also complementary to **kwargs features (see EDIT 2: automatic shape checking). I need to see how this fits with the rest. Writing an EDIT 3 to sum things up.</span>
<span class="comment-copy">In my personal coding style, I try to never mix semantic and non-semantic parameters for any given function. In this case, the semantics of the constructor are "give me the values, and the shape of the values", with the shape being an ordered list of label + integer pairs. Each semantically unique item is a single value. With that, I will propose one more solution, though it might be too verbose for your tastes: <code>a = Dimarray(values, Shape(('lat', lat), ('lon', lon)))</code> where Shape is a class that validates a particular shape.</span>
<span class="comment-copy">I see your point, but I am really trying to make something easy to use for anyone without having to know which class does what. I do have an Axes class and an Axis class, themselves with labels etc...But I would like the api to be made of just a few names to remember, at best only one (<code>Dimarray</code>, plus actually <code>read</code>) and the usage to be straightforward without too many {[('".</span>
<span class="comment-copy">Actually I forgot to mention than the shape of the values is already contained in values (a multi-dimensional numpy array, via its shape attribue). What is missing is really the <code>name</code> and actual values of the axes (and their order in the ambiguous case I mentioned). I do not intend to force shaping a list, really, the starting point is a numpy array.</span>
<span class="comment-copy">So really there are two cases: a) every axis has a different size, in that an ordered list of dimensions if a redundant information (just forces the user to know the underlying structure of the data, but part of the reason why I started programming this was also not to worry about that, and just do slicing like a.xs(time=1950) or a.mean(axis='time') instead of having to think about the acutal position of the axis as I have to do with numpy or pandas.</span>
