<div class="post-text" itemprop="text">
<p>I have a dictionary that contains simulation results of various protocols for various values of <code>n</code> ("protocols" and <code>n</code> are irrelevant to the problem I face). This dictionary is structured as follows:</p>
<pre><code>myDict = {"protocol1" : {1:[some list of numbers], 2:[another list of numbers]},
          "protocol2" : {1:[some list of numbers], 2:[another list of numbers]},
         }
</code></pre>
<p>Now, in order to analyze the results, I would do something like this:</p>
<pre><code>for protocol, stats in myDict.items():
  for n, counts in stats.items():
    # do stuff with protocol, n and counts
</code></pre>
<p>I wonder though, if there exists some set of built-ins that allow me to do this, without having to define a custom iterator:</p>
<pre><code>for protocol, n, counts in magicFunc(myDict):
  # do stuff with protocol, n and counts
</code></pre>
<p>Is there something in <code>itertools</code> perhaps, that lets me do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not sure it's any nicer... I'd stick with what you've got for your example, but were it to become deeper, than something like:</p>
<pre><code>myDict = {
    'p1': {1: [1, 2, 3], 2: [4, 5, 6]},
    'p2': {3: [7, 8, 9], 4: [0, 1, 2]}
}

from collections import Mapping

def go_go_gadget_go(mapping):
    for k, v in mapping.items():
        if isinstance(v, Mapping):
            for ok in go_go_gadget_go(v):
                yield [k] + ok
        else:
            yield [k] + [v]

for protocol, n, counts in go_go_gadget_go(myDict):
    print(protocol, n, counts)

# p2 3 [7, 8, 9]
# p2 4 [0, 1, 2]
# p1 1 [1, 2, 3]
# p1 2 [4, 5, 6]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't need to use <code>protocol</code>, you can use <a href="http://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable</code></a> with <a href="http://docs.python.org/3/library/functions.html#map" rel="nofollow"><code>map</code></a>:</p>
<pre><code>import itertools
for n, counts in itertools.chain.from_iterable(map(dict.items, myDict.values())):
    # do stuff with n and counts
</code></pre>
</div>
<span class="comment-copy">As it stands I'd stick with what you've got. If you second dict, instead of lists having more dicts which had more dicts, then in effect, you'd use a dict flattener and yield from that. Otherwise, any solution for your current problem is going to be more obscure and not worth it...</span>
<span class="comment-copy"><code>you'd use a dict flattener</code>. Does such a thing exist (very interested), or do I have to write it myself (less interested)?</span>
<span class="comment-copy">Whipped up a quick example of what I meant.... It might have some value if you get more deeply nested - otherwise - stick with what you got...</span>
<span class="comment-copy">Why not <code>[k, v]</code> instead of <code>[k] + [v]</code>?</span>
<span class="comment-copy">@falsetru that would have been easier than copy pasting and changing <code>v</code> to be a list wouldn't it :p</span>
<span class="comment-copy">But that still implicitly loops twice, right? Granted it may be faster, but there is an implicit look in there.</span>
<span class="comment-copy">@GamesBrainiac, Anyway, loop is unavoidable.</span>
<span class="comment-copy">He used <code>protocol</code> in his sample code.</span>
<span class="comment-copy">@ChadMiller, The question is changed after I posted the answer.</span>
<span class="comment-copy">I do need to use <code>protocol</code>. I've edited my post to reflect that. Sorry about the confusion. @GamesBrainiac: implicit double looping is less of a concern at this point. I want to be able to unroll all levels of nesting without too much effort. So the call to <code>map(dict.items, myDict.values())</code> is more concerning, as that doesn't scale very easily to more levels of nesting</span>
