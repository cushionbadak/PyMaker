<div class="post-text" itemprop="text">
<p>I'm doing a coursera' <a href="https://www.coursera.org/learn/basic-modeling" rel="nofollow noreferrer">discrete optimization course</a>
which, in the course a tool called Minizinc is used to solve the problems. </p>
<p>I want to translate class examples to python, starting for this one:</p>
<p><a href="https://i.stack.imgur.com/zWQm3.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/zWQm3.png"/></a>
I'm using this example code  reproduce the results:</p>
<pre><code>v = {'hammer':6, 'wrench':10, 'screwdriver':8, 'towel':40}
w = {'hammer':13, 'wrench':21, 'screwdriver':17, 'towel':100}
q = {'hammer':1000, 'wrench':400, 'screwdriver':500, 'towel':150}
limit = 1000
items = list(sorted(v.keys()))

# Create model
m = LpProblem("Knapsack", LpMaximize)

# Variables
x = LpVariable.dicts('x', items, lowBound=0, upBound=1, cat=LpInteger)

# Objective
m += sum(v[i]*x[i] for i in items)

# Constraint
m += sum(w[i]*x[i] for i in items) &lt;= limit


# Optimize
m.solve()

# Print the status of the solved LP
print("Status = %s" % LpStatus[m.status])

# Print the value of the variables at the optimum
for i in items:
    print("%s = %f" % (x[i].name, x[i].varValue))

# Print the value of the objective
print("Objective = %f" % value(m.objective))
</code></pre>
<p>But this is giving a wrong answer since is only taken one of a kind.
How can I add the amount available for each item (dict q) into the constraints?</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to make two very small changes to your code. Firstly you need to remove the upper bound you have set on your <code>x</code> variables. At the moments you have binary variables <code>x[i]</code> which can be only one or zero.</p>
<p>Secondly you need to add in the constraints which effectively set a custom upper bound for each of the items. Working code and resulting solution below - as you can see multiple wrenches (the highest <code>v/w</code> ratio) are chosen, with a single hammer to fill up the small amount of space left.</p>
<pre><code>from pulp import *
v = {'hammer':6, 'wrench':10, 'screwdriver':8, 'towel':40}
w = {'hammer':13, 'wrench':21, 'screwdriver':17, 'towel':100}
q = {'hammer':1000, 'wrench':400, 'screwdriver':500, 'towel':150}
limit = 1000
items = list(sorted(v.keys()))

# Create model
m = LpProblem("Knapsack", LpMaximize)

# Variables
x = LpVariable.dicts('x', items, lowBound=0, cat=LpInteger)

# Objective
m += sum(v[i]*x[i] for i in items)

# Constraint
m += sum(w[i]*x[i] for i in items) &lt;= limit

# Quantity of each constraint:
for i in items:
    m += x[i] &lt;= q[i]


# Optimize
m.solve()

# Print the status of the solved LP
print("Status = %s" % LpStatus[m.status])

# Print the value of the variables at the optimum
for i in items:
    print("%s = %f" % (x[i].name, x[i].varValue))

# Print the value of the objective
print("Objective = %f" % value(m.objective))
print("Total weight = %f" % sum([x[i].varValue*w[i] for i in items]))
</code></pre>
<p>Which returns:</p>
<p>Status = Optimal</p>
<pre><code>x_hammer = 1.000000
x_screwdriver = 0.000000
x_towel = 0.000000
x_wrench = 47.000000
Objective = 476.000000
Total weight = 1000.000000
</code></pre>
</div>
