<div class="post-text" itemprop="text">
<p>I have this string that has been decoded from Quoted-printable to ISO-8859-1 with the email module. This gives me strings like "\xC4pple" which would correspond to "Äpple" (Apple in Swedish).
However, I can't convert those strings to UTF-8.</p>
<pre><code>&gt;&gt;&gt; apple = "\xC4pple"
&gt;&gt;&gt; apple
'\xc4pple'
&gt;&gt;&gt; apple.encode("UTF-8")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 0: ordinal not in     range(128)
</code></pre>
<p>What should I do?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try decoding it first, then encoding:</p>
<pre><code>apple.decode('iso-8859-1').encode('utf8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a common problem, so here's a relatively thorough illustration.</p>
<p>For non-unicode strings (i.e. those without <code>u</code> prefix like <code>u'\xc4pple'</code>), one must decode from the native encoding (<code>iso8859-1</code>/<code>latin1</code>, unless <a href="https://stackoverflow.com/q/2276200/19212">modified with the enigmatic <code>sys.setdefaultencoding</code></a> function) to <a href="http://en.wikipedia.org/wiki/Unicode" rel="noreferrer"><code>unicode</code></a>, then encode to a character set that can display the characters you wish, in this case I'd recommend <a href="http://en.wikipedia.org/wiki/UTF-8" rel="noreferrer"><code>UTF-8</code></a>.</p>
<p>First, here is a handy utility function that'll help illuminate the patterns of Python 2.7 string and unicode:</p>
<pre><code>&gt;&gt;&gt; def tell_me_about(s): return (type(s), s)
</code></pre>
<h3>A plain string</h3>
<pre><code>&gt;&gt;&gt; v = "\xC4pple" # iso-8859-1 aka latin1 encoded string

&gt;&gt;&gt; tell_me_about(v)
(&lt;type 'str'&gt;, '\xc4pple')

&gt;&gt;&gt; v
'\xc4pple'        # representation in memory

&gt;&gt;&gt; print v
?pple             # map the iso-8859-1 in-memory to iso-8859-1 chars
                  # note that '\xc4' has no representation in iso-8859-1, 
                  # so is printed as "?".
</code></pre>
<h3>Decoding a iso8859-1 string - convert plain string to unicode</h3>
<pre><code>&gt;&gt;&gt; uv = v.decode("iso-8859-1")
&gt;&gt;&gt; uv
u'\xc4pple'       # decoding iso-8859-1 becomes unicode, in memory

&gt;&gt;&gt; tell_me_about(uv)
(&lt;type 'unicode'&gt;, u'\xc4pple')

&gt;&gt;&gt; print v.decode("iso-8859-1")
Äpple             # convert unicode to the default character set
                  # (utf-8, based on sys.stdout.encoding)

&gt;&gt;&gt; v.decode('iso-8859-1') == u'\xc4pple'
True              # one could have just used a unicode representation 
                  # from the start
</code></pre>
<h3>A little more illustration — with “Ä”</h3>
<pre><code>&gt;&gt;&gt; u"Ä" == u"\xc4"
True              # the native unicode char and escaped versions are the same

&gt;&gt;&gt; "Ä" == u"\xc4"  
False             # the native unicode char is '\xc3\x84' in latin1

&gt;&gt;&gt; "Ä".decode('utf8') == u"\xc4"
True              # one can decode the string to get unicode

&gt;&gt;&gt; "Ä" == "\xc4"
False             # the native character and the escaped string are
                  # of course not equal ('\xc3\x84' != '\xc4').
</code></pre>
<h3>Encoding to UTF</h3>
<pre><code>&gt;&gt;&gt; u8 = v.decode("iso-8859-1").encode("utf-8")
&gt;&gt;&gt; u8
'\xc3\x84pple'    # convert iso-8859-1 to unicode to utf-8

&gt;&gt;&gt; tell_me_about(u8)
(&lt;type 'str'&gt;, '\xc3\x84pple')

&gt;&gt;&gt; u16 = v.decode('iso-8859-1').encode('utf-16')
&gt;&gt;&gt; tell_me_about(u16)
(&lt;type 'str'&gt;, '\xff\xfe\xc4\x00p\x00p\x00l\x00e\x00')

&gt;&gt;&gt; tell_me_about(u8.decode('utf8'))
(&lt;type 'unicode'&gt;, u'\xc4pple')

&gt;&gt;&gt; tell_me_about(u16.decode('utf16'))
(&lt;type 'unicode'&gt;, u'\xc4pple')
</code></pre>
<h3>Relationship between unicode and UTF and latin1</h3>
<pre><code>&gt;&gt;&gt; print u8
Äpple             # printing utf-8 - because of the encoding we now know
                  # how to print the characters

&gt;&gt;&gt; print u8.decode('utf-8') # printing unicode
Äpple

&gt;&gt;&gt; print u16     # printing 'bytes' of u16
���pple

&gt;&gt;&gt; print u16.decode('utf16')
Äpple             # printing unicode

&gt;&gt;&gt; v == u8
False             # v is a iso8859-1 string; u8 is a utf-8 string

&gt;&gt;&gt; v.decode('iso8859-1') == u8
False             # v.decode(...) returns unicode

&gt;&gt;&gt; u8.decode('utf-8') == v.decode('latin1') == u16.decode('utf-16')
True              # all decode to the same unicode memory representation
                  # (latin1 is iso-8859-1)
</code></pre>
<h3>Unicode Exceptions</h3>
<pre><code> &gt;&gt;&gt; u8.encode('iso8859-1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 0:
  ordinal not in range(128)

&gt;&gt;&gt; u16.encode('iso8859-1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 0:
  ordinal not in range(128)

&gt;&gt;&gt; v.encode('iso8859-1')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 0:
  ordinal not in range(128)
</code></pre>
<p>One would get around these by converting from the specific encoding (latin-1, utf8, utf16) to unicode e.g. <code>u8.decode('utf8').encode('latin1')</code>.</p>
<p>So perhaps one could draw the following principles and generalizations:</p>
<ul>
<li>a type <code>str</code> is a set of bytes, which may have one of a number of encodings such as Latin-1, UTF-8, and UTF-16</li>
<li>a type <code>unicode</code> is a set of bytes that can be converted to any number of encodings, most commonly UTF-8 and latin-1 (iso8859-1)</li>
<li>the <code>print</code> command has <a href="https://stackoverflow.com/questions/2596714">its own logic for encoding</a>, set to <code>sys.stdout.encoding</code> and defaulting to UTF-8</li>
<li>One must decode a <code>str</code> to unicode before converting to another encoding.</li>
</ul>
<p>Of course, all of this changes in Python 3.x.</p>
<p>Hope that is illuminating.</p>
<h3>Further reading</h3>
<ul>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF" rel="noreferrer">Characters vs. Bytes</a>, by Tim Bray.</li>
</ul>
<p>And the very illustrative rants by Armin Ronacher:</p>
<ul>
<li><a href="http://lucumr.pocoo.org/2013/7/2/the-updated-guide-to-unicode/" rel="noreferrer">The Updated Guide to Unicode on Python (July 2, 2013)</a></li>
<li><a href="http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/" rel="noreferrer">More About Unicode in Python 2 and 3 (January 5, 2014)</a></li>
<li><a href="http://lucumr.pocoo.org/2014/1/9/ucs-vs-utf8/" rel="noreferrer">UCS vs UTF-8 as Internal String Encoding (January 9, 2014)</a></li>
<li><a href="http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/" rel="noreferrer">Everything you did not want to know about Unicode in Python 3 (May 12, 2014)</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3:</p>
<pre><code>bytes(apple,'iso-8859-1').decode('utf-8')
</code></pre>
<p>I used this for a text incorrectly encoded as iso-8859-1 (showing words like <em>VeÅ\x99ejnÃ©</em>) instead of utf-8. This code produces correct version <em>Veřejné</em>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Decode to Unicode, encode the results to UTF8. </p>
<pre><code>apple.decode('latin1').encode('utf8')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>concept = concept.encode('ascii', 'ignore') 
concept = MySQLdb.escape_string(concept.decode('latin1').encode('utf8').rstrip())
</code></pre>
<p>I do this, I am not sure if that is a good approach but it works everytime !!</p>
</div>
<span class="comment-copy">I had some problems encoding stuff to my language (Portuguese),so what worked for me was string.decode('iso-8859-1').encode('latin1'). Also, on the top of my python file, I have this # -<i>- coding: latin-1 -</i>-</span>
<span class="comment-copy">Thanks for taking the time to write such a detailed explanation, one of the best answers I ever found on stackoverflow :)</span>
<span class="comment-copy">Wow. Succinct, very understandable, and explained by example.  Thanks for making the Intertubes better.</span>
<span class="comment-copy">where does <code>bytes</code> come from?</span>
<span class="comment-copy">Documentation: <a href="https://docs.python.org/3/library/functions.html#bytes" rel="nofollow noreferrer">bytes</a>. Also see this <a href="http://stackoverflow.com/questions/7585435/best-way-to-convert-string-to-bytes-in-python-3">question</a> and its answers.</span>
<span class="comment-copy">For files downloaded with Requests with missing or incorrect headers: <code>r = requests.get(url)</code> and then directly setting <code>r.encoding = 'utf-8'</code> worked for me</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" rel="nofollow noreferrer">bytes.decode</a> method documentation.</span>
