<div class="post-text" itemprop="text">
<p>I am trying to create a dictionary from a csv file. The first column of the csv file contains unique keys and the second column contains values. Each row of the csv file represents a unique key, value pair within the dictionary. I tried to use the <a href="https://docs.python.org/3/library/csv.html#csv.DictReader"><code>csv.DictReader</code></a> and <a href="https://docs.python.org/3/library/csv.html#csv.DictWriter"><code>csv.DictWriter</code></a> classes, but I could only figure out how to generate a new dictionary for each row. I want one dictionary. Here is the code I am trying to use:</p>
<pre><code>import csv

with open('coors.csv', mode='r') as infile:
    reader = csv.reader(infile)
    with open('coors_new.csv', mode='w') as outfile:
    writer = csv.writer(outfile)
    for rows in reader:
        k = rows[0]
        v = rows[1]
        mydict = {k:v for k, v in rows}
    print(mydict)
</code></pre>
<p>When I run the above code I get a <code>ValueError: too many values to unpack (expected 2)</code>. How do I create one dictionary from a csv file? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I believe the syntax you were looking for is as follows:</p>
<pre><code>with open('coors.csv', mode='r') as infile:
    reader = csv.reader(infile)
    with open('coors_new.csv', mode='w') as outfile:
        writer = csv.writer(outfile)
        mydict = {rows[0]:rows[1] for rows in reader}
</code></pre>
<p>Alternately, for python &lt;= 2.7.1, you want:</p>
<pre><code>mydict = dict((rows[0],rows[1]) for rows in reader)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Open the file by calling open and then <code>csv.DictReader</code>.</p>
<pre><code>input_file = csv.DictReader(open("coors.csv"))
</code></pre>
<p>You may iterate over the rows of the csv file dict reader object by iterating over input_file. </p>
<pre><code>for row in input_file:
    print row
</code></pre>
<p>OR 
    To access first line only</p>
<pre><code>dictobj = csv.DictReader(open('coors.csv')).next() 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
reader = csv.reader(open('filename.csv', 'r'))
d = {}
for row in reader:
   k, v = row
   d[k] = v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to just convert csv.reader to dict:</p>
<pre><code>~ &gt;&gt; cat &gt; 1.csv
key1, value1
key2, value2
key2, value22
key3, value3

~ &gt;&gt; cat &gt; d.py
import csv
with open('1.csv') as f:
    d = dict(filter(None, csv.reader(f)))

print(d)

~ &gt;&gt; python d.py
{'key3': ' value3', 'key2': ' value22', 'key1': ' value1'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This isn't elegant but a one line solution using pandas.</p>
<pre><code>import pandas as pd
pd.read_csv('coors.csv', header=None, index_col=0, squeeze=True).to_dict()
</code></pre>
<p>If you want to specify dtype for your index (it can't be specified in read_csv if you use the index_col argument because of a <a href="https://github.com/pandas-dev/pandas/issues/9435" rel="noreferrer">bug</a>):</p>
<pre><code>import pandas as pd
pd.read_csv('coors.csv', header=None, dtype={0: str}).set_index(0).squeeze().to_dict()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also use numpy for this.</p>
<pre><code>from numpy import loadtxt
key_value = loadtxt("filename.csv", delimiter=",")
mydict = { k:v for k,v in key_value }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest adding <code>if rows</code> in case there is an empty line at the end of the file</p>
<pre><code>import csv
with open('coors.csv', mode='r') as infile:
    reader = csv.reader(infile)
    with open('coors_new.csv', mode='w') as outfile:
        writer = csv.writer(outfile)
        mydict = dict(row[:2] for row in reader if row)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are OK with using the numpy package, then you can do something like the following:</p>
<pre><code>import numpy as np

lines = np.genfromtxt("coors.csv", delimiter=",", dtype=None)
my_dict = dict()
for i in range(len(lines)):
   my_dict[lines[i][0]] = lines[i][1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use this, it is pretty cool:</p>
<pre><code>import dataconverters.commas as commas
filename = 'test.csv'
with open(filename) as f:
      records, metadata = commas.parse(f)
      for row in records:
            print 'this is row in dictionary:'+rowenter code here
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One-liner solution</p>
<pre><code>import pandas as pd

dict = {row[0] : row[1] for _, row in pd.read_csv("file.csv").iterrows()}
</code></pre>
</div>
<span class="comment-copy">Can you give an example of an input file and the resulting data structure?</span>
<span class="comment-copy">When you iterate over csv.reader, you get single row, not rows. So, valid form is mydict = {k:v for k,v in reader} but if you are sure, that there are only two columns in the csv file, then mydict = dict(reader) is much faster.</span>
<span class="comment-copy">Good to account for rows longer than expected; but shouldn't he be raising his own exception if there are too many items in a row? I would think that would mean there's an error with his input data.</span>
<span class="comment-copy">And then he'd at least be able to narrow the exception down to faulty input</span>
<span class="comment-copy">That has some merit, but I'm a firm believer that exceptions are there to tell you that you programmed something incorrectly - not for when the world gives you lemons.  That's when you print a pretty error message and fail, or - more appropriate for this case - a pretty warning message and succeed.</span>
<span class="comment-copy">Sorry, looked at op's code, hard to tell if he wanted only 2 items per line. I was wrong!</span>
<span class="comment-copy">This makes DictReader object not a dictionary(and yes not a key value pair)</span>
<span class="comment-copy">@HN Singh - Yeah, I know - intention was it will help some one else as well</span>
<span class="comment-copy">Highly non-pythonic style.</span>
<span class="comment-copy">@Alex Laskin: Really? It looks like some pretty readable python to me. What's your principle to back this statement up? You basically just called him "poopy head"...</span>
<span class="comment-copy">@machine-yearning, no, I didn't say that his code is 'bad'. But there is no a single reason to write <code>for row in reader:   k, v = row</code> if you can simply write <code>for k, v in reader</code>, for example. And if you expect, that reader is an iterable, producing two-element items, then you can simply pass it directly to dict for conversion. <code>d = dict(reader)</code> is much shorter and significantly faster on huge datasets.</span>
<span class="comment-copy">@Alex Laskin: Thanks for the clarification. I personally agreed with you but I think that if you're gonna call someone's code "non-pythonic" you should accompany that comment with a justification.  I'd say that "shorter" and "faster" are not necessarily equivalent to "more pythonic". Readability/reliability is a huge concern as well. If it's easier to work in some of our constraints into the above <code>for row in reader</code> paradigm, then it might (after longer-term development) be more practical. I agree with you short-term, but beware of premature optimization.</span>
<span class="comment-copy">that solution is tidy, and will work great if he can be <b>sure</b> that his inputs will never have three or more columns in some row.  However, if that is ever encountered, an exception somewhat like this will be raised: <code>ValueError: dictionary update sequence element #2 has length 3; 2 is required</code>.</span>
<span class="comment-copy">@machine, judging from the error in the question, the csv file has more than 2 columns</span>
<span class="comment-copy">@gnibbler, no, error in the question is due to double unpacking of row. First he try to iterate over reader, obtaining <i>rows</i> which is actually single <i>row</i>. And when he try to iterate over this single row, he get two items, which can't be unpacked correctly.</span>
<span class="comment-copy">A general comment: making objects held in memory from iterables can cause a memory problem. Suggest checking your memory space and the size of the iterable source file. A main advantage (the whole point?) of iterables is to not hold large things in memory.</span>
<span class="comment-copy">@Nate: That can be fixed if necessary by wrapping the <code>filter</code> call with <code>map(operator.itemgetter(slice(2)), ...)</code>, so it will only pull the first two iterms, making it: <code>dict(map(operator.itemgetter(slice(2)), filter(None, csv.reader(f))))</code>. If it's Python 2, make sure to do <code>from future_builtins import map, filter</code>, so the <code>dict</code> reads a generator directly, instead of producing multiple unnecessary temporary <code>list</code>s first).</span>
<span class="comment-copy">Both well-done and well-thought-out. But like I said above, should he really be ignoring the fact that his input line is longer than he expected? I'd say he should raise his own exception (with a custom message) if he gets a line with more than two items.</span>
<span class="comment-copy">Or rather, as stated above by @Nate, at least print a warning message. This just doesn't seem like something you'd want to ignore.</span>
<span class="comment-copy">your answer (vs. mine) made ponder something - is there an efficiency difference between slicing and indexing in this case?</span>
<span class="comment-copy">@machine, no idea. Perhaps it's a dump of a user table from a database, and he just wants a dict of userid:username or something for example</span>
<span class="comment-copy">Hey guys, thanks for the comments. Your discussion really helped me out with my problem. I like the idea about about raising a flag if the input is longer than expected. My data is a database dump and I do have more than two columns of data.</span>
