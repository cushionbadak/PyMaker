<div class="post-text" itemprop="text">
<p>I want something like <code>sys.builtin_module_names</code> except for the standard library. Other things that didn't work:</p>
<ul>
<li><code>sys.modules</code> - only shows modules that have already been loaded</li>
<li><code>sys.prefix</code> - a path that would include non-standard library modules EDIT: and doesn't seem to work inside a virtualenv.</li>
</ul>
<p>The reason I want this list is so that I can pass it to the <code>--ignore-module</code> or <code>--ignore-dir</code> command line options of <code>trace</code> <a href="http://docs.python.org/library/trace.html">http://docs.python.org/library/trace.html</a></p>
<p>So ultimately, I want to know how to ignore all the standard library modules when using <code>trace</code> or <code>sys.settrace</code>.</p>
<p>EDIT: I want it to work inside a virtualenv. <a href="http://pypi.python.org/pypi/virtualenv">http://pypi.python.org/pypi/virtualenv</a></p>
<p>EDIT2: I want it to work for all environments (i.e. across operating systems, inside and outside of a virtualenv.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not work out what's part of the standard library yourself?</p>
<pre><code>import distutils.sysconfig as sysconfig
import os
std_lib = sysconfig.get_python_lib(standard_lib=True)
for top, dirs, files in os.walk(std_lib):
    for nm in files:
        if nm != '__init__.py' and nm[-3:] == '.py':
            print os.path.join(top, nm)[len(std_lib)+1:-3].replace('\\','.')
</code></pre>
<p>gives</p>
<pre><code>abc
aifc
antigravity
--- a bunch of other files ----
xml.parsers.expat
xml.sax.expatreader
xml.sax.handler
xml.sax.saxutils
xml.sax.xmlreader
xml.sax._exceptions
</code></pre>
<p><strong>Edit:</strong> You'll probably want to add a check to avoid <code>site-packages</code> if you need to avoid non-standard library modules.</p>
</div>
<div class="post-text" itemprop="text">
<p>If anyone's still reading this in 2015, I came across the same issue, and didn't like any of the existing solutions. So, I brute forced it by writing some code to scrape the TOC of the Standard Library page in the official Python docs. I also built a simple API for getting a list of standard libraries (for Python version 2.6, 2.7, 3.2, 3.3, and 3.4).</p>
<p>The package is <a href="https://github.com/jackmaney/python-stdlib-list" rel="noreferrer">here</a>, and its usage is fairly simple:</p>
<pre><code>&gt;&gt;&gt; from stdlib_list import stdlib_list
&gt;&gt;&gt; libraries = stdlib_list("2.7")
&gt;&gt;&gt; libraries[:10]
['AL', 'BaseHTTPServer', 'Bastion', 'CGIHTTPServer', 'ColorPicker', 'ConfigParser', 'Cookie', 'DEVICE', 'DocXMLRPCServer', 'EasyDialogs']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Take a look at this,
<a href="https://docs.python.org/3/py-modindex.html">https://docs.python.org/3/py-modindex.html</a>
They made an index page for the standard modules.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an improvement on Caspar's answer, which is not cross-platform, and misses out top-level modules (e.g. <code>email</code>), dynamically loaded modules (e.g. <code>array</code>), and core built-in modules (e.g. <code>sys</code>):</p>
<pre><code>import distutils.sysconfig as sysconfig
import os
import sys

std_lib = sysconfig.get_python_lib(standard_lib=True)

for top, dirs, files in os.walk(std_lib):
    for nm in files:
        prefix = top[len(std_lib)+1:]
        if prefix[:13] == 'site-packages':
            continue
        if nm == '__init__.py':
            print top[len(std_lib)+1:].replace(os.path.sep,'.')
        elif nm[-3:] == '.py':
            print os.path.join(prefix, nm)[:-3].replace(os.path.sep,'.')
        elif nm[-3:] == '.so' and top[-11:] == 'lib-dynload':
            print nm[0:-3]

for builtin in sys.builtin_module_names:
    print builtin
</code></pre>
<p>This is still not perfect because it will miss things like <code>os.path</code> which is defined from within <code>os.py</code> in a platform-dependent manner via code such as <code>import posixpath as path</code>, but it's probably as good as you'll get, bearing in mind that Python is a dynamic language and you can't ever really know which modules are defined until they're actually defined at runtime.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a 2014 answer to a 2011 question - </p>
<p>The author of <a href="https://pypi.python.org/pypi/isort" rel="nofollow">isort</a>, a tool which cleans up imports, had to grapple this same problem in order to satisfy the pep8 requirement that core library imports should be ordered before third party imports.  </p>
<p>I have been using this tool and it seems to be working well.  You can use the method <code>place_module</code> in the file <code>isort.py</code>, since it's open source I hope the author would not mind me reproducing the logic here:</p>
<pre><code>def place_module(self, moduleName):
    """Tries to determine if a module is a python std import, third party import, or project code:

    if it can't determine - it assumes it is project code

    """
    if moduleName.startswith("."):
        return SECTIONS.LOCALFOLDER

    index = moduleName.find('.')
    if index:
        firstPart = moduleName[:index]
    else:
        firstPart = None

    for forced_separate in self.config['forced_separate']:
        if moduleName.startswith(forced_separate):
            return forced_separate

    if moduleName == "__future__" or (firstPart == "__future__"):
        return SECTIONS.FUTURE
    elif moduleName in self.config['known_standard_library'] or \
            (firstPart in self.config['known_standard_library']):
        return SECTIONS.STDLIB
    elif moduleName in self.config['known_third_party'] or (firstPart in self.config['known_third_party']):
        return SECTIONS.THIRDPARTY
    elif moduleName in self.config['known_first_party'] or (firstPart in self.config['known_first_party']):
        return SECTIONS.FIRSTPARTY

    for prefix in PYTHONPATH:
        module_path = "/".join((prefix, moduleName.replace(".", "/")))
        package_path = "/".join((prefix, moduleName.split(".")[0]))
        if (os.path.exists(module_path + ".py") or os.path.exists(module_path + ".so") or
           (os.path.exists(package_path) and os.path.isdir(package_path))):
            if "site-packages" in prefix or "dist-packages" in prefix:
                return SECTIONS.THIRDPARTY
            elif "python2" in prefix.lower() or "python3" in prefix.lower():
                return SECTIONS.STDLIB
            else:
                return SECTIONS.FIRSTPARTY

    return SECTION_NAMES.index(self.config['default_section'])
</code></pre>
<p>Obviously you need to use this method in the context of the class and the settings file.  That is basically a fallback on a static list of known core lib imports.  </p>
<pre><code># Note that none of these lists must be complete as they are simply fallbacks for when included auto-detection fails.
default = {'force_to_top': [],
           'skip': ['__init__.py', ],
           'line_length': 80,
           'known_standard_library': ["abc", "anydbm", "argparse", "array", "asynchat", "asyncore", "atexit", "base64",
                                      "BaseHTTPServer", "bisect", "bz2", "calendar", "cgitb", "cmd", "codecs",
                                      "collections", "commands", "compileall", "ConfigParser", "contextlib", "Cookie",
                                      "copy", "cPickle", "cProfile", "cStringIO", "csv", "datetime", "dbhash", "dbm",
                                      "decimal", "difflib", "dircache", "dis", "doctest", "dumbdbm", "EasyDialogs",
                                      "errno", "exceptions", "filecmp", "fileinput", "fnmatch", "fractions",
                                      "functools", "gc", "gdbm", "getopt", "getpass", "gettext", "glob", "grp", "gzip",
                                      "hashlib", "heapq", "hmac", "imaplib", "imp", "inspect", "itertools", "json",
                                      "linecache", "locale", "logging", "mailbox", "math", "mhlib", "mmap",
                                      "multiprocessing", "operator", "optparse", "os", "pdb", "pickle", "pipes",
                                      "pkgutil", "platform", "plistlib", "pprint", "profile", "pstats", "pwd", "pyclbr",
                                      "pydoc", "Queue", "random", "re", "readline", "resource", "rlcompleter",
                                      "robotparser", "sched", "select", "shelve", "shlex", "shutil", "signal",
                                      "SimpleXMLRPCServer", "site", "sitecustomize", "smtpd", "smtplib", "socket",
                                      "SocketServer", "sqlite3", "string", "StringIO", "struct", "subprocess", "sys",
                                      "sysconfig", "tabnanny", "tarfile", "tempfile", "textwrap", "threading", "time",
                                      "timeit", "trace", "traceback", "unittest", "urllib", "urllib2", "urlparse",
                                      "usercustomize", "uuid", "warnings", "weakref", "webbrowser", "whichdb", "xml",
                                      "xmlrpclib", "zipfile", "zipimport", "zlib", 'builtins', '__builtin__'],
           'known_third_party': ['google.appengine.api'],
           'known_first_party': [],
</code></pre>
<p>---snip--- </p>
<p>I was already an hour into writing this tool for myself before I stumbled the isort module, so I hope this can also help somebody else to avoid re-inventing the wheel!</p>
</div>
<div class="post-text" itemprop="text">
<p>This will get you close:</p>
<pre><code>import sys; import glob
glob.glob(sys.prefix + "/lib/python%d.%d" % (sys.version_info[0:2]) + "/*.py")
</code></pre>
<p>Another possibility for the <code>ignore-dir</code> option:</p>
<pre><code>os.pathsep.join(sys.path)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would consult the standard library reference in the official documentation, which goes through the whole library with a section for each module. :)</p>
</div>
<span class="comment-copy">This is a rough duplicate of <a href="http://stackoverflow.com/questions/5632980/list-of-all-imports-in-python-3" title="list of all imports in python 3">stackoverflow.com/questions/5632980/…</a>, which unfortunately did not attract any particularly useful answers so far.</span>
<span class="comment-copy"><code>sysconfig.get_python_lib(standard_lib=True)</code> also gives me the path of my virtualenv which doesn't have all the standard library modules.</span>
<span class="comment-copy">In the case of virtualenv, you can reduce the problem to finding the location of the virtualenv, which <a href="http://groups.google.com/group/python-virtualenv/browse_thread/thread/e30029b2e50ae17a" rel="nofollow noreferrer">this thread</a> suggests can be done using <code>sys.real_prefix</code> (although I don't have a virtualenv handy to test on)</span>
<span class="comment-copy">Using <code>sys.real_prefix</code> with virtualenv is also mentioned in <a href="http://stackoverflow.com/questions/1871549/python-determine-if-running-inside-virtualenv/1883251#1883251">this SO answer</a></span>
<span class="comment-copy">Using <code>sys.real_prefix</code> works inside a virtualenv. But I do want it to work both inside and outside a virtualenv. I guess I just need some logic to decide which prefix to use.</span>
<span class="comment-copy">It turns out that if my virtualenv is activated and my current working directory is <code>/usr/lib/python2.6</code> when I invoke the Python interpreter, <code>sysconfig.get_python_lib(standard_lib=True)</code> returns the path for my virtualenv (e.g. <code>~/.virtualenvs/myenv/lib/python2.6</code>). However, if I my current working directory is something other than <code>/usr/lib/python2.6</code>, it returns the correct path, <code>/usr/lib/python2.6</code>. So I was not smoking drugs last night.</span>
<span class="comment-copy">I just realized that <code>sys.prefix</code> returns a path doesn't include most of the standard library modules when I'm running inside a virtualenv. I edited my question above.</span>
