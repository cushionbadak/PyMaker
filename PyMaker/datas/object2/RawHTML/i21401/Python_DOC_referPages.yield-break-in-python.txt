<div class="post-text" itemprop="text">
<p>according to answer to this <a href="https://stackoverflow.com/questions/1704607/difference-between-yield-in-python-and-yield-in-c">question</a>, yield break in C# is equivalent to return in python. in normal case, 'return' indeed stop a generator. But if your function does nothing but return, you will get a None not an empty iterator, which is returned by yield break in C#</p>
<pre><code>def generate_nothing():
    return

for i in generate_nothing():
    print i
</code></pre>
<p>you will get a TypeError: 'NoneType' object is not iterable.
but if I add an never run yield before return, this function return what I expect.</p>
<pre><code>def generate_nothing():
    if False: yield None
    return
</code></pre>
<p>if works but seems wired. Who has better idea?</p>
<p>thanks,</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def generate_nothing():
    return
    yield
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A good way to handle this is raising <a href="http://docs.python.org/2/library/exceptions.html#exceptions.StopIteration">StopIteration</a> which is what is raised when your iterator has nothing left to yield and <code>next()</code> is called. This will also gracefully break out of a for loop with nothing inside the loop executed.</p>
<p>For example, given a tuple <code>(0, 1, 2, 3)</code> I want to get overlapping pairs <code>((0, 1), (1, 2), (2, 3))</code>. I could do it like so:</p>
<pre><code>def pairs(numbers):
    if len(numbers) &lt; 2:
        raise StopIteration

    for i, number in enumerate(numbers[1:]):
        yield numbers[i], number
</code></pre>
<p>Now <code>pairs</code> safely handles lists with 1 number or less.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def generate_nothing():
    return iter([])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The funny part is that both functions have the same bytecode. Probably there's a flag that sets to <code>generator</code> when bytecode compiler finds the <code>yield</code> keyword.</p>
<pre><code>&gt;&gt;&gt; def f():
...   return

&gt;&gt;&gt; def g():
...   if False: yield 
#in Python2 you can use 0 instead of False to achieve the same result


&gt;&gt;&gt; from dis import dis
&gt;&gt;&gt; dis(f)
2           0 LOAD_CONST               0 (None) 
            3 RETURN_VALUE
&gt;&gt;&gt; dis(g)
2           0 LOAD_CONST               0 (None) 
            3 RETURN_VALUE
</code></pre>
</div>
<span class="comment-copy">That's just how Python works. I don't think you really even need the final <code>return</code> in there. Python is not C#. don't expect them to work the same.</span>
<span class="comment-copy">A function without <code>yield</code> is not a generator. Thus your first example just returns <code>None</code> and tries to iterate over that.</span>
<span class="comment-copy">@Jochen: that's not a generator. It's an iterable-producing object. Though as I said in phihag's answer, it's unlikely to matter.</span>
<span class="comment-copy">note that from vs 3.6 and on this is a bad idea because with the implementation of <a href="https://www.python.org/dev/peps/pep-0479/" rel="nofollow noreferrer">PEP 479</a> the <code>StopIteration</code> will be converted into a <code>RuntimeError</code> to prevent problems when using sub generators.</span>
<span class="comment-copy">It's a bad idea in any version; just <code>return</code>.</span>
<span class="comment-copy">While this is functional (for now), <code>return</code> is better; the described functionality is even included in the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-return-statement" rel="nofollow noreferrer">return documentation</a>.</span>
<span class="comment-copy">or <code>xrange(0)</code> (<code>range(0)</code> in 3.x).</span>
<span class="comment-copy">Both of these are about twice as fast as <code>return; yield</code>. But be aware that these will return objects of types <code>&lt;type 'listiterator'&gt;</code> and <code>&lt;type 'xrange'&gt;</code>, both of which are direct subtypes of <code>object</code> - so they are not generators. Not that that's likely to matter. Merely of academic interest :-)</span>
<span class="comment-copy">@Chris: in python3, I'm only clocking it about 20-30% faster, though qualitatively it seems slightly less of a strain of memory (not a rigorous test: <code>z=[list(f()) for _ in range(10**7)]</code>)</span>
<span class="comment-copy">Huh? They're far from the same. Check your results again. You made a mistake somewhere.</span>
<span class="comment-copy">@Chris Yeah, Python2 don't optimize it because False isn't a keyword and might not be a false value. Python3 does.</span>
<span class="comment-copy">Sweet. It doesn't even generates bytecode for yield statement</span>
<span class="comment-copy">@JBernado: hmm, I see that that is possible in Python 3. I was thinking at first that that would be a glaring problem if False was assigned a different value. I'd forgotten that <code>True</code> and <code>False</code> are keywords in Python 3. And with the same bytecode, I presume the difference is in the fact that <code>f.__code__.co_flags == 67</code> while <code>g.__code__.co_flags == 99</code>. That suggests to be that the sixth bit flag marks it as a generator. Apologies for criticising you - but you really should mark it as Python 3 now for producing the same byte code, anyway.</span>
<span class="comment-copy">@Chris I had already made a comment in my answer :) In Python 2 you can use 0 instead of False</span>
