<div class="post-text" itemprop="text">
<p>I have a large project consisting of sufficiently large number of modules, each printing something to the standard output. Now as the project has grown in size, there are large no. of <code>print</code> statements printing a lot on the std out which has made the program considerably slower.</p>
<p>So, I now want to decide at <em>runtime</em> whether or not to print anything to the stdout. I cannot make changes in the modules as there are plenty of them. (I know I can redirect the stdout to a file but even this is considerably slow.)  </p>
<p>So my question is how do I redirect the stdout to nothing ie how do I make the <code>print</code> statement do nothing?</p>
<pre><code># I want to do something like this.
sys.stdout = None         # this obviously will give an error as Nonetype object does not have any write method.
</code></pre>
<p>Currently the only idea I have is to make a class which has a write method (which does nothing) and redirect the stdout to an instance of this class.</p>
<pre><code>class DontPrint(object):
    def write(*args): pass

dp = DontPrint()
sys.stdout = dp
</code></pre>
<p>Is there an inbuilt mechanism in python for this? Or is there something better than this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Cross-platform:</p>
<pre><code>import os
import sys
f = open(os.devnull, 'w')
sys.stdout = f
</code></pre>
<p>On Windows:</p>
<pre><code>f = open('nul', 'w')
sys.stdout = f
</code></pre>
<p>On Linux:</p>
<pre><code>f = open('/dev/null', 'w')
sys.stdout = f
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A nice way to do this is to create a small context processor that you wrap your prints in. You then just use is in a <code>with</code>-statement to silence all output.</p>
<pre><code>import os
import sys
from contextlib import contextmanager

@contextmanager
def silence_stdout():
    new_target = open(os.devnull, "w")
    old_target = sys.stdout
    sys.stdout = new_target
    try:
        yield new_target
    finally:
        sys.stdout = old_target

with silence_stdout():
    print("will not print")

print("this will print")
</code></pre>
<p>Running this code only prints the second line of output, not the first:</p>
<pre><code>$ python test.py
this will print
</code></pre>
<p>This works cross-platform (Windows + Linux + Mac OSX), and is cleaner than the ones other answers imho.</p>
</div>
<div class="post-text" itemprop="text">
<p>(at least on my system) it appears that writing to os.devnull is about 5x faster than writing to a DontPrint class, i.e.</p>
<pre><code>#!/usr/bin/python
import os
import sys
import datetime

ITER = 10000000
def printlots(out, it, st="abcdefghijklmnopqrstuvwxyz1234567890"):
   temp = sys.stdout
   sys.stdout = out
   i = 0
   start_t = datetime.datetime.now()
   while i &lt; it:
      print st
      i = i+1
   end_t = datetime.datetime.now()
   sys.stdout = temp
   print out, "\n   took", end_t - start_t, "for", it, "iterations"

class devnull():
   def write(*args):
      pass


printlots(open(os.devnull, 'wb'), ITER)
printlots(devnull(), ITER)
</code></pre>
<p>gave the following output:</p>
<pre><code>&lt;open file '/dev/null', mode 'wb' at 0x7f2b747044b0&gt; 
   took 0:00:02.074853 for 10000000 iterations
&lt;__main__.devnull instance at 0x7f2b746bae18&gt; 
   took 0:00:09.933056 for 10000000 iterations
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're in python 3.4 or higher, there's a simple and safe solution using the standard library:</p>
<pre><code>import contextlib
import os

with contextlib.redirect_stdout(None):
  print("This won't print!")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're in a Unix environment (Linux included), you can redirect output to <code>/dev/null</code>:</p>
<pre><code>python myprogram.py &gt; /dev/null
</code></pre>
<p>And for Windows:</p>
<pre><code>python myprogram.py &gt; nul
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>from contextlib import ExitStack, redirect_stdout
import os

with ExitStack() as stack:
    if should_hide_output():
        null_stream = open(os.devnull, "w")
        stack.enter_context(null_stream)
        stack.enter_context(redirect_stdout(null_stream))
    noisy_function()
</code></pre>
<p>This uses the features in the <a href="https://docs.python.org/3.5/library/contextlib.html" rel="nofollow">contextlib</a> module to hide the output of whatever command you are trying to run, depending on the result of <code>should_hide_output()</code>, and then restores the output behavior after that function is done running.</p>
<p>If you want to hide standard error output, then import <code>redirect_stderr</code> from <code>contextlib</code> and add a line saying <code>stack.enter_context(redirect_stderr(null_stream))</code>.</p>
<p>The main downside it that this only works in Python 3.4 and later versions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your class will work just fine (with the exception of the <code>write()</code> method name -- it needs to be called <code>write()</code>, lowercase). Just make sure you save a copy of <code>sys.stdout</code> in another variable.</p>
<p>If you're on a *NIX, you can do <code>sys.stdout = open('/dev/null')</code>, but this is less portable than rolling your own class.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just mock it.</p>
<pre><code>import mock

sys.stdout = mock.MagicMock()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you try this?</p>
<pre><code>sys.stdout.close()
sys.stderr.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>sys.stdout = None
</code></pre>
<p>It is OK for <code>print()</code> case. But it can cause an error if you call any method of sys.stdout, e.g. <code>sys.stdout.write()</code>.</p>
<p>There is a <a href="https://docs.python.org/3/library/sys.html#sys.__stderr__" rel="nofollow noreferrer">note in docs</a>:</p>
<blockquote>
<p>Under some conditions stdin, stdout and stderr as well as the original
  values <strong>stdin</strong>, <strong>stdout</strong> and <strong>stderr</strong> can be None. It is usually
  the case for Windows GUI apps that arenâ€™t connected to a console and
  Python apps started with pythonw.</p>
</blockquote>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/4675728/4279">Redirect stdout to a file in Python?</a></span>
<span class="comment-copy">I've just discovered a peculiar thing. Turning sys.stdout into None actually works in my program, although I'm not sure why. I was having <i>really</i> weird problems with encoding redirecting to os.devnull so I tried just using None, and it works. Might have something to do with me doing it in a Django unit test, but I'm not sure.</span>
<span class="comment-copy">Use <code>os.devnull</code> instead of 'nul' or '/dev/null' and it will be pretty portable. Edit: For reference: <a href="http://docs.python.org/library/os.html#os.devnull" rel="nofollow noreferrer">docs.python.org/library/os.html#os.devnull</a></span>
<span class="comment-copy">@plundra - I was already adding that when I saw your comment, thanks!</span>
<span class="comment-copy">How do you then cancel it? Is there a way to turn print statements back on after you are done?</span>
<span class="comment-copy">Sure, just save a reference to the original <code>sys.stdout</code> and set it back after.  For example <code>old_stdout = sys.stdout</code> before any of the other code, then <code>sys.stdout = old_stdout</code> when you are done.</span>
<span class="comment-copy">note: it doesn't redirect at a file descriptor level i.e., it may fail to redirect the output of external child processes, the output from C extensions that print to C stdout directly, <code>os.write(1, b'abc\n')</code>. You need <code>os.dup2()</code>, to redirect at the file descriptor level, see <a href="http://stackoverflow.com/a/22434262/4279"><code>stdout_redirected()</code></a></span>
<span class="comment-copy">...doesn't this permanently clobber <code>sys.stdout</code>?</span>
<span class="comment-copy">@celticminstrel you are totally right, thanks for correcting me. I've updated the code to reset sys.stdout afterwards.</span>
<span class="comment-copy">This is missing some error checking, but great idea</span>
<span class="comment-copy">This is an elegant idea.</span>
<span class="comment-copy">Just for the record, next time you want to time something, just use <a href="https://docs.python.org/2/library/timeit.html" rel="nofollow noreferrer">timeit</a></span>
<span class="comment-copy">of course /dev/null is fast... it's "web scale"!</span>
<span class="comment-copy"><code>with contextlib.redirect_stdout(None)</code> works as well</span>
<span class="comment-copy">@ChrisCogdon Very good hint, I edited the answer accordingly.</span>
<span class="comment-copy">Its better to have a solution which would work on all platforms.</span>
<span class="comment-copy">@Guanidene, perhaps, but if he is the only person using his program, he can pretty much guarantee the environment.</span>
<span class="comment-copy">It is easy to support <a href="http://stackoverflow.com/a/22434262/4279"><code>redirect_stdout()</code>'s analog on earlier Python versions (e.g. using <code>contextlib.contextmanager</code>)</a>.</span>
<span class="comment-copy">Because A) it might not even work, and B) if it does, you'll get an error instead of just suppressing the output.</span>
<span class="comment-copy">Have <i>you</i> tried it?</span>
<span class="comment-copy">"OK" and "Won't throw an error the moment you try to print" are very different things in this case.</span>
<span class="comment-copy">You're right. You can't call any method with <code>sys.stdout = Null</code> so in some cases it can be dangerous.</span>
<span class="comment-copy">In this exact case it is known to be dangerous. OP specifically addresses the error he gets from doing it.</span>
