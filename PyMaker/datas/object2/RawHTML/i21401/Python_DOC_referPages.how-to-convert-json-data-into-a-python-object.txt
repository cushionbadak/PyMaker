<div class="post-text" itemprop="text">
<p>I want to use Python to convert JSON data into a Python object.</p>
<p>I receive JSON data objects from the Facebook API, which I want to store in my database.  </p>
<p>My current View in Django (Python) (<code>request.POST</code> contains the JSON):</p>
<pre><code>response = request.POST
user = FbApiUser(user_id = response['id'])
user.name = response['name']
user.username = response['username']
user.save()
</code></pre>
<ul>
<li><p>This works fine, but how do I handle complex JSON data objects?   </p></li>
<li><p>Wouldn't it be much better if I could somehow convert this JSON object into a Python object for easy use?</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>You can do it in one line, using <code>namedtuple</code> and <code>object_hook</code>:</p>
<pre><code>import json
from collections import namedtuple

data = '{"name": "John Smith", "hometown": {"name": "New York", "id": 123}}'

# Parse JSON into an object with attributes corresponding to dict keys.
x = json.loads(data, object_hook=lambda d: namedtuple('X', d.keys())(*d.values()))
print x.name, x.hometown.name, x.hometown.id
</code></pre>
<p>or, to reuse this easily:</p>
<pre><code>def _json_object_hook(d): return namedtuple('X', d.keys())(*d.values())
def json2obj(data): return json.loads(data, object_hook=_json_object_hook)

x = json2obj(data)
</code></pre>
<p>If you want it to handle keys that aren't good attribute names, check out <code>namedtuple</code>'s <a href="http://docs.python.org/2/library/collections.html#collections.namedtuple" rel="noreferrer"><code>rename</code> parameter</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Check out the section titled <strong>Specializing JSON object decoding</strong> in the <code>json</code> <a href="http://docs.python.org/library/json.html" rel="noreferrer">module documentation</a>. You can use that to decode a JSON object into a specific Python type.</p>
<p>Here's an example:</p>
<pre><code>class User(object):
    def __init__(self, name, username):
        self.name = name
        self.username = username

import json
def object_decoder(obj):
    if '__type__' in obj and obj['__type__'] == 'User':
        return User(obj['name'], obj['username'])
    return obj

json.loads('{"__type__": "User", "name": "John Smith", "username": "jsmith"}',
           object_hook=object_decoder)

print type(User)  # -&gt; &lt;type 'type'&gt;
</code></pre>
<p><strong>Update</strong></p>
<p>If you want to access data in a dictionary via the json module do this:</p>
<pre><code>user = json.loads('{"__type__": "User", "name": "John Smith", "username": "jsmith"}')
print user['name']
print user['username']
</code></pre>
<p>Just like a regular dictionary.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is not code golf, but here is my shortest trick, using <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace" rel="noreferrer"><code>types.SimpleNamespace</code></a> as the container for JSON objects.</p>
<p>Compared to the leading <code>namedtuple</code> solution, it is:</p>
<ul>
<li>probably faster/smaller as it does not create a class for each object</li>
<li>shorter</li>
<li>no <code>rename</code> option, and probably the same limitation on keys that are not valid identifiers (uses <code>setattr</code> under the covers)</li>
</ul>
<p>Example:</p>
<pre><code>from __future__ import print_function
import json

try:
    from types import SimpleNamespace as Namespace
except ImportError:
    # Python 2.x fallback
    from argparse import Namespace

data = '{"name": "John Smith", "hometown": {"name": "New York", "id": 123}}'

x = json.loads(data, object_hook=lambda d: Namespace(**d))

print (x.name, x.hometown.name, x.hometown.id)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try this:</p>
<pre><code>class User(object):
    def __init__(self, name, username, *args, **kwargs):
        self.name = name
        self.username = username

import json
j = json.loads(your_json)
u = User(**j)
</code></pre>
<p>Just create a new Object, and pass the parameters as a map.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a quick and dirty json pickle alternative</p>
<pre><code>import json

class User:
    def __init__(self, name, username):
        self.name = name
        self.username = username

    def to_json(self):
        return json.dumps(self.__dict__)

    @classmethod
    def from_json(cls, json_str):
        json_dict = json.loads(json_str)
        return cls(**json_dict)

# example usage
User("tbrown", "Tom Brown").to_json()
User.from_json(User("tbrown", "Tom Brown").to_json()).to_json()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For complex objects, you can use <a href="https://github.com/jsonpickle/jsonpickle" rel="noreferrer" title="JSON Pickle">JSON Pickle</a></p>
<blockquote>
<p>Python library for serializing any arbitrary object graph into JSON.
  It can take almost any Python object and turn the object into JSON.
  Additionally, it can reconstitute the object back into Python.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I have written a small (de)serialization framework called <a href="https://github.com/pistolero/any2any" rel="nofollow">any2any</a> that helps doing complex transformations between two Python types.</p>
<p>In your case, I guess you want to transform from a dictionary (obtained with <code>json.loads</code>) to an complex object <code>response.education ; response.name</code>, with a nested structure <code>response.education.id</code>, etc ...
So that's exactly what this framework is made for. The documentation is not great yet, but by using <code>any2any.simple.MappingToObject</code>, you should be able to do that very easily. Please ask if you need help.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're using Python 3.5+, you can use <a href="https://jsons.readthedocs.io/en/latest/" rel="nofollow noreferrer"><code>jsons</code></a> to serialize and deserialize to plain old Python objects:</p>
<pre><code>import jsons

response = request.POST

# You'll need your class attributes to match your dict keys, so in your case do:
response['id'] = response.pop('user_id')

# Then you can load that dict into your class:
user = jsons.load(response, FbApiUser)

user.save()
</code></pre>
<p>You could also make <code>FbApiUser</code> inherit from <code>jsons.JsonSerializable</code> for more elegance:</p>
<pre><code>user = FbApiUser.from_json(response)
</code></pre>
<p>These examples will work if your class consists of Python default types, like strings, integers, lists, datetimes, etc. The <code>jsons</code> lib will require type hints for custom types though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Modifying @DS response a bit, to load from a file:</p>
<pre><code>def _json_object_hook(d): return namedtuple('X', d.keys())(*d.values())
def load_data(file_name):
  with open(file_name, 'r') as file_data:
    return file_data.read().replace('\n', '')
def json2obj(file_name): return json.loads(load_data(file_name), object_hook=_json_object_hook)
</code></pre>
<p>One thing: this cannot load items with numbers ahead. Like this:</p>
<pre><code>{
  "1_first_item": {
    "A": "1",
    "B": "2"
  }
}
</code></pre>
<p>Because "1_first_item" is not a valid python field name.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python3.x</p>
<p>The best aproach I could reach with my knowledge was this.<br/>
Note that this code treat set() too.<br/>
This approach is generic just needing the extension of class (in the second example).<br/>
Note that I'm just doing it to files, but it's easy to modify the behavior to your taste.</p>
<p>However this is a CoDec.</p>
<p>With a little more work you can construct your class in other ways.
I assume a default constructor to instance it, then I update the class dict.</p>
<pre><code>import json
import collections


class JsonClassSerializable(json.JSONEncoder):

    REGISTERED_CLASS = {}

    def register(ctype):
        JsonClassSerializable.REGISTERED_CLASS[ctype.__name__] = ctype

    def default(self, obj):
        if isinstance(obj, collections.Set):
            return dict(_set_object=list(obj))
        if isinstance(obj, JsonClassSerializable):
            jclass = {}
            jclass["name"] = type(obj).__name__
            jclass["dict"] = obj.__dict__
            return dict(_class_object=jclass)
        else:
            return json.JSONEncoder.default(self, obj)

    def json_to_class(self, dct):
        if '_set_object' in dct:
            return set(dct['_set_object'])
        elif '_class_object' in dct:
            cclass = dct['_class_object']
            cclass_name = cclass["name"]
            if cclass_name not in self.REGISTERED_CLASS:
                raise RuntimeError(
                    "Class {} not registered in JSON Parser"
                    .format(cclass["name"])
                )
            instance = self.REGISTERED_CLASS[cclass_name]()
            instance.__dict__ = cclass["dict"]
            return instance
        return dct

    def encode_(self, file):
        with open(file, 'w') as outfile:
            json.dump(
                self.__dict__, outfile,
                cls=JsonClassSerializable,
                indent=4,
                sort_keys=True
            )

    def decode_(self, file):
        try:
            with open(file, 'r') as infile:
                self.__dict__ = json.load(
                    infile,
                    object_hook=self.json_to_class
                )
        except FileNotFoundError:
            print("Persistence load failed "
                  "'{}' do not exists".format(file)
                  )


class C(JsonClassSerializable):

    def __init__(self):
        self.mill = "s"


JsonClassSerializable.register(C)


class B(JsonClassSerializable):

    def __init__(self):
        self.a = 1230
        self.c = C()


JsonClassSerializable.register(B)


class A(JsonClassSerializable):

    def __init__(self):
        self.a = 1
        self.b = {1, 2}
        self.c = B()

JsonClassSerializable.register(A)

A().encode_("test")
b = A()
b.decode_("test")
print(b.a)
print(b.b)
print(b.c.a)
</code></pre>
<hr/>
<p><strong>Edit</strong></p>
<p>With some more of research I found a way to generalize without the need of the <strong>SUPERCLASS</strong> register method call, using a <strong>metaclass</strong></p>
<pre><code>import json
import collections

REGISTERED_CLASS = {}

class MetaSerializable(type):

    def __call__(cls, *args, **kwargs):
        if cls.__name__ not in REGISTERED_CLASS:
            REGISTERED_CLASS[cls.__name__] = cls
        return super(MetaSerializable, cls).__call__(*args, **kwargs)


class JsonClassSerializable(json.JSONEncoder, metaclass=MetaSerializable):

    def default(self, obj):
        if isinstance(obj, collections.Set):
            return dict(_set_object=list(obj))
        if isinstance(obj, JsonClassSerializable):
            jclass = {}
            jclass["name"] = type(obj).__name__
            jclass["dict"] = obj.__dict__
            return dict(_class_object=jclass)
        else:
            return json.JSONEncoder.default(self, obj)

    def json_to_class(self, dct):
        if '_set_object' in dct:
            return set(dct['_set_object'])
        elif '_class_object' in dct:
            cclass = dct['_class_object']
            cclass_name = cclass["name"]
            if cclass_name not in REGISTERED_CLASS:
                raise RuntimeError(
                    "Class {} not registered in JSON Parser"
                    .format(cclass["name"])
                )
            instance = REGISTERED_CLASS[cclass_name]()
            instance.__dict__ = cclass["dict"]
            return instance
        return dct

    def encode_(self, file):
        with open(file, 'w') as outfile:
            json.dump(
                self.__dict__, outfile,
                cls=JsonClassSerializable,
                indent=4,
                sort_keys=True
            )

    def decode_(self, file):
        try:
            with open(file, 'r') as infile:
                self.__dict__ = json.load(
                    infile,
                    object_hook=self.json_to_class
                )
        except FileNotFoundError:
            print("Persistence load failed "
                  "'{}' do not exists".format(file)
                  )


class C(JsonClassSerializable):

    def __init__(self):
        self.mill = "s"


class B(JsonClassSerializable):

    def __init__(self):
        self.a = 1230
        self.c = C()


class A(JsonClassSerializable):

    def __init__(self):
        self.a = 1
        self.b = {1, 2}
        self.c = B()


A().encode_("test")
b = A()
b.decode_("test")
print(b.a)
# 1
print(b.b)
# {1, 2}
print(b.c.a)
# 1230
print(b.c.c.mill)
# s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While searching for a solution, I've stumbled upon this blog post:  <a href="https://blog.mosthege.net/2016/11/12/json-deserialization-of-nested-objects/" rel="nofollow noreferrer">https://blog.mosthege.net/2016/11/12/json-deserialization-of-nested-objects/</a></p>
<p>It uses the same technique as stated in previous answers but with a usage of decorators. 
Another thing I found useful is the fact that it returns a typed object at the end of deserialisation </p>
<pre><code>class JsonConvert(object):
    class_mappings = {}

    @classmethod
    def class_mapper(cls, d):
        for keys, cls in clsself.mappings.items():
            if keys.issuperset(d.keys()):   # are all required arguments present?
                return cls(**d)
        else:
            # Raise exception instead of silently returning None
            raise ValueError('Unable to find a matching class for object: {!s}'.format(d))

    @classmethod
    def complex_handler(cls, Obj):
        if hasattr(Obj, '__dict__'):
            return Obj.__dict__
        else:
            raise TypeError('Object of type %s with value of %s is not JSON serializable' % (type(Obj), repr(Obj)))

    @classmethod
    def register(cls, claz):
        clsself.mappings[frozenset(tuple([attr for attr,val in cls().__dict__.items()]))] = cls
        return cls

    @classmethod
    def to_json(cls, obj):
        return json.dumps(obj.__dict__, default=cls.complex_handler, indent=4)

    @classmethod
    def from_json(cls, json_str):
        return json.loads(json_str, object_hook=cls.class_mapper)
</code></pre>
<p>Usage:</p>
<pre><code>@JsonConvert.register
class Employee(object):
    def __init__(self, Name:int=None, Age:int=None):
        self.Name = Name
        self.Age = Age
        return

@JsonConvert.register
class Company(object):
    def __init__(self, Name:str="", Employees:[Employee]=None):
        self.Name = Name
        self.Employees = [] if Employees is None else Employees
        return

company = Company("Contonso")
company.Employees.append(Employee("Werner", 38))
company.Employees.append(Employee("Mary"))

as_json = JsonConvert.to_json(company)
from_json = JsonConvert.from_json(as_json)
as_json_from_json = JsonConvert.to_json(from_json)

assert(as_json_from_json == as_json)

print(as_json_from_json)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Expanding on DS's answer a bit, if you need the object to be mutable (which namedtuple is not), you can use the <a href="https://pypi.org/project/recordclass/" rel="nofollow noreferrer">recordclass</a> library instead of namedtuple:</p>
<pre><code>import json
from recordclass import recordclass

data = '{"name": "John Smith", "hometown": {"name": "New York", "id": 123}}'

# Parse into a mutable object
x = json.loads(data, object_hook=lambda d: recordclass('X', d.keys())(*d.values()))
</code></pre>
<p>The modified object can then be converted back to json very easily using <a href="https://pypi.org/project/simplejson/" rel="nofollow noreferrer">simplejson</a>:</p>
<pre><code>x.name = "John Doe"
new_json = simplejson.dumps(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since noone provided an answer quite like mine, I am going to post it here.</p>
<p>It is a robust class that can easily convert back and forth between json <code>str</code> and <code>dict</code> that I have copied from <a href="https://stackoverflow.com/a/49085020/4936137">my answer to another question</a>:</p>
<pre><code>import json

class PyJSON(object):
    def __init__(self, d):
        if type(d) is str:
            d = json.loads(d)

        self.from_dict(d)

    def from_dict(self, d):
        self.__dict__ = {}
        for key, value in d.items():
            if type(value) is dict:
                value = PyJSON(value)
            self.__dict__[key] = value

    def to_dict(self):
        d = {}
        for key, value in self.__dict__.items():
            if type(value) is PyJSON:
                value = value.to_dict()
            d[key] = value
        return d

    def __repr__(self):
        return str(self.to_dict())

    def __setitem__(self, key, value):
        self.__dict__[key] = value

    def __getitem__(self, key):
        return self.__dict__[key]

json_str = """... json string ..."""

py_json = PyJSON(json_str)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are using python 3.6+, you can use <a href="https://pypi.org/project/marshmallow-dataclass/" rel="nofollow noreferrer">marshmallow-dataclass</a>. Contrarily to all the solutions listed above, it is both simple, and type safe:</p>
<pre class="lang-py prettyprint-override"><code>from marshmallow_dataclass import dataclass

@dataclass
class User:
    name: str

user, err = User.Schema().load({"name": "Ramirez"})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/library/json.html" rel="nofollow"><code>json</code> module</a> (<a href="http://docs.python.org/whatsnew/2.6.html#the-json-module-javascript-object-notation" rel="nofollow">new in Python 2.6</a>) or the <code>simplejson</code> module which is almost always installed.</p>
</div>
<span class="comment-copy">Typically JSON gets converted to vanilla lists or dicts. Is that what you want? Or are you hoping to convert JSON straight to a custom type?</span>
<span class="comment-copy">I want to convert it into an object, something I can access using the "." . Like from the above example -&gt; reponse.name, response.education.id etc....</span>
<span class="comment-copy">Using <code>dict</code>s is a weak-sauce way to do object-oriented programming. Dictionaries are a very poor way to communicate expectations to readers of your code. Using a dictionary, how can you clearly and reusably specify that some dictionary keys-value pairs are required, while others aren't? What about confirming that a given value is in the acceptable range or set? What about functions that are specific to the type of object you are working with (aka methods)? Dictionaries are handy and versatile, but too many devs act like they forgot Python is an object oriented language for a reason.</span>
<span class="comment-copy">this may result in a Value error, ValueError: Type names and field names cannot start with a number: '123'</span>
<span class="comment-copy">As a newbie to Python, I'm interested if this is a save thing also when security is an issue.</span>
<span class="comment-copy">This creates a new <i>different</i> class each time encountering a JSON object while parsing, right?</span>
<span class="comment-copy">Interesting. I thought relying on <code>d.keys()</code> and <code>d.values()</code> iterating in the same order is not guaranteed, but I was wrong. The <a href="https://docs.python.org/3.5/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">docs</a> say: "If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond.". Good to know for such small, local code blocks. I'd add a comment though to explicitly alert maintainers of code of such a dependency.</span>
<span class="comment-copy">I am not aware of any nice general-purpose reverse operation. Any individual namedtuple can be turned to a dict using <code>x._asdict()</code>, which might help for simple cases.</span>
<span class="comment-copy">Hey, I was just reading up and I realized that dictionaries will totally do, only I was wondering how to convert JSON objects into dictionaries and how do I access this data from the dictionary?</span>
<span class="comment-copy">Awesome, it's almost clear, just wanted to know one more little thing that if there's this object -&gt; { 'education' : { 'name1' : 456 , 'name2' : 567 } }, how do i access this data?</span>
<span class="comment-copy">it'd just be topLevelData['education']['name1'] ==&gt; 456. make sense?</span>
<span class="comment-copy">Got it sir........Thanks a zillion</span>
<span class="comment-copy">@Ben: I think your comment is inappropriate. Of all the answers here currently it is the only one to get the classes right. Which means: It's a one-pass operation and the result uses the correct types. Pickle itself is for different applications than JSON (binary versus textual rep) and jsonpickle is a nonstandard lib. I'd be interested to see how you solve the issue that the std json lib does not provide the upper parse tree to the object hook</span>
<span class="comment-copy">By the way, the serialization library Marshmallow offers a similar feature with its <code>@post_load</code> decorator. <a href="https://marshmallow.readthedocs.io/en/latest/quickstart.html#deserializing-to-objects" rel="nofollow noreferrer">marshmallow.readthedocs.io/en/latest/…</a></span>
<span class="comment-copy">To avoid the dependency on argparse: replace the argparse import with <code>from types import SimpleNamespace</code> and use: <code>x = json.loads(data, object_hook=lambda d: SimpleNamespace(**d))</code></span>
<span class="comment-copy">This is the most elegant solution, should be at the top.</span>
<span class="comment-copy">Edited to use @maxschlepzig's solution when running under Python 3.x (<code>types.SimpleNamespace</code> doesn't exist in 2.7, unfortunately).</span>
<span class="comment-copy">This is a great answer. Thanks you. 🎉</span>
<span class="comment-copy">I get TypeError: 'User' object is not subscriptable</span>
<span class="comment-copy">This should be the accepted answer. worked for me ad much simplest than all the rest.</span>
<span class="comment-copy">Thanks for providing such a simple solution to json serialization and de-serialization.</span>
<span class="comment-copy">This should be selected as the answer.</span>
<span class="comment-copy">I think <a href="https://github.com/initialxy/jsonstruct" rel="nofollow noreferrer">jsonstruct</a> is better.     <code>jsonstruct originally a fork of jsonpickle (Thanks guys!).  The key difference between this library and jsonpickle is that during deserialization, jsonpickle requires Python types to be recorded as part of the JSON. This library intends to remove this requirement, instead, requires a class to be passed in as an argument so that its definition can be inspected. It will then return an instance of the given class. This approach is similar to how Jackson (of Java) works.</code></span>
<span class="comment-copy">The problems with jsonstruct is that it doesn't appear to be maintained (in fact, it looks abandoned) and it fails to convert a list of objects, like <code>'[{"name":"object1"},{"name":"object2"}]'</code>.  jsonpickle doesn't handle it very well, either.</span>
<span class="comment-copy">I have no idea why this answer isn't getting more votes. Most other solution are quite out-there. Someone developed a great library for JSON de/serialization - why not use it? In addition, seems to be working fine with lists - what was your issue with it @LS ?</span>
<span class="comment-copy">@guyarad, the problem is: x= jsonpickle.decode('[{"name":"object1"},{"name":"object2"}]') gives a list of dictionaries ([{'name': 'object1'}, {'name': 'object2'}]), not a list of objects with properties (x[0].name == 'object1'), which is what the original question required. To get that, I ended up using the object_hook/Namespace approach suggested by eddygeek, but the quick/dirty approach by ubershmekel looks good, too. I think I could use object_hook with jsonpickle's set_encoder_options() (undocumented!), but it would take more code than the basic json module. I'd love to be proven wrong!</span>
<span class="comment-copy">@LS if you have no control over the input, which is truly what the OP asked, jsonpickle isn't ideal since it expect the actual type in each level (and will assume basic types if missing). Both solutions are "cute".</span>
<span class="comment-copy">Sebpiq, have installed any2any and am having troubles understanding the intended sequence of method calls. Could you give a simple example of converting a dictionary to a Python object with a property for each key?</span>
<span class="comment-copy">Hi @sansjoe ! If you have installed it from pypi, the version is completely out of date, I have made a complete refactoring a few weeks ago. You should use the github version (I need to make a proper release !)</span>
<span class="comment-copy">I installed it from pypy because the github said to install it from pypy. Also, you said pypy was out of date months ago.. It didn't work :( I filed a bug report tho! <a href="https://github.com/sebpiq/any2any/issues/11" rel="nofollow noreferrer">github.com/sebpiq/any2any/issues/11</a></span>
<span class="comment-copy">It works!!! Hooray! I'm gonna try this. This can possibly save soo much time!</span>
<span class="comment-copy">Hey, thank you for replying. Can you please post an example of how to decode the JSON and then access that data ?</span>
<span class="comment-copy">Hey, now you got a point but somehow, I prefer doing without knowing and then reverse-engineering it : D.</span>
<span class="comment-copy">@Zach: there are examples right at the top of the docs I linked to.</span>
