<div class="post-text" itemprop="text">
<p>I would like to write a custom list class in Python (let's call it <code>MyCollection</code>) where I can eventually call:</p>
<pre><code>for x in myCollectionInstance:
    #do something here
</code></pre>
<p>How would I go about doing that? Is there some class I have to extend, or are there any functions I must override in order to do so?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/reference/datamodel.html#emulating-container-types" rel="noreferrer">Python Language Reference, §3.4.6, "Emulating container types"</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Your can subclass <code>list</code> if your collection basically behaves like a list:</p>
<pre><code>class MyCollection(list):
    def __init__(self, *args, **kwargs):
        super(MyCollection, self).__init__(args[0])
</code></pre>
<p>However, if your main wish is that your collection supports the iterator protocol, you just have to provide an <code>__iter__</code> method:</p>
<pre><code>class MyCollection(object):
    def __init__(self):
        self._data = [4, 8, 15, 16, 23, 42]

    def __iter__(self):
        for elem in self._data:
            yield elem
</code></pre>
<p>This allows you to iterate over any instance of <code>MyCollection</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I like to subclass <a href="http://docs.python.org/2/library/collections.html#collections.MutableSequence" rel="nofollow noreferrer"><code>MutableSequence</code></a>, as <a href="https://stackoverflow.com/a/3488283/667301">recommended by Alex Martelli</a>.  This works well for me, particularly when I need to add custom methods on top of the list I'm building.</p>
<pre><code>from collections import MutableSequence

class MyList(MutableSequence):
    """A container for manipulating lists of hosts"""
    def __init__(self, data=None):
        """Initialize the class"""
        super(MyList, self).__init__()
        if (data is not None):
            self._list = list(data)
        else:
            self._list = list()

    def __repr__(self):
        return "&lt;{0} {1}&gt;".format(self.__class__.__name__, self._list)

    def __len__(self):
        """List length"""
        return len(self._list)

    def __getitem__(self, ii):
        """Get a list item"""
        return self._list[ii]

    def __delitem__(self, ii):
        """Delete an item"""
        del self._list[ii]

    def __setitem__(self, ii, val):
        # optional: self._acl_check(val)
        self._list[ii] = val

    def __str__(self):
        return str(self._list)

    def insert(self, ii, val):
        # optional: self._acl_check(val)
        self._list.insert(ii, val)

    def append(self, val):
        self.insert(len(self._list), val)

if __name__=='__main__':
    foo = MyList([1,2,3,4,5])
    foo.append(6)
    print foo  # &lt;MyList [1, 2, 3, 4, 5, 6]&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could extend the <code>list</code> class:</p>
<pre><code>class MyList(list):

    def __init__(self, *args):
        super(MyList, self).__init__(args[0])
        # Do something with the other args (and potentially kwars)
</code></pre>
<p>Example usage:</p>
<pre><code>a = MyList((1,2,3), 35, 22)
print(a)
for x in a:
    print(x)
</code></pre>
<p>Expected output:</p>
<pre><code>[1, 2, 3]
1
2
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 we have beautiful <code>collections.UserList([list])</code>:</p>
<blockquote>
<p>Class that simulates a list. The instance’s contents are kept in a
  regular list, which is accessible via the data attribute of UserList
  instances. The instance’s contents are initially set to a copy of
  list, defaulting to the empty list <code>[]</code>. list can be any iterable, for
  example a real Python list or a UserList object.</p>
<p>In addition to supporting the methods and operations of mutable
  sequences, UserList instances provide the following attribute: <code>data</code>
  A real list object used to store the contents of the UserList class.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/collections.html#userlist-objects" rel="nofollow noreferrer">https://docs.python.org/3/library/collections.html#userlist-objects</a></p>
</div>
<span class="comment-copy">Could you clarify better your requirements? If you subclass any iterable class (list, dict, etc...) it should work without problems. But maybe I am missing something?</span>
<span class="comment-copy">@mac: If I subclassed an iterable class, I'd also want a way to be able to access the underlying list object so that I can provide additional functions that act on it. I don't want a key-value pair (dict), so something that emulates an indexed collection (list) would suffice.</span>
<span class="comment-copy">@Kshitij: specifically, you need to define <code>__iter__</code>.</span>
<span class="comment-copy">Not necessarily. <code>for</code> will also iterate from index 0 to until <code>__getitem__()</code> raises an exception; see the linked documentation for details.</span>
<span class="comment-copy">could you update this from link-only?</span>
<span class="comment-copy">I think the signature of your super method is wrong (only 99% sure, but doesn't <code>list()</code> accept only one iterable as argument? Also, is there a special reason for the final colon on the <code>super</code> call?</span>
<span class="comment-copy">Yes, you are of course right, I edited to code. Thanks for the hint.</span>
<span class="comment-copy"><code>if not (data is None):</code> that's not how you write your python code, until a Grand Jedi Master you are. <code>if data is not None</code> -- this looks good.</span>
