<div class="post-text" itemprop="text">
<p>During the runtime of a process I would like to read its stdout and write it to a file. Any attempt of mine however failed because no matter what I tried as soon as I tried reading from the stdout it blocked until the process finished.</p>
<p>Here is a snippet of what I am trying to do. (The first part is simply a python script that writes something to stdout.)</p>
<pre><code>import subprocess

p = subprocess.Popen('python -c \'\
from time import sleep\n\
for i in range(3):\n\
    sleep(1)\n\
    print "Hello", i\
\'', shell = True, stdout = subprocess.PIPE)

while p.poll() == None:
    #read the stdout continuously
    pass

print "Done"
</code></pre>
<p>I know that there are multiple questions out there that deal with the same subject. However, none of the ones I found was able to answer my question.</p>
</div>
<div class="post-text" itemprop="text">
<p>What is happening is buffering on the writer side. Since you are writing such small chunks from the little code snippet the underlying FILE object is buffering the output until the end. The following works as you expect.</p>
<pre><code>#!/usr/bin/python

import sys
import subprocess

p = subprocess.Popen("""python -c '
from time import sleep ; import sys
for i in range(3):
    sleep(1)
    print "Hello", i
    sys.stdout.flush()
'""", shell = True, stdout = subprocess.PIPE)

while True:
    inline = p.stdout.readline()
    if not inline:
        break
    sys.stdout.write(inline)
    sys.stdout.flush()

print "Done"
</code></pre>
<p>However, you may not be expecting the right thing. The buffering is there to reduce the number of system calls in order to make the system more efficient. Does it really matter to you that the whole text is buffered until the end before you write it to a file? Don't you still get all the output in the file?</p>
</div>
<div class="post-text" itemprop="text">
<p>the following code would print stdout line by line as the subprocess runs until the readline() method returns an empty string:</p>
<pre><code>p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
for line in iter(p.stdout.readline, ''):
    print line
p.stdout.close()
print 'Done'
</code></pre>
<p>update relating to your question better:</p>
<pre><code>import subprocess

p = subprocess.Popen(['python'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
p.stdin.write("""
from time import sleep ; import sys
for i in range(3):
    sleep(1)
    print "Hello", i
    sys.stdout.flush()
""")
p.stdin.close()
for line in iter(p.stdout.readline, ''):
    print line
p.stdout.close()
print 'Done'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>subprocess.communicate()</code> to get the output from stdout. Something like:</p>
<pre><code>while(p.poll() == None):
    #read the stdout continuously
    print(p.communicate()[0])
    pass
</code></pre>
<p>More info available at: <a href="http://docs.python.org/library/subprocess.html" rel="nofollow">http://docs.python.org/library/subprocess.html</a></p>
</div>
<span class="comment-copy">Your code doesn't show how you are rrading the stream.</span>
<span class="comment-copy">@Keith Well, this is kind of my question. How do you read the stream without blocking it. I hope to find that part of the code in an answer somewhere below. ^^</span>
<span class="comment-copy">Hey Keith, thx for the answer. It works, and also thx for showing me the <code>"""</code>-"trick" ^^.</span>
<span class="comment-copy">Hi keith, what if I wanted to send some commands to my process like <code>p.stdin.write(command1)</code>, then read the chunk of output from that (as in the output resulting only from this input!) and then, <code>p.stdin.write(command1)</code> and read that chunk and so on?</span>
<span class="comment-copy">@Jack Yes, you can do that. You should use shell=False in that case, and stdin=PIPE. You can also use the <code>communicate</code> method to make that easier. See the <a href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="nofollow noreferrer">docs</a>.</span>
<span class="comment-copy">Removing the parameter <code>shell = True</code> from the <code>Popen</code> constructor results in a <code>OSError: [Errno 2] No such file or directory</code> exception on my machine. And if I leave the <code>shell = True</code> parameter in there, your reading routine still blocks the reading process.</span>
<span class="comment-copy">are you passing 'cmd' as a list of commands?</span>
<span class="comment-copy">I pass it exactly like posted in my question. I simply removed the <code>shell = True</code> statement.</span>
<span class="comment-copy">see updated answer</span>
<span class="comment-copy">Thx for the update. It now runs perfectly :)</span>
<span class="comment-copy">Unfortunately the <code>communicate</code> method also blocks and only returns the stdout after the process <code>p</code> has finished. No continuous readout is possible.</span>
<span class="comment-copy">Ah, I see. Thanks for the correction!</span>
