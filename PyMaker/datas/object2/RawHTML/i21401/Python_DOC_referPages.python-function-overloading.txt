<div class="post-text" itemprop="text">
<p>I know that Python does not support method overloading, but I've run into a problem that I can't seem to solve in a nice Pythonic way.</p>
<p>I am making a game where a character needs to shoot a variety of bullets, but how do I write different functions for creating these bullets? For example suppose I have a function that creates a bullet travelling from point A to B with a given speed. I would write a function like this:</p>
<pre><code>    def add_bullet(sprite, start, headto, speed):
        ... Code ...
</code></pre>
<p>But I want to write other functions for creating bullets like:</p>
<pre><code>    def add_bullet(sprite, start, direction, speed):
    def add_bullet(sprite, start, headto, spead, acceleration):
    def add_bullet(sprite, script): # For bullets that are controlled by a script
    def add_bullet(sprite, curve, speed): # for bullets with curved paths
    ... And so on ...
</code></pre>
<p>And so on with many variations. Is there a better way to do it without using so many keyword arguments cause its getting kinda ugly fast. Renaming each function is pretty bad too because you get either <code>add_bullet1</code>, <code>add_bullet2</code>, or <code>add_bullet_with_really_long_name</code>.</p>
<p>To address some answers:</p>
<ol>
<li><p>No I can't create a Bullet class hierarchy because thats too slow. The actual code for managing bullets is in C and my functions are wrappers around C API.</p></li>
<li><p>I know about the keyword arguments but checking for all sorts of combinations of parameters is getting annoying, but default arguments help allot like <code>acceleration=0</code></p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Python does support "method overloading" as you present it. In fact, what you just describe is trivial to implement in Python, in so many different ways, but I would go with:</p>
<pre><code>class Character(object):
    # your character __init__ and other methods go here

    def add_bullet(self, sprite=default, start=default, 
                 direction=default, speed=default, accel=default, 
                  curve=default):
        # do stuff with your arguments
</code></pre>
<p>In the above code, <code>default</code> is a plausible default value for those arguments, or <code>None</code>. You can then call the method with only the arguments you are interested in, and Python will use the default values. </p>
<p>You could also do something like this:</p>
<pre><code>class Character(object):
    # your character __init__ and other methods go here

    def add_bullet(self, **kwargs):
        # here you can unpack kwargs as (key, values) and
        # do stuff with them, and use some global dictionary
        # to provide default values and ensure that ``key``
        # is a valid argument...

        # do stuff with your arguments
</code></pre>
<p>Another alternative is to directly hook the desired function directly to the class or instance:</p>
<pre><code>def some_implementation(self, arg1, arg2, arg3):
  # implementation
my_class.add_bullet = some_implementation_of_add_bullet
</code></pre>
<p>Yet another way is to use an abstract factory pattern:</p>
<pre><code>class Character(object):
   def __init__(self, bfactory, *args, **kwargs):
       self.bfactory = bfactory
   def add_bullet(self):
       sprite = self.bfactory.sprite()
       speed = self.bfactory.speed()
       # do stuff with your sprite and speed

class pretty_and_fast_factory(object):
    def sprite(self):
       return pretty_sprite
    def speed(self):
       return 10000000000.0

my_character = Character(pretty_and_fast_factory(), a1, a2, kw1=v1, kw2=v2)
my_character.add_bullet() # uses pretty_and_fast_factory

# now, if you have another factory called "ugly_and_slow_factory" 
# you can change it at runtime in python by issuing
my_character.bfactory = ugly_and_slow_factory()

# In the last example you can see abstract factory and "method
# overloading" (as you call it) in action 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you are asking for, is called <em>multiple dispatch</em>. See <a href="http://nbviewer.ipython.org/gist/StefanKarpinski/b8fe9dbb36c1427b9f22">Julia</a> language examples which demonstrates different types of dispatches.</p>
<p>However, before looking at that, we'll first tackle why <em>overloading</em> is not really what you want in python.</p>
<h1>Why Not Overloading?</h1>
<p>First one needs to understand the concept of overloading and why it's not applicable to python.</p>
<blockquote>
<p>When working with languages that can discriminate data types at
  compile-time, selecting among the alternatives can occur at
  compile-time. The act of creating such alternative functions for
  compile-time selection is usually referred to as overloading a
  function. (<a href="http://en.wikipedia.org/wiki/Multiple_dispatch">Wikipedia</a>)</p>
</blockquote>
<p>Python is a <a href="https://pythonconquerstheuniverse.wordpress.com/2009/10/03/static-vs-dynamic-typing-of-programming-languages/">dynamically</a> typed language, so the concept of overloading simply does not apply to it. However, all is not lost, since we can create such <em>alternative functions</em> at run-time:</p>
<blockquote>
<p>In programming languages that defer data type identification until
  run-time the selection among alternative
  functions must occur at run-time, based on the dynamically determined
  types of function arguments. Functions whose alternative
  implementations are selected in this manner are referred to most
  generally as <em>multimethods</em>. (<a href="http://en.wikipedia.org/wiki/Multiple_dispatch">Wikipedia</a>)</p>
</blockquote>
<p>So we should be able to do <em>multimethods</em> in python or, as it is alternatively called, <em>multiple dispatch</em>.</p>
<h1>Multiple dispatch</h1>
<p>The multimethods are also called <em>multiple dispatch</em>:</p>
<blockquote>
<p>Multiple dispatch or multimethods is the feature of some
  object-oriented programming languages in which a function or method
  can be dynamically dispatched based on the run time (dynamic) type of
  more than one of its arguments. (<a href="http://en.wikipedia.org/wiki/Multiple_dispatch">Wikipedia</a>)</p>
</blockquote>
<p>Python does not support this out of the box<sup>1</sup>. But, as it happens, there is an excellent python package called <a href="https://pypi.python.org/pypi/multipledispatch/">multipledispatch</a> that does exactly that. </p>
<h1>Solution</h1>
<p>Here is how we might use <a href="https://pypi.python.org/pypi/multipledispatch/">multipledispatch</a><sup>2</sup> package to implement your methods:</p>
<pre><code>&gt;&gt;&gt; from multipledispatch import dispatch
&gt;&gt;&gt; from collections import namedtuple  
&gt;&gt;&gt; from types import *  # we can test for lambda type, e.g.:
&gt;&gt;&gt; type(lambda a: 1) == LambdaType
True

&gt;&gt;&gt; Sprite = namedtuple('Sprite', ['name'])
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; Curve = namedtuple('Curve', ['x', 'y', 'z'])
&gt;&gt;&gt; Vector = namedtuple('Vector', ['x','y','z'])

&gt;&gt;&gt; @dispatch(Sprite, Point, Vector, int)
... def add_bullet(sprite, start, direction, speed):
...     print("Called Version 1")
...
&gt;&gt;&gt; @dispatch(Sprite, Point, Point, int, float)
... def add_bullet(sprite, start, headto, speed, acceleration):
...     print("Called version 2")
...
&gt;&gt;&gt; @dispatch(Sprite, LambdaType)
... def add_bullet(sprite, script):
...     print("Called version 3")
...
&gt;&gt;&gt; @dispatch(Sprite, Curve, int)
... def add_bullet(sprite, curve, speed):
...     print("Called version 4")
...

&gt;&gt;&gt; sprite = Sprite('Turtle')
&gt;&gt;&gt; start = Point(1,2)
&gt;&gt;&gt; direction = Vector(1,1,1)
&gt;&gt;&gt; speed = 100 #km/h
&gt;&gt;&gt; acceleration = 5.0 #m/s
&gt;&gt;&gt; script = lambda sprite: sprite.x * 2
&gt;&gt;&gt; curve = Curve(3, 1, 4)
&gt;&gt;&gt; headto = Point(100, 100) # somewhere far away

&gt;&gt;&gt; add_bullet(sprite, start, direction, speed)
Called Version 1

&gt;&gt;&gt; add_bullet(sprite, start, headto, speed, acceleration)
Called version 2

&gt;&gt;&gt; add_bullet(sprite, script)
Called version 3

&gt;&gt;&gt; add_bullet(sprite, curve, speed)
Called version 4
</code></pre>
<p><sub>
1. Python 3 currently supports <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch">single dispatch</a>
</sub></p>
<p><sub>
2. Take care not to use  <a href="https://pypi.python.org/pypi/multipledispatch/">multipledispatch</a> in a multi-threaded environment, or you will get weird behavior.
</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use "roll-your-own" solution for function overloading. This one is copied from <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605">Guido van Rossum's article</a> about multimethods (because there is little difference between mm and overloading in python):</p>
<pre><code>registry = {}

class MultiMethod(object):
    def __init__(self, name):
        self.name = name
        self.typemap = {}
    def __call__(self, *args):
        types = tuple(arg.__class__ for arg in args) # a generator expression!
        function = self.typemap.get(types)
        if function is None:
            raise TypeError("no match")
        return function(*args)
    def register(self, types, function):
        if types in self.typemap:
            raise TypeError("duplicate registration")
        self.typemap[types] = function


def multimethod(*types):
    def register(function):
        name = function.__name__
        mm = registry.get(name)
        if mm is None:
            mm = registry[name] = MultiMethod(name)
        mm.register(types, function)
        return mm
    return register
</code></pre>
<p>The usage would be</p>
<pre><code>from multimethods import multimethod
import unittest

# 'overload' makes more sense in this case
overload = multimethod

class Sprite(object):
    pass

class Point(object):
    pass

class Curve(object):
    pass

@overload(Sprite, Point, Direction, int)
def add_bullet(sprite, start, direction, speed):
    # ...

@overload(Sprite, Point, Point, int, int)
def add_bullet(sprite, start, headto, speed, acceleration):
    # ...

@overload(Sprite, str)
def add_bullet(sprite, script):
    # ...

@overload(Sprite, Curve, speed)
def add_bullet(sprite, curve, speed):
    # ...
</code></pre>
<p>Most restrictive limitations <em>at the moment</em> are:</p>
<ul>
<li>methods are not supported, only functions that are not class members;</li>
<li>inheritance is not handled;</li>
<li>kwargs are not supported;</li>
<li>registering new functions should be done at import time thing is not thread-safe</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>A possible option is to use the multipledispatch module as detailed here:
<a href="http://matthewrocklin.com/blog/work/2014/02/25/Multiple-Dispatch" rel="noreferrer">http://matthewrocklin.com/blog/work/2014/02/25/Multiple-Dispatch</a></p>
<p>Instead of doing this:</p>
<pre><code>def add(self, other):
    if isinstance(other, Foo):
        ...
    elif isinstance(other, Bar):
        ...
    else:
        raise NotImplementedError()
</code></pre>
<p>You can do this:</p>
<pre><code>from multipledispatch import dispatch
@dispatch(int, int)
def add(x, y):
    return x + y    

@dispatch(object, object)
def add(x, y):
    return "%s + %s" % (x, y)
</code></pre>
<p>With the resulting usage:</p>
<pre><code>&gt;&gt;&gt; add(1, 2)
3

&gt;&gt;&gt; add(1, 'hello')
'1 + hello'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.4 was added <a href="https://www.python.org/dev/peps/pep-0443/" rel="noreferrer">PEP-0443. Single-dispatch generic functions</a>.</p>
<p>Here is short API description from PEP.</p>
<p>To define a generic function, decorate it with the @singledispatch decorator. Note that the dispatch happens on the type of the first argument. Create your function accordingly:</p>
<pre><code>from functools import singledispatch
@singledispatch
def fun(arg, verbose=False):
    if verbose:
        print("Let me just say,", end=" ")
    print(arg)
</code></pre>
<p>To add overloaded implementations to the function, use the register() attribute of the generic function. This is a decorator, taking a type parameter and decorating a function implementing the operation for that type:</p>
<pre><code>@fun.register(int)
def _(arg, verbose=False):
    if verbose:
        print("Strength in numbers, eh?", end=" ")
    print(arg)

@fun.register(list)
def _(arg, verbose=False):
    if verbose:
        print("Enumerate this:")
    for i, elem in enumerate(arg):
        print(i, elem)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This type of behaviour is typically solved (in OOP languages) using Polymorphism. Each type of bullet would be responsible for knowing how it travels. For instance:</p>
<pre><code>class Bullet(object):
    def __init__(self):
        self.curve = None
        self.speed = None
        self.acceleration = None
        self.sprite_image = None

class RegularBullet(Bullet):
    def __init__(self):
        super(RegularBullet, self).__init__()
        self.speed = 10

class Grenade(Bullet):
    def __init__(self):
        super(Grenade, self).__init__()
        self.speed = 4
        self.curve = 3.5

add_bullet(Grendade())

def add_bullet(bullet):
    c_function(bullet.speed, bullet.curve, bullet.acceleration, bullet.sprite, bullet.x, bullet.y) 


void c_function(double speed, double curve, double accel, char[] sprite, ...) {
    if (speed != null &amp;&amp; ...) regular_bullet(...)
    else if (...) curved_bullet(...)
    //..etc..
}
</code></pre>
<p>Pass as many arguments to the c_function that exist, then do the job of determining which c function to call based on the values in the initial c function. So, python should only ever be calling the one c function. That one c function looks at the arguments, and then can delegate to other c functions appropriately.</p>
<p>You're essentially just using each subclass as a different data container, but by defining all the potential arguments on the base class, the subclasses are free to ignore the ones they do nothing with.</p>
<p>When a new type of bullet comes along, you can simply define one more property on the base, change the one python function so that it passes the extra property, and the one c_function that examines the arguments and delegates appropriately. Doesn't sound too bad I guess.</p>
</div>
<div class="post-text" itemprop="text">
<p>By <a href="http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/" rel="noreferrer">passing keyword args</a>.</p>
<pre><code>def add_bullet(**kwargs):
    #check for the arguments listed above and do the proper things
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think your basic requirement is to have a C/C++ like syntax in python with the least headache possible.  Although I liked Alexander Poluektov's answer it doesn't work for classes.  </p>
<p>The following should work for classes.  It works by distinguishing by the number of non keyword arguments (but doesn't support distinguishing by type):</p>
<pre><code>class TestOverloading(object):
    def overloaded_function(self, *args, **kwargs):
        # Call the function that has the same number of non-keyword arguments.  
        getattr(self, "_overloaded_function_impl_" + str(len(args)))(*args, **kwargs)

    def _overloaded_function_impl_3(self, sprite, start, direction, **kwargs):
        print "This is overload 3"
        print "Sprite: %s" % str(sprite)
        print "Start: %s" % str(start)
        print "Direction: %s" % str(direction)

    def _overloaded_function_impl_2(self, sprite, script):
        print "This is overload 2"
        print "Sprite: %s" % str(sprite)
        print "Script: "
        print script
</code></pre>
<p>And it can be used simply like this:</p>
<pre><code>test = TestOverloading()

test.overloaded_function("I'm a Sprite", 0, "Right")
print
test.overloaded_function("I'm another Sprite", "while x == True: print 'hi'")
</code></pre>
<p>Output:</p>
<blockquote>
<p>This is overload 3<br/>
    Sprite: I'm a Sprite<br/>
    Start: 0<br/>
    Direction: Right  </p>
<p>This is overload 2<br/>
    Sprite: I'm another Sprite<br/>
    Script:<br/>
    while x == True: print 'hi'  </p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Either use multiple keyword arguments in the definition, or create a <code>Bullet</code> hierarchy whose instances are passed to the function.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think a <code>Bullet</code> class hierarchy with the associated polymorphism is the way to go. You can effectively overload the base class constructor by using a metaclass so that calling the base class results in the creation of the appropriate subclass object. Below is some sample code to illustrate the essence of what I mean.</p>
<p><strong>Updated</strong></p>
<p>The code has been modified to run under both Python 2 and 3 to keep it relevant. This was done in a way that avoids the use Python's explicit metaclass syntax, which varies between the two versions. </p>
<p>To accomplish that objective, a <code>BulletMetaBase</code> instance of the <code>BulletMeta</code> class is created by explicitly calling the metaclass when creating the <code>Bullet</code> baseclass (rather than using the <code>__metaclass__=</code> class attribute or via a <code>metaclass</code> keyword argument depending on the Python version).</p>
<pre><code>class BulletMeta(type):
    def __new__(cls, classname, bases, classdict):
        """ Create Bullet class or a subclass of it. """
        classobj = type.__new__(cls, classname, bases, classdict)
        if classname != 'BulletMetaBase':
            if classname == 'Bullet':  # Base class definition?
                classobj.registry = {}  # Initialize subclass registry.
            else:
                try:
                    alias = classdict['alias']
                except KeyError:
                    raise TypeError("Bullet subclass %s has no 'alias'" %
                                    classname)
                if alias in Bullet.registry: # unique?
                    raise TypeError("Bullet subclass %s's alias attribute "
                                    "%r already in use" % (classname, alias))
                # Register subclass under the specified alias.
                classobj.registry[alias] = classobj

        return classobj

    def __call__(cls, alias, *args, **kwargs):
        """ Bullet subclasses instance factory.

            Subclasses should only be instantiated by calls to the base
            class with their subclass' alias as the first arg.
        """
        if cls != Bullet:
            raise TypeError("Bullet subclass %r objects should not to "
                            "be explicitly constructed." % cls.__name__)
        elif alias not in cls.registry: # Bullet subclass?
            raise NotImplementedError("Unknown Bullet subclass %r" %
                                      str(alias))
        # Create designated subclass object (call its __init__ method).
        subclass = cls.registry[alias]
        return type.__call__(subclass, *args, **kwargs)


class Bullet(BulletMeta('BulletMetaBase', (object,), {})):
    # Presumably you'd define some abstract methods that all here
    # that would be supported by all subclasses.
    # These definitions could just raise NotImplementedError() or
    # implement the functionality is some sub-optimal generic way.
    # For example:
    def fire(self, *args, **kwargs):
        raise NotImplementedError(self.__class__.__name__ + ".fire() method")

    # Abstract base class's __init__ should never be called.
    # If subclasses need to call super class's __init__() for some
    # reason then it would need to be implemented.
    def __init__(self, *args, **kwargs):
        raise NotImplementedError("Bullet is an abstract base class")


# Subclass definitions.
class Bullet1(Bullet):
    alias = 'B1'
    def __init__(self, sprite, start, direction, speed):
        print('creating %s object' % self.__class__.__name__)
    def fire(self, trajectory):
        print('Bullet1 object fired with %s trajectory' % trajectory)


class Bullet2(Bullet):
    alias = 'B2'
    def __init__(self, sprite, start, headto, spead, acceleration):
        print('creating %s object' % self.__class__.__name__)


class Bullet3(Bullet):
    alias = 'B3'
    def __init__(self, sprite, script): # script controlled bullets
        print('creating %s object' % self.__class__.__name__)


class Bullet4(Bullet):
    alias = 'B4'
    def __init__(self, sprite, curve, speed): # for bullets with curved paths
        print('creating %s object' % self.__class__.__name__)


class Sprite: pass
class Curve: pass

b1 = Bullet('B1', Sprite(), (10,20,30), 90, 600)
b2 = Bullet('B2', Sprite(), (-30,17,94), (1,-1,-1), 600, 10)
b3 = Bullet('B3', Sprite(), 'bullet42.script')
b4 = Bullet('B4', Sprite(), Curve(), 720)
b1.fire('uniform gravity')
b2.fire('uniform gravity')
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>creating Bullet1 object
creating Bullet2 object
creating Bullet3 object
creating Bullet4 object
Bullet1 object fired with uniform gravity trajectory
Traceback (most recent call last):
  File "python-function-overloading.py", line 93, in &lt;module&gt;
    b2.fire('uniform gravity') # NotImplementedError: Bullet2.fire() method
  File "python-function-overloading.py", line 49, in fire
    raise NotImplementedError(self.__class__.__name__ + ".fire() method")
NotImplementedError: Bullet2.fire() method
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use keyword arguments with defaults. E.g.</p>
<pre><code>def add_bullet(sprite, start=default, direction=default, script=default, speed=default):
</code></pre>
<p>In the case of a straight bullet versus a curved bullet, I'd add two functions: <code>add_bullet_straight</code> and <code>add_bullet_curved</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>@overload</code> decorator was added with type hints (PEP 484). While this doesn't change the behaviour of python, it does make it easier to understand what is going on, and for mypy to detect errors.<br/>
See: <a href="https://docs.python.org/3/library/typing.html#typing.overload" rel="nofollow noreferrer">Type hints</a> and <a href="https://www.python.org/dev/peps/pep-0484/#id45" rel="nofollow noreferrer">PEP 484</a></p>
</div>
<div class="post-text" itemprop="text">
<p>overloading methods is tricky in python. However, there could be usage of passing the dict, list or primitive variables.</p>
<p>I have tried something for my use cases, this could help here to understand people to overload the methods.</p>
<p>Let's take your example:</p>
<p>a class overload method with call the methods from different class.</p>
<pre><code>def add_bullet(sprite=None, start=None, headto=None, spead=None, acceleration=None):
</code></pre>
<p>pass the arguments from remote class:</p>
<pre><code>add_bullet(sprite = 'test', start=Yes,headto={'lat':10.6666,'long':10.6666},accelaration=10.6}
</code></pre>
<p>OR </p>
<pre><code>add_bullet(sprite = 'test', start=Yes, headto={'lat':10.6666,'long':10.6666},speed=['10','20,'30']}
</code></pre>
<p>So, handling is being achieved for list, Dictionary or primitive variables from method overloading.</p>
<p>try it out for your codes.</p>
</div>
<span class="comment-copy">Works for only one parameter, but here (for people coming here from a search engine): <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow noreferrer">docs.python.org/3/library/…</a></span>
<span class="comment-copy">this seems like a good place for default values. you can set some to None and just check for them. the extra boolean impact seems negligable</span>
<span class="comment-copy">Have to use <code>default value + if + else</code> to do the same as C++ do. This is one of the very few things that C++ has better readability than Python...</span>
<span class="comment-copy">All these look as examples of variable arguments, rather than overloading. Since overloading allows you to have the same function, for different types as arguments. eg: sum(real_num1, real_num2) and sum(imaginary_num1, imaginary_num2)  Will both have same calling syntax, but are actually expecting 2 different types as input, and the implementation has to change also internally</span>
<span class="comment-copy">Using the answer you would go with, how would you present to the caller which arguments make sense together? Just putting a bunch of arguments each with a default value may provide the same functionality but in terms of an API it is much less elegant</span>
<span class="comment-copy">Non of the above is overloading, the implementation will have to check all combinations of parameters inputs (or ignore parameters) like: <code>if sprite and script and not start and not direction and not speed...</code> just to know it is in a specific action. because a caller can call the function providing all the parameters available. While overloading define for you the exact sets of relevant parameters.</span>
<span class="comment-copy">It is very upsetting when people say that python supports method overloading. It does not. The fact that you put "method overloading" in quotations indicates that you aware of this fact. You can get similar functionality with several techniques, like the one mentioned here. But method overloading has a very specific definition.</span>
<span class="comment-copy">What is the problem with  'multipledispatch' in a multi-threaded environment ? Since server-side's code is usually in  multi-threaded environment! Just trying to dig it out!</span>
<span class="comment-copy">@danzeer It was not thread-safe. I saw the argument being modified by two different threads (i.e. the value of <code>speed</code> might change in the middle of the function when another thread sets it's own value of <code>speed</code>)!!! It took me long time to realize that it was the library that was the culprit.</span>
<span class="comment-copy">thanks！Need to use Flask with Python3！</span>
<span class="comment-copy">+1 for decorators for extending the language in this use case.</span>
<span class="comment-copy">+1 because this is a great idea (and probably what the OP should go with) --- I had never seen a multimethod implementation in Python.</span>
<span class="comment-copy">Deferred 2007  PEP <a href="https://www.python.org/dev/peps/pep-3124/#user-api" rel="nofollow noreferrer">python.org/dev/peps/pep-3124/#user-api</a></span>
<span class="comment-copy">Why doesn't this get more votes? I'm guessing due to lack of examples... I've created an answer with an example of how to implement a solution to OP's problem with <i>multipledispatch</i> package.</span>
<span class="comment-copy">That was my initial approach, but for performance reasons I had to rewrite that code in C.</span>
<span class="comment-copy">@Bullets, I would suggest that there may be a number of different options available to improve performance rather than writing a whole lot of c functions that probably won't be doing a whole lot. For example: creating an instance may be expensive, so maintain an object pool. Though I say this without knowing what you found to be too slow. Out of interest, what exactly was slow about this approach? Unless significant time is going to be spent in the C side of the boundary, I can't think that Python (itself) is the real problem.</span>
<span class="comment-copy">Maybe there are other ways to improve the performance, but I am much better with C than with Python. The problem was calculating the motions of the bullets and detecting when they go out of screen bounds. I had a methods for calculating position of the bullet <code>pos+v*t</code> and then comparing to screen boundaries <code>if x &gt; 800</code> and so on. Calling these functions several hundred times per frame turned out to be unacceptably slow. It was something like 40 fps at 100% cpu with pure python to 60 fps with 5%-10% when done in C.</span>
<span class="comment-copy">@Bullets, fair enough then. I'd still use the approach I went with for encapsulating data. Pass an instance of bullet to <code>add_bullet</code>, and extract all the fields that you need. I'll edit my answer.</span>
<span class="comment-copy">@Bullets: You can combine your C functions and the OOP approach suggested by Josh using <a href="http://docs.cython.org/src/quickstart/overview.html" rel="nofollow noreferrer">Cython</a>. It allows early binding so there should not be a speed penalty.</span>
<span class="comment-copy">I was going to suggest the second approach: make some BulletParams... classes to specify the bullet details.</span>
<span class="comment-copy">Can you elaborate on this? I tried to create a class hierarchy with different bullets but this does not work, because Python is too slow. It can't calculate the motions of the required number of bullets fast enough, so I had to write that part in C. All the add_bullet variants just call the corresponding C function.</span>
<span class="comment-copy">Hmm this is still just a fancy way to name the functions as add_bullet1, add_bullet2 and so on.</span>
<span class="comment-copy">@Bullets: Perhaps it is, or maybe it's just a slightly elaborate way to create a factory function. A nice thing about it is that it supports a hierarchy of <code>Bullet</code> subclasses without having to modify the base class or factory function every time you add another subtype. (Of course, if you're using C rather than C++, I guess you don't have classes.) You could also make a smarter metaclass that figured-out on its own what subclass to create based on the type and/or number of arguments passed (like C++ does to support overloading).</span>
<span class="comment-copy">This inheritance idea would be my first option as well.</span>
