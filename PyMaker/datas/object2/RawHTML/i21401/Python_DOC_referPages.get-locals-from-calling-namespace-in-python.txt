<div class="post-text" itemprop="text">
<p>I want to retrieve the local variables from Python from a called function. Is there any way to do this? I realize this isn't right for most programming, but I am basically building a debugger. For example:</p>
<pre><code>def show_locals():
  # put something in here that shows local_1.

local_1 = 123
show_locals()  # I want this to show local_1.
</code></pre>
<p>What do I put in the body of <code>show_locals</code>? If I have to modify the calling statement, what is the minimal modification I can make?</p>
<p><strong>Note:</strong> this must work when <code>show_locals</code> is in a different module to its caller.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're writing a debugger, you'll want to make heavy use of the <a href="http://docs.python.org/library/inspect.html" rel="noreferrer"><code>inspect</code></a> module:</p>
<pre><code>def show_callers_locals():
    """Print the local variables in the caller's frame."""
    import inspect
    frame = inspect.currentframe()
    try:
        print(frame.f_back.f_locals)
    finally:
        del frame
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You use the python builtin, dir() or vars():</p>
<p>vars(object)</p>
<p>For examples using dir(), see: <a href="https://stackoverflow.com/questions/5748448/how-to-retrieve-all-local-variables-of-another-module">this post</a></p>
<p>Examples using vars:</p>
<pre><code>&gt;&gt;&gt; class X:
...     a=1
...     def __init__(self):
...         b=2
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; vars(X)
{'a': 1, '__module__': '__main__', '__doc__': None, '__init__': &lt;function __init__ at 0x100488848&gt;}
&gt;&gt;&gt; 
&gt;&gt;&gt; vars(X())
{}
</code></pre>
<p>A potentially problematic fact: New style classes not return the same result</p>
<pre><code>&gt;&gt;&gt; class X(object):
...     a=1
...     def __init__(self):
...         b=2
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; vars(X)
&lt;dictproxy object at 0x1004a1910&gt;
&gt;&gt;&gt; vars(X())
{}
</code></pre>
<p>Also: for an instantiated class (new and old style), if you add a variable after instantiating, vars will return the object's <strong>dict</strong> like this:</p>
<pre><code>&gt;&gt;&gt; x = X() 
&gt;&gt;&gt; x.c = 1
&gt;&gt;&gt; vars(x)
{'c': 1}
&gt;&gt;&gt; 
</code></pre>
<p>See:  <a href="http://docs.python.org/library/functions.html#vars" rel="nofollow noreferrer">http://docs.python.org/library/functions.html#vars</a></p>
</div>
<span class="comment-copy">nice, looking good.</span>
<span class="comment-copy">Super helpful. Thanks.</span>
<span class="comment-copy">Yay! I found your solution after running into significant performance issues with an alternative solution: <code>caller = inspect.stack()[1][0]; myvars = caller.f_locals</code>. Your way is MUCH faster.</span>
<span class="comment-copy">Why is deleting the <code>frame</code> in the <code>finally</code> block necessary? Is keeping the frame object in memory somehow expensive? This is a minor point, of course, but it left me confused. Also, thank you, this is very helpful!</span>
<span class="comment-copy">The <a href="https://docs.python.org/3/library/inspect.html#the-interpreter-stack" rel="nofollow noreferrer"><code>inspect</code> documentation</a> explains the <code>del frame</code>.</span>
<span class="comment-copy">This doesn't answer the question,  the OP wants the oppersite where inside of func_1, if you call func_2 you can see all the locals from func_1.</span>
