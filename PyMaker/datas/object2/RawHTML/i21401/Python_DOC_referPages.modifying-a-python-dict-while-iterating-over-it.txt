<div class="post-text" itemprop="text">
<p>Let's say we have a Python dictionary <code>d</code>, and we're iterating over it like so:</p>
<pre><code>for k,v in d.iteritems():
    del d[f(k)] # remove some item
    d[g(k)] = v # add a new item
</code></pre>
<p>(<code>f</code> and <code>g</code> are just some black-box transformations.)</p>
<p>In other words, we try to add/remove items to <code>d</code> while iterating over it using <code>iteritems</code>.</p>
<p>Is this well defined? Could you provide some references to support your answer?</p>
<p>(It's pretty obvious how to fix this if it's broken, so this isn't the angle I am after.)</p>
</div>
<div class="post-text" itemprop="text">
<p>It is explicitly mentioned on the Python doc page (for <a href="https://docs.python.org/2.7/library/stdtypes.html#dict.iteritems" rel="noreferrer">Python 2.7</a>) that</p>
<blockquote>
<p>Using <code>iteritems()</code> while adding or deleting entries in the dictionary may raise a <code>RuntimeError</code> or fail to iterate over all entries.</p>
</blockquote>
<p>Similarly for <a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="noreferrer">Python 3</a>.</p>
<p>The same holds for <code>iter(d)</code>, <code>d.iterkeys()</code> and <code>d.itervalues()</code>, and I'll go as far as saying that it does for <code>for k, v in d.items():</code> (I can't remember exactly what <code>for</code> does, but I would not be surprised if the implementation called <code>iter(d)</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Alex Martelli weighs in on this <a href="https://stackoverflow.com/questions/2315520/in-python-how-do-i-loop-through-the-dictionary-and-change-the-value-if-it-equals/2315529#2315529">here</a>.</p>
<p>It may not be safe to change the container (e.g. dict) while looping over the container.
So <code>del d[f(k)]</code> may not be safe. As you know, the workaround is to use <code>d.items()</code> (to loop over an independent copy of the container) instead of <code>d.iteritems()</code> (which uses the same underlying container).</p>
<p>It is okay to modify the value at an <em>existing</em> index of the dict, but inserting values at new indices (e.g. <code>d[g(k)]=v</code>) may not work.</p>
</div>
<div class="post-text" itemprop="text">
<p>You cannot do that, at least with <code>d.iteritems()</code>. I tried it, and Python fails with</p>
<pre><code>RuntimeError: dictionary changed size during iteration
</code></pre>
<p>If you instead use <code>d.items()</code>, then it works.</p>
<p>In Python 3, <code>d.items()</code> is a view into the dictionary, like <code>d.iteritems()</code> in Python 2. To do this in Python 3, instead use <code>d.copy().items()</code>. This will similarly allow us to iterate over a copy of the dictionary in order to avoid modifying the data structure we are iterating over.</p>
</div>
<div class="post-text" itemprop="text">
<p>The following code shows that this is not well defined:</p>
<pre><code>def f(x):
    return x

def g(x):
    return x+1

def h(x):
    return x+10

try:
    d = {1:"a", 2:"b", 3:"c"}
    for k, v in d.iteritems():
        del d[f(k)]
        d[g(k)] = v+"x"
    print d
except Exception as e:
    print "Exception:", e

try:
    d = {1:"a", 2:"b", 3:"c"}
    for k, v in d.iteritems():
        del d[f(k)]
        d[h(k)] = v+"x"
    print d
except Exception as e:
    print "Exception:", e
</code></pre>
<p>The first example calls g(k), and throws an exception (dictionary changed size during iteration).</p>
<p>The second example calls h(k) and throws no exception, but outputs:</p>
<pre><code>{21: 'axx', 22: 'bxx', 23: 'cxx'}
</code></pre>
<p>Which, looking at the code, seems wrong - I would have expected something like:</p>
<pre><code>{11: 'ax', 12: 'bx', 13: 'cx'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have a large dictionary containing Numpy arrays, so the dict.copy().keys() thing suggested by @murgatroid99 was not feasible (though it worked).  Instead, I just converted the keys_view to a list and it worked fine (in Python 3.4):</p>
<pre><code>for item in list(dict_d.keys()):
    temp = dict_d.pop(item)
    dict_d['some_key'] = 1  # Some value
</code></pre>
<p>I realize this doesn't dive into the philosophical realm of Python's inner workings like the answers above, but it does provide a practical solution to the stated problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>I got the same problem  and I used following procedure to solve this issue.</p>
<p>Python List can be iterate even if you modify during iterating over it.
so for following code it will print 1's infinitely.</p>
<pre><code>for i in list:
   list.append(1)
   print 1
</code></pre>
<p>So using list and dict collaboratively you can solve this problem.</p>
<pre><code>d_list=[]
 d_dict = {} 
 for k in d_list:
    if d_dict[k] is not -1:
       d_dict[f(k)] = -1 # rather than deleting it mark it with -1 or other value to specify that it will be not considered further(deleted)
       d_dict[g(k)] = v # add a new item 
       d_list.append(g(k))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Today I had a similar use-case, but instead of simply materializing the keys on the dictionary at the beginning of the loop, I wanted changes to the dict to affect the iteration of the dict, which was an ordered dict.</p>
<p>I ended up building the following routine, which can also be <a href="https://github.com/jaraco/jaraco.itertools/blob/be08cb5d04f9434e140cf7f26483c261b2cff41c/jaraco/itertools.py#L1152-L1168" rel="nofollow noreferrer">found in jaraco.itertools</a>:</p>
<pre><code>def _mutable_iter(dict):
    """
    Iterate over items in the dict, yielding the first one, but allowing
    it to be mutated during the process.
    &gt;&gt;&gt; d = dict(a=1)
    &gt;&gt;&gt; it = _mutable_iter(d)
    &gt;&gt;&gt; next(it)
    ('a', 1)
    &gt;&gt;&gt; d
    {}
    &gt;&gt;&gt; d.update(b=2)
    &gt;&gt;&gt; list(it)
    [('b', 2)]
    """
    while dict:
        prev_key = next(iter(dict))
        yield prev_key, dict.pop(prev_key)
</code></pre>
<p>The docstring illustrates the usage. This function could be used in place of <code>d.iteritems()</code> above to have the desired effect.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 you should just:</p>
<pre><code>prefix = 'item_'
t = {'f1': 'ffw', 'f2': 'fca'}
t2 = dict() 
for k,v in t.items():
    t2[k] = prefix + v
</code></pre>
<p>or use:</p>
<pre><code>t2 = t1.copy()
</code></pre>
<p>You should never modify original dictionary, it leads to confusion as well as potential bugs or RunTimeErrors. Unless you just append to the dictionary with new key names.</p>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/3346696/python-why-is-it-not-safe-to-modify-sequence-being-iterated-on">python - why is it not safe to modify sequence being iterated on?</a></span>
<span class="comment-copy">See <a href="http://stackoverflow.com/questions/5384914/deleting-items-from-a-dictionary-while-iterating-over-it" title="deleting items from a dictionary while iterating over it">stackoverflow.com/questions/5384914/…</a></span>
<span class="comment-copy">I have tried to do this and it seems that if you leave initial dict size unchanged - e.g. replace any key/value instead of removing them then this code will not throw exception</span>
<span class="comment-copy">I will embarrass myself for the sake of the community by stating that I used the very code snippet.  Thinking that since I didn't get a RuntimeError I thought everything was good.  And it was, for a while.  Anally retentive unit tests were giving me the thumbs up and and it was even running well when it was released.  Then, I started getting bizarre behavior.  What was happening was that items in the dictionary were getting skipped over and so not all items in the dictionary were being scanned.  Kids, learn from the mistakes that I have made in my life and just say no! ;)</span>
<span class="comment-copy">Can I run in to problems if I'm changing the value at the current key (but not adding or removing any keys?) I would imaaaagine that this shouldn't cause any problems, but I'd like to know!</span>
<span class="comment-copy">@GershomMaes I don't know of any, but you may still be running into a minefield should your loop body make use of the value and not expecting it to change.</span>
<span class="comment-copy"><code>d.items()</code> should be safe in Python 2.7 (the game changes with Python 3), as it makes what is essentially a copy of <code>d</code>, so you're not modifying what you're iterating over.</span>
<span class="comment-copy">It would be interesting to know if this is also true for <code>viewitems()</code></span>
<span class="comment-copy">I think this is a key answer for me. A lot of use cases will have one process inserting things and another cleaning things up/deleting them so the advice to use d.items() works. Python 3 caveats not withstanding</span>
<span class="comment-copy">More information about the Python 3 caveats can be found in <a href="http://legacy.python.org/dev/peps/pep-0469/#lists-as-mutable-snapshots" rel="nofollow noreferrer">PEP 469</a> where the semantic equivalents of the aforementioned Python 2 dict methods are enumerated.</span>
<span class="comment-copy"><i>"It is okay to modify the value at an existing index of the dict"</i> -- do you have a reference for this?</span>
<span class="comment-copy">@JonathonReinhart: No, I don't have a reference for this, but I think it is pretty standard in Python. For example, Alex Martelli was a Python core developer and <a href="https://stackoverflow.com/a/2315529/190597">demonstrates its usage here</a>.</span>
<span class="comment-copy">Except in Python 3…</span>
<span class="comment-copy">I added Python 3 to my answer.</span>
<span class="comment-copy">FYI, the literal translation (as e.g. used by <code>2to3</code>) of Py2's <code>d.items()</code> to Py3 is <code>list(d.items())</code>, although <code>d.copy().items()</code> is probably of comparable efficiency.</span>
<span class="comment-copy">If the dict object is very large, is d.copy().items() efficiet?</span>
<span class="comment-copy">I can understand why you might expect <code>{11: 'ax', 12: 'bx', 13: 'cx'}</code> but the 21,22,23 should give you clue as to what actually happened: your loop went through items 1, 2, 3, 11, 12, 13 but didn't manage to pick up the second round of new items as they got inserted in front of the items you had already iterated over. Change <code>h()</code> to return <code>x+5</code> and you get another x: <code>'axxx'</code> etc. or 'x+3' and you get the magnificent <code>'axxxxx'</code></span>
<span class="comment-copy">Yeah, my mistake I'm afraid - my expected output was <code>{11: 'ax', 12: 'bx', 13: 'cx'}</code> as you said, so I'll update my post about it. Either way, this is clearly not well defined behaviour.</span>
<span class="comment-copy">I'm not sure if it is safe to modify a list during iteration (although it may work in some cases). See <a href="https://stackoverflow.com/questions/3752618/python-adding-element-to-list-while-iterating">this question</a> for example...</span>
<span class="comment-copy">@Roman If you want to delete elements of a list, you can safely iterate over it in reverse order, since in normal order the index of the next element would change upon deletion. <a href="https://tio.run/##dY1BCsIwFETX5hQfREh2VXeFHEDoDYpIIRMNxKT8RrGnj2ms4MbZDfNmZpzTLYZjzls6JfCQQC4Q4wmeYCiyAQsDSwiPe80v31B2qhVUZCOXksHrtyp5CFdIj1A4tZKLZgdvPnzuSJN3U1rhfaOUqGvL0p/HjbPU9e68O2jdtAa@OjGyC6kA@Q0" rel="nofollow noreferrer">See this example.</a></span>
