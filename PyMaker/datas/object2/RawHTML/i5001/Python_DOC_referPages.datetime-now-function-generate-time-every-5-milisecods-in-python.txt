<div class="post-text" itemprop="text">
<p>Hi I have issue with simple code:</p>
<pre><code>from datetime import datetime
import datetime as dt

while True:
    now = dt.datetime.now().strftime("%Y%m%d%H%M%S%f")
    print(now)
</code></pre>
<p>I receive timestamp not continuously but every 5 miliseconds,
    20180226173710394770
    20180226173710399770
etc.</p>
<p>How can I replace .now() function with something other to get timestamps with mili/microseconds.</p>
<p>Thanks </p>
</div>
<div class="post-text" itemprop="text">
<p>first of all, do not try to print the time as soon as you create it, create a list (print can take some time and you are trying to debug time sensitive problem, in this case it is not an issue but a good thing to remember when playing around with time...)</p>
<pre><code>times = [dt.datetime.now().strftime("%Y%m%d%H%M%S|%f") for _ in range(1000)]
</code></pre>
<p>and then you can take a look at the values you generated - a lot of them are the same still</p>
<p>filter them out and print them in order to take a look at them (divided microseconds to make comparison more obvious)</p>
<pre><code>print(sorted(set(times)))
&gt;&gt;&gt;['20180226192911|002542', '20180226192911|003544', '20180226192911|004547', '20180226192911|005549', '20180226192911|006552']
</code></pre>
<p>we can see that the values are spaced apart by roughly 1000 microseconds and this is not caused because we can generate only one value per ms (our list had a lot more values, but they did not change) but because the datetime function does not have precision higher than one ms - this is caused by your OS (older PC could have the precision lower like 16ms and different OS can have different outcomes as well)</p>
<blockquote>
<p>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock “ticks” only 50 or 100 times a second.
  <a href="https://docs.python.org/3/library/time.html" rel="nofollow noreferrer">https://docs.python.org/3/library/time.html</a></p>
</blockquote>
<p>so aside from using the print in a loop the 5ms differences you see are most likely caused by the clock your OS provides - it is not precise enough</p>
</div>
<span class="comment-copy">I'm almost positive this is python, but it would be very useful to add the language tag.</span>
<span class="comment-copy">What platform is this? I am unable to replicate the behavior.</span>
<span class="comment-copy">@Dietrich Epp I use PyCharm</span>
<span class="comment-copy">PyCharm is your IDE, your platform is probably either Linux, macOS, or Windows.</span>
<span class="comment-copy">I use Windows 10, I need to get actual clock time with microseconds precision.</span>
<span class="comment-copy">That “most Unix systems” is surely out of date. High resolution timers have been in Linux since 2.6.21 back in 2007, and I don’t know how long they’ve been available on macOS but it’s been a while. (Never mind the fact that technically Linux isn’t Unix.)</span>
<span class="comment-copy">you can have a great timer based on cpu tick counting, but the clock is stored in memory and updated only once in a while - it is important for it to be that way so that it is synchronized for each cpu core / thread, if you use a timer you cant really tell the clock - the error margin is still given by the fact you dont know when the clock was updated and how long did it take... here is a question with some helpful answers I found when making sure I dont spit nonsense (I am no expert) <a href="https://stackoverflow.com/questions/18346879/timer-accuracy-c-clock-vs-winapis-qpc-or-timegettime" title="timer accuracy c clock vs winapis qpc or timegettime">stackoverflow.com/questions/18346879/…</a></span>
<span class="comment-copy">Those answers are about Windows, on Linux Python's <code>datetime.now()</code> will will go through <code>clock_gettime()</code> which uses a combination of the value stored in memory (updated "only once in a while") and the TSC register. Combined, this will give nanosecond resolution although the accuracy will be less. I think the Python documentation must be out of date.</span>
