<div class="post-text" itemprop="text">
<p>I am using <a href="http://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse" rel="nofollow noreferrer"><code>dateutils.parser.parse</code></a> to parse date strings which might contain partial information. If some information is not present, <code>parse</code> can take a <code>default</code> keyword argument from which it will fill any missing fields. This default defaults to <code>datetime.datetime.today()</code>.</p>
<p>For a case like <code>dateutil.parser.parse("Thursday")</code>, this means it will return the date of the <em>next</em> Thursday. However, I need it to return the date of the <em>last</em> Thursday (including today, if today happens to be a Thursday).</p>
<p>So, assuming <code>today == datetime.datetime(2018, 2, 20)</code> (a Tuesday), I would like to get all of these <code>assert</code>s to be true:</p>
<pre><code>from dateutil import parser
from datetime import datetime

def parse(date_str, default=None):
    # this needs to be modified
    return parser.parse(date_str, default=default)

today = datetime(2018, 2, 20)

assert parse("Tuesday", default=today) == today    # True
assert parse("Thursday", default=today) == datetime(2018, 2, 15)    # False
assert parse("Jan 31", default=today) == datetime(2018, 1, 31)    # True
assert parse("December 10", default=today) == datetime(2017, 12, 10)    # False
</code></pre>
<p>Is there an easy way to achieve this? With the current <code>parse</code> function only the first and third <code>assert</code> would pass.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's your modified code (<em>code.py</em>):</p>
<pre><code>import sys
from dateutil import parser
from datetime import datetime, timedelta


today = datetime(2018, 2, 20)

data = [
    ("Tuesday", today, today),
    ("Thursday", datetime(2018, 2, 15), today),
    ("Jan 31", datetime(2018, 1, 31), today),
    ("December 10", datetime(2017, 12, 10), today),
]


def parse(date_str, default=None):
    # this needs to be modified
    return parser.parse(date_str, default=default)


def _days_in_year(year):
    try:
        datetime(year, 2, 29)
    except ValueError:
        return 365
    return 366


def parse2(date_str, default=None):
    dt = parser.parse(date_str, default=default)
    if default is not None:
        weekday_strs = [day_str.lower() for day_tuple in parser.parserinfo.WEEKDAYS for day_str in day_tuple]
        if date_str.lower() in weekday_strs:
            if dt.weekday() &gt; default.weekday():
                dt -= timedelta(days=7)
        else:
            if (dt.month &gt; today.month) or ((dt.month == today.month) and (dt.day &gt; today.day)):
                dt -= timedelta(days=_days_in_year(dt.year))
    return dt


def print_stats(parse_func):
    print("\nPrinting stats for \"{:s}\"".format(parse_func.__name__))
    for triple in data:
        d = parse_func(triple[0], default=triple[2])
        print("  [{:s}] [{:s}] [{:s}] [{:s}]".format(triple[0], str(d), str(triple[1]), "True" if d == triple[1] else "False"))


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    print_stats(parse)
    print_stats(parse2)
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>I changed the structure of the code "a bit", to parametrize it, so if a change is needed (e.g. a new example to be added) the changes should be minimal

<ul>
<li>Instead of <code>assert</code>s, I added a function (<code>print_stats</code>) that prints the results (instead raising <code>AssertError</code> and exiting the program if things don't match)

<ul>
<li>Takes an argument (<code>parse_func</code>) which is a function that does the parsing (e.g. <code>parse</code>)</li>
<li>Uses some globally declared data (<code>data</code>) together with the (above) function</li>
</ul></li>
<li><code>data</code> - is a list of triples, where each triple contains:

<ol>
<li>Text to be converted</li>
<li>Expected <code>datetime</code> (<a href="https://docs.python.org/3/library/datetime.html#datetime-objects" rel="nofollow noreferrer">[Python]: datetime Objects</a>) to be yielded by the conversion</li>
<li><code>default</code> argument to be passed to the parsing function (<code>parse_func</code>)</li>
</ol></li>
</ul></li>
<li><p><code>parse2</code> function (an improved version of <code>parse</code>):</p>
<ul>
<li>Accepts 2 types of date strings:

<ol>
<li>Weekday name</li>
<li>Month / Day (unordered)</li>
</ol></li>
<li>Does the regular parsing, and if the converted object comes <strong>after</strong> the one passed as the <code>default</code> argument (that is determined by comparing the appropriate attributes of the 2 objects), it subtracts a period (take a look at <a href="https://docs.python.org/3/library/datetime.html#timedelta-objects" rel="nofollow noreferrer">[Python]: timedelta Objects</a>):

<ol>
<li>"Thursday" comes after "Tuesday", so it subtracts the number of days in a week (7)</li>
<li>"December 10" comes after "February 20", so it subtracts the number of days in the year<sup><strong>*</strong></sup></li>
</ol></li>
<li><p><code>weekday_strs</code>: I'd better explain it by example:</p>
<blockquote>
<pre><code>&gt;&gt;&gt; parser.parserinfo.WEEKDAYS
[('Mon', 'Monday'), ('Tue', 'Tuesday'), ('Wed', 'Wednesday'), ('Thu', 'Thursday'), ('Fri', 'Friday'), ('Sat', 'Saturday'), ('Sun', 'Sunday')]
&gt;&gt;&gt; [day_str.lower() for day_tuple in parser.parserinfo.WEEKDAYS for day_str in day_tuple]
['mon', 'monday', 'tue', 'tuesday', 'wed', 'wednesday', 'thu', 'thursday', 'fri', 'friday', 'sat', 'saturday', 'sun', 'sunday']
</code></pre>
</blockquote>
<ul>
<li>Flattens <code>parser.parserinfo.WEEKDAYS</code></li>
<li>Converts strings to lowercase (for simplifying comparisons)</li>
</ul></li>
</ul></li>
<li><code>_days_in_year</code><sup><strong>*</strong></sup> - as you probably guessed, returns the number of days in an year (couldn't simply subtract 365 because <em>leap</em> years might mess things up):

<blockquote>
<pre><code>&gt;&gt;&gt; dt = datetime(2018, 3, 1)
&gt;&gt;&gt; dt
datetime.datetime(2018, 3, 1, 0, 0)
&gt;&gt;&gt; dt - timedelta(365)
datetime.datetime(2017, 3, 1, 0, 0)
&gt;&gt;&gt; dt = datetime(2016, 3, 1)
&gt;&gt;&gt; dt
datetime.datetime(2016, 3, 1, 0, 0)
&gt;&gt;&gt; dt - timedelta(365)
datetime.datetime(2015, 3, 2, 0, 0)
</code></pre>
</blockquote></li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>(py35x64_test) E:\Work\Dev\StackOverflow\q048884480&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32


Printing stats for "parse"
  [Tuesday] [2018-02-20 00:00:00] [2018-02-20 00:00:00] [True]
  [Thursday] [2018-02-22 00:00:00] [2018-02-15 00:00:00] [False]
  [Jan 31] [2018-01-31 00:00:00] [2018-01-31 00:00:00] [True]
  [December 10] [2018-12-10 00:00:00] [2017-12-10 00:00:00] [False]

Printing stats for "parse2"
  [Tuesday] [2018-02-20 00:00:00] [2018-02-20 00:00:00] [True]
  [Thursday] [2018-02-15 00:00:00] [2018-02-15 00:00:00] [True]
  [Jan 31] [2018-01-31 00:00:00] [2018-01-31 00:00:00] [True]
  [December 10] [2017-12-10 00:00:00] [2017-12-10 00:00:00] [True]
</code></pre>
</blockquote>
</div>
<span class="comment-copy">It doesn't default to last or next, it just replaces the components of the default with the ones it finds in the string</span>
<span class="comment-copy">@Paul You are correct, will re-word.</span>
<span class="comment-copy">Compare if that weekday(date) have passed or not, if not passed, minus a weekday(a year).</span>
<span class="comment-copy">@Paul Hm, <code>dateutil.parser.parse("Thursday", default=datetime.datetime.(2018, 12, 31) == datetime.datetime.(2019, 1, 3)</code>, though.</span>
<span class="comment-copy">@Graipher Thursday with 2018/2/20 was parsed to 2018/2/22, 2018/12/31 was parsed to 2019/1/3. Both of the results are the following day Thursday of the given day, is there anything looks strange?</span>
