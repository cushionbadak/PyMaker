<div class="post-text" itemprop="text">
<p>I need to check if a list of filenames can be copied and I check this against a list of fobidden substrings.</p>
<p>Here is what I have:</p>
<pre><code>exclude = ['ex','xe']
files = ['include', 'exclude']
</code></pre>
<p>And this is what I expect:</p>
<pre><code>['include']
</code></pre>
<p>I already got it working with a list comprehension, like this:</p>
<pre><code>[a[0] for a in [(f, any([e in f for e in exclude])) for f in files] if not a[1]]
</code></pre>
<p>Where I create a tuple <code>(f, any([e in f for e in exclude]))</code> checking if there is any correspondence on the filename to the excluding substrings.
I do this for every file in the list of files <code>for f in files</code> and include only those that don't exist on the excluding substrings <code>if not a[1]</code>.</p>
<p>Is there a better way to this? A more pythonic one?
Because I'm looping through the file list 2 times and I'm guessing there is a way to this in one go!</p>
<p>Thank you!</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't really understand your logic. Looks like you're building tuples with boolean values, then filter the <code>False</code> values out.</p>
<p>It seems to me that this also works and is simpler:</p>
<pre><code>exclude = ['ex','xe']
files = ['include', 'exclude']

print([x for x in files if not any(e in x for e in exclude)])
</code></pre>
<p>it loops through <code>files</code>, and for each file, checks that no <code>exclude</code> member is included in it.</p>
<p>Note that you don't have to build an actual list in <code>any</code>. Omit the square brackets, let <code>any</code> perform a lazy evaluation, it's faster.</p>
</div>
<div class="post-text" itemprop="text">
<p>This will only loop through the file list one time:</p>
<pre><code>[file for file in files if not any(item in file for item in exclude)]
</code></pre>
<p>It does loop through the exclude list once for every item in the file list so if you have a long exclude list the performance might take a hit.</p>
</div>
<span class="comment-copy">this is what I was looking for! I knew there was a better way but was stuck on that. Thank you!</span>
<span class="comment-copy">Also didn't know about the lazy evaluation. Thanks for that note. Always learning!</span>
<span class="comment-copy">Check out the <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a> and <a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all</code></a> functions.  They short-circuit, meaning they don't go through the whole input iterable if  they already "know" whether or not they succeeded.</span>
<span class="comment-copy">@PatrickHaugh Plus they're clearer (which I find more important).</span>
<span class="comment-copy">@PatrickHaugh Good point, updated to include an any generator, which it turns out is the same as the accepted answer</span>
