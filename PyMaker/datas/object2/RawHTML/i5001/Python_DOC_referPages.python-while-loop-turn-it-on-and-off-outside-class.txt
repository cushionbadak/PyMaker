<div class="post-text" itemprop="text">
<p>I'm quite new on Python, and just can't figure out how I get this working.</p>
<p>What I want is a background while loop that prints every second something out, but can turn it off and on when I want to.
For the example I just want to have it the first 4 seconds turned on, after that 4 seconds off (so nothing actually happens). I run it as an process.</p>
<pre><code>#!/usr/bin/env python
import sys
import os
from multiprocessing import Process
from time import gmtime, strftime,sleep

## Start with false
switch = False

def logstate():
    switchT = switch
    while (switchT == True):
        print('state')
        sleep(1)
        switchT = switch

if __name__ == '__main__':
    # start process
    p1 = Process(target=logstate())
    p1.start()
    p1.join()

    # switch on
    switch = True #?
    sleep(4)
    # switch off
    switch = False #?
    sleep(4)
</code></pre>
<p>So there is probably a lot of ways how to do this, but can't figure out what's the easiest way. Many thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you should run the while loop inside a <a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">Thread</a></p>
<pre><code>from threading import Thread
from time import sleep

SHOULD_LOOP = False


def threaded_function():
    while True:
        if not SHOULD_LOOP: continue
        print('state')
        sleep(1)


if __name__ == "__main__":
    thread = Thread(target = threaded_function)
    thread.start()
    while True:
        SHOULD_LOOP = True
        sleep(4)
        SHOULD_LOOP = False
        sleep(4)

    thread.join()
    print ("thread finished...exiting")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your loop should always run, otherwise you would need a second loop to check if it should run the loop = redundant.  </p>
<p>Also you are using the multiprocessing library, which means they won't share global variables inside the system, like threads would.  SO... you need to save the switch in an outside context (like a DB, or config file) and have the loop check that before output.  </p>
<pre><code>def logstate():
    while 1:
        with open('myfile.txt', 'r') as f:
            switch = f.readline()
        if switch.lower() == "true":
            print('state')
        sleep(1)
</code></pre>
<p>Here is the problem with the above.  Sleep blocks the thread.  You really should think about context switching, like gevent.  </p>
<p>Additional option, if you do go to gevent, you can use GIPC to open multiple processes as well as asynch threading inside each process AND share states between them.  It works extremely well.</p>
</div>
<span class="comment-copy">as a thread you could share a global variable</span>
<span class="comment-copy">The while loop never begins as <code>switch</code> begins with <code>False</code></span>
<span class="comment-copy">This works really well, thanks.</span>
<span class="comment-copy">Thanks for the tips about GIPC in gevent!</span>
