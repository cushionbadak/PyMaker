<div class="post-text" itemprop="text">
<p>I'm trying to understand f their are differencies between <code>self</code> and <code>cls</code> but I'm struggle, even if it exists alot of topic about that. For instance:</p>
<pre><code>class maclass():
    A = "class method"

    def __init__(self):
        self.B = "instance method"

    def getA_s(self):
        print(self.A)

    def getA_c(cls):
        print(cls.A)

    def getB_s(self):
        print(self.B)

    def getB_c(cls):
        print(cls.B)

C = maclass()
C.getA_s()
C.getA_c()
C.getB_s()
C.getB_c()
</code></pre>
<p>which give me:</p>
<pre><code>class method
class method
instance method
instance method
</code></pre>
<p>So whatever I use <code>self</code> or <code>cls</code> It aways refer to the same variable. When I add a  <code>self.A</code> in the <code>Init__</code>, the cls.A is just replaced</p>
<pre><code>def __init__(self):
        self.B = "instance method"
        self.A = "new instance method"
</code></pre>
<p>and I get:</p>
<pre><code>new instance method
new instance method
instance method
instance method
</code></pre>
<p>I don't understand the point having two way to call class member if they are the same? I know this is a common question on this forum but yet I really don't understand why we can use different words to refer to the same thing (we even could use whatever the word instead of <code>self</code> or <code>cls</code>)</p>
<h2>update</h2>
<p>In the following case:</p>
<pre><code>class maclass():
    A = "class method, "

    def __init__(self):
        self.A = "instance method, "

    def getA_s(self):
        print(self.A) #give me "instance method, "

    @classmethod
    def getA_c(cls):
        print(cls.A) #give me "class method, "

C = maclass()
C.getA_s()
C.getA_c()
print(' ')
print(C.A) #give me "instance method, "
</code></pre>
<p>I get :</p>
<pre><code>instance method, 
class method, 

instance method,    
</code></pre>
<p>So in this case, in <code>maclass</code> <code>cls.A</code> or <code>self.A</code> do not refer to the same variable.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>All</em> your methods are instance methods. None of them are class methods.</p>
<p>The first argument to a method is named <code>self</code> only by convention. You can name it anything you want, and naming it <code>cls</code> instead will not make it a reference to the class. That the first argument is bound to an instance is due to how method lookup works (accessing <code>C.getA_s</code> produces a <em>bound method object</em>, and calling that object causes <code>C</code> to be passed into the original function <code>getA_s</code>), the names of the parameters play no role.</p>
<p>In your methods, you are merely referencing instance attributes. That the <code>A</code> attribute is ultimately only defined on the class doesn't matter, you are still accessing that attribute through <code>C.A</code> (where <code>C</code> is the instance you created), not <code>maclass.A</code>. Looking up an attribute on the instance will also find attributes defined on the class if there is no instance attribute shadowing it.</p>
<p>To make a method a class method, decorate it with the <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="noreferrer"><code>@classmethod</code> decorator</a>:</p>
<pre><code>@classmethod
def getA_c(cls):
    print(cls.A)
</code></pre>
<p>Now <code>cls</code> will always be a reference to the class, never to the instance. I need to stress again that it doesn't actually matter to Python what name I picked for that first argument, but <code>cls</code> is the convention here as that makes it easier to remind the reader that this method is bound to the class object. </p>
<p>Note that if you do this for the <code>getB_c()</code> method, then trying to access <code>cls.B</code> in the method will fail because there is no <code>B</code> attribute on the <code>maclass</code> class object.</p>
<p>That's because <code>classmethod</code> wraps the function in a <a href="https://docs.python.org/3/howto/descriptor.html" rel="noreferrer">descriptor object</a> that overrides the normal function binding behaviour. It is the descriptor <em>protocol</em> that causes methods to be bound to instances when accessed as attributes on the instance, a <code>classmethod</code> object redirects that binding process.</p>
<p>Here is a short demonstration with inline comments, I used the Python convertions for naming classes (using CamelCase), and for instances, attributes, functions and methods (using snake_case):</p>
<pre><code>&gt;&gt;&gt; class MyClass():
...     class_attribute = "String attribute on the class"
...     def __init__(self):
...         self.instance_attribute = "String attribute on the instance"
...     @classmethod
...     def get_class_attribute(cls):
...         return cls.class_attribute
...     def get_instance_attribute(self):
...         return self.instance_attribute
...     @classmethod
...     def get_instance_attribute_on_class(cls):
...         return cls.instance_attribute
...
&gt;&gt;&gt; instance = MyClass()
&gt;&gt;&gt; instance.class_attribute  # class attributes are visible on the instance
'String attribute on the class'
&gt;&gt;&gt; MyClass.class_attribute   # class attributes are also visible on the class
'String attribute on the class'
&gt;&gt;&gt; instance.get_class_attribute()  # bound to the class, but that doesn't matter here
'String attribute on the class'
&gt;&gt;&gt; instance.class_attribute = "String attribute value overriding the class attribute"
&gt;&gt;&gt; instance.get_class_attribute()  # bound to the class, so the class attribute is found
'String attribute on the class'
&gt;&gt;&gt; MyClass.get_instance_attribute_on_class()   # fails, there is instance_attribute on the class
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in get_instance_attribute_on_class
AttributeError: type object 'MyClass' has no attribute 'instance_attribute'
</code></pre>
<p>Note that the class method accesses the class attribute even though we set an attribute with the same name on the instance.</p>
<p>Next is binding behaviour:</p>
<pre><code>&gt;&gt;&gt; MyClass.get_instance_attribute   # accessing the method on the class gives you the function
&lt;function MyClass.get_instance_attribute at 0x10f94f268&gt;
&gt;&gt;&gt; instance.get_instance_attribute  # accessing the method on the instance gives you the bound method
&lt;bound method MyClass.get_instance_attribute of &lt;__main__.MyClass object at 0x10f92b5f8&gt;&gt;
&gt;&gt;&gt; MyClass.get_class_attribute      # class methods are always bound, to the class
&lt;bound method MyClass.get_class_attribute of &lt;class '__main__.MyClass'&gt;&gt;
&gt;&gt;&gt; instance.get_class_attribute     # class methods are always bound, to the class
&lt;bound method MyClass.get_class_attribute of &lt;class '__main__.MyClass'&gt;&gt;
</code></pre>
<p>The bound methods tell you what they are bound <em>to</em>, calling the method passes in that bound object as the first argument. That object can also be introspected by looking at the <code>__self__</code> attribute of a bound method:</p>
<pre><code>&gt;&gt;&gt; instance.get_instance_attribute.__self__  # the instance
&lt;__main__.MyClass object at 0x10f92b5f8&gt;
&gt;&gt;&gt; instance.get_class_attribute.__self__     # the class
&lt;class '__main__.MyClass'&gt;
</code></pre>
</div>
<span class="comment-copy">They are just naming conventions. You can name that first argument anything you like.</span>
<span class="comment-copy">Try calling it <code>kevin</code>, it will still work in the same way.  We use <code>self</code> and <code>cis</code> as a convention for <i>readability</i>, nothing more.</span>
<span class="comment-copy">So in your example, <code>cls.A</code> differ from <code>self.A</code>. If I do a <code>C.A</code> from a <code>maclass</code> instance I will get the <code>self.A</code> from <code>maclass</code>, Am I right?</span>
<span class="comment-copy">@ymmx: I'm not sure what you are asking. What are <code>cls</code> and <code>self</code> there? The parameter names in your example code? Those are always the same object, the instance of the <code>maclass</code> you assigned to <code>C</code>.</span>
<span class="comment-copy">@ymmx: If you add <code>@classmethod</code> to your <code>get*_c</code> definitions, then <code>cls</code> will be bound to the <code>maclass</code> class, and so <code>cls.A</code> will only ever find the class attribute. Calling <code>C.getB_c()</code> would fail, because there is no <code>B</code> attribute on the <code>maclass</code> class object.</span>
<span class="comment-copy">Ok I get it. So <code>self</code>and <code>cls</code> are different if at least a classmethod decorator is used.</span>
<span class="comment-copy">I found this answer to be exceptionally thorough and clear. Thank you!</span>
