<div class="post-text" itemprop="text">
<p>So i have a script for a countdown which looks something like this:</p>
<pre><code>import time, threading, asyncio
def countdown(n, m):
    print("timer start")
    time.sleep(n)
    print("timer stop")
    yield coro1

async def coro1():
    print("coroutine called")

async def coromain():
    print("first")
    t1 = threading.Thread(target=countdown, args=(5, 0))
    t1.start()
    print("second")

loop = asyncio.get_event_loop()
loop.run_until_complete(coromain())
loop.stop()
</code></pre>
<p>What i want it to do is simple:</p>
<pre><code>Run coromain
Print "first"
Start thread t1, print "timer start" and have it wait for 5 seconds
In the mean time, print "second"
after 5 seconds, print "timer stop"
exit
</code></pre>
<p>However, when i run this code it outputs:</p>
<pre><code>Run coromain
Print "first"
Print "second"
exit
</code></pre>
<p>I'm so confused as to why it does this. Can anyone explain what I'm doing wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<p>This depends on whether your question is a part of a bigger problem imposing additional constraints or not, but I do not see a reason to use <code>threading</code>. Instead, you can use two separate <code>Task</code>s running in the same event loop, which is one of the main points of asynchronous programming:</p>
<pre><code>import asyncio

async def countdown(n, m):  # &lt;- coroutine function
    print("timer start")
    await asyncio.sleep(n)
    print("timer stop")
    await coro1()

async def coro1():
    print("coroutine called")

async def coromain():
    print("first")
    asyncio.ensure_future(countdown(5, 0))  # create a new Task
    print("second")

loop = asyncio.get_event_loop()
loop.run_until_complete(coromain())  # run coromain() from sync code
pending = asyncio.Task.all_tasks()  # get all pending tasks
loop.run_until_complete(asyncio.gather(*pending))  # wait for tasks to finish normally
</code></pre>
<p>Output: </p>
<pre><code>first
second
timer start
(5 second wait)
timer stop
coroutine called
</code></pre>
<p>When using <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future" rel="nofollow noreferrer"><code>ensure_future</code></a>, you effectively make a new “execution thread” (see fibers) inside the single OS's thread.</p>
</div>
<div class="post-text" itemprop="text">
<p>After some digging crafted this workaround. It might not be pretty, but it works:</p>
<pre><code>import time, threading, asyncio
def countdown(n, m):
    print("timer start")
    time.sleep(n)
    print("timer stop")
    looptemp = asyncio.new_event_loop()
    asyncio.set_event_loop(looptemp)
    loop2 = asyncio.get_event_loop()
    loop2.run_until_complete(coro1())
    loop2.close()

async def coro1():
    print("coroutine called")

async def coromain():
    print("first")
    t1 = threading.Thread(target=countdown, args=(5, 0))
    t1.start()
    print("second")

loop = asyncio.get_event_loop()
loop.run_until_complete(coromain())
loop.stop()
</code></pre>
<p>It unfortunately doesn't work for my specific usecase, but I thought it might be useful.</p>
</div>
<span class="comment-copy">Can you please explain the choice of running the countdown in a different thread?</span>
<span class="comment-copy">i'm making a discord bot. I need it to count down for n seconds and then notify the user, while still being able to accept commands in the main thread</span>
<span class="comment-copy">Awesome, i'm not that familiar with asyncio, but was forced upon it because I'm using a library that only works with said library. I thought there had to be a way like this, but couldn't make it out from the docs</span>
<span class="comment-copy">You might want to use <code>create_task</code> instead of <code>ensure_future</code> when you pass it an actual coroutine. <a href="https://github.com/python/asyncio/issues/477#issuecomment-268709555" rel="nofollow noreferrer">According to Guido</a>, <code>ensure_future</code> is a only needed when you are converting something that may or may not be a future and need an actual <code>Future</code> result, e.g. to call <code>cancel</code> or <code>add_done_callback</code> on it.</span>
<span class="comment-copy">@user4815162342 That's an interesting point, thanks. I usually use <code>ensure_future</code> because I rarely have an explicit loop lying around.</span>
<span class="comment-copy">That makes sense, but does have <code>ensure_future</code> have any overhead that <code>create_task</code> doesn't have? Aka, would it be better to use <code>create_task</code> when you know that you are dealing with a <code>Future</code>?</span>
<span class="comment-copy">@DavinMiler In this case it's not about the overhead, it's about clarity of code. <code>ensure_future</code> indicates that the code is trying to convert some object into a future. <code>create_task</code> always accepts a coroutine and returns a task, which is a subclass of <code>Future</code> that "drives" a coroutine in the event loop. Now, <code>ensure_future</code> is smart enough to return a task when given a coroutine, but using <code>create_task</code> more precisely indicates the intent of the code.</span>
