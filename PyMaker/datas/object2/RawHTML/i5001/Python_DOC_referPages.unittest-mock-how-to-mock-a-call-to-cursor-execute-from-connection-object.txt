<div class="post-text" itemprop="text">
<p>I am trying to stub out cursor.execute() in the following code with mock such that I can test execute is called with a correctly formatted query:</p>
<pre><code>// Module ABC

def buildAndExecuteQuery( tablesAndColumnsToSelect ):
   '''Build and execute a query.

   Args: tablesAndColumnsToSelect (dict)
         - keys are table names, values are columns

   '''
   query = ..... &lt; logic to build query &gt; ....

   from django.db import connections
   cursor = connections[ 'mydb' ].cursor()
   cursor.execute( query )
</code></pre>
<p>How can I accomplish this type of mock in python2.7 with the mock library?</p>
</div>
<div class="post-text" itemprop="text">
<p>Since I don't know what your query logic is, I modified the <code>query</code> to just accept a sentinel value directly through the <code>tables_and_columns_to_select</code> argument.</p>
<pre><code># b_and_ex_q.py


def build_and_execute_query(tables_and_columns_to_select):
    """Build and execute a query.

    Args: tablesAndColumnsToSelect (dict)
          - keys are table names, values are columns

    """

    query = tables_and_columns_to_select  # ..... &lt; logic to build query &gt; ....

    from django.db import connections

    cursor = connections['mydb'].cursor()
    cursor.execute(query)
</code></pre>
<hr/>
<pre><code>import unittest

from mock import patch, sentinel

from b_and_ex_q import build_and_execute_query


class TestCursorExecute(unittest.TestCase):
    @patch('django.db.connections')
    def test_build_and_execute_query(self, mock_connections):
        # Arrange
        mock_cursor = mock_connections.__getitem__('mydb').cursor.return_value

        # Act
        build_and_execute_query(sentinel.t_and_c)

        # Assert
        mock_cursor.execute.assert_called_once_with(sentinel.t_and_c)


if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I will expand @G_M answer with example since I have two objections:</p>
<ol>
<li>In my opinion, it is a good practice to explicitly close database cursor, more about this here: <a href="https://stackoverflow.com/questions/24661754/necessity-of-explicit-cursor-close">Necessity of explicit cursor.close()</a>. This can be done by using the cursor as a context manager, more in Django docs: <a href="https://docs.djangoproject.com/en/dev/topics/db/sql/#connections-and-cursors" rel="nofollow noreferrer">https://docs.djangoproject.com/en/dev/topics/db/sql/#connections-and-cursors</a>.</li>
<li>When using <code>mock</code> we should not patch objects where they are defined:</li>
</ol>
<blockquote>
<p>The basic principle is that you patch where an object is looked up,
  which is not necessarily the same place as where it is defined. A
  couple of examples will help to clarify this.</p>
</blockquote>
<p>Ref: <a href="https://docs.python.org/3/library/unittest.mock.html#where-to-patch" rel="nofollow noreferrer">https://docs.python.org/3/library/unittest.mock.html#where-to-patch</a></p>
<p><strong>Example:</strong></p>
<p>Our function we want to test:</p>
<pre><code># foooo_bar.py
from typing import Optional

from django.db import DEFAULT_DB_ALIAS, connections


def some_function(some_arg: str, db_alias: Optional[str] = DEFAULT_DB_ALIAS):
    with connections[db_alias].cursor() as cursor:
        cursor.execute('SOME SQL FROM %s;', [some_arg])
</code></pre>
<p><strong>Test:</strong></p>
<pre><code># test_foooo_bar.py
from unittest import mock

from django.db import DEFAULT_DB_ALIAS
from django.test import SimpleTestCase

from core.db_utils.xx import some_function


class ExampleSimpleTestCase(SimpleTestCase):
    @mock.patch('foooo_bar.connections')
    def test_some_function_executes_some_sql(self, mock_connections):
        mock_cursor = mock_connections.__getitem__(DEFAULT_DB_ALIAS).cursor.return_value.__enter__.return_value
        some_function('fooo')

        # Demonstrating assert_* options:
        mock_cursor.execute.assert_called_once()
        mock_cursor.execute.assert_called()
        mock_cursor.execute.assert_called_once_with('SOME SQL FROM %s;', ['fooo'])
</code></pre>
</div>
<span class="comment-copy"><a href="https://pypi.python.org/pypi/mox" rel="nofollow noreferrer">mox 0.5.3: New uses of this library are discouraged.</a> Is there any reason why you have to use mox?</span>
<span class="comment-copy">Not really, though it is common practice where I am working. A working  solution using another mock library would be ok-- I guess even better if new uses of mox are discouraged.</span>
<span class="comment-copy">I hadn't heard of <code>mox</code> and that was just a quote from the pypi page itself. It also hasn't been updated since 2010. I'll try to write an example for you right now but the imports are slightly different between versions (Python 3 mock is in the stdlib but Python 2 is third-party). I'm guessing Python 2 since <code>mox</code> is Python 2 only?</span>
<span class="comment-copy">Yes Python 2.7. Sure, thanks for the help Delirious Lettuce!</span>
<span class="comment-copy">I have updated the post to refer to mock library instead of pymox.</span>
<span class="comment-copy">Thanks Delirious Lettuce, this was confusing me all day. Btw I found that the patch to apply for a local "from django.db import connections" import inside of buildAndExecuteQuery() is simply: @patch( 'django.db.connections' ).</span>
<span class="comment-copy">@bwrabbit No problem, I also updated the patch as per your comment. It's nice to see a fellow Vancouverite on here!</span>
