<div class="post-text" itemprop="text">
<p>I have inherited code that looks something like this:</p>
<pre><code>class A:
  def __init__(self):
    print('A')

def foo(self, *args):
  print('foo')

a = A()
setattr(a,'foo',types.MethodType(foo,a,A))
</code></pre>
<p>For that last line, I want to make the code 2to3 compatible, but MethodType only takes two arguments in python3.</p>
<p>Simplest option is probably to let it break intelligently and</p>
<pre><code>try:
  setattr(a,'foo',types.MethodType(foo,a,A))
except TypeError:
  setattr(a,'foo',types.MethodType(foo,a))
</code></pre>
<p>But then I realized that I don't understand why I'm adding the third argument in python2, because <code>setattr(a,'foo',types.MethodType(foo,a))</code> works across languages.</p>
<p>In Python2, what is the third argument buying me, to bind it to the class vs not?</p>
<pre><code>&gt;&gt;&gt; types.MethodType(foo,a)
&lt;bound method ?.foo of &lt;__main__.A instance at 0x1&gt;&gt;
&gt;&gt;&gt; types.MethodType(foo,a,A)
&lt;bound method A.foo of &lt;__main__.A instance at 0x1&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2, the third argument to the method type constructor was mostly used for unbound method objects:</p>
<pre><code>&gt;&gt;&gt; class Foo(object):
...     def bar(self):
...         pass
...
&gt;&gt;&gt; Foo.bar
&lt;unbound method Foo.bar&gt;
</code></pre>
<p>A direct constructor call to create one of these would have looked like <code>types.MethodType(bar, None, Foo)</code>, where <code>bar</code> is the function. Unbound method objects did a bit of type checking to ensure they weren't used for objects of the wrong type, but they were deemed not useful enough to justify their existence, so they got taken out in Python 3. With no more unbound method objects, there wasn't much reason for the method constructor to take a third argument, so that was removed too.</p>
</div>
<div class="post-text" itemprop="text">
<p>A python2 / python3 compatible way to accomplish what you want is to use the <a href="https://docs.python.org/3/howto/descriptor.html#functions-and-methods" rel="nofollow noreferrer">descriptor protocol (<code>__get__</code>)</a>:</p>
<pre><code>class A(object):
  def __init__(self):
    print('A')

def foo(self, *args):
  print('foo')

a = A()
setattr(a,'foo', foo.__get__(a, A))
</code></pre>
<p><code>.__get__</code> will return a <code>bound method</code> instance</p>
</div>
<span class="comment-copy">This seems like a backdoor to access types.MethodType (since that is what <b>get</b> eventually returns)? or is this the preferred method and direct access to types.MethodType is discouraged? For Zen reasons I'm curious which is more pythonic?</span>
