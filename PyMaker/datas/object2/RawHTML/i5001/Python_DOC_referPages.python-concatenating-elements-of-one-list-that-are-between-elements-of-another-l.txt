<div class="post-text" itemprop="text">
<p>I have two lists: <code>a</code> and <code>b</code>.  I want to concatenate all of the elements of the <code>b</code> that are between elements of <code>a</code>. All of the elements of <code>a</code> are in <code>b</code>, but <code>b</code> also has some extra elements that are extraneous. I would like to take the first instance of every element of <code>a</code> in <code>b</code> and concatenate it with the extraneous elements that follow it in <code>b</code> until we find another element of <code>a</code> in <code>b</code>. The following example should make it more clear.  </p>
<pre><code>a = [[11.0, 1.0], [11.0, 2.0], [11.0, 3.0], [11.0, 4.0], [11.0, 5.0], [12.0, 1.0], [12.0, 2.0], [12.0, 3.0], [12.0, 4.0], [12.0, 5.0], [12.0, 6.0], [12.0, 7.0], [12.0, 8.0], [12.0, 9.0], [12.0, 10.0], [12.0, 11.0], [12.0, 12.0], [12.0, 13.0], [12.0, 14.0], [13.0, 1.0], [13.0, 2.0], [13.0, 3.0], [13.0, 4.0], [13.0, 5.0], [13.0, 6.0], [13.0, 7.0], [13.0, 8.0], [13.0, 9.0], [13.0, 10.0]]  

b = [[11.0, 1.0], [11.0, 1.0], [1281.0, 8.0], [11.0, 2.0], [11.0, 3.0], [11.0, 3.0], [11.0, 4.0], [11.0, 5.0], [12.0, 1.0], [12.0, 2.0], [12.0, 3.0], [12.0, 4.0], [12.0, 5.0], [12.0, 6.0], [12.0, 7.0], [12.0, 5.0], [12.0, 8.0], [12.0, 9.0], [12.0, 10.0], [13.0, 5.0], [12.0, 11.0], [12.0, 8.0], [3.0, 1.0], [13.0, 1.0], [9.0, 7.0], [12.0, 12.0], [12.0, 13.0], [12.0, 14.0], [13.0, 1.0], [13.0, 2.0], [11.0, 3.0], [13.0, 3.0], [13.0, 4.0], [13.0, 5.0], [13.0, 5.0], [13.0, 5.0], [13.0, 6.0], [13.0, 7.0], [13.0, 7.0], [13.0, 8.0], [13.0, 9.0], [13.0, 10.0]]

c = [[[11.0, 1.0], [11.0, 1.0], [1281.0, 8.0]], [[11.0, 2.0]], [[11.0, 3.0], [11.0, 3.0]], [[11.0, 4.0]], [[11.0, 5.0]], [[12.0, 1.0]], [[12.0, 2.0]], [[12.0, 3.0]], [[12.0, 4.0]], [[12.0, 5.0]], [[12.0, 6.0]], [[12.0, 7.0], [12.0, 5.0]], [[12.0, 8.0]], [[12.0, 9.0]], [[12.0, 10.0], [13.0, 5.0]], [[12.0, 11.0], [12.0, 8.0], [3.0, 1.0]], [[13.0, 1.0], [9.0, 7.0], [12.0, 12.0], [12.0, 13.0], [12.0, 14.0], [13.0, 1.0]], [[13.0, 2.0]], [[11.0, 3.0], [13.0, 3.0]], [[13.0, 4.0]], [[13.0, 5.0], [13.0, 5.0], [13.0, 5.0]], [[13.0, 6.0]], [[13.0, 7.0], [13.0, 7.0]], [[13.0, 8.0]], [[13.0, 9.0]], [[13.0, 10.0]]]
</code></pre>
<p>What I have thought of is something like this:</p>
<pre><code>slice_list = []
for i, elem in enumerate(a):
    if i &lt; len(key_list)-1:
        b_first_index = b.index(a[i])
        b_second_index = b.index(a[i+1]) 
        slice_list.append([b_first_index, b_second_index])

c = [[b[slice_list[i][0]:b[slice_list[i][1]]]] for i in range(len(slice_list))]
</code></pre>
<p>This however will not catch the last item in the list (which I am not quite sure how to fit into my list comprehension anyways) and it seems quite ugly. My question is, is there a neater way of doing this (perhaps in itertools)?</p>
</div>
<div class="post-text" itemprop="text">
<p>I think your example wrong_list_fixed is incorrect.</p>
<pre><code>        [[12.0, 10.0], [13.0, 5.0], [12.0, 11.0], [12.0, 8.0],
# There should be a new list here -^
</code></pre>
<p>Here's a solution that walks the lists. It can be optimized further:</p>
<pre><code>from contextlib import suppress

fixed = []
current = []
key_list_iter = iter(key_list)
next_key = next(key_list_iter)
for wrong in wrong_list:
    if wrong == next_key:
        if current:
            fixed.append(current)
            current = []
        next_key = None
        with suppress(StopIteration):
            next_key = next(key_list_iter)
    current.append(wrong)

if current:
    fixed.append(current)
</code></pre>
<p>Here are the correct lists (modified to be easier to visually parse):</p>
<pre><code>key_list = ['_a0', '_b0', '_c0', '_d0', '_e0', '_f0', '_g0', '_h0', '_i0', '_j0', '_k0', '_l0', '_m0', '_n0', '_o0', '_p0', '_q0', '_r0', '_s0', '_t0', '_u0', '_v0', '_w0', '_x0', '_y0', '_z0', '_A0', '_B0', '_C0'] 
wrong_list = ['_a0', '_a0', 'D0', '_b0', '_c0', '_c0', '_d0', '_e0', '_f0', '_g0', '_h0', '_i0', '_j0', '_k0', '_l0', '_j0', '_m0', '_n0', '_o0', '_x0', '_p0', '_m0', 'E0', '_t0', 'F0', '_q0', '_r0', '_s0', '_t0', '_u0', '_c0', '_v0', '_w0', '_x0', '_x0', '_x0', '_y0', '_z0', '_z0', '_A0', '_B0', '_C0'] 
wrong_list_fixed = [['_a0', '_a0', 'D0'], ['_b0'], ['_c0', '_c0'], ['_d0'], ['_e0'], ['_f0'], ['_g0'], ['_h0'], ['_i0'], ['_j0'], ['_k0'], ['_l0', '_j0'], ['_m0'], ['_n0'], ['_o0', '_x0'], ['_p0', '_m0', 'E0', '_t0', 'F0'], ['_q0'], ['_r0'], ['_s0'], ['_t0'], ['_u0', '_c0'], ['_v0'], ['_w0'], ['_x0', '_x0', '_x0'], ['_y0'], ['_z0', '_z0'], ['_A0'], ['_B0'], ['_C0']] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let's simplify the visual a bit:</p>
<pre><code>key_list = ['a', 'c', 'f']
wrong_list = ['a', 'b', 'c', 'd', 'e', 'f']
wrong_list_fixed = [['a', 'b'], ['c', 'd', 'e'], ['f']]
</code></pre>
<p>This will be semantically identical to what you have, but I think it is easier to see without all the extra nested brackets.</p>
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a>, if you could only come up with a clever key. Luckily, the mapping of <code>key_list</code> to <code>wrong_list</code> givs you exactly what you want:</p>
<pre><code>class key:
    def __init__(self, key_list):
        self.last = -1
        self.key_list = key_list
    def __call__(self, item):
        try:
            self.last = self.key_list.index(item, self.last + 1)
        except ValueError:
            pass
        return self.last
wrong_list_fixed = [list(g) for k, g in itertools.groupby(wrong_list, key(key_list))]
</code></pre>
<p>The key maps elements of <code>wrong_list</code> to <code>key_list</code> using <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="nofollow noreferrer"><code>index</code></a>. For missing indices, it just returns the last one successfully found, ensuring that groups are not split until a new index is found. By starting the search from the next available index, you can ensure that duplicate entries in <code>key_list</code> get handled correctly.</p>
<p><a href="https://ideone.com/jXwiGs" rel="nofollow noreferrer">[IDEOne Link]</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I get slightly different result from yours, but give it a try. If this is not what you want, I will delete my answer.</p>
<pre><code>idx = sorted(set([b.index(ai) for ai in a] + [len(b)]))
c = [b[i:j] for i, j in zip(idx[:-1], idx[1:])]
</code></pre>
</div>
<span class="comment-copy">I am having a very hard time understanding your desired end-state, but I suspect there is a much simper/cleaner way to do this using sets instead of lists. Are you saying you want a list of lists, each one starting with the first index of a key_list and containing "extraneous" lists? What do you want to keep, and what do you want to get rid of?</span>
<span class="comment-copy">Yes, it is kind of a complicated question. The wrong_list is basically the key_list with a bunch of extraneous items. I would like wrong_list to be fixed using the elements of key_list so that the first element of each element in list of lists wrong_list_fixed is an element of key_list. Basically I want to group all the extraneous info between the elements of key_list</span>
<span class="comment-copy">@sfortney Side note: I think you should consider using different abstractions in your example.  I'm having a very tough time wrapping my head around <code>key_list</code> and <code>wrong_list</code>.  Maybe <code>a</code> and <code>b</code> would be better :)</span>
<span class="comment-copy">Also, I don't see a nicer way to get the desired output than a list of lists (I am happy to be wrong about that though)</span>
<span class="comment-copy">So you want something like: [[(11.0, 1.0),(1281.0, 8.0)], [(11.0, 2.0),(more extraneous)]]? Also, what is the value of having duplicates in your wrong_list?</span>
<span class="comment-copy">That's possible. I made the desired output by hand. Testing it right now.</span>
<span class="comment-copy">I like this one the best and this is what I ended up using. Mad Physicist's answer was great too though. This one just came in first and seems a bit more maintainable in general. Speed isn't as big a concern as maintainability in this problem.</span>
<span class="comment-copy">Edited my Q to fix the desired output. Good catch.</span>
<span class="comment-copy">In your <code>ValueError</code> case, it will be immediately followed by a <code>NameError</code> (because <code>last</code> is never defined). And you never use <code>self.last</code> at all, which seems a bit suspicious, correctness-wise.</span>
<span class="comment-copy">returns <code>wrong_list_fixed = [[0, &lt;itertools._grouper object at 0x7f03ceef6550&gt;], ...</code></span>
<span class="comment-copy">@Harvey. Fixed that too.</span>
<span class="comment-copy">@sfortney. You did ask for itertools :)</span>
<span class="comment-copy">I almost always prefer solutions that let Python internals do most of the work.</span>
<span class="comment-copy"><code>c</code> is missing some elements and contains some empty lists</span>
<span class="comment-copy">@Harvey what about now? I just edited my answer. Thanks for noticing!</span>
<span class="comment-copy">missing and empty fixed, now some lists are split in the wrong place</span>
<span class="comment-copy">I added the inputs and the correct output to my answer for you to use in testing. They're all converted to letters and numbers to make debugging easier.</span>
<span class="comment-copy">@Harvey Thanks again. I think I fixed it this time but there are difference with your reference answer, i.e., at <code>wrong_list_fixed[14]</code>. I am not sure this is right: <code>_x0</code> is included in <code>key_list</code> (or I mis-understood the problem)</span>
