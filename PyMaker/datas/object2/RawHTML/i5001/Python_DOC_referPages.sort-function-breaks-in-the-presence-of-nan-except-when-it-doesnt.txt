<div class="post-text" itemprop="text">
<p>I'm experimenting with NaN values and it turns out that sorting tuples containing NaN doesn't work very well.</p>
<pre><code>&gt;&gt;&gt; tuples = [(float('nan'), i) for i in range(7)]
... random.shuffle(tuples)
... sorted(tuples)
[(nan, 6), (nan, 0), (nan, 2), (nan, 5), (nan, 4), (nan, 3), (nan, 1)]
</code></pre>
<p>This kinda makes sense, considering that all comparison operations between NaN and NaN should return False, as explained in <a href="https://stackoverflow.com/questions/4240050/python-sort-function-breaks-in-the-presence-of-nan">this question</a>.</p>
<pre><code>&gt;&gt;&gt; float('nan') == float('nan') 
False
&gt;&gt;&gt; float('nan') &lt; float('nan') 
False
&gt;&gt;&gt; float('nan') &gt; float('nan') 
False
</code></pre>
<p>However, when I change my example slightly, it is suddenly possible to sort the list of tuples.</p>
<pre><code>&gt;&gt;&gt; nan = float('nan')
... tuples = [(nan, i) for i in range(7)]
... random.shuffle(tuples)
... sorted(tuples)
[(nan, 0), (nan, 1), (nan, 2), (nan, 3), (nan, 4), (nan, 5), (nan, 6)]

&gt;&gt;&gt; tuples #  it was really shuffled
[(nan, 6), (nan, 0), (nan, 2), (nan, 3), (nan, 1), (nan, 4), (nan, 5)]
</code></pre>
<p>What's going on here? Why is it possible to sort the list in the second example, but not the first one?</p>
</div>
<div class="post-text" itemprop="text">
<p>Tuple comparison assumes that the <code>&lt;</code>/<code>==</code>/<code>&gt;</code> operations on their elements are a valid <a href="https://en.wikipedia.org/wiki/Weak_ordering" rel="nofollow noreferrer">weak ordering</a>, and <a href="https://github.com/python/cpython/blob/v3.6.4/Objects/tupleobject.c#L603" rel="nofollow noreferrer">it compares elements</a> with <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a>, which assumes that <code>x is y</code> implies <code>x == y</code>. When you use the same NaN object for all tuples, <code>PyObject_RichCompareBool</code> thinks the NaNs are equal.</p>
</div>
<span class="comment-copy">I would guess that because all your <code>nan</code> are the same instance in the second example, the sort can figure out to regard them as equal. Perhaps there is an <code>x is y</code> shortcut in the sort code.</span>
<span class="comment-copy">Does that mean that PyObject_RichCompareBool breaks the IEEE754 floating point standard? I thought the definition required <code>NaN == NaN</code> to always be false? It is kinda weird that <code>nan is nan</code> can be true even though <code>nan == nan</code> is false.</span>
<span class="comment-copy">Adding explanation to intuition. Thanks.</span>
<span class="comment-copy">@HÃ¥kenLid: Most of the cases where PyObject_RichCompareBool is used are cases where the <code>x == x</code> assumption needs to hold for the operation to be meaningful. By trying to sort tuples with NaNs in them, you've already broken the preconditions of the sort operation. That said, there are probably cases where PyObject_RichCompareBool is used where it really shouldn't be.</span>
