<div class="post-text" itemprop="text">
<p>I wrote the following code in Python 3.6.4 to read a .csv file "Data.csv" in my directory and to copy the contents to a NamedTemporaryFile "temp_file"</p>
<pre><code>file_path= "Data.csv"
temp_file=NamedTemporaryFile(delete=False)
with open(file_path,"rb") as csvfile,temp_file:
    fieldnames=["id","Title","Desc","Comments"]
    reader=csv.DictReader(csvfile,fieldnames=fieldnames)
    writer=csv.DictWriter(temp_file,fieldnames=fieldnames)
    for row in reader:
        temp_row={"id":row["id"],"Title":row["Title"],"Desc":row["Desc"],"Comments":row["Comments"],}
        writer.writerow(temp_row)
        print(row)
</code></pre>
<p>Executing the above code gave an error in the iterator line(for row in reader):
The error said:</p>
<pre><code>_csv.Error: iterator should return strings, not bytes (did you open the file in text mode?)
</code></pre>
<p>I searched for a solution and found <a href="https://stackoverflow.com/questions/8515053/csv-error-iterator-should-return-strings-not-bytes">this answer</a></p>
<p>But this did not solve my problem as, when I changed "rb" to "rt", I started getting another error on the line </p>
<pre><code>writer.writerow(temp_row)
</code></pre>
<p>This error said: </p>
<pre><code>TypeError: a bytes-like object is required, not 'str'
</code></pre>
<p>I think this problem occurs only in Python 3 does not affect Python 2</p>
<p>I have already tried methods like <code>encode()</code>, <code>decode()</code> function to convert String to bytes and also some library functions like <code>json.dumps()</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You opened your file in binary mode:</p>
<pre><code>with open(file_path,"rb") as csvfile,temp_file:
    #                ^^ b is for binary
</code></pre>
<p>Don't do that. The error message tells you you should not do that, it specifically reminds you to open the file in text mode instead:</p>
<pre><code>(did you open the file in text mode?)
</code></pre>
<p>Remove the <code>b</code> from the file mode.</p>
<p>The <a href="https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile" rel="nofollow noreferrer"><code>NamedTemporaryFile()</code> class</a> also defaults to binary mode with <code>'w+b'</code>, you need to tell it to open the file in text mode instead; use either <code>'w+'</code> or <code>'w'</code>.</p>
<p>Corrected code:</p>
<pre><code>temp_file = NamedTemporaryFile(mode='w+', delete=False)
with open(file_path, "r") as csvfile, temp_file:
</code></pre>
<p>In Python 2, the <code>csv</code> module could only handle data in binary mode, partly because Python did not have strong Unicode support when the module was first created, and because in Python 2, text mode files on certain platforms translate line endings in a manner incompatible with the CSV standards.</p>
<p>In Python 3, it is <a href="https://docs.python.org/3/library/csv.html#id3" rel="nofollow noreferrer">strongly recommended</a> you switch off line ending translation by adding <code>newline=''</code> when opening files:</p>
<pre><code>temp_file = NamedTemporaryFile(mode='w+', newline='', delete=False)
with open(file_path, "r", newline='') as csvfile, temp_file:
</code></pre>
<p>I'd also strongly consider setting the encoding explicitly, rather than rely on the system defaults.</p>
<p>As a side note, there is no need to spell out all the column names when copying dictionaries across, nor do you have to even create a new dictionary for each row as the <code>DictReader()</code> and <code>DictWriter</code> <code>fieldnames</code> lists match. You can just pass the reader directly to the <code>DictWriter.writerows()</code> method:</p>
<pre><code>file_path = "Data.csv"
fieldnames = ["id", "Title", "Desc", "Comments"]
temp_file = NamedTemporaryFile(mode='w+', newline='', delete=False)
with open(file_path, "r", newline='') as csvfile, temp_file:
    reader = csv.DictReader(csvfile, fieldnames=fieldnames)
    writer = csv.DictWriter(temp_file, fieldnames=fieldnames)
    writer.writerows(reader)
</code></pre>
<p>at which point I do wonder if you didn't just want to use <a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="nofollow noreferrer"><code>shutil.copyfileob()</code></a> and just avoid parsing into dictionaries and then serialising back to CSV.</p>
</div>
<span class="comment-copy">Thank you for the comprehensive answer. It even cleared some additional questions. I use shututil.move(temp_file.name,filepath) so that this function can be used to update certain rows on the .csv file using id.</span>
