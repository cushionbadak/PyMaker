<div class="post-text" itemprop="text">
<p>I'm trying to speed up my BFS algorithm, that solves rush hour games. I feed the algorithm a parent board, and I'm wondering whether the implementation of my BFS algorithm or the building blocks used in my code that I call from the algorithm should change. </p>
<p>This is the BFS algorithm at the moment:</p>
<pre><code>def start_bfs(start_grid):
vehicle_dict = dict()
queue = deque()
queue.append(pd.DataFrame(start_grid))
while queue:
    vehicle_dict.clear()
    df_grid = queue.pop()
    vehicle_dict = set_up(vehicle_dict,df_grid)
    for key, value in vehicle_dict.iteritems():
        check_adjecent(key, value, vehicle_dict)
        movelist, object_location, direction = get_movelist(key, value, vehicle_dict, df_grid)
        if not movelist:
            continue
        while movelist:
                node = movelist.pop(0)
                new_vehicle_dict = move(node, copy.deepcopy(vehicle_dict), df_grid)
                child_df_grid = create_board(new_vehicle_dict)
                if not True in [child_df_grid.equals(x) for x in archive]:
                    check_goal(node[1], new_vehicle_dict, archive, df_grid, child_df_grid) 
                    queue.append(copy.deepcopy(child_df_grid))
                    archive.append(copy.deepcopy(child_df_grid))
        archive.append(copy.deepcopy(df_grid))
</code></pre>
<p>The start grid, for example, looks like this:</p>
<pre><code> start_grid = [['.', '.', 'T', 'F', 'F', 'E'],
         ['.', '.', 'T', '.', '.', 'E'],
         ['.', '.', 'T', 'R', 'R', 'E'],
         ['.', '.', '.', 'C', '.', '.'],
         ['A', 'B', 'B', 'C', '.', '.'],
         ['A', '.', '.', 'C', 'H', 'H']]
</code></pre>
<p>Is there something I'm doing inherently wrong here?</p>
</div>
<div class="post-text" itemprop="text">
<p>Do your <code>set_up(vehicle_dict,df_grid)</code>, <code>get_movelist(key, value, vehicle_dict, df_grid)</code>, and/or <code>move(node, copy.deepcopy(vehicle_dict), df_grid)</code> modify the <code>df_grid</code> passed into them? If not, I highly doubt many of those deep copies you're doing are necessary. You'll want to carefully check to make sure yourself, but I think the following lines dont need all those deep copies:</p>
<ul>
<li><code>queue.append(copy.deepcopy(child_df_grid))</code></li>
<li><code>archive.append(copy.deepcopy(child_df_grid))</code></li>
<li><code>archive.append(copy.deepcopy(df_grid))</code></li>
</ul>
<p>I think you can also move <code>archive.append(copy.deepcopy(df_grid))</code> to <em>before</em> the while loop, so that you can immediately discard moves that do nothing.</p>
<p>Checking whether you've seen a board before using </p>
<pre><code>if not True in [child_df_grid.equals(x) for x in archive]: 
</code></pre>
<p>also seems inefficient. What kind of object is <code>archive</code> anyway? I'd recommend using a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow noreferrer"><code>set</code></a> (<em>not</em> a list!). That may not work correctly if your boards are represented as <code>pd.DataFrame</code>s though (which also seems kind of overcomplicated at first glance here without seeing how your other functions are implemented). A simple custom class to contain your data, with <a href="https://stackoverflow.com/questions/15326985/how-to-implement-eq-for-set-inclusion-test">correctly implemented</a> <code>__eq__</code> and <code>__hash__</code> functions (required for set) would probably be better. Then you can efficiently check if something is truly new using:</p>
<pre><code>if not child_df_grid in archive:
</code></pre>
</div>
<span class="comment-copy">Archive is just a list, I'm going to try the set alternative.</span>
<span class="comment-copy">It's true that saving the boards as data frames is excessive. I wasn't aware of the extra computing time that a pd.dataframe could give</span>
<span class="comment-copy">Although, hashing a dict isn't possible either. I'm not sure if this will increase my computing time, for I'm working with dict and pd.dataframes</span>
<span class="comment-copy">Yeah hashing is problematic there, which is why I suggested building your own custom class to hold your data. I dont think it needs to be fancy, just a class wrapped around a simple matrix/nested lists, with a few supporting functions (like <code>__eq__</code> and <code>__hash__</code> and anything else you may find useful)</span>
