<div class="post-text" itemprop="text">
<p>In a comment on this <a href="https://stackoverflow.com/questions/306130/python-decorator-makes-function-forget-that-it-belongs-to-a-class#306277">answer to another question</a>, someone said that they weren't sure what <code>functools.wraps</code> was doing. So, I'm asking this question so that there will be a record of it on StackOverflow for future reference: what does <code>functools.wraps</code> do, exactly?</p>
</div>
<div class="post-text" itemprop="text">
<p>When you use a decorator, you're replacing one function with another.  In other words, if you have a decorator</p>
<pre><code>def logged(func):
    def with_logging(*args, **kwargs):
        print(func.__name__ + " was called")
        return func(*args, **kwargs)
    return with_logging
</code></pre>
<p>then when you say</p>
<pre><code>@logged
def f(x):
   """does some math"""
   return x + x * x
</code></pre>
<p>it's exactly the same as saying</p>
<pre><code>def f(x):
    """does some math"""
    return x + x * x
f = logged(f)
</code></pre>
<p>and your function <code>f</code> is replaced with the function with_logging.  Unfortunately, this means that if you then say</p>
<pre><code>print(f.__name__)
</code></pre>
<p>it will print <code>with_logging</code> because that's the name of your new function.  In fact, if you look at the docstring for <code>f</code>, it will be blank because <code>with_logging</code> has no docstring, and so the docstring you wrote won't be there anymore.  Also, if you look at the pydoc result for that function, it won't be listed as taking one argument <code>x</code>; instead it'll be listed as taking <code>*args</code> and <code>**kwargs</code> because that's what with_logging takes.</p>
<p>If using a decorator always meant losing this information about a function, it would be a serious problem.  That's why we have <code>functools.wraps</code>.  This takes a function used in a decorator and adds the functionality of copying over the function name, docstring, arguments list, etc.  And since <code>wraps</code> is itself a decorator, the following code does the correct thing:</p>
<pre><code>from functools import wraps
def logged(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + " was called")
        return func(*args, **kwargs)
    return with_logging

@logged
def f(x):
   """does some math"""
   return x + x * x

print(f.__name__)  # prints 'f'
print(f.__doc__)   # prints 'does some math'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I very often use classes, rather than functions, for my decorators.  I was having some trouble with this because an object won't have all the same attributes that are expected of a function.  For example, an object won't have the attribute <code>__name__</code>.  I had a specific issue with this that was pretty hard to trace where Django was reporting the error "object has no attribute '<code>__name__</code>'".  Unfortunately, for class-style decorators, I don't believe that @wrap will do the job.  I have instead created a base decorator class like so:</p>
<pre><code>class DecBase(object):
    func = None

    def __init__(self, func):
        self.__func = func

    def __getattribute__(self, name):
        if name == "func":
            return super(DecBase, self).__getattribute__(name)

        return self.func.__getattribute__(name)

    def __setattr__(self, name, value):
        if name == "func":
            return super(DecBase, self).__setattr__(name, value)

        return self.func.__setattr__(name, value)
</code></pre>
<p>This class proxies all the attribute calls over to the function that is being decorated.  So, you can now create a simple decorator that checks that 2 arguments are specified like so:</p>
<pre><code>class process_login(DecBase):
    def __call__(self, *args):
        if len(args) != 2:
            raise Exception("You can only specify two arguments")

        return self.func(*args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this is the source code about wraps:</p>
<pre><code>WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')

WRAPPER_UPDATES = ('__dict__',)

def update_wrapper(wrapper,
                   wrapped,
                   assigned = WRAPPER_ASSIGNMENTS,
                   updated = WRAPPER_UPDATES):

    """Update a wrapper function to look like the wrapped function

       wrapper is the function to be updated
       wrapped is the original function
       assigned is a tuple naming the attributes assigned directly
       from the wrapped function to the wrapper function (defaults to
       functools.WRAPPER_ASSIGNMENTS)
       updated is a tuple naming the attributes of the wrapper that
       are updated with the corresponding attribute from the wrapped
       function (defaults to functools.WRAPPER_UPDATES)
    """
    for attr in assigned:
        setattr(wrapper, attr, getattr(wrapped, attr))
    for attr in updated:
        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
    # Return the wrapper so this can be used as a decorator via partial()
    return wrapper

def wraps(wrapped,
          assigned = WRAPPER_ASSIGNMENTS,
          updated = WRAPPER_UPDATES):
    """Decorator factory to apply update_wrapper() to a wrapper function

   Returns a decorator that invokes update_wrapper() with the decorated
   function as the wrapper argument and the arguments to wraps() as the
   remaining arguments. Default arguments are as for update_wrapper().
   This is a convenience function to simplify applying partial() to
   update_wrapper().
    """
    return partial(update_wrapper, wrapped=wrapped,
                   assigned=assigned, updated=updated)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As of python 3.5+:</p>
<pre><code>@functools.wraps(f)
def g():
    pass
</code></pre>
<p>Is an alias for <code>g = functools.update_wrapper(g, f)</code>. It does exactly three things:</p>
<ul>
<li>it copies the <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__doc__</code>, and <code>__annotations__</code> attributes of <code>f</code> on <code>g</code>. This default list is in <code>WRAPPER_ASSIGNMENTS</code>, you can see it in the <a href="https://github.com/python/cpython/blob/master/Lib/functools.py" rel="nofollow noreferrer">functools source</a>.</li>
<li>it updates the <code>__dict__</code> of <code>g</code> with all elements from <code>f.__dict__</code>. (see <code>WRAPPER_UPDATES</code> in the source)</li>
<li>it sets a new <code>__wrapped__=f</code> attribute on <code>g</code></li>
</ul>
<p>The consequence is that <code>g</code> appears as having the same name, docstring, module name, and signature than <code>f</code>. The only problem is that concerning the signature this is not actually true: it is just that <code>inspect.signature</code> follows wrapper chains by default. You can check it by using <code>inspect.signature(g, follow_wrapped=False)</code> as explained in the <a href="https://docs.python.org/3/library/inspect.html#inspect.signature" rel="nofollow noreferrer">doc</a>. This has annoying consequences:</p>
<ul>
<li>the wrapper code will execute even when the provided arguments are invalid.</li>
<li>the wrapper code can not easily access an argument using its name, from the received *args, **kwargs. Indeed one would have to handle all cases (positional, keyword, default) and therefore to use something like <code>Signature.bind()</code>.</li>
</ul>
<p>Now there is a bit of confusion between <code>functools.wraps</code> and decorators, because a very frequent use case for developing decorators is to wrap functions. But both are completely independent concepts. If you're interested in understanding the difference, I implemented helper libraries for both: <a href="https://smarie.github.io/python-decopatch/" rel="nofollow noreferrer">decopatch</a> to write decorators easily, and <a href="https://smarie.github.io/python-makefun/" rel="nofollow noreferrer">makefun</a> to provide a signature-preserving replacement for <code>@wraps</code>. Note that <code>makefun</code> relies on the same proven trick than the famous <code>decorator</code> library.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Prerequisite: You must know how to use decorators and specially with wraps. This <a href="https://stackoverflow.com/a/309000/4098813">comment</a> explains it a bit clear or this <a href="https://realpython.com/blog/python/primer-on-python-decorators/" rel="nofollow noreferrer">link</a> also explains it pretty well.</p></li>
<li><p>Whenever we use For eg: @wraps followed by our own wrapper function. As per the details given in this <a href="https://docs.python.org/2/library/functools.html" rel="nofollow noreferrer">link</a> , it says that</p></li>
</ol>
<blockquote>
<p>functools.wraps is convenience function for invoking update_wrapper() as a function decorator, when defining a wrapper function. </p>
<p>It is equivalent to partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated).</p>
</blockquote>
<p>So @wraps decorator actually gives a call to  functools.partial(func[,*args][, **keywords]).</p>
<p>The functools.partial() definition says that </p>
<blockquote>
<p>The partial() is used for partial function application which “freezes” some portion of a function’s arguments and/or keywords resulting in a new object with a simplified signature. For example, partial() can be used to create a callable that behaves like the int() function where the base argument defaults to two: </p>
</blockquote>
<pre><code>&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; basetwo = partial(int, base=2)
&gt;&gt;&gt; basetwo.__doc__ = 'Convert base 2 string to an int.'
&gt;&gt;&gt; basetwo('10010')
18
</code></pre>
<p>Which brings me to the conclusion that, @wraps gives a call to partial() and it passes your wrapper function as a parameter to it. The partial() in the end returns the simplified version i.e the object of what's inside the wrapper function and not the wrapper function itself.</p>
</div>
<div class="post-text" itemprop="text">
<p>In short, <strong>functools.wraps</strong> is just a regular function. Let's consider <a href="https://docs.python.org/2/library/functools.html#functools.wraps" rel="nofollow noreferrer">this official example</a>. With the help of the <a href="https://github.com/python/cpython/blob/521995205a2cb6b504fe0e39af22a81f785350a3/Lib/functools.py#L67" rel="nofollow noreferrer">source code</a>, we can see more details about the implementation and the running steps as follows:</p>
<ol>
<li><strong>wraps(f)</strong> returns an object, say <strong>O1</strong>. It is an object of the <a href="https://github.com/python/cpython/blob/521995205a2cb6b504fe0e39af22a81f785350a3/Lib/functools.py#L234" rel="nofollow noreferrer"><strong>class Partial</strong></a></li>
<li>The next step is <strong>@O1...</strong> which is the decorator notation in python. It means </li>
</ol>
<blockquote>
<p><strong>wrapper=O1.__call__(wrapper)</strong></p>
</blockquote>
<p>Checking the implementation of <a href="https://github.com/python/cpython/blob/521995205a2cb6b504fe0e39af22a81f785350a3/Lib/functools.py#L266" rel="nofollow noreferrer"><strong>__call__</strong></a>, we see that after this step, (the left hand side )<strong>wrapper</strong> becomes the object resulted by <strong>self.func(*self.args, *args, **newkeywords)</strong> Checking the creation of <strong>O1</strong> in <strong>__new__</strong>, we know <strong>self.func</strong> is the function <strong>update_wrapper</strong>. It uses the parameter <strong>*args</strong>, the right hand side <strong>wrapper</strong>, as its 1st parameter. Checking the last step of <strong>update_wrapper</strong>, one can see the right hand side <strong>wrapper</strong> is returned, with some of attributes modified as needed. </p>
</div>
<span class="comment-copy">Yep, I prefer to avoid the decorator module since functools.wraps is part of the standard library and thus doesn't introduce another external dependency.  But the decorator module does indeed solve the help problem, which hopefully functools.wraps someday will as well.</span>
<span class="comment-copy">here's an example of what can happen if you don't use wraps: doctools tests can suddenly disappear.  that's because doctools cannot find the tests in decorated functions unless something like wraps() has copied them across.</span>
<span class="comment-copy">why do we need <code>functools.wraps</code> for this job, shouldn't it just be part of the decorator pattern in the first place?  when would you <i>not</i> want to use @wraps ?</span>
<span class="comment-copy">@wim: I've written some decorators which do their own version of <code>@wraps</code> in order to perform various types of modification or annotation on the values copied over. Fundamentally, it's an extension of the Python philosophy that explicit is better than implicit and special cases aren't special enough to break the rules. (The code is much simpler and the language easier to understand if <code>@wraps</code> must be provided manually, rather than using some kind of special opt-out mechanism.)</span>
<span class="comment-copy">@LucasMalor Not all decorators wrap the functions they decorate. Some apply side-effects, such as registering them in some kind of lookup system.</span>
<span class="comment-copy">As the docs from <code>@wraps</code> says, <code>@wraps</code> is just a convenience function to <code>functools.update_wrapper()</code>. In case of class decorator, you can call <code>update_wrapper()</code> directly from your <code>__init__()</code> method. So, you don't need to create <code>DecBase</code> at all, you can just include on <code>__init__()</code> of <code>process_login</code> the line: <code>update_wrapper(self, func)</code>. That's all.</span>
