<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3755136/pythonic-way-to-check-if-a-list-is-sorted-or-not">Pythonic way to check if a list is sorted or not</a>
<span class="question-originals-answer-count">
                    19 answers
                </span>
</li>
</ul>
</div>
<p>I have a function named checker(nums) that has an argument that will later receive a list. What i want to do with that list is to check if each other element is greater or equal to the previous one.
Example:
I have a list <code>[1, 1, 2, 2, 3]</code> and i have to check if it fulfills the condition.
Since it does, the function should return <code>True</code></p>
<p>My code:</p>
<pre><code>def checker(nums):
    for x in range(len(nums)):
        if x+1&lt;len(nums):
            if nums[x] &lt;= nums[x+1] and nums[-1] &gt;= nums[-2]:
                return True
</code></pre>
<p>This will only run once and return True if the first condition is true.
I've seen a statement if all and am unsure of how to use it.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your function can be reduced to this:</p>
<pre><code>def checker(nums):
    return all(i &lt;= j for i, j in zip(nums, nums[1:]))
</code></pre>
<p>Note the following:</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a> loops through its arguments in parallel, i.e. <code>nums[0]</code> &amp; <code>nums[1]</code> are retrieved, then <code>nums[1]</code> &amp; <code>nums[2]</code> etc.</li>
<li><code>i &lt;= j</code> performs the actual comparison.</li>
<li>The <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> denoted by parentheses <code>()</code> ensures that each value of the condition, i.e. <code>True</code> or <code>False</code> is extracted one at a time. This is called <em>lazy evaluation</em>.</li>
<li><a href="https://docs.python.org/3/library/functions.html#all" rel="nofollow noreferrer"><code>all</code></a> simply checks all the values are <code>True</code>. Again, this is lazy. If one of the values extracted lazily from the generator expression is <code>False</code>, it short-circuits and returns <code>False</code>.</li>
</ul>
<h3>Alternatives</h3>
<p>To avoid the expense of building a list for the second argument of <code>zip</code>, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow noreferrer"><code>itertools.islice</code></a>. This option is particularly useful when your input is an iterator, i.e. it cannot be sliced like a <code>list</code>.</p>
<pre><code>from itertools import islice

def checker(nums):
    return all(i &lt;= j for i, j in zip(nums, islice(nums, 1, None)))
</code></pre>
<p>Another iterator-friendly option is to use the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>pairwise</code> recipe</a>, also available via 3rd party <a href="https://more-itertools.readthedocs.io/en/latest/_modules/more_itertools/recipes.html#pairwise" rel="nofollow noreferrer"><code>more_itertools.pairwise</code></a>:</p>
<pre><code># from more_itertools import pairwise  # 3rd party library alternative
from itertools import tee

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

def checker(nums):
    return all(i &lt;= j for i, j in pairwise(nums))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code can in fact be reduced to checking if <code>nums</code> is sorted, e.g.</p>
<pre><code>def checker(nums):
    return sorted(nums) == nums
</code></pre>
<p>This does exactly what you expect, e.g.</p>
<pre><code>&gt;&gt;&gt; checker([1, 1, 2, 2, 3])
True
&gt;&gt;&gt; checker([1, 1, 2, 2, 1])
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Similar solution to @jp_data_analysis using <a href="http://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.windowed" rel="nofollow noreferrer"><code>more_itertools.windowed</code></a></p>
<pre><code>&gt;&gt;&gt; from more_itertools import windowed
&gt;&gt;&gt; nums = [1, 1, 2, 2, 3]
&gt;&gt;&gt; all(i &lt;= j for i, j in windowed(nums, 2))
True
</code></pre>
<hr/>
<p>And for scientific purposes (not recommended code), here is a more functional approach</p>
<pre><code>&gt;&gt;&gt; from operator import le
&gt;&gt;&gt; from itertools import starmap
&gt;&gt;&gt; all(starmap(le, windowed(nums, 2)))
True
</code></pre>
</div>
<span class="comment-copy">Downside is that this solution is O(N log N). Upside is simplicity</span>
<span class="comment-copy">This is only partially true. If the list is sorted, this is in fact only O(n), see e.g. <a href="https://stackoverflow.com/questions/23809785/python-sorting-complexity-on-sorted-list" title="python sorting complexity on sorted list">stackoverflow.com/questions/23809785/â€¦</a>. But sure, the worst case complexity is O(n log n).</span>
<span class="comment-copy">You're wrong,  that's not "partially true", I only referred to Worst Case. I never once talked about best case or average case. If I was talking about best case I would have used the correct symbol. And the reason why we are doing this check is because sometimes the list is not sorted, therefore it is O(N log N)</span>
