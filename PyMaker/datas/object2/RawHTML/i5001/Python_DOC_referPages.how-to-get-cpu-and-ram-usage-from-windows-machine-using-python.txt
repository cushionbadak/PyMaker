<div class="post-text" itemprop="text">
<p>What's your preferred way of getting current system status (current CPU, RAM, free disk space, etc.) in Python? Bonus points for *nix and Windows platforms.</p>
<p>There seems to be a few possible ways of extracting that from my search:</p>
<ol>
<li><p>Using a library such as <a href="http://www.psychofx.com/psi/trac/wiki/">PSI</a> (that currently seems not actively developed and not supported on multiple platform) or something like <a href="http://www.i-scream.org/pystatgrab/">pystatgrab</a> (again no activity since 2007 it seems and no support for Windows).</p></li>
<li><p>Using platform specific code such as using a <code>os.popen("ps")</code> or similar for the *nix systems and <code>MEMORYSTATUS</code> in <code>ctypes.windll.kernel32</code> (see <a href="http://code.activestate.com/recipes/511491/">this recipe on ActiveState</a>) for the Windows platform. One could put a Python class together with all those code snippets.</p></li>
</ol>
<p>It's not that those methods are bad but is there already a well-supported, multi-platform way of doing the same thing?</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://pypi.python.org/pypi/psutil" rel="noreferrer">The psutil library</a> will give you some system information (CPU / Memory usage) on a variety of platforms:</p>
<blockquote>
<p>psutil is a module providing an interface for retrieving information on running processes and system utilization (CPU, memory) in a portable way by using Python, implementing many functionalities offered by tools like ps, top  and Windows task manager.</p>
<p>It currently supports Linux, Windows, OSX, Sun Solaris, FreeBSD, OpenBSD and NetBSD, both 32-bit and 64-bit architectures, with Python versions from 2.6 to 3.5 (users of Python 2.4 and 2.5 may use 2.1.3 version).</p>
</blockquote>
<hr/>
<p>UPDATE: Here is some example usages of <code>psutil</code>:</p>
<pre><code>#!/usr/bin/env python
import psutil
# gives a single float value
psutil.cpu_percent()
# gives an object with many fields
psutil.virtual_memory()
# you can convert that object to a dictionary 
dict(psutil.virtual_memory()._asdict())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://pypi.org/project/psutil/" rel="nofollow noreferrer">psutil library</a>.  On Ubuntu 18.04, pip installed 5.5.0 (latest version) as of 1-30-2019.  Older versions may behave somewhat differently. 
 You can check your version of psutil by doing this in Python:</p>
<pre><code>from __future__ import print_function  # for Python2
import psutil
print(psutil.__versi‌​on__)
</code></pre>
<p>To get some memory and CPU stats:</p>
<pre><code>from __future__ import print_function
import psutil
print(psutil.cpu_percent())
print(psutil.virtual_memory())  # physical memory usage
print('memory % used:', psutil.virtual_memory()[2])
</code></pre>
<p>The <code>virtual_memory</code> (tuple) will have the percent memory used system-wide.  This seemed to be overestimated by a few percent for me on Ubuntu 18.04.</p>
<p>You can also get the memory used by the current Python instance:</p>
<pre><code>import os
import psutil
pid = os.getpid()
py = psutil.Process(pid)
memoryUse = py.memory_info()[0]/2.**30  # memory use in GB...I think
print('memory use:', memoryUse)
</code></pre>
<p>which gives the current memory use of your Python script.</p>
<p>There are some more in-depth examples on the <a href="https://pypi.org/project/psutil/" rel="nofollow noreferrer">pypi page for psutil</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Below codes, without external libraries worked for me. I tested at Python 2.7.9</p>
<p><strong>CPU Usage</strong></p>
<pre><code>import os

    CPU_Pct=str(round(float(os.popen('''grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage }' ''').readline()),2))

    #print results
    print("CPU Usage = " + CPU_Pct)
</code></pre>
<p><strong>And Ram Usage, Total, Used and Free</strong></p>
<pre><code>import os
mem=str(os.popen('free -t -m').readlines())
"""
Get a whole line of memory output, it will be something like below
['             total       used       free     shared    buffers     cached\n', 
'Mem:           925        591        334         14         30        355\n', 
'-/+ buffers/cache:        205        719\n', 
'Swap:           99          0         99\n', 
'Total:        1025        591        434\n']
 So, we need total memory, usage and free memory.
 We should find the index of capital T which is unique at this string
"""
T_ind=mem.index('T')
"""
Than, we can recreate the string with this information. After T we have,
"Total:        " which has 14 characters, so we can start from index of T +14
and last 4 characters are also not necessary.
We can create a new sub-string using this information
"""
mem_G=mem[T_ind+14:-4]
"""
The result will be like
1025        603        422
we need to find first index of the first space, and we can start our substring
from from 0 to this index number, this will give us the string of total memory
"""
S1_ind=mem_G.index(' ')
mem_T=mem_G[0:S1_ind]
"""
Similarly we will create a new sub-string, which will start at the second value. 
The resulting string will be like
603        422
Again, we should find the index of first space and than the 
take the Used Memory and Free memory.
"""
mem_G1=mem_G[S1_ind+8:]
S2_ind=mem_G1.index(' ')
mem_U=mem_G1[0:S2_ind]

mem_F=mem_G1[S2_ind+8:]
print 'Summary = ' + mem_G
print 'Total Memory = ' + mem_T +' MB'
print 'Used Memory = ' + mem_U +' MB'
print 'Free Memory = ' + mem_F +' MB'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One-liner for the RAM usage with only stdlib dependency:</p>
<pre><code>import os
tot_m, used_m, free_m = map(int, os.popen('free -t -m').readlines()[-1].split()[1:])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's something I put together a while ago, it's windows only but may help you get part of what you need done.</p>
<p>Derived from:
"for sys available mem"
<a href="http://msdn2.microsoft.com/en-us/library/aa455130.aspx" rel="noreferrer">http://msdn2.microsoft.com/en-us/library/aa455130.aspx</a></p>
<p>"individual process information and python script examples"
<a href="http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true" rel="noreferrer">http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true</a></p>
<p>NOTE: the WMI interface/process is also available for performing similar tasks
        I'm not using it here because the current method covers my needs, but if someday it's needed to extend or improve this, then may want to investigate the WMI tools a vailable.</p>
<p>WMI for python:</p>
<p><a href="http://tgolden.sc.sabren.com/python/wmi.html" rel="noreferrer">http://tgolden.sc.sabren.com/python/wmi.html</a></p>
<p>The code:</p>
<pre><code>'''
Monitor window processes

derived from:
&gt;for sys available mem
http://msdn2.microsoft.com/en-us/library/aa455130.aspx

&gt; individual process information and python script examples
http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true

NOTE: the WMI interface/process is also available for performing similar tasks
        I'm not using it here because the current method covers my needs, but if someday it's needed
        to extend or improve this module, then may want to investigate the WMI tools available.
        WMI for python:
        http://tgolden.sc.sabren.com/python/wmi.html
'''

__revision__ = 3

import win32com.client
from ctypes import *
from ctypes.wintypes import *
import pythoncom
import pywintypes
import datetime


class MEMORYSTATUS(Structure):
    _fields_ = [
                ('dwLength', DWORD),
                ('dwMemoryLoad', DWORD),
                ('dwTotalPhys', DWORD),
                ('dwAvailPhys', DWORD),
                ('dwTotalPageFile', DWORD),
                ('dwAvailPageFile', DWORD),
                ('dwTotalVirtual', DWORD),
                ('dwAvailVirtual', DWORD),
                ]


def winmem():
    x = MEMORYSTATUS() # create the structure
    windll.kernel32.GlobalMemoryStatus(byref(x)) # from cytypes.wintypes
    return x    


class process_stats:
    '''process_stats is able to provide counters of (all?) the items available in perfmon.
    Refer to the self.supported_types keys for the currently supported 'Performance Objects'

    To add logging support for other data you can derive the necessary data from perfmon:
    ---------
    perfmon can be run from windows 'run' menu by entering 'perfmon' and enter.
    Clicking on the '+' will open the 'add counters' menu,
    From the 'Add Counters' dialog, the 'Performance object' is the self.support_types key.
    --&gt; Where spaces are removed and symbols are entered as text (Ex. # == Number, % == Percent)
    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,
    keyed by the 'Performance Object' name as mentioned above.
    ---------

    NOTE: The 'NETFramework_NETCLRMemory' key does not seem to log dotnet 2.0 properly.

    Initially the python implementation was derived from:
    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true
    '''
    def __init__(self,process_name_list=[],perf_object_list=[],filter_list=[]):
        '''process_names_list == the list of all processes to log (if empty log all)
        perf_object_list == list of process counters to log
        filter_list == list of text to filter
        print_results == boolean, output to stdout
        '''
        pythoncom.CoInitialize() # Needed when run by the same process in a thread

        self.process_name_list = process_name_list
        self.perf_object_list = perf_object_list
        self.filter_list = filter_list

        self.win32_perf_base = 'Win32_PerfFormattedData_'

        # Define new datatypes here!
        self.supported_types = {
                                    'NETFramework_NETCLRMemory':    [
                                                                        'Name',
                                                                        'NumberTotalCommittedBytes',
                                                                        'NumberTotalReservedBytes',
                                                                        'NumberInducedGC',    
                                                                        'NumberGen0Collections',
                                                                        'NumberGen1Collections',
                                                                        'NumberGen2Collections',
                                                                        'PromotedMemoryFromGen0',
                                                                        'PromotedMemoryFromGen1',
                                                                        'PercentTimeInGC',
                                                                        'LargeObjectHeapSize'
                                                                     ],

                                    'PerfProc_Process':              [
                                                                          'Name',
                                                                          'PrivateBytes',
                                                                          'ElapsedTime',
                                                                          'IDProcess',# pid
                                                                          'Caption',
                                                                          'CreatingProcessID',
                                                                          'Description',
                                                                          'IODataBytesPersec',
                                                                          'IODataOperationsPersec',
                                                                          'IOOtherBytesPersec',
                                                                          'IOOtherOperationsPersec',
                                                                          'IOReadBytesPersec',
                                                                          'IOReadOperationsPersec',
                                                                          'IOWriteBytesPersec',
                                                                          'IOWriteOperationsPersec'     
                                                                      ]
                                }

    def get_pid_stats(self, pid):
        this_proc_dict = {}

        pythoncom.CoInitialize() # Needed when run by the same process in a thread
        if not self.perf_object_list:
            perf_object_list = self.supported_types.keys()

        for counter_type in perf_object_list:
            strComputer = "."
            objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator")
            objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2")

            query_str = '''Select * from %s%s''' % (self.win32_perf_base,counter_type)
            colItems = objSWbemServices.ExecQuery(query_str) # "Select * from Win32_PerfFormattedData_PerfProc_Process")# changed from Win32_Thread        

            if len(colItems) &gt; 0:        
                for objItem in colItems:
                    if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:

                            for attribute in self.supported_types[counter_type]:
                                eval_str = 'objItem.%s' % (attribute)
                                this_proc_dict[attribute] = eval(eval_str)

                            this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]
                            break

        return this_proc_dict      


    def get_stats(self):
        '''
        Show process stats for all processes in given list, if none given return all processes   
        If filter list is defined return only the items that match or contained in the list
        Returns a list of result dictionaries
        '''    
        pythoncom.CoInitialize() # Needed when run by the same process in a thread
        proc_results_list = []
        if not self.perf_object_list:
            perf_object_list = self.supported_types.keys()

        for counter_type in perf_object_list:
            strComputer = "."
            objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator")
            objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2")

            query_str = '''Select * from %s%s''' % (self.win32_perf_base,counter_type)
            colItems = objSWbemServices.ExecQuery(query_str) # "Select * from Win32_PerfFormattedData_PerfProc_Process")# changed from Win32_Thread

            try:  
                if len(colItems) &gt; 0:
                    for objItem in colItems:
                        found_flag = False
                        this_proc_dict = {}

                        if not self.process_name_list:
                            found_flag = True
                        else:
                            # Check if process name is in the process name list, allow print if it is
                            for proc_name in self.process_name_list:
                                obj_name = objItem.Name
                                if proc_name.lower() in obj_name.lower(): # will log if contains name
                                    found_flag = True
                                    break

                        if found_flag:
                            for attribute in self.supported_types[counter_type]:
                                eval_str = 'objItem.%s' % (attribute)
                                this_proc_dict[attribute] = eval(eval_str)

                            this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]
                            proc_results_list.append(this_proc_dict)

            except pywintypes.com_error, err_msg:
                # Ignore and continue (proc_mem_logger calls this function once per second)
                continue
        return proc_results_list     


def get_sys_stats():
    ''' Returns a dictionary of the system stats'''
    pythoncom.CoInitialize() # Needed when run by the same process in a thread
    x = winmem()

    sys_dict = { 
                    'dwAvailPhys': x.dwAvailPhys,
                    'dwAvailVirtual':x.dwAvailVirtual
                }
    return sys_dict


if __name__ == '__main__':
    # This area used for testing only
    sys_dict = get_sys_stats()

    stats_processor = process_stats(process_name_list=['process2watch'],perf_object_list=[],filter_list=[])
    proc_results = stats_processor.get_stats()

    for result_dict in proc_results:
        print result_dict

    import os
    this_pid = os.getpid()
    this_proc_results = stats_processor.get_pid_stats(this_pid)

    print 'this proc results:'
    print this_proc_results
</code></pre>
<p><a href="http://monkut.webfactional.com/blog/archive/2009/1/21/windows-process-memory-logging-python" rel="noreferrer">http://monkut.webfactional.com/blog/archive/2009/1/21/windows-process-memory-logging-python</a></p>
</div>
<div class="post-text" itemprop="text">
<p>"... current system status (current CPU, RAM, free disk space, etc.)"  And "*nix and Windows platforms" can be a difficult combination to achieve.</p>
<p>The operating systems are fundamentally different in the way they manage these resources.  Indeed, they differ in core concepts like defining what counts as system and what counts as application time.</p>
<p>"Free disk space"?  What counts as "disk space?"  All partitions of all devices?  What about foreign partitions in a multi-boot environment?</p>
<p>I don't think there's a clear enough consensus between Windows and *nix that makes this possible.  Indeed, there may not even be any consensus between the various operating systems called Windows.  Is there a single Windows API that works for both XP and Vista?</p>
</div>
<div class="post-text" itemprop="text">
<p>I feel like these answers were written for Python 2, and in any case nobody's made mention of the standard <a href="https://docs.python.org/3/library/resource.html" rel="nofollow noreferrer"><code>resource</code></a> package that's available for Python 3. It provides commands for obtaining the resource <em>limits</em> of a given process (the calling Python process by default). This isn't the same as getting the current <em>usage</em> of resources by the system as a whole, but it could solve some of the same problems like e.g. "I want to make sure I only use X much RAM with this script."</p>
</div>
<div class="post-text" itemprop="text">
<p>We chose to use usual information source for this because we could find instantaneous fluctuations in free memory and felt querying the <strong>meminfo</strong> data source was helpful.  This also helped us get a few more related parameters that were pre-parsed.</p>
<p><strong>Code</strong></p>
<pre><code>import os
....
memory_usage = os.popen("cat /proc/meminfo").read()
</code></pre>
<p><strong>Output for reference</strong> (we stripped all newlines for further analysis)</p>
<blockquote>
<p>MemTotal: 1014500 kB MemFree: 562680 kB MemAvailable: 646364 kB
  Buffers: 15144 kB Cached: 210720 kB SwapCached: 0 kB Active: 261476 kB
  Inactive: 128888 kB Active(anon): 167092 kB Inactive(anon): 20888 kB
  Active(file): 94384 kB Inactive(file): 108000 kB Unevictable: 3652 kB
  Mlocked: 3652 kB SwapTotal: 0 kB SwapFree: 0 kB Dirty: 0 kB Writeback:
  0 kB AnonPages: 168160 kB Mapped: 81352 kB Shmem: 21060 kB Slab: 34492
  kB SReclaimable: 18044 kB SUnreclaim: 16448 kB KernelStack: 2672 kB
  PageTables: 8180 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB
  CommitLimit: 507248 kB Committed_AS: 1038756 kB VmallocTotal:
  34359738367 kB VmallocUsed: 0 kB VmallocChunk: 0 kB HardwareCorrupted:
  0 kB AnonHugePages: 88064 kB CmaTotal: 0 kB CmaFree: 0 kB
  HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp:
  0 Hugepagesize: 2048 kB DirectMap4k: 43008 kB DirectMap2M: 1005568 kB</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This script for CPU usage:</p>
<pre><code>import os

def get_cpu_load():
    """ Returns a list CPU Loads"""
    result = []
    cmd = "WMIC CPU GET LoadPercentage "
    response = os.popen(cmd + ' 2&gt;&amp;1','r').read().strip().split("\r\n")
    for load in response[1:]:
       result.append(int(load))
    return result

if __name__ == '__main__':
    print get_cpu_load()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use psutil or psmem with subprocess
example code </p>
<pre><code>import subprocess
cmd =   subprocess.Popen(['sudo','./ps_mem'],stdout=subprocess.PIPE,stderr=subprocess.PIPE) 
out,error = cmd.communicate() 
memory = out.splitlines()
</code></pre>
<p>Reference  <a href="http://techarena51.com/index.php/how-to-install-python-3-and-flask-on-linux/" rel="nofollow">http://techarena51.com/index.php/how-to-install-python-3-and-flask-on-linux/</a></p>
<p><a href="https://github.com/Leo-g/python-flask-cmd" rel="nofollow">https://github.com/Leo-g/python-flask-cmd</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the cpu usage code by @Hrabal, this is what I use:</p>
<pre><code>from subprocess import Popen, PIPE

def get_cpu_usage():
    ''' Get CPU usage on Linux by reading /proc/stat '''

    sub = Popen(('grep', 'cpu', '/proc/stat'), stdout=PIPE, stderr=PIPE)
    top_vals = [int(val) for val in sub.communicate()[0].split('\n')[0].split[1:5]]

    return (top_vals[0] + top_vals[2]) * 100. /(top_vals[0] + top_vals[2] + top_vals[3])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't believe that there is a well-supported multi-platform library available. Remember that Python itself is written in C so any library is simply going to make a smart decision about which OS-specific code snippet to run, as you suggested above. </p>
</div>
<span class="comment-copy">You could build your own multiplatform library by using dynamic imports: "if sys.platform == 'win32': import win_sysstatus as sysstatus; else" ...</span>
<span class="comment-copy">It would be cool to have something that works on App Engine too.</span>
<span class="comment-copy">Is the age of the packages significant? If someone got them right first time, why wouldn't they still be right?</span>
<span class="comment-copy">Worked for me on OSX: <code>$ pip install psutil</code>; <code>&gt;&gt;&gt; import psutil; psutil.cpu_percent()</code> and <code>&gt;&gt;&gt; psutil.virtual_memory()</code> which returns a nice vmem object: <code>vmem(total=8589934592L, available=4073336832L, percent=52.6, used=5022085120L, free=3560255488L, active=2817949696L, inactive=513081344L, wired=1691054080L)</code></span>
<span class="comment-copy">How would one do this without the psutil library?</span>
<span class="comment-copy">@user1054424 There is a builtin library in python called <a href="https://docs.python.org/2/library/resource.html" rel="nofollow noreferrer">resource</a>. However, it seems the most you can do with it is grab the memory that a single python process is using and/or it's child processes. It also doesn't seem very accurate. A quick test showed <b>resource</b> being off by about 2MB from my mac's utility tool.</span>
<span class="comment-copy">@BigBrownBear00 just check source of psutil ;)</span>
<span class="comment-copy">you have a typo in the string "psutil.virtual_memory()`"</span>
<span class="comment-copy">Don't you think the <code>grep</code> and <code>awk</code> would be better taken care of by string processing in Python?</span>
<span class="comment-copy">Personally not familiar with awk, made an awkless version of the cpu usage snippet below. Very handy, thanks!</span>
<span class="comment-copy">It's disingenuous to say that this code does not use external libraries. In fact, these have a hard dependency on the availability of grep, awk and free. This makes the code above non-portable. The OP stated "Bonus points for *nix and Windows platforms."</span>
<span class="comment-copy">elegant, simple, efficient.</span>
<span class="comment-copy">Your link is broken.</span>
<span class="comment-copy">yep. the link is broken now.</span>
<span class="comment-copy">Use GlobalMemoryStatusEx instead of GlobalMemoryStatus because the old one can return bad values.</span>
<span class="comment-copy">You should avoid <code>from x import *</code> statements! They clutter the main-namespace and overwrite other functions and variables.</span>
<span class="comment-copy"><code>df -h</code> answers the "disk space" question both on Windows and *nix.</span>
<span class="comment-copy">@J.F.Sebastian: Which Windows?  I get a 'df' is not recognized... error message from Windows XP Pro.  What am I missing?</span>
<span class="comment-copy">you can install new programs on Windows too.</span>
<span class="comment-copy">Why was this answer downvoted? Is this statement false?</span>
<span class="comment-copy">because psutil is a well-supported multi-platform library that suits the ops needs possibly</span>
