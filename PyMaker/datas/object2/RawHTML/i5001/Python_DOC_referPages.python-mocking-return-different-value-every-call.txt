<div class="post-text" itemprop="text">
<p>I am testing a method, <code>geodata_collect._request_loc_data()</code>, and within that method I call another method, <code>geodata_collect.utils.loadJSON(...)</code> which I need to mock in order to unit-test the first mentioned method. </p>
<p>My problem is that I need <code>geodata_collect.utils.loadJSON(...)</code> to return a different value the third time it is called from within <code>geodata_collect._request_loc_data()</code>.</p>
<p>I have been exploring <code>MagicMock</code> and <code>side_effect</code> in order to do this.</p>
<pre><code>mock = MagicMock()
mock.side_effect = [self._create_request_dict(next_page_token=True),
    self._create_request_dict(next_page_token=True), self._create_request_dict()]

with patch('geodata_collect.utils.loadJSON',return_value=mock):
    geodata_collect._request_loc_data()
</code></pre>
<p>However, when <code>geodata_collect.utils.loadJSON(...)</code> is called from within <code>geodata_collect._request_loc_data()</code> the MagicMock class is returned, instead of the actual value.</p>
<pre><code>&lt;MagicMock id='140642209064888'&gt;
</code></pre>
<p>What should be returned:</p>
<pre><code>{'status': 'OK', 'next_page_token': 'Next Page EXISTS!!', 'result': [1, 2, 3, 4, 5]}
{'status': 'OK', 'next_page_token': 'Next Page EXISTS!!', 'result': [1, 2, 3, 4, 5]}
{'status': 'OK', 'result': [1, 2, 3, 4, 5]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have set the return value of the call to a mock object. So thatâ€™s what will be returned! You set return values (side effects) for calls to that call result, so <code>geodata_collect.utils.loadJSON()()</code>. </p>
<p>Set the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow noreferrer"><code>side_effect</code> argument in the <code>patch()</code> call</a>:</p>
<pre><code>results = [
    self._create_request_dict(next_page_token=True),
    self._create_request_dict(next_page_token=True),
    self._create_request_dict()]

with patch('geodata_collect.utils.loadJSON', side_effect=results):
    geodata_collect._request_loc_data()
</code></pre>
<p>Or the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect" rel="nofollow noreferrer"><code>side_effect</code> attribute</a> on the mock object returned when entering the context manager:</p>
<pre><code>with patch('geodata_collect.utils.loadJSON', side_effect=results) as load_mock:
    load_mock.side_effect = [
        self._create_request_dict(next_page_token=True),
        self._create_request_dict(next_page_token=True),
        self._create_request_dict()]
    geodata_collect._request_loc_data()
</code></pre>
<p>Capturing the mock object the <code>patch()</code> context manager creates with <code>as &lt;name&gt;</code> is generally a good idea anyway as you now have access to it to assert if it was called. </p>
<p>You can also pass in the <code>MagicMock</code> instance you created up front, just pass it in as the second argument, or use the name <code>new</code>:</p>
<pre><code>mock = MagicMock()
mock.side_effect = [self._create_request_dict(next_page_token=True),
    self._create_request_dict(next_page_token=True), self._create_request_dict()]

with patch('geodata_collect.utils.loadJSON', mock):  # or new=mock
    geodata_collect._request_loc_data()
</code></pre>
<p><code>patch()</code> will then replace <code>geodata_collect.utils.loadJSON</code> with that instance, and calling it will use the <code>side_effect</code> list set.</p>
</div>
<span class="comment-copy">Please provide a proper MCVE that demonstrates the issue. The more likely explanation is that you are printing the result of a different mock call. What does <code>print(mock.called())</code>  produce, for instance?</span>
<span class="comment-copy">Also, I'd use <code>with patch('geodata_collect.utils.loadJSON') as mock:</code>, then set <code>mock.return_value.side_effect</code> in the <code>with</code> block. But that's just my preference. That way you also have access to the mock that actually replaced <code>loadJSON</code>, not just the result of <i>calling</i> that mock.</span>
<span class="comment-copy">Yes, it turned out that one of the prints was from another call. mock.called returns false</span>
<span class="comment-copy">I hope the question is a bit more clear now.</span>
