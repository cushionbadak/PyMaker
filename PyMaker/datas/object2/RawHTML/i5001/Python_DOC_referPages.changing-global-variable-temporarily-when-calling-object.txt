<div class="post-text" itemprop="text">
<p>I'm trying to understand how to change an object's attribute temporarily when it is called and have the original value persist when the object is not called.</p>
<p>Let me describe the problem with some code:</p>
<pre><code>class DateCalc:
 DEFAULT= "1/1/2001"
 def __init__(self, day=DEFAULT):
  self.day= day
 def __call__(self, day=DEFAULT):
  self.day= day
  return self
 def getday(self):
  return self.day
</code></pre>
<p>In the event where a user calls getday method while passing another value 
 i.e 2/2/2002, self.day is set to 2/2/2002. However I want to be able to revert self.day to the original value of 1/1/2001 after the method call:</p>
<pre><code>d_obj = DateCalc()
d_obj.getday() == "1/1/2001"
True
d_obj().getday() == "1/1/2001"
True
another_day_str = "2/2/2002"
d_obj(another_day_str).getday()
</code></pre>
<p>returns</p>
<pre><code>"2/2/2002"
</code></pre>
<p>But when I run the following</p>
<pre><code>d_obj.getday()
</code></pre>
<p>returns</p>
<pre><code>"2/2/2002"
</code></pre>
<p>I was wondering what's the right way to revert the value, without needing to include code at every method call. Secondly, this should also be true when the object is called. For example:</p>
<pre><code>d_obj().getday()
</code></pre>
<p>should return</p>
<pre><code>"1/1/2001"
</code></pre>
<p>I thought a decorator on the <strong>call</strong> magic method would work here, but I'm not really sure where to start.</p>
<p>Any help would be much appreciated</p>
</div>
<div class="post-text" itemprop="text">
<p>Since you probably don't really want to modify the attributes of your object for a poorly defined interval, you need to return or otherwise create a different object.</p>
<p>The simplest case would be one in which you had two separate objects, and no <code>__call__</code> method at all:</p>
<pre><code>d1_obj = DateCalc()
d2_obj = DateCalc('2/2/2002')
print(d1_obj.getday())  # 1/1/2001
print(d2_obj.getday())  # 2/2/2002
</code></pre>
<p>If you know where you want to use <code>d_obj</code> vs <code>d_obj()</code> in the original case, you clearly know where to use <code>d1_obj</code> vs <code>d2_obj</code> in this version as well.</p>
<p>This may not be adequate for cases where <code>DateCalc</code> actually represents a very complex object that has many attributes that you do <em>not</em> want to change. In that case, you can have the <code>__call__</code> method return a <em>separate</em> object that intelligently copies the portions of the original that you want.</p>
<p>For a simple case, this could be just</p>
<pre><code>def __call__(self, day=DEFAULT):
    return type(self)(day)
</code></pre>
<p>If the object becomes complex enough, you will want to create a proxy. A proxy is an object that forwards most of the implementation details to another object. <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super()</code></a> is an example of a proxy that has a very highly customized <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code></a> implementation, among other things.</p>
<p>In your particular case, you have a couple of requirements:</p>
<ol>
<li>The proxy must store all overriden attributes.</li>
<li>The proxy must get all non-overriden attributes from the original objects.</li>
<li>The proxy must pass itself as the <code>self</code> parameter to any (at least non-special) methods that are invoked.</li>
</ol>
<p>You can get as complicated with this as you want (in which case look up how to properly implement proxy objects like <a href="https://stackoverflow.com/q/9942536/2988730">here</a>). Here is a fairly simple example:</p>
<pre><code># Assume that there are many fields like `day` that you want to modify
class DateCalc:
    DEFAULT= "1/1/2001"

    def __init__(self, day=DEFAULT):
        self.day= day

    def getday(self):
        return self.day

    def __call__(self, **kwargs):
        class Proxy:
            def __init__(self, original, **kwargs):
                self._self_ = original
                self.__dict__.update(kwargs)
            def __getattribute__(self, name):
                # Don't forward any overriden, dunder or quasi-private attributes
                if name.startswith('_') or name in self.__dict__:
                    return object.__getattribute__(self, name)
                # This part is simplified:
                # it does not take into account __slots__
                # or attributes shadowing methods
                t = type(self._self_)
                if name in t.__dict__:
                    try:
                        return t.__dict__[name].__get__(self, t)
                    except AttributeError:
                        pass
                return getattr(self._self_, name)
        return Proxy(self, **kwargs)
</code></pre>
<p>The proxy would work exactly as you would want: it forwards any values that you did not override in <code>__call__</code> from the original object. The interesting thing is that it binds instance methods to the proxy object instead of the original, so that <code>getday</code> gets called with a <code>self</code> that has the overridden value in it:</p>
<pre><code>d_obj = DateCalc()
print(type(d_obj))    # __main__.DateCalc
print(d_obj.getday()) # 1/1/2001

d2_obj = d_obj(day='2/2/2002')
print(type(d2_obj))     # __main__.DateCalc.__call__.&lt;locals&gt;.Proxy
print(d2_obj.getday())  # 2/2/2002
</code></pre>
<p>Keep in mind that the proxy object shown here has very limited functionality implemented, and will not work properly in many situations. That being said, it likely covers many of the use cases that you will have out of the box. A good example is if you chose to make <code>day</code> a property instead of having a getter (it is the more Pythonic approach):</p>
<pre><code>class DateCalc:
    DEFAULT= "1/1/2001"

    def __init__(self, day=DEFAULT):
        self.__dict__['day'] = day

    @property
    def day(self):
        return self.__dict__['day']

    # __call__ same as above
    ...
</code></pre>
<p></p>
<pre><code>d_obj = DateCalc()
print(d_obj(day='2/2/2002').day)  # 2/2/2002
</code></pre>
<p>The catch here is that the proxy's version of <code>day</code> is just a regular writable attribute instead of a read-only property. If this is a problem for you, implementing <code>__setattr__</code> appropriately on the proxy will be left as an exercise for the reader.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems that you want a behavior like a context manager: to modify an attribute for a limited time, use the updated attribute and then revert to the original. You can do this by having <code>__call__</code> return a context manager, which you can then use in a <code>with</code> block like this:</p>
<pre><code>d_obj = DateCalc()
print(d_obj.getday())     # 1/1/2001
with d_obj('2/2/2002'):
    print(d_obj.getday()) # 2/2/2002
print(d_obj.getday())     # 1/1/2001
</code></pre>
<p>There are a couple of ways of creating such a context manager. The simplest would be to use a nested method in <code>__call__</code> and decorate it with <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer"><code>contextlib.contextmanager</code></a>:</p>
<pre><code>from contextlib import contextmanager
...
    def __call__(self, day=DEFAULT):
        @contextmanager
        def context()
            orig = self.day
            self.day = day
            yield
            self.day = orig
        return context
</code></pre>
<p>You could also use a fully-fledged nested class for this, but I would not recommend it unless you have some really complex requirements. I am just providing it for completeness:</p>
<pre><code>def __call__(self, day=DEFAULT):
    class Context:
        def __init__(self, inst, new):
            self.inst = inst
            self.old = inst.day
            self.new = new
        def __enter__(self):
            self.inst.day = self.new
        def __exit__(self, *args):
            self.inst.day = self.old
    return Context(self, day)
</code></pre>
<p>Also, you should consider making <code>getday</code> a property, especially if it is really read-only.</p>
<p>Another alternative would be to have your methods accept different values:</p>
<pre><code>def getday(self, day=None):
    if day is None:
        day = self.day
    return day
</code></pre>
<p>This is actually a fairly common idiom.</p>
</div>
<span class="comment-copy">What? You need to provide a <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a></span>
<span class="comment-copy">@juanpa.arrivillaga I actually followed the guideline before posting...I provided an example to showcase the problem, I described what i'm trying to solve. Would you happen to have any suggestions?</span>
<span class="comment-copy">This is not a reproducible example. Please show something that others can copy-and-paste and actually run, and provide the expected outputs for <i>those</i> cases.</span>
<span class="comment-copy">@juanpa.arrivillaga I kind of confused myself going through the code, but I think it's more clear now. Please let me know if this is not the case</span>
<span class="comment-copy">@user3166881 it looks much improved. I'll try to answer later when I have some time.</span>
<span class="comment-copy">I have never heard/seen this before. This works!  One last q, is this approach unusual? I've never really seen this anywhere</span>
<span class="comment-copy">@user3166881. This approach is not common, because you do not often need to spoof limited portions of an object's functionality. However, it does appear sometimes. <code>super</code> is a method that returns a very complex proxy representing your MRO. The question I linked has some pretty good resources on what it takes to make a proper proxy.</span>
<span class="comment-copy">@user3166881. I've added some stuff to the answer. See edits.</span>
<span class="comment-copy">Just realized that i can only use context manager with "with"... I see now what you mean by creating a separate object, it would be easier for my use case. I'm surprised there isn't an easier way, maybe a magic method that gets applied to all method calls in an object. Something like <b>getattr</b> but for methods</span>
<span class="comment-copy">@user3166881 <code>__getattr__</code> and <code>__getattribute__</code> work on methods just fine. The problem is that you haven't clearly defined <i>when</i> the attribute gets reverted. A <code>with</code> block allows you to specify it quite precisely.</span>
<span class="comment-copy">@user3166881. If you found my answer to be helpful, upvoting and/or selecting it would be in order.</span>
<span class="comment-copy">True to the context manager, but it doesn't work when calling the method directly which is what I want to do - I've thumbs upped the approach since it can be applicable to someone else</span>
<span class="comment-copy">@user3166881. To phrase it differently, in the current incarnation, you have two references to the exact same object (since <code>__call__</code> returns <code>self</code>). How do you intend to determine which one should return the original value and which one should return the updated value?</span>
