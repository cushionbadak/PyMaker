<div class="post-text" itemprop="text">
<p>I am following this tutorials <a href="http://rwnin.net/?p=5" rel="nofollow noreferrer">here</a> where the CopyFile function calling the windows API just dosen't work for me. This is the code I am using (just changed the username)</p>
<pre><code>from ctypes import *
CopyFile = windll.kernel32.CopyFileA
CopyFile("C:\Windows\System32\calc.exe", "C:\\Users\legion\Desktop\calc.exe", False)
</code></pre>
<p>I tried changing the parameters, file path, I tried same file to the same directory changing False to True so that I may get an error or prompt that the file already exists. It just dosen't work. If you haven't worked with Ctypes (like me) and don't know the answer, please try and try this snippet on your machine. </p>
</div>
<div class="post-text" itemprop="text">
<p>The 1<sup>st</sup> thing that I see, is that some <em>backslash</em>es in the paths are not escaped. It won't be a problem in this particular case, but it's better to always escape them.</p>
<p>I modified your code a bit (<em>code0.py</em>):</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import os
from ctypes import windll


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    src = r"C:\Windows\System32\calc.exe"
    dst = os.path.join(os.getcwd(), "calc.exe")  # Change this to your original path

    kernel32_dll = windll.kernel32

    copy_file_a = kernel32_dll.CopyFileA

    copy_file_w = kernel32_dll.CopyFileW

    reta = copy_file_a(src, dst, False)
    retw = copy_file_w(src, dst, False)

    print("CopyFileA returned: {:d}\nCopyFileW returned: {:d}\n".format(reta, retw))
</code></pre>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-bat prettyprint-override"><code>E:\Work\Dev\StackOverflow\q048927571&gt;"e:\Work\Dev\VEnvs\py27x64_test\Scripts\python.exe" code0.py
Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:53:40) [MSC v.1500 64 bit (AMD64)] on win32

CopyFileA returned: 1
CopyFileW returned: 0

E:\Work\Dev\StackOverflow\q048927571&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code0.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

CopyFileA returned: 0
CopyFileW returned: 1
</code></pre>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li>According to <a href="https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-copyfile" rel="nofollow noreferrer">[MS.Docs]: CopyFile function</a>:

<blockquote>
<p>If the function succeeds, the return value is nonzero.</p>
</blockquote></li>
<li>I've added <em>CopyFileW</em> in the mix</li>
<li>According to output, <em>CopyFileA</em> fails with <em>Python 3</em> (I've figured out that this is your scenario), and <em>CopyFileW</em> fails with <em>Python 2</em>. <br/>That happens because in <em>Python 2</em>, strings are <em>8bit</em> (<code>char *</code> based), while in <em>Python 3</em> they are <em>Unicode</em> (<em>16bit</em> (<code>wchar_t *</code> based) on <em>Win</em>)</li>
<li>Since the <em>ANSI</em> (<strong><em>A</em></strong>) version of a function has some limitations compared to its <em>Wide</em> (<strong><em>W</em></strong>) version, it's recommended to use the latter one</li>
</ul>
<p>We have a cause for the failure, but we're not quite there yet. Here's a more elaborate example (<em>code1.py</em>):</p>
<pre class="lang-py prettyprint-override"><code>#!/usr/bin/env python3

import sys
import os
from ctypes import windll, c_char_p, c_wchar_p, c_int


if __name__ == "__main__":
    print("Python {:s} on {:s}\n".format(sys.version, sys.platform))
    src = r"C:\Windows\System32\calc.exe"
    dst = os.path.join(os.getcwd(), "calc.exe")

    kernel32_dll = windll.kernel32

    copy_file_a = kernel32_dll.CopyFileA
    copy_file_a.argtypes = (c_char_p, c_char_p, c_int)
    copy_file_a.restype = c_int

    copy_file_w = kernel32_dll.CopyFileW
    copy_file_w.argtypes = (c_wchar_p, c_wchar_p, c_int)
    copy_file_w.restype = c_int

    reta = copy_file_a(src.encode(), dst.encode(), False)
    retw = copy_file_w(src, dst, False)

    print("CopyFileA returned: {:d}\nCopyFileW returned: {:d}\n".format(reta, retw))
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Added some string encoding</li>
<li>Set the <em>argtypes</em> and <em>restype</em> (<a href="https://docs.python.org/3/library/ctypes.html#specifying-the-required-argument-types-function-prototypes" rel="nofollow noreferrer">[Python 3]: Specifying the required argument types (function prototypes)</a>) for the 2 functions, so that values are properly converted (otherwise they point to <em>32bit</em> <em>int</em> - which can get messy on <em>64bit</em>)</li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre class="lang-bat prettyprint-override"><code>E:\Work\Dev\StackOverflow\q048927571&gt;"e:\Work\Dev\VEnvs\py27x64_test\Scripts\python.exe" code1.py
Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:53:40) [MSC v.1500 64 bit (AMD64)] on win32

CopyFileA returned: 1
CopyFileW returned: 1

E:\Work\Dev\StackOverflow\q048927571&gt;"e:\Work\Dev\VEnvs\py35x64_test\Scripts\python.exe" code1.py
Python 3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)] on win32

CopyFileA returned: 1
CopyFileW returned: 1
</code></pre>
</blockquote>
</div>
