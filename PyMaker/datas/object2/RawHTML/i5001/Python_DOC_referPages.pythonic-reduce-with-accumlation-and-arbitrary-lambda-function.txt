<div class="post-text" itemprop="text">
<p>What would be the Pythonic way of performing a reduce with accumulation?</p>
<p>For example, take <code>R</code>'s <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/funprog.html" rel="nofollow noreferrer"><code>Reduce()</code></a>. Given a list and an arbitrary lambda function it allows for yielding a vector of accumulated results instead of only the final result by setting <code>accumulate=T</code>. An example for this with a simple multiplication as lambda function would be (taken from <a href="https://stackoverflow.com/a/28545991/6229919">this answer</a>):</p>
<pre><code>Reduce(`*`, x=list(5,4,3,2), accumulate=TRUE)
# [1]   5  20  60 120
</code></pre>
<p>It is important that an arbitrary lambda function (like <code>lambda x, y: ...</code>) can be used, so solutions that allow for e.g. only using a sum, multiplication, or else won't do the trick. I was not able to come up with a Pythonic solution to do this with e.g. Python's <a href="https://docs.python.org/3.3/library/itertools.html" rel="nofollow noreferrer"><code>itertools</code></a> or <a href="https://docs.python.org/3.3/library/functools.html" rel="nofollow noreferrer"><code>functools</code></a>, but there might be a way. And though there are numerous other questions and answers on reduce and specially accumulation with Python I did not spot a generic answer so far.</p>
<p>A non-Pythonic example using a loop for performing a accumulated reduce with an arbitrary lambda function could look like this:</p>
<pre><code># the source list
l = [0.5, 0.9, 0.8, 0.1, 0.1, 0.9]
# the lambda function for aggregation can be arbitrary
# this one is just made up for the example
func = lambda x, y: x * 0.65 + y * 0.35 

# the accumulated reduce:
# a) the target list with initializer value hardcoded
l2 = [l[0]]
# b) the loop
for i in range(1, len(l)):
    l2 += [func(
            l2[i-1],    # last value in l2
            l[i]        # new value from l   
            )]
</code></pre>
<p>So: how would you do a reduce with accumulation and arbitrary lambda function in a Pythonic way?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 (introduced in 3.2, ability to pass the function added in 3.3) this is already implemented, in <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a>. Just use it like this:</p>
<pre><code>from itertools import accumulate
list(accumulate([5, 4, 3, 2], lambda a, b: a*b))
# [5, 20, 60, 120]
</code></pre>
<hr/>
<p>If you are using an earlier Python version, or want to implement it yourself, and you really want any arbitrary <code>lambda</code> (that takes two arguments) to work, then you could use the generator which is given in the documentation of the above:</p>
<pre><code>def accumulate(iterable, func=operator.add):
    'Return running totals'
    # accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15
    # accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120
    it = iter(iterable)
    try:
        total = next(it)
    except StopIteration:
        return
    yield total
    for element in it:
        total = func(total, element)
        yield total
</code></pre>
<p>The usage is exactly the same as above.</p>
<hr/>
<p>If you are using <code>numpy</code>, then there exists a faster solution, at least for all <code>numpy.ufunc</code>s. These include basically the same functions that the standard library module <code>math</code> provides, and then some. You can find a complete list <a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs" rel="nofollow noreferrer">here</a>.</p>
<p>Every <code>numpy.ufunc</code> has the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.accumulate.html" rel="nofollow noreferrer"><code>accumulate</code></a> method, so you can just do:</p>
<pre><code>import numpy as np
np.multiply.accumulate([5, 4, 3, 2])
# array([  5,  20,  60, 120])
</code></pre>
</div>
