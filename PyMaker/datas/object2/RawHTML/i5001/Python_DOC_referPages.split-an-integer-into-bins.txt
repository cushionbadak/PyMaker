<div class="post-text" itemprop="text">
<p>Given a single integer and the number of bins, <strong>how to split the integer into as equal parts as possible?</strong> </p>
<p>E.g. the sum of the outputs should be equals to the input integer</p>
<pre><code>[in]: x = 20 , num_bins = 3
[out]: (7, 7, 6)
</code></pre>
<p>Another e.g. </p>
<pre><code>[in]: x = 20 , num_bins = 6
[out]: (4, 4, 3, 3, 3, 3)
</code></pre>
<p>I've tried this:</p>
<pre><code>x = 20
num_bins = 3
y = [int(x/num_bins)] * num_bins
for i in range(x%num_bins):
    y[i] += 1
</code></pre>
<p>It works but there must be a simpler/better way, maybe using <code>bisect</code> or <code>numpy</code>? </p>
<p>Using <code>numpy</code> from <a href="https://stackoverflow.com/a/48899071/610569">https://stackoverflow.com/a/48899071/610569</a> , I could do this too:</p>
<pre><code>list(map(len, np.array_split(range(x), num_bins)))
</code></pre>
<p>But that's a little convoluted with creating a generate to get the a pretend list and getting the length. </p>
</div>
<div class="post-text" itemprop="text">
<p>The built-in <a href="https://docs.python.org/3/library/functions.html" rel="nofollow noreferrer"><code>divmod</code></a> function could be useful for this. </p>
<pre><code>def near_split(x, num_bins):
    quotient, remainder = divmod(x, num_bins)
    return [quotient + 1] * remainder + [quotient] * (num_bins - remainder)
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>In [11]: near_split(20, 3)
Out[11]: [7, 7, 6]
In [12]: near_split(20, 6)
Out[12]: [4, 4, 3, 3, 3, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Updated</strong> simplified using integer arithmetic.</p>
<p>Here's a one-liner:</p>
<pre><code>np.arange(n+k-1, n-1, -1) // k
</code></pre>
<p>Little demo:</p>
<pre><code>&gt;&gt;&gt; for k in range(4, 10, 3):
...     for n in range(10, 17):
...         np.arange(n+k-1, n-1, -1) // k
... 
array([3, 3, 2, 2])
array([3, 3, 3, 2])
array([3, 3, 3, 3])
array([4, 3, 3, 3])
array([4, 4, 3, 3])
array([4, 4, 4, 3])
array([4, 4, 4, 4])
array([2, 2, 2, 1, 1, 1, 1])
array([2, 2, 2, 2, 1, 1, 1])
array([2, 2, 2, 2, 2, 1, 1])
array([2, 2, 2, 2, 2, 2, 1])
array([2, 2, 2, 2, 2, 2, 2])
array([3, 2, 2, 2, 2, 2, 2])
array([3, 3, 2, 2, 2, 2, 2])
</code></pre>
</div>
<span class="comment-copy">The example with <code>num_bins = 6</code> should have been <code>5</code>.</span>
<span class="comment-copy">Whoops typo! ;P</span>
<span class="comment-copy">Your algorithm looks fine enough for me btw. I don't have any input.</span>
<span class="comment-copy">Oh cool! The <code>divmod</code> avoided the 2nd div/mod operation =)</span>
<span class="comment-copy">Nice! Didn't think of using <code>linspace</code> like this.</span>
