<div class="post-text" itemprop="text">
<p>I have a large text file which have values separated by a header starting with "#". If the condition matches the one in the header I would like to read the file until the next header "#" and SKIP rest of the file. </p>
<p>To test that I'm trying to read the following text file named as test234.txt: </p>
<pre><code># abcdefgh
1fnrnf
mrkfr
nfoiernfr
nerfnr
# something
njndjen kj
ejkndjke
#vcrvr
</code></pre>
<p>The code I wrote is:</p>
<pre><code>file_t = open('test234.txt')
cond = True
while cond:
    for line_ in file_t:
        print(line_)
        if file_t.read(1) == "#":
            cond = False
file_t.close()
</code></pre>
<p>But, the output I'm getting is:</p>
<pre><code># abcdefgh

fnrnf

rkfr

foiernfr

erfnr

something

jndjen kj

jkndjke

vcrvr
</code></pre>
<p>Instead I would like the output between two headers separated by "#" which is:</p>
<pre><code>1fnrnf
mrkfr
nfoiernfr
nerfnr      
</code></pre>
<p>How can I do that? Thanks!</p>
<p>EDIT: <a href="https://stackoverflow.com/questions/38655176/reading-in-file-block-by-block-using-specified-delimiter-in-python">Reading in file block by block using specified delimiter in python</a> talks about reading file in groups separated by headers but I don't want to read all the headers. I only want to read the header where a given condition is met and as soon as the line reaches the next header marked by '#' it stops reading the file.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html?highlight=groupby#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> can help:</p>
<pre><code>from io import StringIO
from itertools import groupby

text = '''# abcdefgh
1fnrnf
mrkfr
nfoiernfr
nerfnr
# something
njndjen kj
ejkndjke
#vcrvr'''


with StringIO(text) as file:
    lines = (line.strip() for line in file)  # removing trailing '\n'
    for key, group in groupby(lines, key=lambda x: x[0]=='#'):

        if key is True:
            # found a line that starts with '#'
            print('found header: {}'.format(next(group)))

        if key is False:
            # group now contanins all lines that do not start with '#'
            print('\n'.join(group))
</code></pre>
<p>note that all of this is <em>lazy</em>. you'd only ever have all the items between two headers in memory.</p>
<p>you'd have to replace the <code>with StringIO(text) as file:</code> with; <code>with open('test234.txt', 'r') as file:</code>...</p>
<p>the output for your test is:</p>
<pre><code>found header: # abcdefgh
1fnrnf
mrkfr
nfoiernfr
nerfnr
found header: # something
njndjen kj
ejkndjke
found header: #vcrvr
</code></pre>
<hr/>
<p><strong>UPDATE</strong> as i misunderstood. here is a fresh attempt:</p>
<pre><code>from io import StringIO
from collections import deque
from itertools import takewhile

from_line = '# abcdefgh'
to_line = '# something'

with StringIO(text) as file:
    lines = (line.strip() for line in file)  # removing trailing '\n'

    # fast-forward up to from_line
    deque(takewhile(lambda x: x != from_line, lines), maxlen=0)

    for line in takewhile(lambda x: x != to_line, lines):
        print(line)
</code></pre>
<p>where i use <a href="https://docs.python.org/3/library/itertools.html?highlight=takewhile#itertools.takewhile" rel="nofollow noreferrer"><code>itertools.takewhile</code></a> to get an iterator over the lines until a contition is met (until the first header is found in your case).</p>
<p>the <code>deque</code> part is just the <a href="https://docs.python.org/3/library/itertools.html?highlight=consume#itertools-recipes" rel="nofollow noreferrer"><code>consume</code> pattern</a> suggested in the itertools recipes. it just fast-forwards to the point where the given condition does not hold anymore. </p>
</div>
<div class="post-text" itemprop="text">
<p>Learn and use regex. It will help you for all document signification processes.</p>
<pre><code>import re #regex library

with open('test234.txt') as f:  #file stream
    lines = f.readlines()       #reads all lines

p = re.compile('^#.*')          #regex pattern creation

for l in lines:
    if p.match(l) == None:      #looks for non-matching lines
        print(l[:-2])
</code></pre>
</div>
<span class="comment-copy">The line has a new line character at the end and print adds another one. Use <code>print(line.rstrip())</code> to remove the trailing new line..</span>
<span class="comment-copy">Is your file using windows line endings <code>\r\n</code>? If so, use the <code>rsrip</code> method.</span>
<span class="comment-copy">Yes, the file has \n character but I simply want the output between the 2 headers specified by "#"</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/38655176/reading-in-file-block-by-block-using-specified-delimiter-in-python">Reading in file block by block using specified delimiter in python</a></span>
<span class="comment-copy">Could you explain how the groupby is working? Is group iterating line by line in the for loop? Also, since the original file which I would try to read is pretty big. So, is the code reading the file line by line or all the lines at once? Thanks!</span>
<span class="comment-copy">as mentioned: this is lazy. everything used here is a generator. so yes: the file is treated line-by-line and not read as a whole. <code>groupby</code> reads until the condition (first character in the line == '#'?) changes and treturns the <code>key</code> (the value of the condition) and an iterator over the <code>group</code> (which is all the lines in between). the documentation is pretty helpful.</span>
<span class="comment-copy">It took me some time to understand your solution being a beginner. It's removing the headers and grouping all the data as one. Instead, I would only like to read the data between two given headers and skip the whole file as specified in the question. Maybe you already meant it but I'm not able to work it out. Also, the question asked by Chris is reading the whole data in different sections separated by headers whereas I only want to read one section of my data specified by a given header and skip everything else.</span>
<span class="comment-copy">Thanks for the update. I also found using regex to be very simple for understanding as a beginner as suggested by @accumulatorax in the other solution. Do you think what you suggested is faster &amp; efficient over using regex? I've developed my own solution building on accumulatorax solution. I can post it for comparison?</span>
<span class="comment-copy">if you wonder about speed, there is the <code>timeit</code> module. i'd say that regex is overkill if you know exactly what the header you are looking for looks like. regex is great if you know it's structure only.</span>
<span class="comment-copy">Could you add some comments for a beginner like me to understand more? What is re.compile doing there?</span>
<span class="comment-copy">Regular expression logic provides you to finding patterns (described by yourself) in strings.  <i>^#.*</i> means that you are looking for string pieces starts with # mark.  Check <a href="https://www.computerhope.com/jargon/r/regex.htm" rel="nofollow noreferrer">that</a> out. For some more info.</span>
<span class="comment-copy">Will it work if I don't want to read all the lines at once since the file is pretty large?</span>
<span class="comment-copy">Of course you can do it in "with" indent in while loop with readline() function</span>
