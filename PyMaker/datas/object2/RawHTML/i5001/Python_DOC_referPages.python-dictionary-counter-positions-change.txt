<div class="post-text" itemprop="text">
<p>So i'm trying to count the most repeated values in an text file. By using the <code>Counter</code> method it returns exaclty what im looking for </p>
<h1>file.txt</h1>
<pre><code>12334
99965
99965
44144
99965
00000
44144
</code></pre>
<h1>scirpt.py</h1>
<pre><code>pArray=[]
with open("file.txt") as my_file:
        for line in my_file:
             pArray.append((line.split('\n'))[0])
        dictn = Counter(pArray)
        print(dictn)
        for key, value in dictn.items():
                print("KEY",key)    
                print("VALUE",value)
        print(dictn)
</code></pre>
<h1>OUTPUT</h1>
<pre><code>Counter({'99965': 3, '44144': 2, '12334': 1, '00000': 1})
KEY 12334
VALUE 1
KEY 99965
VALUE 3
KEY 44144
VALUE 2
KEY 00000
VALUE 1
['12334', '99965', '44144', '00000']
</code></pre>
<p>But as you can see the output of the final array is not in the same order as the dictionary <br/>(<code>value</code> should be in descending order)</p>
<p>I am expecting an output like</p>
<pre><code> ['99965', '44144', '12334', '00000']
</code></pre>
<p>I also tried <code>list(dictn.keys())</code> but i got the same output :/  <br/>
Why is the order changing and how can I fix it?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/collections.html#counter-objects" rel="nofollow noreferrer">the docs</a>, we see that <code>Counter</code> objects: are "unordered collections" - much like <code>dictionaries</code>, (in-fact they are a sub-class). So this means that iterating over <code>.items()</code> won't give the elements in order of size.</p>
<p>However, we can simply use <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer"><code>.most_common</code></a> which returns a <em>list</em> of <em>tuples</em> - each containing an element and its count. The most important thing being that it is in order.</p>
<p>So all we need to do is use a <code>list-comprehension</code> to extract the first element of each <em>tuple</em> in the <em>list</em> returned. That can be done with:</p>
<pre><code>[t[0] for t in dictn.most_common()]
</code></pre>
<p>which gave:</p>
<pre><code>['99965', '44144', '12334', '00000']
</code></pre>
<p>but could also give the following as the counts for <code>'12334'</code> and <code>'00000'</code> are the same. This is unavoidable due to the nature of how dictionaries (and Counters) work. But if this is important, just let me know and I can update the answer.</p>
<pre><code>['99965', '44144', '00000', '12334']
</code></pre>
<hr/>
<p><em>Note that not all of your code needs to be inside the <code>with</code> statement, once you have created <code>pArray</code>, you can exit the <code>with</code> statement. Also, basic Python uses <code>lists</code>, <strong>not</strong> <code>arrays</code>!</em></p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to print <code>Key</code>, <code>Value</code> pairs you can do</p>
<pre><code>for key in reversed(sorted(dictn)):
    print("KEY: {0}, VALUE: {1}".format(key, dictn[key]))
</code></pre>
</div>
<span class="comment-copy">Dictionaries <b>have no order</b> in Python, I am afraid you'll have to sort it once creating a list or something of that approach...</span>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/11037005/pythonic-way-to-iterate-over-a-collections-counter-instance-in-descending-orde">Pythonic way to iterate over a collections.Counter() instance in descending order?</a></span>
<span class="comment-copy">Having the same values wont be an issue. Thanks this works perfectly!</span>
<span class="comment-copy">This does not work, <code>Counters</code> are <b>not</b> ordered!</span>
<span class="comment-copy">It does, python dictionaries retrieve keys by default, which is exactly the same thing as dictn.keys() in a loop. Nonetheless if the ordering is regarded to each item value, then yes that code is improper.</span>
