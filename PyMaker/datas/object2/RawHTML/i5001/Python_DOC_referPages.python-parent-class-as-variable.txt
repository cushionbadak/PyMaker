<div class="post-text" itemprop="text">
<p>Assume you have two parent classes with the same interface in some module parents.py</p>
<pre><code>class Mother:
    def __init__(self):
         print("mother")

class Father:
    def __init__(self):
         print("father")
</code></pre>
<p>and you want to use a child class, which can operate on both classes, such as</p>
<pre><code>import parents

class Child:
    def __init__(self,parent_choice):
        parents.parent_choice.__init__()
</code></pre>
<p>Is it possible to create such an child object choosing the right parent as variable? something like</p>
<pre><code>import child

son_of_your_mother = Child(Mother)
</code></pre>
<p>The best approach would be having separate modules (.py files) for each of the parents (not as shown in my example).
Any other approach to the issue is welcome, as long as it keeps the two parent classes separate (divorce is often good for the kids).</p>
</div>
<div class="post-text" itemprop="text">
<p>Define mother and father as child attributes, keep the two as references to the mother and father object instances (has-a relationship)</p>
<pre><code>class Mother:
    ...

class Father:
    ...

class Child:
    def __init__(self, mother, father):
        self.mother = mother
        self.father = father
        ...
    ...
    # use whatever attributes/methods you want from mother or father with
    # self.mother.somethod() or self.father.someattribute


mother1 = Mother() # create real objects from your classes
father1 = Father()
child1 = Child(mother1, father1) # pass them to the child `__init__`
</code></pre>
<p>Where you keep the Mother and Father classes is irrelevant. You might keep them in the same file or make a <code>family.py</code> module and then</p>
<pre><code>from family import Mother, Father

class Child:
...
</code></pre>
<p>defining your child in the current script.</p>
<p>Edit:</p>
<p>As per your comments you would need to inherit the <code>Child</code> class from some <code>Parent</code> class, from which you also inherit both <code>Mother</code> and <code>Father</code> classes.
That would inherit the methods and attributes but would also state that a <code>Child</code> is also a <code>Parent</code>, which he isn't. But they are all Persons, so you can create a <code>Person</code> class with common attributes and methods, extend it with a Mother and Father class both inheriting from Person, and then alter the child class <code>__init__</code> to receive a list of parents. You mantain a container-like has-a relationship, but now a child can have many parents. Maybe add a method <code>add_parent</code> to append new parents to that list in <code>self.parents</code>. If creating methods in <code>Child</code> just to delegate (call) the corresponding methods in the parents becomes labourious, then you might consider changing the <code>Child</code> class to inherit from Person class too, getting all the common Parents machinery. You'll need to adapt a bit the code in those scenarios, but I think you get it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found a very similar question: <a href="https://stackoverflow.com/questions/18683097/pass-a-parent-class-as-an-argument">Pass a parent class as an argument?</a></p>
<p>The solution is to define a function that wraps the class. In this case would be something like</p>
<pre><code>import parents

def Child(parent):

    class Child(parent):
         # stuff

    return Child
</code></pre>
<p>and to create instances</p>
<pre><code>import child

c = Child(Mother)(**args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could pass a string to <code>Child</code> then use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer">getattr</a> to create a parent object.</p>
<pre><code>import parents

class Child:
    def __init__(self,parent_choice):
        self.parent = getattr(parents, parent_choice)()
</code></pre>
<p>Then you would use it like this</p>
<pre><code>son_of_your_mother = Child('Mother')
</code></pre>
</div>
<span class="comment-copy">The line <code>parents.parent_choice.__init__()</code> gives an error. Please do not write code that obviously does not work.</span>
<span class="comment-copy">Sorry not that obvious to me. Normally I would do super().__init__(**args). How is that not equivalent?</span>
<span class="comment-copy">Not that obvious ??? Simply test your code !</span>
<span class="comment-copy">the problem is at son_of_your_mother = child(mother), where mother should be an instance of mother, not at the line you mentioned. And I did not instantiate it because the goal would be to instantiate an object while doing this, but inherit the class attributes. Of course the code doesn't work  the way I put it, otherwise I would have no question</span>
<span class="comment-copy">Thank you, this partially solves the problem (adding maybe a conditional statement, if it's not desired to create both objects). The problem with this, which is more structural than practical I guess, is that child does not inherit the parents class attributes, but sort of contains them. For now I will use this solution, but ideally I would want to call, say function foo from mother as child.foo().</span>
<span class="comment-copy">Also, with this solutions the possible classes that child can take must be hardcoded in child itself, whereas it would be useful to be able to add extra parents, without modifying the child class</span>
<span class="comment-copy">@Francesco, see my edit.</span>
