<div class="post-text" itemprop="text">
<p>Here is my python code for this question.</p>
<pre><code>class iterator():
    def __init__(self, data):
        self.__data__ = data
        self.__base__ = -1
        self.__sentinel__ = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        self.__base__ = self.__base__ + 1
        if self.__base__ == self.__sentinel__:
            raise StopIteration
        else:
            return self.__data__[self.__base__]

class iterable():
    def __init__(self, data):
        self.__iterator__ = iterator(data)

    def __iter__(self):
        return self.__iterator__
</code></pre>
<p>From above definitions, I wrote the following code to understand the concept iterator binding</p>
<pre><code>love = 'Welcome to my house!'
house = iterable(love)
ice = iter(house)
joy = iter(house)

if ice is joy:
    print("ice and joy are the same iterators")

king = iter(love)
mouse = iter(love)

if king is not mouse:
    print("king and mouse are not the same iterators")
</code></pre>
<p>When I run the above code, I will get the above messages, which indicates that iterators obtained from iter function invoking on data are not the same, but iterators obtained from iter function invoking on my iterable are the same. Can anyone explain to me what is going on? I would appreciate any help on this. Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>You have incorrectly implemented the protocol, from the <a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">data-model</a>, the <code>__iter__</code> method:</p>
<blockquote>
<p>This method is called when an iterator is required for a container.
  This method should return a <strong>new</strong> iterator object that can iterate over
  all the objects in the container.</p>
</blockquote>
<p>You always return the <em>same old iterator</em>:</p>
<pre><code>def __iter__(self):
    return self.__iterator__
</code></pre>
<p>Which is only ever set here:</p>
<pre><code>self.__iterator__ = iterator(data)
</code></pre>
<p>...</p>
<blockquote>
<p>Iterator objects also need to implement this method; they are required
  to return themselves.</p>
</blockquote>
<p>You implemented your iterator correctly in that regard.</p>
<hr/>
<p>Your <code>iterable</code> implementation should be like this:</p>
<pre><code>class iterable:
    def __init__(self, data):
        self.data = data

    def __iter__(self):
        return iterator(self.data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You misimplemented <code>iterable</code>. The <code>__iter__</code> of an iterable non-iterator should return a <em>new</em> iterator on each call, so a proper implementation would be:</p>
<pre><code>class iterable:
    def __init__(self, data):
        # Convert to reusable data in case input is itself an iterator
        self.data = tuple(data)

    def __iter__(self):
        return iterator(self.data)
</code></pre>
<p>This preserves an important attribute of iterators and iterables. <code>iter(iterator)</code> should always return <code>iterator</code>, but <code>iter(iterable)</code> should not only return a new object, but it should be a <em>different</em> object each time (because the idea is that non-iterators can be iterated separately and repeatably, only iterators are stateful); that is <code>iter(iterable) is not iter(iterable)</code>.</p>
</div>
<span class="comment-copy">Just a style tip: according to PEP8, you should use "dunder" names: "<code>__double_leading_and_trailing_underscore__</code>: "magic" objects or attributes that live in user-controlled namespaces. E.g. <code>__init__</code>, <code>__import__</code> or <code>__file__</code>. <i>Never invent such names</i>; only use them as documented."</span>
<span class="comment-copy">You <b>shouldn't</b> use dunder names, is what I meant to type.</span>
<span class="comment-copy">Thanks for your response!!</span>
<span class="comment-copy">Thanks for your response!!</span>
