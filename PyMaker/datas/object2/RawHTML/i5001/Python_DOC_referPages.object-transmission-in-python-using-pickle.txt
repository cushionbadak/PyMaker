<div class="post-text" itemprop="text">
<p>I have the following class, a Point object</p>
<pre><code>class Point:
    def __init__(self):
        pass

    def __init__(self, x, y):
        self.x = x
        self.y = y
</code></pre>
<p>And I have a server (Uses UDP)</p>
<pre><code># Server side
import socket
import pickle

host = "localhost"
port = 10000

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((host, port))

data = s.recvfrom(1024)
print(data)
</code></pre>
<p>And my client side is: </p>
<pre><code>import socket
import pickle
from Point import *

host = "localhost"
port = 10000
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

p = Point(10, 20)
a = pickle.dumps(p)

s.sendto(a, (host, port))
</code></pre>
<p>In the server side, whenever I get the <code>p</code> and print it, I get the following <code>(b'\x80\x03cPoint\nPoint\nq\x00)\x81q\x01}q\x02(X\x01\x00\x00\x00xq\x03K\nX\x01\x00\x00\x00yq\x04K\x14ub.', ('127.0.0.1', 55511))</code> </p>
<p>How can I get the object, instead of this?</p>
</div>
<div class="post-text" itemprop="text">
<p>First, a caveat. Pickles allow for arbitrary code execution. Do <strong>not</strong> use this to accept arbitrary connections, and preferably use cryptography to ensure you are only exchanging trusted data. Even then, consider using a safer exchange format.</p>
<p>Next, take into account that UDP packets are limited in size. You need to make sure your pickle data is small enough to fit in a UDP packet (the maximum payload size is 65507 bytes). At least when you receive the packet, you'll know you have all the data. Use 65535 as the buffer size to ensure large packets can be fully received.</p>
<p>On sending, make sure you don't cross the size limits:</p>
<pre><code>MAX_UDP_SIZE = 65507  # https://en.wikipedia.org/wiki/User_Datagram_Protocol

a = pickle.dumps(p)
if len(a) &gt; MAX_UDP_SIZE:
    raise ValueError('Message too large')
s.sendto(a, (host, port))
</code></pre>
<p>and on the other side, use <a href="https://docs.python.org/3/library/pickle.html#pickle.loads" rel="nofollow noreferrer"><code>pickle.loads()</code></a> to turn the pickle data stream back into an object:</p>
<pre><code>UDP_MAX = 2 ** 16 - 1

data, addr = s.recvfrom(UDP_MAX)
object = pickle.loads(data)
</code></pre>
<p>I urge you strongly to <strong>at the very least</strong> verify that <code>addr</code> is trusted, or you leave yourself open to executing arbitrary code. 65507 bytes is ample space to send a pickle that takes control of your process.</p>
<p>If you need to send more data, then you'll need to use TCP instead of UDP, because you'll have to send across data in a specific order, spread across multiple packets, and need for all packets to arrive on the receiving end; TCP provides that layer of reliability. At that point you'd have to prefix your pickle with a fixed number of bytes encoding the size of the pickle, so you can ensure you read that same amount of data again on the other side.</p>
</div>
<div class="post-text" itemprop="text">
<p>Pickle is not suitable for this purpose.  Consider <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow noreferrer">this warning</a>:</p>
<blockquote>
<p>Warning The pickle module is not secure against erroneous or
  maliciously constructed data. Never unpickle data received from an
  untrusted or unauthenticated source.</p>
</blockquote>
<p>Your protocol lacks any kind of access control so your processes are vulnerable to arbitrary remote code execution attacks.</p>
<p>Consider a real network protocol instead.  There are many to choose from.  For example, <a href="https://github.com/capnproto/pycapnp" rel="nofollow noreferrer">Cap' Proto</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Solution is to used <code>pickle.loads</code> as below on the server side</p>
<pre><code>d = s.recvfrom(1024)
p1 = Point(1,1)
p1 = pickle.loads(d[0])
print(str(p1.x))
</code></pre>
<p>However, as suggested by many, <code>pickle</code> might not be the best solution for such scenarios.</p>
</div>
<span class="comment-copy">...use <code>pickle.loads</code>? What does "it does not work" mean? Does it throw an error? Does it crash your PC? Does it return a Circle instead of a Point?</span>
<span class="comment-copy">@Aran-Fey I did so, but I still can't load create the object, I updated my question to show what I have tried</span>
<span class="comment-copy">Why do you have <b>two</b> <code>__init__</code> methods? The first definition is a dud, replaced by the second.</span>
<span class="comment-copy">I <b>strongly</b> want to caution against using Pickle in a client-server application, not unless you want to open yourself to having the process hijacked. Pickles allow for arbitrary code execution.</span>
<span class="comment-copy">@MartijnPieters thanks ! I updated the question. Still, out of curiosity, want to know how to make this happen.</span>
<span class="comment-copy">The comments about framing are wrong.  The OP uses UDP.  The framing is the datagram.  The correct amount of data to handle is already known.</span>
<span class="comment-copy">@Jean-PaulCalderone: made it UDP specific now, thanks for pointing that out.</span>
<span class="comment-copy">Chances of getting 2 ** 16 byte UDP packets over the public internet is pretty small.  You might pull it off over a LAN.  The ease of forging a sender address on UDP is pretty great so don't rely on the reported sender address for access control.  For crypto, it's very easy to get things wrong.  You almost certainly need to use an existing, widely accepted solution.  Consider DTLS with certificates or <i>perhaps</i> NaCL SecretBox.</span>
<span class="comment-copy">(But really there are tons of alternatives to Pickle, just don't use it.)</span>
<span class="comment-copy">Python has good <a href="https://cryptography.io/en/latest/" rel="nofollow noreferrer">cryptography support</a> but you do need to know what you are doing, yes.</span>
<span class="comment-copy">While true, this is a separate issue and not an answer to the question.</span>
<span class="comment-copy">Ignoring the security consequences here is irresponsible.</span>
<span class="comment-copy">Reading a fixed 1024 bytes will cause issues if your data sent is larger than that size. UDP has size limits you need to account for.</span>
