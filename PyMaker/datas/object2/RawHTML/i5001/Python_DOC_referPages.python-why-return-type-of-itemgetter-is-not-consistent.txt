<div class="post-text" itemprop="text">
<p>Python <code>itemgetter</code> doesn't return tuples of length 0 or 1. 
For example:</p>
<pre><code>from operator import itemgetter

def get_something(keys):
    d = {
        "a": 1,
        "b": 2,
        "c": 3
    }
    return itemgetter(*keys)(d)

print(type(get_something(["a", "b"])))
# &lt;class 'tuple'&gt;
print(type(get_something(["a"])))
# &lt;class 'int'&gt;
print(type(get_something([])))
# TypeError: itemgetter expected 1 arguments, got 0 
</code></pre>
<ul>
<li><p>Is there any good reason that the <code>itemgetter</code> is written this way?  And not <code>(1,)</code> for the second last <code>()</code> and for the last? </p></li>
<li><p>Is there some other built-in option if I always want to return a tuple/list given the keys?</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there some other built-in option if I always want to return a
  tuple/list given the keys?</p>
</blockquote>
<p>just use a comprehension:</p>
<pre><code>[d[k] for k in keys]
</code></pre>
<p>In context:</p>
<pre><code>from operator import itemgetter

def get_something(keys):
    d = {
        "a": 1,
        "b": 2,
        "c": 3
    }
    return [d[k] for k in keys]

print(get_something(["a", "b"]))
#[1, 2]
print(get_something(["a"]))
#[1]
print(get_something([]))
#[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Part of your confusion comes from the fact that your <code>get_something()</code> func takes a single argument (expected to be an iterable) and unpacks it when passing it to <code>itemgetter()</code>. This results in the return value of <code>get_something()</code> not being "symetric" with it's arguments. </p>
<p>If you defined <code>get_something()</code> to use varargs instead (as <code>itemgetter()</code> does) :</p>
<pre><code>def get_something(*keys):
    d = {
        "a": 1,
        "b": 2,
        "c": 3
    }
    return itemgetter(*keys)(d)
</code></pre>
<p>the return values would be more consistant with the arguments, ie:</p>
<pre><code># ask for 3 keys, get 3 values:
&gt;&gt;&gt; get_something("a", "b", "c")
(1, 2, 3)

# ask for 2 keys, get 2 values:
&gt;&gt;&gt; get_something("a", "b")
(1, 2)

# ask for one key, get 1 value
&gt;&gt;&gt; get_something("a")
1

# all of this with tuple unpacking in mind:

a, b = get_something("a", "b")
a = get_something("a") 
</code></pre>
<p>Now the point is that few people would bother using <code>itemgetter()</code> to implement your <code>get_something</code> function - <code>itemgetter</code> has mainly been designed to be used as a callback for <code>sorted()</code> and like functions / methods (where it's current behaviour makes sense), and <code>get_something</code> would more canonically be implemented with a list expression ie:</p>
<pre><code>def get_something(keys):
    d = {
        "a": 1,
        "b": 2,
        "c": 3
    }
    return [d[k] for k in keys]
</code></pre>
<p>which would take an iterable and return a (possibly empty) list.</p>
</div>
<div class="post-text" itemprop="text">
<p>This behavior is documented in the <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">docs</a> (emphasis is mine):</p>
<blockquote>
<p>Return a callable object that fetches item from its <strong>operand using the
  operand’s <code>__getitem__()</code> method. If multiple items are specified,
  returns a tuple of lookup values</strong></p>
</blockquote>
<p><code>itemgetter</code> does not decide the return type, it is the operand's <code>__getitem__()</code> method.</p>
<blockquote>
<p>Wouldn't it be easier/better</p>
</blockquote>
<p>"better" is subjective. You can always wrap <code>itemgetter</code>:</p>
<pre><code>def get_something(keys):
    def my_itemgetter():
        r = itemgetter(*keys)(d)
        return (r,) if type(r) is not tuple else r

    d = {
        "a": 1,
        "b": 2,
        "c": 3
    }

    return my_itemgetter()
</code></pre>
</div>
<span class="comment-copy">what do your <code>print</code>s actually <code>return</code>?</span>
<span class="comment-copy">I added it above</span>
<span class="comment-copy"><code>itemgetter</code> is a pretty trivial helper function. If the way it works doesn't suit you, you should write your own that works the way you want. FWIW I agree with you about inconsistent return types.</span>
<span class="comment-copy">@SpoonMeiser  Yes, but for me it looks like an obvious design flaw but still I realise that people who created Python are 100x smarter than me. So I am trying to understand what am I missing here.</span>
<span class="comment-copy">If already going down that path, consider using <code>.get</code> to avoid potential <code>KeyError</code>.</span>
<span class="comment-copy">@DeepSpace Yah could do or <code>[d[k] for k in keys if k in d]</code>, depends what they want in such circmumstances</span>
<span class="comment-copy">Ok. So why do we have <code>itemgetter</code> built-in at all?  I mean this is a good way to do it but hard for me to image a situation where I would use the actual <code>itemgetter</code> for anything.</span>
<span class="comment-copy">@Pekka <code>itemgetter</code> is suitable for some tasks, like sorting based on the 2nd item <code>sorted([('a', 2), ('b', 1)], key=itemgetter(1))</code></span>
<span class="comment-copy">@Pekka Using <code>lambda</code> works, but it is less performant (slower) <a href="https://stackoverflow.com/questions/17243620/operator-itemgetter-or-lambda" title="operator itemgetter or lambda">stackoverflow.com/questions/17243620/…</a></span>
<span class="comment-copy">Ok maybe that part of the question is subjective, but I meant better for everybody. I will change the question to be more objective :)</span>
