<div class="post-text" itemprop="text">
<p>I am using NetworkX's simple_cycles to generate all cycles, and I iterate through on the condition of breaking if a cycle of size k is found (k being supplied by the user).</p>
<pre><code>try:
    for cycle in nx.simple_cycles(G):
        if len(cycle) == k:
            checkval = True
            break
    if not checkval:
        print "no path of size k"
except nx.NetworkXNoPath:
    print "There was no path of size k"
    checkval = False
</code></pre>
<p>Depending on the graph, simple_cycles may take basically forever to try to find a cycle of size k.  I would like to stop checking after a certain amount of time.  I can't stop based on the amount of cycles found, because that is unreliable.  Sometimes 1 cycle may be found in a full minute, and 100000 cycles may be found in 30 seconds.</p>
<p>My question is if there is a way to stop the generator based on a certain amount of time passing, from OUTSIDE of the generator.. or if the only way would be to modify the code of the generator itself.</p>
<p>(Also any general advice about what I am trying to do would be appreciated.)</p>
</div>
<div class="post-text" itemprop="text">
<p>The trouble is that there are pathological corner cases ... for example, a huge, huge graph with zero cycles, such that it requires too much time before even the first iteration of <code>nx.simple_cycles(G)</code> can complete.</p>
<p>As a result, there won't be a way to do it from <em>outside</em> the generator unless you place the execution into another context that you are able to terminate, like a separate <code>Process</code> from <code>multiprocessing</code>, or <a href="https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading" rel="nofollow noreferrer">running the coroutine with asyncio</a>.</p>
<p>Then for each cycle that is asynchronously obtained (either from the process or thread), you can check the length condition <em>and</em> a condition on the overall amount of elapsed time, and choose to terminate the other process / thread if you exceed the time limit.</p>
<p>On the other hand, if you don't care about this type of corner case and you're reasonably sure that the values yielded by <code>nx.simple_cycles(G)</code> will return in reasonable amounts of time, then you could wrap that generator to make your own time-limited generator:</p>
<pre><code>import time


def time_limited_cycles(G, time_limit=100.0):
    elapsed, cycle_generator = 0.0, nx.simple_cycles(G)
    while elapsed &lt;= time_limit:
        start_time = time.time()
        try:
            # crucial assumption here, that calling next on
            # the original generator never takes too long.
            cycle = next(cycle_generator)
        except StopIteration:
            break
        yield cycle
        elapsed += time.time() - start_time 
        # move elapsed above the yield line if you are looking
        # to limit the internal runtime of the generator, rather
        # than overall time spent processing cycles.
</code></pre>
<p>With the above, you can replace your original usage of <code>nx.simple_cycles</code> with a call to <code>time_limited_cycles</code> instead (with your desired time limit), and the rest of your code will work the same, because <code>time_limited_cycles</code> yields the same cycle results that <code>nx.simple_cycles</code> would yield, up to the point that it stops.</p>
</div>
<div class="post-text" itemprop="text">
<p>The part where you check the length looks like a good place to start. Using <code>time</code> is also a good idea for timing things. At the top of your code, insert:</p>
<pre><code>from time import time
</code></pre>
<p>Before the <code>for</code> loop, insert:</p>
<pre><code>time_to_wait = int (time()) + x # x is the time you want to wait. 
</code></pre>
<p>In your <code>for</code> loop, change the <code>if</code> statement to:</p>
<pre><code>if len (cycle) == k or int (time()) == time_to_wait
</code></pre>
<p>You might want to make another <code>if</code> instead of merging it because a timeout will still set <code>checkval</code> to True, which you may not want. In that case, just leave the first <code>if</code> alone, and make another one:</p>
<pre><code>if int (time()) == time_to_wait: break
</code></pre>
</div>
