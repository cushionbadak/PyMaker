<div class="post-text" itemprop="text">
<p>I need to merge multiple dictionaries, here's what I have for instance:</p>
<pre><code>dict1 = {1:{"a":{A}}, 2:{"b":{B}}}

dict2 = {2:{"c":{C}}, 3:{"d":{D}}
</code></pre>
<p>With <code>A</code> <code>B</code> <code>C</code> and <code>D</code> being leaves of the tree, like <code>{"info1":"value", "info2":"value2"}</code></p>
<p>There is an unknown level(depth) of dictionaries, it could be <code>{2:{"c":{"z":{"y":{C}}}}}</code></p>
<p>In my case it represents a directory/files structure with nodes being docs and leaves being files.</p>
<p>I want to merge them to obtain:</p>
<pre><code> dict3 = {1:{"a":{A}}, 2:{"b":{B},"c":{C}}, 3:{"d":{D}}}
</code></pre>
<p>I'm not sure how I could do that easily with Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>this is actually quite tricky - particularly if you want a useful error message when things are inconsistent, while correctly accepting duplicate but consistent entries (something no other answer here does....)</p>
<p>assuming you don't have huge numbers of entries a recursive function is easiest:</p>
<pre><code>def merge(a, b, path=None):
    "merges b into a"
    if path is None: path = []
    for key in b:
        if key in a:
            if isinstance(a[key], dict) and isinstance(b[key], dict):
                merge(a[key], b[key], path + [str(key)])
            elif a[key] == b[key]:
                pass # same leaf value
            else:
                raise Exception('Conflict at %s' % '.'.join(path + [str(key)]))
        else:
            a[key] = b[key]
    return a

# works
print(merge({1:{"a":"A"},2:{"b":"B"}}, {2:{"c":"C"},3:{"d":"D"}}))
# has conflict
merge({1:{"a":"A"},2:{"b":"B"}}, {1:{"a":"A"},2:{"b":"C"}})
</code></pre>
<p>note that this mutates <code>a</code> - the contents of <code>b</code> are added to <code>a</code> (which is also returned).  if you want to keep <code>a</code> you could call it like <code>merge(dict(a), b)</code>.</p>
<p>agf pointed out (below) that you may have more than two dicts, in which case you can use:</p>
<pre><code>reduce(merge, [dict1, dict2, dict3...])
</code></pre>
<p>where everything will be added to dict1.</p>
<p>[note - i edited my initial answer to mutate the first argument; that makes the "reduce" easier to explain]</p>
<p>ps in python 3, you will also need <code>from functools import reduce</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an easy way to do it using generators:</p>
<pre><code>def mergedicts(dict1, dict2):
    for k in set(dict1.keys()).union(dict2.keys()):
        if k in dict1 and k in dict2:
            if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):
                yield (k, dict(mergedicts(dict1[k], dict2[k])))
            else:
                # If one of the values is not a dict, you can't continue merging it.
                # Value from second dict overrides one in first and we move on.
                yield (k, dict2[k])
                # Alternatively, replace this with exception raiser to alert you of value conflicts
        elif k in dict1:
            yield (k, dict1[k])
        else:
            yield (k, dict2[k])

dict1 = {1:{"a":"A"},2:{"b":"B"}}
dict2 = {2:{"c":"C"},3:{"d":"D"}}

print dict(mergedicts(dict1,dict2))
</code></pre>
<p>This prints:</p>
<pre><code>{1: {'a': 'A'}, 2: {'c': 'C', 'b': 'B'}, 3: {'d': 'D'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One issue with this question is that the values of the dict can be arbitrarily complex pieces of data. Based upon these and other answers I came up with this code:
</p>
<pre><code>class YamlReaderError(Exception):
    pass

def data_merge(a, b):
    """merges b into a and return merged result

    NOTE: tuples and arbitrary objects are not handled as it is totally ambiguous what should happen"""
    key = None
    # ## debug output
    # sys.stderr.write("DEBUG: %s to %s\n" %(b,a))
    try:
        if a is None or isinstance(a, str) or isinstance(a, unicode) or isinstance(a, int) or isinstance(a, long) or isinstance(a, float):
            # border case for first run or if a is a primitive
            a = b
        elif isinstance(a, list):
            # lists can be only appended
            if isinstance(b, list):
                # merge lists
                a.extend(b)
            else:
                # append to list
                a.append(b)
        elif isinstance(a, dict):
            # dicts must be merged
            if isinstance(b, dict):
                for key in b:
                    if key in a:
                        a[key] = data_merge(a[key], b[key])
                    else:
                        a[key] = b[key]
            else:
                raise YamlReaderError('Cannot merge non-dict "%s" into dict "%s"' % (b, a))
        else:
            raise YamlReaderError('NOT IMPLEMENTED "%s" into "%s"' % (b, a))
    except TypeError, e:
        raise YamlReaderError('TypeError "%s" in key "%s" when merging "%s" into "%s"' % (e, key, b, a))
    return a
</code></pre>
<p>My use case is <a href="https://github.com/ImmobilienScout24/yamlreader">merging YAML files</a> where I only have to deal with a subset of possible data types. Hence I can ignore tuples and other objects. For me a sensible merge logic means</p>
<ul>
<li>replace scalars</li>
<li>append lists</li>
<li>merge dicts by adding missing keys and updating existing keys</li>
</ul>
<p>Everything else and the unforeseens results in an error.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p><strong>Dictionaries of dictionaries merge</strong></p>
</blockquote>
<p>As this is the canonical question (in spite of certain non-generalities) I'm providing the canonical Pythonic approach to solving this issue.</p>
<h1>Simplest Case: "leaves are nested dicts that end in empty dicts":</h1>
<pre><code>d1 = {'a': {1: {'foo': {}}, 2: {}}}
d2 = {'a': {1: {}, 2: {'bar': {}}}}
d3 = {'b': {3: {'baz': {}}}}
d4 = {'a': {1: {'quux': {}}}}
</code></pre>
<p>This is the simplest case for recursion, and I would recommend two naive approaches:</p>
<pre><code>def rec_merge1(d1, d2):
    '''return new merged dict of dicts'''
    for k, v in d1.items(): # in Python 2, use .iteritems()!
        if k in d2:
            d2[k] = rec_merge1(v, d2[k])
    d3 = d1.copy()
    d3.update(d2)
    return d3

def rec_merge2(d1, d2):
    '''update first dict with second recursively'''
    for k, v in d1.items(): # in Python 2, use .iteritems()!
        if k in d2:
            d2[k] = rec_merge2(v, d2[k])
    d1.update(d2)
    return d1
</code></pre>
<p>I believe I would prefer the second to the first, but keep in mind that the original state of the first would have to be rebuilt from its origin. Here's the usage:</p>
<pre><code>&gt;&gt;&gt; from functools import reduce # only required for Python 3.
&gt;&gt;&gt; reduce(rec_merge1, (d1, d2, d3, d4))
{'a': {1: {'quux': {}, 'foo': {}}, 2: {'bar': {}}}, 'b': {3: {'baz': {}}}}
&gt;&gt;&gt; reduce(rec_merge2, (d1, d2, d3, d4))
{'a': {1: {'quux': {}, 'foo': {}}, 2: {'bar': {}}}, 'b': {3: {'baz': {}}}}
</code></pre>
<h1>Complex Case: "leaves are of any other type:"</h1>
<p>So if they end in dicts, it's a simple case of merging the end empty dicts. If not, it's not so trivial. If strings, how do you merge them? Sets can be updated similarly, so we could give that treatment, but we lose the order in which they were merged. So does order matter? </p>
<p>So in lieu of more information, the simplest approach will be to give them the standard update treatment if both values are not dicts: i.e. the second dict's value will overwrite the first, even if the second dict's value is None and the first's value is a dict with a lot of info.</p>
<pre><code>d1 = {'a': {1: 'foo', 2: None}}
d2 = {'a': {1: None, 2: 'bar'}}
d3 = {'b': {3: 'baz'}}
d4 = {'a': {1: 'quux'}}

from collections import MutableMapping

def rec_merge(d1, d2):
    '''
    Update two dicts of dicts recursively, 
    if either mapping has leaves that are non-dicts, 
    the second's leaf overwrites the first's.
    '''
    for k, v in d1.items(): # in Python 2, use .iteritems()!
        if k in d2:
            # this next check is the only difference!
            if all(isinstance(e, MutableMapping) for e in (v, d2[k])):
                d2[k] = rec_merge(v, d2[k])
            # we could further check types and merge as appropriate here.
    d3 = d1.copy()
    d3.update(d2)
    return d3
</code></pre>
<p>And now</p>
<pre><code>from functools import reduce
reduce(rec_merge, (d1, d2, d3, d4))
</code></pre>
<p>returns</p>
<pre><code>{'a': {1: 'quux', 2: 'bar'}, 'b': {3: 'baz'}}
</code></pre>
<h1>Application to the original question:</h1>
<p>I've had to remove the curly braces around the letters and put them in single quotes for this to be legit Python (else they would be set literals in Python 2.7+) as well as append a missing brace:</p>
<pre><code>dict1 = {1:{"a":'A'}, 2:{"b":'B'}}
dict2 = {2:{"c":'C'}, 3:{"d":'D'}}
</code></pre>
<p>and <code>rec_merge(dict1, dict2)</code> now returns:</p>
<pre><code>{1: {'a': 'A'}, 2: {'c': 'C', 'b': 'B'}, 3: {'d': 'D'}}
</code></pre>
<p>Which matches the desired outcome of the original question (after changing, e.g. the <code>{A}</code> to <code>'A'</code>.)</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on @andrew cooke. This version handles nested lists of dicts and also allows the option to update the values</p>
<pre>
def merge(a, b, path=None, update=True):
    "http://stackoverflow.com/questions/7204805/python-dictionaries-of-dictionaries-merge"
    "merges b into a"
    if path is None: path = []
    for key in b:
        if key in a:
            if isinstance(a[key], dict) and isinstance(b[key], dict):
                merge(a[key], b[key], path + [str(key)])
            elif a[key] == b[key]:
                pass # same leaf value
            elif isinstance(a[key], list) and isinstance(b[key], list):
                for idx, val in enumerate(b[key]):
                    a[key][idx] = merge(a[key][idx], b[key][idx], path + [str(key), str(idx)], update=update)
            elif update:
                a[key] = b[key]
            else:
                raise Exception('Conflict at %s' % '.'.join(path + [str(key)]))
        else:
            a[key] = b[key]
    return a
</pre>
</div>
<div class="post-text" itemprop="text">
<p>If you have an unknown level of dictionaries, then I would suggest a recursive function:</p>
<pre><code>def combineDicts(dictionary1, dictionary2):
    output = {}
    for item, value in dictionary1.iteritems():
        if dictionary2.has_key(item):
            if isinstance(dictionary2[item], dict):
                output[item] = combineDicts(value, dictionary2.pop(item))
        else:
            output[item] = value
    for item, value in dictionary2.iteritems():
         output[item] = value
    return output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on answers from @andrew cooke.
It takes care of nested lists in a better way.</p>
<pre><code>def deep_merge_lists(original, incoming):
    """
    Deep merge two lists. Modifies original.
    Reursively call deep merge on each correlated element of list. 
    If item type in both elements are
     a. dict: call deep_merge_dicts on both values.
     b. list: Calls deep_merge_lists on both values.
     c. any other type: Value is overridden.
     d. conflicting types: Value is overridden.

    If length of incoming list is more that of original then extra values are appended.
    """
    common_length = min(len(original), len(incoming))
    for idx in range(common_length):
        if isinstance(original[idx], dict) and isinstance(incoming[idx], dict):
            deep_merge_dicts(original[idx], incoming[idx])

        elif isinstance(original[idx], list) and isinstance(incoming[idx], list):
            deep_merge_lists(original[idx], incoming[idx])

        else:
            orginal[idx] = incoming[idx]

    for idx in range(common_length, len(incoming)):
        original.append(incoming[idx])


def deep_merge_dicts(original, incoming):
    """
    Deep merge two dictionaries. Modfies original.
    For key conflicts if both values are:
     a. dict: Recursivley call deep_merge_dicts on both values.
     b. list: Calls deep_merge_lists on both values.
     c. any other type: Value is overridden.
     d. conflicting types: Value is overridden.

    """
    for key in incoming:
        if key in original:
            if isinstance(original[key], dict) and isinstance(incoming[key], dict):
                deep_merge_dicts(original[key], incoming[key])

            elif isinstance(original[key], list) and isinstance(incoming[key], list):
                deep_merge_lists(original[key], incoming[key])

            else:
                original[key] = incoming[key]
        else:
            original[key] = incoming[key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This simple recursive procedure will merge one dictionary into another while overriding conflicting keys:</p>
<pre><code>#!/usr/bin/env python2.7

def merge_dicts(dict1, dict2):
    """ Recursively merges dict2 into dict1 """
    if not isinstance(dict1, dict) or not isinstance(dict2, dict):
        return dict2
    for k in dict2:
        if k in dict1:
            dict1[k] = merge_dicts(dict1[k], dict2[k])
        else:
            dict1[k] = dict2[k]
    return dict1

print (merge_dicts({1:{"a":"A"}, 2:{"b":"B"}}, {2:{"c":"C"}, 3:{"d":"D"}}))
print (merge_dicts({1:{"a":"A"}, 2:{"b":"B"}}, {1:{"a":"A"}, 2:{"b":"C"}}))
</code></pre>
<p>Output:</p>
<pre><code>{1: {'a': 'A'}, 2: {'c': 'C', 'b': 'B'}, 3: {'d': 'D'}}
{1: {'a': 'A'}, 2: {'b': 'C'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This version of the function will account for N number of dictionaries, and only dictionaries -- no improper parameters can be passed, or it will raise a TypeError. The merge itself accounts for key conflicts, and instead of overwriting data from a dictionary further down the merge chain, it creates a set of values and appends to that; no data is lost.</p>
<p>It might not be the most effecient on the page, but it's the most thorough and you're not going to lose any information when you merge your 2 to N dicts.</p>
<pre><code>def merge_dicts(*dicts):
    if not reduce(lambda x, y: isinstance(y, dict) and x, dicts, True):
        raise TypeError, "Object in *dicts not of type dict"
    if len(dicts) &lt; 2:
        raise ValueError, "Requires 2 or more dict objects"


    def merge(a, b):
        for d in set(a.keys()).union(b.keys()):
            if d in a and d in b:
                if type(a[d]) == type(b[d]):
                    if not isinstance(a[d], dict):
                        ret = list({a[d], b[d]})
                        if len(ret) == 1: ret = ret[0]
                        yield (d, sorted(ret))
                    else:
                        yield (d, dict(merge(a[d], b[d])))
                else:
                    raise TypeError, "Conflicting key:value type assignment"
            elif d in a:
                yield (d, a[d])
            elif d in b:
                yield (d, b[d])
            else:
                raise KeyError

    return reduce(lambda x, y: dict(merge(x, y)), dicts[1:], dicts[0])

print merge_dicts({1:1,2:{1:2}},{1:2,2:{3:1}},{4:4})
</code></pre>
<p>output: {1: [1, 2], 2: {1: 2, 3: 1}, 4: 4}</p>
</div>
<div class="post-text" itemprop="text">
<p>There's a slight problem with andrew cookes answer: In some cases it modifies the second argument <code>b</code> when you modify the returned dict. Specifically it's because of this line:</p>
<pre><code>if key in a:
    ...
else:
    a[key] = b[key]
</code></pre>
<p>If <code>b[key]</code> is a <code>dict</code>, it will simply be assigned to <code>a</code>, meaning any subsequent modifications to that <code>dict</code> will affect both <code>a</code> and <code>b</code>.</p>
<pre><code>a={}
b={'1':{'2':'b'}}
c={'1':{'3':'c'}}
merge(merge(a,b), c) # {'1': {'3': 'c', '2': 'b'}}
a # {'1': {'3': 'c', '2': 'b'}} (as expected)
b # {'1': {'3': 'c', '2': 'b'}} &lt;----
c # {'1': {'3': 'c'}} (unmodified)
</code></pre>
<p>To fix this, the line would have to be substituted with this:</p>
<pre><code>if isinstance(b[key], dict):
    a[key] = clone_dict(b[key])
else:
    a[key] = b[key]
</code></pre>
<p>Where <code>clone_dict</code> is:</p>
<pre><code>def clone_dict(obj):
    clone = {}
    for key, value in obj.iteritems():
        if isinstance(value, dict):
            clone[key] = clone_dict(value)
        else:
            clone[key] = value
    return
</code></pre>
<p>Still. This obviously doesn't account for <code>list</code>, <code>set</code> and other stuff, but I hope it illustrates the pitfalls when trying to merge <code>dicts</code>.</p>
<p>And for completeness sake, here is my version, where you can pass it multiple <code>dicts</code>:</p>
<pre><code>def merge_dicts(*args):
    def clone_dict(obj):
        clone = {}
        for key, value in obj.iteritems():
            if isinstance(value, dict):
                clone[key] = clone_dict(value)
            else:
                clone[key] = value
        return

    def merge(a, b, path=[]):
        for key in b:
            if key in a:
                if isinstance(a[key], dict) and isinstance(b[key], dict):
                    merge(a[key], b[key], path + [str(key)])
                elif a[key] == b[key]:
                    pass
                else:
                    raise Exception('Conflict at `{path}\''.format(path='.'.join(path + [str(key)])))
            else:
                if isinstance(b[key], dict):
                    a[key] = clone_dict(b[key])
                else:
                    a[key] = b[key]
        return a
    return reduce(merge, args, {})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since dictviews support set operations, I was able to greatly simplify jterrace's answer.</p>
<pre><code>def merge(dict1, dict2):
    for k in dict1.keys() - dict2.keys():
        yield (k, dict1[k])

    for k in dict2.keys() - dict1.keys():
        yield (k, dict2[k])

    for k in dict1.keys() &amp; dict2.keys():
        yield (k, dict(merge(dict1[k], dict2[k])))
</code></pre>
<p>Any attempt to combine a dict with a non dict (technically, an object with a 'keys' method and an object without a 'keys' method) will raise an AttributeError. This includes both the initial call to the function and recursive calls. This is exactly what I wanted so I left it. You could easily catch an AttributeErrors thrown by the recursive call and then yield any value you please.</p>
</div>
<div class="post-text" itemprop="text">
<p>This should help in merging all items from <code>dict2</code> into <code>dict1</code>:</p>
<pre><code>for item in dict2:
    if item in dict1:
        for leaf in dict2[item]:
            dict1[item][leaf] = dict2[item][leaf]
    else:
        dict1[item] = dict2[item]
</code></pre>
<p>Please test it and tell us whether this is what you wanted.</p>
<p><strong>EDIT:</strong></p>
<p>The above mentioned solution merges only one level, but correctly solves the example given by OP. To merge multiple levels, the recursion should be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>I had two dictionaries (<code>a</code> and <code>b</code>) which could each contain any number of nested dictionaries. I wanted to recursively merge them, with <code>b</code> taking precedence over <code>a</code>.</p>
<p>Considering the nested dictionaries as trees, what I wanted was:</p>
<ul>
<li>To update <code>a</code> so that every path to every leaf in <code>b</code> would be represented in <code>a</code></li>
<li>To overwrite subtrees of <code>a</code> if a leaf is found in the corresponding path in <code>b</code>
<ul>
<li>Maintain the invariant that all <code>b</code> leaf nodes remain leafs.</li>
</ul></li>
</ul>
<p>The existing answers were a little complicated for my taste and left some details on the shelf. I hacked together the following, which passes unit tests for my data set.</p>
<pre><code>  def merge_map(a, b):
    if not isinstance(a, dict) or not isinstance(b, dict):
      return b

    for key in b.keys():
      a[key] = merge_map(a[key], b[key]) if key in a else b[key]
    return a
</code></pre>
<p>Example (formatted for clarity):</p>
<pre><code> a = {
    1 : {'a': 'red', 
         'b': {'blue': 'fish', 'yellow': 'bear' },
         'c': { 'orange': 'dog'},
    },
    2 : {'d': 'green'},
    3: 'e'
  }

  b = {
    1 : {'b': 'white'},
    2 : {'d': 'black'},
    3: 'e'
  }


  &gt;&gt;&gt; merge_map(a, b)
  {1: {'a': 'red', 
       'b': 'white',
       'c': {'orange': 'dog'},},
   2: {'d': 'black'},
   3: 'e'}
</code></pre>
<p>The paths in <code>b</code> that needed to be maintained were:</p>
<ul>
<li><code>1 -&gt; 'b' -&gt; 'white'</code></li>
<li><code>2 -&gt; 'd' -&gt; 'black'</code></li>
<li><code>3 -&gt; 'e'</code>.</li>
</ul>
<p><code>a</code> had the unique and non-conflicting paths of:</p>
<ul>
<li><code>1 -&gt; 'a' -&gt; 'red'</code> </li>
<li><code>1 -&gt; 'c' -&gt; 'orange' -&gt; 'dog'</code></li>
</ul>
<p>so they are still represented in the merged map.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Overview</strong></p>
<p>The following approach subdivides the problem of a deep merge of dicts into: </p>
<ol>
<li><p>A parameterized shallow merge function <code>merge(f)(a,b)</code> that uses a
function <code>f</code> to merge two dicts <code>a</code> and <code>b</code></p></li>
<li><p>A recursive merger function <code>f</code> to be used together with <code>merge</code></p></li>
</ol>
<hr/>
<p><strong>Implementation</strong></p>
<p>A function for merging two (non nested) dicts can be written in a lot of ways. I personally like</p>
<pre><code>def merge(f):
    def merge(a,b): 
        keys = a.keys() | b.keys()
        return {key:f(*[a.get(key), b.get(key)]) for key in keys}
    return merge
</code></pre>
<hr/>
<p>A nice way of defining an appropriate recurrsive merger function <code>f</code> is using <a href="https://pypi.python.org/pypi/multipledispatch" rel="nofollow noreferrer">multipledispatch</a> which allows to define functions that evaluate along different paths depending on the type of their arguments.</p>
<pre><code>from multipledispatch import dispatch

#for anything that is not a dict return
@dispatch(object, object)
def f(a, b):
    return b if b is not None else a

#for dicts recurse 
@dispatch(dict, dict)
def f(a,b):
    return merge(f)(a,b)
</code></pre>
<hr/>
<p><strong>Example</strong></p>
<p>To merge two nested dicts simply use <code>merge(f)</code> e.g.:</p>
<pre><code>dict1 = {1:{"a":"A"},2:{"b":"B"}}
dict2 = {2:{"c":"C"},3:{"d":"D"}}
merge(f)(dict1, dict2)
#returns {1: {'a': 'A'}, 2: {'b': 'B', 'c': 'C'}, 3: {'d': 'D'}} 
</code></pre>
<hr/>
<p><strong>Notes:</strong></p>
<p>The advantages of this approach are:</p>
<ul>
<li><p>The function is build from smaller functions that each do a single thing
which makes the code simpler to reason about and test</p></li>
<li><p>The behaviour is not hard-coded but can be changed and extended as needed which improves code reuse (see example below). </p></li>
</ul>
<hr/>
<p><strong>Customization</strong></p>
<p>Some answers also considered dicts that contain lists e.g. of other (potentially nested) dicts. In this case one might want map over the lists and merge them based on position. This can be done by adding another definition to the merger function <code>f</code>:</p>
<pre><code>import itertools
@dispatch(list, list)
def f(a,b):
    return [merge(f)(*arg) for arg in itertools.zip_longest(a,b,fillvalue={})]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code will depend on your rules for resolving merge conflicts, of course. Here's a version which can take an arbitrary number of arguments and merges them recursively to an arbitrary depth, without using any object mutation. It uses the following rules to resolve merge conflicts:</p>
<ul>
<li>dictionaries take precedence over non-dict values (<code>{"foo": {...}}</code> takes precedence over <code>{"foo": "bar"}</code>)</li>
<li>later arguments take precedence over earlier arguments (if you merge <code>{"a": 1}</code>, <code>{"a", 2}</code>, and <code>{"a": 3}</code> in order, the result will be <code>{"a": 3}</code>)</li>
</ul>
<pre class="lang-python prettyprint-override"><code>try:
    from collections import Mapping
except ImportError:
    Mapping = dict

def merge_dicts(*dicts):                                                            
    """                                                                             
    Return a new dictionary that is the result of merging the arguments together.   
    In case of conflicts, later arguments take precedence over earlier arguments.   
    """                                                                             
    updated = {}                                                                    
    # grab all keys                                                                 
    keys = set()                                                                    
    for d in dicts:                                                                 
        keys = keys.union(set(d))                                                   

    for key in keys:                                                                
        values = [d[key] for d in dicts if key in d]                                
        # which ones are mapping types? (aka dict)                                  
        maps = [value for value in values if isinstance(value, Mapping)]            
        if maps:                                                                    
            # if we have any mapping types, call recursively to merge them          
            updated[key] = merge_dicts(*maps)                                       
        else:                                                                       
            # otherwise, just grab the last value we have, since later arguments    
            # take precedence over earlier arguments                                
            updated[key] = values[-1]                                               
    return updated  
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've been testing your solutions and decided to use this one in my project:</p>
<pre><code>def mergedicts(dict1, dict2, conflict, no_conflict):
    for k in set(dict1.keys()).union(dict2.keys()):
        if k in dict1 and k in dict2:
            yield (k, conflict(dict1[k], dict2[k]))
        elif k in dict1:
            yield (k, no_conflict(dict1[k]))
        else:
            yield (k, no_conflict(dict2[k]))

dict1 = {1:{"a":"A"}, 2:{"b":"B"}}
dict2 = {2:{"c":"C"}, 3:{"d":"D"}}

#this helper function allows for recursion and the use of reduce
def f2(x, y):
    return dict(mergedicts(x, y, f2, lambda x: x))

print dict(mergedicts(dict1, dict2, f2, lambda x: x))
print dict(reduce(f2, [dict1, dict2]))
</code></pre>
<p>Passing functions as parameteres is key to extend jterrace solution to behave as all the other recursive solutions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Easiest way i can think of is :</p>
<pre><code>#!/usr/bin/python

from copy import deepcopy
def dict_merge(a, b):
    if not isinstance(b, dict):
        return b
    result = deepcopy(a)
    for k, v in b.iteritems():
        if k in result and isinstance(result[k], dict):
                result[k] = dict_merge(result[k], v)
        else:
            result[k] = deepcopy(v)
    return result

a = {1:{"a":'A'}, 2:{"b":'B'}}
b = {2:{"c":'C'}, 3:{"d":'D'}}

print dict_merge(a,b)
</code></pre>
<p>Output:</p>
<pre><code>{1: {'a': 'A'}, 2: {'c': 'C', 'b': 'B'}, 3: {'d': 'D'}}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I have another slightly different solution here:</p>
<pre><code>def deepMerge(d1, d2, inconflict = lambda v1,v2 : v2) :
''' merge d2 into d1. using inconflict function to resolve the leaf conflicts '''
    for k in d2:
        if k in d1 : 
            if isinstance(d1[k], dict) and isinstance(d2[k], dict) :
                deepMerge(d1[k], d2[k], inconflict)
            elif d1[k] != d2[k] :
                d1[k] = inconflict(d1[k], d2[k])
        else :
            d1[k] = d2[k]
    return d1
</code></pre>
<p>By default it resolves conflicts in favor of values from the second dict, but you can easily override this, with some witchery you may be able to even throw exceptions out of it. :).</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Utils(object):

    """

    &gt;&gt;&gt; a = { 'first' : { 'all_rows' : { 'pass' : 'dog', 'number' : '1' } } }
    &gt;&gt;&gt; b = { 'first' : { 'all_rows' : { 'fail' : 'cat', 'number' : '5' } } }
    &gt;&gt;&gt; Utils.merge_dict(b, a) == { 'first' : { 'all_rows' : { 'pass' : 'dog', 'fail' : 'cat', 'number' : '5' } } }
    True

    &gt;&gt;&gt; main = {'a': {'b': {'test': 'bug'}, 'c': 'C'}}
    &gt;&gt;&gt; suply = {'a': {'b': 2, 'd': 'D', 'c': {'test': 'bug2'}}}
    &gt;&gt;&gt; Utils.merge_dict(main, suply) == {'a': {'b': {'test': 'bug'}, 'c': 'C', 'd': 'D'}}
    True

    """

    @staticmethod
    def merge_dict(main, suply):
        """
        获取融合的字典，以main为主,suply补充,冲突时以main为准
        :return:
        """
        for key, value in suply.items():
            if key in main:
                if isinstance(main[key], dict):
                    if isinstance(value, dict):
                        Utils.merge_dict(main[key], value)
                    else:
                        pass
                else:
                    pass
            else:
                main[key] = value
        return main

if __name__ == '__main__':
    import doctest
    doctest.testmod()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>hey there I also had the same problem but I though of a solution and I will post it here, in case it is also useful for others, basically merging nested dictionaries and also adding the values, for me I needed to calculate some probabilities so this one worked great:</p>
<pre><code>#used to copy a nested dict to a nested dict
def deepupdate(target, src):
    for k, v in src.items():
        if k in target:
            for k2, v2 in src[k].items():
                if k2 in target[k]:
                    target[k][k2]+=v2
                else:
                    target[k][k2] = v2
        else:
            target[k] = copy.deepcopy(v)
</code></pre>
<p>by using the above method we can merge:</p>
<p>target = {'6,6': {'6,63': 1}, '63,4': {'4,4': 1}, '4,4': {'4,3': 1}, '6,63': {'63,4': 1}}</p>
<p>src = {'5,4': {'4,4': 1}, '5,5': {'5,4': 1}, '4,4': {'4,3': 1}}</p>
<p>and this will become:
{'5,5': {'5,4': 1}, '5,4': {'4,4': 1}, '6,6': {'6,63': 1}, '63,4': {'4,4': 1}, '4,4': {'4,3': 2}, '6,63': {'63,4': 1}}</p>
<p>also notice the changes here:</p>
<p>target = {'6,6': {'6,63': 1}, '6,63': {'63,4': 1}, <strong>'4,4': {'4,3': 1}</strong>, '63,4': {'4,4': 1}}</p>
<p>src = {'5,4': {'4,4': 1}, '4,3': {'3,4': 1}, <strong>'4,4': {'4,9': 1}</strong>, '3,4': {'4,4': 1}, '5,5': {'5,4': 1}}</p>
<p>merge = {'5,4': {'4,4': 1}, '4,3': {'3,4': 1}, '6,63': {'63,4': 1}, '5,5': {'5,4': 1}, '6,6': {'6,63': 1}, '3,4': {'4,4': 1}, '63,4': {'4,4': 1}, <strong>'4,4': {'4,3': 1, '4,9': 1}</strong>}</p>
<p>dont forget to also add the import for copy:</p>
<pre><code>import copy
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Short-n-sweet:</p>
<pre><code>from collections.abc import MutableMapping as Map

def nested_update(d, v):
"""
Nested update of dict-like 'd' with dict-like 'v'.
"""

for key in v:
    if key in d and isinstance(d[key], Map) and isinstance(v[key], Map):
        nested_update(d[key], v[key])
    else:
        d[key] = v[key]
</code></pre>
<p>This works like (and is build on) Python's <code>dict.update</code> method. It returns <code>None</code> (you can always add <code>return d</code> if you prefer) as it updates dict <code>d</code> in-place. Keys in <code>v</code> will overwrite any existing keys in <code>d</code> (it does not try to interpret the dict's contents). </p>
<p>It will also work for other ("dict-like") mappings.</p>
</div>
<span class="comment-copy">What do you want for your arbitrary depth of dictionaries? Do you want <code>y</code> flattened up to the <code>c</code> level or what? Your example is incomplete.</span>
<span class="comment-copy">Check my NestedDict class here: <a href="http://stackoverflow.com/a/16296144/2334951">stackoverflow.com/a/16296144/2334951</a> It does managing of nested dictionary structures like merging &amp; more.</span>
<span class="comment-copy">A warning to everyone looking for solutions: This question is about nested dicts only. Most of the answers do not handle the more complicated case of lists of dicts within the structure properly. If you need this try the answer of @Osiloke below: <a href="http://stackoverflow.com/a/25270947/1431660">stackoverflow.com/a/25270947/1431660</a></span>
<span class="comment-copy"><b>See also:</b> <a href="https://github.com/akesterson/dpath-python#example-merging" rel="nofollow noreferrer">python dpath merge</a></span>
<span class="comment-copy"><b>See also:</b> <a href="https://stackoverflow.com/questions/9415785/merging-several-python-dictionaries">merge multiple dictionary</a></span>
<span class="comment-copy">You can then stick this inside a <code>reduce</code> or the equivalent loop to work with an arbitrary number of <code>dict</code>s instead of two. However, I'm not sure this does what he wants either (he wasn't clear), You end up with <code>2: {'c': {'z': {'y': {'info1': 'value', 'info2': 'value2'}}}, 'b': {'info1': 'value', 'info2': 'value2'}}</code> for his second example, I'm not sure whether he wants the <code>z</code> and <code>y</code> flattened up or not?</span>
<span class="comment-copy">they are directory structures so i don't think s/he wants anything flattened?  oh, sorry, missed "multiple dictionaries".  yes, reduce would be good.  will add that.</span>
<span class="comment-copy">This does exactly what I wanted! I'm sorry I wasn't clear enough... I thought I was okay with Python, seems not :-/  I needed a recursive function because of the nested dicts, this one works and I can understand it :) I do not seem to be able to make it work with reduce though...</span>
<span class="comment-copy">i updated the code a while ago to make it work better with reduce.  the current version seems ok to me - can you post an error?  for example, this works:  <code>print(reduce(merge, [{1:{"a":"A"},2:{"b":"B"}}, {2:{"c":"C"},3:{"d":"D"}}, {7:"foo"}]))</code></span>
<span class="comment-copy">For anyone with lists as the final nested level under the dicts, you can do this instead of raising the error to concatenate the two lists: <code>a[key] = a[key] + b[key]</code>. Thanks for the helpful answer.</span>
<span class="comment-copy">if you want to keep the generator theme you could chain(dict1.keys(), dict2.keys())</span>
<span class="comment-copy">Wouldn't that get duplicate keys?</span>
<span class="comment-copy">This one seems to do the work, at least on my set of data, but as I never understood yield and generators well I'm pretty much lost as to why, but I'm gonna try a bit harder, might be useful!</span>
<span class="comment-copy">ah, yes, it would get duplicate keys.  you'd still need to wrap it in a set, sorry.</span>
<span class="comment-copy">I found this specially helpfull. But the nicesting would be to let the function to solve the conflicts as a parameter.</span>
<span class="comment-copy">Fantastic. Works well on json dumps, too. Just removed the error handling. (Being lazy, can do proper ones for json I'm sure)</span>
<span class="comment-copy">the "isinstance" sequence can be replaced w/ <code>isinstance(a, (str, unicode, int, long, float))</code> isnt' it?</span>
<span class="comment-copy">Thanks, this is so helpful. I am having lists of dicts in my structures all the time, the other solutions cannot properly merge this.</span>
<span class="comment-copy">I find this version most elegant. Thanks!</span>
<span class="comment-copy">Why not <a href="https://docs.python.org/3/library/copy.html?highlight=deepcopy#copy.deepcopy" rel="nofollow noreferrer"><code>deepcopy</code></a> instead of <code>clone_dict</code>?</span>
<span class="comment-copy">Because the python stdlib is friggin huge and magnificent! I had no clue this existed -- plus it was a fun little thing to code :-)</span>
<span class="comment-copy">He's got an arbitrary depth of nesting</span>
<span class="comment-copy">That can be rewritten simply as <code>for k,v in dict2.iteritems(): dict1.setdefault(k,{}).update(v)</code>. But as @agf pointed out, this does not merge the nested dicts.</span>
<span class="comment-copy">@agf: Correct, so it seems OP needs solution employing recurrence. Thanks to the fact dictionaries are mutable, this should be quite easy to be done. But I think the question is not specific enough to tell what should happen when we come up with places with different levels of depths (eg. trying to merge <code>{'a':'b'}</code> with <code>{'a':{'c':'d'}</code>).</span>
