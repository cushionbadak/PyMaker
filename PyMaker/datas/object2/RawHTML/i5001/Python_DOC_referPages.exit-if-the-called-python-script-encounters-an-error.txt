<div class="post-text" itemprop="text">
<p>I have a central python script that calls various other python scripts and looks like this:</p>
<pre><code>os.system("python " + script1 + args1)
os.system("python " + script2 + args2)
os.system("python " + script3 + args3)
</code></pre>
<p>Now, I want to exit from my central script if any of the sub-scripts encounter an error.</p>
<p>What is happening with current code is that let's say script1 encounters an error. The console will display that error and then central script will move onto calling script2 and so on.</p>
<p>I want to display the encountered error and immediately exit my central code.</p>
<p>What is the best way to do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Overall this is a terrible way to execute a series of commands from within Python.  However here's a minimal way to handle it:</p>
<pre><code>#!python
import os, system
for script, args in some_tuple_of_commands:
    exit_code = os.system("python " + script + args)
    if exit_code &gt; 0:
        print("Error %d running 'python %s %s'" % (
            exit_code, script, args), file=sys.stderr)
        sys.exit(exit_code)
</code></pre>
<p>But, honestly this is all horrible. It's almost always a bad idea to concatenate strings and pass them to your shell for execution from within any programming language.</p>
<p>Look at the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">subprocess module</a> for much more sane handling of subprocesses in Python.</p>
<p>Also consider trying the <a href="https://amoffat.github.io/sh/" rel="nofollow noreferrer">sh</a> or the <a href="https://pexpect.readthedocs.io/en/stable/" rel="nofollow noreferrer">pexpect</a> third party modules depending on what you're trying to do with input or output.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try subprocess </p>
<pre><code>import subprocess,sys

try:
    output = subprocess.check_output("python test.py", shell=True)
    print(output)
except ValueError as e:
    print e
    sys.exit(0)

print("hello world")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't know if it's ideal for you but enclosing these commands in a function seems a good idea to me:</p>
<blockquote>
<p>I am using the fact that when a process exits with error <code>os.system(process)</code> returns 256 else it returns 0 as an output respectively.</p>
</blockquote>
<pre><code>def runscripts():
    if os.system("python " + script1 + args1):return(-1); #Returns -1 if script1 fails and exits.
    if os.system("python " + script2 + args2):return(-2); #Returns -2 and exits
    if os.system("python " + script3 + args3):return(-3); #Pretty obvious
    return(0)

runscripts()

#or if you want to exit the main program
if runscripts():sys.exit(0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Invoking the operating system like that is a security breach waiting to happen. One should use the <a href="https://docs.python.org/3/library/subprocess.html#module-subprocess" rel="nofollow noreferrer">subprocess module</a>, because it is more powerful and does not invoke a shell (unless you specifically tell it to). In general, avoid invoking  shell whenever possible (<a href="https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess">see this post</a>).</p>
<p>You can do it like this:</p>
<pre><code>import subprocess
import sys

# create a list of commands
# each command to subprocess.run must be a list of arguments, e.g.
# ["python", "echo.py", "hello"]
cmds = [("python " + script + " " + args).split()
        for script, args in [(script1, args1), (script2, args2), (script3,
                                                                  args3)]]


def captured_run(arglist):
    """Run a subprocess and return the output and returncode."""
    proc = subprocess.run( # PIPE captures the output
        arglist, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return proc.stdout, proc.stderr, proc.returncode


for cmd in cmds:
    stdout, stderr, rc = captured_run(cmd)
    # do whatever with stdout, stderr (note that they are bytestrings)
    if rc != 0:
        sys.exit(rc)
</code></pre>
<p>If you don't care about the output, just remove the <code>subprocess.PIPE</code> stuff and return only the <code>returncode</code> from the function. You may also want to add a timeout to the execution, see the subprocess docs linked above for how to do that.</p>
</div>
<span class="comment-copy">could you explain it more ?</span>
<span class="comment-copy">@AnjaneyuluBatta My main script is calling various other scipts (as shown in the code snippet). So now if the first scipt1 encounters an error, even though that error is displayed, the code moves onto calling scipt2 and so on.</span>
<span class="comment-copy">Are these scripts supposed t run parallel to the main process?</span>
<span class="comment-copy">@UbdusSamad No. They are supposed to run sequentially. And the latter one is dependent on its previous one. So if I encounter an error in any script, it gets propagated through all the latter scripts. Hence I want to exit just as the first error is encountered.</span>
