<div class="post-text" itemprop="text">
<p>I would like to find inside python for what architecture a file (in my case .so) has been build.</p>
<p>I known that I can see this in the terminal with the 'file' command.</p>
<p>Example:
<code>file libstuff.so</code> gives as output:</p>
<pre><code>libstuff.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=3cac824147a873a51c2862fea4e83cfed46c8d9, not stripped
</code></pre>
<p>I need this in my python script so I don't load the .so file if I running my program on a ARM aarch64 architecture.</p>
<p>I seem to be unable to find anything on this matter...
Is this not possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can make a call to the terminal using the <code>subprocess</code> module.</p>
<pre><code>import subprocess

proc = subprocess.Popen([
        'file',
        'libstuff.so'
    ], 
    stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)

out, err = proc.communicate()
info = out.decode()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://pypi.python.org/pypi/pyelftools" rel="nofollow noreferrer">pyelftools</a> for identifying the architecture for a shared object file.</p>
<p>Interfacing with shared libraries can be done via <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer">ctypes.cdll</a> in standard library.</p>
</div>
<span class="comment-copy">Could always <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header" rel="nofollow noreferrer">read it manually</a></span>
<span class="comment-copy">I had also though of this approach but would like to avoid it (if possible)</span>
<span class="comment-copy">Ok thanks! I will check it out</span>
