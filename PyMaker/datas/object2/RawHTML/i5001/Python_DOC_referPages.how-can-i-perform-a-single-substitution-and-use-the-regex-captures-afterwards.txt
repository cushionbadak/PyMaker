<div class="post-text" itemprop="text">
<p>I am porting a parsing tool from Perl to Python:</p>
<pre class="lang-perl prettyprint-override"><code>my $lineno = 1;
my @data;
for my $line (split /\R/, $source) {
    $line =~ s/^([ ]*)//;
    my $indent = length $1;
    push @data, [$lineno++, $indent, $line];
}
</code></pre>
<p>This</p>
<ul>
<li>splits the input into lines, using Unicode line separators,</li>
<li>strips leading space (only U+0020 space characters),</li>
<li>determines the indendation level from the stripped space.</li>
</ul>
<p>I am finding it difficult to translate this to idiomatic Python because <code>re.sub()</code> only returns the string after replacement, but not the match object (which I need to count the removed spaces).</p>
<p>In this <em>particular</em> example, I could simply compare the length of the string before and after the substitution.
But I'm interested in a general solution to this kind of problem:</p>
<p><strong>How can I perform a single substitution while also accessing the regex captures?</strong></p>
<p>Attempt 1 – exfiltrate the match object through a substitution function:</p>
<pre><code>lineno = 1
data = []
re_leading_space = re.compile(r'^([ ]*)')
for line in source.splitlines():  # TODO handle Unicode line seps
    m = None
    def exfiltrate(the_match):
        nonlocal m
        m = the_match
        return ''
    line = re_leading_space.sub(exfiltrate, line, count=1)
    indent = len(m.group(1)) if m is not None else 0
    data.append((lineno, indent, line))
    lineno += 1
</code></pre>
<p>Disadvantage: weird <code>nonlocal</code> data flow.</p>
<p>Attempt 2 – perform the substitution manually:</p>
<pre><code>lineno = 1
data = []
re_leading_space = re.compile(r'^([ ]*)')
for line in source.splitlines():  # TODO handle Unicode line seps
    m = re_leading_space.match(line)
    indent = 0
    if m is not None:
        line = line[m.end():]  # remove matched prefix
        indent = len(m.group(1))
    data.append((lineno, indent, line))
    lineno += 1
</code></pre>
<p>Disadvantage: while otherwise fairly clear, it just ends up being a bad reimplementation of the standard library.</p>
<p>Attempt 3 – perform a match, then match the regex again as a substitution:</p>
<pre><code>lineno = 1
data = []
re_leading_space = re.compile(r'^([ ]*)')
for line in source.splitlines():  # TODO handle Unicode line seps
    m = re_leading_space.match(line)
    line = re_leading_space.sub('', line, count=1)
    indent = len(m.group(1)) if m is not None else 0
    data.append((lineno, indent, line))
    lineno += 1
</code></pre>
<p>Disadvantage: while comparatively concise, this needlessly matches the pattern twice. Care has to be taken to provide the same flags etc. to <code>match()</code> and <code>sub()</code>.</p>
<p>So what would be the Pythonic solution to this problem?
I couldn't find “one and only one obvious way to do it.”
Maybe I'm missing a particular idiom?</p>
</div>
<div class="post-text" itemprop="text">
<p>I strongly doubt you'll find any way to do regular expressions in Python that's as natural as it is in Perl. Regex are part of Perl's design at a very low level, while they're not nearly as central to Python.</p>
<p>So my first suggestion is to consider if you can avoid using regex all together. For your example problem that would be easy, just use <code>line.lstrip(' ')</code> and compare lengths to figure out how much indentation was removed. Maybe some other problems you'd consider will also have easy implementations using string methods, rather than regex.</p>
<p>I really doubt there is any solution for general regex substitutions that is massively better than all of the options you've considered. I'd probably use something like your Attempt 2 myself, or maybe Attempt 1 where the indentation amount was saved by the inner function, rather than the match object itself.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">Match objects</a> have an <code>expand</code> method, which is documented as:</p>
<blockquote>
<p>Return the string obtained by doing backslash substitution on the
  template string template, as done by the sub() method. Escapes such as
  \n are converted to the appropriate characters, and numeric
  backreferences (\1, \2) and named backreferences (\g&lt;1&gt;, \g) are
  replaced by the contents of the corresponding group.</p>
</blockquote>
<p>This allows matching only once and doing the substitution using the match, like this:</p>
<pre><code>data = []
re_leading_space = re.compile(r'^([ ]*)(.*)')
for lineno, line in enumerate(source.splitlines()):  # TODO handle Unicode line seps
    m = re_leading_space.match(line)
    indent = 0
    if m is not None:
        line = m.expand(r'\2')
        indent = len(m.group(1))
    data.append((lineno, indent, line))
</code></pre>
</div>
<span class="comment-copy">Hmm, OK thank you for re-affirming that there isn't a better way. I ended up going with a variant of attempt 2.</span>
<span class="comment-copy">I don't see how this is relevant to the question. What are you planning to do with that <code>expand</code> method?</span>
<span class="comment-copy">I've added an example of how to use it, since apparently the documentation wasn't enough.</span>
<span class="comment-copy">This is actually somewhat helpful, as it would allow me to implement attempt 2 correctly in the general case. E.g. <code>def substitute_match(match, orig, template): return orig[:match.start()] + match.expand(template) + orig[match.end():]</code>. I won't be adding another capture group for the non-matched string (this has nontrivial implications in connection with <code>regex.match(..., pos=n)</code>).</span>
<span class="comment-copy"><code>m.expand(r'\2')</code> the same thing as <code>m.group(2)</code>. It's not useful at all here. If you need access to the content of a group, use <code>group</code>, not <code>expand</code>.</span>
<span class="comment-copy">You are correct, but I was attempting to answer this part of the original question: <i>How can I perform a single substitution while also accessing the regex captures?</i></span>
