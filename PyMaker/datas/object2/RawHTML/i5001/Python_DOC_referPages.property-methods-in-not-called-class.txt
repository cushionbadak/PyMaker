<div class="post-text" itemprop="text">
<pre><code>class Parrot:
    def __init__(self):
        self._voltage = 100000

    @property
    def voltage(self):
        """Get the current voltage."""
        return self._voltage
</code></pre>
<p>I have the code above (found <a href="https://docs.python.org/3/library/functions.html#repr" rel="nofollow noreferrer">here</a>) and I wish to understand if there is any usability for not calling the class and getting the following result.</p>
<pre><code>&gt;&gt;&gt; Parrot.voltage
&lt;property at 0x7f19e83cdf48&gt;
</code></pre>
<p>I understand that the usual would be</p>
<pre><code>&gt;&gt;&gt; Parrot().voltage
100000
</code></pre>
<p>For usability, I mean that <code>Parrot.voltage</code> has many methods of the @property available, such as <code>deleter, fdel, getter</code>, etc. However, I am not understanding how to use these.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I wish to understand if there is any usability for not calling the class and getting the following result.</p>
</blockquote>
<pre><code>&gt;&gt;&gt; Parrot.voltage
&lt;property at 0x7f19e83cdf48&gt;
</code></pre>
<p>Well, you could ask the same question about getting a function back when looking up a method on a class, ie:</p>
<pre><code>bruno@bigb:~$ python3
&gt;&gt;&gt; class Foo():
...     def bar(self):
...         return 42
... 
&gt;&gt;&gt; Foo.bar
&lt;function Foo.bar at 0x7fab209c5510&gt;
</code></pre>
<p>In this example, you could keep a reference to this function and call it later passing it a <code>Foo</code> instance as <code>self</code> argument:</p>
<pre><code>&gt;&gt;&gt; f = Foo.bar
&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; f(foo)
42
&gt;&gt;&gt; 
</code></pre>
<p>It's actually just what Python does when you call the method on an instance (using <code>foo.bar()</code> instead of <code>Foo.bar(foo)</code>). You could do the same with your <code>property</code> object:</p>
<pre><code>&gt;&gt;&gt; class Parrot:
...     def __init__(self):
...         self._voltage = 100000
...     @property
...     def voltage(self):
...         """Get the current voltage."""
...         return self._voltage
... 
&gt;&gt;&gt; p = Parrot()
&gt;&gt;&gt; Parrot.voltage.__get__(p)
100000
&gt;&gt;&gt; 
</code></pre>
<p>Here again, that's actually what Python does behind the scene when it sees something like:</p>
<pre><code>&gt;&gt;&gt; p.voltage
</code></pre>
<p>FWIW, python's functions are descriptors too so the real equivalent of <code>foo.bar()</code> is actually <code>Foo.bar.__get__(foo)()</code></p>
<p>All this might look useless, and you usually don't use methods nor properties that way indeed - you just look them up on the instances, not on the class, and let Python do the grunt work. But having the whole object model implemented in terms of a couple simple concepts (classes, metaclasses, callables and the attribute resolution rules - including the descriptor protocol) makes the language highly dynamic and gives  opportunities to hook into the whole mechanism and customize it. As an example (general example I mean) this is specially handy for framework code by vastly reducing the boilerplate. </p>
</div>
<span class="comment-copy">what is the problem in creating the object. Without object class is not initilised hence can't get those values</span>
<span class="comment-copy">What do you mean <i>"any usability"</i>? That's just an artefact of the way properties are implemented, as a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">descriptor</a> on the class rather than an attribute on the instance.</span>
<span class="comment-copy"><code>p = Parrot</code> just makes <code>p</code> a reference to <code>Parrot</code> and so <code>x = p()</code> would be equivalent to <code>x = Parrot()</code>.</span>
