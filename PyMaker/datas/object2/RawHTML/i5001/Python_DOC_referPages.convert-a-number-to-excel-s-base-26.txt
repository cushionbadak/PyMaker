<div class="post-text" itemprop="text">
<p>OK, I'm stuck on something seemingly simple. I am trying to convert a number to base 26 (ie. 3 = C, 27 = AA, ect.). I am guessing my problem has to do with not having a 0 in the model? Not sure. But if you run the code, you will see that numbers 52, 104 and especially numbers around 676 are really weird. Can anyone give me a hint as to what I am not seeing? I will appreciate it. (just in case to avoid wasting your time, <code>@</code> is ascii char 64, <code>A</code> is ascii char 65)</p>
<pre><code>def toBase26(x):
    x = int(x)
    if x == 0:
        return '0'
    if x &lt; 0:
        negative = True
        x = abs(x)
    else:
        negative = False
    def digit_value (val):
        return str(chr(int(val)+64))
    digits = 1
    base26 = ""
    while 26**digits &lt; x:
        digits += 1
    while digits != 0:
        remainder = x%(26**(digits-1))
        base26 += digit_value((x-remainder)/(26**(digits-1)))
        x = remainder
        digits -= 1
    if negative:
        return '-'+base26
    else:
        return base26

import io    
with io.open('numbers.txt','w') as f:
    for i in range(1000):
        f.write('{} is {}\n'.format(i,toBase26(i)))
</code></pre>
<p>So, I found a temporary workaround by making a couple of changes to my function (the 2 if statements in the while loop). My columns are limited to 500 anyways, and the following change to the function seems to do the trick up to x = 676, so I am satisfied. However if any of you find a general solution for any x (may be my code may help), would be pretty cool!</p>
<pre><code>def toBase26(x):
    x = int(x)
    if x == 0:
        return '0'
    if x &lt; 0:
        negative = True
        x = abs(x)
    else:
        negative = False
    def digit_value (val):
        return str(chr(int(val)+64))
    digits = 1
    base26 = ""
    while 26**digits &lt; x:
        digits += 1
    while digits != 0:
        remainder = x%(26**(digits-1))
        if remainder == 0:
            remainder += 26**(digits-1)
        if digits == 1:
            remainder -= 1
        base26 += digit_value((x-remainder)/(26**(digits-1)))
        x = remainder
        digits -= 1
    if negative:
        return '-'+base26
    else:
        return base26
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problematic when converting to Excel’s “base 26” is for Excel, a number <code>AA</code> is actually <code>26 * 26**1 + 26 * 26**0</code> while normal base 26 number systems would make a <code>1 * 26**2 + 1 * 26**1 + 0 * 26**0</code> out of that. So we cannot use the normal ways here to convert these numbers.</p>
<p>Instead, we have to roll our own <code>divmod_excel</code> function:</p>
<pre><code>def divmod_excel(n):
    a, b = divmod(n, 26)
    if b == 0:
        return a - 1, b + 26
    return a, b
</code></pre>
<p>With that, we can create a <code>to_excel</code> function:</p>
<pre><code>import string
def to_excel(num):
    chars = []
    while num &gt; 0:
        num, d = divmod_excel(num)
        chars.append(string.ascii_uppercase[d - 1])
    return ''.join(reversed(chars))
</code></pre>
<p>For the other direction, this is a bit simpler</p>
<pre><code>from functools import reduce
def from_excel(chars):
    return reduce(lambda r, x: r * 26 + x + 1, map(string.ascii_uppercase.index, chars), 0)
</code></pre>
<hr/>
<p>This set of functions does the right thing:</p>
<pre><code>&gt;&gt;&gt; to_excel(26)
'Z'
&gt;&gt;&gt; to_excel(27)
'AA'
&gt;&gt;&gt; to_excel(702)
'ZZ'
&gt;&gt;&gt; to_excel(703)
'AAA'
&gt;&gt;&gt; from_excel('Z')
26
&gt;&gt;&gt; from_excel('AA')
27
&gt;&gt;&gt; from_excel('ZZ')
702
&gt;&gt;&gt; from_excel('AAA')
703
</code></pre>
<p>And we can actually confirm that they work correctly opposite of each other by simply checking whether we can chain them to reproduce the original number:</p>
<pre><code>for i in range(100000):
    if from_excel(to_excel(i)) != i:
        print(i)
# (prints nothing)
</code></pre>
</div>
<span class="comment-copy">Typically, you would need a symbol for <code>0</code>, and 26 should be the first double-digit number for base 26. Compare bases 2 and 10, where those numbers are the first double digit numbers and digit values range from <code>0</code> to <code>n-1</code>.</span>
<span class="comment-copy">Right, but that doesn't really solve what I am trying to do. I need excel style columns and an easy conversion from column number to column label.</span>
<span class="comment-copy">Isn’t @ your zero symbol?</span>
<span class="comment-copy">@Yaroslav What you are trying to do is not convert to base26. You are trying to map numbers to letters.</span>
<span class="comment-copy">@Ev. Kounis. Yes, so what's the best way to convert 1000 to letters? I am getting something better by adding if remainder == 0: remainder += 26**(digits-1) in the while loop, but it is still missing out on the A as first 'digit'</span>
<span class="comment-copy">You forgot to define <code>divmod</code> I believe.</span>
<span class="comment-copy">@IMCoins That one <a href="https://docs.python.org/3/library/functions.html#divmod" rel="nofollow noreferrer">is built-in</a>.</span>
<span class="comment-copy">Didn't know, thanks. :)</span>
<span class="comment-copy">For you my good sir, my hat is off. I was basically coming up to your solution with my second function, but yours is the generalization of what I was doing. Nice.</span>
