<div class="post-text" itemprop="text">
<p>Suppose I have a Python array <code>a=[3, 5, 2, 7, 5, 3, 6, 8, 4]</code>. My goal is to iterate through this array 3 elements at a time returning the mean of the top 2 of the three elements.</p>
<p>Using the above array, during my iteration step, the first three elements are <code>[3, 5, 2]</code> and the mean of the top 2 elements is 4. The next three elements are <code>[5, 2, 7]</code> and the mean of the top 2 elements is 6. The next three elements are <code>[2, 7, 5]</code> and the mean of the top 2 elements is again 6. ...</p>
<p>Hence, the result for the above array would be <code>[4, 6, 6, 6, 5.5, 7, 7]</code>.</p>
<p>What is the nicest way to write such a function?</p>
</div>
<div class="post-text" itemprop="text">
<h2>Solution</h2>
<p>You can use some fancy slicing of your list to manipulate subsets of elements. Simply grab each three element sublist, sort to find the top two elements, and then find the simple average (aka. mean) and add it to a result list.</p>
<h2>Code</h2>
<pre><code>def get_means(input_list):
    means = []
    for i in xrange(len(input_list)-2):
        three_elements = input_list[i:i+3]
        sum_top_two = sum(three_elements) - min(three_elements)
        means.append(sum_top_two/2.0)
    return means
</code></pre>
<h2>Example</h2>
<p>You can see your example input (and desired result) like so:</p>
<pre><code>print(get_means([3, 5, 2, 7, 5, 3, 6, 8, 4]))
# [4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
</code></pre>
<h2>And more...</h2>
<p>There are some other great answers that get into more performance directed answers, including one using a generator to avoid large in memory lists: <a href="https://stackoverflow.com/a/49001728/416500">https://stackoverflow.com/a/49001728/416500</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I believe in splitting the code in 2 parts. Here that would be getting the sliding window, getting the top 2 elements, and calculating the mean. cleanest way to do this is using generators</p>
<h1>Sliding window</h1>
<p>Slight variation on <a href="https://stackoverflow.com/a/49001728/1562285">evamicur</a>'s answer using <code>tee</code>, <code>islice</code> and <code>zip</code> to create the window:</p>
<pre><code>def windowed_iterator(iterable, n=2):
    iterators = itertools.tee(iterable, n)
    iterators = (itertools.islice(it, i, None) for i, it in enumerate(iterators))
    yield from zip(*iterators)

windows = windowed_iterator(iterable=a, n=3)
</code></pre>
<blockquote>
<pre><code>[(3, 5, 2), (5, 2, 7), (2, 7, 5), (7, 5, 3), (5, 3, 6), (3, 6, 8), (6, 8, 4)]
</code></pre>
</blockquote>
<h1>top 2 elements</h1>
<p>to calculate the mean of the 2 highest you can use any of the methods used in the other answers, I think the <code>heapq</code> on is the clearest</p>
<pre><code>from heapq import nlargest
top_n = map(lambda x: nlargest(2, x), windows)
</code></pre>
<p>or equivalently</p>
<pre><code>top_n = (nlargest(2, i) for i in windows)
</code></pre>
<blockquote>
<pre><code>[[5, 3], [7, 5], [7, 5], [7, 5], [6, 5], [8, 6], [8, 6]]
</code></pre>
</blockquote>
<h1>mean</h1>
<pre><code>from statistics import mean
means = map(mean, top_n)
</code></pre>
<blockquote>
<pre><code>[4, 6, 6, 6, 5.5, 7, 7]
</code></pre>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>The following code does what you need:</p>
<pre><code>[sum(sorted(a[i:i + 3])[-2:]) / 2 for i in range(len(a) - 2)]
</code></pre>
<p>Given your <code>a=[3, 5, 2, 7, 5, 3, 6, 8, 4]</code>, returns:</p>
<pre><code>[4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code></a> has a neat recipe to extract pairs of items from any iterable, not only indexable. You can adapt it slightly to extract triplets instead:</p>
<pre><code>def tripletwise(iterable):
    a, b, c = itertools.tee(iterable, 3)
    next(b, None)
    next(itertools.islice(c, 2, 2), None)
    return zip(a, b, c)
</code></pre>
<p>Using that, you can simplify iterating over all triplets:</p>
<pre><code>def windowed_means(iterable):
    return [
        (sum(window) - min(window)) / 2.0
        for window in tripletwise(iterable)
    ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As a vectorized approach using Numpy you can do the following:</p>
<pre><code>np.sort(np.column_stack((a[:-2], a[1:-1], a[2:])))[:,-2:].mean(axis=1)
</code></pre>
<p>Demo:</p>
<pre><code>In [13]: a=np.array([3, 5, 2, 7, 5, 3, 6, 8, 4])

In [14]: np.sort(np.column_stack((a[:-2], a[1:-1], a[2:])))[:,-2:].mean(axis=1)
Out[14]: array([4. , 6. , 6. , 6. , 5.5, 7. , 7. ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Iterator-only solution</h2>
<p>foslok's solution is definitely fine, but I wanted to play around and make a version of this with generators. It only stores a deque of length(window_size)
as it iterates through the original list, then finds the n_largest values and calculates the mean thereof. </p>
<pre><code>import itertools as it
from collections import deque
from heapq import nlargest
from statistics import mean

def windowed(iterable, n):
    _iter = iter(iterable)
    d = deque((it.islice(_iter, n)), maxlen=n)
    yield tuple(d)
    for i in _iter:
        d.append(i)
        yield tuple(d)

a = [3, 5, 2, 7, 5, 3, 6, 8, 4]
means = [mean(nlargest(2, w)) for w in windowed(a, 3)]
print(means)   
</code></pre>
<p>result:</p>
<pre><code>[4, 6, 6, 6, 5.5, 7, 7]
</code></pre>
<p>Thus to change both the number of elements (window size) or the n largest elements just change the arguments to the respective functions. This approach also avoids the use of slicing so it can be more easily applied to iterables that you can't or don't want to slice. </p>
<h2>Timings</h2>
<pre><code>def deque_version(iterable, n, k):
    means = (mean(nlargest(n, w)) for w in windowed(iterable, k))
    for m in means:
        pass

def tee_version(iterable, n, k):
    means = (mean(nlargest(n, w)) for w in windowed_iterator(iterable, k))
    for m in means:
        pass

a = list(range(10**5))


n = 3 
k = 2
print("n={} k={}".format(n, k))
print("Deque")
%timeit deque_version(a, n, k)
print("Tee")
%timeit tee_version(a, n, k)

n = 1000 
k = 2
print("n={} k={}".format(n, k))
print("Deque")
%timeit deque_version(a, n, k)
print("Tee")
%timeit tee_version(a, n, k)

n = 50
k = 25
print("n={} k={}".format(n, k))
print("Deque")
%timeit deque_version(a, n, k)
print("Tee")
%timeit tee_version(a, n, k)


result:

n=3 k=2
Deque
1.28 s ± 3.07 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
Tee
1.28 s ± 16.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
n=1000 k=2
Deque
1.28 s ± 8.72 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
Tee
1.27 s ± 2.92 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
n=50 k=25
Deque
2.46 s ± 10.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
Tee
2.47 s ± 2.45 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>So apparently the itertools tee vs deque doens't matter much. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this!</p>
<pre><code>&gt;&gt;&gt; a
[3, 5, 2, 7, 5, 3, 6, 8, 4]
&gt;&gt;&gt; n
3
&gt;&gt;&gt; m
2
&gt;&gt;&gt; [sum(sorted(a[i*n:i*n+n])[1:])/m for i in range(len(a)/n)]
[4, 6, 7]
</code></pre>
<p>That is,</p>
<pre><code>&gt;&gt;&gt; a
[3, 5, 2, 7, 5, 3, 6, 8, 4]
&gt;&gt;&gt; n
3
&gt;&gt;&gt; [i for i in range(len(a)/n)]
[0, 1, 2]
&gt;&gt;&gt; m=2
&gt;&gt;&gt; [a[i*n:i*n+n] for i in range(len(a)/n)]
[[3, 5, 2], [7, 5, 3], [6, 8, 4]]
&gt;&gt;&gt; [sorted(a[i*n:i*n+n]) for i in range(len(a)/n)]
[[2, 3, 5], [3, 5, 7], [4, 6, 8]]
&gt;&gt;&gt; [sorted(a[i*n:i*n+n])[1:] for i in range(len(a)/n)]
[[3, 5], [5, 7], [6, 8]]
&gt;&gt;&gt; [sum(sorted(a[i*n:i*n+n])[1:]) for i in range(len(a)/n)]
[8, 12, 14]
&gt;&gt;&gt; [sum(sorted(a[i*n:i*n+n])[1:])/m for i in range(len(a)/n)]
[4, 6, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>a=[3, 5, 2, 7, 5, 3, 6, 8, 4]
mean_list = [
    mean(x)
        for x in [
            y[1:3]
                for y in [
                    sorted(a[z:z+3])
                        for z in range(len(a))
                            if z &lt; len(a) -2
                ]
        ]
]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can look at it from generators perspective too: </p>
<pre><code>a=[3, 5, 2, 7, 5, 3, 6, 8, 4]

def gen_list():
    for i in range(0, len(a) - 3):
        yield sorted(a[i:i + 3], reverse=True)

apply_division = map(lambda x: sum(x[:2]) / len(x[:2]), gen_list())


if __name__=="__main__":
    result = list(apply_division)
    print(result)
[4.0, 6.0, 6.0, 6.0, 5.5, 7.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You need a sliding window iterator along with the mean of max two elements. I will try to produce a generic solution which can be used with sliding window of size <code>n</code> where n is any positive real number.</p>
<pre><code>from itertools import islice

def calculate_means(items, window_length=3):
     stop_seq = window_length - 1
     sliding_window = [sorted(islice(items[x:],window_length),reverse=True) for x in range(len(items)-stop_seq)]
     return [sum(a[:stop_seq])/stop_seq for a in sliding_window]

&gt;&gt;&gt; calculate_means([3, 5, 2, 7, 5, 3, 6, 8, 4])
&gt;&gt;&gt; [4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For the record, here is a functional version:</p>
<pre><code>&gt;&gt;&gt; f=lambda values:[] if len(values)&lt;=2 else [(sum(values[:3])-min(values[:3]))/2]+f(values[1:])
&gt;&gt;&gt; f([3, 5, 2, 7, 5, 3, 6, 8, 4])
[4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
&gt;&gt;&gt; f([3, 5, 2])
[4.0]
&gt;&gt;&gt; f([3, 5])
[]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://stackoverflow.com/questions/8269916/what-is-sliding-window-algorithm-examples">sliding window algorithm</a> and the third-party <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.windowed" rel="nofollow noreferrer"><code>more_itertools.windowed</code></a> tool:</p>
<pre><code>import statistics as stats

import more_itertools as mit


lst = [3, 5, 2, 7, 5, 3, 6, 8, 4]

[stats.mean(sorted(w)[1:]) for w in mit.windowed(lst, 3)]
# [4, 6, 6, 6, 5.5, 7, 7]
</code></pre>
<p>See also @Maarten Fabré's <a href="https://stackoverflow.com/a/49005973/4531270">related post</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use list comprehension    </p>
<pre><code>from statistics import mean

yourList=[3, 5, 2, 7, 5, 3, 6, 8, 4]

k = 3

listYouWant = [mean(x) for x in [y[1:k] for y in [sorted(yourList[z:z+k]) for z in xrange(len(yourList)) if z &lt; len(yourList) -(k-1)]]]
</code></pre>
<p>yields [4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Don't sort your sub-lists, that operation is <code>nlog(n)</code>!</strong> Instead, find the largest two numbers with an <code>O(n)</code> algorithm. This will increase the efficiency of your solution. The efficiency gain will be more visible if you work on a larger problem of "find sum of top <code>m</code> out of a moving window of <code>k</code> items" for large <code>m</code> and <code>k</code>.</p>
<pre><code>def largestTwoMeans(myList):
    means = []
    for i in xrange(len(myList)-2):
        subList = myList[i:i+3]
        first, second = -float("inf"), -float("inf")
        for f in subList:       
            if f &gt;= first:
                first, second = f, first
            elif first &gt; f &gt; second:
                second = f
        means.append((first+second)/2.0)
    return means

print largestTwoMeans(myList)
Out[222]: [4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
</code></pre>
<p>Here is the generator version:</p>
<pre><code>def largestTwoMeans(myList):
    for i in xrange(len(myList)-2):
        subList = myList[i:i+3]
        first, second = -float("inf"), -float("inf")
        for f in subList:       
            if f &gt;= first:
                first, second = f, first
            elif first &gt; f &gt; second:
                second = f
        yield (first+second)/2.0

print list(largestTwoMeans(myList))
Out[223]: [4.0, 6.0, 6.0, 6.0, 5.5, 7.0, 7.0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To sort three numbers, we need a maximum of three comparisons. To find the lowest of three numbers we only need two by quickselect. We also don't need to make any sublist copies:</p>
<pre><code>a,b,c

a &lt; b
? (a &lt; c ? a : c)
: (b &lt; c ? b : c)
</code></pre>
<pre class="lang-py prettyprint-override"><code>def f(A):
  means = [None] * (len(A) - 2)

  for i in xrange(len(A) - 2):
    if A[i] &lt; A[i+1]:
      means[i] = (A[i+1] + A[i+2]) / 2.0 if A[i] &lt; A[i+2] else (A[i] + A[i+1]) / 2.0
    else:
      means[i] = (A[i] + A[i+2]) / 2.0 if A[i+1] &lt; A[i+2] else (A[i] + A[i+1]) / 2.0

  return means

print f([3, 5, 2, 7, 5, 3, 6, 8, 4])
</code></pre>
</div>
<span class="comment-copy">What if the array has less than 3 elements?</span>
<span class="comment-copy">The original question I had in mind was that for an input array of length m, we iterate through n elements at a time while finding the mean of the top k elements such that m &gt;= n &gt;= k. The question was phrased in the above manner for simplicity. I was hoping to generalize a good solution to the general case.</span>
<span class="comment-copy">I'm voting to close this question as off-topic because it's just asking for code.  Probably a homework question.</span>
<span class="comment-copy">My solution seems to be about 4-5 times faster than (foslock's) accepted answer :) <a href="https://repl.it/repls/AliveTechnoGraph" rel="nofollow noreferrer">repl.it/repls/AliveTechnoGraph</a></span>
<span class="comment-copy">You could avoid sorting using <code>sum_top_two = sum(three_elements) - min(three_elements)</code></span>
<span class="comment-copy">An improvement might be to turn the function into a generator, by replacing the <code>means.append</code> line with <code>yield</code>. This would be more memory efficient in case <code>input_list</code> is very large</span>
<span class="comment-copy">@gyre Good suggestion! Personally I like to mirror how I operate on the list myself (get the top two by sorting the three elements in my head)</span>
<span class="comment-copy">@thegreatemu Also a good suggestion, and the written function is very easily converted to return generator. I return a list here since that's what the question asked.</span>
<span class="comment-copy">My solution seems to be about 4-5 times faster :) <a href="https://repl.it/repls/AliveTechnoGraph" rel="nofollow noreferrer">repl.it/repls/AliveTechnoGraph</a></span>
<span class="comment-copy">I like your windowed iterator function, I just timed them both on my machine and got equivalent performance for range(10**5), window size of 3 and top 2. When I make the window size and # largest bigger the deque seems to scale much better</span>
<span class="comment-copy">oops I mistimed, the deque is very slightly faster for large windows, it seems the nlargest dominates in this case anyway</span>
<span class="comment-copy">My solution seems to be about 60-80 times faster :) <a href="https://repl.it/repls/TragicNextCleantech" rel="nofollow noreferrer">repl.it/repls/TragicNextCleantech</a></span>
<span class="comment-copy">My solution seems to be about 50 times faster :) <a href="https://repl.it/repls/TragicNextCleantech" rel="nofollow noreferrer">repl.it/repls/TragicNextCleantech</a></span>
<span class="comment-copy">I didn't bother timing it but yours very well may be faster, it's less general though.</span>
<span class="comment-copy">I'm pretty sure tee is often implemented using deques so the negligible performance difference makes sense</span>
<span class="comment-copy">I hadn't heard that before but it makes sense!</span>
<span class="comment-copy">take a look at <a href="https://docs.python.org/3.6/library/itertools.html#itertools.tee" rel="nofollow noreferrer">docs.python.org/3.6/library/itertools.html#itertools.tee</a></span>
<span class="comment-copy">Well <code>n</code> is 3 in this case so sorting makes sense as it will be faster than manual iteration. Besides you’re comparing numbers to <code>None</code> which is only valid in Python 2.</span>
<span class="comment-copy">That's right but the problem mentions <code>k</code>, for which my answer aims to generalize. The inefficiency of sort will be emphasized as <code>k</code> grows. And yes I coded in Python 2, but I'll address that in my edit. Thank you.</span>
<span class="comment-copy">@FatihAkici Your "Don't sort your sub-lists, that operation is nlog(n)" comment is misleading. Sorting the list of constant size 3 (as the question defines without question) is constant time, and only in the severely generalized case does the time complexity increase. You are not wrong, but be careful of <a href="https://en.wikipedia.org/wiki/Program_optimization" rel="nofollow noreferrer">en.wikipedia.org/wiki/Program_optimization</a></span>
