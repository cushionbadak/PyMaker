<div class="post-text" itemprop="text">
<p>I'm programming in python and have a list of lists of</p>
<pre><code>a=[[1234,32.5,'John',1114],[1234,16.3,'John',1115],[1235,25.3,'John',1116],
  [1239,16.3,'Lisa',1117]]
</code></pre>
<p>How can I merge the lists of the similar element in sub-index <code>[0]</code> and remove the list that contains the smallest element of index <code>[3]</code> ?</p>
<p>Expected output:</p>
<pre><code>a=[[1234,48.8,'John',1115],[1235,25.3,'John',1116],[1239,16.3,'Lisa',1117]]
</code></pre>
<p>since </p>
<pre><code> a[1][3] &gt; a[0][3] (1116 &gt; 1115) 
</code></pre>
<p><code>a[0][1]</code> will be added to <code>a[1][1]</code> and <code>a[0]</code> will be completely removed.</p>
<p>I'm planning to use this to a list of ten thousands of lists.</p>
<p>EDIT:</p>
<p>I''ve made:</p>
<pre><code>old=[[1234,32.5,'John',1114],[1234,16.3,'John',1115],[1235,25.3,'John',1116],[1239,16.3,'Lisa',1117]]

memory=old[0]

new=[]

for x, t in enumerate(old):
    if t==memory:
        new.append([t[0],memory[1]+t[1],t[2],t[3]])
        memory=t
</code></pre>
<p>But this would not work on lists if there are more than two lists that are similar in index [0], the code should be run again and again depending on how many similar elements are there. In application, my list of lists would have hundreds of similar elements in a specific index.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you really need is to <em>group</em> your data by the common keys. <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> is made for this, and you can use <a href="https://docs.python.org/3/library/operator.html#operator.itemgetter" rel="nofollow noreferrer"><code>operator.itemgetter</code></a> to group by the key elements of each sublist. </p>
<p>Once iterating over the groups, tracking the respective sum and maximum you need is not hard. This does assume that you intend on <em>keeping the maximum</em> and not removing the minimum, as having more than 2 elements in a group would make this impossible to do while summing the second elements.  </p>
<pre><code>from itertools import groupby
from operator import itemgetter

def merge(data):
    out_data = []
    for _, group in groupby(data, key=itemgetter(0, 2)):
        key_num, to_sum, key_name, to_max = next(group)
        for _, sum_val, _, max_val in group:
            to_sum += sum_val
            to_max = max(to_max, max_val)
        out_data.append([key_num, to_sum, key_name, to_max])
    return out_data
</code></pre>
<p><strong>Demo</strong></p>
<pre><code>&gt;&gt;&gt; a = [[1234,32.5,'John',1114],
         [1234,16.3,'John',1115], 
         [1235,25.3,'John',1116], 
         [1239,16.3,'Lisa',1117]]

&gt;&gt;&gt; merge(a)
[[1234, 48.8, 'John', 1115],
 [1235, 25.3, 'John', 1116],
 [1239, 16.3, 'Lisa', 1117]]
</code></pre>
<hr/>
<p>It is also worth noting that if you have many operations to apply to tabular data like this, you may want to look into the <a href="https://pandas.pydata.org/" rel="nofollow noreferrer">Pandas library</a>. Using Pandas, a succinct solution to your problem could be </p>
<pre><code>import pandas as pd

def pd_merge(data):
    df = pd.DataFrame(data)    
    return (df.groupby((0, 2), as_index=False)
              .agg({1: 'sum', 3: 'max'})
              .sort_index(1))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Below is my solution, it seems that can handle elements that more than 2:</p>
<pre><code>from collections import defaultdict

a=[[1234,32.5,'John',1114], [1234,32.5,'John',1113],[1234,16.3,'John',1115],[1235,25.3,'John',1116],  [1239,16.3,'Lisa',1117]]

def merge_list(data):
    total_dic = defaultdict(list)
    new_data = []
    for elem in a:
        total_dic[elem[0]].append(elem)

    for dic_elem in total_dic:
        total_dic[dic_elem].sort(key=lambda x: x[3], reverse=False)
        if(len(total_dic[dic_elem]) &gt; 1):
            new_data.append(total_dic[dic_elem][1:])
        else:
            new_data.append(total_dic[dic_elem][0])
    return new_data

print(merge_list(a))

[[[1234, 32.5, 'John', 1114], [1234, 16.3, 'John', 1115]], [1235, 25.3, 'John', 1116], [1239, 16.3, 'Lisa', 1117]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thank you everyone, I've managed to answer my problem with the use of itertool's groupby</p>
<p>Here is my working prototype:</p>
<pre><code>from itertools import groupby
from operator import itemgetter


def merge(data):
    out_data = []
    for key, group in groupby(data, key=itemgetter('name','time')):
        id_temp = 0
        dep_temp=0

        dict_temp={}
        for t in group:
            dict_temp=t
            if t["deposit_id"] &lt; id_temp:
                dict_temp['deposit_id']=id_temp
            else:
                id_temp=dict_temp['deposit_id']
            dep_temp+=dict_temp['deposit']
        dict_temp['deposit'], dict_temp['deposit_id'] = dep_temp, id_temp
        out_data.append(dict_temp)
    return out_data

a = [{'name':'John','time':1234,'deposit':16.7,'deposit_id':1115},
 {'name':'John','time':1234,'deposit':24.3,'deposit_id':1116},
 {'name':'John','time':1234,'deposit':65.3,'deposit_id':1117},
 {'name':'John','time':1235,'deposit':95.3,'deposit_id':1118},
 {'name':'Lisa','time':1235,'deposit':95.3,'deposit_id':1119}]

b=merge(a)

for t in b:
    print t
</code></pre>
<p>Output</p>
<pre><code>{'deposit_id': 1117, 'deposit': 106.3, 'name': 'John', 'time': 1234}
{'deposit_id': 1118, 'deposit': 95.3, 'name': 'John', 'time': 1235}
{'deposit_id': 1119, 'deposit': 95.3, 'name': 'Lisa', 'time': 1235}
</code></pre>
</div>
<span class="comment-copy">What have you attempted, and what in particular are you struggling with?</span>
<span class="comment-copy">I already made a function that would do the function in two lists, but it's not efficient because I'm planning to use this to an enormous list of lists.</span>
<span class="comment-copy">Really hard to tell which subindices are suppose to merge and which ones are supposed to sum. Which are unique ids?</span>
<span class="comment-copy">Then I suggest you add your inefficient code, and detail why you believe it is inefficient. This would increase the likelihood of your question helping others, and of getting a suitable answer.</span>
<span class="comment-copy">I''ve made:  old=[[1234,32.5,'John',1114],[1234,16.3,'John',1115],[1235,25.3,'John',1116],   [1239,16.3,'Lisa',1117]]  memory=old[0]  new=[]  for x, t in enumerate(old):      if t[0]==memory[0]:           new.append([t[0],memory[1]+t[1],t[2],t[3]])           memory=t  but this would not work on lists if there are more than two lists that are similar in index [0], the code should be run again and again depending on how many similar elements are there.</span>
<span class="comment-copy">Thank you! I apologize if I did not explain it well. I will see into that pandas groupby function. I'm  working on dataframes with list of dictionaries and I will study this deeply. Gratitude!</span>
