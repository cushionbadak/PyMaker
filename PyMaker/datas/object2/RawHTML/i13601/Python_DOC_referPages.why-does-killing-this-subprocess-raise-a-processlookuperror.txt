<div class="post-text" itemprop="text">
<p>I can't understand when I need to kill subprocess.</p>
<pre><code>for package in server.packages:
    n = subprocess.Popen(['which', package], stdout=subprocess.DEVNULL)
    n.wait()
    if n.returncode != 0:
        n.kill()
        &lt;some other code&gt;
</code></pre>
<p>I'm getting error (using Python3):</p>
<pre><code>ProcessLookupError: [Errno 3] No such process
</code></pre>
<p>Can anybody explain me when subprocess kill himself and when I need to do it manually ?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, <code>Popen.wait</code> is a blocking call that waits for the subprocess to terminate. So there is normally no need to kill the subprocess after the call to <code>wait</code> returns. See Python docs on <a href="https://docs.python.org/3.3/library/subprocess.html#subprocess.Popen.wait" rel="nofollow">Popen.wait()</a>. </p>
<p>Now, if you understand how that works, you can see that your code fails because at some point <code>Popen.returncode</code> returns a non-zero value and you then try to kill a process that does not exist any more.</p>
<p>This is why a <code>ProcessLookupError</code> is raised.</p>
<p>Now, as pointed out by another answer here, it is possible the returned value will be <code>None</code>, which indicates a possible (perhaps OS-specific) problem with the subprocess and could be checked for. The Python docs <a href="https://docs.python.org/3.3/library/subprocess.html#subprocess.Popen.returncode" rel="nofollow">merely state</a> that <code>None</code> indicates the process is still running (a negative value is also possible; see the docs for details).</p>
<p>Apart from that, if you need to kill a still-running subprocess for some reason, you either have to set and catch a timeout using:</p>
<pre><code>   try:
      # time out in five seconds
      n.wait(timeout=5)
   except TimeOutExpired:
      # you can use kill, terminate or send_signal method; see the docs
      n.kill()
</code></pre>
<p>... or, alternatively, not use <code>wait</code> at all: Instead, let the subprocesses run while you do something else in your code, and then kill them later:</p>
<pre><code>   import os

   processes = []
   for package in server.packages:
      n = subprocess.Popen(['which', package], stdout=subprocess.DEVNULL)
      processes.append(n)

   &lt;some other code while the subprocesses run (and possibly terminate)&gt;

   for p in processes:
      try:
          p.kill()
      except OSError:
          # silently fail if the subprocess has exited already
          pass
</code></pre>
<p>What if you want to just check if the process is alive? Unfortunately, Python stdlib does not have a good, convenient way to check if a process is running. But, it can be conveniently done using <a href="https://pypi.python.org/pypi/psutil" rel="nofollow">psutil</a>, a third-party library. With it, checking if a process exists is as easy as:</p>
<pre><code>   pid = n.pid # where n is a subprocess.Popen object from above examples
   import psutil
   psutil.pid_exists(pid) # returns True or False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you can do is to set a timeout of the process, once the timeout is attained then you can terminate the process by using:</p>
<pre><code>n.terminate()
</code></pre>
<p>you can also use     </p>
<pre><code>.is_alive() 
</code></pre>
<p>to check if the process or thread is alive or not and then terminate it if it has already attained the timeout.</p>
</div>
<div class="post-text" itemprop="text">
<p>You would have to examine the result from wait to determine why it returned. If it returns <code>None</code> the wait returned for other reasons than that the subprocess has terminated. If it returns other than <code>None</code> it would not be appropriate to <code>kill</code> the process, but that doesn't mean that it automatically is appropriate to <code>kill</code> it if it returned <code>None</code>. </p>
<p>For example, depending on OS the returning of <code>None</code> may indicate a state change for the process for which you wouldn't want to kill it. But also there may be scenarios where it returns <code>None</code>, but is still running an may terminate before you reach the <code>kill</code>.</p>
<p>So if you choose to <code>kill</code> the process you should probably enclose it in a <code>try</code>-<code>catch</code>-statement in order to handle the scenario where the subprocess has terminated.</p>
<p>Also from python3.3 you could add <code>timeout</code> (eg <code>n.wait(timeout=seconds_to_wait)</code> argument to wait in order to not wait indefinitely.</p>
<p>Your code might then look something like:</p>
<pre><code>for package in server.packages:
    n = subprocess.Popen(['which', package], stdout=subprocess.DEVNULL)
    rc = n.wait() # in python3 you could supply timeout argument
    if rc != None:
        try:
            n.kill()
        except ProcessLookupError:
            pass
        code_to_run_when_killed()
    elif rc != 0:
        code_to_run_when_failed() # or perhaps you should raise exception
    else:
        code_to_run_when_exited_successfully()
</code></pre>
</div>
<span class="comment-copy">Just a side-note: <a href="https://docs.python.org/3/library/shutil.html" rel="nofollow noreferrer"><code>shutil.which</code></a> will return where the location of an executable is, and <code>None</code> if it doesn't exist</span>
<span class="comment-copy">This is partially wrong: <code>.is_alive()</code> is not a method that's available on <code>subprocess.Popen</code> objects.</span>
<span class="comment-copy">Note that <code>n.terminate()</code> is not guaranteed to actually terminate the process. Under POSIX it sends the <code>SIGTERM</code> to the process, which may be caught and discarded or result in delayed termination. You'd then have to wait for the process to actually terminate.</span>
