<div class="post-text" itemprop="text">
<p>I am trying to make a simple multi-threaded command prompt for a small AngularJS app I'm running.</p>
<p>In this prompt, I want to type in a command without it being broken up by output, like below:</p>
<pre><code>Output
More output HTTP 1.0
HTTP Request from 127.0.0.1 for /img/foo.png - 200
&gt; Humble command I'm ty-OH NO BUT MORE OUTPUT
SUCH ANNOYING OUTPUT FOR FAVICON.ICO - 404
-ping.. Dang it.
</code></pre>
<p>Instead, I want it like this:</p>
<pre><code>Output
More output HTTP 1.0
HTTP Request from 127.0.0.1 for /img/foo.png - 200
OH NO BUT MORE OUTput and it's not breaking up what
you're typing... :/ - favicon.ico 404 btw...
&gt; Humble command I'm typing that's not broken up
</code></pre>
<p>I'm not sure if it's possible on the command prompt, and if needed, I might just import pygame or take a look at pyglet if needed, but I believe that the command prompt would be better for my purpose.</p>
<p>I hope I explained it for you, but if you need more information, please ask below!</p>
<p><em>Using Python 3.x</em></p>
<p><a href="https://gist.github.com/MathManiac0/de5a717185ed4cded8c7" rel="nofollow noreferrer">Gist</a></p>
<p><a href="https://i.stack.imgur.com/VFqzI.png" rel="nofollow noreferrer"><img alt="What it looks like" src="https://i.stack.imgur.com/VFqzI.png"/></a></p>
<p>this is what it looks like</p>
<p><strong>Edit:</strong> I added cmd.Cmd to be my command prompt and did what J. F. Sebastian told me to do, but it acts.. strange..</p>
</div>
<div class="post-text" itemprop="text">
<p>To avoid output from other threads interrupting your input, organize your script to perform standard I/O only in the main thread e.g., replace <code>sys.stdout</code>, <code>sys.stderr</code> with file-like objects that queue writes and consume the queue when you've done input:</p>
<pre><code>import sys
from queue import Queue, Empty

class QueuedFile:
   def __init__(self, queue):
       self.queue = queue
   def write(self, text):
       self.queue.put(text)
   def flush(self):
       pass # noop

q = Queue()
sys.stdout = sys.stderr = QueuedFile(q)

# print from multiple threads while accepting input...

# print queued output
while True:
    try:
        sys.__stdout__.write(q.get(block=False))
    except Empty:
        break # no more output
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like you want to run the python script as a background process:</p>
<pre><code>&gt;python yourScript.py &amp;
&gt;now it won't interrupt you but you'll have to pipe output to a file if you want to read it
</code></pre>
<p>The <code>&amp;</code> is what does that.</p>
<p>If you want to run the script without output in the background <em>from within Python</em>, I would consider using <a href="https://docs.python.org/3/library/threading.html" rel="nofollow">threading</a>.</p>
</div>
<span class="comment-copy">Interesting... Is there a module for that, or would I need to make it?</span>
<span class="comment-copy">@MathManiac: I've added code example</span>
<span class="comment-copy">My head is thumping right now, but you've been a great help! I'll go and study the queue module...</span>
<span class="comment-copy">I've been looking it up and why do you have a try/except block when you can just leave the <code>block</code> arg to be True?</span>
<span class="comment-copy">@MathManiac: To break the loop when the available queued output is exhausted. I assume there is also an outer loop i.e., you read input without interruptions then you print output so far then you read input again, etc.</span>
<span class="comment-copy">While this doesn't solve the problem I want to solve,+1 for the info! I might use it later!</span>
