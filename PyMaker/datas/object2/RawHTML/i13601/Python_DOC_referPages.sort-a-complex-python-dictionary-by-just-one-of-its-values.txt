<div class="post-text" itemprop="text">
<p>I am writing a little optimization tool for purchasing stamps at the post office.</p>
<p>In the process <strong>I am using a dictionary</strong>, which I am sorting according to what I learned in this other "famous" question:
<a href="https://stackoverflow.com/questions/613183/sort-a-python-dictionary-by-value">Sort a Python dictionary by value</a></p>
<p>In my case my dictionary is mildly more complex:<br/>
 - one <strong>four-item-tuple</strong> to make the <strong>key</strong><br/>
 - and another <strong>five-item-tuple</strong> to make the <strong>data</strong>.</p>
<p>The origin of this dictionary is an iteration, where each successful loop is adding one line:</p>
<pre><code>MyDicco[A, B, C, D] = eval, post, number, types, over
</code></pre>
<p>This is just a tiny example of a trivial run, trying for 75 cents:<br/>
   {<br/>
   (0, 0, 1, 1): (<strong>22</strong>, 75, 2, 2, 0)<br/>
   (0, 0, 0, 3): (<strong>31</strong>, 75, 3, 1, 0)<br/>
   (0, 0, 2, 0): (<strong>2521</strong>, 100, 2, 1, 25)<br/>
   (0, 1, 0, 0): (<strong>12511</strong>, 200, 1, 1, 125)<br/>
   (1, 0, 0, 0): (<strong>27511</strong>, 350, 1, 1, 275)<br/>
   }  </p>
<p>So far I am using this code to sort (is is working):  </p>
<pre><code>MyDiccoSorted = sorted(MyDicco.items(), key=operator.itemgetter(1))
</code></pre>
<p>I am sorting by my evaluation-score, because the sorting is all about bringing the best solution to the top. The evaluation-score is just one datum out of a five-item-tuple (in the example those are the evaluation-scores: 22, 31, 2521, 12511 and 27511).</p>
<p>As you can see in the example above, it is sorting (as I want it) by the second tuple, index 1. But I had to (grumpily) bring my "evaluation-score" to the front of my second tuple. The code is obviously using the entire second-tuple for the sorting-process, which is heavy and not needed.</p>
<hr/>
<p><strong>Here is my question: How can I please sort more precisely. I do not want to sort by the entire second tuple of my dictionary: I want to target the first item precisely.<br/>
   And ideally I would like to put this value back to its original position, namely to be the last item in the second tuple - and still sort by it.</strong></p>
<hr/>
<p>I have read-up on and experimented with the syntax of operator.itemgetter() but have not managed to just "grab" the "first item of my second item".
<a href="https://docs.python.org/3/library/operator.html?highlight=operator.itemgetter#operator.itemgetter" rel="nofollow noreferrer">https://docs.python.org/3/library/operator.html?highlight=operator.itemgetter#operator.itemgetter</a></p>
<p>(note: It is permissible to use tuples as keys and values, according to:<br/>
<a href="https://docs.python.org/3/tutorial/datastructures.html?highlight=dictionary" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html?highlight=dictionary</a>
and those are working fine for my project; this question is just about better sorting)</p>
<hr/>
<p><strong>For those who like a little background</strong> (you will yell at me that I should use some other method, but I am learning about dictionaries right now (which is one of the purposes of this project)):</p>
<p>This optimization is for developing countries, where often certain values of stamps are not available, or are limited in stock at any given post office. It will later run on Android phones.</p>
<p>We are doing regular mailings (yes, letters). Figuring out the exact postage for each destination with the available values and finding solutions with low stocks of certain values is a not-trivial process, if you consider six different destination-based-postages and hundreds of letters to mail.</p>
<p>There are other modules which help turning the theoretical optimum solution into something that can actually be purchased on any given day, by strategic dialog-guidance...</p>
<p>About my dictionary in this question:
I iterate over all reasonable (high enough to make the needed postage and only overpaying up to a fraction of one stamp) combinations of stamp-values.  </p>
<p>Then I calculate a "success" value, which is based on the number of stamps needed (priority), the number of types needed (lower priority)(because purchasing different stamps takes extra time at the counter) and a very high penalty for paying-over. So lowest value means highest success.</p>
<p>I collect all reasonable "solutions" in a dictionary where the tuple of needed-stamps serves as the key, and another tuple of some results-data makes up the values. It is mildly over-defined because a human needs to read it at this phase in the project (for debugging).</p>
<p>If you are curious and want to read the example (first line):<br/>
The colums are:  </p>
<ul>
<li>number of stamps of 350 cents </li>
<li>number of stamps of 200 cents </li>
<li>number of stamps of 50 cents</li>
<li>number of stamps of 25 cents</li>
<li>evaluation-score</li>
<li>calculated applied postage</li>
<li>total number of stamps applied</li>
<li>total number of stamp-types</li>
<li>over-payment in cents if any</li>
</ul>
<p><strong>Or in words:</strong> (Assuming a postal service is offering existing stamps of 350, 200, 50 and 25 cents), I can apply postage of 75 cents by using 1x 50 cents and 1x 25 cents. This gives me a success-rating of 22 (the best in this list), postage is 75 cents, needing two stamps of two different values and having 0 cents overpayment.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can just use a double index, something like this should work:</p>
<pre><code>MyDiccoSorted = sorted(MyDicco.items(), key=lambda s: s[1][2])
</code></pre>
<p>Just set <code>2</code> to whatever the index is of the ID in the tuple.</p>
</div>
<div class="post-text" itemprop="text">
<p>I find it easier to use <a href="https://docs.python.org/2/tutorial/controlflow.html#lambda-expressions" rel="nofollow">lambda expressions</a> than to remember the various <code>operator</code> functions.</p>
<p>Assuming, for the moment, that your eval score is the 3rd item of your value tuple (i.e. <code>(post, number, eval, types, over</code>):</p>
<pre><code>MyDiccoSorted = sorted(MyDicco.items(), key=lamba x:x[1][2])
</code></pre>
<p>Alternatively, you can create a named function to do the job:</p>
<pre><code>def myKey(x): return x[1][2]
MyDiccoSorted = sorted(MyDicco.items(), key=myKey)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a lambda expression instead of <code>operator.itemgetter()</code> , to get the precise element to sort on. Assuming your <code>eval</code> is the first item in the tuple of <code>values</code>, otherwise use the index of the precise element you want in <code>x[1][0]</code> .Example -</p>
<pre><code>MyDiccoSorted = sorted(MyDicco.items(), key=lambda x: x[1][0])
</code></pre>
<hr/>
<p>How this works -</p>
<p>A <code>dict.items()</code> returns something similar to a list of tuples (though not exactly that in Python 3.x) , Example -</p>
<pre><code>&gt;&gt;&gt; d = {1:2,3:4}
&gt;&gt;&gt; d.items()
dict_items([(1, 2), (3, 4)])
</code></pre>
<p>Now, in <code>sorted()</code> function, the <code>key</code> argument accepts a function object (which can be lambda , or <code>operator.itemgetter()</code> which also return a function, or any simple function) , the function that you pass to <code>key</code> should accept one argument, which would be the element of the list being sorted.</p>
<p>Then that <code>key</code> function is called with each element, and you are expected to return the correct value to sort the list on. An example to help you understand this -</p>
<pre><code>&gt;&gt;&gt; def foo(x):
...     print('x =',x)
...     return x[1]
...
&gt;&gt;&gt; sorted(d.items(),key=foo)
x = (1, 2)
x = (3, 4)
[(1, 2), (3, 4)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>does this do what you need?</p>
<pre><code>sorted(MyDicco.items(), key=lambda x: x[1][0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>index_of_evaluation_score = 0
MyDiccoSorted = sorted(MyDicco.items(), key=lambda key_value: key_value[1][index_of_evaluation_score])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Placing your evaluation score back at the end where you wanted it, you can use the following:</p>
<pre><code>MyDicco = {
    (0, 0, 1, 1): (75, 2, 2, 0, 22),
    (0, 0, 0, 3): (75, 3, 1, 0, 31),
    (0, 0, 2, 0): (100, 2, 1, 25, 2521),
    (0, 1, 0, 0): (200, 1, 1, 125, 12511),
    (1, 0, 0, 0): (350, 1, 1, 275, 27511)} 

MyDiccoSorted = sorted(MyDicco.items(), key=lambda x: x[1][4])

print MyDiccoSorted
</code></pre>
<p>Giving:</p>
<pre><code>[((0, 0, 1, 1), (75, 2, 2, 0, 22)), ((0, 0, 0, 3), (75, 3, 1, 0, 31)), ((0, 0, 2, 0), (100, 2, 1, 25, 2521)), ((0, 1, 0, 0), (200, 1, 1, 125, 12511)), ((1, 0, 0, 0), (350, 1, 1, 275, 27511))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think one of the things you might be looking for is a stable sort.</p>
<p>Sorting functions in Python are generally "stable" sorts. For example, if you sort:</p>
<pre><code> 1 4 6
 2 8 1
 1 2 3
 2 1 8
</code></pre>
<p>by its first column, you'll get:</p>
<pre><code> 1 4 6
 1 2 3
 2 8 1
 2 1 8
</code></pre>
<p>The order of rows sharing the same value in column 1 does not change. <code>1 4 6</code> is sorted before <code>1 2 3</code> because that was the original order of these rows before the column 1 sort. Sorting has been 'stable' since version 2.2 of Python. More details <a href="https://wiki.python.org/moin/HowTo/Sorting/" rel="nofollow noreferrer">here</a>.</p>
<p>On another note I'm interested in how much you had to explain your code. That is a sign that the code would benefit from refactoring to make its purpose clearer.</p>
<p>Named tuples could be used to remove the hard-to-read tuple indices you see in many answer here, e.g. <code>key=lambda x: x[1][0]</code>-- what does that actually mean? What is it doing?</p>
<p>Here's a version using named tuples that helps readers (most importantly, you!) understand what your code is trying to do. Note how the lambda now explains itself much better.</p>
<pre><code>from collections import namedtuple

StampMix = namedtuple('StampMix', ['c350', 'c200', 'c50', 'c25'])
Stats = namedtuple('Stats', ['score', 'postage', 'stamps', 'types', 'overpayment'])

data = {
    (0, 0, 1, 1): (22, 75, 2, 2, 0),
    (0, 0, 0, 3): (31, 75, 3, 1, 0),
    (0, 0, 2, 0): (2521, 100, 2, 1, 25),
    (0, 1, 0, 0): (12511, 200, 1, 1, 125),
    (1, 0, 0, 0): (27511, 350, 1, 1, 275)
}

candidates = {}
for stampmix, stats in data.items():
    candidates[StampMix(*stampmix)] = Stats(*stats)

print(sorted(candidates.items(), key=lambda candidate: candidate[1].score))
</code></pre>
<p>You can see the benefits of this approach in the output:</p>
<pre><code>&gt;&gt;&gt; python namedtuple.py
(prettied-up output follows...)
[
    (StampMix(c350=0, c200=0, c50=1, c25=1), Stats(score=22, postage=75, stamps=2, types=2, overpayment=0)),
    (StampMix(c350=0, c200=0, c50=0, c25=3), Stats(score=31, postage=75, stamps=3, types=1, overpayment=0)),
    (StampMix(c350=0, c200=0, c50=2, c25=0), Stats(score=2521, postage=100, stamps=2, types=1, overpayment=25)),
    (StampMix(c350=0, c200=1, c50=0, c25=0), Stats(score=12511, postage=200, stamps=1, types=1, overpayment=125)),
    (StampMix(c350=1, c200=0, c50=0, c25=0), Stats(score=27511, postage=350, stamps=1, types=1, overpayment=275))
]
</code></pre>
<p>and it will help with your algorithms too. For example:</p>
<pre><code>def score(stats):
    return stats.postage * stats.stamps * stats.types + 1000 * stats.overpayment
</code></pre>
</div>
<span class="comment-copy">This was my first ever question on stackoverflow and I am impressed and very thankful for the response: Superfast and very, very helpful. I just decided to select the first answer, because it does what I need (I have already tested it with my project).  I have mainly selected so fast, that no other users will need to spend time with more answers. I am happy and can move on the the next modules. Thank you all!!</span>
<span class="comment-copy">Thanks, awesomely fast answer. I see in your answer (and from Rob) the syntax key=lambda s: s[1][4]. Assuming that in pythonian way [4] will give me the fifth item of my values-tuple. What does the first [1] do please? Is it a reference to the second item of my keys-tuple? Or where can I please look-up the syntax for this key=lambda solution?</span>
<span class="comment-copy">@MartinZaske Yup. What that does is take in each element of <code>MyDicco</code> and assigns it to <code>s</code>. Then it gets the first element of <code>s</code>, and returns the fourth element of that.</span>
<span class="comment-copy">This would therefore not look at the keys at all. You mean the values, when you write "each element", right? That would be a perfect answer...</span>
<span class="comment-copy">@MartinZaske Right, it'll just take the second element of the tuple returned by <code>.items()</code>, (or the values) and sort by the third element of that.</span>
<span class="comment-copy">Very nice and helpful answer. Thank you. This project is now history for me. But I +1 your answer because it explains this aspect of sorting and of naming very well. And I might come back here later for other projects.</span>
