<div class="post-text" itemprop="text">
<p>What is the most pythonic way to execute a full generator comprehension where you don't care about the return values and instead the operations are purely side-effect-based?</p>
<p>An example would be splitting a list based on a predicate value as discussed <a href="https://stackoverflow.com/questions/949098/python-split-a-list-based-on-a-condition">here</a>.  It's natural to think of writing a generator comprehension</p>
<pre><code>split_me = [0, 1, 2, None, 3, '']
a, b = [], []
gen_comp = (a.append(v) if v else b.append(v) for v in split_me)
</code></pre>
<p>In this case the best solution I can come up with is to use <code>any</code></p>
<pre><code>any(gen_comp)
</code></pre>
<p>However that's not immediately obvious what's happening for someone who hasn't seen this pattern.  Is there a better way to cycle through that full comprehension without holding all the return values in memory?</p>
</div>
<div class="post-text" itemprop="text">
<p>You do so by <em>not using a generator expression</em>.</p>
<p>Just write a proper loop:</p>
<pre><code>for v in split_me:
    if v:
        a.append(v)
    else:
        b.append(v)
</code></pre>
<p>or perhaps:</p>
<pre><code>for v in split_me:
    target = a if v else b
    target.append(v)
</code></pre>
<p>Using a generator expression here is pointless if you are going to execute the generator immediately <em>anyway</em>. Why produce an object plus a sequence of <code>None</code> return values when all you wanted was to append values to two other lists?</p>
<p>Using an explicit loop is both more comprehensible for future maintainers of the code (including you) and more efficient.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>itertools</code> has this consume recipe</p>
<pre><code>def consume(iterator, n):
    "Advance the iterator n-steps ahead. If n is none, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
</code></pre>
<p>in your case <code>n</code> is <code>None</code>, so:</p>
<pre><code>collections.deque(iterator, maxlen=0)
</code></pre>
<p>Which is interesting, but also a lot of machinery for a simple task</p>
<p>Most people would just use a <code>for</code> loop</p>
</div>
<div class="post-text" itemprop="text">
<p>As others have said, don't use comprehensions just for side-effects.</p>
<p>Here's a nice way to do what you're actually trying to do using the <code>partition()</code> recipe from <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>itertools</code></a>:</p>
<pre><code>try:  # Python 3
    from itertools import filterfalse
except ImportError:  # Python 2
    from itertools import ifilterfalse as filterfalse
    from itertools import ifilter as filter


from itertools import tee


def partition(pred, iterable):
    'Use a predicate to partition entries into false entries and true entries'
    # From itertools recipes:
    # https://docs.python.org/3/library/itertools.html#itertools-recipes
    # partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9
    t1, t2 = tee(iterable)
    return filterfalse(pred, t1), filter(pred, t2)

split_me = [0, 1, 2, None, 3, '']

trueish, falseish = partition(lambda x: x, split_me)

# You can iterate directly over trueish and falseish,
# or you can put them into lists

trueish_list = list(trueish)
falseish_list = list(falseish)

print(trueish_list)
print(falseish_list)
</code></pre>
<p>Output:</p>
<pre><code>[0, None, '']
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's nothing non-pythonic in writing things on many lines and make use of <code>if</code>-statements:</p>
<pre><code>for v in split_me:
    if v:
        a.append(v)
    else:
        b.append(v)
</code></pre>
<p>If you want a one-liner you could do so by putting the loop on one line anyway:</p>
<pre><code>for v in split_me: a.append(v) if v else b.append(v)
</code></pre>
<p>If you want it in an expression (which still beats me why you want unless you have a value you want to get out of it) you could use list comprehension to force looping:</p>
<pre><code>[x for x in (a.append(v) if v else b.append(v) for v in split_me) if False]
</code></pre>
<p>Which solution do you think best shows what you're doing? I'd say the first solution. To be pythonic you should probably consider the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow">zen of python</a>, especially:</p>
<ul>
<li>Readability counts.</li>
<li>If the implementation is hard to explain, it's a bad idea.</li>
</ul>
</div>
<span class="comment-copy">if you do <code>any(gen_comp)</code> without assigning it to a variable, it is automatically marked for garbage-collection, but what you're doing is more of a hack, not a regular thing - use <code>for</code> loops instead.</span>
<span class="comment-copy">@RenaeLider Calling a function (for it's sideeffect) without storing the return value is perfectly OK (in many cases).</span>
<span class="comment-copy">@skyking, it doesn't make sense to cram that into a comprehension though; better to just use a loop.</span>
<span class="comment-copy">@Cyphase I meant the point about garbage collection is not the point (if you don't care about the return value then it's fine if it gets garbage collected).</span>
<span class="comment-copy">@skyking <a href="https://docs.python.org/3/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="nofollow noreferrer"><i>"Particularly tricky is map() invoked for the side effects of the function; the correct transformation is to use a regular for loop (since creating a list would just be wasteful)."</i></a></span>
<span class="comment-copy">If he wants to use constant memory (e.g. if <code>split_me</code> is enormous) then <code>split_me</code> should be fed out of a generator. But there's not enough detail to say whether or not that's useful.</span>
<span class="comment-copy">I'm a little uncomfortable with your one-liner, since it uses a conditional expression which produces the same result (None) in both branches, and then throws away the result; OTOH, using an expression for its side-effects isn't as bad as using a gen exp or list comp for its side-effects. An alternative one-liner is a condensed version of Martijn's last answer: `for v in split_me: (a if v else b).append(v), but I'd still prefer to see that on two lines.</span>
<span class="comment-copy">I thought I was pretty clear - you <b>should</b> be (a little) uncomfortable with them.</span>
