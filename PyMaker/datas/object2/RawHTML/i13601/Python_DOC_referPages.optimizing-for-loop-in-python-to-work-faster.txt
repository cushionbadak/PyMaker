<div class="post-text" itemprop="text">
<p>I am working to optimize Python code. The goal is to take a list of integers and calculate and output how many pairs there are in the list. A pair is considered to be 2 numbers with the difference of <strong><code>K</code></strong> ( <code>2</code> in this case)
For example: </p>
<pre><code>k = 2
list = [1, 5, 3, 4, 2]
</code></pre>
<p>The pairs here will be <code>(1,3), (5,3), (2,4)</code><br/>
The answer is: <code>3</code></p>
<p><strong>I want to increase efficiency of the code</strong>, current version takes 8 second or more.</p>
<p><strong><code>cProfile</code></strong> tells me that <code>for number in sorted_array:</code> is the only line that takes all the time. But I cannot seem to figure out how to optimize <code>for</code> loop.</p>
<p>Does anyone have any experience or suggestions? Thank you so much.</p>
<p>The code:</p>
<pre><code>#generate random numbers
import bisect
import random
n_integers = random.sample(xrange(1, 29999), 29998)
####cProfile
import cProfile
pr = cProfile.Profile()
pr.enable()

#the difference between numbers we are looking for
k = 2
sorted_array = []
pairs_counter = 0

#insert N integers in array in sorted fashion and typecast
for number in n_integers:
    bisect.insort_left(sorted_array, number)

#iterate over the array and calculate (number + K)
for number in sorted_array:
    the_pair = number + k
    #check if the number+K is in the array
    if the_pair in sorted_array:
        pairs_counter += 1

print pairs_counter

#Close cProfile
pr.disable()
pr.print_stats(sort = 'time')
</code></pre>
<p>cProfile:</p>
<pre><code>30075 function calls in 7.995 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    7.834    7.834    7.834    7.834 &lt;ipython-input-5-19d578e3c582&gt;:19(&lt;module&gt;)
    29998    0.143    0.000    0.143    0.000 {_bisect.insort_left}
        1    0.016    0.016    0.159    0.159 &lt;ipython-input-5-19d578e3c582&gt;:15(&lt;module&gt;)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If <code>[1,3,3,3,3,3,6]</code> results in five <em>pairs</em> (<code>k=2</code>), you could use <code>numpy</code>'s <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" rel="nofollow"><code>broadcasting</code></a> <em>feature</em> to eliminate the Python <code>for</code> loops.</p>
<pre><code>import numpy as np
import random

a = random.sample(xrange(1, 29999), 29998)
a = np.array(a)
# or just a = np.random.randint(1, 29999, 29998)

k = 2
</code></pre>
<p>Create a new array that contains all the integers that would make <em>pairs</em></p>
<pre><code>b = a + k
</code></pre>
<p>Create a boolean array by broadcasting <code>b</code> across <code>a</code>: this results in a 2-d array with <code>True</code>'s everywhere there is a <em>pair</em>.</p>
<pre><code>c = a[:, np.newaxis] == b
</code></pre>
<p>Sum all the <code>True</code>'s</p>
<pre><code>np.sum(c)
</code></pre>
<p>Or just:</p>
<pre><code>np.sum(a[:, np.newaxis] == b)
</code></pre>
<hr/>
<p>If, as the example <em>input</em> suggests, the list only contains unique values the <code>numpy</code> solution would be:</p>
<pre><code>a = random.sample(xrange(1, 29999), 29998)
k = 2
a = np.array(a)
b = a + k
result = np.sum(np.in1d(b, a, assume_unique=True))
</code></pre>
<p>Which is much faster.</p>
<p>In fact if the values are NOT unique, <code>numpy.in1d</code> is much faster than the broadcasting solution, above.  By switching the order of the arguments, you <em>count</em> five pairs for <code>[1,3,3,3,3,3,6]</code>.</p>
<pre><code>result = np.sum(np.in1d(a, b))
</code></pre>
<hr/>
<p>Now for a bit of crow eating:  turning the list to a set (assuming unique values), a <em>pure Python</em> solution is faster than the <code>numpy</code> solutions.</p>
<pre><code>q = 10000
a = random.sample(xrange(1, q), q-1)
a = set(a)
result = sum(n+k in a for n in a)
</code></pre>
<p>Using <code>sum</code> to consume a <a href="https://docs.python.org/3/tutorial/classes.html#generator-expressions" rel="nofollow">generator expression</a> doesn't require making any intermediate objects - probably one reason for its speed/efficiency.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a better algorithm.  In your code</p>
<pre><code>for number in sorted_array:
    the_pair = number + k
    #check if the number+K is in the array
    if the_pair in sorted_array:
        pairs_counter += 1
</code></pre>
<p>you are checking the entire array for <code>the_pair</code>, so you have gained nothing by sorting the list.  Since all the elements are integers, after the list is sorted `the_pair, if it occurs in the list can only be in one of the next two positions.  Try something like</p>
<pre><code>for index, number in sorted_array:
    if number+k in sorted_array[index+1:index+k+1]:
        &lt;do whatever&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>@saulspatz is correct that you are making sorting irrelevant in your code, however I would suggest you skip the sorting instead of generating thousands of list slices. The <code>in</code> operation is in fact extremely fast provided you are comparing to an immutable type (ex:<code>tuple()</code>). I therefore would propose the following code: </p>
<pre><code>#generate random numbers
import bisect
import random
n_integers = tuple(random.sample(xrange(1, 29999), 29998))
####cProfile
import cProfile
pr = cProfile.Profile()
pr.enable()

#the difference between numbers we are looking for
k = 2
pairs_counter = 0

#iterate over the array and calculate (number + K)
for number in n_integers:
    the_pair = number + k
    #check if the number+K is in the array
    if the_pair in n_integers:
        pairs_counter += 1

print pairs_counter

#Close cProfile
pr.disable()
pr.print_stats(sort = 'time')
</code></pre>
<p>output:</p>
<pre><code>29996
     1 function calls in 0.000 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    1    0.000    0.000    0.000    0.000 {method 'disable' of'_lsprof.Profiler' objects}
</code></pre>
</div>
<span class="comment-copy">What is the expected output when you have an input with duplicates such as <code>[1,3,3,3,6]</code>?</span>
<span class="comment-copy">I'm getting <code>30004 function calls in 0.091 seconds</code> Is it possible that your computer is just slow?</span>
<span class="comment-copy">I too got a runtime with the exact code of .147 sec. (late 2012 macbook pro 15")</span>
<span class="comment-copy">@MorganThrapp: <a href="https://docs.python.org/2/library/bisect.html" rel="nofollow noreferrer"><code>bisect</code></a></span>
<span class="comment-copy">@MorganThrapp I have a last year generation mac with 8Gb DDR3 of RAM and 2.6 i5 processor. Probably your computer is too strong?)))) But that is the great result. I am running code in iPython notebooks, so I tried in console - the result is the same &gt;7 seconds for 30000 calls.</span>
<span class="comment-copy">I love the last solution that you proposed. It is extremely simple and elegant. How did you learn to do that? I am coming from Java background, probably that is why my code is so bulk. I want to learn to write it like you do.</span>
<span class="comment-copy">@solarguard89 - Spend a lot of time reading the docs, start with <a href="https://docs.python.org/3/tutorial/index.html" rel="nofollow noreferrer">the tutorial</a>.  Work your way through some of the online learning materials.  Practice every example you come across - one of the cool things about an interpreted language is that it is very easy to try things out and play with ideas in the shell.</span>
<span class="comment-copy">Thanks for the advice :)</span>
<span class="comment-copy">What if the sequence included something like - <code>1,3,3,3,3,3,3,3</code>?</span>
<span class="comment-copy">@wwii Good point.  I would say that there was only one pair, but I'm not sure what the OP wants.  On the other hand, if the list included 1,2,2,2,2,3 I wouldn't detect the (1,3).    So, if my interpretation of the question is correct, I should have made a set out of the list first.  If multiple instances of the same pair are required, then an inner while loop would work.</span>
<span class="comment-copy">you should update your answer.</span>
<span class="comment-copy">@wwii Actually, doesn't random.sample give a sample without replacement?  That's why I originally thought the numbers were distinct, but it slipped my mind when I saw your comment.</span>
<span class="comment-copy">You are right, <code>random.sample</code> returns unique elements.  Maybe use a <code>set</code> instead of a sorted list., <code>x in s</code> would be O(1), for small <code>k</code> a slight improvement.</span>
<span class="comment-copy">What if there are multiple <i>pairs</i> - e.g. <code>(1,3,3,3,3,3,3,3,3)</code>?</span>
<span class="comment-copy"><code>x in s</code> takes the same time for a <code>tuple</code> and a <code>list</code>, O(n).</span>
<span class="comment-copy">@Aaron unfortunately for me this code produces the result in 11 seconds(((</span>
