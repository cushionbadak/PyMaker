<div class="post-text" itemprop="text">
<p>I need to generate all possible strings of certain length X that satisfies the following two rules:</p>
<ol>
<li>Must end with '0'</li>
<li>There can't be two or more adjacent '1'</li>
</ol>
<p>For example, when X = 4, all 'legal' strings are [0000, 0010, 0100, 1000, 1010].</p>
<p>I already wrote a piece of recursive code that simply append the newly found string to a list.</p>
<pre><code>def generate(pre0, pre1, cur_len, max_len, container = []):
    if (cur_len == max_len-1):
        container.append("".join([pre0, pre1, "0"]))
        return

    if (pre1 == '1'):
        cur_char = '0'
        generate(pre0+pre1, cur_char, cur_len+1, max_len, container)
    else:   
        cur_char = '0'
        generate(pre0+pre1, cur_char, cur_len+1, max_len, container)
        cur_char = '1'
        generate(pre0+pre1, cur_char, cur_len+1, max_len, container)

if __name__ == "__main__": 
    container = []
    _generate("", "", 0, 4, container)
    print container
</code></pre>
<p>However this method won't work while X reaches 100+ because the memory complexity. I am not familiar with the generator method in Python, so could anyone here help me figure out how to re-write it into a generator? Thanks so much!</p>
<p>P.S. I am working on a Project Euler problem, this is not homework.</p>
<p>Update 1:</p>
<p>Grateful to the first 3 answers, I am using Python 2.7 and can switch to python 3.4. The reason I am asking for the generator is that I can't possibly hold even just the final result list in my memory. A quick mathematical proof will show that there are Fibonacci(X) possible strings for the length X, which means I have to really use a generator and filter the result on the fly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Lame string-based testing whether "11" is contained in the formatted string and yield if it's not (for every even number up to 2^maxlen):</p>
<pre><code>def gen(maxlen):
    pattern = "{{:0{}b}}".format(maxlen)
    for i in range(0, 2**maxlen, 2):
        s = pattern.format(i) # not ideal, because we always format to test for "11"
        if "11" not in s:
            yield s
</code></pre>
<p>Superior mathematical approach (<code>M xor M * 2 = M * 3</code>):</p>
<pre><code>def gen(maxlen):
    pattern = "{{:0{}b}}".format(maxlen)
    for i in range(0, 2**maxlen, 2):
        if i ^ i*2 == i*3:
            yield pattern.format(i)
</code></pre>
<p>Here's a benchmark for 6 different implementations (Python 3!):</p>
<pre><code>from time import clock
from itertools import product

def math_range(maxlen):
    pattern = "{{:0{}b}}".format(maxlen)
    for i in range(0, 2**maxlen, 2):
        if i ^ i*2 == i*3:
            yield pattern.format(i)


def math_while(maxlen):
    pattern = "{{:0{}b}}".format(maxlen)
    maxnum = 2**maxlen - 1
    i = 0
    while True:
        if i ^ i*2 == i*3:
            yield pattern.format(i)
        if i &gt;= maxnum:
            break
        i += 2


def itertools_generator(max_len):
    return filter(lambda i: '11' not in i, (''.join(i) + '0' for i in product('01', repeat=max_len-1)))


def itertools_list(maxlen):
    return list(filter(lambda i: '11' not in i, (''.join(i) + '0' for i in product('01', repeat=maxlen-1))))


def string_based(maxlen):
    pattern = "{{:0{}b}}".format(maxlen)
    for i in range(0, 2**maxlen, 2):
        s = pattern.format(i)
        if "11" not in s:
            yield s


def generate(pre0, pre1, cur_len, max_len):
    if (cur_len == max_len-1):
        yield "".join((pre0, pre1, "0"))
        return

    if (pre1 == '1'):
        yield from generate(pre0+pre1, "0", cur_len+1, max_len)
    else:
        yield from generate(pre0+pre1, "0", cur_len+1, max_len)
        yield from generate(pre0+pre1, "1", cur_len+1, max_len)

def string_based_smart(val):
    yield from generate("", "", 0, val)


def benchmark(val, *funcs):
    for i, func in enumerate(funcs, 1):
        start = clock()
        for g in func(val):
            g
        print("{}. {:6.2f} - {}".format(i, clock()-start, func.__name__))

benchmark(24, string_based_smart, math_range, math_while, itertools_generator, itertools_list, string_based)
</code></pre>
<p>Some numbers for string length = 24 (in seconds):</p>
<pre><code>1.   0.24 - string_based_smart
2.   1.73 - math_range
3.   2.59 - math_while
4.   6.95 - itertools_generator
5.   6.78 - itertools_list
6.   6.45 - string_based
</code></pre>
<p>shx2's algorithm is clearly the winner, followed by math. Pythonic code makes quite a difference if you compare the results of both math approaches (note: ranges are also generators).</p>
<p>Noteworthy: the <code>itertools_*</code> functions perform almost equally slow, but <code>itertools_list</code> needs a lot more memory to store the list in (~6 MB spike in my test). All other generator-based solutions have a minimal memory footprint, because they only need to store the current state and not the entire result.</p>
<p>None of the shown functions blows up the stack, because they do not use actual recursion. Python <a href="https://stackoverflow.com/questions/13591970/does-python-optimize-tail-recursion">does not optimize tail recursion</a>, thus you need loops and generators.</p>
<p><strong>//edit:</strong> naive C++ implementation of <code>math_range</code> (MSVS 2013):</p>
<pre><code>#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;

using namespace std;

int _tmain(int argc, _TCHAR* argv[])
{
    const unsigned __int32 maxlen = 24;
    const unsigned __int32 maxnum = 2 &lt;&lt; (maxlen - 1);

    clock_t begin = clock();

    ofstream out;
    out.open("log.txt");
    if (!out.is_open()){
        cout &lt;&lt; "Can't write to target";
        return 1;
    }

    for (unsigned __int32 i = 0; i &lt; maxnum; i+=2){
        if ((i ^ i * 2) == i * 3){
            out &lt;&lt; std::bitset&lt;maxlen&gt;(i) &lt;&lt; "\n"; // dont use std::endl!
        }
    }

    out.close();

    clock_t end = clock();
    double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
    cout &lt;&lt; elapsed_secs &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>It takes 0.08 seconds(!) for maxlen = 24 (<code>/Ox</code>).</p>
<p>An implementation of shx2's algorithm in C++ is non-trivial, because a recursive approach would lead to stack overflow (ha ha), and there's no <code>yield</code>. See:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/3864410/why-wasnt-yield-added-to-c0x">Why wasn't yield added to C++0x?</a></li>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" rel="nofollow noreferrer">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></li>
<li><a href="http://blog.think-async.com/2009/08/secret-sauce-revealed.html" rel="nofollow noreferrer">http://blog.think-async.com/2009/08/secret-sauce-revealed.html</a></li>
<li><a href="http://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and" rel="nofollow noreferrer">http://www.codeproject.com/Articles/418776/How-to-replace-recursive-functions-using-stack-and</a></li>
</ul>
<p>But if you want raw speed, then there's no way around it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <code>filter</code> with <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a></p>
<pre><code>def generate(max_len):
    return list(filter(lambda i: '11' not in i, (''.join(i) + '0' for i in itertools.product('01', repeat=max_len-1))))
</code></pre>
<p>This uses generators the entire time until the return which finally creates a <code>list</code>. The <code>filter</code> will act on each of the strings created by <code>itertools.product</code> as they are produced.</p>
<pre><code>&gt;&gt;&gt; generate(5)
['00000', '00010', '00100', '01000', '01010', '10000', '10010', '10100']
</code></pre>
<p><strong>Edit</strong> To use this function as a generator expression, just drop the <code>list</code> and switch <code>filter</code> to <a href="https://docs.python.org/2/library/itertools.html#itertools.ifilter" rel="nofollow"><code>itertools.ifilter</code></a></p>
<pre><code>def generate(max_len):
    return itertools.ifilter(lambda i: '11' not in i, (''.join(i) + '0' for i in itertools.product('01', repeat=max_len-1)))

for s in generate(10):
    # do something with s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming you're using python version &gt;= 3.4, where <code>yield from</code> is available, you can <code>yield</code> instead of accumulating+returning. You don't need to pass around a container.</p>
<pre><code>def generate(pre0, pre1, cur_len, max_len):
    if (cur_len == max_len-1):
        yield "".join((pre0, pre1, "0"))
        return

    if (pre1 == '1'):
        yield from generate(pre0+pre1, '0', cur_len+1, max_len)
    else:   
        yield from generate(pre0+pre1, '0', cur_len+1, max_len)
        yield from generate(pre0+pre1, '1', cur_len+1, max_len)

if __name__ == "__main__": 
    for result in generate("", "", 0, 4):
        print result
</code></pre>
<p>If you're using a python version where <code>yield from</code> is not available, replace those lines with:</p>
<pre><code>for x in generate(...):
    yield x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you were doing it in Python 3, you would adapt it as follows:</p>
<ul>
<li>Remove the <code>container</code> parameter.</li>
<li>Change all occurrences of <code>container.append(<i>some_value</i>)</code> to <code>yield <i>some_value</i></code>.</li>
<li>Prepend <code>yield from</code> to all recursive calls.</li>
</ul>
<p>To do it in Python 2, you do the same, except that Python 2 doesn’t support <code>yield from</code>. Rather than doing <code>yield from <i>iterable</i></code>, you’ll need to use:</p>
<pre>for item in <i>iterable</i>:
    yield item</pre>
<p>You’ll then also need to change your call site, removing the <code>container</code> argument and instead storing the return value of the call. You’ll also need to iterate over the result, printing the values, as <code>print</code> will just give you <code>&lt;generator object at 0x...&gt;</code>.</p>
</div>
<span class="comment-copy">I changed your title to further indicate what you want. Good title results into good answers.</span>
<span class="comment-copy">A recursive approach would most likely <i>not</i> lead to stack overflow unless you want very long outputs—the recursion depth is bounded by the length of the desired string.</span>
<span class="comment-copy">My C++ knowledge is probably way too small, but in my attempt to implement shx2's approach, a stack overflow occurred even for small maxlen values. Most likely a flaw caused by me I suppose.</span>
<span class="comment-copy">I was successfully able to implement it in C like so: <a href="http://codepad.org/wPS8d2GF" rel="nofollow noreferrer">codepad.org/wPS8d2GF</a></span>
<span class="comment-copy">Nice one! Doesn't print the expected results though - numbers should always end with 0.</span>
<span class="comment-copy">Oops! Well, it’s a small matter. Only one new line is necessary to fix it: <a href="http://codepad.org/mdic3FqW" rel="nofollow noreferrer">codepad.org/mdic3FqW</a></span>
<span class="comment-copy">Is there any other ways that I can get a generator and for loop it instead of getting a list? I have updated the question to explain why I need it that way. Thanks again.</span>
<span class="comment-copy">@JimmyK Sure, just drop the <code>list</code> call and switch Python's native <code>filter</code> for <code>itertools.ifilter</code> which returns an iterator (only needed for Python 2.x, in Python 3.x <code>filter</code> already returns an iterator)</span>
<span class="comment-copy">Brilliant answer! This is by far the fastest solution, ~30x faster than the monstrous one-liner from the accepted answer (see my answer for benchmark). I'll have to think a bit more about how <code>yield</code> and <code>return</code> play together in this one... Do you happen to know how to implement the same in let's say C++ or Assembly?</span>
<span class="comment-copy">@CoDEmanX: If you wanted to translate it directly, you could use coroutines, libraries for which are available. However, more pragmatically you would pass to <code>generate</code> a function pointer that is called whenever a new result is generated.</span>
<span class="comment-copy">Generators can also be cast to sequences (list, tuple), you do not necessarily need to iterate over them. Beware though if the generator contains an infinite loop. By using iteration, it's possible to abort after a certain amount of elements (or time).</span>
<span class="comment-copy">@CoDEmanX: If it failed because of the memory usage before, turning it into a list reintroduces the memory exhaustion.</span>
