<div class="post-text" itemprop="text">
<p>I have a module with a dictionary as associative array to implement a kind-of switch statement.</p>
<pre><code>def my_method1():
    return "method 1"


def my_method2():
    return "method 2"


map_func = {
    '0': my_method1,
    '1': my_method2
}

def disptach(arg):
  return map_func[arg]()
</code></pre>
<p>How can I mock my_method1 in tests? I've tried the following without success:</p>
<pre><code>import my_module as app

@patch('my_module.my_method1')
def test_mocking_sample(self, my_mock):
    my_mock.return_value = 'mocked'
    assert_equal('mocked',app.dispatch('0'))
</code></pre>
<p>Any idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>This piece of <a href="http://www.voidspace.org.uk/python/mock/patch.html#where-to-patch" rel="nofollow">patch</a> documentation says the following:</p>
<blockquote>
<p>patch works by (temporarily) changing the object that a name points to
  with another one. There can be many names pointing to any individual
  object, so for patching to work you must ensure that you patch the
  name used by the system under test.</p>
</blockquote>
<p>Basically, your dispatcher won't see it, as the mapping is built to reference the original method, before the patch is applied.</p>
<p>The simplest thing you can do to make it mockable is to fold the mapping into the <code>dispatch</code> function:</p>
<pre><code>def dispatch(arg):
  return {
    '0': my_method1,
    '1': my_method2
  }[arg]()
</code></pre>
<p>This does have the downside that it rebuilds that mapping every time you call it, so it will be slower.</p>
<p>Trying to get a bit clever, it seems that Python lets you swap out the actual code of a function, like so:</p>
<pre><code>&gt;&gt;&gt; f = lambda: "foo"
&gt;&gt;&gt; a = f
&gt;&gt;&gt; g = lambda: "bar"
&gt;&gt;&gt; f.func_code = g.func_code
&gt;&gt;&gt; a()
'bar'
</code></pre>
<p>I won't recommend that you do it this way, but maybe you can find a mocking framework that supports something similar.</p>
</div>
<div class="post-text" itemprop="text">
<p>As you've discovered, patching <code>my_Method1()</code> does not work.  This is because <code>map_func['0']</code> was defined when my_module was imported and subsequent changes to <code>my_Method1()</code> do not update <code>map_func</code> for your test.  Instead, we need to patch the value in dictionary <code>map_func</code> for key <code>'0'</code> directly.  The unittest.mock <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch.dict" rel="nofollow noreferrer">documentation</a> explains how to patch a dictionary entry.  Below is a working implementation of your test: </p>
<pre><code>""" test_my_module.py
"""
import unittest
import unittest.mock as mock
import my_module as app


my_mock = mock.MagicMock()


class Test_mock_sample(unittest.TestCase):

    @mock.patch.dict('my_module.map_func', {'0': my_mock})
    def test_mocking_sample(self):
        my_mock.return_value = 'mocked'
        self.assertEqual('mocked', app.dispatch('0'))

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>After changing <code>disptach</code> to <code>dispatch</code> in your original my_module...</p>
<pre><code>""" my_module.py
"""
def my_method1():
    return "method 1"


def my_method2():
    return "method 2"


map_func = {
    '0': my_method1,
    '1': my_method2
}

def dispatch(arg):
  return map_func[arg]()
</code></pre>
<p>Then the command <code>python -m unittest test_my_module</code> gives the following output:</p>
<pre><code>.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>It worked!</p>
</div>
<span class="comment-copy">I suppose you have to mock dispatch('0') instead of my_method1. That is mock dispatch when called with arg '0'.</span>
