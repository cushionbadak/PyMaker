<div class="post-text" itemprop="text">
<p>I'm trying to test a cache class where old items should be automatically deleted. The amount of items the cache can hold is controlled by a "constant" class variable like this:</p>
<pre><code>class Cache(dict):
    MAX_ITEMS = 100
</code></pre>
<p>For testing purposes I would like to change that constant for the duration of a single test case. Using <code>unittest.mock.patch</code> I could replace the class variable with a <code>MagicMock</code> but that's not really what I'm trying to do. I just need to replace it with a different number.</p>
<p>Is there an elegant way to do this in Python (like <code>patch</code>), or should I just reset the variable myself on <code>tearDown</code>?</p>
<hr/>
<p><sub>I'm using Python 3.4.3</sub></p>
</div>
<div class="post-text" itemprop="text">
<p>patch can do this already. try:</p>
<pre><code>from unittest.mock import patch

class A:
    val = 1

assert A.val == 1
with patch.object(A, "val", "patched_value"):
    assert A.val == "patched_value"

assert A.val == 1
</code></pre>
<p>Of course you can use <code>patch.object</code> as a decorator as well.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="nofollow">Reading the docs</a> more carefully, it turns out <code>patch</code> actually has an optional argument that controls what the variable is replaced by (instead of a mock object), so I can do this:</p>
<pre><code>class CacheTest(TestCase):
    @patch("myproject.Cache.MAX_ITEMS", new=3)
    def testCacheTrim(self):
        # ...
</code></pre>
<p>Or, as Dunes pointed out:</p>
<pre><code>class CacheTest(TestCase):
    @patch.object(Cache, "MAX_ITEMS", new=3)
    def testCacheTrim(self):
        # ...
</code></pre>
<p>Which arguably looks prettier.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could consider providing a class constructor that sets MAX_ITEMS. Something like:</p>
<pre><code>class Cache(dict):
    def __init__(self, *args, **kwargs):
        self.MAX_ITEMS = kwargs.get("MAX_ITEMS", 100)  # default value

    @classmethod
    def create_with_max(cls, MAX_ITEMS, *args, **kwargs):
        return cls(MAX_ITEMS=MAX_ITEMS, *args, **kwargs)

&gt;&gt;&gt; c = Cache.create_with_max(40)
&gt;&gt;&gt; c.MAX_ITEMS
40
</code></pre>
<p>This would allow you to set the cache size (during testing or otherwise)</p>
</div>
<span class="comment-copy">Well you could use the <code>with</code> syntax to create a limited scope for the value inside the test, that looks not too bad. But if you need it for every testcase doing it inside the corresponding setup/teardown methods seems nicer.</span>
<span class="comment-copy">@Voo What would be nice is a function like <code>patch</code> that simply makes sure the original value is restored after the test, without replacing it with a mock object</span>
<span class="comment-copy">I think using <code>setUp</code> and <code>tearDown</code> is the way to go; if you don't know a different way, chances are the next reader won't either!</span>
