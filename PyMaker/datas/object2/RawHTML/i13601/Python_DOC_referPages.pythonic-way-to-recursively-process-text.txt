<div class="post-text" itemprop="text">
<p>I need to parse text files that include configuration for an application. The file contents are formatted like this:</p>
<blockquote>
<p>param1=val1<br/>
  param2=val2<br/>
  hash.param3={<br/>
  subparam3=subval3<br/>
  subparam4=subval4<br/>
  }<br/>
  ...</p>
</blockquote>
<p>I want to store this in a dictionary as:   </p>
<pre><code>self.values = {'param1': 'value1', 'param2': 'value2', 
               'param3':{'subparam3':'subvalue3', 'subparam4': 'subvalue4'}
</code></pre>
<p>I have this working fine using global variables shared between some functions but wanted to try again using a class as a learning exercise, which I've done now but it still feels clunky. </p>
<p>Here's what I have currently:</p>
<pre><code>class Cfg(object):
    def __init__(self, abs_path):
        self._text = iter(open(abs_path, 'r').readlines())
        self.values = {}
        self._parse_cfg(self.values)

    @property
    def next_line(self):
        """Get next non-blank, non-comment line."""
        while True:
            nl = next(self._text).strip()
            if nl and not nl.startswith('#'):
                return nl

    def _parse_cfg(self, dic):
        while True:
            try:
                line = self.next_line
                # closing brace signals end of sub dict
                if line.startswith('}'):
                    break
                # Look for param with hash prefix, which signifies a new subdict
                elif re.match(hash_rgx, line):
                    m = re.match(hash_rgx, line)
                    # Add new hash dict
                    dic[m.group('hash')] = {}
                    # collect keys/values for subdict until closing brace found
                    self._parse_cfg(dic[m.group('hash')])

                # Look for normal key=value pair
                elif re.match(val_rgx, line):
                    m = re.match(val_rgx, line)
                    dic[m.group('key')] = m.group('val')
                else:
                    raise ValueError('line ignored *' + str(line) + '*')
            except StopIteration:
                        break
</code></pre>
<p>I'm looking for suggestions on how to do this in a cleaner, more Pythonic way. </p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it using the builtin <a href="https://docs.python.org/3/library/functions.html#eval" rel="nofollow">evals</a> function.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have control over configuration files, then better use more programming friendly data format like json, yaml (even xml).</p>
<p>Otherwise, convert it into json if thats possible, maybe by replacing '=' by ':'(if it's that simple). In that case, you can easily use json.loads</p>
<pre><code>import json
json.loads(configuration_string)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a function that calls itself recursively when it encounters an opening brace. The code below returns what you want from your sample data.</p>
<pre><code>data="""param1=val1
param2=val2
param3={
subparam3=subval3
subparam4=subval4
}
"""

# given a string of configuration data separated by newlines, put it into a dictionary
def dict_from_data(data):
    newdict = {}
    datalist=data.splitlines()
    # create iterable here so that we can skip lines if we encounter a brace {} section
    iterable = iter(range(len(datalist)))
    for num in iterable:
        skiplines=0
        key,val = datalist[num].split('=')
        if val == '{':
            # find the matching close brace. This won't work for nested braces, but could be adapted.
            ix = num + 1
            while skiplines==0:
                if datalist[ix][0] == '}':
                    skiplines = ix-num
                ix +=1
            # call this function recursively with the lines inside the brace,
            val = dict_from_data('\n'.join([datalist[n] for n in range(num+1, num+skiplines)]))
            # and then skip those lines at this recursion depth.
            for i in range(skiplines):
                iterable.next()
        newdict[key]=val
    return newdict

values = dict_from_data(data)
print "Result of data parsing:"
print values
</code></pre>
</div>
<span class="comment-copy">seems like this belongs on <a href="http://codereview.stackexchange.com">codereview.stackexchange.com</a></span>
<span class="comment-copy">Recursion is not really pythonic.  <a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html" rel="nofollow noreferrer">neopythonic.blogspot.com/2009/04/â€¦</a></span>
<span class="comment-copy">What will your <code>next_line(self)</code> method do once it reaches the end of the input?</span>
