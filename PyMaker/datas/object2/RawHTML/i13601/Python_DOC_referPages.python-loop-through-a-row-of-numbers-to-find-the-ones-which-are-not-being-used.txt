<div class="post-text" itemprop="text">
<p>I am trying to make a python script that loops through a text file. In the text file I have something similair to this:</p>
<pre>
abc1
abc2
abc3
abc5
abc6
</pre>
<p>Now i want it to loop through all of this and find the numbers that are not being used. In this case it would be abc4 and print it. But im stuck. Ive tried searching for the way to approach this but cant seem to frase the question to get a good answer...</p>
<p>I hope someone can help me or point me in the right direction!</p>
<p>I will add. The text is always abcN (N = a number) the numbers are also in a row. Like in the example</p>
</div>
<div class="post-text" itemprop="text">
<p>Read the data, discard the text and only keep the numbers. Put the numbers in a <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow"><code>set</code></a> while finding the maximum value. This will assure that you have all numbers in the file, without duplicates, and also the max number to look for.</p>
<p>Once you have the numbers in the set, just loop from the zero to the max value, and check if the number is <code>in</code> the set.</p>
<p>This might not be the most effective or Pythonic solution, but it's <em>a</em> solution.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to get adventitious with <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow">itertools</a>, a pythonic solution using generators would seem ideal. 
It is worth noting that it handles the edge cases well and is highly scalable.</p>
<p><strong>Implementation</strong></p>
<pre><code>from itertools import tee, izip, islice
with open("test.txt") as fin:
    fin1, fin2 = tee((int(line[3:]) for line in fin))
    print [line1 + 1 for line2, line1 in izip(islice(fin2 , None), fin1) 
           if line2 - line1 &gt; 1]
</code></pre>
<p><strong>Output (for same input)</strong></p>
<pre><code>abc1
abc2
abc3
abc5
abc6
abc8

[4, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>try this:</p>
<pre><code>import re
my_numbers = [int(re.search('\d+', line).group()) for line in open('myfile.txt')]
reference_numbers = range(0, max(my_numbers))
missing_numbers = [num for num in reference_numbers if num not in my_numbers]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>For small files:</strong></p>
<pre><code>with open("file") as inp:
    c=[]
    for line in inp:
        c.append(int(line.strip("abc")))

check=set(range(min(c),max(c)+1))
print c
print check
print "difference : "+" ".join(map(str,check-set(c)))
[1, 2, 3, 5, 6]
{1, 2, 3, 4, 5, 6}
difference : 4
</code></pre>
<p>You could use <strong>set instead of list</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>As suggested, this is an implementation of one possible solution:</p>
<pre><code>nums=[]
for line in file:
    i = int(line[3:])
    nums.append(i);

singles=set(nums)
max=max(singles)
missing=[]
for k in range(max):
   if k not in singles:
       missing.appens(k)

print missing
</code></pre>
<p>Hope helped you!</p>
</div>
<div class="post-text" itemprop="text">
<p>If it is possible to generate all the possible entries without reading the file (eg, if N is limited to a fixed range, say 0-9), you could build all of those into a set, using something like:</p>
<pre><code>possibilities = {'abc{}'.format(i) for i in range(10)}
</code></pre>
<p>You can then generate a similar set of the entries that are actually in the file:</p>
<pre><code>entries = set(file)
</code></pre>
<p>Then your problem is reduced to "the things in the set <code>possibilities</code> which are not also in <code>entries</code>", which sets support directly:</p>
<pre><code>missing = possibilities - entries
</code></pre>
<p>If the size of <code>possibilities</code> is large, you may wish to fill it with numbers instead, and parse out the numbers from each entry in the file. If it is bounded only by the largest number actually present in the file, you would need to dynamically generate it from the <code>entries</code>.</p>
<hr/>
<p>If the file is large enough that keeping all the entries and all the possibilities in memory at once is prohibitive, you can take advantage of the order by using nested loops. Create a generator to give you just the numbers:</p>
<pre><code>entries = (parse_num(line) for line in file)
</code></pre>
<p>(where <code>parse_num</code> takes <code>abcN</code> and gives you <code>N</code>, as an int). You can then iterate over these lines while keeping a separate counter of where you <em>expect</em> to be up to - whenever it is different to where you <em>are</em> up to, you have a missing value:</p>
<pre><code>expected = 0
for entry in entries:
    while expected &lt; entry:
        yield expected
        expected += 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the OP pointed out that the numbers will be in order, I thought of this solution which will always expect the <code>nextnum</code> for the following line:</p>
<pre><code>import re
nextnum = 1
for line in open('input_file.txt'):
    match = re.search(r'abc(\d+)$', line)
    if not match:
        print('error: line "%s" did not match' % line)
        continue
    linenum = int(match.group(1))
    if linenum &gt; nextnum:
        print('line abc%d skipped, found abc%d!' % (nextnum, linenum))
    nextnum = linenum + 1
</code></pre>
<p>Note that this will only give one "skipped" output even if there are multiple subsequent numbers missing because it will simply expect the next line to have the current line's number plus one.</p>
</div>
<span class="comment-copy">Is it always <code>abcN</code> where n is the number? Is it in an <code>Order</code>?</span>
<span class="comment-copy">Yes it is always abcN and it is also always in a order</span>
<span class="comment-copy">Please show what you've tried so far.</span>
