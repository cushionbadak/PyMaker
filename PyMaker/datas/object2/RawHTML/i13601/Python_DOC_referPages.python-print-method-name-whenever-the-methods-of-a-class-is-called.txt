<div class="post-text" itemprop="text">
<p>I need to perform certain operations everytime the methods of a particular class is called (for example log the method name). How can this be achieved in Python in a generic way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Decorate callable attributes from within a metaclass:</p>
<pre><code>from functools import wraps

def _log_method(val):
    @wraps(val)
    def wrapper(*a, **ka):
        print(val.__name__, 'is called')
        val(*a, **ka)
    return wrapper

class LogMethodCalls(type):
    def __new__(cls, cls_name, bases, attrs):
        for name, attr in attrs.items():
            if callable(attr):
                attrs[name] = _log_method(attr)
        return type.__new__(cls, cls_name, bases, attrs)

class Foo(metaclass=LogMethodCalls):
    def my_method(self):
        pass

Foo().my_method() # my_method is called
</code></pre>
<p><strong><em>Warning</em></strong>: This code only works for instance methods, methods that were decorated with <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow"><code>@classmethod</code></a> or <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow"><code>@staticmethod</code></a> will not be logged (because <code>classmethod</code> and <code>staticmethod</code> objects are <em>not</em> callable - they're just non-data descriptors).</p>
<hr/>
<p>The following works for class methods and static methods as well:</p>
<pre><code>from functools import wraps

def _log_method(val):
    @wraps(val)
    def wrapper(*a, **ka):
        print('calling', val.__name__)
        val(*a, **ka)
    return wrapper

class LogMethodCalls(type):
    def __new__(cls, cls_name, bases, attrs):
        for name, attr in attrs.items():
            if callable(attr):
                attrs[name] = _log_method(attr)
            elif isinstance(attr, (classmethod, staticmethod)):
                attrs[name] = type(attr)(_log_method(attr.__func__))
        return type.__new__(cls, cls_name, bases, attrs)

class Foo(metaclass=LogMethodCalls):

    def my_instance_method(self):
        pass

    @classmethod
    def my_class_method(cls):
        pass

    @staticmethod
    def my_static_method():
        pass

Foo().my_instance_method() # calling my_instance_method
Foo.my_class_method() # calling my_class_method
Foo.my_static_method() # calling my_static_method
</code></pre>
<p>They have <code>__func__</code> attributes that we can decorate.</p>
<hr/>
<p>Note that you'll need to use</p>
<pre><code>class Foo(object):
    __metaclass__ = LogMethodCalls
</code></pre>
<p>in Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>Taken from <a href="https://stackoverflow.com/a/5067654/1772838">this answer</a>. You can use the <code>inspect</code> module to look at the stack for the function name to create a simple logging function. Seems like kind of a hack, but I suppose it answers the question.</p>
<pre><code>import inspect

def log_call():
    print(inspect.stack()[1][3])

def my_func():
    log_call()
    # do stuff

my_func()
</code></pre>
<p>This will print <code>my_func</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could implement a <a href="https://docs.python.org/2/reference/compound_stmts.html#function" rel="nofollow">decorator</a>:</p>
<pre><code>from functools import wraps

def print_function_name(function):
    @wraps(function)
    def do_it():
        print function.__name__
        function()
    return do_it
</code></pre>
<p>Usage:</p>
<pre><code>class MyClass(object):
    @print_function_name
    def some_function(self):
        pass
</code></pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; my_object = MyClass()
&gt;&gt;&gt; my_object.some_function()
some_function
</code></pre>
<p>The use of <a href="https://docs.python.org/2/library/functools.html#functools.wraps" rel="nofollow"><code>functools.wraps</code></a> makes sure the function keeps its documentation and name, instead of becoming <code>do_it</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Taken from <a href="https://stackoverflow.com/a/5103895/5270581">https://stackoverflow.com/a/5103895/5270581</a>:<br/>
The following method of <em>object</em> class is called on each access to an attribute of an object, including method calls:</p>
<pre>
    __get_attribute__
</pre>
<p>So I suggest to override it by simply adding a call to a logging function inside.<br/>
See <a href="https://stackoverflow.com/a/5103895/5270581">https://stackoverflow.com/a/5103895/5270581</a> (go to last answer) for code example.</p>
</div>
<span class="comment-copy">You could use <a href="https://docs.python.org/2/library/trace.html" rel="nofollow noreferrer"><code>trace</code></a> or <a href="http://stackoverflow.com/questions/6200270/decorator-to-print-function-call-details-parameters-names-and-effective-values">decorate the methods</a></span>
<span class="comment-copy">Or just do it in <code>__getattribute__</code></span>
<span class="comment-copy">@jonrsharpe It's possible to call <code>__getattribute__</code> but not call the function.</span>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/5067604/determine-function-name-from-within-that-function-without-using-traceback">Determine function name from within that function (without using traceback)</a></span>
<span class="comment-copy">@PeterWood that's true, good point; it would log access rather than invocation</span>
<span class="comment-copy">Overrinding <code>__get_attribute__</code> is definitely not a good idea when you can do otherwise.</span>
<span class="comment-copy">@brunodesthuilliers: Can you explain why it is not a good idea ? (or add a link to explanation)</span>
<span class="comment-copy">The two main reasons why it's not a good idea (when there are other solutions at least) are 1. it's tricky and 2. you'll get a performance penalty on each and every attribute access. In fact <code>object.__getattribute__</code> is the default implementation for attribute resolution (which includes handling descriptor protocol and looking up names on class and parents according to the mro), and is implemented in C. So, having the possibility to override it is handy but as with some features in Python it's wisest to only use it when there's no better way.</span>
