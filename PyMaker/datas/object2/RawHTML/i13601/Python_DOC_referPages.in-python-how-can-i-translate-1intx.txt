<div class="post-text" itemprop="text">
<p>This question is a follow-up of <a href="https://stackoverflow.com/questions/32300386/in-suns-libm-what-does-1intx-do-where-x-is-of-type-double">this one</a>.   In <a href="http://www.netlib.org/fdlibm/readme" rel="nofollow noreferrer">Sun's math library</a> (in C), the expression</p>
<pre><code>*(1+(int*)&amp;x)
</code></pre>
<p>is used to retrieve the high word of the floating point number <code>x</code>. Here, the OS is assumed 64-bit, with little-endian representation. </p>
<p>I am thinking how to translate the C expression above into Python? The difficulty here is how to translate the '&amp;', and '*' in the expression. Btw, maybe Python has some built-in function that retrieves the high word of a floating point number? </p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this more easily with <a href="https://docs.python.org/3/library/struct.html" rel="nofollow"><code>struct</code></a>:</p>
<pre class="lang-python prettyprint-override"><code>high_word = struct.pack('&lt;d', x)[4:8]
return struct.unpack('&lt;i', high_word)[0]
</code></pre>
<p>Here, <code>high_word</code> is a <code>bytes</code> object (or a <code>str</code> in 2.x) consisting of the four most significant bytes of <code>x</code> in little endian order (using IEEE 64-bit floating point format).  We then unpack it back into a 32-bit integer (which is returned in a singleton tuple, hence the <code>[0]</code>).</p>
<p>This always uses little-endian for everything, regardless of your platform's underlying endianness.  If you need to use native endianness, replace the <code>&lt;</code> with <code>=</code> (and use <code>&gt;</code> or <code>!</code> to force big endian).  It also guarantees 64-bit doubles and 32-bit ints, which C does not.  You <em>can</em> remove that guarantee as well, but there is no good reason to do so since it makes your question nonsensical.</p>
<p>While this could be done with pointer arithmetic, it would involve messing around with <code>ctypes</code> and the conversion from Python float to C float would still be relatively expensive.  The <code>struct</code> code is much easier to read.</p>
</div>
<span class="comment-copy">Use <code>struct.pack()</code> to turn it into a string of bytes.</span>
<span class="comment-copy">Why not put yours as an answer?</span>
