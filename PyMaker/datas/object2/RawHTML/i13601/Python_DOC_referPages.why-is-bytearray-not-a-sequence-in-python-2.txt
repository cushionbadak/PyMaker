<div class="post-text" itemprop="text">
<p>I'm seeing a weird discrepancy in behavior between Python 2 and 3.</p>
<p>In Python 3 things seem to work fine:</p>
<pre><code>Python 3.5.0rc2 (v3.5.0rc2:cc15d736d860, Aug 25 2015, 04:45:41) [MSC v.1900 32 b
it (Intel)] on win32
&gt;&gt;&gt; from collections import Sequence
&gt;&gt;&gt; isinstance(bytearray(b"56"), Sequence)
True
</code></pre>
<p>But not in Python 2:</p>
<pre><code>Python 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on wi
n32
&gt;&gt;&gt; from collections import Sequence
&gt;&gt;&gt; isinstance(bytearray("56"), Sequence)
False
</code></pre>
<p>The results seem to be consistent across minor releases of both Python 2.x and 3.x. Is this a known bug? Is it a bug at all? Is there any logic behind this difference?</p>
<p>I am actually more worried about the C API function <a href="https://docs.python.org/2/c-api/sequence.html#c.PySequence_Check"><code>PySequence_Check</code></a> properly identifying an object of type <code>PyByteArray_Type</code> as exposing the sequence protocol, which by looking at the source code it seems like it should, but any insight into this whole thing is very welcome.</p>
</div>
<div class="post-text" itemprop="text">
<p>Abstract classes from <code>collections</code> use <a href="https://docs.python.org/3/library/abc.html#abc.ABCMeta.register" rel="nofollow"><code>ABCMeta.register(subclass)</code></a> to</p>
<blockquote>
<p>Register <em>subclass</em> as a “virtual subclass” of this ABC.</p>
</blockquote>
<p>In Python 3 <code>issubclass(bytearray, Sequence)</code> returns <code>True</code> because <code>bytearray</code> is explicitly registered as a subclass of <code>ByteString</code> (which is derived from <code>Sequence</code>) and <code>MutableSequence</code>. See the relevant part of <a href="https://hg.python.org/cpython/file/b76346142b49/Lib/_collections_abc.py#l870" rel="nofollow"><em>Lib/_collections_abc.py</em></a>:</p>
<pre><code>class ByteString(Sequence):

    """This unifies bytes and bytearray.

    XXX Should add all their methods.
    """

    __slots__ = ()

ByteString.register(bytes)
ByteString.register(bytearray)
...
MutableSequence.register(bytearray)  # Multiply inheriting, see ByteString
</code></pre>
<p>Python 2 doesn't do that (from <a href="https://hg.python.org/cpython/file/v2.7.10/Lib/_abcoll.py#l631" rel="nofollow"><em>Lib/_abcoll.py</em></a>):</p>
<pre><code>Sequence.register(tuple)
Sequence.register(basestring)
Sequence.register(buffer)
Sequence.register(xrange)
...
MutableSequence.register(list)
</code></pre>
<p>This behaviour was changed in Python 3.0 (in <a href="https://hg.python.org/cpython/rev/fe5b2edffae7" rel="nofollow">this commit</a> specifically):</p>
<blockquote>
<p>Add ABC <em>ByteString</em> which unifies <em>bytes</em> and <em>bytearray</em> (but not <em>memoryview</em>).
  There's no ABC for "PEP 3118 style buffer API objects" because there's no
  way to recognize these in Python (apart from trying to use <em>memoryview()</em>
  on them).</p>
</blockquote>
<p>And there's more information in <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow">PEP 3119</a>:</p>
<blockquote>
<p>This is a proposal to add Abstract Base Class (ABC) support to Python
  3000. It proposes:
  [...]
   Specific ABCs for containers and iterators, to be added to the
     collections module.</p>
<p>Much of the thinking that went into the proposal is not about the
  specific mechanism of ABCs, as contrasted with Interfaces or Generic
  Functions (GFs), but about clarifying philosophical issues like "what
  makes a set", "what makes a mapping" and "what makes a sequence".</p>
<p>[...] a metaclass for use with ABCs that will allow us to add an ABC as a "virtual base class" (not the same concept as in C++) to any class, including to another ABC. This allows the standard library to define ABCs <em>Sequence</em> and <em>MutableSequence</em> and register these as virtual base classes for built-in types like <em>basestring</em>, <em>tuple</em> and <em>list</em>, so that for example the following conditions are all true: [...] <em>issubclass(bytearray, MutableSequence)</em>.</p>
</blockquote>
<p>Just FYI <code>memoryview</code> was registered as a subclass of <code>Sequence</code> only in Python 3.4: </p>
<blockquote>
<p>There's no ducktyping for this due to the <em>Sequence</em>/<em>Mapping</em> confusion
  so it's a simple missing explicit registration.</p>
</blockquote>
<p>(see <a href="http://bugs.python.org/issue18690" rel="nofollow">issue18690</a> for details).</p>
<hr/>
<p><a href="https://hg.python.org/cpython/file/b76346142b49/Objects/abstract.c#l1375" rel="nofollow"><code>PySequence_Check</code></a> from Python C API does not rely on the <code>collections</code> module:</p>
<pre><code>int
PySequence_Check(PyObject *s)
{
    if (PyDict_Check(s))
        return 0;
    return s != NULL &amp;&amp; s-&gt;ob_type-&gt;tp_as_sequence &amp;&amp;
        s-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item != NULL;
}
</code></pre>
<p>It checks for non-zero <code>tp_as_sequence</code> field (<a href="https://hg.python.org/cpython/file/b76346142b49/Objects/bytearrayobject.c#l3116" rel="nofollow">example for <code>bytearray</code></a>) and if that succeeds, for non-zero <code>sq_item</code> field (which is basically getitem - <a href="https://hg.python.org/cpython/file/b76346142b49/Objects/bytearrayobject.c#l2985" rel="nofollow">example for <code>bytearray</code></a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>When you look at the source code of <code>collections</code> abstract classes you will see that in python3 (file <code>_collections_abc.py</code>) subclass of <code>Sequence</code> class , class <code>ByteString</code>, <code>register</code> itself with <code>bytearray</code> while in python2 (file <code>_abcoll.py</code>) there is no <code>ByteString</code> class and <code>Sequence</code> does not <code>register</code> itself with <code>bytearray</code>.</p>
<p>By <code>register</code> I mean that the abstract class <code>Sequence</code> (or it's subclass <code>ByteString</code>) is calling <a href="https://docs.python.org/2/library/abc.html#abc.ABCMeta.register" rel="nofollow">abc.ABCMeta.register</a> method which as said in description of this method <em>Register subclass as a “virtual subclass” of this ABC.</em></p>
<p>I think that is causing differennt behaviour between py2 and py3 but IMHO it's bug (or better fixed bug in py3).</p>
</div>
<span class="comment-copy">You can find your answer in <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">PEP 3137 -- Immutable Bytes and Mutable Buffer</a> and <a href="https://www.python.org/dev/peps/pep-3119/" rel="nofollow noreferrer">PEP 3119 -- Introducing Abstract Base Classes</a></span>
<span class="comment-copy">According to <a href="https://www.python.org/dev/peps/pep-3119/#overloading-isinstance-and-issubclass" rel="nofollow noreferrer">PEP 3119</a> the expression <code>issubclass(bytearray, MutableSequence)</code> evaluates to true... but that's not the case in python2.  AFAIK <code>PySequence_Check</code> will return the correct result simply because it does <i>not</i> use the metaclass to see whether a class is a sequence. It sees if the field of the <code>struct</code> that contains the sequence methods is set or not.</span>
