<div class="post-text" itemprop="text">
<p>When using <code>time.sleep(1)</code> before <code>sendMessage</code>, the hole process stops (even the others connections).</p>
<p><code>def handleConnected(self):
    print self.address, 'connected'
    for client in clients:
        time.sleep(1)
        client.sendMessage(self.address[0] + u' - connected')</code></p>
<p>Server: <a href="https://github.com/dpallot/simple-websocket-server" rel="nofollow">https://github.com/dpallot/simple-websocket-server</a></p>
<p>How to solve it?</p>
</div>
<div class="post-text" itemprop="text">
<p>The server that you are using is a synchronous, "select" type server. These servers use a single process and a single thread, they achieve concurrency through the use of the <a href="https://docs.python.org/3/library/select.html" rel="nofollow">select()</a> function to efficiently wait for I/O on multiple socket connections.</p>
<p>The advantage of select servers is that they can easily scale to very large number of clients. The disadvantage is that when the server invokes an application handler (the <code>handleConnected()</code>, <code>handleMessage()</code> and <code>handleClose()</code> methods for this server), the server <em>blocks</em> on them, meaning that while the handlers are running the server is suspended, because both the handlers and the server run on the same thread. The only way for the server to be responsive in this type of architecture is to code the handlers in such a way that they do what they need to do quickly and return control back to the server.</p>
<p>Your <code>handleConnected</code> handler function is not a good match for this type of server, because it is a long running function. This function will run for several seconds (as many seconds as there are clients), so during all that time the server is going to be blocked.</p>
<p>You can maybe work around the limitations in this server by creating a background thread for your long running task. That way your handler can return back to the server after launching the thread. The server will then regain control and go back to work, while the background thread does that loop with the one second sleeps inside. The only problem you have to consider is that now you have sort of a home-grown multithreaded server, so you will not be able to scale as easily.</p>
<p>Another option for you to consider is to use a different server architecture. A coroutine based server will support your handler function as you coded it, for example. The two servers that I recommend in this category are <a href="http://eventlet.net/" rel="nofollow">eventlet</a> and <a href="http://www.gevent.org/" rel="nofollow">gevent</a>. The eventlet server comes with <a href="http://eventlet.net/doc/modules/websocket.html" rel="nofollow">native WebSocket support</a>. For gevent you have to install an extension called <a href="https://bitbucket.org/Jeffrey/gevent-websocket/" rel="nofollow">gevent-websocket</a>.</p>
<p>Good luck!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are suspending the thread with <a href="https://docs.python.org/2/library/time.html#time.sleep" rel="nofollow">sleep</a> and the server which you are using seems to be using <a href="https://github.com/dpallot/simple-websocket-server/blob/master/SimpleWebSocketServer/SimpleWebSocketServer.py#L579" rel="nofollow">select</a> to handle the requests not threads. So no other request will be able to be handled.</p>
<p>So you can't use <code>time.sleep</code>.</p>
<p>Why do you need to sleep? Can you solve it some other way?</p>
<p>Maybe you can use something like <code>threading.Timer()</code></p>
<pre><code>def sendHello(client):
    client.sendMessage("hello, world")

for client in clients:
    t = Timer(1.0, lambda: sendHello(client))
    t.start() # after 30 seconds, "hello, world" will be printed
</code></pre>
<p>This is off the top of my head. You would also need a way to cancel each timer so I guess you would need to save each <code>t</code> in a list and call it when done.</p>
</div>
<span class="comment-copy">Thanks so much for the explanation! Gonna try something client-side.</span>
<span class="comment-copy">Because there's a loop in a function, and I need to send each 1 second the value. Ex: <code>def smth():                               for num in range(50, 1500):                                     time.sleep(1)                                      client.sendMessage...</code></span>
<span class="comment-copy">Maybe you can use something like <a href="https://docs.python.org/2/library/threading.html#timer-objects" rel="nofollow noreferrer">docs.python.org/2/library/threading.html#timer-objects</a></span>
<span class="comment-copy">Did not solve. =/</span>
<span class="comment-copy">@user3211337 I naively thought that it would be easy adding a thread to make periodic calls. It's a bit more complicated and not really sure if it's posible. To wait one would have to suspend the <code>handleMessage</code> function for a specific client, but I don't think it's feasible.</span>
