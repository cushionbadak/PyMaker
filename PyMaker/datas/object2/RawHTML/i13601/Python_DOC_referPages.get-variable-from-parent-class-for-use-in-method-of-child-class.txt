<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/805066/call-a-parent-classs-method-from-child-class-in-python">Call a parent class's method from child class in Python?</a>
<span class="question-originals-answer-count">
                    15 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to understand how parent and child classes in Python work and I ran into this seemingly simple problem:</p>
<pre><code>class parent(object):

    def __init__(self):
        self.data = 42


class child(parent):

    def __init__(self):
        self.string = 'is the answer!'

    def printDataAndString(self):
        print( str(self.data) + ' ' + self.string )


c = child()
c.printDataAndString()
</code></pre>
<p>I'm expecting the string <em>42 is the answer!</em> but I get </p>
<blockquote>
<p>AttributeError: 'child' object has no attribute 'data'</p>
</blockquote>
<p><strong>What am I missing?</strong></p>
<p>I experimentated with <code>pass</code> and also <code>super(parent,...)</code> but couldn't get it right.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since your <code>child</code> has its own <code>__init__()</code> function, you need to call the parent class' <code>__init__()</code>  , otherwise it does not get called. Example -</p>
<pre><code>def __init__(self):
    super(child,self).__init__()
    self.string = 'is the answer!'
</code></pre>
<p><a href="https://docs.python.org/2/library/functions.html#super" rel="nofollow"><code>super()</code> from documentation</a> - </p>
<blockquote>
<p><strong>super(type[, object-or-type])</strong></p>
<p>Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by getattr() except that the type itself is skipped.</p>
</blockquote>
<p>So the first argument to <code>super()</code> should be the child class (whose' parent class' method you want to call) , and the second argument should be the object itself , that is self. Hence , <code>super(child, self)</code> .</p>
<p>In <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow">Python 3.x</a> , you can simply call -</p>
<pre><code>super().__init__()
</code></pre>
<p>And it would call the <code>__init__()</code> method from the correct parent class.</p>
</div>
<span class="comment-copy">FWIW, you <i>could</i> call the parent <code>__init__</code> using <code>parent.__init__(self)</code>, but using <code>super</code> is preferred because it handle multiple inheritance properly.</span>
<span class="comment-copy">Great explanation</span>
<span class="comment-copy">What if the <code>_init_</code> function of my parent class contains a lot of variable declarations and some heavyweight file-io - is there are way to just get specific variables? Otherwise everytime I create an instance of my child class, it would call the <code>_init_</code> function of my parent class, which I guess would be a little overkill if I just need that one or two variables?</span>
<span class="comment-copy">Wouldn't it be possible to define those one or two variables in the child class itself , and not call the <code>super().__init__()</code> .</span>
<span class="comment-copy">@thewaywewalk: The simple answer is what Anand says: simply declare those variables in the child's <code>__init__</code> method and don't call the parent's  <code>__init__</code> method. However, if the child doesn't need all that extra stuff, then you should consider reorganizing the inheritance and swapping the roles of parent &amp; child. The parent class ought to be the base class, with the child classes having the fancy added extras.</span>
