<div class="post-text" itemprop="text">
<p>I have a bytestring from a socket connection:</p>
<pre><code>&gt;&gt;&gt; var
b'\xb5\x1a'
</code></pre>
<p>How can i convert this (little endian order) into a Hex string like:</p>
<pre><code>&gt;&gt;&gt; var2
0x1AB5
</code></pre>
<p>I tried:</p>
<pre><code>&gt;&gt;&gt; var.decode('utf-8')
Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb5 in position 0: invalid start byte

&gt;&gt;&gt; var.from_bytes(2,'little')
Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'bytes' object has no attribute 'from_bytes'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#int.from_bytes" rel="nofollow"><code>int.from_bytes</code></a> method will help.</p>
<blockquote>
<p><em>int.from_bytes(bytes, byteorder, *, signed=False)</em> -&gt; <em>int</em></p>
<p>Return the integer represented by the given array of bytes.</p>
<p>...</p>
<p>If byteorder is 'little', the most
  significant byte is at the end of the byte array.  </p>
</blockquote>
<p>It will convert bytes to integer:</p>
<pre><code>In [1]: int.from_bytes(b'\xb5\x1a', 'little') # 'little' for little-endian order
Out[1]: 6837
</code></pre>
<p>Then you can use <a href="https://docs.python.org/3/library/functions.html#hex" rel="nofollow"><code>hex</code></a></p>
<pre><code>In [2]: hex(int.from_bytes(b'\xb5\x1a', 'little'))
Out[2]: '0x1ab5'
</code></pre>
<p>or <a href="https://docs.python.org/3/library/functions.html#format" rel="nofollow"><code>format(..., '#x')</code></a></p>
<pre><code>In [3]: format(int.from_bytes(b'\xb5\x1a', 'little'), '#x')
Out[3]: '0x1ab5'
</code></pre>
<p>to get hexadecimal representation.</p>
<p>Other solutions include <a href="https://docs.python.org/3/library/base64.html#base64.b16encode" rel="nofollow"><code>base64.b16encode</code></a></p>
<pre><code>In [4]: import base64

In [5]: '0x' + base64.b16encode(b'\xb5\x1a'[::-1]).decode('ascii')
Out[5]: '0x1AB5'
</code></pre>
<p>and <a href="https://docs.python.org/3/library/binascii.html#binascii.hexlify" rel="nofollow"><code>binascii.hexlify</code></a>:</p>
<pre><code>In [24]: '0x' + binascii.hexlify(b'\xb5\x1a'[::-1]).decode('ascii')
Out[24]: '0x1ab5'
</code></pre>
<hr/>
<p>Some timings for <code>bytestr = b'\xb5\x1a'</code>:</p>
<pre><code>In [32]: %timeit hex(int.from_bytes(bytestr, 'little'))
1000000 loops, best of 3: 267 ns per loop

In [33]: %timeit format(int.from_bytes(bytestr, 'little'), '#x')
1000000 loops, best of 3: 465 ns per loop

In [34]: %timeit '0x' + base64.b16encode(bytestr[::-1]).decode('ascii')
1000000 loops, best of 3: 746 ns per loop

In [35]: %timeit '0x' + binascii.hexlify(bytestr[::-1]).decode('ascii')
1000000 loops, best of 3: 545 ns per loop
</code></pre>
<p>For <code>bytestr = b'\xb5\x1a' * 100</code>:</p>
<pre><code>In [37]: %timeit hex(int.from_bytes(bytestr, 'little'))
1000000 loops, best of 3: 992 ns per loop

In [38]: %timeit format(int.from_bytes(bytestr, 'little'), '#x')
1000000 loops, best of 3: 1.2 µs per loop

In [39]: %timeit '0x' + base64.b16encode(bytestr[::-1]).decode('ascii')
1000000 loops, best of 3: 1.38 µs per loop


In [40]: %timeit '0x' + binascii.hexlify(bytestr[::-1]).decode('ascii')
1000000 loops, best of 3: 983 ns per loop
</code></pre>
<p><code>int.from_bytes</code> is (predictably) fast for small byte strings, <code>binascii.hexlify</code> is fast for longer byte strings.</p>
</div>
