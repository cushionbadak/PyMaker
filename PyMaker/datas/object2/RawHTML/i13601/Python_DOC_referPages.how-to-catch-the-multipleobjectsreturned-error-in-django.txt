<div class="post-text" itemprop="text">
<p>Is it possible to catch the <code>MultipleObjectsReturned</code> error in Django? </p>
<p>I do a searchquery and if there are more than one objects I want that the first in the list will be taken so I tried this: </p>
<pre><code>try:
    Location.objects.get(name='Paul')
except MultipleObjectsReturned:
    Location.objects.get(name='Paul')[0]
</code></pre>
<p>However, it exists in the <a href="https://docs.djangoproject.com/en/1.8/ref/exceptions/" rel="noreferrer">doc</a> though </p>
<blockquote>
<p>global variable MultipleObjectsReturned does not exist</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This isn't the best practice. You can technically do this without using exceptions. Did you intend to use <code>Location</code> and <code>Car</code> in this example?</p>
<p>You can do this:</p>
<pre><code>Location.objects.filter(name='Paul').order_by('id').first()
</code></pre>
<p>I strongly suggest you read the Django QuerySet API reference.</p>
<p><a href="https://docs.djangoproject.com/en/1.8/ref/models/querysets/" rel="noreferrer">https://docs.djangoproject.com/en/1.8/ref/models/querysets/</a></p>
<p>To answer your question about where the exception exists -- you can always access these QuerySet exceptions on the model itself. E.g. <code>Location.DoesNotExist</code> and <code>Location.MultipleObjectsReturned</code>. You don't need to import them if you already have the model imported.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use a filter:</p>
<pre><code>Location.objects.filter(name='Paul').first()
</code></pre>
<p>Or import the exception:</p>
<pre><code>from django.core.exceptions import MultipleObjectsReturned
...
try:
    Location.objects.get(name='Paul')
except MultipleObjectsReturned:
    Location.objects.filter(name='Paul').first()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is more pythonic way to do it.</p>
<pre><code>try:
    Location.objects.get(name='Paul')
except Location.MultipleObjectsReturned:
    Location.objects.filter(name='Paul')[0]
</code></pre>
</div>
<span class="comment-copy">If I am not mistaken the exception is a propery of the model. Since that variable doesn't exist error seems to lead me to believe so.</span>
<span class="comment-copy"><a href="https://docs.djangoproject.com/en/1.8/ref/exceptions/#multipleobjectsreturned" rel="nofollow noreferrer">docs.djangoproject.com/en/1.8/ref/exceptions/â€¦</a></span>
<span class="comment-copy">However, I suggest using filter, which returns a queryset then you can take the first item in the query set using indexing. Get is for returning 1 actual object. So  you don't have to deal with error checking.</span>
<span class="comment-copy">yeah true! sorry, meant Location both times. Why is using exceptions not the best practice?</span>
<span class="comment-copy">Then what you probably want is just <code>Location.objects.filter(name='Paul').order_by('id').first()</code>. It returns None if there isn't a record with that name. I updated the answer. Using exceptions in this case is unneccessary. Instead of causing an exception to be thrown, you can still have a happy path without raising any errors.</span>
<span class="comment-copy">i see, ok thanks !</span>
<span class="comment-copy">This isn't actually an answer to the question.</span>
<span class="comment-copy">"This isn't the best practice." Are you sure catching the exception isn't best practices? I think it might be best practice in Python. According to "EAFP" in <a href="https://docs.python.org/3/glossary.html" rel="nofollow noreferrer">docs.python.org/3/glossary.html</a>, I think <a href="https://stackoverflow.com/a/32173014/2573242">stackoverflow.com/a/32173014/2573242</a> is the correct answer here.</span>
<span class="comment-copy">perfect works, thanks ! forgot to import the exceptions</span>
<span class="comment-copy"><b>Note</b>: <code>Location.objects.get(name='Paul')[0]</code> will raise <code>MultipleObjectsReturned</code> again. Use <code>Location.objects.filter(name='Paul').first()</code> instead.</span>
<span class="comment-copy">You mean <code>filter</code>, but at least it does answer how to catch the exception.</span>
<span class="comment-copy">@RemcoGerlich yes it filters or return object according to query. get return object whereas .filter returns queryset.</span>
<span class="comment-copy">@VaseemAhmedKhan The answer should be updated to do <code>Location.objects.filter(name='Paul')[0]</code>, otherwise the except block will result in the same exception being thrown. You need a queryset because that contains the logic about <i>which</i> object to return, for instance <code>Location.objects.get(name='Paul').order_by('age')[0]</code> will return the youngest Paul in the database. This is how you return the correct Paul, according to your business logic.</span>
