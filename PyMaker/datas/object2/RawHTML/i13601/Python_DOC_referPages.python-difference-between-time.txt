<div class="post-text" itemprop="text">
<p>Looking for easiest way to calculate the difference between 2 python times and display the millisecond delta</p>
<p>I have 2 times</p>
<pre><code>startTime = datetime.datetime.now().time()
</code></pre>
<p>do some stuff...</p>
<pre><code>endTime= datetime.datetime.now().time()
</code></pre>
<p>This works fine and when I log the times out and I get something like this in my logs...</p>
<pre><code>RequestStartTime = 08:56:19.188999

ResponseTime = 08:56:19.905999
</code></pre>
<p>When I try to simply subtract them like this</p>
<pre><code>delta = endTime - startTime
</code></pre>
<p>I get the following error</p>
<pre><code>unsupported operand type(s) for -: 'time' and 'time'
</code></pre>
<p>All I want to do is show the difference in microseconds and I can't figure it out</p>
<p>I want to show is <code>717000 ms</code></p>
</div>
<div class="post-text" itemprop="text">
<p>If you just use the result of <code>now()</code>, and don't convert them to <code>time</code>s, you can take the difference &amp; extract the bits you want in the form you want; for example:</p>
<pre><code>startTime = datetime.datetime.now()
endTime= datetime.datetime.now()
delta = endTime - startTime
print str(delta).split(":")[2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>from datetime import datetime, date

datetime.combine(date.today(), endTime) - datetime.combine(date.today(), startTime)
</code></pre>
<p>Hope this Helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>To measure the difference manually, you should use <a href="http://docs.python.org/3/library/time.html#time.monotonic" rel="nofollow"><code>time.monotonic()</code></a> instead.</p>
<p>If you don't care about leap seconds (~1s error once per year and a half) and you need to display the local time:</p>
<pre><code>#!/usr/bin/env python3
from datetime import datetime, timedelta, timezone

start = datetime.now(timezone.utc).astimezone() # current local time
# print("RequestStartTime = %s" % start.time())
end = datetime.now(timezone.utc).astimezone()
diff_milliseconds = (end - start) / timedelta(milliseconds=1)
print("%.0f ms" % diff_milliseconds)
</code></pre>
<p>The code works fine around/during DST transitions.</p>
<p>Note: it is different from the code that uses just <code>.now()</code>. If you use  <code>.now()</code> (no argument) then you get a naive datetime object that represents local time and in that case if a DST transition happens between <code>start</code> and <code>end</code> times then <code>end - start</code> returns a completely wrong result i.e., the code may be wrong by an hour approximately couple of times per year in some timezones.</p>
</div>
<div class="post-text" itemprop="text">
<p>the reason why you are getting an error is because class <code>time</code> does not support subtraction. You must turn <code>time</code> into miliseconds (int format) to subtract from one another.</p>
<p>instead of using <code>datetime</code>, use <code>time</code></p>
<pre><code>import time

def timenow():
    return int(round(time.time() * 1000))

startTime = timenow()
time.sleep(1)
endTime = timenow()

delta = endTime - startTime
print delta
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest solution would be to convert the datetime objects to timestamps and subtract those. If you use Python 3.3 or later you can simply do something along these lines</p>
<pre><code>startTime = datetime.datetime.now(timezone.utc).timestamp()
...
endTime = datetime.datetime.now(timezone.utc).timestamp()
</code></pre>
<p>Then you can just subtract those.</p>
<p>In Python 2 you do not have the timestamp method available. One way around would be to use a timedelta object:</p>
<pre><code>startTime = datetime.datetime.now(timezone.utc)
...
endTime = datetime.datetime.now(timezone.utc)
dt = (endTime - startTime).total_seconds()
</code></pre>
<p>A third option is to simply use raw timestamps with <code>time.time()</code> and subtract them to get the time interval in seconds and fraction of seconds. </p>
<p>To be extra safe you could use <code>time.monotonic()</code> as @Sebastian mentions.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the best answer for this problem:
<a href="https://stackoverflow.com/a/39651061/2686243">https://stackoverflow.com/a/39651061/2686243</a></p>
<pre><code>from datetime import datetime, date

duration = datetime.combine(date.min, end) - datetime.combine(date.min, beginning)
</code></pre>
</div>
<span class="comment-copy">turn them into milliseconds and then subtract.</span>
<span class="comment-copy">you may get a wrong result during DST transitions. Use <code>utcnow()</code> + <code>.total_seconds()</code> or <code>time.monotonic()</code> (short intervals) instead.</span>
<span class="comment-copy">This works great, thanks but now I am only getting microseconds.  so for example when I have these 2 times like14:25:52.206000 and 14:25:55.539000 I get a difference of 333000 which is the microseconds but I am not getting the 3 seconds, (55 - 52), included in that.  Is there an easy way to do that all in one fell swoop?</span>
<span class="comment-copy">I can do it as follows but seems this way is harder than it should be  <code>seconds = str((endTime - startTime).seconds)</code> <code>microseconds = str((endTime - startTime).microseconds)</code> <code>infolog(seconds+"."+microseconds)</code></span>
<span class="comment-copy">@Stiley: as I said above, you could use <code>seconds = (end_time - start_time).total_seconds()</code>, to get seconds including microseconds (as a fraction). To get milliseconds directly, use: <code>milliseconds = (end - start) / timedelta(milliseconds=1)</code> as shown in <a href="http://stackoverflow.com/a/32358658/4279">my answer</a></span>
<span class="comment-copy">Will this work if the program starts at 11:59:55 PM on tuesday, and finishes on 12:00:05 AM on wednesday?</span>
<span class="comment-copy">@Kevin: <code>abs()</code> call may fix the overnight difference.</span>
<span class="comment-copy">@Kevin obviously it won't work. The question assumes two time instances on the same day.</span>
<span class="comment-copy">you should call <code>time.time()</code> instead (<code>.now().timestamp()</code> may fail during DST transitions). Note: both results may be inaccurate due to ntp-adjustments or around a leap second. You could <a href="http://stackoverflow.com/a/32358658/4279">use <code>time.monotonic()</code> in this case</a></span>
<span class="comment-copy">Excellent points, @Sebastian. I have updated my answer to use UTC. Of course the issue with leap second adjustment remains.</span>
<span class="comment-copy"><code>utcnow().timestamp()</code> is wrong unless the local timezone has zero utc offset. <code>.microseconds</code> is wrong if the difference is larger than a second (you could use <code>.total_seconds()</code> instead)</span>
<span class="comment-copy">@J.F.Sebastian: you are totally right about <code>.microseconds</code>! I have changed my answer to reflect that, thank you. Could you please expand on why a difference in timestamps would be incorrect when using <code>.utcnow</code>? Thanks</span>
<span class="comment-copy"><code>.timestamp()</code> uses local timezone for naive datetime objects (that may make the absolute values wrong). Local timezone may have different utc offsets at different times (that makes the difference wrong)</span>
