<div class="post-text" itemprop="text">
<p>I am working on a Python project that mainly returns closures instead of the traditional class-based approach. For example:</p>
<pre><code>def term(token):
    def fn(text):
        return (...)
    return fn
</code></pre>
<p>As you can imagine, debugging and testing closures are a nightmare especially if I use the same name for the closure throughout my code. For example:</p>
<pre><code>&gt;&gt;&gt; term('t')
&lt;function fn at 0x...&gt;
</code></pre>
<p>So I tried wrapping it in a class to get the special <code>__repr__</code> handling from a namedtuple:</p>
<pre><code>def rr(cls, attrs):
    T = namedtuple(cls, attrs)

    class G(object):
        __slots__ = ()

        def __init__(self, repr_message, callable):
            self.callable = callable
            self.repr_message = repr_message

        def __call__(self, *args, **kwargs):
            return self.callable(*args, **kwargs)

        def __repr__(self):
            return self.repr_message

    K = type(cls, (G,), {})

    def wrapper(fn):
        def init(*args, **kwargs):
            t = T(*args, **kwargs)
            return K(
                repr(t),
                fn(*args, **kwargs),
            )
        return init
    return wrapper
</code></pre>
<p>Such that:</p>
<pre><code>&gt;&gt;&gt; rr('Term', ['token'])(term)('$')
Term(token='$')
</code></pre>
<p>As you can imagine this takes probably a hit on performance. My question is if this kind of wrapping is preferrable, if at all more Pythonic than just returning the "ugly" closure?</p>
</div>
<div class="post-text" itemprop="text">
<p>A lighter approach is to simply modify the closure's <code>func_name</code> attribute. The result isn't as pretty as what your code produces, but it will have minimal impact on RAM and performance.</p>
<pre><code>def term(token):
    def fn(text):
        return text.split(token)
    fn.func_name = "term(token={0!r})".format(token)
    return fn

s = 'splitthistestup'
f = term('t')
g = term('i')
print(f, f(s))
print(g, g(s))
</code></pre>
<p><strong>typical output</strong></p>
<pre><code>&lt;function term(token='t') at 0xb74878b4&gt; ['spli', '', 'his', 'es', 'up']
&lt;function term(token='i') at 0xb74878ec&gt; ['spl', 'tth', 'stestup']
</code></pre>
<p>For Python 3 you need to do something slightly different.</p>
<pre><code>fn.func_name = ...
</code></pre>
<p>becomes:</p>
<pre><code>fn.__qualname__ = ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I understood from your question that you were still using Python 2.</p>
<p>In Python 3 (3.3+ as we're using <code>inspect.getclosurevars</code>) here one can do some serious magic to do an almost-no-overhead decorator that will (for this case) produce the desired output; this is harder to do in Python 2, since Python 2 functions do not know their fully-qualified name:</p>
<pre><code>import inspect

class reprcorate(object):
    __slots__ = ('__call__',)

    def __init__(self, callable):
        self.__call__ = callable

    def __repr__(self):
        func = self.__call__
        funcname = func.__qualname__
        funcname = funcname.replace('.&lt;locals&gt;', '')

        try:
            closure_vars = inspect.getclosurevars(func)
            args = '(%s)' % ', '.join('%s=%r' % i for i in closure_vars.nonlocals.items())
            last_part = '.' + func.__name__

            if funcname.endswith(last_part):
                funcname = funcname[:-len(last_part)]

        except:
            args = '(...)'

        return funcname + args

def term(token):
    @reprcorate
    def fn(text):
        @reprcorate
        def fn2(fn2arg):
            print(token, text, fn2arg)

        return fn2

    return fn

print(term('foo'))
print(term('foo')('bar'))
</code></pre>
<p>prints out</p>
<pre><code>term(token='foo')
term.fn(token='foo', text='bar')
</code></pre>
<hr/>
<p>How this works is that the <code>__call__</code> can be assigned for an <em>instance</em>; so we do not need to have a dummy <code>__call__</code> trampoline; we also use the <code>__slots__</code> to decrease runtime overhead.</p>
<p>The real magic lies in the <code>__repr__</code> method, wherein the function/closure that was decorated is carefully dissected. The free variables that the function uses from the outer scope can be inspected with the help of <a href="https://docs.python.org/3/library/inspect.html#inspect.getclosurevars" rel="nofollow"><code>inspect.getclosurevars</code></a> which returns a named tuple; we're especially interested in the <code>nonlocals</code> since these are the values used from the outer scopes; this is a simple dictionary of variable name to value. We make this into a nice string of <code>variable=value, variable=value</code>. These are not strictly the function arguments, but are the values that are seen and used in the inner closure. </p>
<p>We also clean the function name a bit; in Python 3 the name of the function is in <code>__name__</code>, and the fully qualified name is in <code>__qualname__</code>; the <code>__qualname__</code> for closures looks like <code>foo.&lt;locals&gt;.bar.&lt;locals&gt;.baz</code>, so we remove all <code>.&lt;locals&gt;</code>, to get <code>foo.bar.baz</code>; we then remove the last dotted part if it matches the <code>__funcname__</code> of our wrapped function, and append the nicely formatted arguments at the end, for truly nice results.</p>
</div>
<span class="comment-copy">Your problem is a Python <b>2</b> problem; in Python 3 the <code>repr</code> of a closure reports the defining environment.</span>
<span class="comment-copy">Thanks for the update to my answer, Dunes.</span>
<span class="comment-copy">Thanks - this is really good and I would've used it if I didn't need to support both versions of Python. From my understanding, aren't "magic-methods" ignored on a per-object basis, instead only acknowledged if the object's class has the magic-method?</span>
