<div class="post-text" itemprop="text">
<p>I want to check all the values in a matrix and if it's 1 print the x,y coordinates. </p>
<p>This is my matrix:</p>
<pre><code>0, 0, 0, 1,
1, 0, 0, 0,
0, 0, 1, 0,
0, 1, 0, 0,
</code></pre>
<p>This is my code so far:</p>
<pre><code>m = open('matrix.txt', 'r')
l = []
l = [line.split() for line in m]
for x in range(4):
    for y in range(4):
        p = int(l[x][y][:-1])
        if p == 1:
            print(x, y)
</code></pre>
<p>But when i run it i get this:</p>
<p>the coordinates:</p>
<pre><code>0 3
1 0
2 2
3 1
</code></pre>
<p>and then this error:</p>
<pre><code>ValueError: invalid literal for int() with base 10: ''
</code></pre>
<p>What am i doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>You are iterating over <code>range(10)</code> while you have a 4x4 matrix. You need <code>range(4)</code> instead.</p>
<p>But this is not the pythonic way to go with this task.First of all you don't need to initial a list when you want to use a list comprehension so you don't need <code>l=[]</code> at all,then as a pythonic way for dealing with files you can use <a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement" rel="nofollow"><code>with</code> statement</a> that close the file after the nested block of code.And for iterating over an iterable and getting the indices you can use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow"><code>enumerate()</code></a> function.</p>
<pre><code>with open('matrix.txt', 'r') as f:
    li = [line.split() for line in f]

    for index,row in enumerate(li):
       for i,item in enumerate(row):
        if item == '1':
            print(index,i)
</code></pre>
<p>Also note that in your code the line <code>p = int(l[x][y][:-1])</code> is redundant and you don't need to convert the item to integer you can simply check with <code>'1'</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>Alternatively I will suggest using <code>numpy</code> to deal with matrix.</p>
<p>Here is how to do it with <code>argwhere</code>:</p>
<pre><code>In [6]: import numpy as np

In [7]: m = np.matrix([
[0, 0, 0, 1],
[1, 0, 0, 0],
[0, 0, 1, 0],
[0, 1, 0, 0]])

# use argwhere to find the coordinates
In [8]: np.argwhere(m == 1)
Out[8]:
array([[[0, 3]],

       [[1, 0]],

       [[2, 2]],

       [[3, 1]]])
</code></pre>
<p>To return as a list of tuples:</p>
<pre><code>In [10]: list(map(tuple, np.argwhere(m == 1)))
Out[10]: [(0, 3), (1, 0), (2, 2), (3, 1)]
</code></pre>
<p>To construct your matrix, you can do it with:</p>
<pre><code>m = np.matrix([map(int, filter(lambda x: x, line.strip().split(","))) 
               for line in f]) # where f is your opened file
</code></pre>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import product
</code></pre>
<p>You can do it simply this way</p>
<pre><code>with open('matrix.txt', 'r') as m:
    l = [line.split() for line in m]
    result = [ (x,y)  for x,y in list(product(range(4), range(4))) if int(l[x][y][:-1]) ]

print result

[(0, 3), (1, 0), (2, 2), (3, 1)]
</code></pre>
<p>I kept the same splitting line as yours,
Then in the second one I iterate over all the combinations and keep only x,y when 1 is met.
And you get the expected result</p>
</div>
<div class="post-text" itemprop="text">
<p>After reading the matrix from the file:</p>
<pre><code>with open('matrix.txt', 'r') as f:
  lines=[line.split() for line in f.readlines()]
</code></pre>
<p>You can find all the 1 indices with one line:</p>
<pre><code>indices=[[(i,j) for i,a in enumerate(line) if a==1] for j,line in enumerate(lines)]
</code></pre>
<p>And if you want to flatten the array:</p>
<pre><code>indices=reduce(list.__add__,indices)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another pythonic way would be to read a comma-separated data file with the <code>csv</code> library and <code>enumerate()</code> over rows and column fields:</p>
<pre><code>#!/usr/bin/env python

import csv

mtx = csv.reader(open("matrix.txt", "rb"))
for row_idx, row_data in enumerate(mtx):
    for cell_enum in [(col_idx, col_val.strip()) for col_idx, col_val in enumerate(row_data)]:
        if cell_enum[1] == '1':
            print row_idx, cell_enum[0]
</code></pre>
<p>Output:</p>
<pre><code>0 3
1 0
2 2
3 1
</code></pre>
<p><strong>Edit</strong>: Removed <code>int()</code> cast so that the <code>try..except</code> block is no longer necessary.</p>
</div>
<span class="comment-copy">And the Pythonic way to walk through a matrix is <code>for x, y in itertools.product(range(4), repeat=2):...</code></span>
<span class="comment-copy">@EliKorvigo Yep, but in this case we just have 2 loop and it make no difference.</span>
<span class="comment-copy">it throws a SintaxError for the<code>,</code> in  <code>except ValueError, ve:</code> is there another way to except the <code>ValueError</code> and the <code>ve</code>?</span>
<span class="comment-copy">See edited answer.</span>
<span class="comment-copy">? Why the downvote?</span>
