<div class="post-text" itemprop="text">
<p>I am unit testing the following functions:</p>
<pre><code>import uuid


def process_name(id, name, weight):
    print('process_item:', id, name, weight)


def process_list(names):
    for (name, weight) in names:
        id = uuid.uuid4()
    process_name(id, name, weight)
</code></pre>
<p>My unit test looks as follows:</p>
<pre><code>import unittest
from mock import patch, call
import SomePackage.SomeModule


class MyTestCase(unittest.TestCase):
    def test_something(self):
        items = [('Joe', 190), ('Dan', 200)]
        with patch('SomePackage.SomeModule.process_name') as mock_process_name:
            SomePackage.SomeModule.process_list(items)
</code></pre>
<p>I cannot match the whole <code>mock_calls</code> thing, because the first parameter submitted to it is a guid, and as such it will be different every time I call the function:</p>
<pre><code>print(mock_process_name.mock_calls)
[call(UUID('some randomish guid'), 'Joe', 190),
 call(UUID('some other guid'), 'Dan', 200)]
</code></pre>
<p>I want to extract the parameters, and only match the non-volatile ones:</p>
<pre><code> print(mock_process_name.mock_calls[0][1][1:])
 print(mock_process_name.mock_calls[1][1][1:])
 ('Joe', 190)
 ('Dan', 200)
</code></pre>
<p>I know that I can also mock the thing which returns guids, and provide a fixed list of values in its side_effect. However, I feel quite lazy needing to mock too many things like <code>uuid.uuid4()</code>, <code>datetime.now()</code> and such. This is why I am looking for an alternative to mocking each and every volatile function.</p>
<p>Is there a more readable alternative to <code>mock_calls[0][1][1:]</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>There was a proposal to support this use case somewhere (bugs or mock repo?) but AFAIK it's not implemented yet.</p>
<p>For now you have these options in the order of my preference:</p>
<h3>inspect what you need</h3>
<pre><code>assert "Joe" in xx.mock_calls[0][1]
assert 190 in xx.mock_calls[0][1]
</code></pre>
<p>Also has the advantage that when tests break you know exactly which of these two broke.</p>
<h3>mock UUID</h3>
<p>Mock it with predictable sequence and then you can validate your calls.</p>
<h3>use mock.ANY</h3>
<pre><code>xx.assert_called_with(mock.ANY, "Dan", 200)
</code></pre>
<p>Unfortunately only works with the last call.
You could decompose your test.</p>
<h3>assert_any_call</h3>
<pre><code>xx.assert_any_call(mock.ANY, "Joe", 190)
</code></pre>
<p>However you can't validate relative order of Joe and Dan.</p>
<h3>mock.ANY in roundabout way</h3>
<pre><code>assert xx.mock_calls[0][1] == (mock.ANY, "Joe", 190)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The simplest way to do your assert is </p>
<pre><code>mock_process_name.assert_has_calls([call(ANY, "Dan", 200), call(ANY, "Joe", 190)])
</code></pre>
<p>Where <a href="https://docs.python.org/3/library/unittest.mock.html#any" rel="nofollow"><code>ANY</code></a> is an helper imported from <code>mock</code> module </p>
<p>You can use <code>any_order=True</code> options if you are not interested in call order. Moreover if your chain calls is complex you can take a look to <a href="http://www.voidspace.org.uk/python/mock/examples.html#tracking-order-of-calls-and-less-verbose-call-assertions" rel="nofollow">Tracking order of calls and less verbose call assertions</a>.</p>
</div>
<span class="comment-copy">That fits very well with OP; Quoting documentation, """ If <code>any_order</code> is false (the default) then the calls must be sequential. There can be extra calls before or after the specified calls. """ Gotta remember the last gotcha :)</span>
<span class="comment-copy">@qarma IMHO the name <code>assert_has_calls</code> is clear enough to don't forget it (<code>assert_is_calls</code> can be a better name for this purpose). I write my <code>assert_is_calls</code> helper when I need to check it exactly by use <code>assert len(m.mock_calls) == len(calls)</code></span>
