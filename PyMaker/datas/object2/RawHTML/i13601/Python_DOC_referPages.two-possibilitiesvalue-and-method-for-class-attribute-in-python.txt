<div class="post-text" itemprop="text">
<p>Let's say I have a class. I want this class to have attribute x so that whenever I use the class without instantiating, I can both call the current value of x and when I change the value of x, to run a method that takes the value I put in x and does something else with it.</p>
<p>"Example" is a class:</p>
<pre><code>[IN]: Example(y).x
[OUT]: 0

[IN]: Example(y).x=2
[OUT]: x(2)=6

[IN]: Example(y).x
[OUT]: 6
</code></pre>
<p>Sorry if this turns out to be banal. I tried searching and didn't come up with anything.</p>
<p>Example's x value must have a paired y value that belongs to the particular class. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can override the <code>__setattr__</code> method on your class:</p>
<pre><code>class Test(object):
    def foo(self, v):
        return v + 1

    def __setattr__(self, attribute, v):
        return super(Test, self).__setattr__(attribute, self.foo(v))

t = Test()
t.a = 1  # t == 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's how you do this:</p>
<pre><code>values = {}

class Example(object):

    def __init__(self,y):
        self.y=y

    @property
    def value(self):
        values[self.y]=some_data_object_method(self.y)
        return some_data_object_method(self.y)

    @value.setter
    def value(self,new_value):
        if new_value not in values.itervalues():
            some_data_object_method(self.y) = new_value
</code></pre>
<p>Simple as that. Probably ended up being banal after all.</p>
</div>
<span class="comment-copy">Does a class variable work for you?  class Example:      x = 0</span>
<span class="comment-copy">Actually I think I answered my own question. I am going to create a global dictionary for the values and have calling the value of x insert y:x(input) as a pair in the dictionary while running the appropriate method. I think I can do this within a class by saying that x is equal to the relevant function. The only question now is whether I can do this without having to instantiate the class for each y value.</span>
<span class="comment-copy">I agree with a 'common dictionary' approach - see <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer">defaultdict</a> (with <a href="https://www.accelebrate.com/blog/using-defaultdict-python/" rel="nofollow noreferrer">an example here</a>); <code>defaultdict</code> allows specifying a creation function. In this case that would simply be to create a new Example object which frees up the busywork of needing to 'check' first.</span>
<span class="comment-copy">Ok, this was probably an easy exercise I just need a little input on to get creative juices flowing. Today I learned about decoraters! Yay haha. Anyway, simple solution, property vs property setter. No need to instantiate class. Works perfectly.</span>
