<div class="post-text" itemprop="text">
<p>I have line segments of four colors—pink, green, orange, red—as in the figure below.</p>
<p><a href="https://i.stack.imgur.com/ZkyT6.jpg" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/ZkyT6.jpg"/></a></p>
<p>As an example, the first pink segment has start and end position <code>(5258,5422)</code>.</p>
<p>The coordinates are stored in this dictionary of tuples:</p>
<pre><code>mycoord = { 'pink'  :[(5258,5422), (5479,5864)],
            'green' :[(5425,5450)],
            'orange':[(5266,5770)],
            'red'   :[(5258,5864)] }
</code></pre>
<p>What I want to do is to get all the possible intersections' start and end values as shown in this figure:</p>
<p><a href="https://i.stack.imgur.com/tj0Mj.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/tj0Mj.png"/></a></p>
<p>Thus, the desired answer would be:</p>
<pre><code>sect1/pink-red        : 5258,5266
sect2/pink-orange-red : 5266,5422
sect3/orange-red      : 5422,5425
sect4/green-orange-red: 5425,5450
sect5/orange-red      : 5450,5479
sect6/pink-orange-red : 5479,5770
sect7/pink-red        : 5770,5864
</code></pre>
<p>Note that I want to preserve the color indicator for each intersection (<em>e.g.,</em> <code>pink-red</code>). How can I achieve this with Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest that you proceed as follows.</p>
<ul>
<li><p>Sort the endpoints, remembering each one's color and whether it's a left (opening) or right (closing) endpoint.</p></li>
<li><p>Iterate over the endpoints, keeping track of open spans with a hash that maps each color to the number of open spans of that color. Increment when you open a span of a given color, decrement when you close a span. Remove colors when their count reaches zero. For each distinct endpoint, put the colors of all open spans at that point into a set.</p></li>
<li><p>Iterate over consecutive pairs of distinct endpoints. These form the left and right endpoints of the spans that interest you. For each endpoint, you know the colors that are active at that point. The set of colors that are active during the span is the <a href="https://docs.python.org/3/library/stdtypes.html#set" rel="nofollow">set intersection</a> of the colors that are active at the left end and the colors that are active at the right end.</p></li>
</ul>
<p><strong>Note:</strong> If the intersection of colors between two endpoints is empty, you've found a gap between spans, so you know that it should be skipped. You might also like to skip spans with only one color. The implementation below does not. You can easily change it to skip single-color spans by modifying this line:</p>
<pre><code>  if len(colors) &gt; 0:
</code></pre>
<p>so that it reads:</p>
<pre><code>  if len(colors) &gt; 1:
</code></pre>
<p>If you're interested in seeing the gaps between spans, you can change the threshold to <code>-1</code> or remove the condition altogether.</p>
<p>Implementation:</p>
<pre><code>mycoord = { 'pink'  :[(5258,5422), (5479,5864)],
            'green' :[(5425,5450)],
            'orange':[(5266,5770)],
            'red'   :[(5258,5864)] }

# Sort the endpoints. Remember their color and whether they open or close.
points = []
for color, spans in mycoord.items():
  for open, close in spans:
    points.append((open, 'open', color))
    points.append((close, 'close', color))
points.sort()

# Iterate over the endpoints. Keep track of open spans. Mark intersections.
active_spans = {}
intersections = []
for point, kind, color in points:
  if len(intersections) != 0 and intersections[-1][0] == point:
    intersections[-1][1].add(color)
  else:
    color_set = set([color] + list(active_spans.keys()))
    intersections.append((point, color_set))
  if kind == 'close':
    active_spans[color] -= 1
    if active_spans[color] == 0:
      del active_spans[color]
  else:
    active_spans[color] = active_spans.setdefault(color, 0) + 1

# Iterate over consecutive pairs of unique intersections. Intersect the color sets.
tab_width = sum(map(len, mycoord)) + len(mycoord) 
count = 0
for i in range(1, len(intersections)):
  a, b = intersections[i - 1], intersections[i]
  colors = sorted(a[1] &amp; b[1])
  if len(colors) &gt; 0:
    count += 1
    print('sect{0}/{1:&lt;{2}}: {3},{4}'.format(count, '-'.join(colors), tab_width,
        a[0], b[0]))
</code></pre>
<p>Result:</p>
<pre><code>sect1/pink-red              : 5258,5266
sect2/orange-pink-red       : 5266,5422
sect3/orange-red            : 5422,5425
sect4/green-orange-red      : 5425,5450
sect5/orange-red            : 5450,5479
sect6/orange-pink-red       : 5479,5770
sect7/pink-red              : 5770,5864
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using the brace open/close idea of Michael Laszlo above:</p>
<pre><code>&gt;&gt;&gt; mycoord = { 'pink'  :[(5258,5422), (5479,5864)],
            'green' :[(5425,5450)],
            'orange':[(5266,5770)],
            'red'   :[(5258,5864)] }
&gt;&gt;&gt; labeled_values=[]
# make tuples of (value, brace status (open/close), color)
&gt;&gt;&gt; for color,color_ranges in mycoord.items():
        for color_range in color_ranges:
            labeled_values.append((color_range[0],True,color))
            labeled_values.append((color_range[1],False,color))

    # labeled_values are now like (5258, True, 'pink'), (5422, False, 'pink') ...
&gt;&gt;&gt; sects = []
# traverse the sorted values and maintain a color-set
&gt;&gt;&gt; color_set_so_far=set()
&gt;&gt;&gt; range_start = -1
&gt;&gt;&gt; for value,range_open,color in sorted(labeled_values):   
        if not range_open or range_start != value:
            sects.append(("-".join(color_set_so_far), range_start, value))

        if range_open:          
            color_set_so_far.add(color)
        else:       
            color_set_so_far.remove(color)      

        range_start = value

&gt;&gt;&gt; sects = [s for s in sects if s[0] and s[1]!=s[2]] # filter out empty ranges
&gt;&gt;&gt; sects
# [('pink-red', 5258, 5266), ('pink-orange-red', 5266, 5422), ('orange-red', 5422, 5425), ('orange-green-red', 5425, 5450), ('orange-red', 5450, 5479), ('pink-orange-red', 5479, 5770), ('pink-red', 5770, 5864)]
</code></pre>
</div>
<span class="comment-copy">Quick guess: Flatten the values and sort?</span>
<span class="comment-copy">Flattening and sorting may lose the colour information; you'd need something like numpy's argsort. Neversaint: have you already tried anything? You may have a look at Python's sets, and use intersections; perhaps that can help get you started.</span>
<span class="comment-copy">@neversaint You accepted an answer that doesn't work when there are several overlapping segments of the same color. My answer works in all cases.</span>
<span class="comment-copy">@MichaelLaszlo: Ok. I accepted yours instead.</span>
