<div class="post-text" itemprop="text">
<p>Why isn't this for loop working? My goal is to delete every <code>1</code> from my list.</p>
<pre><code>&gt;&gt;&gt; s=[1,4,1,4,1,4,1,1,0,1]
&gt;&gt;&gt; for i in s:
...   if i ==1: s.remove(i)
... 
&gt;&gt;&gt; s
[4, 4, 4, 0, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should not change the content of list while iterating over it </p>
<p>But you could iterate over the copy of the list content and change it in your case</p>
<p><strong>Code:</strong></p>
<pre><code>s=[1,4,1,4,1,4,1,1,0,1]
for i in s[:]:
    if i ==1: s.remove(i)
print s
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>[4, 4, 4, 0]
</code></pre>
<p>As @metatoaster stated you could use <code>filter</code></p>
<p><strong>Code:</strong></p>
<pre><code>s=[1,4,1,4,1,4,1,1,0,1]
s=list(filter(lambda x:x !=1,s))
print s
[4, 4, 4, 0]
</code></pre>
<p>You could use filter to remove multiple things example</p>
<p><strong>Code:</strong></p>
<pre><code>s=[1,4,1,4,1,4,1,1,0,1,2,3,5,6,7,8,9,10,20]
remove_element=[1,2,3,5,6,7,8,9]
s=list(filter(lambda x:x not in remove_element,s))
print s
[4, 4, 4, 0, 10, 20]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Never change a list while iterating over it. The results are unpredictable, as you're seeing here. One simple alternative is to construct a new list:</p>
<pre><code>s = [i for i in s if i != 1]
</code></pre>
<p>If for some reason you absolutely have to edit the list in place rather than constructing a new one, my off-the-cuff best answer is to traverse it finding the indices that must be deleted, then reverse traverse that list of indices removing them one by one:</p>
<pre><code>indices_to_remove = [i for (i, val) in enumerate(s) if val == 1]
for i in reversed(indices_to_remove):
    del s[i]
</code></pre>
<p>Because that removes elements from the end of the list first, the original indices computed remain valid. But I would generally prefer computing the new list unless special circumstances apply.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider this code:</p>
<pre><code>  #!/usr/bin/env python

  s=[1, 4, 1, 4, 1, 4, 1, 1, 0, 1]
  list_size=len(s)
  i=0

  while i!=list_size:
      if s[i]==1:
          del s[i]
          list_size=len(s)
      else:
          i=i + 1

  print s
</code></pre>
<p>Result:</p>
<pre><code>[4, 4, 4, 0]
</code></pre>
<p>For short, your code get some undesirable result because of "size" and "index positions" of your list are changed every times you cut the number <code>1</code> off and your code is clearly proved that <code>for each loop</code> in <code>Python</code> can not handle a list with a dynamic size.</p>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't work because you are modifying the list as it is iterating, and the current pointer moves past one of the <code>1</code> you check against.  We can illustrate this:</p>
<pre><code>&gt;&gt;&gt; for i in s:
...   print(s)
...   if i == 1:
...      s.remove(i)
... 
[1_, 4, 1, 4, 1, 4, 1, 1, 0, 1]
[4, 1_, 4, 1, 4, 1, 1, 0, 1]
[4, 4, 1_, 4, 1, 1, 0, 1]
[4, 4, 4, 1_, 1, 0, 1]
[4, 4, 4, 1, 0_, 1]
[4, 4, 4, 1, 0, 1_]
</code></pre>
<p>I added <code>_</code> to the element being compared.  Note how there was only 6 passes in total and with one of the <code>1</code>s actually skipped over from being ever looked at.  That ends up being the element that was removed because <code>list.remove</code> removes the first occurrence of the element specified, and it is an O(n) operation on its own which gets <strong>very</strong> expensive once your list gets big - this is O(n) even if the item is in the beginning, as it has to copy every single item from everything after the item one element forward as python <code>list</code>s are more like C styled arrays than Java linked-lists (if you want to use linked-lists, use <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow"><code>collections.deque</code></a>). O(n) towards the end because it has to iterate through the entire list to do its own comparison too. Your resulting code can result in a worst case runtime complexity of O(n log n) if you make use of <code>remove</code>.</p>
<p>See <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">Python's data structure time complexity</a></p>
<p>Peter's answer already covered the generation of a new list, I am only answering why and how your original code did not work exactly.</p>
</div>
<span class="comment-copy">Your solution results in one extra iteration through the list for every element to be removed, and one extra for the creation of the new list plus the memory required.  Just use the filter to create the new list and don't bother with remove.</span>
<span class="comment-copy">@metatoaster agreed just wanted to show that OP can do it with his same code with slight changes</span>
<span class="comment-copy">@metatoaster added filter as you stated</span>
<span class="comment-copy">This is another good way to modify the list in place.</span>
<span class="comment-copy">Just for the sake of fiddly precision - I think technically the language behavior in this case is undefined, but this is a good demonstration of how the common C implementation handles this, and how anything that implements the obvious index-based iterator over a mutable data structure will handle this.</span>
<span class="comment-copy">@PeterDeGlopper I ended up expanding on this as you were making this comment, also added that other link, too.</span>
<span class="comment-copy">Come to think of it, if the OP were willing to tolerate an <code>n^2</code> algorithm (such as anything using <code>remove</code>) the simplest way to do it would just be to run it in an infinite <code>while</code> loop that breaks on the <code>ValueError</code> raised when nothing matches the <code>remove</code> argument.</span>
<span class="comment-copy">Yeah, and this at least avoids the doubling of memory usage from recreation of the new list for the comparison. Basically only do the least wrong things at a time if wrongness must be done.</span>
<span class="comment-copy">Right, although the old list will be garbage collected unless anything else is pointing to it. Either way you have to know whether a new shallow copy with the filtered data works for you or not.</span>
