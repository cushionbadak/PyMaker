<div class="post-text" itemprop="text">
<p>I'm trying to define the <code>__call__</code> dunder method at runtime, but with no success. The code is the following:</p>
<pre><code>class Struct:
    pass

result=Struct()
dictionary={'a':5,'b':7}
for k,v in dictionary.items():
    setattr(result,k,v)

result.__call__=lambda self: 2
</code></pre>
<p>However, the interpreter returns the error:</p>
<pre><code>Traceback (most recent call last):
 File "&lt;input&gt;", line 1, in &lt;module&gt;
TypeError: 'Struct' object is not callable
</code></pre>
<p>But, if I add the dunder method since the beginning, all magically works:</p>
<pre><code>class Foo():
   def __call__(self):
      return 42

foo=Foo()
foo() #returns 42
</code></pre>
<p>I'm using Python 3.4 on windows 64bit machine.</p>
<p>Where am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Edited</strong></p>
<p>You can attach <code>__call__</code> by adding it to the <strong>class</strong> object:</p>
<pre><code>Struct.__call__ = lambda self: 2
</code></pre>
<p>But if you want to get different values per instance you should:</p>
<pre><code>class Struct:
    def __call__(self):
        return self._call_ret

result=Struct()
dictionary={'a':5,'b':7}
for k,v in dictionary.items():
    setattr(result,k,v)
    result._call_ret = 2

print(result())
</code></pre>
<p>@Blckknght thanks.</p>
</div>
<span class="comment-copy">When you do <code>obj(...)</code>, Python executes <code>obj.__class__.__call__(obj, ...)</code></span>
<span class="comment-copy">For reference, see <a href="https://docs.python.org/3/reference/datamodel.html?highlight=special%20methods#special-method-names" rel="nofollow noreferrer">Special method names</a>: "if a class defines a method named __getitem__(), and x is an instance of this class, then x[i] is roughly equivalent to type(x).__getitem__(x, i)."</span>
<span class="comment-copy">And more generally for all special methods, <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">Special method lookup</a>: "implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary."</span>
<span class="comment-copy">@ShadowRanger,  thanks for the link about the special method lookup; reading it improved my knowledge about special methods;</span>
<span class="comment-copy">There's no need for <code>setattr</code> if the name is a constant. You can just do <code>Struct.__call__ = lambda self: 2</code> and <code>result._call_ret = 2</code></span>
<span class="comment-copy">At the end I used the method proposed by kAlmAcetA. However, the link <a href="https://docs.python.org/3/reference/datamodel.html#special-lookup" rel="nofollow noreferrer">special method lookup</a> got from ShadowRanger really solved why I encoutered this problem.</span>
