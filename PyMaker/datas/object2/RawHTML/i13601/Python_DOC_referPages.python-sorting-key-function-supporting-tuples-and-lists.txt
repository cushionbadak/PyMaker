<div class="post-text" itemprop="text">
<p>In Python you can for example sort tuples <code>sorted([(2,2),(1,2),(2,1),(1,1)])</code> and get <code>[(1, 1), (1, 2), (2, 1), (2, 2)]</code>.</p>
<p>You can also use custom key functions <code>sorted([x, y, z], key=custom_key)</code> to implement special sorting criteria.</p>
<p>For example:</p>
<pre><code>medals_map = {'Gold': 1, 'Silver': 2, 'Bronze': 3 }
def custom_key(item):
    if isinstance(item, basestring):
       try:
           return medals_map[item]
       except KeyError:
           pass
    return item
</code></pre>
<p>Could sort any list of strings normally, and also gold/silver/bronze according to my custom ordering.</p>
<p>But it does not "correctly" handle tuples anymore: <code>sorted([('Gold', 2), ('Bronze', 1), ('Gold', 1)], key=custom_key)</code> results in <code>[('Bronze', 1), ('Gold', 1), ('Gold', 2)]</code> as item is not a <code>basestring</code>.</p>
<p>But I would like to get <code>[('Gold', 1), ('Gold', 2), ('Bronze', 1)]</code> by somehow applying the custom logic to each item in the tuple.</p>
<p>What's the best way to "map" the custom key logic over any tuples (that may or may not appear) in the list like the default key function does?</p>
<hr/>
<p>Edit: More examples:</p>
<ul>
<li><code>sorted(['Silver', 'Bronze', 'Gold'], key=custom_key)</code>
<ul>
<li><code>['Gold', 'Silver', 'Bronze']</code></li>
</ul></li>
<li><code>sorted([['Silver', 2], ['Silver', 1], ['Gold', 1]], key=custom_key)</code>
<ul>
<li><code>[['Gold', 1], ['Silver', 1], ['Silver', 2]]</code></li>
</ul></li>
<li><code>sorted([(2, 'Gold'), (2, 'Bronze'), (1, 'Gold')], key=custom_key)</code>
<ul>
<li><code>[(1, 'Gold'), (2, 'Gold'), (2, 'Bronze')]</code></li>
</ul></li>
<li><code>sorted([('Silver', 'Bronze'), ('Gold', 'Bronze'), ('Silver', 'Gold')], key=custom_key)</code>
<ul>
<li><code>[('Gold', 'Bronze'), ('Silver', 'Gold'), ('Silver', 'Bronze')]</code></li>
</ul></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<pre><code>from collections import Iterable
def custom_key(item):
    if isinstance(item, Iterable) and not isinstance(item, basestring):
        return [medals_map.get(ele, ele) for ele in item]
    return medals_map.get(item, item)
</code></pre>
<p>Output:</p>
<pre><code>In [2]: assert sorted(['Silver', 'Bronze', 'Gold'], key=custom_key) == ['Gold', 'Silver', 'Bronze']

In [3]: assert sorted([['Silver', 2], ['Silver', 1], ['Gold', 1]], key=custom_key) == [['Gold', 1], ['Silver', 1], ['Silver', 2]]

In [4]: assert sorted([(2, 'Gold'), (2, 'Bronze'), (1, 'Gold')], key=custom_key) == [(1, 'Gold'), (2, 'Gold'), (2, 'Bronze')]

In [5]: assert sorted([('Silver', 'Bronze'), ('Gold', 'Bronze'), ('Silver', 'Gold')], key=custom_key) == [('Gold', 'Bronze'), ('Silver', 'Gold'), ('Silver', 'Bronze')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create a mapper function, that takes your key function and returns another function, applying the key function to each element of some iterable.</p>
<pre><code>def mapper(function):
    def inner(values):
        return tuple([function(x) for x in values])
    return inner
</code></pre>
<p>Example:</p>
<pre><code>&gt;&gt;&gt;sorted([('Gold', 2), ('Bronze', 1), ('Gold', 1)], key=mapper(custom_key))
[('Gold', 1), ('Gold', 2), ('Bronze', 1)]
</code></pre>
<p>Or similar, using <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow"><code>functools.partial</code></a> with <code>map</code>:</p>
<pre><code>&gt;&gt;&gt; sorted([('Gold', 2), ('Bronze', 1), ('Gold', 1)], key=functools.partial(map, custom_key))
[('Gold', 1), ('Gold', 2), ('Bronze', 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The key function can return a tuple:</p>
<pre><code>medals_map = {'Gold': 1, 'Silver': 2, 'Bronze': 3 }

def custom_key(item):
    if isinstance(item, basestring):
       try:
           return medals_map[item]
       except KeyError:
           pass
    return item

print sorted([('Gold', 2), ('Bronze', 1), ('Gold', 1)], key=lambda x: (custom_key(x[0]), x[1]))
</code></pre>
<p>Prints <code>[('Gold', 1), ('Gold', 2), ('Bronze', 1)]</code>. Essentially this makes the sorting behave the same as your first example, i.e. <code>sorted([(1, 2), (3, 1), (1, 1)])</code>.</p>
<p>Edit: you can also make a custom key that returns a tuple, which may be prettier.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need a extra function. You can also do it:</p>
<pre><code>medals_map = {'Gold': 1, 'Silver': 2, 'Bronze': 3 }
List = [('Bronze', 1), ('Gold', 1), ('Gold', 2)]

new_list = sorted(List, key=lambda word: (medals_map[word[0]], word[1]))

print new_list
</code></pre>
<p>Output:</p>
<pre><code>[('Gold', 1), ('Gold', 2), ('Bronze', 1)]
</code></pre>
</div>
<span class="comment-copy">So the <code>custom_key</code> needs to handle <code>item</code> being either a tuple or string? Why not add another <code>isinstance</code>, with a recursive call? Note that <code>return medals_map.get(item, item)</code> is neater than faffing with <code>try</code> and <code>except</code>.</span>
<span class="comment-copy">@jonrsharpe: Right, but <code>item</code> might also be a list, or maybe some other iterable? Do I just have to add more <code>isinstance</code> checks for all kinds of things? I hoped since the default key function already does all that I can somehow avoid doing that.</span>
<span class="comment-copy">@Peter, add an example of a less structured input list and what you expect as output</span>
<span class="comment-copy">@PadraicCunningham: I now added more examples at the end of the question</span>
<span class="comment-copy">@Peter if you don't even know what you're going to be trying to sort, maybe solve <i>that</i> problem?</span>
<span class="comment-copy">This looks interesting. Why is the first element in the iterable special?</span>
<span class="comment-copy">@Peter, it's not,   was originally doing something else, you just need to return the list come if the "item" is not a string.</span>
<span class="comment-copy">I don't actually know the structure of the list. It might not contain tuples.</span>
<span class="comment-copy">I don't actually know the structure of the list. It might not contain tuples, and the medals might appear in any position in the tuple.</span>
<span class="comment-copy">That works for this specific example, but I don't actually know the structure of the list. It might not contain tuples, and the medals might appear in any position in the tuple.</span>
<span class="comment-copy">But this answer according this question. you don't tell this(as your comment) in you question. So my answer according question</span>
<span class="comment-copy">The question mentions "over any tuples (that may or may not appear)". (I did not downvote your answer by the way!)</span>
<span class="comment-copy">Hmm you edited your question only 6 min ago, but I answered  28 min ago</span>
<span class="comment-copy">Only to add more examples. The quoted part of the question was there before.</span>
