<div class="post-text" itemprop="text">
<p>I have this function that calls itself:</p>
<pre><code>def get_input():
    my_var = input('Enter "a" or "b": ')

    if my_var != "a" and my_var != "b":
        print('You didn\'t type "a" or "b". Try again.')
        get_input()
    else:
        return my_var

print('got input:', get_input())
</code></pre>
<p>Now, if I input just "a" or "b", everything works fine:</p>
<pre class="lang-none prettyprint-override"><code>Type "a" or "b": a
got input: a
</code></pre>
<p>But, if I type something else and then "a" or "b", I get this:</p>
<pre class="lang-none prettyprint-override"><code>Type "a" or "b": purple
You didn't type "a" or "b". Try again.
Type "a" or "b": a
got input: None
</code></pre>
<p>I don't know why <code>get_input()</code> is returning <code>None</code>, since it should only return <code>my_var</code>. Where is this <code>None</code> coming from and how do I fix my function?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is returning <code>None</code> because when you recursively call it:</p>
<pre><code>if my_var != "a" and my_var != "b":
    print('You didn\'t type "a" or "b". Try again.')
    get_input()
</code></pre>
<p>..you don't return the value.  </p>
<p>So while the recursion does happen, the return value gets discarded, and then you fall off the end of the function.  Falling off the end of the function means that python implicitly returns <code>None</code>, just like this:</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     pass
&gt;&gt;&gt; print(f(20))
None
</code></pre>
<p>So, instead of just <em>calling</em> <code>get_input()</code> in your <code>if</code> statement, you need to <code>return</code> it:</p>
<pre><code>if my_var != "a" and my_var != "b":
    print('You didn\'t type "a" or "b". Try again.')
    return get_input()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To return a value other than None, you need to use a return statement.</p>
<p>In your case, the if block only executes a return when executing one branch. Either move the return outside of the if/else block, or have returns in both options.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def get_input():
    my_var = input('Enter "a" or "b": ')

    if my_var != "a" and my_var != "b":
        print('You didn\'t type "a" or "b". Try again.')
        return get_input()
    else:
        return my_var

print('got input:', get_input())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think that you should use <em>while loops</em>.</p>
<pre><code>if my_var != "a" and my_var != "b":
    print('You didn\'t type "a" or "b". Try again.')
    get_input()
</code></pre>
<p>Consider that you type something different than "a" and "b", of course, it will call <code>get_input</code> but then it is skipping the next part. Which is:</p>
<pre><code>else:
    return my_var
</code></pre>
<p>And will go directly into:</p>
<pre><code>print('got input:', get_input())
</code></pre>
<p>So, if you use while loop as:</p>
<pre><code>while my_var!="a" and my_var!="b":
    print('You didn\'t type "a" or "b". Try again.')
    return get_input()
</code></pre>
<p>This way I think that you can handle it. </p>
</div>
<span class="comment-copy">You need to do <code>return Dat_Function()</code> when calling it recursively.</span>
<span class="comment-copy">Just a tip: The idiomatic way of that <code>my_var != "a" and my_var != "b"</code> condition would be <code>my_var not in ('a', 'b')</code></span>
<span class="comment-copy">Shouldn't it run through the if statement again if it is called recursively? I don't understand why it wouldn't return a value.</span>
<span class="comment-copy">Nope.  See my edit.  The recursion happens, and then you discard what the recursion returns.</span>
<span class="comment-copy">So if you call a function from inside that same function the return value gets discarded, but you return the same function in that function you really just call it in <code>main()</code>?</span>
<span class="comment-copy">You lost me with that <code>main()</code> bit...  You can fail as many times as you want to, the one that "succeeds" will return <code>my_var</code>, which will get passed down (<code>return</code>ed) through all of the recursive calls all the way down to the original caller.  Which, yes, is <code>main()</code>.</span>
<span class="comment-copy">I was thinking that when you <code>return Dat_Function()</code> you're really just calling <code>Dat_Function()</code> again in <code>main()</code>.  <code>Dat_Function()</code> now returns a function and <code>main()</code> has go call it.</span>
<span class="comment-copy">I've tried moving it out of the block, but to no avail.  Instead of returning the correct value, it returns the first incorrect value.  Also, I don't want a return statement for the if part of the if/else statement because I want the function to only return a correct value.</span>
<span class="comment-copy">A loop with a return inside it like that is completely pointless.</span>
