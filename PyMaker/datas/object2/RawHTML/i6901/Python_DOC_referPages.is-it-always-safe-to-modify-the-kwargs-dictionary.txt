<div class="post-text" itemprop="text">
<p>Using the Python function syntax <code>def f(**kwargs)</code>, in the function a keyword argument dictionary <code>kwargs</code> is created, and dictionaries are mutable, so the question is, if I modify the <code>kwargs</code> dictionary, is it possible that I might have some effect outside the scope of my function?</p>
<p>From my understanding of how dictionary unpacking and keyword argument packing works, I don't see any reason to believe it might be unsafe, and it seems to me that there is no danger of this in Python 3.6:</p>
<pre><code>def f(**kwargs):
    kwargs['demo'] = 9

if __name__ == '__main__':
    demo = 4
    f(demo=demo)
    print(demo)     # 4

    kwargs = {}
    f(**kwargs)
    print(kwargs)   # {}

    kwargs['demo'] = 4
    f(**kwargs)
    print(kwargs)    # {'demo': 4}
</code></pre>
<p>However, is this implementation-specific, or is it part of the Python spec? Am I overlooking any situation or implementation where (barring modifications to arguments which are <em>themselves</em> mutable, like <code>kwargs['somelist'].append(3)</code>) this sort of modification might be a problem?</p>
</div>
<div class="post-text" itemprop="text">
<p>It is always safe. As the <a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="noreferrer">spec says</a></p>
<blockquote>
<p>If the form “**identifier” is present, it is initialized to a <strong>new</strong>
  ordered mapping receiving any excess keyword arguments, defaulting to
  a <strong>new</strong> empty mapping of the same type.</p>
</blockquote>
<p><em>Emphasis added.</em></p>
<p>You are always guaranteed to get a new mapping-object inside the callable. See this example</p>
<pre><code>def f(**kwargs):
    print((id(kwargs), kwargs))

kwargs = {'foo': 'bar'}
print(id(kwargs))
# 140185018984344
f(**kwargs)
# (140185036822856, {'foo': 'bar'})
</code></pre>
<p>So, although <code>f</code> may modify an object that is passed via <code>**</code>, it can't modify the caller's <code>**</code>-object itself.</p>
<hr/>
<p><em>Update</em>: Since you asked about corner cases, here is a special hell for you that does in fact modify the caller's <code>kwargs</code>:</p>
<pre><code>def f(**kwargs):
    kwargs['recursive!']['recursive!'] = 'Look ma, recursive!'

kwargs = {}
kwargs['recursive!'] = kwargs
f(**kwargs)
assert kwargs['recursive!'] == 'Look ma, recursive!'
</code></pre>
<p>This you probably won't see in the wild, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python-level code, the <code>kwargs</code> dict inside a function will always be a new dict.</p>
<p>For <em>C extensions</em>, though, watch out. The C API version of <code>kwargs</code> will sometimes pass a dict through directly. In previous versions, it would even pass dict subclasses through directly, leading to the bug (<a href="http://bugs.python.org/issue18531" rel="noreferrer">now fixed</a>) where</p>
<pre><code>'{a}'.format(**collections.defaultdict(int))
</code></pre>
<p>would produce <code>'0'</code> instead of raising a <code>KeyError</code>.</p>
<p>If you ever have to write C extensions, possibly including Cython, don't try to modify the <code>kwargs</code> equivalent, and watch out for dict subclasses on old Python versions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Both of above answers are correct in stating that technically, mutating <code>kwargs</code> will never have an effect on the parent scopes.</p>
<p>But... <strong>that's not the end of the story</strong>.  It is possible for a <em>reference</em> to <code>kwargs</code> to be shared outside of the function scope, and then you run into all the usual shared mutated state problems that you'd expect.  </p>
<pre><code>def create_classes(**kwargs):

    class Class1:
        def __init__(self):
            self.options = kwargs

    class Class2:
        def __init__(self):
            self.options = kwargs

    return (Class1, Class2)

Class1, Class2 = create_classes(a=1, b=2)

a = Class1()
b = Class2()

a.options['c'] = 3

print(b.options)
# {'a': 1, 'b': 2, 'c': 3}
# other class's options are mutated because we forgot to copy kwargs
</code></pre>
<p>Technically this answers your question, since sharing a reference to <code>mutable</code> kwargs does lead to effects outside of the function scope's.</p>
<p>I've been bitten multiple times by this in production code, and it's something that I explicitly watch out for now, both in my own code and when reviewing others.  The mistake is obvious in my contrived example above, but it's much sneakier in real code when creating factory funcs that share some common options.</p>
</div>
<span class="comment-copy">To me, your tests are enough to prove that this is safe with your implementation. Is it enough though? I'm curious to see the answers.</span>
<span class="comment-copy">@Rightleg The question came up in the context of a FOSS library function which is intended to support many implementations and use cases. I'm fairly convinced that it's safe but I don't have any iron-clad reasoning that would say, "It's a bug if this is unsafe in some implementation."</span>
<span class="comment-copy">I'd say the corner case is a special case of "the arguments themselves being mutable", but it's clever nonetheless.</span>
<span class="comment-copy">@Paul - Indeed, no need for anything as exotic as a self-referential dictionary. If one of the input dictionary's elements is mutable (like a list) and that element is mutated inside the function (such as with <code>.append()</code>), then the input dictionary will be mutated.</span>
<span class="comment-copy">@JohnY Yes, I used that very example in my question ;)</span>
<span class="comment-copy">@Paul - Ah, so you did! There you go then. :) Besides being clever, the example in this answer showed me something I didn't realize before: That the keys in the input dictionary can have characters that are illegal in parameter names! "Look Ma, exclamation points! (And spaces, and whatever else!)"</span>
<span class="comment-copy">Define "safe". Will it blow up your computer? Probably not. Will arbitrary modifications cause your function to do what you intend? Probably not. You need to be just as careful as with any other modifications to arguments of functions - and perhaps moreso because this would be an easy point for bugs in your Python to slip in.</span>
<span class="comment-copy">Note: use <code>string.Formatter.vformat</code> if you really want this.</span>
<span class="comment-copy">@o11c: Or <code>str.format_map</code>.</span>
<span class="comment-copy">... huh. I guess things have changed since my old Python2 code needed this. Of course, I even needed to use the undocumented internals to change the recursion limit ...</span>
<span class="comment-copy">When is "sometimes" in this context? Is there a reference for this?</span>
<span class="comment-copy">@Paul: "Sometimes" for the following reasons: 1) As far as I'm aware, this is an undocumented implementation detail, and I don't know if some CPython versions behave differently, or if future versions might change the behavior. 2) The dict subclass fix means that some objects that are technically dicts (specifically, subclass instances) aren't passed through directly. 3) If you do something like <code>c_func(a=1, **{b:2})</code>, a new dict will be created.</span>
