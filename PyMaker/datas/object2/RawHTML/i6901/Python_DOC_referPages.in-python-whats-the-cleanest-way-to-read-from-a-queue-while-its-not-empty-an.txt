<div class="post-text" itemprop="text">
<p>I've just had a situation where a multi-threaded app I wrote was hanging at some point when it was interacting with a Queue, which was being populated by a library, in another thread.</p>
<p>In the simplest form, I was just doing</p>
<pre><code>while not q.empty():
    row = q.get()
    # do something with row
</code></pre>
<p>The reason I had that, and no more (specifically leaving out <code>task_done</code>) was that I wasn't that experienced with multi-threading, or <code>Queue</code>s in python, and that's what was in the sample code.</p>
<p>In my situation, at some point after hours of operation, the app would hang, sometimes at <code>q.empty()</code>, sometimes at <code>q.get()</code>, and sometimes after <code>q.get()</code>.</p>
<p>When I read about others who'd had similar issues, it was only then that I learned about <code>task_done</code>, and when I added that to my code, simply like,</p>
<pre><code>while not q.empty():
    row = q.get()
    # do something with row
    q.task_done()
</code></pre>
<p>These hangs I was experiencing ceased.  I do a few queueing operations like this throughout the app, and I want a standardised way to handle running through the q <code>while not q.empty()</code>, getting a row with <code>q.get()</code>, and calling <code>q.task_done()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The favourite method I've found for this, which I'm now using is a combination of a <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="nofollow noreferrer">context manager</a> to handle the <code>get</code> and <code>task_done</code> like,</p>
<pre><code>class read_from_q:
    def __init__(self, q, block=False, timeout=None):
        """
         :param Queue.Queue q:
         :param bool block:
         :param timeout:
        """
        self.q = q
        self.block = block
        self.timeout = timeout

    def __enter__(self):
        return self.q.get(self.block, self.timeout)

    def __exit__(self, _type, _value, _traceback):
        self.q.task_done()
</code></pre>
<p>in combination with a <a href="https://wiki.python.org/moin/Generators" rel="nofollow noreferrer">generator function</a> to handle the <code>not empty()</code> check, and <code>yield</code> the row back to you like,</p>
<pre><code>def queue_rows(q, block=False, timeout=None):
    """
     :param Queue.Queue q:
     :param bool block:
     :param int timeout:
    """
    while not q.empty():
        with read_from_q(q, block, timeout) as row:
            yield row
</code></pre>
<p>So now, instead of writing,</p>
<pre><code>while not q.empty():
    row = q.get()
    # do something with row
    q.task_done()
</code></pre>
<p>I use,</p>
<pre><code>for row in queue_rows(q):
    # do something with row and fogedaboutit
</code></pre>
<p>which I personally consider more elegant, and overall safer (because I won't forget about calling <code>task_done</code> as was the case before).</p>
</div>
<span class="comment-copy">Make sure you're using synchronized Queue.  get() will use the default (block=True, timeout=None) parameters, so it sounds like you may have a deadlock somewhere else.  <a href="https://docs.python.org/3/library/queue.html#queue.Queue.get" rel="nofollow noreferrer">docs.python.org/3/library/queue.html#queue.Queue.get</a></span>
<span class="comment-copy">And what should the corresponding put() be?  I don't have access to that, because it's in the library (although I could either request an update to there, or pass my own Queue subclass, and do what I want at put), but it's currently a simple q.put(data), and the Queue I've passed in was set to maxsize=0 (infinite), so I don't really know where the deadlock would have come from.</span>
