<div class="post-text" itemprop="text">
<p>So using the code i have when generating a number/letter string it generates an extra dash on the end and i want it to only consist of 16 digits numbers and letters (without the extra dash)</p>
<pre><code>import string, random

def generateCode():
    code = ''
    for i in xrange(16):
        number = random.choice(string.ascii_letters + string.digits)
        code += str(number)
        if (i - 3) % 4 == 0 and i - 4:
            code += '-'

    file = open('AlphaKeys.txt', 'w')
    file.write(code + '\n')
    file.close()
    return code

generateCode()
</code></pre>
<p>And an example of the output: qIss-wXbS-PZo7-audg-</p>
</div>
<div class="post-text" itemprop="text">
<p>The second condition in your <code>if</code> statement serves no meaningful purpose. You should just modify it so as to not add the <code>-</code> if you're at the last iteration:</p>
<pre><code>if (i - 3) % 4 == 0 and i &lt; 15:
    ...
</code></pre>
<p>Making this change gives me:</p>
<pre><code>LjIs-6HT5-zZMD-HMMz
</code></pre>
<hr/>
<p>Might I suggest an improvement over your current approach with <a href="https://docs.python.org/3/library/random.html#random.sample" rel="nofollow noreferrer"><code>random.sample</code></a>?</p>
<pre><code>import random

r = string.ascii_letters + string.digits
string =  '-'.join(''.join(random.sample(r, 4)) for _ in range(4))
print(string)

'fiqc-fvbc-z7s9-62w3'
</code></pre>
<p>Note that <code>random.sample</code> does not offer replacement per call, so if you want that, you'll need <code>random.choice</code>.</p>
<p>If you want randomness with replacement, you can substitute <code>random.sample</code> with <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices</code></a> - but only from python3.6 and onwards.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yet another alternative, with only one loop :</p>
<pre><code>import string,random
possible_chars = string.ascii_letters + string.digits
"".join(random.choice(possible_chars) if i % 5 &lt; 4 else '-' for i in range(19))
#=&gt; '4Mhg-flw1-lUEu-pu3h'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Of course, you're adding the dash even at the last iteration.</p>
<p>Anyway, the most pythonic way: just nest 2 <code>str.join</code> statements:</p>
<pre><code>import string,random

code = "-".join(["".join([random.choice(string.ascii_letters + string.digits) for _ in range(4)]) for _ in range(4)])

print(code)
</code></pre>
<p>an example:</p>
<pre><code>m7b1-A0vS-JARQ-hlo2
</code></pre>
<p>the inner comprension generates the 4 letter/digit sequence, and the outer one joins 4 of those sequences with <code>-</code>.</p>
<p>Note that the <code>join([..])</code> syntax may appear cumbersome, but is faster than without the square brackets (<a href="https://stackoverflow.com/questions/34822676/joining-strings-generator-or-list-comprehension">Joining strings. Generator or list comprehension?</a>)</p>
<p>EDIT: note that your digits/letters can repeat with <code>random.choice</code>. A better approach without repeats would be to use <code>random.choice</code> as follows:</p>
<pre><code>import string,random

it = iter(random.sample(string.ascii_letters + string.digits,16))

code = "".join(["-" if i % 5 == 4 else next(it) for i in range(19)])
</code></pre>
<p>the iterator is consumed except when it's time to issue a dash.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another way would be to add the code that adds the dash before adding the number. eg.</p>
<pre><code>if i and i % 4 == 0:
     code+= '-'
number = random.choice(string.ascii_letters + string.digits)
code += str(number)
</code></pre>
<p>which is a bit more readable than doing it after with </p>
<p><code>if (i - 3) % 4 == 0 and i &lt; 15: code+= '-'</code></p>
<p>but in general using join would be the more pythonic way eg.</p>
<pre><code>def code_part():
    return ''.join(random.choice(string.ascii_letters + string.digits) 
                   for i in xrange(4))
'-'.join(code_part() for i in xrange(4))
</code></pre>
</div>
<span class="comment-copy">OP, note the use of the second approach if you don't mind that groups are unique.</span>
<span class="comment-copy"><code>random.sample</code> is wrong in this case. It could be replaced by <code>random.choices</code>, but it requires Python 3.6</span>
<span class="comment-copy">@EricDuminil Not wrong, it depends on OP's needs... :) And thanks, I've edited that in.</span>
<span class="comment-copy">Since it's a key, it's probably best to have as many possible keys as possible.</span>
<span class="comment-copy">"<i>but is faster than without the square brackets.</i>" That's interesting...</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ edited with the reference</span>
<span class="comment-copy">That's interesting.. but if Ray says it, then it is truth.</span>
<span class="comment-copy">This also gets a bit more elegant in 3.6, eg: <code>'-'.join(random.choices(whatever, k=4) for _ in range(4))</code>...</span>
<span class="comment-copy">Also... another approach, but overkill here, is you could set up a template string with values to be filled - <code>replacement = {'X': lambda: random.choice(all_of_them), 'U': lambda L: random.choice(ascii_uppercase), 'L': lambda L: random.choice(ascii_lowercase); output = ''.join(replacement.get(ch, lambda L: ch)(ch) for ch in 'XXXU-LLUX-XLUU-XXXX')</code> - you get the idea...</span>
