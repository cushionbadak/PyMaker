<div class="post-text" itemprop="text">
<p>I need to get files with the biggest size in different folders, change their name to folder name that they belong to and save to a new folder. I have something like this and I got stuck:</p>
<pre><code>import os

# Core settings
rootdir = 'C:\\Users\\X\\Desktop\\humps'
to_save = 'C:\\Users\\X\\Desktop\\new'

for root, dirs, files in os.walk(rootdir):
        new_list = []
        for file in files:
            if file.endswith(".jpg"):
                try:
                    print(file)
                    os.chdir(to_save)
                    add_id = root.split("humps\\")[1]
                    add_id = add_id.split("\\")[0]
                    file_name = os.path.join(root,file)
                    new_list.append(file_name)
                    bigfile = max(new_list, key=lambda x: x.stat().st_size)


                except:
                    pass
</code></pre>
<p>To make it more clear: Let's say the name of the sub-folder is "elephant" and there are different elephant photos and subfolders in in this elephant folder. I want to go through those photos and subfolders and find the elephant foto with the biggest size, name it as elephant and save it to my target folder. Also repaet it for other sub folders such as lion, puma etc.
How I could achieve what I want ?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How to get the files with the biggest size in the folders, change their name and save to a different folder</p>
</blockquote>
<p>Basically you already have a good description of what you need to do. You just need to follow it step by step:</p>
<ol>
<li>get all files in some search directory</li>
<li>filter for relevant files ("*.jpg")</li>
<li>get their sizes</li>
<li>find the maximum</li>
<li>copy to new directory with name of search directory</li>
</ol>
<p>IMO it's an important skill to be able to break down a task into smaller tasks. Then, you just need to implement the smaller tasks and combine:</p>
<hr/>
<pre><code>def iterate_files_recursively(directory="."):
  for entry in os.scandir(directory):
    if entry.is_dir():
      for file in iterate_files_recursively(entry.path):
        yield file
    else:
      yield entry

files = iterate_files_recursively(subfolder_name)
</code></pre>
<p>I'd use <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow noreferrer"><code>os.scandir</code></a> because it avoids building up a (potentially) huge list of files in memory and instead allows me (via a generator) to work one file at a time. Note that starting with 3.6 you can use the result of <code>os.scandir</code> as a context manager (<code>with</code> syntax).</p>
<pre><code>images = itertools.filterfalse(lambda f: not f.path.endswith('.jpg'), files)
</code></pre>
<p>Filtering is relatively straightforward except for the IMO strange choice of <a href="https://docs.python.org/3/library/itertools.html#itertools.filterfalse" rel="nofollow noreferrer"><code>Ã¬tertools.filterfalse</code></a> to only keep elements for which its predicate returns <code>False</code>. </p>
<pre><code>biggest = max(images, key=(lambda img: img.stat().st_size))
</code></pre>
<p>This is two steps in one: Get the maximum with the builtin <a href="https://docs.python.org/3.5/library/functions.html#max" rel="nofollow noreferrer"><code>max</code></a> function, and use the file size as "key" to establish an order. Note that this raises a <code>ValueError</code> if you don't have any images ... so you might want to supply <code>default=None</code> or handle that exception.</p>
<pre><code>shutil.copy(biggest.path, os.path.join(target_directory, subfolder_name + '.jpg')
</code></pre>
<p><a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="nofollow noreferrer"><code>shutil.copy</code></a> copies the file and some metadata.  Instead of hardcoding path separators, please use <a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow noreferrer"><code>os.path.join</code></a>!</p>
<p>Now all of this assumes that you know the <code>subfolder_name</code>. You can scan for those easily, too:</p>
<pre><code>def iterate_directories(directory='.'):
  for entry in os.scandir(directory):
    if entry.is_dir():
      yield entry
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To find biggest file and save to another location</p>
<pre><code>import os
import shutil

f_list = []

root = "path/to/directory"
root = os.path.abspath(root) 

for folder, subfolders, files in os.walk(root):
    for file in files:

       filePath = os.path.join(folder, file)
       f_list.append(filePath)


bigest_file = max(f_list,key=os.path.getsize)
new_path = "path/where/you/want/to/save"
shutil.copy(biggest_file,new_path)
</code></pre>
<p>if you want only images then add one more condition in loop</p>
<pre><code>for folder, subfolders, files in os.walk(root):
    for file in files:
        if file.endswith(".jpg"):
            filePath = os.path.join(folder, file)
            f_list.append(filePath)
</code></pre>
<p>To get all folders biggest file</p>
<pre><code>root = "demo"
root = os.path.abspath(root) 

def test(path):
    big_files = []
    all_paths = [x[0] for x in os.walk(path)]

    for paths in all_paths:

        f_list = filter(os.path.isfile, os.listdir(paths))
        if len(f_list) &gt; 0:
            big_files.append((paths,max(f_list,key=os.path.getsize)))
    return big_files


print test(root)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's some code that does what you want. Instead of using the old <code>os.walk</code> function, it uses modern <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a> functions.</p>
<p>The heart of this code is the recursive <code>biggest</code> function. It scans all the files and directories in <code>folder</code>, saving the matching file names to the <code>files</code> list, and recursively searching any directories it finds. It then returns the path of the largest file that it finds, or <code>None</code> if no matching files are found.</p>
<pre><code>from pathlib import Path
import shutil

def filesize(path):
    return path.stat().st_size

def biggest(folder, pattern):
    ''' Find the biggest file in folder that matches pattern
        Search recursively in all subdirectories
    '''
    files = []
    for f in folder.iterdir():
        if f.is_file():
            if f.match(pattern):
                files.append(f)
        elif f.is_dir():
            found = biggest(f, pattern)
            if found:
                files.append(found)
    if files:
        return max(files, key=filesize)

def copy_biggest(src, dest, pattern):
    ''' Find the biggest file in each folder in src that matches pattern
        and copy it to dest, using the folder's name as the new file name
    '''
    for path in src.iterdir():
        if path.is_dir():
            found = biggest(path, pattern)
            if found:
                newname = dest / path
                print(path, ':', found, '-&gt;', newname)
                shutil.copyfile(found, newname)
</code></pre>
<p>You can call it like this:</p>
<pre><code>rootdir = r'C:\Users\X\Desktop\humps'
to_save = r'C:\Users\X\Desktop\new'
copy_biggest(Path(rootdir), Path(to_save), '*.jpg')
</code></pre>
<hr/>
<p>Note that the copied files will have the same name as the top-level folder in <code>rootdir</code> that they were found in, with no file extension. If you want to give them a <code>.jpg</code> extension, you can change</p>
<pre><code>newname = dest / path
</code></pre>
<p>to</p>
<pre><code>newname = (dest / path).with_suffix('.jpg')
</code></pre>
<hr/>
<p>The <code>shutil</code> module on older versions of Python 3 doesn't understand <code>pathlib</code> paths. But that's easy enough to remedy. In the <code>copy_biggest</code> function, replace</p>
<pre><code>shutil.copyfile(found, newname)
</code></pre>
<p>with</p>
<pre><code>shutil.copyfile(str(found), str(newname))
</code></pre>
</div>
<span class="comment-copy">So let's say there are different folders and each folder has many files. For those folders I want to get the files with the biggest size in terms of kbs</span>
<span class="comment-copy">What do you want to do if a folder has multiple files with the maximum size? Do you just need to scan for JPEG files that are in folders in rootdir, or can there be folders inside those folders that also need to be searched for JPEGs?</span>
<span class="comment-copy">Exactly, there might be some sub folders. To make it more clear: Let's say the name of the folder is "elephant" and there are different elephant photos and subfolders in in this elephant folder. I want to go through those photos and subfolders and find the elephant foto with the biggest size, name it as elephant and save it to my target folder</span>
<span class="comment-copy">You need to figure out how to categorize - how do you know that subfolders belong to the same <i>category</i> as <b>this</b> folder??  If you have prior knowledge of the directory tree, maybe you put all the <i>top</i> folders in a list then iterate over the list using each item as the root for os.walk.</span>
<span class="comment-copy">You should add that info to your question. And you still haven't said what you want the program to do if there are 2 or more files that have the biggest size. Do you want to choose one of them at random?</span>
<span class="comment-copy">thank you very much for awesome answer</span>
<span class="comment-copy">It throws this error: NameError: name 'img' is not defined</span>
<span class="comment-copy">@edyvedy13 I update my answer please check it</span>
<span class="comment-copy">I should take bigest_file into the loop? ValueError: max() arg is an empty sequence</span>
<span class="comment-copy">@edyvedy13 define root to your path in code <code>root = "path/to/directory</code>. you getting this error because your path is empty</span>
<span class="comment-copy">It just gets the copy  of the biggest file in the first folder</span>
<span class="comment-copy">It throws: TypeError: argument should be string, bytes or integer, not WindowsPath</span>
<span class="comment-copy">@edyvedy13 Sorry about that. It works fine on Python 3.6. But it's easy to fix so that it works on  Python 3.4 or 3.5. I'll edit my answer.</span>
