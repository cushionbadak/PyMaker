<div class="post-text" itemprop="text">
<p>Say I have a string list:</p>
<pre><code>li = ['a', 'b', 'c']
</code></pre>
<p>I would like to construct a new list such that each entry of the new list is a concatenation of a selection of 3 entries in the original list. Note that each entry can be chosen repeatedly:</p>
<pre><code>new_li=['abc', 'acb', 'bac', 'bca', 'cab', 'cba', 'aab', 'aac',....'aaa', 'bbb', 'ccc']
</code></pre>
<p>The brutal force way is to construct a 3-fold nested for loop and insert each 3-combination into the new list. I was wondering if there is any Pythonic way to deal with that? Thanks.</p>
<p>Update:
Later I will convert the new list into a set, so the order does not matter anyway.</p>
</div>
<div class="post-text" itemprop="text">
<p>This looks like a job for <code>itertools.product</code>.</p>
<pre><code>import itertools

def foo(l):
     yield from itertools.product(*([l] * 3)) 

for x in foo('abc'):
     print(''.join(x))

aaa
aab
aac
aba
abb
abc
aca
acb
acc
baa
bab
bac
bba
bbb
bbc
bca
bcb
bcc
caa
cab
cac
cba
cbb
cbc
cca
ccb
ccc
</code></pre>
<hr/>
<p><code>yield from</code> is available to you from python3.3 and beyond. For older version, <code>yield</code> within a loop:</p>
<pre><code>def foo(l):
     for i in itertools.product(*([l] * 3)) :
         yield i
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The best way to get all combinations (also called cartesian product) of a list is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product</code></a> using the <code>len</code> of your iterable as <code>repeat</code> argument (that's where it differs from the other answer):</p>
<pre><code>from itertools import product
li = ['a', 'b', 'c']
for comb in product(li, repeat=len(li)):
    print(''.join(comb))
</code></pre>
<p>or if you want the result as list:</p>
<pre><code>&gt;&gt;&gt; combs = [''.join(comb) for comb in product(li, repeat=len(li))]
&gt;&gt;&gt; combs
['aaa', 'aab', 'aac', 'aba', 'abb', 'abc', 'aca', 'acb', 'acc', 'baa', 
 'bab', 'bac', 'bba', 'bbb', 'bbc', 'bca', 'bcb', 'bcc', 'caa', 'cab', 
 'cac', 'cba', 'cbb', 'cbc', 'cca', 'ccb', 'ccc']
</code></pre>
<p>It's a bit cleaner to use the <code>repeat</code> argument than to multiply and unpack the list you have manually.</p>
</div>
<span class="comment-copy">Does it have to be random? How long should the list be?</span>
<span class="comment-copy">@whackamadoodle3000 Please see the updates. The length of the list should be 3^n, where n is the number of entries in the original list</span>
<span class="comment-copy">Thanks. What if each entry in the original list is not a single character, like li=['a1','b2','c3']?</span>
<span class="comment-copy">@James It works exactly the same way. You could just try it.</span>
