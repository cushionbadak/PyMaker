<div class="post-text" itemprop="text">
<p>I want to extend the list </p>
<pre><code>s = 0,1

def hi(x):
    global s
    for i in range(x):
        s = 0,s
    return s

print hi(5)
</code></pre>
<p>the result of this will be '(0, (0, (0, (0, (0, (0, 1))))))'</p>
<p>But what I really want is (0, 0, 0, 0, 0, 0, 1).
Do you have any idea doing it?</p>
</div>
<div class="post-text" itemprop="text">
<p>you could do: <code>s= (0,)+s</code> to create a new <code>tuple</code> with leading <code>0</code> (instead of nesting the tuple at each iteration like you're doing.</p>
<p>But maybe the best way would be to prepend with a tuple of zeroes using multiplication (to avoid the loop):</p>
<pre><code>s = (0,)*x + s
</code></pre>
<p>what bothers me even more is the need to use a <code>global</code>. I would pass <code>s</code> as a parameter:</p>
<pre><code>def hi(x,s):
    return (0,)*x + s

print(hi(5,(0,1)))
</code></pre>
<p>resulting in the following <code>tuple</code>:</p>
<pre><code>(0, 0, 0, 0, 0, 0, 1)
</code></pre>
<p>you may want to read about <code>list</code>s and <code>tuple</code>s and their differences: <a href="https://stackoverflow.com/questions/626759/whats-the-difference-between-lists-and-tuples">What's the difference between lists and tuples?</a>. It's much easier to work with lists because of the available in-place operations they offer (<em>but</em> they cannot be used as dictionary keys or to be stored in <code>set</code>s)</p>
</div>
<div class="post-text" itemprop="text">
<p><code>s = 0, 1</code> is not a <code>list</code> but a <code>tuple</code> which is immutable.</p>
<p>It would be better to use proper list <code>s = [0, 1]</code> and then use <a href="https://docs.python.org/3/tutorial/datastructures.html" rel="nofollow noreferrer"><code>insert()</code></a> method.</p>
<pre class="lang-python prettyprint-override"><code>def hi(x, s):
    for _ in range(x):
        s.insert(0, 0)
    return s
</code></pre>
<p>Or event better to avoid the for loop:</p>
<pre class="lang-python prettyprint-override"><code>def hi(x, s):
    return ([0] * x) + s
</code></pre>
<p>If you want to use a <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow noreferrer"><code>tuple</code></a>, then the answer from @Jean-Fran√ßois Fabre is the way to go.</p>
</div>
<div class="post-text" itemprop="text">
<p>Given your particular use case Jean's answer would be better. But if you want to make that nested tuple into a single dimensional tuple, the more canonical operation is called <code>flatten()</code>. <code>flatten()</code> takes an arbitrarily-nested sequence and 'flattens' it into sequence with no nesting. <code>flatten()</code> isn't included in the python standard libraries, but is an incredibly useful operation included in many other languages. I took this below implementation from <a href="https://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html" rel="nofollow noreferrer">here</a>, which includes other implementations and discusses their strengths and weaknesses.</p>
<pre><code>def flatten(l, ltypes=(list, tuple)):
    ltype = type(l)
    l = list(l)
    i = 0
    while i &lt; len(l):
        while isinstance(l[i], ltypes):
            if not l[i]:
                l.pop(i)
                i -= 1
                break
            else:
                l[i:i + 1] = l[i]
        i += 1
    return ltype(l)
</code></pre>
<p>The usage is simple:</p>
<pre><code>a = ((1, 2), (3,), (4, (5, 6)))
flatten(a)  # -&gt; (1, 2, 3, 4, 5, 6)

a = hi(6)   # -&gt; (0, (0, (0, (0, (0, (0, 1))))))
flatten(a)  # -&gt; (0, 0, 0, 0, 0, 0, 1)
</code></pre>
</div>
<span class="comment-copy">try: <code>s= (0,)+s</code> but that's not a list, but a <code>tuple</code>, and it's really inefficient to "insert" in a tuple.</span>
<span class="comment-copy">you're mentionning lists, but those are not lists, those are <code>tuple</code>s (immutable, vs mutable))</span>
<span class="comment-copy">Thanks! Problem is fixed:) I should understand more about the tuple..</span>
