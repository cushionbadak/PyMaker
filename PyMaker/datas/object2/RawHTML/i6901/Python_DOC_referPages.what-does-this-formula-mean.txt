<div class="post-text" itemprop="text">
<p><a href="https://i.stack.imgur.com/xy4dK.png" rel="nofollow noreferrer">The formula in the image is depicting quantization</a></p>
<p>I would like to know if anyone can help me understand what is going on in the above formula? Am I supposed to first perform x = [c/s1] and then perform s1 * x?</p>
<p>Please help me understand this.</p>
<p><a href="http://sharif.edu/~mbzadeh/Publications/PublicationFiles/NonOfficial_WhereOfficialIsPrivate/2016/ICEE2016_Azarian_JPEGghostDetection4ImageForensics_NonOfficialVersion.pdf" rel="nofollow noreferrer">The paper in question</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>In a nutshell, JPEG works by applying the <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform" rel="nofollow noreferrer">discrete cosine transform</a> to 8x8-pixel blocks of the image and then <a href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)" rel="nofollow noreferrer">quantizing</a> the resulting 8x8 matrix in order to compress it into fewer bits.</p>
<p>The quantization is what makes JPEG lossy. Different quantization matrices lead to different levels of compression (and decompressed image quality).</p>
<p>The formula in your question represents JPEG compression followed by decompression. The DCT yields an 8x8 matrix of float coefficients. Then:</p>
<ul>
<li>The DCT coefficient matrix is divided element-by-element by the quantization matrix.</li>
<li>The results get rounded to integer.</li>
<li>The integers are then multiplied back by the quantization coefficients. </li>
</ul>
<p>The point that the paper is getting at is that when this process is done more than once (potentially with different quantization coefficients), this is detectable and can be used to find doctored JPEG images.</p>
<p>P.S. It seems to me that the author's notation is a bit sloppy. If I am not mistaken, JPEG rounds to the nearest integer whereas the paper uses the floor function, which rounds towards negative infinity. That aside, the main point of the paper stands.</p>
</div>
<div class="post-text" itemprop="text">
<p>⌊⌋ is the floor operation. Any fractional part of the number is dropped, reducing it to the largest lesser or equal integer. In Python this is done via <a href="https://docs.python.org/3/library/math.html#math.floor" rel="nofollow noreferrer"><code>math.floor()</code></a> or any equivalent.</p>
</div>
<div class="post-text" itemprop="text">
<p>Okay so the formula can be represented as</p>
<pre><code>Quantized Value(i, j) = DCT(i, j)/Quantum(i, j)[Rounded-off to the nearest integer]
</code></pre>
<p>where <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform" rel="nofollow noreferrer">DCT</a> =  Discreet Cosine Transform Coefficient and</p>
<pre><code>For every element position in the DCT matrix, a corresponding value in the 
quantization matrix gives a **Quantum value** indicating what the step size is 
going to be for that element. 

and i, j are the row and column of the quantization matrix respectively.
</code></pre>
<p>Here is the sample matrix:
<a href="https://i.stack.imgur.com/PPwHJ.jpg" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/PPwHJ.jpg"/></a></p>
<p>Mentioned in <a href="http://etutorials.org/Programming/Python.+Text+processing/Appendix+B.+A+Data+Compression+Primer/B.2+Lossless+and+Lossy+Compression/" rel="nofollow noreferrer">here</a> the python way for <code>Lossy Data Compression</code> technique(<code>JPEG</code> for the instance). You can also read more about formula insights(Do refer this paper) in <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossy/jpeg/coeff.htm" rel="nofollow noreferrer"><strong>here</strong></a>. </p>
<p>Hope it helps...</p>
</div>
<div class="post-text" itemprop="text">
<p>Your source is a confusing one. Quantization is simply a highfaluting term for integer division.</p>
<p>You have an 8x8 quantization table (Q). When you quantize the 8x8 DCT matrix (M) into values (V) you do</p>
<p>V (n, m) = M (n, m) / Q (n, m)</p>
<p>JPEG does do INTEGER division where the values are rounded DOWN.</p>
<p>Note there is no multiplication afterward as shown in our example during the compression process. The paper is apparently suggesting a process to determining whether an image has been compressed multiple times.</p>
<p>If V(n, m) * Q (n, m) != M (n, m) it is likely the image has not been compressed before.</p>
</div>
<span class="comment-copy">I have another question, regarding the paper, I am hoping you could help me out. There is a step before the three step process begins, where image is horizontally and vertically shifted. How can I go about performing this step in python? I have not found a function which will horizontally shift rows and vertically shift columns. Is this step even important, can the ghost be detected even if the shifts are not performed?</span>
<span class="comment-copy">@SanketWagh: If it's a separate question, please post it as a new question. Comments are not well-suited for this sort of discussion.</span>
