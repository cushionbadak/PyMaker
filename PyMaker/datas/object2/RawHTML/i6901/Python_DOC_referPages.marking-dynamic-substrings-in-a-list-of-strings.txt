<div class="post-text" itemprop="text">
<p>Assume these two sets of strings:</p>
<pre><code>file=sheet-2016-12-08.xlsx
file=sheet-2016-11-21.xlsx
file=sheet-2016-11-12.xlsx
file=sheet-2016-11-08.xlsx
file=sheet-2016-10-22.xlsx
file=sheet-2016-09-29.xlsx
file=sheet-2016-09-05.xlsx
file=sheet-2016-09-04.xlsx

size=1024KB
size=22KB
size=980KB
size=15019KB
size=202KB
</code></pre>
<p>I need to run a function on both these sets separately and receive the following output respectively:</p>
<pre><code>file=sheet-2016-*.xlsx

size=*KB
</code></pre>
<p>The dataset can be any set of strings. It doesn't have to match the format. Here's another example for instance:</p>
<pre><code>id.4030.paid
id.1280.paid
id.88.paid
</code></pre>
<p>For which the expected output would be:</p>
<pre><code>id.*.paid
</code></pre>
<p>Basically, I need a function to analyze a set of strings and replace the uncommon substring with an asterisk(*)</p>
</div>
<div class="post-text" itemprop="text">
<p>you could use <code>os.path.commonprefix</code> to compute the common prefix. It is used to compute shared directories in a list of filepaths, but it can be used in a generic context.</p>
<p>Then reverse the strings, and apply common prefix again, then reverse, to compute common suffix (adapted from <a href="https://gist.github.com/willwest/ca5d050fdf15232a9e67" rel="nofollow noreferrer">https://gist.github.com/willwest/ca5d050fdf15232a9e67</a>)</p>
<pre><code>dataset = """id.4030.paid
id.1280.paid
id.88.paid""".splitlines()

import os


# Return the longest common suffix in a list of strings
def longest_common_suffix(list_of_strings):
    reversed_strings = [s[::-1] for s in list_of_strings]
    return os.path.commonprefix(reversed_strings)[::-1]

common_prefix = os.path.commonprefix(dataset)
common_suffix = longest_common_suffix(dataset)

print("{}*{}".format(common_prefix,common_suffix))
</code></pre>
<p>result:</p>
<pre><code>id.*.paid
</code></pre>
<p>EDIT: as wim noted:</p>
<ul>
<li>when all strings are equal, common prefixes &amp; suffixes are the same, but it should return the string itself instead of <code>prefix*suffix</code>: should check if all strings are the same</li>
<li>when common prefix &amp; suffixes overlap/have shared letters, this confuses the computation as well: should compute common suffix on the string minus the common prefix</li>
</ul>
<p>So a all-in-one method is required to test the list beforehand to make sure that at least 2 strings are different (condensing the prefix/suffix formula in the process), and compute common suffix with slicing to remove common prefix:</p>
<pre><code>def compute_generic_string(dataset):
    # edge case where all strings are the same
    if len(set(dataset))==1:
        return dataset[0]

    commonprefix = os.path.commonprefix(dataset)

    return "{}*{}".format(commonprefix,os.path.commonprefix([s[len(commonprefix):][::-1] for s in dataset])[::-1])
</code></pre>
<p>now let's test this:</p>
<pre><code>for dataset in [['id.4030.paid','id.1280.paid','id.88.paid'],['aBBc', 'aBc'],[]]:
    print(compute_generic_string(dataset))
</code></pre>
<p>result:</p>
<pre><code>id.*.paid
aB*c
*
</code></pre>
<p>(when dataset is empty, code returns <code>*</code>, maybe that should be another edge case)</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from os.path import commonprefix

def commonsuffix(m):
    return commonprefix([s[::-1] for s in m])[::-1]

def inverse_glob(strs):
    start = commonprefix(strs)
    n = len(start)
    ends = [s[n:] for s in strs]
    end = commonsuffix(ends)
    if start and not any(ends):
        return start
    else:
        return start + '*' + end
</code></pre>
<p>This problem is trickier than it seems at face value.</p>
<p>As currently specified, the question remains poorly constrained, i.e. there is not a unique solution.  For input <code>['spamAndEggs', 'spamAndHamAndEggs']</code>, both <code>spam*AndEggs</code> and <code>spamAnd*Eggs</code> are valid answers.  For input <code>['aXXXXz', 'aXXXz']</code> there are <em>four</em> possible solutions.  In the code given above, we prefer choosing the longest possible prefix in order to make the solution unique.</p>
<p>Credit to <a href="https://stackoverflow.com/a/45890218/674039">JFF's answer</a> for pointing out the existence of <a href="https://docs.python.org/3/library/os.path.html#os.path.commonprefix" rel="nofollow noreferrer"><code>os.path.commonprefix</code></a>. </p>
<p><a href="https://stackoverflow.com/q/43808808/674039">Inverse glob - reverse engineer a wildcard string from file names</a> is a related and more difficult generalisation of this question.</p>
</div>
<span class="comment-copy">Dang, <code>os.path.commonprefix</code>!  How long has that been around.</span>
<span class="comment-copy">upvote for commonprefix... no idea it existed.</span>
<span class="comment-copy">pretty nice one, plus one</span>
<span class="comment-copy">@wim nice catch. Tough to spot, easy to fix</span>
<span class="comment-copy">os.path.commonprefix is not very difficult to implement, but a bit tedious. So it's great that it's built-in.</span>
<span class="comment-copy">thanks for your comments &amp; help to make my solution better. Some may object that your solution is a copy of mine, but without your comments, I couldn't have achieved a working one.</span>
<span class="comment-copy">FWIW my <a href="https://stackoverflow.com/revisions/45890262/1">original solution</a> had same bug as yours.   Deleted it when I saw your implementation, that was better.</span>
<span class="comment-copy">we can say we beat that one together :)</span>
