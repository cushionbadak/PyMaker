<div class="post-text" itemprop="text">
<p>What I want to do is something like this:</p>
<pre><code>class MyThread(threading.Thread):
    def __init__(self, host, port):
        threading.Thread.__init__(self)
        # self._sock = self.initsocket(host, port)
        self._id = random.randint(0, 100)

    def run(self):
        for i in range(3):
            print("current id: {}".format(self._id))

def main():
    ts = []
    for i in range(5):
        t = MyThread("localhost", 3001)
        t.start()
        ts.append(t)

    for t in ts:
        t.join()
</code></pre>
<p>I got these output:</p>
<pre><code>current id: 10
current id: 10
current id: 13
current id: 43
current id: 13
current id: 10
current id: 83
current id: 83
current id: 83
current id: 13
current id: 98
current id: 43
current id: 98
current id: 43
current id: 98
</code></pre>
<p><strong>This output is what I want.</strong> As you can see, my <code>_id</code> is different in different threads, but in single thread, I share the same <code>_id</code>.(<strong><code>_id</code> is just one of these variables, I have many other similar variable</strong>).</p>
<p>Now, I want to do the same thing with <code>multiprocessing.pool.ThreadPool</code></p>
<pre><code>class MyProcessor():
    def __init__(self, host, port):
        # self._sock = self.initsocket(host, port)
        self._id = random.randint(0, 100)

    def __call__(self, i):
        print("current id: {}".format(self._id))
        return self._id * i

def main():
    with ThreadPool(5) as p:
        p.map(MyProcessor("localhost", 3001), range(15))
</code></pre>
<p>But now <code>_id</code> will be share by all threads:</p>
<pre><code>current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
current id: 58
</code></pre>
<p>And with <code>concurrent.futures.ThreadPoolExecutor</code>, I also try to do the same thing:</p>
<pre><code>class MyProcessor():
    def __init__(self, host, port):
        # self.initsocket(host, port)
        self._id = random.randint(0, 100)

    def __call__(self, i):
        print("current id: {}".format(self._id))
        return self._id * i

def main():
    with ThreadPoolExecutor(max_workers=5) as executor:
        func = MyProcessor("localhost", 3001)
        futures = [executor.submit(func, i) for i in range(15)]
        for f in as_completed(futures):
            pass
</code></pre>
<p>Output is this:</p>
<pre><code>current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
current id: 94
</code></pre>
<p>Of course, I get this result is not strange, <strong>because I just call <code>__init__</code> one time</strong>. But what I am asking is that:</p>
<p><strong>How can I do the same thing with <code>concurrent.futures.ThreadPoolExecutor</code> and <code>multiprocessing.pool.ThreadPool</code>(and also please with no more global variable).</strong></p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of issues going on here, and I will do my best to address all of them.</p>
<p>In the first example you give, you have full control over all the <code>Thread</code>s that you create, and so each thread gets a unique ID in the initializer. The problem there is of course that you start all the threads at once, which is probably very inefficient for a large number of threads.</p>
<p>In both of the thread pool examples in the question, you initialize the ID once for the callable object, so of course you don't have separate IDs per thread. The correct way to do it would be to initialize an ID per thread, by doing it in the <code>__call__</code> method:</p>
<pre>
class MyProcessor():
    def __init__(self, host, port):
        self.initsocket(host, port)

    def __call__(self, i):
        <b>id_</b> = random.randint(0, 100)
        print("current id: {}".format(<b>id_</b>))
        return <b>id_</b> * i

def main():
    func = MyProcessor("localhost", 3001)
    with ThreadPoolExecutor(max_workers=5) as executor:
        <b>collections.deque(executor.map(MyProcessor, range(15)), maxlen=0)</b>
</pre>
<p>Notice that you can shorten the <a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow noreferrer"><code>concurrent.futures.ThreadPoolExecutor</code></a> example by using the <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map" rel="nofollow noreferrer"><code>map</code></a> method there as well, if all you care about is the final result and not the intermediate <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="nofollow noreferrer"><code>Future</code></a> objects. The <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque(..., maxlen=0)</code></a> call is a standard idiom for consuming an iterator.</p>
<p>Given the gist you linked to in your comments, I understand why you want to have thread-local data. However, you certainly do not need a global variable to achieve that result. Here are a couple of alternatives:</p>
<ol>
<li><p>Just add your <a href="https://docs.python.org/3/library/threading.html#thread-local-data" rel="nofollow noreferrer">thread-local</a> data to <code>self</code> in the initializer, and voila, it is accessible to all calls without being global:</p>
<pre><code>def __init__(self, host, port):
    self.thread_local = threading.local()

def __call__(self, i):
    try:
        id_ = self.thread_local.id_
    except AttributeError:
        id_ = random.randint(0, 100)
    ...
</code></pre></li>
<li><p>Use function-local data instead of thread-local data. You are using thread-local data to avoid passing your connection (in the gist) to some private functions. That is not a real need, just an aesthetic choice. You can always have <code>def _send_data(self, conn, **kwargs)</code> and <code>def _recv_data(self, conn)</code>, since the only place a connection actually comes from is <code>__call__</code> anyway.</p></li>
</ol>
<p>While there may be situations where option #1 is a possibility, I <em>highly</em> recommend that you do <em>not</em> use it with any type of thread pool manager. A thread pool may reuse the same thread to run tasks sequentially from the queue that they are submitted to. This means that you will end up with the same connection in a task that should have opened its own. It would have been fine in your original example, where you create all your threads independently, but it may not be fine when you have multiple calls to <code>MyProcessor</code> on a recycled pool thread.</p>
</div>
<span class="comment-copy">Anything set in <code>__init__</code> is shared. Anything set in <code>__call__</code> is thread local. Set the port and other shared stuff  in <code>__init__</code>. Set the ID in <code>__call__</code>. Same as my answer to your other question.</span>
<span class="comment-copy">You just look at what thread a call belongs to and adjust based on that. <code>__init__</code> is main thread. <code>__call__</code> is run by individual task threads.</span>
<span class="comment-copy">I'll draft answer here and update the other one now that I understand what the confusion is once I get to my computer tonight.</span>
<span class="comment-copy">@MadPhysicist if I set id in <code>__call__ </code>, I will get different <code>id</code> every time, but  what I want is that <code>_id</code> in one thread is always the same.</span>
<span class="comment-copy">@MadPhysicist really thanks</span>
<span class="comment-copy">I've updated my answer to your other question as well. I think you are making things unnecessarily complicated with <code>local</code> object, but I've shown you a way to use it non-globally anyway.</span>
<span class="comment-copy">Yes, according to the <a href="https://github.com/uqfoundation/multiprocess/blob/master/py3.6/multiprocess/pool.py#L204" rel="nofollow noreferrer">source</a>, the socket may not be clean up, if the <code>thread</code> is cleaned up. Anyway, thanks</span>
<span class="comment-copy">All the more reason to make your sockets live in <code>__call__</code> and not in thread local storage.</span>
