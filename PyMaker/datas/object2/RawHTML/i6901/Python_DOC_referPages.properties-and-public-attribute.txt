<div class="post-text" itemprop="text">
<p>I'm following a tutorial on python 3 and there is a simple example I'm struggling with.</p>
<pre><code>class P:
    def __init__(self,x):
        self.x = x

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        if x &lt; 0:
            self.__x = 0
        elif x &gt; 1000:
            self.__x = 1000
        else:
            self.__x = x
</code></pre>
<p>Why is the attribute x in <code>__init__</code> defined as public but is accessed like a private attribute with <code>self.__x</code> in the functions decorated with <code>@property</code> and <code>@x.setter</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>This isn't that straightforward because it heavily relies on Pythons <a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors" rel="nofollow noreferrer">descriptor protocol</a> see also <a href="https://docs.python.org/howto/descriptor.html" rel="nofollow noreferrer">Descriptor HOW-TO which refers to <code>property</code> as well</a>. But I will try to explain it in easy terms.</p>
<p>You have a class that has (besides what is inherited by the implicit superclass <code>object</code> and some automatically included stuff) 2 attributes:</p>
<pre><code>&gt;&gt;&gt; P.__dict__
mappingproxy({'__init__': &lt;function __main__.P.__init__&gt;,
              'x': &lt;property at 0x2842664cbd8&gt;})
</code></pre>
<p>I removed the automatically added attributes for the sake of this discussion. You can always add or replace attributes as much as you want:</p>
<pre><code>&gt;&gt;&gt; P.y = 1000
&gt;&gt;&gt; P.__dict__
mappingproxy({'__init__': &lt;function __main__.P.__init__&gt;,
              'x': &lt;property at 0x2842664cbd8&gt;,
              'y': 1000})
</code></pre>
<p>But when you create an instance the instance will have only one attribute <code>_P__x</code> (the <code>_P</code> is inserted because variables starting with <code>__</code> and not ending in <code>__</code> are name-mangled):</p>
<pre><code>&gt;&gt;&gt; p = P(10)
&gt;&gt;&gt; p.__dict__
{'_P__x': 10}
</code></pre>
<p>You can also add almost (only almost because the descriptor protocol intercepts certain operations - see below) any attribute for the instance:</p>
<pre><code>&gt;&gt;&gt; p.y = 100
&gt;&gt;&gt; p.__dict__
{'_P__x': 10, 'z': 100}
</code></pre>
<p>That's where the descriptor protocol comes into play. If you access an attribute on the instance, it starts by looking if the instance has that attribute. If the instance doesn't have that attribute it will look at the class - but through the descriptor protocol! So when you access <code>self.x</code> this is roughly equivalent to: <code>type(self).x.__get__(self)</code>:</p>
<pre><code>&gt;&gt;&gt; p.x
10

&gt;&gt;&gt; type(p).x.__get__(p)
10
</code></pre>
<p>Likewise setting the attribute with <code>self.x = 200</code> will call <code>type(self).x.__set__(self, 200)</code>:</p>
<pre><code>&gt;&gt;&gt; p.x = 200
&gt;&gt;&gt; p.x
200
&gt;&gt;&gt; type(p).x.__set__(p, 100)
&gt;&gt;&gt; p.x
100
</code></pre>
<p>The <code>@property</code> will intercept though the descriptor protocol <strong>any</strong> access to <code>x</code> on <code>self</code>. So you can't use the name <code>x</code> to store the <em>actual</em> value on the instance because it would always go into the <code>@property</code> and <code>@x.setter</code> (and also <code>x.deleter</code> but you haven't implemented that one) functions of the class. So you have to use another name to store the variable.</p>
<p>It's typically stored with the same name but one leading underscore (also eases maintainability). It's actually not good practice to use two leading underscores because that makes it hard to subclass your class and modify the <code>x</code> property - without name-mangling the variable name yourself.</p>
</div>
<span class="comment-copy">The <code>x()</code> methods define what <code>.x</code> does, for instances of <code>P</code>. If they accessed <code>self.x</code>, they would be calling themselves.</span>
<span class="comment-copy">Thank you very much for the answer understandable even for begginers!</span>
<span class="comment-copy">Just to be sure that I got it right: the property object <code>x</code> of the class P redefine the descriptor protocol triggered by the syntax <code>.x</code> with <code>__get__</code> redirecting toward <code>x(self)' and </code>__set__` redirecting toward <code>x(self,x)</code>. The call to <code>self.x = x</code> in <code>__init__</code> is not the declaration of a public attribute <code>x</code> but a call to <code>x(self,x)</code> which then define the protected attribute <code>_x</code> of the instance storing the value. That's why <code>p.__dict__</code> contains <code>'_x' = 100</code> instead of <code>'x' = 100</code> and why <code>tpye(P.x) = &lt;class 'property'&gt;</code> and <code>type(p.x) = &lt;class 'int'&gt;</code>.</span>
<span class="comment-copy">Yes, that seems correct. However it's not like <code>@property</code> <i>actually redefines</i> the descriptor protocol. It's just that it makes the function that is decorated with <code>@property</code> a data-descriptor while normal methods are non-data-descriptors and something like <code>_x</code> is an instance variable (these have different precedence during lookup). But that's splitting hairs, your comment summarizes the process quite nicely :)</span>
