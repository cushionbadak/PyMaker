<div class="post-text" itemprop="text">
<p>I was trying to implement singleton classes for my project and an interesting post in StackOverflow on the same</p>
<p><a href="https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python">Creating a singleton in Python</a></p>
<p>I decided to go with the metaclasses approach mentioned..</p>
<p>Now.. I tried to add a method to get and clear the instances (in case the user wants to get rid of the current instance and create a new one..):</p>
<pre><code>class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

    def getInstance(cls):
        print("Class is {}".format(cls.__name__))

        if not cls in cls._instances:
            raise LookupError("No instance of the class {cls} create yet.".format(cls.__name__))

        return cls._instances[cls]

    def clearInstance(cls):
        cls._instances.pop(cls, None)


class someClass(metaclass=Singleton):
    def __init__(self,val):
        self.value = val
</code></pre>
<p>I am able to create objects successfully..</p>
<pre><code>In [9]: sc = someClass(1)

In [10]: sc.value
Out[10]: 1
</code></pre>
<p>But when I do <code>dir(someClass)</code> the 2 methods are not displayed:</p>
<pre class="lang-none prettyprint-override"><code>In [14]: dir(someClass)
Out[14]:
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']
</code></pre>
<p>Nevertheless I am able to call the methods..</p>
<pre class="lang-none prettyprint-override"><code>In [13]: someClass.getInstance()

Class is someClass

Out[13]: &lt;__main__.someClass at 0x7f728b180860&gt;
</code></pre>
<p>In all the examples on metaclass I see online I see <code>__new__</code>, <code>__init__</code> and <code>__call__</code> methods implemented but I don't see any additional methods added. Is it correct to add methods to the metaclass?</p>
<p>I also tried a small variation of the above metaclass code:</p>
<pre><code>class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

    @classmethod
    def getInstance(cls):
        print("Class is {}".format(cls.__name__))

        if not cls in cls._instances:
            raise LookupError("No instance of the class {cls} create yet.".format(cls.__name__))

        return cls._instances[cls]

    @classmethod
    def clearInstance(cls):
        cls._instances.pop(cls, None)
</code></pre>
<p>Marked the 2 methods as class method..</p>
<p>Now when I attempt to call them:</p>
<pre class="lang-none prettyprint-override"><code>In [2]: sc = someClass(1)

In [3]: someClass.getInstance()

Class is Singleton
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-3-c83fe01aa254&gt; in &lt;module&gt;()
----&gt; 1 someClass.getInstance()

&lt;ipython-input-1-9efb6548d92d&gt; in getInstance(cls)
     12
     13                 if not cls in cls._instances:
---&gt; 14                         raise LookupError("No instance of the class {cls} create yet.".format(cls.__name__))
     15
     16                 return cls._instances[cls]

KeyError: 'cls'
</code></pre>
<p>As you can see the <code>class is</code> print says its <code>Singleton</code> when I decorate it as <code>classmethod</code>. Otherwise it shows the correct class. I don't understand this behavior, can someone explain?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can python metaclasses have methods?</p>
</blockquote>
<p>Yes.</p>
<hr/>
<blockquote>
<p>But when I do dir(someClass) the 2 methods are not displayed</p>
</blockquote>
<p>Contrary to what you might have believed, <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer"><code>dir</code> doesn't show everything</a>:</p>
<blockquote>
<p>Because <code>dir()</code> is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, <strong>metaclass attributes are not in the result list when the argument is a class</strong>.</p>
</blockquote>
<hr/>
<blockquote>
<p>As you can see the class is print says its Singleton when I decorate it as classmethod.</p>
</blockquote>
<p>Don't decorate it with <code>classmethod</code>! That <em>specifically says</em> you want the method to operate on <code>Singleton</code> itself or subclasses of <code>Singleton</code>, rather than instances of <code>Singleton</code>. Classes with <code>Singleton</code> as their metaclass are <em>instances</em> of singleton; the fact that they are classes is not a reason to put <code>classmethod</code> on <code>Singleton</code>'s methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>Classes are instances of their metaclasses. Just as instances of classes don't have the methods of the class as attributes but nonetheless can have them called, classes do not have the methods of the metaclass as attributes.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Can python metaclasses have methods?</p>
</blockquote>
<p>Yes, as your first example shows they can have methods and they can be called on classes that implement your metaclass.</p>
<p>For example in python-3.x the metaclass <code>type</code> implements the <code>mro</code> attribute:</p>
<pre><code>&gt;&gt;&gt; object.mro()
[object]
</code></pre>
<p>But you can't access them on instances:</p>
<pre><code>&gt;&gt;&gt; object().mro()
AttributeError: 'object' object has no attribute 'mro'
</code></pre>
<blockquote>
<p>But when I do <code>dir(someClass)</code> the 2 methods are not displayed.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer"><code>dir</code></a> calls <code>type.__dir__</code> and that just shows a limited amount of the methods:</p>
<blockquote>
<blockquote>
<p>If the object is a type or class object, the list contains the names of its attributes, and recursively of the attributes of its bases.</p>
</blockquote>
</blockquote>
<p>No mention about methods of the metaclass here. That's because these are hidden by default.</p>
<p>That's why you don't see the <code>mro</code> method either:</p>
<pre><code>&gt;&gt;&gt; 'mro' in dir(object)
False
</code></pre>
<p>However <code>dir</code> allows to customize what you see, so you can simply override it. Because <code>__dir__</code> is called on the "class of the instance" and your "metaclass is the type of your class" you have to implement it on your metaclass:</p>
<pre><code>class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]
    def getInstance(cls):
        print("Class is {}".format(cls.__name__))
        if not cls in cls._instances:
            raise LookupError("No instance of the class {cls} create yet.".format(cls.__name__))
        return cls._instances[cls]
    def clearInstance(cls):
        cls._instances.pop(cls, None)

    def __dir__(self):
        normal_dir = type.__dir__(self)
        # Also include all methods that don't start with an underscore and
        # not "mro".
        normal_dir.extend([f for f in dir(type(self)) 
                           if not f.startswith('_') and f != 'mro'])
        return normal_dir

class someClass(metaclass=Singleton):
    def __init__(self,val):
        self.value = val

&gt;&gt;&gt; dir(someClass)
[..., 'clearInstance', 'getInstance']
</code></pre>
<p>Now these methods of your class are visible when you call <code>dir</code>.</p>
<blockquote>
<p>Is it correct to add methods to the metaclass?</p>
</blockquote>
<p>That depends a bit on the context. I would say it's fine to add the methods to the metaclass. However, these should be used rarely.</p>
<blockquote>
<p>As you can see the class is print says its Singleton when I decorate it as <code>classmethod</code>. Otherwise it shows the correct class. I don't understand this behavior, can someone explain?</p>
</blockquote>
<p>It's obvious if you think about it. <code>Singleton</code> is the class of your <code>someClass</code> and when you make it a <code>classmethod</code> the <code>cls</code> argument will be <code>Singleton</code>. However the class that has been added to the <code>_instances</code> is <code>someClass</code>. I can see where that comes from though. All your methods take a <code>cls</code> argument. That probably made you believe they are "like" classmethods (and they are in some way, but not of the metaclass but of the class that implements the metaclass!).</p>
<p>But it's just a convention because, like <code>self</code> is the typical argument name for an instance of a <code>class</code>, so is <code>cls</code> the typical argument name for an instance of a <code>metaclass</code>. When you have classmethods on your metaclass the first argument should probably be called <code>metacls</code>. Also fixing a small problem with the <code>str.format</code> (which is the reason it throws a <code>KeyError</code> instead of a <code>LookupError</code>):</p>
<pre><code>class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
            print(cls._instances)  # print the dict after creating an instance
        return cls._instances[cls]
    @classmethod
    def getInstance(metacls):
        print("Class is {}".format(metacls))
        if not metacls in metacls._instances:
            raise LookupError("No instance of the class {0} create yet.".format(metacls.__name__))
        return metacls._instances[metacls]
    @classmethod
    def clearInstance(metacls):
        metacls._instances.pop(metacls, None)

class someClass(metaclass=Singleton):
    def __init__(self,val):
        self.value = val

&gt;&gt;&gt; sc = someClass(1)
{&lt;class '__main__.someClass'&gt;: &lt;__main__.someClass object at 0x00000235844F8CF8&gt;}
&gt;&gt;&gt; someClass.getInstance()
Class is &lt;class '__main__.Singleton'&gt;
LookupError: No instance of the class Singleton create yet.
</code></pre>
<p>So you add the "class" to the dict but then you check if the metaclass is in the dict (which it isn't).</p>
<p>Generally custom <code>classmethods</code> (besides those that should/could be classmethods e.g. <code>__prepare__</code>) on a metaclass don't make much sense because you seldom need the type of the class of your instance.</p>
</div>
<span class="comment-copy">While I agree that they can have methods it was also asked "Is it correct to add methods to the metaclass?" - which is a bit harder to answer. I would be definitely interested in what your thoughts are on this point :)</span>
<span class="comment-copy">yes i am aware that instead of someClass i am getting the SingletonClass as the cls argument.. But i did not understand why i get the cls as SingletonClass once i decorate as class method..</span>
<span class="comment-copy">@ArunKalirajaBaskaran I edited the answer a bit to include more details. Let me know if anything is unclear. I have learned a lot by answering this question and because some aspects are also new to me it could be a bit "jumpy" in the text. :)</span>
