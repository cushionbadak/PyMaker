<div class="post-text" itemprop="text">
<p>I want to convert a string into a dictionary. I saved this dictionary previously in a text file. </p>
<p>The problem is now, that I am not sure, how the structure of the keys are. The values are generated with Counter(dictionaryName). The dictionary is really large, so I cannot check every key to see how it would be possible.</p>
<p>The keys can contain simple quotes like ', double quotes ", commas and maybe other characters. So is there any possibility to convert it back into a dictionary?</p>
<p>For example this is stored in the file:</p>
<pre><code>Counter({'element0':512, "'4,5'element1":50, '4:55foobar':23,...})
</code></pre>
<p>I found previous solutions with for example json, but I have problems with the double quotes and I cannot simply split for the commas.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you trust the source, load <code>from collections import Counter</code> and <code>eval()</code> the string</p>
</div>
<div class="post-text" itemprop="text">
<p>How about something like:</p>
<pre><code>&gt;&gt; from collections import Counter
&gt;&gt; line = '''Counter({'element0':512, "'4,5'element1":50, '4:55foobar':23})'''
&gt;&gt; D = eval(line)
&gt;&gt; D
 Counter({"'4,5'element1": 50, '4:55foobar': 23, 'element0': 512})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could remove the <code>Counter(</code> and <code>)</code> parts, then parse the rest with <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> as long as it only involves basic Python data types:</p>
<pre><code>import ast

def parse_Counter_string(s):
    s = s.strip()
    if not (s.startswith('Counter(') and s.endswith(')')):
        raise ValueError('String does not match expected format')
    # Counter( is 8 characters
    # 12345678
    s = s[8:-1]
    return Counter(ast.literal_eval(s))
</code></pre>
<p>In the future, I recommend picking a different way to serialize your data.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can use <code>demjson</code> library for doing this, you can have the text directly in your program</p>
<pre><code>import demjson

counter = demjson.decode("enter your text here")
</code></pre>
<p>if it is in the file ,you can do the following steps :</p>
<pre><code>WD = dirname(realpath(__file__))
file = open(WD, "filename"), "r")
counter = demjson.decode(file.read())
file.close()
</code></pre>
</div>
<span class="comment-copy">I do not understand what you are trying to accomplish, and indeed, what you are even working with exactly... What, <b>exactly</b> is stored in a file? How did you "save the dictionary"? Did you literally just write the string representation to a file?That would be your first mistake - you should have used one of the many available serialization formats.</span>
<span class="comment-copy">so you have the dictionary in text form ? and you want to convert it into dictionary?</span>
<span class="comment-copy">@Mohsen_Fatemi yes I stored it in a text file. It took a lot of hours to get the dictionary, so I wanted to save it in a file. But I didn't expect, that it would contain double quotes etc.</span>
<span class="comment-copy">Again, <b>that is your first problem</b>. You should have considered <i>beforehand</i> how you were going to serialize your data. Python has a <code>pickle</code> module that would have made this trivial. Just use <code>eval</code> and then <i>use <code>pickle</code></i> to properly serialize your object.</span>
<span class="comment-copy">If it is <i>your data</i> and you used something like <code>repr</code> to write that to the file, just use <code>eval</code> to reverse the process. As others have said, it is better to fix the problem in how the file was created as use <code>cPickle</code> to store the data.</span>
