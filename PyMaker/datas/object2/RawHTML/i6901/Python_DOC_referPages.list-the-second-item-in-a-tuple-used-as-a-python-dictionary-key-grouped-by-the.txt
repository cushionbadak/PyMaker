<div class="post-text" itemprop="text">
<p>I have a dict of tuples: (port , freq).</p>
<pre><code>d = {(0, 410): None, (1, 640): None, (2, 88): None, (2, 410): None, (0, 33): None}
</code></pre>
<p>I want to collect all tuples with the same port number, the frequencies for these are unique. I then want to list these frequencies.</p>
<p>If I can do this without having a value that would be great as it isn't needed, however port, freq must be unique and making them keys allowed me to achieve this.</p>
<p>I managed to list all the frequencies but this is not what I want.</p>
<pre><code>_, freq = zip (*list( d.keys() ))
</code></pre>
<p>Can someone show me an efficient pythonic way to do this please?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is exactly the kind of problem <a href="https://docs.python.org/3/library/collections.html#defaultdict-objects" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> was created for. </p>
<p>This is how you would create a <code>defaultdict</code> that creates a new <code>list</code> when a missing key is accessed:</p>
<pre><code>from collections import defaultdict as ddict

dd = ddict(list)
</code></pre>
<p>Now you can just populate your default dictionary with the second item from all your tuples:</p>
<pre><code>for port, freq in d:
    dd[port].append(freq)
</code></pre>
<p>Done. This works because each time a missing key with the value of <code>port</code> is accessed, a new <code>list</code> is created, and then you just append to that list. If the key is already there, you just append to the existing list. </p>
<p>Now you can access all the frequencies for any given port:</p>
<pre><code>print(dd[0])
</code></pre>
<p>Note: if your goal for your first data structure is to have a collection of unique tuples, instead of using a dictionary to hold your tuples I suggest using a <code>set</code> instead. A <code>set</code> is just that- a set of unique items, with no associated values to consider: </p>
<pre><code>&gt;&gt;&gt; s = {(0, 410), (1, 640), (2, 88), (2, 410), (0, 33)}
&gt;&gt;&gt; type(s).__name__
'set'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>zip</code>ing is not an inefficient way of doing what you need.<br/>
A simple list comprehension would be sufficient:</p>
<pre><code>freq = [x[1] for x in d]
</code></pre>
<p>Or:</p>
<pre><code>import operator as op
freq = list(map(op.itemgetter(1), d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the <code>None</code> valued dictionary seems awkward, a set works too</p>
<pre><code>d = {(0, 410), (1, 640), (2, 88), (2, 410), (0, 33)}
type(d)
Out[410]: set
</code></pre>
<p>itertools groupby is the tool if standard libs are allowed</p>
<pre><code>from itertools import groupby


grouped = [(k, *g) for k, g in groupby(sorted(list(d),
                                              key=lambda x: x[0]),
                                       key=lambda x: x[0])]
print(*grouped, sep='\n')
(0, (0, 410), (0, 33))
(1, (1, 640))
(2, (2, 88), (2, 410))
</code></pre>
<p>what I came up with for pulling apart the groupby structure seems ugly</p>
<pre><code>[(b[0], list(b[-1])) 
 for b in [(a[0], *zip(*a[1:])) 
           for a in grouped ]]
Out[399]: [(0, [410, 33]), (1, [640]), (2, [88, 410])] 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simple solution.</p>
<p>Let's make a dictionary where each key is the port and each value is a list of the frequencies, this allows you to sum them or operate on them as you like and gives you O(1) access to them!</p>
<pre><code>#first let's make a dict of all the keys with empty lists
my_dict = dict.fromkeys( [str(x[0]) for x in d.keys()], [])

#now let's append those frequencies!
[my_dict[str(soc)].append(freq) for soc, freq in d.keys()]
</code></pre>
<p>note that this doesnt give you a sorted structure, but you can save a sockets list and use it for the from_keys method and have a sorted way of accessing sockets. e.g.</p>
<pre><code>sockets = [str(x[0]) for x in d.keys()] #str() allows us to use an integer as a key, keep this in mind!
</code></pre>
<p>This however, makes it really easy to access all the different frequencies for a given socket, just like this:</p>
<pre><code>my_dict['socket']
</code></pre>
<p>Interpreter copy paste demo:</p>
<pre><code>&gt;&gt;&gt; d = {(0, 410): None, (1, 640): None, (2, 88): None, (2, 410): None, (0, 33): None}
&gt;&gt;&gt; my_dict = dict.fromkeys( [str(x[0]) for x in d.keys()], [])
&gt;&gt;&gt; [my_dict[str(soc)].append(freq) for soc, freq in d.keys()]
[None, None, None, None, None]
&gt;&gt;&gt; my_dict
{'0': [410, 640, 88, 410, 33], '1': [410, 640, 88, 410, 33], '2': [410, 640, 88, 410, 33]}
&gt;&gt;&gt;
</code></pre>
<p>Note that this converts form the current format that you have (or edit your post and ping me :D). You can adapt whatever code you may have to get similar results and have equivalent level of happiness to access things. Keeping a sorted list of the keys makes life really easy. Python3 is supposed to keep dictionaries sorted by default now so don't take my word on it but if you use my_dict.keys() it should return them in a sorted way but I could be wrong about how that operates.</p>
<h2><strong>TakeAway</strong></h2>
<p>A dict of socket-&gt; frequencies will be the easiest to deal with. An optional sorted list of sockets might help also</p>
</div>
<span class="comment-copy">A set of tuples, if you don't have values, perhaps?</span>
<span class="comment-copy">Great thanks. I've changed my dict to a set and it lists all freqs for the port.</span>
<span class="comment-copy">Thanks for the Set solution but an O2 (plus zip) to access the elements seem slow to me.</span>
<span class="comment-copy">Set isn't required, the code consumes your <code>None</code> valued dict just fine</span>
