<div class="post-text" itemprop="text">
<h2>Summary</h2>
<p>Sorting in Python is guaranteed to be stable since Python 2.2, as documented <a href="https://wiki.python.org/moin/HowTo/Sorting/#Sort_Stability_and_Complex_Sorts" rel="nofollow noreferrer">here</a> and <a href="https://stackoverflow.com/q/1915376/4594973">here</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" rel="nofollow noreferrer">Wikipedia</a> explains what the property of being stable means for the behavior of the algorithm:</p>
<blockquote>
<p>A sorting algorithm is stable if whenever there are two records R and S with the same key, and R appears before S in the original list, then R will always appear before S in the sorted list.</p>
</blockquote>
<p>However, when sorting objects, such as tuples, sorting <em>appears</em> to be unstable.</p>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; a = [(1, 3), (3, 2), (2, 4), (1, 2)]
&gt;&gt;&gt; sorted(a)
[(1, 2), (1, 3), (2, 4), (3, 2)]
</code></pre>
<p>However, to be considered stable, I <em>thought</em> the new sequence should've been</p>
<pre><code>[(1, 3), (1, 2), (2, 4), (3, 2)]
</code></pre>
<p>because, in the original sequence, the tuple <code>(1, 3)</code> appears before tuple <code>(1, 2)</code>. The <code>sorted</code> function is relying on the 2-ary "keys" when the 1-ary "keys" are equal. (To clarify, the 1-ary key of some tuple <code>t</code> would be <code>t[0]</code> and the 2-ary <code>t[1]</code>.)</p>
<p>To produce the expected result, we have to do the following:</p>
<pre><code>&gt;&gt;&gt; sorted(a, key=lambda t: t[0])
[(1, 3), (1, 2), (2, 4), (3, 2)]
</code></pre>
<p>I'm guessing there's a false assumption on my part, either about <code>sorted</code> or maybe on how tuple and/or list types are treated during comparison.</p>
<h2>Questions</h2>
<ol>
<li>Why is the <code>sorted</code> function said to be "stable" even though it alters the original sequence in this manner?</li>
<li>Wouldn't setting the default behavior to that of the <code>lambda</code> version be more consistent with what "stable" means? Why is it not set this way?</li>
<li>Is this behavior simply a side-effect of how tuples and/or lists are inherently compared (i.e. the false assumption)?</li>
</ol>
<p>Thanks.</p>
<hr/>
<p>Please note that this is <em>not</em> about whether the default behavior is or isn't useful, common, or something else. It's about whether the default behavior is <em>consistent</em> with the definition of what it means to be <em>stable</em> (which, IMHO, does not appear to be the case) and the guarantee of stability mentioned in the docs.</p>
</div>
<div class="post-text" itemprop="text">
<p>Think about it - <code>(1, 2)</code> comes before <code>(1, 3)</code>, does it not? Sorting a list by default does not automatically mean "just sort it based off the first element". Otherwise you could say that <code>apple</code> comes before <code>aardvark</code> in the alphabet. In other words, this has nothing to do with stability.</p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow noreferrer">The docs</a> also have a nice explanation about how data structures such as <code>list</code>s and <code>tuple</code>s are sorted lexicographically:</p>
<blockquote>
<p>In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Stable sort keeps the order of those elements which are considered equal from the sorting point of view. Because tuples are compared element by element lexicographically, <code>(1, 2)</code> precedes <code>(1, 3)</code>, so it should go first:</p>
<pre><code>&gt;&gt;&gt; (1, 2) &lt; (1, 3)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A tuple's key is made out of all of it's items.</p>
<pre><code>&gt;&gt;&gt; (1,2) &lt; (1,3)
True
</code></pre>
</div>
<span class="comment-copy">Again with the downvoters that don't even bother to provide an explanation. In what way does this question "not show any research effort, is unclear, or not useful"?... Those votes came before any reasonable amount of time needed to actually <i>read</i> the question had gone by... smh</span>
<span class="comment-copy">I guess the downvoter consider it a lack of research that you only <i>assume</i> how tuples should be sorted.</span>
<span class="comment-copy">@GhostCat While I can see that part of your feedback, I think it's unreasonable for anyone to assume that missing <i>one</i> detail negates the rest of the research that <i>did</i> go into it. In any case, I digress.</span>
<span class="comment-copy">I didn't downvote, so I can only speculate. And honestly: I <i>rarely</i> see that questioners agree to downvotes. So that piece of information isn't exactly newsworthy. And just for the record: you focused your research on the <i>stable</i> part. You then assumed that <b>your</b> idea how tuples should be sorted is correct. Maybe some folks simply understand how well designed and "perfect" the python sort implementation is. So instead of asking "woha, why is python sort not stable" ... a title like "where is the flaw in my logic" would have resulted in less downvotes. But whatever. Nice question.</span>
<span class="comment-copy"><code>["the docs" is] a</code> <i>lot</i> <code>to read</code> moreover, the bit about how <i>sequences of the same type compare</i> is <i>not</i> linked or repeated near the <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer">claim to stability</a>.</span>
<span class="comment-copy">I must've missed that in the docs; it's a long document. I understand the string comparison example (i.e. char lists), but hadn't extrapolated the behavior to tuples when thinking about the other non-string types (i.e. the iterable itself being compared lexicographically, not just the characters in a string).</span>
