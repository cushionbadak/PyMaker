<div class="post-text" itemprop="text">
<p>Consider if you will, a world where you have a default nmap XML output.</p>
<p>I am specifically trying to parse out the IP Address (no problem here), and OS Vendor (here is the problem).</p>
<p>The issue is because the xml tag has several instances, as well as attributes and I can't figure out how to use the untangle syntax to pull and attribute from a tag that also needs indices.</p>
<p>The xml looks like this:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet href="file:///usr/bin/../share/nmap/nmap.xsl" type="text/xsl"?&gt;
&lt;!-- Nmap 7.40 scan initiated Tue Aug 29 12:45:56 2017 as: nmap -sV -O -oX ./nmap_results.xml 1.2.3.4/24 --&gt;
&lt;nmaprun attributes=""&gt;
    &lt;scaninfo attributes="" /&gt;
    &lt;debugging attributes="" /&gt;
    &lt;host attributes=""&gt;
        &lt;status attributes="" /&gt;
        &lt;address attributes="" /&gt;
        &lt;hostnames&gt;
            &lt;hostname attributes="" /&gt;
        &lt;/hostnames&gt;
        &lt;ports&gt;
            &lt;extraports attributes=""&gt;
                &lt;extrareasons attributes="" /&gt;
            &lt;/extraports&gt;
            &lt;port attributes=""&gt;
                &lt;state attributes="" /&gt;
                &lt;service attributes="" /&gt;
            &lt;/port&gt;
            &lt;port attributes=""&gt;
                &lt;state attributes="" /&gt;
                &lt;service attributes=""&gt;
                    &lt;cpe&gt;stuff&lt;/cpe&gt;
                    &lt;cpe&gt;more stuff&lt;/cpe&gt;
                &lt;/service&gt;
            &lt;/port&gt;
            ...
</code></pre>
<p>Lets just assume that I want to pull the attributes from the first instance of port.</p>
<p>In my python, I would assume it would look something like this:</p>
<pre><code>#!/bin/env python
import untangle

nmap = untangle.parse('./location/to/results.xml')

alive = int(nmap.nmaprun.runstats.hosts['up'])

count = range(0,alive,1)
for tick in count:
    print(nmap.nmaprun.host[tick].ports.port[0, 'attribute'])
</code></pre>
<p>The problem here, is that instance of port[0, 'attribute']) because it wants and needs that 0 index, but there are also attributes that I want to pull. </p>
<p>Here is the python error:</p>
<pre><code>/usr/bin/python2.7 /path/to/my/dot.py
Traceback (most recent call last):
  File "/path/to/my/dot.py", line 10, in &lt;module&gt;
    print(nmap.nmaprun.host[tick].ports.port[0, 'vendor'])
TypeError: list indices must be integers, not tuple

Process finished with exit code 1
</code></pre>
<p>If I try to just use the attribute name, without the index, I get this:</p>
<pre><code>/usr/bin/python2.7 /path/to/my/dot.py
Traceback (most recent call last):
  File "/path/to/my/dot.py", line 10, in &lt;module&gt;
    print(nmap.nmaprun.host[tick].ports.port['vendor'])
TypeError: list indices must be integers, not str

Process finished with exit code 1
</code></pre>
<p>And if I provide just the index, I get a string with all of the attributes, but I only need to one.</p>
<p>What am I doing wrong or is there a way?</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of blindly guessing, I've downloaded the module (it's a single <em>.py</em> file) and started to play with it. What I've learned:</p>
<ol>
<li>The <em>xml</em> tree is indeed converted into a tree like structure of <em>Python</em> objects (<code>untangle.Element</code>), based on <em>xml</em> node tags (which will become object attributes)</li>
<li><code>Element</code> supports indexing (<a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer">[Python]: object.__getitem__(self, key)</a>) and returns an <em>xml</em> node attribute with the name matching the given key</li>
<li>When an <em>xml</em> node has several nodes with the same tag, the corresponding converted object will be <strong>a list</strong> of <code>Element</code> objects</li>
<li><code>Element</code> <strong>supports iteration</strong> (<a href="https://docs.python.org/3/reference/datamodel.html#object.__iter__" rel="nofollow noreferrer">[Python]: object.__iter__(self)</a>) and it yields itself when iterated over</li>
</ol>
<p>From bullets 3. and 4. results that it' best to always iterate over an element which can appear <strong>once or more</strong> <sup><strong>Side note *</strong></sup>.</p>
<p>Here's some code that demonstrates that:</p>
<pre><code>#!/bin/env python

import untangle

FILE_NAME = "a.xml" # "./location/to/results.xml" # You should change the name back to match your location


def main():
    nmap = untangle.parse(FILE_NAME)
    up_host_count = int(nmap.nmaprun.runstats.hosts['up'])
    host_iterator = nmap.nmaprun.host
    for host in host_iterator:
        print("IP Address: {}".format(host.address["addr"]))

        vendors = set()
        osmatch_iterator = host.os.osmatch
        for osmatch in osmatch_iterator:
            osclass_iterator = osmatch.osclass
            for osclass in osclass_iterator:
                vendor = osclass["vendor"]
                if vendor is not None:
                    vendors.add(vendor)
        print("    OS Vendors: {}".format(vendors))

        port_iterator = host.ports.port
        for port in port_iterator:
            print("    Port number: {}".format(port["portid"]))


if __name__ == "__main__":
    main()
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Every <code>for</code> loop in the code is an example of iteration (that I talked above), and I got it from the provided <em>xml</em> sample (the complete version), looking where are there more than one node with the same tag</li>
<li>Of course there's the alternative to iteration of always checking the type of an object, but that's neither nice nor scalable</li>
<li>The port handling was not required in the question, but I placed it there since there was an example that didn't work involving the ports</li>
<li>Since the <em>nmap</em> scan can identify more than one <em>OS</em> (<strong>does</strong> happen in our case) that come from different vendors (<strong>doesn't</strong> happen in our case) which can happen especially between <em>Ux</em>(<em>Unix</em>) flavors, I added some logic for the <em>OS</em> vendor part to only display it once (you can manually modify the <em>xml</em> file, and specify a vendor other than <em>Linux</em> for one of the <code>osclass</code> nodes and see that it appears in the output)</li>
<li>Code runs with <em>Python3</em> and <em>Python2</em></li>
</ul>
<p><strong>Output</strong>:</p>
<blockquote>
<pre><code>E:\Work\Dev\StackOverflow\q45946779&gt;python b.py
IP Address: 127.0.0.1
    OS Vendors: set([u'Linux'])
    Port number: 22
    Port number: 111
    Port number: 631
    Port number: 2222
    Port number: 8081
    Port number: 30000
</code></pre>
</blockquote>
<p><strong>Side note *</strong>: I talked about an element that can appear once or more, but this approach (I'm talking about the <code>untangle</code> module approach) is not very error proof if the <em>xml</em> is incomplete. Take the following line of code (which is no longer used, but I kept it there only to make a point):</p>
<pre><code>up_host_count = int(nmap.nmaprun.runstats.hosts['up'])
</code></pre>
<p>If any of the nodes <code>nmaprun</code>, <code>runstats</code>, <code>hosts</code> is missing from the <em>xml</em>, the line will spit <em>AttributeError</em>. The same line, but with error proofing would look like:</p>
<pre><code>up_host_count = int(getattr(getattr(getattr(nmap, "nmaprun", None), "runstats", None), "hosts", None)["up"] or 0)
</code></pre>
<p>but that's ugly, and it gets even messier when advancing the <em>xml</em> tree depth.</p>
</div>
<span class="comment-copy">Can you post a complete XML file? Posting a snippet makes it difficult to test.</span>
<span class="comment-copy">What's the type of <code>nmap.nmaprun.host[tick].ports.port[0]</code>?</span>
<span class="comment-copy">I've uploaded a full xml here (<a href="https://pastebin.com/EgguG1Ss" rel="nofollow noreferrer">pastebin.com/EgguG1Ss</a>)</span>
<span class="comment-copy">Python says: <code>&lt;class 'untangle.Element'&gt; None &lt;type 'NoneType'&gt;</code></span>
<span class="comment-copy">Are you restricted to use <i>untangle</i> module for parsing the <i>xml</i>? P.S. What if you'd use smth like: <code>print(nmap.nmaprun.host[tick].ports.port[0]['portid']</code> ?</span>
<span class="comment-copy">That seems to get me exactly what I need using the tools that I have. Thank you very much.</span>
<span class="comment-copy">That being said, you mentioned that it's not very error-proof, what would you use to parse XMLs rather than this?  I've looked into etree and things like that, but I am just so very green when it comes to XML parsing in python. It seemed like more of a hassle than it was worth at the time.</span>
<span class="comment-copy">I worked previously with <code>xml.etree</code> (I'm not saying it's the best but I'm comfortable with it) and also with <code>xml.dom</code>. Here are some examples: <a href="https://stackoverflow.com/questions/45799991/python-get-xml-siblings-into-dictionary">[SO]: Python get XML siblings into dictionary</a>, <a href="https://stackoverflow.com/questions/45049761/python-read-xml-with-related-child-elements">[SO]: Python read xml with related child elements</a>, <a href="https://stackoverflow.com/questions/44622347/convert-xml-into-lists-of-tags-and-values-with-python">[SO]: Convert XML into Lists of Tags and Values with Python</a>.</span>
