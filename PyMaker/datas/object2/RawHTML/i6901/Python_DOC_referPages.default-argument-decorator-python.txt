<div class="post-text" itemprop="text">
<p>Python 3.6</p>
<p>I'm attempting to create a decorator that automatically assigns the string of the argument as the default value. </p>
<p>such as:</p>
<pre><code>def example(one='one', two='two', three='three'):
    pass
</code></pre>
<p>would be equivalent to:</p>
<pre><code>@DefaultArguments
def example(one, two, three):
    pass
</code></pre>
<p>Here is my attempt (doesn't work.. yet..) <code>DefaultArguments</code>:</p>
<pre><code>from inspect import Parameter, Signature, signature


class DefaultArguments(object):

    @staticmethod
    def default_signature(signature):
        def default(param):
            if param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.POSITIONAL_ONLY):
                return param.replace(default=param.name)
            else:
                return param
        return Signature([default(param) for param in signature.parameters.values()])

    def __init__(self, func):
        self.func = func
        self.sig = self.default_signature(signature(func))

    def __call__(self, *args, **kwargs):
        arguments = self.sig.bind(*args, **kwargs)
        return self.func(arguments)
</code></pre>
<p>The staticmethod <code>default_signature</code> creates the desired signature for the function, but I'm having difficulty assigning the new signature to the function. I'm trying to use Signature.<code>bind</code> I've read the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">docs</a> but i'm missing something.</p>
<p><strong>EDIT</strong> </p>
<p>Incorporating Ashwini Chaudhary's answer:</p>
<pre><code>from inspect import Parameter, Signature, signature

class DefaultArguments(object):

    @staticmethod
    def default_signature(signature):
        def default(param):
            if param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.POSITIONAL_ONLY):
                return param.replace(default=param.name)
            else:
                return param
        return Signature([default(param) for param in signature.parameters.values()])

    def __init__(self, func):
        self.func = func
        self.sig = self.default_signature(signature(func))
        print(self.sig)

    def __call__(self, *args, **kwargs):
        ba = self.sig.bind(*args, **kwargs)
        ba.apply_defaults()
        return self.func(*ba.args, **ba.kwargs)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After binding the args and keywords with the signature you need to call <a href="https://docs.python.org/3/library/inspect.html#inspect.BoundArguments.apply_defaults" rel="nofollow noreferrer"><code>apply_defaults</code></a> on the <a href="https://docs.python.org/3/library/inspect.html#inspect.BoundArguments" rel="nofollow noreferrer"><code>BoundArguments</code></a> instance to set the default values for missing arguments.</p>
<p>Also the function call will be invoked using <code>BoundArguments</code>'s <code>args</code> and <code>kwargs</code> properties.</p>
<pre><code>def __call__(self, *args, **kwargs):
    ba = self.sig.bind(*args, **kwargs)
    ba.apply_defaults()
    return self.func(*ba.args, **ba.kwargs)
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; @DefaultArguments
... def example(one, two, three):
...         print(one, two, three)
...

&gt;&gt;&gt; example()
one two three
&gt;&gt;&gt; example('spam')
spam two three
&gt;&gt;&gt; example(one='spam', three='eggs')
spam two eggs
</code></pre>
<hr/>
<p>A functional version of your code that also updates the signature of the decorated function:</p>
<pre><code>from functools import wraps
from inspect import Parameter, Signature, signature


def default_arguments(func):

    def default(param):
        if param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.POSITIONAL_ONLY):
            param = param.replace(default=param.name)
        return param

    sig = Signature([default(param) for param in signature(func).parameters.values()])

    @wraps(func)
    def wrapper(*args, **kwargs):
        ba = sig.bind(*args, **kwargs)
        ba.apply_defaults()
        return func(*ba.args, **ba.kwargs)

    wrapper.__signature__ = sig
    return wrapper
</code></pre>
<p><strong>Demo:</strong></p>
<pre><code>&gt;&gt;&gt; from inspect import getfullargspec    
&gt;&gt;&gt; @default_arguments
... def example(one, two, three):
...         print(one, two, three)
...

&gt;&gt;&gt; getfullargspec(example)
FullArgSpec(
    args=['one', 'two', 'three'],
    varargs=None,
    varkw=None,
    defaults=('one', 'two', 'three'),
    kwonlyargs=[], kwonlydefaults=None, annotations={}
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This seems to work:</p>
<pre><code>import inspect

def default_args(func):
    argspec = inspect.getfullargspec(func)

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        unpassed_positional_args = argspec.args[len(args):]
        kwargs.update((a, a) for a in unpassed_positional_args if a not in kwargs)
        return func(*args, **kwargs)

    return wrapper
</code></pre>
<p>It relies on the fact that you can pass positional arguments by keyword in python.  e.g. if you have a function:</p>
<pre><code>def foo(a, b):
    ...
</code></pre>
<p>You're completely in your rights to call it as:</p>
<pre><code>foo(b=1, a=2)
</code></pre>
<p>My solution figures out how many positional arguments you've passed and uses that to figure out which positional arguments <em>weren't</em> passed.  I then add those positional argument names to the <code>kwargs</code> dict instead.</p>
<p>And the cool thing here is that if someone needs this for python2.x, they only need to change <code>getfullargspec</code> to <code>getargspec</code> and it should work OK.</p>
<hr/>
<h2>A note on speed:</h2>
<p>Comparing my solution with Ashwini's excellent explanation shows that the simple decorator is approximately 10x faster than messing around with Signature objects:</p>
<pre><code>@default_args
def foo(a, b, c):
    pass

@DefaultArguments
def bar(a, b, c):
    pass

@default_arguments
def qux(a, b, c):
    pass

import timeit
print(timeit.timeit('foo()', 'from __main__ import foo'))  # 1.72s
print(timeit.timeit('bar()', 'from __main__ import bar'))  # 17.4s
print(timeit.timeit('qux()', 'from __main__ import qux'))  # 17.6
</code></pre>
<p>His solution actually updates the <code>__signature__</code> of the function (which is really nice).  In principle, you could take the <code>Signature</code> creation logic and add that to my solution to update the <code>__signature__</code> but keep the <code>argspec</code> style logic for the actual computation...</p>
</div>
<span class="comment-copy">Have you tried replacing the <code>__defaults__</code> attribute?</span>
<span class="comment-copy">Admittedly no, I guess  I was hoping to avoid doing it manually, and let the Signature class handle it</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/inspect.html#inspect.Signature" rel="nofollow noreferrer">"Signature objects are <i>immutable</i>."</a></span>
<span class="comment-copy">Thanks for the functional version. That's cool, I will use that.</span>
<span class="comment-copy">That's amazing! Just give me a moment to get my head around it...</span>
<span class="comment-copy">Really cool :) thanks, Its a cleaner solution than my code.</span>
<span class="comment-copy">@JamesSchinner -- There was a small bug that Ashwini's test cases alerted me to -- Basically I needed to make sure that I didn't add defaults if they were already present in <code>kwargs</code>.</span>
<span class="comment-copy">This is super clean. If I wasn't emotionally invested in my code. I'd use this. I selected Ashwini's because it explained what was wrong with my previous understanding.</span>
<span class="comment-copy">Yeah -- I have no problem with that.  In fact, I agree with your giving him the checkmark -- His is a great answer to your question.  In a lot of ways, it's better than mine because it explains more about the API that you were asking about.   (and I think that this is a good demonstration why StackOverflow allows <i>multiple</i> answers :-).</span>
