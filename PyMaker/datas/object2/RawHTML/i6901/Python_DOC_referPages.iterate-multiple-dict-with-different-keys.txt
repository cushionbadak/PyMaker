<div class="post-text" itemprop="text">
<p><strong>The goal</strong></p>
<p>I am trying to iterate two <code>dict</code>s at the same time knowing that they have some keys in common (for sure), but some of them are not (possibly). What is more the same keys could (rarely, but still) be ordered differently. Another issue is that <code>dict</code>s can have different lenght. In my case the keys are all numerical.</p>
<p><strong>Atempted solutions</strong></p>
<p>Example <code>dict</code>s:</p>
<pre><code>di1 = {1: "a", 2: "b", 3: "c", 5:"e"}
di2 = {1: "a", 2: "b", 4: "d", 5:"e", 6:"f"}
</code></pre>
<p>After reading some answers to iterating multiple <code>dict</code>s I tried <code>zip()</code>ing the two <code>dict</code>s:</p>
<pre><code>for i, j in zip( di1, di2 ): print( i, j )
1 1
2 2
3 4
5 5
</code></pre>
<p>but this 'cuts' the longer <code>dict</code>, also this iterates over keys of each <code>dict</code> seperately instead of keeping them consistent (always <code>i == j</code>, even if <code>i in di1 and j in di2</code> would return <code>False</code>)</p>
<p>Given that in my case all keys are numerical I tried the following:</p>
<pre><code>for i in range(max(max(di1), max(di2))+1): print(i)
0
1
2
3
4
5
6
</code></pre>
<p>which works (I can pass <code>i</code> as <code>dict</code> key), but:</p>
<ol>
<li>Doesn't iterate <code>dict</code>s per se, just generates numbers to try to match to given <code>dict</code>s.</li>
<li>Iterates over values even if they are non existent keys in both <code>dict</code>s (<code>i in di1 or i in di2</code> is <code>False</code>).</li>
<li>This works only if keys are numerical.</li>
<li>Doesn't seem very pythonic.</li>
</ol>
<p><strong>The quesstion</strong></p>
<p>How do I iterate two (or more) <code>dict</code>s (keys) given that it is enough for the key to exist in at least one of them?</p>
<p><strong>Conditions</strong></p>
<ol>
<li>Solutions using standard libraries are preferable.</li>
<li>You can assume <code>dict</code> keys are numerical but a more general solution is preferable.</li>
<li>Iteration order is of no importance but additional information on the matter is a bonus.</li>
<li>I'm iterating two <code>dict</code>s.</li>
<li>Both <code>dict</code>s should remain unaltered.</li>
<li>I'm using python 3.6.1</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over common keys:</p>
<pre><code>for key in di1.keys() &amp; di2.keys():
  print(key)
</code></pre>
<p>Or union of keys:</p>
<pre><code>for key in di1.keys() | di2.keys():
  print(key)
</code></pre>
<p>You choose. Use <code>dict.viewkeys()</code> in Python 2.</p>
</div>
<div class="post-text" itemprop="text">
<p>I would extract keys from both dicts (<code>.keys()</code>), join the lists of the keys, remove duplicates (make it <code>set</code>), then iterate over the dicts using this new set of keys.</p>
<pre><code>keys1 = di1.keys()
keys2 = di2.keys()
keys = keys1 + keys2
keys = set(keys)

for key in keys:
    try:
        di1[key]
        di2[key]
    except KeyNotFoundError:
        # key is not present in both dicts
        pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools.izip_longest</code>, to iterate till the longer collection, where <code>zip</code> iterates till the smaller collection. </p>
<pre><code>&gt;&gt;&gt; di1 = {1: "a", 2: "b", 3: "c", 5:"e"}
&gt;&gt;&gt; di2 = {1: "a", 2: "b", 4: "d", 5:"e", 6:"f"}
&gt;&gt;&gt; 
&gt;&gt;&gt; from itertools import izip_longest
&gt;&gt;&gt; for a, b in  izip_longest(di1, di2):
...     print(di1.get(a), di2.get(b))
... 
('a', 'a')
('b', 'b')
('c', 'd')
('e', 'e')
(None, 'f')
</code></pre>
<p>The thing to look at here is the use of <code>dict.get(key)</code>,  because using <code>dict[key]</code> will cause KeyError for unique keys. You can however, add an optional default value as second parameter inside <code>dict.get(key, default_value)</code>.</p>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that the <em>values</em> are consistent between the various dictionaries you can use <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap" rel="nofollow noreferrer"><code>collections.ChainMap</code></a> to iterate over multiple dictionaries:</p>
<pre><code>from collections import ChainMap

di1 = {1: "a", 2: "b", 3: "c", 5:"e"}
di2 = {1: "a", 2: "b", 4: "d", 5:"e", 6:"f"}

chained_dicts = ChainMap(di1, di2)    # add more dicts as required
for key in chained_dicts:
    print(key, chained_dicts[key])
</code></pre>
<p>Output:</p>
<pre>
1 a
2 b
3 c
4 d
5 e
6 f
</pre>
<p>Or more simply:</p>
<pre><code>for key, value in ChainMap(di1, di2).items():
    print(key, value)
</code></pre>
<p>As mentioned above, this is fine if the values for duplicated keys are the same. Where there is variation the value from the first chained dictionary will be returned.</p>
</div>
<span class="comment-copy">What to do in the case that the <i>value</i> for a duplicated key is different in each dictionary?</span>
