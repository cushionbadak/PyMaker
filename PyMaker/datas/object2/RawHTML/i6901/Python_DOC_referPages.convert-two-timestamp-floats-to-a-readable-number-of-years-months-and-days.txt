<div class="post-text" itemprop="text">
<p>I have two timestamps which are stored in float format:</p>
<pre><code>tms1 = 1479081600.0
tms2 = 1482105600.0
</code></pre>
<p>Upon calculating the difference I get</p>
<pre><code>tms2 - tms1
3024000.0
</code></pre>
<p><strong>How do I go about displaying this time difference of 3024000 into a readable format in days, months or years?</strong> (The answer is 35 days between 14 Nov 2016 to 19 Dec 2016 using an online unix time difference calculator)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use (after <code>import</code>ing <code>datetime</code>)</p>
<pre><code>datetime.timedelta(seconds=3024000).days
</code></pre>
<p>which is </p>
<pre><code>35
</code></pre>
<p>You should use <code>timedelta</code> as this is a time delta - a difference in time, not an absolute time. A full representation can also be obtained by coercing a <code>timedelta</code> to a string:</p>
<pre><code>print(datetime.timedelta(seconds=3024000))
</code></pre>
<p>Gives the output:</p>
<pre><code>35 days, 0:00:00
</code></pre>
<p>Note that you don't need an online calculator for anything - <code>datetime</code> comes with batteries included. You could do:</p>
<pre><code>import datetime

date_format = "%d %b %Y"

start_date = datetime.datetime.strptime("14 Nov 2016", date_format)
end_date = datetime.datetime.strptime("19 Dec 2016", date_format)

print(start_date == datetime.datetime.fromtimestamp(1479081600))

print(start_date)
print(end_date.strftime("%d/%m/%Y"))

diff = end_date - start_date

print(diff)
print(diff.days)
</code></pre>
<p>which outputs:</p>
<pre><code>True
2016-11-14 00:00:00
19/12/2016
35 days, 0:00:00
35
</code></pre>
<p>Note that <code>diff</code> here is identical to the original <code>timedelta</code> object, but is dynamically created from <code>datetime</code>s rather than statically constructed. I've also demonstrated the fact that you can build a datetime from a timestamp, should you wish, and I've also taken the liberty of demonstrating <code>strftime</code> and the like to illustrate the power of datetime. I highly recommend the <code>datetime</code> approach over an arithmetic approach as it's a lot more readable and extensible.</p>
<p>This answer is pretty lightweight, which isn't necessarily bad, as often you might not need any more functionality than it provides, but if the <code>timedelta</code> between two days is less than 24 hours, it will round down to 0 days, for example. It also can't handle timezones. If you need either of those, see <a href="https://stackoverflow.com/questions/45899661/how-to-convert-the-days-between-two-timestamp-floats-to-a-readable-format/45900003#45900003">the legendary Raymond's awesome answer</a></p>
</div>
<div class="post-text" itemprop="text">
<p>Just subtracting seconds doesn't help you know whether a day boundary has been crossed, so it is necessary to convert the timestamps to <a href="https://docs.python.org/3/library/datetime.html#datetime-objects" rel="nofollow noreferrer">datetime</a> objects before computing the days.</p>
<p>Add since the timezone can affect what the calendar day is for a UTC timestamp, you may need a <a href="https://docs.python.org/3/library/datetime.html#tzinfo-objects" rel="nofollow noreferrer"><em>tzinfo</em></a> object as well.</p>
<p>Once the calendar dates are known, a little calendar math is needed to compute the difference in years, months, and days:</p>
<pre><code>from datetime import timedelta, datetime

def time_diff(start_timestamp, end_timestamp, tz=None):
    """ Return time difference in years, months, and days.

        If *tz* is None, the timestamp is converted to the platformâ€™s local date 
        and time.  Otherwise, *tz* should be an instance of a *tzinfo* subclass.
    """

    # Determine whether we're going forward or backward in time
    ago = ''
    if end_timestamp &lt; start_timestamp:
        ago = 'ago'
        start_timestamp, end_timestamp = end_timestamp, start_timestamp

    # Compute the calendar dates from the timestamps
    d1  = datetime.fromtimestamp(start_timestamp, tz)
    d2  = datetime.fromtimestamp(end_timestamp, tz)

    # Advance d1 day-by-day until the day is at or above d2.day
    days = 0
    while d2.day &lt; d1.day:
        days += 1
        d1 += timedelta(days=1)

    # Now compute the day difference
    days += d2.day - d1.day

    # Compute the totals months difference and express in years and months
    total_months = (d2.year * 12 + d2.month) - (d1.year * 12 + d1.month)
    years, months = divmod(total_months, 12)

    # format the output
    plural = lambda n: '' if n == 1 else 's'
    return '%d year%s, %d month%s, and %d day%s %s' % (
        years, plural(years), months, plural(months), days, plural(days), ago)
</code></pre>
<p>Here is an example of how to use the function:</p>
<pre><code>from datetime import tzinfo

class GMT1(tzinfo):
    # Example tzinfo subclass taken from the Python docs
    def utcoffset(self, dt):
        return timedelta(hours=1)
    def dst(self, dt):
        return timedelta(0)
    def tzname(self,dt):
        return "Europe/Prague"

print(time_diff(1479081600.0, 1482105600.0, tz=GMT1()))
</code></pre>
<p>This outputs:</p>
<pre><code>0 years, 1 month, and 5 days
</code></pre>
</div>
<span class="comment-copy">seconds in day <code>= 60 * 60 * 24 = 86400</code>, so <code>3024000.0 / 86400 = 35.0</code></span>
