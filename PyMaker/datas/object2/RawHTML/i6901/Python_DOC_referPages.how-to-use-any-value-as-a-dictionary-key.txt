<div class="post-text" itemprop="text">
<p>I'd like to use instances of any type as a key in a single <code>dict</code>.</p>
<pre><code>def add_to_dict(my_object, d, arbitrary_val = '123'):
    d[ id(my_object) ] = arbitrary_val

d = {}
add_to_dict('my_str', arbitrary_val)
add_to_dict(my_list, arbitrary_val)
add_to_dict(my_int, arbirtray_val)

my_object = myclass()
my_object.__hash__ = None
add_to_dict(my_object, arbitrary_val)
</code></pre>
<p>The above won't work because <code>my_list</code> and <code>my_object</code> can't be hashed.</p>
<p>My first thought was to just pass in the <code>id</code> value of the object using the <code>id()</code> function.</p>
<pre><code>def add_to_dict(my_object, d, arbitrary_val = '123'):
    d[ id(my_object) ] = arbitrary_val
</code></pre>
<p>However, that won't work because <code>id('some string') == id('some string')</code> is not guaranteed to always be <code>True</code>.</p>
<p>My second thought was to test if the object has the <code>__hash__</code> attribute. If it does, use the object, otherwise, use the <code>id()</code> value.</p>
<pre><code>def add_to_dict(my_object, d, arbitrary_val = '123'):
    d[ my_object if my_object.__hash__ else id(my_object) ] = arbitrary_val
</code></pre>
<p>However, since <code>hash()</code> and <code>id()</code> both return <code>int</code>'s, I believe I will eventually get a collision.</p>
<p>How can I write <code>add_to_dict(obj, d)</code> above to ensure that no matter what <code>obj</code> is (<code>list</code>, <code>int</code>, <code>str</code>, <code>object</code>, <code>dict</code>), it will correctly set the item in the dictionary and do so without collision?</p>
</div>
<div class="post-text" itemprop="text">
<p>We could make some kind of dictionary that allows us to insert mutable objects as well:</p>
<pre><code>class DictionaryMutable:

    nullobject = object()

    def __init__(self):
        self._inner_dic = {}
        self._inner_list = []

    def __getitem__(self, name):
        try:
            return self._inner_dic[name]
        except TypeError:
            for key, val in self._inner_list:
                if name == key:
                    return val
            raise KeyError(name)

    def __setitem__(self, name, value):
        try:
            self._inner_dic[name] = value
        except TypeError:
            for elm in self._inner_list:
                if name == elm[0]:
                    elm[1] = value
                    break
            else:
                self._inner_list.append([name,value])

    # ...
</code></pre>
<p>This works as follows: the <code>DictionaryMutable</code> consists out of a dictionary and a list. The dictionary contains the hashable <em>immutable</em> keys, the list contains sublists where each sublist contains two elements: a key and a value.</p>
<p>For each lookup we first attempt to perform a lookup on the dictionary, in case the key <code>name</code> is unhashable, a <code>TypeError</code> will be thrown. In that case we iterate through the list, check if one of the keys matches and return the corresponding value if it does. If no such element exists, we raise a <code>KeyError</code>.</p>
<p>Setting elements works approximately the same way: first we attempt to set the element in the dictionary. If it turns out the key is unhashable, we search linearly through the list and aim to add the element. If that fails, we add it at the end of the list.</p>
<p>This implementation has some major disadvantages:</p>
<ul>
<li>if the dictionary lookup fails due to the key being unhashable, we will perform <strong>linear lookup</strong>, this can siginificantly slow down the lookup; and</li>
<li>if you alter an object that is in the dictionary, then the key will be updated, and thus a search for that object will fail. It thus can result in some unpredicted behavior.</li>
</ul>
<p>This is only a basic implementation. For instance <code>__iter__</code>, etc. need to be implemented as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of the <code>id()</code> of the object, you could use the pickled byte stream representation of the object <a href="https://docs.python.org/3/library/pickle.html#pickle.dumps" rel="nofollow noreferrer"><code>pickle.dumps()</code></a> returns for it. <code>pickle</code> works with most built-in types, and there are ways to extend it to work with most values it doesn't know how to do automatically. </p>
<p>Note: I used the <code>repr()</code> of the object as its "arbitrary value" in an effort to make it easier to identify them in the output displayed.</p>
<pre><code>try:
    import cpickle as pickle
except ModuleNotFoundError:
    import pickle
from pprint import pprint

def add_to_dict(d, obj, arbitrary_val='123'):
    d[pickle.dumps(obj)] = arbitrary_val

class MyClass: pass

my_string = 'spam'
my_list = [13, 'a']
my_int = 42
my_instance = MyClass()

d = {}
add_to_dict(d, my_string, repr(my_string))
add_to_dict(d, my_list, repr(my_list))
add_to_dict(d, my_int, repr(my_int))
add_to_dict(d, my_instance, repr(my_instance))

pprint(d)
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>{b'\x80\x03K*.': '42',
 b'\x80\x03X\x04\x00\x00\x00spamq\x00.': "'spam'",
 b'\x80\x03]q\x00(K\rX\x01\x00\x00\x00aq\x01e.': "[13, 'a']",
 b'\x80\x03c__main__\nMyClass\nq\x00)\x81q\x01.': '&lt;__main__.MyClass object at '
                                                  '0x021C1630&gt;'}
</code></pre>
</div>
<span class="comment-copy">I'm not sure that it's a good idea. mutable objects <i>could</i> be hashable, but the hash doesn't change, whereas the object <i>can</i> change. for lists, it's very easy: convert to <code>tuple</code> and you're good to go.</span>
<span class="comment-copy">read: <a href="https://stackoverflow.com/questions/24217647/why-must-dictionary-keys-be-immutable" title="why must dictionary keys be immutable">stackoverflow.com/questions/24217647/…</a></span>
<span class="comment-copy">also: <a href="https://stackoverflow.com/questions/4418741/im-able-to-use-a-mutable-object-as-a-dictionary-key-in-python-is-this-not-disa" title="im able to use a mutable object as a dictionary key in python is this not disa">stackoverflow.com/questions/4418741/…</a></span>
<span class="comment-copy">one implementation here: <a href="http://code.activestate.com/recipes/578096-a-mutablemapping-that-can-use-unhashable-objects-a/" rel="nofollow noreferrer">code.activestate.com/recipes/…</a>  , but as predicted, it's very dangerous</span>
<span class="comment-copy">Any hashable type can be a dict key already ... but if it's not hashable, then a dict makes absolutely no sense. Even if it "works" (air quotes), it won't work like a dict should.</span>
