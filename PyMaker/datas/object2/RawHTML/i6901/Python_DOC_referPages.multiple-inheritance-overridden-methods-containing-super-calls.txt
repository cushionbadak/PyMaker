<div class="post-text" itemprop="text">
<p>With the file super5.py:</p>
<pre><code>class A:
    def m(self):
        print("m of A called")

class B(A):
    def m(self):
        print("m of B called")
        super().m()

class C(A):
    def m(self):
        print("m of C called")
        super().m()

class D(B,C):
    def m(self):
        print("m of D called")
        super().m()
</code></pre>
<p>we can do the following:</p>
<pre><code>&gt;&gt;&gt; from super5 import D
&gt;&gt;&gt; x = D()
&gt;&gt;&gt; x.m()
m of D called
m of B called
m of C called
m of A called
</code></pre>
<p>To me, this doesn't make sense, because when I execute <code>x.m()</code>, I expect the following to happen:</p>
<ol>
<li>The first line of <code>m</code> of <code>D</code> is executed and thus <code>"m of D called"</code> is output.</li>
<li>The second line, <code>super().m()</code> is executed, which first takes us to <code>m</code> of <code>B</code>.</li>
<li>In <code>m</code> of <code>B</code>, <code>"m of B called"</code> is first output, and then, <code>m</code> of <code>A</code> is executed due to the <code>super.m()</code> call in <code>m</code> of <code>B</code>, and <code>"m of A called"</code> is output.</li>
<li><code>m</code> of <code>C</code> is executed in a fashion analogous to 3.</li>
</ol>
<p>As you can see, what I expect to see is:</p>
<pre><code>m of D called
m of B called
m of A called
m of C called
m of A called
</code></pre>
<p>Why am I wrong? Is python somehow keeping track of the number of <code>super()</code> calls to a particular superclass and limiting the execution to 1?</p>
</div>
<div class="post-text" itemprop="text">
<p>No, Python keep a track of all super classes in a special <code>__mro__</code> attribute (Method Resolution Order in new-style classes):</p>
<pre><code>print(D.__mro__)
</code></pre>
<p>You get:</p>
<pre><code>(&lt;class 'D'&gt;, &lt;class 'B'&gt;, &lt;class 'C'&gt;, &lt;class 'A'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>So, when you call <code>super</code>, it follow this list in order.</p>
<p>See this question: <a href="https://stackoverflow.com/q/2010692/1513933">What does mro() do?</a>.</p>
<p>Everything is explained in the official document in the chapter <a href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance" rel="nofollow noreferrer">"Multiple Inheritance"</a>.</p>
<blockquote>
<p>For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in DerivedClassName, it is searched for in Base1, then (recursively) in the base classes of Base1, and if it was not found there, it was searched for in Base2, and so on.</p>
<p>In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to super(). This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages.</p>
<p>Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from object, so any case of multiple inheritance provides more than one path to reach object. <strong>To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents).</strong> Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance.</p>
</blockquote>
</div>
<span class="comment-copy">You're describing the behavior that would result if each class called its direct superclasses' methods directly. <code>super</code> was designed specifically not to do that.</span>
<span class="comment-copy">As usual, the definitive article on this is Raymond Hettinger's "<a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="nofollow noreferrer"><code>super()</code> considered super</a>".</span>
<span class="comment-copy">Okay, so when we reach <code>class B</code> in that list, does it simply ignore the <code>super()</code>-call in <code>m</code>of <code>B</code>?</span>
<span class="comment-copy">@Sandi No, it goes to the next superclass according to the mro. That means if you delete the <code>super()</code> call in B, you would not reach C.</span>
<span class="comment-copy">The snippet you posted is missleading, because in this case it is <i>not</i> depth first. I think this text is more appropriate: "To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class"</span>
<span class="comment-copy">@Sandi: It goes through <code>type(self)</code>'s MRO.</span>
<span class="comment-copy">@Sandi: Correct.</span>
