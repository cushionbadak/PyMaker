<div class="post-text" itemprop="text">
<p>I would like to know whether it be possible to set a length for a variable in python like in C: <code>short</code>, <code>long</code>, etc.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I already mentioned in the comments Pythons integers are big integers. They can hold any integer number you wish:</p>
<pre><code>&gt;&gt;&gt; a = 1234567890 ** 100
... very long number ...
</code></pre>
<p>In Python there is also rarely a need for shorter types because (at least CPython) uses a reference counting system and that means all instances (and I mean <strong>all</strong>) have a refcount (64bit) and a pointer to the class (another 64bit) attribute. With an overhead of 128bits it's rarely useful to use integers that are shorter than 32 or 64bit.</p>
<p>If you really want these C-types you could use NumPy which already wrapped them:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.short(10)
10
&gt;&gt;&gt; type(np.short(10))
numpy.int16
</code></pre>
<p>But the memory overhead for scalars is, as said above, not worth it. However if you have arrays this argument doesn't hold anymore:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof(np.short(10))
26   # bytes

&gt;&gt;&gt; arr = np.array([1,2,3,4,5,6,7,8,9,10], dtype=np.short)
&gt;&gt;&gt; arr
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10], dtype=int16)
&gt;&gt;&gt; sys.getsizeof(arr)
116  # bytes
</code></pre>
<p>This is because NumPy also wraps C-arrays and only has the reference count overhead + class overhead (+ additional overhead) (=96 bytes) once per array:</p>
<pre><code>&gt;&gt;&gt; sys.getsizeof(np.zeros(1000000, dtype=np.short))
2000096
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest taking a look at Numpy's dtype, some documentation can be found <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.dtypes.html" rel="nofollow noreferrer">here</a>.</p>
<p>Some examples:</p>
<pre><code>import numpy as np
a = np.dtype(np.int32)
a = np.dtype(np.int64)
a = np.dtype(np.float32)
a = np.dtype(np.float64)
a = np.dtype(np.float128)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot specify a precision directly. When a python <code>int</code> grows too large they will automatically be converted to a python long. You can initialize a python long by appending an 'l' or 'L'. Note however that this is only possible in python 2.</p>
<p>For example:</p>
<p><code>long_int = 398593849843l</code></p>
<p><code>another = 13L</code></p>
</div>
<span class="comment-copy">No, <code>int</code>s (at least on python3.x) are big integers. They can hold any integer number. If you want C-like types you need to go to a library like <code>NumPy</code> which already wrapped them.</span>
<span class="comment-copy">Also, there is the <a href="https://docs.python.org/3/library/ctypes.html" rel="nofollow noreferrer"><code>ctypes</code> module</a>, which is mainly intended to interoperate with native libraries and provides, as the name suggests, C-compatible types.</span>
