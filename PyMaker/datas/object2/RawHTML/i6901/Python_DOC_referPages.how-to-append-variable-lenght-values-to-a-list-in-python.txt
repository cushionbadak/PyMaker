<div class="post-text" itemprop="text">
<p>I have a file which contains input like below:</p>
<pre><code>host1 192.168.100.24
user1@abc.com  host2 192.168.100.45 host7 192.168.100.40 host3 192.168.100.34 host4 192.168.100.20
user2@xyz.com  host8 192.168.100.48 host6 192.168.100.43 host10 192.168.100.37 
host5 192.168.100.24 host9 192.168.100.33
</code></pre>
<p>Expected Output:</p>
<pre><code>no_email: 
      host1 192.168.100.24
      host5 192.168.100.24 
      host9 192.168.100.33
user1@abc.com:  
            host2 192.168.100.45
            host7 192.168.100.40
            host3 192.168.100.34 
            host4 192.168.100.20
user2@xyz.com: 
            host8 192.168.100.48
            host6 192.168.100.43 
            host10 192.168.100.37
</code></pre>
<p>Code:</p>
<pre><code>def get_contacts(filename):

emails = []
hostname = []
ip = []
with open(filename,'r') as contacts_file:
    for a_contact in contacts_file:
        match = re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', a_contact.split()[0])
        if match == None:
           emails.append('no_email')
           hostname.append(a_contact.split()[0])
           ip.append(a_contact.split()[1])
        line_length = a_contact.count(' ')
        elif line_length &gt; 1:
           emails.append(a_contact.split()[0])
           hostname.append(a_contact.split()[1])
           ip.append(a_contact.split()[2])
        else:
           emails.append(a_contact.split()[0])
           hostname.append(a_contact.split()[1])
           ip.append(a_contact.split()[2])
return emails, hostname, ip
</code></pre>
<p>I just want to return list of hostname and IP which will be used to send to the specified email address returned from the list. Can any one help me how it can be done easily? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>First install the <a href="https://github.com/syrusakbary/validate_email" rel="nofollow noreferrer">validate_email</a> module with:</p>
<pre><code>$pip3 install validate_email
</code></pre>
<p>Then:</p>
<pre><code>from validate_email import validate_email

result = {}
with open('file.txt') as f:
    for line in f:
        words = line.split()
        if validate_email(words[0]): # If first word of the line is a valid email, lets store data on the result dict using the email as key.
            email = words[0]
            words = words[1:]
        else:
            email = 'no_email'

        hosts_emails = [(words[i], words[i+1]) for i in range(0, len(words) - 1, 2)]
        (result.setdefault(email, [])).append(hosts_emails)

print(result)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>{'no_email': [[('host1', '192.168.100.24')], [('host5', '192.168.100.24'), ('host9', '192.168.100.33')]], 'user1@abc.com': [[('host2', '192.168.100.45'), ('host7', '192.168.100.40'), ('host3', '192.168.100.34'), ('host4', '192.168.100.20')]], 'user2@xyz.com': [[('host8', '192.168.100.48'), ('host6', '192.168.100.43'), ('host10', '192.168.100.37')]]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Hope this helps. It will be wise to use a dictionary where the keys can be either <code>no_email</code> or <code>email_id</code> (if matched by the email-regex). For each iteration we firstly set the <code>to_update</code> variable to <code>no-email</code> and only change it if a matching email is found. The <code>host_and_ip</code> variable is accordingly set to grab the portion of each line with only host and ips, i.e. stripping off the email address when a matching email is detected. In case a email is detected we see if the same email is already in our dictionary <code>dicto</code>, if yes we just update with the host and ips else we will properly initialize a list for the email(as a new key).</p>
<pre><code>import re
def get_contacts(filename):
    dicto={}
    dicto['no_email']=[]
    with open(filename,'r') as contacts_file:
        for a_contact in contacts_file:
            match = re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', a_contact.split()[0])
            to_update = 'no_email'      #by default to_update is set to no_email
            if match == None:
                host_and_ip = a_contact.split() #grab all as host and ip
            else:
                curr_email = a_contact.split()[0]
                if curr_email not in dicto.keys():
                    dicto[curr_email]=[]    #initialize for new email
                host_and_ip = a_contact.split()[1:]  #grab leaving one behind i.e. the email
                to_update = curr_email  #to be updated to the email
            for i in range(len(host_and_ip)//2):
                dicto[to_update]+=[[host_and_ip[2*i],host_and_ip[2*i+1]]]
    return dicto

print(get_contacts('test.txt'))
</code></pre>
<p>The function will give a dictionary looking like this:</p>
<pre><code>{'no_email': [['host1', '192.168.100.24'], ['host4', '192.168.100.20'], ['host5', '192.168.100.24'], ['host9', '192.168.100.33']], 'user1@abc.com': [['host2', '192.168.100.45'], ['host7', '192.168.100.40'], ['host3', '192.168.100.34']], 'user2@xyz.com': [['host8', '192.168.100.48'], ['host6', '192.168.100.43'], ['host10', '192.168.100.37']]}
</code></pre>
<p>You can easily access the list of host and ip for a particular email id simply as:</p>
<p><code>get_contacts('test.txt')['user1@abc.com']</code> which will return back a list of host and ips. </p>
</div>
<div class="post-text" itemprop="text">
<p>I use the third-party library, <a href="https://github.com/erikrose/more-itertools" rel="nofollow noreferrer"><code>more_itertools</code></a> to facilitate implementing the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.grouper" rel="nofollow noreferrer"><code>grouper</code></a> itertools recipe.  This can be installed via <code>pip install more_itertools</code>.</p>
<pre><code>import more_itertools as mit


dd = ct.defaultdict(list)
with open(filename, "r") as f:
    for line in f.readlines():
        parts = line.split()
        if "@" not in parts[0]:
            dd["no email"].extend(list(mit.grouper(2, parts)))
        else:
            name = parts[0]
            dd[name].extend(list(mit.grouper(2, parts[1:])))

dd
</code></pre>
<p>Output</p>
<pre><code>defaultdict(list,
            {'no email': [
              ('host1', '192.168.100.24'),
              ('host5', '192.168.100.24'),
              ('host9', '192.168.100.33')],
             'user1@abc.com': [
              ('host2', '192.168.100.45'),
              ('host7', '192.168.100.40'),
              ('host3', '192.168.100.34'),
              ('host4', '192.168.100.20')],
             'user2@xyz.com': [
              ('host8', '192.168.100.48'),
              ('host6', '192.168.100.43'),
              ('host10', '192.168.100.37')]})
</code></pre>
<p>The <code>grouper</code> recipe aids with re-chunking the (host, IP) together afters each line has been split by spaces.  </p>
<hr/>
<p>You can optionally implement this recipe by without installing <code>more_itertools</code>.</p>
<p>From the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipes</a> (in Python 3):</p>
<pre><code>from itertools import zip_longest 


def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One approach is to split each line and determine if the first entry has an <code>@</code> character in it. Then use slicing to extract the remaining entries:</p>
<pre><code>def get_contacts(filename):
    no_email = []
    users = []

    with open(filename) as f_contacts:
        for row in f_contacts:
            entries = row.split()

            if '@' in entries[0]:
                pairs = [entries[i:i+2] for i in range(1, len(entries), 2)]
                users.append([entries[0], pairs])
            else:
                for i in range(0, len(entries), 2):
                    no_email.append(entries[i:i+2])

    return no_email, users

no_email, users = get_contacts('contacts.txt')            

print "no_email:"
for host, ip in no_email:
    print "    {} {}".format(host, ip)

for user_entry in users:    
    print "{}:".format(user_entry[0])
    for host, ip in user_entry[1]:
        print "    {} {}".format(host, ip)
</code></pre>
<p>This will display:</p>
<pre class="lang-none prettyprint-override"><code>no_email:
    host1 192.168.100.24
    host5 192.168.100.24
    host9 192.168.100.33
user1@abc.com:
    host2 192.168.100.45
    host7 192.168.100.40
    host3 192.168.100.34
    host4 192.168.100.20
user2@xyz.com:
    host8 192.168.100.48
    host6 192.168.100.43
    host10 192.168.100.37 
</code></pre>
<p><code>users</code> stores the entries in the form <code>["username", [["host1", "ip1"], ["host2, "ip2"]]]</code></p>
<p>If your file has multiple lines for the same user, it would be necessary to use a <code>defaultdict()</code> to store all entries for the same user in the same place.    </p>
</div>
<span class="comment-copy">Is it ok if you use <code>dict</code> to store the hostname and ips as values to email/no-email as keys?</span>
<span class="comment-copy">@officialaimm, Yes, it will be fine. Thanks.</span>
<span class="comment-copy">Validate email looks interesting.  Thanks.</span>
