<div class="post-text" itemprop="text">
<p>I read the documentation and am not sure how to simplify the following code with Python properties:</p>
<pre><code>class PatientRecordJson:
    def __init__(self):
        self.json = {}

    def set_raw_data_field(self, string):
        self.json['raw_data'] = string

    def get_raw_data_field(self):
        return self.json.get('raw_data', None)

    def set_data_type(self, string):
        self.json['data_type'] = string

    def get_data_type(self):
        return self.json.get('data_type', None)

    def set_type_of_record(self, string):
        self.json['type_of_record'] = string

    def get_type_of_record(self):
        return self.json.get('type_of_record', None)

    def set_npi(self, string):
        self.json['npi'] = string

    def get_npi(self):
        return self.json.get('npi', None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could override <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code></a> which are called when you access a property with <code>obj.prop</code>.</p>
<pre><code>class PatientRecordJson:
    properties = ['raw_data', 'data_type', 'type_of_record', 'npi']

    def __init__(self):
        self.json = {}

    def __getattr__(self, name):
        if name in PatientRecordJson.properties:
            return self.json.get(name)

        return super().__getattr__(name)

    def __setattr__(self, name, value):
        if name in PatientRecordJson.properties:
            self.json[name] = value

        return super().__setattr__(name, value)
</code></pre>
<p>Usage example:</p>
<pre><code>pr = PatientRecordJson()
pr.raw_data              #=&gt; None
pr.raw_data = 'raw data'
pr.raw_data              #=&gt; 'raw data'
pr.json                  #=&gt; {'raw_data': 'raw data'}
pr.z                     #=&gt; AttributeError
pr.z = 2
pr.z                     #=&gt; 2
pr.json                  #=&gt; {'raw_data': 'raw data'}
</code></pre>
<p>A note: you've defined <code>json</code> on the class, if you want it to be instance variable create it on <code>self</code> in <code>__init__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're just learning Python, this may be too advanced—however by using it you can largely automate the process of creating any number of classes like this by using a metaclass (a class whose instances are other classes).</p>
<p>Although doing so requires some non-trivial code, it makes defining the target classes extremely simple. Plus, as a bonus I added optional type-checking.</p>
<pre><code>def typed_property(field_name, expected_type=None):
    """ Helper function which creates and returns a property with the given
        name with optional type-checking. Each property retrieves or stores
        values from/to an instance-defined "json" dictionary attribute.
    """
    @property
    def prop(self):
        return self.json[field_name]

    @prop.setter
    def prop(self, value):
        if expected_type and not isinstance(value, expected_type):
            raise TypeError('Only {} values may be assigned to {}'.format(
                                expected_type.__name__, field_name))
        self.json[field_name] = value

    return prop


class PatientRecordMeta(type):
    """ Metaclass to define properties based on a class-level defined "fields"
        dictionary.
    """
    def __new__(metaclass, classname, bases, classdict):
        cls = super().__new__(metaclass, classname, bases, classdict)
        fields = classdict.get('fields')
        if not fields or not isinstance(fields, dict):
            raise TypeError('Class {} did not define required "fields" '
                            'instance dictionary'.format(classname))

        # Create the properties.
        for field, expected_type in fields.items():
            setattr(cls, field, typed_property(field, expected_type))

        return cls
</code></pre>
<p>The defined metaclass makes it very easy to create a class with exactly the desired properties:</p>
<pre><code>class PatientRecordJson(metaclass=PatientRecordMeta):
    fields = {'raw_data': str,
              'data_type': str,
              'type_of_record': str,
              'npi': int}  # Note changed to "int" to test type-checking,

    def __init__(self):
        self.json = {}  # define required instance attribute

    # Other methods could be defined here, too, if desired.
    # ...


patient_rec = PatientRecordJson()

patient_rec.raw_data = 'something'
patient_rec.bogus = 'something else'  # OK, but not saved in "self.json" dict.

try:
    patient_rec.npi = 'spam'  # -&gt; Should cause a TypeError
except TypeError:
    pass  # expected TypeError occurred
else:
    print('Error: a TypeError did not occur as expected')

patient_rec.npi = 42  # Integer value is OK.

patient_rec.json['raw_data'] = 'eggs'  # can still do this
print(patient_rec.raw_data)  # -&gt; eggs
print(patient_rec.npi)  # -&gt; 42
print(patient_rec.json)  # -&gt; {'raw_data': 'something', 'npi': 42}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> and <a href="https://docs.python.org/2/reference/datamodel.html#object.__setattr__" rel="nofollow noreferrer"><code>__setattr__</code></a> to treat your dynamic fields as if they are properties of the object itself, rather than of the internal <code>json</code> object.</p>
<pre><code>class PatientRecordJson:
    def __init__(self):
        self.fields = ['raw_data', 'data_type', 'type_of_record', 'npi']
        self.json = {}

    def __getattr__(self, key):
        if key not in self.fields:
            raise AttributeError
        return self.json.get(key, None)

    def __setattr__(self, key, data):
        if key not in self.fields
            raise AttributeError
        self.json[key] = data
</code></pre>
<p>The sample above will allow you to access the properties like so.</p>
<pre><code>patient = PatientRecordJson()
patient.data_type = 'something'
patient.npi = 12345
patient.raw_data = 'whatever you want here'
print(patient.data_type) #  'something'
print(patient.doesntexist) #  AttributeError
patient.notinfields = True #  AttributeError
</code></pre>
</div>
<span class="comment-copy">Off-topic: Do you realize that you've made <code>json</code> a <b>class</b>, not instance, variable? This means that all instances of the class will share it (and I suspect that's not something you'll want unless there's only one).</span>
<span class="comment-copy">Thank you @martineau I'm new to python world.</span>
<span class="comment-copy">+1 for using the static var for properties. I thought of changing my answer but saw you submitted one soon after.</span>
<span class="comment-copy">You have broken <code>return super().__getattr__(self)</code>. Should be <code>return super().__getattr__(name)</code>?</span>
<span class="comment-copy">@JimWright you're right, thank you )</span>
<span class="comment-copy">This doesn't use <code>property</code>... at least if you undertand it to mean the built-in decorator to implement this using the descriptor protocol...</span>
<span class="comment-copy">this doesn't use <code>property</code>, technically...</span>
<span class="comment-copy">OP asked how to simplify code, not how to use the property decorator.</span>
<span class="comment-copy">JIm: The OP didn't specifically say a property <i>decorator</i>, but they did explicitly ask about properties—see the question's title and the first (and only) line of text in it.</span>
