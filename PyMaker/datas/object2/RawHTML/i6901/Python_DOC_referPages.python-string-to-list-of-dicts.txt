<div class="post-text" itemprop="text">
<p>I have reviewed a number of similar questions on stackoverflow, but been unable to locate an answer which applies to my data/string.</p>
<p>I have a string which is effectively a list of dictionaries.  In the fields, numbers are not surrounded by double quotes.  If I try to use ast to evaluate the string, part of the string is cut off and I am unsure why.  Could someone help me determine an appropriate way to read in this string and create a list of dicts.</p>
<p>Thanks,</p>
<pre><code>&gt;&gt;&gt; print(ascii_data)
   [{"measurement": "cpu_load_short","tags": {"host": "server999","region": "us-west-1"},"fields": {"value": 0.99}},{"measurement": "cpu_load_short","tags": {"host": "server888","region": "us-east-1"},"fields": {"value": 0.88}}]
&gt;&gt;&gt; x = ast.literal_eval(ascii_data)
&gt;&gt;&gt; print(x)
   [{'fields': {'value': 0.99}, 'tags': {'host': 'server999', 'region': 'us-west-1'}, 'measurement': 'cpu_load_short'}, {'fields': {'value': 0.88}, 'tags': {'host': 'server888', 'region': 'us-east-1'}, 'measurement': 'cpu_load_short'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Given:</p>
<pre><code>&gt;&gt;&gt; s
'[{"measurement": "cpu_load_short","tags": {"host": "server999","region": "us-west-1"},"fields": {"value": 0.99}},{"measurement": "cpu_load_short","tags": {"host": "server888","region": "us-east-1"},"fields": {"value": 0.88}}]'
</code></pre>
<p>You can use <code>json</code></p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.loads(s)
[{u'fields': {u'value': 0.99}, u'tags': {u'host': u'server999', u'region': u'us-west-1'}, u'measurement': u'cpu_load_short'}, {u'fields': {u'value': 0.88}, u'tags': {u'host': u'server888', u'region': u'us-east-1'}, u'measurement': u'cpu_load_short'}]
</code></pre>
<p>Or <code>ast</code>:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval(s)
[{'fields': {'value': 0.99}, 'tags': {'host': 'server999', 'region': 'us-west-1'}, 'measurement': 'cpu_load_short'}, {'fields': {'value': 0.88}, 'tags': {'host': 'server888', 'region': 'us-east-1'}, 'measurement': 'cpu_load_short'}]
</code></pre>
<p>And they produce the same Python data structure (at least with ascii input...):</p>
<pre><code>&gt;&gt;&gt; json.loads(s)==ast.literal_eval(s)
True
</code></pre>
<p>Since in each case the result is a Python <code>dict</code> know that the order may be different than the string's order. Python dicts are unordered and will usually be different than the creation order (at least prior to Python 3.6).</p>
<hr/>
<p>Under Python 3.6, they resulting dict is in the same order:</p>
<pre><code>&gt;&gt;&gt; json.loads(s)
[{'measurement': 'cpu_load_short', 'tags': {'host': 'server999', 'region': 'us-west-1'}, 'fields': {'value': 0.99}}, {'measurement': 'cpu_load_short', 'tags': {'host': 'server888', 'region': 'us-east-1'}, 'fields': {'value': 0.88}}]
&gt;&gt;&gt; ast.literal_eval(s)
[{'measurement': 'cpu_load_short', 'tags': {'host': 'server999', 'region': 'us-west-1'}, 'fields': {'value': 0.99}}, {'measurement': 'cpu_load_short', 'tags': {'host': 'server888', 'region': 'us-east-1'}, 'fields': {'value': 0.88}}]
</code></pre>
<p>Python 3.6 is great...</p>
</div>
<div class="post-text" itemprop="text">
<p>Use json.</p>
<pre><code>In [1]: s = '''[{"measurement": "cpu_load_short","tags": {"host": "server999","region": "us-west-1"},"fields": {"value": 0.99}},{"measuremen
   ...: t": "cpu_load_short","tags": {"host": "server888","region": "us-east-1"},"fields": {"value": 0.88}}]'''

In [2]: import json

In [3]: import pprint

In [4]: pprint.pprint(json.loads(s))
[{'fields': {'value': 0.99},
  'measurement': 'cpu_load_short',
  'tags': {'host': 'server999', 'region': 'us-west-1'}},
 {'fields': {'value': 0.88},
  'measurement': 'cpu_load_short',
  'tags': {'host': 'server888', 'region': 'us-east-1'}}]
In [11]: json.loads(s)[0]['tags']['host']
Out[11]: 'server999'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about <code>json.loads</code>?</p>
<pre><code>j = json.loads(ascii_data)
</code></pre>
<p><code>ast.literal_eval</code> may not be the best option. If your data source comes from some API, it would definitely be json format.</p>
<p>And if the order of dict keys matters to you, try specifying the object_pairs_hook argument to JSONDecoder. (ref: <a href="https://stackoverflow.com/questions/6921699/can-i-get-json-to-load-into-an-ordereddict-in-python">Can I get JSON to load into an OrderedDict in Python?</a>)</p>
</div>
<span class="comment-copy">Nothing is cut off. It is a dictionary so the order is arbitrary.</span>
<span class="comment-copy">The AWS API returns JSON data</span>
<span class="comment-copy">Note that <a href="https://docs.python.org/3/whatsnew/3.6.html#whatsnew36-compactdict" rel="nofollow noreferrer">Python 3.6 dicts</a> do preserve order. Though, it is considered to be an implementation detail not to be relied upon, but that might change in the future.</span>
<span class="comment-copy">@JohnB: Example added. Thanks</span>
