<div class="post-text" itemprop="text">
<h1>Problem</h1>
<p>Say you have <code>n</code> lists of integers, where each list only includes integers in the range from <code>1</code> to <code>n</code>. For example, for <code>n = 4</code>, we might have:</p>
<pre><code>a_1 = [1, 2]
a_2 = [3]
a_3 = [4, 1, 1]
a_4 = [2, 3]
</code></pre>
<p><strong>Now my question is:</strong> Can I tick off all the integers between <code>1</code> and <code>n</code> in those <code>n</code> lists but with the catch that once I find one number, I can't use that list anymore to find subsequent numbers?</p>
<p>For example, in the above example with <code>n = 4</code>, I can choose 1 from <code>a_1</code>, 2 from <code>a_4</code>, 3 from <code>a_2</code>, and 4 for <code>a_3</code>, and I have therefore filled all the numbers from 1 to 4 but only using each list <strong>once</strong>.</p>
<p>An example where I can't find the range (and hence should return <code>False</code>) would be:</p>
<pre><code>a_1 = [1, 2]
a_2 = [3, 3, 5]
a_3 = [4]
a_4 = [5]
a_5 = [3, 4, 5]
</code></pre>
<p>The reason is because if I choose 1 from a_1, I can't choose 2 anymore from any list.</p>
<h1>Approach</h1>
<p>This is my current straightforward approach. I make a cartesian product of the lists and check if there is any that, sorted, will be a range. </p>
<pre><code>import itertools

def fillRange(lists):
  cartesian = itertools.product(*lists)
  return any([sorted(comb) == range(1, len(lists) + 1) for comb in cartesian])
</code></pre>
<h1>Question</h1>
<p>Although my approach works, for large lists it becomes a bit inefficient. Any thoughts on how I can improve this algorithm?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can formulate this as a maximum flow problem in a bipartite graph where the left nodes correspond to lists, and the right nodes correspond to integers 1 to n.</p>
<p>There is an edge in the graph iff the integer is in the corresponding list.</p>
<p>All capacities in the graph are equal to 1.</p>
<p>If you can find a flow of size n from the left side to the right side then the problem is soluble.</p>
<p>Python code to do this below:</p>
<pre><code>import networkx as nx

a_1 = [1, 2]
a_2 = [2]
a_3 = [4, 1, 1]
a_4 = [2, 3]
A = [a_1,a_2,a_3,a_4]
n = 4

G=nx.DiGraph()
for i,a in enumerate(A):
    for j in set(a):
        l = 'list'+str(i)
        G.add_edge(l,j,capacity=1)
        G.add_edge('start',l,capacity=1)
for j in range(1,n+1):
    G.add_edge(j,'dest',capacity=1)
v,flow = nx.maximum_flow(G,'start','dest')
if v&lt;n:
    print 'Impossible'
else:
    for i,a in enumerate(A):
        for j in set(a):
            if flow['list'+str(i)][j]&gt;0:
                print 'Use',j,'from list',a
</code></pre>
<p>This prints:</p>
<pre><code>Use 1 from list [1, 2]
Use 2 from list [2]
Use 4 from list [4, 1, 1]
Use 3 from list [2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of testing all the combinations in order, you can speed this up a lot by testing the most-constrained lists first, and also updating the alternatives in the other lists as you add elements to your solution set. This way, you can "solve" both your examples without backtracking once.</p>
<pre><code>def search(n, lists):
    if n == 0:
        yield []
    else:
        lists = [l for l in lists if l != []]
        if len(lists) &gt;= n:
            least = min(lists, key=len)
            for val in least:
                new = [[x for x in lst if x != val] for lst in lists if lst is not least]
                for res in search(n-1, new):
                    yield [val] + res
</code></pre>
<p>Here's some debugging/tracing output for your two examples to help with the understanding. First value is <code>n</code>, then the <code>lists</code>, and finally the previously chosen <code>val</code>.</p>
<pre><code>4 [[1, 2], [3], [4, 1, 1], [2, 3]] None
3 [[1, 2], [4, 1, 1], [2]] 3
2 [[1], [4, 1, 1]] 2
1 [[4]] 1
0 [] 4 --&gt; solution
[3, 2, 1, 4]

5 [[1, 2], [3, 3, 5], [4], [5], [3, 4, 5]] None
4 [[1, 2], [3, 3, 5], [5], [3, 5]] 4
3 [[1, 2], [3, 3], [3]] 5
2 [[1, 2], []] 3 --&gt; abort
</code></pre>
<hr/>
<p>If you also want the indices of the lists the elements have been taken from, the code gets a little more complicated, but not much:</p>
<pre><code>def search(n, lists):
    if n == 0:
        yield []
    else:
        if sum(1 for l in lists if l) &gt;= n:
            i = min(range(len(lists)), key=lambda x: (lists[x] == [], len(lists[x])))
            for val in lists[i]:
                new = [[x for x in lst if x != val] if lst is not lists[i] else [] for lst in lists]
                for res in search(n-1, new):
                    yield [(i, val)] + res
</code></pre>
<p>Result for your first example then is <code>[(1, 3), (3, 2), (0, 1), (2, 4)]</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The cartesian product seems the most straightforward to me. I would do the following to streamline your code:</p>
<ul>
<li><p>remove []'s from your <code>any</code> expression as I mentioned in the comments</p></li>
<li><p>collapse all input lists to sets before computing cartesian product - there is no point in processing duplicate values from the same list</p></li>
<li><p>save <code>range(1, len(lists)+1)</code> to a local variable and compare with that instead of recreating the range each time (this is a common optimization technique called "invariant lifting", in which a computed expression that doesn't change during the loop is "lifted" out of the loop and just computed once)</p></li>
</ul>
<p>But ultimately, the basic algorithm of computing <em>a</em> cartesian of your input lists, and then looking for any which are the values 1-n is still as you originally wrote.</p>
<pre><code>def fillRange(lists):
  cartesian = itertools.product(*(set(x) for x in lists))
  target = list(range(1, len(lists) + 1))
  return any(sorted(comb) == target for comb in cartesian)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This can be seen as a problem of <a href="https://en.wikipedia.org/wiki/Bipartite_graph#Matching" rel="nofollow noreferrer">matching in a bipartite graph</a>. As it turns out, <a href="https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem#Graph_theoretic_formulation" rel="nofollow noreferrer">Hall's marriage theorem</a> tells you the answer (that is, whether the matching exists, not the matching itself). Here is a possible implementation (using NumPy for convenience):</p>
<pre><code>from itertools import chain, combinations
import numpy as np

# Recipe from itertools docs: https://docs.python.org/3/library/itertools.html#itertools-recipes
def powerset(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))


def has_matching(lists):
    n = len(lists)
    m = np.array([np.logical_or.reduce(np.arange(1, n + 1)[:, np.newaxis] == lst, axis=1)
                  for lst in lists])
    m = m.astype(int)
    for s in powerset(range(n)):
        if np.sum(np.logical_or.reduce(m[s, :], axis=0)) &lt; len(s):
            return False
    return True


lists1 = [[1, 2],
          [3],
          [4, 1, 1],
          [2, 3]]
print(has_matching(lists1))
&gt;&gt;&gt; True

lists2 = [[1, 2],
          [3, 3, 5],
          [4],
          [5],
          [3, 4, 5]]
print(has_matching(lists2))
&gt;&gt;&gt; False
</code></pre>
<p>However, this requires you to go through every subset of <code>{1, ..., n}</code>, so I guess the algorithm is O(2<sup><em>N</em></sup>). Not great, but maybe better than going through the whole Cartesian product, which I guess would be O(<em>N</em><sup><em>N</em></sup>).</p>
</div>
<div class="post-text" itemprop="text">
<p>You could try mapping which values occur in which list, and decompose your problem from there. This code builds that sort of reverse-lookup:</p>
<pre><code>In[38]: from collections import defaultdict
In[39]: occurrences = defaultdict(set)
In[40]: for i,ll in enumerate(lists):
   ...:     for x in ll:
   ...:         occurrences[x].add(i)
   ...:         
In[41]: print(occurrences)
defaultdict(&lt;class 'set'&gt;, {1: {0, 2}, 2: {0, 3}, 3: {1, 3}, 4: {2}})
In[42]: print(dict(occurrences.items()))
{1: {0, 2}, 2: {0, 3}, 3: {1, 3}, 4: {2}}
</code></pre>
<p>For instance, you can see at a glance, that 4 exists only in <code>list[2]</code> (that is <code>a_3</code> in your original question). From there, if you eliminate 2 from the other values, 1 exists only in <code>list[0]</code>. Eliminating 0 shows that 2 only exists in <code>list[3]</code>, and 3 then can only be gotten from <code>list[1]</code>. If in doing this successive elimination, any of the sets to select from becomes empty, then there is no solution.</p>
</div>
<span class="comment-copy">ok, so what exactly is your desired output for input <code>lists = [a_1, a_2, a_3, a_4]</code> ?</span>
<span class="comment-copy">Is it any better if you remove the <code>[]</code>s from <code>return any([sorted(comb) == range(1, len(lss) + 1) for comb in cartesian])</code>? As it stands, you will always process the full cartesian product first, evaluating the condition to build a list of booleans, then pass that list to <code>any</code> to see if any are True. If you remove the <code>[]</code>s, then <code>any</code> will return True when it finds the first matching condition.</span>
<span class="comment-copy">@Chris_Rands My desired output is a boolean indicating whether it is possible to find the range with those lists or not.</span>
<span class="comment-copy">@McGuire And for that example it's <code>True</code>?</span>
<span class="comment-copy">@Chris_Rands See my updated edit, there are many example where the range from 1 to n can't be achieved.</span>
<span class="comment-copy">Hi Peter, it's a neat solution, what's the complexity?</span>
<span class="comment-copy">Should be about O(Esqrt(n)) where E is the total length of all your lists</span>
<span class="comment-copy">I like it! This was more or less what I was looking for, thank you. It looks very similar to what @PaulMcG is proposing on his second solution; I'm now in a dilemma to which answer to check as correct, if any.</span>
<span class="comment-copy">@McGuire Yes, the approach is similar: Where I pick the list with the fewest elements, he picks the element that's in the fewest lists. Since the number of lists is the same as the number of unique elements, those are more or less equivalent, but there might be cases in which the one or the other is faster. My answer provides the full algorithm, though...</span>
<span class="comment-copy">@wwii Yes. (If your point is that the list has a <code>6</code>, but a <code>5</code> would be expected: Well, I do not check whether the numbers are in a certain range, but only whether there are <code>n</code> distinct numbers to be found.)</span>
<span class="comment-copy">@wwii I still don't get your point. OP says that the given lists contain the numbers "from 1 to n", so I'd just take that as a given. If the input is valid, the output will be the numbers from 1 to n, too.</span>
<span class="comment-copy">@wwii Nevermind. :-) Comments can not be downvoted, though, but you can delete your own comments if you like.</span>
<span class="comment-copy">Thanks for the approach Paul, but I'm looking for a new approach that cuts altogether the use of the cartesian product. I'm sure there must be a faster way to solve this, but I'm just not seeing it.</span>
<span class="comment-copy">Hall's marriage problem seems very interesting. I'm still not completely sure however that O(2^N) is the best we can do on this problem, don't you think?</span>
<span class="comment-copy">@McGuire Well, it is already better than trying every possible combination. I lack the mathematical authority to ensure that there is no better algorithm, but Hall's theorem does say "if and only if". However, maybe there is a better implementation to check the condition, with dynamic programming or something else...</span>
<span class="comment-copy">May be better to use the <a href="https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm" rel="nofollow noreferrer">Hopcroft-Karp algorithm</a> to solve the matching problem - this will be O(Esqrt(V)) instead of O(2^V)</span>
<span class="comment-copy">@PeterdeRivaz That sounds like an answer to the question of its own.</span>
<span class="comment-copy">@PeterdeRivaz but isn't the question actually the exact cover problem (for which there is DLX)?</span>
<span class="comment-copy">Thanks Paul, this is more or less what I'm looking for, see my comment to tobias.</span>
<span class="comment-copy">How would you search <code>occurrences</code>? As a graph??</span>
<span class="comment-copy"><code>occurrences</code> is just a glorified dict of sets. The list values to find are the keys, the lists they are in are the values.</span>
