<div class="post-text" itemprop="text">
<p>I have the following class:</p>
<pre><code>class TestClass(object):
def __init__(self, **kwargs):
    for key, value in kwargs.items(): #items return list of dict
        setattr(self, key, value)
</code></pre>
<p>Examplary use:</p>
<pre><code>obj = MessageItem(**{"testkey1":"tval1", "tkey2":"tval2", "tkey3":"tval3"})
</code></pre>
<p>How can I iterate on this structure without knowing the names of the attributes? Python provides us with the built-in method <code>__getattribute__</code>, but I still need to know the name of the requested attribute:</p>
<pre><code>print(obj.__getattribute__("testkey1"))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__dict__</code> attribute holds what you want.
The class has it:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __init__(self, x):
...             self.x = x
...
&gt;&gt;&gt; Foo.__dict__
mappingproxy({'__module__': '__main__', '__init__': &lt;function Foo.__init__ at
0x000001CC1821EEA0&gt;, '__dict__': &lt;attribute '__dict__' of 'Foo' objects&gt;, '__weakref__':
&lt;attribute '__weakref__' of 'Foo' objects&gt;, '__doc__': None})
</code></pre>
<p>And any instance has it as well:</p>
<pre><code>&gt;&gt;&gt; f = Foo(2)
&gt;&gt;&gt; f.__dict__
{'x': 2}
</code></pre>
<p>You should access this attribute through the <code>vars</code> builtin function.
Calling <code>vars(foo)</code> will return <code>foo.__dict__</code>.
See this related post: <a href="https://stackoverflow.com/questions/21297203/use-dict-or-vars">Use <code>__dict__</code> or <code>vars()</code>?</a>.</p>
<p><a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer">Documentation for <code>vars</code></a>:</p>
<blockquote>
<p>vars([object])</p>
<p>Return the <code>__dict__</code> attribute for a module, class, instance, or any other object with a <code>__dict__</code> attribute.</p>
<p>Objects such as modules and instances have an updateable <code>__dict__</code> attribute; however, other objects may have write restrictions on their
  <code>__dict__</code> attributes (for example, classes use a <code>types.MappingProxyType</code> to prevent direct dictionary updates).</p>
<p>Without an argument, <code>vars()</code> acts like <code>locals()</code>. Note, the locals dictionary is only useful for reads since updates to the locals
  dictionary are ignored.</p>
</blockquote>
<hr/>
<p>In addition, I tried and wrote a decorator that might interest you.
This is a class decorator, that adds a <code>initKwargs</code> to the class it decorates.
Besides, it wraps the <code>__init__</code> method of that class as well, so as to have it append the <code>kwargs</code> dictionary it receives to the class' <code>initKwargs</code> attribute.</p>
<pre><code>def class_wrapper(cls):
    cls.initKwargs = []
    f = cls.__init__

    def wrapped_init(instance, **kwargs):
        cls.initKwargs.append(kwargs)
        return f(instance, **kwargs)            
    cls.__init__ = wrapped_init

    return cls

@class_wrapper
class Foo:
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)
</code></pre>
<p>Demonstration:</p>
<pre><code>&gt;&gt;&gt; f1 = Foo()
&gt;&gt;&gt; f2 = Foo(a=1, b=2)
&gt;&gt;&gt; f3 = Foo(a=1, b=2, c=3, d=4)
&gt;&gt;&gt; Foo.initKwargs
[{}, {'a': 1, 'b': 2}, {'a': 1, 'b': 2, 'c': 3, 'd': 4}]
</code></pre>
<p>I find this approach much cleaner that using <code>vars</code>, because you know what you're accessing since you define it yourself.
It gives you more control on the class' behaviour.</p>
</div>
<span class="comment-copy">Why would you want to deliberately put yourself in such a situation instead of storing it as a <code>dict</code> ?</span>
<span class="comment-copy">@JonClements Personaly, i haven't idea, my leader planed this in that way, and i must implement :D</span>
<span class="comment-copy">Well, feel free to tell them it's not good design and it's somewhat dangerous... People will be able to clobber names you've already used and break things and debugging it later on is going to be horrible.</span>
<span class="comment-copy">(Or inversely, you may clobber assignment to a variable they've passed...)</span>
<span class="comment-copy">And just to note (on top of this being a bad idea in most use cases): you wouldn't really want to use <code>obj.__getattribute__("testkey1")</code> - you'd use <code>getattr(obj, 'testkey1')</code> - not only is it easier on the eyes and keyboard, it also allows providing a default value to return if the attribute isn't found.</span>
<span class="comment-copy">Which if you're going to suggest, then suggest using <code>vars(f)</code> - there's little need to access <code>__dict__</code> here directly and it may not always be as expected.</span>
<span class="comment-copy">@JonClements Considering what the doc says about <code>vars</code>, how can it be different from <code>__dict__</code>? I think I remember reading that <code>__dict__</code> was not quite good, but I can't remember why...</span>
<span class="comment-copy">I can't remember <i>exactly</i> off the top of my head... but <code>vars(...)</code> will do the right thing while directly accessing <code>__dict__</code> may fail in cases. Although I'm slightly doubting myself now... but something rings a bell :) Besides - at the very least - not having dunder method access in your code where not necessary is always good.</span>
<span class="comment-copy">@JonClements I found <a href="https://stackoverflow.com/questions/21297203/use-dict-or-vars">this post</a>. So basically the argument is that since Python provides a wrapper for it, it should be accessed through that wrapper instead of directly. It makes sense to me.</span>
<span class="comment-copy">Nice find. Thanks. Now - the only problem with this is that you can't actually tell what arguments were supplied unless you take away the ones that were already there or know you've set... But if the OPs going to take this approach then, well, on their head be it and all that.</span>
