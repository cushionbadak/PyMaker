<div class="post-text" itemprop="text">
<p>I've created several customized classes to transform dataframes, as follows (version simplified):</p>
<pre><code>class class1():
      def _init_(self, a):
          self.dataframe = a

      def __getitem__(self, key):
          return self.dataframe[key]

      def transform(self):
          self.dataframe = (some dataframe computations)
          return self.dataframe


class class2():
      def _init_(self, b):
          self.dataframe = b

      def __getitem__(self, key):
          return self.dataframe[key]

      def transform(self, arg0):
          self.dataframe = (some dataframe computations)
          return self.dataframe
</code></pre>
<p>what I want to do now is to execute these two classes methods in parallel. 
I suppose it should be something like :</p>
<pre><code>import multiprocessing

df1 = class1(a)
pr1 = multiprocessing.Process(target=df1.transform)
df2 = class2(b)
pr1 = multiprocessing.Process(target=df2.transform, kwargs={'arg0' : x})
pr1.start()
pr2.start()
pr1.join()
pr2.join()
</code></pre>
<p>However, after I executing this code, and do</p>
<pre><code>print df1.dataframe
print df2.dataframe
</code></pre>
<p>I observed that <strong>no transformation had been done</strong> at all. (Though according to the computation time, something did happe when called pr1.start() and pr2.start())</p>
<p>Does anyone know what might be the reason? And what will be the solution?</p>
<p>Thanks a lot :)</p>
<p><strong><em>P.s</em></strong>  The next step will be 'merging df1.dataframe and df2.dataframe. So I'd also like to know whether I need another function <em>fun_wait_until_all_process_finished()</em>  and then do pd.merge((df1.dataframe,df2.dataframe))</p>
</div>
<div class="post-text" itemprop="text">
<p>In my opinion, using the <strong><a href="https://docs.python.org/3/library/threading.html" rel="nofollow noreferrer">threading</a></strong> module is the best way to solve this.</p>
<p>For ease of use, you can use a <a href="https://www.python.org/dev/peps/pep-0318/" rel="nofollow noreferrer">decorator</a>:</p>
<pre><code>import threading

def threaded(fn):
    def wrapper(*args, **kwargs):
        threading.Thread(target=fn, args=args, kwargs=kwargs).start()
    return wrapper
</code></pre>
<p>After this is defined, add the decorator to functions/class methods you want to be threaded like this:</p>
<pre><code>@threaded
def transform(self):
  self.dataframe = (some dataframe computations)
  return self.dataframe
</code></pre>
<p>Then just call the function, a thread will be created automatically:</p>
<pre><code>c1 = class1(a)
c2 = class2(b)

c1.transform()
c2.transform()
</code></pre>
</div>
