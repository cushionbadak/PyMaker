<div class="post-text" itemprop="text">
<h2>Introduction to the problem</h2>
<p>Hi, I have recently switched to Python programming language from Mathematica because I would like to make my code portable and more powerful. I studied the <a href="https://docs.python.org/3/howto/functional.html" rel="nofollow noreferrer">Functional Programming HOWTO guide</a> and I started playing around with higher-order functions. </p>
<p>What I find confusing for a newcomer on the functional paradigm of the Python language is the <strong>default behavior</strong>, i.e. the standard execution, of higher-order functions. For example when you apply <code>map()</code> over a sequence you get back a map object (heck see the comments below):</p>
<pre><code>odd = lambda x : x%2!=0
lis = [1, 6, 2, 5, 9, 4]
map(odd, lis)

Out[171]: &lt;map at 0x19e6a228e48&gt;
</code></pre>
<p>Mathematica users would expect to "thread" <code>odd()</code> over a list and the result of the evaluation would be a list of booleans. In python you have to materialize the result using the <code>list()</code> constructor e.g.:</p>
<pre><code>list(map(odd, [1, 6, 2, 5, 9, 4]))

Out[172]: [True, False, False, True, True, False]
</code></pre>
<h2>What I am missing</h2>
<p>One of the things I am missing in Python is a list-able attribute for thread-able functions. Indeed this is a <a href="http://reference.wolfram.com/language/ref/Listable.html" rel="nofollow noreferrer">core feature in Wolfram Mathematica language</a>. But the beautiful thing in Python is that <strong>everything is an object</strong> (everything is an expression in Wolfram Language) including functions therefore I can change how function objects behave by passing a keyword argument to indicate whether I want the function to return a generator/iterator or the full materialized result.</p>
<h2>Specifications for a full answer</h2>
<p>So this is the question to ask here for advanced core developers of the Python Language. Continuing the example above, <code>odd()</code> is a function that takes one argument, if <code>PyFunctionObject</code> had, let's say, a <code>materialize</code> and <code>listable</code> attribute I would expect to write</p>
<pre><code>odd.listable = True
odd.materialize = True
odd(1, 6, 2, 5, 9, 4)

Out[172]: [True, False, False, True, True, False]

odd(6)

Out[173]: False
</code></pre>
<p>Or switch to the default behavior you get now when you map() ...</p>
<pre><code>odd.listable = True
odd.materialize = False
odd(1, 6, 2, 5, 9, 4)

Out[31]: &lt;generator object Listable.__call__.&lt;locals&gt;.&lt;genexpr&gt; at 0x000001F3BBF1CC50&gt;
</code></pre>
<h2>References</h2>
<p>I have searched stackoverflow for similar questions and the closest I have found is this one: <a href="https://stackoverflow.com/questions/12175031/automatically-use-list-comprehension-map-recursion-if-a-function-is-given-a-li">Automatically use list comprehension/map() recursion if a function is given a list</a>. The answer of David Robinson is based on decorators. Back in 1999 Michael Vanier posted also this answer <a href="https://mail.python.org/pipermail/python-list/1999-May/007878.html" rel="nofollow noreferrer">here</a> which is a class based solution of this problem.</p>
<p>My question is slightly different because I am asking how you can tweak the function object at a low level so that you get the desirable behavior I wrote about. I am also arguing here that this feature will make functional programming in Python easier for newcomers and a lot more fun, For a start, they do not need to learn about generators and iterators. If there is already such discussion in the road map to Python please let me know.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is already a perfectly Pythonic way to "materialize" lazy constructs. Wrap it in <code>list()</code>. The <code>list</code> constructor takes any sequence and converts it to a list.</p>
<pre><code>&gt;&gt;&gt; odd(1, 6, 2, 5, 9, 4)
&lt;generator object odd at ...&gt;

list(odd(1, 6, 2, 5, 9, 4))
[True, False, False, True, True, False]
</code></pre>
<p>The idea of setting "switches" on a function to change its behavior means that functions can no longer even possibly be "pure." It's neither Pythonic nor functional.</p>
</div>
<div class="post-text" itemprop="text">
<p>This answer does not fully cover my question because I am asking how to modify the behavior of the core function type (is it PyFunctionObject?). Nevertheless, I thought to share it with the rest of the users because I learned a lot going through this piece of code and it is the closest I could reach as an answer. It is based on an old <a href="https://mail.python.org/pipermail/python-list/1999-May/007878.html" rel="nofollow noreferrer">post of Michael Vanier</a> back in 1999. 
Here it goes:</p>
<pre><code>class Listable(object):
    """
    Listable functions, are functions which automatically map themselves over a sequence.  
    This idea is borrowed from Mathematica.
    """

    def __init__(self, f, materialize=True):
        self.func  = f
        self.gen = not materialize

    def __call__(self, *args):
        # check the number of arguments
        if len(args)==1:
            # return a scalar
            return self.func(*args)
        elif self.gen:
            # return a generator 
            return (self.func(x) for x in args)
        else:
            # return an iterator
            return [self.func(x) for x in args]
</code></pre>
</div>
<span class="comment-copy">I'm not sure I understand what you're asking; something like a syntax change to the language? Note that <code>map</code> <a href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">isn't even really liked by the creator of Python</a>. Python would have to work hard to be any easier than it already is (I'm not sure what that would look like) and it's not just for mathematical work so the features have to support a huge range of use cases. I think you're approaching this with the wrong mindset; you're probably not approaching your problem in a pythonic way.</span>
<span class="comment-copy">"For example when you apply map() over a sequence you get back a generator" No, you <b>do not</b>. You get a <code>map</code> object.</span>
<span class="comment-copy">How about the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html" rel="nofollow noreferrer"><code>vectorize</code></a> in <code>numpy</code>?</span>
<span class="comment-copy">@roganjosh yes you are right I think functional programming could become more fun and easier with some syntactic sugar.  So in Mathematica if the function is listable you can do fun@lis or even lis // fun, i.e. postfix and prefix notation. Now I think in terms of Composability that makes it far more easier to test and write cleaner code</span>
<span class="comment-copy">Ah, no, I disagree that this makes code easier to test. Python is not "complete" in terms of having all of this kind of syntactic sugar; it's a general-purpose language. However, it's supported by a <i>huge</i> number of libraries that build on this foundation and provide basically exactly what you suggest so that projects that need such functionality have access to it.</span>
<span class="comment-copy">I fully agree with that but it may be sensible to explain why this would not be pythonic.</span>
<span class="comment-copy">Because it's usually something you'd do with an argument, if you were going to do it at all.</span>
<span class="comment-copy">Hi Kindall, in Mathematica all these functions are immutable and listability is an attribute that you can set on a function. Add to this the generall impression that I got from Python is that it is a language with a lot of freedom and at the same time responsibility from experienced users to code at the right direction. That said I am not a core developer and obviously I cannot judge whether such a feature at a low level could be hazardous</span>
<span class="comment-copy">@Athanassios I fundamentally agree with kindall, such a feature is neither Pythonic nor functional - there seems to be some sort of disconnect between the claim that in Mathematica, functions are immutable, and yet, you can set attributes on the function...</span>
<span class="comment-copy">@juanpa.arrivillaga first thank you indeed both of you for the lessons in Python ;-) I am really trying to understand the issue here. It seems that there is a clear seperation between language constructs i.e. generators, iterators, functions and built-in sequence types, i.e. container objects correct ?</span>
<span class="comment-copy">Ok, this seems like it's already covered by the <a href="http://www.numpy.org/" rel="nofollow noreferrer">numpy</a> library. You mention "threadable" in your question, but actually I don't think that it's the same as what you're expecting in Python due to the Global Interpreter Lock. Numpy will allow you to vectorize calculations in near-C-time. If you're working with numbers, you probably want to use that, not some construct like you've made here.</span>
<span class="comment-copy">This would be fine if you want to provide a similar interface as what is available in Mathematica, but I definitely do not think it should become part of the core language. Python and Mathematica are not similar languages at all. But Python is versatile and extendable enough to provide this for those that want it.</span>
<span class="comment-copy">Anyway, Python is <i>not meant to be a functional language</i>. At it's core, it is very very imperative.</span>
<span class="comment-copy">Also, your listable class <i>returns a <b>list</b>, not an iterator</i>. Lists are <i>iterable</i> but they are <b>not iterators</b>. Try to see what the interpreter tells you when you do <code>next([1,2,3])</code></span>
<span class="comment-copy">@juanpa.arrivillaga would you call list an iterable sequence type then ? And by the way my listable class returns also a generator which is an iterator if materialize=False is that correct ;-)</span>
