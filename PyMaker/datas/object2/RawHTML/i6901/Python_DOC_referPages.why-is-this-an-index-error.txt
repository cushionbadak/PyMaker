<div class="post-text" itemprop="text">
<p>This is my first post, so I apologize if this has been answered previously. I have tried to look through the Python 3 documentation on string formatting and lists, and reviewed similar formatting questions here on SO. </p>
<p>I want to take the string (data1), break it into a list (bigData), and print out a statement using the list items. <em>Eventually, the idea would be to read in a csv file, break it up, and print out a response, but I've tried to simplify the process since there's an error.</em></p>
<blockquote>
<p>"Hello, John Doe. Your current balance is $53.44." </p>
</blockquote>
<p>However, I'm not sure why the following code is throwing an IndexError, much less a tuple index.</p>
<pre><code>data1 = "John,Doe,53.44"
bigData = data1.split(",")
bigData[-1] = float(bigData[-1])

print(bigData) # test - []'s indicate a list, not tuple?

greeting = "Hello, {} {}. Your current balance is ${}."

print(greeting.format(bigData))
</code></pre>
<p>My guess is that bigData is heterogeneous, which implies a tuple. If I substitute a string value instead of 53.44 (so data1 and bigData are homogeneous), it throws the same error.</p>
<pre><code>data1 = "John,Doe,random"
bigData = data1.split(",")

print(bigData) # test - []'s indicate a list, not tuple?

greeting = "Hello, {} {}. Your current balance is {}."

print(greeting.format(bigData))
</code></pre>
<p>However, if I convert the original to Python 2.x string formatting, it formats correctly without an error.</p>
<pre><code>data1 = "John,Doe,53.44"
bigData = data1.split(",")
bigData[-1] = float(bigData[-1])

print(bigData) # test - []'s indicate a list, not tuple?

greeting = "Hello, %s %s. Your current balance is $%.2f."

print(greeting % tuple(bigData))
</code></pre>
<ol>
<li>Why is it converting my string to a tuple?</li>
<li>How do I write this work in Python 3?</li>
</ol>
<p>Thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use the splat (<code>*</code>) to unpack your arguments (your <code>format</code> string wants three arguments but you only give it one, a list containter).</p>
<pre><code>print(greeting.format(*bigData))
</code></pre>
<p>Also, you may want:</p>
<pre><code>bigData[-1] = str(round(float(bigData[-1]), 2))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#str.format" rel="nofollow noreferrer"><code>str.format</code></a> method takes positional arguments, not a single list. You need to unpack your list <code>bigData</code> using the <code>*</code> operator:</p>
<pre><code>data1 = "John,Doe,random"
bigData = data1.split(",")

print(bigData)  # test - []'s indicate a list, not tuple?

greeting = "Hello, {} {}. Your current balance is {}."

print(greeting.format(*bigData))  # here's the change
</code></pre>
<p>You're correct that <code>bigData</code> is a list, not a tuple, <code>str.split</code> returns a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>str.split()</code> method returns a list, by definition.</p>
<p>I think you've misunderstood something you've read - heterogeneous vs. homogeneous refer to <em>typical use cases</em> of tuples vs. lists.  Having the types of all the elements match or not does not magically cause the container to change to the other type!</p>
</div>
<div class="post-text" itemprop="text">
<p>I can see how this is surprising, though what surprises me is that the traceback doesn't show that the exception occurs in the <code>format</code> call. </p>
<p>Python's lists can be heterogenous just like tuples; this is because the common type they store is object references, which all things in Python are. The tuple is actually the argument list to the <code>format</code> method, in this case <code>(bigData,)</code>. It ran out of arguments when looking for things to format, since you had three <code>{}</code> placeholders but only one argument (the list <code>bigData</code>). You can use <code>greeting.format(*bigData)</code> to unpack the list and use its contents as arguments. </p>
<p>The <code>%</code> formatting doesn't encounter this error because it actually expects a tuple (or one item) in the right operand. </p>
<p>A more idiomatic and legible approach might actually be to go to the <code>csv</code> module already:</p>
<pre><code>import csv, io
data1 = "John,Doe,random"
for row in csv.DictReader(io.StringIO(data1),
        "givenname surname balance".split()):
    greeting = "Hello, {givenname} {surname}. Your current balance is {balance}."
    print(greeting.format(**row))
</code></pre>
<p>This lets us assign meaningful names to the columns, including reordering them in the format string if needed. I've left out the float conversion, and by the way, <code>decimal.Decimal</code> may be better for that use. </p>
</div>
<span class="comment-copy">Probably you need to unpack the list/tuple, cause format() expects that you'll do that: <code>greeting.format(*bigData)</code> should help. <i>Edit:</i> Format will try to convert each arg to a string first, so it converts your entire list to a string and then complains about insufficient number of args. You can see that by executing '{}'.format(bigData) for example.</span>
<span class="comment-copy">Why don't you do <code>"Hello, {} {}. Your current balance is {}.".format(X, Y)</code>? Also, what is your exact error message?</span>
<span class="comment-copy">I'm pretty new, so I didn't even know unpacking was a thing. I gave Alexander the answer because that's what got the code working. Yann did a great job of explaining why that works and where I was confused.  Thanks, everyone!</span>
<span class="comment-copy">Reference to <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer">Unpacking Argument Lists</a> from the <a href="https://docs.python.org/3/tutorial/index.html" rel="nofollow noreferrer">Python Tutorial</a>.</span>
<span class="comment-copy">A lot of the comments below help to expand on why this works the way it does, but this is what I needed.  And thanks for the suggestions on rounding bigData!</span>
<span class="comment-copy">Being new to python, I'm sure I've misunderstood something. However, my thought was that since python dynamically types, I wondered if it assumed it was a tuple since it was heterogeneous.</span>
<span class="comment-copy">There is never any assumption of type.  Whatever created it, explicitly created either a list or a tuple (or some other type).</span>
<span class="comment-copy">Minor quibbles:  "The % formatting doesn't encounter this error because it actually expects a sequence in the right operand."  Not a sequence.  A tuple.  <code>"%s %s" % [1, 2]</code> raises a <code>TypeError</code>.  Also when there is only one item to be formatted it will accept either a one item tuple or the item by itself.</span>
<span class="comment-copy">Thank you for the detail. I figured it had something to do with format, but I didn't understand what was going on.  Also, I agree with your adding names to the formatting. That's one reason I wanted to figure this out in python 3 syntax - it reads a lot more clearly.</span>
