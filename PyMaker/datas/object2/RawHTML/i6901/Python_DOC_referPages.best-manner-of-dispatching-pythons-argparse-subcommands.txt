<div class="post-text" itemprop="text">
<p>I am playing around with Python's <code>argparse</code> module in order to get a rather complicated and large sub-commands structure. So far, the arguments parse goes pretty well and everything works fine but I am looking for a better way to manage how sub-commands are executed.</p>
<p>Here is an example of my dummy/playaround application:</p>
<pre><code>def a_func(cmd_args):
    print(cmd_args)


def b_func(cmd_args):
    print(cmd_args)


CMD_DISPATCHER = {
    'a': a_func,
    'b': b_func
}


def parse_commands():
    # Create top-level parser
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='subcmd_name')

    # Create parser for the "a" sub-command
    parser_a = subparsers.add_parser('a')
    parser_a.add_argument('-bar', type=int)

    # Create parser for the "b" sub-command
    parser_b = subparsers.add_parser('b')
    parser_b.add_argument('-foo', type=int)

    args = parser.parse_args()

    CMD_DISPATCHER[args.subcmd_name](args)


def main():
    parse_commands()


if __name__ == '__main__':
    main()
</code></pre>
<p>As you can see, here I use a simple <code>dict</code> (<code>CMD_DISPATCHER</code>) as a map relating the sub-command name to its function.</p>
<p>As I said, this is just a simple example of what I want to achieve but the real project will have many nested sub-commands so I would like a better way to manage those several sub-commands.</p>
<p><strong>Do you know a better/more-professional way to do this?</strong> </p>
</div>
<div class="post-text" itemprop="text">
<p>OK, after some more research I have found a good way that fits my needs: <code>set_defaults</code>. I have used this function earlier but always to set default existing default argument values. I did not notice the clear example that <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer">argparse documentation</a> provides:</p>
<pre><code>&gt;&gt;&gt; # sub-command functions
&gt;&gt;&gt; def foo(args):
...     print(args.x * args.y)
...
&gt;&gt;&gt; def bar(args):
...     print('((%s))' % args.z)
...
&gt;&gt;&gt; # create the top-level parser
&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; subparsers = parser.add_subparsers()
&gt;&gt;&gt;
&gt;&gt;&gt; # create the parser for the "foo" command
&gt;&gt;&gt; parser_foo = subparsers.add_parser('foo')
&gt;&gt;&gt; parser_foo.add_argument('-x', type=int, default=1)
&gt;&gt;&gt; parser_foo.add_argument('y', type=float)
&gt;&gt;&gt; parser_foo.set_defaults(func=foo)
&gt;&gt;&gt;
&gt;&gt;&gt; # create the parser for the "bar" command
&gt;&gt;&gt; parser_bar = subparsers.add_parser('bar')
&gt;&gt;&gt; parser_bar.add_argument('z')
&gt;&gt;&gt; parser_bar.set_defaults(func=bar)
&gt;&gt;&gt;
&gt;&gt;&gt; # parse the args and call whatever function was selected
&gt;&gt;&gt; args = parser.parse_args('foo 1 -x 2'.split())
&gt;&gt;&gt; args.func(args)
2.0
&gt;&gt;&gt;
&gt;&gt;&gt; # parse the args and call whatever function was selected
&gt;&gt;&gt; args = parser.parse_args('bar XYZYX'.split())
&gt;&gt;&gt; args.func(args)
((XYZYX))
</code></pre>
<p>As you can see the line <code>parser_bar.set_defaults(func=bar)</code> sets a new variable to <code>parser_bar</code> arguments. In this case <code>bar</code> is a function that is eventually used as the sub-command executor in line <code>args.func(args)</code>.</p>
<p>I hope this helps someone in the future.</p>
</div>
<span class="comment-copy">in <a href="https://pypi.python.org/pypi/ruamel.std.argparse" rel="nofollow noreferrer">ruamel.std.argparse</a> I use decorators to register methods of a <code>Cmd</code> class into subparsers. Additional decorators on those methods are used for options. There is also a special method that defines "global" options (applying to all subparsers).</span>
