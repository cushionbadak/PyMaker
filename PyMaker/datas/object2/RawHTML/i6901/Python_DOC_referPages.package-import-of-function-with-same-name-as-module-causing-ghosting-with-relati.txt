<div class="post-text" itemprop="text">
<p>I have a package <code>foo_package</code> organized like this:</p>
<pre><code>foo/
    setup.py
    README.md
    ...
    foo_package/
        __init__.py
        bar.py
        baz.py
</code></pre>
<p>The module <code>bar.py</code> defines one 'public' function also named <code>bar</code>, and both the module and the function benefit hugely from being named exactly <code>bar</code>. <code>bar.py</code> also defines some 'private' helper functions.</p>
<p>Inside of <code>__init__.py</code> I make a top-level import of <code>bar.bar</code> so that <code>foo_package.bar</code> will be the API of the overall package.</p>
<pre><code># __init__.py:
from .bar import bar
</code></pre>
<p>But now I am getting bitten by relative imports.</p>
<p>First, if I am debugging or working in an interactive prompt like IPython,  naively pasting <code>from .bar import bar</code> doesn't work. I can get around this by launching IPython inside <code>foo_package</code> and using <code>from foo_package import bar</code> instead.</p>
<p>But then how can I import the <code>bar</code> <em>module</em> and not the exported <code>bar</code> function? E.g. variants of </p>
<pre><code>from foo_package import bar
import foo_package.bar as bar
</code></pre>
<p>etc., all import the <em>function</em> <code>bar</code>, meanwhile any time that <code>bar.py</code> also contains a relative import to another module, such as </p>
<pre><code># inside bar.py
from .baz import helper_function
</code></pre>
<p>then the plain</p>
<pre><code>import bar
</code></pre>
<p>won't work either.</p>
<p>The package-level 'ghosting' of <code>bar</code> <em>the module</em> with <code>bar</code> <em>the function</em> is the correct behavior. How can I maintain this while also being able to import <code>bar</code> <em>the module</em> in local development (especially in an interactive environment like IPython)?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you really do have a compelling reason to keep the shadowing, you can access the module object through <a href="https://docs.python.org/3/library/sys.html#sys.modules" rel="nofollow noreferrer"><code>sys.modules</code></a>:</p>
<pre><code>import sys
import foo_package.bar

bar_module = sys.modules['foo_package.bar']
</code></pre>
<p>There's also <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="nofollow noreferrer"><code>importlib.import_module</code></a>:</p>
<pre><code>import importlib

bar_module = importlib.import_module('foo_package.bar')
</code></pre>
</div>
<span class="comment-copy">The inability to paste the relative import in e.g. IPython is also a pain point. There are benefits to using explicit relative imports when designing a package, but obvs you are going to want to paste code around and test things interactively when working on the development of that package. Have to adjust the actual import statements copied from a file-under-test to artificially use <code>sys.modules</code> or <code>importlib</code> temporarily adds a lot of overhead.</span>
<span class="comment-copy">@ely: If you want imports that work the same no matter what module they're run in or whether they're run in <code>__main__</code>, you want absolute imports. Copying relative imports out of the module they're relative to isn't going to work. (None of the code in this answer is intended to replicate the behavior of <code>from .bar import bar</code>, since that imports the function, and you asked for the module. If you want an import that always imports the function, that's <code>from foo_package.bar import bar</code>.)</span>
<span class="comment-copy">I understand. I'm saying that I want to have my cake and eat it too. I don't like that there isn't an easy way to automate relative imports from the working directory. There is a design benefit to using explicit relative imports because you know that the module is not a top-level package in advance. And less risk of a name conflict with a top level installed module (esp. by accident after shipping the code). This is worth something, and so it's slightly disappointing that the only answer is to sacrifice this and use absolute imports.</span>
