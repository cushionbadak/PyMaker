<div class="post-text" itemprop="text">
<p>I want to write a function that compares the first element of this list with the last element of this list, the second element of this list with the second last element of this list, and so on. If the compared elements are the same, I want to add the element to a new list. Finally, I'd like to print this new list.</p>
<p>For example,</p>
<pre><code>&gt;&gt;&gt; f([1,5,7,7,8,1])
[1,7]
&gt;&gt;&gt; f([3,1,4,1,5]
[1,4]
&gt;&gt;&gt; f([2,3,5,7,1,3,5])
[3,7]
</code></pre>
<p>I was thinking to take the first (i) and last (k) element, compare them, then raise i but lower k, then repeat the process. When i and k 'overlap', stop, and print the list. I've tried to visualise my thoughts in the following code:</p>
<pre><code>def f(x): 
    newlist=[]
    k=len(x)-1
    i=0
    for j in x:
        if x[i]==x[k]:
            if i&lt;k:
                newlist.append(x[i])
        i=i+1
        k=k-1
    print(newlist)
</code></pre>
<p>Please let me know if there are any errors in my code, or if there is a more suitable way to address the problem.</p>
<p>As I am new to Python, I am not very good with understanding complicated terminology/features of Python. As such, it would be encouraged if you took this into account in your answer.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a conditional list comprehension with <code>enumerate</code>, comparing the element <code>x</code> at index <code>i</code> to the element at index <code>-1-i</code> (<code>-1</code> being the last index of the list):</p>
<pre><code>&gt;&gt;&gt; lst = [1,5,7,7,8,1]
&gt;&gt;&gt; [x for i, x in enumerate(lst[:(len(lst)+1)//2]) if lst[-1-i] == x]
[1, 7]
&gt;&gt;&gt; lst = [3,1,4,1,5]
&gt;&gt;&gt; [x for i, x in enumerate(lst[:(len(lst)+1)//2]) if lst[-1-i] == x]
[1, 4]
</code></pre>
<p>Or, as already suggested in other answers, use <code>zip</code>. However, it is enough to slice the first argument; the second one can just be the <code>reversed</code> list, as <code>zip</code> will stop once one of the argument lists is finished, making the code a bit shorter.</p>
<pre><code>&gt;&gt;&gt; [x for x, y in zip(lst[:(len(lst)+1)//2], reversed(lst)) if x == y]
</code></pre>
<p>In both approaches, <code>(len(lst)+1)//2</code> is equivalent to <code>int(math.ceil(len(lst)/2))</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>maybe you want something like for even length of list:</p>
<pre><code>&gt;&gt;&gt; r=[l[i] for i in range(len(l)/2) if l[i]==l[-(i+1)]]
&gt;&gt;&gt; r
[3]
&gt;&gt;&gt; l=[1,5,7,7,8,1]
&gt;&gt;&gt; r=[l[i] for i in range(len(l)/2) if l[i]==l[-(i+1)]]
&gt;&gt;&gt; r
[1, 7]
</code></pre>
<p>And for odd length of list :</p>
<pre><code>&gt;&gt;&gt; l=[3,1,4,1,5]
&gt;&gt;&gt; r=[l[i] for i in range(len(l)/2+1) if l[i]==l[-(i+1)]]
&gt;&gt;&gt; r
[1, 4]
</code></pre>
<p>so you can create a function :</p>
<pre><code>def myfunc(mylist):
     if (len(mylist) % 2 == 0):
            return [l[i] for i in range(len(l)/2) if l[i]==l[-(i+1)]]
     else:
            return [l[i] for i in range(len(l)/2+1) if l[i]==l[-(i+1)]]
</code></pre>
<p>and use it this way :</p>
<pre><code>&gt;&gt;&gt; l=[1,5,7,7,8,1]
&gt;&gt;&gt; myfunc(l)
[1, 7]
&gt;&gt;&gt; l=[3,1,4,1,5]
&gt;&gt;&gt; myfunc(l)
[1, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What you can do is zip over the first half and the second half reversed and use list comprehensions to build a list of the same ones:</p>
<pre><code>[element_1 for element_1, element_2 in zip(l[:len(l)//2], reversed(l[(len(l)+1)//2:])) if element_1 == element_2]
</code></pre>
<p>What happens is that you take the first half and iterate over those as element_1, the second half reversed as element_2 and then only add them if they are the same:</p>
<pre><code>l = [1, 2, 3, 3, 2, 4]
l[:len(l)//2] == [1, 2, 3]
reversed(l[(len(l)+1)//2:])) == [4, 2, 3]
1 != 4, 2 == 2, 3 == 3, result == [2, 3]
</code></pre>
<p>If you also want to include the middle element in the case of an odd list, we can just extend our lists to both include the middle element, which will always evaluate as the same:</p>
<pre><code>[element_1 for element_1, element_2 in zip(l[:(len(l) + 1)//2], reversed(l[len(l)//2:])) if element_1 == element_2]

l = [3, 1, 4, 1, 5]
l[:len(l)//2] == [3, 1, 4]
reversed(l[(len(l)+1)//2:])) == [5, 1, 4]
3 != 5, 1 == 1, 4 == 4, result == [1, 4]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is my solution:</p>
<pre><code>[el1 for (el1, el2) in zip(L[:len(L)//2+1], L[len(L)//2:][::-1]) if el1==el2]
</code></pre>
<p>There is a lot going on, so let me explain step by step:</p>
<ul>
<li><code>L[:len(L)//2+1]</code> is the first half of the list plus an extra element (which is useful for lists of odd lengths)</li>
<li><code>L[len(L)//2:][::-1]</code> is the second half of the list, reversed (<code>[::-1]</code>)</li>
<li><a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow noreferrer">zip</a> creates a list of pairs from two lists. it stops at the end of the shortest list. We use this in the case the length of the list is even, so the extra term in the first half is neglected</li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Comprehensions.html" rel="nofollow noreferrer">List comprehension</a> essentially equivalent to a for loop, but useful to create a list "on the fly". It will return an element only if the if condition is true, otherwise it will pass.</li>
</ul>
<p>You can easily modify the solution above if you are interested in the <em>indexes</em> (of the first half) where the match occurs:</p>
<pre><code>[idx for idx, (el1, el2) in enumerate(zip(L[:len(L)//2+1], L[len(L)//2:][::-1])) if el1==el2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the following which leverages from <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow noreferrer"><strong><code>zip_longest</code></strong></a>:</p>
<pre><code>from itertools import zip_longest

def compare(lst):
    size = len(lst) // 2
    return [y for x, y in zip_longest(lst[:size], lst[-1:size-1:-1], fillvalue=None) if x == y or x is None]

print(compare([1, 5, 7, 7, 8, 1]))      # [1, 7]
print(compare([3, 1, 4, 1, 5]))         # [1, 4]
print(compare([2, 3, 5, 7, 1, 3, 5]))   # [3, 7]
</code></pre>
<hr/>
<p><strong>On <code>zip_longest</code></strong>:</p>
<p>Normally, <code>zip</code> stops <code>zip</code>ping when one of its iterators run out. <code>zip_longest</code> does not have that limitation and it simply keeps on <code>zip</code>ping by adding <em>dummy</em> values.</p>
<p>Example:</p>
<pre><code>list(zip([1, 2, 3], ['a']))                         # [(1, 'a')]
list(zip_longest([1, 2, 3], ['a'], fillvalue='z'))  # [(1, 'a'), (2, 'z'), (3, 'z')]
</code></pre>
</div>
<span class="comment-copy">Iterating over a sequence yields elements, not indexes.</span>
<span class="comment-copy">@IgnacioVazquez-Abrams I see! I've edited my code to fix this.</span>
<span class="comment-copy">why your second example returns [4] as well, but the third example does not return [7]? (in both cases they are the elements "at the center" of the list)</span>
<span class="comment-copy">@FLab fixed, thanks.</span>
<span class="comment-copy">fails for <code>[3, 1, 4, 1, 5]</code></span>
<span class="comment-copy">@Ev.Kounis Yup, off-by-one for odd-numbered lists. Fixed.</span>
<span class="comment-copy">I imagine OP would want one solution that solves all problems.</span>
<span class="comment-copy">Yes sure I have completed my post</span>
<span class="comment-copy">yes but not quite.. See my answer.</span>
<span class="comment-copy">Good point, I assumed that one didn't count. I'll edit it</span>
<span class="comment-copy">Could you explain what fillvalue and zip_longest do? I am not familiar with itertools.</span>
<span class="comment-copy">@Jazzachi Added a link to the documentation and an example. It is really easy to understand.</span>
<span class="comment-copy">No need for <code>zip_longest</code> with <code>size = (len(lst) + 1) // 2</code> and <code>zip(lst[:size], lst[-1:size-2:-1])</code></span>
