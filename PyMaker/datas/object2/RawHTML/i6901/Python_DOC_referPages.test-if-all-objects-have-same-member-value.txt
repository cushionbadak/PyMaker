<div class="post-text" itemprop="text">
<p>I have a simple class in <a class="post-tag" href="/questions/tagged/python" rel="tag" title="show questions tagged 'python'">python</a>:</p>
<pre><code>class simple(object):
    def __init__(self, theType, someNum):
        self.theType = theType
        self.someNum = someNum
</code></pre>
<p>Later on in my program, I create multiple instantiations of this class, i.e.:</p>
<pre><code>a = simple('A', 1)
b = simple('A', 2)
c = simple('B', 3)
d = simple('B', 4)
e = simple('C', 5)

allThings = [a, b, c, d, e] # Fails "areAllOfSameType(allThings)" check

a = simple('B', 1)
b = simple('B', 2)
c = simple('B', 3)
d = simple('B', 4)
e = simple('B', 5)

allThings = [a, b, c, d, e] # Passes "areAllOfSameType(allThings)" check
</code></pre>
<p>I need to test if all of the elements in <code>allThings</code> have the same value for simple.theType. How would I write a generic test for this, so that I can include new "types" in the future (i.e. <code>D</code>, <code>E</code>, <code>F</code>, etc) and not have to re-write my test logic? I can think of a way to do this via a histogram, but I figured there's a "pythonic" way to do this.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just compare each object with the first item's type, using the <a href="https://docs.python.org/3.6/library/functions.html#all" rel="nofollow noreferrer"><code>all()</code></a> function:</p>
<pre><code>all(obj.theType == allThings[0].theType for obj in allThings)
</code></pre>
<p>There will be no IndexError if the list is empty, too.</p>
<p><code>all()</code> short-circuits, so if one object is not the same type as the other, the loop breaks immediately and returns False.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use an <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">itertools recipe for this: <code>all_equal</code></a> (copied verbatim):</p>
<pre><code>from itertools import groupby

def all_equal(iterable):
    "Returns True if all the elements are equal to each other"
    g = groupby(iterable)
    return next(g, True) and not next(g, False)
</code></pre>
<p>Then you could call it with a generator expression that accesses the <code>theType</code> attribute:</p>
<pre><code>&gt;&gt;&gt; allThings = [simple('B', 1), simple('B', 2), simple('B', 3), simple('B', 4), simple('B', 5)]
&gt;&gt;&gt; all_equal(inst.theType for inst in allThings)
True

&gt;&gt;&gt; allThings = [simple('A', 1), simple('B', 2), simple('B', 3), simple('B', 4), simple('B', 5)]
&gt;&gt;&gt; all_equal(inst.theType for inst in allThings)
False
</code></pre>
<p>Given that it is actually put as recipe in the Python documentation seems like it's probably one of the best (or at least recommended) ways to solve this kind of problem.</p>
</div>
