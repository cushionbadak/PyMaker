<div class="post-text" itemprop="text">
<p>My equation in a loop is long. I would like to define a range obviously before going to substitute it into the equation line. </p>
<p>Here is my loop. <code>k</code> represents a range I want to use in the equation</p>
<pre><code>    k = 0
    char_num = np.array([196, 191, 122])

    for p in xrange(3):
        # k = "k:(char_num[p]+ k)" # here is the range I which to use

        ## below is the equation which is quite cluttering. 
        H[k,:] = (H[k,:]/(2)) * \
                    (( np.sqrt((sum(W[:,k]))**2 + \
                    (4*sum((V[:,:].T*W[:,k]).T/np.dot(W[:,:],H[:,:]))) )))


        # k += char_num[p]
</code></pre>
<p>Is it possible to define k as a range as pseudocode shown?</p>
</div>
<div class="post-text" itemprop="text">
<p>We could generate those start, stop indices with <code>cumsum</code> on <code>char_num</code> and then use those within the loop for slicing <code>H</code>, like so -</p>
<pre><code>s = np.r_[0,char_num.cumsum()]
for i,j in zip(s[:-1], s[1:]): 
    H[i:j,:] = ...
</code></pre>
<p>Sample run -</p>
<pre><code>In [18]: char_num = np.array([196, 191, 122])

In [19]: s = np.r_[0,char_num.cumsum()]
    ...: for i,j in zip(s[:-1], s[1:]): 
    ...:     print(i,j) # print start, stop indices
    ...:     
(0, 196)
(196, 387)
(387, 509)
</code></pre>
<p>If you actually need the range as an array for some processing other than for slicing, we can use <code>range(i,j)</code> or <code>np.arange(i,j)</code> within the loop. We can also use that range for slicing, but that would force a copy and would slow things down.</p>
<p>Alternatively, we can use a slice notation there, like so -</p>
<pre><code>slice0 = slice(i,j)
H[slice0] = ... # equivalent to H[i:j], i.e. H[i:j,:]
</code></pre>
</div>
<span class="comment-copy">It looks like you mean defining a <i>slice</i>, in which case: <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#slice</a></span>
<span class="comment-copy"><code>k_arr = char_num + np.arange(len(char_num))</code> and then iterate on <code>k_arr</code> : <code>for k in k_arr</code>?</span>
<span class="comment-copy">@Divakar In that case <code>k</code> is a single number. I want to have <code>H[0:196,:]</code> for the first loop, <code>H[196:387,:]</code> for the second... So <code>k</code> has to be a range?</span>
<span class="comment-copy">@jonrsharpe Thanks. I don't know what I already used is called as slice. Can we make slice as variable then?</span>
<span class="comment-copy">It takes me a while for wrapping around your idea. It's cool. Thanks so much. I make <code>k = zip(s[:-1], s[1:])</code> and substitute into <code>H</code> as <code>H[k[p],:]</code> in <code>for p in xrange(3)</code>. Let me ask you another question. Do you think this will be slow if my <code>char_num</code> is super long? Or what is the fastest way here?</span>
<span class="comment-copy">@Jan If you want to make it faster, use <code>s = np.concatenate(( [0], char_num.cumsum() ))</code>. That's the fastest way I know of on the iterating part. On the sum-reductions, i.e. RHS of <code>H[k,:] = </code>, it seems we can optimize further.</span>
