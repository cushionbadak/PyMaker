<div class="post-text" itemprop="text">
<p>I want to create a set of <code>namedtuple</code> in python, with the ability to add elements dynamically using the union operation.</p>
<p>The following code snippet creates a <code>set</code> of <code>namedtuple</code>, which is behaving nicely.</p>
<pre><code>from collections import namedtuple

B = namedtuple('B', 'name x')

b1 = B('b1',90)
b2 = B('b2',92)
s = set([b1,b2])
print(s)
</code></pre>
<p>which prints </p>
<pre><code>{B(name='b1', x=90), B(name='b2', x=92)}
</code></pre>
<p>Now if I create another <code>namedtuple</code> and add it to my <code>set</code> with the <code>union</code> operations it is not behaving as expected.</p>
<pre><code>b3 = B('b3',93)
s = s.union(b3)
print(s)
</code></pre>
<p>The code snippet prints the following output.</p>
<pre><code>{93, B(name='b1', x=90), B(name='b2', x=92), 'b3'}
</code></pre>
<p>The expected output should be:</p>
<pre><code>{B(name='b1', x=90), B(name='b2', x=92), B(name='b3', x=93)}
</code></pre>
<p>Am I mis-understanding the API?
Both python2 and 3 are showing the same behaviour.  </p>
</div>
<div class="post-text" itemprop="text">
<p><code>union</code> expects a set (or a list or another iterable), but you pass a named tuple, which is an iterable by itself, but it provides values, so you merge the set with the values. Try this:</p>
<pre><code>s = s.union({b3})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A <code>namedtuple</code> instance is an iterable of items. <code>set.union</code> simply merges the current set with the items in the <code>namedtuple</code>. </p>
<p>However, what you want is put the <code>namedtuple</code> in another container/iterable, so the merge is done with the item (the <code>namedtuple</code>) contained in the new parent iterable:</p>
<pre><code>s.union((b3,))
</code></pre>
<p>It becomes more obvious if you actually think of the operator equivalent:</p>
<pre><code>s = s | set(b3) #Â set(b3) -&gt; {93, 'b3'}
</code></pre>
<p>As compared to what we actually want:</p>
<pre><code>s = s | {b3}
</code></pre>
<p>The <em>union</em> is performed with the outer iterable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>b3</code> is iterable, <code>union</code> works on its elements rather than on the tuple itself. Replace that with:</p>
<pre><code>s = s.union([b3])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The documentation on <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.union" rel="nofollow noreferrer"><code>set.union</code></a> actually explains this:</p>
<blockquote>
<p><code>union(*others)</code></p>
<p>Return a new set with elements from the set and all others.</p>
</blockquote>
<p>So it will create a new set including all elements from the <code>others</code>:</p>
<pre><code>&gt;&gt;&gt; set(b3)  # these are the unique elements in your `b3`
{93, 'b3'}

&gt;&gt;&gt; s.union(b3)   # the union of the unique elements in "s" and "b3"
{B(name='b1', x=90), 93, 'b3', B(name='b2', x=92)}
</code></pre>
<p>In your case (because you assign it back to <code>s</code>) you can simply add the item thus avoiding creating a new set entirely:</p>
<pre><code>&gt;&gt;&gt; s.add(b3)
&gt;&gt;&gt; s
{B(name='b1', x=90), B(name='b3', x=93), B(name='b2', x=92)}
</code></pre>
</div>
