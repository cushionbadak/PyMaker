<div class="post-text" itemprop="text">
<p>I know of two approaches to it. The first one: documentation is <a href="https://docs.python.org/3/library/heapq.html#heapq.nlargest" rel="nofollow noreferrer">here</a></p>
<pre><code>heapq.nlargest(n, iterable, key=None)
</code></pre>
<p>and the second traditional approach of using sorted</p>
<pre><code>sorted(iterable, key=key, reverse=True)[:K]
</code></pre>
<p>The documentation mentions that these two are equivalent. However, I just wanted to know if the complexity of both are the same or if the first approach was implemented with lesser time complexity. </p>
<p>I remember from my algorithms course that obtaining top K elements from a list can be done in lesser order of operations compared to sorting the entire list and then going with picking the top K.
Correct me if I am wrong</p>
<p><strong>Edit:</strong> What standard python libs can perform this task in O(N) operations or what's the best complexity we can get from python?</p>
</div>
<div class="post-text" itemprop="text">
<p><em>I'm not a great mathematician</em>, but I guess it should depend mostly on two things: </p>
<ol>
<li>relation between K and length of an iterable  </li>
<li>relation between amount of python and cpython code executed.</li>
</ol>
<p>Generally you're right, and quick tests show the difference in numbers:</p>
<pre><code>&gt;&gt;&gt; timeit(stmt='sorted(i)[-100:]', setup='from random import seed,random;seed(666);i=[random() for _ in range(10000)]', number=1000)
2.086820379132405
&gt;&gt;&gt; timeit(stmt='heapq.nlargest(n, i)', setup='from random import seed,random;import heapq;seed(666);n=100;i=[random() for _ in range(10000)]', number=1000)
0.5397011679597199
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is more fast algorithm <a href="https://en.wikipedia.org/wiki/Quickselect" rel="nofollow noreferrer">QuickSelect</a> that does not perform full sorting - just makes partition, and has average complexity about <code>O(N)</code>. </p>
<p>Thanks to @Violet Red comment:  <a href="https://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.partition.html" rel="nofollow noreferrer">numpy.partition</a></p>
<p>Complexity of heap approach is <code>O(NlogK)</code>, of sort approach is <code>O(NlogN)</code>. </p>
<p>C++ STL contains method <code>partial_sort</code> that might execute faster that full sorting.</p>
</div>
<div class="post-text" itemprop="text">
<p>Finding top K elements, can be done with complexities less than O(N * logN) with  </p>
<ul>
<li>heap based solution in O(N * logK)</li>
<li><a href="https://en.wikipedia.org/wiki/Median_of_medians" rel="nofollow noreferrer">Median of Median</a> solution in O(N)</li>
</ul>
</div>
<span class="comment-copy">The documentation says "equivalent" not identical so I would guess the time complexity is different for both. See <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow noreferrer">Time Complexity</a></span>
<span class="comment-copy">Can you think of any python built-in library method that uses QuickSelect algorithm in accomplishing this task?</span>
<span class="comment-copy">I don't know, but I see a lot of implementations in Google search that don't mention any standard methods.</span>
<span class="comment-copy">There are  some partitioning functions in numpy, that probably can be fast and usable.</span>
