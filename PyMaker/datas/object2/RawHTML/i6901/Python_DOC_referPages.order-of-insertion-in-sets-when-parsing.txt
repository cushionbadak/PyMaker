<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/34623846/dict-set-parsing-order-consistency">Dict/Set Parsing Order Consistency</a>
<span class="question-originals-answer-count">
                    1 answer
                </span>
</li>
</ul>
</div>
<p>Someone asked <a href="https://stackoverflow.com/questions/46003779/python-3-1-dictionary-python-upper-case-values-present-in-a-single-key-2-wh">here</a> why when putting <code>1</code> and <code>True</code> in a <code>set</code> only <code>1</code> is kept.</p>
<p>This is of course because <code>1==True</code>. But in which cases <code>1</code> is kept and in which cases <code>True</code> is kept?</p>
<p>Let's see:</p>
<p>passing a <code>list</code> to build the <code>set</code> instead of using the <code>set</code> notation:</p>
<pre><code>&gt;&gt;&gt; set([True,1])
{True}
&gt;&gt;&gt; set([1,True])
{1}
</code></pre>
<p>seems logical: <code>set</code> iterates on the inner list, and doesn't add the second element because it is equal to the first element (note that <code>set([True,1])</code> <em>cannot</em> yield <code>1</code>, because <code>set</code> cannot know what's inside the list. It may even not be a <code>list</code> but an <em>iterable</em>)</p>
<p>Now using <code>set</code> notation:</p>
<pre><code>&gt;&gt;&gt; {True,1}
{1}
&gt;&gt;&gt; {1,True}
{True} 
</code></pre>
<p>It seems that in that case, the list of items is processed in reverse order (tested on Python 2.7 and Python 3.4).</p>
<p>But is that guaranteed? Or just an implementation detail?</p>
</div>
<div class="post-text" itemprop="text">
<p>The order the elements in the set literal will be inserted does not seem to be guaranteed by the language specification. However, Python 3.6 was changed so that it has the expected left-to-right evaluation order. For full details of this change, here is the <a href="https://bugs.python.org/issue26020" rel="noreferrer">issue</a>, and also the <a href="https://github.com/python/cpython/commit/4c483ad52b6f7760a0a861badae6c803d6ce8590" rel="noreferrer">commit</a> that introduced the change in insertion order.</p>
<hr/>
<p>To describe the change in a bit more detail, building the set literal <code>{True, 1}</code> triggers the <code>BUILD_SET</code> opcode (with oparg equal to 2) after first pushing pointers to <code>True</code> and <code>1</code> onto the virtual machine's internal stack.</p>
<p>In Python 3.4, <a href="https://github.com/python/cpython/blob/3.4/Python/ceval.c#L2358-L2375" rel="noreferrer"><code>BUILD_SET</code></a> uses the following loop to insert elements into the set (note that oparg is 2 in our case):</p>
<pre class="lang-C prettyprint-override"><code>while (--oparg &gt;= 0) {
    PyObject *item = POP();
    if (err == 0)
        err = PySet_Add(set, item);
        Py_DECREF(item);
</code></pre>
<p>Since <code>1</code> was added to the stack last, it is popped off first and is the first object inserted into the set.</p>
<p>In newer versions of Python (such as 3.6), the <a href="https://github.com/python/cpython/blob/3.6/Python/ceval.c#L2609-L2628" rel="noreferrer"><code>BUILD_SET</code></a> opcode uses <code>PEEK</code> instead of <code>POP</code>:</p>
<pre class="lang-C prettyprint-override"><code>for (i = oparg; i &gt; 0; i--) {
    PyObject *item = PEEK(i);
    if (err == 0)
        err = PySet_Add(set, item);
        Py_DECREF(item);
</code></pre>
<p><a href="https://github.com/python/cpython/blob/3.6/Python/ceval.c#L966" rel="noreferrer"><code>PEEK(i)</code></a> fetches the i<sup>th</sup> item down the stack, so for <code>{True, 1}</code>, the object <code>True</code> is added to the set first.</p>
</div>
<div class="post-text" itemprop="text">
<p>Left to right order in the set display is guaranteed by <a href="https://docs.python.org/3/reference/expressions.html#set-displays" rel="nofollow noreferrer">the documentation</a>:</p>
<blockquote>
<p>its elements are evaluated from left to right and added to the set object</p>
</blockquote>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; def f(i, seq="left to right".split()): print(seq[i])
&gt;&gt;&gt; {f(0), f(1), f(2)}
left
to
right
{None}
</code></pre>
<p>Therefore, <code>{1, True}</code> is effectively:</p>
<pre><code>&gt;&gt;&gt; S = set()
&gt;&gt;&gt; S.add(1)
&gt;&gt;&gt; S.add(True) # no effect according to docs
&gt;&gt;&gt; S
{1}
</code></pre>
<p>The set may contain only one of <code>True</code> or <code>1</code> because they are duplicates from the <code>set</code> point of view:</p>
<pre><code>&gt;&gt;&gt; hash(1) == hash(True)
True
&gt;&gt;&gt; 1 == True
True
</code></pre>
<p>It is guaranteed on Python 3 that <code>1 == True</code>.  See <a href="https://stackoverflow.com/q/2764017/4279">Is `False == 0 and True == 1 in Python an implementation detail or is it guaranteed by the language?</a>:</p>
<blockquote>
<p>Booleans: These represent the truth values False and True [...] Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings "False" or "True" are returned, respectively.</p>
</blockquote>
<p>If <code>{1, True}</code>  prints <code>{True}</code> then it is a <a href="https://bugs.python.org/issue26020" rel="nofollow noreferrer">bug ("set_display evaluation order doesn't match documented behaviour"</a>). The output should be the same as <code>set([1, True])</code>. It works as expected (<code>{1}</code>) on the recent pypy, jython, and cpython 2.7.13+, 3.5.3+ versions.</p>
</div>
<div class="post-text" itemprop="text">
<p>From one of the most recent version, the <code>dict</code> preserves order as a side effect of an implementation detail. In 3.7 this behaviour may be guaranteed. <em>Maybe</em> it had also some effect on a set literal.</p>
<p>Python 3.6.2:</p>
<pre><code>&gt;&gt;&gt; {True,1}
{True}
&gt;&gt;&gt; {1,True}
{1}
&gt;&gt;&gt; set([True,1])
{True}
&gt;&gt;&gt; set([1,True])
{1}
</code></pre>
</div>
<span class="comment-copy"><code>python -c 'print({1, True}, {True, 1})'</code> gives me <code>{1} {True}</code> on Python 3.6.1.</span>
<span class="comment-copy">For what it's worth, <code>{True} == {1}</code> evaluates to <code>True</code>. Or to <code>1</code>. I don't know anymore.</span>
<span class="comment-copy">The culprit <i>might</i> be the <code>BUILD_SET</code> bytecode instruction, but I can't find its specification. If someone cares to dig into the sources, that's where I'd look.</span>
<span class="comment-copy">Nice to see you followed this up Jean, might be worth adding some python-internal or CPython tags, just a thought, I'll do a bit more digging myself when I find time</span>
<span class="comment-copy">Superb answer. I suspected that parsing trick but digging this out is another thing.</span>
<span class="comment-copy">As I expected. So basically, the answer is "an implementation detail". Nice digging by the way, +1</span>
<span class="comment-copy">the order <i>is</i> <a href="https://stackoverflow.com/a/46007408/4279">guaranteed</a>. Even the title of bug that you've linked says so explicitly: <i>"set_display evaluation order doesn't match documented behaviour"</i></span>
<span class="comment-copy">@jfs: I perhaps read the documentation too pedantically, but the specification for set displays says that the elements will be <i>evaluated</i> in left-to-right order, but is ambiguous about the order in which these evaluated elements will be added to the set. The insertion order for ordered collections, like list displays, is explicitly defined (for obvious reasons). I read the issue as being that the previous behaviour was not intuitive rather than a contradiction of the language specification, but, like I say, it's possible that my reading is unreasonable given how others have interpreted it.</span>
<span class="comment-copy">ok, so it seems that it was implementation defined, and no longer the case. Any official link to prove that?</span>
<span class="comment-copy">See: <a href="https://stackoverflow.com/questions/39980323/dictionaries-are-ordered-in-python-3-6" title="dictionaries are ordered in python 3 6">stackoverflow.com/questions/39980323/â€¦</a></span>
<span class="comment-copy">note that <code>set([True,1])</code> <i>cannot</i> yield <code>1</code>, because <code>set</code> cannot know what's inside the list. It may even not be a list but a generator.</span>
<span class="comment-copy">it's about order in dictionaries. Not about the order of the parsing of the set notation</span>
<span class="comment-copy">I'm sorry I cannot upvote or accept this answer with <i>maybes</i>. But thanks for testing on 3.6. And you may be on to something here. Related: <a href="https://stackoverflow.com/questions/9792664/set-changes-element-order" title="set changes element order">stackoverflow.com/questions/9792664/set-changes-element-order</a></span>
