<div class="post-text" itemprop="text">
<p>I want to make sure 2 unsorted lists of dictionaries are equal, i.e., they have the same content, even though the order may be different.</p>
<p>An <code>in</code> check isn't good enough because duplicate dictionaries are possible. (e.g. <code>list1 = [dict1, dict1, dict2]</code> and <code>list2 = [dict1, dict2, dict2]</code>)</p>
<p>If it were lists of lists, I'd just sort them:</p>
<p><code>sorted(list_of_lists1) == sorted(list_of_lists2)</code></p>
<p>But sorting dictionaries is unstable.</p>
<p>I can get around this by converting all the dicts to tuples but that seems inefficient and lame.</p>
<p>Is there a more direct solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think you need to hash anything - you can change each dictionary to a sorted list of tuples of key-value pairs, and sort that.</p>
<pre><code>def dict_list_eq(l1, l2):
    sorted_l1 = sorted(sorted(d.items()) for d in l1)
    sorted_l2 = sorted(sorted(d.items()) for d in l2)
    return sorted_l1 == sorted_l2

l1 = [{1: 2}, {3: 4}]
l2 = [{3: 4}, {1: 2}]
l3 = [{1: 209}, {3: 4}]

print(dict_list_eq(l1, l2))
print(dict_list_eq(l1, l3))
</code></pre>
<p>Output, as expected:</p>
<pre><code>True
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you were looking to make sure that the exact same objects are in each list the same number of times you can rely on the id (<a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#id</a>) of the dictionaries, and do the sorting you mentioned:</p>
<pre><code>if sorted(id(d) for d in list1) == sorted(id(d) for d in list2):
    ...
</code></pre>
<p>If you are looking for dicts that might be equal but are not the same python object then this wont work.</p>
</div>
<span class="comment-copy">This is what I did, but I really thought there'd be a way to do it with dictionaries. Thanks though!</span>
<span class="comment-copy">My intuition says that if you kept them as dictionaries it wouldn't be possible to sort them, so you would have to compare each item to each other item, resulting in <code>O(n^2)</code> runtime, whereas this uses a (probably) <code>O(n)</code> conversion to list/tuple, an <code>O(n log(n))</code> sort and then an <code>O(n)</code> comparison.</span>
<span class="comment-copy">Right, in my case, they are equal but not the same object.</span>
