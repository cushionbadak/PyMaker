<div class="post-text" itemprop="text">
<p>I'm having a little bit of trouble comparing two similar dictionaries. I would like stricter comparison of the values (and probably keys).</p>
<p>Here's the really basic problem:</p>
<pre><code>&gt;&gt;&gt; {'a': True} == {'a': 1}
True
</code></pre>
<p>Similarly (and somewhat confusingly):</p>
<pre><code>&gt;&gt;&gt; {1: 'a'} == {True: 'a'}
True
</code></pre>
<p>This makes sense because <code>True == 1</code>. What I'm looking for is something that behaves more like <code>is</code>, but compares two possibly nested dictionaries. Obviously you can't use use <code>is</code> on the two dictionaries, because that will always return <code>False</code>, even if all of the elements are identical.</p>
<p>My current solution is to just use <code>json.dumps</code> to get a string representation of both and compare that.</p>
<pre><code>&gt;&gt;&gt; json.dumps({'a': True}, sort_keys=True) == json.dumps({'a': 1}, sort_keys=True)
False
</code></pre>
<p>But this only works if everything is JSON-serializable.</p>
<p>I also tried comparing all of the keys and values manually:</p>
<pre><code>&gt;&gt;&gt; l = {'a': True}
&gt;&gt;&gt; r = {'a': 1}
&gt;&gt;&gt; r.keys() == l.keys() and all(l[key] is r[key] for key in l.keys())
False
</code></pre>
<p>But this fails if the dictionaries have some nested structure. I figured I could write a recursive version of this to handle the nested case, but it seemed unnecessarily ugly and un-pythonic.</p>
<p>Is there a "standard" or simple way of doing this?</p>
<p>Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>You were pretty close with JSON: Use Python's <code>pprint</code> module instead. This is documented to sort dictionaries in Python <a href="https://docs.python.org/2/library/pprint.html" rel="nofollow noreferrer">2.5+</a> and <a href="https://docs.python.org/3/library/pprint.html" rel="nofollow noreferrer">3</a>:</p>
<blockquote>
Dictionaries are sorted by key before the display is computed.
</blockquote>
<p>Let's confirm this. Here's a session in Python 3.6 (which conveniently preserves insertion order even for regular <code>dict</code> objects):</p>
<pre><code>Python 3.6.2 (v3.6.2:5fd33b5, Jul  8 2017, 04:57:36) [MSC v.1900 64 bit (AMD64)]
 on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; a = {2: 'two', 3: 'three', 1: 'one'}
&gt;&gt;&gt; b = {3: 'three', 2: 'two', 1: 'one'}
&gt;&gt;&gt; a
{2: 'two', 3: 'three', 1: 'one'}
&gt;&gt;&gt; b
{3: 'three', 2: 'two', 1: 'one'}
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; c = {2: 'two', True: 'one', 3: 'three'}
&gt;&gt;&gt; c
{2: 'two', True: 'one', 3: 'three'}
&gt;&gt;&gt; a == b == c
True
&gt;&gt;&gt; from pprint import pformat
&gt;&gt;&gt; pformat(a)
"{1: 'one', 2: 'two', 3: 'three'}"
&gt;&gt;&gt; pformat(b)
"{1: 'one', 2: 'two', 3: 'three'}"
&gt;&gt;&gt; pformat(c)
"{True: 'one', 2: 'two', 3: 'three'}"
&gt;&gt;&gt; pformat(a) == pformat(b)
True
&gt;&gt;&gt; pformat(a) == pformat(c)
False
&gt;&gt;&gt;
</code></pre>
<p>And let's quickly confirm that pretty-printing sorts nested dictionaries:</p>
<pre><code>&gt;&gt;&gt; a['b'] = b
&gt;&gt;&gt; a
{2: 'two', 3: 'three', 1: 'one', 'b': {3: 'three', 2: 'two', 1: 'one'}}
&gt;&gt;&gt; pformat(a)
"{1: 'one', 2: 'two', 3: 'three', 'b': {1: 'one', 2: 'two', 3: 'three'}}"
&gt;&gt;&gt;
</code></pre>
<p>So, instead of serializing to JSON, serialize using <code>pprint.pformat()</code>. I imagine there may be some corner cases where two objects that you want to consider unequal nevertheless create the same pretty-printed representation. But those cases should be rare, and you wanted something simple and Pythonic, which this is.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use isinstance() to delineate between a regular dictionary entry and a nested dictionary entry. This way you can iterate through using <code>is</code> to compare strictly, but also check when you need to dive down a level into the nested dictionary.</p>
<p><a href="https://docs.python.org/3/library/functions.html#isinstance" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html#isinstance</a></p>
<pre><code>myDict = {'a': True, 'b': False, 'c': {'a': True}}
for key, value in myDict.items():
    if isinstance(value, dict):
        # do what you need to do....
    else:
        # etc...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can test identity of all (key, value) pairs element-wise:</p>
<pre class="lang-python prettyprint-override"><code>def equal_dict(d1, d2):
    return all((k1 is k2) and (v1 is v2)
               for (k1, v1), (k2, v2) in zip(d1.items(), d2.items()))

&gt;&gt;&gt; equal_dict({True: 'a'}, {True: 'a'})
True

&gt;&gt;&gt; equal_dict({1: 'a'}, {True: 'a'})
False
</code></pre>
<p>This should work with <code>float</code>, <code>int</code>, <code>str</code> and <code>bool</code>, but not other sequences or more complex objects.
Anyway, that's a start if you need it.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think you are looking for something like this. However since you didn't provide example data I won't go into guessing what it could be</p>
<pre><code>from boltons.itertools import remap

def compare(A, B): return A == B and type(A) == type(B)

dict_to_compare_against = { some dict }

def visit(path, key, value):
    cur = dict_to_compare_against
    for i in path:
        cur = cur[i]

    if not compare(cur, value):
        raise Exception("Not equal")


remap(other_dict, visit=visit)
</code></pre>
</div>
<span class="comment-copy">This doesn't seem like a good idea - small integers and strings that are valid identifiers compare OK with <code>is</code> because they're interned (in CPython at least), but you will quickly hit issues with anything non-trivial. What is the underlying problem that you were trying to solve that led you to <code>True</code> vs. <code>1</code> as a dictionary key?</span>
<span class="comment-copy">some sample dictionaries with the nested cases you want to find would be nice</span>
<span class="comment-copy">I have a <code>JSONField</code> in Django that stores some denormalized data. (It's product data). Having <code>{"assembly_required": True}</code> makes it clear that the product requires assembly, but <code>{"assembly_required": 1}</code> is slightly less clear.  DeepDiff looks like it will work. Just need to do a <code>DeepDiff(left, right) == {}</code>.</span>
<span class="comment-copy">Hmm, not sure why the original comment mentioning <a href="https://github.com/seperman/deepdiff" rel="nofollow noreferrer">DeepDiff</a> was deleted, but OP didn't pull it out of thin air: <a href="https://stackoverflow.com/a/26171760/95852">stackoverflow.com/a/26171760/95852</a></span>
<span class="comment-copy"><code>isinstance(myDict, dict)</code> :.. myDict -&gt; myDict[x] ?</span>
<span class="comment-copy">fixed. Thanks for catching</span>
<span class="comment-copy">I don't think that'll work either, x is just they key. Probably need myDict[x] to get the contents</span>
<span class="comment-copy">or use <code>for x, y in myDict.items()</code></span>
<span class="comment-copy">Right, forgot how python dictionary iteration worked... bad answer. Let me edit again.</span>
<span class="comment-copy">This doesn't work, because you are testing with <code>is</code>. Your tests happen to give the desired results due to interning and possibly other Python micro-optimizations. But it can incorrectly report two equal dictionaries as unequal. For example, instead of <code>'a'</code>, use two separate variables, and give those variables equal-but-not-interned values, such as large integers.</span>
<span class="comment-copy">And, as you already said, it doesn't work for "sequences or more complex objects". So it doesn't meet OP's requirement that it handle nested structures.</span>
