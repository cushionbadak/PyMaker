<div class="post-text" itemprop="text">
<p>I'm trying to use webrtcvad to detect speech in wav file, to do so I must provide 30ms of 16bit pcm at 32Khz.
what I'm trying to do is to cut my wav in packet of 30ms but take this file for example (<a href="https://dl.dropboxusercontent.com/u/91396766/recording000001.wav" rel="nofollow noreferrer">https://dl.dropboxusercontent.com/u/91396766/recording000001.wav</a>) :</p>
<pre><code>audio software : 
5,568 seconds, 16 bit, mono, 320000Hz
</code></pre>
<p>-</p>
<pre><code>https://docs.python.org/3/library/wave.html
w.getnframes() = 178176
w.getframerate() = 32000
w.getnchannels() = 1 = mono
w.getsampwidth() = 2 byte = 16 bits
len(w.readframes(w.getnframes())) = 356352, shouldn't it be 178176?
len(w.readframes(0)) = 1
</code></pre>
<p>why is len(w.readframes(w.getnframes())) = 356352, it should be 178176 because </p>
<p>1/32000 = 0.00003125 seconds
and 0.00003125*175176 = 5.568 secs</p>
<p>Thanks</p>
<h1>Edit</h1>
<p>test script :</p>
<pre><code>import wave

infile = 'recording000001.wav'
w = wave.open(infile, 'rb')

data = w.readframes(w.getnframes())
frequency = w.getframerate()
number_of_channels = w.getnchannels()
sample_width_in_bytes = w.getsampwidth()

print "{} is sampled at {}Hz, it has {} channel(s) and a sample width of {} bytes".format(infile, frequency, number_of_channels, sample_width_in_bytes) 
print "it contains {} data".format(len(data))
print "for {} frames".format(w.getnframes())
print "one data length is {}".format(len(data[0]))

w.close()
</code></pre>
<p>output :</p>
<pre><code>recording000001.wav is sampled at 32000Hz, it has 1 channel(s) and a sample width of 2 bytes
it contains 356352 data
for 178176 frames
one data length is 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>After </p>
<blockquote>
<p>w.rewind()</p>
</blockquote>
<p>I tried</p>
<blockquote>
<p>len(w.readframes(0))</p>
<p>0</p>
</blockquote>
<p>Which is different from your results, where you got 1.</p>
<p>Interestingly however, </p>
<blockquote>
<p>len(w.readframes(1))</p>
<p>2</p>
</blockquote>
<p>But this makes sense, in a convoluted fashion, since there are indeed 2 bytes. (16bit audio frames imply that there are 2 bytes per frame. Since you are calling len on a binary object, I think it therefore makes sense that it would return the number of actual bytes.)</p>
<p>If you want to work on your audio data, perhaps you should investigate a library like numpy to do further analysis or processing of your audio.</p>
<blockquote>
<p>import numpy as np</p>
<p>c = np.frombuffer(w.readframes(w.getnframes()), dtype="int16")</p>
<p>c.shape</p>
<p>(178175,)</p>
<p>c[0] = 100</p>
<p>c[1] = 122</p>
<p>c[100] = -132</p>
</blockquote>
<p>This is the raw waveform data. It is on the range of (-2^15, 2^15) or, -32768 to 32,768. Since the first portion of your audio file is quiet at the beginning, small values in the first few hundred frames makes good sense.</p>
</div>
<span class="comment-copy">try this :   frames = w.readframes(w.getnframes()) print len(frames[0]) &gt;&gt;&gt; 1</span>
<span class="comment-copy">frames[356352] is out of range, but frames[356351] is a valid index [BUT, not a valid measure of your audio]. This is because you are getting the uint8 values of the bytes. It takes a small extra step to ensure your uint16 numbers (2-bytes) are handled correctly.</span>
<span class="comment-copy">Sorry, I meant int8 and int16 types, respectively. Not uint8 and uint16.</span>
<span class="comment-copy">To directly reply to your comment, len(frames[0]) throws an error because calling len() on an integer is invalid.</span>
<span class="comment-copy">Thanks, a lot make sense now, however len(frame[0]) does not raise an error for me, it returns 1</span>
