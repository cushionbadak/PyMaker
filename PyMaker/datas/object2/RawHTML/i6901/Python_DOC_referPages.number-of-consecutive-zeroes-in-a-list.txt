<div class="post-text" itemprop="text">
<p>I have a list made up of 1's and 0's e.g.</p>
<pre><code>[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0]
</code></pre>
<p>I want to output another list of the same length where each entry represents the number of consecutive 0's that have just gone i.e. the output for the above example will be:</p>
<pre><code>[0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 1, 0]
</code></pre>
<p>Note that the first entry of the output list will always be <code>0</code> and it doesn't matter what the last entry of the input list is.</p>
<p>What I've tried so far:</p>
<pre><code>def zero_consecutive(input_list):
    output = [0]
    cons = 0
    for i in input_list[:-1]:
        if i == 0:
            cons += 1
            output.append(cons)
        else:
            cons = 0
            output.append(cons)

    return output
</code></pre>
<p>It works for the example, but there might be a more efficient way that covers more edge cases.</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of a function that <code>append</code>s everything to a list you could write a generator function and then just cast that to a <code>list</code>. In general that's shorter and in most cases even faster (while doing the same thing)!</p>
<pre><code>def zero_consecutive(input_list):
    yield 0
    cons = 0
    for i in input_list[:-1]:
        if i == 0:
            cons += 1
        else:
            cons = 0
        yield cons

&gt;&gt;&gt; list(zero_consecutive([0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0]))
[0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 1, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You stated that you're really interested in a very fast solution. In case performance is critical you could use a C extension type, for example with Cython.</p>
<p>I'm using IPython so I simply use the cythonmagic:</p>
<pre><code>%load_ext cython
</code></pre>
<p>And let Cython compile this iterator class:</p>
<pre><code>%%cython

cdef class zero_consecutive_cython(object):
    cdef long cons
    cdef object input_list
    cdef int started

    def __init__(self, input_list):
        self.input_list = iter(input_list[:-1])
        self.cons = 0
        self.started = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.started == 0:
            self.started = 1
            return 0
        item = next(self.input_list)
        if item == 0:
            self.cons += 1
        else:
            self.cons = 0
        return self.cons
</code></pre>
<p>It's basically the same as the generator function mentioned in <a href="https://stackoverflow.com/a/45904440/5393381">the other answer</a> but it's much faster:</p>
<pre><code>import numpy as np

def zero_consecutive_numpy(input_list):  # from https://stackoverflow.com/a/45905344/5393381
    a = np.array(input_list)
    idx = np.flatnonzero(a[1:] != a[:-1])+2
    out = np.ones(a.size,dtype=int)   
    out[0] = 0

    if len(idx)==0:
        out = np.arange(a.size)
    elif len(idx)==1:
        out[idx[0]] = -a.size
        np.cumsum(out, out=out)
        out[out&lt;0] = 0
    else:    
        out[idx[0]] = 2-idx[1]
        if len(idx)%2==1:
            out[idx[-1]] = -a.size
            out[idx[2:-1:2]] = 1-idx[3:-1:2] - idx[1:-3:2]
        else:
            out[idx[2::2]] = 1-idx[3::2] - idx[1:-2:2]
        np.cumsum(out, out=out)
        out[out&lt;0] = 0
    return out

def zero_consecutive_python(input_list):  # from https://stackoverflow.com/a/45904440/5393381
    yield 0
    cons = 0
    for i in input_list[:-1]:
        if i == 0:
            cons += 1
        else:
            cons = 0
        yield cons

np.random.seed(0)

for n in [200, 2000, 20000, 100000]:
    print(n)
    a = np.repeat(np.arange(n)%2, np.random.randint(3,8,(n))).tolist()

    %timeit list(zero_consecutive_python(a))
    %timeit list(zero_consecutive_cython(a))
    %timeit zero_consecutive_numpy(a)
</code></pre>
<p>Giving me this result:</p>
<pre><code>200
380 µs ± 13.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)    # python
122 µs ± 1.06 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)   # cython
488 µs ± 7.35 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)    # numpy
2000
3.49 ms ± 26.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)    # python
1.07 ms ± 19.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)   # cython
3.85 ms ± 288 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)     # numpy
20000
42.9 ms ± 3.03 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)     # python
15 ms ± 778 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)       # cython
33.9 ms ± 670 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)      # numpy
100000
199 ms ± 2.69 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)        # python
77.8 ms ± 507 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)      # cython
173 ms ± 4.37 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)      # numpy
</code></pre>
<p>At least on my computer it seems like this can beat the other approaches by a factor of 2-3.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a vectorized solution -</p>
<pre><code>def zero_consecutive_vectorized(input_list):
    a = np.array(input_list)
    idx = np.flatnonzero(a[1:] != a[:-1])+2
    out = np.ones(a.size,dtype=int)   
    out[0] = 0

    if len(idx)==0:
        out = np.arange(a.size)
    elif len(idx)==1:
        out[idx[0]] = -a.size
        np.cumsum(out, out=out)
        out[out&lt;0] = 0
    else:    
        out[idx[0]] = 2-idx[1]
        if len(idx)%2==1:
            out[idx[-1]] = -a.size
            out[idx[2:-1:2]] = 1-idx[3:-1:2] - idx[1:-3:2]
        else:
            out[idx[2::2]] = 1-idx[3::2] - idx[1:-2:2]
        np.cumsum(out, out=out)
        out[out&lt;0] = 0
    return out
</code></pre>
<p>Sample run -</p>
<pre><code>In [493]: a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

In [494]: zero_consecutive_vectorized(a)
Out[494]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

In [495]: a = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

In [496]: zero_consecutive_vectorized(a)
Out[496]: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

In [497]: a = [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0]

In [498]: zero_consecutive_vectorized(a)
Out[498]: [0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 1, 0]
</code></pre>
<p><strong>Runtime test</strong></p>
<p>Timing against @MSeifert's solution, which seems to be competing enough from the lot of loopy solutions -</p>
<pre><code>In [579]: n = 10000

In [580]: a = np.repeat(np.arange(n)%2, np.random.randint(3,8,(n))).tolist()

In [581]: %timeit list(zero_consecutive(a))
     ...: %timeit zero_consecutive_vectorized(a)
     ...: 
100 loops, best of 3: 2.85 ms per loop
100 loops, best of 3: 1.96 ms per loop

In [582]: n = 60000

In [583]: a = np.repeat(np.arange(n)%2, np.random.randint(3,8,(n))).tolist()

In [584]: %timeit list(zero_consecutive(a))
     ...: %timeit zero_consecutive_vectorized(a)
     ...: 
100 loops, best of 3: 17.2 ms per loop
100 loops, best of 3: 12 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This works:</p>
<pre><code>def zero_consecutive(a):
    y = []
    for i, _ in enumerate(a):
        #prevents a StopIteration error
        if not(1 in a[:i]): y.append(i)
        else:
            index = next(j for j in range(i-1, -1, -1) if a[j])
            y.append(i - index - 1)
    return y
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to do it using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to detect runs of zeroes:</p>
<pre><code>from itertools import groupby

def zero_consecutive(input_list):
    result = [0]
    for k, values in groupby(input_list[:-1], bool):
        len_values = len(list(values))
        if k:
            result.extend([0] * len_values)
        else:
            result.extend(range(1, len_values + 1))
    return result

&gt;&gt;&gt; zero_consecutive([0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0])
[0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 1, 0]
</code></pre>
<p>This groups by using the lambda expression <code>x == 0</code> as the key so that non-zero values are treated equivalently. This means that the function will work for lists that contains values other than 0 and 1, e.g.:</p>
<pre><code>&gt;&gt;&gt; zero_consecutive([0, 0, 0, 0, 1, 2, 'a', 2, 1000, 0, 1, 0])
[0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 1, 0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another solution using <code>numpy</code> and <code>scipy</code>, for fun</p>
<pre class="lang-python prettyprint-override"><code>import numpy as np
from scipy.ndimage.measurements import label
from scipy.ndimage.interpolation import shift

a = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0])
a_zeros = a == 0
labels = label(a_zeros)[0]

for l in np.unique(labels):
    a[labels == l] = a_zeros[labels == l].cumsum()

shift(a, 1, output=a)

&gt;&gt;&gt; a
Out[1]:
array([0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 1, 0])
</code></pre>
<p>And the function if you want it.</p>
<pre class="lang-python prettyprint-override"><code>def zero_consecutive(array):
    a = array.copy()
    a_zeros = a == 0
    labels = label(a_zeros)[0]

    for l in np.unique(labels):
        a[labels == l] = a_zeros[labels == l].cumsum()

    shift(a, 1, output=a)
    return a
</code></pre>
<hr/>
<p><strong>EDIT: Improved version</strong></p>
<p>Better performance.</p>
<pre class="lang-python prettyprint-override"><code>import numpy as np
from scipy.ndimage.measurements import label
from scipy.ndimage.interpolation import shift
from scipy.ndimage.measurements import labeled_comprehension

def zero_consecutive(array):
    def func(a, idx):
        r[idx] = a.astype(bool).cumsum()
            return True
    r = np.zeros_like(array)
    labels, nlabels = label(array == 0)
    labeled_comprehension(labels, labels, np.arange(1, nlabels + 1), func, int, 0, pass_positions=True)

    return shift(r, 1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>list(map(int,list(''.join(['0' if elem=='' else ''.join(map(str,list(range(len(elem)+1)))) for elem in str([0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0]).strip('[').strip(']').replace(', ','').split('1')])[0:-1])))
</code></pre>
<p>How about this list comprehension one-liner.</p>
</div>
<span class="comment-copy">What's the problem with your approach. It works, doesn't it?</span>
<span class="comment-copy">I figured it out once I was asked to provide code.  It works for that example but there might be a more efficient way that covers more edge cases.</span>
<span class="comment-copy">In the case you figured out the solution yourself you can self-answer your question. That's better than to put it in the question. You can always include a note alongside the code that you would still be interested in more efficient solutions. :)</span>
<span class="comment-copy">Is it okay to have an array as output?</span>
<span class="comment-copy">@Divakar yes it is</span>
<span class="comment-copy">A much better solution than my <code>groupby</code> suggestion. It's elegant and efficient.</span>
<span class="comment-copy">This is about as quick as my solution.  Tried it on 60,000 lists of variable lengths and both take about 15s</span>
<span class="comment-copy">@Imran Yes, there won't be <i>much</i> speedup compared to your <code>append</code> solution in case you want the result as <code>list</code>. But if you just want to iterate over the result the generator will be much faster and much more memory efficient.</span>
<span class="comment-copy">@Imran What about my <a href="https://stackoverflow.com/a/45905344/"><code>vectorized solution</code></a>?</span>
<span class="comment-copy">@MSeifert Updated. Also optimized my solution a bit. Was comparable on smaller ones. On bigger ones, seems a bit better. Also, outputting as array, but accepting lists as inputs. Check out the timings at your end too?</span>
<span class="comment-copy">Yes, I get roughly the same timings. At around 1000-2000 for <code>n</code> seems break-even. Then your solution is faster.</span>
<span class="comment-copy">Just to complement your timings: <a href="https://stackoverflow.com/a/45905965/5393381">stackoverflow.com/a/45905965/5393381</a> :)</span>
<span class="comment-copy">@MSeifert numba/cython the last resort! ;)</span>
<span class="comment-copy">Yeah, but numba isn't too good with generators (unfortunatly) :D</span>
<span class="comment-copy">About 17s for 60,000 lists of variable lengths compared to 15s for my solution</span>
<span class="comment-copy">Yes, I tried a similar approach and it's working although much slower (5-10 times slower) - that's why I chose the generator function approach! :) But I have a few improvements: Use <code>key=bool</code> and test for <code>if not k</code>. That's faster than a <code>lambda</code>.</span>
<span class="comment-copy">@MSeifert: thanks for those suggestions.... I like your answer <i>far</i> more than this.</span>
<span class="comment-copy">Takes about 32s on 60,000 lists of variable lengths compared to 15s for my solution</span>
<span class="comment-copy">Yes, it's made inefficient by the for loop. As I said, it is for fun. I'm not sure there is a parallelised function for computing label-wise cumsum.</span>
<span class="comment-copy">@Imran: new version without for loop, a little bit better, but not as efficient as yours I think.</span>
<span class="comment-copy">Why the downvote?</span>
