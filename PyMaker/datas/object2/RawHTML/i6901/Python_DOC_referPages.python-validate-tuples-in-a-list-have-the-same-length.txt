<div class="post-text" itemprop="text">
<p>Here is my code:</p>
<pre><code>x = [(1, 2, 3), (4, 5, 6)]

for tup in x:
     if len(tup) == 3:
        print(True) 
     else:
        print(False) 
</code></pre>
<p>I want to validate tuples in a list have the same length of 3. If any of the tuples in the list has more or less than 3 values, I want to print single output <code>False</code>. If all the tuples have 3 values then it should print single output <code>True</code>. </p>
<p>Currently, the for loop produces more than 1 output. How do I tweak the for loop?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>all()</code>:</p>
<pre><code>if all(len(tup) == 3 for tup in x):
    print(True)
else:
    print(False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a one-liner:</p>
<pre><code>print(all(len(t) == 3 for t in x))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A convenient solution for this problem is to use the <code>break</code> keyword and loop manipulation like so:</p>
<pre><code>x = [(1, 2, 3), (4, 5, 6)]
tupleCheck = True
for tup in x:
    if len(tup) != 3:
       tupleCheck = False # Here, the program realizes that a tuple does not have a length of 3...
       break # and aborts.
print(tupleCheck)
</code></pre>
<p>Although somewhat redundant, this solution is quite readable.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another approach would be to use <code>namedTuple</code>. Instead of checking the list of point you could create your list of point using this. <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer">doc</a>.</p>
<pre><code>&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(11, y=22)     # instantiate with positional or keyword arguments
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This gives a list corresponding to each tuple:</p>
<pre><code>x=[(1,2,3),(1,2,2)]
d=[len(a)==3 for a in x]
p=True
for i in d:
    p= i and p
print p
</code></pre>
</div>
<span class="comment-copy">You get a warning from the Department of Redundancy Department! Never use <code>if/else</code> to just print out True or False. Use the boolean directly from <code>all</code> ;)</span>
<span class="comment-copy">I agree, but I'm perhaps incorrectly assuming the OP has 2 branches of logic and is just printing for MCVE - but he does explicitly ask to print. I would update but @DanilSperansky has the one-liner covered.</span>
<span class="comment-copy">I'm pretty sure that I'd <i>never</i> use the <code>set</code> version if I had the <code>all</code> version available to me.  Specifically, <code>all</code> is more clear and it has the ability to short-circuit as soon as it finds a tuple of the wrong length.  The <code>set</code> version` will always look at <i>every</i> tuple before coming to a decision.</span>
<span class="comment-copy">@mgilson You're right</span>
<span class="comment-copy">@JoelLawZiYang consider accepting one of the answers</span>
<span class="comment-copy">So much code and slower compare to the use of a list comprehension and all()</span>
<span class="comment-copy">@Y0da I'm trying to go with OP's idea of "tweaking the for loop" instead of completely demolishing everything and making a one-liner. But still, using list comp + all() is the better solution if the aforementioned "tweak" was not mentioned.</span>
<span class="comment-copy">I get the motivation but in my opinion this is not readable compare to the list comp + all() which is way more pythonic. This kind of answer (@danil-speransky) help everyone to be more pythonic and write better code =)</span>
<span class="comment-copy">I actually really like this approach.  It's better to force the formatting of the data-structure when you create it rather than needing to check it at every point where you use it.</span>
<span class="comment-copy">Apologies.misread the q. corrected it.</span>
