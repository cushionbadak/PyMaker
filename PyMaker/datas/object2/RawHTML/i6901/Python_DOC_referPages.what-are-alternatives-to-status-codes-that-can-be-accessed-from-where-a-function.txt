<div class="post-text" itemprop="text">
<p>I would like to raise an exception in a function, and then check somewhere else (in the Django view and my unit tests) if it was raised. The following code uses status codes, and it works. But I can't figure out how to do the same thing with exceptions - which, everyone seems to agree, are the right way to do this kind of thing.</p>
<p>It is important to me to use custom error messages. Not to print them, but to detect and use them in the code (mainly to forward them to the end user with Django messages).</p>
<p>I have no idea how I would check in <code>add_foo_view</code> if an exception was raised in <code>utils.add_foo</code>.</p>
<p>In the unit test I have tried things like <code><a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertWarnsRegex" rel="nofollow noreferrer">assertWarnsRegex</a>(Warning, 'blah went wrong')</code>, but that did not bother to check if the message is actually the same.</p>
<p><strong>views.py:</strong></p>
<pre><code>from django.contrib import messages

from .utils import add_foo


def add_foo_view(request):
    if request.method == 'POST':

        status = add_foo(request.POST['bar'])
        if not status == 'Bar was added.':
            messages.error(request, status)

        return render(request, 'index.html')
    else:
        return render(request, 'add_foo.html')
</code></pre>
<p><strong>utils.py:</strong></p>
<pre><code>def add_foo(bar):

    if not spamifyable(bar):
        return 'Bar can not be spamified.'

    try:
        eggs = Egg.objects.get(baz=bar)
    except:
        return 'Bar has no eggs.'

    do_things(bar)

    return 'Bar was added.'
</code></pre>
<p><strong>tests.py:</strong></p>
<pre><code>def test_bar_without_eggs(self):

    status = add_foo(eggless_bar)

    assertEqual(status, 'Bar has no eggs.')
</code></pre>
<p>I use Python 3.5.2 and Django 1.11.4.</p>
<p><strong>Edit:</strong> I am not actually sure if exceptions would be the correct choice here. I often read, that exceptions are only for things that are unexpected. But the cases I am catching here are wrong inputs by the user, which are very much expected. <strong>So my question is not really how to make this with exceptions, but how to make this the right and pythonic way.</strong> In any case I want the validation to happen in the separate <code>utils</code> place (plain Python, no Django), and not in the view.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the 'raise' statement to raise an exception, like:</p>
<pre><code>raise Exception("Bar has no eggs.")
</code></pre>
<p>You can also create custom exceptions by inheriting from the Exception in-built class, like:</p>
<pre><code>class MyException(Exception):
    pass
</code></pre>
<p>then you can do:</p>
<pre><code>raise MyException("Bar has no eggs.")
</code></pre>
<p>And you can catch the raised exceptions using a try-except block:</p>
<pre><code>try:
    function_that_raises_exception(args)
except MyException:
    function_to _handle_exception(args)
</code></pre>
<p>So in your views.py you can do:</p>
<pre><code>from django.contrib import messages

from .utils import add_foo, MyException


def add_foo_view(request):
    if request.method == 'POST':
        try:
            add_foo(request.POST['bar'])
        except MyException as e:
            messages.error(request, str(e))

        return render(request, 'index.html')
    else:
        return render(request, 'add_foo.html')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>An explicit success message returned by <code>add_foo</code> may seem clearer, but is probably not a good idea. The function does not need to return anything. If no exception is raised, it can be assumed that it was successful.</p>
<p>I can create a custom exception and add the <code>message</code> property in the <code>__init__</code>. This way it can be accessed as <code>e.message</code>, which in my case will be relayed to the index page in <code>views.py</code>.</p>
<p><strong>utils.py</strong></p>
<pre><code>class AddFooException(Exception):

    def __init__(self, message):
        self.message = message


def add_foo(bar):

    if not spamifyable(bar):
        raise AddFooException('Bar can not be spamified.')

    try:
        eggs = Egg.objects.get(baz=bar)
    except:
        raise AddFooException('Bar has no eggs.')

    do_things(bar)
</code></pre>
<p><strong>views.py</strong></p>
<pre><code>from django.contrib import messages

from .utils import add_foo, AddFooException


def add_foo_view(request):
    if request.method == 'POST':
        bar = request.POST['bar']

        try:
            add_foo(bar)
        except AddFooException as e:
            messages.error(request, e.message)


        return render(request, 'index.html')
    else:
        return render(request, 'add_foo.html')
</code></pre>
</div>
<span class="comment-copy">But you still use <code>status</code>, which is essentially an error code. How would I find out in the view, whether the problem is <i>can not be spamified</i> or <i>has no eggs</i>, using only exceptions?</span>
<span class="comment-copy">You can replace <code>return 'Bar has no eggs.'</code> with <code>raise MyException("Bar has no eggs.")</code> then you don't need to check for <code>status</code>.</span>
<span class="comment-copy">I got that. But how would I check in the view (or in the tests) what the actual problem was - <code>MyException("Bar can not be spamified.")</code> or <code>MyException("Bar has no eggs.")</code>? I want to check the error message. And I don't think that making as many subclasses as I have error messages (<code>UnpamifyableException</code>, <code>NoEggsException</code>) would be a sane thing to do.</span>
<span class="comment-copy">I will edit my answer, according to my understanding of your question. I am assuming that you ant to do <code>messages.error(request, status)</code> if that exception is caught.</span>
<span class="comment-copy">Yes. So if the solution involves something like <code>except MyException as e:</code> in the view (which did not work for me), something like <code>messages.error(request, e.message)</code> would come below.</span>
