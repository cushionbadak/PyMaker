<div class="post-text" itemprop="text">
<p>Suppose I have two (or more) functions. One is higher level, processing stuff by calling different other functions. If one of these functions fails (e.g. Math error), I want to "abort" not only that function, but also the ones that called it. In my case I need this to escape an error and avoid having the rest of all calculations done, without quitting the whole process (which would also terminate my GUI). Instead, I want the script to continue running, but back on the upmost level. </p>
<p>This is an abstraction of my original problem:</p>
<pre><code>def levelA(x):
    xx = levelB(x=x)
    xx *= 2
    return xx

def levelB(x):
    if x==0: return
    y = 10 / x
    return y

x = 0
print (levelA(x=x))
</code></pre>
<p>Initializing <code>x</code> with the value 0 would cause a crash in <code>levelB</code> when 10 is divided by <code>x</code>. So I first make sure that <code>x</code> is different from 0. If it's not, the function is aborted by calling return. Now <code>levelA</code> wants to continue with the doubling of the result of <code>levelB</code> which, in the case <code>x=0</code>, is "None" and there we go with another crash.</p>
<p>Of course, what I can do is inserting the line</p>
<pre><code>if xx is None: return
</code></pre>
<p>before doing <code>xx *= 2</code>. But in my real case, there is not just one extra level, but 2 or even 3 and there are many different functions that are called. I want to avoid checking each and every output of the function for errors.</p>
<p>So my question is: Can I somehow go all the way back to the first function call and skip the ones that were in between? Something like a "deep return"?</p>
</div>
<div class="post-text" itemprop="text">
<p>Exceptions were invented to handle the situation you describe. So, for example:</p>
<pre><code>In [72]: def f1(x):
    ...:     return f2(x)
    ...:

In [73]: def f2(x):
    ...:     return f3(x)
    ...:

In [74]: def f3(x):
    ...:     if x &gt; 0:
    ...:         return x
    ...:     else:
    ...:         raise ValueError("f3 called with negative argument")
    ...:

In [75]: try:
    ...:     print(f1(-2))
    ...: except ValueError as e:
    ...:     print(e)
    ...:
f3 called with negative argument
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>how about try/catch?</p>
<pre><code>def levelA(x):
    xx = levelB(x=x)
    xx *= 2
    return xx

def levelB(x):
    if x==0: raise ZeroDivisionError
    y = 10 / x
    return y

try:
    x = 0
    print (levelA(x=x))
except ZeroDivisionError:
    // error handling or other stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Initializing x with the value 0 would cause a crash in levelB when 10 is divided by x. So I first make sure that x is different from 0. If it's not, the function is aborted by calling return. </p>
</blockquote>
<p>That's a good summary but you reached the wrong conclusion. You shouldn't <code>return</code>, you should raise an <code>Exception</code>. Then you can use a <code>try</code>, <code>except</code> clause wherever you want to handle that:</p>
<pre><code>def levelA(x):
    xx = levelB(x=x)
    xx *= 2
    return xx

def levelB(x):
    if x==0: raise ValueError
    y = 10 / x
    return y

x = 0
try:
    print(levelA(x=x))
except ValueError:
    print('x was invalid! Wanna try again?')
</code></pre>
<p>Even better would be to just do the division and catch the Exception raised there:</p>
<pre><code>def levelA(x):
    xx = levelB(x=x)
    xx *= 2
    return xx

def levelB(x):
    y = 10 / x
    return y

x = 0
try:
    print(levelA(x=x))
except ZeroDivisionError:
    print('x was invalid! Wanna try again?')
</code></pre>
</div>
<span class="comment-copy"><code>try</code> and <code>except</code> instead of using <code>if</code> and <code>else</code>. That's called <a href="https://docs.python.org/3/glossary.html#term-eafp" rel="nofollow noreferrer">EAFP</a>. :)</span>
<span class="comment-copy">Throw a custom exception and catch it in the first function?</span>
<span class="comment-copy"><code>if x == 0: return</code> this returns <code>None</code> and renders your first function invalid</span>
<span class="comment-copy">The important hint in your post is that I can raise a <code>ValueError</code> together with a string - that's the puzzle piece I was missing. It means I can basically catch everything and give it my own error message which is handled by my main routine!</span>
<span class="comment-copy">Indeed. You can even define your own exceptions if you want.</span>
<span class="comment-copy">Just wanted to tell you that I implemented ValueErrors all over my GUI constructor and now I capture all errors without having to exit the application of forcing it to crash. Thanks!</span>
<span class="comment-copy">Thanks for the feedback - well done!</span>
<span class="comment-copy">I am familiar with the concept of try and except, especially for the ZeroDivisionError. The problem is that my highest level handles all the exceptions together (and not the low-level). It's the class for my GUI that also contains functions to pop up message boxes. In the lowest level function I do not have those possibilities. So what I desire is a fast forward back to my highest level function that creates a MessageBox with the error that was thrown. Is that possible, too?</span>
<span class="comment-copy">@offeltoffel Where you catch the exception and what you do in the except clause is up to you. You could put the <code>try</code> and <code>except</code> in the GUI code that forwards to the function and pop the messagebox in the except clause.</span>
