<div class="post-text" itemprop="text">
<p>I have the following file structure 
<strong>File structure</strong></p>
<pre><code>1?,a,b,c,d,1
2?,a,b,c,d,2
3?,a,b,c,d,3
4?,a,b,c,d,4
5?,a,b,c,d,5
</code></pre>
<p><strong>The code</strong> I have is as follows:</p>
<pre><code>def myfunction(dr):
  print("===H===")
  print("You have selected rating: ", dr)
  question_count=0
  while question_count&lt;5:
    with open('myfile.txt','r') as f:
        reader=csv.reader(f,delimiter=",")
        answer=False
        while answer==False:

           for row in reader:

            if dr=="d": 

              c_a=int(row[6])

              print(row[0])
              print(row[c_a])
              print(row[2])
              print(row[3])
              print(row[4])


            elif dr =="m":

              correct_answer=int(row[6])

              print(row[0])
              print(row[c_a])
              print(row[2])
              print(row[3])

            elif dr=="e": 
               correct_answer=int(row[6])

               print(row[0])
               print(row[c_a])
               print(row[2])
</code></pre>
<p>At the moment, the program reads the file, inserts the right answer into the mix, but what I want it to do is:</p>
<p>insert the correct variable into the mix</p>
<p>I will need some help with randomisation within this file handling structure, and how to not duplicate the correct answer. </p>
<p>I did think about reading all into a list, and then producing a random output, but it seemed terribly complex. Is there an easier way?</p>
<p>Update:</p>
<p>One suggestion is to use a different file format, but I want to, if at all possible avoid that, although please feel free to make these suggestions in your answers:</p>
<p>My other idea was to create a list: Search for duplicates in that list, and then delete the duplicate, if any, from that list. </p>
<p>I have this so far, it doesn't work quite yet and nor does it include randomisation of the resultant list:</p>
</div>
<div class="post-text" itemprop="text">
<p>This may not be the prettiest solution but it definitely works:</p>
<pre><code>from random import shuffle

if dr=="d": 
    # Number of answers to display
    nAns = 3
    # Position of the correct answer in row
    npos = 3
    # Correct answer
    correct_answer = row[npos]

    # Shuffle all indices except the one with the correct answer 
    # and append the correct answer        
    ind = [i for i in range(1,5) if i!=npos]
    shuffle(ind)
    new_row = [row[i] for i in ind]
    new_row = new_row[:nAns-1]
    new_row.append(correct_answer)

    # Shuffle the resulting list again
    ind = [i for i in range(0,nAns)]
    shuffle(ind)
    new_row = [new_row[i] for i in ind]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The method you want is <code>get_n_choices()</code> below. It uses <code>random.sample</code> to choose n-1 unique items from the answers list.</p>
<p>Remember to break your code up into functions to make it easier to read and work with. Also, when you find yourself writing an <code>if</code> block like your <code>if dr=='d'</code> and each of the choices looks almost the same as the others, that's a great indicator that you need to refactor that code into a single function.</p>
<pre><code>#!/usr/bin/env python3

from random import shuffle, sample
from collections import namedtuple

# namedtuple's provide a nice way of storing simple data and
# using names to access it.
Difficulty = namedtuple('Difficulty', ('name', 'num_answers'))
# Storing your difficulties in a dictionary allows for
# easy lookup.
Difficulty_Settings = {
    'e': Difficulty(name='easy', num_answers=3),
    'm': Difficulty(name='medium', num_answers=4),
    'd': Difficulty(name='difficult', num_answers=5),
}

# Note: There's no error handling here...
# - what if correct_answer_index isn't an integer?
# - what if that index isn't valid for answers?
# - what if answers isn't a list-like object?
def get_n_choices(n, answers, correct_answer_index):
    choices = [answers[correct_answer_index]]
    # Add n - 1 distinct samples from a new answers list
    # omitting the correct answer.
    choices += sample(answers[0:correct_answer_index]
                      + answers[correct_answer_index + 1:], n - 1)
    shuffle(choices)
    return choices


def handle_row(row, difficulty):
    num_choices = Difficulty_Settings[difficulty].num_answers
    # Use unpacking to avoid using indexes, i.e. no row[1], etc.
    # You can use the row you get from the csv reader here instead
    # of the split.
    question, *answers, correct_answer_index = row.split(',')
    # Now that we have the answers in their own list, fix the
    # correct answer index offset
    correct_answer_index = int(correct_answer_index) - 1
    choices = get_n_choices(num_choices, answers, correct_answer_index)
    # Ask question using choices
    print(question)
    print(choices)


if __name__ == '__main__':
    row = "what color is the sky?,red,purple,blue,yellow,green,3"
    handle_row(row, 'd')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I did think about reading all into a list, and then producing a random output, but it seemed terribly complex</p>
</blockquote>
<p>It is not and can lead to less repeatable code. And you can use <a href="https://docs.python.org/3/library/random.html#random.shuffle" rel="nofollow noreferrer">random.shuffle</a> to shuffle answers in list. Take a look at a code below: </p>
<pre><code>import random

def quiz(dr):
    rating_wrongs_count = {'d': 3, 'm': 2, 'e': 1}
    print("===History===")
    print("You have selected rating: ", dr)
    question_count = 0
    # number of wrong answers to include in choices
    wrongs_count = rating_wrongs_count[dr]
    while question_count &lt; 5:
        with open('myfile.txt', 'r') as f:
            reader = csv.reader(f, delimiter=",")
            answer = False
            while not answer:
                for row in reader:
                    correct_answer_idx = int(row[6])
                    correct_answer = row[correct_answer_idx]
                    # get all answers which are not correct answer
                    wrong_answers = [ans for ans in row[1:-1] if ans != correct_answer]
                    random.shuffle(wrong_answers)
                    # get wrongs_count wrong answers and append correct answer
                    choices = wrong_answers[:wrongs_count] + [correct_answer, ]
                    # shuffle and print that list
                    random.shuffle(choices)
                    print(row[0])
                    print("\n".join(choices))
</code></pre>
<p>Don't forget to set <code>answer</code> variable and increase <code>question_count</code> variable. I assume it is done later in your code somewhere.</p>
</div>
<span class="comment-copy">I'm not sure if I understand, all you really want is to print all answers in a random order?</span>
<span class="comment-copy">I think the SO also needs to ensure that the correct answer is included in that random order (that's the hard part).</span>
<span class="comment-copy">See it only now unfortunately, will include it in my answer.</span>
<span class="comment-copy">please see update in my Question</span>
<span class="comment-copy">please see the update in my question ...thanks for this, but it doesn't deal with duplicates at all does it? All the answers are included including the right answer, and one cannot guarantee in the shuffle it will turn up twice.</span>
<span class="comment-copy">@MissComputing fixed it - it's not very pretty but it works, consider turning it into a function for readability.</span>
<span class="comment-copy">are you able to use pythoncarrots answer below for the first part, and add the randomisation to it as an additional answer in your post? The one below seems simpler ....? Or is it?</span>
<span class="comment-copy">please see update in my question</span>
<span class="comment-copy">You should shuffle wrong_answers before you take wrongs_count from them or else you're always leaving out the later answers in easier levels.</span>
<span class="comment-copy">@Harvey fair point, missed that, thanks!</span>
