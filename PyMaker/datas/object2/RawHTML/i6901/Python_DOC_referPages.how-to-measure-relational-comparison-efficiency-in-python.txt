<div class="post-text" itemprop="text">
<p>I'm working on some Computer Science problems on CodeFights and then I found this problem, At first I couldn't understand why the first approach is considered as the best implementation for this context. </p>
<p>Can someone give me guidance on how to measure the relational comparison coding efficiency in Python?</p>
<blockquote>
<p>You would like to write a function that takes integer numbers x, y, L
  and R as parameters and returns True if xy lies in the interval (L, R]
  and False otherwise. You're considering several ways to write a
  conditional statement inside this function:</p>
</blockquote>
<pre><code>if L &lt; x ** y &lt;= R:
if x ** y &gt; L and x ** y &lt;= R:
if x ** y in range(L + 1, R + 1):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For microbenchmarking small snippets, take a look at <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">the <code>timeit</code> module</a>.</p>
<p>For the record, I strongly suspect <code>return L &lt; x ** y &lt;= R</code> will be the most efficient solution; it computes <code>x ** y</code> only once, short-circuits, and constructs no additional objects. It also uses the result of the test directly, rather than using <code>if</code> checks controlling explicit <code>return True</code> or <code>return False</code>. The equivalent <code>if</code> check would be the fastest if you have to choose; <code>range</code> tests are equally fast in theory, but constructing the <code>range</code> object, even in Py 3, would have a high fixed cost that the containment test wouldn't make up.</p>
</div>
<span class="comment-copy">Right, so in this case, the last option would be the less optimized because we have to construct the range object in the memory, but do you think that the first option in this scenario is considered as the best implementation because the Python supports this kind of comparison?</span>
<span class="comment-copy">@AlifyzF.Pires: Yes, Python actually guarantees the "single evaluation" of middle term as part of <a href="https://docs.python.org/3/reference/expressions.html#comparisons" rel="nofollow noreferrer">the language spec</a>: "Comparisons can be chained arbitrarily, e.g., x &lt; y &lt;= z is equivalent to x &lt; y and y &lt;= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x &lt; y is found to be false)." By contrast, the second form must compute <code>x ** y</code> twice; if <code>y</code> is large and <code>x</code> is non-trivial, this can take quite some time. It's otherwise equivalent to the first option, so try it out w/large values.</span>
