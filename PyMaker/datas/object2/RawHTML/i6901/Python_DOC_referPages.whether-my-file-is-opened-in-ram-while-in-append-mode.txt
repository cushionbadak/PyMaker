<div class="post-text" itemprop="text">
<p>I have written a code which keep on append the file. Here is the code for it:  </p>
<pre><code>writel = open('able.csv','a',encoding='utf-8',errors='ignore')
with open('test','r',encoding='utf-8',errors='ignore') as file:
    for i in file.readlines():
        data = functionforprocess(i)
        if data is not "":
            writel.write(data)
        if count% 10000 == 0:
            log = open('log','w')
            log.write(str(count))
            log.close()
</code></pre>
<p>My question is: whether the file that I have opened in the <code>append</code> mode is available in RAM? Does that file is acting like a buffer, means If I store the <code>data</code> in variable and then write the variable to file is equal to open a file in append mode and write directly?  </p>
<p>Kindly, get me out of this confusion.</p>
</div>
<div class="post-text" itemprop="text">
<p>Appending is a basic function of file I/O and is carried out by the operating system.  For instance, fopen with mode <code>a</code> or <code>a+</code> is part of the POSIX standard.  With file I/O, the OS will also tend to buffer reads and writes; for instance, for most purposes it's not necessary to make sure that the data that you've passed to <code>write</code> is actually on the disk all the time.  Sometimes it sits in a buffer somewhere in the OS; sometimes the OS dumps these buffers out to disk.  You can force writes using <code>fsync</code> if it's important to you; this is also a really good reason to make sure that you always call <code>close</code> on your open file objects when you're done with them (or use a context manager); if you forget, you might get weird behaviour because of those buffers hanging around in the OS.</p>
<p>So, to answer your question.  The file that you opened is most likely in RAM at any given moment.  However, as far as I know, it's not <em>available</em> to you.  You can interact with the data in the file using file I/O methods, but it's not like there's a buffer that you can get the memory address of, and read back what you just wrote.  As to if append-mode writing is equivalent to storing something in a buffer and then writing to disk, I guess I would say no.  Any kind of file I/O write will probably be buffered the same way by the OS, and the reason this is efficient is that the OS gets to make the decision on when to flush the buffers.  If you store things in a variable and then write them out atomically to disk, you get to decide when the writes take place.</p>
</div>
<div class="post-text" itemprop="text">
<p>The signature of the <a href="https://docs.python.org/3/library/functions.html?highlight=open#open" rel="nofollow noreferrer"><code>open</code> function</a> is:</p>
<pre><code>open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
</code></pre>
<p>If you open in "a" (append) mode, it means: open for writing, appending to the end of the file if it exists. There is nothing about buffering. </p>
<p>Buffering can be customized with the <em>buffering</em> parameter. Quoting the doc:</p>
<blockquote>
<p><em>buffering</em> is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable in text mode), and an integer &gt; 1 to indicate the size in bytes of a fixed-size chunk buffer. When no buffering argument is given, the default buffering policy works as follows:</p>
<ul>
<li>Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on io.DEFAULT_BUFFER_SIZE. On many systems, the buffer will typically be 4096 or 8192 bytes long.</li>
<li>“Interactive” text files (files for which isatty() returns True) use line buffering. Other text files use the policy described above for binary files.</li>
</ul>
</blockquote>
<p>In your example, your file is opened for append in text mode.</p>
<p>So, only a chunk of your data is stored in RAM during writing. If you write a "big" data, it will be divided into several chunks.</p>
</div>
<span class="comment-copy">No, in append mode the file is not in RAM. Only the position is sought to the end. Then, on next write, the buffer is flushed and appended to the end.</span>
<span class="comment-copy">Do you need more explanation? I suggest you to upvote and <a href="https://meta.stackexchange.com/a/5235/344471">accept</a> my answer.</span>
