<div class="post-text" itemprop="text">
<p>I'm trying to combine 2 lists that have different data and size into 1, and have the smaller list "wrap" around. I'm looking for a clean way to do this, e.g.</p>
<p>Input:</p>
<pre><code>list1 = ['apple', 'orange', 'strawberry', 'avocado']
list2 = ['1','2','3']
</code></pre>
<p>Output:</p>
<pre><code>[ 
    {"l1": "apple", "l2": "1"}, 
    {"l1": "orange", "l2": "2"}, 
    {"l1": "strawberry", "l2": "3"}, 
    {"l1": "avocado", "l2": "1"}
 ]
</code></pre>
<p>Notice that for <code>"avocado"</code>, we went back to <code>"1"</code> and wrapped around list2.</p>
<p>The obvious (and ugly looking) solution is to just start with an empty list, have 2 indexes in a loop, each iteration append a new list item, and the smaller one 'wraps' to the beginning when it reaches the end. Is there a clean way of doing this in Python 2.7?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="noreferrer"><code>itertools.cycle</code></a> to wrap the second list:</p>
<pre><code>from itertools import cycle

lst = [dict(zip(['l1', 'l2'], tup)) for tup in zip(list1, cycle(list2))]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a generator that avoids appending to an empty list:</p>
<pre><code>def func(l1, l2):
    length1 = len(l1)
    length2 = len(l2)
    for idx in range(max(length1, length2)):
        # I use the modulo so the indices wrap around.
        yield {'l1': l1[idx % length1], 'l2': l2[idx % length2]}

list(func(list1, list2))
# [{'l1': 'apple', 'l2': '1'},
#  {'l1': 'orange', 'l2': '2'},
#  {'l1': 'strawberry', 'l2': '3'},
#  {'l1': 'avocado', 'l2': '1'}]
</code></pre>
<p>However <code>itertools.cycle</code> (see the other answer) is probably much better.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can merely use <code>enumerate</code> for simplicity; however, a cleaner solution would involve <code>itertools.cycle</code>:</p>
<pre><code>list1 = ['apple', 'orange', 'strawberry', 'avocado']
list2 = ['1','2','3']
new_list = [{"li":a, "l2":list2[i%len(list2)]} for i, a in enumerate(list1)]
</code></pre>
<p>Output:</p>
<pre><code>[{'l2': '1', 'li': 'apple'}, {'l2': '2', 'li': 'orange'}, {'l2': '3', 'li': 'strawberry'}, {'l2': '1', 'li': 'avocado'}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def processing(opt, longlist, shortlist):
  def processing_iter(inL, refL, outL):
    if refL == []:
      return outL
    elif inL == []:
      return processing_iter(shortlist, refL[1:], outL+opt(refL[0], shortlist[0]))
    else:
      return processing_iter(inL[1:], refL[1:], outL+opt(refL[0], inL[0]))
  return processing_iter(shortlist, longlist, [])


def makedict(a,b): return [{"l1":a, "l2":b}]

list1 = ['apple', 'orange', 'strawberry', 'avocado']
list2 = ['1','2','3']
print(processing(makedict,list1, list2))
</code></pre>
</div>
<span class="comment-copy">Consider <code>itertools.izip</code> along <code>itertools.cycle</code> on your shorter list.</span>
<span class="comment-copy">Apologies.  I just noticed that our answers are the same and that yours came earlier.  Add the timings to yours, and I'll delete mine.</span>
<span class="comment-copy">@Alexander No problem at all! Thank you.</span>
