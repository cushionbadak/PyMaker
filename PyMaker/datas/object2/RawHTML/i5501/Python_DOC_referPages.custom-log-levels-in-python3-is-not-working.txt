<div class="post-text" itemprop="text">
<p>I have changed the numeric value of log levels using addLevelName() and then put logs in my modules but in the log file the log.error is giving me level name as DEBUG.
Here is the piece of code that am trying to </p>
<pre><code>class LogAttribute:

def __init__(self):

    logger = logging.getLogger()

    logging.addLevelName(50, "ERROR")
    logging.addLevelName(40, "DEBUG")
    logging.addLevelName(30, "WARNING")
    logging.addLevelName(20, "INFO")
    logging.addLevelName(10, "VERBOSE")

    check = logging.getLevelName(40)
    logger.setLevel(config_obj["loggerLevel"])
    output_dir = (os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    filename = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")+"_EP_script.log"
    handler = logging.FileHandler(os.path.join(output_dir, filename))
    formatter = logging.Formatter(" %(levelname)s - %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>logging</code> module is not set up for arbitrary re-assignment of the standard logging levels. The <code>logging.addLevelName()</code> method is really only meant to add <em>new</em> levels, not for adjusting existing levels.</p>
<p>What happens under the hood is that <code>logging.error()</code> uses the module-level constant <code>logging.ERROR</code> to log the error message. That constant has been set to <code>40</code>, a numeric value you just told the module to map to the string <code>'DEBUG'</code>.</p>
<p>If you really must re-map all the levels, you also need to reassign the constants. Because Python is a dynamic language, that is certainly possible:</p>
<pre><code>logging.ERROR = 50
</code></pre>
<p>However, I <strong>strongly</strong> advice you not to do this. There may be 3rd-party frameworks that rely on the constants to stay, well, <em>constant</em>.</p>
<p>If you are trying to adjust how a third-party library logging, you have better options. Each log message includes a logger name, and names with a <code>.</code> in them form a <em>hierarchy</em>, so a logger name of <code>foo.bar.baz</code> is seen as a child of <code>foo.bar</code> and <code>foo</code>, letting you adjust logging for child logging nodes by settings on a parent node. See the <a href="https://docs.python.org/3/library/logging.html#logger-objects" rel="nofollow noreferrer"><em>Logger objects</em> documentation intro</a> for details and how to configure these.</p>
<p>Even if the per-logger-object and per-hierarchy configuration options do not fit your specific use case, you can almost certainly <em>monkeypatch</em> such a module to replace the logger object with a custom wrapper based on the <a href="https://docs.python.org/3/library/logging.html#loggeradapter-objects" rel="nofollow noreferrer"><code>LoggerAdapter</code> pattern</a>. That's because the <em>standard, best practice</em> method of logging in a 3rd party library is to create a top-level <code>logger</code> object and apply all logging to that object. You can replace that object with a wrapper:</p>
<pre><code>import logging

level_map = {
    logging.ERROR: logging.CRITICAL,
    logging.DEBUG: logging.ERROR
}

class RemappingLogger(logging.LoggerAdapter):
    def __init__(self, logger, extra=None):
        # make the extra parameter optional
        if extra is None:
            extra = {}
        super().__init__(logger, extra)

    def log(self, lvl, *args, **kwargs):
        lvl = level_map.get(lvl, lvl)
        super().log(lvl, *args, **kwargs)


import somelibrary
import somelibrary.submodule

somelibrary.logger = RemappingLogger(somelibrary.logger)
somelibrary.submodule.logger = RemappingLogger(somelibrary.submodule.logger)
</code></pre>
<p>You can use the same pattern to filter specific messages; it may be sufficient to provide a custom <code>LoggingAdapter.process()</code> method in that case.</p>
</div>
<span class="comment-copy">i have a main.py file which calls different modules, and have put logs into it</span>
<span class="comment-copy">logging.error("{} - media_data is empty No data to save".format(<b>name</b>))</span>
<span class="comment-copy">This log gives me output as following, DEBUG - src.acms.media_list - The submitted id 200755730 is invalid</span>
<span class="comment-copy">Custom log levels are not designed to let you re-target the standard existing levels.</span>
<span class="comment-copy"><code>logging.error()</code> uses the module-level constant <code>logging.ERROR</code>, which is set to <code>40</code>.</span>
<span class="comment-copy">Also there is one issue, whenever i set loggerLevel to INFO i have this log,INFO - Starting new HTTPS connection (1): api.airtime.geemedia.com, which am really not interested in, how do i disable it</span>
<span class="comment-copy">I don't know. What library is logging this? Are they using a dedicated <code>logging.getLogger()</code> instance?</span>
<span class="comment-copy">The requests library is logging this, requests.packages.urllib3.connectionpool this is the file heirarchy from where it comes</span>
<span class="comment-copy">@tintin: then just disable that logger. Why do you need to alter the levels here?</span>
<span class="comment-copy">@tintin: I have added a better option to handle logging configuration in 3rd-party modules. Rather than globally change the meaning of levels, adapt levels on a case-by-case basis for a given library.</span>
