<div class="post-text" itemprop="text">
<p>I have an array, let's say arr = [1, 2, 3, 4, 5, 6, 7, 8]
and another indices array: idx = [0, 3, 4, 6]</p>
<p>and I want to get two arrays, one is only those indices from arr: [1, 4, 5, 7]
and another one is all the rest: [2, 3, 6, 8]</p>
<p>Can someone help me with that? I can only think of ugly ways to do it, but it must be some function that does it elegantly. </p>
<p>Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do it like this:</p>
<pre><code>selected = [arr[i] for i in idx]
other = [v for i, v in enumerate(arr) if i not in idx]
</code></pre>
<p>If <code>arr</code> has no duplicates, you could also do:</p>
<pre><code>other = [v for v in arr if v not in selected]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Way to do it:</p>
<pre><code>a1 = [arr[x] for x in idx] 
a2 = [x for x in arr if x not in a1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With one traversal:</p>
<pre><code>no, yes = both = [], []
for i, x in enumerate(arr):
    both[i in idx].append(x)
</code></pre>
<p>Or (as commented by Chris_Rands):</p>
<pre><code>yes, no = [], []
for i, x in enumerate(arr):
    (yes if i in idx else no).append(x)
</code></pre>
<p>Though <code>idx</code> should either be small for this or turned into a set (same goes for the solutions in the other answers, I guess they just don't want to talk about it).</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; if 1:
    arr = [1, 2, 3, 4, 5, 6, 7, 8]
    idx = [0, 3, 4, 6]
    no, yes = both = [], []
    for i, x in enumerate(arr):
        both[i in idx].append(x)
    print('yes', yes)
    print('no', no)

yes [1, 4, 5, 7]
no [2, 3, 6, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is a neat solution with <code>numpy</code>:</p>
<pre><code>import numpy as np

arr = np.asarray([1, 2, 3, 4, 5, 6, 7, 8])  # converts your list in numpy array
idx1 = [0, 3, 4, 6]
idx2 = [1, 2, 5, 7]

arr1 = arr[idx1]  # [1 4 5 7]
arr2 = arr[idx2]  # [2 3 6 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>itertools</code> for a one line solution:</p>
<pre><code>import itertools
arr = [1, 2, 3, 4, 5, 6, 7, 8]
idx = [0, 3, 4, 6]
[(out_index, not_in_arr), (in_index, in_arr)] = [(a, list(b)) for a, b in itertools.groupby(sorted(arr, key=lambda x:arr.index(x) in idx), key=lambda x:arr.index(x) in idx)]
print(not_in_arr)
print(in_arr)
</code></pre>
<p>Output:</p>
<pre><code>[2, 3, 6, 8]
[1, 4, 5, 7]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also map each value in <code>arr</code> to a dictionary, indicating if it's index is present in <code>idx</code>:</p>
<pre><code>arr = [1, 2, 3, 4, 5, 6, 7, 8]
idx = [0, 3, 4, 6]

# converted to a set
idx_lookup = set(idx)

d = {x: True if i in idx_lookup else False for i, x in enumerate(arr)}
print(d)
</code></pre>
<p>Which gives this dictionay:</p>
<pre><code>{1: True, 2: False, 3: False, 4: True, 5: True, 6: False, 7: True, 8: False}
</code></pre>
<p>I also converted <code>idx</code> to a set since in this case, duplicate indices are not necessary, and set/dictionary lookup is <code>O(1)</code>. However, list lookup is <code>O(n)</code>, so this optimization is worth it if possible. </p>
<p>Once you have this dictionary,  you can <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer"><code>filter</code></a> out the elements you want to keep, and the rest of the elements from this:</p>
<pre><code>keep = list(filter(lambda x: d[x], arr))
rest = list(filter(lambda x: not d[x], arr))

print(keep)
print(rest)
</code></pre>
<p>Which Outputs:</p>
<pre><code>[1, 4, 5, 7]
[2, 3, 6, 8]
</code></pre>
<p><strong>Note:</strong> You can also use list comprehensions above filtering of <code>keep</code> and <code>rest</code>:</p>
<pre><code>keep = [x for x in arr if d[x]]
rest = [x for x in arr if not d[x]]
</code></pre>
</div>
<span class="comment-copy">Works great. Thanks a lot!</span>
<span class="comment-copy">i find more readable <code>(yes if i in idx else no).append(x)</code></span>
<span class="comment-copy">@Chris_Rands Hmm, what if I rename <code>both</code> to <code>noyes</code> or <code>no_yes</code>?</span>
<span class="comment-copy">Well it's subjective I guess, but personally I prefer the other way, plus it might be less confusing for beginners perhaps</span>
<span class="comment-copy">@Chris_Rands Ok, I'll add it. I thought one reason I started using mine was that it was faster, but I just timed it again and it was slower. Thanks.</span>
