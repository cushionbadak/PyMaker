<div class="post-text" itemprop="text">
<p>Overriding and inheritance is seeming to work differently than I expect, let me explain this situation.  I have three classes:  Card, Treasure, and Copper.  Copper inherits from Treasure and Treasure inherits from Card.  The only difference between Treasure and Card is a single method that Treasure overrides.  The only difference between Treasure and Copper is an attribute that Copper overrides.  The attribute that Copper overrides is originally from Card and it is an attribute that Treasure uses in its unique method.  The issue that I'm running into is that when Copper's method is being called that it inherits from Treasure, it is still using Card's attribute value, not the attribute value that Copper should be overriding it with.  Below is some code, any help is appreciated.</p>
<p>Card Class:</p>
<pre><code>class Card:
    normal_full_table = 6
    pile_player_rate = 10

    @staticmethod
    def pile_setup(player_count):
        pass
</code></pre>
<p>Treasure Class:</p>
<pre><code>from card.card import Card
from math import floor

class Treasure(Card):
    @staticmethod
    def pile_setup(player_count):
        return (floor(player_count/Card.normal_full_table) + 1) * Card.pile_player_rate
</code></pre>
<p>Copper Class:</p>
<pre><code>from card.basic.card_treasure import Treasure


class Copper(Treasure):
    pile_player_rate = 60
</code></pre>
<p>What I would expect to happen is when Copper.pile_setup(6) is called that the value pile_player_rate to be 60 since Copper is overriding that value but upon inspection it is still 10.  Why is this?  Is this because I'm saying specifically Card.pile_player_rate?  How can I get Copper to use it unique value for pile_player_rate rather than the generic one in Card?  Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>A sounder way to implement this would be a <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>classmethod</code></a>. That allows you to dynamically access the attributes of the class that the method is called on:</p>
<pre><code>class Treasure(Card):
    @classmethod
    def pile_setup(cls, player_count):
        return (floor(player_count/cls.normal_full_table) + 1) * cls.pile_player_rate
</code></pre>
<p>You could implement this method on <code>Card</code>, and without overriding it, it would access the attributes of <code>Treasure</code> when called on <code>Treasure</code>.</p>
</div>
<span class="comment-copy">It's using the values from <code>Card</code> because you're explicitly telling it to.</span>
<span class="comment-copy">You don't access <code>Copper</code>'s <code>pile_player_rate</code>, you <b>explicitly</b> access the root <code>Card.pile_player_rate</code>. If that's not the behaviour you want, that shouldn't be a static method; make it a <code>@classmethod</code>, and access the attribute via <code>cls</code>.</span>
<span class="comment-copy">Yeah that is exactly what I was looking for.  Thanks!</span>
<span class="comment-copy">Yeah this is exactly what I was looking for, thanks!</span>
