<div class="post-text" itemprop="text">
<p>I have a list of coordinates (x,y).</p>
<p>What is the most efficient way to compute the distance between each coordinate ?</p>
<p>So far it seems like I have to do something like:</p>
<pre><code>for coord1 in coordinates:
    for coord2 in coordinates:
        if (not_already_done_(coord1,coord2)):
            dist = math.hypot(coord2.x - coord1.x, coord2.y - coord1.y)
            save_dist(dist,coord1,coord2)
</code></pre>
<p>Is there no faster way ? Or atleast is there a better way to write it ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer">itertools.combinations</a>:</p>
<pre><code>from math import hypot
from itertools import combinations

coordinates = [(1, 1), (2, 2), (-2, 5)]

distances = {(a,b): hypot(a[0] - b[0], a[1] - b[1])
             for a, b in combinations(coordinates, 2)}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about:</p>
<pre><code>for n, coord1 in enumerate(coordinates[:-1]):
    for coord2 in coordinates[n+1:]:
        dist = math.hypot(coord2.x - coord1.x, coord2.y - coord1.y)
        save_dist(dist,coord1,coord2)
</code></pre>
<p>or:</p>
<pre><code>for n in range(len(coordinates) - 1):
    coord1 = coordinates[n] 
    for m in range(n+1, len(coordinates)):
        coord2 = coordinates[m]
        dist = math.hypot(coord2.x - coord1.x, coord2.y - coord1.y)
        save_dist(dist,coord1,coord2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also embed a <code>distance</code> function in your class, which calculates the distance between a coordinate and another coordinate. Your class would then look something like this:</p>
<pre><code>from math import hypot

class Coordinate(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def getX(self):
        return self.x

    def getY(self):
        return self.y

    def distance(self, other):
        dx = self.x - other.x
        dy = self.y - other.y

        return hypot(dx, dy)
</code></pre>
<p>Then you could just use <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow noreferrer"><code>itertools.combinations</code></a> to get the coordinate distances between the <code>Coordinate</code> objects, as others have suggested:</p>
<pre><code>coordinates = [Coordinate(1, 2), Coordinate(2, 3), Coordinate(3, 4)]

distances = [[(c1.getX(), c1.getY()), (c2.getX(), c2.getY()), c1.distance(c2)] for c1, c2 in combinations(coordinates, 2)]

print(distances)
</code></pre>
<p>Which Outputs:</p>
<pre><code>[[(1, 2), (2, 3), 1.4142135623730951], [(1, 2), (3, 4), 2.8284271247461903], [(2, 3), (3, 4), 1.4142135623730951]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use list comprehension over multiple index rages:</p>
<pre><code>from math import hypot

# assume l is a sequence of (x,y) coordinates
distances = [(hypot(l[i][0]-l[j][0],l[i][1]-l[j][1]), l[i], l[j]) for i in range(len(l)) for j in range(i+1, len(l))]
</code></pre>
<p>You can make it more readable by extracting the distance calculation into its own named function.</p>
</div>
<span class="comment-copy"><code>itertools.combinations()</code> instead of a product, at least, so you don't need to check if it's done already.</span>
<span class="comment-copy">No libraries possible?</span>
<span class="comment-copy">Can I ask - what if the coordinates, was a list of objects, instead of a list of tuples ? Does it matter ?</span>
<span class="comment-copy">@KaizerSozay It doesn't</span>
<span class="comment-copy">This will create a physical copy of the slice on each iteration.</span>
<span class="comment-copy">True.  Added an alternative that just uses integer indexing ("writing a C program in Python") but still avoids the necessity for the <code>not_already_done_</code> function.</span>
