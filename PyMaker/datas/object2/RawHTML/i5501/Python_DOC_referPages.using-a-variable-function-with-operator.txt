<div class="post-text" itemprop="text">
<p>I'm messing around with * and **, and figuring out what the use-cases of these operators would be. For this "study", I wrote a function <code>scandir_and_execute</code> that traverses a directory (recursive by default) and executes a function <code>exec_func</code> on each file that is encountered. The function is variable, meaning when calling <code>scandir_and_execute</code> the programmer can indicate which function to run on every file. In addition, to figure out <code>*</code>, I added a <code>func_args</code> variable (defaults to an empty list) that can hold any number of argument.</p>
<p>The idea is that the programmer can use any <code>exec_func</code> that they have defined (or built-in) to which the file is the first argument, and that they provide the needed arguments themselves, in a list, which is then expanded on the <code>exec_func</code> call.</p>
<p><em>Note: at least Python 3.5 is required to run this function.</em></p>
<pre><code>import os

def scandir_and_execute(root, exec_func, func_args=[], recursive=True, verbose=False):
    if verbose:
        print(f"TRAVERSING {root}")

    # Use scandir to return iterator rather than list
    for entry in os.scandir(root):
        if entry.is_dir() and not entry.name.startswith('.'):
            if recursive:
                scan_and_execute(entry.path, exec_func, func_args, True, verbose)
        elif entry.is_file():
            if verbose:
                print(f"\tProcessing {entry.name}")

            # Unpack (splat) argument list, i.e. turn func_args into separate arguments and run exec_func
            exec_func(entry.path, *func_args)
</code></pre>
<p>Is this the correct way to use <code>*</code>, or am I misinterpreting the documentation and the concept of the operator? The function works, as far as I have tested it, but perhaps there are some caveats or non-pythonic things that I did? For instance, would it be better to write the function like this where the unnamed "superfluous" arguments are tupled together (or another way)?</p>
<pre><code>def scandir_and_execute(root, exec_func, recursive=True, verbose=False, *func_args):
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>That <em>is</em> how you use the splat operator, but consider whether it needs to be your function’s responsibility to pas arguments at all. Say you’re using it like this now:</p>
<pre><code>scandir_and_execute(root, foo, (foo_arg1, foo_arg2), recursive=True)
</code></pre>
<p>you can rewrite <code>scandir_and_execute</code> to accept a callable taking one argument:</p>
<pre><code>def scandir_and_execute(root, exec_func, recursive=True, verbose=False):
    if verbose:
        print(f"TRAVERSING {root}")

    # Use scandir to return iterator rather than list
    for entry in os.scandir(root):
        if entry.is_dir() and not entry.name.startswith('.'):
            if recursive:
                scandir_and_execute(entry.path, exec_func, True, verbose)
        elif entry.is_file():
            if verbose:
                print(f"\tProcessing {entry.name}")

            exec_func(entry.path)
</code></pre>
<p>and let the caller handle its business:</p>
<pre><code>scandir_and_execute(root, lambda path: foo(path, foo_arg1, foo_arg2))
</code></pre>
<p>Then drop the callback entirely and make a generator:</p>
<pre><code>def scandir(root, recursive=True, verbose=False):
    if verbose:
        print(f"TRAVERSING {root}")

    # Use scandir to return iterator rather than list
    for entry in os.scandir(root):
        if entry.is_dir() and not entry.name.startswith('.'):
            if recursive:
                yield from scandir(entry.path, True, verbose)
        elif entry.is_file():
            if verbose:
                print(f"\tProcessing {entry.name}")

            yield entry.path
</code></pre>
<pre><code>for path in scandir(root, recursive=True):
    foo(path, foo_arg1, foo_arg2)
</code></pre>
<p>(Close to <a href="https://docs.python.org/3/library/os.html#os.walk" rel="nofollow noreferrer"><code>walk</code></a>, but not quite!) Now the non-recursive version is just this generator:</p>
<pre><code>(entry.path for entry in os.scandir(root) if entry.is_file())
</code></pre>
<p>so you may as well provide only the recursive version:</p>
<pre><code>import os


def is_hidden(dir_entry):
    return dir_entry.name.startswith('.')


def scandir_recursive(root, *, exclude_dir=is_hidden):
    for entry in os.scandir(root):
        yield entry

        if entry.is_dir() and not exclude_dir(entry):
            yield from scandir_recursive(entry.path, exclude_dir=exclude_dir)
</code></pre>
<pre><code>import <strong><a href="https://docs.python.org/3/library/logging.html" rel="nofollow noreferrer" title="16.6. logging — Logging facility for Python — Python 3.6.4 documentation">logging</a></strong>

logging.info(f'TRAVERSING {root}')

for entry in scandir_recursive(root):
    if entry.is_dir():
        logging.info(f'TRAVERSING {entry.path}')
    elif entry.is_file():
        logging.info(f'\tProcessing {entry.name}')
        foo(entry.path, foo_arg1, foo_arg2)</code></pre>
</div>
<span class="comment-copy">Note that <code>func(args=[])</code> is not the same as <code>func(*args)</code>. You'd call the first as <code>func([a, b, c])</code> and the latter as <code>func(a, b, c)</code>. Also, note that using <code>[]</code> as a default is not good practice (but probably not a problem in this case) as that will be <i>the same</i> list instance each time you call the function.</span>
<span class="comment-copy">@tobias_k I was aware of the first comment, not of the second! Could you give me any pointers what to change, and where I can find more information on this?</span>
<span class="comment-copy">@BramVanroy <a href="https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument" title="least astonishment and the mutable default argument">stackoverflow.com/questions/1132941/…</a></span>
<span class="comment-copy">using <code>*</code> is the same as unpacking iterable objects in passing parameters. for example, <code>a = [1, 2, 3]</code>, <code>*a =&gt; 1, 2, 3</code>.</span>
<span class="comment-copy">I’m thinking this is a C-ism? You should drop <code>func_args</code> and let people pass in <code>exec_func=lambda x: foo(x, …)</code> if they need that.</span>
<span class="comment-copy">I understand what you're saying, thanks. For me, still getting my head around generators and <code>yield</code>, I prefer the readability of the first example (with the lambda expression). Would there be a performance gain using a generator (your example) in comparison to my initial function?</span>
<span class="comment-copy">@BramVanroy: No performance difference; the separated/generator version is just for improved readability and flexibility.</span>
