<div class="post-text" itemprop="text">
<p>I have a large number of entries in a file. Let me call it file A.</p>
<p>File A:</p>
<blockquote>
<p>('aaa.dat', 'aaa.dat', 'aaa.dat') </p>
<p>('aaa.dat', 'aaa.dat', 'bbb.dat')</p>
<p>('aaa.dat', 'aaa.dat', 'ccc.dat')</p>
</blockquote>
<p>I want to use these entries, line by line, in a program that would iteratively pick an entry from file A, concatenate the files in this way:</p>
<pre><code>filenames = ['aaa.dat', 'aaa.dat', 'ccc.dat'] ###entry number 3
with open('out.dat', 'w') as outfile:   ###the name has to be aaa-aaa-ccc.dat
    for fname in filenames:
        with open(fname) as infile:
            outfile.write(infile.read().strip()) 
</code></pre>
<p>All I need to do is to substitute the filenames iteratively and create an output in a "aaa-aaa-aaa.dat" format. I would appreciate any help-- feeling a bit lost!</p>
<p>Many thanks!!!</p>
</div>
<div class="post-text" itemprop="text">
<p>You can retrieve and modify the file names in the following way:</p>
<pre><code>import re
pattern = re.compile('\W')

with open('fnames.txt', 'r') as infile:
    for line in infile:
        line = (re.sub(pattern, ' ', line)).split()
        # Old filenames - to concatenate contents
        content = [x + '.dat' for x in line[::2]];
        # New filename
        new_name = ('-').join(line[::2]) + '.dat'
        # Write the concatenated content to the new
        # file (first read the content all at once) 
        with open(new_name, 'w') as outfile:
            for con in content:
                with open(con, 'r') as old:
                    new_content = old.read()
                    outfile.write(new_content)
</code></pre>
<p>This program reads your input file, here named <code>fnames.txt</code> with the exact structure from your post, line by line. For each line it splits the entries using a precompiled regex (precompiling regex is suitable here and should make things faster). This assumes that your filenames are only alphanumeric characters, since the regex substitutes all non-alphanumeric characters with a space. </p>
<p>It retrieves only <code>'aaa'</code> and <code>dat</code> entries as a list of strings for each line and forms a new name by joining every second entry starting from 0 and adding a <code>.dat</code> extension to it. It joins using a <code>-</code> as in the post. </p>
<p>It then retrieves the individual file names from which it will extract the content into a list <code>content</code> by selecting every second entry from <code>line</code>. </p>
<p>Finally, it reads each of the files in <code>content</code> and writes them to the common file <code>new_name</code>. It reads each of them all at ones which may be a problem if these files are big and in general there may be more efficient ways of doing all this. Also, if you are planning to do more things with the content from old files before writing, consider moving the old file-specific operations to a separate function for readability and any potential debugging. </p>
</div>
<div class="post-text" itemprop="text">
<p>Something like this:</p>
<pre><code>with open(fname) as infile, open('out.dat', 'w') as outfile:
    for line in infile:
        line = line.strip()
        if line:  # not empty
            filenames = eval(line.strip())  # read tuple
            filenames = [f[:-4] for f in filenames]  # remove extension
            filename = '-'.join(filenames) + '.dat'  # make filename
            outfile.write(filename + '\n')  # write
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your problem is just calculating the new filenames, how about using <a href="https://docs.python.org/2/library/os.path.html#os.path.splitext" rel="nofollow noreferrer"><code>os.path.splitext</code></a>?</p>
<pre><code>'-'.join([
   f[0] for f in [os.path.splitext(path) for path in filenames]
]) + '.dat'
</code></pre>
<p>Which can be probably better understood if you see it like this:</p>
<pre><code>import os

clean_fnames = []
filenames = ['aaa.dat', 'aaa.dat', 'ccc.dat']
for fname in filenames:
    name, extension = os.path.splitext(fname)
    clean_fnames.append(name)

name_without_ext = '-'.join(clean_fnames)
name_with_ext = name_without_ext + '.dat'
print(name_with_ext)
</code></pre>
<p><strong>HOWEVER</strong>: If your issue is that you can not get the <code>filenames</code> in a list by reading the file line by line, you must keep in mind that when you read files, you get text (strings) <strong>NOT</strong> Python structures. You need to rebuild a <code>list</code> from a text like: <code>"('aaa.dat', 'aaa.dat', 'aaa.dat')\n"</code>. </p>
<p>You could take a look to <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer"><code>ast.literal_eval</code></a> or try to rebuild it yourself. The code below outputs a lot of messages to show what's happening:</p>
<pre><code>import pprint

collected_fnames = []
with open('./fileA.txt') as f:
    for line in f:
        print("Read this (literal) line: %s" % repr(line))
        line_without_whitespaces_on_the_sides = line.strip()
        if not line_without_whitespaces_on_the_sides:
            print("line is empty... skipping")
            continue
        else:
            line_without_parenthesis = (
                line_without_whitespaces_on_the_sides
                .lstrip('(')
                .rstrip(')')
            )
            print("Cleaned parenthesis: %s" % line_without_parenthesis)
            chunks = line_without_parenthesis.split(', ')
            print("Collected %s chunks in a %s: %s" % (len(chunks), type(chunks), chunks))
            chunks_without_quotations = [chunk.replace("'", "") for chunk in chunks]
            print("Now we don't have quotations: %s" % chunks_without_quotations)
            collected_fnames.append(chunks_without_quotations)

print("collected %s lines with filenames:\n%s" %
      (len(collected_fnames), pprint.pformat(collected_fnames)))
</code></pre>
</div>
<span class="comment-copy">Is the file literally in the form you are showing it? I mean, with the brackets and quotations?</span>
<span class="comment-copy">Yes, it is, correct</span>
<span class="comment-copy">It's still not clear to me though, you want an output file with concatenated names from the input file? Or an output file which name is the concatenated name?</span>
<span class="comment-copy">I want both. The bit of code does the concatenation, all i need to do is to make sure that i use entries from file A, iteratively, producing aaaaaaaaa entry for the first file that should be named aaa-aaa-aaa.dat (first line of file A) and so on, all the way to the last, 8000th entry.</span>
<span class="comment-copy">thank you! this helps with the filenames, which solved one part of the question, but i am not sure this is the complete solution: I need to make sure I create those files and also have the correct entries in each...</span>
<span class="comment-copy">Ok, I'll add it but just to confirm (or maybe add expected output to the post) - you want every file to be named as the concatenated file and have the concatenation components (except extension) as file body? i.e. file named aaa-aaa-aaa.dat will have aaaaaaaa inside and file named aaa-aaa-ccc.dat will have only aaaaaaccc in it?</span>
<span class="comment-copy">Thank you so much. That is correct. I have all individual files, like aaa.dat or ccc.dat, so i think the best thing would be not to expect that ccc is always ccc but to refer to the information in the original (unconcatenated) file.</span>
<span class="comment-copy">Here it is. Let me know if you need anything else in there.</span>
<span class="comment-copy">Thank you atru, it works wonderfully.  The only problem is that if i decided to have the filename not equal to its content, that would be problematic: what if aaa.dat is contained “aat”, or “CO=ON”?</span>
