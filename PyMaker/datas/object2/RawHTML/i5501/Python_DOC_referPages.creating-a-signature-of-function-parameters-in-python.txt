<div class="post-text" itemprop="text">
<p>I have a function takes a long time and needs to be able to cache its own results for when it is called again with the same parameters.  See example below which seems to solve the problem.  I'm using Python 3.6</p>
<p>My questions revolved around this line:</p>
<pre><code>param_sig = repr(locals())
</code></pre>
<p>1) is there a more Pythonic way to get a unique signature of the parameters passed to a function?</p>
<p>2) Can I rely on Python's insertion order of the function parameters into the locals() map?  Again, this seems to work, but if needed I can just explicitly relist every parameter in a less elegant signature creator like:</p>
<pre><code>param_sig = "{},{},{}".format(a,b,c)
</code></pre>
<p>Example code:</p>
<pre><code>import random
cached_answers = {}

def f(a=1, b=2, c=3):
    param_sig = repr(locals())
    if param_sig in cached_answers:
        ans = cached_answers[param_sig]
        print("Call: {} = CACHED {}".format(param_sig,ans))
        return ans
    else:
        # do heavy lifting then cache the result
        ans = random.random()
        print("Call: {} = {}".format(param_sig,ans))
        cached_answers[param_sig] = ans
        return ans

# various calls... some of which are repeated and should be cached
f()
f(b=9)
f(c=9, a=9)
f()               # should be cached
parms={'a':9}
f(**parms)
f(b=9)            # should be cached
f(a=9)            # should be cached
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>repr(locals())</code> is quite bad, as it is not intended for this function. It will work, or otherwise can be made to work, and I could dig in some problems other than the semantics of doing that.</p>
<p>I will come back to the problem - first, your solution:</p>
<p>Python has a cache function just like what you need in the <code>functools</code> module on the stdlib - just import it and use it as a decorator:</p>
<pre><code>from functools import lru_cache

@lru_cache()
def f(a=1, b=2, c=3):
   # just put the heavy stuff inside your original "else" clause here
</code></pre>
<p>Now to understand why decorators a better solution there: the logic of caching your results is not mixed with the logic of your function at all, and moreover, whatever method is used for caching can be used for the caching of any function in your program -  no need to copy the caching code inside each function body.</p>
<p>You will learn that while Python's own <code>lru_cache</code>  is a match for your case, it is not the best match and not perfect for all cases - in any way, you will be better either installing a 3rd party package for caching or rolling your own caching, but keeping the logic separate.</p>
<p>The idea of a certain programing logic that can apply to various similar functions or methods in a system is otherwise known as <a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="nofollow noreferrer">"aspect oriented programing"</a>, and Python decorator syntax is a nice way of using it on the cheap. </p>
<p>Other than separating the logic from the function, and using <code>repr(locals())</code> to serialize the parameters,  your approach is correct:  keeping a (module) global dictionary around with the result for each set of parameters is the usual approach for caching functions. The <code>lru_cache</code> just happens to that in a transparent way.</p>
</div>
<div class="post-text" itemprop="text">
<p>You get access to your parameters in a deterministic order by providing the arguments using *args (which gives a list of positional arguments) or **kwargs (a dict of "keyword" arguments) syntax.  Consider:</p>
<pre><code>&gt;&gt;&gt; def fn(*args):
...     for i in args: print(i)
... 
&gt;&gt;&gt; fn('a', 'b', 'c')
a
b
c
</code></pre>
<p>or</p>
<pre><code>&gt;&gt;&gt; def fn2(**kwargs):
...     for k in kwargs.keys(): print("{}: {}".format(k, kwargs[k]))
... 
&gt;&gt;&gt; fn2(a='aval', b='bval', c='cval')
a: aval
c: cval
b: bval
</code></pre>
<p>To use these in a cache, you'll need to convert the args into a dict key. 
 Rather than format it as a string, I'd recommend using tuples for your cache keys.  Tuples are immutable, so they can be hashed (a requirement for dicts).  Example:</p>
<pre><code>&gt;&gt;&gt; cache=dict()
&gt;&gt;&gt; def fn3(**kwargs):
...     key=(kwargs['a'], kwargs['b'], kwargs['c'])
...     val = ':'.join( (kwargs['a'], kwargs['b'], kwargs['c']) )
...     print(str(key))
...     print(val)
...     cache[key] = val
...     return
... 
&gt;&gt;&gt; fn3(a='1', b='2', c='3')
('1', '2', '3')
1:2:3
&gt;&gt;&gt; print(str(cache))
{('1', '2', '3'): '1:2:3'}
</code></pre>
</div>
<span class="comment-copy">...why not use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow noreferrer"><code>functools.lru_cache</code></a>?</span>
<span class="comment-copy">Very cool!  Lesson learned...</span>
<span class="comment-copy">Thank you. The answer to my specific question (getting a parameter signature) is inside the lru_cache code.  As you guessed, my actual problem is a bit more complex than just the cache example, but I had not considered using a decorator which seems to be the right solution.</span>
<span class="comment-copy">Thanks, Jeff.  It looks like this assumes none of the parameters have default values, and changes the function code since kwargs parameters are not available as local variables inside the function</span>
<span class="comment-copy">I like the idea of using a tuple as the key.</span>
