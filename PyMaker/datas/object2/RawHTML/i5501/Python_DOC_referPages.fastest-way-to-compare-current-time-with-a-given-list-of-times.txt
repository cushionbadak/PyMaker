<div class="post-text" itemprop="text">
<p>I just want to compare current time (in only hours and minutes) with a given list of times and get the closest time (or just previously available time in the list) value from the list.</p>
<pre><code>list_of_times = ['5:00:00 AM',  '5:10:00 AM',   '5:20:00 AM',   '5:30:00 AM',   '5:40:00 AM',   '5:50:00 AM',   '6:00:00 AM',   '6:05:00 AM',   '6:10:00 AM',   '6:15:00 AM',   '6:25:00 AM']
current_time = '6:02:00 AM'
</code></pre>
<p>What I want:</p>
<pre><code>def get_closes_time(current_time , list_of_times ):
    # some logic here
    return closest_time # In this case I want 6:00:00 AM
</code></pre>
<p>Assuming that my list is in sorted with time, what could be the fastest way of doing this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Binary search for <code>current_time</code> in your array. That's the simple part. 
The more complicated part is to define some <em>comparing</em> logic between your hours, to decide if your binary search algorithm should continue searching in the left part or the right part of the remaining array.</p>
<pre><code>from datetime import datetime

list_of_times = ['5:00:00 AM', '5:10:00 AM', '5:20:00 AM', '5:30:00 AM', '5:40:00 AM', '5:50:00 AM', '6:00:00 AM', '6:05:00 AM', '6:10:00 AM', '6:15:00 AM', '6:25:00 AM']

current_time = '6:02:00 AM'
current = datetime.strptime(current_time, '%I:%M:%S %p')

def getClosestTime(current, list_of_times, left, right):
  if right &lt; 0:
    return "Empty array"
  if right == 0:
    return list_of_times[right]
  if right - 1 == left:
    leftTime = datetime.strptime(list_of_times[left], '%I:%M:%S %p')
    rightTime = datetime.strptime(list_of_times[right], '%I:%M:%S %p')
    if  leftTime &lt; rightTime:
      return leftTime
    else:
      return rightTime

  mid = int((left + right) / 2)
  midTime = datetime.strptime(list_of_times[mid], '%I:%M:%S %p')

  if current &lt; midTime:
    return getClosestTime(current, list_of_times, left, mid - 1)
  if current &gt; midTime:
    return getClosestTime(current, list_of_times, mid + 1, right)
</code></pre>
<p>This will guarantee a O(log(n)) complexity time, and a O(n) space complexity. </p>
<pre><code>getClosestTime(currentTime, listOfTimes, 0, len(listOfTimes) - 1) //that's how you call it
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure if this will be the fastest</p>
<pre><code>import datetime
list_of_times = ['5:00:00 AM',  '5:10:00 AM',   '5:20:00 AM',   '5:30:00 AM',   '5:40:00 AM',   '5:50:00 AM',   '6:00:00 AM',   '6:05:00 AM',   '6:10:00 AM',   '6:15:00 AM',   '6:25:00 AM']
current_time = '6:02:00 AM'
format = '%I:%M:%S %p'
current_time = datetime.datetime.strptime(current_time, format)
print(sorted([[i,abs(current_time - datetime.datetime.strptime(i, format))] for i in list_of_times], key=lambda x: x[1])[0][0])
</code></pre>
<p>Above will result to 6:00:00 AM.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this</p>
<pre><code>from datetime import datetime

def get_closes_time(current_time , list_of_times ):

    closest_time=list_of_times[0]
    FMT = '%I:%M:%S %p'

    for each in list_of_times:


        dif_1= abs(datetime.strptime(each, FMT) - datetime.strptime(current_time, FMT))
        dif_2= abs(datetime.strptime(closest_time, FMT) - datetime.strptime(current_time, FMT))
        if dif_1&lt;dif_2:
            closest_time=each

    return closest_time 
</code></pre>
</div>
<span class="comment-copy">The fastest way will be in O(log n) time and O(1) space.  You will need to use bisection / linear search, and take special care at the endpoints (since times "wrap around" at 12).</span>
<span class="comment-copy">Is it guaranteed that the list of times is sorted?</span>
<span class="comment-copy">Have a look at <a href="https://docs.python.org/3/library/bisect.html#searching-sorted-lists" rel="nofollow noreferrer">"8.6.1. Searching Sorted Lists"</a> in the <code>bisect</code> module's documentation for guidance.</span>
<span class="comment-copy">You should use built-in <code>bisect</code> module.</span>
<span class="comment-copy">seems good, but with the list comprehension we're already at O(n), muazfaiz asked for the fastest way to do it.</span>
