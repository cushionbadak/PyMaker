<div class="post-text" itemprop="text">
<p><strong>What is the difference between below 2 ways of reading bytes?</strong></p>
<pre><code>stream = BytesIO(unhexlify('000000010000'))
print(int.from_bytes(stream.read(4), byteorder="big"))  //prints 1


bytes = unhexlify('000000010000')
print(int.from_bytes(bytes[:4], byteorder="big"))  //prints 1
</code></pre>
<p>which is better? why?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you know that your string is the <a href="https://docs.python.org/3/library/functions.html#hex" rel="nofollow noreferrer"><code>hex</code></a> string, why not directly convert it into <a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow noreferrer"><code>int</code></a> with <code>base</code> as "16" after slicing it? For example:</p>
<pre><code>&gt;&gt;&gt; my_hex = '000000010000'
&gt;&gt;&gt; int(my_hex[:8], base=16)
1
</code></pre>
<p>You must note here that I am slicing the string with index as "8" instead of 4, but since we know that it is a hex string, we can slice it accordingly considering <code>2</code> characters represents a <code>hex</code> number. </p>
<p>Here's the performance comparison of your's as well as mine solution:</p>
<pre><code>mquadri$ python3 -m timeit "my_hex = '000000010000'; int(my_hex[:8], base=16)"
1000000 loops, best of 3: 0.581 usec per loop

mquadri$ python3 -m timeit -s "from io import BytesIO; from binascii import unhexlify" "stream = BytesIO(unhexlify('000000010000')); int.from_bytes(stream.read(4), byteorder='big')"
1000000 loops, best of 3: 1.15 usec per loop

mquadri$ python3 -m timeit -s "from binascii import unhexlify" "bytes = unhexlify('000000010000'); int.from_bytes(bytes[:4], byteorder='big')"
1000000 loops, best of 3: 0.764 usec per loop
</code></pre>
<p>As you see, simply using <code>int</code> to convert is more efficient than both of your solutions.</p>
<hr/>
<p>However if you are interested only in the solutions you mentioned, then I'll suggest the one without using <code>io.BytesIO</code> because:</p>
<ul>
<li>without using <code>ByteIO</code>, you'll requires one lesser <code>imports</code> </li>
<li>comparatively your second solution looks simpler too</li>
</ul>
<p><strong>Note:</strong> For the performance measurement, I am not calculating the time of <em>imports</em>, in case someone is planning to say that <em>"this difference is related to additional import"</em> ;)</p>
</div>
<div class="post-text" itemprop="text">
<p>The point of using IO constructs (<code>StringIO</code>, <code>BytesIO</code>) is to work with objects that mimic a stream (like files). So your first solution is wrapping your bytes in a file-like object and reading from that wrapper as if it was a file. Your second solution just reads from the bytes. </p>
<p>I say if the semantics of your code do not require that the bytes be a stream, skip the IO solution go straight to the source.</p>
</div>
<span class="comment-copy">The first one looks overly complicated.  Why convert the result of <code>unhexlify</code> to BytesIO and back?</span>
<span class="comment-copy">Hey! Could you tell me what this mean "I say if the semantics of your code do not require that the bytes be a stream". When to use bytes as stream?</span>
<span class="comment-copy">@LokeshCherukuri What I meant is that if your code is not expecting to work with specifically an IO stream then you don't have to worry about creating one. In some other cases it could happen that your code is much better understood if it is clear that the stream of bytes comes from IO source. In such situation for the sake of more clarity and maybe compatibility, it's probably better to use the IO. Semantics are not necessarily concerned with performance, but rather clarity, so in the end you be the judge of what's more important.</span>
<span class="comment-copy">As to when to use byte streams technically, there could be situations for example where you need to work with an API that normally works with files. However you identify a function in the API that can do a job that you need to apply to some bytes that you only currently have in memory. So you wrap these bytes in IO and send the stream to your function.</span>
