<div class="post-text" itemprop="text">
<p>I'm trying to extract the sequential 'NN' elements (including 'NNP') from a list and append to a new list given 'IN' or 'TO' are encountered before 'NN'. How can I do it?</p>
<p>I tried the following code. But unable to capture the  other similar instances.</p>
<pre><code>    new = ['JJ',
 'NN',
 'IN',
 'NNP',
 'NN',
 'MD',
 'VB',
 'VBN',
 'IN',
 'NN',
 'TO',
 'VB',
 'NN',
 'CC',
 'NN',
 'TO',
 'NNP',
 'NN',
 'NN',
 '.']

lst = []
for i,j in enumerate(new):
    lst1 = []
    if j == 'IN':
        for i in new[i+1:]:
            if 'NN' in i:
                lst1.append(i)
                lst.append(lst1)
                break

lst = [['NNP'], ['NN']]
</code></pre>
<p>But I want to improve the code to give the below output:</p>
<pre><code>[['NNP', 'NN'], ['NN'], ['NNP', 'NN', 'NN']
</code></pre>
<p>Each output chunk has either 'IN' or 'TO' occurred before them.</p>
<p>Actually, the above list (new) is underlying parts of speech for this list :          </p>
<pre><code>[['Additional',
  'condition',
  'of',
  'DeNOx',
  'activation',
  'shall',
  'be',
  'introduced',
  'in',
  'order',
  'to',
  'provide',
  'flexibility',
  'and',
  'robustness',
  'to',
  'NSC',
  'regeneration',
  'management',
  '.'],
 ['JJ',
  'NN',
  'IN',
  'NNP',
  'NN',
  'MD',
  'VB',
  'VBN',
  'IN',
  'NN',
  'TO',
  'VB',
  'NN',
  'CC',
  'NN',
  'TO',
  'NNP',
  'NN',
  'NN',
  '.']].
</code></pre>
<p>How can I map the results back to this list so that I will get </p>
<pre><code>[['DeNOx', 'activation'], ['order'], ['NSC', 'regeneration', 'management']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your not too far away. One way to make this easier is to obtain all the indexes of <code>'IN'</code> and <code>'TO'</code>:</p>
<pre><code>starts = {'IN', 'TO'}
in_twos = [i for i, e in enumerate(new) if e in starts]
</code></pre>
<p>Which gives:</p>
<pre><code>[2, 8, 10, 15]
</code></pre>
<p>Then you just need to iterate though these indexes, specifically <code>new[i+1:]</code>, and take elements that are <code>'NN'</code> or <code>'NNP'</code>. When you reach an element that is not one of these, <code>break</code> out of the loop.</p>
<p>Here is an example:</p>
<pre><code>result = []
take = {'NN', 'NNP'}

for i in in_twos:
    temp = []
    for x in new[i+1:]:
        if x not in take:
            break

        temp.append(x)

    # If this is empty, don't add it
    if temp:
        result.append(temp)

print(result)
</code></pre>
<p>Which in the end outputs:</p>
<pre><code>[['NNP', 'NN'], ['NN'], ['NNP', 'NN', 'NN']]
</code></pre>
<p>Another shorter way, as @schwobaseggl suggested, is to use <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow noreferrer"><code>itertools.takewhile</code></a> to make the extraction of <code>'NN'</code> elements easier. This function basically keeps extracting elements until the first argument predicate returns false.</p>
<p>Here is what it can look like:</p>
<pre><code>from itertools import takewhile

# new, take and in_twos same as before

result = [l for l in [list(takewhile(lambda x: x in take, new[i+1:])) for i in in_twos] if l]

print(result)
# [['NNP', 'NN'], ['NN'], ['NNP', 'NN', 'NN']]
</code></pre>
<p><strong>UPDATE:</strong></p>
<p>If you want to map the words and speeches together, you can do this:</p>
<pre><code>new = [['JJ', 'NN', 'IN','NNP','NN','MD','VB','VBN','IN','NN','TO','VB','NN','CC','NN','TO','NNP','NN','NN','.'],
   ['Additional','condition','of','DeNOx','activation','shall','be','introduced','in', 'order','to','provide','flexibility','and','robustness', 'to','NSC','regeneration','management','.']]

starts = {'IN', 'TO'}
in_twos = [i for i, e in enumerate(new[0]) if e in starts]

speech = []
words = []
take = {'NN', 'NNP'}

for i in in_twos:
    temp = []
    for x, y in zip(new[0][i+1:], new[1][i+1:]):
        if x not in take:
            break

        temp.append((x, y))

    # If this is empty, don't add it
    if temp:
        speech.append([x for x, _ in temp])
        words.append([y for _, y in temp])

print(speech)
print(words)
</code></pre>
<p>Which Outputs:</p>
<pre><code>[['NNP', 'NN'], ['NN'], ['NNP', 'NN', 'NN']]
[['DeNOx', 'activation'], ['order'], ['NSC', 'regeneration', 'management']]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use two handy <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer"><strong><code>itertools</code></strong></a> for this: <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><strong><code>groupby</code></strong></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile" rel="nofollow noreferrer"><strong><code>takewhile</code></strong></a>:</p>
<pre><code>from itertools import groupby, takewhile

nn = lambda x: x.startswith('NN')
to_in = lambda x: x in ('IN', 'TO')

list(filter(None, [list(takewhile(nn, g)) for k, g in groupby(new, key=to_in)][1:]))
# [['NNP', 'NN'], ['NN'], ['NNP', 'NN', 'NN']]
</code></pre>
<p>This chunks the initial list in chunks based on the items being <code>TO</code> or <code>IN</code>. From each of the chunks except the first (to avoid any initial <code>NNs</code>), this takes elements while they start with <code>NN</code>. Finally, it <a href="https://docs.python.org/3/library/functions.html#filter" rel="nofollow noreferrer">filters</a> out non-truthy (empty) lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>There is another nice answer posted while I was typing this out -- this is a simple implementation without imports.</p>
<pre><code>full_list = []

for x in range(0, len(new)):
    if 'NN' in new[x] and ('IN' in new[x-1] or 'TO' in new[x-1]):
        temp_list = [new[x]]
        temp_index = x+1
        while 'NN' in new[temp_index]:
            temp_list.append(new[temp_index])
            temp_index += 1
        full_list.append(temp_list)
</code></pre>
</div>
<span class="comment-copy">I added some changes to my question. Will be glad if you can provide a way to map the resultant parts of speech ('new' list) to the real English words list as mentioned in my question. Thanks</span>
<span class="comment-copy">@sharathreddymandadi See my recent edit.</span>
<span class="comment-copy">Thanks for the answer. But I'm unable to map the results to the original list. Will be of great help if any help regarding this is provided.</span>
