<div class="post-text" itemprop="text">
<p>I'm having a C function that returns a pointer to an struct:</p>
<pre class="lang-c prettyprint-override"><code>struct iperf_test *
iperf_new_test()
{
    struct iperf_test *test;

    test = (struct iperf_test *) malloc(sizeof(struct iperf_test));
    ...
    return test;
}
</code></pre>
<p>This function is called from Python in the following way:</p>
<pre class="lang-py prettyprint-override"><code>self.lib = cdll.LoadLibrary("lib.so")
self._test = self.lib.iperf_new_test()
</code></pre>
<p>The struct has some values such as:</p>
<pre class="lang-c prettyprint-override"><code>struct iperf_test
{
    int       server_port;
    int       bind_port; 
};
</code></pre>
<p>The examples I see on the internet shows that I need to use a function that receives a pointer to alter the values, for example in python:</p>
<pre class="lang-py prettyprint-override"><code>self.lib.iperf_set_test_server_port(self._test, int(port))
</code></pre>
<p>And in C:</p>
<pre class="lang-c prettyprint-override"><code>void
iperf_set_test_server_port(struct iperf_test *ipt, int srv_port)
{
    ipt-&gt;server_port = srv_port;
}
</code></pre>
<p>Is there a way to <strong>change the value bind_port directly</strong> without using a C function?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. This is why <code>ctypes</code> supports <a href="https://docs.python.org/3/library/ctypes.html#structures-and-unions" rel="nofollow noreferrer">defining your own structs</a>, and defining prototypes for functions.</p>
<p>You'd need to make a Python level definition of your structure, e.g.:</p>
<pre><code>from ctypes import Structure, c_int, POINTER

class iperf_test(Structure):
    _fields_ = [("server_port", c_int),
                ("bind_port", c_int)]
</code></pre>
<p>Then, before calling your C function, you <a href="https://docs.python.org/3/library/ctypes.html#return-types" rel="nofollow noreferrer">set its <code>restype</code></a> correctly:</p>
<pre><code># Load library as normal
self.lib = cdll.LoadLibrary("lib.so")
# New, so Python knows how to interpret result
self.lib.iperf_new_test.restype = POINTER(iperf_test)
# Call, and Python returns pointer to Python definition of struct
self._test = self.lib.iperf_new_test()
</code></pre>
<p>Now you can use it <a href="https://docs.python.org/3/library/ctypes.html#pointers" rel="nofollow noreferrer">by dereferencing</a> (done with <code>[0]</code> since Python lacks a <code>*</code> pointer dereference operator) and setting attributes on the dereferenced struct directly:</p>
<pre><code>self._test[0].bind_port = new_bind_port
</code></pre>
</div>
<span class="comment-copy">You can recreate the struct definition in Python as class derived from <code>ctypes.Structure</code>, create a <code>ctypes.POINTER</code> type of this class and set this as <code>restype</code> of the function. Then you can change the value directly.</span>
<span class="comment-copy">Is possible to partially recreate the struct? for example, the struct has a lot of object types (some are custom created), that could be difficult to convert to python.</span>
<span class="comment-copy">@h3ct0r: If you only ever use single instances of the struct (no arrays), and only use pointers to it allocated in C (no copying), you can usually just define the first fields and stop when you reach the ones you don't care about. Alternatively (more safely), you can define trivial placeholder attributes of the correct size (e.g. for the pointers you don't care about the contents of, just declare the field as <code>c_void_p</code>, a void pointer); doing so makes it safer for use with arrays and the like. But if you need full control of all attributes, you must define all types involved.</span>
