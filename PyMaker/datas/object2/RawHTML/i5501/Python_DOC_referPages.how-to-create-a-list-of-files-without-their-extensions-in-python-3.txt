<div class="post-text" itemprop="text">
<p>How to get the filename without the extension from a path in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>Getting the name of the file without the extension :</p>
<pre><code>import os
print(os.path.splitext("path_to_file")[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just roll it:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; base=os.path.basename('/root/dir/sub/file.ext')
&gt;&gt;&gt; base
'file.ext'
&gt;&gt;&gt; os.path.splitext(base)
('file', '.ext')
&gt;&gt;&gt; os.path.splitext(base)[0]
'file'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; print(os.path.splitext(os.path.basename("hemanth.txt"))[0])
hemanth
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A readable version, using <code>Pathlib</code> in Python 3.4+</p>
<pre><code>from pathlib import Path

Path('/root/dir/sub/file.ext').stem
</code></pre>
<p>Will print :</p>
<blockquote>
<p>file</p>
</blockquote>
<p>If the path can be a <strong>symbolic link</strong>, then add <code>resolve()</code></p>
<pre><code>Path('/root/dir/sub/file.ext').resolve().stem
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For completeness sake, here is the <code>pathlib</code> solution for python 3.2+:</p>
<pre><code>from pathlib import Path

print(Path(your_path).resolve().stem)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to keep the path to the file and just remove the extension</p>
<pre><code>&gt;&gt;&gt; file = '/root/dir/sub.exten/file.data.1.2.dat'
&gt;&gt;&gt; print ('.').join(file.split('.')[:-1])
/root/dir/sub.exten/file.data.1.2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>os.path.splitext() <strong>won't</strong> work if there are multiple dots in the extension.</p>
<p>For example, images.tar.gz</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; file_path = '/home/dc/images.tar.gz'
&gt;&gt;&gt; file_name = os.path.basename(file_path)
&gt;&gt;&gt; print os.path.splitext(file_name)[0]
images.tar
</code></pre>
<p>You can just find the index of the first dot in the basename and then slice the basename to get just the filename without extension.</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; file_path = '/home/dc/images.tar.gz'
&gt;&gt;&gt; file_name = os.path.basename(file_path)
&gt;&gt;&gt; index_of_dot = file_name.index('.')
&gt;&gt;&gt; file_name_without_extension = file_name[:index_of_dot]
&gt;&gt;&gt; print file_name_without_extension
images
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/os.path.html" rel="noreferrer">https://docs.python.org/3/library/os.path.html</a></p>
<p>In python 3 pathlib "The pathlib module offers high-level path objects."
so, </p>
<pre><code>&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; p = Path("/a/b/c.txt")
&gt;&gt;&gt; print(p.with_suffix(''))
\a\b\c
&gt;&gt;&gt; print(p.stem)
c
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>But even when I import os, I am not able to call it path.basename. Is it possible to call it as directly as basename?</p>
</blockquote>
<p><code>import os</code>, and then use <code>os.path.basename</code></p>
<p><code>import</code>ing <code>os</code> doesn't mean you can use <code>os.foo</code> without referring to <code>os</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>@IceAdor's refers to rsplit in a comment to @user2902201's solution.  rsplit is the simplest solution that supports multiple periods.</p>
<p>Here it is spelt out:</p>
<pre><code>file = 'my.report.txt'
print file.rsplit('.', 1)[0]
</code></pre>
<p>my.report</p>
</div>
<div class="post-text" itemprop="text">
<p>Thought I would throw in a variation to the use of the <a href="https://docs.python.org/3/library/os.path.html#os.path.splitext" rel="noreferrer">os.path.splitext</a> without the need to use array indexing. </p>
<p>The function always returns a <code>(root, ext)</code> pair so it is safe to use:</p>
<p><code>root, ext = os.path.splitext(path)</code></p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; path = 'my_text_file.txt'
&gt;&gt;&gt; root, ext = os.path.splitext(path)
&gt;&gt;&gt; root
'my_text_file'
&gt;&gt;&gt; ext
'.txt'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>import os</code></p>
<pre><code>filename = C:\\Users\\Public\\Videos\\Sample Videos\\wildlife.wmv
</code></pre>
<p>This returns the <code>filename</code> without the <code>extension</code>(C:\Users\Public\Videos\Sample Videos\wildlife)</p>
<pre><code>temp = os.path.splitext(filename)[0]  
</code></pre>
<p>Now you can get just the <code>filename</code> from the temp with</p>
<pre><code>os.path.basename(temp)   #this returns just the filename (wildlife)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A multiple extension aware procedure. Works for <code>str</code> and <code>unicode</code> paths. Works in Python 2 and 3.</p>
<pre><code>import os

def file_base_name(file_name):
    if '.' in file_name:
        separator_index = file_name.index('.')
        base_name = file_name[:separator_index]
        return base_name
    else:
        return file_name

def path_base_name(path):
    file_name = os.path.basename(path)
    return file_base_name(file_name)
</code></pre>
<p>Behavior:</p>
<pre><code>&gt;&gt;&gt; path_base_name('file')
'file'
&gt;&gt;&gt; path_base_name(u'file')
u'file'
&gt;&gt;&gt; path_base_name('file.txt')
'file'
&gt;&gt;&gt; path_base_name(u'file.txt')
u'file'
&gt;&gt;&gt; path_base_name('file.tar.gz')
'file'
&gt;&gt;&gt; path_base_name('file.a.b.c.d.e.f.g')
'file'
&gt;&gt;&gt; path_base_name('relative/path/file.ext')
'file'
&gt;&gt;&gt; path_base_name('/absolute/path/file.ext')
'file'
&gt;&gt;&gt; path_base_name('Relative\\Windows\\Path\\file.txt')
'file'
&gt;&gt;&gt; path_base_name('C:\\Absolute\\Windows\\Path\\file.txt')
'file'
&gt;&gt;&gt; path_base_name('/path with spaces/file.ext')
'file'
&gt;&gt;&gt; path_base_name('C:\\Windows Path With Spaces\\file.txt')
'file'
&gt;&gt;&gt; path_base_name('some/path/file name with spaces.tar.gz.zip.rar.7z')
'file name with spaces'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>On Windows system I used drivername prefix as well, like:</p>
<pre><code>&gt;&gt;&gt; s = 'c:\\temp\\akarmi.txt'
&gt;&gt;&gt; print(os.path.splitext(s)[0])
c:\temp\akarmi
</code></pre>
<p>So because I do not need drive letter or directory name, I use:</p>
<pre><code>&gt;&gt;&gt; print(os.path.splitext(os.path.basename(s))[0])
akarmi
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
path = "a/b/c/abc.txt"
print os.path.splitext(os.path.basename(path))[0]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>We could do some simple <code>split</code> / <code>pop</code> magic as seen here (<a href="https://stackoverflow.com/a/424006/1250044">https://stackoverflow.com/a/424006/1250044</a>), to extract the filename (respecting the windows and POSIX differences).</p>
<pre><code>def getFileNameWithoutExtension(path):
  return path.split('\\').pop().split('/').pop().rsplit('.', 1)[0]

getFileNameWithoutExtension('/path/to/file-0.0.1.ext')
# =&gt; file-0.0.1

getFileNameWithoutExtension('\\path\\to\\file-0.0.1.ext')
# =&gt; file-0.0.1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os
list = []
def getFileName( path ):
for file in os.listdir(path):
    #print file
    try:
        base=os.path.basename(file)
        splitbase=os.path.splitext(base)
        ext = os.path.splitext(base)[1]
        if(ext):
            list.append(base)
        else:
            newpath = path+"/"+file
            #print path
            getFileName(newpath)
    except:
        pass
return list

getFileName("/home/weexcel-java3/Desktop/backup")
print list
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the easiest way to resolve this is to </p>
<pre><code>import ntpath 
print('Base name is ',ntpath.basename('/path/to/the/file/'))
</code></pre>
<p>this saves you time and computation cost.</p>
</div>
<div class="post-text" itemprop="text">
<p>For convenience, a simple function wrapping the two methods from <a href="https://docs.python.org/3/library/os.path.html" rel="nofollow"><code>os.path</code></a> :</p>
<pre><code>def filename(path):
  """Return file name without extension from path.

  See https://docs.python.org/3/library/os.path.html
  """
  import os.path
  b = os.path.split(path)[1]  # path, *filename*
  f = os.path.splitext(b)[0]  # *file*, ext
  #print(path, b, f)
  return f
</code></pre>
<p>Tested with Python 3.5.</p>
</div>
<span class="comment-copy">If this is a common enough operation, perhaps it should merit it's own official command? Something like os.path.filename(path_to_file) instead of os.path.splitext(os.path.basename(path_to_file))[0]</span>
<span class="comment-copy">What if the filename contains multiple dots?</span>
<span class="comment-copy">For anyone wondering the same as matteok, if there are multiple dots, splitext splits at the last one (so <code>splitext('kitty.jpg.zip')</code> gives <code>('kitty.jpg', '.zip')</code>).</span>
<span class="comment-copy">Bears some similarity to <a href="http://stackoverflow.com/questions/8384737/python-extract-file-name-from-path-no-matter-what-the-os-path-format">this SO question</a> as well.</span>
<span class="comment-copy">Note that this code returns the complete file <i>path</i> (without the extension), not just the file <i>name</i>.</span>
<span class="comment-copy">os.path.basename seems nicer and more compact than an import followed by the call to basename.</span>
<span class="comment-copy">@ScottWilson: You do still have to import <code>os</code> though.</span>
<span class="comment-copy">What does 'roll it' mean?</span>
<span class="comment-copy">It's short for "roll your own," which means "build it yourself" in American English.</span>
<span class="comment-copy">+1 for this. 3 exact same answers, but this is the most direct one. You just could have used <code>`</code> for showing the code, and "/somepath/hermanth.txt" as a path instance.</span>
<span class="comment-copy">Thanks, i added the `` but don really know why the code is not been highlighted!</span>
<span class="comment-copy">@hemanth.hm Unfortunately `` does not highlight code, and it's just one-line. That's why it is discouraged from using in answers when using large code fragments and not one-lining them.</span>
<span class="comment-copy">@hemanth.hm Note that in this statement you provided, <code>os.path.basename</code> is not necessary. <code>os.path.basename</code> should be only used to get the file name from the file path.</span>
<span class="comment-copy">Right way to do it post 3.4</span>
<span class="comment-copy">Why would you call <code>resolve()</code>? The whole point of a symbolic link is that it's transparent. <i>Don't</i> resolve symbolic links unless you <b><i>really</i></b> have to.</span>
<span class="comment-copy">If you want to split on the last period, use rsplit: <code>'/root/dir/sub.exten/file.data.1.2.dat'.rsplit('.', 1)</code></span>
<span class="comment-copy">index_of_dot =  file_name.index('.') This will be done after getting the basename of the file so that it wont split at .env</span>
<span class="comment-copy">Important point, as a series of extensions like this is common. <code>.tar.gz</code> <code>.tar.bz</code> <code>.tar.7z</code></span>
<span class="comment-copy">Note that <code>'haystack'.index('needle')</code> throws a ValueError exception if the needle (in above case the dot, <code>.</code>) is not found in haystack. Files without any extension exist too.</span>
<span class="comment-copy">though if you wanted to call foo directly you could use <code>from os import foo</code>.</span>
<span class="comment-copy">you have a very non-standard version of the <code>os</code> module if it has a member called <code>foo</code>.</span>
<span class="comment-copy">It's a placeholder name. (e.g. consider <code>path</code>, or <code>walk</code>).</span>
<span class="comment-copy">os.path.splitext()[0] does the same thing.</span>
<span class="comment-copy">@CharlesPlager <i>os.path.splitext() won't work if there are multiple dots in the extension.</i> <a href="http://stackoverflow.com/a/37760212/1250044">stackoverflow.com/a/37760212/1250044</a></span>
<span class="comment-copy">It works for me:  In [72]: os.path.splitext('one.two.three.ext') Out[72]: ('one.two.three', '.ext')</span>
