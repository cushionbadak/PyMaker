<div class="post-text" itemprop="text">
<p>Getting an error with this code
(SyntaxError: invalid syntax)</p>
<pre><code>score = [a*a in range(1, 100) if (a*a)%2 is 0 and str(a*a)[-1] is '0']
print(score)
</code></pre>
<p>Result:</p>
<pre><code>SyntaxError: invalid syntax
</code></pre>
<p>but same code working fine when i use it without list comprehension method.</p>
<pre><code>score = []
for a in range(1,100):
    if (a*a)%2 is 0 and str(a*a)[-1] is '0':
        score.append(a*a)
print(score)
</code></pre>
<p>result:</p>
<pre><code>[100, 400, 900, 1600, 2500, 3600, 4900, 6400, 8100]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are missing the <code>for a</code>. Also, you should use <code>==</code> to test ints and strings for equality because <code>is</code> checks object identity:</p>
<pre><code>score = [a*a for a in range(1, 100) if (a*a) % 2 == 0 and str(a*a)[-1] == '0']
</code></pre>
<p>You could also shorten the <code>== 0</code> to a <code>bool</code> check and generally consider to use <code>endswith</code> for more robust suffix checking:</p>
<pre><code>score = [a*a for a in range(1, 100) if not (a*a) % 2 and str(a*a).endswith('0')]
</code></pre>
<p>See the <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">docs on list comprehensions</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is the <em>yield</em> part of the expression:</p>
<pre><code>score = [<b>a</b> in range(1, 100) if (a*a)%2 is 0 and str(a*a)[-1] is '0']</code></pre>
<p>You want to add <code>a*a</code> to the list, so:</p>
<pre><code>score = [<b>a*a for a</b> in range(1, 100) if (a*a)%2 is 0 and str(a*a)[-1] is '0']</code></pre>
<p>But the code is very inelegantly. You use <code>is</code> which is reference equality. Although most interpreters cache characters, and small integers, it is a bit risky to rely on it: the more assumptions that have to be satisfied for a program to work, the more can go wrong.</p>
<p>Furthermore you can detect whether <code>a*a</code> will end with <code>0</code>, by checking <code>(a*a)%10 == 0</code>. Since <code>10</code> is a multiple of <code>2</code>, we can even drop the first check then. We can check for an integer <code>i</code> being zero with <code>not i</code> (this is <code>True</code> is <code>i == 0</code>).</p>
<p>So a more safe and shorter solution is:</p>
<pre><code>score = [a*a for a in range(1, 100) if <b>not (a * a) % 10</b>]</code></pre>
<p>This then produces then:</p>
<pre><code>&gt;&gt;&gt; [a*a for a in range(1, 100) if not (a * a) % 10]
[100, 400, 900, 1600, 2500, 3600, 4900, 6400, 8100]
</code></pre>
</div>
<span class="comment-copy"><code>[a for a in range(1, 100) if (a*a)%2 is 0 and str(a*a)[-1] is '0']</code></span>
<span class="comment-copy">@MenglongLi: no it is a filter clause.</span>
<span class="comment-copy">Apart from the missing <code>for</code>, it's not the same, you're appending only <code>a</code> instead of <code>a*a</code> (or <code>a**2</code>). Also, if you're doing it for performance concerns, you might don't want to use list comprehension in this case as you're squaring your <code>a</code> three times to get to your result - you can square it only once and do the checkups later.</span>
<span class="comment-copy">Thanks, now it works</span>
<span class="comment-copy"><code>str.endswith()</code> is not more robust than using the <code>-1</code> index, in fact it's probably slower but more readable</span>
<span class="comment-copy">@Chris_Rands It is more robust as it will not raise an <code>IndexError</code> for the empty string.</span>
<span class="comment-copy">Fair, although that could never occur here, I take the point for the generic case</span>
<span class="comment-copy">@Chris_Rands Thinking about it, you would get away with slicing in the general case <code>s[-len(suf):] == suf</code> :) but I do think <code>endswith</code> is still more readable and fairly optimized, as well.</span>
