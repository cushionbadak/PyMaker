<div class="post-text" itemprop="text">
<p>What I am asking might not be possible in Python and probably stems from my being used to pointers, but this is how it goes: is the following achievable in python?</p>
<pre><code>class A(object):
    #body of class

a = A() #create a new object
b = A(a) #"b" is now an alias for "a"
</code></pre>
<p>My naive attempt to do this was</p>
<pre><code>class A(object):
    def __init__(self, x):
        if isinstance(x, A):
             self = x
</code></pre>
<p>But, of course, this is non-sense since self is just a local variable. </p>
<p>EDIT: To be clear, this is not about simple variable assignment (i.e. <code>b=a</code> creates an alias but I don't care). This question came while I was trying to construct a loop with lots of objects of the same type:</p>
<pre><code>class A(object):
    #blah

l = []
for cond in conditions:
    tmp = A(*cond)
    l.append(tmp)
</code></pre>
<p>If <code>cond[0]</code> is another object of type A, then <code>tmp</code> is just a reference to that object.
Now, there is a work-around for everything, but that's not what I am asking. I'd like to know if there is a solution to my original question.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve this with <code>__new__</code>:</p>
<pre><code>class A(object):
    def __new__(cls, param=None):
        if isinstance(param, A):
            return param
        return super().__new__(cls)

    def __init__(self, param=None):  # should match __new__ signature
        if isinstance(param, A):
            return
        self.param = param
        # normal initialization
</code></pre>
<p>that being said you probably want to rethink your architecture.</p>
</div>
<div class="post-text" itemprop="text">
<p>IF you want to do this it has to happen in the objects <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer"><code>__new__</code></a> method.  That's where you can affect the creation of new objects, as opposed to <a href="https://docs.python.org/3/reference/datamodel.html#object.__init__" rel="nofollow noreferrer"><code>__init__</code></a> which modifies them after their creation.  One way to do this would be</p>
<pre><code>class A:
    def __new__(cls, copy=None):
        if copy: # This assumes that instances of A cannot be falsy
            if isinstance(copy, A):
                return copy
            else:
                raise ValueError("Argument not of type A")
        else:
            return super().__new__(cls)

a = A()
b = A(a)
b is a # True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think the best approach is actually to use a meta-class here, especially if you plan on using inheritance, although, meta-classes do add some complexity to that situation. If only, I would appeal to the fact that this is the common approach to creating a singleton class, which is very similar to what you are doing in principle. But here is a sketch:</p>
<pre><code>In [43]: class MyMeta(type):
    ...:     def __call__(cls, *args, **kwargs):
    ...:         if isinstance(args[0], cls):
    ...:             return args[0]
    ...:         else:
    ...:             return super(MyMeta, cls).__call__(*args, **kwargs)
    ...:

In [44]: class A(metaclass=MyMeta):
    ...:     def __init__(self, arg1, arg2):
    ...:         print("initialized")
    ...:

In [45]: a1 = A(1, 1)
initialized

In [46]: a2 = A(2, 2)
initialized

In [47]: a3 = A(a1, 3)

In [48]: [hex(id(x)) for x in (a1, a2, a3)]
Out[48]: ['0x103ccd160', '0x103ccd198', '0x103ccd160']

In [49]: a1 is a2, a1 is a3
Out[49]: (False, True)
</code></pre>
<p>Note, from the <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__" rel="nofollow noreferrer">docs</a></p>
<blockquote>
<p><code>__new__()</code> is intended mainly to allow subclasses of immutable types
  (like <code>int</code>, <code>str</code>, or <code>tuple</code>) to customize instance creation. It is
  also commonly overridden in custom metaclasses in order to customize
  class creation.</p>
</blockquote>
<p>Also, note that using this approach, <code>__init__</code> isn't called again, which <em>may</em> be what you want.</p>
<pre><code>In [53]: class A(object):
    ...:     def __new__(cls, *args, **kwargs):
    ...:         if isinstance(args[0], A):
    ...:             return args[0]
    ...:         return super().__new__(cls)
    ...:
    ...:     def __init__(self, arg1, arg2):  # should match __new__ signature
    ...:         print("initialized")
    ...:

In [54]: a1 = A(1, 1)
initialized

In [55]: a2 = A(2, 2)
initialized

In [56]: a3 = A(a1, 3)
initialized

In [57]: a1 is a2, a1 is a3
Out[57]: (False, True)
</code></pre>
</div>
<span class="comment-copy">What's wrong with <code>b = a</code>?</span>
<span class="comment-copy">Sounds like you could use a quick guide to <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">how Python variables work</a>.</span>
<span class="comment-copy">@StefanPochmann, <code>b=a</code> is not possible because of what I am trying to do. I would like to be able to create a bunch of objects dependent on certain conditions. I want to initialize them all the same way, hence the question.</span>
<span class="comment-copy">.... <b>what exactly do you mean</b>?</span>
<span class="comment-copy">@Ivan You may want to look at <code>__new__</code> function instead of <code>__init__</code>. What you are trying to achieve is possible.</span>
<span class="comment-copy">While this is a solution to the original question, this logic really should be inside of the <code>for</code> loop, not in <code>A.__new__</code>. <code>A</code>'s constructor shouldn't make accommodations for <code>conditions</code> being a heterogenous container.</span>
<span class="comment-copy">Thanks, this was a principle question. Is <code>__init__</code> called from <code>super().__new__</code> only?</span>
<span class="comment-copy">@Ivan the default <code>__new__</code> implementation (the one you call via <code>super()</code>) calls <code>__init__</code>. You can call it manually if you wish.</span>
<span class="comment-copy">Sorry, I can't get this to work in python 3.5, I get <code>TypeError: object() takes no parameters</code>.</span>
<span class="comment-copy">@Ivan fixed the code.</span>
<span class="comment-copy">What do I need to add in case I also want to pass arguments for regular initialization?</span>
