<div class="post-text" itemprop="text">
<p>I am trying to use <code>SequenceMatcher.ratio()</code> to get the similarity of two strings: <code>"86418648"</code> and <code>"86488648"</code>:</p>
<pre><code>&gt;&gt;&gt; SequenceMatcher(None,"86418648","86488648").ratio()
0.5
</code></pre>
<p>The ratio returned is <code>0.5</code>, which is much lower than I expected because there is only one character different in the two strings.</p>
<p>It seems that the ratio is calculated based on matching blocks. So I tried to run <code>SequenceMatcher.get_matching_blocks()</code>:</p>
<pre><code>&gt;&gt;&gt; SequenceMatcher(None,"86418648","86488648").get_matching_blocks()
[Match(a=4, b=0, size=4), Match(a=8, b=8, size=0)]
</code></pre>
<p>But I expected the result to be:</p>
<pre><code>[Match(a=0, b=0, size=3), Match(a=4, b=4, size=4), Match(a=8, b=8, size=0)]
</code></pre>
<p>Can anyone help to explain why it didn't match from the first 3 numbers <code>"864"</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>SequenceMatcher.get_matching_blocks()</code> works by repeated application of <code>SequenceMatcher.find_longest_match()</code> to as-yet-unmatched blocks of the two sequences. </p>
<p>Quoting from the docstring for <a href="https://github.com/python/cpython/blob/master/Lib/difflib.py#L336" rel="nofollow noreferrer"><code>find_longest_match()</code></a>:</p>
<pre><code>Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
    alo &lt;= i &lt;= i+k &lt;= ahi
    blo &lt;= j &lt;= j+k &lt;= bhi
and for all (i',j',k') meeting those conditions,
    k &gt;= k'
    i &lt;= i'
    and if i == i', j &lt;= j'

In other words, of all maximal matching blocks, return one that
starts earliest in a, and of all those maximal matching blocks that
start earliest in a, return the one that starts earliest in b.
</code></pre>
<p>In the case of the two sequences <code>a = "86418648"</code> and <code>b = "86488648"</code>, the longest block in <code>a</code> matching a block in <code>b</code> is the single <code>8648</code> at <code>a[4]</code>, and the earliest match for it in <code>b</code> is the first of two such possible matches, at <code>b[0]</code>.</p>
<p>Once this match is decided, there are no longer any further matches such that, per the <a href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.get_matching_blocks" rel="nofollow noreferrer">guarantee</a> provided by <code>SequenceMatcher.get_matching_blocks()</code>, <strong>"The triples are monotonically increasing in <em>i</em> and in <em>j</em>"</strong>.</p>
<p>For instance, matching the as-yet-unmatched <code>864</code> at <code>a[0]</code> with the as-yet-unmatched <code>864</code> at <code>b[4]</code> would require that <em>i</em> decrease as <em>j</em> increases (or vice versa), in violation of the aforementioned guarantee.</p>
</div>
<span class="comment-copy">thanks for your reply. However, if I am comparing "164079131" and "169079131", it doesn't use the longest block for the first match. The longest block should be "079131".                                                           &gt;&gt;&gt;SequenceMatcher(None,"164079131","169079131").get_matching_b‌​locks()     &gt;&gt;&gt;[Match(a=0, b=0, size=2), Match(a=3, b=3, size=6), Match(a=9, b=9, size=0)]</span>
<span class="comment-copy">@Jessie Sorry, I wasn't entirely clear: the point is that both <i>i</i> and <i>j</i> are guaranteed to increase together, and this isn't possible after the earliest instances of <code>8648</code> have been matched in each string. In your second example, that is possible, as the result shows.</span>
<span class="comment-copy">Note that the first match <b>found</b> is not necessarily the first match <b>returned</b>. Matches are <a href="https://github.com/python/cpython/blob/master/Lib/difflib.py#L489" rel="nofollow noreferrer">sorted</a> after they're found but before they're returned. The code is actually quite clear and well-documented; taking a look through it ought to help you understand what's happening.</span>
