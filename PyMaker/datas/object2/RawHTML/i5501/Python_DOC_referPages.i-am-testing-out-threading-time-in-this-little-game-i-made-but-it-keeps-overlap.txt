<div class="post-text" itemprop="text">
<pre><code>import time
from threading import Timer
from random import randint
print("Every wrong answer is a 3s delay; you have 30s")
end = False
def lose():
    print(end)
    print("Time up!")
    time.sleep(1)
    print("Score is",pts,", with",wrong,"wrong answers.")
    time.sleep(1)
    input("enter to quit")
    quit()
timer = Timer(10,lose)
timer.start()
pts = 0
wrong = 0
while end == False:
    a = randint(5,50)
    b = randint(5,50)
    print(a,"+",b)
    ans = input()
    if ans.isnumeric():
        ans = int(ans)
    if ans == a+b:
        print("correct")
        pts = pts+1
    else:
        print("wrong,",a+b)
        wrong = wrong+1
        print("delay")
        time.sleep(3)
        print("delay end")
    print("")
</code></pre>
<p>When the timer finishes, the loop overlaps the 'lose' function, and it messes up on the line like this:</p>
<pre><code>Time up!

45 + 10
55
Score iscorrect 
3 
, with29  0+  wrong answers.37


enter to quitwrong,p
 66
delay
</code></pre>
<p>How do I fix this issue?<br/>
Sorry if this question has already been answered, but I want to know.</p>
</div>
<div class="post-text" itemprop="text">
<p>Ideally, you should probably avoid using threads altogether, as mentioned in the comments.</p>
<p>However, if you are going to use threads, consider using a <a href="https://stackoverflow.com/a/3311157/2744663">mutex</a> to ensure that multiple threads are not trying to write to stdout at the same time.</p>
<p>For example:</p>
<pre><code># setup at the beginning:
from threading import Thread, Lock
mutex = Lock()

# surrounding each print statement:
mutex.acquire()
try:
    print('text')
finally:
    mutex.release()
</code></pre>
</div>
<span class="comment-copy">looks like the GIL isn't working properly on that one. Surprising.</span>
<span class="comment-copy">Don't you remember â€” threads are run sumultaneously, and with varying speed, and all this timing is unpredictable (depends on many factors). Can you avoid using threads? Can you go for asynchronous functions perhaps?</span>
<span class="comment-copy">Yeah, I think I could do that instead, so the while loop will repeat until start time is 30 less than current time, then 'lose' will play</span>
<span class="comment-copy">I'd probably use <a href="https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement" rel="nofollow noreferrer"><code>with mutex:</code></a>, but yeah.</span>
