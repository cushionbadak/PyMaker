<div class="post-text" itemprop="text">
<p>I am trying to emulate a switch-case statement from the <code>validate_input2</code> function below.</p>
<pre><code>def _validate_inputs2(*args):
    if len(args) == 1:
        stop = args
        start = 1
        step = 1
    elif len(args) == 2:
        start, stop = args
        step = 1
    elif len(args) == 3:
        start, stop, step = args
    else:
        raise TypeError("xxx expected at most 3 arguments, got 4")
    if 0 == step:
        raise ValueError("xxx arg 3 must not be zero")
    return start, stop, step
</code></pre>
<p>This is what I basically did but it doesn't work correctly</p>
<pre><code>def _validate_inputs(*args):
    start, stop, step = {
        len(args) == 1: lambda x, y, z: (args, 1, 1),
        len(args) == 2: lambda x, y, z: (args, 1),
        len(args) == 3: args
    }.get(args, lambda: TypeError("xxx expected at most 3 arguments, got 4"))()
    if 0 == step:
        raise ValueError("xxx arg 3 must not be zero")
    return start, stop, step
</code></pre>
<p>Even though I find this emulation less readable I would like to better understand it in order to improve my python skills.</p>
<p>Can someone help me simplify this code?</p>
</div>
<div class="post-text" itemprop="text">
<p>(Not an answer to the question, but maybe a better approach to the actual problem.)</p>
<p>It seems like you are replicating part of what the Python <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer"><code>slice</code></a> builtin does. So you could just create a <code>slice</code> from the <code>args</code> and get the <code>start</code>, <code>stop</code>, and <code>step</code> from that.</p>
<pre><code>&gt;&gt;&gt; args = (2, 4)
&gt;&gt;&gt; s = slice(*args)
&gt;&gt;&gt; start, stop, step = s.start, s.stop, s.step
&gt;&gt;&gt; start, stop, step
(2, 4, None)
</code></pre>
<p>This also takes care of handling the error cases:</p>
<pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; slice(*args)    
TypeError: slice expected at most 3 arguments, got 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a solution that builds upon what you have done:</p>
<pre><code>def _validate_inputs(*args):
    if len(args) &gt; 3:
        raise TypeError("xxx expected at most 3 arguments, got 4")
    else:
        start, stop, step = {
            1: (1,) + args + (1,),
            2: args + (1,),
            3: args
        }.get(len(args))
        if 0 == step:
            raise ValueError("xxx arg 3 must not be zero")
        return start, stop, step
</code></pre>
<p>Example outputs:</p>
<pre><code>&gt;&gt;&gt; print _validate_inputs(40)
(1, 40, 1)

&gt;&gt;&gt; print(_validate_inputs(10, 20))
(10, 20, 1)

&gt;&gt;&gt; print(_validate_inputs(1, 2, 3))
(1, 2, 3)
</code></pre>
<p><strong>Edit</strong>: The <code>TypeError</code> wasn't working correctly in the original post. You can't return a <code>TypeError</code> as the not-found value in <code>get()</code> in this case, since the code is expecting 3 values to be unpacked (in <code>python 2.x</code> at least AFAIK). </p>
<p>I've updated the code to handle the case where <code>len(args) &gt; 3</code>. One could also add a check for the case where <code>args</code> is <code>None</code> or empty.</p>
<pre><code>&gt;&gt;&gt; print(_validate_inputs(1, 2, 3, 4))
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-302-c2f9c1befae1&gt; in &lt;module&gt;()
----&gt; 1 print(_validate_inputs(1,2,3,4))

&lt;ipython-input-296-769e989711e0&gt; in _validate_inputs(*args)
      1 def _validate_inputs(*args):
      2     if len(args) &gt; 3:
----&gt; 3         raise TypeError("xxx expected at most 3 arguments, got 4")
      4     else:
      5         start, stop, step = {

TypeError: xxx expected at most 3 arguments, got 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would try something like this..</p>
<pre><code>def _validate_inputs(*args):
    start, stop, step = [0, 0, 0]
    dict = {1: [args, 1, 1], 2: args.append(1), 3: args}

    if len(args) in dict.keys():
         start, stop, step = dict[len(args)]
    else:
        raise TypeError("xxx expected at most 3 arguments, got "+str(len(args))))()

    if 0 == step:
        raise ValueError("xxx arg 3 must not be zero")
    return start, stop, step
</code></pre>
</div>
<span class="comment-copy">What errors are you getting?</span>
<span class="comment-copy">Addendum: The "step not zero" check is actually not performed by <code>slice</code> itself, but only when using the slice to slice e.g. a list.</span>
<span class="comment-copy">Indeed I am doing the same operation as slice. Thanks</span>
<span class="comment-copy">I think this should be <code>1: (1,) + args + (1,),</code> or <code>1: (1, *args, 1)</code>, but otherwise fine.</span>
<span class="comment-copy">Oops, didn't see that. Fixed it now. Thanks.</span>
<span class="comment-copy">Thanks your code help me understand the switch-case as a dict however I accepted the 'slice' that does more nicely what the method is doing.</span>
<span class="comment-copy">The dict is invalid syntax, and the value for <code>2</code> is <code>None</code>...</span>
<span class="comment-copy">I just edited and  added commas in between the dict values.</span>
