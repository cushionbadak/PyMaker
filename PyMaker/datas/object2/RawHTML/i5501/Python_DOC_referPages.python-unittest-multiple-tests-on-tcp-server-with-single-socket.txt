<div class="post-text" itemprop="text">
<p>I am trying to test my implementation of a simple service that uses a TCP socket. I would like to test my server without creating a connection for every test case. I would like to make a single connection for the entire test suite. Currently I have something that looks like this..</p>
<pre><code>class Test_service(unittest.TestCase):

    def test_1(self):
        client_socket = socket(AF_INET, SOCK_STREAM)
        client_socket.connect(('', port_number))
        client_socket.send('message1'.encode())
        self.assertEqual(client_socket.recv(1024).decode(), 'reply1')
        client_socket.close()

    def test_2(self):
        client_socket = socket(AF_INET, SOCK_STREAM)
        client_socket.connect(('', port_number))
        client_socket.send('message2'.encode())
        self.assertEqual(client_socket.recv(1024).decode(), 'reply2')
        client_socket.close()

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>What is a good way to keep a single socket connection open and have multiple test cases use that connection?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you look at the <a href="https://docs.python.org/3/library/unittest.html#organizing-tests" rel="nofollow noreferrer">docs</a> you'll find that can put <code>setUp</code> and <code>tearDown</code> methods in your test class that will get executed once. So you can do something like:</p>
<pre><code>class Test_service(unittest.TestCase):

    def setUp(self):
        client_socket = socket(AF_INET, SOCK_STREAM)
        client_socket.connect(('', port_number))

    def tearDown(self):
        client_socket.close()

    def test_1(self):
        client_socket.send('message1'.encode())
        self.assertEqual(client_socket.recv(1024).decode(), 'reply1')

    def test_2(self):
        client_socket.send('message2'.encode())
        self.assertEqual(client_socket.recv(1024).decode(), 'reply2')
</code></pre>
</div>
