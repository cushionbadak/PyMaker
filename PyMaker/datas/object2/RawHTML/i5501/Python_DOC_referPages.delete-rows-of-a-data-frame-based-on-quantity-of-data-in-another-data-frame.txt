<div class="post-text" itemprop="text">
<p>I have two pandas data frames <code>A</code> and <code>B</code>. <code>B</code> is a subset of A.</p>
<p>I want to delete all numbers from A if it's in B. <strong>But</strong>, if a number occurs two times in A and 1 time in B then it will only delete 1 occurrence of the number from A.</p>
<p>Here is my sample data sets:</p>
<pre><code>df_A                df_B
[Test]              [Test]
1                   1
2                   2         
3                   5 
2                   5 
4
5
5
</code></pre>
<p>After the operation I want new data frame c as</p>
<pre><code>df_C
[Test]
3
2
4
</code></pre>
<p>Can you please suggest how to do that?</p>
<p>The <a href="https://stackoverflow.com/questions/39880627/in-pandas-how-to-delete-rows-from-a-data-frame-based-on-another-data-frame">suggested duplicate</a> removes all occurrences from <code>A</code> if present in <code>B</code>, not just the first N occurrences.</p>
</div>
<div class="post-text" itemprop="text">
<p>I might do something (stealing SR's setup):</p>
<pre><code>dfA = pd.DataFrame({'A': [1, 2, 3, 2, 4, 5, 5]})
dfB = pd.DataFrame({'B': [1, 2, 5, 5]})

counts = dfA.groupby('A').cumcount()
limits = dfB['B'].value_counts().reindex(dfA.A).fillna(0).values
dfC = dfA.loc[counts &gt;= limits]
</code></pre>
<p>which gives me</p>
<pre><code>In [121]: dfC
Out[121]: 
   A
2  3
3  2
4  4
</code></pre>
<hr/>
<p>This works by using groupby to get the number of times a given value in A has been seen before:</p>
<pre><code>In [124]: dfA.groupby('A').cumcount()
Out[124]: 
0    0
1    0
2    0
3    1
4    0
5    0
6    1
dtype: int64
</code></pre>
<p>and using <code>value_counts</code> to get the limits which we then reindex to match the counts:</p>
<pre><code>In [139]: dfB['B'].value_counts()
Out[139]: 
5    2
2    1
1    1
Name: B, dtype: int64

In [140]: dfB['B'].value_counts().reindex(dfA.A)
Out[140]: 
A
1    1.0
2    1.0
3    NaN
2    1.0
4    NaN
5    2.0
5    2.0
Name: B, dtype: float64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you create some intermediate values which contain the occurrence number for each value, then you can use <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html" rel="nofollow noreferrer"><code>pandas.Series.isin()</code></a> to create a logical index of which rows of the dataframe to exclude like:</p>
<h3>Code:</h3>
<pre><code>from collections import Counter

def occurrences_number(column):

    def occurrence_number(value, accumulator):
        """ tuple of value and occurrence number of value """
        accumulator[value] += 1
        return value, accumulator[value]

    occurrences = Counter()
    return column.apply(lambda x: occurrence_number(x, occurrences))

def find_not_in_by_occurrence_number(data, not_in):
    not_in_indices = ~occurrences_number(data).isin(occurrences_number(not_in))
    return data[not_in_indices].reset_index()
</code></pre>
<h3>Test Code:</h3>
<pre><code>import pandas as pd

dfA = pd.DataFrame({'A': [1, 2, 3, 2, 4, 5, 5]})
dfB = pd.DataFrame({'B': [1, 2, 5, 5]})
print(dfA)
print(dfB)

dfC = find_not_in_by_occurrence_number(dfA.A, dfB.B).A

print (dfC)
</code></pre>
<h3>Results:</h3>
<pre><code>   A
0  1
1  2
2  3
3  2
4  4
5  5
6  5

   B
0  1
1  2
2  5
3  5

0    3
1    2
2    4
Name: A, dtype: int64
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In this problem, you can make use of <a href="https://docs.python.org/3/library/collections.html#counter-objects" rel="nofollow noreferrer"><code>Counter</code></a> and <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html" rel="nofollow noreferrer"><code>drop</code></a>. For drop, you will need to know the indexes of rows that you want to discard.</p>
<pre><code>import itertools
from collections import Counter
df = pd.DataFrame({'Test': {0: 1, 1: 2, 2: 3, 3: 2, 4: 4, 5: 5, 6: 5}})
df2 = pd.DataFrame({'Test': {0: 1, 1: 2, 2: 5, 3: 5}})
c_df2 = Counter(df2.Test)

indexes_to_remove_2d = [df.index[df['Test'] == k].tolist()[:v] 
                        for k, v in c_df2.items()]
# [[0], [1], [5, 6]]
merged = list(itertools.chain(*indexes_to_remove_2d))
# [0, 1, 5, 6]
df.drop(merged)

    Test
2   3
3   2
4   4
</code></pre>
<p><code>indexes_2d</code> generates those indexes that fits the value <code>k</code> in the counter with <code>df.index[df['Test'] == k]</code> and has a <code>[:v]</code> to limit the size of indexes we take from. </p>
<p>Then, we merge these <code>indexes</code> with <code>itertools.chain</code>. Finally drop rows with these indexes.</p>
<p>Thanks for Stephan Ranch to point out the order problem.</p>
</div>
<span class="comment-copy">Possible duplicate of <a href="https://stackoverflow.com/questions/39880627/in-pandas-how-to-delete-rows-from-a-data-frame-based-on-another-data-frame">In Pandas, how to delete rows from a Data Frame based on another Data Frame?</a></span>
<span class="comment-copy">This is not dupe, as question asks to remove only first N occurrences.</span>
<span class="comment-copy">@StephenRauch That's true! Will emphasize it.</span>
