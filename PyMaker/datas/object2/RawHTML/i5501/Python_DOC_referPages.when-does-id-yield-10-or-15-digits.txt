<div class="post-text" itemprop="text">
<p>I've realized that in some circumstances (version of python and type) the <code>id</code> built-in function is yielding a 15 digit number, rather than the mostly seen 10 digits. I was wondering if it might be long as the Documentation mentions that, but that's not the case </p>
<blockquote>
<p>id: Return the “identity” of an object. This is an <strong>integer</strong> <strong>(or long integer)</strong> which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.</p>
</blockquote>
<p>Here is what I've tried: </p>
<p><strong>Python 2.7.5 - GCC 4.8.3 Linux 2</strong></p>
<pre><code>&gt;&gt;&gt; print(id(3))
18705464
&gt;&gt;&gt; print(id('2'))
139621043310840
</code></pre>
<p>Python </p>
<p><strong>Python 2.7.14 - GCC 4.2.1 Compatible Apple LLVM 9.0.0</strong></p>
<pre><code>&gt;&gt;&gt; print(id('1'))
4318307312
&gt;&gt;&gt; print(id(1))
140699106326584
</code></pre>
<p>As you can see, in two different <em>minor</em> versions on two operating systems I have a slightly different behaviour. In one case a <code>str</code> object yields 15 digits in the other case an <code>int</code>. In Python 3 I couldn't reproduce it, they are all 10 digits.</p>
</div>
<div class="post-text" itemprop="text">
<p>The numbers depend entirely on what memory regions the OS has assigned to Python, and should not be seen as anything other than opaque.</p>
<p>From the <a href="https://docs.python.org/3/library/functions.html#id" rel="nofollow noreferrer">documentation for <code>id()</code></a>:</p>
<blockquote>
<p><strong>CPython implementation detail</strong>: This is the address of the object in memory.</p>
</blockquote>
<p>The <a href="https://github.com/python/cpython/blob/2.7/Python/bltinmodule.c#L928-L932" rel="nofollow noreferrer">implementation of the function</a> simply converts the pointer to a long:</p>
<pre class="lang-c prettyprint-override"><code>static PyObject *
builtin_id(PyObject *self, PyObject *v)
{
    return PyLong_FromVoidPtr(v);
}
</code></pre>
<p>The basic implementation hasn't changed since Python 1.0; there has been no change whatsoever in how this number is produced since <a href="https://github.com/python/cpython/commit/5b7221849e240c2a62ebbc48d58607417b42ef44" rel="nofollow noreferrer">the first time the function was added</a>, over 2 decades ago (only the C function call to produce the Python integer object has been renamed in that time).</p>
<p>The number of digits used is entirely dependant on how much memory is addressable and available, how your OS allocates it to the Python process, and how many objects the Python process has loaded into memory, and how much memory fragmentation has taken place. For example, a 32-bit OS is likely to produce lower ids than a 64-bit OS, purely because the latter can address more memory.</p>
<p>You'll find that if you ran your tests more often (interspersed with other programs starting or having exited, and different memory loads on your OS), the numbers will vary widely.</p>
</div>
<span class="comment-copy">An implementation detail, possibly?</span>
<span class="comment-copy">In the standard Python interpreter (CPython), <code>id()</code> is the memory address of the object. It doesn't need to have a certain number of digits, and different platforms (and Python versions) may allocate memory differently. This is not something you need to concern yourself with.</span>
<span class="comment-copy">what do you care?</span>
<span class="comment-copy">I don't, I was reading about memory allocation and was expecting that the id would be <code>2**32</code> (which would be 10 digits) and found <code>2**49</code>.  I still appreciate grumpy downvoters.</span>
<span class="comment-copy">I'd love to hear what is not helpful or wrong about my answer, to deserve a downvote. That way I can improve my answer!</span>
