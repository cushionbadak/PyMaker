<div class="post-text" itemprop="text">
<p>It is well known that tuples are not defined by parentheses, but commas. <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="noreferrer">Quote from documentation</a>:</p>
<blockquote>
<p>A tuple consists of a number of values separated by commas</p>
</blockquote>
<p>Therefore:</p>
<pre><code>myVar1 = 'a', 'b', 'c'
type(myVar1)
# Result:
&lt;type 'tuple'&gt;
</code></pre>
<p>Another striking example is this:</p>
<pre><code>myVar2 = ('a')
type(myVar2)
# Result:
&lt;type 'str'&gt;  

myVar3 = ('a',)
type(myVar3)
# Result:
&lt;type 'tuple'&gt;
</code></pre>
<p>Even the single-element tuple needs a comma, and parentheses are always used just to avoid confusion. <strong>My question is:</strong> Why can't we omit parentheses of arrays in a list comprehension? For example:</p>
<pre><code>myList1 = ['a', 'b']
myList2 = ['c', 'd']

print([(v1,v2) for v1 in myList1 for v2 in myList2])
# Works, result:
[('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd')]

print([v1,v2 for v1 in myList1 for v2 in myList2])
# Does not work, result:
SyntaxError: invalid syntax
</code></pre>
<p>Isn't the second list comprehension just syntactic sugar for the following loop, which does work?</p>
<pre><code>myTuples = []
for v1 in myList1:
    for v2 in myList2:
        myTuple = v1,v2
        myTuples.append(myTuple)
print myTuples
# Result:
[('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's grammar is <a href="https://docs.python.org/3/reference/grammar.html" rel="noreferrer">LL(1)</a>, meaning that it only looks ahead one symbol when parsing.</p>
<pre><code>[(v1, v2) for v1 in myList1 for v2 in myList2]
</code></pre>
<p>Here, the parser sees something like this.</p>
<pre><code>[ # An opening bracket; must be some kind of list
[( # Okay, so a list containing some value in parentheses
[(v1
[(v1,
[(v1, v2
[(v1, v2)
[(v1, v2) for # Alright, list comprehension
</code></pre>
<p>However, without the parentheses, it has to make a decision earlier on.</p>
<pre><code>[v1, v2 for v1 in myList1 for v2 in myList2]

[ # List-ish thing
[v1 # List containing a value; alright
[v1, # List containing at least two values
[v1, v2 # Here's the second value
[v1, v2 for # Wait, what?
</code></pre>
<p>A parser which backtracks tends to be notoriously slow, so LL(1) parsers do not backtrack. Thus, the ambiguous syntax is forbidden.</p>
</div>
<div class="post-text" itemprop="text">
<p>As I felt <a href="https://github.com/python/cpython/blob/v3.6.4/Grammar/Grammar" rel="nofollow noreferrer">"because the grammar forbids it"</a> to be a little too snarky, I came up with a <em>reason</em>.</p>
<p>It begins parsing the expression as a list/set/tuple and is expecting a <code>,</code> and instead encounters a <code>for</code> token.</p>
<p>For example:</p>
<pre><code>$ python3.6 test.py
  File "test.py", line 1
    [a, b for a, b in c]
            ^
SyntaxError: invalid syntax
</code></pre>
<p>tokenizes as follows:</p>
<pre><code>$ python3.6 -m tokenize test.py
0,0-0,0:            ENCODING       'utf-8'        
1,0-1,1:            OP             '['            
1,1-1,2:            NAME           'a'            
1,2-1,3:            OP             ','            
1,4-1,5:            NAME           'b'            
1,6-1,9:            NAME           'for'          
1,10-1,11:          NAME           'a'            
1,11-1,12:          OP             ','            
1,13-1,14:          NAME           'b'            
1,15-1,17:          NAME           'in'           
1,18-1,19:          NAME           'c'            
1,19-1,20:          OP             ']'            
1,20-1,21:          NEWLINE        '\n'           
2,0-2,0:            ENDMARKER      ''     
</code></pre>
</div>
<span class="comment-copy">If I'm not wrong, the rounded brackets math operator has precedence over tuple assignment.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">docs.python.org/3/reference/â€¦</a></span>
<span class="comment-copy">You might want to explore the grammar for <a href="https://docs.python.org/3/reference/expressions.html#list-displays" rel="nofollow noreferrer"><code>list displays</code></a> some more.  You'll notice that a <code>comprehension</code> is <code>expression comp_for</code>.  An <code>expression</code> is different from a <code>starred_list</code>, which is what the bare comma separated values you're considering are.  Basically, the language/parser does not accept <code>expression, expression, ...</code> everywhere it accepts an <code>expression</code></span>
<span class="comment-copy">Note that <code>[v1, (v2 for v1 in myList1 for v2 in myList2)]</code> is also valid syntax (assuming <code>v1</code> is defined previously). So you need the parentheses to disambiguate.</span>
<span class="comment-copy">Thank y'all for the really good discussion! I wish I could mark all of the answers and comments as the accepted answer! :)</span>
<span class="comment-copy">I think your second example shouldn't contain any parenthesis around <code>v1, v2</code></span>
<span class="comment-copy">You are correct, and I should stop relying on my clipboard to do all the work for me.</span>
<span class="comment-copy">Thank you, @SilvioMayolo! I guess my question constitutes an example of when list comprehension can be really different than a for loop due to grammar.</span>
<span class="comment-copy">Thank you Anthony, <code>tokenize</code> is really cool! Definitely upvoted, but hope you don't mind me marking the most upvoted answer as accepted.</span>
<span class="comment-copy">Not that it isn't the right thing to do here but you shouldn't necessarily accept an answer based on votes alone.  From the help <a href="https://stackoverflow.com/help/someone-answers">Choose one answer that you believe is the best solution to your problem.</a>.</span>
