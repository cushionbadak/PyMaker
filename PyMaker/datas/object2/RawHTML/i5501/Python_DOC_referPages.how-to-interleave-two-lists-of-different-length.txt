<div class="post-text" itemprop="text">
<p>I'm quite new to Python and I am still having a hard time actually using the language itself into my program. Here's what I have so far:</p>
<pre><code># Purpose: 'twolists' = takes 2 lists, &amp; returns a new list containing
# alternating elements of lists. 
# Return = final_list
# Parameter = list1, list2

def twolists(list1, list2): # don't forget to return final_list
    alt_list = []
    a1 = len(list1)
    a2 = len(list2)

    for i in range(# ? ):
        # append one thing from list1 to alt_list - How?
        # append one thing from list2 to alt_list - How?
</code></pre>
<p>Now the program is supposed to yield outputs like these:</p>
<pre><code>outcome = twolists([ ], ['w', 'x', 'y', 'z'])
print(outcome)
['w', 'x', 'y', 'z']

outcome = twolists([0, 1], ['w', 'x'])
print(outcome)
[0, 'w', 1, 'x']

outcome = twolists([0, 1], ['w', 'x', 'y', 'z'])
print(outcome)
[0, 'w', 1, 'x', 'y', 'z']

outcome = twolists([0, 1, 2, 3], ['w', 'x'])
print(outcome)
[0, 'w', 1, 'x', 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def twolists(list1, list2):
    newlist = []
    a1 = len(list1)
    a2 = len(list2)

    for i in range(max(a1, a2)):
        if i &lt; a1:
            newlist.append(list1[i])
        if i &lt; a2:
            newlist.append(list2[i])

    return newlist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This composes a list comprehension using <code>zip_longest</code> from <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow noreferrer">itertools</a> (which is part of the standard library) to interleave items from both lists into a <code>tuple</code>, which by default uses <code>None</code> as the fillvalue. </p>
<p>This also uses <code>chain</code> also from <code>itertools</code> to flatten the list. </p>
<p>Finally it filters the <code>None</code> items from the list: </p>
<pre><code>from itertools import chain, zip_longest
def twolists(l1, l2):
    return [x for x in chain(*zip_longest(l1, l2)) if x is not None]
</code></pre>
<p>Or as recommended from @EliKorvigo, use <code>itertools.chain.from_iterable</code> for iterating lazily:</p>
<pre><code>def twolists(l1, l2):
    return [x for x in chain.from_iterable(zip_longest(l1, l2)) if x is not None]
</code></pre>

Testing

<pre><code>In [56]: twolists([0, 1], ['w', 'x'])
Out[56]: [0, 'w', 1, 'x']

In [57]: twolists([0, 1], ['w', 'x', 'y', 'z'])
Out[57]: [0, 'w', 1, 'x', 'y', 'z']

In [74]: twolists([0, 1, 2, 3], ['w', 'x'])
Out[74]: [0, 'w', 1, 'x', 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>A basic approach:</strong></p>
<p>You could <code>zip()</code> the lists normally, and append the rest of the biggest list if both lists are not the same size:</p>
<pre><code>def two_lists(lst1, lst2):
    result = []

    for pair in zip(lst1, lst2):
        result.extend(pair)

    if len(lst1) != len(lst2):
        lsts = [lst1, lst2]
        smallest = min(lsts, key = len)
        biggest = max(lsts, key = len)
        rest = biggest[len(smallest):]
        result.extend(rest)

    return result
</code></pre>
<p>Which works as follows:</p>
<pre><code>&gt;&gt;&gt; print(two_lists([], ['w', 'x', 'y', 'z']))
['w', 'x', 'y', 'z']
&gt;&gt;&gt; print(two_lists([0, 1], ['w', 'x']))
[0, 'w', 1, 'x']
&gt;&gt;&gt; print(two_lists([0, 1], ['w', 'x', 'y', 'z']))
[0, 'w', 1, 'x', 'y', 'z']
&gt;&gt;&gt; print(two_lists([0, 1, 2, 3], ['w', 'x']))
[0, 'w', 1, 'x', 2, 3]
</code></pre>
<p><strong>Another possible approach:</strong></p>
<p>You could also use <a href="https://docs.python.org/3.6/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> to convert the lists to <code>deque()</code> objects beforehand, and pop off the beginning of each one with <code>popleft()</code>, until one of the objects is empty. Then you could append the rest of the list that is not yet empty. </p>
<p>Here is an example:</p>
<pre><code>def two_lists2(lst1, lst2):
    result = []

    fst, snd = deque(lst1), deque(lst2)

    while fst and snd:
        result.append(fst.popleft())
        result.append(snd.popleft())

    rest = leftover(fst, snd)
    if rest:
        result.extend(rest)

    return result

def leftover(x, y):
    if x and not y:
        return x

    elif y and not x:
        return y

    return None
</code></pre>
<p><strong>Note:</strong> Both of the approaches are <code>O(n)</code> time, which is expected for this kind of problem. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution that deals in iterators. The advantage to this is that it will work with any iterable data structure, not just lists.</p>
<pre><code>def twolists(list1, list2):
    result = []
    iter1 = iter(list1)
    iter2 = iter(list2)
    try:
        while True:
            result.append(next(iter1))
            result.append(next(iter2))
    except StopIteration:
        # This exception will be raised when either of the iterators
        # hits the end of the sequence.
        pass
    # One of the lists is exhausted, but not both of them. We need
    # to finish exhausting the lists.
    try:
        while True:
            result.append(next(iter1))
    except StopIteration:
        pass
    try:
        while True:
            result.append(next(iter2))
    except StopIteration:
        pass
    return result
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't care whether your original lists (<code>a</code> and <code>b</code> in the following example) change, you can use the following snippet:</p>
<pre><code>def twolists(a, b):
    result = []
    while len(a) &gt; 0:
        result.append(a.pop(0))
        if len(b) &gt; 0:
            result.append(b.pop(0))
    result += a + b
    return result

twolists([ ], ['w', 'x', 'y', 'z'])
print(outcome)

outcome = twolists([0, 1], ['w', 'x'])
print(outcome)

outcome = twolists([0, 1], ['w', 'x', 'y', 'z'])
print(outcome)

outcome = twolists([0, 1, 2, 3], ['w', 'x'])
print(outcome)
</code></pre>
<p>Produces the following output:</p>
<pre><code>['w', 'x', 'y', 'z']
[0, 'w', 1, 'x']
[0, 'w', 1, 'x', 'y', 'z']
[0, 'w', 1, 'x', 2, 3]
</code></pre>
</div>
<span class="comment-copy">Look at the desired output. This is completely different from what was requested.</span>
<span class="comment-copy">@SilvioMayolo very well, I have edited and addressed the interleaving requirement.</span>
<span class="comment-copy">You beat me to it. Though, instead of <code>chain(*zip_longest(...))</code> you'd better use <code>chain.from_iterable(zip_longest(...))</code>. That starred expansion kills all the laziness early on.</span>
<span class="comment-copy">@EliKorvigo sure, edited.</span>
<span class="comment-copy">Too long and too many try catches for a beginner.</span>
<span class="comment-copy">This is (1) awfully effectful and (2) has quadratic time complexity for no good reason. This task is naturally linear in time, why make a quadratic monster out of it for not other reason, than to gain some reputation scores?</span>
