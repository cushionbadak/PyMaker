<div class="post-text" itemprop="text">
<p>I have dictionary in python as </p>
<pre><code>d = {(2,4):40,(1,2,4):8}
</code></pre>
<p>in this dict keys are tuples,
Values are count of each element in the tuple</p>
<p>I need output 1 more dictionary as
Total count of values in all the tuples</p>
<pre><code>out={2:48,4:48,1:8}
</code></pre>
<p>The example I gave is small dictionary but I have very large dictionary so time complexity plays the key role
Can someone help me out?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this in a single pass, just iterate over the keys and add the corresponding value. You can use a <code>collections.Counter</code> or whatever dict/dict-like container you prefer:</p>
<pre><code>&gt;&gt;&gt; origin = {(2,4):40,(1,2,4):8}
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; counts = Counter()
&gt;&gt;&gt; for k, v in origin.items(): # python 2 use .iteritems()
...     for x in k:
...         counts[x] += v
...
&gt;&gt;&gt; counts
Counter({2: 48, 4: 48, 1: 8})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One can utilize the capability of multiple <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>Counters</code></a> to be  handily summed to create some neat one-liners, but their performance can't compete with <a href="https://stackoverflow.com/questions/48221317/finding-the-max-repeated-value-in-dictionary-keys-python/answer-48221400">juanpa's explicit loop approach</a> (timings for the original <code>dict</code>):</p>
<pre><code>from collections import Counter
from operator import add
from functools import reduce

# 1
out = sum((Counter({x: v for x in k}) for k, v in d.items()), Counter())
# timeit: 16.2

# 2
out = reduce(add, (Counter({x: v for x in k}) for k, v in d.items()))
# timeit: 10.8

# 3
# juanpa's approach
# timeit: 3.7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>Dict = {(2,4):40,(1,2,4):8}    
Out={}

for k,v in Dict.items():
    for i in k:
        if i in Out:
            Out[i] += v
        else:
            Out[i] = v

print(Out)

{2: 48, 4: 48, 1: 8}
</code></pre>
</div>
<span class="comment-copy">You want to find the ones with biggest counts? Like 4 or 2 becaue they all have 48?</span>
<span class="comment-copy">Hm. You use a <code>Counter</code> without utilizing its counting ability. It does nothin g a common <code>dict</code> couldn't do (or a <code>defaultdict(int)</code>).</span>
<span class="comment-copy">@schwobaseggl of course I use it's counting ability.</span>
<span class="comment-copy">Not in any way any other dict couldn't do.</span>
<span class="comment-copy">@schwobaseggl so? This is the most straight-forward way. It is fast, and memory efficient.</span>
<span class="comment-copy">I don't say it is wrong ;) I just think this is bad example to show someone a <code>Counter</code> whose inherent advantage is its performant constructor that one can pass an iterable, but a much better chance to introduce the OP to a <code>defaultdict</code>.</span>
