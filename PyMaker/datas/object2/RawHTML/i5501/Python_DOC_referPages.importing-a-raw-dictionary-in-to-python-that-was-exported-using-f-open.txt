<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/11026959/writing-a-dict-to-txt-file-and-reading-it-back">Writing a dict to txt file and reading it back?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
</ul>
</div>
<p>everyone.</p>
<p>I was tinkering with ways to store dictionaries and retrieve them later, loading them into and replacing the existing dictionary values.  </p>
<p>I was intending to use this as a way to store game data in a simple text-based game.</p>
<pre><code># Player dictionaries

p1 = {'name' : "placeholder", 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0,
      'atk': 0, 'def': 0, 'cyra' : 0, 'monero' : 0, 'bits': 0, 'dollars': 0,
      'nordas': 0,}
p2 = {'name' : "placeholder", 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0,
      'atk': 0, 'def': 0, 'cyra' : 0, 'monero' : 0, 'bits': 0, 'dollars': 0,
      'nordas': 0,}
p3 = {'name' : "placeholder", 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0,
      'atk': 0, 'def': 0, 'cyra' : 0, 'monero' : 0, 'bits': 0, 'dollars': 0,
      'nordas': 0,}
p4 = {'name' : "placeholder", 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0,
      'atk': 0, 'def': 0, 'cyra' : 0, 'monero' : 0, 'bits': 0, 'dollars': 0,
      'nordas': 0,}
p5 = {'name' : "placeholder", 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0,
      'atk': 0, 'def': 0, 'cyra' : 0, 'monero' : 0, 'bits': 0, 'dollars': 0,
      'nordas': 0,}
p6 = {'name' : "placeholder", 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0,
      'atk': 0, 'def': 0, 'cyra' : 0, 'monero' : 0, 'bits': 0, 'dollars': 0,
      'nordas': 0,}

#save function
import pickle
def save() :
    f = open("p1.txt","w")
    f.write( str(p1) )
    f.close()

    f = open("p2.txt","w")
    f.write( str(p2) )
    f.close()

    f = open("p3.txt","w")
    f.write( str(p3) )
    f.close()

    f = open("p4.txt","w")
    f.write( str(p4) )
    f.close()

    f = open("p5.txt","w")
    f.write( str(p5) )
    f.close()

    f = open("p6.txt","w")
    f.write( str(p6) )
    f.close()

    print ("The game was saved.")
</code></pre>
<p>To my delight, I discovered that this does work, and it creates six files names "p1.txt", "p2.txt", and so forth in the folder that the program is saved. It looks exactly like the original dictionary:</p>
<pre><code>{'name': 'placeholder', 'hp': 0, 'str': 0, 'stm': 0, 'mana': 0, 'atk': 0, 'def': 0, 'cyra': 0, 'monero': 0, 'bits': 0, 'dollars': 0, 'nordas': 0}
</code></pre>
<p>However, upon attempting to try and create an <code>import_save()</code> function, I ran into a problem. I couldn't use <code>unpickle()</code>, because that's not how I exported the dictionary in the first place. Any tips on how this could be solved?</p>
<p>I was also looking to find a way that the imported dictionary could over-write the existing dictionary? I couldn't find anything about it... I'm not against re-writing the code if that is needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>As @Mark suggested, json is the best way:</p>
<pre><code>import json

p_list = [p1, p2, p3, p4, p5, p6]

# Write
for i in range(1, 7):
    with open('p'+str(i)+'.json', 'w') as f:
        json.dump(p_list[i-1], f)

#Read
p_read_list = list()
for i in range(1, 7):
    with open('p'+str(i)+'.json', 'r') as f:
        p_read_list.append(json.load(f))

print(p_read_list[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this instead:</p>
<pre><code>import json

# save to file
with open("p1.txt", "w") as f:
    json.dump(p1, f)

# read from file
with open("p1.txt", "r") as f:
    p1 = json.load(f)
</code></pre>
<p>Although as Patrick Haugh mentions, and the duplicate answer also indicates, <code>json</code> will convert all dictionary keys to unicode strings, so, for example, if you had integers like <code>{1: 'a'}</code> decoded would be <code>{u'1': u'a'}</code> which is not the same as the original dictionary - <em>note the key is now a string, not an integer</em>. Using the <code>pickle</code> module would avoid this particular issue, but it is not human readable, nor is it readable by other computer languages - <code>pickle</code> is a Python object serialization.</p>
</div>
<span class="comment-copy">Just a thought, but why not use the <a href="https://docs.python.org/3/library/json.html" rel="nofollow noreferrer"><code>json</code> module</a> instead. Also it's better IMO too wrap open in a <code>with</code> context.</span>
<span class="comment-copy">might help if you show us your <code>import_save()</code> function</span>
<span class="comment-copy">also why 6 file? just add all the dict in the list or another dict and store it in a single file using <code>json.dump</code> (and read it again using <code>json.load</code>)</span>
<span class="comment-copy">Patrick Haugh I agree, <a href="https://stackoverflow.com/a/11027016/1020470">this answer</a> has the <code>pickle</code> alternative to using <code>json</code> and avoids the dangerous evil function that shall not be named</span>
<span class="comment-copy">I'm not a fan of <code>json</code> for this because not all python dictionaries conform to the <a href="https://json.org/" rel="nofollow noreferrer"><code>json</code> standard</a>.  I would probably use either <code>ast.literal_eval</code> or <code>pickle</code></span>
<span class="comment-copy">Thank you. Can I ask what this does, step-by-step?</span>
<span class="comment-copy">We first create a list of the dicts, then <code>json.dump()</code> dumps the ith dict into file f (of name <code>p&lt;i&gt;.json</code>), then to load it back, we use <code>json.load()</code></span>
<span class="comment-copy">Thanks! I'll try this and report back.</span>
