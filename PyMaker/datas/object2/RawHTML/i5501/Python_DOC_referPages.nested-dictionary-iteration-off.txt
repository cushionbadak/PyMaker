<div class="post-text" itemprop="text">
<p>I am trying to convert some data into a nested dictionary, where there is a general State key and then specific Area keys that match to numbers (as seen below).</p>
<p>To get the data into this better form, I have a painful triple loop as seen below. However, it is not working properly because it is only saving the last number for every state/area. I have tried to adjust this code but do not see where to fix my iteration to make it properly loop through each iterator and place the growth numbers aaccordingly. The output that I am trying to get vs. the actual output is below - while there is no error message, the output is not what I am aiming for. </p>
<p>Thank you for your help on this, and curious if this is a wildly inefficient (or okay) way to iterate when there are dictionaries inside dictionaries. </p>
<pre><code>state=['NJ', 'NY', 'TX', 'CA', 'OH']
area=['North','South']
growth = [['State', 'North', 'South'],
    ['NJ', '5.09', '3'],
    ['NY', '0', '1',],
    ['TX', '8','5.54'],
    ['CA', '6', '1'],
    ['OH', '7.77', '5']]

nested_dict={}
for i in range(1,len(growth)):
    nested_dict[growth[i][0]]=dict()

for i in range(0,len(state)):
    for j in range(0,len(area)):
        for k in range(1,len(growth[0])):
            nested_dict[state[i]][area[j]]=float(growth[i+1][k])
</code></pre>
<p>Expected Output: </p>
<pre><code>{'CA': {'North': 6.0, 'South': 1.0},
 'NJ': {'North': 5.09, 'South': 3.0},
 'NY': {'North': 0.0, 'South': 1.0},
 'OH': {'North': 7.77, 'South': 5.0},
 'TX': {'North': 8.0, 'South': 5.54}}
</code></pre>
<p>Wrong Output:</p>
<pre><code>{'CA': {'North': 1.0, 'South': 1.0},
 'NJ': {'North': 3.0, 'South': 3.0},
 'NY': {'North': 1.0, 'South': 1.0},
 'OH': {'North': 5.0, 'South': 5.0},
 'TX': {'North': 5.54, 'South': 5.54}}
</code></pre>
<p><em>Edits above to reflect comments</em></p>
</div>
<div class="post-text" itemprop="text">
<p>You are assigning both the 2nd and 3rd values from your <code>growth</code> rows to all <code>state</code> and <code>area</code> pairings, with your innermost loop:</p>
<pre><code>for k in range(1,len(growth[0])):
</code></pre>
<p>So you end up assigning twice:</p>
<pre><code># first iteration
i = 0   # state: NJ
j = 0   # area: North
k = 1   # second column in growth
nested_dict[state[0]][area[0]] = float(growth[0+1][1])
# nested_dict['NJ']['North'] = float(['NJ', '5.09', '3'][1] == '5.09')

# second iteration
i = 0   # state: NJ
j = 0   # area: North
k = 2   # third column in growth
nested_dict[state[0]][area[0]] = float(growth[0+1][2])
# nested_dict['NJ']['North'] = float(['NJ', '5.09', '3'][2] == '3')
</code></pre>
<p>Note how <code>i</code> and <code>j</code> have not changed!</p>
<p>You don't need that 3rd loop at all, you already have picked your state and area; just pick out the right value from the table with that, using the <code>area</code> index, plus 1 to map to the right column:</p>
<pre><code>for i in range(len(state)):
    for j in range(len(area)):
        nested_dict[state[i]][area[j]] = float(growth[i + 1][j + 1])
        #                                       instead of k ^^^^^
</code></pre>
<p>Now, using indices single-letter indices makes it hard to follow your code. You should really learn about the <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code> function</a> here, to generate indices:</p>
<pre><code>for row, state_name in enumerate(state, 1):   # starting at row 1
    for col, area_name in enumerate(area, 1): # starting at column 1
        nested_dict[state_name][area_name] = float(growth[row][col])
</code></pre>
<p>By looping <em>directly</em> over <code>state</code>, and using <code>enumerate()</code> to add an index starting at 1, you get both the state name (<code>'NJ'</code>) <em>and</em> the right index into <code>growth</code> (<code>1</code>). The same happens for the <code>area</code> list (so <code>'North'</code> and <code>1</code>, or <code>'South'</code> and <code>2</code>).</p>
<p>However, you already have all your row and column names in the <code>growth</code> matrix, so you can just generate all your dictionaries directly with that:</p>
<pre><code>area_names = growth[0][1:]
nested_dict = {
    state: {area: float(value) for area, value in zip(area_names, row)}
    for state, *row in growth[1:]
}
</code></pre>
<p>The <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code> function</a> puts the area names (found on the first row of <code>growth</code>), together with the values from each column (stored in <code>row</code>, with the first value diverted to <code>state</code>).</p>
<p>Note the <code>for state, *row in ..</code> loop; Python unpacks each list from <code>growth</code> into two variables; the first value is stored in <code>state</code>, and because <code>row</code> is prefixed with <code>*</code>, <em>all remaining values</em> are stored in <code>row</code>:</p>
<pre><code>&gt;&gt;&gt; state, *row = ['NJ', '5.09', '3']
&gt;&gt;&gt; state
'NJ'
&gt;&gt;&gt; row
['5.09', '3']
</code></pre>
<p>That's really all you need:</p>
<pre><code>&gt;&gt;&gt; area_names = growth[0][1:]
&gt;&gt;&gt; nested_dict = {
...     state: {area: float(value) for area, value in zip(area_names, row)}
...     for state, *row in growth[1:]
... }
{'NJ': {'North': 5.09, 'South': 3.0}, 'NY': {'North': 0.0, 'South': 1.0}, 'TX': {'North': 8.0, 'South': 5.54}, 'CA': {'North': 6.0, 'South': 1.0}, 'OH': {'North': 7.77, 'South': 5.0}}
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(_)
{'CA': {'North': 6.0, 'South': 1.0},
 'NJ': {'North': 5.09, 'South': 3.0},
 'NY': {'North': 0.0, 'South': 1.0},
 'OH': {'North': 7.77, 'South': 5.0},
 'TX': {'North': 8.0, 'South': 5.54}}
</code></pre>
<p>Last but not least, if all this data came from a CSV file, perhaps you should use the <a href="https://docs.python.org/3/library/csv.html" rel="nofollow noreferrer"><code>csv</code> module</a> instead:</p>
<pre><code>import csv

nested_dict = {}
with open(somefile, 'r', newline='') as f:
    reader = csv.DictReader(f)
    for row in reader:
        state = row.pop('State')
        nested_dict[state] = {k: float(v) for k, v in row.items()}
</code></pre>
<p>A <code>DictReader()</code> object takes the first row of a CSV file as the column names, and produces a dictionary for each row. If your state column uses quotes around the names, you can even use <code>quoting=csv.QUOTE_NONNUMERIC</code> to have the module automatically convert anything that is not quoted into a <code>float()</code> value for you.</p>
</div>
<div class="post-text" itemprop="text">
<p>Unless I'm missing something important, you do not need any nested loops for this, and you do not need those other two lists, as well. A single (nested) dict comprehension is enough.</p>
<pre><code>result = {st: {"North": float(n), "South": float(s)} 
          for (st, n, s) in growth[1:]}
print(result)
# {'OH': {'North': 7.77, 'South': 5.0}, 'TX': {'North': 8.0, 'South': 5.54}, 
#  'NJ': {'North': 5.09, 'South': 3.0}, 'NY': {'North': 0.0, 'South': 1.0}, 
#  'CA': {'North': 6.0, 'South': 1.0}}
</code></pre>
<p>(This is assuming that the <code>growth</code> list contains each state no more than once and that the first, second and third items are always the state, north, and south values, in that order.)</p>
</div>
<span class="comment-copy">Please provide the <i>expected</i> output, as well as the wrong output that your code produces.</span>
<span class="comment-copy">Also, you assign something to <code>nested_dict[state[i]][area[j]]</code> three times. Only the last assignment will remain. I'm not sure at all what you wanted that to do?</span>
<span class="comment-copy">Hi Martijn, sorry about that. Please see above for an edited version.</span>
<span class="comment-copy">On the question of assignment three times, i am trying to loop through the three indices in that manner (but am not succeeding).</span>
<span class="comment-copy">Thank you very much for the thorough, detailed response. You're absolutely right - I should have used enumerate at the least to properly complete this. Need to become more comfortable with that function, and that certainly helps. Thanks again.</span>
