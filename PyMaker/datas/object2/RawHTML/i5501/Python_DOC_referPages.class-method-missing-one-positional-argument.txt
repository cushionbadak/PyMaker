<div class="post-text" itemprop="text">
<p>I have defined the following parent class:</p>
<pre><code>class Material(object):
    def newMaterial(self,matPhysLaw, stressState,e,nu,alpha,sigY = 0.0,kM = 0.0,mM = 0.0):
        if (matPhysLaw=="elastic"):
            return ElasticMaterial(self,stressState,e,nu,alpha,sigY,kM,mM)
</code></pre>
<p>And the following Child Class:</p>
<pre><code>class ElasticMaterial(Material):
    def __init__(self,StressState,e,nu,alpha,sigY=0.0,kM=0.0,mM=0.0):
        #Material.__init__(self,StressState,e,nu,alpha,sigY=0.0,kM=0.0,mM=0.0)
        self.StressState = StressState
        if self.StressState=='threed':
            self.lv=6  #lv is length of stress and strain vectors
        else:
            self.lv=4
        self.e = e
        self.nu = nu
        self.alpha = alpha
        self.sigY = sigY
        self.kM = kM
        self.mM = mM
</code></pre>
<p>I am trying to create the child class from the base class itself and I am calling the <code>newMaterial()</code> method as below:</p>
<pre><code>m2 = Material.newMaterial('elastic','threed',10e6,0.2,1e7)
</code></pre>
<p>But, I am getting an error as <code>newMaterial() is missing 1 positional argument: alpha</code>.
I want an explanation as to why I am getting this error and how can I rectify it?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you're calling <code>Material.newMaterial(...)</code> directly, <code>self</code> is not bound, so you're missing a mandatory argument. (You're trying to call <code>newMaterial</code> with <code>self='elastic'</code>, etc.)</p>
<p>Either remove the parameter and make it a <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer"><code>@staticmethod</code></a>:</p>
<pre><code>class Material(object):

    @staticmethod
    def newMaterial(matPhysLaw, stressState, e, nu, alpha, sigY=0.0, kM=0.0, mM=0.0):
        if matPhysLaw == "elastic":
            # But here you don't need the `self` parameter for instantiation
            return ElasticMaterial(stressState, e, nu, alpha, sigY, kM, mM)
</code></pre>
<p>Or use a <a href="https://docs.python.org/3/library/functions.html#classmethod" rel="nofollow noreferrer"><code>@classmethod</code></a> decorator if you need to keep a reference to the class:</p>
<pre><code>class Material(object):

    @classmethod
    def newMaterial(cls, matPhysLaw, stressState, e, nu, alpha, sigY=0.0, kM=0.0, mM=0.0):
        if (matPhysLaw=="elastic"):
            return ElasticMaterial(stressState, e, nu, alpha, sigY, kM, mM)
    # Do something with `cls`...
</code></pre>
</div>
<span class="comment-copy">Just do what it tell you to do. Note that there is no <code>self</code> here.</span>
<span class="comment-copy">You seems to have a huge confusion between (analogy from other languages) static methods and non-static methods. Constructors are non-static, the <code>newMaterial</code> method (as in the way you call it) is static.</span>
