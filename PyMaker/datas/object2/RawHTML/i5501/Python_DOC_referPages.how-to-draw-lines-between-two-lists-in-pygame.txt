<div class="post-text" itemprop="text">
<pre><code>import pygame as pg
import sys
pg.init()
screen = pg.display.set_mode((800, 600))
clock = pg.time.Clock()
screenGray = pg.Color('gray80')
RotorFont = pg.font.SysFont("malgun gothic",17)
textColour = pg.Color('navy')
background = pg.Surface(screen.get_size())
background.fill(screenGray)

ACTIONPRINT = False

while True:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()
        if event.type == pg.MOUSEBUTTONDOWN:
            ACTIONPRINT = True

    screen.blit(background,(0,0))
    rotorAA = ['G','N','Z','M','V','B','F','L','Q','R','Y','P','I','C','E','A','D','K','J','W','X','S','H','U','O','T']#2
    rotorAB = ['L','Q','R','Y','D','K','J','W','X','S','H','U','O','P','I','C','F','A','G','N','Z','M','V','B','E','T']#3
    rotorBA = ['Q','W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M']#4
    rotorBB = ['Y','H','Q','V','L','T','C','W','K','P','S','N','X','E','O','M','B','U','G','F','A','J','D','R','Z','I']#5
    rotorCA = ['D','F','P','A','N','E','Y','C','S','G','K','J','M','X','O','V','L','W','Q','H','T','U','B','R','Z','I']#6
    rotorCB = ['Z','I','A','C','T','F','U','Q','N','V','P','B','D','O','L','R','S','X','M','G','H','J','W','E','K','Y']#7

    rotorList = [rotorAA,rotorAB,rotorBA,rotorBB,rotorCA,rotorCB]

    count = 0
    k = 0
    if ACTIONPRINT == True:
    ACTIONPRINT = False
    for i in range(0,len(rotorList)):
        if count % 2 == 0 and count != 0:
                k += 25
        for j in range(0,26):
            a = RotorFont.render(rotorList[i][j],1,textColour)
            background.blit(a,(25 + (i * 25) + k,90+(j * 16)))

            if rotorList[i][j] == letter and i + 2 &lt; 6:
                correspondingLetter = rotorList[i+1][(rotorList[i].index(letter))]
                pg.draw.line(background,black,(25 + (i * 25) + k,90+(j * 16)),(25 + (i + 1 * 25) + 25,90+(rotorList[i+1].index(correspondingLetter) * 16)))
                letter = rotorList[i+2][rotorList[i+1].index(correspondingLetter)]
        count += 1

    pg.display.flip()
    clock.tick(60)
</code></pre>
<p>The above code prints the rotors to the screens, in pairs.</p>
<p>What I would like to happen is for a letter to be entered in an input, and a line to be drawn between the corresponding letters, going from the most right list, to the left list.</p>
<p>However, I have no idea how to even start with this.</p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's the solution. I blit the letters onto the background surface before the main loop starts and then just blit the background every frame. To store the coordinates of the letters, I add the letters to a dictionary with a list as the value and append the coords to this list.</p>
<p>When the user presses a key, I call <code>dict.get</code> to look up the letter in the dict and assign the corresponding coords list to the <code>coords</code> variable which I then pass to <code>pygame.draw.lines</code>. The <code>get</code> method will return <code>None</code> if the key doesn't exist, so that <code>KeyError</code>s are prevented.</p>
<pre><code>import sys
import pygame as pg


pg.init()
screen = pg.display.set_mode((800, 600))
clock = pg.time.Clock()
screenGray = pg.Color('gray80')
RotorFont = pg.font.SysFont('malgun gothic', 17)
textColour = pg.Color('navy')
background = pg.Surface(screen.get_size())
background.fill(screenGray)

# You can create the lists and blit the letters before the main loop starts.
rotorAA = ['G','N','Z','M','V','B','F','L','Q','R','Y','P','I','C','E','A','D','K','J','W','X','S','H','U','O','T']#2
rotorAB = ['L','Q','R','Y','D','K','J','W','X','S','H','U','O','P','I','C','F','A','G','N','Z','M','V','B','E','T']#3
rotorBA = ['Q','W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M']#4
rotorBB = ['Y','H','Q','V','L','T','C','W','K','P','S','N','X','E','O','M','B','U','G','F','A','J','D','R','Z','I']#5
rotorCA = ['D','F','P','A','N','E','Y','C','S','G','K','J','M','X','O','V','L','W','Q','H','T','U','B','R','Z','I']#6
rotorCB = ['Z','I','A','C','T','F','U','Q','N','V','P','B','D','O','L','R','S','X','M','G','H','J','W','E','K','Y']#7
rotorList = [rotorAA,rotorAB,rotorBA,rotorBB,rotorCA,rotorCB]
# This dict will have the letters as the keys and the
# corresponding coordinates as the values.
rotor_dict = {}

k = 0

# You can use `enumerate` if you need the index and the item.
for i, sublist in enumerate(rotorList):
    if i % 2 == 0 and i != 0:
        k += 25
    for j, letter in enumerate(sublist):
        surface = RotorFont.render(letter, 1, textColour)
        x = 25 + (i*25) + k
        y = 90 + (j*16)
        background.blit(surface, (x, y))
        # If the letter isn't in the dict, add a new list with the
        # first coordinates.
        if letter not in rotor_dict:
            rotor_dict[letter] = [(x+4, y+11)]
        # Otherwise append the next coordinates to the list.
        else:
            rotor_dict[letter].append((x+4, y+11))

coords = None  # The list of currently selected coordinates.

while True:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()
        elif event.type == pg.KEYDOWN:  # If the user pressed a key.
            # Use the `get` method which returns `None` by
            # default if the key doesn't exist.
            # `event.unicode` is the letter (string).
            # So if the letter is in the dict, this assigns the coords
            # list in the dict to the `coords` variable.
            coords = rotor_dict.get(event.unicode.upper())

    screen.blit(background, (0, 0))
    # If a key was pressed and a list was assigned to `coords`.
    if coords is not None:
        # Pass the coords list to draw lines.
        pg.draw.lines(screen, (200, 100, 0), False, coords, 2)

    pg.display.flip()
    clock.tick(60)
</code></pre>
<p>I'd also use a <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> instead of the normal dict, but I don't know if you're already familiar with them.</p>
<hr/>
<p>If you want to connect the letters in the way you described in the comment, you need to figure out the indices of the letters in the following lists and use the indices to get the next letters one after the other. </p>
<p>You could then zip the letters and their coords to blit them on the background surface and add the coords list to the <code>rotor_dict</code> again for each letter.</p>
<pre><code>import sys
import pygame as pg


pg.init()
screen = pg.display.set_mode((800, 600))
clock = pg.time.Clock()
screenGray = pg.Color('gray80')
RotorFont = pg.font.SysFont('malgun gothic', 17)
textColour = pg.Color('navy')
background = pg.Surface(screen.get_size())
background.fill(screenGray)

rotorAA = ['G','N','Z','M','V','B','F','L','Q','R','Y','P','I','C','E','A','D','K','J','W','X','S','H','U','O','T']
rotorAB = ['L','Q','R','Y','D','K','J','W','X','S','H','U','O','P','I','C','F','A','G','N','Z','M','V','B','E','T']
rotorBA = ['Q','W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M']
rotorBB = ['Y','H','Q','V','L','T','C','W','K','P','S','N','X','E','O','M','B','U','G','F','A','J','D','R','Z','I']
rotorCA = ['D','F','P','A','N','E','Y','C','S','G','K','J','M','X','O','V','L','W','Q','H','T','U','B','R','Z','I']
rotorCB = ['Z','I','A','C','T','F','U','Q','N','V','P','B','D','O','L','R','S','X','M','G','H','J','W','E','K','Y']
rotor_dict = {}

# Iterate over the letters in the first list.
for i, letter1 in enumerate(rotorAA):
    # Find the indices of the following letters.
    letter2 = rotorAB[i]  # The letter at index i in the AB list.
    j = rotorBA.index(letter2)  # Letter2's index in the BA list.
    letter3 = rotorBB[j]  # Letter at index j in the AB list.
    k = rotorCA.index(letter3)  # Letter3's index in the CA list.
    letter4 = rotorCB[k]  # Letter at index k in the CB list.
    # A list of the connected letters.
    letters = [letter1, letter2, letter2, letter3, letter3, letter4]
    # The coords of the letters in the `letters` list above.
    coords = [(25, 90 + i*16), (50, 90 + i*16),
              (100, 90 + j*16), (125, 90 + j*16),
              (175, 90 + k*16), (200, 90 + k*16),
              ]
    rotor_dict[letter1] = coords
    # Draw the letters. Check out the `zip` function.
    for letter, coord in zip(letters, coords):
        background.blit(RotorFont.render(letter, True, textColour), coord)

coords = None
offset = pg.math.Vector2(5, 11)  # Add this to the coords to center the lines.

while True:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()
        elif event.type == pg.KEYDOWN:
            # Add an offset, so that the lines start at the center points.
            # This is called a list comprehension if you haven't seen this before.
            coords = [coord+offset for coord in rotor_dict.get(event.unicode.upper())]

    screen.blit(background, (0, 0))
    if coords is not None:
        pg.draw.lines(screen, (200, 100, 0), False, coords, 2)

    pg.display.flip()
    clock.tick(60)
</code></pre>
</div>
<span class="comment-copy">Since you haven't started yet, we should only give you hints (always attempt to solve the problem on your own before you post something here). What do you need to draw lines between the letters? The coordinates of the letters. You already have them in your nested for loops, but you need to group and associate them with a letter (a dictionary would be suited for this task). If you had such a dictionary, what could you do when the user enters a letter?</span>
<span class="comment-copy"><code>rotorAA.index('A')</code> and <code>rotorAB.index('A')</code> gives you positions of the same letter in two lists so you have to convert positions to <code>x,y</code> and draw line.</span>
<span class="comment-copy">BTW: you can create <code>rotorList</code> before <code>while True</code>, and you can <code>screen.fill(screenGray)</code> instead of <code>screen.blit(background,(0,0))</code></span>
<span class="comment-copy">I have only just started but I will see how far I get. Thanks for the hints</span>
<span class="comment-copy">Cool, happy coding! BTW, it would really be a good idea to move the rotor list definitions and the part where you draw the letters on the background surface above the while loop to improve the performance (it probably won't matter here, though). Also, if you keep drawing the text surfaces again and again on the same surface the quality will get worse every frame.</span>
<span class="comment-copy">This is really good and what I was looking for, but say instead I wanted the lines to go from the left list letter, to the same position in the right list. Then the line goes from whatever the letter was in the right list, to the same letter in the next pair. So, in this example, if the letter G is pressed, its corresponding letter in the pair would be L, in the pair <code>rotorAA</code> and <code>rotorAB</code>. The line is then drawn from the letter L in the first pair, to the letter L in the next pair of lists, <code>rotorBA</code> and <code>rotorBB</code>. Which bit would need to be altered?</span>
<span class="comment-copy">I've added another example. There could be more elegant solutions, but I'm a bit exhausted and not sure if I can find a better one atm.</span>
<span class="comment-copy">This is great thanks. I was looking through it and tried to add another pair of rotors, in the same format as you have done it. But when I ran it, it only displayed one of the lists, and drew the line to the wrong letter. Is there something that restricts it to only three rotors, as I can't see anything obvious. Thanks again</span>
<span class="comment-copy">Yes, the solution works only with six lists. If the number of lists is variable, you need to figure out a more general solution.</span>
