<div class="post-text" itemprop="text">
<p>I have spent considerable time on my below code but I just can't get it to work and I'm hoping someone can offer me some advice.</p>
<pre><code>#Example Code
import os, datetime
source = "U://Working_Files"
nameList=["U://Working_Files".format(x) for x in ['Property','Ownership','Sold','Lease']]
def Rename_and_move_files():
    for name in nameList:
        path=os.path.expanduser(os.path.join("~",name))
        dirList=os.listdir(path)
        for filename in dirList:
            filePath=os.path.join(path,filename)
            modified_time=os.path.getmtime(name)
            modified_date=datetime.date.fromtimestamp(modified_time)
            correct_format=modified_date.strftime('%Y%m%d')
            if os.path.isfile(filePath):
                new_name = correct_format + '_' + filename
                destPath=os.path.join(path, "superseded", new_name)
                print destPath
                os.rename(filePath, new_name)



Rename_and_move_files()
</code></pre>
<p>In each folder (<code>Property</code> for example) I have a <code>superseded</code> folder. My end goal is to rename each file that is in each directory to prefix the date (e.g. <code>2018010_Property_Export.dfb</code>) and then move it to the <code>superseded</code> folder.</p>
<pre><code>Property-&gt;
    Property_Export.dfb
    Property_Export.xls
    Property_Export.shp
    Supserdeded (This is a folder)
</code></pre>
<p>I am not sure how to rename each file in each folder and then move it to the <code>superseded</code> folder. At the moment I think I'm trying to rename the filepath instead of the individual file names.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>"U://Working_Files".format(x)</code> results in <code>"U://Working_Files"</code>, because there is no placeholder (<code>{}</code>) in the string. You should really use <a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow noreferrer"><code>os.path.join()</code></a> to handle path building. Also, you should not double the <code>/</code> forward slash (you probably confused that with the <code>\\</code> being required in a Python string literal to produce a single backslash):</p>
<pre><code>import os.path

source = "U:/Working_Files"
nameList = [os.path.join(source, name) for name in ['Property', 'Ownership', 'Sold', 'Lease']]
</code></pre>
<p>This is really the only logic mistake you have made; the rest of the code does work as designed. That said, there are a few things that can be improved.</p>
<p>Personally, I'd leave the work of putting the source directory name and the names of the subdirectories together, to the function loop. That saves you an extra loop when just setting up your configuration.</p>
<pre><code>source = "U:/Working_Files"
nameList = ['Property', 'Ownership', 'Sold', 'Lease']
</code></pre>
<p>I'd not prefix directories with <code>~</code>; leave that to whomever configures the <code>source</code> directory; they can specify <code>~/some_directory</code> or <code>~someuser/some_directory</code> as a path explicitly. The function should take <em>arguments</em>, not use globals, anyway. Besides, prefixing your directories with <code>~</code> would disallow the use of <code>~some_other_account_name</code> at the start of such a path.</p>
<p>I'd skip over anything that isn't a file early; no need to get the modified date for a directory, right?</p>
<p>The following will move any non-directory name out of the directory, into the subdirectory named <code>superseded</code>:</p>
<pre><code>import os
import os.path
import datetime

def rename_and_move_files(source, subdirs, destination_subdir):
    """Archive files from all subdirs of source to destination_subdir

    subdirs is taken as a list of directory names in the source path, and
    destination_subdir is the name of a directory one level deeper. All files
    in the subdirectories are moved to the destination_subdir nested directory,
    renamed with their last modification date as a YYYYMMDD_ prefix.

    For example, rename_and_move_files('C:\', ['foo', 'bar'], 'backup') moves
    all files in the C:\foo to C:\foo\backup, and all files in C:\bar to 
    C:\bar\backup, with each file prefixed with the last modification date.
    A file named spam_ham.ext, last modified on 2018-01-10 is moved to
    backup\20180110_spam_ham.ext.

    source is made absolute, with ~ expansion applied.

    Returns a dictionary mapping old filenames to their new locations, using
    absolute paths.

    """
    # support relative paths and paths starting with ~
    source = os.path.abspath(os.path.expanduser(source))

    renamed = {}

    for name in subdirs:
        subdir = os.path.join(source, name)
        destination_dir = os.path.join(subdir, destination_subdir)
        for filename in os.listdir(destination_dir):
            path = os.path.join(subdir, filename)

            if not os.path.isfile(path):
                # not a file, skip to the next iteration
                continue

            modified_timestamp = os.path.getmtime(path)
            modified_date = datetime.date.fromtimestamp(modified_timestamp)
            new_name = '{:%Y%m%d}_{}'.format(modified_date, filename)
            destination = os.path.join(destination_dir, new_name)
            os.rename(path, destination)
            renamed[path] = destination

    return renamed

source = "U:/Working_Files"
name_list = ['Property', 'Ownership', 'Sold', 'Lease']

renamed = rename_and_move_files(source, name_list, 'superseded')
for old, new in sorted(renamed.items()):
    print '{} -&gt; {}'.format(old, new)
</code></pre>
<p>The above also tries to minimise work. You only need to resolve the <code>source</code> path once, not for each name in <code>subdirs</code>. <code>datetime</code> objects support <code>str.format()</code> formatting directly, so we can form the new filename in one step from the modified timestamp and the old name. The <code>os.path.abspath()</code> cleans out errors like the <code>//</code> double slash as well, making it more robust.</p>
<p>Rather than print each path in the loop, the function returns a mapping of files that have been renamed, so the caller can process that further as needed.</p>
</div>
<div class="post-text" itemprop="text">
<p>See if this below code will work for you. This code will go through all the working folders, find only the files, rename and move those renamed files to the superseded folder </p>
<pre><code>import os
import shutil

working_folders = [f'C:\working_folders\{x}' for x in ['Property','Ownership','Sold','Lease']]

for wf in working_folders:
    for f in os.listdir(wf):
        if os.path.isfile(os.path.join(wf, f)):
            os.rename(os.path.join(wf, f), os.path.join(wf, f'2018010_Property_Export.dfb_{f}'))
            shutil.move(os.path.join(wf, f'2018010_Property_Export.dfb_{f}'), os.path.join(wf, 'superseded', f'2018010_Property_Export.dfb_{f}'))
</code></pre>
</div>
<span class="comment-copy">Your question is a little confusing because there is no difference between "renaming" a file and "moving" a file.</span>
<span class="comment-copy">@larsks: I don't think it is all that confusing. Renaming the parent path vs. the file name itself is often seen as two separate actions. I'm fine with that.</span>
<span class="comment-copy"><code>os.path.expanduser</code> results in the wrong thing if you use <code>os.path.join</code> inside. On my machine <code>os.path.expanduser('~dan')</code> gives <code>/home/dan</code> where <code>os.path.expanduser(os.path.join('~', 'dan'))</code> gives <code>/home/dan/dan</code> (as long as I'm logged in as <code>dan</code>).</span>
<span class="comment-copy">@DanielAbercrombie: I'm not using <code>os.path.join('~', ..)</code> in my code, am I? :-)</span>
<span class="comment-copy">Oh whoops sorry, I should have only put that comment on the original post, since @Dunuts is now doing that. But now I see that he just didn't read your post carefully. (And neither did I.)</span>
<span class="comment-copy">@DanielAbercrombie: I do see that the OP did this, but for absolute paths, <code>os.path.join()</code> will ignore the prefix anyway; <code>os.path.join('~', '/absolute/path')</code> produces <code>'/absolute/path'</code>. But for paths that already start with <code>~</code>, it absolutely does the wrong thing.</span>
<span class="comment-copy">@vaultah: Indeed. Corrected.</span>
<span class="comment-copy">This moves <code>&lt;dir&gt;/Property_Export.dfb</code> to <code>&lt;dir&gt;/superseded/2018010_Property_Export.dfb_Property_Export.dfb</code>, and ignores the modified date.</span>
<span class="comment-copy">And <code>os.rename()</code> is <i>enough to move the file</i>, why use <code>shutil.move()</code> too? <code>shutil.move</code> is useful to move a <i>hierarchy of files</i>, not for individual files.</span>
<span class="comment-copy">Im sure os.rename is enough and it can be used instead of os.rename, i happened to use os.shutil lot and used it. I'm just copying the files, more date checks can be implemented using the above code</span>
<span class="comment-copy">is shutil.move the reason for the downvote? it can be modified to use os.rename</span>
<span class="comment-copy">Using <code>shutil.move</code> is not the only issue with your code, I also pointed out you are renaming the files incorrectly; you are ignoring the file modified time, and have inserted an arbitary filename. You do need to read the question more carefully, you have missed a few important details.</span>
