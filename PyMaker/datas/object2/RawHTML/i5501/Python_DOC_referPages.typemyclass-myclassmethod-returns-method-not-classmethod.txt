<div class="post-text" itemprop="text">
<p>I just stumbled over this strange behavior when the type of a method changes during subclassing:</p>
<pre><code>class A:
    def f(self, x):
        return x**2

class B(A):
    @classmethod
    def f(cls, x):            
        return x**2
</code></pre>
<p>If I now ask for the type of <code>B.f</code>, I'll get the (supposedly) wrong answer:</p>
<pre><code>In [37]: type(B.f)
Out[37]: method
</code></pre>
<p>Whereas this works as expected:</p>
<pre><code>In [39]: type(B.__dict__["f"])
Out[39]: classmethod
</code></pre>
<p>(Seen in Python 3.4 and 3.6.)</p>
<p>Is this just a bug or is there a specific reason for this?</p>
<p>What's the difference between the attribute <code>f</code> and the <code>.__dict__["f"]</code> item? I thought they were the same.</p>
<p>In a testing suite, I was trying to support both types of methods inside a class to be tested. To be able to do that, I need to know the type in order to pass the correct number of arguments. If it's a normal method (i.e. <code>self</code> is the first argument), I'd just pass <code>None</code> explicitly, which by design shouldn't be used inside the method anyway, since it's not instance-dependent.</p>
<p>Maybe there's a better way to do this, like duck typing the call to the method. But there might be cases where this is not so easy to do, like if the method had <code>*args</code> and <code>**kwargs</code>... Therefore I went with the explicit type check, but got stuck at this point.</p>
</div>
<div class="post-text" itemprop="text">
<p>No, this is not a bug, this is normal behaviour. A <code>classmethod</code> produces a <strong>bound method</strong> when accessed on a class. That's exactly the point of a <code>classmethod</code>, to bind a function to the class you access it on or the class of an instance you access it on.</p>
<p>Like function and <code>property</code> objects, <code>classmethod</code> is a <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer"><em>descriptor object</em></a>, it implements a <code>__get__</code> method. Accessing attributes on an instance or a class is delegated to the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__" rel="nofollow noreferrer"><code>__getattribute__</code> method</a>, and the default implementation of that hook will not just return what it found in <code>object.__dict__[attributename]</code>; it  will also <em>bind</em> descriptors, by calling the <a href="https://docs.python.org/3/reference/datamodel.html#object.__get__" rel="nofollow noreferrer"><code>descriptor.__get__()</code> method</a>. This is a hugely important aspect of Python, it is this mechanism that makes methods and attributes and loads of other things work.</p>
<p><code>classmethod</code> objects, when bound by the descriptor protocol, return a method object. Method objects are wrappers that record the object bound to, and the function to call when they are called; calling a method really calls the underlying method with the bound object as first argument:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     pass
...
&gt;&gt;&gt; def bar(*args): print(args)
...
&gt;&gt;&gt; classmethod(bar).__get__(None, Foo)  # decorate with classmethod and bind
&lt;bound method bar of &lt;class '__main__.Foo'&gt;&gt;
&gt;&gt;&gt; method = classmethod(bar).__get__(None, Foo)
&gt;&gt;&gt; method.__self__
&lt;class '__main__.Foo'&gt;
&gt;&gt;&gt; method.__func__
&lt;function bar at 0x1056f0e18&gt;
&gt;&gt;&gt; method()
(&lt;class '__main__.Foo'&gt;,)
&gt;&gt;&gt; method('additional arguments')
(&lt;class '__main__.Foo'&gt;, 'additional arguments')
</code></pre>
<p>So the method object returned for a <code>classmethod</code> object references the class (the second argument to <code>__get__</code>, the <em>owner</em>), and the original function. If you use a class method on an instance, the first argument is still ignored:</p>
<pre><code>&gt;&gt;&gt; classmethod(bar).__get__(Foo(), Foo).__self__  # called on an instance
&lt;class '__main__.Foo'&gt;
</code></pre>
<p>Functions, on the other hand, want to bind <em>only</em> to instances; so if the first argument to <code>__get__</code> is set to <code>None</code>, they simply return <code>self</code>:</p>
<pre><code>&gt;&gt;&gt; bar.__get__(None, Foo)    # access on a class
&lt;function bar at 0x1056f0e18&gt;
&gt;&gt;&gt; bar.__get__(Foo(), Foo)   # access on an instance
&lt;bound method bar of &lt;__main__.Foo object at 0x105833a90&gt;&gt;
&gt;&gt;&gt; bar.__get__(Foo(), Foo).__self__
&lt;__main__.Foo object at 0x105833160&gt;
</code></pre>
<p>If accessing <code>ClassObject.classmethod_object</code> would return the <code>classmethod</code> object itself, like a <code>function</code> object would, then you could never actually <em>use</em> the class method on a class. That'd be rather pointless.</p>
<p>So no, <code>object.attribute</code> is <em>not always</em> the same thing as <code>object.__dict__['attribute']</code>. If <code>object.__dict__['attribute']</code> supports the descriptor protocol, it'll be invoked.</p>
</div>
<span class="comment-copy">Thanks for the great explanation, I learned something new. Updated my post with a conclusion.</span>
<span class="comment-copy">@Jeronimo: glad I was able to help! I've rolled back your addendum, however, as it's not really part of the question future visitors will look for. I'm happy to provide extra links in my answer to material if that helps.</span>
