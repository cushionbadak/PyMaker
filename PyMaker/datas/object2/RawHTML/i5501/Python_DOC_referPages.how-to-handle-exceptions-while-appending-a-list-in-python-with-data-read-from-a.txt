<div class="post-text" itemprop="text">
<p>I'm new to Python and I'm having trouble with a very specific problem. I need to read data from various JSON files that have a similar structure. The procedure is: load the JSON file into a dictionary, save the relevant data from the dict in a list in order to insert it into a MySQL database. The problem is: some fields of the JSON files don't necessarily appear in EVERY JSON file. Some fields are missing in some of the files, and sometimes even inside the same file, as in:</p>
<pre><code>  "actions": [
    {
      "acted_at": "2014-12-10", 
      "action_code": "Intro-H", 
      "references": [], 
      "text": "Introduced in House", 
      "type": "action"
    }, 
    {
      "acted_at": "2014-12-10", 
      "action_code": "H11100", 
      "committees": [
        "HSWM"
      ], 
      "references": [], 
      "status": "REFERRED", 
      "text": "Referred to the House Committee on Ways and Means.", 
      "type": "referral"
    }, 
    {
      "acted_at": "2014-12-12", 
      "action_code": "B00100", 
      "references": [
        {
          "reference": "CR E1800-1801", 
          "type": null
        }
      ], 
      "text": "Sponsor introductory remarks on measure.", 
      "type": "action"
    }
  ]
</code></pre>
<p>Here is a code snippet to illustrate what the relevant (to the question) part of my program does:</p>
<pre><code>hr_list = []
with open("data.json") as json_data:
    d = json.load(json_data)
    actions_list.append((
    d["actions"][j]["acted_at"],
    d["actions"][j]["action_code"],
    d["actions"][j]["status"],
    d["actions"][j]["text"],
    d["actions"][j]["type"]))
</code></pre>
<p>As you can see, there is some consistency to the file. The problem is: whenever one of the fields is not present, I receive a <code>KeyError</code> stating that there is no such data to append to the list. What I need to do is a way to handle this exception, like add some type of "null" data as default, so it doesn't return any errors (what would be null anyway when added to the database).</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, I'd move code out of the <code>with</code> block. </p>
<pre><code>actions_list = []
with open("data.json") as json_data:
    d = json.load(json_data)

actions_list.append((
d["actions"][j]["acted_at"],
d["actions"][j]["action_code"],
d["actions"][j]["status"],
d["actions"][j]["text"],
d["actions"][j]["type"]))
</code></pre>
<p>Secondly, if I HAD to do what you are asking, I'd use a function to get the value optionally / return None.</p>
<pre><code>actions_list = []
with open("data.json") as json_data:
    d = json.load(json_data)

def f(d, j, k):
    try:
        return d["actions"][j][k] 
    except:
        return None

actions_list.append((
f(j, "acted_at"),
f(j, "action_code"),
f(j, "status"),
f(j, "text")))
</code></pre>
<p>Alternatively, you can check the keys of all the data, as a validation step, and then retrieve values.</p>
<p>Additionally, you can use the <code>get</code> function on a <code>dict</code> to get the <code>value</code> of <code>key</code> if it exists, and if not return some default value.</p>
<pre><code>d.get(k, "default_return_value")
</code></pre>
<p>If you want to safely return <code>None</code> just for the deepest nest, you can do the following</p>
<pre><code>d["actions"][j].get("acted_at", None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get()</code></a> to specify a default value like:</p>
<pre><code>with open("data.json") as json_data:
    d = json.load(json_data)
    actions_list.append((
        d["actions"][j].get("acted_at", ''),
        d["actions"][j].get("action_code", ''),
        d["actions"][j].get("status", ''),
        d["actions"][j].get("text", ''),
        d["actions"][j].get("type", '')
    ))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are mentioning it yourself. Using try-catch logic, you can catch specific errors and handle them without breaking the execution of the program, thereby filling in the empty data points.</p>
<p>So with your snippet, surround the append method with a <code>try</code>, then add an <code>except</code> afterwards. Here is the python documentation on try-catch logic. <a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/errors.html#handling-exceptions</a></p>
<pre><code>hr_list = []
with open("data.json") as json_data:
    d = json.load(json_data)
    dict_keys = ["acted_at","action_code","status","text","type"]
    for d_key in dict_keys:
        try:
            actions_list.append(d["actions"][j][d_key])
        except KeyError as e:
            cause = e.args[0]
            actions_list.append((d["actions"][j][cause] = NULL))
</code></pre>
<p>The exception you mention, keyerror, is documented <a href="https://docs.python.org/2/library/exceptions.html#exceptions.KeyError" rel="nofollow noreferrer">here</a>. Then for a <code>KeyError</code> the first argument is the key that raised the exception. With that, you have the offending key stored in <code>cause</code>.</p>
<p>With that, the missing values should be filled in. </p>
</div>
<span class="comment-copy">I really liked the the "d.get" method. I'm working with thousands of files. I tested all the solutions you described and ended up using the d.get one. But I'd like to know: do you know which would be the fastest method between the ones you listed?</span>
<span class="comment-copy">I'm assuming <code>d.get</code> is going to be faster than using a <code>try: ... except: ...</code> block. I'd have to check using a sample program / using <code>dis</code> to be sure. My initial hypothesis is that direct dictionary access is going up faster than using a function which will be faster than raising an exception.</span>
<span class="comment-copy">If this helped you, please accept this answer. Otherwise let me know what is wrong.</span>
<span class="comment-copy">Your solution does solve my problem, but i ended up using the d.get method as i think its simpler and cleaner.</span>
