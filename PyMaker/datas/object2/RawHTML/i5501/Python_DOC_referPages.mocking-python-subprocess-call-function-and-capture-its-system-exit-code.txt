<div class="post-text" itemprop="text">
<p>Writing test cases to handle successful and failed python subprocess calls, I need to capture <code>subprocess.call</code> returning code.</p>
<p>Using python <code>unittest.mock module</code>, is it possible to patch the <code>subprocess.call</code> function and capture its real system exit code?</p>
<p>Consider an external library with the following code:</p>
<pre><code>## &lt;somemodule.py&gt; file

import subprocess


def run_hook(cmd):
    # ...
    subprocess.call(cmd, shell=True)
    sum_one = 1+1
    return sum_one
</code></pre>
<p>I can't modify the function <code>run_hook</code>. It is not part of my code. But, the fact is that <code>subprocess.call</code> is being called among other statements.</p>
<p>Here we have a snippet of code returning a forced system exit error code 1:</p>
<pre><code>## &lt;somemodule.py&gt; tests file

import subprocess
from somemodule import run_hook

try:
    from unittest.mock import patch
except ImportError:
    from mock import patch


@patch("subprocess.call", side_effect=subprocess.call)
def test_run_hook_systemexit_not_0(call_mock):
    python_exec = sys.executable
    cmd_parts = [python_exec, "-c", "'exit(1)'"] # Forced error code 1
    cmd = " ".join(cmd_parts)
    run_hook(cmd)
    call_mock.assert_called_once_with(cmd, shell=True)

    # I need to change the following assertion to
    # catch real return code "1"

    assert "1" == call_mock.return_value(), \
           "Forced system exit(1) should return 1. Just for example purpose"
</code></pre>
<p>How can I improve this test to capture the expected real value for any <code>subprocess.call</code> return code?</p>
<p>For compatibility purposes, new <code>subprocess.run</code> (3.5+) can't be used. This library is still broadly used by python 2.7+ environments.</p>
</div>
<div class="post-text" itemprop="text">
<p>About <a href="https://docs.python.org/3/library/subprocess.html#subprocess.call" rel="nofollow noreferrer">subprocess.call</a>, the documentation says:</p>
<blockquote>
<p>Run the command described by <em>args</em>. Wait for command to complete, then return the <em>returncode</em> attribute.</p>
</blockquote>
<p>All you need to do is to modify your <code>run_hook</code> function and return the exit code:</p>
<pre><code>def run_hook(cmd):
    # ...
    return subprocess.call(cmd, shell=True)
</code></pre>
<p>This will simply your test code.</p>
<pre><code>def test_run_hook_systemexit_not_0():
    python_exec = sys.executable
    args = [python_exec, "-c", "'exit(1)'"]
    assert run_hook(args) == 1
</code></pre>
<p>My advice: use <code>subprocess.run</code> instead </p>
<p><strong>Edit</strong></p>
<p>If you want to check the exit code of <code>subprocess.call</code> you need to patch it with your own version, like this:</p>
<pre><code>import subprocess

_original_call = subprocess.call

def assert_call(*args, **kwargs):
    assert _original_call(*args, **kwargs) == 0
</code></pre>
<p>Then, you use <code>assert_call</code> as a side effect function for your patch:</p>
<pre><code>from  unittest.mock import patch


@patch('subprocess.call', side_effect=assert_call)
def test(call):
    python_exec = sys.executable
    args = [python_exec, "-c", "'exit(1)'"]
    run_hook(args)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A wrapper around <code>subprocess.call</code> can handle the assertion verification.</p>
<p>In this case, I declare this wrapper as the <code>side_effect</code> argument in <code>@patch</code> definition.</p>
<p>In this case, the following implementation worked well.</p>
<pre><code>import sys
import unittest


try:
    from unittest.mock import patch
except ImportError:
    from mock import patch


def subprocess_call_assert_wrap(expected, message=None):
    from subprocess import call as _subcall
    def _wrapped(*args, **kwargs):
        if message:
            assert expected == _subcall(*args, **kwargs), message
        else:
            assert expected == _subcall(*args, **kwargs)
    return _wrapped


class TestCallIsBeingCalled(unittest.TestCase):

    @patch("subprocess.call", side_effect=subprocess_call_assert_wrap(expected=0))
    def test_run_hook_systemexit_0(self, call_mock):
        python_exec = sys.executable
        cmd_parts = [python_exec, "-c", "'exit(0)'"]
        cmd = " ".join(cmd_parts)
        run_hook(cmd)
        call_mock.assert_called_once_with(cmd, shell=True)

    @patch("subprocess.call", side_effect=subprocess_call_assert_wrap(expected=1))
    def test_run_hook_systemexit_not_0(self, call_mock):
        python_exec = sys.executable
        cmd_parts = [python_exec, "-c", "'exit(1)'"]
        cmd = " ".join(cmd_parts)
        run_hook(cmd)
        call_mock.assert_called_once_with(cmd, shell=True)
</code></pre>
<p>After some tests with taking this approach, it seems possible to use for a more general purpose calls, like:</p>
<pre><code>def assert_wrapper(expected, callable, message=None):
    def _wrapped(*args, **kwargs):
        if message:
            assert expected == callable(*args, **kwargs), message
        else:
            assert expected == callable(*args, **kwargs)
    return _wrapped
</code></pre>
<p>This is not the best approach, but it seems reasonable.</p>
<p>There is some best known lib with similar behavior that I can use in this project?</p>
</div>
<span class="comment-copy">Actually, what do you want to test? Do you want to test that <code>exit(1)</code> will return 1. It sounds weird.</span>
<span class="comment-copy">You can use <a href="https://docs.python.org/3/library/sys.html#sys.executable" rel="nofollow noreferrer">sys.executable</a> to get the Python executable instead of searching it in the paths.</span>
<span class="comment-copy">@LaurentLAPORTE, I use it just for demonstration purposes. The complete test should cover how program is proceeding when some error occurs. But, before, I need to understand how catch system exit code.</span>
<span class="comment-copy">@LaurentLAPORTE Thanks! I will update this call for <code>sys.executable</code></span>
<span class="comment-copy">Yes, I thought about this solution. But, I am developing under an environment where it is not possible. The run_hook is an external function.  I am looking for an approach to capture and store the return_value into the mocked call, without modify the run_hook function.</span>
<span class="comment-copy">I updated the question to separate run_hook from my test code</span>
<span class="comment-copy">For compatibility purposes, I can't use subprocess.run. This library is still used by python 2.7+ environments. (I will add all questions you are bringing to light to my original question. I appreciate your helpful insights)</span>
