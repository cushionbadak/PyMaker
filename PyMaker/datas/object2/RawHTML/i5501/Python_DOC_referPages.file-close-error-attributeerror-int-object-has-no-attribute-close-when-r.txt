<div class="post-text" itemprop="text">
<p>Going through Zed Shaw's book Exercise 17 [about copying one file to another] where he reduces his these two lines of code </p>
<pre><code>in_file = open(from_file)
indata = in_file.read()
</code></pre>
<p>into one as :</p>
<pre><code>indata = open(from_file).read()
</code></pre>
<p>there's also a piece of code where he writes </p>
<pre><code>out_file = open(to_file, 'w')
out_file.write(indata)
</code></pre>
<p>So I was reducing this into one line same as above :</p>
<pre><code>out_file = open(to_file, 'w').write(indata)
</code></pre>
<p>This seems to work fine but when I close the <code>out_file</code> there's an error as:</p>
<pre><code>Traceback (most recent call last):
  File "filesCopy.py", line 27, in &lt;module&gt;
    out_file.close()
AttributeError: 'int' object has no attribute 'close'
</code></pre>
<p>I am unable to grasp what is going on and how <code>close()</code> is working here?</p>
</div>
<div class="post-text" itemprop="text">
<p>The two are <strong>not</strong> equivalent. If you write <code>out_file = open(to_file, 'w').write(indata)</code>, you have implicitly written:</p>
<pre><code># equivalent to second code sample
temp = open(to_file, 'w')
out_file = temp.write(indata)
</code></pre>
<p>Now as we can see in the <a href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="nofollow noreferrer">documentation</a> of <code>write()</code>:</p>
<blockquote>
<p><code>f.write(string)</code> writes the contents of string to the file, <strong>returning the number of characters written</strong>.</p>
</blockquote>
<p>So it returns an integer. So in your second sample <code>out_file</code> is <em>not</em> a file handler, but an integer. Further in the code, you somewhere aim to close the <code>out_file</code> file handler with <code>out_file.close()</code>. But since <code>out_file</code> is no longer a file handler, it thus makes no sense to call close on this.</p>
<p>Nevertheless, by using a context, you do no longer need to perform a <code>.close()</code> yourself, so more elegantly is probably:</p>
<pre><code>with open(to_file, 'w') as out_file:
    out_file.write(indata)
</code></pre>
<p>The reduction in the book itself is allowed (well at least semantically, it is better to use context manager), since the author probably never closes the file handle explicitly.</p>
</div>
<div class="post-text" itemprop="text">
<p>Following is usually better approach, both for reading &amp; writing: </p>
<pre><code>with open("myfile.txt", "w") as f:
    # do something with f
</code></pre>
<p>There is no need to close f with this code. </p>
<p>With code <code>val = open(to_file, 'w').write(indata)</code> "val" will be return value of <code>write</code> function, not <code>open</code> function. </p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>write</code> method <strong>returns the number of characters written in your file</strong> which is an integer not a file object and therefore doesn't have a <code>close</code> method.</p>
<pre><code>In [6]: a = open('test', 'w')          
In [7]: t = a.write('ssss')
In [8]: t
Out[8]: 4
</code></pre>
<p>Also, calling the I/O methods directly on <code>open()</code> is recommended only if you don't want to have any further interaction with the file. Besides, the most proper way to deal with file objects is to use a <code>with</code> statement that closes the file automatically at the end of the block and there's no need to call the <code>close()</code> manually.</p>
<pre><code>with open('filename', 'w') as f:
    # do something
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>read()</code> function reads the file and then returns the file content, so when you assign <code>indata</code> to <code>read()</code> it's assigning the returned file content.  The difference is that the <code>write()</code> function returns the number of characters written, therefore your <code>outdata</code> is now an <code>int</code> object.</p>
<p>Read more about it here: <a href="https://docs.python.org/3.6/tutorial/inputoutput.html" rel="nofollow noreferrer">https://docs.python.org/3.6/tutorial/inputoutput.html</a></p>
<p>Therefore, you cannot combine the <code>write()</code> function into one line and expect to have a referenced file object to close after, and that's disastrous.</p>
<p>The preferred way is to use the <code>with</code> block.  Refer to @Willem's answer for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>The author "Zed" has already clarified when you will read the page 64 from that book. Please read below:</p>
<blockquote>
<p><strong>When I try to make this script shorter, I get an error when I close the files at the end.</strong> 
  You probably did something like this, indata = open(from_file).read(), which means you donâ€™t need to then do in_file.close() when you reach the end of the script. It should already be closed by Python once that one line runs.</p>
</blockquote>
</div>
<span class="comment-copy"><code>.write(..)</code> does <i>not</i> return a fil handler, but an integer.</span>
<span class="comment-copy">This sums it up. Thank you so much :D</span>
<span class="comment-copy">So is there some precedence involved in these functions? Like in your example <code>val</code> is assigned return value of <code>write()</code> and not <code>open()</code></span>
<span class="comment-copy">It will be the return value of last performed function.</span>
<span class="comment-copy">oh! That makes it clear, thanks again @rnso :D</span>
<span class="comment-copy">But explicitly writing:   <code>out_file = open(to_file, 'w')</code> <code>out_file.write(indata)</code> <code>out_file.close()</code>  works. Why ?</span>
<span class="comment-copy">@f__society Because that's the way it should be. The fact that you can close your file manually is a great feature that can be used when you want to keep your file object for a longer time and use it in multiple places (withing a module) and/or within other objects. In that case you won't loose the reference after doing some operations. like what happens in <code>with</code> statement.</span>
