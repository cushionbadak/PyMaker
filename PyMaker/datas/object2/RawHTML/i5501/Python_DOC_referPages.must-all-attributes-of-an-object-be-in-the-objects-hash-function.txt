<div class="post-text" itemprop="text">
<p>Using python 3.6</p>
<p>I have read the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs</a>.</p>
<p>When implementing <code>__hash__</code> <strong>Must all attributes of an object be in the objects __hash__ function?</strong></p>
<p>So would this example be ok?</p>
<pre><code>class Foo(object):

    def __init__(self, value):
        self.value = value
        self.not_important = 'irrelevant'

    def __hash__(self):
        return hash((self.value,))

    def __eq__(self, other):
        if self.value == other.value:
            return True
        return False
</code></pre>
<p><code>foo.not_important</code> is modified while being a key in a dictionary</p>
<pre><code>&gt;&gt;&gt; foo = Foo(1)
&gt;&gt;&gt; d = {foo:'foo is in d'}
&gt;&gt;&gt; foo.not_important = 'something else'
&gt;&gt;&gt; d[foo]
'foo is in d'
&gt;&gt;&gt; bar = Foo(1)
&gt;&gt;&gt; foo == bar
True
&gt;&gt;&gt; d[bar]
'foo is in d'
</code></pre>
<p>But <code>foo.not_important</code> isn't used by it's <code>__hash__</code> implementation. Is this perfectly okay? Or can this go horribly wrong? </p>
</div>
<div class="post-text" itemprop="text">
<p>Answering the literal question, it's okay to leave out attributes not considered by <code>__eq__</code>. In fact, you can leave out <em>all</em> the attributes and just <code>return 0</code>, though it'll kill your dict efficiency, so don't do that.</p>
<p>Answering the implied question, it's okay to mutate an object while it's a dict key, as long as you don't mutate it in ways that affect <code>__eq__</code> or <code>__hash__</code>. For example, the default <code>__hash__</code> implementation doesn't consider any attributes of the object it's hashing at all - it's based on object identity. With the default <code>__hash__</code> and <code>__eq__</code>, an object is only equal to itself, and you can mutate such an object all you want while it's a dict key without breaking dicts.</p>
</div>
<div class="post-text" itemprop="text">
<p>No. As <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">the documentation</a> states:</p>
<blockquote>
<p><code>object.__hash__(self)</code></p>
<p>Called by built-in function <code>hash()</code> and for operations on members of hashed collections including <code>set</code>, <code>frozenset</code>, and <code>dict</code>. <code>__hash__()</code> should return an integer. <strong>The only required property is that objects which compare equal have the same hash value</strong>; it is advised to mix together the hash values of the components of the object that also play a part in comparison of objects by packing them into a tuple and hashing the tuple.</p>
</blockquote>
<p>In your example, both <code>__eq__</code> and <code>__hash__</code> only use <code>self.value</code>. This satisfies the only requirement.</p>
</div>
<span class="comment-copy">You should include in <code>__hash__</code> all data that you consider part of the object's identity, such that two object's would be equivalent if they had the same values for these attributes. If an attribute isn't important to the object's identity, it can be left out of the hash. And provide a corresponding <code>__eq__</code> method.</span>
<span class="comment-copy">Right, so <code>foo.not_important</code> is not part of <code>Foo</code>'s identity so it can be left out?</span>
<span class="comment-copy">"identity" is a misleading choice of word, since it usually refers to "which object is this", and different objects can't have the same identity under the usual usage of the word. It's okay to leave attributes out of <code>__hash__</code> if they're not considered by <code>__eq__</code> - in fact, it's okay to leave out any attributes you want. <code>return 0</code> is a valid (but terrible) <code>__hash__</code> for any hashable class.</span>
<span class="comment-copy">Awesome, thanks for the info. I have heard "mutable objects can't be used for a key in a dict" so many times that I thought any mutation of the object could be bad, regardless of the <code>__hash__</code>  and <code>__eq__</code> implementation.</span>
<span class="comment-copy">Yes, by "identity" I meant the <i>real-world</i> identity that the object represents. So, for a book, for example, the hash only really needs to consider the ISBN. This allows you to fix errors (e.g. a typo in the title or an incomplete list of authors) without affecting the hash.</span>
<span class="comment-copy">Good answer, you correctly guessed the "implied question" while I was writing a comment, about the same point.</span>
