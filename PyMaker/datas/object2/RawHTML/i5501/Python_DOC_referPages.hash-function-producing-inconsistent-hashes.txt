<div class="post-text" itemprop="text">
<p>I have a function that produces a <code>block</code> with some data in it:</p>
<pre><code>def new_block(self, proof, previous_hash=None):

    ...

    block = {
        'message': 'New Block Forged',
        'index': len(self.chain) + 1,
        'transactions': self.current_transactions,
        'proof': proof,
        'previous_hash': previous_hash, or self.hash_block(self.chain[-1]),
        'timestamp': response.tx_time or time(),
    }
</code></pre>
<p><code>self.chain</code> is the list of blocks that the block is on. The <code>previous_hash</code> (the hash of the previous block), gets passed to the function, and a time stamp is created. Don't worry too much about the details of the actual data (well something could be wrong there, but it relates more to the <code>hash()</code> function than what is going on with the data)</p>
<p>Next I hash the block, and add it to the block:</p>
<p><code>block['hash'] = self.hash_block(block)</code></p>
<p>The <code>hash_block</code> function looks like this:</p>
<pre><code>@staticmethod
def hash_block(block):

    block_string = json.dumps(block, sort_keys=True)
    return hash(block_string)
</code></pre>
<p>This function creates a completely different hash than the next block in line says it has (the hash of the last block attached to the block in front, on the chain, does not match the <code>previous_hash</code> of the block in front. However, they are using the same function:</p>
<p>This line:
    <code>'previous_hash': previous_hash or self.hash_block(self.chain[-1])</code></p>
<p>and this line:
    <code>block['hash'] = self.hash_block(block)</code></p>
<p>Are the important lines (and the <code>hash_block</code>) function. A block gets created, gets hashed and the hash gets attached, then another block gets created and hashes the previous block and it doesn't match the hash created for that block when the block is created.</p>
<p>Also, I started out with hashlib.sha256, and when I noticed this problem i decided to see if it was the hashing function, so I switched to the <code>stock</code> hash, but I am still having the problem - ultimately I want this to work on <code>hashlib</code>, but I figure if I can get it to work with <code>hash</code> first...I will have solved the problem for <code>hashlib</code></p>
</div>
<div class="post-text" itemprop="text">
<p><code>hash()</code> is <strong>only suitable for producing mappings, hash tables</strong>. It uses a <strong>random seed</strong> to prevent attacks. It is <strong>not</strong> a cryptographic hash and should not be counted on to be stable across Python invocations.</p>
<p>From the <a href="https://docs.python.org/3/library/functions.html#hash" rel="nofollow noreferrer"><code>hash()</code> function</a> documentation:</p>
<blockquote>
<p>Return the hash value of the object (if it has one). Hash values are integers. <strong>They are used to quickly compare dictionary keys during a dictionary lookup.</strong> Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0).</p>
</blockquote>
<p>and from the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer"><code>__hash__</code> hook method</a>, which <code>hash()</code> calls if present:</p>
<blockquote>
<p><strong>Note</strong>: By default, the <code>__hash__()</code> values of <code>str</code>, <code>bytes</code> and <code>datetime</code> objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.</p>
</blockquote>
<p>Stick to the <a href="https://docs.python.org/3/library/hashlib.html" rel="nofollow noreferrer"><code>hashlib</code> module</a> options; those are stable across calls.</p>
<p>Apart from this, <em>within</em> a single Python process, <code>hash()</code> on objects with the same <em>value</em>, will also produce the exact same hash. Since your <code>block</code> dictionary changes between blocks (as it includes the hash for the preceding block in the chain), it will naturally <em>not</em> be the same string and so not the same hash value.</p>
<p>The same applies to the <code>hashlib</code> functions; they produce the same value for the same input only. If your hash values differ, then the input differs. And your inputs naturally differ because each <code>block</code> dictionary includes a reference to the preceding hash.</p>
</div>
<div class="post-text" itemprop="text">
<p>After printing the the object which would be <code>json.dumps</code>'d, I noticed that it was retaining the added <code>hash</code> property (I thought it wasn't) - check your variables </p>
</div>
<span class="comment-copy">I note that you didn't include inputs, or expected output and actual output. Even as made up data. I can't help you with your hashing issues, because you haven't actually given us a decent <a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>.</span>
<span class="comment-copy">cool ok - well the same problem was happening with hashlib.sha256</span>
<span class="comment-copy">aside from all that...these are not repeated invocations...and the hashes seem to be created the same in different spots...except for the spot where it hashes the block initially</span>
<span class="comment-copy">@ewizard: in the same Python interpreter (so not restarted), the <code>hash()</code> of a string (like returned by <code>json.dumps()</code>) will be the same <i>only if the value is exactly the same</i>. If they are not the same, the string is not the same.</span>
<span class="comment-copy">ahhh ok that might be it! ill try and work something out</span>
