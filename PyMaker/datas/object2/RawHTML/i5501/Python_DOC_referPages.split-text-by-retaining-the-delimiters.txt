<div class="post-text" itemprop="text">
<p>With the <code>re</code> module, it seems that I am unable to split on pattern matches that are empty strings:</p>
<pre><code>&gt;&gt;&gt; re.split(r'(?&lt;!foo)(?=bar)', 'foobarbarbazbar')
['foobarbarbazbar']
</code></pre>
<p>In other words, even if a match is found, if it's the empty string, even <code>re.split</code> cannot split the string.</p>
<p>The <a href="https://docs.python.org/3/library/re.html#re.split" rel="noreferrer">docs for <code>re.split</code></a> seem to support my results.</p>
<p>A "workaround" was easy enough to find for this particular case:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'(?&lt;!foo)(?=bar)', 'qux', 'foobarbarbazbar').split('qux')
['foobar', 'barbaz', 'bar']
</code></pre>
<p>But this is an error-prone way of doing it because then I have to beware of strings that already contain the substring that I'm splitting on:</p>
<pre><code>&gt;&gt;&gt; re.sub(r'(?&lt;!foo)(?=bar)', 'qux', 'foobarbarquxbar').split('qux')
['foobar', 'bar', '', 'bar']
</code></pre>
<p>Is there any better way to split on an empty pattern match with the <code>re</code> module? Additionally, why does <code>re.split</code> not allow me to do this in the first place? I know it's possible with other split algorithms that work with regex; for example, I am able to do this with JavaScript's built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split" rel="noreferrer"><code>String.prototype.split()</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is unfortunate that the <code>split</code> requires a non-zero-width match, but it hasn't been to fixed yet, since quite a lot incorrect code depends on the current behaviour by using for example <code>[something]*</code>as the regex. Use of such patterns will now generate a <code>FutureWarning</code> and those that <em>never</em> can split anything, throw a <code>ValueError</code> from Python 3.5 onwards:</p>
<pre><code>&gt;&gt;&gt; re.split(r'(?&lt;!foo)(?=bar)', 'foobarbarbazbar')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/lib/python3.6/re.py", line 212, in split
    return _compile(pattern, flags).split(string, maxsplit)
ValueError: split() requires a non-empty pattern match.
</code></pre>
<p>The idea is that after a certain period of warnings, the behaviour can be changed so that your regular expression would work again.</p>
<hr/>
<p>If you can't use the <code>regex</code> module, you can write your own split function using <code>re.finditer()</code>:</p>
<pre><code>def megasplit(pattern, string):
    splits = list((m.start(), m.end()) for m in re.finditer(pattern, string))
    starts = [0] + [i[1] for i in splits]
    ends = [i[0] for i in splits] + [len(string)]
    return [string[start:end] for start, end in zip(starts, ends)]

print(megasplit(r'(?&lt;!foo)(?=bar)', 'foobarbarbazbar'))
print(megasplit(r'o', 'foobarbarbazbar'))
</code></pre>
<p>If you are sure that the matches are zero-width only, you can use the starts of the splits for easier code:</p>
<pre><code>import re

def zerowidthsplit(pattern, string):
    splits = list(m.start() for m in re.finditer(pattern, string))
    starts = [0] + splits
    ends = splits + [ len(string) ]
    return [string[start:end] for start, end in zip(starts, ends)]

print(zerowidthsplit(r'(?&lt;!foo)(?=bar)', 'foobarbarbazbar'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import regex
x="bazbarbarfoobar"
print regex.split(r"(?&lt;!baz)(?=bar)",x,flags=regex.VERSION1)
</code></pre>
<p>You can use <a href="https://pypi.python.org/pypi/regex" rel="nofollow"><code>regex</code></a> module here for this.</p>
<p>or</p>
<pre><code>(.+?(?&lt;!foo))(?=bar|$)|(.+?foo)$
</code></pre>
<p>Use <code>re.findall</code> .</p>
<p><a href="https://regex101.com/r/uE3cC4/10#python" rel="nofollow">See demo</a></p>
</div>
<span class="comment-copy">While the <code>findall</code> method in the other answer is clever, it requires the "foo" pattern to be repeated twice in the same regex. If "foo" were actually a placeholder for a much more complicated pattern, that would be entirely undesirable. This answer is the most scalable and practical for complicated regular expressions and it also doesn't require any additional modules to be installed (which also takes away the necessity to refactor existing code to work with <code>regex</code>), and that's why I'm accepting this as the best answer.</span>
<span class="comment-copy">@Shashank added a split function that works correctly with zero-width and non-zero-width matches</span>
<span class="comment-copy">How could incorrect code rely on something which isn't implemented? There are very few areas for which Python objectively sucks, and this one fine example.</span>
<span class="comment-copy">@EricDuminil the single example is using <code>[something]*</code> as separator. In any case it is <i>being</i> fixed.</span>
<span class="comment-copy">@EricDuminil see the edit</span>
<span class="comment-copy">You mean the module on PyPI that is supposed to replace <code>re</code> in the future?</span>
<span class="comment-copy">I had to Google it because your answer didn't have a link. :p But that is nice to know about. Any idea when the replacement is scheduled?</span>
<span class="comment-copy">Well foo would need to be in the capture group, so I fixed it like this: <code>re.findall(r'(.+?(?&lt;!foo)|.*?foo(?!bar))(?=bar|$)', 'foo')</code>. I <i>think</i> that works properly. It allows the capture group to end in foo if the negative lookahead says that it's not preceded by bar.</span>
<span class="comment-copy">@Shashank seems to be working fine!!! <code>(.+?(?&lt;!foo))(?=bar|$)|(.*?foo)$</code> guess both would work the same!!!</span>
<span class="comment-copy">Ah I see, it's giving [('', 'foo')] because findall returns tuples when you have multiple capture groups tied together with an alternation operator. Which is undesired...so I think my method is the best since it has only one capture group.</span>
