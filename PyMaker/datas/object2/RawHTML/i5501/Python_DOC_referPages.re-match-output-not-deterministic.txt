<div class="post-text" itemprop="text">
<p>I am doing a rather complex match with python using <code>re.match</code>, which takes the form of <code>(some_pattern_1)?(some_pattern_2)?..(.*)</code></p>
<p>On the other side of it I have a unit test with about one hundred examples I am checking, which are all sending request asynchronously to my (local, development) server. The server is in django.</p>
<p>I am sometime seing the match apparently be non-greedy (i.e. too many things end up in the last catch all block) and the unit test fail, but can't really reproduce it in isolation, and I don't really have an idea what's going on.</p>
<p>More concretely, the relevant part of the regex is (in Python):</p>
<pre><code>import re

input = "1 small shoe"

sizes = ["small", "large", "big", "huge"]
colors = ["blue", "red", "green", "yellow", "grey"]
anySize = u' |'.join(sizes)
anyColor = u' |'.join(colors)
matched_expression = re.match(
    r'\s*(?P&lt;amount&gt;(((\d{1,2}\.)?\d{1,3})?)\s*'
    r'(?P&lt;size&gt;(\b'+anySize+'\b)?)\s*'
    r'(?P&lt;color&gt;(\b'+anyColor+'\b)?)\s*'
    r'(?P&lt;name&gt;.*, input, re.UNICODE|re.IGNORECASE)
if matched_expression:
    print(matched_expression.groupdict()["amount"])
    print(matched_expression.groupdict()["size"])
    print(matched_expression.groupdict()["color"])
    print(matched_expression.groupdict()["name"])
</code></pre>
<p>And I am sometimes seeing this printed:</p>
<pre><code>1
''
''
'small shoe'
</code></pre>
<p>Are there know conditions where this could happen (and am I correct to assume that the regex match is guaranteed to be fully deterministic in principle?) ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Most of the string literals you're using to build your pattern are <em>raw</em> literals (introduced with the <code>r</code> prefix), which is great—the string interpreter therefore does not give backslash any special meaning, but instead leaves them intact for the regex parser.  However, you have unfortunately not used raw literals in every case:</p>
<pre><code>    r'(?P&lt;size&gt;(\b'+anySize+'\b)?)\s*'
#                           ^^^^^^^^^^   this is not a raw string literal

    r'(?P&lt;color&gt;(\b'+anyColor+'\b)?)\s*'
#                             ^^^^^^^^^^ and nor is this
</code></pre>
<p>Consequently, the backslashes in those literals have the effect described under <a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals" rel="nofollow noreferrer">String and Bytes literals</a> before the interpreted string is given to the regex compiler.  Accordingly, your <code>\b</code> boundary anchors are replaced with ASCII backspace characters!</p>
<p>Either use raw string literals by prefixing them with <code>r</code> or else be sure to escape the backslashes they contain.</p>
<p>There are however also a number of other issues with your code worth noting:</p>
<ol>
<li><p>As currently written, your regex won't compile due to some syntax errors.  In particular, the capture groups named <code>amount</code> and <code>name</code> are not terminated due to unbalanced brackets:</p>
<pre><code>    r'\s*(?P&lt;amount&gt;(((\d{1,2}\.)?\d{1,3})?)\s*'
#        +          +++         -        - -
</code></pre>
<p>There are four opening brackets, but only three closing brackets.  You probably intended to write:</p>
<pre><code>    r'\s*(?P&lt;amount&gt;(((\d{1,2}\.)?\d{1,3})?))\s*'
#                                           ^
</code></pre>
<p>Similarly, <code>r'(?P&lt;name&gt;.*, ...</code> should probably be <code>r'(?P&lt;name&gt;.*)', ...</code> (note also the pattern string needs to be terminated before the argument separator).</p></li>
<li><p><code>\b</code> boundary anchors bind more tightly than <code>|</code> alternation, so when placed at the same level as your joined arrays they are only bound to the first and last elements of the alternatives respectively.  For example, the capture group named <code>size</code> is currently specified by the following pattern:</p>
<pre><code>(\bsmall |large |big |huge\b)?
</code></pre>
<p>Which is equivalent, in terms of precedence, to:</p>
<pre><code>((\bsmall )|(large )|(big )|(huge\b))?
</code></pre>
<p>Better instead to place the boundary anchors outside of the brackets:</p>
<pre><code>    r'(?P&lt;size&gt;\b('+anySize+r')?\b)\s*'
    r'(?P&lt;color&gt;\b('+anyColor+r')?\b)\s*'
</code></pre></li>
<li><p>As shown above, the whitespace in your join expressions is likely to lead to unintended consequences: <code>anySize</code> and <code>anyColor</code> require that all but the final terms in their underlying arrays are, if present, followed by a space character (in addition to those that match the <code>\s*</code> patterns.  Better to join the arrays with <code>'|'</code> alone, rather than <code>' |'</code>:</p>
<pre><code>anySize = u'|'.join(sizes)
anyColor = u'|'.join(colors)
</code></pre></li>
<li><p>Depending on the source of the underlying arrays, and how confident you are that they do not contain any special regex patterns, you may wish to first escape the array elements.</p></li>
</ol>
</div>
<span class="comment-copy">It would be <i>extremely</i> helpful to see the exact patterns, as well as string examples</span>
<span class="comment-copy">yeap, <code>regex</code> can be non deterministic.</span>
<span class="comment-copy">@sKwa: can you give more details about conditions under which this happens?</span>
<span class="comment-copy">@vib: python <code>regex</code> engine based on <code>NFA</code>(nondeterministic finite automaton). You can read a brief explanation here: <a href="https://stackoverflow.com/questions/33895542/why-regular-expression-x-yx-z-is-nondeterministic">Why regular expression ((x,y)|(x,z)) is nondeterministic?</a></span>
<span class="comment-copy">@sKwa: that isn't the sense of "nondeterministic" the question is using.  they are asking if the same regex applied to the same string can be expected to always match in the same way or not</span>
<span class="comment-copy">Excellent, thank you so much ! I still don't completely understand what I was matching but I think I had two errors compensating themselves except when matching the last term in anySize / anyColor. Now because the latter was not hardcoded as shown but rather extracted from a dict, i.e. anySize = " |".join(self.mySizesDict.keys()), there was some randomness in which element would arrive last. This explain why my regex would fail only in some cases, but then repetidively (as I think that the regex is somehow cached by the system)</span>
<span class="comment-copy">@vib: You'd do well to store the complete pattern in a variable (the value of which you can inspect for debugging) rather than passing directly to <code>re.match()</code>.  If you encounter problems, you can then copy/paste the complete pattern into something like <a href="https://regex101.com/" rel="nofollow noreferrer">regex101.com</a> to visualise exactly what's going on.</span>
<span class="comment-copy">yes, the issue is that my mistakes where somewhat compensating so that it was working as expected in most cases and confused me. I am already using regex101 ;-)</span>
<span class="comment-copy">Cool.  As regards the intermittent randomness (which is probably worth a question of its own), I'd comment that the order of values in the list returned by a dictionary's <code>keys()</code> method is implementation-specific; in the reference CPython implementation, it's non-random but arbitrary and depends on the dictionary’s history of insertions and deletions—consequently, the last item in the list should have been consistent unless the order in which items were added to the dictionary differed.  The regex would then have required that last item, if present, to be followed by an ASCII backspace.</span>
