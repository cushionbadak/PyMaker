<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/13905741/accessing-class-variables-from-a-list-comprehension-in-the-class-definition">Accessing class variables from a list comprehension in the class definition</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>This following simple code gives an error in Python 3.6 (but OK in 2.7):</p>
<pre><code>class XY:
    pre = ''
    z = [pre + a for a in ['x', 'y']]

# NameError: name 'pre' is not defined.
</code></pre>
<p>When I put the same code inside a function instead of a class: <code>def XY(): ...</code> it works. When I roll the list comprehension inside a regular loop, it also works. Python 2.7 works with the same code that gives an error in 3.6!</p>
<p>Any idea what's wrong with accessing a local class variable from inside a list comprehension?</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions now use a function scope, that was a change between Python 2 and 3.  The variable <code>pre</code> will be inaccessible from within the list comprehension for this reason.  </p>
<p>The new behavior is documented under the <a href="https://docs.python.org/3/reference/executionmodel.html" rel="nofollow noreferrer">execution model</a> (emphasis mine), with an example given that is very similar to the one you have found:</p>
<blockquote>
<p>Class definition blocks and arguments to <code>exec()</code> and <code>eval()</code> are special in the context of name resolution. A class definition is an executable statement that may use and define names. These references follow the normal rules for name resolution with an exception that unbound local variables are looked up in the global namespace. The namespace of the class definition becomes the attribute dictionary of the class. <strong>The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods â€“ this includes comprehensions and generator expressions since they are implemented using a function scope</strong>.  This means that the following will fail:</p>
</blockquote>
<pre><code>class A:
    a = 42
    b = list(a + i for i in range(10))
</code></pre>
<p>Furthermore, <code>pre</code> name will also be inaccessible via the class <code>XY.pre</code>, because the class doesn't exist yet.  You will have to find another way to go about what you want to do.  </p>
</div>
<div class="post-text" itemprop="text">
<p>You can create <code>z</code> in the <code>__init__</code> method of <code>XY</code>:</p>
<pre><code>class XY:
   pre = ''
   def __init__(self):
       self.z = [self.pre + a for a in ['x', 'y']]
</code></pre>
</div>
<span class="comment-copy">Probably you are looking for creating a function instead of class <i>(currently it is class)</i>. If class, then your this logic should be inside any of the class' function</span>
<span class="comment-copy">Are <code>x</code> and <code>y</code> initialized properly?</span>
