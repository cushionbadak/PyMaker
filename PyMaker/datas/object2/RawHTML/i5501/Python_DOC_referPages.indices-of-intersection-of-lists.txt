<div class="post-text" itemprop="text">
<p>Given two lists of equal length:</p>
<pre><code>_list = [1, 4, 8, 7, 3, 15, 5, 0, 6]
_list2 = [7, 4, 0, 1, 5, 5, 7, 2, 2]
</code></pre>
<p>How do I try getting an output like this:</p>
<p><code>output = [(0,3), (1,1), (3,0), (6,4), (6,5), (7,2)]</code></p>
<p>Here the intersection of two lists are obtained and the common elements' indices are arranged in the list:</p>
<p><code>output = list of (index of an element in _list, where it appears in _list2)</code></p>
<p>Trying intersection with sets is not an option since the set removes the repeating elements.</p>
</div>
<div class="post-text" itemprop="text">
<p><em>Basic-Intermediate</em>: As a generator:</p>
<pre><code>def find_matching_indices(a, b):
    for i, x in enumerate(a):
        for j, y in enumerate(b):
            if x == y:
                yield i, j

list(find_matching_indices(list1_, list2_))
# [(0, 3), (1, 1), (3, 0), (3, 6), (6, 4), (6, 5), (7, 2)] 
</code></pre>
<p><em>Basic-Intermediate</em>: As a list comprehension:</p>
<pre><code>[(i, j)  for i, x in enumerate(list1_) for j, y in enumerate(list2_) if x == y]
# [(0, 3), (1, 1), (3, 0), (3, 6), (6, 4), (6, 5), (7, 2)] 
</code></pre>
<p>These solutions involve two loops.</p>
<hr/>
<p><em>Intermediate-Advanced</em>: For fun, a dictionary is another data structure you might consider:</p>
<pre><code>import collections as ct

import more_itertools as mit


def locate_indices(a, b):
    """Return a dictionary of `a` index keys found at `b` indices."""
    dd = ct.defaultdict(list)
    for i, y in enumerate(a):
        idxs = list(mit.locate(b, lambda z: z == y))
        if idxs: dd[i].extend(idxs)
    return dd


locate_indices(list1_, list2_)
# defaultdict(list, {0: [3], 1: [1], 3: [0, 6], 6: [4, 5], 7: [2]})
</code></pre>
<p>Note the index of list <code>a</code> is the key in the dictionary.  All indices in list <code>b</code> that share the same value are appended. </p>
<p>A <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>defaultdict</code></a> was used since it is helpful in building dictionaries with list values.  See more on the <a href="https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.locate" rel="nofollow noreferrer">third-party tool <code>more_itertools.locate()</code></a>, which simply yields all indices that satisfy the lambda condition - an item in list <code>a</code> is also found in <code>b</code>.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import product
from collections import defaultdict


def mathcing_indices(*lists):
    d = defaultdict(lambda: tuple([] for _ in range(len(lists))))
    for l_idx, l in enumerate(lists):
        for i, elem in enumerate(l):
            d[elem][l_idx].append(i)
  return sorted([tup for _, v in d.items() for tup in product(*v)])
</code></pre>
<p>This solution builds a dictionary that tracks the indices that values appear at in the input lists.  So if the value <code>5</code> appears at indices 0 and 2 of the first list and index 3 of the second, the value for <code>5</code> in the dictionary would be <code>([0, 2], [3])</code></p>
<p>It then uses <code>itertools.product</code> to build all the combinations of those indices. </p>
<p>This looks more complicated than the other answers here, but because it is <code>O(nlogn)</code> and not <code>O(n**2)</code> it is <a href="https://repl.it/@Haugh/BackPassionateMaltesedog" rel="nofollow noreferrer">significantly faster</a>, especially for large inputs. Two length 1000 lists of random numbers 0-1000 complete 100 tests in ~.4 seconds using the above algorithm and 6-13 seconds using some of the others here   </p>
</div>
<span class="comment-copy">Did the elements in your two lists are unique ?</span>
<span class="comment-copy">@ChihebNexus not in the sample input</span>
<span class="comment-copy">Isn't <code>(1,1)</code> missing?</span>
<span class="comment-copy">Are you sure that the output should be <code>[(0,3), (2,2), (3,0), (6,4), (6,5), (7,2)]</code> ? And if there is duplicates, which index should you use ?</span>
<span class="comment-copy">Sorry, that (2,2) should have been (1,1). Thanks for pointing it out.</span>
