<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/38163366/split-list-into-separate-but-overlapping-chunks">Split list into separate but overlapping chunks</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>I need to get a list that contains every two adjacent characters in the string <code>hello</code> such that  </p>
<pre><code>['he', 'el', 'll', 'lo']
</code></pre>
<p>I thought I could do it int this way  </p>
<pre><code>&gt;&gt;&gt;import re
&gt;&gt;&gt;re.findall(r'..', 'hello')
['he', 'll']
</code></pre>
<p>Which is not what I want. I need to get a list as I mentioned above using Regular Expression</p>
</div>
<div class="post-text" itemprop="text">
<p>Good news! Your question is an <a href="https://stackoverflow.com/questions/11430863/how-to-find-overlapping-matches-with-a-regexp/18966698"><em>exact duplicate</em> of this one</a>, which gives you the exact regex needed:</p>
<pre><code>&gt;&gt;&gt; re.findall(r'(?=(\w\w))', 'hello')
['he', 'el', 'll', 'lo']
</code></pre>
<p>Read the linked thread for more logic behind it.</p>
<h1>Original Answer:</h1>
<p>No need for regex.  You can use list comprehension for that.</p>
<pre><code>h = 'hello'

a = [h[i:i+2] for i in range(len(h)-1)]
</code></pre>
<p>Result:</p>
<pre><code>['he', 'el', 'll', 'lo']
</code></pre>
<p>Edit: RoadRunner's zip/map solution is more elegant.  That said, this solution is scale-able so if you want, you can get more than just 2 adjacent characters:</p>
<pre><code>func = lambda my_list, n: [my_list[i:i+n] for i in range(len(my_list)-n+1)]

# OR, as RoadRunner suggested a cleaner read if you don't like lambdas:

def func(my_list, n): return [my_list[i:i+n] for i in range(len(my_list)-n+1)]
</code></pre>
<p>This will give you:</p>
<pre><code>&gt;&gt;&gt; func('hello', 2)
['he', 'el', 'll', 'lo']
&gt;&gt;&gt; func('hello', 3)
['hel', 'ell', 'llo']
&gt;&gt;&gt; func('hello', 4)
['hell', 'ello']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need regex here, you can do this easily with <a href="https://docs.python.org/3.3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a>:</p>
<pre><code>&gt;&gt;&gt; s = "hello"
&gt;&gt;&gt; [x + y for x, y in zip(s, s[1:])]
['he', 'el', 'll', 'lo']
</code></pre>
<p>Or even a functional approach with <a href="https://docs.python.org/3.3/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a>:</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x, y: x + y, s, s[1:]))
['he', 'el', 'll', 'lo']
</code></pre>
<p>If you want a way to handle any number of adjacent characters, you could try using a sliding window approach, which takes the first <code>n</code> characters, and pops the first character, and repeats this until no more substrings can be taken.</p>
<p>Here is an example:</p>
<pre><code>from collections import deque
from itertools import islice

def every_n(s, n):
    result = []

    items = deque(s)
    while len(items) &gt;= n:
        result.append(''.join(islice(items, 0, n)))
        items.popleft()

    return result
</code></pre>
<p>Which works as follows:</p>
<pre><code>&gt;&gt;&gt; print(every_n('hello', 2))
['he', 'el', 'll', 'lo']
&gt;&gt;&gt; print(every_n('hello', 3))
['hel', 'ell', 'llo']
&gt;&gt;&gt; print(every_n('hello', 4))
['hell', 'ello']
&gt;&gt;&gt; print(every_n('hello', 5))
['hello']
</code></pre>
</div>
<span class="comment-copy">@coldspeed: you couldn't have linked the dupe with the exact same question? :P <a href="https://stackoverflow.com/questions/11430863/how-to-find-overlapping-matches-with-a-regexp/18966698" title="how to find overlapping matches with a regexp">stackoverflow.com/questions/11430863/â€¦</a></span>
<span class="comment-copy">Another perfect solution @Idlehands cheerz</span>
<span class="comment-copy">coldspeed is too eager to mark a question as duplicate. In my opinion to mark a question as duplicate needs more time to analyze and find the most appropriate duplicate.</span>
<span class="comment-copy">To be fair, it was a thread he answered before (and recently edited), so it was natural for him to pick that one.  I was just poking fun because I found the other link while I was looking up <code>re</code> with overlapping matches, and thought it was funny it was the exact same question.</span>
<span class="comment-copy">Your answer seem to be better than @RoadRunner cuz i can extend it to solve my real problem. The question asked here is not the exact question. But why re.findall(r'..', 'hello') does not return every possible two adjacent characters? as .. represents every two adjacent characters in re. Can u do it using re?</span>
<span class="comment-copy">The last edit you made is what i exactly want though i didn't write it in the question. So accepted answer for you. but can u provide it using re?</span>
<span class="comment-copy">I'm not much of a regex user, but it seems that once <code>re</code> has a match, it continues from the character <i>after</i> the match, that's why it continued from 'he' to 'll' instead of 'el'.  When I ran <code>re.finditer(r'..','hello')</code> the iterable returned this: <code>&lt;_sre.SRE_Match object; span=(0, 2), match='he'&gt;, &lt;_sre.SRE_Match object; span=(2, 4), match='ll'&gt;</code>.  As you can see, the span went from 0,2 to 2,4.</span>
<span class="comment-copy">@skilledDt: Based on the <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow noreferrer"><code>re</code> documentation</a>, <code>findall</code> returns non-overlapping matches, that's why it wouldn't work.  There <i>might</i> be a function for overlapping matches, but I haven't seen it in the documentation.</span>
