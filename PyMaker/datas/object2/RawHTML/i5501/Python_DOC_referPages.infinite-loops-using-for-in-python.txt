<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/5737196/is-there-an-expression-for-an-infinite-generator">Is there an expression for an infinite generator?</a>
<span class="question-originals-answer-count">
                    7 answers
                </span>
</li>
</ul>
</div>
<p>Why does this not create an infinite loop? </p>
<pre><code>a=5
for i in range(1,a):
  print(i)
  a=a+1
</code></pre>
<p>or this</p>
<pre><code>for i in range(1,4):
  print(i)
  i=i-1
</code></pre>
<p>or this</p>
<pre><code>for i in range(1,4):
  print(i)
  i=1
</code></pre>
<p>Is there any way we can create infinite loops using a <code>for</code> loop? I know there is the <code>while</code> loop for that but I was just curious.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html?highlight=range#range" rel="noreferrer"><code>range</code> is a <em>class</em></a>, and using in like e.g. <code>range(1, a)</code> creates an <em>object</em> of that class. This object is created only <em>once</em>, it is not recreated every iteration of the loop. That's the reason the first example will not result in an infinite loop.</p>
<p>The other two loops are not infinite because, unlike the <code>range</code> object, the loop variable <code>i</code> <em>is</em> recreated (or rather <em>reinitialized</em>) each iteration. The values you assign to <code>i</code> inside the loop will be overwritten as the loop iterates.</p>
</div>
<div class="post-text" itemprop="text">
<p>Consider a <code>for</code> loop:</p>
<pre><code>for item in iterable:
    print(item)
</code></pre>
<p>The idea is that as long as <code>iterable</code> is unchanged, we will loop through each and every <code>item</code> inside <code>iterable</code> once. For example,</p>
<pre><code>for item in [3, 2, 1, 666]:
    print(item)
</code></pre>
<p>will output <code>3 2 1 666</code>. In particular, we find that <code>range(1, 4)</code> is a easy way to represent an iterable <code>[1, 2, 3]</code>. Thus,</p>
<pre><code>for i in range(1, 4):
    print(i)
</code></pre>
<p>will output <code>1 2 3</code>.</p>
<hr/>
<h3>Example 1</h3>
<pre><code>a=5
for i in range(1,a):
  print(i)
  a=a+1
</code></pre>
<p>In this case, <code>range(1,a)</code> is evaluated <em>once</em>, when the loop begins.</p>
<h3>Example 2</h3>
<pre><code>for i in range(1,4):
  print(i)
  i=i-1
</code></pre>
<p>In this case, <code>i</code> is reevaluated every loop, before executing the <code>print</code> and <code>i=i-1</code> statements within the body of the loop.</p>
<h3>Example 3</h3>
<pre><code>for i in range(1,4):
  print(i)
  i=1
</code></pre>
<p>Just like <strong>Example 2</strong>, <code>i</code> is reevaluated every loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't, in this case, update the iterator that your <code>for</code> loop is looping over.</p>
<hr/>
<p>The <code>range</code> in <code>for i in range(a):</code> is actually a function - it takes a value, a, and returns an object that contains the values that it will loop through. Once you've built that object you can change the input variable as much as you'd like, and that object won't change.</p>
<p>Imagine if we made our own similar function called <code>my_range</code> that generates a list (whereas the built in <code>range</code> function generates a <code>range</code>):</p>
<pre><code>def my_range(end):
    my_list = []
    for i in range(end):
        my_list.append(i)
    return my_list
</code></pre>
<p>Now if we were to use our new function, like so:</p>
<pre><code>a = 4
for i in my_range(a):
    print(i)
    a += 1
</code></pre>
<p>It'd be obvious that we can't update the list object that we're looping over by changing <code>a</code>, because the list that we're looping over has already been made, and isn't being remade on every loop.</p>
<hr/>
<p>Can you make an infinite loop in python? Yes, just add a new entry to the object that you're looping through, e.g.:</p>
<pre><code>my_list = [0]
for i in my_list:
    print(i)
    my_list.append(i+1)
</code></pre>
<p>Now we're updating the object that we're looping over.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because a range is either a list (Python2) or a <code>range</code> object both of which are finite. That range is created once before the loop starts. Your loop variable is assigned the next element of the range at the beginning of each iteration, regardless of what you assign it later in the loop body. You need an infinite iterator for an infinite for loop, e.g. <code>itertools.cycle</code>:</p>
<pre><code>from itertools import cycle
for x in cycle(range(5)):
    # endless
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1><code>for</code> loops and the <code>range(..)</code> object</h1>
<p>If you write <code>for i in range(..):</code> Python does <em>not</em> translate this into something like <code>for(int i = 0; i &lt; n; i++)</code> (in the C-programming language family).</p>
<p>Furthermore the range object is constructed once, before the <code>for</code> loop. The <code>range(..)</code> object, does not know which variables have been used to construct it. Once constructed, the range is <em>fixed</em>.</p>
<p>It sees <code>range(..)</code> as an <em>iterable</em> object, and each iteration, it takes the next item the iterable yields. So whether you set the variable or not in the <code>for</code> loop, has <em>no</em> effect for the next iteration.</p>
<p>In <a class="post-tag" href="/questions/tagged/python-2.x" rel="tag" title="show questions tagged 'python-2.x'">python-2.x</a>, <code>range(..)</code> is not a specific object, but a call to construct a list. So if you call <code>range(10)</code> (without the <code>for</code> loop), you get <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>.</p>
<h1>Why it does not work?</h1>
<p>So then why does the examples do not work?</p>
<pre><code>a=5
for i in range(1,a):
  print(i)
  a=a+1
</code></pre>
<p>Here we construct <code>range(..)</code> once. After that, the variables based on which it was constructed can change, since the <code>range(..)</code> object does change anymore. Incrementing <code>a</code> thus will not mean the <code>range</code> object will get larger.</p>
<pre><code>for i in range(1,4):
  print(i)
  i=i-1
</code></pre>
<p>The <code>for</code> loop each time takes the <em>next</em> item of the iterable. So if we first have collected <code>1</code> from the <code>range</code> loop, the next iteration, we collect <code>2</code>. This is regardless what the value of <code>i</code> is.</p>
<pre><code>for i in range(1,4):
  print(i)
  i=1
</code></pre>
<p>For the very same reason: <code>for</code> does <em>not</em> take into account the previous value of <code>i</code>. It only fetches the next item the iterable (here <code>range(..)</code> yields). Since <code>range(..)</code> is fixed, it will simply feed the <code>for</code> loop the next item.</p>
<h1>Emulating an infinite loop</h1>
<p>So we need to construct an iterable that keeps yielding elements. A way to do this is <code>itertools.count</code>:</p>
<pre><code>from itertools import count

for i in count():
    # ...
    pass
</code></pre>
<p>Or in case you are not interested in any value, we can use <code>repeat</code> as well:</p>
<pre><code>from itertools import repeat

for _ in repeat(None):
    # ...
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>range</code> copies the parameters given to it for internal use. So changes to those afterwards have no effect. Same as with the loop variable, which is only created from the internal values every time.</p>
<p>That's different though if you use a mutable object like a <code>list</code> to iterate over:</p>
<pre><code>a = [1,2,3]

for i in a:
    a.append(i)
</code></pre>
<p>This loop will indeed run infinitely.</p>
</div>
<span class="comment-copy">That's why while loops exists. For loops are iterating through elements of a generator. You can write an infinite generator using the <code>yield</code> keyword though.</span>
<span class="comment-copy">This will however easily run out of memory. Furthermore some collections (not lists) will raise an exception for good reasons when altering a collection when iterating over it.</span>
<span class="comment-copy">Sure. It's not meant for actual "use", just for creating a counter-example which behaves as OP expected.</span>
