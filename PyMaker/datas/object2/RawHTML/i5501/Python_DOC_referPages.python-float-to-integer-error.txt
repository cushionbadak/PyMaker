<div class="post-text" itemprop="text">
<p>I'm having a hard time understanding this:</p>
<pre><code>&gt;&gt;&gt; 52920*(15303855351918+15303855298999)/2.0 == 809880023823263820
False
&gt;&gt;&gt; 52920*(15303855351918+15303855298999)/2.0 == 809880023823263820.0
True
&gt;&gt;&gt; (52920*(15303855351918+15303855298999)/2.0) - 809880023823263820
0.0
&gt;&gt;&gt; int(52920*(15303855351918+15303855298999)/2.0)
809880023823263872
&gt;&gt;&gt; int(52920/2.0)*(15303855351918+15303855298999)
809880023823263820
</code></pre>
<p>Running Python 3.5.3</p>
<p>The number 809880023823263820 is obviously representable as an integer since it's the sum of an a.p. series with all integer parameters. What is the explanation for the 1st and 4th computations?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <code>int</code> objects have infinite precision (bounded only by memory). <code>float</code> objects do not have infinite precision; numbers are represented as an exponent and a significant, with the latter building up a number from 53 <em>binary fractions</em>. Binary fractions can't represent <em>every possible decimal number</em> and that is what is happening here.</p>
<p><code>809880023823263820</code> is not cleanly representable using binary fractions:</p>
<pre><code>&gt;&gt;&gt; float(809880023823263820)
8.098800238232639e+17
&gt;&gt;&gt; format(float(809880023823263820), 'f')
'809880023823263872.000000'
</code></pre>
<p>The number is stored as Note the last two digits; they are <code>72</code>, not <code>20</code>.</p>
<p>Note that a float value is <em>always stored as fractions</em>, with the exponent determining the position of the decimal point; there is non 'integer portion'. Both very large and very small numbers are simply represented as a fraction with the decimal point shifted by the exponent.</p>
<p>For the third expression, Python <em>converts numbers to a common type</em>. Subtracting an integer from a float causes the integer to be converted to a float first. Since <code>float(809880023823263820)</code> is the same floating point value as the result on the left of the <code>-</code> operator, the result is <code>0.0</code>.</p>
<p>From the <a href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations" rel="nofollow noreferrer"><em>Binary arithmetic operations</em> section</a> of the expressions reference documentation:</p>
<blockquote>
<p>The <code>-</code> (subtraction) operator yields the difference of its arguments. The numeric arguments are first converted to a common type.</p>
</blockquote>
<p>and a separate <a href="https://docs.python.org/3/reference/expressions.html#arithmetic-conversions" rel="nofollow noreferrer"><em>Arithmetic conversions</em> section</a> documents how this conversion is done:</p>
<blockquote>
<p>When a description of an arithmetic operator below uses the phrase “the numeric arguments are converted to a common type,” this means that the operator implementation for built-in types works as follows:</p>
<ul>
<li>If either argument is a complex number, the other is converted to complex;</li>
<li>otherwise, if either argument is a floating point number, the other is converted to floating point;</li>
<li>otherwise, both must be integers and no conversion is necessary.</li>
</ul>
</blockquote>
<p>You probably want to explore a <em>different</em> representation of rational numbers, either the <a href="https://docs.python.org/3/library/fractions.html" rel="nofollow noreferrer"><code>fractions</code></a> or the <a href="https://docs.python.org/3/library/decimal.html" rel="nofollow noreferrer"><code>decimal</code></a> modules. Either let you handle rational numbers as abstract <em>fractions</em>, or let you configure the numeric precision.</p>
</div>
<div class="post-text" itemprop="text">
<p>Floats are only of limited precision, while integers have arbitrary precision. That means you cannot represent every integer as float in Python! You can easily see this if you check:</p>
<pre><code>&gt;&gt;&gt; 809880023823263820 == 809880023823263820.0
False
&gt;&gt;&gt; 809880023823263820 == int(809880023823263820.0)
False
</code></pre>
<p>From <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64" rel="nofollow noreferrer">Wikipedia</a>:</p>
<blockquote>
<p>The 53-bit significand precision gives from 15 to 17 significant decimal digits precision (2−53 ≈ 1.11 × 10−16). If a decimal string with at most 15 significant digits is converted to IEEE 754 double-precision representation, and then converted back to a decimal string with the same number of digits, the final result should match the original string.</p>
</blockquote>
<p>But your integer has 18 digits, so you shouldn't expect that a float can exactly represent that integer. There are values that can be represented exactly that are longer than 18 digits, but the conditions have to be "right" (for example powers of two):</p>
<pre><code>&gt;&gt;&gt; 2.0 ** 80 + 1 == 2 ** 80 + 1
False
&gt;&gt;&gt; 2.0 ** 80 == 2 ** 80
True
</code></pre>
<p>Your last example is actually a bit misleading because <code>52920/2.0</code> can be represented exactly as float and because you actually convert it to an integer the calculation will be done completely with integers and result in an accurate integer result.</p>
<p>In the general case you could use <a href="https://docs.python.org/library/fractions.html" rel="nofollow noreferrer"><code>Fraction</code></a> to represent the value exactly:</p>
<pre><code>&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; Fraction(52920*(15303855351918+15303855298999), 2) == 809880023823263820
True
</code></pre>
<p>Note the <code>, 2</code> instead of the <code>/ 2.0</code> here.</p>
</div>
<span class="comment-copy">Floating point numbers are the wrong abstraction for such 'precise' numbers. There are too many digits of precision.</span>
<span class="comment-copy">Okay, I get that the significand doesn't have enough bits of precision to represent the exact number. But how does the third calculation produce the correct result?</span>
<span class="comment-copy">@DebD: added the explanation. <code>float - int</code> coerces the integer to a float.</span>
