<div class="post-text" itemprop="text">
<p>What is the difference between the following class methods?</p>
<p>Is it that one is static and the other is not?</p>
<pre><code>class Test(object):
  def method_one(self):
    print "Called method_one"

  def method_two():
    print "Called method_two"

a_test = Test()
a_test.method_one()
a_test.method_two()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python, there is a distinction between <em>bound</em> and <em>unbound</em> methods. </p>
<p>Basically, a call to a member function (like <code>method_one</code>), a bound function</p>
<pre><code>a_test.method_one()
</code></pre>
<p>is translated to</p>
<pre><code>Test.method_one(a_test)
</code></pre>
<p>i.e. a call to an unbound method. Because of that, a call to your version of <code>method_two</code> will fail with a <code>TypeError</code></p>
<pre><code>&gt;&gt;&gt; a_test = Test() 
&gt;&gt;&gt; a_test.method_two()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: method_two() takes no arguments (1 given) 
</code></pre>
<p>You can change the behavior of a method using a decorator</p>
<pre><code>class Test(object):
    def method_one(self):
        print "Called method_one"

    @staticmethod
    def method_two():
        print "Called method two"
</code></pre>
<p>The decorator tells the built-in default metaclass <code>type</code> (the class of a class, cf. <a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">this question</a>) to not create bound methods for <code>method_two</code>.</p>
<p>Now, you can invoke static method both on an instance or on the class directly:</p>
<pre><code>&gt;&gt;&gt; a_test = Test()
&gt;&gt;&gt; a_test.method_one()
Called method_one
&gt;&gt;&gt; a_test.method_two()
Called method_two
&gt;&gt;&gt; Test.method_two()
Called method_two
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Methods in Python are a very, very simple thing once you understood the basics of the descriptor system.  Imagine the following class:</p>
<pre><code>class C(object):
    def foo(self):
        pass
</code></pre>
<p>Now let's have a look at that class in the shell:</p>
<pre><code>&gt;&gt;&gt; C.foo
&lt;unbound method C.foo&gt;
&gt;&gt;&gt; C.__dict__['foo']
&lt;function foo at 0x17d05b0&gt;
</code></pre>
<p>As you can see if you access the <code>foo</code> attribute on the class you get back an unbound method, however inside the class storage (the dict) there is a function.  Why's that?  The reason for this is that the class of your class implements a <code>__getattribute__</code> that resolves descriptors.  Sounds complex, but is not.  <code>C.foo</code> is roughly equivalent to this code in that special case:</p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)
&lt;unbound method C.foo&gt;
</code></pre>
<p>That's because functions have a <code>__get__</code> method which makes them descriptors.  If you have an instance of a class it's nearly the same, just that <code>None</code> is the class instance:</p>
<pre><code>&gt;&gt;&gt; c = C()
&gt;&gt;&gt; C.__dict__['foo'].__get__(c, C)
&lt;bound method C.foo of &lt;__main__.C object at 0x17bd4d0&gt;&gt;
</code></pre>
<p>Now why does Python do that?  Because the method object binds the first parameter of a function to the instance of the class.  That's where self comes from.  Now sometimes you don't want your class to make a function a method, that's where <code>staticmethod</code> comes into play:</p>
<pre><code> class C(object):
  @staticmethod
  def foo():
   pass
</code></pre>
<p>The <code>staticmethod</code> decorator wraps your class and implements a dummy <code>__get__</code> that returns the wrapped function as function and not as a method:</p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)
&lt;function foo at 0x17d0c30&gt;
</code></pre>
<p>Hope that explains it.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; class Class(object):
...     def __init__(self):
...         self.i = 0
...     def instance_method(self):
...         self.i += 1
...         print self.i
...     c = 0
...     @classmethod
...     def class_method(cls):
...         cls.c += 1
...         print cls.c
...     @staticmethod
...     def static_method(s):
...         s += 1
...         print s
... 
&gt;&gt;&gt; a = Class()
&gt;&gt;&gt; a.class_method()
1
&gt;&gt;&gt; Class.class_method()    # The class shares this value across instances
2
&gt;&gt;&gt; a.instance_method()
1
&gt;&gt;&gt; Class.instance_method() # The class cannot use an instance method
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unbound method instance_method() must be called with Class instance as first argument (got nothing instead)
&gt;&gt;&gt; Class.instance_method(a)
2
&gt;&gt;&gt; b = 0
&gt;&gt;&gt; a.static_method(b)
1
&gt;&gt;&gt; a.static_method(a.c) # Static method does not have direct access to 
&gt;&gt;&gt;                      # class or instance properties.
3
&gt;&gt;&gt; Class.c        # a.c above was passed by value and not by reference.
2
&gt;&gt;&gt; a.c
2
&gt;&gt;&gt; a.c = 5        # The connection between the instance
&gt;&gt;&gt; Class.c        # and its class is weak as seen here.
2
&gt;&gt;&gt; Class.class_method()
3
&gt;&gt;&gt; a.c
5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you call a class member, Python automatically uses a reference to the object as the first parameter. The variable <code>self</code> actually means nothing, it's just a coding convention. You could call it <code>gargaloo</code> if you wanted. That said, the call to <code>method_two</code> would raise a <code>TypeError</code>, because Python is automatically trying to pass a parameter (the reference to its parent object) to a method that was defined as having no parameters.</p>
<p>To actually make it work, you could append this to your class definition:</p>
<pre><code>method_two = staticmethod(method_two)
</code></pre>
<p>or you could use the <code>@staticmethod</code> <a href="https://docs.python.org/2/library/functions.html#staticmethod" rel="nofollow noreferrer">function decorator</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>method_two won't work because you're defining a member function but not telling it what the function is a member of. If you execute the last line you'll get:</p>
<pre><code>&gt;&gt;&gt; a_test.method_two()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: method_two() takes no arguments (1 given)
</code></pre>
<p>If you're defining member functions for a class the first argument must always be 'self'.</p>
</div>
<div class="post-text" itemprop="text">
<p>Accurate explanation from Armin Ronacher above, expanding on his answers so that beginners like me understand it well:</p>
<p>Difference in the methods defined in a class, whether static or instance method(there is yet another type - class method - not discussed here so skipping it), lay in the fact whether they are somehow bound to the class instance or not. For example, say whether the method receives a reference to the class instance during runtime</p>
<pre><code>class C:
    a = [] 
    def foo(self):
        pass

C # this is the class object
C.a # is a list object (class property object)
C.foo # is a function object (class property object)
c = C() 
c # this is the class instance
</code></pre>
<p>The <code>__dict__</code> dictionary property of the class object holds the reference to all the properties and methods of a class object and thus </p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo']
&lt;function foo at 0x17d05b0&gt;
</code></pre>
<p>the method foo is accessible as above. An important point to note here is that everything in python is an object and so references in the dictionary above are themselves pointing to other objects. Let me call them Class Property Objects - or as CPO within the scope of my answer for brevity.</p>
<p>If a CPO is a descriptor, then python interpretor calls the <code>__get__()</code> method of the CPO to access the value it contains.</p>
<p>In order to determine if a CPO is a descriptor, python interpretor checks if it implements the descriptor protocol. To implement descriptor protocol is to implement 3 methods</p>
<pre><code>def __get__(self, instance, owner)
def __set__(self, instance, value)
def __delete__(self, instance)
</code></pre>
<p>for e.g. </p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo'].__get__(c, C)
</code></pre>
<p>where </p>
<ul>
<li><code>self</code> is the CPO (it could be an instance of list, str, function etc) and is supplied by the runtime</li>
<li><code>instance</code> is the instance of the class where this CPO is defined (the object 'c' above) and needs to be explicity supplied by us</li>
<li><code>owner</code> is the class where this CPO is defined(the class object 'C' above) and needs to be supplied by us. However this is because we are calling it on the CPO. when we call it on the instance, we dont need to supply this since the runtime can supply the instance or its class(polymorphism)</li>
<li><code>value</code> is the intended value for the CPO and needs to be supplied by us</li>
</ul>
<p>Not all CPO are descriptors. For example </p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)
&lt;function C.foo at 0x10a72f510&gt; 
&gt;&gt;&gt; C.__dict__['a'].__get__(None, C)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute '__get__'
</code></pre>
<p>This is because the list class doesnt implement the descriptor protocol.</p>
<p>Thus the argument self in <code>c.foo(self)</code> is required because its method signature is actually this <code>C.__dict__['foo'].__get__(c, C)</code> (as explained above, C is not needed as it can be found out or polymorphed)
And this is also why you get a TypeError if you dont pass that required instance argument.</p>
<p>If you notice the method is still referenced via the class Object C and the binding with the class instance is achieved via passing a context in the form of the instance object into this function. </p>
<p>This is pretty awesome since if you chose to keep no context or no binding to the instance, all that was needed was to write a class to wrap the descriptor CPO and override its <code>__get__()</code> method to require no context. 
This new class is what we call a decorator and is applied via the keyword <code>@staticmethod</code></p>
<pre><code>class C(object):
  @staticmethod
  def foo():
   pass
</code></pre>
<p>The absence of context in the new wrapped CPO <code>foo</code> doesnt throw an error and can be verified as follows:</p>
<pre><code>&gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)
&lt;function foo at 0x17d0c30&gt;
</code></pre>
<p>Use case of a static method is more of a namespacing and code maintainability one(taking it out of a class and making it available throughout the module etc). </p>
<p>It maybe better to write static methods rather than instance methods whenever possible, unless ofcourse you need to contexualise the methods(like access instance variables, class variables etc). One reason is to ease garbage collection by not keeping unwanted reference to objects.</p>
</div>
<div class="post-text" itemprop="text">
<p>that is an error.</p>
<p>first of all, first line should be like this (be careful of capitals)</p>
<pre><code>class Test(object):
</code></pre>
<p>Whenever you call a method of a class, it gets itself as the first argument (hence the name self) and method_two gives this error </p>
<pre><code>&gt;&gt;&gt; a.method_two()
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: method_two() takes no arguments (1 given)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The second one won't work because when you call it like that python internally tries to call it with the a_test instance as the first argument, but your method_two doesn't accept any arguments, so it wont work, you'll get a runtime error.
If you want the equivalent of a static method you can use a class method.
There's much less need for class methods in Python than static methods in languages like Java or C#. Most often the best solution is to use a method in the module, outside a class definition, those work more efficiently than class methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>The call to method_two will throw an exception for not accepting the self parameter the Python runtime will automatically pass it.</p>
<p>If you want to create a static method in a Python class, decorate it with the <code>staticmethod decorator</code>.</p>
<pre><code>Class Test(Object):
  @staticmethod
  def method_two():
    print "Called method_two"

Test.method_two()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please read this docs from the Guido <a href="http://python-history.blogspot.in/2009/02/first-class-everything.html" rel="nofollow">First Class everything</a> Clearly explained how Unbound, Bound methods are born.</p>
</div>
<div class="post-text" itemprop="text">
<p>The definition of <code>method_two</code> is invalid. When you call <code>method_two</code>, you'll get <code>TypeError: method_two() takes 0 positional arguments but 1 was given</code> from the interpreter. </p>
<p>An instance method is a bounded function when you call it like <code>a_test.method_two()</code>. It automatically accepts <code>self</code>, which points to an instance of <code>Test</code>, as its first parameter. Through the <code>self</code> parameter, an instance method can freely access attributes and modify them on the same object.</p>
</div>
<span class="comment-copy">No difference other than method_two() definition is invalid and its call fails.</span>
<span class="comment-copy">@techtonik: Nothing is wrong with the definition of the method_two! It's being called in an incorrect/invalid spec, i.e. with an extra argument.</span>
<span class="comment-copy">Yours are both <b>instance methods</b>, not class methods. You create a <a href="https://docs.python.org/3/library/functions.html?highlight=classmethod#classmethod" rel="nofollow noreferrer">class method</a> by applying <code>@classmethod</code> to the definition. The first parameter should be called <code>cls</code> instead of <code>self</code> and will receive the class object rather than an instance of your class: <code>Test.method_three()</code> and <code>a_test.method_three()</code> are equivalent.</span>
<span class="comment-copy">Why would you want to create a function definition without the <code>self</code> argument? Is there a strong use case for this?</span>
<span class="comment-copy">I support this answer, it is superior to mine. Well done Torsten :)</span>
<span class="comment-copy">More Reading on Decorators: <a href="http://www.python.org/dev/peps/pep-0318/" rel="nofollow noreferrer">python.org/dev/peps/pep-0318</a></span>
<span class="comment-copy">in python 3 unbound methods are deprecated. instead there is just a function.</span>
<span class="comment-copy">@boldnik, why do you say unbound methods are deprecated? static methods are still present in the documentation: <a href="https://docs.python.org/3/library/functions.html#staticmethod" rel="nofollow noreferrer">docs.python.org/3/library/functions.html#staticmethod</a></span>
<span class="comment-copy"><i>The <code>staticmethod</code> decorator wraps your class (...)</i> This phrase is a bit misleading as the class which is being wrapped is the class <b>of</b> the method <code>foo</code> and not the class in which <code>foo</code> is defined.</span>
<span class="comment-copy"><code>Class.instance_method() # The class cannot use an instance method</code> it can use. Just pass the instance manually: <code>Class.instance_method(a)</code></span>
<span class="comment-copy">@warwaruk It's there, look at the line below the <code>TyeError</code> line.</span>
<span class="comment-copy">yes i saw it later. still, imo, it's not correct to say 'The class cannot use an instance method', because you just did it one line below.</span>
<span class="comment-copy">@kzh, Thanks for your explanation. When you called <code>a.class_method()</code>, it seems <code>a.c</code> got updated to <code>1</code>, so the call the <code>Class.class_method()</code>, updated the <code>Class.c</code> variable to <code>2</code>. However, when you assigned <code>a.c=5</code>, why did <code>Class.c</code> not get updated to <code>5</code>?</span>
<span class="comment-copy">@alpha_989 python first looks for an attribute directly on an ovjects own instance first and if it is not there, it looks for it on its class by default. If you have any other questions about this, please feel free to open a question and link it here and I would be happy to help further.</span>
<span class="comment-copy">You mean "the @staticmethod function decorator syntax".</span>
<span class="comment-copy">If I define a function   <code>Class Test(object): 	@staticmethod 	def method_two(): 		print(“called method_two”)</code>  One use case, I was thinking of is when you want the function to be a part of a class, but don’t want the user to access the function directly. So the <code>method_two</code> can be called by other functions inside the <code>Test</code> instance, but cant be called using <code>a_test.method_two()</code>. If I use <code>def method_two()</code>, will this work for this use case? Or is there a better way to modify the function definition, so it works as intended for the above use case?</span>
<span class="comment-copy">That won't work either, you have to omit self then.</span>
<span class="comment-copy">You're correct. Was too quick with copy-paste. Fixed it.</span>
