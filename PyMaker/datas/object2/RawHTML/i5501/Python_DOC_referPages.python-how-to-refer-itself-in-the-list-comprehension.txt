<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/21112814/is-it-possible-to-access-current-object-while-doing-list-dict-comprehension-in-p">Is it possible to access current object while doing list/dict comprehension in Python?</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
</ul>
</div>
<pre><code>lsit_a = [2, 4, 3, 6, 3, 8, 5]
</code></pre>
<p>list comprehension is very useful.</p>
<pre><code>list_b = [a**2 for a in list_a]
</code></pre>
<p>I want to know how to write a self-reference in the python list comprehension.</p>
<p>for example -</p>
<pre><code>list_c = [a**2 if i == 0 else a*2 + (itself[i-1]) for i, a in enumurate(list_a)]
</code></pre>
<p>how to write the part of <code>itself[i-1]</code>?</p>
<h1>ADD</h1>
<p>Sorry, my explain is bad...</p>
<p>I want to get the list by a high-speed way.</p>
<h2>input list</h2>
<p>list_a = [0,0,1,0,0,0,1,0,0,1,0]</p>
<h2>output list</h2>
<p>list_c = [0, 0, 1, 0.9, 0.8, 0.7, 1, 0.9, 0.8, 1, 0.9]</p>
<p>like a saw tooth list.</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehension is meant to be a compact expression for the most straightforward use cases. You cannot reference the list itself in list comprehension, for that just use a regular for-loop:</p>
<pre><code>list_c = []
for i, a in enumerate(list_a):
    if i == 0:
        list_c.append(a ** 2)
    else:
        list_c.append(a * 2 + list_c[i-1])
</code></pre>
<p>You can also rewrite that loop in a more efficient way:</p>
<pre><code>list_a_iterator = iter(list_a)
list_c = [next(list_a_iterator) ** 2]  # May raise StopIteration if list_a is empty
for item in list_a_iterator:
    list_c.append(item * 2 + list_c[-1])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You cannot reference a list before it is created. However, you can use this hacky <code>reduce</code> approach if you desperately want a one-liner:</p>
<pre><code>list_c = reduce(lambda lst, a: lst + [lst[-1] + a**2], list_a, [0])[1:]
</code></pre>
<p>And in Python &gt; 3.2, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a>:</p>
<pre><code>from itertools import accumulate
list_c = list(accumulate(a**2 for a in list_a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can access <code>list_a</code> from your comprehension:</p>
<pre><code>[a**2 if i == 0 else a*2 + list_a[i-1]**2 if i == 1 else a*2 + list_a[i-1]*2 for i, a in enumerate(list_a)]
</code></pre>
</div>
<span class="comment-copy">What is <code>itself</code> supposed to be a reference to? The as-yet uncompleted list comprehensionâ€¦?!</span>
<span class="comment-copy">What makes you think that this is possible?</span>
<span class="comment-copy">@deceze <code>list_c</code> I guess..</span>
<span class="comment-copy">You cannot refer to things that <b>do not exist</b> yet. And <code>list_c</code> does not exist inside the list-comprehension that <i>creates it</i>. You have to go with a for-loop here or find a mathematical way to re-write your comprehension that only references objects that exist</span>
<span class="comment-copy">People are mocking this question but it is perfectly reasonable, and I would go so far as to say that Python <i>should</i> allow self-referential list comprehensions-I'm sure there are reasons why this isn't supported, but a priori this seems like a perfectly reasonable feature to have in a language (Haskell, for example, supports this...).    The snarky comments are unwarranted.</span>
<span class="comment-copy">Thank you! I don't know itertools. I will try to learn this library.</span>
