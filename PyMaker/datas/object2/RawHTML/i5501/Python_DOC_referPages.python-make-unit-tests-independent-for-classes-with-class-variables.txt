<div class="post-text" itemprop="text">
<p>I have a class with a dictionary that is used to cache response from server for a particular input. Since this is used for caching purpose, this is kept as a class variable.</p>
<pre><code>class MyClass:
    cache_dict = {}

    def get_info_server(self, arg):
        if arg not in self.cache_dict:
            self.cache_dict[arg] = Client.get_from_server(arg)
        return cache_dict[arg]

    def do_something(self, arg):
        # Do something based on get_info_server(arg)
</code></pre>
<p>And when writing unit tests, since the dictionary is a class variable, the values are cached across test cases. </p>
<h3>Test Cases</h3>
<pre><code># Assume that Client is mocked.

def test_caching():
    m = MyClass()
    m.get_info_server('foo')
    m.get_info_server('foo')
    mock_client.get_from_server.assert_called_with_once('foo')

def test_do_something():
    m = MyClass()
    mock_client.get_from_server.return_value = 'bar'
    m.do_something('foo') # This internally calls get_info_server('foo')
</code></pre>
<p>If <code>test_caching</code> executes first, the cached value will be some mock object. If <code>test_do_something</code> executes first, then the assertion that the test case is called exactly once will fail.</p>
<p>How do I make the tests independent of each other, <strong>besides manipulating the dictionary directly</strong> (since this is like requiring intimate knowledge of the inner working of the code. what if the inner working were to change later. All I need to verify is the API itself, and not rely on the inner workings)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't really avoid resetting your cache here. If you are <em>unittesting</em> this class, then your unittest will need to have an intimate knowledge of the inner workings of the class, so <em>just reset the cache</em>. You rarely can change how your class works without adjusting your unittests anyway.</p>
<p>If you feel that that still will create a maintenance burden, then make cache handling explicit by adding a class method:</p>
<pre><code>class MyClass:
    cache_dict = {}

    @classmethod
    def _clear_cache(cls):
        # for testing only, hook to clear the class-level cache.
        cls.cache_dict.clear()
</code></pre>
<p>Note that I still gave it a name with a leading underscore; this is not a method that a 3rd party should call, it is only there for tests. But now you have centralised clearing the cache, giving you control over how it is implemented.</p>
<p>If you are using the <code>unittest</code> framework to run your tests, clear the cache before each test in a <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp" rel="nofollow noreferrer"><code>TestCase.setUp()</code> method</a>. If you are using a different testing framework, that framework will have a similar hook. Clearing the cache <em>before</em> each test ensures that you always have a clean state.</p>
<p>Do take into account that your cache is <em>not thread safe</em>, if you are running tests in parallel with threading you'll have issues here. Since this also applies to the cache implementation itself, this is probably not something you are worried about right now.</p>
</div>
<div class="post-text" itemprop="text">
<p>You didn't put it in the question explicitly, but I'm assuming your test methods are in a subclass of <code>unittest.TestCase</code> called <code>MyClassTests</code>.</p>
<p>Explicitly set <code>MyClass.cache_dict</code> in the method under test.  If it's just a dictionary, without any getters / setters for it, you don't need a Mock.</p>
<p>If you want to guarantee that every test method is independent, set <code>MyClass.cache_dict = {}</code> in <code>MyClassTests.setup()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to make use of Python's built in UnitTest TestCase and implement setup and teardown methods.</p>
<p>If you define <code>setUp()</code> and <code>tearDown()</code> in your tests, these will execute each time one of the single test methods gets called (before and after, respectively)</p>
<p>Example:</p>
<pre><code># set up any global, consistent state here

# subclass unit test test case here.

def setUp(self):
  # prepare your state if needed for each test, if this is not considered "fiddling", use this method to set your cache to a fresh state each time
  your_cache_dict_variable = {}

### Your test methods here

def tearDown(self):
  # this will handle resetting the state, as needed
</code></pre>
<p>Check out the docs for more info: <a href="https://docs.python.org/2/library/unittest.html" rel="nofollow noreferrer">https://docs.python.org/2/library/unittest.html</a></p>
</div>
<div class="post-text" itemprop="text">
<p>One thing I can suggest is to use <code>setUp()</code> and <code>tearDown()</code> methods in your test class.</p>
<pre><code>from unittest import TestCase

class MyTest(TestCase):
    def setUp(self):
        self.m = MyClass()
        //anything else you need to load before testing

    def tearDown(self):
        self.m = None

    def test_caching(self):
        self.m.get_info_server('foo')
        self.m.get_info_server('foo')
        mock_client.get_from_server.assert_called_with_once('foo')
</code></pre>
</div>
<span class="comment-copy">Fiddle with the dictionary directly. That, or add cache support methods to the class and have those methods fiddle with the dictionary.</span>
<span class="comment-copy">Your unittest is allowed to have that intimate knowledge. If you want to make it more formal, add a classmethod that clears the cache.</span>
<span class="comment-copy">I think you mean to use <code>self.cache_dict</code> in your <code>get_info_server</code> method?</span>
<span class="comment-copy">@JacobIRR Yes <code>get_info_server</code> uses cache_dict, but the test cases should not rely on that piece of information for testing. How to write test cases without that was the question itself. Please correct the question if it is not clear enough.</span>
<span class="comment-copy">@MartijnPieters That works for me. Can you post it as an answer? Will mark it as the correct one.</span>
<span class="comment-copy">That still requires 'fiddling' with the class attribute dictionay.</span>
<span class="comment-copy">@MartijnPieters - that dictionary can be global if it needs to persist, or temporal (inside the test case class) if it needs to be refreshed. This solution allows for both scenarios to work.</span>
<span class="comment-copy">I doubt that the problem is knowing where to reset the cache. The OP still needs to reset the cache.</span>
<span class="comment-copy">And he can do so in the setup or teardown methods since those get called for each test</span>
<span class="comment-copy">But that's the whole point of the question, is <i>how to handle an inner implementation detail like a cache</i>.</span>
<span class="comment-copy">This still retains the cache. Creating a new instance won't clear it.</span>
