<div class="post-text" itemprop="text">
<p>Recently, when creating a loop with a very short wait at the end, I ran into an unexpected behaviour of <code>time.sleep()</code> when used in quick succession.</p>
<p>I used this piece of code to look further into my problem</p>
<pre><code>import time
import statistics

def average_wait(func):
    waits=[]
    loops=0

    while loops&lt;1000:
            start=time.time()
            func(1/1000)
            waits.append(time.time()-start)
            loops+=1
    print(waits)
    print("Average wait for 0.001: {}".format(statistics.mean(waits)))

average_wait(time.sleep)
</code></pre>
<p>This function usually returns something around 0.0013 which is many many times less accurate than just calling <code>time.sleep()</code> once, upon further inspection of this problem by looking at the <code>waits</code> list, I found that the amount of time <code>time.sleep()</code> was actually sleeping for was either almost exactly the right amount of time or almost exactly double the amount of time. </p>
<p>Here is a sample from <code>waits</code>: 
<code>[0.0010008811950683594, 0.0020041465759277344, 0.0009999275207519531, 0.0019621849060058594, 0.0010418891906738281]</code></p>
<p>Is there any reason for this behaviour and anything that can be done to avoid it?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/time.html#time.time" rel="nofollow noreferrer"><code>time.time()</code> documentation</a>:</p>
<blockquote>
<p>Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second.</p>
</blockquote>
<p>The precision is platform dependent. Moreover, it produces wall-clock time, and your process is never the only thing running on a modern OS, other processes <em>also</em> are given time to process and you'll see variation in timings in your own process because of that.</p>
<p>The module offers different clocks, with more precision and some are per-process. See the <a href="https://docs.python.org/3/library/time.html#time.get_clock_info" rel="nofollow noreferrer"><code>time.get_clock_info()</code> function</a> to see what precision they offer. Note <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="nofollow noreferrer"><code>time.process_time()</code></a> offers per-process time but excludes sleep time.</p>
<p>Next, <code>time.sleep()</code> is also not going to sleep in exact time spans; again from the <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow noreferrer">relevant documentation</a>:</p>
<blockquote>
<p>[T]he suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</p>
</blockquote>
<p>It too is subject to OS scheduling.</p>
<p>Together, these effects can easily add up to the millisecond variation in timings you see in your experiments. So this is not a doubling of time slept; even if you used different values for <code>time.sleep()</code> you'd still see a similar deviation from the requested time.</p>
</div>
<span class="comment-copy">I'm using Windows 10 and I can confirm that the precision offered by time.sleep is definitely better than 1 second so that isn't the problem, as for other processes being allocated processing time. I understand this however I would assume that this would just add a small element of randomness, however in this situation the small deviation is not the problem rather the HUGE deviation of sometimes randomly being double</span>
<span class="comment-copy">@froog: you are dealing in milliseconds here. It is absolutely possible for other processes to be active for a millisecond before the OS returns control to your process.</span>
<span class="comment-copy">@froog If you're on Windows, it also has a pretty extreme and variable CPU throttling approach in some power settings, even if you're on a PC and not a laptop. Go into Control Panel --&gt; Power Options and check that it's set at High Performance (at least in Windows 7 that was the way). Not having unrestricted CPU performance can mess up <code>timeit</code> too giving very variable results.</span>
<span class="comment-copy">I see what you mean now, I was thinking of it as the time being doubled instead of an extra millisecond being added on, I'll try it again with 1/100 and 1/10 of a second and see if the results are repeated</span>
<span class="comment-copy">@froog: I'd not count on sleep being that precise. And note that the <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow noreferrer"><code>time.sleep()</code> documentation</a> warns: <i>Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system</i>.</span>
