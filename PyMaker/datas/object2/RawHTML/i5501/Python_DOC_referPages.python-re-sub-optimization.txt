<div class="post-text" itemprop="text">
<p>I have a python list with each string being one of the following 4 possible options like this (of course the names would be different):</p>
<pre><code>Mr: Smith\n
Mr: Smith; John\n
Smith\n
Smith; John\n
</code></pre>
<p>I want these to be corrected to:</p>
<pre><code>Mr,Smith,fname\n
Mr,Smith,John\n
title,Smith,fname\n
title,Smith,John\n
</code></pre>
<p>Easy enough to do with 4 re.sub():</p>
<pre><code>with open ("path/to/file",'r') as fileset:
    dataset = fileset.readlines()
for item in dataset:
    dataset = [item.strip() for item in dataset]    #removes some misc. white noise
    item = re.sub((.*):\W(.*);\W,r'\g&lt;1&gt;'+','+r'\g&lt;2&gt;'+',',item)
    item = re.sub((.*);\W(.*),'title,'+r'\g&lt;1&gt;'+','+r'\g&lt;2&gt;',item)
    item = re.sub((.*):\W(.*),r'\g&lt;1&gt;'+','+r'\g&lt;2&gt;'+',fname',item)
    item = re.sub((*.),'title,'+r'\g&lt;1&gt;'+',fname',item)
</code></pre>
<p>While this is fine for the dataset I'm using, I want to be more efficient.<br/>
Is there a single operation that can simplify this process?</p>
<p>Please pardon if I forgot a quote or some such; I'm not at my workstation now and I'm aware I've stripped the newline (<code>\n</code>).</p>
<p>Thank you, </p>
</div>
<div class="post-text" itemprop="text">
<h2>Brief</h2>
<p>Instead of running two loops, you can reduce it to just one line. Adapted from <a href="https://stackoverflow.com/questions/5733419/how-to-iterate-over-the-file-in-python">How to iterate over the file in Python</a> (and using the code in my <strong>Code</strong> section):</p>
<pre><code>f = open("path/to/file",'r')
while True:
    x = f.readline()
    if not x: break
    print re.sub(r, repl, x)
</code></pre>
<p>See <a href="https://stackoverflow.com/questions/6186938/python-how-to-use-regexp-on-file-line-by-line-in-python">Python - How to use regexp on file, line by line, in Python</a> for other alternatives.</p>
<hr/>
<h2>Code</h2>
<p>For viewing sake I've changed your file to an array.</p>
<p><a href="https://regex101.com/r/ugEqGB/1" rel="nofollow noreferrer">See regex in use here</a></p>
<pre><code>^(?:([^:\r\n]+):\W*)?([^;\r\n]+)(?:;\W*(.+))?
</code></pre>
<p><strong>Note:</strong> You don't need all that in python, I do in order to show it on regex101, so your regex would actually just be <code>^(?:([^:]+):\W*)?([^;]+)(?:;\W*(.+))?</code></p>
<h3>Usage</h3>
<p><a href="https://ideone.com/kbrRdG" rel="nofollow noreferrer">See code in use here</a></p>
<pre><code>import re

a = [
    "Mr: Smith",
    "Mr: Smith; John",
    "Smith",
    "Smith; John"
]
r = r"^(?:([^:]+):\W*)?([^;]+)(?:;\W*(.+))?"

def repl(m):
    return (m.group(1) or "title" ) + "," + m.group(2) + "," + (m.group(3) or "fname")

for s in a:
    print re.sub(r, repl, s)
</code></pre>
<hr/>
<h2>Explanation</h2>
<ul>
<li><code>^</code> Assert position at the start of the line</li>
<li><code>(?:([^:]+):\W*)?</code> Optionally match the following

<ul>
<li><code>([^:]+)</code> Capture any character except <code>:</code> one or more times into capture group 1</li>
<li><code>:</code> Match this literally</li>
<li><code>\W*</code> Match any number of non-word characters (copied from OP's original code, I assume <code>\s*</code> can be used instead)</li>
</ul></li>
<li><code>([^;]+)</code> Group any character except <code>;</code> one or more times into capture group 2</li>
<li><code>(?:;\W*(.+))?</code> Optionally match the following

<ul>
<li><code>;</code> Match this literally </li>
<li><code>\W*</code> Match any number of non-word characters (copied from OP's original code, I assume <code>\s*</code> can be used instead)</li>
<li><code>(.+)</code> Capture any character one or more times into capture group 3</li>
</ul></li>
</ul>
<p>Given the above explanation of the regex part. The <code>re.sub(r, repl, s)</code> works as follows:</p>
<ul>
<li><code>repl</code> is a callback to the <code>repl</code> function which returns:

<ul>
<li><code>group 1</code> if it captured anything, <code>title</code> otherwise</li>
<li><code>group 2</code> (it's supposedly always set - using OP's logic here again)</li>
<li><code>group 3</code> if it captured anything, <code>fname</code> otherwise</li>
</ul></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>IMHO, RegEx are just too complex here, you can use classic string function to split your string <em>item</em> in chunks. For that, you can use <a href="https://docs.python.org/3/library/stdtypes.html#str.partition" rel="nofollow noreferrer"><code>partition</code></a> (or <a href="https://docs.python.org/3/library/stdtypes.html#str.rpartition" rel="nofollow noreferrer"><code>rpartition</code></a>).</p>
<p>First, split your <em>item</em> string in "records", like that:</p>
<pre><code>item = "Mr: Smith\n Mr: Smith; John\n Smith\n Smith; John\n"
records = item.splitlines()
# -&gt; ['Mr,Smith,fname', 'Mr,Smith,John', 'title,Smith,fname', 'title,Smith,John']
</code></pre>
<p>Then, you can create a short function to normalize each "record".
Here is an example:</p>
<pre><code>def normalize_record(record):
    # type: (str) -&gt; str
    name, _, fname = record.partition(';')
    title, _, name = name.rpartition(':')
    title = title.strip() or 'title'
    name = name.strip()
    fname = fname.strip() or 'fname'
    return "{0},{1},{2}".format(title, name, fname)
</code></pre>
<p>This function is easier to understand than a collection of RegEx. And, in most case, it is faster.</p>
<p>For a better integration, you can define another function to handle each <em>item</em>:</p>
<pre><code>def normalize(row):
    records = row.splitlines()
    return "\n".join(normalize_record(record) for record in records) + "\n"
</code></pre>
<p>Demo:</p>
<pre><code>item = "Mr: Smith\n Mr: Smith; John\n Smith\n Smith; John\n"
item = normalize(item)
</code></pre>
<p>You get:</p>
<pre><code>'Mr,Smith,fname\nMr,Smith,John\ntitle,Smith,fname\ntitle,Smith,John\n'
</code></pre>
</div>
<span class="comment-copy">Compiling the regexes in advance helps because it can cache the state machines it generates. Backreferences can be slow as well.</span>
<span class="comment-copy">Question: what do you want to do <i>in fine</i> with your dataset? Do you want to write a new (corrected) file?</span>
<span class="comment-copy">What's this logic with <code>for item in dataset:</code>? You have a double, nested loop.</span>
<span class="comment-copy">@Beefster: The difference is often negligible with a compiled regex because the string regex gets compiled and stored in cache anyway.</span>
<span class="comment-copy">In fine I will be inserting to a database but that is a couple of steps out. shorter term I will be using the information to get data from a mix of web pages.</span>
<span class="comment-copy">Yes, even if your suggestion reduces four patterns to only one (that will probably speed up the code), note that the main problem in his code are not the patterns but the redundant and nested loops.</span>
<span class="comment-copy">I think he has a typo: there should have been <code>with</code>, instead of <code>while</code> on the line where he opens the file, and next line reads all lines from file with <code>readlines</code></span>
<span class="comment-copy">Good job, but without to be an expert in python good practises, I think that Mike Pennington design (see your other alternatives link) is less old school than the one you suggested. Something like <a href="https://tio.run/##Pco9CsAgDEDhvafIpoLUoVtv00LEgMQQU0pPb3@GfuPjyWWl8TLGSVagCbJ3sllJ1lKmii6CUxdg65DLOsEjN4VKjED8t5cosXnFuR@71wiKUuN3zt2UxIcwxg0" rel="nofollow noreferrer">this</a></span>
<span class="comment-copy">And regex patterns would be more complex than that?</span>
<span class="comment-copy">Obviously, have you taken a look at the accepted answer?</span>
<span class="comment-copy">Yes, although it's not laid out well and it's longer than necessary. I understand how regular expressions can be an anathema, but I spent ten years writing Python and another eight with Perl and its built-in regex engine. I would now far rather read the regex solution than your cryptic Python.</span>
