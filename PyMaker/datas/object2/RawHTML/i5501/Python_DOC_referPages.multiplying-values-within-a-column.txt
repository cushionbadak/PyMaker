<div class="post-text" itemprop="text">
<p>I'm using sqlite3 through python 2.7. </p>
<p>I have a table where I would like to multiply values in column C where column B is the same. </p>
<p>If these values were in different columns it would be a lot more simple 
I could just use</p>
<p><code>SELECT B, C1 *C2 FROM table1;</code></p>
<p>But I am lost when it comes to multiplying within a column.</p>
<p>For example if this is original table</p>
<pre><code>A   B      C
1   Mike   2.5
1   Susan  4.2
1   Patti  2.0
2   Susan  1.1
2   Patti  3.7
3   Mike   0.2
</code></pre>
<p>Then where the entrys in column B are the same, their values in column C are multiplied together, so my output would be </p>
<pre><code>A      B
Mike   0.5
Susan  4.62
Patti  7.4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As pointed out in the comments, it is very difficult to create an aggregate function for multiplication in SQLite. However, you can work around it by using <code>itertools.groupby</code> to perform the combination and multiplication operations and then create a new table. This answer utilizes a context manager and property decorators to create a clean class call:</p>
<pre><code>import sqlite3
import itertools
class UpdateTable:
   def __init__(self, *args):
     self.__dict__ = dict(zip(['table', 'filename'], args))
     self.new_table = None
   @property
   def newtable(self):
      return self.new_table
   @newtable.setter
   def newtable(self, new_table_name):
      self.new_table = new_table_name
   def __enter__(self):
       data = map(lambda (a, b, c):[b, float(c)], list(sqlite3.connect(self.filename).cursor().execute('SELECT * FROM {}'.format(self.table))))
       self.new_data = [(a, reduce(lambda x, y:x[-1]*y[-1], list(b))) for a, b in itertools.groupby(sorted(data, key=lambda x:x[0]), key=lambda x:x[0])]
       return self
   def __exit__(self):
       conn = sqlite3.connect(self.filename)
       conn.execute('CREATE TABLE {} (A text, B float)'.format(self.new_table))
       conn.executemany('INSERT INTO {} VALUES (?, ?)'.format(self.new_table), self.new_data)
       conn.commit()
       conn.close()


with UpdateTable('table', 'db_file.db') as t:
   t.newtable = 'table2'
</code></pre>
<p>Python3 requires <code>functools</code> for <code>reduce</code> and is not compatible with lambda tuple unpacking.</p>
<p><strong>Python3 version:</strong></p>
<pre><code>import functools
import sqlite3
import itertools
class UpdateTable:
   def __init__(self, *args):
     self.__dict__ = dict(zip(['table', 'filename'], args))
     self.new_table = None
   @property
   def newtable(self):
      return self.new_table
   @newtable.setter
   def newtable(self, new_table_name):
      self.new_table = new_table_name
   def __enter__(self):
      data = map(lambda x:[x[1], float(x[-1])], list(sqlite3.connect(self.filename).cursor().execute('SELECT * FROM {}'.format(self.table))))
      self.new_data = [(a, functools.reduce(lambda x, y:x[-1]*y[-1], list(b))) for a, b in itertools.groupby(sorted(data, key=lambda x:x[0]), key=lambda x:x[0])]
      return self
   def __exit__(self):
      conn = sqlite3.connect(self.filename)
      conn.execute('CREATE TABLE {} (A text, B float)'.format(self.new_table))
      conn.executemany('INSERT INTO {} VALUES (?, ?)'.format(self.new_table), self.new_data)
      conn.commit()
      conn.close()


with UpdateTable('table', 'db_file.db') as t:
   t.newtable = 'table2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using just Python, have a look at <a href="https://stackoverflow.com/questions/24696351/aggregate-in-sqlite-or-python#24696815">this answer</a>. You can sort your query by column <code>B</code>, and then use <a href="https://docs.python.org/3/library/itertools.html?highlight=itertools%20groupby#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to group the results of your query into packets which you then process using <a href="https://docs.python.org/2.7/library/functions.html#reduce" rel="nofollow noreferrer">the <code>reduce</code> built-in</a>:</p>
<pre><code>curs.execute("SELECT id, user, number FROM table WHERE condition() ORDER BY user")

for person, group in itertools.groupby(curs.fetchall(), lambda row: row[1]):
    product = reduce((lambda a,b: a*b), [r[2] for r in group])
    do_something_with(person, product)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way by using group_concat() with a convenient delimiter:</p>
<pre><code>import sqlite3

db = sqlite3.connect(':memory:')
db.execute('create table t(A,B,C)')
db.execute('''
insert into t values
  (1,'Mike',2.5),
  (1,'Susan',4.2),
  (1,'Patti',2.0),
  (2,'Susan',1.1),
  (2,'Patti',3.7),
  (3,'Mike',0.2)
''')

for b,expr in db.execute('''select b,group_concat(c,'*') from t group by b'''):
  #print(f'{b:10s} {eval(expr):5.2f}')            #Python 3.6
  print('%-10s %5.2f' % (b,eval(expr)))            #Python 2.7
</code></pre>
</div>
<span class="comment-copy">This needs a <code>PRODUCT()</code> aggregate function (like <code>SUM()</code>, but multiplies instead of adding), but there isn't such a thing.</span>
<span class="comment-copy">See <a href="https://www.sqlite.org/c3ref/create_function.html" rel="nofollow noreferrer">sqlite.org/c3ref/create_function.html</a> for how to create custom aggregate functions in SQLite.</span>
<span class="comment-copy">I tried this way but I get the error 'can't multiply sequence by non-int of type 'str''</span>
<span class="comment-copy">You mean you copy pasted the above code and got an error?  It works for me under Python 2.7 and Python 3.6 giving the expected answer.  Try adding a <code>print(expr)</code> right under the <code>for</code> and see if there is anything unexpected in the expression (in which case you need to correct your data).  The only way I could get a similar error as you said is if any value in column C contains <b>nested</b> quotes, e.g., <code>(3,'Mike',"  '0.2' ")</code></span>
<span class="comment-copy">I'm wrong, I was rephrasing it into my own code but yours works fine.</span>
