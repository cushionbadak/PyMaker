<div class="post-text" itemprop="text">
<pre><code>Python 3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time() - time.time()
0.0
</code></pre>
<p>Why is this the case? From my simple understanding, this function returns the system clock in seconds since the epoch at the exact time of the call. But shouldn't the two calls to time.time() return slightly different floats?</p>
</div>
<div class="post-text" itemprop="text">
<p>The resolution of the timer isn't unlimited; it goes up by small amounts periodically. If the two calls are close enough together, you will see a zero value. If you tried a large number of such calls, you would probably find that the difference is zero most of the time, and some number of microseconds the rest of the time, depending on your particular system's speed, hardware details, and kernel implementation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Per the <a href="https://docs.python.org/3/library/time.html#time.time" rel="nofollow noreferrer">docs on <code>time.time</code></a>:</p>
<blockquote>
<p>... even though the time is always returned as a floating point number, <strong>not all systems provide time with a better precision than 1 second</strong>.</p>
</blockquote>
<p>(my emphasis). For Python3.3+ use <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer"><code>time.perf_counter</code></a> instead.
Or for Python3.2 or older, or for backwards compatibility, use
<a href="https://docs.python.org/3.2/library/timeit.html#timeit.default_timer" rel="nofollow noreferrer"><code>timeit.default_timer</code></a>, which attempts to pick the most accurate clock for your
system.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not Always, just depends on your cpu scheduling and the clock:</p>
<pre><code>n, d = 0, 0.0
while d == 0.0:
     d = time.time() - time.time()
     n += 1
print(n, d)

26096 -0.0010001659393310547
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's time.time() generates the amount of time since the epoch, measured in thirds of a microsecond, a unit I like to call deltas. This means there are 3 million deltas in every second. </p>
<p>Like a clock only reports time to the nearest second, python will only report time to the nearest delta. So if your code can complete before the time moves onto the next delta, it will report as 0.0!</p>
</div>
<span class="comment-copy">I've got another result <code>&gt;&gt;&gt;&gt; time() - time() -1.9073486328125e-06</code>. Maybe your computer is too fast (:</span>
<span class="comment-copy">Is it 0.0 every run?</span>
<span class="comment-copy">By the way, doing <code>[time.time() for _ in range(50)]</code> generates about ~11 unique timestamps on my machine.</span>
<span class="comment-copy">it depends on the time slices the operating system uses. <code>time.time() - time.time() -&gt; -9.5367431640625e-07</code>.</span>
<span class="comment-copy">I tried this on Python 2 and got 0.0 result about 1 out of every 3-4 tries.  But I tried 20+ times on Python 3 and never got 0.0.</span>
<span class="comment-copy">Thank you, I believe <b>close enough together</b> is what is happening in my case.</span>
<span class="comment-copy">Do you happen to know which systems do not provide better precision that 1 second?</span>
<span class="comment-copy">@JacobLee: I'm not sure if this is what the docs are referring to, but depending on how Windows is configured, it <a href="https://docs.microsoft.com/en-us/windows-server/networking/windows-time-service/support-boundary" rel="nofollow noreferrer">may only provide 1 second accuracy</a>. (That link was found via, <a href="https://stackoverflow.com/questions/27253216/configure-windows-time-with-high-sub-seconds-precision">this question</a>.)</span>
<span class="comment-copy">Thanks for looking into that. The accuracy of a measured interval t2 - t1 will depend on the stability of the clock and the clock's precision or resolution (the smallest time increment), but not on whether time1 and time2 "true" clock times wrt an authoritative clock. Of course, Python could run on a wide variety of systems, and time.time() depends on the system dependent C program of that name, so it could just be an open-ended caveat.</span>
<span class="comment-copy">Thank you, I think this function is the best way I could have understood what was happening.</span>
