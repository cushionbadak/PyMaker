<div class="post-text" itemprop="text">
<p>I was reading an interesting post on <a href="https://stackoverflow.com/questions/2580136/does-python-support-short-circuiting">Short-Circuiting in Python</a> and wondered if this was true for the <code>in</code> operator. My simple testing would conclude that it does not:</p>
<pre><code>%%timeit -n 1000
0 in list(range(10))
1000 loops, best of 3: 639 ns per loop

%%timeit -n 1000
0 in list(range(1000))
1000 loops, best of 3: 23.7 µs per loop
# larger the list, the longer it takes. however, i do notice that a higher 
# value does take longer.

%%timeit -n 1000
999 in list(range(1000))
1000 loops, best of 3: 45.1 µs per loop
</code></pre>
<p>Is there a detailed explanation of why <code>999</code> takes longer than <code>0</code>. Is the <code>in</code> operator like a loop?</p>
<p>Also, is there a way to tell the <code>in</code> operator to "stop the loop" once the value is found (or is this the already defaulted behavior that I'm not seeing)? </p>
<p>Lastly- Is there another operator/function that I am skipping over that does what I'm talking about in regards to "short-circuiting" <code>in</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The implementation of <code>in</code> for <code>list</code> objects is found in <a href="https://github.com/python/cpython/blob/ce5b0e9db1b9698e6ffc43ae41cf3a22ca5a6ba6/Objects/listobject.c#L398" rel="nofollow noreferrer"><code>list_contains</code></a>. It performs a scan of the list and does exit early if the last comparison has found the element, there's no point in continuing there. </p>
<p>The loop involved is:</p>
<pre><code>for (i = 0, cmp = 0 ; cmp == 0 &amp;&amp; i &lt; Py_SIZE(a); ++i)
    cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),
                                       Py_EQ);
</code></pre>
<p>If <code>cmp</code> is <code>1</code> (the value returned from <a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool" rel="nofollow noreferrer"><code>PyObject_RichCompareBool</code></a> for a match), the <code>for</code> loop condition (<code>cmp == 0 &amp;&amp; i &lt; Py_SIZE(a)</code>) becomes false and terminates.</p>
<p>For list objects, which are built-in, what is called for <code>in</code> is a <code>C</code> function (for CPython). For other implementations of Python, this can be a different language using different language constructs. </p>
<p>For user-defined classes in Python, what is called is defined in the <a href="https://docs.python.org/3.7/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">Membership test operations</a> of the Reference Manual, take a look there for a run-down of what gets called.</p>
<hr/>
<p>You could also come to this conclusion by timing:</p>
<pre><code>l = [*range(1000)]    
%timeit 1 in l
85.8 ns ± 11.9 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
%timeit 999 in l
22 µs ± 221 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<p>The furthest the element the more you need to scan. If it didn't short-circuit, all <code>in</code> operations would result in similar timings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Short circuiting does occur. The <code>in</code> operator calls the <code>__contains__</code> method, which in turn is implemented differently per class (in your case <code>list</code>). Searching for <code>999</code> takes around double the time as searching for <code>0</code>, since half of the work is creating the list, and the other half is iterating through it, which is short circuited in the case of <code>0</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another look with a hashed object, <code>set</code>:</p>
<pre><code>from time import time

qlist = list(range(1000))
qset = set(qlist)

start = time()
for i in range(1000):
    0 in qlist
print time() - start

start = time()
for i in range(1000):
    999 in qlist
print time() - start

start = time()
for i in range(1000):
    0 in qset
print time() - start

start = time()
for i in range(1000):
    999 in qset
print time() - start
</code></pre>
<p>Output:</p>
<pre><code>0.000172853469849    0 in list
0.0399038791656    999 in list
0.000147104263306i   0 in set
0.000195980072021  999 in set
</code></pre>
<p>As others have said, the <code>list</code> implementation must do a sequential search.  Set inclusion uses a hashed value, and is on par with finding the item in the first element checked.</p>
</div>
<span class="comment-copy"><code>Is the in operator like a loop?</code> Yes, when you call <code>in</code> with a list, a C loop is invoked, I believe.</span>
<span class="comment-copy">Also, <code>in</code> is a conditional operator, not a logical operator, so "short circuiting" does not apply here.</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ, ah! okay. I can't find that in the docs when I Google it. do you have any citations on this?</span>
<span class="comment-copy"><code>in list</code> will iterate through the list until it finds the element. If that's what you mean, it is short-circuited: it doesn't carry on looking through the list once the element has been found.</span>
<span class="comment-copy">I think <a href="https://stackoverflow.com/a/30081318/289011">this answer</a> might be interesting too (it is slightly different, to what you're asking since you're converting to <code>list</code>, but it is a very interesting explanation on how <code>range</code> works)</span>
<span class="comment-copy">I believe I created a Red Herring when i wrapped <code>list()</code> around <code>range()</code>. with <code>l</code> already defined, this clears it up! Does <code>in</code> call different "functions" for different data types based on the latter half of the <code>in</code> operator? (please excuse my bad nomenclature if I've used the wrong terms)</span>
<span class="comment-copy">@MattR yes, it does. You can take a look at <a href="https://docs.python.org/3.7/reference/expressions.html#membership-test-operations" rel="nofollow noreferrer">Membership test operations</a> in the Reference Manual for the full run-down of what is called (which is too much for a comment to include).</span>
<span class="comment-copy">I really appreciate the links to the documentation. I'll read up some more.</span>
<span class="comment-copy">You're welcome @MattR. Thankfully Python's docs are quite good and readable. It's worth reading through them.</span>
<span class="comment-copy">It will also be educating to time the operations for the "range" object alone, without converting it to a list.</span>
<span class="comment-copy">ah! so the double in time would be due to <code>list(range(x))</code> being set up?</span>
<span class="comment-copy">Yes. This is the case.</span>
<span class="comment-copy"><code>which in turn is implemented differently per class</code> - could you elaborate on this? I feel like there is something important packed inside this statement!</span>
<span class="comment-copy">When creating a new class, Python supports operator overloading. Statements such as <code>a = A() + 5</code> can work by implementing <code>A.__add__(self, other)</code>. Similarly, when Python runs into <code>x in y</code>, it checks if <code>y</code>s class implemented the <code>__contains__ method</code> and if so, calls <code>y.__contains__(x)</code>. If, on the other hand, the method wasn't implemented, a <code>TypeError</code> exception will be thrown.</span>
<span class="comment-copy">@Loquacious No <code>TypeError</code> here: <a href="https://ideone.com/pXSj9d" rel="nofollow noreferrer">ideone.com/pXSj9d</a></span>
<span class="comment-copy"><code>in</code> is faster in a set than a list, but what does it show regarding short-circuiting?</span>
<span class="comment-copy">I appreciate the optimization piece.</span>
<span class="comment-copy">@Loquacious: this merely highlights the effect of early loop exit with a list; set <b>in</b> doesn't short-circuit at all, because the reference is direct.</span>
