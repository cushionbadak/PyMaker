<div class="post-text" itemprop="text">
<p>I have a program that needs to create several graphs, with each one often taking hours. Therefore I want to run these simultaneously on different cores, but cannot seem to get these processes to run with the <code>multiprocessing</code> module. Here is my code:</p>
<pre><code>if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=full_graph)
        jobs.append(p)
        p.start()
        p.join()
</code></pre>
<p>(<code>full_graph()</code> has been defined earlier in the program, and is simply a function that runs a collection of other functions)</p>
<p>The function normally outputs some graphs, and saves the data to a .txt file. All data is saved to the same 2 text files. However, calling the functions using the above code gives no console output, nor any output to the text file. All that happens is a few second long pause, and then the program exits.</p>
<p>I am using the Spyder IDE with WinPython 3.6.3</p>
</div>
<div class="post-text" itemprop="text">
<p>Without a simple <code>full_graph</code> sample nobody can tell you what's happening. But your code is inherently wrong.</p>
<pre><code>if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=full_graph)
        jobs.append(p)
        p.start()
        p.join()  # &lt;- This would block until p is done
</code></pre>
<p>See the comment after <code>p.join()</code>. If your processes really take hours to complete, you would run one process for hours and then the 2nd, the 3rd. Serially and using a single core.</p>
<p>From the docs: <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html</a></p>
<p><code>Process.join</code>: <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.join" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.join</a></p>
<blockquote>
<p>If the optional argument timeout is None (the default), the method blocks until the process whose join() method is called terminates. If timeout is a positive number, it blocks at most timeout seconds. Note that the method returns None if its process terminates or if the method times out. Check the processâ€™s exitcode to determine if it terminated.</p>
</blockquote>
<p>If each process does something different, you should then also have some <code>args</code> for <code>full_graph</code>(<em>hint</em>: may that be the missing factor?)</p>
<p>You probably want to use an interface like <code>map</code> from <code>Pool</code></p>
<ul>
<li><a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool</a></li>
</ul>
<p>And do (from the docs again)</p>
<pre><code>from multiprocessing import Pool

def f(x):
    return x*x

if __name__ == '__main__':
    with Pool(5) as p:
        print(p.map(f, [1, 2, 3]))
</code></pre>
</div>
