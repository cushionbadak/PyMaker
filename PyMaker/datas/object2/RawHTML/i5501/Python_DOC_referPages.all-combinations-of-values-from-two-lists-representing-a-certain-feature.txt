<div class="post-text" itemprop="text">
<p>I have three lists:</p>
<pre><code>a = [0,1,2]
b = [3,4,5]
c = [aab, abb, aaa]
</code></pre>
<p>How to create all three-element combinations? Where sequences from the list <code>c</code> tell you which list can be used to choose numbers for a given place in a given output sequence</p>
<p>For example (pseudocode):</p>
<pre><code>for i=0 in range(len(c)):
    print: [0,1,3]
           [0,1,4]
             ...
           [0,2,5]
             ...
           [1,2,4]
           [1,2,5]
</code></pre>
<p>And the same for the rest of the <code>i</code> indexes. Where the values in individual sublistas can not be repeated.
I will be very grateful for any tips.</p>
</div>
<div class="post-text" itemprop="text">
<p>This generator function will handle 'ab' template strings with the a's and b's in any order, and the output lists will not contain repeated items if the <code>a</code> and <code>b</code> lists are disjoint. We use <code>itertools.combinations</code> to generate combinations of the required order, and combine the <code>a</code> and <code>b</code> combinations using <code>itertools.product</code>. We get them in the correct order by turning each <code>a</code> and <code>b</code> combination into an iterator and select from the correct iterator via a dictionary.</p>
<pre><code>from itertools import combinations, product

def groups(a, b, c):
    for pat in c:
        acombo = combinations(a, pat.count('a'))
        bcombo = combinations(b, pat.count('b'))
        for ta, tb in product(acombo, bcombo):
            d = {'a': iter(ta), 'b': iter(tb)}
            yield [next(d[k]) for k in pat]

# tests

a = [0,1,2]
b = [3,4,5]

templates = ['aab', 'abb', 'aaa'], ['aba'], ['bab']

for c in templates:
    print('c', c)
    for i, t in enumerate(groups(a, b, c), 1):
        print(i, t)
    print()
</code></pre>
<p><strong>output</strong></p>
<pre><code>c ['aab', 'abb', 'aaa']
1 [0, 1, 3]
2 [0, 1, 4]
3 [0, 1, 5]
4 [0, 2, 3]
5 [0, 2, 4]
6 [0, 2, 5]
7 [1, 2, 3]
8 [1, 2, 4]
9 [1, 2, 5]
10 [0, 3, 4]
11 [0, 3, 5]
12 [0, 4, 5]
13 [1, 3, 4]
14 [1, 3, 5]
15 [1, 4, 5]
16 [2, 3, 4]
17 [2, 3, 5]
18 [2, 4, 5]
19 [0, 1, 2]

c ['aba']
1 [0, 3, 1]
2 [0, 4, 1]
3 [0, 5, 1]
4 [0, 3, 2]
5 [0, 4, 2]
6 [0, 5, 2]
7 [1, 3, 2]
8 [1, 4, 2]
9 [1, 5, 2]

c ['bab']
1 [3, 0, 4]
2 [3, 0, 5]
3 [4, 0, 5]
4 [3, 1, 4]
5 [3, 1, 5]
6 [4, 1, 5]
7 [3, 2, 4]
8 [3, 2, 5]
9 [4, 2, 5]
</code></pre>
<p>I should mention that even though <code>combinations</code> returns iterators, and <code>product</code> happily takes iterators as arguments, it has to make lists from the iterators because it has to run over the iterator contents multiple times. So if the number of combinations is huge this can consume a fair amount of RAM. </p>
<hr/>
<p>If you want permutations instead of combinations, that's easy. We just call <code>itertools.permutations</code> instead of <code>itertools.combinations</code>.</p>
<pre><code>from itertools import permutations, product

def groups(a, b, c):
    for pat in c:
        acombo = permutations(a, pat.count('a'))
        bcombo = permutations(b, pat.count('b'))
        for ta, tb in product(acombo, bcombo):
            d = {'a': iter(ta), 'b': iter(tb)}
            yield [next(d[k]) for k in pat]

# tests

a = [0,1,2]
b = [3,4,5]

templates = ['aaa'], ['abb'] 

for c in templates:
    print('c', c)
    for i, t in enumerate(groups(a, b, c), 1):
        print(i, t)
    print()
</code></pre>
<p><strong>output</strong></p>
<pre><code> c ['aaa']
1 [0, 1, 2]
2 [0, 2, 1]
3 [1, 0, 2]
4 [1, 2, 0]
5 [2, 0, 1]
6 [2, 1, 0]

c ['abb']
1 [0, 3, 4]
2 [0, 3, 5]
3 [0, 4, 3]
4 [0, 4, 5]
5 [0, 5, 3]
6 [0, 5, 4]
7 [1, 3, 4]
8 [1, 3, 5]
9 [1, 4, 3]
10 [1, 4, 5]
11 [1, 5, 3]
12 [1, 5, 4]
13 [2, 3, 4]
14 [2, 3, 5]
15 [2, 4, 3]
16 [2, 4, 5]
17 [2, 5, 3]
18 [2, 5, 4]
</code></pre>
<hr/>
<p>Finally, here's a version that handles any number of lists, and template strings of any length. It only accepts a single template string per call, but that shouldn't be an issue. You can also choose whether you want to generate permutations or combinations via an optional keyword arg.</p>
<pre><code>from itertools import permutations, combinations, product

def groups(sources, template, mode='P'):
    func = permutations if mode == 'P' else combinations
    keys = sources.keys()
    combos = [func(sources[k], template.count(k)) for k in keys]
    for t in product(*combos):
        d = {k: iter(v) for k, v in zip(keys, t)}
        yield [next(d[k]) for k in template]

# tests

sources = {
    'a': [0, 1, 2],
    'b': [3, 4, 5],
    'c': [6, 7, 8],
}

templates = 'aa', 'abc', 'abba', 'cab'

for template in templates:
    print('\ntemplate', template)
    for i, t in enumerate(groups(sources, template, mode='C'), 1):
        print(i, t)
</code></pre>
<p><strong>output</strong></p>
<pre><code>template aa
1 [0, 1]
2 [0, 2]
3 [1, 2]

template abc
1 [0, 3, 6]
2 [0, 3, 7]
3 [0, 3, 8]
4 [0, 4, 6]
5 [0, 4, 7]
6 [0, 4, 8]
7 [0, 5, 6]
8 [0, 5, 7]
9 [0, 5, 8]
10 [1, 3, 6]
11 [1, 3, 7]
12 [1, 3, 8]
13 [1, 4, 6]
14 [1, 4, 7]
15 [1, 4, 8]
16 [1, 5, 6]
17 [1, 5, 7]
18 [1, 5, 8]
19 [2, 3, 6]
20 [2, 3, 7]
21 [2, 3, 8]
22 [2, 4, 6]
23 [2, 4, 7]
24 [2, 4, 8]
25 [2, 5, 6]
26 [2, 5, 7]
27 [2, 5, 8]

template abba
1 [0, 3, 4, 1]
2 [0, 3, 5, 1]
3 [0, 4, 5, 1]
4 [0, 3, 4, 2]
5 [0, 3, 5, 2]
6 [0, 4, 5, 2]
7 [1, 3, 4, 2]
8 [1, 3, 5, 2]
9 [1, 4, 5, 2]

template cab
1 [6, 0, 3]
2 [7, 0, 3]
3 [8, 0, 3]
4 [6, 0, 4]
5 [7, 0, 4]
6 [8, 0, 4]
7 [6, 0, 5]
8 [7, 0, 5]
9 [8, 0, 5]
10 [6, 1, 3]
11 [7, 1, 3]
12 [8, 1, 3]
13 [6, 1, 4]
14 [7, 1, 4]
15 [8, 1, 4]
16 [6, 1, 5]
17 [7, 1, 5]
18 [8, 1, 5]
19 [6, 2, 3]
20 [7, 2, 3]
21 [8, 2, 3]
22 [6, 2, 4]
23 [7, 2, 4]
24 [8, 2, 4]
25 [6, 2, 5]
26 [7, 2, 5]
27 [8, 2, 5]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from itertools import product, chain

setups = ['aab', 'abb', 'aaa']
sources = {
    'a': [0,1,2],
    'b': [3,4,5]
}

combinations = (product(*map(sources.get, setup)) for setup in setups) 
</code></pre>
<p><code>combinations</code> is a nested lazy iterator (i.e. nothing is stored in memory and calculated, yet). If you want to get an iterator of lists</p>
<pre><code>combinations = map(list, (product(*map(sources.get, setup)) for setup in setups))
</code></pre>
<p>Or you might want to flatten the result:</p>
<pre><code>combinations = chain.from_iterable(product(*map(sources.get, setup)) for setup in setups)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand it correctly, you can achieve the goal with a dictionary bookkeeping the correspondence of a character like <code>"a"</code> to a variable name <code>a</code>.</p>
<pre><code>from collections import defaultdict

a = [0,1,2]
b = [3,4,5]
c = ["aab", "abb", "aaa"]
d = {"a": a, "b": b}
d2 = defaultdict(list)
for seq in c:
    l = []
    for idx, v in enumerate(seq):
        l.append(d[v][idx]) 
    print(l)
    d2[seq].append(l)
# Out:
#[0, 1, 5]
#[0, 4, 5]
#[0, 1, 2]
print(d2)
# defaultdict(&lt;class 'list'&gt;, {'aab': [[0, 1, 5]], 'abb': [[0, 4, 5]], 'aaa': [[0, 1, 2]]})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Put the lists in a dictionary so you can access them with strings.<br/>
Use the characters in each sequence to determine which lists to use.<br/>
Use itertools.product to get the <em>combinations</em>.</p>
<pre><code>import itertools, collections
from pprint import pprint
d = {'a':[0,1,2], 'b':[3,4,5]}
c = ['aab', 'abb', 'aaa']

def f(t):
    t = collections.Counter(t)
    return max(t.values()) &lt; 2

for seq in c:
    data = (d[char] for char in seq)
    print(f'sequence: {seq}')
    pprint(list(filter(f, itertools.product(*data))))
    print('***************************')
</code></pre>
<p>Result for sequence <code>'abb'</code>:</p>
<pre><code>sequence: abb
[(0, 3, 4),
 (0, 3, 5),
 (0, 4, 3),
 (0, 4, 5),
 (0, 5, 3),
 (0, 5, 4),
 (1, 3, 4),
 (1, 3, 5),
 (1, 4, 3),
 (1, 4, 5),
 (1, 5, 3),
 (1, 5, 4),
 (2, 3, 4),
 (2, 3, 5),
 (2, 4, 3),
 (2, 4, 5),
 (2, 5, 3),
 (2, 5, 4)]
</code></pre>
<hr/>
<p>edit to filter out tuples with <em>duplicates</em></p>
<hr/>
<p>I like the idea of a callable dict that can be used with map.  It could be used here.</p>
<pre><code>class CallDict(dict):
    def __call__(self, key):
        return self[key]    #self.get(key)

e = CallDict([('a',[0,1,2]), ('b',[3,4,5])])

for seq in c:
    data = map(e, seq)
    print(f'sequence: {seq}')
    for thing in filter(f, itertools.product(*data)):
        print(thing)
    print('***************************')
</code></pre>
<hr/>
<p>I couldn't help myself, here is a <em>generic</em> version of @PM2Ring's <a href="https://stackoverflow.com/a/48121777/2823755">solution/answer</a>. Instead of filtering out unwanted items, it doesn't produce them in the first place.</p>
<pre><code>d = {'a':[0,1,2], 'b':[3,4,5]}
c = ['aab', 'abb', 'aaa', 'aba']
def g(d, c):
    for seq in c:
        print(f'sequence: {seq}')
        counts = collections.Counter(seq)
##        data = (itertools.combinations(d[key],r) for key, r in counts.items())
        data = (itertools.permutations(d[key],r) for key, r in counts.items())
        for thing in itertools.product(*data):
            q = {key:iter(other) for key, other in zip(counts, thing)}
            yield [next(q[k]) for k in seq]

for t in g(d, c):
    print(t)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It looks like you're looking for some way to programmatically call <a href="https://docs.python.org/3/library/itertools.html#product" rel="nofollow noreferrer"><code>itertools.product</code></a></p>
<pre><code>from itertools import product

d = {'a': [0,1,2],
     'b': [3,4,5]}
c = ['aab', 'abb', 'aaa']

for s in c:
    print(list(product(*[d[x] for x in s])))
</code></pre>
</div>
<span class="comment-copy">What are ""How to create all three-element combinations?"" Can you illustrate more?</span>
<span class="comment-copy">And that doesn't look like Python. More importantly, have you tried anything yourself?</span>
<span class="comment-copy">I deliberately used pseudo-language to illustrate the problem.</span>
<span class="comment-copy">I used it as a standard <code>it.combinations</code>, and later screening conditions. but I wanted to find an approach that would not look for all combinations with each index.</span>
<span class="comment-copy">"""Where the values in individual sublistas can not be repeated.""" explanation to this line?</span>
<span class="comment-copy">well, this stupid RAM;) that's why I'm constantly trying to write something without storing it in my memory. but a hard thing :) thanks for your solution. for now, I am testing the solution of colleague @wwii. but strangely when it comes to calculating time it comes out worse than in my old solution ...</span>
<span class="comment-copy">why in your solution if I want to make only one 'templates' value then I have to enter it with a comma? that is, for example, <code>templates = ['bba'],</code>. Because otherwise it displays results incorrectly.</span>
<span class="comment-copy">@TomaszPrzemski <code>for c in templates:</code> loops over a collection of templates. The line <code>templates = ['bba'],</code> creates a 1 item tuple that contains the 1 item list <code>['bba']</code>. (Parentheses don't create tuples, commas do). You could just do <code>a = [0,1,2]; b = [3,4,5]; c = ['bba']</code> ` for i, t in enumerate(groups(a, b, c), 1): print(i, t)`</span>
<span class="comment-copy">@TomaszPrzemski As you noticed, wwii's solution makes a high proportion of combinations containing repeated elements. And then you have to filter those out, so it's bound to be slower than a solution like mine which simply avoids making combinations containing repeated elements.</span>
<span class="comment-copy">@TomaszPrzemski Seriously? Next time, you should do a better job of showing / describing the expected output! So why does 'aaa' give just those 3 permutations and not <code>[1, 2, 0], [2, 0, 1], [2, 1, 0]</code> as well?</span>
<span class="comment-copy">This code produces lots of lists that contain repeated items, which the OP doesn't want. You <i>could</i> just filter them out, but that is rather inefficient if the source lists and setups strings are large.</span>
<span class="comment-copy">@PM2Ring then I guess, I misunderstood the task.</span>
<span class="comment-copy">but it was close :) because I'm interested in the most economical way, because I work on large lists. thanks for your time.</span>
<span class="comment-copy">near. and how do you get all the combinations with a given feature?</span>
<span class="comment-copy">What is a given feature? @TomaszPrzemski</span>
<span class="comment-copy">all with characteristics 'aab', all with characteristics 'abb', all with characteristics 'aaa'</span>
<span class="comment-copy">@TomaszPrzemski Updated. Is this what you mean? Keep another dictionary that stores the value each time a sequence is formed.</span>
<span class="comment-copy">it was not what it was about yet, but I already have a solution. though not perfect :) thanks for your time!</span>
<span class="comment-copy">it seems fine, just to set the filter so that there are no duplicate values in a given tuple.</span>
<span class="comment-copy">@TomaszPrzemski - Are tuples with duplicate values <i>discarded</i>?</span>
<span class="comment-copy">yes, I said a little badly  :) I used your solution for now, but I was a bit surprised because it turned out to be longer in time. honestly, looking at the code itself, I expected to shorten the time. sigh ...</span>
