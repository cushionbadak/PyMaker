<div class="post-text" itemprop="text">
<p>I've a flask application, which uses following format to load configuration values.</p>
<pre><code>#in application.py file

app = Flask(__name__, instance_relative_config=True)
app.config.from_object(app_config)
app.config.from_pyfile('config.py')


#in config.py file

class Config(object):
    DEBUG = True
    SQLALCHEMY_ECHO = True

app_config = Config

# in instance/config.py
SECRET_KEY = '........'
SQLALCHEMY_DATABASE_URI = 'mysql://root:.......'
</code></pre>
<p>I'm deploying this to aws elastic-beanstalk. There I can set environment variables using aws web console.
<a href="https://i.stack.imgur.com/sVvMO.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/sVvMO.png"/></a></p>
<p>Is there a way I could set <code>SQLALCHEMY_DATABASE_URI</code> in aws admin area, and let it overwrite <code>SQLALCHEMY_DATABASE_URI</code> that is loaded in config.py file?</p>
<p>Above is just an example, I've a long list of config values which I would like to keep only on aws.</p>
</div>
<div class="post-text" itemprop="text">
<p>For Flask's <code>app.config</code>, load the second set of variables after the first. Flask's below example references two different access methods, but it should work for similar successive uploads as well.</p>
<blockquote>
<p><a href="http://flask.pocoo.org/docs/1.0/config/#development-production" rel="nofollow noreferrer">Most applications</a> need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:</p>
</blockquote>
<pre><code>app = Flask(__name__)
app.config.from_object('yourapplication.default_settings')
app.config.from_envvar('YOURAPPLICATION_SETTINGS')
</code></pre>
<p>For a more explicit overwrite, take a look at using flask app.config.update after you load your config from your existing config file. </p>
<blockquote>
<p><a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow noreferrer">update([other])</a>
  Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None.</p>
</blockquote>
<pre><code>app.config.from_envvar('DEFAULT_CONFIG_FILE')
app.config.update('OVERRIDING_CONFIG_FILE')
</code></pre>
<p><a href="http://flask.pocoo.org/docs/1.0/config/" rel="nofollow noreferrer">http://flask.pocoo.org/docs/1.0/config/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You should <code>import os</code>, and then</p>
<pre><code>SQLALCHEMY_DATABASE_URI = os.getenv('SQLALCHEMY_DATABASE_URI',
                                    'sqlite:////tmp/your_default.db')
</code></pre>
<p>Or assign <code>os.getenv['SQLALCHEMY_DATABASE_URI']</code> if you prefer to raise an exception if the URI is unspecified. Take care to avoid deferring such assignments until after <code>import</code> time.</p>
<p>Edit: Assign the URI before it is used. For example, OP question specified assignment "# in instance/config.py".</p>
</div>
<span class="comment-copy">I do that in instance/config.py file?  (which is more like a .env file)</span>
