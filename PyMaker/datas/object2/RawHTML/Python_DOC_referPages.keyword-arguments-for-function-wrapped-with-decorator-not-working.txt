<div class="post-text" itemprop="text">
<p>All the tutorials I find on decorators suggest using <code>*args, **kwargs</code> in the wrapping function's signature, to handle arguments from the wrapped function.  Yet kwargs are not working, while plain args are:</p>
<pre><code>from functools import wraps


def wrapper(a_thing):
    @wraps(a_thing)
    def do_thing(*args, **kwargs):
        print('before')
        print(kwargs)
        value = a_thing(*args, **kwargs)
        print("after", *args, **kwargs)
        return value
    return do_thing


@wrapper
def output(*args, **kwargs):
    print('during', *args, **kwargs)

import pdb; pdb.set_trace()
</code></pre>
<p>Here's my interactive output:</p>
<pre><code>(Pdb) output(99, 100)
before
{}
during 99 100
after 99 100
(Pdb) output(arg1=99, arg2=100)
before
{'arg1': 99, 'arg2': 100}
*** TypeError: 'arg1' is an invalid keyword argument for this function
(Pdb)
</code></pre>
<p>Here's <a href="https://www.saltycrane.com/blog/2010/03/simple-python-decorator-examples/" rel="nofollow noreferrer">an example</a> of one of many such tutorials:</p>
<p>What's the point of using **kwargs if it doesn't work?  I feel like I'm missing something.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't want to unpack in the calls to <code>print</code>; <code>print</code> only accepts a limited number of keyword arguments, and will reject all others. Presumably you just want to see what was passed, so print the raw <code>tuple</code> and <code>dict</code> without unpacking:</p>
<pre><code>def wrapper(a_thing):
    @wraps(a_thing)
    def do_thing(*args, **kwargs):
        print('before')
        print(kwargs)
        value = a_thing(*args, **kwargs)
        print("after", args, kwargs)  # Removed unpacking
        return value
    return do_thing


@wrapper
def output(*args, **kwargs):
    print('during', args, kwargs)  # Removed unpacking
</code></pre>
<p>The point of unpacking is that it passes the elements of a <code>*</code> unpacked iterable as sequential positional arguments, and the key value pairs from a <code>**</code> unpacked mapping using the keys as keyword arguments, and the values as the associated value. So when you did:</p>
<pre><code>    print('during', *args, **kwargs)
</code></pre>
<p>having called into the function with <code>output(arg1=99, arg2=100)</code>, it was as if you ran:</p>
<pre><code>    print('during', arg1=99, arg2=100)
</code></pre>
<p>Neither <code>arg1</code> nor <code>arg2</code> are keywords accepted by <code>print</code>, so it screamed at you. By removing the unpacking, the <code>print</code> becomes equivalent to:</p>
<pre><code>    print('during', (), {'arg1': 99, 'arg2': 100})
</code></pre>
<p>which is perfectly valid (it's printing the <code>tuple</code> and <code>dict</code> directly, not trying to unpack).</p>
</div>
<span class="comment-copy">Ahh, thank you, the "function" mentioned in the error is the <code>print()</code> function, not the <code>output</code> function like I assumed..... wow.</span>
