<div class="post-text" itemprop="text">
<p>I know similar questions have been asked a million times, but despite reading through many of them I can't find a solution that applies to my situation.</p>
<p>I have a django application, in which I've created a management script. This script reads some text files, and outputs them to the terminal (it will do more useful stuff with the contents later, but I'm still testing it out) and the characters come out with escape sequences like <code>\xc3\xa5</code> instead of the intended <code>å</code>. Since that escape sequence means <code>Ã¥</code>, which is a common misinterpretation of <code>å</code> because of encoding problems, I suspect there are at least two places where this is going wrong. However, I can't figure out where - I've checked all the possible culprits I can think of:</p>
<ul>
<li>The terminal encoding is UTF-8; <code>echo $LANG</code> gives <code>en_US.UTF-8</code></li>
<li>The text files are encoded in UTF-8; <code>file *</code> in the directory where they reside results in all entries being listed as "UTF-8 Unicode text" except one, which does not contain any non-ASCII characters and is listed as "ASCII text". Running <code>iconv -f ascii -t utf8 thefile.txt &gt; utf8.txt</code> on that file yields another file with ASCII text encoding.</li>
<li>The Python scripts are all UTF-8 (or, in several cases, ASCII with no non-ASCII characters). I tried inserting a comment in my management script with some special characters to force it to save as UTF-8, but it did not change the behavior. The above observations on the text files apply on all Python script files as well.</li>
<li>The Python script that handles the text files has <code># -*- encoding: utf-8 -*-</code> at the top; the only line preceding that is <code>#!/usr/bin/python3</code>, but I've tried both changing to <code>.../python</code> for Python 2.7 or removing it entirely to leave it up to Django, without results.</li>
<li>According to <a href="https://docs.djangoproject.com/en/dev/ref/unicode/" rel="nofollow">the documentation</a>, "Django natively supports Unicode data", so I "can safely pass around Unicode strings" anywhere in the application.</li>
</ul>
<p>I really can't think of anywhere else to look for a non-UTF-8 link in the chain. Where could I possibly have missed a setting to change to UTF-8?</p>
<p>For completeness: I'm reading from the files with <code>lines = file.readlines()</code> and printing with the standard <code>print()</code> function. No manual encoding or decoding happens at either end.</p>
<h3>UPDATE:</h3>
<p>In response to quiestions in comments:</p>
<ul>
<li><code>print(sys.getdefaultencoding(), sys.stdout.encoding, f.encoding)</code> yields <code>('ascii', 'UTF-8', None)</code> for all files.</li>
<li>I started compiling an SSCCE, and quickly found that the problem is only there if I try to print the value in a tuple. In other words, <code>print(lines[0].strip())</code> works fine, but <code>print(lines[0].strip(), lines[1].strip())</code> does not. Adding <code>.decode('utf-8')</code> yields a tuple where both strings are marked with a prepending <code>u</code> and <code>\xe5</code> (the correct escape sequence for <code>å</code>) instead of the odd characters before - but I can't figure out how to print them as regular strings, with no escape characters. I've tested another call to <code>.decode('utf-8')</code> as well as wrapping in <code>str()</code> but both fail with <code>UnicodeEncodeError</code> complaining that <code>\xe5</code> can't be encoded in ascii. Since a single string works correctly, I don't know what else to test.</li>
</ul>
<p><strong>SSCCE:</strong></p>
<pre><code># -*- coding: utf-8 -*-

import os, sys

for root,dirs,files in os.walk('txt-songs'):
    for filename in files:
        with open(os.path.join(root,filename)) as f:
            print(sys.getdefaultencoding(), sys.stdout.encoding, f.encoding)

            lines = f.readlines()
            print(lines[0].strip()) # works
            print(lines[0].strip(), lines[1].strip()) # does not work
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The big problem here is that you're mixing up Python 2 and Python 3. In particular, you've written Python 3 code, and you're trying to run it in Python 2.7. But there are a few other problems along the way. So, let me try to explain everything that's going wrong.</p>
<hr/>
<blockquote>
<p>I started compiling an SSCCE, and quickly found that the problem is only there if I try to print the value in a tuple. In other words, <code>print(lines[0].strip())</code> works fine, but <code>print(lines[0].strip(), lines[1].strip())</code> does not.</p>
</blockquote>
<p>The first problem here is that the <code>str</code> of a tuple (or any other collection) includes the <code>repr</code>, not the <code>str</code>, of its elements. The simple way to solve this problem is to not print collections. In this case, there is really no reason to print a tuple at all; the only reason you have one is that you've built it for printing. Just do something like this:</p>
<pre><code>print '({}, {})'.format(lines[0].strip(), lines[1].strip())
</code></pre>
<p>In cases where you already have a collection in a variable, and you want to print out the str of each element, you have to do that explicitly. You can print the repr of the str of each with this:</p>
<pre><code>print tuple(map(str, my_tuple))
</code></pre>
<p>… or print the str of each directly with this:</p>
<pre><code>print '({})'.format(', '.join(map(str, my_tuple)))
</code></pre>
<hr/>
<p>Notice that I'm using Python 2 syntax above. That's because if you actually used Python 3, there would be no tuple in the first place, and there would also be no need to call <code>str</code>.</p>
<hr/>
<p>You've got a Unicode string. In Python 3, <code>unicode</code> and <code>str</code> are the same type. But in Python 2, it's <code>bytes</code> and <code>str</code> that are the same type, and <code>unicode</code> is a different one. So, in 2.x, you don't have a <code>str</code> yet, which is why you need to call <code>str</code>.</p>
<p>And Python 2 is also why <code>print(lines[0].strip(), lines[1].strip())</code> prints a tuple. In Python 3, that's a call to the <code>print</code> function with two strings as arguments, so it will print out two strings separated by a space. In Python 2, it's a <code>print</code> statement with one argument, which is a tuple.</p>
<p>If you want to write code that works the same in both 2.x and 3.x, you either need to avoid ever printing more than one argument, or use a wrapper like <a href="http://pythonhosted.org/six/#six.print_" rel="nofollow"><code>six.print_</code></a>, or do a <code>from __future__ import print_function</code>, or be very careful to do ugly things like adding in extra parentheses to make sure your tuples are tuples in both versions.</p>
<hr/>
<p>So, in 3.x, you've got <code>str</code> objects and you just print them out. In 2.x, you've got <code>unicode</code> objects, and you're printing out their <code>repr</code>. You can change that to print out their <code>str</code>, or to avoid printing a tuple in the first place… but that still won't help anything. </p>
<p>Why? Well, printing anything, in either version, just calls <code>str</code> on it and then passes it to <code>sys.stdio.write</code>. But in 3.x, <code>str</code> means <code>unicode</code>, and <code>sys.stdio</code> is a <code>TextIOWrapper</code>; in 2.x, <code>str</code> means <code>bytes</code>, and <code>sys.stdio</code> is a binary <code>file</code>.</p>
<p>So, the pseudocode for what ultimately happens is:</p>
<pre><code>sys.stdio.wrapped_binary_file.write(s.encode(sys.stdio.encoding, sys.stdio.errors))

sys.stdio.write(s.encode(sys.getdefaultencoding()))
</code></pre>
<p>And, as you saw, those will do different things, because:</p>
<blockquote>
<p><code>print(sys.getdefaultencoding(), sys.stdout.encoding, f.encoding)</code> yields <code>('ascii', 'UTF-8', None)</code></p>
</blockquote>
<p>You can simulate Python 3 here by using a <code>io.TextIOWrapper</code> or <code>codecs.StreamWriter</code> and then using <code>print &gt;&gt;f, …</code> or <code>f.write(…)</code> instead of <code>print</code>, or you can explicitly encode all your <code>unicode</code> objects like this:</p>
<pre><code>print '({})'.format(', '.join(element.encode('utf-8') for element in my_tuple)))
</code></pre>
<hr/>
<p>But really, the best way to deal with all of these problems is to run your existing Python 3 code in a Python 3 interpreter instead of a Python 2 interpreter.</p>
<p>If you want or need to use Python 2.7, that's fine, but you have to write Python 2 code. If you want to write Python 3 code, that's great, but you have to run Python 3.3. If you really want to write code that works properly in both, you <em>can</em>, but it's extra work, and takes a lot more knowledge.</p>
<p>For further details, see <a href="http://docs.python.org/3.0/whatsnew/3.0.html" rel="nofollow">What's New In Python 3.0</a> (the "Print Is A Function" and "Text Vs. Data Instead Of Unicode Vs. 8-bit" sections), although that's written from the point of view of explaining 3.x to 2.x users, which is backward from what you need. The <a href="http://docs.python.org/3/howto/unicode.html" rel="nofollow">3.x</a> and <a href="http://docs.python.org/2/howto/unicode.html" rel="nofollow">2.x</a> versions of the Unicode HOWTO may also help.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>For completeness: I'm reading from the files with lines = file.readlines() and printing with the standard print() function. No manual encoding or decoding happens at either end.</p>
</blockquote>
<p>In Python 3.x, the standard <code>print</code> function just writes Unicode to <code>sys.stdout</code>. Since that's a <code>io.TextIOWrapper</code>, its <code>write</code> method is equivalent to this:</p>
<pre><code>self.wrapped_binary_file.write(s.encode(self.encoding, self.errors))
</code></pre>
<p>So one likely problem is that <code>sys.stdout.encoding</code> does not match your terminal's actual encoding.</p>
<hr/>
<p>And of course another is that your shell's encoding does not match your terminal window's encoding.</p>
<p>For example, on OS X, I create a myscript.py like this:</p>
<pre><code>print('\u00e5')
</code></pre>
<p>Then I fire up Terminal.app, create a session profile with encoding "Western (ISO Latin 1)", create a tab with that session profile, and do this:</p>
<pre><code>$ export LANG=en_US.UTF-8
$ python3 myscript.py
</code></pre>
<p>… and I get exactly the behavior you're seeing.</p>
</div>
<div class="post-text" itemprop="text">
<p>It seems from your comment that you are using python-2 and not python-3.</p>
<p>If you are using  python-3, it's worth reading the <a href="http://docs.python.org/3.3/howto/unicode.html" rel="nofollow">unicode howto guide</a> on <a href="http://docs.python.org/3.3/howto/unicode.html#reading-and-writing-unicode-data" rel="nofollow">reading/writing</a> to understand what python is doing.</p>
<p>The basic flow if encoding is:</p>
<p>DECODE from encoding to unicode -&gt; Processing -&gt; Encode from unicode to encoding</p>
<p>In python3 the bytes are <em>decoded</em> to strings and strings are <em>encoded</em> to bytes.
The bytes to string <em>decoding</em> is handled for you with <code>open()</code>.</p>
<blockquote>
<p>[..] the built-in <em>open()</em> function can return a file-like object that
  assumes the file’s contents are in a specified encoding and accepts
  Unicode parameters for methods such as read() and write(). This works
  through open()‘s <em>encoding</em> and errors parameters [..]</p>
</blockquote>
<p>So to read in <em>unicode</em> from a <em>utf-8 encoded</em> file you should be doing this:</p>
<pre><code># python-3
with open('utf8.txt', mode='r', encoding='utf-8') as f:
    lines = f.readlines() # returns unicode 
</code></pre>
<p>If you want similar functionality using python-2, you can use <a href="http://docs.python.org/2/library/codecs.html#codecs.open" rel="nofollow"><code>codecs.open()</code></a>:</p>
<pre><code># python-2
import codecs
with codecs.open('utf8.txt', mode='r', encoding='utf-8') as f:
    lines = f.readlines() # returns unicode 
</code></pre>
</div>
<span class="comment-copy">Yes, Django natively supporting Unicode, and you can pass around Unicode strings… but ultimately, if you're reading/writing files or stdin/stdout, you have to encode/decode at the edges.</span>
<span class="comment-copy">Decode it: <code>'\xc3\xa5'.decode('utf-8') == u'\xe5'</code></span>
<span class="comment-copy">Anyway, my first suggestion would be to give us a <a href="http://sscce.org" rel="nofollow noreferrer">SSCCE</a> so we can find the actual error in your code, instead of just trying to guess at what you could conceivably have done wrong. Second, print out <code>sys.getdefaultencoding()</code>, <code>sys.stdout.encoding</code>, and <code>f.encoding</code> for each text-mode file (in 3.x).</span>
<span class="comment-copy">One likely possibility is that you're properly encoding Unicode to UTF-8, and then printing that UTF-8 to a Latin-1/CP819/etc. <code>stdout</code>. (And Blender's edited comment shows that he was already thinking the same thing 4 minutes before me…)</span>
<span class="comment-copy">You have to answer all of the questions that we give you for debugging the problem, not partially answer a handful of them, or we can't debug the problem for you.</span>
<span class="comment-copy">This was very enlightening, and spot on the problem. However, since I very much prefer Python 3.x over Python 2.7, I decided to just do <code>from __future__ import print_function, unicode_literals</code>, which solved the problem galantly. Thanks for a thorough answer!</span>
<span class="comment-copy">@TomasLycken: I also prefer Python 3.x over Python 2.7. So… why not just use Python 3.3? Django is 3.3-compatible, and it's a good bet that any other libraries you're using are too. Of course it's <i>possible</i> that you'll run into a library that you need that hasn't been ported yet… but don't just assume that, try it and see.</span>
<span class="comment-copy">Django (apparently) installs with python 2.7 as default in Ubuntu, and I haven't bothered changing it. After all, this is the first thing I did since I installed Django (this time - but last time was a couple of years, and a couple of Ubuntu versions, ago...).</span>
<span class="comment-copy">@TomasLycken: Yeah, it looks like Ubuntu doesn't plan to offer a <code>python3-django</code> package until they upgrade their default Django version to 1.6. So, you can either install an unofficial package, <code>pip-3.3 install django</code>, or write Python 2.7 code.</span>
<span class="comment-copy">How do I conclusively check my shell and terminal encodings on Ubuntu 13.04? <code>echo $LANG</code> seems to be the most referred to method I can find, but it seems from your answer that this can be misleading.</span>
<span class="comment-copy">@TomasLycken: Well, <code>echo $LANG</code> is the way to check your <i>shell</i> (although you may want to run <code>locale</code> and make sure all the settings are consistent), but that doesn't tell you anything about your <i>terminal</i>. Of course if everything is working, they'll match… but the whole point is that we suspect that not everything is working, so… Does Ubuntu still use <code>gnome-terminal</code>? It should have menu options that let you change the encoding… but the default should be to read from your environment. This can go wrong if you change the locale in your profile to be different from in your login.</span>
<span class="comment-copy">@TomasLycken: Sorry I can't give more specific answers about Ubuntu, but really askubuntu, linuxquestions, superuser, etc. may be better places to go.</span>
<span class="comment-copy">That gives me <code>TypeError: 'encoding' is an invalid keyword argument for this function</code>. Changing to just <code>coding</code> or <code>enc</code> does not help - and I had the impression this is what Python would do anyway, since everything else is specified in Unicode.</span>
<span class="comment-copy">Ok, that means you are using python 2.  I got the impression you were using python 3 from your question.</span>
