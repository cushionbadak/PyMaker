<div class="post-text" itemprop="text">
<p>I'm trying to define some class methods using another more generic class method as follows:</p>
<pre><code>class RGB(object):
    def __init__(self, red, blue, green):
        super(RGB, self).__init__()
        self._red = red
        self._blue = blue
        self._green = green

    def _color(self, type):
        return getattr(self, type)

    red = functools.partial(_color, type='_red')
    blue = functools.partial(_color, type='_blue')
    green = functools.partial(_color, type='_green')
</code></pre>
<p>But when i attempt to invoke any of those methods i get:</p>
<pre><code>rgb = RGB(100, 192, 240)
print rgb.red()
TypeError: _color() takes exactly 2 arguments (1 given)
</code></pre>
<p>I guess self is not passed to <code>_color</code> since <code>rgb.red(rgb)</code> works.</p>
</div>
<div class="post-text" itemprop="text">
<p>You are creating partials on the <em>function</em>, not the method. <code>functools.partial()</code> objects are not descriptors, they will not themselves add the <code>self</code> argument and cannot act as methods themselves. You can <em>only</em> wrap bound methods or functions, they don't work at all with unbound methods. This is <a href="http://docs.python.org/2/library/functools.html#partial-objects">documented</a>:</p>
<blockquote>
<p><code>partial</code> objects are like <code>function</code> objects in that they are callable, weak referencable, and can have attributes. There are some important differences. For instance, the <code>__name__</code> and <code>__doc__</code> attributes are not created automatically. Also, <code>partial</code> objects defined in classes behave like static methods and do not transform into bound methods during instance attribute look-up.</p>
</blockquote>
<p>Use <code>property</code>s instead; these <em>are</em> descriptors:</p>
<pre><code>class RGB(object):
    def __init__(self, red, blue, green):
        super(RGB, self).__init__()
        self._red = red
        self._blue = blue
        self._green = green

    def _color(self, type):
        return getattr(self, type)

    @property
    def red(self): return self._color('_red')
    @property
    def blue(self): return self._color('_blue')
    @property
    def green(self): return self._color('_green')
</code></pre>
<p>As of Python 3.4, you can use the new <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod"><code>functools.partialmethod()</code> object</a> here; it'll do the right thing when bound to an instance:</p>
<pre><code>class RGB(object):
    def __init__(self, red, blue, green):
        super(RGB, self).__init__()
        self._red = red
        self._blue = blue
        self._green = green

    def _color(self, type):
        return getattr(self, type)

    red = functools.partialmethod(_color, type='_red')
    blue = functools.partialmethod(_color, type='_blue')
    green = functools.partialmethod(_color, type='_green')
</code></pre>
<p>but these'd have to be called, whilst the <code>property</code> objects can be used as simple attributes.</p>
</div>
<span class="comment-copy">This is a useful question, and I don't want to detract from the main point, but as a side-issue question on your code I was wondering why you wrote super(RGB, self).__init__(), when RGB inherits from object?</span>
<span class="comment-copy">Got it. Thanks.</span>
<span class="comment-copy">What about <code>self.red = functools.partial(RGB._color, self, 'red')</code> in <code>__init__</code>? It is Python2 compatible too.</span>
<span class="comment-copy">@dashesy: sure, but that puts those objects on each instance (a memory cost), also making it harder for a subclass to replace them.</span>
