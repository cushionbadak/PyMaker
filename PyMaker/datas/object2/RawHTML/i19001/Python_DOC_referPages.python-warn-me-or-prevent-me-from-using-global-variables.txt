<div class="post-text" itemprop="text">
<p>I've gotten myself in trouble a few times now with accidentially (unintentionally) referencing global variables in a function or method definition.</p>
<p>My question is: is there any way to disallow python from letting me reference a global variable?  Or at least warn me that I am referencing a global variable?</p>
<pre><code>x = 123

def myfunc() :
    print x    # throw a warning or something!!!
</code></pre>
<p>Let me add that the typical situation where this arrises for my is using IPython as an interactive shell.  I use 'execfile' to execute a script that defines a class.  In the interpreter, I access the class variable directly to do something useful, then decide I want to add that as a method in my class.  When I was in the interpreter, I was referencing the class variable.  However, when it becomes a method, it needs to reference 'self'.  Here's an example.</p>
<pre><code>class MyClass :

    a = 1
    b = 2

    def add(self) :
        return a+b


m = MyClass()
</code></pre>
<p>Now in my interpreter I run the script 'execfile('script.py')', I'm inspecting my class and type: 'm.a * m.b' and decide, that would be a useful method to have.  So I modify my code to be, with the non-intentional copy/paste error:</p>
<pre><code>class MyClass :

    a = 1
    b = 2

    def add(self) :
        return a+b


    def mult(self) :
        return m.a * m.b   # I really meant this to be self.a * self.b
</code></pre>
<p>This of course still executes in IPython, but it can really confuse me since it is now referencing the previously defined global variable!</p>
<p>Maybe someone has a suggestion given my typical IPython workflow.  </p>
</div>
<div class="post-text" itemprop="text">
<p>First, you probably don't want to do this. As Martijn Pieters points out, many things, like top-level functions and classes, are globals.</p>
<p>You could filter this for only non-callable globals. Functions, classes, builtin-function-or-methods that you import from a C extension module, etc. are callable. You might also want to filter out modules (anything you <code>import</code> is a global). That still won't catch cases where you, say, assign a function to another name after the <code>def</code>. You could add some kind of whitelisting for that (which would also allow you to create global "constants" that you can use without warnings). Really, anything you come up with will be a very rough guide at best, not something you want to treat as an absolute warning.</p>
<p>Also, no matter how you do it, trying to detect implicit global access, but not explicit access (with a <code>global</code> statement) is going to be very hard, so hopefully that isn't important.</p>
<hr/>
<p>There is no obvious way to detect all implicit uses of global variables at the source level.</p>
<p>However, it's pretty easy to do with reflection from inside the interpreter.</p>
<p>The documentation for the <code>inspect</code> module has a nice chart that shows you the standard members of various types. Note that some of them have different names in <a href="https://docs.python.org/2/library/inspect.html" rel="nofollow noreferrer">Python 2.x</a> and <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">Python 3.x</a>.</p>
<p>This function will get you a list of all the global names accessed by a bound method, unbound method, function, or code object in both versions:</p>
<pre><code>def get_globals(thing):
    thing = getattr(thing, 'im_func', thing)
    thing = getattr(thing, '__func__', thing)
    thing = getattr(thing, 'func_code', thing)
    thing = getattr(thing, '__code__', thing)
    return thing.co_names
</code></pre>
<hr/>
<p>If you want to only handle non-callables, you can filter it:</p>
<pre><code>def get_callable_globals(thing):
    thing = getattr(thing, 'im_func', thing)
    func_globals = getattr(thing, 'func_globals', {})
    thing = getattr(thing, 'func_code', thing)
    return [name for name in thing.co_names
            if callable(func_globals.get(name))]
</code></pre>
<p>This isn't perfect (e.g., if a function's globals have a custom builtins replacement, we won't look it up properly), but it's probably good enough.</p>
<hr/>
<p>A simple example of using it:</p>
<pre><code>&gt;&gt;&gt; def foo(myparam):
...     myglobal
...     mylocal = 1
&gt;&gt;&gt; print get_globals(foo)
('myglobal',)
</code></pre>
<hr/>
<p>And you can pretty easily <code>import</code> a module and recursively walk its callables and call <code>get_globals()</code> on each one, which will work for the major cases (top-level functions, and methods of top-level and nested classes), although it won't work for anything defined dynamically (e.g., functions or classes defined inside functions).</p>
<hr/>
<p>If you only care about CPython, another option is to use the <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer"><code>dis</code></a> module to scan all the bytecode in a module, or .pyc file (or class, or whatever), and log each <code>LOAD_GLOBAL</code> op.</p>
<p>One major advantage of this over the <code>inspect</code> method is that it will find functions that have been compiled, even if they haven't been created yet.</p>
<p>The disadvantage is that there is no way to look up the names (how could there be, if some of them haven't even been created yet?), so you can't easily filter out callables. You can try to do something fancy, like connecting up <code>LOAD_GLOBAL</code> ops to corresponding <code>CALL_FUNCTION</code> (and related) ops, but… that's starting to get pretty complicated.</p>
<hr/>
<p>Finally, if you want to hook things dynamically, you can always replace <code>globals</code> with a wrapper that warns every time you access it. For example:</p>
<pre><code>class GlobalsWrapper(collections.MutableMapping):
    def __init__(self, globaldict):
        self.globaldict = globaldict
    # ... implement at least __setitem__, __delitem__, __iter__, __len__
    # in the obvious way, by delegating to self.globaldict
    def __getitem__(self, key):
        print &gt;&gt;sys.stderr, 'Warning: accessing global "{}"'.format(key)
        return self.globaldict[key]

globals_wrapper = GlobalsWrapper(globals())
</code></pre>
<p>Again, you can filter on non-callables pretty easily:</p>
<pre><code>    def __getitem__(self, key):
        value = self.globaldict[key]
        if not callable(value):
            print &gt;&gt;sys.stderr, 'Warning: accessing global "{}"'.format(key)
        return value
</code></pre>
<p>Obviously for Python 3 you'd need to change the <code>print</code> statement to a <code>print</code> function call.</p>
<p>You can also raise an exception instead of warning pretty easily. Or you might want to consider using the <a href="https://docs.python.org/3/library/warnings.html" rel="nofollow noreferrer"><code>warnings</code></a> module.</p>
<p>You can hook this into your code in various different ways. The most obvious one is an import hook that gives each new module a <code>GlobalsWrapper</code> around its normally-built <code>globals</code>. Although I'm not sure how that will interact with C extension modules, but my guess is that it will either work, or be harmlessly ignored, either of which is probably fine. The only problem is that this won't affect your top-level script. If that's important, you can write a wrapper script that <code>execfile</code>s the main script with a <code>GlobalsWrapper</code>, or something like that.</p>
</div>
<span class="comment-copy">Why would you want that? Other functions are usually globals too. So are imports from other modules. Classes are usually globals, etc. You'd get warnings <b>all the time</b>.</span>
<span class="comment-copy">@EpicAdv I assume your problem with global variable starts when you're updating its value somewhere else.</span>
<span class="comment-copy">PyLint shows a warning when you use the "global" statement.</span>
<span class="comment-copy">@Markon: I don't think that would help him. He's using a global variable accidentally, <i>without</i> using the <code>global</code> statement.</span>
<span class="comment-copy">You can't reference a global variable that you don't define in the first place.</span>
<span class="comment-copy">Thank you for the very thorough response.  I'm intrigued by this last idea, but I'm struggling as how to exactly implement it.  I get the error: Can't instantiate abstract class GlobalsWrapper with abstract methods <b>delitem</b>, <b>iter</b>, <b>len</b>, <b>setitem</b></span>
<span class="comment-copy">@EpicAdv: That's what the <code># ...</code> is for. You need to implement all of the <code>MutableMapping</code> methods. The <a href="http://docs.python.org/2/library/collections.html#collections-abstract-base-classes" rel="nofollow noreferrer">documentation</a> explains this. It even has a complete example implementing <code>Set</code> on top of <code>list</code>—not quite the same as <code>Mapping</code> on top of <code>dict</code>, but the chart and text above should make it obvious what to do. (Also, anyone who doesn't know how to implement a collection ABC will probably not be able to implement an import hook.)</span>
<span class="comment-copy">@abernert: Thanks for the clarification.  I now am creating the GlobalsWrapper class by implementing all of the required methods.  My confusion remains in how to best access the globals dict and wrap it. <code>globals</code> is a function the returns the global dict, so we can't instantiate GlobalsWrapper as you show (I think), rather I think it needs to be <code>global_wrapper = GlobalsWrapper(globals())</code>. I also added a <code>__call__</code> method to the GlobalsWrapper that returns the dict, but that doesn't seem to work (e.g. globals_wrapper()['some_var'] doesn't warn me).</span>
<span class="comment-copy">@EpicAdv: Yes, sorry, the missing parents in the constructor call were a typo. I'll edit that. But as for the rest… How did you hook this into your code? Just creating this object won't have any effect if you don't actually use it. Also, why did you add a <code>__call__</code> method?</span>
<span class="comment-copy">@EpicAdv: Anyway, when I try this, with a quick hacky test, where I just do <code>globals = lambda: globals_wrapper</code> then <code>print sys</code> and <code>print asdfgh</code>, I get a warnings printed to <code>stderr</code> followed by the module being printed out, then a warning printed to <code>stderr</code> followed by a <code>KeyError</code> traceback. Just as you'd expect.</span>
