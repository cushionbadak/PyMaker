<div class="post-text" itemprop="text">
<p>I have a Python application written on the Pyramid framework.</p>
<p>We <em>really</em> take advantage of logging on this ( for debugging ) , using the standard import library.</p>
<p>As we profile stuff on production, it seems that there is quite a bit of overhead from our logging activity.  All the string formatting and loops add up.  I'd love to remove it, but we can't -- we do actually need to keep it in for testing and will sometimes need to debug on the production environment.</p>
<p>I'm wondering if anyone has effective strategies for minimizing logging as needed , so this code could get "optimized away" during execution on our production environment and simply not run .</p>
<p>For example, under mod_perl, the compiler would "optimize away" statements run under False constants</p>
<p>in psuedocode...  ( i haven't touched perl in a long time! )</p>
<pre><code>use constant DEBUG =&gt; False ;
if ( DEBUG ) {
      log.debug("stuff here " + string );
}
</code></pre>
<p>or</p>
<pre><code>use constant DEBUG =&gt; False ;
DEBUG &amp;&amp; log.debug("stuff here " + string );
</code></pre>
<p>Under those scenarios, the call to log.debug and even the string interpolation would never happen.</p>
<p>Can anyone recommend an effective method of mimicking that behavior under Python ?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>__debug__</code>.  This flag is set to <code>False</code> when Python is run with the <code>-O</code> command line flag, and Python will furthermore <em>optimize out debug code at compile time.</em> I <a href="http://www.engyrus.com/2013/03/idtkap-4-debug-and-o.html" rel="noreferrer">wrote a blog post on it</a> a couple months ago.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't use concatenation when you can use <code>log.debug('stuff here %s', string)</code>; the logging module postpones interpolation until actually formatting the string when logging. If the <code>DEBUG</code> log level has been disabled, no interpolation takes place.</p>
<p>You can also test the logging level to avoid gathering expensive logging information unless needed:</p>
<pre><code>if logger.isEnabledFor(logging.DEBUG):
    logger.debug('Message with %s, %s', expensive_func1(),
                                        expensive_func2())
</code></pre>
<p>See the <a href="http://docs.python.org/2/howto/logging.html#optimization">optimization section of the Logging HOWTO</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suggest to use <code>assert</code> for that purpose, as it nicely is optimized away in optimized mode.</p>
<p>In this case, it is not necessary to manually check if the logging level is enabled. This is especially useful when doing expensive formatting operations that can be useful for logging (like with the <code>pprint</code> module).</p>
<p>An example:</p>
<p>Instead of</p>
<p><code>logging.debug('my message %s', pprint.pformat(mycomplexdata))</code></p>
<p>you would write</p>
<p><code>assert(logging.debug('my message %s', pprint.pformat(mycomplexdata)) or True)</code></p>
<p>(The part <code>or True</code> makes sure the assertion does not fail.)</p>
<p>It is even possible to use <code>.format</code> in this case without performance penalty when running with <code>-O</code>.</p>
<p><code>assert(logging.debug('my message {}'.format(pprint.pformat(mycomplexdata))) or True)</code></p>
<p>Everything in assert() is optimized away when running python with <code>-O</code>.</p>
</div>
<span class="comment-copy">thanks Martijn, that's a great tip.  You should repost it as an answer.</span>
<span class="comment-copy">Posted with some expansion.</span>
<span class="comment-copy">Thanks, @kindall - that's a great trick.  you have no idea how much i'm smiling right now.</span>
<span class="comment-copy">It's sad that you have to use an <code>if</code> in your code. It would have been possible for <code>logger</code> to have been made smart enough to accept <code>logger.debug('Message with %s, %s', expensive_func1, expensive_func2)</code> and only call the func if needed. I guess you could do that with a wrapper, but I hate how much boilerplate there is for logging. It causes people to avoid logging or do it poorly.</span>
<span class="comment-copy">It is actually not strictly necessary to use an explicit if to completely deactivate execution of the logging code in optimized mode (see my answer below). I wonder if my answer has any drawbacks that I cannot see (except for an obvious abuse of <code>assert</code>).</span>
<span class="comment-copy">@pesch√º: well, the abuse itself is already one such drawback; readability definitely suffers.</span>
<span class="comment-copy"><code>assert</code> is a statement, not a function: <code>assert logging.debug('my message %s', pprint.pformat(mycomplexdata)) or True</code></span>
<span class="comment-copy">Rather than abuse <code>assert</code>, use the <a href="https://docs.python.org/3/library/constants.html#__debug__" rel="nofollow noreferrer"><code>__debug__</code> constant</a>, so use <code>if __debug__:</code>. The compiler will either include the block under <code>if</code> or omit it entirely (so <b>no actual <code>if</code> test is included</b>).</span>
<span class="comment-copy">In other words, using <code>assert</code> is the ugly ugly version of using the accepted answer.</span>
<span class="comment-copy">Thank you, I was not aware that the <code>if __debug__</code> statements are actually removed by the optimizer.</span>
