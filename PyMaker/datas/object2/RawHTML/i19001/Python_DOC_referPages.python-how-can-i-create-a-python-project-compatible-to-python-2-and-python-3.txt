<div class="post-text" itemprop="text">
<p>I want to create a package which should be compatible to Python 2.7 and Python 3.3.
The logic should exist only once. </p>
<p><strong>How do you normally represent the programming logic - in Python 2.7 or Python 3.3? 
Or do you choose a different way?</strong></p>
<p><strong>EDIT:</strong> How this issue is handled in the core?</p>
</div>
<div class="post-text" itemprop="text">
<p>You do it by quite simply only using those bits of the language that is the same, and by having conditions or exception handling during other parts.</p>
<p>This is harder or easier depending on what your software do, and what versions of Python you need to support. By supporting just Python 2.6, 2.7 and 3.3 it becomes relatively simple.</p>
<p>Exactly <em>how</em> you do it is not answerable in a question on SO, because there is a lot to it. </p>
<p>I recommend you check out this book: <a href="http://python3porting.com/" rel="nofollow">http://python3porting.com/</a> , especially the chapter "Supporting Python 2 and 3 without 2to3 conversion" and the Appendices, that has loads of examples of how to solve most incompatibilities.</p>
<p>The <a href="https://pypi.python.org/pypi/six" rel="nofollow">six</a> library may also be useful. </p>
</div>
<div class="post-text" itemprop="text">
<p>I tend to use a number of <code>__future__</code> imports (which are, presumably, safely ignored in Python 3), and the occasionaly <code>try except</code> for some import statements. In addition, I define a stringtype for <code>basestring / str</code> compatibility. Just depending on what I need per module.</p>
<p>For example:</p>
<pre><code>from __future__ import absolute_import
from __future__ import unicode_literals
from __future__ import division
from __future__ import print_function
try:
    import ConfigParser as cfgparser
except ImportError:
    import configparser as cfgparser
try:
    stringtype = basestring
except NameError:
    stringtype = str
</code></pre>
<p>I think the <a href="http://pythonhosted.org/six/" rel="nofollow">six</a> package already does this, so that may be another good option.</p>
</div>
<span class="comment-copy">Python3 isn't 100% backwards compatible with Python2 so you would have to be very choosy when it comes to what functions to use.</span>
<span class="comment-copy"><a href="http://docs.python.org/2/library/2to3.html" rel="nofollow noreferrer">docs.python.org/2/library/2to3.html</a></span>
<span class="comment-copy">@AshwiniChaudhary <code>2to3</code> converts Python 2.x code to Python 3 code that isn't backwards-compatible with Python 2.7.</span>
<span class="comment-copy">So, do you recommend coding the package in Python 2.7 and convert it later to Python 3.3?</span>
<span class="comment-copy">See the <a href="http://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">Porting HOWTO</a>. That document is pretty comprehensive.</span>
<span class="comment-copy">Also, <code>from io import open</code> gives you strictly the Python 3 <code>open</code> builtin (with, among other things, its platform-independent meaning of binary vs text files).</span>
<span class="comment-copy">This is just a small sample of the things you need to do. I don't think it as such is a very useful answer.</span>
<span class="comment-copy">@lennart I agree that it's not complete. It's just what I need to use, and mostly on a per-module basis (thus, the <code>ConfigParser</code> import isn't always there). It serves more as an example than as a complete answer, which I thought may be useful to get someone started. For a more complete answer, the <a href="http://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">porting howto</a> Martijn has pointed out does contain most of that info (it mentions <code>six</code> as well).</span>
<span class="comment-copy">I would advise against using the <code>unicode_literals</code> future module mainly because of the regressions with other modules/3rd-party libs I've encountered as stated <a href="http://python-future.org/imports.html#drawbacks" rel="nofollow noreferrer">in the futures doc</a>. Its a lot of trouble to fix. A more cautious approach, such as using the <code>u''</code> prefix is preferable. I upvoted because of the boilerplate.</span>
