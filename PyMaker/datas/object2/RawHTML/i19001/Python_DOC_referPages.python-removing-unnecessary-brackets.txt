<div class="post-text" itemprop="text">
<p>I wrote a very simple function in Python, that prints out all prime numbers within a specific sequence. </p>
<p>It works fine, but the results it gives me have way too many brackets/parentheses in them. I'd like to get the result as one output with a single list including all of the numbers, rather than a lot of outputs, each containing a single number.</p>
<p>Here's the code:</p>
<pre><code>def prime_list(X, Y):
    Z = 0
    while X &lt;= Y:
        if is_prime(X):
            Z = Z, X
        X = X + 1
    print (Z)
</code></pre>
<p>The function <code>is_prime()</code> used in the code simply returns <code>True</code>, if the number is a prime number, and <code>False</code>, if it isn't.</p>
<p>Basically, for every loop, it checks if <code>X</code> is a prime number. If it is, <code>X</code> will be added to the list called <code>Z</code>. Although, when it does this, it also adds unnecessary brackets/parentheses to the list. Here's the result, using the sequence 1-100:</p>
<pre><code>&gt;&gt;&gt; prime_list(1,100)
(((((((((((((((((((((((((0, 2), 3), 5), 7), 11), 13), 17), 19), 23), 29), 31), 37), 41), 43), 47), 53), 59), 61), 67), 71), 73), 79), 83), 89), 97)
</code></pre>
<p>As you can see, there are way too many brackets/parentheses.</p>
<p>How can I rewrite the code, so it doesn't make these?</p>
</div>
<div class="post-text" itemprop="text">
<p>Just append to a list instead of nesting tuples:</p>
<pre><code>def prime_list(X, Y):
    Z = []
    while X &lt;= Y:
        if is_prime(X):
            Z.append(X)
        X = X + 1
    return Z
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not a direct answer, but here's a cleaner and shorter way:</p>
<pre><code>def prime_list(X, Y):
    return [ x for x in range(X, Y+1) if is_prime(x) ]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can also concatenate tuples (notice the trailing comma when appending to <code>Z</code>):</p>
<pre><code>def prime_list(X, Y):
    Z = ()
    while X &lt;= Y:
        if is_prime(X):
            Z += X,
        X = X + 1
    print (Z)
</code></pre>
<p>Not sure which is more efficient: appending to a list or concatenating tuples...</p>
</div>
<div class="post-text" itemprop="text">
<p>In the line "z = z, x", what you've done is to assign to z a list containing z and x. After the first time, z is always a list when you arrive here, so you get a new list, containing the old list, and an integer. So, z = 0 at the start, then 0, 1 next, and then it goes oval... The next time, it becomes (0, 1), 2; the previous list (the old z), and the new x. Next time, you get ((0, 1), 2), 3, and so on.</p>
<p>If you use z.append(x), it adds an additional item to the list, rather than creating a new, 2 element list each time. Using z.append(x), in the end, you'll get (0, 1, 2, 3, ...), which is closer to what you'd thought you'd get.</p>
</div>
<span class="comment-copy">As a side note, speaking of unnecessary brackets: You don't want <code>print (Z)</code>. If this is Python 2.x, just do <code>print Z</code>. If it's 3.x, <code>print</code> is a function call, just like <code>is_prime</code>, so do <code>print(Z)</code>.</span>
<span class="comment-copy">More importantly, you probably want to <code>return Z</code> anyway, not <code>print Z</code>. That means you can write code that calls <code>prime_list</code> and does something with the resulting list, besides just printing it out and throwing it away.</span>
<span class="comment-copy">@abarnert Thanks, good points. I'm not used to working with lists though, so I suppose that's why I made it <code>print</code> and not <code>return</code></span>
<span class="comment-copy">Thanks, this worked. I'm new to Python, though, so I don't quite understand how lists and .append works</span>
<span class="comment-copy">@kongehund: Have you read the <a href="http://docs.python.org/3/tutorial/introduction.html#lists" rel="nofollow noreferrer">tutorial</a>? Or a third-party tutorial? (The official one isn't that novice-friendly, although it's <i>great</i> if you're a C expert with some experience with perl, Self, Haskell, and Icon…)</span>
<span class="comment-copy">@abarnert It's <i>great</i> if you know any other programming language, why would you have to be expert in C and know perl, Self, Haskell and Icon? I learned just well from the official tutorial by knowing nothing but Lua :)</span>
<span class="comment-copy">@abarnert Thanks for the link. Python is the first language for me to program in, as I started programming relatively recently. I'm learning Python from a book, so I haven't read the official tutorial.</span>
<span class="comment-copy">@MarkusMeskanen: A <i>lot</i> of things are explained as "like C", and a few things are explained as "just like" one of the other languages. For example: "Strings can be subscripted (indexed); like in C, the first character of a string has subscript (index) 0… Like in Icon, substrings can be specified with the slice notation…" Really, the tutorial has only been modestly updated since the original version in the 90s, when it was reasonable to assume that everyone learning Python knew C and probably Perl. (I have no idea why there are references to Icon and Self…)</span>
<span class="comment-copy">That's a type error (<code>Z = 0; Z += 1,</code>).</span>
<span class="comment-copy">Appending to a list is going to be more efficient (because it's in-place, whereas concatenating tuples constructs new tuples objects every time), but the main issue I have with this is that the function is called <code>prime_list</code>; it's kind of implied to return a list.</span>
<span class="comment-copy">Thanks @Cairnarvon!</span>
<span class="comment-copy">@Cairnarvon: Being in-place doesn't <i>necessarily</i> make it faster; there are plenty of examples where that isn't true (e.g., <code>filter</code> or a listcomp almost always beats deleting in-place). If it matters, you need to test. (And it probably doesn't matter). But 100% agreed with your main issue.</span>
