<div class="post-text" itemprop="text">
<p>I have the following directory:</p>
<pre><code>mydirectory
├── __init__.py
├── file1.py 
└── file2.py
</code></pre>
<p>I have a function f defined in file1.py.</p>
<p>If, in file2.py, I do</p>
<pre><code>from .file1 import f
</code></pre>
<p>I get the following error:</p>
<blockquote>
<p>SystemError: Parent module '' not loaded, cannot perform relative
  import</p>
</blockquote>
<p>Why? And how to make it work?</p>
</div>
<div class="post-text" itemprop="text">
<p>since <code>file1</code> and <code>file2</code> are in the same directory, you don't even need to have an <code>__init__.py</code> file.  If you're going to be scaling up, then leave it there.</p>
<p>To import something in a file in the same directory, just do like this</p>
<p><code>from file1 import f</code></p>
<p>i.e., you don't need to do the relative path <code>.file1</code> because they are in the same directory.</p>
<p>If your main function, script, or whatever, that will be running the whole application is in another directory, then you will have to make everything relative to wherever that is being executed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Launching modules inside a package as executables is a <em>bad practice</em>.</p>
<p>When you develop something you either build a library, which is intended to be imported by other programs and thus it doesn't make much sense to allow executing its submodules directly, or you build an executable in which case there's no reason to make it part of a package.</p>
<p>This is why in <code>setup.py</code> you distinguish between packages and scripts. The packages will go under <code>site-packages</code> while the scripts will be installed under <code>/usr/bin</code> (or similar location depending on the OS).</p>
<p>My recommendation is thus to use the following layout:</p>
<pre><code>/
├── mydirectory
|    ├── __init__.py
|    ├── file1.py 
└── file2.py
</code></pre>
<p>Where <code>file2.py</code> imports <code>file1.py</code> as any other code that wants to use the library <code>mydirectory</code>, with an <em>absolute import</em>:</p>
<pre><code>from mydirectory.file1 import f
</code></pre>
<p>When you write a <code>setup.py</code> script for the project you simply list <code>mydirectory</code> as a package and <code>file2.py</code> as a script and everything will work. No need to fiddle with <code>sys.path</code>.</p>
<p>If you ever, for some reason, really want to actually run a submodule of a package, the proper way to do it is to use the <code>-m</code> switch:</p>
<pre><code>python -m mydirectory.file1
</code></pre>
<p>This loads the whole package and then executes the module as a script, allowing the relative import to succeed.</p>
<p>I'd personally avoid doing this. Also because a lot of people don't even know you can do this and will end up getting the same error as you and think that the package is broken.</p>
<hr/>
<p>Regarding the currently accepted answer, which says that you should just use an <em>implicit</em> relative import <code>from file1 import f</code> because it will work since they are in the same directory:</p>
<p>This is <strong>wrong</strong>! </p>
<ul>
<li>It will <em>not</em> work in python3 where implicit relative imports are disallowed and will surely break if you happen to have installed a <code>file1</code> module (since it will be imported instead of your module!).</li>
<li><p>Even if it works the <code>file1</code> will not be seen as part of the <code>mydirectory</code> package. This <em>can</em> matter. </p>
<p>For example if <code>file1</code> uses <code>pickle</code>, the name of the package is important for proper loading/unloading of data.</p></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>When launching a python source file, it is forbidden to import another file, that is in the current package, using relative import. </p>
<p>In <a href="http://docs.python.org/3/tutorial/modules.html#intra-package-references" rel="nofollow noreferrer">documentation</a> it is said:</p>
<p><em>Note that relative imports are based on the name of the current module. Since the name of the main module is always "__main__", modules intended for use as the main module of a Python application must always use absolute imports.</em></p>
<p>So, as <a href="https://stackoverflow.com/users/2077015/mrkelley">@mrKelley</a> said, you need to use absolute import in such situation.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>myproject/

mypackage
├── __init__.py
├── file1.py
├── file2.py 
└── file3.py

mymainscript.py
</code></pre>
<p>Example to import from one file to another</p>
<pre><code>#file1.py
from myproject import file2
from myproject.file3 import MyClass
</code></pre>
<p>Import the package example to the mainscript</p>
<pre><code>#mymainscript.py
import mypackage
</code></pre>
<p><a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow">https://docs.python.org/3/tutorial/modules.html#packages</a></p>
<p><a href="https://docs.python.org/3/reference/import.html#regular-packages" rel="nofollow">https://docs.python.org/3/reference/import.html#regular-packages</a></p>
<p><a href="https://docs.python.org/3/reference/simple_stmts.html#the-import-statement" rel="nofollow">https://docs.python.org/3/reference/simple_stmts.html#the-import-statement</a></p>
<p><a href="https://docs.python.org/3/glossary.html#term-import-path" rel="nofollow">https://docs.python.org/3/glossary.html#term-import-path</a></p>
<p>The variable sys.path is a list of strings that determines the interpreter’s search path for modules. It is initialized to a default path taken from the environment variable PYTHONPATH, or from a built-in default if PYTHONPATH is not set. You can modify it using standard list operations:</p>
<pre><code>import sys
sys.path.append('/ufs/guido/lib/python')
sys.path.insert(0, '/ufs/guido/myhaxxlib/python')
</code></pre>
<p>Inserting it at the beginning has the benefit of guaranteeing that the path is searched before others (even built-in ones) in the case of naming conflicts.</p>
</div>
<span class="comment-copy">Are you running <code>file2.py</code> directly?</span>
<span class="comment-copy">yes I'm doing: <code>python3 file2.py</code> from the command line</span>
<span class="comment-copy">If a python module is part of a package you <i>shouldn't</i> launch it as main. If you distribute your library the packages will go into <code>site-packages</code> but scripts should go to <code>/usr/bin</code> or something like that(hence the need for absolute imports). There should be a clear distinction between a python module that was written to be executed and one that was written to be part of a library.</span>
<span class="comment-copy">@Bakuriu Your comment should be an answer.</span>
<span class="comment-copy">@kevin Thanks. I've decided to expand it a bit and add it as an answer.</span>
<span class="comment-copy">This assumes that there is no other <code>file1</code> in the PYTHONPATH.</span>
<span class="comment-copy">Is it also a bad practice if you have a unit test file in the same directory and you want to run that unit test file?</span>
<span class="comment-copy">@gsanta Why would you put unittests there? The typical project structure have a <code>test</code> or <code>tests</code> directory that contains all the test file, while the actual sources are in a different directory.</span>
<span class="comment-copy">I'm coming from the 'javascript world' where there is a growing trend of putting the unit test file next to the file you want to test, and I find it to be a good practice. But maybe it is not so popular in python programming. (And sometimes I would like to run only that test file not all the unit test files, when I want to quickly verify that it is working)</span>
<span class="comment-copy">@gsanta It seems like Javascript lacks proper test discovery tools. For example in python using Nose it's trivial to automatically discover the tests, and also you can simply invoke it with the name of the test as argument and it will only perform those tests... if you only work from an IDE, they usually provide a built-in tester that does the same. Basically doing that is only slightly more convenient if you do everything by hand.</span>
<span class="comment-copy">Nah JS has that. I too am coming from the JS world and find this "bad practice" a bit peculiar.</span>
