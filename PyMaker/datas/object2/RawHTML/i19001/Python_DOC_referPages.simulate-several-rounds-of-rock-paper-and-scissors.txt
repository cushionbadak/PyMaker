<div class="post-text" itemprop="text">
<p>I am trying to implement a function that takes an integer n and simulates n rounds of Rock, Paper, Scissors between players Player 1 and Player 2. The player who wins the most rounds wins the n-round game, with ties possible. The function should print the result of the game as shown.</p>
<pre><code>    &gt;&gt;&gt; simul(1)
    Player 1
    &gt;&gt;&gt; simul(1)
    Tie
    &gt;&gt;&gt;simul(100)
    Player 2
</code></pre>
<p>I think I need to approach this in a modular fashion. In other words, I need to combine at least 2 functions, my problem is that I can't seem to figure out how to do that. How can I activate the result from an embedded function when calling the <code>simul()</code> function?</p>
<p>So I have created a function that simulates the game Rock, Paper, Scissors by execution the function <code>rps(p1, p2)</code>. The code is the following:</p>
<pre><code>    def rps(p1,p2):
        #tie
        if (p1==p2):
            return 0
        # player 1 wins    
        elif p1+p2 in ['PR','RS','SP']:
            return -1
        else:
            return 1
        # player 2 wins
</code></pre>
<p>This is where I'm a bit stuck. I need to activate this function when executing the <code>simul()</code> function—how can I do that? What I have so far is the following:</p>
<pre><code>    def rps(p1,p2):
    #tie
        if (p1==p2):
            return 0
    # player 1 wins    
        elif p1+p2 in ['PR','RS','SP']:
            return -1
        else:
            return 1
    # player 2 wins

    def choose_rps():
        import random
        random.choice('RPS')

    def simul(n):
        p1_wins, p2_wins = 0, 0
        for i in range(n):
            p1 = choose_rps()
            p2 = choose_rps()
            result = rps(p1, p2)
            if result == -1:
                p1_wins += 1
            elif result == 1:
                p2_wins += 1
            if p1_wins &gt; p2_wins:
                return 'Player 1'
            elif p1_wins == p2_wins:
                return 'Tie'
            else:
                return 'Player 2'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To "activate" a function, you just call it. For example:</p>
<pre><code>def simul(n):
    score = 0
    for i in range(n):
        p1 = choose_rps()
        p2 = choose_rps()
        result = rps(p1, p2)
        score += result
    if score &lt; 0:
        print('Player 1')
    elif score == 0:
        print('Tie')
    else:
        print('Player 2')
</code></pre>
<p>Of course you need to write the <code>choose_rps</code> function (which <a href="http://docs.python.org/3/library/random.html#random.choice" rel="nofollow">randomly chooses</a> and returns one of <code>R</code>, <code>P</code>, or <code>S</code>)—but, as you can see, you just call it the same way as the <code>rps</code> function.</p>
<hr/>
<p>To put it all together into a script:</p>
<pre><code>def rps(p1, p2):
    # ... your code here

def choose_rps():
    # implement this here

def simul(n):
    # code from above
</code></pre>
<p>And then you'll probably want something to drive it, such as this:</p>
<pre><code>if __name__ == '__main__':
    import sys
    n = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 5
    simul(n)
</code></pre>
<p>… or…</p>
<pre><code>while True:
    n = int(input('How many trials?')) # raw_input for Python 2.x
    simul(n)
</code></pre>
<hr/>
<p>If you want, you can simplify this further. For example, you can turn the whole loop into a <code>sum</code> call with a generator expression:</p>
<pre><code>def simul(n):
    score = sum(rps(choose_rps(), choose_rps()) for _ in range(n))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is an equivalent function without the RPS narrative:</p>
<pre><code>import random

def simul(n):
    score = sum([random.choice([-1, 0, 1]) for i in xrange(n)])
    winner_idx = 0 if score &gt; 0 \
            else 1 if score &lt; 0 \
            else 2
    print ['Player 1', 'Player 2', 'Tie'][winner_idx]
</code></pre>
<p>Here is one that follows the story and is expanded to Rock, Paper, Scissors, Lizard, Spock:</p>
<pre><code>import random

def rand_RPSLK():
    while True:
        yield random.choice('PSKLR')

def simul(n):
    p1 = rand_RPSLK()
    p2 = rand_RPSLK()
    choice = lambda px: 'PSKLR'.index(next(px))
    score = sum([[0,1,-1,1,-1][choice(p1)-choice(p2)] for i in xrange(n)])
    winner_idx = 0 if score &gt; 0 \
            else 1 if score &lt; 0 \
            else 2
    print ['Player 1', 'Player 2', 'Tie'][winner_idx]
</code></pre>
</div>
<span class="comment-copy">Thanks, but how do i merge the two functions code wise - in other words, how do I write the the functions into one code? rps must be first right?</span>
<span class="comment-copy">hmm, I gues I have never seen a choose function :)</span>
<span class="comment-copy">@Snarre: Let me edit the answer to deal with your first question. But really, this should be covered in whatever tutorial or class got you far enough to write any of this…</span>
<span class="comment-copy">is it random.choice(rps) ??</span>
<span class="comment-copy">Close, but <code>random.choice</code> takes a sequence (list, string, etc.) of values to choose from. <code>rps</code> isn't a sequence of values, it's a function. You want it to choose from the values <code>'R'</code>, <code>'P'</code>, and <code>'S'</code>, so <code>random.choice('RPS')</code>. (Also, make sure to <code>import random</code> at the top of the script.)</span>
<span class="comment-copy">This is missing the crucial bit of simulating the <code>rps</code> function. Of course you know that this game has an equal chance of win/draw/lose, but the whole point of simulating games is when you <i>don't</i> know that. Or, if you want to ignore that, why even bother to sum up n games, when you can just calculate the result with a single call to <code>random</code>?</span>
<span class="comment-copy">More than one game in a series does not have an equal chance of win, loose, or draw.  Win or Loose are equal, but tie gets lower in probability as the n increases, which is why the sum is needed. See how often n=1000 results in tie.  This program provides exactly the same statistical output behavior as the more complex version that is built to model the narrative.</span>
<span class="comment-copy">Who said anything about an N-game series having an equal distribution? It's trivial to <i>calculate</i> the distribution given N, and then make a single call to <code>random.random</code>.</span>
<span class="comment-copy">More importantly, you're still missing the point. You are not simulating the game. "This program provides exactly the same statistical output behavior…" is of course true, but the only way you <i>know</i> it's true is that you've analyzed the game and determined its statistical behavior without needing to simulate it. The reason you write simulations is to validate, or substitute for, analysis. Your code is like validating that <code>sum(range(n))==n*(n-1)/2</code> by writing a <code>sum</code> function that returns <code>n*(n-1)/2</code> and then comparing its result to <code>n*(n-1)/2</code>.</span>
<span class="comment-copy">Can you show it?  I think my equivalent function captures the essence of the problem without unneeded additional complexity but also without being too obtuse as to hide what is being done.  The problem is essentially to model the outcome of a series of games.</span>
