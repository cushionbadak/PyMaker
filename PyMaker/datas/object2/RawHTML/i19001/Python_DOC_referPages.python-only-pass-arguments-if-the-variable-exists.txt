<div class="post-text" itemprop="text">
<p>I have the following variables that a user can optionally submit through a form (they are not required, but may do this to filter down a search).</p>
<pre><code>color = request.GET.get ('color')
size = request.GET.get ('size')
</code></pre>
<p>Now I want to pass these variables to a function, but only if they exist. If they do not exist I want to just run the function without arguments.</p>
<p>the function without arguments is:</p>
<pre><code>apicall = search ()
</code></pre>
<p>with color only it's</p>
<pre><code>apicall = search (color)
</code></pre>
<p>and with color and size it's</p>
<pre><code>apicall = search (color, size)
</code></pre>
<p>If the argument is defined I want to pass it to the function, but if it's not I do not want to pass it.</p>
<p>What is the most efficient way to do that? Does python have built-in methods for this?</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that's a standard <code>get</code> call (like on a dictionary), this ought to be easy. Define your function with <code>None</code> for the defaults for your parameters, and then pass <code>color</code> and <code>size</code> without bothering to check them! </p>
<pre><code>def apicall(color=None, size=None):
    pass # Do stuff

color = request.GET.get('color')
size = request.GET.get('size')
apicall(color, size)
</code></pre>
<p>This way, you only check for <code>None</code> arguments in one place (inside the function call, where you have to check anyway if the function can be called multiple ways). Everything stays nice and clean. Of course this assumes (like I said at the top) that your <code>get</code> call is like a normal Python dictionary's <code>get</code> method, which returns <code>None</code> if the value isn't found.</p>
<p>Finally, I notice that your function name is <code>apicall</code>: there's a chance you don't actually have access to the function code itself. In this case, since you may not know anything about the default values of the function signature and <code>None</code> might be wrong, I would probably just write a simple wrapper to do the argument-checking for you. Then you can call the wrapper as above!</p>
<pre><code>def wrapped_apicall(color=None, size=None):
    if color is None and size is None:
        return apicall()
    # At least one argument is not None, so...
    if size is None:
        # color is not None
        return apicall(color)
    if color is None: 
        # size is not None
        return apicall(size)
    # Neither argument is None
    return apicall(color, size)
</code></pre>
<p><strong>NOTE:</strong> This second version <em>shouldn't be necessary</em> unless you can't see the code that you're calling and don't have any documentation on it! Using <code>None</code> as a default argument is very common, so chances are that you can just use the first way. I would only use the wrapper method if you can't modify the function you're calling and you don't know what its default arguments are (or its default arguments are module constants or something, but that's pretty rare).</p>
</div>
<div class="post-text" itemprop="text">
<p>meybe you can use something like this:</p>
<pre><code>try:
    apicall = search (color, size)
else:
    apicall = search(color)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As much as I like <a href="https://stackoverflow.com/users/2069350/henry-keiter">@HenryKeiter</a>'s <a href="https://stackoverflow.com/a/16576593/1224827">solution</a>, Python provides a MUCH easier way to check the parameters. In fact, there are a couple different solutions.</p>
<ol>
<li>For example, if <code>search()</code> is a standalone function and you want to view the args, you can use the <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer">inspect</a> module as seen in <a href="https://stackoverflow.com/a/218709/1224827">this solution</a>.</li>
</ol>
<p><strong>Example Code 1</strong></p>
<pre><code>&gt;&gt;&gt; import inspect
&gt;&gt;&gt; print(inspect.getfullargspec(search))

ArgSpec(args=['size', 'color'], varargs=None, keywords=None, defaults=(None, None))
</code></pre>
<ol start="2">
<li>However, if <code>search()</code> is a method of a class (we'll call it <code>Search</code>), then you can simply do use the built-in <a href="https://docs.python.org/3/library/functions.html#vars" rel="nofollow noreferrer">vars</a> function to see all of the class methods and their parameters:</li>
</ol>
<p><strong>Example Code 2</strong></p>
<pre><code>&gt;&gt;&gt; import Search
&gt;&gt;&gt; print(vars(Search))

mappingproxy({'__init__': &lt;function Search.__init__(self, size, color)&gt;,
                  'search': &lt;function Search.search(self, size, color)})
</code></pre>
<p>The only caveat with the 2nd method is that it's more useful as a visual inspection tool, rather than a programmatic one, although you could technically say <code>if 'size' in vars(Search)['search']: do something</code>. It just wouldn't be very robust. Easier and more durable to say <code>if 'size' in inspect.getfullargspec(Search.search).args: do something</code> or <code>for arg in inspect.getfullargsspec(Search.search).args: do something</code></p>
</div>
<div class="post-text" itemprop="text">
<p>When you're defining your method, if you set a default argument you can specify the argument or not.</p>
<pre><code>def search(color=None, size=None):
    pass
</code></pre>
<p>Then, when you call it, you can specify the keyword argument as you choose. Both of these would be valid:</p>
<pre><code>apicall = search(color=color)
apicall = search(size=size)
</code></pre>
</div>
<span class="comment-copy">Yes, but if i one of the variables is not defined then the <code>apicall (color, size)</code> will throw an error, won't it?</span>
<span class="comment-copy">Ok thanks... what you wrote is how I'd assume it to be done, but I was thinking there must be a more efficient way...</span>
<span class="comment-copy">@user1328021 Assuming both of these lines execute: <code>color = request.GET.get('color')</code> and  <code>size = request.GET.get('size')</code>, then both <code>color</code> and <code>size</code> are guaranteed to be <b>defined</b>, though they may be <code>None</code>. What do you think is inefficient about this?</span>
<span class="comment-copy">Ahh, I see. Thanks!</span>
<span class="comment-copy">I'm guessing this solution can be generalized to any number of variables using a decorator and a dictionary of arguments, though yet not precisely sure how. This is useful to prevent overwriting function parameters from partial assignment (specified with functools.partial)</span>
<span class="comment-copy">that wont work ... size is None , but it still exists ...</span>
