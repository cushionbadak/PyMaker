<div class="post-text" itemprop="text">
<p>I have developed a simple app in Python (2.7) with Tkinter. But my status bar is only sort of working. Here's the stripped down code:</p>
<pre><code>from Tkinter import *
import os
import sys

def fixFiles():
    inputFilePath= input_dir.get()

    #Build a list of files in a directory
    fileList = os.listdir(inputFilePath)

    #Loop through those files, open the file, do something, close the file
    for filename in fileList:
        infile = open(inputfilepath + "/" + filename,'r')

        #Update the status with the filename
        status_string = 'Status: Working on file: ' + str(filename)
        status.set(status_string)

        for line in infile:
            #Do some stuff here
        infile.close()  

class App:
    def __init__(self, master):
            i = 0
        status.set("Status: Press 'Fix Files!'")
        statuslabel = Label(master, textvariable=status, relief = RIDGE, width = 65, pady = 5, anchor=W)
        bFixFiles = Button(root, text='Fix Files!', command = fixFiles)
        bQuit = Button(root, text='Quit', command = root.destroy)

        statuslabel.grid(row=i, column = 0, columnspan = 2)
        bFixFiles.grid(row=i, column=2, sticky=E)
        bQuit.grid(row=i, column=3, sticky=W)

root = Tk()
root.title("FIX Files")
input_dir = StringVar()
status = StringVar()
choice = IntVar()
app = App(root)
root.mainloop()
</code></pre>
<p>Currently what's happening is that the status bar reads "Status: Press 'Fix Files!'" until the program is finished looping through the files, at which point it reads "Status: Working on file: XXXXX.txt" (which is the name of the last file to be opened and closed by the program.</p>
<p>I would like the status bar to update with the file name each time the program opens a new file. Any help is appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>The goofy way is to use <code>root.update_idletasks()</code>:</p>
<pre><code>#Update the status with the filename
status_string = 'Status: Working on file: ' + str(filename)
status.set(status_string)
root.update_idletasks()
</code></pre>
<p>To its credit, it is simple, but it does not really work -- although the <code>statuslabel</code> gets updated, the Quit button is frozen until <code>fixFiles</code> is completed. That's not very GUI-friendly. <a href="http://wiki.tcl.tk/1255" rel="noreferrer">Here are some more reasons</a> why <code>update</code> and <code>update_idletasks</code> are considered harmful.</p>
<hr/>
<p>So how should we run a long-running task without freezing the GUI?</p>
<p>The key is to make your callback functions end quickly. Instead of having a long-running <code>for-loop</code>, make a function that runs through the innards of the <code>for-loop</code> once. Hopefully that ends quickly enough for the user to not feel the GUI has been frozen. </p>
<p>Then, to replace the <code>for-loop</code>, you could use calls to <code>root.after</code> to call your quick-running function multiple times. </p>
<hr/>
<pre><code>from Tkinter import *
import tkFileDialog
import os
import sys
import time


def startFixFiles():
    inputFilePath = tkFileDialog.askdirectory()
    # inputFilePath= input_dir.get()

    # Build a list of files in a directory
    fileList = os.listdir(inputFilePath)
    def fixFiles():
        try:
            filename = fileList.pop()
        except IndexError:
            return
        try:
            with open(os.path.join(inputFilePath, filename), 'r') as infile:
                # Update the status with the filename
                status_string = 'Status: Working on file: ' + str(filename)
                status.set(status_string)
                for line in infile:
                    # Do some stuff here
                    pass
        except IOError:
            # You might get here if file is unreadable, you don't have read permission,
            # or the file might be a directory...
            pass
        root.after(250, fixFiles)
    root.after(10, fixFiles)

class App:
    def __init__(self, master):
        i = 0
        status.set("Status: Press 'Fix Files!'")
        statuslabel = Label(
            master, textvariable=status, relief=RIDGE, width=65,
            pady=5, anchor=W)
        bFixFiles = Button(root, text='Fix Files!', command=startFixFiles)
        bQuit = Button(root, text='Quit', command=root.destroy)

        statuslabel.grid(row=i, column=0, columnspan=2)
        bFixFiles.grid(row=i, column=2, sticky=E)
        bQuit.grid(row=i, column=3, sticky=W)

root = Tk()
root.title("FIX Files")
input_dir = StringVar()
status = StringVar()
choice = IntVar()
app = App(root)
root.mainloop()
</code></pre>
<hr/>
<p>The above begs the question, What should we do if our long-running task has no loop? or if even one pass through the loop requires a long time?</p>
<p>Here is a way to run the long-running task in a separate process (or thread), and have it communicate information through a queue which the main process can periodically poll (using <code>root.after</code>) to update the GUI status bar. I think this design is more easily applicable to this problem in general since it does not require you to break apart the <code>for-loop</code>.</p>
<p>Note carefully that all Tkinter GUI-related function calls <strong>must</strong> occur from a single thread. That is why the long-running process simply sends strings through the queue instead of trying to call <code>status.set</code> directly.</p>
<pre><code>import Tkinter as tk
import multiprocessing as mp
import tkFileDialog
import os
import Queue

sentinel = None

def long_running_worker(inputFilePath, outqueue):
    # Build a list of files in a directory
    fileList = os.listdir(inputFilePath)  
    for filename in fileList:
        try:
            with open(os.path.join(inputFilePath, filename), 'r') as infile:
                # Update the status with the filename
                status_string = 'Status: Working on file: ' + str(filename)
                outqueue.put(status_string)
                for line in infile:
                    # Do some stuff here
                    pass
        except IOError:
            # You might get here if file is unreadable, you don't have read permission,
            # or the file might be a directory...
            pass
    # Put the sentinel in the queue to tell update_status to end
    outqueue.put(sentinel)

class App(object):
    def __init__(self, master):
        self.status = tk.StringVar()
        self.status.set("Status: Press 'Fix Files!'")
        self.statuslabel = tk.Label(
            master, textvariable=self.status, relief=tk.RIDGE, width=65,
            pady=5, anchor='w')
        bFixFiles = tk.Button(root, text='Fix Files!', command=self.startFixFiles)
        bQuit = tk.Button(root, text='Quit', command=root.destroy)
        self.statuslabel.grid(row=1, column=0, columnspan=2)
        bFixFiles.grid(row=0, column=0, sticky='e')
        bQuit.grid(row=0, column=1, sticky='e')

    def update_status(self, outqueue):
        try:
            status_string = outqueue.get_nowait()
            if status_string is not sentinel:
                self.status.set(status_string)
                root.after(250, self.update_status, outqueue)
            else:
                # By not calling root.after here, we allow update_status to truly end
                pass
        except Queue.Empty:
            root.after(250, self.update_status, outqueue)

    def startFixFiles(self):
        inputFilePath = tkFileDialog.askdirectory()
        # Start long running process
        outqueue = mp.Queue()    
        proc = mp.Process(target=long_running_worker, args=(inputFilePath, outqueue))
        proc.daemon = True
        proc.start()
        # Start a function to check a queue for GUI-related updates
        root.after(250, self.update_status, outqueue)

root = tk.Tk()
root.title("FIX Files")
app = App(root)
root.mainloop()
</code></pre>
</div>
<span class="comment-copy">How long does it take to process each file? Maybe the operations are completed so quickly that you cannot notice the change of the label's text.</span>
<span class="comment-copy">Thanks, that was very helpful.</span>
<span class="comment-copy">For long-running tasks with no loop that get stuck without throwing any errors, try using the <i>spawn start method</i> with a context object as explained here: (<a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow noreferrer">docs.python.org/3/library/â€¦</a>). This worked for me in OS X 10.11.6 using Python 3.4.5.</span>
