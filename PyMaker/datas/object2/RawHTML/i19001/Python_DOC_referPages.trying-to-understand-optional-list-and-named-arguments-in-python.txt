<div class="post-text" itemprop="text">
<p>I'm a beginner at Python, trying to understand function arguments and their types and orders.</p>
<p>I tried to experiment a little with the different kinds of argument and here's my experiment</p>
<pre><code>def main():
    test_a(2, 33, 44)
    test_b(2, 33)
    test_c(2)
    ## test_d(2,,44) **Produces Invalid syntax**

    test_e(2,33,44,55,66)
    test_f(2, 44,55,66, y = 44)

    test_g(2, 33, 44,55,66, rofa = 777, nard = 888)
    ##test_h(2, 33, foo = 777, boo = 888, 44,55,66)  **Invalid Syntax in Function definition
    ##test_l(2, 44,55,66 ,  foo= 777, boo = 888, y  = 900) **Invalid Syntax in Function definition
    test_m(2, 44,55,66 , y = 900, foo=77777 , boo = 88888)

#############################################################
## NO optional arguments
def test_a(x,y,z):
    print("test_a : x = {}, y = {}, z = {} ".format(x ,y ,z))

## One optional argument at the end
def test_b(x, y, z = 22):
    print("test_b : x = {}, y = {}, z = {} ".format(x ,y ,z))

## TWO optional arguments at the end
def test_c(x, y = 11, z = 22):
    print("test_c : x = {}, y = {}, z = {} ".format(x ,y ,z))

## ONE optional argument at the middle
## Produces Non-default argument follows default argument
#### **** DEFAULT ARGUMENTS MUST COME AT THE END **** ####
## def test_d(x, y = 11, z):
##    print("test_d : x = {}, y = {}, z = {} ".format(x ,y ,z))

#################################################################

## NO optional argument + One List argument
def test_e(x, y, *args):
    print("test_e : x = {}, y = {} ||".format(x, y), end= " ")
    for i in args :
        print(i)

## One optional argument + One list argument
def test_f(x, *args , y = 5):
    print("test_f : x = {}, y = {} ||".format(x, y), end= " ")
    for i in args :
        print(i)

################################################################

## No optional argument, one list, one keyword arguments
def test_g(x,y,*args, **kwargs):
    print(x, y)
    for i in args:
        print(i)

    for i, v in kwargs.items():
        print(i, v)

## **kwargs befor *args produces syntax error !!!
##def test_h(x,y, **kwargs, *args):
##    print(x, y)
##    for i in args:
##        print(i)
##
##    for i, v in kwargs.items():
##        print(i, v)

## **kwargs befor optional argument produces syntax error !!!
##def test_l(x,*args,**kwargs, y = 5):
##    print(x, y)
##    for i in args:
##        print(i)
##
##    for i, v in kwargs.items():
##        print(i, v)
##    

## One optiona, list and keyword arguments
def test_m(x,*args,y = 5, **kwargs):
    print(x, y)
    for i in args:
        print(i)

    for i, v in kwargs.items():
        print(i, v)


if __name__ == "__main__":
    main()
</code></pre>
<p>I really understood most of things after this experiment. But there's one issue that i can't get inside my head.</p>
<p>In the function definition in <code>test_h</code> and <code>test_m</code> where <code>**kwargs</code> are defined before optional argument and list argument, when i run the program, even if i didn't use that function, just defined it.. It produces <code>Syntax Error</code> .. I'd be grateful to know why is this happening ?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>Keyword arguments have to be the final arguments passed to a function. <a href="http://docs.python.org/3/tutorial/controlflow.html#keyword-arguments" rel="nofollow">Read up on it here.</a> Parameters like <code>**kwargs</code> must be the <strong>last</strong> parameter in a function signature (as detailed on that page in the docs). From the documentation:</p>
<blockquote>
<p>When a <strong>final</strong> formal parameter of the form **name is present, it receives a dictionary (see Mapping Types — dict) containing all keyword arguments except for those corresponding to a formal parameter.</p>
</blockquote>
<p>The reason your code raises a SyntaxError even if you don't use that function is that if you violate this rule, Python can't even complete the function definition since the signature you're trying to give it is illegal.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>*args</code> and <code>**kwargs</code> must be the last arguments specified (in that order!); the reason is that they're essentially "catch-alls" that match arguments passed to the function that don't match the specific arguments listed beforehand, so having them listed before specific arguments is ambiguous.</p>
<p>For example, test_m above must be specified as</p>
<pre><code>def test_m(x, y=5, *args, **kwargs):
    ...
</code></pre>
</div>
<span class="comment-copy">A <code>def</code> statement is executed when it's reached in the code; it doesn't matter if you ever call the function later. (It's a statement like any other one).</span>
<span class="comment-copy">More than that - the whole script gets syntax-checked whether or not it can ever get executed. If you do <code>if False: !syntax_error</code> you still get a syntax error, even though the body won't be executed.</span>
<span class="comment-copy">That's exactly what puzzles me! When it says <code>it receives a dictionary containing all keyword arguments except for those corresponding to a formal parameter.</code>. Now i have <code>y = 5</code> optional parameter defined with it's name. Isn't this considered as the other parameters corresponding keys ? even if it came after the <code>**kwargs</code></span>
<span class="comment-copy">@RafaelAdel That's exactly what it means. <code>test_m</code> runs just fine, at least on my machine. Are you sure you're on Python 3? I believe <code>*args</code> has to be the final parameter besides <code>**kwargs</code> prior to Python 3, which <i>would</i> make <code>test_m</code> raise an error if you're running Python 2.x</span>
<span class="comment-copy">@RafaelAdel: I think you're mixing up <i>parameters</i> and <i>arguments</i>. If you have <code>def foo(a, b=3)</code>, <code>a</code> is a positional parameter, and <code>b</code> is a positional parameter with a default value. If you call it with <code>foo(3, 4)</code>, <code>3</code> and <code>4</code> are positional arguments. If you call it with <code>foo(a=5, b=6)</code>, then they're both named arguments. But they're still matched to the same parameters. So, if you <code>def foo(a, b=3, **kw)</code>, and call <code>foo(a=5, b=6)</code>, <code>b</code> is <code>corresponding to a formal parameter</code>, and therefore doesn't end up in <code>kw</code>.</span>
<span class="comment-copy">@RafaelAdel: Also, don't feel too bad if you're confused. All of this stuff makes obvious intuitive sense… until you try to think it through, at which point you realize that it's actually pretty complicated, and you don't even have the words to make the distinctions needed to reason about it. In fact, the core devs confused themselves for a couple years into believing that named parameters after <code>*args</code> were impossible, so we didn't get them until Python 3.0.</span>
<span class="comment-copy">This is not actually true for <code>*args</code>. You can have it earlier in the function signature, but you can't call the function using any of the following parameters unless you refer to them as keyword arguments. <a href="http://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists" rel="nofollow noreferrer">See the example here.</a></span>
<span class="comment-copy">(This is new in Python 3, but the question is tagged as such...)</span>
