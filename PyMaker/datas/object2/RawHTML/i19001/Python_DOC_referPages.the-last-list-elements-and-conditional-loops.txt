<div class="post-text" itemprop="text">
<pre><code>mylist="'a','b','c'"

count=0
i=0

while count&lt; len(mylist):
    if mylist[i]==mylist[i+1]:
        print mylist[i]
    count +=1
    i +=1
</code></pre>
<p>Error:</p>
<pre><code>File "&lt;string&gt;", line 6, in &lt;module&gt;
IndexError: string index out of range
</code></pre>
<p>I'm assuming that when it gets to the last (nth) element it can't find an n+1 to compare it to, so it gives me an error. </p>
<p>Interestingly, i think that I've done this before and not had this problem on a larger list: Here is an example (with credit to Raymond Hettinger for fixing it up) </p>
<pre><code>list=['a','a','x','c','e','e','f','f','f']

i=0
count = 0

while count &lt; len(list)-2:
    if list[i] == list[i+1]:
        if list [i+1] != list [i+2]:
            print list[i]
            i+=1
            count +=1
        else:
            print "no"
            count += 1
    else:   
        i +=1
        count += 1
</code></pre>
<p>For crawling through a list in the way I've attempted, is there any fix so that I don't go "out of range?" I plan to implement this on a very large list, where I'll have to check if "list[i]==list[i+16]", for example. In the future, I would like to add on conditions like "if int(mylist[i+3])-int(mylist[i+7])&gt;10: newerlist.append[mylist[i]". So it's important that I solve this problem. </p>
<p>I thought about inserting a break statement, but was unsuccessful. </p>
<p>I know this is not the most efficient, but I'm at the point where it's what i understand best. </p>
</div>
<div class="post-text" itemprop="text">
<p>Edit:</p>
<p>Right, with the new information in the OP, this becomes much simpler. Use <a href="http://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">the <code>itertools</code> <code>grouper()</code> recipe</a> to group the data for each person into tuples:</p>
<pre><code>import itertools

def grouper(iterable, n, fillvalue=None):
    """Collect data into fixed-length chunks or blocks"""
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return itertools.zip_longest(*args, fillvalue=fillvalue)

data = ['John', 'Sally', '5', '10', '11', '4', 'John', 'Sally', '3', '7', '7', '10', 'Bill', 'Hallie', '4', '6', '2', '1']

grouper(data, 6)
</code></pre>
<p>Now your data looks like:</p>
<pre><code>[
    ('John', 'Sally', '5', '10', '11', '4'), 
    ('John', 'Sally', '3', '7', '7', '10'), 
    ('Bill', 'Hallie', '4', '6', '2', '1')
]
</code></pre>
<p>Which should be easy to work with, by comparison.</p>
<hr/>
<p>Old Answer:</p>
<p>If you need to make more arbitrary links, rather than just checking continuous values:    </p>
<pre><code>def offset_iter(iterable, n):
    offset = iter(iterable)
    consume(offset, n)
    return offset

data = ['a', 'a', 'x', 'c', 'e', 'e', 'f', 'f', 'f']

offset_3 = offset_iter(data, 3)

for item, plus_3 in zip(data, offset_3): #Naturally, itertools.izip() in 2.x
    print(item, plus_3)                  #if memory usage is important.
</code></pre>
<p>Naturally, you would want to use semantically valid names. The advantage to this method is it works with arbitrary iterables, not just lists, and is efficient and readable, without any ugly, inefficient iteration by index. If you need to continue checking once the offset values have run out (for other conditions, say) then use <a href="http://docs.python.org/3.3/library/itertools.html?highlight=groupby#itertools.zip_longest" rel="nofollow"><code>itertools.zip_longest()</code></a> (<a href="http://docs.python.org/2.7/library/itertools.html?highlight=groupby#itertools.izip_longest" rel="nofollow"><code>itertools.izip_longest()</code></a> in 2.x). </p>
<p>Using <a href="http://docs.python.org/3.3/library/itertools.html?highlight=groupby#itertools-recipes" rel="nofollow">the <code>consume()</code> recipe from <code>itertools</code></a>.</p>
<pre><code>import itertools
import collections

def consume(iterator, n):
    """Advance the iterator n-steps ahead. If n is none, consume entirely."""
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(itertools.islice(iterator, n, n), None)
</code></pre>
<p>I would, however, greatly question if you need to re-examine your data structure in this case.</p>
<hr/>
<p>Original Answer:</p>
<p>I'm not sure what your aim is, but from what I gather you probably want <a href="http://docs.python.org/3.3/library/itertools.html?highlight=groupby#itertools.groupby" rel="nofollow"><code>itertools.groupby()</code></a>:</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; data = ['a', 'a', 'x', 'c', 'e', 'e', 'f', 'f', 'f']
&gt;&gt;&gt; grouped = itertools.groupby(data)
&gt;&gt;&gt; [(key, len(list(items))) for key, items in grouped]
[('a', 2), ('x', 1), ('c', 1), ('e', 2), ('f', 3)]
</code></pre>
<p>You can use this to work out when there are (arbitrarily large) runs of repeated items. It's worth noting you can provide <code>itertools.groupby()</code> with a <code>key</code> argument that will group them based on any factor you want, not just equality.</p>
</div>
<div class="post-text" itemprop="text">
<p>So it sounds like you are trying to compare elements in your list at various fixed offsets. perhaps something like this could help you:</p>
<pre><code>for old, new in zip(lst, lst[n:]):
    if some_cond(old, new):
        do_work()
</code></pre>
<h2>Explanation:</h2>
<p><code>lst[n:]</code> returns a copy of lst, starting from the nth (mind the 0-indexing) element</p>
<pre><code>&gt;&gt;&gt; lst = [1,2,2,3];
&gt;&gt;&gt; lst[1:]
[2,2,3]
</code></pre>
<p><code>zip(l1, l2)</code> creates a new list of tuples, with one element from each list</p>
<pre><code>&gt;&gt;&gt; zip(lst, lst[1:])
[(1, 2), (2, 2), (2, 3)]
</code></pre>
<p>Note that it stops as soon as either list runs out. in this case, the offset list runs out first.</p>
<p>for a list of tuples, you can "upack directly" in the loop variable, so</p>
<pre><code>for old, new in zip(lst, lst[1:])
</code></pre>
<p>gives loops through the elements you want (pairs of successive elements in your list)</p>
</div>
<div class="post-text" itemprop="text">
<p>As a general idea, if you are trying to look ahead a certain number of places, you can do a few things: </p>
<ol>
<li><p>In the loop check (I.e. count &lt; length), you'll need to check on the max field. So in your example, you wanted to go 16 spaces. This would mean that you would need to check count &lt; (length - 16). The downside is that your last elements (the last 16) won't be iterated over. </p></li>
<li><p>Check inside the loop to make sure the index is applicable. That is, on each if statement start with: if(I+16 &lt; length &amp;&amp; logic_you_want_to_check). This will allow you to continue through the loop, but when the logic will fail because its out of bounds, you won't error out. </p></li>
<li><p>Note- this probably isn't what you want, but ill add it for completeness. Wrap around your logic. This will only work if wrap arounds can be considered. If you literally want to check the 16th index ahead of your current index (I.e like a place in a line perhaps), then wrapping around doesn't really suit well. But if don't need that logic, and want to model your values in a circular pattern, you can modulus your index. That is: if array[i] == array [(i + 16)%length(array)] would check either 16 ahead or wrap around to the front of the array. </p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>If you adhere to <a href="http://www.python.org/dev/peps/pep-0020/" rel="nofollow">"Practicality beats purity"</a>:</p>
<pre><code>for idx, element in enumerate(yourlist[n:]):
    if yourlist[idx] == yourlist[idx-n]
    ...
</code></pre>
<p>If you don't care about memory efficiency go for second's answer. If you want the purest answer then go for Lattyware's one.</p>
</div>
<span class="comment-copy">could you briefly explain what you are trying to achieve? most cases of <code>while counter &lt; len(list): [...], i+= 1</code> can be better solved with other patterns</span>
<span class="comment-copy">I'm trying to compare list[i] with list[i+n] and print list[i] if some relationship between them holds.</span>
<span class="comment-copy">Please make it clear what you are trying to achieve (overall, not just the problem you have). It will make it much easier to give a useful answer. It's also worth noting <code>list</code> is a bad name for a variable, as it means you can't access the <code>list()</code> built-in function.</span>
<span class="comment-copy">I'll clarify my comment again - you are asking how to solve a problem in your solution to your problem. I believe that the solution you are working towards isn't optimal. If you tell us what the problem you are trying to solve with this code is, we will be able to provide a lot more insight. tomislav-maric suggested you are trying to count the number of duplicate items in the list, for example - and this can be achieved with a single line of code.</span>
<span class="comment-copy">Lattyware: I have a large list that looks like ["'John','Sally','5','10','11','4'", 'John','Sally','3','7','7','10','Bill','Hallie','4','6','2','1', etc...], where list[0],list[0+6], etc... are all men, list [1], [1+6], etc... are all their respective spouses, and then the next numbers represent each man's number of children, height, income, and   number of address. In the first two cases you can see that John and Sally are listed twice. If that's the case, I would like to take them and all their respective info and put them into a new list.</span>
<span class="comment-copy">Three downvotes and no comments as to why?</span>
<span class="comment-copy">+1, this is the best option when it comes to looping over neighbour elements - no ugly looping by index. The better version of this is to do <code>itr = iter(lst)</code> <code>next(itr)</code>, then use <code>itr</code> instead of <code>lst[n:]</code> - that way it works with iterables that don't support slicing.</span>
<span class="comment-copy">as @Lattyware mentions, using iterators would make this code more efficient. Figured i was introducing enough new concepts as it was for the moment</span>
<span class="comment-copy">It's not really about efficiency, more about flexibility. Not everything is a list.</span>
<span class="comment-copy">This is a nice answer but may be it is the opposite case and you need memory efficiency not flexibility, in this case zip() doubles the memory requirements.</span>
<span class="comment-copy">As discussed above, iterator versions (e.g. <code>izip</code>) are better for lots of reasons, but were left out here for simplicity</span>
<span class="comment-copy">-1. Your edit now makes the same mistake in a slightly better way.</span>
<span class="comment-copy">That doesn't allow you to access the next element.</span>
<span class="comment-copy">@Lattyware, you are right, i answered to quickly,:-), fixed now.</span>
<span class="comment-copy">This is still a terrible way of doing it. Looping by index is bad - that was what your post originally (correctly) said. It's also what your post now does.</span>
<span class="comment-copy">Well thats what he wants, see comments to his question, given his comments I think my answer is now the simplest one.</span>
