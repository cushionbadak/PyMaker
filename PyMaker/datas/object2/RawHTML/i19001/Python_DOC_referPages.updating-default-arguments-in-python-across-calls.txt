<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/1132941/least-astonishment-and-the-mutable-default-argument">“Least Astonishment” and the Mutable Default Argument</a>
<span class="question-originals-answer-count">
                    32 answers
                </span>
</li>
</ul>
</div>
<p>In the following function L stores the values during every call.</p>
<p>For example, if I call <code>f(1)</code>, L is now <code>[1]</code>. When I call it again the previous L is appended with the new value. So now L is <code>[1,1]</code>.</p>
<pre><code>def f(a, L=[]):

    L.append(a)
    return L
</code></pre>
<p>But in this function:</p>
<pre><code>i = 5

def f(arg=i):

    print arg
i = 6
</code></pre>
<p>No matter how many times I call this function, the argument is still <code>5</code> - it does not remain updated between calls.</p>
<p>What is the reason why this does not get updated but the list does?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is a good question. The reason why this happens is because the default arguments to functions are stored as single objects in memory, not recreated every time you call the function.</p>
<p>So when you have a list <code>[]</code> as a default argument, there will only be one list forever for the duration of that program. So when you add to the list you are adding to that one copy of the list. This is still true for numbers like <code>5</code>. However, numbers are immutable in Python, and so when you alter a default argument that starts at a number, you're really making it point to a new number and not editing that <code>5</code> object, whereas many operations on lists mutate the list in place rather than returning a new list.</p>
<p><a href="http://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="nofollow">http://docs.python.org/3/tutorial/controlflow.html#default-argument-values</a></p>
<blockquote>
<p>Important warning: The default value is evaluated only once. This
  makes a difference when the default is a mutable object such as a
  list, dictionary, or instances of most classes.</p>
</blockquote>
<p>The recommended solution, if you need the behaviour of an empty list default argument without having the same empty list default argument every call to the function, is to do this:</p>
<pre><code>def f(a, L = None):

    if L is None:
        L = []
    L.append(a)
    return L
</code></pre>
<p>The creation of an empty list is now evaluated on individual calls to the function - not once.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>a.append()</code> is different from <code>i = 6</code>.  The first changes the array but the array stays the same object (the same but not equal).  The latter on the other hand assigns a totally new value to a variable.  It does not change any object (ints aren't mutable anyway).</p>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/1132941/4279">“Least Astonishment” in Python: The Mutable Default Argument</a></span>
