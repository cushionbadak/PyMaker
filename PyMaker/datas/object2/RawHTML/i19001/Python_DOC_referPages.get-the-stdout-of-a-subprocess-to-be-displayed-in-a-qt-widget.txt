<div class="post-text" itemprop="text">
<p>I'm trying to have what is written to stdout in a subprocess, displayed in a Qt widget.</p>
<p>I'm starting the process this way:</p>
<pre><code>import subprocess

subprocess.call(["program_name", "arguments"])
</code></pre>
<p>I think I have to make a class to act like the stdout, and point it out when I call subprocess, I tried this:</p>
<pre><code>class Log:
    def __init__(self, qtWidget):
        self.qtWidget = qtWidget

    def write(self, data):
        self.qtWidget.append(data)


# (...)

log = Log(theWidget)

sub.process.call(["program_name", "arguments"], stdout=log)
</code></pre>
<p>but I am getting an error saying: AttributeError: 'Log' object has no attribute 'fileno'</p>
<p>Can't really think of any other ideas, apart from redirecting to a file and then having a timer which reads from it from time to time..</p>
<p>[edit]</p>
<p>Ended up with this:</p>
<pre><code>process = QProcess()
process.setProcessChannelMode( QProcess.MergedChannels )
process.start( "program_name", [ "arguments" ] )
process.readyReadStandardOutput.connect( aFunction )


# then in the function...

outputBytes = process.readAll().data()
outputUnicode = outputBytes.decode( 'utf-8' )
messageWidget.append( outputUnicode )
</code></pre>
<p>thanks for the help!</p>
</div>
<div class="post-text" itemprop="text">
<p>Redirecting of input/output streams in the subprocess module works at a lower level, that's why you can only pass filelike objects which have a fileno.</p>
<p>If you want to read the data from python, you can either use <a href="http://docs.python.org/3/library/subprocess#subprocess.check_output" rel="nofollow"><code>subprocess.check_output</code></a> instead of <code>subprocess.call</code>, which will return the data written to the process's stdout as bytes: </p>
<pre><code>log = subprocess.check_call(["program_name", "arguments"])
...   # use log
</code></pre>
<p>Or you can use <a href="http://docs.python.org/3/library/subprocess#subprocess.Popen" rel="nofollow"><code>subprocess.Popen</code></a> and pass <code>stdout=subprocess.PIPE</code>. Then you can read the data from the returned objets's <code>stdout</code>:</p>
<pre><code>p = subprocess.Popen(["program_name", "arguments"], stdout=subprocess.PIPE)
log = subprocess.stdout.read()
...   # use log
</code></pre>
<p>There should be a lot of examples in the subprocess documentation.</p>
<hr/>
<p>Edit:</p>
<p>If you need tighter integration with Qt, you could also use <a href="http://pyqt.sourceforge.net/Docs/PyQt4/qprocess.html" rel="nofollow"><code>QProcess</code></a> to start your program instead of the subprocess module. That would allow you to use it's read channel's readyRead signal to be notified when data is ready to be read from the process.</p>
</div>
<span class="comment-copy">I ended up using QProcess and listening to the 'readyReadStandardOutput' signal. It works well, thanks!</span>
