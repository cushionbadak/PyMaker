<div class="post-text" itemprop="text">
<p>I'm currently using <code>hash</code> on tuples of integers and strings (and nested tuples of integers and strings etc.) in order to compute the uniqueness of some objects. Barring that there might be a hash collisions, I wonder - is the <code>hash</code> function on those data types guaranteed to return the same result for different versions of Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>No. Apart from long-standing differences between 32- and 64-bit versions of Python, the hashing algorithm <a href="http://docs.python.org/3/reference/datamodel.html#object.__hash__">was changed in Python 3.3</a> to resolve a security issue:</p>
<blockquote>
<p>By default, the <strong>hash</strong>() values of str, bytes and datetime objects are “salted” with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.</p>
<p>This is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict insertion, O(n^2) complexity. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>Changing hash values affects the iteration order of dicts, sets and other mappings. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds).</p>
</blockquote>
<p>As a result, from 3.3 onwards <code>hash()</code> is not even guaranteed to return the same result across different invocations of the same Python version.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm not sure what you are looking for, but you can always use <a href="http://docs.python.org/2/library/hashlib.html" rel="nofollow"><code>hashlib</code></a> if you're looking for consistent hashing.</p>
<pre><code>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; t = ("values", "other")
&gt;&gt;&gt; hashlib.sha256(str(t)).hexdigest()
'bc3ed71325acf1386b40aa762b661bb63bb72e6df9457b838a2ea93c95cc8f0c'
</code></pre>
<p>OR: </p>
<pre><code>&gt;&gt;&gt; h = hashlib.sha256()
&gt;&gt;&gt; for item in t:
...     h.update(item)
...
&gt;&gt;&gt; h.hexdigest()
'5e98df135627bc8d98250ca7e638aeb2ccf7981ce50ee16ce00d4f23efada068'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No. eg.</p>
<p>32 bit</p>
<pre><code>Python 2.7.3 (default, Aug  1 2012, 05:16:07) 
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash("foobar")
-1969371895
</code></pre>
<p>64 bit</p>
<pre><code>Python 2.7.3 (default, Aug  1 2012, 05:14:39) 
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash("foobar")
3433925302934160649
</code></pre>
</div>
<span class="comment-copy">that would be my answer then! thanks, I will find another way.</span>
