<div class="post-text" itemprop="text">
<p>We recently delve into infinite series in calculus and that being said, I'm having so much fun with it. I derived my own inverse tan infinte series in <strong>python</strong> and set to 1 to get pi/4*4 to get pi. I know it's not the fastest algorithm, so please let's not discuss about my algorithm. What I would like to discuss is how do I represent very very small numbers in python. What I notice is as my programs iterate the series, it stops somewhere at the 20 decimal places (give or take). I tried using <strong>decimal</strong> module and that only pushed to about 509. I want an infinite (almost) representation. </p>
<p>Is there a way to do such thing? I reckon no data type will be able to handle such immensity, but if you can show me a way around that, I would appreciate that very much.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <a href="http://docs.python.org/3/library/decimal.html" rel="nofollow">decimal module</a> requires that you specify the "context," which affects how precise the representation will be.</p>
<p>I might recommend <a href="https://gmpy2.readthedocs.org/en/latest/" rel="nofollow">gmpy2</a> for this type of thing - you can do the calculation on rational numbers (arbitrary precision) and convert to decimal at the last step.</p>
<p>Here's an example - substitute your own algorithm as needed:</p>
<pre><code>import gmpy2
# See https://gmpy2.readthedocs.org/en/latest/mpfr.html
gmpy2.get_context().precision = 10000
pi = 0
for n in range(1000000):
    # Formula from http://en.wikipedia.org/wiki/Calculating_pi#Arctangent
    numer = pow(2, n + 1)
    denom = gmpy2.bincoef(n + n, n) * (n + n + 1)
    frac = gmpy2.mpq(numer, denom)
    pi += frac
    # Print every 1000 iterations
    if n % 1000 == 0:
        print(gmpy2.mpfr(pi))
</code></pre>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/11522933/python-floating-point-arbitrary-precision-available">Python floating point arbitrary precision available?</a></span>
<span class="comment-copy">If it stopped after 509 decimal places then that indicates a flaw in the algorithm, not the datatype.</span>
<span class="comment-copy">@KenWayneVanderLinde nope, they just recommended to use the decimal module on that one either.</span>
<span class="comment-copy">@JoeyArnoldAndres: How are you sing the <code>decimal</code> module? Are you sure your algorithm isn't just slowing down to a point where it looks like it stopped?</span>
<span class="comment-copy">That's because you're converting from a <code>float</code>, and those only go to about 1e-308 or so. <code>&gt;&gt;&gt; Decimal('1e-400')</code> <code>Decimal('1E-400')</code></span>
