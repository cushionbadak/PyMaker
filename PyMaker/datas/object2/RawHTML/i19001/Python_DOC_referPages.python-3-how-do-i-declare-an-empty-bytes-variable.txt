<div class="post-text" itemprop="text">
<p>How do I 'declare' an empty <code>bytes</code> variable in Python 3?</p>
<p>I am trying to receive chunks of bytes, and later change that to a utf-8 string.
However, I'm not sure how to declare the initial variable that will hold the entire series of bytes. This variable is called <code>msg</code>. I can't declare it as <code>None</code>, because you can't add a <code>bytes</code> and a <code>NoneType</code>. I can't declare it as a unicode string, because then I will be trying to add <code>bytes</code> to a string. Also, as the receiving program evolves it might get me in to a mess with series of bytes that contain only parts of characters. I can't do without a <code>msg</code> declaration, because then <code>msg</code> would be referenced before assignment.
The following is the code in question</p>
<pre><code>def handleClient(conn, addr):
    print('Connection from:', addr)
    msg = ?
    while 1:
        chunk = conn.recv(1024)
        if not chunk:
            break
        msg = msg + chunk
    msg = str(msg, 'UTF-8')
    conn.close()
    print('Received:', unpack(msg))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just use an empty byte string, <code>b''</code>.</p>
<p>However, concatenating to a string repeatedly involves copying the string many times. A <a href="http://docs.python.org/3/library/stdtypes.html#typebytearray"><code>bytearray</code></a>, which is mutable, will likely be faster:</p>
<pre><code>msg = bytearray()  # New empty byte array
# Append data to the array
msg.extend(b"blah")
msg.extend(b"foo") 
</code></pre>
<p>To decode the byte array to a string, use <code>msg.decode(encoding='utf-8')</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>msg = bytes('', encoding = 'your encoding here')</code>.</p>
<p>Encase you want to go with the default encoding, simply use <code>msg = b''</code>, but this will garbage the whole buffer if its not in the same encoding</p>
</div>
<div class="post-text" itemprop="text">
<p>As per documentation:</p>
<blockquote>
<p>Blockquote
  socket.recv(bufsize[, flags])
  Receive data from the socket. The return value is a <b>string</b> representing the data received.
  Blockquote
  So, I think msg="" should work just fine:</p>
</blockquote>
<pre><code>&gt;&gt;&gt; msg = ""
&gt;&gt;&gt; msg
''
&gt;&gt;&gt; len(msg)
0
&gt;&gt;&gt;
</code></pre>
</div>
<span class="comment-copy">This is initialization, not declaration. Python doesn't have declaration of types.</span>
<span class="comment-copy">would you say "initialization" or "instantiation"?  Perhaps both ... But as you say, definitely not "declaration"</span>
<span class="comment-copy">You can also just keep the received chunks in a list, and join them at the end.</span>
<span class="comment-copy">Even if the program weren't entirely I/O bound waiting on the socket, I can't imagine that the performance cost would actually matter anywhere.</span>
<span class="comment-copy">From a quick test, with 1024 chunks of 1024 bytes, in 64-bit Python 3.3.1, <code>bytes</code> took 30.1ns, <code>bytearray</code> took 29.6ns, <code>join</code> took 29.9ns.</span>
<span class="comment-copy">You appear to be quoting <a href="http://docs.python.org/2/library/socket.html#socket.socket.recv" rel="nofollow noreferrer">the Python 2.x documentation</a>, but the question is about Python 3, <a href="http://docs.python.org/3/library/socket.html#socket.socket.recv" rel="nofollow noreferrer">where <code>recv</code> returns <code>bytes</code></a>.</span>
<span class="comment-copy">The behaviour between Python 2 and 3 is indeed different. I just ported my code from Python 2 to 3 to get rid of the extra code related to unicode. I then ran into this difference, which is how I ended up asking this question.</span>
<span class="comment-copy">Ooops... sorry didn't see python 3 on top :(</span>
