<div class="post-text" itemprop="text">
<p>I have made a mistake as below:</p>
<pre><code>&gt;&gt;&gt; list = ['a', 'b', 'c']
</code></pre>
<p>But now I want to use the built-in function <code>list()</code>. As you can see, there is a naming conflict between listname <code>list</code> and the built-in function <code>list()</code>. </p>
<p>How can I use <code>list</code> as a built-in function not the variable without restarting the Python shell?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>__builtins__.list</code> or <code>__builtins__['__list__']</code> (depending on context), or simply delete <code>list</code> again (<code>del list</code>).</p>
<p>No imports needed:</p>
<pre><code>&gt;&gt;&gt; __builtins__.list
&lt;type 'list'&gt;
</code></pre>
<p>The presence of <code>__builtins__</code> is a CPython implementation detail; in the <code>__main__</code> module it is a module, everywhere else it is the module <code>__dict__</code> dictionary. Jython, IronPython and PyPy may opt to not make this available at all. Use the <a href="http://docs.python.org/2/library/__builtin__.html" rel="nofollow noreferrer"><code>__builtin__</code> module</a> for those platforms, or for Python 3 compatible implementations, the <a href="http://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>builtins</code> module</a>:</p>
<pre><code>&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; __builtin__.list
&lt;type 'list'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Step one</em>: rebind the list to a different name</p>
<pre><code>lst = list
</code></pre>
<p><em>Step two</em>: delete the <code>list</code> variable</p>
<pre><code>del list
</code></pre>
<p><em>Step three</em>: <strong>don't do it again</strong></p>
<hr/>
<p>I prefer this over <code>__builtins__.list</code> simply because it saves the typing, and you aren't still left with a variable named <code>list</code>. However, it is always best to avoid the problem altogether. When writing production code, always remember <em>not</em> to have variables named the same as built in functions.</p>
</div>
<div class="post-text" itemprop="text">
<p>Do not use built-in functions, or types as variable names. It is just as simple as that, the language is not meant for that. And it makes no sense to do so.</p>
<p>Not only that - but using the name "list" for a list is very ambiguous, and I doubt it is even remotely usable in any real code.</p>
<hr/>
<p>There are a few reasons why you should <strong>NOT</strong> <em>ever</em> shadow a built-in. Some of the more serious ones are below:</p>
<ul>
<li>Compatibility, the code would not work with other modules.</li>
<li>Confusion, anyone reading your code will not understand what is going on.</li>
<li>Circumstances, many of the built-ins use other built-ins, changing one can have unexpected results on other aspects of code.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>To repair the mistake, there is another option - if we remember that the built-in 'function' <code>list()</code> is actually a class, then we can just do this:</p>
<pre><code>list = type([])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use <code>__builtin__.list</code> in py2x:</p>
<pre><code>&gt;&gt;&gt; import __builtin__ 
&gt;&gt;&gt; __builtin__.list
&lt;type 'list'&gt;
</code></pre>
<p>Don't use <code>__builtins__.list</code> :</p>
<p>From the <a href="http://docs.python.org/2/reference/executionmodel.html" rel="nofollow">docs</a>:</p>
<blockquote>
<p>CPython implementation detail: Users should not touch <code>__builtins__</code>; it
  is strictly an implementation detail. Users wanting to override values
  in the <code>builtins</code> namespace should import the <code>__builtin__</code> (no ‘s’)
  module and modify its attributes appropriately.</p>
</blockquote>
<p>for py3x:</p>
<pre><code>&gt;&gt;&gt; import builtins
&gt;&gt;&gt; builtins.list
&lt;class 'list'&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is always available as <code>__builtins__.list</code>:</p>
<pre><code>&gt;&gt;&gt; __builtins__.list
&lt;class 'list'&gt;
&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; __builtins__.list
&lt;class 'list'&gt;
</code></pre>
<p>If you happen to rebind <em>that</em>, however, you're out of options.</p>
<p>You can also use the module <code>__builtin__</code> (or <code>builtins</code>, without the underscores, in Python 3) but you have to import it. But these are different ways to spell the same thing, rather than being an extra option - modifying one affects both:</p>
<pre><code>&gt;&gt;&gt; import builtins
&gt;&gt;&gt; builtins.list
&lt;class 'list'&gt;
&gt;&gt;&gt; builtins.list = [1, 2, 3]
&gt;&gt;&gt; builtins.list
[1, 2, 3]
&gt;&gt;&gt; __builtins__.list
[1, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes, others are saying above, don't use the name of a builtin as a variable name.  This goes for <code>list</code>, <code>dict</code>, etc.</p>
<p>Likewise, as others have said, you have access to the type <code>list</code> through <code>__builtins__.list</code>.  So if you need to call <code>list</code>, you can still find it, as long as you haven't rebound <code>__builtins__.list</code> also.</p>
<p>Importantly, though, <code>list</code> is a name.  You've rebound it to an instance of a list.  If you want <code>list</code> to mean <code>&lt;type 'list'&gt;</code> again, just rebind it again.  In Python 2.7:</p>
<pre><code>&gt;&gt;&gt; __builtins__.list
&lt;type 'list'&gt;
&gt;&gt;&gt; list
&lt;type 'list'&gt;
&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; list
[1, 2, 3]
&gt;&gt;&gt; fred = list
&gt;&gt;&gt; fred
[1, 2, 3]
&gt;&gt;&gt; list = __builtins__.list
&gt;&gt;&gt; list
&lt;type 'list'&gt;
</code></pre>
</div>
<span class="comment-copy">nice question, we should link to this whenever people use a builtin name</span>
<span class="comment-copy">Worth noting: probably the best thing for you to do is to use one of the methods below to access the built-in version, and rebind the <code>list</code> name to it, to undo your mistake. <code>list = __builtins__.list</code></span>
<span class="comment-copy">Re: <code>__builtins__.list</code> - don't do this. Just because you can doesn't mean you should.</span>
<span class="comment-copy">@FogleBird Given the situation the OP gives - a mistake at the interpreter, I don't think there is anything wrong with doing this. Obviously in any code written in a file, it's a different case.</span>
<span class="comment-copy">This is an excellent answer. In addition to the advantages you mentioned, it does not rely on CPython implementation details!</span>
<span class="comment-copy">Sorry, this is a bad answer in my book. -1. It is definitely a possibility, but it is going against what I believe is the sensibility of coding. This causes your code to be disjointed from other Python everywhere, Anyone looking at segments of the code would becomes confused, and it would not work well with other modules. In other words- this would BREAK constantly and be VERY fragile.</span>
<span class="comment-copy">@InbarRose The question specifically applies to the Python interpreter shell. Using <i>any</i> of the hacks provided in these answers would be <i>crazy</i> in production code—and by that, I mean any code that is written outside of the live interpreter.</span>
<span class="comment-copy"><code>How can I use list as a built-in function not a list variable without restart the Python shell?</code> @InbarRose - this is probably the easiest to type in the shell and also remembers to mention to re-bind the existing variable to something else first... (not just getting <code>list</code> back)</span>
<span class="comment-copy">@InbarRose You don't seem to be taking into account the context of the question.</span>
<span class="comment-copy">This does not answer the question - the OP understands that what he did was wrong, but he is using the shell and wants to fix the mistake.</span>
<span class="comment-copy">So what do you do when you overwrite <code>type</code>? Because that's exactly my situation: I have a class with a <code>type</code> attribute, and I need to resolve the ambiguity in <code>__init__</code> while still allowing the caller to call with, e.g. <code>Transaction(type = Transaction.T_SINGLE)</code>. I can't use a different name like <code>_type</code>, because I'm implementing an API, and <code>type</code>, being a function argument to <code>__init__</code>, is user-facing. You'd think deleting <code>type</code> in the function would work as it does on the global scope, but it causes python to crash on an ostensibly <i>erroneous</i> <code>UnboundLocalError</code> instead.</span>
<span class="comment-copy">So what I ended up doing is making a "backup" in the class named <code>_typeof</code>. I used the name <code>_typeof</code> so that it's obvious that the intent is type checking (ala JavaScript); the underscore is to hopefully prevent others from confusing it with JavaScript's <code>typeof</code> operator. Referenced as <code>Transaction._typeof(...)</code></span>
<span class="comment-copy">@BradenBest The correct answer is definitely <i>don't</i>. If you are making an API then calling something <code>type</code> infects other people's code with that bad idea. If it's already been shipped and you have to maintain compatibility, then yes "backing up" is a perfectly fine strategy. Python does also provide <a href="https://docs.python.org/3/library/builtins.html" rel="nofollow noreferrer"><code>builtins</code></a> as another way to get these back, but that is generally more overhead than just doing what you suggested (it's mostly useful in the interactive shell).</span>
<span class="comment-copy">Ah, but if you're using python 2.x, there is no guarantee that you'll be able to use it. <code>builtins</code> is a 3.x module made to address 2.x's <code>__builtins__</code>, which is a Cpython extension and not part of the standard library. This would be fine and dandy if <code>builtins</code> could be imported from <code>__future__</code>, but...yeah. That said, I wasn't happy with the workaround, so I ended up changing the function signature <code>__init__(self, price, [...], type)</code> -&gt; <code>__init__(self, data)</code>, where <code>data</code> is a dict. This (mostly) preserves the API while making serialization to/from JSON straightforward.</span>
<span class="comment-copy">No need for the <code>import</code>, AFAIK.</span>
<span class="comment-copy"><code>__builtins__</code>, not <code>__builtin__</code></span>
<span class="comment-copy">@HenryKeiter: No, there is a <a href="http://docs.python.org/2/library/__builtin__.html" rel="nofollow noreferrer"><code>__builtin__</code> module</a>.</span>
<span class="comment-copy">@HenryKeiter both work fine in py2x.</span>
<span class="comment-copy">@MartijnPieters That module requires an import (whereas <code>__builtins__</code> does not). One way or another this code doesn't work as written; it either needs <code>import __builtin__</code> or <code>__builtins__.list</code>.</span>
<span class="comment-copy">Don't use <code>__builtins__</code> : <a href="http://docs.python.org/2/reference/executionmodel.html" rel="nofollow noreferrer">docs.python.org/2/reference/executionmodel.html</a></span>
