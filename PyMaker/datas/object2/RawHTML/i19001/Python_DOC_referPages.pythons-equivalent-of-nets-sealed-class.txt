<div class="post-text" itemprop="text">
<p>Does python have anything similar to a sealed class? I believe it's also known as final class, in java.</p>
<p>In other words, in python, can we mark a class so it can never be inherited or expanded upon? Did python ever considered having such a feature? Why?</p>
<h2>Disclaimers</h2>
<p><sup>
Actually trying to understand <a href="https://stackoverflow.com/questions/554894/why-does-the-sealed-keyword-exist-in-net">why sealed classes</a> even exist. <a href="http://blogs.msdn.com/b/ericlippert/archive/2004/01/22/61803.aspx" rel="noreferrer">Answer here</a> (and in <a href="https://stackoverflow.com/questions/8434127/sealing-a-class">many</a>, <a href="https://stackoverflow.com/questions/252257/why-arent-classes-sealed-by-default">many</a>, <a href="https://stackoverflow.com/questions/2134/do-sealed-classes-really-offer-performance-benefits">many</a>, <a href="http://codebetter.com/patricksmacchia/2008/01/05/rambling-on-the-sealed-keyword/" rel="noreferrer">many</a>, <a href="https://stackoverflow.com/a/268287/274502">many</a>, <a href="https://stackoverflow.com/a/657526/274502">really many</a> other places) did not satisfy me at all, so I'm trying to look from a different angle. Please, avoid theoretical answers to this question, and focus on the title! Or, if you'd insist, at least please give <strong>one</strong> very good and practical example of a sealed class in csharp, pointing what would break big time if it was unsealed.
</sup></p>
<p><sup>
I'm no expert in either language, but I do know a bit of both. Just yesterday while coding on csharp I got to know about the existence of sealed classes. And now I'm wondering if python has anything equivalent to that. I believe there is a very good reason for its existence, but I'm really not getting it.
</sup></p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a metaclass to prevent subclassing:</p>
<pre><code>class Final(type):
    def __new__(cls, name, bases, classdict):
        for b in bases:
            if isinstance(b, Final):
                raise TypeError("type '{0}' is not an acceptable base type".format(b.__name__))
        return type.__new__(cls, name, bases, dict(classdict))

class Foo:
    __metaclass__ = Final

class Bar(Foo):
    pass
</code></pre>
<p>gives:</p>
<pre><code>&gt;&gt;&gt; class Bar(Foo):
...     pass
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in __new__
TypeError: type 'Foo' is not an acceptable base type
</code></pre>
<p>The <code>__metaclass__ = Final</code> line makes the <code>Foo</code> class 'sealed'.</p>
<p>Note that you'd use a sealed class in .NET as a performance measure; since there won't be any subclassing methods can be addressed directly. Python method lookups work very differently, and there is no advantage or disadvantage, when it comes to method lookups, to using a metaclass like the above example.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <em>does</em> have classes that can't be extended, such as <code>bool</code> or <code>NoneType</code>:</p>
<pre><code>&gt;&gt;&gt; class ExtendedBool(bool):
...     pass
... 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: type 'bool' is not an acceptable base type
</code></pre>
<p>However, such classes cannot be created from Python code. (In the CPython C API, they are created by not setting the <a href="https://docs.python.org/3/c-api/typeobj.html#Py_TPFLAGS_BASETYPE" rel="nofollow"><code>Py_TPFLAGS_BASETYPE</code></a> flag.)</p>
<p>Python 3.6 will introduce the <a href="https://docs.python.org/3.6/whatsnew/3.6.html#pep-487-simpler-customization-of-class-creation" rel="nofollow"><code>__init_subclass__</code></a> special method; raising an error from it will prevent creating subclasses. For older versions, a metaclass can be used.</p>
<p>Still, the most “Pythonic” way to limit usage of a class is to document how it should not be used.</p>
</div>
<div class="post-text" itemprop="text">
<p>Before we talk Python, let's talk "sealed":</p>
<p>I, too, have heard that the advantage of .Net sealed / Java final / C++ entirely-nonvirtual classes is performance. I heard it from a .Net dev at Microsoft, so maybe it's true. If you're building a heavy-use, highly-performance-sensitive app or framework, you may want to seal a handful of classes at or near the real, profiled bottleneck. Particularly classes that you are using within your own code. </p>
<p>For most applications of software, sealing a class that other teams consume as part of a framework/library/API is kinda...weird. </p>
<p>Mostly because there's a simple work-around for any sealed class, anyway. </p>
<p>I teach "Essential Test-Driven Development" courses, and in those three languages, I suggest consumers of such a sealed class wrap it in a delegating proxy that has the exact same method signatures, but they're override-able (virtual), so devs can create test-doubles for these slow, nondeterministic, or side-effect-inducing external dependencies. </p>
<p>[Warning: below snark intended as humor. <em>Please</em> read with your sense of humor subroutines activated. I do realize that there are cases where sealed/final are necessary.]</p>
<p>The proxy (which is not test code) effectively unseals (re-virtualizes) the class, resulting in v-table look-ups and possibly less efficient code (unless the compiler optimizer is competent enough to in-line the delegation). The advantages are that you can test your own code efficiently, saving living, breathing humans weeks of debugging time (in contrast to saving your app a few million microseconds) per month... [Disclaimer: that's just a WAG. Yeah, I know, your app is special. ;-]</p>
<p>So, my recommendations: (1) trust your compiler's optimizer, (2) stop creating unnecessary sealed/final/non-virtual classes that you built in order to either (a) eke out every microsecond of performance at a place that is likely not your bottleneck anyway (the keyboard, the Internet...), or (b) create some sort of misguided compile-time constraint on the "junior developers" on your team (yeah...I've seen that, too). </p>
<p>Oh, and (3) write the test first. ;-)</p>
<p>Okay, yes, there's always link-time mocking, too (e.g. TypeMock). You got me. Go ahead, seal your class. Whatevs.</p>
<p>Back to Python: The fact that there's a hack rather than a keyword is probably a reflection of the pure-virtual nature of Python. It's just not "natural."  </p>
<p>By the way, I came to this question because I had the exact same question. Working on the Python port of my ever-so-challenging and realistic legacy-code lab, and I wanted to know if Python had such an abominable keyword as sealed or final (I use them in the Java, C#, and C++ courses as a challenge to unit testing). Apparently it doesn't. Now I have to find something equally challenging about untested Python code. Hmmm...</p>
</div>
<span class="comment-copy">Sealed classes are useful in a few cases. One might be that you have only static and/or const members so inheriting wouldn't help any. Another alternative use would be in a situation where the class is such that any errors ought to be fixed by changing the implementation and submitting the fix, rather than subclassing. <code>seal</code>ing the class could encourage that...although that's probably not how it was intended to be used ;)</span>
<span class="comment-copy">@ChristopherPfohl <i>only static / const</i> members sounds a good reason to seal it. But, again, who'd want to expand such a class anyway? Using it to enforce debugging only with you sounds like an awful centralized-oriented reason to me, but maybe the best reason I've heard so far.</span>
<span class="comment-copy">This is awesome, and I believe it answers the question. Unfortunately, doesn't really help me at all, as I'd expect. This tells me the answer would actually be "no, python doesn't implement sealed classes, but you still can hack your own". But, would you know if this is a clean hack? You know, it won't break stuff or is highly disencourage or simply make the code runs slower... I believe originally, sealed classes are also meant to be faster.</span>
<span class="comment-copy">@Cawas: It won't make anything go slower; the metaclass only applies to when you <i>define</i> a subclass. It won't make anything go faster either, there is no lookup-optimization that can be gleaned from using this 'hack'.</span>
<span class="comment-copy">Performance is just one of the minor yet simpler points people give for sealing classes. You did tell me how to seal a class in python, now I guess I just want to know why would you do it. Since it's not native, I suppose people never do it. And probably are advised against doing it. Why?</span>
<span class="comment-copy">@Cawas: It certainly is not pythonic; preventing others from creating subclasses is a very authoritarian thing to do; part of the Python ethos is to let others just shoot themselves in the foot if they really want to, it's not the problem of the original class author.</span>
<span class="comment-copy">Perfect. Thanks! :-)</span>
<span class="comment-copy">very verbose and interesting point of view. i actually couldn't agree more that python classes should never be sealed, even while i still wouldn't know to pinpoint the reasoning behind - it's probably along the lines of  "haven't even considered doing anything this authoritarian" thing. anyway, perhaps you could turn this into an awesome answer if you also add practical ways of shooting ourselves in the foot (as to answer the question in the title) if we want to while explaining why we shouldn't and the best alternatives. ;P</span>
