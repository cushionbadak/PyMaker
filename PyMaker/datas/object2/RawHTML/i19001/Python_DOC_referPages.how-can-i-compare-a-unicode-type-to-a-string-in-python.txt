<div class="post-text" itemprop="text">
<p>I am trying to use a list comprehension that compares string objects, but one of the strings is utf-8, the byproduct of json.loads.  Scenario:</p>
<pre><code>us = u'MyString' # is the utf-8 string
</code></pre>
<p>Part one of my question, is why does this return False? :</p>
<pre><code>us.encode('utf-8') == "MyString" ## False
</code></pre>
<p>Part two - how can I compare within a list comprehension?</p>
<pre><code>myComp = [utfString for utfString in jsonLoadsObj
           if utfString.encode('utf-8') == "MyString"] #wrapped to read on S.O.
</code></pre>
<p>EDIT:  I'm using Google App Engine, which uses Python 2.7</p>
<p>Here's a more complete example of the problem:</p>
<pre><code>#json coming from remote server:
#response object looks like:  {"number1":"first", "number2":"second"}

data = json.loads(response)
k = data.keys()

I need something like:
myList = [item for item in k if item=="number1"]  

#### I thought this would work:
myList = [item for item in k if item.encode('utf-8')=="number1"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You must be looping over the wrong data set; just loop directly over the JSON-loaded dictionary, there is no need to call <code>.keys()</code> first:</p>
<pre><code>data = json.loads(response)
myList = [item for item in data if item == "number1"]  
</code></pre>
<p>You may want to use <code>u"number1"</code> to avoid implicit conversions between Unicode and byte strings:</p>
<pre><code>data = json.loads(response)
myList = [item for item in data if item == u"number1"]  
</code></pre>
<p>Both versions <strong>work fine</strong>:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; data = json.loads('{"number1":"first", "number2":"second"}')
&gt;&gt;&gt; [item for item in data if item == "number1"]
[u'number1']
&gt;&gt;&gt; [item for item in data if item == u"number1"]
[u'number1']
</code></pre>
<p>Note that in your first example, <code>us</code> is <strong>not</strong> a UTF-8 string; it is unicode data, the <code>json</code> library has already decoded it for you. A UTF-8 string on the other hand, is a sequence <em>encoded bytes</em>. You may want to read up on Unicode and Python to understand the difference:</p>
<ul>
<li><p><a href="http://joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a> by Joel Spolsky</p></li>
<li><p>The <a href="http://docs.python.org/3/howto/unicode.html">Python Unicode HOWTO</a></p></li>
<li><p><a href="http://nedbatchelder.com/text/unipain.html">Pragmatic Unicode</a> by Ned Batchelder</p></li>
</ul>
<p>On Python 2, your expectation that your test returns <code>True</code> would be correct, you are doing something else wrong:</p>
<pre><code>&gt;&gt;&gt; us = u'MyString'
&gt;&gt;&gt; us
u'MyString'
&gt;&gt;&gt; type(us)
&lt;type 'unicode'&gt;
&gt;&gt;&gt; us.encode('utf8') == 'MyString'
True
&gt;&gt;&gt; type(us.encode('utf8'))
&lt;type 'str'&gt;
</code></pre>
<p>There is <strong>no</strong> need to encode the strings to UTF-8 to make comparisons; use unicode literals instead:</p>
<pre><code>myComp = [elem for elem in json_data if elem == u"MyString"]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You are trying to compare a string of bytes (<code>'MyString'</code>) with a string of Unicode code points (<code>u'MyString'</code>).  This is an "apples and oranges" comparison.  Unfortunately, Python 2 pretends in some cases that this comparison is valid, instead of always returning <code>False</code>:</p>
<pre><code>&gt;&gt;&gt; u'MyString' == 'MyString'  # in my opinion should be False
True
</code></pre>
<p>It's up to you as the designer/developer to decide what the correct comparison should be.  Here is one possible way:</p>
<pre><code>a = u'MyString'
b = 'MyString'
a.encode('UTF-8') == b  # True
</code></pre>
<p>I recommend the above instead of <code>a == b.decode('UTF-8')</code> because all <code>u''</code> style strings can be encoded into bytes with UTF-8, except possibly in some bizarre cases, but not all byte-strings can be decoded to Unicode that way.</p>
<p>But if you choose to do a UTF-8 encode of the Unicode strings before comparing, that will fail for something like this on a Windows system: <code>u'Em dashes\u2014are cool'.encode('UTF-8') == 'Em dashes\x97are cool'</code>.  But if you <code>.encode('Windows-1252')</code> instead it would succeed.  That's why it's an apples and oranges comparison.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming you're using Python 3. <code>us.encode('utf-8') == "MyString"</code> returns <code>False</code> because the <code>str.encode()</code> function is <a href="http://docs.python.org/3/library/stdtypes.html#str.encode" rel="nofollow">returning a bytes object</a>:</p>
<pre><code>In [2]: us.encode('utf-8')
Out[2]: b'MyString'
</code></pre>
<p>In Python 3, strings are <a href="http://docs.python.org/3/library/stdtypes.html#text-sequence-type-str" rel="nofollow">already Unicode</a>, so the <code>u'MyString'</code> is superfluous.</p>
</div>
<span class="comment-copy">part 1 returns true to me.</span>
<span class="comment-copy">returns True for me too, are you in python3?</span>
<span class="comment-copy"><a href="http://ideone.com/F3BI7d" rel="nofollow noreferrer">In python3</a></span>
<span class="comment-copy">Are you looking for <code>us.decode('utf-8')</code>? Doesn't json handle the unicode parsing for you? What are you trying to do?</span>
<span class="comment-copy">I will add more complete code to show exactly what's happening.</span>
<span class="comment-copy">Why is it apparent that the OP is using Python 2? If it were Python 2, his test would return <code>True</code>, <b>not</b> <code>False</code>.</span>
<span class="comment-copy">Looks like I repeated his typo back to him.  He explicitly states Python 2 after his edit so I'll edit my answer too.</span>
