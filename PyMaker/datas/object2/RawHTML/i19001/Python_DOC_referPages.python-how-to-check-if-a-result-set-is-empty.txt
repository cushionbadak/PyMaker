<div class="post-text" itemprop="text">
<p>I have a sql statement that returns no hits. For example, <code>'select * from TAB where 1 = 2'</code>.</p>
<p>I want to check how many rows are returned, </p>
<pre><code>cursor.execute(query_sql)

rs = cursor.fetchall()
</code></pre>
<p>Here I get already exception: "(0, 'No result set')" </p>
<p>How can I prevend this exception, check whether the result set is empty?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>cursor.rowcount</code> will usually be set to 0.</p>
<p>If, however, you are running a statement that would <em>never</em> return a result set (such as <code>INSERT</code> without <code>RETURNING</code>, or <code>SELECT ... INTO</code>), then you do not need to call <code>.fetchall()</code>; there won't be a result set for such statements. Calling <code>.execute()</code> is enough to run the statement.</p>
<hr/>
<p>Note that database adapters are also allowed to set the rowcount to <code>-1</code> if the database adapter can't determine the exact affected count. See the <a href="https://www.python.org/dev/peps/pep-0249/#rowcount" rel="nofollow noreferrer">PEP 249 <code>Cursor.rowcount</code> specification</a>:</p>
<blockquote>
<p>The attribute is <code>-1</code> in case no <code>.execute*()</code> has been performed on the cursor or the rowcount of the last operation is cannot be determined by the interface.</p>
</blockquote>
<p>The <a href="https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount" rel="nofollow noreferrer"><code>sqlite3</code> library</a> is prone to doing this. In all such cases, if you must know the affected rowcount up front, execute a <code>COUNT()</code> select in the same transaction first.</p>
</div>
<div class="post-text" itemprop="text">
<p>MySQLdb will not raise an exception if the result set is empty. Additionally cursor.execute() function will return a long value which is number of rows in the fetched result set. So if you want to check for empty results, your code can be re-written as</p>
<pre><code>rows_count = cursor.execute(query_sql)
if rows_count &gt; 0:
     rs = cursor.fetchall()
else:
     // handle empty result set
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had issues with rowcount always returning -1 no matter what solution I tried.</p>
<p>I found the following a good replacement to check for a null result.</p>
<pre><code>c.execute("SELECT * FROM users WHERE id=?", (id_num,))
row = c.fetchone()
if row == None:
   print("There are no results for this query")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>Notice:</em> This is for MySQLdb module in Python.</p>
<p>For a <code>SELECT</code> statement, there shouldn't be an exception for an empty recordset. Just an empty list (<code>[]</code>) for <code>cursor.fetchall()</code> and <code>None</code> for <code>cursor.fetchone()</code>.</p>
<p>For any other statement, e.g. <code>INSERT</code> or <code>UPDATE</code>, that doesn't return a recordset, you can neither call <code>fetchall()</code> nor <code>fetchone()</code> on the cursor. Otherwise, an exception will be raised.</p>
<p>There's one way to distinguish between the above two types of cursors:</p>
<pre><code>def yield_data(cursor):
    while True:
        if cursor.description is None:
            # No recordset for INSERT, UPDATE, CREATE, etc
            pass
        else:
            # Recordset for SELECT, yield data
            yield cursor.fetchall()
            # Or yield column names with
            # yield [col[0] for col in cursor.description]

        # Go to the next recordset
        if not cursor.nextset():
            # End of recordsets
            return
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you're connecting to a postgres database, the following works:</p>
<pre><code>result = cursor.execute(query)

if result.returns_rows:
    # we got rows!
    return [{k:v for k,v in zip(result.keys(), r)} for r in result.rows]
else:
    return None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do like this :</p>
<pre><code>count = 0
cnxn = pyodbc.connect("Driver={SQL Server Native Client 11.0};"
                      "Server=serverName;"
                      "Trusted_Connection=yes;")
cursor = cnxn.cursor()
cursor.execute(SQL query)
for row in cursor:
    count = 1
    if true condition:
        print("True")
    else:
        print("False")
if count == 0:
    print("No Result")
</code></pre>
<p>Thanks :)</p>
</div>
<span class="comment-copy">What database is this? I would not expect an exception here, rather <code>.fetchall()</code> returns an empty list.</span>
<span class="comment-copy">returns empty list for <code>Django 2.1</code> and <code>SQLite</code></span>
<span class="comment-copy">in my script, I execute a list of sql statements, measure their runtime and number of hits. I cannot know beforehand if a statement is select or insert, is there a way for me to know after each query execution whether there is a resultset at all? Thanks a lot.</span>
<span class="comment-copy">@TaoVenzke: Use <code>try: results = cursor.fetchall()</code> then catch the exception with an <code>except</code> handler? Not all databases throw an exception in this case, what database are you using here?</span>
<span class="comment-copy">I am using SAP HANA database. I did it with TRY, and an exception is caught. But I would like to avoid exception in this case. cursor.rowcount is quite confusing: it returns -1 for select statement; it returns NOT 0 for insert statement, the number it returns appears to be the number of records inserted, but can I really trust it?</span>
<span class="comment-copy">Depends on the database, and I am not familiar with SAP. <code>-1</code> could be that the database doesn't <i>know</i> beforehand how many rows are to be returned. INSERTS may also give a rowcount indeed, that'd be how many rows were added. Unless documented otherwise, the number should be reliable.</span>
<span class="comment-copy">There WILL sometimes be results for DML statements. For example Postgres: <code>INSERT INTO some_table (id) values (1) RETURNING id;</code>. You should update your answer.</span>
<span class="comment-copy">Works very fine with Oracle !</span>
<span class="comment-copy">When posting an answer, try to explain why this answer solves the problem, along with the code itself.</span>
