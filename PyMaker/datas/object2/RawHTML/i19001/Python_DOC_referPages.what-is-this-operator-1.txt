<div class="post-text" itemprop="text">
<p>I'm going through some Python activities and was given example code with this operator: <code>y *= -1</code></p>
<p>I had a look through the <a href="http://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not" rel="noreferrer">relevant Python docs</a>, to no avail.</p>
<p>I know <code>y += 1</code>, for example, is short for <code>y = y + 1</code>. So is this <code>y = y * -1</code> y equals y times -1 maybe?</p>
<p>Closest thing in Python docs I could find is this: <code>x * y</code>: <em>product of x and y</em></p>
<p>Is this it?</p>
</div>
<div class="post-text" itemprop="text">
<p>In the vast majority of the cases</p>
<pre><code>y *= &lt;expr&gt;
</code></pre>
<p>is the same as </p>
<pre><code>y = y * &lt;expr&gt;
</code></pre>
<p>but in the general case, it is interpreted as:</p>
<pre><code>y = imul(y, &lt;expr&gt;)
</code></pre>
<p>which is then equivalent to:</p>
<pre><code>y = y.__imul__(&lt;expr&gt;)
</code></pre>
<p>if <code>y</code>'s type overrides <a href="http://docs.python.org/2/library/operator.html#operator.__imul__" rel="nofollow"><code>__imul__</code></a>.</p>
<p>This means that if <code>y</code>'s type overrides the <em>inplace</em> multiplication operator, <code>y*=&lt;expr&gt;</code> is performed <em>inplace</em>, while <code>y=y*&lt;expr&gt;</code> is not.</p>
<hr/>
<p><strong>EDIT</strong></p>
<p>It might not be immediately clear why the assignment is needed, i.e. why it is intrepreted as <code>y = imul(y, &lt;expr&gt;)</code>, and not just <code>imul(y, &lt;expr&gt;)</code>.</p>
<p>The reason is that it makes a lot of sense for the following two scenarios to give the same result:</p>
<pre><code>c = a * b
</code></pre>
<p>and</p>
<pre><code>c = a
c *= b
</code></pre>
<p>Now, this of course works if <code>a</code> and <code>b</code> are of the same type (e.g. floats, numpy arrays, etc.), but if they aren't, it is possible for the result of the operation to have the type of <code>b</code>, in which case the operation cannot be an inplace operation of <code>a</code>, thus the result needs to be assigned to <code>a</code>, in order to achieve the correct behavior.</p>
<p>For example, this works, thanks to the assignment:</p>
<pre><code>from numpy import arange
a = 2
a *= arange(3)
a
=&gt; array([0, 2, 4])
</code></pre>
<p>Whereas if the assignment is dropped, <code>a</code> remains unchanged:</p>
<pre><code>a = 2
imul(a, arange(3))
=&gt; array([0, 2, 4])
a
=&gt; 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yes that's correct. It just means multiply the left-hand value by negative the right-hand value. They're both arithmetic operators that differ simply by operation and expression binding, so I believe +/* are parallel everywhere else in overloads.</p>
<pre><code>y = y * -1
</code></pre>
</div>
<span class="comment-copy">To find the relevant docs you would need to search for <i>augmented assignment</i>.</span>
<span class="comment-copy">Ahh ok thanks mate.</span>
<span class="comment-copy">Can you explain why is it interpreted as <code>y = y.__imul__(&lt;expr&gt;)</code> and not just <code>y.__imul__(&lt;expr&gt;)</code>?</span>
<span class="comment-copy">See <a href="http://docs.python.org/3.3/reference/datamodel.html#object.__iadd__" rel="nofollow noreferrer">the docs</a>: " These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self)."</span>
<span class="comment-copy">@wim there's then the infamous case of tuple modification <code>x = ([],)</code>, <code>x[0] += ['a']</code> <code>x</code></span>
<span class="comment-copy">@jamylak, yes! one of my favorites :)</span>
<span class="comment-copy">Interesting. Perhaps the AST greatly reflects the x86 and other integer multiplications machine instructions for performance (mul instruction has implicit source operand)?</span>
<span class="comment-copy">It's not 100% identical, if <code>y</code> has side effects when evaluated (such as printing or modifying state). In <code>y *= -1</code>, <code>y</code> is evaluated once. In <code>y = y * -1</code>, <code>y</code> is is evaluated twice.</span>
<span class="comment-copy">You mean the second evaluated from the equal operator? Nvm, you said modifying state. It's more apparent when dealing with items: <code>k[key] *= -1</code></span>
