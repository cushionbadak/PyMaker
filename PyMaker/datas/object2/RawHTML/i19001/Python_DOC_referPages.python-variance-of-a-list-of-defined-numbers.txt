<div class="post-text" itemprop="text">
<p>I am trying to make a function that prints the variance of a list of defined numbers:</p>
<pre><code>grades = [100, 100, 90, 40, 80, 100, 85, 70, 90, 65, 90, 85, 50.5]
</code></pre>
<p>So far, I have tried proceeding on making these three functions:</p>
<pre><code>def grades_sum(my_list):
    total = 0
    for grade in my_list: 
        total += grade
    return total

def grades_average(my_list):
    sum_of_grades = grades_sum(my_list)
    average = sum_of_grades / len(my_list)
    return average

def grades_variance(my_list, average):
    variance = 0
    for i in my_list:
        variance += (average - my_list[i]) ** 2
    return variance / len(my_list)
</code></pre>
<p>When I try to execute the code, however, it gives me the following error at the following line:</p>
<pre><code>Line: variance += (average - my_list[i]) ** 2
Error: list index out of range
</code></pre>
<p>Apologies if my current Python knowledges are limited, but I am still learning - so please if you wish to help solving this issue try not to suggest extremely-complicated ways on how to solve this, thank you really much. </p>
</div>
<div class="post-text" itemprop="text">
<p>First I would suggest using Python's built-in <code>sum</code> method to replace your first custom method. <code>grades_average</code> then becomes:</p>
<pre><code>def grades_average(my_list):
    sum_of_grades = sum(my_list)
    average = sum_of_grades / len(my_list)
    return average
</code></pre>
<p>Second, I would strongly recommend looking into the <a href="http://numpy.scipy.org" rel="nofollow noreferrer">NumPy library</a>, as it has these methods built-in. <code>numpy.mean()</code> and <code>numpy.std()</code> would cover both these cases.</p>
<p>If you're interested in writing the code for yourself first, that's totally fine too. As for your specific error, I believe @gnibbler above nailed it. If you want to loop using an index, you can restructure the line in <code>grades_variance</code> to be:</p>
<pre><code>for i in range(0, len(my_list)):
</code></pre>
<p>As <a href="https://stackoverflow.com/users/722121/lattyware">Lattyware</a> noted, looping by index is not particularly "Pythonic"; the way you're currently doing it is generally superior. This is just for your reference.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html#numpy.var">numpy</a>.</p>
<pre><code>import numpy as np
variance = np.var(grades)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>When you say</p>
<pre><code> for i in my_list:
</code></pre>
<p><code>i</code> isn't the <em>index</em> of the item. <code>i</code> <em>is</em> the item</p>
<pre><code>for i in my_list:
    variance += (average - i) ** 2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While <a href="https://stackoverflow.com/a/16670690/722121">gnibbler has solved the problem with your code</a>, you can achieve this much more easily using <a href="http://docs.python.org/3.3/library/functions.html#sum" rel="nofollow noreferrer">built-in functions</a> and a <a href="http://www.youtube.com/watch?v=pShL9DCSIUw" rel="nofollow noreferrer">generator expression</a>:</p>
<pre><code>average = sum(grades) / len(grades)
varience = sum((average - value) ** 2 for value in grades) / len(grades)
</code></pre>
<p>It might look a little scary at first, but if you watch the video I link about list comprehensions and generator expressions - they are actually really simple and useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>python 3.4 has a statistics lib which does this.</p>
<pre><code>   import statistics
   grades = [100, 100, 90, 40, 80, 100, 85, 70, 90, 65, 90, 85, 50.5]
   statistics.pvariance(grades)
=&gt; 334.07100591715977
</code></pre>
<p><a href="https://docs.python.org/3/library/statistics.html#statistics.pvariance" rel="nofollow">https://docs.python.org/3/library/statistics.html#statistics.pvariance</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose you would like the sample variance i.e. the unbiased estimator of the variance. I think this function might do the job. It will print the variance and the mean of a vector n.</p>
<pre><code>n = [5, 3, 1, 2, 4]

def variance1337(n):
    var1 = []
    mean1 = sum(n)/len(n)
    for xs in n:
        var1.append((xs - mean1) ** 2)
    print(sum(var1)/(len(n) - 1))
    print(mean1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the below code is used to get the average of values</p>
<pre><code>def grades_average(my_list):
    sum_of_grades = sum(my_list)
    average = sum(my_list) / len(my_list)
    return average
</code></pre>
<p>variance formula -&gt; The average of the squared differences from the Mean.
This code below is used to get the variance of values</p>
<pre><code>def grades_variance(my_list, average):
    variance = 0
    for i in my_list:
         variance += (average - i) ** 2
    return variance / len(my_list)
</code></pre>
</div>
<span class="comment-copy">Just as a note, <a href="http://docs.python.org/3.3/library/functions.html#sum" rel="nofollow noreferrer"><code>sum()</code></a> is a built-in function that already exists - no  need to reinvent the wheel. <code>sum(grades)</code> will do.</span>
<span class="comment-copy">That is correct.</span>
<span class="comment-copy">It's worth noting looping by index is a terrible idea in Python - it's harder to read, slower and makes your code inflexible.</span>
<span class="comment-copy">Agreed, but it's useful to know how to do.</span>
<span class="comment-copy">What do you mean by "the way I am currently doing it is generally superior"?</span>
<span class="comment-copy">Your current loop construction makes <code>i</code> the item in the list. I gave the loop structure for making <code>i</code> an integer index into the list. The former (how you do it in your original question) is generally better.</span>
<span class="comment-copy">As of Python 3.4, there are <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow noreferrer"><code>mean()</code></a> and <a href="https://docs.python.org/3/library/statistics.html#statistics.variance" rel="nofollow noreferrer"><code>variance()</code></a> functions in the <a href="https://docs.python.org/3/library/statistics.html#module-statistics" rel="nofollow noreferrer"><code>statistics</code> module</a>. No need to load NumPy just to calculate a variance anymore.</span>
<span class="comment-copy">Thank you, that was such a stupid mistake.</span>
<span class="comment-copy">Note that you want 2.0 if you're on python 2.x</span>
<span class="comment-copy">I would just love to see a <code>statistics</code> port to python 2.7</span>
<span class="comment-copy">@ThiagoFernandes Today is your lucky day <a href="https://pypi.python.org/pypi/statistics" rel="nofollow noreferrer">pypi.python.org/pypi/statistics</a></span>
<span class="comment-copy">Wow, congrats!! ;D Really thanks, that will be helpful!</span>
