<div class="post-text" itemprop="text">
<p>If I have a list l:</p>
<pre><code>l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>Is there a way to control the following <em>for</em> loop so that the next element in the list is only printed one second after the previous?</p>
<pre><code>for i in l:
    print i
</code></pre>
<p>In other words, is there a way to elegantly slow down a loop in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>time.sleep</code></p>
<pre><code>import time

for i in l:
    print i
    time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you use <code>time.sleep(1)</code>, your loops will run a little over a second since the looping and printing also takes some time. A better way is to sleep for the remainder of the second. You can calculate that by using <code>-time.time()%1</code></p>
<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; for i in L:
...     time.sleep(-time.time()%1)
...     print i
... 
</code></pre>
<p>It's easy to observe this by using <code>print i, repr(time.time())</code></p>
<pre><code>&gt;&gt;&gt; for i in L:
...     time.sleep(-time.time()%1)
...     print i, repr(time.time())
... 
0 1368580358.000628
1 1368580359.001082
2 1368580360.001083
3 1368580361.001095
4 1368580362.001149
5 1368580363.001085
6 1368580364.001089
7 1368580365.001086
8 1368580366.001086
9 1368580367.001085
</code></pre>
<p>vs</p>
<pre><code>&gt;&gt;&gt; for i in L:
...     time.sleep(1)
...     print i, repr(time.time())
... 
0 1368580334.104903
1 1368580335.106048
2 1368580336.106716
3 1368580337.107863
4 1368580338.109007
5 1368580339.110152
6 1368580340.111301
7 1368580341.112447
8 1368580342.113591
9 1368580343.114737
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pause the code execution using <a href="http://docs.python.org/3/library/time.html#time.sleep" rel="nofollow"><code>time.sleep</code></a>:</p>
<pre><code>import time

for i in l:
    print(i)
    time.sleep(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="http://docs.python.org/2/library/time.html#time.sleep" rel="nofollow"><code>time.sleep</code></a> function.  Just do <code>time.sleep(1)</code> in your function.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>time.sleep(number)</code>:</p>
<pre><code>for i in range(i)
print(1)
time.sleep(0.05)
</code></pre>
</div>
<span class="comment-copy">That's funny, most people want to know how to <i>speed up</i> their loops!</span>
<span class="comment-copy">I find that running it on my old Treo 300 is a good way to slow down the loops…</span>
<span class="comment-copy">More seriously, if you're trying to watch what's going on, you may want to try running in a debugger or an interactive visualizer, instead of just tossing in <code>sleep</code> calls.</span>
<span class="comment-copy">How can slow be achieved without time.sleep? (Am on a platform that allows time but not sleep, a security fear with them). Pretty sure an inconsistency I'm seeing is from something asynchronous on the back end and I have no access and they're no help..I think the bug I'm seeing will disappear with slower execution.</span>
<span class="comment-copy">Besides forcing this to align on the exact second mark, this also assumes that the cost of <code>time.time</code> and <code>time.sleep</code> is negligible, but the time of <code>print</code> is significant, and that <code>sleep</code> is accurate to the relevant scale, both of which are unlikely to be true on most platforms…</span>
<span class="comment-copy">@abarnert, the time caused from <code>time.time()</code> and <code>time.sleep()</code> doesn't matter much as long as it's fairly consistent. <code>sleep()</code> doesn't offer a guarantee for precise timing anyway.</span>
<span class="comment-copy">The second part of your comment is the main point. <code>sleep</code> isn't accurate or precise no matter what you do. It could easily sleep past the next <code>.000</code> mark, which means your code will lose a whole second, while the "dumb" code would just lose 50us. Is that really an improvement? You need more complicated logic (basically, keep track of the time to sleep <i>until</i>, so you can correct for oversleep) to actually do this right. There are very few situations where <code>sleep(1)</code> is not good enough, but <code>sleep(-time.time()%1)</code> is.</span>
<span class="comment-copy">@abarnert, depends on the use case. If the code in the loop is more complicated than <code>print</code> and takes a substantial part of (but less than) a second, my version will run 3600 times an hour.</span>
<span class="comment-copy">Necro-posting is fine, if it brings some additional value, but this answer brings no such light on the matter: the code doesn't even work.</span>
