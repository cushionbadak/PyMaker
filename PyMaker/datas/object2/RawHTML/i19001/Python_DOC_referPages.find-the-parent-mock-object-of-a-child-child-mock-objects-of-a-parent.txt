<div class="post-text" itemprop="text">
<p>Is it possible to identify the parent <a href="http://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock" rel="nofollow"><code>MagicMock</code></a> mock object instance of a child mock object instance, or the children of a parent mock object instance? For example, if I have the following code</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; parent_mock = MagicMock()
&gt;&gt;&gt; child_mock1 = parent_mock(a=1)
&gt;&gt;&gt; child_mock2 = parent_mock(b='spam')
</code></pre>
<p>How could I confirm later that the child mocks spawned from calling <code>parent_mock</code>? How could I check which mock objects <code>parent_mock</code> produced?</p>
<p>Also, how could I distinguish that <code>child_mock1</code> originated specifically from the call <code>parent_mock(a=1)</code>, while <code>child_mock2</code> originated from the call <code>parent_mock(b='spam')</code>?</p>
<p>I understand one can <a href="http://docs.python.org/3/library/unittest.mock.html#attaching-mocks-as-attributes" rel="nofollow">manually attach mocks as attributes of other mocks</a>, however, it requires a good deal of setup in that you will need to make sure to explicitly define the return calls of the parent mock so that it returns the designated child mocks, and so it doesn't scale well past a few calls. </p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>How could I confirm later that the child mocks spawned from calling <code>parent_mock</code>?</p>
</blockquote>
<p>Well, there's an undocumented attribute <code>_mock_new_parent</code>, which you could use like this...</p>
<pre><code>&gt;&gt;&gt; from unittest.mock import MagicMock
&gt;&gt;&gt; parent_mock = MagicMock()
&gt;&gt;&gt; child_mock1 = parent_mock(a=1)
&gt;&gt;&gt; child_mock2 = parent_mock(b='spam')
&gt;&gt;&gt; child_mock1._mock_new_parent is parent_mock
True
&gt;&gt;&gt; child_mock2._mock_new_parent is parent_mock
True
</code></pre>
<p>...but it looks as if the answer to all your other questions is "you can't".</p>
<p>I suppose you could subclass <code>MagicMock</code> to keep track of its children with something like this...</p>
<pre><code>class MyMock(MagicMock):

    def __init__(self, *args, **kwargs):
        MagicMock.__init__(self, *args, **kwargs)
        self._kids = []

    def __call__(self, *args, **kwargs):
        result = MagicMock.__call__(self, *args, **kwargs)
        self._kids.append((args, kwargs, result))
        return result
</code></pre>
<p>...then you could do...</p>
<pre><code>&gt;&gt;&gt; parent_mock = MyMock()
&gt;&gt;&gt; child_mock1 = parent_mock(a=1)
&gt;&gt;&gt; child_mock2 = parent_mock(b='spam')
&gt;&gt;&gt; parent_mock._kids
[((), {'a': 1}, &lt;MyMock name='mock()' id='140358357513616'&gt;),
 ((), {'b': 'spam'}, &lt;MyMock name='mock()' id='140358357513616'&gt;)]
&gt;&gt;&gt; parent_mock._kids[0][2] is child_mock1
True
&gt;&gt;&gt; parent_mock._kids[1][2] is child_mock2
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Careful there!</p>
<p><a href="http://docs.python.org/dev/library/unittest.mock#calling" rel="nofollow">26.4.2.1. Calling</a></p>
<blockquote>
<p>Mock objects are callable. The call will return the value set as the return_value attribute. The default return value is a new Mock object; it is created the first time the return value is accessed (either explicitly or by calling the Mock) - but it is stored and <strong>the same one returned each time</strong>.</p>
</blockquote>
<p>If you want different calls to give different results, you'll want to give your mock a <a href="http://docs.python.org/dev/library/unittest.mock#unittest.mock.Mock.side_effect" rel="nofollow"><code>side_effect</code></a> attribute. If <code>mock.side_effect</code> is a function, then <code>mock(*args, **kwargs)</code> will call <code>mock.side_effect(*args, **kwargs)</code> and return whatever that returns. You can make your custom <code>mock.side_effect</code> keep track of what calls produced what values.</p>
</div>
<span class="comment-copy">You probably don't want to do something like that at all. It's not pythonic to worry about inheritance hierarchies. Why do you want to know those things? Likely there is another way to solve your actual problem.</span>
<span class="comment-copy">@erikb85 The words "parent" and "child" do not mean "superclass" and "subclass". <code>Mock</code> instances, when called, return "child" <code>Mock</code> instances (by default); the <code>Mock</code> instance which created another is called the "parent".</span>
<span class="comment-copy">Which doesn't answer the question. :)</span>
<span class="comment-copy">Your <code>MyMock</code> still has <code>child_mock1 is child_mock2</code>, because you delegate to <code>MagicMock.__call__</code>, which won't create different objects for different calls. You can't distinguish which call a mock came from.</span>
<span class="comment-copy">I missed that part of the documentation, thanks! It seems like @Aya's implementation which subclasses <code>MagicMock</code> and overrides <code>__call__</code> will actually return distinct mock instances.</span>
<span class="comment-copy">Aya's implementation doesn't work. It delegates to <code>MagicMock.__call__</code>, which will always return the same object. In other words, <code>child_mock1 is child_mock2</code>.</span>
