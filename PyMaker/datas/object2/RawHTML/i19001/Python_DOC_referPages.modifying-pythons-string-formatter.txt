<div class="post-text" itemprop="text">
<p>I have a function which takes no arguments and returns a string, which I want to be called using a string format. Here it is, and here's how I've tried to use <a href="http://docs.python.org/3/library/string.html#string.Formatter.format" rel="nofollow"><code>format</code></a>:</p>
<pre><code>def cabbages():
    return 'hello'

In [2]: '{cabbages} world'.format(**locals())
Out[2]: '&lt;function cabbages at 0x101f75578&gt; world'

In [3]: '{cabbages()} world'.format(**locals())
KeyError: 'cabbages()'
</code></pre>
<p><em>So neither of which is quite what I want, i.e. the value of <code>cabbages()</code>.</em></p>
<p><a href="http://www.python.org/dev/peps/pep-3101/" rel="nofollow">PEP 3101</a> describes some way in which <code>string.Formatter</code> can be overwritten but it doesn't seem to give many examples. How can I subclass/customise the string <a href="http://docs.python.org/3/library/string.html#string.Formatter" rel="nofollow"><code>Formatter</code></a> class to do this?</p>
<p><em>A hacky thing I considered would be to overwrite the <code>__getattr__</code> method of <code>cabbages</code>, and I <strong>really</strong> don't want be "considered pathological" (or, at least, *that* pathological).</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I guess the main deficiency I see in your answer is that it doesn't also handle the original compound field name syntaxes like <code>0.name</code> for 'getattr'/'dot' operator access nor, <code>0[name]</code> for 'getitem' retrieval specified in PEP 3101. </p>
<p>Here's a version that works in both Python 2.7 and 3.3. A major implementation difference is that it overrides the <code>get_value()</code> method instead of <code>get_field()</code>.</p>
<p>While it's a little hacky about how it detects calls in the <code>get_value()</code> method, I don't think it's to the point where it would be considered <em>pathological</em>. ;-)</p>
<pre><code>from __future__ import print_function

from string import Formatter

class CallFormatter(Formatter):
    try:  # deal with Py 2 &amp; 3 difference
        NUMERICS = (int, long)
    except NameError:
        NUMERICS = int

    def get_value(self, key, args, kwargs):
        if key.endswith('()'):  # call?
            return kwargs[key[:-2]]()
        elif isinstance(key, self.NUMERICS):
            return args[key]
        else:
            return kwargs[key]

if __name__ == '__main__':
    fmt = CallFormatter()

    def cabbages():
        return 'hello'

    d = dict(name='Fred')

    class Thing(object):
        def __init__(self, value):
            self.attr = value
    th = Thing(42)

    print('d[name]:{d[name]}, th.attr:{th.attr}, '
          'cabbages:{cabbages}'.format(**locals()))
    print(fmt.format('d[name]:{d[name]}, th.attr:{th.attr}, '
                     'cabbages:{cabbages}, cabbages():{cabbages()}', 
                     **locals()))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>d[name]:Fred, th.attr:42, cabbages:&lt;function cabbages at 0x00BB05F0&gt;
d[name]:Fred, th.attr:42, cabbages:&lt;function cabbages at 0x00BB05F0&gt;, 
                          cabbages():hello
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can overwrite the <a href="http://docs.python.org/3/library/string.html#string.Formatter.get_field" rel="nofollow"><code>get_field</code></a> method of <code>Formatter</code> as follows:</p>
<pre><code>from string import Formatter
class CallFormatter(Formatter):
    def get_field(self, field_name, *args, **kwargs):
        obj, used_key = Formatter.get_field(self, field_name, *args, **kwargs)
        return obj(), used_key  # obj is the function

fmt = CallFormatter()

In [11]: fmt.format('{cabbages} world', **locals())
Out[11]: 'hello world'
</code></pre>
<p>Doing something like this comes with a health warning, so I think it's worth pasting the Security Considerations section of <a href="http://www.python.org/dev/peps/pep-3101/" rel="nofollow">that PEP</a> in full (emphasis added):</p>
<blockquote>
<p>Historically, string formatting has been a <strong>common source of
      security holes</strong> in web-based applications, particularly if the
      string formatting system allows arbitrary expressions to be
      embedded in format strings.  </p>
<p>The best way to use string formatting in a way that does not
      create potential security holes is to <strong>never use format strings
      that come from an untrusted source</strong>.</p>
<p>Barring that, the next best approach is to <strong>ensure that string
      formatting has no side effects</strong>.  Because of the open nature of
      Python, it is <strong>impossible to guarantee</strong> that any non-trivial
      operation has this property.  What this PEP does is limit the
      types of expressions in format strings to those in which visible
      side effects are both rare and strongly discouraged by the
      culture of Python developers.  So for example, attribute access
      is allowed because it would be considered pathological to write
      code where the mere access of an attribute has visible side
      effects (whether the code has <em>invisible</em> side effects - such
      as creating a cache entry for faster lookup - is irrelevant.)</p>
</blockquote>
</div>
<span class="comment-copy">Using <code>str.format()</code> with <code>locals()</code> is generally a really bad idea. Just pass the values you want.</span>
<span class="comment-copy">@Lattyware True, I actually use a different dictionary, was for example (a poor choice).</span>
<span class="comment-copy">Thanks! I didn't realise there was a 2.7/3 difference, that's annoying. Also I was/am in the unique position where I know everything in the <code>{}</code>s is callable, probably most people won't be!</span>
<span class="comment-copy">@Andy: Sorry, I misspoke. Your answer <i>does</i> work, as far as it goes, in Python 2.7 (as does mine).</span>
<span class="comment-copy">The code with <code>self</code> in it works for me (or I wouldn't have edited your answer).</span>
