<div class="post-text" itemprop="text">
<pre><code>class F(object):     # is the word 'object' meaningful?
    def __init__(self,a,b,c):
        self.a = a
        self.b = b
        self.c = c
class G(F):     # How does this subclass definition   
    a = 1
    b = 2
    c = 3
H = F(1,2,3)    # differ from this one?
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In Python2, </p>
<pre><code>class F(object)
</code></pre>
<p>declares <code>F</code> to be a <a href="http://www.python.org/doc/newstyle/" rel="nofollow">new-style class</a> (as opposed to a classic class).
In Python3, all classes are new-style, so the <code>object</code> can be omitted there.</p>
<p>Certain Python features, such as <a href="http://docs.python.org/2/library/functions.html#property" rel="nofollow">properties</a> and <a href="http://docs.python.org/2/library/functions.html#super" rel="nofollow">super</a>, only work with new-style classes. New-style classes also have certain attributes and methods, like <code>mro</code>, that classic classes lack.</p>
<p>Classic classes are present only for backwards compatibility. All classes you define should be new-style classes.</p>
<hr/>
<pre><code>class G(F):   
</code></pre>
<p>makes <code>G</code> a <em>subclass</em> of <code>F</code>, whereas</p>
<pre><code>H = F(1,2,3) 
</code></pre>
<p>makes <code>H</code> an <em>instance</em> of <code>F</code>.</p>
<p>Note that <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8 Style Guide</a> recommends that classes be named with CapWords, while instances be given lowercase names. (So <code>H</code> should be <code>h</code>...)</p>
<hr/>
<p>Be sure to also be aware of the difference between class attributes and instance attributes. The definition</p>
<pre><code>class F(object): 
    def __init__(self,a,b,c):
        self.a = a
        self.b = b
        self.c = c
</code></pre>
<p>gives instances of <code>F</code> instance attributes. The assignments <code>self.a = a</code>, etc. are executed only when the <code>__init__</code> method is called, which happens when an instance of <code>F</code> is created. For example, when you say</p>
<pre><code>H = F(1,2,3)
</code></pre>
<p>Notice that these instance attributes can be inspected in <code>H.__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; H.__dict__
&gt;&gt;&gt; {'a': 1, 'b': 2, 'c': 3}
</code></pre>
<p>They are <em>not</em> in <code>F.__dict__</code>. </p>
<pre><code>&gt;&gt;&gt; F.__dict__
&gt;&gt;&gt; dict_proxy({'__dict__': &lt;attribute '__dict__' of 'F' objects&gt;, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'F' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0xae90ae4&gt;})
</code></pre>
<p>Keys in <code>F.__dict__</code> are class attributes. They are shared by <em>all</em> instances of <code>F</code>. Instance attributes are specific to each instance, and can differ between instances.</p>
<p>Note that since <code>H</code> is an instance of <code>F</code>, <code>H</code> can access <code>F</code>'s class attributes as well a its own instance attributes. For instance,</p>
<pre><code>&gt;&gt;&gt; H.__module__
&gt;&gt;&gt; '__main__'
</code></pre>
<p>That's the basics, though there is a lot more that could be said about Python attribute lookup rules. See <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html" rel="nofollow">Chaturvedi</a> for a more complete description of these rules.</p>
<hr/>
<p>Now when you say</p>
<pre><code>class G(F):     
    a = 1
    b = 2
    c = 3
</code></pre>
<p>you are defining <code>a</code>, <code>b</code> and <code>c</code> to be class attributes of <code>G</code>. 
Notice that these class attributes can be inspected in <code>G.__dict__</code>:</p>
<pre><code>&gt;&gt;&gt; G.__dict__
&gt;&gt;&gt; dict_proxy({'a': 1, '__module__': '__main__', 'b': 2, 'c': 3, '__doc__': None})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First, <code>H</code> is not a subclass of <code>F</code>, it's an <em>instance</em> of <code>F</code>.</p>
<p>Try printing out the types:</p>
<pre><code>&gt;&gt;&gt; type(G)
builtins.type
&gt;&gt;&gt; type(H)
__main__.F
</code></pre>
<p>The exact details may be different in different Python versions, but the point is that <code>G</code> is a class, an object of type <code>type</code>, while <code>H</code> is an instance, an object of type <code>F</code>.</p>
<hr/>
<p>Second, <code>G</code> sets <em>class attributes</em> named <code>a</code>, <code>b</code>, and <code>c</code>. In any instance of type <code>G</code>, these will be hidden by the instance variables of the same names. But you can access them directly off the class. (If you don't understand class attributes… you don't want them.)</p>
<p>Again, trying to print things out may help:</p>
<pre><code>&gt;&gt;&gt; G.a
1
&gt;&gt;&gt; g = G(5, 6, 7)
&gt;&gt;&gt; g.a
5
</code></pre>
<hr/>
<p>Finally, for your side question:</p>
<blockquote>
<p>is the word 'object' meaningful?</p>
</blockquote>
<p>Yes. It's the name of the base class for all new-style classes in Python 2.x. So, doing <code>class F(object):</code> makes your class a new-style class. (This isn't necessary in Python 3.x.)</p>
<hr/>
<p>You should consider reading either the <a href="http://docs.python.org/3/tutorial/classes.html" rel="nofollow">Classes</a> section in the official tutorial, or a more novice-friendly tutorial. As millimoose says, all of this will be covered in any tutorial worth its bandwidth.</p>
</div>
<span class="comment-copy">This is all tutorial-level material... For one, the last line isn't a subclass definition.</span>
