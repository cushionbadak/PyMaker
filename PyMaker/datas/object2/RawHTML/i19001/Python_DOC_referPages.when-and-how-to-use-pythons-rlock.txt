<div class="post-text" itemprop="text">
<p>Reading through the Python docs I came across <code>RLock</code>.</p>
<p>Can someone explain to me (with example) a scenario in which <a href="http://docs.python.org/2/library/threading.html#rlock-objects" rel="noreferrer"><code>RLock</code></a> would be preferred to <a href="http://docs.python.org/2/library/threading.html#lock-objects" rel="noreferrer"><code>Lock</code></a>?</p>
<p>With particular reference to:</p>
<ul>
<li><code>RLock</code>'s “recursion level”. How is this useful?</li>
<li>A threads "ownership" of an <code>RLock</code> object</li>
<li>Performance?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This is one example where I see the use:</p>
<p><strong>Useful when</strong></p>
<ol>
<li><p>you want to have threadsave access from outside the class and use the same methods from inside the class:</p>
<pre><code>class X:
    def __init__(self):
        self.a = 1
        self.b = 2
        self.lock = threading.RLock()

    def changeA(self):
        with self.lock:
            self.a = self.a + 1

    def changeB(self):
        with self.lock:
            self.b = self.b + self.a

    def changeAandB(self):
        # you can use chanceA and changeB threadsave!
        with self.lock:
            self.changeA() # a usual lock would block in here
            self.changeB()
</code></pre></li>
<li><p>for recursion more obvious:</p>
<pre><code>lock = threading.RLock()
def a(...):
     with lock:

         a(...) # somewhere inside
</code></pre>
<p>other threads have to wait until the first call of <code>a</code> finishes = thread ownership.</p></li>
</ol>
<p><strong>Performance</strong></p>
<p>Usually I start programming with the Lock and when case 1 or 2 occur, I switch to an RLock. <a href="https://stackoverflow.com/questions/16567958/when-and-how-to-use-pythons-rlock/16568426#comment54124491_16568426">Until Python 3.2</a> the RLock should be a bit slower because of the additional code. It uses Lock:</p>
<pre><code>Lock = _allocate_lock # line 98 threading.py

def RLock(*args, **kwargs):
    return _RLock(*args, **kwargs)

class _RLock(_Verbose):

    def __init__(self, verbose=None):
        _Verbose.__init__(self, verbose)
        self.__block = _allocate_lock()
</code></pre>
<p><strong>Thread Ownership</strong></p>
<p>within the given thread you can acquire a <code>RLock</code> as often as you like. Other threads need to wait until this threads releases the resource again. </p>
<p>This is different to the <code>Lock</code> which implies 'function-call ownership'(I would call it this way): Another function call has to wait until the resource is released by the last blocking function even if it is in the same thread = even if it is called by the other function. </p>
<p><strong>When to use Lock instead of RLock</strong></p>
<p>When you make a call to the outside of the resource which you can not control.</p>
<p>The code below has two variables: a and b and the RLock shall be used to make sure a == b * 2</p>
<pre><code>import threading
a = 0 
b = 0
lock = threading.RLock()
def changeAandB(): 
    # this function works with an RLock and Lock
    with lock:
        global a, b
        a += 1
        b += 2
        return a, b

def changeAandB2(callback):
    # this function can return wrong results with RLock and can block with Lock
    with lock:
        global a, b
        a += 1
        callback() # this callback gets a wrong value when calling changeAandB2
        b += 2
        return a, b
</code></pre>
<p>In <code>changeAandB2</code> the Lock would be the right choice although it does block. Or one can enhance it with errors using <code>RLock._is_owned()</code>. Functions like <code>changeAandB2</code> may occur when you have implemented a Observer pattern or a Publisher-Subscriber and add locking afterwards.</p>
</div>
<div class="post-text" itemprop="text">
<ul>
<li>recursion level</li>
<li>ownership</li>
</ul>
<p>A primitive lock (Lock) is a synchronization primitive that is not owned by a particular thread when locked.</p>
<p>For the repeatable Lock (RLock) In the locked state, some thread owns the lock; in the unlocked state, no thread owns it.
When invoked if this thread already owns the lock, increment the recursion level by one, and return immediately. if thread doesn't own the lock It waits until owner release lock.
Release a lock, decrementing the recursion level. If after the decrement it is zero, reset the lock to unlocked.</p>
<ul>
<li>Performance</li>
</ul>
<p>I don't think there is some performance difference rather conceptual one. </p>
</div>
<div class="post-text" itemprop="text">
<p>Here is another use case for RLock.  Suppose you have a web-facing user interface that supports concurrent access, but you need to manage certain kinds of access to an external resource.  For instance, you have to maintain consistency between objects in memory and objects in a database, and you have a manager class that controls access to the database, with methods that you must ensure get called in a specific order, and never concurrently.</p>
<p>What you can do is create an RLock and a guardian thread that controls access to the RLock by constantly acquiring it, and releasing only when signaled to.  Then, you ensure all methods you need to control access to are made to obtain the lock before they run.  Something like this:</p>
<pre><code>def guardian_func():
    while True:
        WebFacingInterface.guardian_allow_access.clear()
        ResourceManager.resource_lock.acquire()
        WebFacingInterface.guardian_allow_access.wait()
        ResourceManager.resource_lock.release()

class WebFacingInterface(object):
    guardian_allow_access = Event()
    resource_guardian = Thread(None, guardian_func, 'Guardian', [])
    resource_manager = ResourceManager()

    @classmethod
    def resource_modifying_method(cls):
        cls.guardian_allow_access.set()
        cls.resource_manager.resource_lock.acquire()
        cls.resource_manager.update_this()
        cls.resource_manager.update_that()
        cls.resource_manager.resource_lock.release()

class ResourceManager(object):
    resource_lock = RLock()

    def update_this(self):
        if self.resource_lock.acquire(False):
            try:
                pass # do something
                return True

            finally:
                self.resource_lock.release()
        else:
            return False

    def update_that(self):
        if self.resource_lock.acquire(False):
            try:
                pass # do something else
                return True
            finally:
                self.resource_lock.release()
        else:
            return False
</code></pre>
<p>This way, you're ensured of the following things:</p>
<ol>
<li>Once a thread acquires the resource lock, it can call the resource manager's protected methods freely, because RLock is recursive</li>
<li>Once the thread acquires the resource lock through the master method in the web facing interface, all access to protected methods in the manager will be blocked to other threads</li>
<li>Protected methods in the manager can only be accessed by first appealing to the guardian.</li>
</ol>
</div>
<span class="comment-copy">See also <a href="http://stackoverflow.com/questions/8720783/recursive-locks">stackoverflow.com/questions/8720783/recursive-locks</a> and <a href="http://stackoverflow.com/questions/187761/recursive-lock-mutex-vs-non-recursive-lock-mutex" title="recursive lock mutex vs non recursive lock mutex">stackoverflow.com/questions/187761/…</a></span>
<span class="comment-copy">Great answer! Is <code>_is_owned</code> documented anywhere? I was expecting some kind of <code>owner_name</code> attribute or method but cannot find anything documented</span>
<span class="comment-copy"><code>_is_owned()</code> starts with an underscore and therefore one is not expected to use it. (It returns the tread id of <code>sys._current_treads()</code>.) <code>require(False)</code> is nonblocking and enough in most cases.</span>
<span class="comment-copy">For future readers, in <a href="https://docs.python.org/3/whatsnew/3.2.html#optimizations" rel="nofollow noreferrer">Python 3.2 and higher, the performance cost of <code>RLock</code> is basically zero</a>, because <code>RLock</code> is implemented in C just like <code>Lock</code>; previously, it was slower because it executed a lot of Python code to wrap <code>Lock</code>, but in 3.2+, there is no cost (aside from <code>Lock</code> being unlockable from other threads, where <code>RLock</code> is only unlockable by the owner, which is a meaningful distinction in stuff like the implementation of <code>Condition</code> which uses cross-thread unlocks to notify waiters).</span>
<span class="comment-copy">Minor comment, does the code not ensure b == 2*a?</span>
