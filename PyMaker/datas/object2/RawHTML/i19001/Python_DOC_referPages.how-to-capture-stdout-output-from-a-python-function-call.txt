<div class="post-text" itemprop="text">
<p>I'm using a Python library that does something to an object</p>
<pre><code>do_something(my_object)
</code></pre>
<p>and changes it. While doing so, it prints some statistics to stdout, and I'd like to get a grip on this information. The proper solution would be to change <code>do_something()</code> to return the relevant information,</p>
<pre><code>out = do_something(my_object)
</code></pre>
<p>but it will be a while before the devs of <code>do_something()</code> get to this issue. As a workaround, I thought about parsing whatever <code>do_something()</code> writes to stdout.</p>
<p>How can I capture stdout output between two points in the code, e.g.,</p>
<pre><code>start_capturing()
do_something(my_object)
out = end_capturing()
</code></pre>
<p>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Try this context manager:</p>
<pre><code>from cStringIO import StringIO
import sys

class Capturing(list):
    def __enter__(self):
        self._stdout = sys.stdout
        sys.stdout = self._stringio = StringIO()
        return self
    def __exit__(self, *args):
        self.extend(self._stringio.getvalue().splitlines())
        del self._stringio    # free up some memory
        sys.stdout = self._stdout
</code></pre>
<p>Usage:</p>
<pre><code>with Capturing() as output:
    do_something(my_object)
</code></pre>
<p><code>output</code> is now a list containing the lines printed by the function call.</p>
<p>Advanced usage:</p>
<p>What may not be obvious is that this can be done more than once and the results concatenated:</p>
<pre><code>with Capturing() as output:
    print 'hello world'

print 'displays on screen'

with Capturing(output) as output:  # note the constructor argument
    print 'hello world2'

print 'done'
print 'output:', output
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>displays on screen                     
done                                   
output: ['hello world', 'hello world2']
</code></pre>
<p><em>Update</em>: They added <code>redirect_stdout()</code> to <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout" rel="noreferrer"><code>contextlib</code></a> in Python 3.4 (along with <code>redirect_stderr()</code>). So you could use <code>io.StringIO</code> with that to achieve a similar result (though <code>Capturing</code> being a list as well as a context manager is arguably more convenient).</p>
</div>
<div class="post-text" itemprop="text">
<p>In python &gt;= 3.4, contextlib contains a <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout"><code>redirect_stdout</code></a> decorator. It can be used to answer your question like so:</p>
<pre><code>import io
from contextlib import redirect_stdout

f = io.StringIO()
with redirect_stdout(f):
    do_something(my_object)
out = f.getvalue()
</code></pre>
<p>From <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout">the docs</a>:</p>
<blockquote>
<p>Context manager for temporarily redirecting sys.stdout to another file
  or file-like object.</p>
<p>This tool adds flexibility to existing functions or classes whose
  output is hardwired to stdout.</p>
<p>For example, the output of help() normally is sent to sys.stdout. You
  can capture that output in a string by redirecting the output to an
  io.StringIO object:</p>
<pre><code>  f = io.StringIO() 
  with redirect_stdout(f):
      help(pow) 
  s = f.getvalue()
</code></pre>
<p>To send the output of help() to a file on disk, redirect the output to
  a regular file:</p>
<pre><code> with open('help.txt', 'w') as f:
     with redirect_stdout(f):
         help(pow)
</code></pre>
<p>To send the output of help() to sys.stderr:</p>
<pre><code>with redirect_stdout(sys.stderr):
    help(pow)
</code></pre>
<p>Note that the global side effect on sys.stdout means that this context
  manager is not suitable for use in library code and most threaded
  applications. It also has no effect on the output of subprocesses.
  However, it is still a useful approach for many utility scripts.</p>
<p>This context manager is reentrant.</p>
</blockquote>
</div>
<span class="comment-copy">possible duplicate of <a href="http://stackoverflow.com/questions/12111717/capturing-dis-dis-results">capturing dis.dis results</a></span>
<span class="comment-copy">My answer in the linked question applies here as well.</span>
<span class="comment-copy">I tried to do that once and the best answer I found was:    <a href="http://stackoverflow.com/a/3113913/1330293">stackoverflow.com/a/3113913/1330293</a></span>
<span class="comment-copy">@elyase linked answer is an elegant solution</span>
<span class="comment-copy">See this <a href="http://stackoverflow.com/a/3378965/355230">answer</a>.</span>
<span class="comment-copy">Thanks! And thanks for adding the advanced section... I originally used a slice assignment to stick the captured text into the list, then I bonked myself in the head and used <code>.extend()</code> instead so it could be used concatenatively, just as you noticed.  :-)</span>
<span class="comment-copy">You're welcome -- glad you didn't mind my edit.</span>
<span class="comment-copy">Great answer, thanks. For Python 3, use <code>from io import StringIO</code> instead of first line in context manager.</span>
<span class="comment-copy">Is this thread-safe? What happens if some other thread/call uses print() while do_something runs?</span>
<span class="comment-copy">This answer will not work for output from C shared libraries, see <a href="https://stackoverflow.com/questions/24277488/in-python-how-to-capture-the-stdout-from-a-c-shared-library-to-a-variable/29834357">this answer</a> instead.</span>
