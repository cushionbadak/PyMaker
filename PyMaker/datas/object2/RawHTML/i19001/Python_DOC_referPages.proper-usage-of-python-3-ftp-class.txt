<div class="post-text" itemprop="text">
<p>As a python newbie still learning the language, I struggled for a couple of days trying to do a simple ASCII file transfer (STOR/PUT) using the ftp class in ftplib (running Python 3.3).</p>
<p>After using the storbinary() method and consistently getting a TypeError: "Type str doesn't support the buffer API", I discovered the discussion on this thread, which implies that there is a bug in the port of ftplib to Python 3:</p>
<p><a href="http://bugs.python.org/issue6822" rel="nofollow">http://bugs.python.org/issue6822</a></p>
<p>I then tried using storbinary() instead of storlines(), using a file object opened using the 'rb' switch and it seems to work perfectly. I'm working on a Windows system, and for testing/learning purposes I'm uploading to my own site which is on a Linux host. After uploading both .zip and .txt files and copying them back down to my workstation using FileZilla, both files are intact.</p>
<p>In my day-to-day work I need to upload gzipped and ASCII files to a mainframe, and am concerned that I may be leaving myself open to file transfer errors using this counter-intuitive work-around. I've screwed up so many manual FTP transfers when forgetting to switch to the appropriate transfer mode, that it feels creepy to be able to transfer both binary and ASCII files using exactly the same code!</p>
<p>Can anyone comment on how I'm implementing this library class? </p>
<p>Thanks.</p>
<pre><code>fileName = 'F:\\Data_Folder\\Test_File.txt'
fileParts = os.path.split(fileName)
putFile = fileParts[1]
cmd = 'STOR {}'.format(putFile)
fileObject = open(fileName, 'rb')
ftp.storbinary(cmd, fileObject)

fileName = 'F:\\Data_Folder\\Test_File.zip'
fileParts = os.path.split(fileName)
putFile = fileParts[1]
cmd = 'STOR {}'.format(putFile)
fileObject = open(fileName, 'rb')
ftp.storbinary(cmd, fileObject)
</code></pre>
<p>6/28/2013 -
Coming back here to kinda "close the loop" on this issue.
While I can use open(fileName, 'rb') together with ftp.storbinary() successfully for both binary and ASCII text files, with both Windows and Linux hosts as the target, when I do so with the mainframe as the target, the text file is getting garbled, appearing as a binary file.</p>
<p>By adding a switch to my wrapper class to continue to open the file with the 'rb' argument, but using storlines() instead to do the transfer, the file arrives at the destination intact. I'm willing to bet that there are likely some configuration options on the mainframe side that could make this behavior vary from one host to another, but I'm hoping that mentioning this will alert anyone encountering this thread to the possibility that the apparently "safe" combination of open(fileName, 'rb') and storbinary() may not succeed with all FTP hosts, most notably mainframe systems. It may be only determined through trial-and-error, but there are cases in which the correct approach for transferring ASCII data will require open(fileName, 'rb') together with storlines().</p>
</div>
<div class="post-text" itemprop="text">
<p>The 3.3 documentation for <a href="http://docs.python.org/3/library/ftplib.html#ftplib.FTP.storlines" rel="nofollow"><code>storlines</code></a> explicitly says:</p>
<blockquote>
<p>Lines are read until EOF from the <em>file object file</em> (opened in binary mode)…</p>
</blockquote>
<p>So, passing it a file opened in text mode isn't supposed to work.</p>
<p>FTP's text (ASCII) mode isn't the same think as Python's text mode. In particular, FTP text is required to be ASCII (and real 7-bit ASCII, not an extended codepage with values &gt; 127). But Python text has an explicitly-specified character set, and is treated as Unicode. If your files are actually UTF-8, Latin-1, CP-850, etc., you can't use text mode.</p>
<p>On top of that, both Python and FTP are allowed to munge line endings for text files. Sometimes you <em>want</em> that, so you can upload a Windows text file to a linux box and have it show up with Unix line-endings instead of Windows (although that may not actually happen, depending on a variety of things…). But otherwise, you don't want to use text mode.</p>
<p>In short, you're probably doing the right thing by opening your text files in binary mode and uploading them in binary (image) mode.</p>
<hr/>
<p>Meanwhile, your code is fine as-is, but if you're looking for ways to improve it, there's always room for minor changes.</p>
<p>First, if you've got the same 7 lines copied and pasted twice, and the only difference is the string in 1 line, factor it out into a function. </p>
<p>Also, close your files. Either add an explicit <code>fileObject.close()</code>, or, better, use a <code>with</code> statement. If you've only got 2 files in a short-lived script, it won't make much difference, but it's still a good idea—and you might later expand this into something that opens more than 2 files or lives longer.</p>
<p>If you just want the basename of a file, it's clearer to call <code>basename</code> than to call <code>split</code> and then access <code>[1]</code>.</p>
<p>Getting into the nitpicky, unless you've got lots of "legacy" or wrapper code using a different style, it's better to stick with <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP 8</a> than to invent your own style.</p>
<p>Finally, if you want to leave open the possibility of sending text and binary files differently, even though at present they're implemented the same, just write <code>upload_binary_file</code> and <code>upload_text_file</code>, and make the latter call the second, or be a reference to the same function. However, you probably <em>don't</em> want this. For the reasons explained above, and in J.F. Sebastian's comments, a <code>upload_text_file</code> function is more likely to be a misleading attractive nuisance than a useful hook for future expansion.</p>
<p>So:</p>
<pre><code>def upload_file(filename):
    put_file = os.path.basename(filename)
    cmd = 'STOR {}'.format(put_file)
    with open(filename, 'rb') as file_object:
        ftp.storbinary(cmd, file_object)

upload_file('F:\\Data_Folder\\Test_File.txt')
upload_file('F:\\Data_Folder\\Test_File.zip')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your code seems a little convoluted to me, you're using a lot of variables, this is how I would do it:</p>
<pre><code>fileName = 'F:\\Data_Folder\\Test_File.txt'

fileObject = open(fileName, 'rb')

ftp.storbinary('STOR ' + os.path.split(fileName)[1], fileObject)
</code></pre>
<p>And the same holds true for a zip file.  Binary mode simply transmits your file as a series of 1's and 0's, <code>ASCII</code> transfers it as <code>ASCII</code> characters, it all ends up the same way at the end. I also believe you're generally advised to avoid <code>ASCII</code> mode because of some sort of exploit that can be executed on it.</p>
</div>
<span class="comment-copy">Keep in mind that FTP text mode is explicitly ASCII, while most "text files" are UTF-8 or Latin-1 or CP-850 or something else. Plus, FTP text mode is allowed to munge line endings. So, are you sure you want to use text mode anyway?</span>
<span class="comment-copy">Meanwhile, it's always safe to transfer ASCII in binary mode, unless you <i>want</i> the other side to convert line endings (or transcode ASCII to EBCDIC or something), so… what are you worried about?</span>
<span class="comment-copy">abarnert - thanks!</span>
<span class="comment-copy">abarnert - thanks! As to the duplicated lines, this is just the quick'n'dirty script I was using to just try to get this to work. I'm actually implementing the entire operation in a class as the ftp transfer is just a small part of it. Thanks too for the basename method, and the with statement - hadn't discovered those yet, and the recommendation to close the file! I read through PEP 8 about once a week, and I'm still trying to internalize the pythonic style.</span>
<span class="comment-copy"><code>upload_text_file</code> seems like a bad idea for the reasons you've outlined, even <code>upload_ascii_file()</code> is not enough (e.g., uploading and downloading the same ascii-only file might be non-idempotent operation (mixed-newlines case)). It is simpler to use image mode that transfers files as-is as you suggested unless there are additional requirements.</span>
<span class="comment-copy">Also, thanks for pointing out the little detail in the doco that I missed - that the storlines() refers to a file object opened in binary. Don't know how I could have missed that as many times as I've read that entry :-)</span>
<span class="comment-copy">@J.F.Sebastian: To clarify: You're saying I should retract the suggestion of possibly having two separate functions, because the second one is guaranteed to be misleading unless incorrect? If so, I think I agree with you, and I'll edit the answer accordingly… but I want to make sure I'm understanding you first.</span>
<span class="comment-copy">Why would you suggest replacing <code>os.path.split</code> with <code>str.split('\')</code>? That's a very bad idea. Even besides the fact that, as written, it's a <code>SyntaxError</code>, why make your code less portable, less flexible, and less clear for no benefit?</span>
<span class="comment-copy">You would be correct, the os.path.split option is better, and I had forgotten the second \ the impetus was more of using less variables, though you are correct that the os method is better than string manipulation</span>
<span class="comment-copy"><code>os.path.basename(path)</code> might be more explicit than <code>os.path.split(path)[1]</code>.</span>
<span class="comment-copy">Thanks for the additional comments, Seth. I don't like to use variables unnecessarily, and abarnert's basename() method eliminates one, but I hesitate to nest too much in a single line. I'm a nut about readability, and I hate doing code reviews, or having to work on code that has too much of that kind of stuff going on.</span>
<span class="comment-copy">I would agree, I personally don't find it too awful to nest something like that in a single line because I find the name of the method itself to be fairly clear in identifying what the output should be.  And you are correct J.F. Sebastian, that is also probably a better solution than split.</span>
