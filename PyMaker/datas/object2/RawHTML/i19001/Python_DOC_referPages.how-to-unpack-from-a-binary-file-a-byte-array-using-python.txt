<div class="post-text" itemprop="text">
<p>I'm giving myself a crash course in reading a binary file using Python. I'm new to both, so please bear with me.</p>
<p>The file format's documentation tells me that the first 16 bytes are a GUID and further reading tells me that this GUID is formatted thus:</p>
<pre><code>typedef struct {
  unsigned long Data1;
  unsigned short Data2;
  unsigned short Data3;
  byte Data4[8];
} GUID, 
 UUID, 
 *PGUID;
</code></pre>
<p>I've got as far us being able to unpack the first three entries in the struct, but I'm getting stumped on #4. It's an array of 8 bytes I think but I'm not sure how to unpack it.</p>
<pre><code>import struct

fp = open("./file.bin", mode='rb')

Data1 = struct.unpack('&lt;L', fp.read(4)) # unsigned long, little-endian
Data2 = struct.unpack('&lt;H', fp.read(2)) # unsigned short, little-endian 
Data3 = struct.unpack('&lt;H', fp.read(2)) # unsigned short, little-endian
Data4 = struct.unpack('&lt;s', bytearray(fp.read(8))) # byte array with 8 entries?

struct.error: unpack requires a bytes object of length 1
</code></pre>
<p>What am I doing wrong for Data4? (I'm using Python 3.2 BTW)</p>
<p>Data1 thru 3 are OK. If I use hex() on them I am getting the correct data that I'd expect to see (woohoo) I'm just failing over on the syntax of this byte array.</p>
<p><strong>Edit: Answer</strong></p>
<p>I'm reading a GUID as defined in MS-DTYP and this nailed it:</p>
<pre><code>data = uuid.UUID(bytes_le=fp.read(16))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want an 8-byte string, you need to put the number <code>8</code> in there:</p>
<pre><code>struct.unpack('&lt;8s', bytearray(fp.read(8)))
</code></pre>
<p>From <a href="http://docs.python.org/3/library/struct.html" rel="noreferrer">the docs</a>:</p>
<blockquote>
<p>A format character may be preceded by an integral repeat count. For example, the format string '4h' means exactly the same as 'hhhh'.</p>
</blockquote>
<p>… </p>
<blockquote>
<p>For the 's' format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, '10s' means a single 10-byte string, while '10c' means 10 characters. If a count is not given, it defaults to 1. For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes. As a special case, '0s' means a single, empty string (while '0c' means 0 characters).</p>
</blockquote>
<hr/>
<p>However, I'm not sure why you're doing this in the first place.</p>
<p><code>fp.read(8)</code> gives you an 8-byte <code>bytes</code> object. You want an 8-byte <code>bytes</code> object. So, just do this:</p>
<pre><code>Data4 = fp.read(8)
</code></pre>
<p>Converting the <code>bytes</code> to a <code>bytearray</code> has no effect except to make a mutable copy. Unpacking it just gives you back a copy of the same <code>bytes</code> you started with. So… why?</p>
<hr/>
<p>Well, actually, <code>struct.unpack</code> returns a <code>tuple</code> whose one value is a copy of the same <code>bytes</code> you started with, but you can do that with:</p>
<pre><code>Data4 = (fp.read(8),)
</code></pre>
<p>Which raises the question of why you want four single-element tuples in the first place. You're going to be doing <code>Data1[0]</code>, etc. all over the place for no good reason. Why not this?</p>
<pre><code>Data1, Data2, Data3, Data4 = struct.unpack('&lt;LHH8s', fp.read(16))
</code></pre>
<hr/>
<p>Of course if this is meant to read a UUID, it's always better to use the "batteries included" than to try to build your own batteries from nickel and cadmium ore. As icktoofay says, just use the <code>uuid</code> module:</p>
<pre><code>data = uuid.UUID(bytes_le=fp.read(16))
</code></pre>
<p>But keep in mind that Python's <code>uuid</code> uses the 4-2-2-1-1-6 format, not the 4-2-2-8 format. If you really need exactly that format, you'll need to convert it, which means either <code>struct</code> or bit twiddling anyway. (Microsoft's GUID makes things even more fun by using a 4-2-2-2-6 format, which is not the same as either, and representing the first 3 in native-endian and the last two in big-endian, because they like to make things easier…)</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" rel="nofollow">UUIDs</a> are supported by Python with <a href="http://docs.python.org/3.3/library/uuid.html" rel="nofollow">the <code>uuid</code> module</a>. Do something like this:</p>
<pre><code>import uuid

my_uuid = uuid.UUID(bytes_le=fp.read(16))
</code></pre>
</div>
<span class="comment-copy">You're using struct in combination with bytearray, these are separate things.  I'm not familiar with bytearray, but I'm pretty sure <code>struct.unpack()</code> won't take the object returned by <code>bytearray</code></span>
<span class="comment-copy">@monkut: It will, because it supports <a href="http://docs.python.org/3.3/c-api/buffer.html" rel="nofollow noreferrer">the buffer protocol</a>.</span>
<span class="comment-copy">@icktoofay thanks!  good to know!</span>
<span class="comment-copy">Additionally, the <code>bytearray</code> is not needed (although it won't hurt).</span>
<span class="comment-copy">@icktoofay: You're right… but the whole <code>unpack</code> is not needed either…</span>
<span class="comment-copy">That's a very good point that I hadn't even thought of.</span>
<span class="comment-copy">Thanks for the all comments. <i>very</i> helpful and will assist as I now try to read the rest of the file :)</span>
<span class="comment-copy"><code>bytes</code> is in big-endian order; the OP's data (assuming he got the <code>struct</code> format right) is in little-endian. So, you need <code>bytes_le</code> here, not <code>bytes</code>.</span>
<span class="comment-copy">Also, it's worth noting that Python's UUID is 4-2-2-1-1-6, not 4-2-2-8. So, if you want to get the 4-2-2-8 format, you have to convert <code>fields</code> manually.</span>
