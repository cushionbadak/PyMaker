<div class="post-text" itemprop="text">
<p>If I have these two lists:</p>
<pre><code>la = [1, 2, 3]
lb = [4, 5, 6]
</code></pre>
<p>I can iterate over them as follows:</p>
<pre><code>for i in range(min(len(la), len(lb))):
    print la[i], lb[i]
</code></pre>
<p>Or more pythonically</p>
<pre><code>for a, b in zip(la, lb):
    print a, b
</code></pre>
<hr/>
<p>What if I have two dictionaries?</p>
<pre><code>da = {'a': 1, 'b': 2, 'c': 3}
db = {'a': 4, 'b': 5, 'c': 6}
</code></pre>
<p>Again, I can iterate manually:</p>
<pre><code>for key in set(da.keys()) &amp; set(db.keys()):
    print key, da[key], db[key]
</code></pre>
<p>Is there some builtin method that allows me to iterate as follows?</p>
<pre><code>for key, value_a, value_b in common_entries(da, db):
    print key, value_a, value_b 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There is no built-in function or method that can do this. However, you could easily define your own.</p>
<pre><code>def common_entries(*dcts):
    for i in set(dcts[0]).intersection(*dcts[1:]):
        yield (i,) + tuple(d[i] for d in dcts)
</code></pre>
<p>This builds on the "manual method" you provide, but, like <code>zip</code>, can be used for any number of dictionaries.</p>
<pre><code>&gt;&gt;&gt; da = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; db = {'a': 4, 'b': 5, 'c': 6}
&gt;&gt;&gt; list(common_entries(da, db))
[('c', 3, 6), ('b', 2, 5), ('a', 1, 4)]
</code></pre>
<p>When only one dictionary is provided as an argument, it essentially returns <code>dct.items()</code>.</p>
<pre><code>&gt;&gt;&gt; list(common_entries(da))
[('c', 3), ('b', 2), ('a', 1)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You may want to make an intersection, using the Python Set type.</p>
<pre><code>da = {'a': 1, 'b': 2, 'c': 3, 'e': 7}
db = {'a': 4, 'b': 5, 'c': 6, 'd': 9}

dc = set(da) &amp; set(db)

for i in dc:
  print i,da[i],db[i]
</code></pre>
<p>Cheers,</p>
<p>K.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">Dictionary key views</a> are already set-like in Python 3.  You can remove <code>set()</code>:</p>
<pre><code>for key in da.keys() &amp; db.keys():
    print(key, da[key], db[key])
</code></pre>
<p>In Python 2:</p>
<pre><code>for key in da.viewkeys() &amp; db.viewkeys():
    print key, da[key], db[key]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>In case if someone is looking for generalized solution:</p>
<pre><code>import operator
from functools import reduce


def zip_mappings(*mappings):
    keys_sets = map(set, mappings)
    common_keys = reduce(set.intersection, keys_sets)
    for key in common_keys:
        yield (key,) + tuple(map(operator.itemgetter(key), mappings))
</code></pre>
<p>or if you like to separate key from values and use syntax like</p>
<pre><code>for key, (values, ...) in zip_mappings(...):
    ...
</code></pre>
<p>we can replace last line with</p>
<pre><code>yield key, tuple(map(operator.itemgetter(key), mappings))
</code></pre>
<hr/>
<h3>Tests</h3>
<pre><code>from collections import Counter


counter = Counter('abra')
other_counter = Counter('kadabra')
last_counter = Counter('abbreviation')
for (character,
     frequency, other_frequency, last_frequency) in zip_mappings(counter,
                                                                 other_counter,
                                                                 last_counter):
    print('character "{}" has next frequencies: {}, {}, {}'
          .format(character,
                  frequency,
                  other_frequency,
                  last_frequency))
</code></pre>
<p>gives us</p>
<pre><code>character "a" has next frequencies: 2, 3, 2
character "r" has next frequencies: 1, 1, 1
character "b" has next frequencies: 1, 1, 2
</code></pre>
<p>(tested on <code>Python 2.7.12</code> &amp; <code>Python 3.5.2</code>)</p>
</div>
<span class="comment-copy">What is <code>common_entries()</code> supposed to be doing?</span>
<span class="comment-copy">@ASGM: The same thing as the code block above. You probably missed my update.</span>
<span class="comment-copy">@ASGM What the manual method does</span>
<span class="comment-copy">When I asked it hadn't been updated yet.  Now it's clear.</span>
<span class="comment-copy">@Eric python builtins are made usually because of their popularity. This is not used often enough to make it a builtin</span>
<span class="comment-copy">Nice - won't bother posting my answer now... I was going a <code>for key in reduce (and_, (d.viewkeys () for d in args))</code> route - not sure why though...</span>
<span class="comment-copy">Bug: the <code>common_entries()</code> fails if it is invoked with no args: `list(common_entries())`` - this is a common case when the list-of-dicts evaluates to the empty-list.</span>
<span class="comment-copy">[Change1:] Also, sticking to the <code>zip(*seq)--&gt;seq</code> contract, i suggest to return <code>key, (values, tuple, ...)</code> so as to mimic a dictionary. [Change2:] Finally a better name would be <code>zipdic(*map)--&gt;map</code>.</span>
<span class="comment-copy">Very helpful, thanks! :)</span>
<span class="comment-copy"><code>for i in set().intersection(*dcts):</code> is faster I think? <code>setup = "x=[[1],[2],[3,2,3]]"</code> <code>timeit.timeit("set(x[0]).union(*x[1:])", setup=setup) - timeit.timeit("set().union(*x)", setup=setup)</code> <code>Out[25]: 0.16900332879538382</code></span>
<span class="comment-copy">That's basically what the OP's manual method does.</span>
<span class="comment-copy">Except it does avoid the use of <code>.keys()</code> which deserves a +1</span>
<span class="comment-copy">Yep, I'd forgotten that dictionaries are iterable over their keys by default.</span>
<span class="comment-copy">Oops, I've answered before Eric edited his question. Thanks @jamylak.</span>
