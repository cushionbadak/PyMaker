<div class="post-text" itemprop="text">
<p>It seems like it would be only natural to do something like:</p>
<pre><code>with socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
</code></pre>
<p>but Python doesn't implement a context manager for socket. Can I easily use it as a context manager, and if so, how?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>socket</code> module is fairly low-level, giving you almost direct access to the C library functionality.</p>
<p>You can always use the <a href="http://docs.python.org/2/library/contextlib.html#contextlib.contextmanager" rel="noreferrer"><code>contextlib.contextmanager</code> decorator</a> to build your own:</p>
<pre><code>import socket
from contextlib import contextmanager

@contextmanager
def socketcontext(*args, **kw):
    s = socket.socket(*args, **kw)
    try:
        yield s
    finally:
        s.close()

with socketcontext(socket.AF_INET, socket.SOCK_DGRAM) as s:
</code></pre>
<p>or use <a href="http://docs.python.org/2/library/contextlib.html#contextlib.closing" rel="noreferrer"><code>contextlib.closing()</code></a> to achieve the same effect:</p>
<pre><code>from contextlib import closing

with closing(socket.socket(socket.AF_INET, socket.SOCK_DGRAM)) as s:
</code></pre>
<p>but the <code>contextmanager()</code> decorator gives you the opportunity to do other things with the socket first.</p>
<p>Python 3.x does make <code>socket()</code> a context manager, even though the documentation fails to mention that. See the <a href="http://hg.python.org/cpython/file/e57c8a90b2df/Lib/socket.py#l87" rel="noreferrer"><code>socket</code> class</a> in the source code, which adds <code>__enter__</code> and <code>__exit__</code> methods.</p>
</div>
<div class="post-text" itemprop="text">
<p>The socket module is just a wrapper around the BSD socket interface. It's low-level, and does not really attempt to provide you with a handy or easy to use Pythonic API. You may want to use something higher-level.</p>
<p>That said, it does in fact implement a context manager:</p>
<pre><code>&gt;&gt;&gt; with socket.socket() as s:
...   print(s)
... 
&lt;socket.socket object, fd=3, family=2, type=1, proto=0&gt;
</code></pre>
<p>But you need to use Python 3.</p>
<p>For Python 2 compatibility you can use <code>contextlib</code>.</p>
<pre><code>from contextlib import closing
import socket

with closing(socket.socket()) as s:
    print s
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Please have a look on following snippets, for both TCP and UDP sockets</p>
<pre><code>import socket
from contextlib import contextmanager


@contextmanager
def tcp_connection_to(*args, **kwargs):
    s = socket.create_connection(*args, **kwargs)
    yield s
    s.close()


@contextmanager
def udp_connection():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    yield s
    s.close()
</code></pre>
<p>So that you can use them in following way:</p>
<pre><code>MY_SERVER = ('localhost', 5000)   # Yes, we need tuple here
some_data = bytes("Hello.")

with tcp_connection_to(MY_SERVER) as conn:
    conn.send(some_data)

with udp_connection() as conn:
    conn.sendto(some_data, MY_SERVER)
</code></pre>
<p>I've also tried to emphasise the difference in behaviour and approach to term 'connection' between TCP  and UDP in method names.</p>
</div>
<span class="comment-copy">"Why" questions are in general not good questions for SO. Perhaps you can rewrite this into "how"? :-)</span>
<span class="comment-copy">@msw: No. That's just a why-question in disguise. A good question is "How do I use a socket as a context manager?". The current question I could correctly answer with. "It does" or "No", or "Yes". Not very helpful.</span>
<span class="comment-copy">@msw: Firstly, this is just more confirmation that "why" questions are bad, since they can trigger an infinite "why not" descent into hell. :-) Secondly,  I think you misunderstand what context managers are. The answer "a socket is not like a file" doesn't make any sense as an answer to the "why" question in this case. It's completely irrelevant that it is not like a file. Context managers are not just for files.</span>
<span class="comment-copy">@msw: I didn't alter the meaning, I made it a good question.</span>
<span class="comment-copy">@msw: Note that closing is really a temporary state; improve the question and it can be reopened again. Improving the question <i>before</i> it is closed is a better idea still.</span>
<span class="comment-copy">the Python3 <code>with</code>/<code>as</code> seems very useful, I can't think of any reason to leave this out of the docs, would you happen to know why it's not in there?</span>
<span class="comment-copy">@RyanHaining: The <a href="http://bugs.python.org/issue9794" rel="nofollow noreferrer">patch submitter</a> merely forgot to document it properly.</span>
<span class="comment-copy">@RyanHaining: The patch did update <a href="https://docs.python.org/3/library/socket.html#socket.create_connection" rel="nofollow noreferrer"><code>socket.create_connection()</code></a> but it's kinda hidden.</span>
<span class="comment-copy">what is meant by "first" where it says "gives you the opportunity to do other things with the socket first"? Seems to me that the custom context manager (i.e. socketcontext) allows one to do exactly the same things as contextlib.closing. What is the difference??</span>
<span class="comment-copy">@allyourcode: <code>contextlib.closing()</code> will only call <code>close</code> on the socket. A custom context manager could, say,  bind to an open port, set a timeout or other socket options first, or send out a protocol-specific closing packet or some such when exiting the context.</span>
