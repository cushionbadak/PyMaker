<div class="post-text" itemprop="text">
<p>I would like to get a python list, say, <code>[1,2,3,4]</code>, from a C++ script. I wrote the C++ script, which returns a vector.</p>
<p>How to connect the ends without SWIG/SIP/Cython/and others?</p>
<p>Could it be easier to just compile the C++ to an .exe or elf file and then call from command line, have the .exe create a .txt containing a vector and read it in with python?</p>
<p>My point is, I only need a really small function from C++ to do the heavy calculations on huge data. What would be the least painful and shortest method to do just this? </p>
<p><strong>EDIT:</strong>
To give an example. Python will give a filename string to C++ ("foo.txt"), which will then read the context of the file (200,000 rows by 300 columns), count the missings and then return to Python the amount of missings per row. This yields a list of 200,000 numbers. 
How to have this communication between both of them? </p>
<p>Just for completeness, this is what I am still wondering about how to go about:</p>
<ul>
<li>Pass python filename string to C++</li>
<li>Receive python string in C++</li>
<li>DONE Create vector in C++                    </li>
<li>Return vector to Python</li>
<li>Receive vector in Python</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This is probably moot now, and I posted something similar on <a href="https://stackoverflow.com/questions/16885344/how-to-handle-c-return-type-stdvectorint-in-python-ctypes">your other question</a>, but I've adapted this version for Python 3.3 and C++ rather than Python 2.7 and C.</p>
<p>If you want to get back a Python list object, and since you're building a list which could potentially be very long (200,000 items), it's probably more efficient to build the Python list in the C++ code, rather than building a <code>std::vector</code> and then converting that to a Python list later on.</p>
<p>Based on the code in your other question, I'd suggest using something like this...</p>
<pre><code>// foo.cpp
#include &lt;python3.3/Python.h&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

extern "C"
{
    PyObject* foo(const char* FILE_NAME)
    {
        string line;
        ifstream myfile(FILE_NAME);
        PyObject* result = PyList_New(0);

        while (getline(myfile, line))
        {
            PyList_Append(result, PyLong_FromLong(1));
        }

        return result;
    }
}
</code></pre>
<p>...compiled with...</p>
<pre><code>$ g++ -fPIC -shared -o foo.so foo.cpp -lpython3.3m
</code></pre>
<p>...and an example of usage...</p>
<pre><code>&gt;&gt;&gt; from ctypes import *
&gt;&gt;&gt; foo = CDLL('./foo.so')
&gt;&gt;&gt; foo.foo.restype = py_object
&gt;&gt;&gt; foo.foo(b'foo.cpp')
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
</code></pre>
<p>...although if you need to convert an existing <code>std::vector</code> to a Python list, you can pre-allocate the memory needed by the Python list by passing the length of the vector into <a href="http://docs.python.org/3/c-api/list.html#PyList_New" rel="nofollow noreferrer"><code>PyList_New()</code></a>, and then use <a href="http://docs.python.org/3/c-api/list.html#PyList_SetItem" rel="nofollow noreferrer"><code>PyList_SetItem()</code></a> instead of <a href="http://docs.python.org/3/c-api/list.html#PyList_Append" rel="nofollow noreferrer"><code>PyList_Append()</code></a>.</p>
<p>The only other methods I can think of would be...</p>
<ol>
<li><p>To pre-allocate a block of RAM in Python, and have the C++ function fill in the values, like in qarma's answer, but you'd have to know in advance how much RAM to allocate. You could just pick an arbitrary value, but given that the number of lines in the file isn't known in advance, this number may be way too large or way too small.</p></li>
<li><p>To heap-allocate the <code>std::vector</code> in C++, and return a pointer to the first element, and the number of elements, but you'd have to write a second function to free the RAM once you were done with it.</p></li>
</ol>
<p>Either way, you still have the overhead of converting the 'returned' array into a Python list, so you may as well do it yourself.</p>
</div>
<div class="post-text" itemprop="text">
<p>Define your entry point <code>extern "C"</code> and use <code>ctypes</code>.</p>
<p>Here's an example to get you started, data is passed from Python, C++ code sorts the data, and Python gets back the result:</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;algorithm&gt;

extern "C" {
    void foo(float* arr, size_t len);
}

void foo(float* arr, size_t len)
{
    // if arr is input, convert to C++ array

    // crazy C++ code here
    std::sort(arr, arr+len);

    // if arr is output, convert C++ array to arr
}
</code></pre>
<p>Compile your code into a shared object (libxxx.so on linux, libxxx.dll on win, libxxx.dylib on osx), then load it dynamically and pass data in/out via ctypes:</p>
<pre><code>import ctypes
import posix

# Darwin .dylib; Linux .so; Windows .dll; use sys.platform() for runtime detection
libxxx = ctypes.CDLL("./libxxx.so")
libxxx.foo.argtypes = [ctypes.POINTER(ctypes.c_float), ctypes.c_size_t]
libxxx.foo.restype = None

data = ctypes.ARRAY(ctypes.c_float, 100)()

# write someting into data[x]
import random
for i in range(100): data[i] = random.random()
print data[:3], "...", data[-3:]

libxxx.foo(data, len(data))

# read out from data[x]
print data[:3], "...", data[-3:]
</code></pre>
<p>Great thing about <code>ctypes</code> is that it's bundled with Python since 2.5, you don't need any additional libraries.</p>
<p>If you want to use something more advanced, have a look at <code>cffi</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're on the right track.</p>
<p>Do you have two executables going?</p>
<p>Better would be to save it to an intermediate file. Lock the file, write to it from your C++ code. Unlock and read it from Python.</p>
<p>If you just want to run from python, you can always look into extending python:</p>
<p><a href="http://docs.python.org/2/extending/extending.html" rel="nofollow">Extending Python with C++</a></p>
<p>There's also the option of doing it through sockets, though this may be a bit of overkill if all you want to do is pass lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use the subprocess module in python to read the output from your c++ exe file.
For example:</p>
<p>c++ file:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
    int a[]={1,2,3,4};
    cout&lt;&lt;"[";
    for(int i=0; i&lt;3; i++)
        cout&lt;&lt;a[i]&lt;&lt;",";
    cout&lt;&lt;a[3]&lt;&lt;"]";
    return 0;
}
</code></pre>
<p>then your python script will be:</p>
<pre><code>import subprocess
a=subprocess.check_output("c++compiledfile")
l=eval(a)
print l
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can work with strings in the interprocess communication:
<br/>use the subprocess.check_output() function in Python to check the C++ program's output, and pass the filename as an argument:</p>
<p>Python's code:</p>
<pre><code>import subprocess
from time import clock


ti=clock()
txt_fname='foo.txt'
# pass the filename string to a c++ program, and receive vector in python
output=subprocess.check_output(["./prog", txt_fname])
result = eval(output)   # convert the str_result to a vector/list
tf=clock()

print(result)
print(format(tf-ti, '.3f'))
</code></pre>
<p>C++ code:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;


int main(int argc, char *argv[])
{
    // receive python string in c++
    char* txt_fname = argv[1];

/*  // read matrix from file in c++
    FILE *f_matrix = fopen(txt_fname, "r");
    // ... [done by the question's author!]
    if (f_matrix!=NULL){
        fclose(f_matrix);
    }*/

    // create the vector in c++
    int n=200000;
    std::vector&lt;int&gt; vect(n);
    // or:  int vect[];
    // ... [done by the question's author!]

    // return the vector to python
    std::cout &lt;&lt; "[";
    for (int i=0; i&lt;n; i++)
        std::cout &lt;&lt; vect[i] &lt;&lt; ", ";
    std::cout &lt;&lt; "]";

    return 0;
}
</code></pre>
<p><strong>EDIT:</strong> to add the timers and to replace "ast.literal_eval()" with "eval()", because in fact eval() in this case is faster and it is compatible with python 3.3.</p>
</div>
<span class="comment-copy">It is likely that most of the time will be spent in C++ parsing the input file so it doesn't matter from the time performance point of you  view how you would communicate with Python. Invoking C++ function from Python in the same process (e.g., <a href="http://stackoverflow.com/q/7543675/4279">using <code>ctypes</code></a> or even easier using Cython) is a cleaner solution but it might be simpler for you just to pipe data between two processes.</span>
<span class="comment-copy">And a pleasant side-effect, GIL is released while your C++ function executes, which means you could split your workload into chunks and use your multicore processor to the max. In this case, I recommend working with threads in Python land. Threading in C++ only if you know what you are doing.</span>
<span class="comment-copy">Excellent answer all around!</span>
<span class="comment-copy">+1 for ctypes. If I understand the question correctly then the function should be <code>int* filter_file(const char* filename, int* result_array, size_t* result_size)</code> i.e., the size of the result is unknown before the function call. The function returns possibly <code>realloc</code>ed <code>result_array</code> or a new <code>malloc</code>'ed array if None is passed (the caller must free it). <code>result_size</code> can be passed using <code>ctypes.byref()</code>. To convert the returned pointer to a numpy array: <a href="http://stackoverflow.com/a/7555971/4279"><code>a = np.frombuffer(cast(result_array, POINTER(c_int*result_size.value)).contents)</code></a>.</span>
<span class="comment-copy">btw, don't use <code>posix</code> directly, use <code>os</code> module instead (either way <code>uname()</code> is documented as Unix-only). You could use <code>sys.platform.startswith("linux")</code> instead. You should probably leave <code>mode</code> at the default value.</span>
<span class="comment-copy">there's no need or benefit from explicit cast here, for example <code>int printf(const char*)</code> can be called implicitly as <code>libc.printf("blah")</code> (return defaults to int and arguments to natural C type for Python "blah", a C string).I advise you to call it explicitly like this: <code>libc.printf.restype = int; libc.printf.argtypes = [ctypes.c_char_p]; libc.printf("blah")</code> then if you supply a wrong argument by accident, e.g. <code>None</code> or <code>123</code> ctypes will raise an exception and not die with segmentation fault.</span>
<span class="comment-copy">Extending Python with C++ is a reference to Python 2.x. Even the Python 3 version is not what I'm looking for: it has the tutorial for C code.</span>
<span class="comment-copy">It will work in C++, you just have to define a few things. Read the part about making it work with C++. But yes, the examples will be in straight C code, this is just the nature of Python. Doesn't mean it will not work with C++.</span>
<span class="comment-copy">Would you advice for or against the other answer below about subprocesses?</span>
<span class="comment-copy">This depends. How many times do you plan on executing the external c++ file? It seems you're doing this for efficiency reasons? If so, Python is fast. Maybe not as fast as c++ but you'll end up losing any performance benefits in these intermediate steps.</span>
<span class="comment-copy">Efficiency is indeed key. I updated the answer, and I'm now putting out a bounty for an answer that can give even more direction (I tried understanding but I can't really follow what's going on in the link).</span>
<span class="comment-copy">you could use <code>ast.literal_eval</code> (or even <code>json</code> module) instead of <code>eval</code> here. It might be more effective to write the C array as binary and read from Python using <code>array</code> module.</span>
<span class="comment-copy">Really interesting. How about its speed?</span>
<span class="comment-copy">It's "fast", you can run that code straight forwardly. This Python script that calls the C++ program and waits for it runs in approximately 0.470 seconds, in my laptop. Is that time good for you? I'm going to add the timers in the script...</span>
