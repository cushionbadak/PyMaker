<div class="post-text" itemprop="text">
<p>I am fairly new programmer. So I am looking at data that is coming from files and I have to order data in a manner that takes up least processing time and memory. One of the methods that I was thinking of was to implement a balanced binary to store data in a ordered manner so that I can retrieve the same in a very efficient manner. For sake of testing, I am generating my log files in this manner.</p>
<pre><code>import time
import random

JITTER = 275 
TICKS = 1000
LINES_PER_TICK = 1000

def log_line(now):
    timestamp = now - (random.random() * JITTER)
    return "%f   City %d" % (timestamp, random.randint(0,10000))

start = time.time()

for tick in xrange(TICKS):
    now = start + tick
    for num_line in xrange(LINES_PER_TICK):
    print(log_line(now))
</code></pre>
<p>Is balanced binary tree the best method to implement such a program. Are there better ways of doing the same? Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'm assuming the main things you want to do are:</p>
<ol>
<li>Add a new log line to the end.</li>
<li>Add a new log line very near to the end (if your program is multithreaded or otherwise asynchronous).</li>
<li>Search for the line nearest a given timestamp.</li>
<li>Search for all lines within a given time range.</li>
</ol>
<p>A binary search tree is O(log N) for all of these. So is a skip list or a B-tree, or a number of other data structures.</p>
<p>So, how do you choose between them?</p>
<p>Well, unless you really need to build this yourself, you probably care more about the interface than the exact performance characteristics, as long as they're all "fast enough", which they probably are. For example, <a href="http://stutzbachenterprises.com/blist/sorteddict.html" rel="nofollow"><code>blist.sorteddict</code></a> is a carefully-designed class that's as close to a drop-in replacement for <code>dict</code> as anything sorted could be. <a href="https://pypi.python.org/pypi/bintrees/" rel="nofollow"><code>bintrees.RBTree</code></a> has some cool features like key slicing that you might not even think to look for, but might use all the time once you find them. <a href="http://docs.python.org/3/library/sqlite3.html" rel="nofollow"><code>sqlite3</code></a> can be trivially backed to disk, and can be searched by nice tools you already have on your system. Likely one of these will be more important to you than the differences between a B+Tree, a red-black tree, and an array with a B-tree index.</p>
<p>If squeezing out the last bit of performance <em>does</em> matter, you probably want to test with realistic data sets on characteristic systems, rather than try to guess. There are some good rules of thumb: B-trees are good if you may have enough data to swap to memory; skiplists are good for fine-grained locking; skiplists are good for reading large ranges; binary trees are good for quickly approximating by position instead of key; etc. But you'll still want to test your guess anyway, so don't put too much effort into guessing.</p>
</div>
<span class="comment-copy">least time and memory does not make sense. using more memry might speed it up...</span>
<span class="comment-copy">So you want to be able to find the nearest log line to some particular timestamp, or all log lines within a range of time?</span>
<span class="comment-copy">@martineau: A heap doesn't let you search by value, which is what it sounds like he wants (although I may be wrong; "retrieve the same" is a  little ambiguousâ€¦).</span>
