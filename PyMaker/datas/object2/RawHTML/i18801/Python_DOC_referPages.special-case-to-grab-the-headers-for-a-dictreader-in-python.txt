<div class="post-text" itemprop="text">
<p>Normally the <a href="http://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow"><code>csv.DictReader</code></a> will use the first line of a .csv file as the column headers, i.e. the keys to the dictionary:</p>
<pre><code>If the fieldnames parameter is omitted, the values in the first row of the csvfile will be used as the fieldnames.
</code></pre>
<p>However, I am faced with something like this for my first line:</p>
<p><code>#Format: header1  header2 header3</code> ...etc.</p>
<p>The <code>#Format:</code> needs to be skipped, as it is not a column header. I could do something like:</p>
<pre><code>column_headers = ['header1', 'header2', 'header3']
reader = csv.dictReader(my_file, delimiter='\t', fieldnames=column_headers)
</code></pre>
<p>But I would rather have the DictReader handle this for two reason. </p>
<ol>
<li><p>There are a lot of columns</p></li>
<li><p>The column names may change over time, and this is a quarterly-run process.</p></li>
</ol>
<p>Is there some way to have the DictReader still use the first line as the column headers, but skip that first <code>#Format:</code> word? Or really any word that starts with a <code>#</code> would probably suffice.</p>
</div>
<div class="post-text" itemprop="text">
<p>As <code>DictReader</code> wraps an open file, you could read the first line of the file, parse the headers from there (<code>headers = my_file.readline().split(delimiter)[1:]</code>, or something like that), and then pass them to <code>DictReader()</code> as the <code>fieldnames</code> argument. The <code>DictReader</code> constructor does not reset the file, so you don't have to worry about it reading in the header list after you've parsed that.</p>
</div>
<span class="comment-copy">Nice I like this. I was thinking I could stick a <code>lambda()</code> in there somewhere, but this is more straight-forward and probably a bit cleaner also, ty.</span>
<span class="comment-copy">@Houdini You're welcome.</span>
