<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/17322668/typeerror-dict-keys-object-does-not-support-indexing">TypeError: 'dict_keys' object does not support indexing</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
</ul>
</div>
<p>This is my code:</p>
<pre><code>{names[i]:d.values()[i] for i in range(len(names))}
</code></pre>
<p>This works completely fine when using python 2.7.3; however, when I use python 3.2.3, I get an error stating <code>'dict_values' object does not support indexing</code>.  How can I modify the code to make it compatible for 3.2.3?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, <code>dict.values()</code> (along with <code>dict.keys()</code> and <code>dict.items()</code>) returns a <code>view</code>, rather than a list. See the documentation <a href="http://docs.python.org/3/library/stdtypes.html#dictionary-view-objects">here</a>. You therefore need to wrap your call to <code>dict.values()</code> in a call to <code>list</code> like so:</p>
<pre><code>v = list(d.values())
{names[i]:v[i] for i in range(len(names))}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A simpler version of your code would be:</p>
<pre><code>dict(zip(names, d.values()))
</code></pre>
<p>If you want to keep the same structure, you can change it to:</p>
<pre><code>vlst = list(d.values())
{names[i]: vlst[i] for i in range(len(names))}
</code></pre>
<p>(You can just as easily put <code>list(d.values())</code> inside the comprehension instead of <code>vlst</code>; it's just wasteful to do so since it would be re-generating the list every time).</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3 the <code>dict.values()</code> method returns a <a href="http://docs.python.org/3/library/stdtypes.html?highlight=dictview#dictionary-view-objects" rel="nofollow noreferrer">dictionary view object</a>, not a list like it does in Python 2. Dictionary views have a length, can be iterated, and support membership testing, but don't support indexing.</p>
<p>To make your code work in both versions, you could use either of these:</p>
<pre><code>{names[i]:value for i,value in enumerate(d.values())}
</code></pre>
<p>    <strong><em>or</em></strong></p>
<pre><code>values = list(d.values())
{name:values[i] for i,name in enumerate(names)}
</code></pre>
<p>By far the simplest, fastest way to do the same thing in either version would be:</p>
<pre><code>dict(zip(names, d.values()))
</code></pre>
<p>Note however, that all of these methods will give you results that will vary depending on the actual contents of <code>d</code>. To overcome that, you may be able use an <a href="http://docs.python.org/3/library/collections.html?highlight=ordereddict#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> instead, which remembers the order that keys were first inserted into it, so you can count on the order of what is returned by the <code>values()</code> method.</p>
</div>
<span class="comment-copy"><code>values</code> now returns a view object <a href="http://docs.python.org/3.2/library/stdtypes.html#dictionary-view-objects" rel="nofollow noreferrer">docs.python.org/3.2/library/…</a></span>
<span class="comment-copy">Why are you relying on the order of the <code>values</code> returned from a dictionary anyway?</span>
<span class="comment-copy">Yeah, this code is unreliable unless d is an <code>OrderedDict</code> - and even if it is is seems like there must be a better way.</span>
<span class="comment-copy">A case I use it in is when I know there is only one key value in the dict from say a database row retrieval for one column only in dict format per row.  I think it is extremely poor that values() cannot auto_convert when indexed.</span>
<span class="comment-copy">The OP's code is unpythonic for everyone looking at this - in Python we avoid indexes (slower, uglier). The correct way is as per @DavidRobinson's <a href="https://stackoverflow.com/a/17431678/281545">answer</a>: <code>dict(zip(names, d.values()))</code>. Of course this code also relies on values being sorted as names which is by no means guaranteed.</span>
<span class="comment-copy">If you can, would you care to explain python's rationale behind this decision? From a naive perspective I don't see any reason why the view should not allow indexing in this particular case. I assume there is a grander scheme behind the view concept that does not play with indexing, but some clarity would be appreciated.</span>
<span class="comment-copy">Unfortuately, when I use the vlst example, I get an error "'dict' object has no attribute 'values'</span>
<span class="comment-copy">@JessePet: I don't see how that's possible, especially since in your own code <code>d.values()</code> did work without an error (until you tried to index it). Is it possible you misspelled <code>values</code> or some simliar error?</span>
<span class="comment-copy">I did not misspell values, it's astounding me to say the least</span>
<span class="comment-copy">@JessePet: What happens if you open a new Python3 terminal and do <code>{1: 2}.values()</code>? Or <code>d = {1: 2}; print d.values()</code>?</span>
<span class="comment-copy">Can you paste the precise code you are using and the error you are getting?</span>
<span class="comment-copy">Update: Note that in Python 3.7, regular dictionaries maintain insertion order, so using <code>OrderedDict</code> would be necessary in it. (Actually they were that way in Python 3.6 as well, but it wasn't official yet).</span>
