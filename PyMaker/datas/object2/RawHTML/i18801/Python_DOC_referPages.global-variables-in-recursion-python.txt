<div class="post-text" itemprop="text">
<p>OK, i'm using Python 2.7.3 and here is my code:</p>
<pre><code>def lenRecur(s): 

    count = 0

    def isChar(c):
        c = c.lower()
        ans=''
        for s in c:
            if s in 'abcdefghijklmnopqrstuvwxyz':
                ans += s
        return ans

    def leng(s):
        global count
        if len(s)==0:
            return count
        else:
            count += 1
            return leng(s[1:])

    return leng(isChar(s))
</code></pre>
<p>I'm trying to modify the variable <code>count</code> inside the <code>leng</code> function. Here are the things that I've tried:</p>
<ol>
<li>If I put the variable count outside the <code>lenRecur</code> function it works fine the first time, but if I try again without restarting python shell, the count (obviously) doesn't restart, so it keeps adding.</li>
<li>If I change the <code>count += 1</code> line for <code>count = 1</code> it also works, but the output is (obviously) one. </li>
</ol>
<p>So, my goal here is to get the length of the string using recursion, but I don't know how to keep track of the number of letters. I've searched for information about global variables, but I am still stuck. I don't know if i haven't understood it yet, or if I have a problem in my code. </p>
<p>Thanks in advance!</p>
</div>
<div class="post-text" itemprop="text">
<p><code>count</code> in <code>lenRecur</code> is <em>not</em> a global. It is a scoped variable.</p>
<p>You'll need to use Python 3 before you can make that work in this way; you are looking for the <a href="http://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement"><code>nonlocal</code> statement</a> added to Python 3.</p>
<p>In Python 2, you can work around this limitation by using a mutable (such as a list) for <code>count</code> instead:</p>
<pre><code>def lenRecur(s): 

    count = [0]

    # ...

    def leng(s):
        if len(s)==0:
            return count[0]
        else:
            count[0] += 1
            return lenIter(s[1:])
</code></pre>
<p>Now you are no longer altering the <code>count</code> name itself; it remains unchanged, it keeps referring to the same list. All you are doing is altering the first element <em>contained</em> in the <code>count</code> list.</p>
<p>An alternative 'spelling' would be to make <code>count</code> a function attribute:</p>
<pre><code>def lenRecur(s): 

    # ...

    def leng(s):
        if len(s)==0:
            return leng.count
        else:
            leng.count += 1
            return lenIter(s[1:])

    leng.count = 0
</code></pre>
<p>Now <code>count</code> is no longer local to <code>lenRecur()</code>; it has become an attribute on the unchanging <code>lenRecur()</code> function instead.</p>
<p>For your specific problem, you are actually overthinking things. Just have the recursion do the summing:</p>
<pre><code>def lenRecur(s):
    def characters_only(s):
        return ''.join([c for c in s if c.isalpha()])

    def len_recursive(s):
        if not s:
            return 0
        return 1 + len_recursive(s[1:])

    return len_recursive(characters_only(s))
</code></pre>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; def lenRecur(s):
...     def characters_only(s):
...         return ''.join([c for c in s if c.isalpha()])
...     def len_recursive(s):
...         if not s:
...             return 0
...         return 1 + len_recursive(s[1:])
...     return len_recursive(characters_only(s))
... 
&gt;&gt;&gt; lenRecur('The Quick Brown Fox')
16
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think You can pass count as second argument</p>
<pre><code>def anything(s):
    def leng(s, count):
        if not s:
            return count
        return leng(s[1:], count + 1)

    return leng(isChar(s), 0)
</code></pre>
<p>this should work better than muting objects from outer scope such as using mutable objects (<code>list</code> or <code>dict</code>) or monkey-patching function itself for example.</p>
</div>
<div class="post-text" itemprop="text">
<p>You need to make the variable count a function variable like</p>
<pre><code>def lenRecur(s):
    lenRecur.count = 0
</code></pre>
<p>However, I see a few problems with the code.</p>
<p>1) If you are trying to find the number of alphabets in a string through recursion, this one will do:</p>
<pre><code>def lenRecur(s):
    def leng(s, count = 0):
            if not s:
                    return count
            else:
                    count += int(s[0].isalpha())
                    return leng(s[1:], count)
    return leng(s)
</code></pre>
<p>But still I would prefer having a single function to do the task, like there will be no leng method at all.</p>
<p>2) If your goal is just to find the number of alphabets in a string, I would prefer list comprehension</p>
<pre><code>def alphalen(s):
    return sum([1 for ch in s if ch.isalpha()])
</code></pre>
<p>If this is anything other than learning purpose, I suggest you to avoid recursion. Because, the solution cannot be used for larger strings(lets say, finding the alphabet count from contents of a file). You might hit the RunTimeError of Maximum Recursion Depth Exceeded.</p>
<p>Even though you can work around this through setting the recursion depth through setrecursionlimit function, I suggest you to go for other easy ways. More info on setting the recursionlimit <a href="http://docs.python.org/2/library/sys.html#sys.setrecursionlimit" rel="nofollow">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Define it outside all function definitions, if you want to use it as a global variable:</p>
<pre><code>count = 0
def lenRecur(s): 
</code></pre>
<p>or  define it as a function attribute:</p>
<pre><code>def lenRecur(s): 
    lenRecur.count = 0
    def isChar(c):
</code></pre>
<p>This has been fixed in py3.x where you can use the <code>nonlocal</code> statement:</p>
<pre><code>def leng(s):
    nonlocal count
    if len(s)==0:
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need count. The below function should work.</p>
<pre>
<code>
    def leng(s):
        if not s:
            return 0
        return 1 + leng(s[1:])
</code>
</pre>
</div>
<span class="comment-copy">can't see recursion itself.</span>
<span class="comment-copy">Sorry, now is ok!</span>
<span class="comment-copy">Is there any way to do this in Python 2.7?</span>
<span class="comment-copy">or You can pass count as a parameter to <code>leng</code> function</span>
<span class="comment-copy">Ok that worked for me! May I ask why did a list work and not a normal variable?</span>
<span class="comment-copy">I <i>think</i> I have been one step ahead of your questions so far; I edited in an explanation as to why <code>count = [0]</code> works; did you see that already?</span>
<span class="comment-copy">Yes yes!! Thank  you very much! That's what I call a good answer :)</span>
<span class="comment-copy">Ouch! Didn't think about that. Thanks!</span>
<span class="comment-copy">I posted the same answer. Didn't see your post there. I guess I am late as usual :-)</span>
<span class="comment-copy">You'd better vote  for my solution instead of comment it ;)</span>
<span class="comment-copy">If I difine it outside the function lenRecur is the first statement I said that I tried. Thanks anyway!</span>
<span class="comment-copy">@CarlesMitjans I guess I missed that detail, You can define it as a function attribute.</span>
<span class="comment-copy">Don't worry :) thanks for the answer!</span>
<span class="comment-copy">Also worked! Thanks!!</span>
