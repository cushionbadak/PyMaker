<div class="post-text" itemprop="text">
<p>I had an overflow error with this program <a href="https://stackoverflow.com/questions/17384151/long-integer-overflow-error-and-resolution">here</a>!, I realized the mistake of that program. I cannot use range or xrange when it came to really long integers. I tried running the program in Python 3 and it works. My code works but then responds after several times. Hence in order to optimize my code, I started thinking of strategies for the optimizing the code. </p>
<p>My problem statement is  A number is called lucky if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many numbers between A and B are lucky?.</p>
<p>I started with this:</p>
<pre><code>squarelist=[0,1,4,9,16,25,36,49,64,81]

def isEven(self, n):
   return
def isPrime(n):
   return

def main():
    t=long(raw_input().rstrip())
    count = []
    for i in xrange(t):
            counts = 0
            a,b = raw_input().rstrip().split()
            if a=='1':
                    a='2'
    tempa, tempb= map(int, a), map(int,b)
    for i in range(len(b),a,-1):
       tempsum[i]+=squarelist[tempb[i]]
</code></pre>
<p>What I am trying to achieve is since I know the series is ordered, only the last number changes. I can save the sum of squares of the earlier numbers in the list and just keep changing the last number. This does not calculate the sum everytime and check if the sum of squares is prime. I am unable to fix the sum to some value and then keep changing the last number.How to go forward from here?</p>
<p>My sample inputs are provided below.</p>
<pre><code>87517 52088
72232 13553
19219 17901
39863 30628
94978 75750
79208 13282
77561 61794
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I didn't get what you want to achieve with your code at all. This is my solution to the question as I understand it: For all natural numbers <strong>n</strong> in a range <strong>X</strong> so that <strong>a &lt; X &lt; b</strong> for some natural numbers <strong>a</strong>, <strong>b</strong> with <strong>a &lt; b</strong>, how many numbers <strong>n</strong> have the property that the sum of its digits and the sum of the square of its digits in decimal writing are both prime?</p>
<pre><code>def sum_digits(n):
    s = 0
    while n:
        s += n % 10
        n /= 10
    return s

def sum_digits_squared(n):
    s = 0
    while n:
        s += (n % 10) ** 2
        n /= 10
    return s

def is_prime(n):
    return all(n % i for i in xrange(2, n))

def is_lucky(n):
    return is_prime(sum_digits(n)) and is_prime(sum_digits_squared(n))

def all_lucky_numbers(a, b):
    return [n for n in xrange(a, b) if is_lucky(n)]

if __name__ == "__main__":
    sample_inputs = ((87517, 52088),
                     (72232, 13553),
                     (19219, 17901),
                     (39863, 30628),
                     (94978, 75750),
                     (79208, 13282),
                     (77561, 61794))

    for b, a in sample_inputs:
        lucky_number_count = len(all_lucky_numbers(a, b))
        print("There are {} lucky numbers between {} and {}").format(lucky_number_count, a, b)
</code></pre>
<p>A few notes:</p>
<ul>
<li>The <code>is_prime</code> is the most naive implementation possible. It's still totally fast enough for the sample input. There are many better implementations possible (and just one google away). The most obvious improvement would be skipping every even number except for 2. That alone would cut calculation time in half.</li>
<li>In Python 3 (and I really recommend using it), remember to use <code>//=</code> to force the result of the division to be an integer, and use <code>range</code> instead of <code>xrange</code>. Also, an easy way to speed up <code>is_prime</code> is Python 3's <a href="http://docs.python.org/3/library/functools.html#functools.lru_cache" rel="nofollow">@functools.lru_cache</a>.</li>
<li><p>If you want to save some lines, calculate the sum of digits by casting them to <code>str</code> and back to <code>int</code> like that:</p>
<pre><code>def sum_digits(n):
    return sum(int(d) for d in str(a))
</code></pre>
<p>It's not as <em>mathy</em>, though.</p></li>
</ul>
</div>
<span class="comment-copy">What is the question?</span>
<span class="comment-copy">finding the sum of squares is not going to be computationally intensive. Checkin if it is prime is going to be. You could try memoization there instead.</span>
<span class="comment-copy">@AccessDenied, I tried optimization with memoization. Recursion fails due to the fact that recursion limit is set to 999. Memoization works but even with memoization, I am going to be using a lot of memory. Also, Just for one single computation, for the first input value in 87517 52088,my machine ran for 17 s. Now, for the code that I am writing, I have 100-1000 such value. So you can imagine.! Even accessing stored tems takes quite a bit of time from my experience.</span>
<span class="comment-copy">Why would it take more time ? can u share wht exactly u memoized and how you did it ? Have u tried a map DS to store the prime nos found ? Also the idea of storing till last but 1 term wont work cause for every 10 numbers one more number is also going to change.</span>
