<div class="post-text" itemprop="text">
<p>I was using this code with some actual coding that requires all of the variables in the enclosing loops. I was thinking that if the range over which iteration has to take place is same there has to be a another way with less indentation and same access to all the variables.</p>
<p>Is there an alternative to such nested loops which has</p>
<ul>
<li>less indentation</li>
<li>access to the variable in the same order in the enclosed scope</li>
</ul>
<p>The code:</p>
<pre><code>import itertools
import time

#My Way
s = time.time()
sums_pyramid = [0] * 36
for i in xrange(1,5):
    for j in xrange(1,5):
        for k in xrange(1,5):
            for l in xrange(1,5):
                for m in xrange(1,5):
                    for n in xrange(1,5):
                        for o in xrange(1,5):
                            for p in xrange(1,5):
                                for q in xrange(1,5):
                                    sums_pyramid[i+j+k+l+m+n+o+p+q - 1] += 1
print (time.time() - s)


#Lattyware's suggested way
s = time.time()
sums_pyramid = [0] * 36
for i,j,k,l,m,n,o,p,q in itertools.product(xrange(1,5), repeat = 9):
    sums_pyramid[i+j+k+l+m+n+o+p+q - 1] += 1
print (time.time() - s)
</code></pre>
<p>The timing results</p>
<pre><code>#My way
0.259999990463
#Lattyware's suggested way
0.310000181198
</code></pre>
<p>EDIT2:</p>
<p>After Lattyware suggested that instead of using <code>time</code> module I should use <code>timeit</code> module I got these results</p>
<p>The new code:</p>
<pre><code>import itertools

def p():
    #My Way
    sums_pyramid = [0] * 36
    for i in xrange(1,5):
        for j in xrange(1,5):
            for k in xrange(1,5):
                for l in xrange(1,5):
                    for m in xrange(1,5):
                        for n in xrange(1,5):
                            for o in xrange(1,5):
                                for p in xrange(1,5):
                                    for q in xrange(1,5):
                                        sums_pyramid[i+j+k+l+m+n+o+p+q - 1] += 1


def q():
    #Lattyware's suggested way
    sums_pyramid = [0] * 36
    for i,j,k,l,m,n,o,p,q in itertools.product(xrange(1,5), repeat = 9):
        sums_pyramid[i+j+k+l+m+n+o+p+q - 1] += 1

if __name__ == '__main__':
    times = 10
    from timeit import Timer
    print Timer(p, 'gc.enable()').timeit(number = times)

    print Timer(q, 'gc.enable()').timeit(number = times)
</code></pre>
<p>New timings:</p>
<pre><code>1.60324387493
1.28266455309
</code></pre>
<p>These show that Lattyware's code is better.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that (as in your example) the loops are all independent of the parent loops, You want <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product()</code></a>.</p>
<pre><code>import itertools

for i, j, k, l, m, n, o, p, q in itertools.product(xrange(1, 5), repeat=9):
    ...
</code></pre>
<p>Here I use the <code>repeat</code> keyword argument as shorthand, as in your example, the iterables were all the same, but you can also pass it multiple iterables if your iterables are not all the same.</p>
<p>It will also be more efficient than many nested loops. Do note that there is likely a better solution to your problem - as iterating with so many nested loops is likely to be a <em>huge</em> amount of iteration, and therefore very slow.</p>
<p>Alternatively, if your loops rely on their parent loops or the like (and as such <code>product()</code> isn't suitable), you can define functions to take some of the heavy nesting and abstract it out.</p>
<pre><code>for i in xrange(1,5):
    for j in xrange(1,5):
        for k in xrange(1,5):
            for l in xrange(1,5):
                for m in xrange(1,5):
                    inner_loops(i, j, k, l, m)

def inner_loops(i, j, k, l, m):
    for n in xrange(1,5):
        for o in xrange(1,5):
            for p in xrange(1,5):
                for q in xrange(1,5):
                    pass
</code></pre>
<p>This will perform worse than <code>product()</code>, and is less readable, but may be necessary, depending on the situation. Naturally you can use as many functions as needed where needed to reduce the nesting as much as needed.</p>
<p>As a final note, I assume that you are using ranges as a simple example, but if you are planning to loop over data structures using indices, don't! It's hard to read, inflexible and slow. Loop directly over the data structure itself - these methods will work fine (in fact, better) that way.</p>
</div>
<span class="comment-copy">The issue was the code directly following the list - indentation after a list element is used for something else in markdown, apparently. Edited to fix.</span>
<span class="comment-copy">Thanks for the answer. It definitely helped me in improving the readability of the code and much less typing. About efficiency, your suggestion is slightly less efficient. I'll update the question to include the timing results.</span>
<span class="comment-copy">If by efficiency, you mean speed, that shouldn't be the case - <code>product()</code> iterates at a lower level, in C code (assuming you are using CPython), while normal loops have more overhead as they are a Python structure. <code>product()</code> should be faster in any case where the timing is non-trivial.</span>
<span class="comment-copy">I updated the question to include timings.</span>
<span class="comment-copy">@Zel The issue is probably with your timing code - use <a href="http://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">the <code>timeit</code> module</a> instead.</span>
<span class="comment-copy">Ok the results with <code>timeit module</code> favored your results and I see that this module is specifically for measuring execution time. What about <code>time</code> module?</span>
