<div class="post-text" itemprop="text">
<p>I have a csv file with mixed floats, a string and an integer, the formatted output from a FORTRAN file.
A typical line looks like:</p>
<pre><code> 507.930    ,  24.4097    ,   1.0253E-04, O  III   ,    4
</code></pre>
<p>I want to read it while keeping the float decimal places unmodified, and check to see if the first entry in each line is present is another list.</p>
<p>Using loadtxt and genfromtxt results in the demical places changing from 3 (or 4) to 12.</p>
<p>How should I tackle this?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you need to keep precision exactly, you need to use the <a href="http://docs.python.org/2/library/decimal.html" rel="nofollow"><code>decimal</code> module</a>. Otherwise, <a href="http://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow">issues with floating point arithmetic limitations</a> might trip you up.</p>
<p>Chances are, though, that you don't really need that precision - just make sure you don't compare <code>float</code>s for equality exactly but always allow a fudge factor, and format the output to a limited number of significant digits:</p>
<pre><code># instead of if float1==float2:, use this:
if abs(float1-float2) &lt;= sys.float_info.epsilon: 
    print "equal"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>loadtxt</code> appears to take a <code>converters</code> argument so something like:</p>
<pre><code>from decimal import Decimal
numpy.loadtxt(..., converters={0: Decimal,
                               1: Decimal,
                               2: Decimal})
</code></pre>
<p>Should work.</p>
<p><code>Decimal</code>'s should work with whatever precision you require although if you're doing significant number crunching with <code>Decimal</code> it will be considerably slower than working with <code>float</code>.  However, I assume you're just looking to transform the data without losing any precision so this should be fine.</p>
</div>
<div class="post-text" itemprop="text">
<p>I finished up writing some string processing code. Not elegant but it works:</p>
<pre><code>stuff=loadtxt(fname1,skiprows=35,dtype="f10,f10,e10,S10,i1",delimiter=','‌​) 
stuff2 = loadtxt('keylines.txt') # a list of the reference values
... # open file for writing etc
for i in range(0,len(stuff)): 
    bb=round(float(stuff[i][0]),3) # gets number back to correct decimal format
    cc=round(float(stuff[i][1]),5) # ditto
    dd=float(stuff[i][2]) 
    ee=stuff[i][3].replace(" ","")  # gets rid of extra FORTRAN spaes
    ff=int(stuff[i][4]) 
    for item in stuff2: 
        if bb == item: 
        fn.write( str(bb)+','+str("%1.5f" % cc)+','+str("%1.4e" % dd)+','+ee+','+str(ff)+'\n')
</code></pre>
</div>
<span class="comment-copy">Actually, after a closer look at the <code>numpy.loadtxt</code> this likely won't work as apparently the <code>converters</code> functions need to return a float.  Of course you could write a function yourself that attempts to preserve the precision from the input but I think the conversion to float requirement is going to make this hard to work around.</span>
