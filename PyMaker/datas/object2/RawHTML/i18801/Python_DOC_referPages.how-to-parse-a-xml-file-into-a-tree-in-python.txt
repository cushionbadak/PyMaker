<div class="post-text" itemprop="text">
<pre><code>***I must use Elementtree for this project, so if you could, please suggest something that utilizes Elementtree
</code></pre>
<p>I have a file that kinda looks like this (each separated by a blank line)</p>
<pre><code>&lt;a&gt;
    &lt;b&gt;
       ....
    &lt;/b&gt;
    &lt;c&gt;
       ....
    &lt;/c&gt;
&lt;/a&gt;
&lt;d&gt;&lt;c&gt;&lt;/c&gt;&lt;/d&gt;

&lt;a&gt;
    &lt;b&gt;
       ....
    &lt;/b&gt;
    &lt;c&gt;
       ....
    &lt;/c&gt;
&lt;/a&gt;
&lt;d&gt;&lt;c&gt;&lt;/c&gt;&lt;/d&gt;

&lt;a&gt;
    &lt;b&gt;
       ....
    &lt;/b&gt;
    &lt;c&gt;
       ....
    &lt;/c&gt;
&lt;/a&gt;
&lt;d&gt;&lt;c&gt;&lt;/c&gt;&lt;/d&gt;
</code></pre>
<p>I know this is not a valid XML, so what I am trying to do is read the whole thing as a string and add a root element to that, which would end up looking like this for each XML:</p>
<pre><code>&lt;root&gt;
    &lt;a&gt;
        &lt;b&gt;
           ....
        &lt;/b&gt;
        &lt;c&gt;
           ....
        &lt;/c&gt;
    &lt;/a&gt;
    &lt;d&gt;&lt;c&gt;&lt;/c&gt;&lt;/d&gt;
&lt;/root&gt;
</code></pre>
<p>I want to know if there is a simple way to read the XML code one by one and concatenate it with a parent node, and do the same for the next XML code, and so on.</p>
<p>Any help would be appreciated, thank you.</p>
</div>
<div class="post-text" itemprop="text">
<p>It sounds like what you really want to do is parse a sequence of XML trees—maybe more than one in the same file, or maybe there are multiple files, or who knows.</p>
<p><code>ElementTree</code> can't quite do that out of the box… but you can build something out of it that can.</p>
<hr/>
<p>First, there's the easy way: Just put your own parser in front of etree. If your XML documents are really separated by blank lines, and there are no embedded lines in any document, this is trivial:</p>
<pre><code>lines = []
for line in inputFile:
    if not line.strip():
        print(lines)
        xml = ET.fromstringlist(lines)
        print(xml)
        lines = []
    else:
        lines.append(line)
print(lines)
xml = ET.fromstringlist(lines)
print(xml)
</code></pre>
<p>If the "outer structure" is more complicated than this—e.g., if each document begins immediately after the other ends, or if you need stateful information to distinguish within-tree blank lines from between-tree ones—then this solution won't work (or, at least, it will be harder rather than easier).</p>
<p>In that case, things get more fun.</p>
<hr/>
<p>Take a look at <a href="http://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.iterparse" rel="nofollow"><code>iterparse</code></a>. It lets you parse a document on the fly, yielding each element when it gets to the end of the element (and even trimming the tree as you go along, if the tree is too big to fit into memory).</p>
<p>The problem is that when <code>iterparse</code> gets to the end of the file, it will raise a <code>ParseError</code> and abort, instead of going on to the next document.</p>
<p>You can easily detect that by reading the first <code>start</code> element, then stopping as soon as you reach its <code>end</code>. It's a bit more complicated, but not too bad. Instead of this:</p>
<pre><code>for _, elem in ET.iterparse(arg):
    print(elem)
</code></pre>
<p>You have to do this:</p>
<pre><code>parser = ET.iterparse(arg, events=('start', 'end'))
_, start = next(parser)
while True:
    event, elem = next(parser)
    if event == 'end':
        print(elem)
        if elem == start:
            break
</code></pre>
<p>(You can make that a bit more concise with <code>filter</code> and <code>itertools</code>, but I thought the explicit version would be easier to understand for someone who's never used <code>iterparse</code>.)</p>
<p>So, you can just do that in a loop until EOF, right? Well, no. The problem is that <code>iterparse</code> doesn't leave the read pointer at the start of the next document, and there's no way to find out where the next document starts.</p>
<p>So, you will need to control the file, and feed the data to <code>iterparse</code>. There are two ways to do this:</p>
<hr/>
<p>First, you can create your own file wrapper object that provides all the file-like methods that ET needs, and pass that to <code>ET.iterparse</code>. That way, you can keep track of how far into the file <code>iterparse</code> reads, and then start the next parse at that offset.</p>
<p>It isn't exactly documented what file-like methods <code>iterparse</code> needs, but as <a href="http://hg.python.org/cpython/file/3.3/Lib/xml/etree/ElementTree.py#l1256" rel="nofollow">the source</a> shows, all you need is <code>read(size)</code> (and you're allowed to return fewer than <code>size</code> bytes, just as a real file could) and <code>close()</code>, so that's not hard at all.</p>
<hr/>
<p>Alternatively, you can drop down a level and use an <a href="http://docs.python.org/3/library/xml.etree.elementtree.html#xmlparser-objects" rel="nofollow"><code>ET.XMLParser</code></a> directly. That sounds scary, but it's not that bad—look how short <code>iterparse</code>'s source is, and how little of what it's doing you actually need.</p>
<p>Anyway, it comes down to something like this (pseudocode, not tested):</p>
<pre><code>class Target(object):
    def __init__(self):
        self.start_tag = None
        self.builder = ET.TreeBuilder()
        self.tree = None
    def start(self, tag, attrib):
        if self.start_tag is None:
            self.start_tag = tag
        return self.builder.start(tag, attrib)
    def end(self, tag):
        ret = self.builder.end(tag, attrib)
        if self.start_tag == tag:
            self.tree = self.builder.close()
            return self.tree
        return ret
    def data(self, data):
        return self.builder.data(data)
    def close(self):
        if self.tree is None:
            self.tree = self.builder.close()
        return self.tree

parser = None
for line in inputFile:
    if parser is None:
        target = Target()
        parser = ET.XMLParser(target=target)
    parser.feed(line)
    if target.tree:
        do_stuff_with(target.tree)
        parser = None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just create a string with the root/end root surrounding:</p>
<pre><code>with open('yourfile') as fin:
    xml_data = '&lt;{0}&gt;{1}&lt;/{0}&gt;'.format('rootnode', fin.read())
</code></pre>
<p>Then use <code>ET.fromstring(xml_data)</code></p>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is pretty simple.</p>
<p><a href="http://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.parse" rel="nofollow"><code>ET.parse</code></a> takes a filename (or file object). But you're passing it a list of lines. That's not a filename. The reason you get this error:</p>
<pre><code>TypeError: coercing to Unicode: need string or buffer, list found
</code></pre>
<p>… is that it's trying to use your list as if it were a string, which doesn't work.</p>
<p>When you've already read the file in, you can use <a href="http://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.fromstring" rel="nofollow"><code>ET.fromstring</code></a>. However, you have to read it into a <em>string</em>, not a list of strings. For example:</p>
<pre><code>def readXML (inputFile) : #inputFile is sys.stdin
    f= '&lt;XML&gt;' + inputFile.read() + '&lt;/XML&gt;'
    newXML = ET.fromstring(f)
    print newXML.getroot().tag
</code></pre>
<p>Or, if you're using Python 3.2 or later, you can use <a href="http://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.fromstringlist" rel="nofollow"><code>ET.fromstringlist</code></a>, which takes a sequence of strings—exactly what you have.</p>
<hr/>
<p>From your side issue:</p>
<blockquote>
<p>Another problem that I just realized while typing this is that my input file has multiple inputs. Say, at least more than 10 of the first XML that I wrote. If I do readlines(), isn't that going to read the whole XML ?</p>
</blockquote>
<p>Yes, it will. <a href="http://stupidpythonideas.blogspot.com/2013/06/readlines-considered-silly.html" rel="nofollow">There's never any good reason to use <code>readlines()</code></a>.</p>
<p>But I'm not sure why that's a problem here.</p>
<p>If you're trying to combine a forest of 10 trees into one big tree, you pretty much have the read the whole thing in, right?</p>
<p>Unless you change the way you do things. The easy way to do this is to put your own trivial parser—something that splits the file on blank lines—in front of ET. For example:</p>
<pre><code>while True:
    lines = iter(inputFile.readline, '')
    if not lines:
        break
    xml = ET.fromstringlist(lines)
    # do stuff with this tree
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have multiple xml fragments that are separated by a blank line. To make each fragment a well-formed xml document you need at least to wrap them in a root element. Building on <code>fromstringlist</code> code example from <a href="https://stackoverflow.com/a/17288001/4279">@abarnert's answer</a>:</p>
<pre><code>from xml.etree.cElementTree import XMLParser

def parse_multiple(lines):
    for line in lines:
        parser = XMLParser()
        parser.feed("&lt;root&gt;")      # start of xml document
        while line.strip():        # while non-blank line
            parser.feed(line)      # continue xml document
            line = next(lines, "") # get next line
        parser.feed("&lt;/root&gt;")     # end of xml document
        yield parser.close() # yield root Element of the xml tree
</code></pre>
<p>It yields xml trees (their <a href="http://docs.python.org/2/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element" rel="nofollow noreferrer">root elements</a>).</p>
<p><a href="http://ideone.com/2tST5M" rel="nofollow noreferrer">Example</a>:</p>
<pre><code>import sys
import xml.etree.cElementTree as etree

for root in parse_multiple(sys.stdin):
    etree.dump(root)
</code></pre>
</div>
<span class="comment-copy">It sounds like what you <i>really</i> want is to parse each of the trees, in order, <i>without</i> bundling them into one big tree. Yes?</span>
<span class="comment-copy">Exactly, and I can't think of way to do that.  I have a multiple of &lt;a&gt; .. &lt;/a&gt; &lt;d&gt;...&lt;/d&gt; in my input file separated by a blank line. I need to read each chunk one by one, and add a parent node to each. All the functions that python provides seems to read the whole file, which is not what I am trying to do. Maybe read a line one by one and store everything I read until I hit the blank line?</span>
<span class="comment-copy">Yes, that last sentence is exactly what I was saying is the "easy way" in my (second) answer. I tried to write it up in a way that's clear even to a novice (no two-argument <code>iter</code> or <code>itertools.groupby</code>), even if it's twice as long that way. Hopefully it's what you want.</span>
<span class="comment-copy">This is a lot more complicated than I expected it to be, but I guess I will just go ahead and follow your instructions. Thank you. You are amazing!</span>
<span class="comment-copy">@Nayana: Hold on, there may be a much simpler way, from the way you described your files. See my latest edit.</span>
<span class="comment-copy">Fantastic answer - hope the OP fully appreciates the effort here!</span>
<span class="comment-copy">I surely do appreciate your help, abarnert. I might need to spend more time to understand your code, but thank you so much. I will make sure to understand your code.</span>
<span class="comment-copy">My inputfile name is not constant, it might change. So I am passing in Sys.stdin, when I pass sys.stdin to parse function, it seems to complain (ET.parse(sys.stdin)). Do you have any ideas of how to deal with that?</span>
<span class="comment-copy">@Nayana If you're passing <code>sys.stdin</code> then you don't need an open, and using <code>sys.stdin.read()</code> should work just fine to return a string.</span>
<span class="comment-copy">I am sorry for being so demanding, I like the way you do it. But as I said in the question, I have a multiple number of the first chunk of XML code separated by a blank line. If I do it the way you did, isn't that going to read the entire code and add a root node to the whole thing, which ends up being an enormous XML code? Is there any easy way to deal with that? I have a couple ideas, but too complicated.</span>
<span class="comment-copy">@Nayana To clarify - you have multiple inputs, and expect to be able to treat each one as though they were all under a parent node?</span>
<span class="comment-copy">@ Jon Clements Exactly. I need to treat each one as though they were all under a different parent node. So, I will have a multiple of &lt;a&gt; .. &lt;/a&gt; &lt;d&gt;...&lt;/d&gt; in my input file. I will read one by one and add a parent node to each, and then do some operations on them.</span>
<span class="comment-copy">My inputfile name is not constant, it might change. So I am passing in Sys.stdin, when I pass sys.stdin to parse function, it seems to complain (ET.parse(sys.stdin)). Do you have any ideas of how to deal with that?</span>
<span class="comment-copy">First, why not just pass an input filename as, say, <code>sys.argv[1]</code>, instead of requiring the input to be in <code>sys.stdin</code>? Or use <code>fileinput</code> to allow <i>either</i>? Second, you're asking for help debugging code which isn't the code you've posted, with an error that you've only loosely described, and that's impossible to debug. Either edit your question, file a new question, or post everything somewhere like <a href="http://pastebin.com" rel="nofollow noreferrer">pastebin.com</a> and give us links.</span>
<span class="comment-copy">you are AMAZING!!!! This is what I was looking for! I am going to try this now. Thank you so much!!!!</span>
<span class="comment-copy">@Nayana: If you're looking at the code at the end here, see the slightly different code at the top of my other answer, which is (a) tested and (b) probably easier to understand.</span>
<span class="comment-copy">I don't think you need to add the <code>&lt;root&gt;</code> element here. The only reason the OP was doing that was to combine all of the trees together into one big tree. If he can parse the trees one by one (and he can), he doesn't need any spurious new elements.</span>
<span class="comment-copy"><code>&lt;a&gt;</code> and <code>&lt;d&gt;</code> go to the same blank-line-separated tree. There are 3 trees in the example input in the question. @Nayana should clarify whether it is indeed the desired outcome.</span>
<span class="comment-copy">Good point. I assumed that the explanation was right and the initial example was wrong, but the opposite is certainly possible, in which case he's actually got not a forest of blank-line-separated trees, but a forest of blank-line-separated subforests, in which case he needs both workarounds…</span>
