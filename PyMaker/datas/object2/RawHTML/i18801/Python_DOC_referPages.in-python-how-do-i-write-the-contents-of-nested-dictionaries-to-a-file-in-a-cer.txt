<div class="post-text" itemprop="text">
<p>I have a dictionary of dictionaries, and I'm trying to output the information within them in a certain way so that it will be usable for downstream analysis. Note: All the keys in "dict" are in also in "list".</p>
<pre><code>for item in list:
for key, value in dict[item].items():
     print item, key, value
</code></pre>
<p>This is the closest I've gotten to what I want, but it's still a long way off. Ideally what I want is:</p>
<pre><code>     item1  item2  item3  item4
key1 value  value  value  value
key2 value  value  value  value
key2 value  value  value  value
</code></pre>
<p>Is this even possible??</p>
</div>
<div class="post-text" itemprop="text">
<p>First, if I understand your structure, the list is just a way of ordering the keys for the outer dictionary, and a lot of your complexity is trying to use these two together to simulate an ordered dictionary. If so, there's a much easier way to do that: use <a href="http://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict</code></a>. I'll come back to that at the end.</p>
<hr/>
<p>First, you need to get all of the keys of your sub-dictionaries, because those are the rows of your output.</p>
<p>From comments, it sounds like all of the sub-dictionaries in <code>dct</code> have the same keys, so you can just pull the keys out of any arbitrary one of them:</p>
<pre><code>keys = dct.values()[0].keys()
</code></pre>
<p>If each sub-dictionary can have a different subset of keys, you'll need to instead do a first pass over <code>dct</code> to get all the keys:</p>
<pre><code>keys = reduce(set.union, map(set, dct.values()))
</code></pre>
<p>Some people find <code>reduce</code> hard to understand, even when you're really just using it as "<code>sum</code> with a different operator". For them, here's how to do the same thing explicitly:</p>
<pre><code>keys = set()
for subdct in dct.values():
    keys |= set(subdct)
</code></pre>
<hr/>
<p>Now, for each key's row, we need to get a column for each sub-dictionary (that is, each value in the outer dictionary), in the order specified by using the elements of the list as keys into the outer dictionary.</p>
<p>So, for each column <code>item</code>, we want to get the outer-dictionary value corresponding to the key in <code>item</code>, and then in the resulting sub-dictionary, get the value corresponding to the row's <code>key</code>. That's hard to say in English, but in Python, it's just:</p>
<pre><code>dct[item][key]
</code></pre>
<p>If you don't actually have all the same keys in all of the sub-dictionaries, it's only slightly more complicated:</p>
<pre><code>dct[item].get(key, '')
</code></pre>
<p>So, if you didn't want any headers, it would look like this:</p>
<pre><code>with open('output.csv', 'wb') as f:
    w = csv.writer(f, delimiter='\t')
    for key in keys:
        w.writerow(dct[item].get(key, '') for item in lst)
</code></pre>
<hr/>
<p>To add a header column, just prepend the header (in this case, <code>key</code>) to each of those rows:</p>
<pre><code>with open('output.csv', 'wb') as f:
    w = csv.writer(f, delimiter='\t')
    for key in keys:
        w.writerow([key], [dct[item].get(key, '') for item in lst])
</code></pre>
<p>Notice that I turned the genexp into a list comprehension so I could use list concatenation to prepend the <code>key</code>. It's conceptually cleaner to leave it as an iterator, and prepend with <a href="http://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>itertools.chain</code></a>, but in trivial cases like this with tiny iterables, I think that's just making the code harder to read:</p>
<pre><code>with open('output.csv', 'wb') as f:
    w = csv.writer(f, delimiter='\t')
    for key in keys:
        w.writerow(chain([key], (dct[item].get(key, '') for item in lst)))
</code></pre>
<hr/>
<p>You also want a header row. That's even easier; it's just the items in the list, with a blank column prepended for the header column:</p>
<pre><code>with open('output.csv', 'wb') as f:
    w = csv.writer(f, delimiter='\t')
    w.writerow([''] + lst)
    for key in keys:
        w.writerow([key] + [dct[item].get(key, '') for item in lst])
</code></pre>
<hr/>
<p>However, there are two ways to make things even simpler.</p>
<p>First, you can use an <code>OrderedDict</code>, so you don't need the separate key list. If you're stuck with the separate <code>list</code> and <code>dict</code>, you can still build an <code>OrderedDict</code> on the fly to make your code easier to read. For example:</p>
<pre><code>od = collections.OrderedDict((item, dct[item]) for item in lst)
</code></pre>
<p>And now:</p>
<pre><code>with open('output.csv', 'wb') as f:
    w = csv.writer(f, delimiter='\t')
    w.writerow([''] + od.keys())
    for key in keys:
        w.writerow([key] + [subdct.get(key, '') for subdct in od.values()])
</code></pre>
<hr/>
<p>Second, you could just build the transposed structure:</p>
<pre><code>transposed = {key_b: {key_a: dct[key_a].get(key_b, '') for key_a in dct} 
              for key_b in keys}
</code></pre>
<p>And then iterate over it in the obvious order (or use a <a href="http://docs.python.org/3/library/csv.html#csv.DictWriter" rel="nofollow"><code>DictWriter</code></a> to handle the ordering of the columns for you, and use its <code>writerows</code> method to deal with the rows, so the whole thing becomes a one-liner).</p>
</div>
<div class="post-text" itemprop="text">
<p>To store objects in Python so that you can re-use them later, you can you use the <code>shelve</code> module. This a module that lets you write objects to a shelf file and re-open it and retrieve the objects later, but it's operating system-dependent, so it won't work if say you made it on a Mac and later you want to open it on a Windows machine.</p>
<pre><code>import shelve

shelf = shelve.open("filename", flag='c') 
#with flag='c', you have to delete the old shelf if you want to overwrite it

dict1 = #something
dict2 = #something

shelf['key1'] = dict1
shelf['key2'] = dict2

shelf.close()
</code></pre>
<p>To read objects from a shelf:</p>
<pre><code>shelf_reader = shelve.open("filename", flag='r')
for k in shelf_reader.keys():
    retrieved = shelf_reader[k]
    print(retrieved) #prints the retrieved dictionary

shelf_reader.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It may be a matter of opinion, but I think one of the best (and by far easieset) ways to serialize a (nested) dictionnary is using the JSON format:</p>
<pre><code>{ "key1" : { "subkey1" : "value1",
             "subkey2" : "value2" },
  "key2" : {"subkey3" : "value3"} }
</code></pre>
<p>The best is that this can be done (either for encoding your values or decoding them) in a single line using the builtin <code>json</code> module !</p>
<p>Let's consider your dictionnary is the <code>dico</code> variable:</p>
<pre><code>import json
save_file = open('save_file', 'w')
save_file.write( json.dumps(dico) )
</code></pre>
<p>Et voil√† :-) !</p>
</div>
<div class="post-text" itemprop="text">
<p>If the data is guaranteed to be loaded back into Python, I'd suggest simply using <a href="http://docs.python.org/2/library/pickle.html" rel="nofollow"><code>pickle</code></a> instead of worrying about the format. If it's going to be loaded into another standard language, then consider using <a href="http://docs.python.org/2/library/json.html" rel="nofollow"><code>json</code></a> instead - there are libraries for most languages to parse JSON format data.</p>
<p>That said if you really need to invent your own format, you could do something like this to store all keys from all sub-dictionaries in CSV format:</p>
<pre><code>import csv
dict_keys = sorted(dict.keys())
with open("output.csv", "wb") as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(["Key"] + dict_keys)
    all_keys = reduce(set.union, (set(d) for d in dict.values()))
    for key in sorted(all_keys):
        writer.writerow([key] + [dict[k].get(key, "") for k in dict_keys])
</code></pre>
</div>
<span class="comment-copy">Is there a guarantee that each entry in the dict will have the same number of items?</span>
<span class="comment-copy">Why are there two rows both labeled <code>key2</code>?</span>
<span class="comment-copy">As a side note: Don't call a list <code>list</code>. That hides the name of the constructor/type, and also confuses readers.</span>
<span class="comment-copy">Hi, this was very helpful but I'm still having trouble with one thing, perhaps because I wasn't clear enough in my original question. The "items" are actually the keys from the dictionary. So to avoid confusion, I have:  A dictionary called dct with keysA and valuesA. Each value of dct's keys is also a dictionary, with keysB(AKA valuesA) and valuesB. So insted of 'item1', 'item2', I want to print the keyA of dct that corresponds to the valuesB and keysB/ValuesA.  So: [tab] keyA1 keyA2 keyA3... keyB1 valB-for-keyB1-and-keyA1  valB-for-keyB1-andkeyA2  valB-for-keyB1-and-keyA3... ...  Make sense?</span>
<span class="comment-copy">I thought I had figured it out, but for some reason the ordering is off... nested values are being printed under the wrong keys. Here is the code I'm using...&lt;br&gt; keys = reduce(set.union, map(set, chemdict.values()))&lt;br&gt; with open('output.csv', 'wb') as f:&lt;br&gt;&amp;nbsp;     w = csv.writer(f, delimiter='\t')&lt;br&gt;&amp;nbsp;     for chem, chrom in chemdict.items():&lt;br&gt;&amp;nbsp;         chemlist2.append(chem)&lt;br&gt;&amp;nbsp;&amp;nbsp;     w.writerow([','] + [chemlist2[i] for i, item in enumerate(chemlist2)])&lt;br&gt;&amp;nbsp;         w.writerow([key] + [chemdict[item].get(key, '0') for item in chemlist])&lt;br&gt;&amp;nbsp;&amp;nbsp;</span>
<span class="comment-copy">@Jay: As you've probably figured out, there's no way to put formatted code into a comment at SO. If it's not appropriate to edit your question or start a new question, post your code somewhere like <a href="http://pastebin.com" rel="nofollow noreferrer">pastebin.com</a> and post a link here.</span>
<span class="comment-copy">@Jay: Meanwhile, based on your comments, it looks like I may have made things more complicated than you need, so let me edit the answer.</span>
<span class="comment-copy">Just one more comment: I had to change the first comma in the following code to a + in order to get it to work:  w.writerow([key], [dct[item].get(key, '') for item in lst])</span>
