<div class="post-text" itemprop="text">
<p>I am writing a Python wrapper for a C library using the <code>cffi</code>. </p>
<p>The C library has to be initialized and shut down. Also, the <code>cffi</code> needs some place to save the state returned from <code>ffi.dlopen()</code>.</p>
<p>I can see two paths here:</p>
<p>Either I wrap this whole stateful business in a class like this</p>
<pre><code>class wrapper(object):
    def __init__(self):
        self.c = ffi.dlopen("mylibrary")
        self.c.initialize()
    def __del__(self):
        self.c.terminate()
</code></pre>
<p>Or I provide two global functions that hide the state in a global variable</p>
<pre><code>def initialize():
    global __library 
    __library = ffi.dlopen("mylibrary")
    __library.initialize()
def terminate():
    __library.terminate()
    del __library
</code></pre>
<p>The first path is somewhat cumbersome in that it requires the user to always create an object that really serves no other purpose other than managing the library state. On the other hand, it makes sure that <code>terminate()</code> is actually called every time.</p>
<p>The second path seems to result in a somewhat easier API. However, it exposes some hidden global state, which might be a bad thing. Also, if the user forgets to call <code>terminate()</code>, the C library is not unloaded correctly (which is not a big problem on the C side).</p>
<p>Which one of these paths would be more pythonic?</p>
</div>
<div class="post-text" itemprop="text">
<p>Exposing a wrapper object only makes sense in python if the library actually supports something like multiple instances in one application. If it doesn't support that or it's not really relevant go for kindall's suggestion and just initialize the library when imported and add an atexit handler for cleanup.</p>
<p>Adding wrappers around a stateless api or even an api without support for keeping different sets of state is not really pythonic and would raise expectations that different instances have some kind of isolation.</p>
<p>Example code:</p>
<pre><code>import atexit

# Normal library initialization
__library = ffi.dlopen("mylibrary")
__library.initialize()

# Private library cleanup function
def __terminate():
    __library.terminate()
# register function to be called on clean interpreter termination
atexit.register(__terminate)
</code></pre>
<p>For more details about atexit <a href="https://stackoverflow.com/questions/3850261/doing-something-before-program-exit">this question</a> has some more details, as has the <a href="https://docs.python.org/3/library/atexit.html" rel="nofollow noreferrer">python documentation</a> of course.</p>
</div>
<span class="comment-copy">Any reason to not just initialize the library when the module is imported (and store the necessary reference(s) in module globals)?</span>
<span class="comment-copy">@kindall how would I call <code>terminate()</code> then?</span>
<span class="comment-copy">You said it's not a big deal if that doesn't get called. But if it needs calling, then the only way to do it reliably is to have the user of your library call it. You can't count on <code>__del__</code> anyway. A context manager might make sense, though...</span>
