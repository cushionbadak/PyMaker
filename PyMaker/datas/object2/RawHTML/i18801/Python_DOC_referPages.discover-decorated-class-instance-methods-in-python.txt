<div class="post-text" itemprop="text">
<p>I have a python class, for example:</p>
<pre><code>class Book(models.Model):
    enabled     = models.BooleanField(default=False)
    full_title  = models.CharField(max_length=256)
    alias       = models.CharField(max_length=64)
    author      = models.CharField(max_length=64)
    status      = models.CharField(max_length=64)
    @serializable
    def pretty_status(self):
        return [b for a, b in BOOK_STATUS_CHOICES if a == self.status][0]
</code></pre>
<p>The method <strong>pretty_status</strong> is decorated with <strong>@serializable</strong>.</p>
<p>What is the simplest and most efficient way to discover the methods in a class that have a certain decoration ? (in the above example giving: pretty_status).</p>
<p><strong>Edit:</strong>
Please also note that the decorator in question is custom/modifiable.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you have no control over what the decorator does, then in general, you can not identify decorated methods. </p>
<p>However, since you can modify <code>serializable</code>, then you could add an attribute to the wrapped function which you could later use to identify serialized methods:</p>
<pre><code>import inspect
def serializable(func):
    def wrapper(self):
        pass
    wrapper.serialized = True
    return wrapper

class Book:
    @serializable
    def pretty_status(self):
        pass
    def foo(self):
        pass


for name, member in inspect.getmembers(Book, inspect.ismethod):
    if getattr(member, 'serialized', False):
        print(name, member)
</code></pre>
<p>yields</p>
<pre><code>('pretty_status', &lt;unbound method Book.wrapper&gt;)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Generally speaking, <em>you can't</em>. A decorator is just syntactic sugar for applying a callable. In your case the decorator syntax translates to:</p>
<pre><code>def pretty_status(self):
    return [b for a, b in BOOK_STATUS_CHOICES if a == self.status][0]
pretty_status = serializable(pretty_status)
</code></pre>
<p>That is, <code>pretty_status</code> is replaced by whatever <code>serializable()</code> returns. What it returns could be anything.</p>
<p>Now, if what <code>serializable</code> returns has itself been decorated with <a href="http://docs.python.org/3/library/functools.html" rel="nofollow"><code>functools.wraps()</code></a> and you are using Python 3.2 or newer, then you can see if there is a <code>.__wrapped__</code> attribute on the new <code>.pretty_status</code> method; it's a reference to the original wrapped function.</p>
<p>On earlier versions of Python, you can easily do this yourself too:</p>
<pre><code>def serializable(func):
    def wrapper(*args, **kw):
        # ...

    wrapper.__wrapped__ = func

    return wrapper
</code></pre>
<p>You can add any number of attributes to that wrapper function, including custom attributes of your own choosing:</p>
<pre><code>def serializable(func):
    def wrapper(*args, **kw):
        # ...

    wrapper._serializable = True

    return wrapper
</code></pre>
<p>and then test for that attribute:</p>
<pre><code>if getattr(method, '_serializable', False):
    print "Method decorated with the @serializable decorator"
</code></pre>
<p>One last thing you can do is test for that wrapper function; it'll have a <code>.__name__</code> attribute that you can test against. That name might not be unique, but it is a start.</p>
<p>In the above sample decorator, the wrapper function is called <code>wrapper</code>, so <code>pretty_status.__name__ == 'wrapper'</code> will be True.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can't discover them directly but You can mark decorated methods with some flag.</p>
<pre><code>import functools
def serializable(func):
    functools.wraps(func)
    def wrapper(*args, **kw):
        # ...

    wrapper._serializable = True
    return wrapper
</code></pre>
<p>And then You can make metaclass for example analyse presence or absence of <code>_serializable</code> attribute.</p>
<p>Or You can collect all wrapped methodsin decorator</p>
<pre><code>import functools
DECORATED = {}
def serializable(func):
    functools.wraps(func)
    def wrapper(*args, **kw):
        # ...

    DECORATED[func.__name__] = wrapper
    return wrapper
</code></pre>
</div>
<span class="comment-copy">Can you modify the decorator, <code>serializable</code>?</span>
<span class="comment-copy">yes of course, it's custom</span>
