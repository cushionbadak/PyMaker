<div class="post-text" itemprop="text">
<p>Can anyone think of an algorithm to put all of the addresses between two others and put them in a list (using python)?  For example:</p>
<pre><code>findIPs('111.111.111.0', '111.111.111.3')
</code></pre>
<p>Should return <code>('111.111.111.0', '111.111.111.1', '111.111.111.2', '111.111.111.3')</code>.  My main problem arises from when corresponding blocks are identical otherwise I could just use nested for loops with the range function.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Python 3.3 with standard library <a href="http://docs.python.org/3/library/ipaddress.html" rel="noreferrer">ipaddress module</a> / Python 3.2-, Python 2.x with <a href="https://pypi.python.org/pypi/ipaddr" rel="noreferrer">ipaddr</a></h2>
<pre><code>try:
    from ipaddress import ip_address
except ImportError:
    from ipaddr import IPAddress as ip_address

def findIPs(start, end):
    start = ip_address(start)
    end = ip_address(end)
    result = []
    while start &lt;= end:
        result.append(str(start))
        start += 1
    return result

print(findIPs('111.111.111.0', '111.111.111.3'))
</code></pre>
<h2>Python 3.2-, Python 2.x</h2>
<pre><code>import struct
import socket

def findIPs(start, end):
    ipstruct = struct.Struct('&gt;I')
    start, = ipstruct.unpack(socket.inet_aton(start))
    end, = ipstruct.unpack(socket.inet_aton(end))
    return [socket.inet_ntoa(ipstruct.pack(i)) for i in range(start, end+1)]

print(findIPs('111.111.111.0', '111.111.111.3'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is one pretty straightforward approach:</p>
<pre><code>def ip_to_int(ip):
    val = 0
    for i, s in enumerate(ip.split('.')):
        val += int(s) * 256 ** (3 - i)
    return val

def int_to_ip(val):
    octets = []
    for i in range(4):
        octets.append(str(val % 256))
        val = val &gt;&gt; 8
    return '.'.join(reversed(octets))

def findIPs(start, end):
    for i in range(ip_to_int(start), ip_to_int(end) + 1):
        yield int_to_ip(i)
</code></pre>
<p>Examples:</p>
<pre><code>&gt;&gt;&gt; list(findIPs('111.111.111.0', '111.111.111.3'))
['111.111.111.0', '111.111.111.1', '111.111.111.2', '111.111.111.3']
&gt;&gt;&gt; list(findIPs('111.111.111.254', '111.111.112.1'))
['111.111.111.254', '111.111.111.255', '111.111.112.0', '111.111.112.1']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A little searching would have probably found the answer as well, but this should work:</p>
<pre><code>import socket
import struct

ip_to_number = lambda ip: struct.unpack('!I', socket.inet_aton(ip))[0]
number_to_ip = lambda num: socket.inet_ntoa(struct.pack('!I', num))

def ip_range(a, b):
    a = ip_to_number(a)
    b = ip_to_number(b)

   for i in range(a, b+1):
     yield number_to_ip(i)
</code></pre>
</div>
<span class="comment-copy">Can you post the code you have so far?</span>
<span class="comment-copy">how do i get the ipaddress module?  it is not in the standard library and the docs says that it is in the provisional package.</span>
<span class="comment-copy">Updated code. See ipaddr link.</span>
<span class="comment-copy">alright got this to work, thanks for your help.</span>
<span class="comment-copy">I don't know what half of your code does but it works!</span>
<span class="comment-copy">thanks for the help</span>
<span class="comment-copy">@avorum I only answered this way because I didn't realize there was a module for this, I would recommend using falsetru's answer.</span>
