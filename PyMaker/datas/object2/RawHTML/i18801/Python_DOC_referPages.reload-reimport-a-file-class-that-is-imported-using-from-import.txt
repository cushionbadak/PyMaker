<div class="post-text" itemprop="text">
<p>well, as the title say, i got a group of import, all import a class, all in the same folder as the script running it:</p>
<pre><code>from lvl import lvl
from get import get
from image import image
from video import vid
from video import MLStripper
from system import system
from setting import setting
from listsearch import lists
</code></pre>
<p>python3 doesn't have reload iirc but there is imp.reload() but it doesn't seem to work,</p>
<p>it just throw a error saying it not a module (it a class so it doesn't work)</p>
<p>after every little edit in those class that are imported, i would need to restart the script</p>
<p>isn't there a way to reload/reimport the class to show the effect of the edit without needing to start the script or rewriting most of the script so that imp.reload() works?</p>
<p>python3, linux (but prefer if it also work on window)</p>
<p>edit1:</p>
<p>example: if i use:</p>
<pre><code>import system
system.system.temp()
</code></pre>
<p>it return:</p>
<pre><code>65°C
</code></pre>
<p>if i change it to show °F and reload it using imp.reload</p>
<pre><code>imp.reload(system)
system.system.temp()
</code></pre>
<p>it return:</p>
<pre><code>149°F
</code></pre>
<p>so, it works BUT if i use</p>
<pre><code>import system as _system
from system import system
system.temp()
</code></pre>
<p>it return:</p>
<pre><code>65°C
</code></pre>
<p>then i change it to show °F and reload it using imp.reload</p>
<pre><code>imp.reload(_system)
from system import system
system.temp()
</code></pre>
<p>it still return</p>
<pre><code>65°C
</code></pre>
<p>BUT again, if i call it this way:</p>
<pre><code>_system.system.temp()
</code></pre>
<p>it return</p>
<pre><code>149°F
</code></pre>
<p>idk why it that but it is cause it happen in a while loop?</p>
<p>edit2:</p>
<p>file name: system.py:</p>
<p>before changing for test:</p>
<pre><code>class system:
  def temp():
    temperature = open("/sys/class/thermal/thermal_zone0/temp","r").read()
    temperature = temperature[:2]
    return(temperature+"°C")
</code></pre>
<p>after changing for test:</p>
<pre><code>class system:
  def temp():
    temperature = open("/sys/class/thermal/thermal_zone0/temp","r").read()
    temperature = temperature[:2]
    temperature = str(9.0 / 5.0 * int(temperature) + 32).split(".")[0]
    return(temperature+"°C")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can only <a href="http://docs.python.org/3/library/imp.html#imp.reload" rel="nofollow"><code>reload</code></a> a module:</p>
<blockquote>
<p>The argument must be a module object, so it must have been successfully imported before.</p>
</blockquote>
<p>In your case, you don't have any reference to the module object. You will have to <code>import</code> it, even if you don't want to use it for anything else, just for the sake of calling <code>reload</code> later.</p>
<p>Also, after the <code>reload</code>, you have re-<code>import</code> the names:</p>
<blockquote>
<p>Other references to the old objects (such as names external to the module) are not rebound to refer to the new objects and must be updated in each namespace where they occur if that is desired.</p>
</blockquote>
<p>When you do <code>from foo import bar</code>, that <code>bar</code> is a "name external to the module", so you have to rebind it explicitly.</p>
<p>If you think about it, it <em>has</em> to work this way. There's no way <code>reload</code> can enumerate all objects whose definition is dependent on the previous version of the module to update them. Even if it could, there could be infinite cycles. And what would happen if the new version didn't even have a definition for a class that was in the old one? Or if the class were defined dynamically?</p>
<p>Looking at it another way, <code>from foo import bar</code> is very similar to <code>import foo; bar = foo.bar</code>. <code>bar</code> is a name in your namespace, not <code>foo</code>'s namespace, so <code>reload(foo)</code> will not touch it; you need to copy the new <code>foo.bar</code> over again.</p>
<p>The easy way to solve all of these problems is to just repeat all of your <code>from foo import bar</code> lines after the <code>reload</code>.</p>
<hr/>
<p>For simple cases:</p>
<pre><code>import video
from video import MLStripper

# ... later

imp.reload(video)
from video import MLStripper
</code></pre>
<hr/>
<p>However, most of your examples have an obvious naming conflict: once you <code>from video import video</code>, you can no longer <code>reload(video)</code>. So, you need another reference to the <code>video</code> module object.</p>
<p>Python keeps one around for you, which you can use:</p>
<pre><code>imp.reload(sys.modules['video'])
from video import MLStripper
</code></pre>
<p>Or, alternatively, you can use an <code>as</code> clause, or just an <code>=</code> assignment, to give it whatever name you want.</p>
<pre><code>import video as _video
from video import video

# ... later

imp.reload(_video)
from video import video
</code></pre>
<hr/>
<p>From your comments and your edited question, it sounds like you have a further problem. Let's use one of the simple non-colliding cases to discuss it.</p>
<p>I believe you're actually doing something like this:</p>
<pre><code>import video
from video import MLStripper

stripper = MLStripper('foo")

# ... later

imp.reload(video)
from video import MLStripper
</code></pre>
<p>The first line will successfully reload the <code>video</code> module, and the second will copy its <code>MLStripper</code> class into your globals, so any new <code>MLStripper</code> instances you created will be of the new type.</p>
<p>But that doesn't affect any existing <code>MLStripper</code> instances, like <code>stripper</code>. </p>
<p>Just like <code>MLStripper</code> was, <code>stripper</code> is one of those "names external to the module". But it's actually even worse. In order to adjust it, <code>reload</code> would have to figure out what its state would have been, had the new version of the code been in effect from the time it was created. It should be obvious that this is an unsolvable problem.</p>
<hr/>
<p>If you know the instances you want to patch up, you can deal with them in effectively the same way you dealt with the classes: just create them again:</p>
<pre><code>imp.reload(video)
from video import MLStripper
stripper = MLStripper('foo")
</code></pre>
<hr/>
<p>If that's not good enough, there are three hacky possibilities that may be what you want:</p>
<ul>
<li>Monkeypatch the methods, attributes, etc. into the instance(s) and their <code>__class__</code>(es).</li>
<li>Patch the instances' <code>__class__</code> attribute directly, so anything that was inherited from the class will now be inherited from the new class.</li>
<li>Serialize the instances with <code>pickle</code> before the <code>reload</code>, then deserialize after.</li>
</ul>
<p>For very simple cases, all three of these will work. For more complex cases, you will have to understand what you're doing.</p>
<hr/>
<p>Note that you can wrap a lot of this stuff up in a function, but you have to understand how locals and globals work (and how import and reload work) or you're going to end up confusing yourself.</p>
<p>A simpler solution is to just create "dump all state" and "load all state" functions. Then you can dump everything, quit, relaunch, and restore. The Python tutorial and the ipython docs both describe a few different ways to do this in place of using <code>reload</code>; it's probably worth going back and rereading those.</p>
</div>
<div class="post-text" itemprop="text">
<p>Access the module through <code>sys.modules</code>, reload <em>that</em>, then reassign the imported names:</p>
<pre><code>imp.reload(sys.modules['lvl'])
from lvl import lvl

imp.reload(sys.modules['get'])
from get import get
</code></pre>
<p>etc.</p>
<p>All the <code>from something import name</code> syntax does is import <code>something</code> then bind <code>name</code> to the same object <code>something.name</code> refers to.</p>
<p>By using <code>sys.modules</code> you don't have to explicitly import the module again, and can reach the new definitions of the objects for rebinding after reloading.</p>
</div>
<span class="comment-copy">For future reference, if you'd used PEP8-style naming, your classes would be named Lvl, Image, etc. and wouldn't conflict with your module names, which would make things simpler.</span>
<span class="comment-copy">well, i never really use the Python Enhancement Proposals, i think it better to code the way that is easy to understand and remember and i try to minimize everything but keep it sorted like indents/newlines and variables/function (use 2 spaces indent, sometimes 1 space indent if the file is only a few lines) since it very unlikely that any of my code would be use by a other person, basically anything that mean lesser typing and error cause by wrong case</span>
<span class="comment-copy">"I never really use the Python Enhancement Proposals" doesn't make any sense. The PEPs are the record of every significant change made in Python 2.0 and later versions. See <a href="http://www.python.org/dev/peps/pep-0001/#what-is-a-pep" rel="nofollow noreferrer">What is a PEP?</a>. Anyway, even if you think it's very unlikely that your code would be used by another person, it's <i>still</i> important that it be readable by other people if you want to, say, post it on SO and ask for help with it. Finally, inventing your own naming style is directly responsible for your problem here—you can't have two things called <code>lvl</code> both in scope.</span>
<span class="comment-copy">@abarnert my naming style isn't directly responsible for my problem here, it the fact that i didn't import the module cause there only one class in those module that got name conflict so i thought that it wouldn't be needed as it would get overwritten by the class in the end anyway</span>
<span class="comment-copy">I don't really understand your edited version. If you think "it is cause it happen in a while loop", you will have to show us what the while loop looks like. And, in general, you will have to show us your actual code. My guess is that you don't actually have a classmethod <code>system.system.temp()</code>, but rather an instance method; you've created a <code>system.system</code> instance, and you're calling <code>temp()</code> on <i>that</i>. In that case, reloading <code>system</code> doesn't do any good; you have to create a new instance of the new class.</span>
<span class="comment-copy">it seem once it imported, executing the from * import * command again won't do anything</span>
<span class="comment-copy">@freeforalltousez: It definitely does do something: it re-copies the name from the module to globals. Just reloading the module doesn't do that; just doing the <code>from … import …</code> doesn't do the reload. That's why you need both.</span>
<span class="comment-copy">i did both and the class in the reloaded module is still the old class, the class didn't get updated, but if i use import video, and call it using video.video.link(<i>arg</i>), then do the imp.reload(_video), then the class with the function link get updated</span>
<span class="comment-copy">see updated post</span>
<span class="comment-copy">You don't need the <code>sys.modules['get'].get</code>, you can just (re-)do <code>from get import get</code>.</span>
<span class="comment-copy">@abarnert: indeed; updated.</span>
