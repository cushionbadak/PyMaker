<div class="post-text" itemprop="text">
<p>I would like to create a class that inherites from <code>None</code>.</p>
<p>Tried this:</p>
<pre><code>class InvalidKeyNone(None):
    pass
</code></pre>
<p>but that gives me:</p>
<pre><code>TypeError: Error when calling the metaclass bases
    cannot create 'NoneType' instances
</code></pre>
<p>What would be the correct solution that gives me a type that behaves exactly like <code>None</code> but which I can type test?</p>
<pre><code>foo = InvalidKeyNone()
print(type(foo))
&gt;&gt;&gt; InvalidKeyNone
</code></pre>
<p>[EDIT]</p>
<p>I want to do this because I am creating a selection scheme on Python datastructures:</p>
<pre><code>bar = select(".foo.bar.[1].x", {"foo":{"bar":[{"x":1}, {"x":2}], "baz":3})
print(bar)
&gt;&gt; 2
</code></pre>
<p>And I want to be able to determine whether I get a None because the selected value is None or because the key was not found.
HOWEVER it must return a (ducktyped) None that behaves exactly like a None. No exceptions or custom type returning here.</p>
<p>[EDIT]</p>
<p>Ok, so the consensus is: can't be done. Which although unsatisfactory is a valid answer. Since I really want the default behavior to have it return a None when the key is not present I think I will have the select eat a param to switch to exception throwing when appropriate. Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>None</code> is a <a href="http://docs.python.org/2/library/constants.html" rel="nofollow noreferrer">constant</a>, the sole value of <code>types.NoneType</code> (for <a href="https://docs.python.org/2/library/constants.html?highlight=nonetype#None" rel="nofollow noreferrer">v2.7</a>, for <a href="https://docs.python.org/3/library/constants.html?highlight=nonetype#None" rel="nofollow noreferrer">v3.x</a>)</p>
<p>Anyway, when you try to inherit from <code>types.NoneType</code></p>
<pre><code>from types import NoneType

class InvalidKeyNone(NoneType):
    pass

foo = InvalidKeyNone()
print(type(foo))
</code></pre>
<p>you'll get this error</p>
<blockquote>
<p><em>Python 2</em></p>
<p>TypeError: Error when calling the metaclass bases
      type 'NoneType' is not an acceptable base type</p>
<p><em>Python 3</em></p>
<p>ImportError: cannot import name 'NoneType'</p>
</blockquote>
<p>in short, you cannot inherit from <code>NoneType</code></p>
<p>Anyway, why would want a class to inherit <code>NoneType</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Subclassing None does not make sense, since it is a singleton and There Can Be Only One.  You say you want a class with the same behaviour, but None does not have any behaviour!</p>
<p>If what you really want is a unique placeholder that you can return from a function to indicate a special case then simplest way to do this is to create a unique instance of object:</p>
<pre><code>InvalidKey = object()

result = doSomething()
if result is InvalidKey:
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There's no way to do it, at least definitely not until you do some unreadable black magic.  </p>
<p>You should probably use exceptions.</p>
</div>
<span class="comment-copy">Why would you want to do this?</span>
<span class="comment-copy">To expand on the singleton point, even assuming such an object could be constructed, using it would break half of Python's stdlib, because the <code>if x is None:</code> idiom used everywhere tests object <i>identity</i>.  Since that pattern is the recommended one, there is no way to construct some None-like type such that instances of it will behave exactly like <code>None</code>.</span>
<span class="comment-copy">You also don't want to rely on type checking - this is an anti-pattern in Python. You should instead check if an object supports an interface; more of a "try it and see" rather than "check and react". It also looks like what you need is a custom Exception.</span>
<span class="comment-copy"><i>"behaves exactly like None"</i> - as far as I'm aware, <code>None</code> has no non-trivial special behavior</span>
<span class="comment-copy">"HOWEVER it must return a (ducktyped) None that behaves exactly like a None. No exceptions or custom type returning here."  Why?  Everyone else seems to get by without this unusual need.  The standard idiom is to use a custom sentinel, whether a fully specified class type or simply <code>sentinel = object()</code>.</span>
<span class="comment-copy">In python 3 you could do: type(None) and it returns NoneType</span>
<span class="comment-copy">I would like to be able to inherit from <code>NoneType</code>, e.g. for dumping to YAML I would then have multiple types that all behave like <code>None</code> but that  can be represented in different ways in YAML (<code>NULL</code>, <code>~</code>, <code>null</code>, the empty scalar, and <code>Null</code>)</span>
<span class="comment-copy"><code>class Foo(type(None)): TypeError: type 'NoneType' is not an acceptable base type</code>  â€” :-D</span>
<span class="comment-copy">Note that the difference here is that <code>bool(None)</code> is <code>False</code>, whereas <code>bool(InvalidKey)</code> is <code>True</code></span>
<span class="comment-copy">The solution would be to create a singleton instance of a custom class with <code>__nonzero__</code> set to return false.</span>
<span class="comment-copy">It would be more "pythonic" to raise an exception...</span>
<span class="comment-copy">This. Subclass <code>KeyError</code> and have your code raise that instead of the standard <code>KeyError</code>.</span>
