<div class="post-text" itemprop="text">
<p>I asked a question related to this several weeks ago on here:
<a href="https://stackoverflow.com/questions/17159627/python-mpg123-and-subprocess-not-properly-using-stdin-write-or-communicate">Python, mpg123 and subprocess not properly using stdin.write or communicate</a></p>
<p>Thanks to help from there I was able to do what I needed at the time. (Didn't call q, but terminated the subprocess to stop it).## Heading ##
Now though I seem to be in another bit of a mess.</p>
<pre><code>    from subprocess import Popen, PIPE, STDOUT
    p = Popen(["mpg123", "-C", "test.mp3"], stdout=PIPE, stdin=PIPE, stderr=STDOUT)
    #wait a few seconds to enter this, "q" without a newline is how the controls for the player work to quit out if it were ran like "mpg123 -C test.mp3" on the command line
    p.communicate(input='q')[0]
</code></pre>
<p>much like before, I need this to be able to quit out of mpg123 like it would be with it's standard controls (like press 'q' to quit, or '-' to turn volume down, '+' to turn volume up, etc), now I use the code above, which should theoretically work, and it works with similar programs. Does anyone know of a way I can use the controls built into mpg123 (the one accessible by using "mpg123 -C whatever.mp3") using a subprocess? terminate isn't enough anymore as I will need the controls ^_^</p>
<p>EDIT: Many thanks to abarnert for the amazing answer =)
ok, so the new code is simply a slightly modified version of abarnert's answer, however mpg123 doesn't seem to be accepting the commands</p>
<pre><code>    import os
    import pty
    import sys
    import time

    pid, fd = os.forkpty()
    if pid:
        time.sleep(5)
        os.write(fd, 'b') #this should've restarted the file
        time.sleep(5)
        os.write(fd, 'q') #unfortunately doesn't quit here =(
        time.sleep(5) # quits after this is finished executing
    else:
        os.spawnl(os.P_WAIT, '/usr/bin/mpg123', '-C', 'TEST file.mp3')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you really need the controls, you can't just use <code>Popen</code>.</p>
<p><code>mpg123</code> only enables terminal control if its stdin is a tty, not if it's a file or pipe. That's why you get this line in the banner:</p>
<pre><code>Terminal control enabled, press 'h' for listing of keys and functions.
</code></pre>
<p>And the whole point of <code>Popen</code> (and <code>subprocess</code>, and the POSIX APIs it's built on) is pipes.</p>
<p>So, what can you do about it?</p>
<hr/>
<p>On linux, you can use the <a href="http://docs.python.org/3/library/pty.html" rel="nofollow"><code>pty</code></a> module. It may also work on other *nix platforms, but it may not—even if it gets built and included in your stdlib. As the docs say:</p>
<blockquote>
<p>Because pseudo-terminal handling is highly platform dependent, there is code to do it only for Linux. (The Linux code is supposed to work on other platforms, but hasn’t been tested yet.)</p>
</blockquote>
<p>It definitely runs on *BSD platforms on 2.7 and 3.3, and the example in the docs seem to work on both Mac OS X and FreeBSD… but that's as far as I've checked.</p>
<hr/>
<p>Meanwhile, most POSIX platforms will at least have <a href="http://docs.python.org/3.3/library/os.html#os.forkpty" rel="nofollow"><code>os.forkpty</code></a>, and that's not much harder, so here's a trivial program that plays the first 5 seconds of a song passed as its first arg:</p>
<pre><code>import os
import pty
import sys
import time

pid, fd = os.forkpty()
if pid:
    time.sleep(5)
    os.write(fd, 'q')
else:
    os.spawnl(os.P_WAIT, # mode
              '/usr/local/bin/mpg123', # path
              '/usr/local/bin/mpg123', '-C', sys.argv[1]) # args
</code></pre>
<hr/>
<p>Note that I used <code>os.spawnl</code> above. This is probably <em>not</em> what you want in a real program; it's for pedagogic purposes, to encourage you to read the docs (and the corresponding manpages) and understand this family of functions.</p>
<p>As <a href="http://docs.python.org/3/library/os.html#os.spawnl" rel="nofollow">the docs</a> explain, this does not use the <code>PATH</code> environment variable, so you need to specify the full path to the program. You can just use <code>spawnlp</code> instead of <code>spawnl</code> to fix this.</p>
<p>Also, <code>spawn</code> may (in fact, always does, although the docs aren't entirely clear) do another fork to execute the child. This really isn't necessary, but <code>spawn</code> does things that you would need to do manually if you just called <code>exec</code>. If you know what you're doing, you may well want to use <code>execl</code> (or <code>execlp</code>) instead of <code>spawnl</code>.</p>
<p>You can even use most of the functionality in <code>subprocess</code> as long as you're careful (do not create any pipes, and remember that you'll end up doing <em>two</em> <code>fork</code>s, so make sure to set up the parent/child relationship properly).</p>
<p>Also notice that you need to pass the path to <code>mpg123</code> <em>twice</em>—once as the path, and then once as the child program's <code>argv[0]</code>. You could also just pass <code>mpg123</code> the second time. Or, ideally, look at what <code>ps</code> says when you run it from the shell, and pass that. At any rate, you have to pass <em>something</em> as the <code>argv[0]</code>; otherwise, <code>-C</code> ends up being the <code>argv[0]</code>, which means mpg123 won't think you gave it a <code>-C</code> flag to enable control keys, but rather than you renamed it to <code>-C</code> and ran it with no flags…</p>
<p>Anyway, you really do need to read the docs to understand what each of these functions does, instead of just treating it like magic code that you don't understand. So, I intentionally used the simplest possible solution to encourage that.</p>
<hr/>
<p>On Windows, there is no such thing as a <code>pty</code>, and no way to do this at all with the facilities built in to Python. You will need to use one of the various third-party libraries for controlling a cmd.exe console (aka DOS prompt) instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on abarnert's idea, we can open a pseudo-terminal and pass it to subprocess.</p>
<pre><code>import os
import pty
import subprocess
import time

master, slave = os.openpty()

p = subprocess.Popen(['mpg123', '-C', 'music.mp3'], stdin=master)
time.sleep(3)
os.write(slave, 's')
time.sleep(3)
os.write(slave, 's')
time.sleep(6)
os.write(slave, 'q')
</code></pre>
</div>
<span class="comment-copy">Is there a reason you want to try to control the <code>mpg123</code> player instead of, say, using a Python library (or even bindings for <code>libmpg123</code>) to play the music and do your own controls?</span>
<span class="comment-copy">mainly because I'm a newbie lol, most things I'm seeing for playback with the Raspberry Pi (my particular platform) uses mpg123 or mpg321, it was suggested to me when I said I'd like to be able to play mp3's through python to use a subprocess with one of those players</span>
<span class="comment-copy">First, sorry for my excessive abbreviation; it seems to have led you astray. Whenever I'm dealing with POSIX-style code I revert to using words like <code>pid</code> and <code>fd</code> as if everyone should understand what they mean. A <code>pid</code> is a Process ID, not a Parent ID—and in this case, it's the <i>child</i> process ID, so calling it <code>parentID</code> is confusing. And an <code>fd</code> is a File Descriptor (or, for really old people File Descriptor index), not a File Dir.</span>
<span class="comment-copy">Meanwhile, calling <code>queue.get(False)</code> in a <code>while True:</code> loop is a bad idea, especially if you don't have anything to do while waiting. Basically, until something comes in, you're using up as much CPU as possible to keep asking "are we there yet?". Just use <code>queue.get(True)</code> and/or pass a timeout.</span>
<span class="comment-copy">Finally… I'm not actually sure what happens when you use <code>forkpty</code> (or just <code>fork</code>) from a <code>multiprocessing.Process</code>. Are you sure it works with the <code>q</code> and not the <code>b</code>? Is it possible that it just works N% of the time at random, or every time after the first, etc.?</span>
<span class="comment-copy">this looks very promising;thank you ^_^ unfortunately it's whole new territory for me, so I got to go read documentation and see if I can find tutorials ^_^</span>
<span class="comment-copy">I couldn't get the example code to work at first, with a slight modification though... instead of '/usr/local/bin/mpg123' mine was located just in '/usr/bin/mpg123'. Time to tinker, thank you again ^_^</span>
<span class="comment-copy">@newbToPython: I was assuming you knew where you'd installed <code>mpg123</code>. But that raises a good point: with <code>subprocess</code> you don't really have to worry about the <code>PATH</code>; with the <code>os.spawn*</code> variants, you have to read the docs and think about it. Let me update the answer to explain.</span>
<span class="comment-copy">I'm also a newbToLinux lol, though I am going to edit my original post with the updated changes as I seem to have come across another issue using pty</span>
<span class="comment-copy">ok, thanks a lot to your help (a TON of reading in the documentation), and a whole bunch of time, I have a working prototype ^_^ Your change to the os.spawn got me thinking about the arguments used, I'm actually using a list instead of sys.argv[1], so I've changed the last argument to *playList so I can add multiple files to mpg123's playlist from a known set of audio files in the script. I very much appreciate all of your help, you've been patient and wonderful, so thank you ^_^</span>
