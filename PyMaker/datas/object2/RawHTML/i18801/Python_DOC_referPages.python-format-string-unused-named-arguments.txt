<div class="post-text" itemprop="text">
<p>Let's say I have:</p>
<pre><code>action = '{bond}, {james} {bond}'.format(bond='bond', james='james')
</code></pre>
<p>this wil output:</p>
<pre><code>'bond, james bond' 
</code></pre>
<p>Next we have:</p>
<pre><code> action = '{bond}, {james} {bond}'.format(bond='bond')
</code></pre>
<p>this will output:</p>
<pre><code>KeyError: 'james'
</code></pre>
<p>Is there some workaround to prevent this error to happen, something like:</p>
<ul>
<li>if keyrror: ignore, leave it alone (but do parse others)</li>
<li>compare format string with available named arguments, if missing then add</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<h2>If you are using Python 3.2+, use can use <a href="http://docs.python.org/3/library/stdtypes.html#str.format_map">str.format_map()</a>.</h2>
<p>For <code>bond,  bond</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; '{bond}, {james} {bond}'.format_map(defaultdict(str, bond='bond'))
'bond,  bond'
</code></pre>
<p>For <code>bond, {james} bond</code>:</p>
<pre><code>&gt;&gt;&gt; class SafeDict(dict):
...     def __missing__(self, key):
...         return '{' + key + '}'
...
&gt;&gt;&gt; '{bond}, {james} {bond}'.format_map(SafeDict(bond='bond'))
'bond, {james} bond'
</code></pre>
<h2>In Python 2.6/2.7</h2>
<p>For <code>bond,  bond</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.Formatter().vformat('{bond}, {james} {bond}', (), defaultdict(str, bond='bond'))
'bond,  bond'
</code></pre>
<p>For <code>bond, {james} bond</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; import string
&gt;&gt;&gt;
&gt;&gt;&gt; class SafeDict(dict):
...     def __missing__(self, key):
...         return '{' + key + '}'
...
&gt;&gt;&gt; string.Formatter().vformat('{bond}, {james} {bond}', (), SafeDict(bond='bond'))
'bond, {james} bond'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="http://docs.python.org/2/library/string.html#template-strings">template string</a> with the <code>safe_substitute</code> method.</p>
<pre><code>from string import Template

tpl = Template('$bond, $james $bond')
action = tpl.safe_substitute({'bond': 'bond'})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can follow the recommendation in <a href="http://www.python.org/dev/peps/pep-3101/" rel="nofollow noreferrer">PEP 3101</a> and subclass Formatter:</p>
<pre><code>from __future__ import print_function
import string

class MyFormatter(string.Formatter):
    def __init__(self, default='{{{0}}}'):
        self.default=default

    def get_value(self, key, args, kwds):
        if isinstance(key, str):
            return kwds.get(key, self.default.format(key))
        else:
            return string.Formatter.get_value(key, args, kwds)
</code></pre>
<p>Now try it:</p>
<pre><code>&gt;&gt;&gt; fmt=MyFormatter()
&gt;&gt;&gt; fmt.format("{bond}, {james} {bond}", bond='bond', james='james')
'bond, james bond'
&gt;&gt;&gt; fmt.format("{bond}, {james} {bond}", bond='bond')
'bond, {james} bond'
</code></pre>
<p>You can change how key errors are flagged by changing the text in <code>self.default</code> to what you would like to show for KeyErrors:</p>
<pre><code>&gt;&gt;&gt; fmt=MyFormatter('"&gt;&gt;{{{0}}} KeyError&lt;&lt;"')
&gt;&gt;&gt; fmt.format("{bond}, {james} {bond}", bond='bond', james='james')
'bond, james bond'
&gt;&gt;&gt; fmt.format("{bond}, {james} {bond}", bond='bond')
'bond, "&gt;&gt;{james} KeyError&lt;&lt;" bond'
</code></pre>
<p>The code works unchanged on Python 2.6, 2.7, and 3.0+</p>
</div>
<div class="post-text" itemprop="text">
<p>One can also do the simple and readable, albeit somewhat silly:</p>
<pre><code>'{bond}, {james} {bond}'.format(bond='bond', james='{james}')
</code></pre>
<p>I know that this answer requires knowledge of the expected keys,
but I was looking for a simple two-step substitution (say problem name first, then problem index within a loop) and creating a whole class or unreadable code was more complex than needed.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://stackoverflow.com/a/17215533/1441112">falsetru's answer</a> has a clever use of a defaulting dictionary with <code>vformat()</code>, and <a href="https://stackoverflow.com/a/33621609/1441112">dawg's answer</a> is perhaps more in-line with Python's documentation, but neither handle compound field names (e.g., with explicit conversion (<code>!r</code>) or format specs (<code>:+10g</code>).</p>
<p>For example, using falsetru's SafeDict:</p>
<pre><code>&gt;&gt;&gt; string.Formatter().vformat('{one} {one:x} {one:10f} {two!r} {two[0]}', (), SafeDict(one=215, two=['James', 'Bond']))
"215 d7 215.000000 ['James', 'Bond'] James"
&gt;&gt;&gt; string.Formatter().vformat('{one} {one:x} {one:10f} {two!r} {two[0]}', (), SafeDict(one=215))
"215 d7 215.000000 '{two}' {"
</code></pre>
<p>And using dawg's MyFormatter:</p>
<pre><code>&gt;&gt;&gt; MyFormatter().format('{one} {one:x} {one:10f} {two!r} {two[0]}', one=215, two=['James', 'Bond'])
"215 d7 215.000000 ['James', 'Bond'] James"
&gt;&gt;&gt; MyFormatter().format('{one} {one:x} {one:10f} {two!r} {two[0]}', one=215)
"215 d7 215.000000 '{two}' {"
</code></pre>
<p>Neither work well in the second case because the value lookup (in <code>get_value()</code>) has already stripped out the formatting specifications. Instead, you can redefine <code>vformat()</code> or <code>parse()</code> so these specifications are available. My solution below does this by redefining <code>vformat()</code> so it performs the key lookup and, if the key is missing, escapes the format string with double braces (e.g. <code>{{two!r}}</code>) and then performs the normal <code>vformat()</code>.</p>
<pre><code>class SafeFormatter(string.Formatter):
    def vformat(self, format_string, args, kwargs):
        args_len = len(args)  # for checking IndexError
        tokens = []
        for (lit, name, spec, conv) in self.parse(format_string):
            # re-escape braces that parse() unescaped
            lit = lit.replace('{', '{{').replace('}', '}}')
            # only lit is non-None at the end of the string
            if name is None:
                tokens.append(lit)
            else:
                # but conv and spec are None if unused
                conv = '!' + conv if conv else ''
                spec = ':' + spec if spec else ''
                # name includes indexing ([blah]) and attributes (.blah)
                # so get just the first part
                fp = name.split('[')[0].split('.')[0]
                # treat as normal if fp is empty (an implicit
                # positional arg), a digit (an explicit positional
                # arg) or if it is in kwargs
                if not fp or fp.isdigit() or fp in kwargs:
                    tokens.extend([lit, '{', name, conv, spec, '}'])
                # otherwise escape the braces
                else:
                    tokens.extend([lit, '{{', name, conv, spec, '}}'])
        format_string = ''.join(tokens)  # put the string back together
        # finally call the default formatter
        return string.Formatter.vformat(self, format_string, args, kwargs)
</code></pre>
<p>Here's it in action:</p>
<pre><code>&gt;&gt;&gt; SafeFormatter().format('{one} {one:x} {one:10f} {two!r} {two[0]}', one=215, two=['James', 'Bond'])
"215 d7 215.000000 ['James', 'Bond'] James"
&gt;&gt;&gt; SafeFormatter().format('{one} {one:x} {one:10f} {two!r} {two[0]}', one=215)
'215 d7 215.000000 {two!r} {two[0]}'
&gt;&gt;&gt; SafeFormatter().format('{one} {one:x} {one:10f} {two!r} {two[0]}')
'{one} {one:x} {one:10f} {two!r} {two[0]}'
&gt;&gt;&gt; SafeFormatter().format('{one} {one:x} {one:10f} {two!r} {two[0]}', two=['James', 'Bond'])
"{one} {one:x} {one:10f} ['James', 'Bond'] James"
</code></pre>
<p>This solution is a bit too hacky (maybe redefining <code>parse()</code> would have fewer kludges), but should work for more formatting strings.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's another way to do it using python27:</p>
<pre><code>action = '{bond}, {james} {bond}'
d = dict((x[1], '') for x in action._formatter_parser())
# Now we have: `d = {'james': '', 'bond': ''}`.
d.update(bond='bond')
print action.format(**d)  # bond,  bond
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Needing to partially fill format strings is a common problem when progressively filling the format strings, e.g. for SQL queries.</p>
<p><code>format_partial()</code> method uses the <code>Formatter</code> from <code>string</code> and <code>ast</code> to parse the format string and also find out whether the named parameter hash has all the values needed to partially evaluate the format:</p>
<pre><code>import ast
from collections import defaultdict
from itertools import chain, ifilter, imap
from operator import itemgetter
import re
from string import Formatter

def format_partial(fstr, **kwargs):
    def can_resolve(expr, **kwargs):
        walk = chain.from_iterable(imap(ast.iter_fields, ast.walk(ast.parse(expr))))
        return all(v in kwargs for k,v in ifilter(lambda (k,v): k=='id', walk))

    ostr = fstr
    fmtr = Formatter()
    dd = defaultdict(int)
    fmtr.get_field = lambda field_name, args, kwargs: (dd[field_name],field_name)
    fmtr.check_unused_args = lambda used_args, args, kwargs: all(v in dd for v in used_args)
    for t in ifilter(itemgetter(1), Formatter().parse(fstr)):
        f = '{'+t[1]+(':'+t[2] if t[2] else '')+'}'
        dd = defaultdict(int)
        fmtr.format(f,**kwargs)
        if all(can_resolve(e,**kwargs) for e in dd):
            ostr = re.sub(re.escape(f),Formatter().format(f, **kwargs),ostr,count=1)
    return ostr
</code></pre>
<p><code>format_partial</code> will leave the unresolved portion of the format string, so subsequent calls can be used to resolve those parts as the data is available.</p>
<p>goodmami's and dawg's answers seem cleaner, but they both fail to capture the format mini-language completely as in <code>{x:&gt;{x}}</code>; <code>format_partial</code> will have no problem resolving any format string that <code>string.format()</code> resolves:</p>
<pre><code>from datetime import date
format_partial('{x} {} {y[1]:x} {x:&gt;{x}} {z.year}', **{'x':30, 'y':[1,2], 'z':date.today()})

'30 {} 2                             30 2016'
</code></pre>
<p>It is even easier to extend the functionality to old style format strings using regex instead of the string formatter, as the old style format substrings were regular (ie. no nested markers).</p>
</div>
<div class="post-text" itemprop="text">
<p>For Python 3, taking the approved answer, this is a nice, tight, Pythonic implementation:</p>
<pre><code>def safeformat(str, **kwargs):
    class SafeDict(dict):
        def __missing__(self, key):
            return '{' + key + '}'
    replacements = SafeDict(**kwargs)
    return str.format_map(replacements)

# In [1]: safeformat("a: {a}, b: {b}, c: {c}", a="A", c="C", d="D")
# Out[1]: 'a: A, b: {b}, c: C'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on some of the other answers, I expanded the solutions.
This will handle strings with formatting spec <code>"{a:&lt;10}"</code>.</p>
<p>I found that some strings from selenium logging were causing vformat (and format_map) to hit a recursion limit.  I also wanted to ensure I could handle strings where empty curly braces exist as well.</p>
<pre class="lang-py prettyprint-override"><code>def partialformat(s: str, recursionlimit: int = 10, **kwargs):
    """
    vformat does the acutal work of formatting strings. _vformat is the 
    internal call to vformat and has the ability to alter the recursion 
    limit of how many embedded curly braces to handle. But for some reason 
    vformat does not.  vformat also sets the limit to 2!   

    The 2nd argument of _vformat 'args' allows us to pass in a string which 
    contains an empty curly brace set and ignore them.
    """

    class FormatPlaceholder:
        def __init__(self, key):
            self.key = key

        def __format__(self, spec):
            result = self.key
            if spec:
                result += ":" + spec
            return "{" + result + "}"

    class FormatDict(dict):
        def __missing__(self, key):
            return FormatPlaceholder(key)

    class PartialFormatter(string.Formatter):
        def get_field(self, field_name, args, kwargs):
            try:
                obj, first = super(PartialFormatter, self).get_field(field_name, args, kwargs)
            except (IndexError, KeyError, AttributeError):
                first, rest = formatter_field_name_split(field_name)
                obj = '{' + field_name + '}'

                # loop through the rest of the field_name, doing
                #  getattr or getitem as needed
                for is_attr, i in rest:
                    if is_attr:
                        try:
                            obj = getattr(obj, i)
                        except AttributeError as exc:
                            pass
                    else:
                        obj = obj[i]

            return obj, first

    fmttr = string.Formatter()
    fs, _ = fmttr._vformat(s, ("{}",), FormatDict(**kwargs), set(), recursionlimit)
    return fs

class ColorObj(object):
    blue = "^BLUE^"
s = '{"a": {"b": {"c": {"d" : {} {foo:&lt;12} &amp; {foo!r} {arg} {color.blue:&lt;10} {color.pink} {blah.atr} }}}}'
print(partialformat(s, foo="Fooolery", arg="ARRrrrrrg!", color=ColorObj))
</code></pre>
<p>output:</p>
<pre class="lang-none prettyprint-override"><code>{"a": {"b": {"c": {"d" : {} Fooolery             &amp; 'Fooolery' Fooolery ARRrrrrrg! ^BLUE^ {color.pink} {blah.atr} }}}}
</code></pre>
</div>
<span class="comment-copy">Which one do you want <code>bond,  bond</code> / <code>bond, {james}, bond</code>?</span>
<span class="comment-copy">The second one is better I think. First one can create weird content.. second one makes people think "hey, something is wrong over here" which in this case in a good thing</span>
<span class="comment-copy">I updated the answer for both case.</span>
<span class="comment-copy"><a href="https://stackoverflow.com/questions/5466451/how-can-i-print-literal-curly-brace-characters-in-python-string-and-also-use-fo" title="how can i print literal curly brace characters in python string and also use fo">stackoverflow.com/questions/5466451/…</a></span>
<span class="comment-copy"><b>See also:</b> <a href="https://stackoverflow.com/questions/35574349/python-format-string-with-custom-delimiters" title="python format string with custom delimiters">stackoverflow.com/questions/35574349/…</a></span>
<span class="comment-copy">I'm using 2.7.. thanks! I'm going to test this</span>
<span class="comment-copy">Great! Accepted!</span>
<span class="comment-copy">Oddly enough, in python3 <code>format</code> gives the same result as <code>format_map</code> in this example.</span>
<span class="comment-copy">@frnhr, What do you mean? <code>'{bond}, {james} {bond}'.format(defaultdict(str, bond='bond'))</code> gives me <code>KeyError</code>.</span>
<span class="comment-copy">Here it is: <code>'{bond}, {james} {bond}'.format(**SafeDict(bond='bond'))</code> returns <code>'bond, {james} bond'</code>. Note the <code>**</code>. I actually didn't notice it until now :)  Python 3.4.3</span>
<span class="comment-copy">Out of the answers provided here I think this is the best in terms of portability/elegance +1</span>
<span class="comment-copy">I think <code>Formatter.get_value(key, args, kwds)</code> <b>should be</b> <code>return string.Formatter.get_value(self, key, args, kwds)</code> in your code</span>
<span class="comment-copy">@GrijeshChauhan I’m not sure… The function is called recursively, the only real return takes place in the last, terminal, call so… Anyway I did not manage to get it working. I finished with a simpler code, which do what I want.      class URLFormatter(string.Formatter):     def __init__(self, default='{}'):         self.default=default     def get_value(self, key, args, kwds):         return kwds.get(key, self.default.format(key))</span>
<span class="comment-copy">Some may balk at the usage of <code>_formatter_parser</code>, but to me this is the most pythonic approach: simple, easy to comprehend, uses out-of-the-box functionality, and if you modify the second line to <code>d = dict((x[1], '{'+str(x[1])+'}') for x in action._formatter_parser())</code> you can get the <code>bond, {james} bond</code> format just as easily as the <code>bond,  bond</code> format.</span>
<span class="comment-copy">The way the code goes through the format templates replacing resolved ones is a big buggy now.</span>
<span class="comment-copy">Unfortunately, this won't handle the string case of <code>"{a:&lt;10}"</code>.</span>
