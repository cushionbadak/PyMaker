<div class="post-text" itemprop="text">
<p>I made a little generator function for character ranges:</p>
<pre><code>&gt;&gt;&gt; def crange(start, end):
...     for i in range(ord(start), ord(end)+1):
...             yield chr(i)
...
</code></pre>
<p>And then I can do this:</p>
<pre><code>&gt;&gt;&gt; print(*crange('a','e'))
a b c d e
</code></pre>
<p>Yay! But this doesn't work:</p>
<pre><code>&gt;&gt;&gt; crange('a','e')[::2]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'generator' object is not subscriptable
</code></pre>
<p>And this works, but is O(n), unlike <code>range</code>'s O(1):</p>
<pre><code>&gt;&gt;&gt; 'y' in crange('a','z')
True
</code></pre>
<p>That means it takes about 0.35 seconds to search for character number 109,999 out of the maximum of 110,000. <code>109999 in range(110000)</code> is, of course, fast.</p>
<p>At that point, my first thought was to simply subclass range. Unfortunately:</p>
<pre><code>&gt;&gt;&gt; class A(range):
...     pass
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: type 'range' is not an acceptable base type
</code></pre>
<p>So I guess I would have to mimic it in some way that allows me to pass characters as arguments, works like <code>range</code> internally, and produces characters. Unfortunately, I'm not sure how to proceed. I tried a <code>dir()</code>:</p>
<pre><code>&gt;&gt;&gt; print(*dir(range), sep='\n')
__class__
__contains__
__delattr__
__dir__
__doc__
__eq__
__format__
__ge__
__getattribute__
__getitem__
__gt__
__hash__
__init__
__iter__
__le__
__len__
__lt__
__ne__
__new__
__reduce__
__reduce_ex__
__repr__
__reversed__
__setattr__
__sizeof__
__str__
__subclasshook__
count
index
start
step
stop
</code></pre>
<p>which lets me see what functions are in there, but I'm not sure what they're doing, or how <code>range</code> uses them. I looked for the source for <code>range</code>, but it's in C, and I don't know where to find its Python wrapper (it does have one, right?).</p>
<p>Where do I go from here, and should I even go there?</p>
</div>
<div class="post-text" itemprop="text">
<p>To add to Martin Konecny's answer. You probably want to use an internal range for everything and convert between chr and ord.</p>
<pre><code>class crange:
    def __init__(self, *args, **kwargs):
        args = [ord(arg) for arg in args]
        kwargs = {key: ord(val) for key, val in kwargs.items()}
        self.range = range(*args, **kwargs)

    def __iter__(self):
        for n in self.range:
            yield chr(n)

    def __contains__(self, c):
        return ord(c) in self.range

    def __getitem__(self, i):
        if isinstance(i, slice):
            ret = crange('\x00')
            ret.range = self.range[i]
            return ret
        else:
            return chr(self.range[i])

    def __repr__(self):
        return  "crange({}, {})".format(
            repr(chr(self.range.start)), repr(chr(self.range.stop)))

r = crange('a', 'f')
print(list(r))
print('b' in r)
print('f' in r)
print(r[:2])
</code></pre>
<p>In other words: if we can't subclass it we can use <a href="https://en.wikipedia.org/wiki/Object_composition#Aggregation" rel="noreferrer">object composition</a>.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>At that point, my first thought was to simply subclass range. </p>
</blockquote>
<p><code>range</code> was a function in Python2 and a "final" class in Python3 (<a href="https://stackoverflow.com/a/10114382/276949">more info here</a>) - in both cases not something you can sub-class. You will need to create a class <code>crange</code> that extends from an <code>object</code> as the base type. </p>
<pre><code>class crange(object):
</code></pre>
<blockquote>
<p>And this works, but is O(n), unlike range's O(1)</p>
</blockquote>
<p>In Python 3, there is a <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow noreferrer"><code>__contains__</code></a> method that you will define for your object.</p>
<blockquote>
<p>For objects that don’t define <code>__contains__()</code>, the membership test first tries iteration via <code>__iter__()</code>, then the old sequence iteration protocol via <code>__getitem__()</code>, see this section in the language reference.</p>
</blockquote>
<p>This allows Python to determine if the value is in your range without actually enumerating the range.</p>
<p>For a simple example, if your range is 1 to 1,000,000, it is trivial to determine whether 23546 is in that range (<code>1 &lt; 23546 &lt; 1000000</code>). Of course the actual implementation is a bit more complex and adds ability to handle step increments etc. </p>
<p>Regarding:</p>
<blockquote>
<p>Yay! But this doesn't work: <code>&gt;&gt;&gt; crange('a','e')[::2]</code></p>
</blockquote>
<p>In this case you need to define <code>__getitem__</code> on your object. Here's an example of some of the methods required:</p>
<pre><code>class crange(object):
    def __init__(self, start, end, step=1):
        # initialize your range object
        self.start = start
        self.end = end
        self.step = step

    def __iter__(self):
        # enable iteration over your object
        # (assume step size is 1)
        for i in range(ord(self.start), ord(self.end)+1):
            yield chr(i)

    def __getitem__(self, i):
        # enable accessing items in your range by index
        # also enable crange('a','e')[::2]
        # (assuming step size of 1)
        if isinstance( i, slice ):
            # implement slicing 
        else:
            return chr(ord(self.start) + i)

    def __contains__(self, char):
        # enable O(1) determination of whether a value is in your range
        # (assume step size is 1)
        return ord(self.start) &lt;= ord(char) &lt; ord(self.end)

    def __len__(self):
        # return length (assuming step size of 1)
        return ord(self.end) - ord(self.start)
</code></pre>
</div>
<span class="comment-copy">"but it's in C, and I don't know where to find its Python wrapper (it does have one, right?)" - nope. Like <code>list</code> or <code>dict</code>, no part of <code>range</code> is written in Python.</span>
<span class="comment-copy">About the class, perhaps <code>class A(object, range):</code></span>
<span class="comment-copy">While this might seem like an interesting question, I'm voting to close it as too broad. There's no good way to do this except by going through <code>range</code>'s entire API and replicating it, so answers would have to describe everything <code>range</code> does, all the hooks used to customize <code>len</code> and slicing and everything, and they'd take like 10 pages. I recommend googling the method names and looking through the <a href="https://docs.python.org/3/reference/datamodel.html" rel="nofollow noreferrer">Python data model</a>.</span>
<span class="comment-copy">alternative to existing version: <code>def crange(start, end): return map(chr, range(ord(start), ord(end)))</code></span>
<span class="comment-copy">I would have to disagree that it's too broad.  The OP already has a core method, what he needs to do is implement a lazy list, which is essentially how <code>range()</code> functions.  Once he has done that, he can work to implement the remainder of the range API and ask specific questions regarding them.  The OP may want to take a look at the <a href="https://pypi.python.org/pypi/lazyarray" rel="nofollow noreferrer"><code>lazyarray</code></a> module on PyPi to start with.  I would strongly suggest that the OP narrow his question down to lazy list implementation as quickly as possible to avoid being closed.</span>
<span class="comment-copy">I was about to ask if it would be a good idea to use a <code>range</code> object internally... :)</span>
<span class="comment-copy"><code>self.range.__contains__(ord(c))</code> → <code>ord(c) in self.range</code>; <code>self.range.__getitem__(i)</code>→ <code>self.range[i]</code>, <code>('crange('+repr(chr(self.range.start))+', '+ repr(chr(self.range.stop))+')')</code> → <code>"crange({}, {})".format(self.range.start, self.range.stop)</code>.</span>
<span class="comment-copy">Suggested changes made, thanks. Got myself stuck on using the method name for symmetry. repr was a mess, no excuse :(.</span>
<span class="comment-copy">If I remember, correctly, <code>__contains__()</code> is implemented in <code>range()</code> as: <code>if step == 1:  return start &lt;= num &lt; end</code> / <code>else: return start &lt;= num &lt; end and not (num - start) % step</code> (not sure why I know that).  The analogous function for <code>crange()</code> would be: <code>if step == 1: return ord(start) &lt;= ord(c) &lt; ord(end)</code> / <code>else: return ord(start) &lt;= ord(c) &lt; ord(end) and not (ord(c) - ord(start)) % step</code>.</span>
<span class="comment-copy">@DougR.thx I filled in some of the methods, and used your <code>__contains__()</code> method</span>
<span class="comment-copy">Glad to be of help.  Sorry it took me three times to get the whole thing right.  This is the kind of problem I like to see here on SO.</span>
<span class="comment-copy">Your <code>__getitem__()</code> function appears to ignore the step.  I.e., if we did <code>my_crange = crange('a', 'm', 3)</code>, <code>my_crange[1] == 'd'</code>.  Your <code>__getitem__()</code> would return 'b'.  I think it should be <code>return chr(ord(self.start) + i * step)</code></span>
<span class="comment-copy">...and I can't believe I made such a rookie mistake.  Looking back on my return value for <code>__contains__()</code>, no need to do an <code>if/else...</code>.  <code>n % 1 == 0</code> for any integer.</span>
