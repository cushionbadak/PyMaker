<div class="post-text" itemprop="text">
<p>How could dictionaries whose values are lists be merged in Python, so that all of the keys are moved into one dictionary, and all the elements of each list moved into a single list for each key?</p>
<p>For example, with these dictionaries:</p>
<pre><code>x = {'a': [2], 'b': [2]}
y = {'b': [11], 'c': [11]}
</code></pre>
<p>... the result of the merging should be like this:</p>
<pre><code>{'a': [2], 'b': [2, 11], 'c': [11]}
</code></pre>
<p>How could this be done with any number of dictionaries, not just two?</p>
</div>
<div class="post-text" itemprop="text">
<p>To collect all the lists together, form a <em>result</em> dictionary that maps your keys to lists.  The simplest way to do this is with <a href="https://docs.python.org/2.7/library/stdtypes.html#dict.setdefault" rel="nofollow"><em>dict.setdefault()</em></a> followed by a call to <a href="https://docs.python.org/2.7/library/stdtypes.html#mutable-sequence-types" rel="nofollow"><em>list.extend</em></a> to grow the lists:</p>
<pre><code>r = {}
for d in [x, y]:
    for k, v in d.items():
        r.setdefault(k, []).extend(v)
</code></pre>
<p>A little more elegant way is with <a href="https://docs.python.org/2.7/library/collections.html#collections.defaultdict" rel="nofollow"><em>collections.defaultdict()</em></a> where the automatic default is a new empty list:</p>
<pre><code>from collections import defaultdict

r = defaultdict(list)
for d in [x, y]:
    for k, v in d.items():
        r[k].extend(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>for k, v in y.items():
    x.setdefault(k, []).extend(v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use following approach, which uses <code>sets</code> and <code>dict comprehension</code></p>
<pre><code>x = {'a': [2], 'b': [2]} 
y = {'b': [11], 'c': [11]}

all_keys = set(x) | set(y)

print {k:x.get(k, [])+y.get(k, []) for k in all_keys}
</code></pre>
<p>Results:</p>
<pre><code>{'a': [2], 'c': [11], 'b': [2, 11]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution that works for an arbitrary number of dictionaries:</p>
<pre><code>def collect(*dicts):
    result = {}
    for key in set.union(*(set(d) for d in dicts)):
        result[key] = sum((d.get(key, []) for d in dicts), [])
    return result
</code></pre>
<p>It's essentially a generalisation of Tanveer's answer, taking advantage of the fact that <a href="https://docs.python.org/3/library/stdtypes.html#set.union" rel="nofollow"><code>set.union()</code></a> can accept any number of dictionaries as arguments.</p>
<p>Here's an example of the function in use:</p>
<pre><code>&gt;&gt;&gt; x = {'a': [2], 'b': [2]}
&gt;&gt;&gt; y = {'b': [11], 'c': [11]}
&gt;&gt;&gt; collect(x, y)
{'a': [2], 'c': [11], 'b': [2, 11]}
</code></pre>
<p>... and with multiple dictionaries:</p>
<pre><code>&gt;&gt;&gt; z = {'c': [12, 13], 'd': [5]}
&gt;&gt;&gt; collect(x, y, z)
{'a': [2], 'c': [11, 12, 13], 'b': [2, 11], 'd': [5]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><div class="snippet" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>x = {'a': [2], 'b': [2]}
y = {'b': [11], 'c': [11]}
result = {}
for key,value in x.iteritems():
    result[key] = value
for key,value in y.iteritems():
    if key in result:
        for l in value:
            result[key].append(l)
    else:
        result[key] = value
print result</code></pre>
</div>
</div>
</p>
</div>
<span class="comment-copy"><code>all_keys = set(x) | set(y)</code> would work in both 2 and 3.</span>
<span class="comment-copy">Thanks @DSM Plus I even don't like <code>.keys()</code> method.</span>
<span class="comment-copy">@DSM  Missed that  :)</span>
<span class="comment-copy">Why not just get rid of all_keys? The expression is short/easy enough to just put in the comprehension directly.</span>
<span class="comment-copy">@StefanPochmann: ehh, not worth worrying about.  Plus if we wanted to do the generalized version (with an arbitrary number of dicts) it would be clearer to work with separate variables anyhow.</span>
