<div class="post-text" itemprop="text">
<p>I am reading about classes in Python (3.4) and from what I understand it seems that every new object has its own bound methods instances.</p>
<pre><code>class A:

    def __init__(self, name):
        self.name = name

    def foo(self):
        print(self.name)

a = A('One')
b = A('Two')

print(a.foo ==  b.foo)
</code></pre>
<p>The output of this is <code>False</code>.</p>
<p>This seems to me as a waste of memory. I thought that internally <code>a.foo</code> and <code>b.foo</code> would point somehow internally to one function in memory: <code>A.foo</code> where <code>self</code> as the class instance will be passed. </p>
<p>I assume this maybe cannot be implemented easily in the language.</p>
<p>Does each new instance contain also new instances of its bound methods?</p>
<p>If so, does not this hurt the performance or make case for creating new objects more cautiously than in other languages where methods are "shared" among objects like in Java?</p>
</div>
<div class="post-text" itemprop="text">
<p>Methods are bound <em>on demand</em>, each time you access one.</p>
<p>Accessing the name of a function invokes the <a href="https://docs.python.org/3/howto/descriptor.html">descriptor protocol</a>, which on function objects returns a bound method.</p>
<p>A bound method is a thin wrapper around a function object; it stores a reference to the original function and to the instance. When calling a method object, it in turn passes the call to the function, with instance inserted as a first argument.</p>
<p>Methods are not created when the instance is created, so there is no extra memory required a-priori.</p>
<p>You can re-create the steps manually:</p>
<pre><code>&gt;&gt;&gt; class A:
...     def __init__(self, name):
...         self.name = name
...     def foo(self):
...         print(self.name)
... 
&gt;&gt;&gt; a = A('One')
&gt;&gt;&gt; a.foo
&lt;bound method A.foo of &lt;__main__.A object at 0x100a27978&gt;&gt;
&gt;&gt;&gt; a.foo.__self__
&lt;__main__.A object at 0x100a27978&gt;
&gt;&gt;&gt; a.foo.__func__
&lt;function A.foo at 0x100a22598&gt;
&gt;&gt;&gt; A.__dict__['foo']
&lt;function A.foo at 0x100a22598&gt;
&gt;&gt;&gt; A.__dict__['foo'].__get__(a, A)
&lt;bound method A.foo of &lt;__main__.A object at 0x100a27978&gt;&gt;
&gt;&gt;&gt; A.__dict__['foo'].__get__(a, A)()
One
</code></pre>
<p>It is only the method object that is recreated each time; the underlying function remains stable:</p>
<pre><code>&gt;&gt;&gt; a.foo is a.foo
False
&gt;&gt;&gt; b = A('Two')
&gt;&gt;&gt; b.foo is a.foo
False
&gt;&gt;&gt; b.foo.__func__ is a.foo.__func__
True
</code></pre>
<p>This architecture also makes <a href="https://docs.python.org/3/library/functions.html#classmethod"><code>classmethod</code></a>, <a href="https://docs.python.org/3/library/functions.html#staticmethod"><code>staticmethod</code></a>, and <a href="https://docs.python.org/3/library/functions.html#property"><code>property</code></a> objects work. You can create your own descriptors, creating a whole host of interesting binding behaviours.</p>
</div>
<span class="comment-copy">Can you link to something you read that makes you think that?</span>
<span class="comment-copy">@SotiriosDelimanolis <code>X().f == X.f</code> will result in <code>False</code> (where f is an instace method). This is enough to make one think like that.</span>
<span class="comment-copy">Each bound method, though, references the same underlying function. The memory overhead for the wrappers is minimal.</span>
<span class="comment-copy">It's your answer here, too, so you get the rep you clearly don't need more of either way ;o)</span>
<span class="comment-copy">@jonrsharpe: hah, but this one is already accepted! :-P I didn't fully re-read the question here; in retrospect both question and answer are a perfect duplicate. I had the impression there was more to explain on the other post.</span>
