<div class="post-text" itemprop="text">
<p>I received this exercise:</p>
<blockquote>
<p>Write a function <code>enumerate</code> that takes a list and returns a list of
  tuples containing <code>(index,item)</code> for each item in the list</p>
</blockquote>
<p>My problem is that I cannot insert the index and value in one or a combination of <code>for</code> loops. This is the code I managed to make:</p>
<pre><code>a = ["a", "b", "c","a","b","c"]
index = 0
for i in a:
    print (index,i)
    index+=1
</code></pre>
<p>This is roughly the code I want to produce (must be on one line):</p>
<pre><code>my_enumerate = lambda x :[(t) for t in x )]
print list(my_enumerate(range(4)))
</code></pre>
<p>How can I put it all one <code>lambda</code> line to get <code>(value, index)</code> back? The output should look like:</p>
<pre><code>[(0, "a"), (1, "b"), (2, "c")]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you can actually index just add the value by indexing:</p>
<pre><code>my_enumerate = lambda x :[(t, x[t]) for t in range(len(x))]
print list(my_enumerate(a))
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'a'), (4, 'b'), (5, 'c')]
</code></pre>
<p>If not  use zip and put range in the lambda:</p>
<pre><code>my_enumerate = lambda x: zip(range(len(x), x))
print list(my_enumerate(a))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>my_enumerate = lambda x: [(i, x[i]) for i in xrange(len(x))]
a = ["a", "b", "c", "a", "b", "c"]
print my_enumerate(a)
</code></pre>
<p>outputs:</p>
<pre><code>[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'a'), (4, 'b'), (5, 'c')]
</code></pre>
<p>EDIT: use <code>range</code> instead of <code>xrange</code> and <code>print(...)</code> instead of <code>print</code> if you are using python3</p>
</div>
<div class="post-text" itemprop="text">
<p>Python's <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> and <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow"><code>range</code></a> functions solve this problem pretty handily.</p>
<pre><code>my_enumerate = lambda seq: zip(range(len(seq)), seq)
</code></pre>
<p>In Python 2.x, you should use <a href="https://docs.python.org/2/library/itertools.html#itertools.izip" rel="nofollow"><code>itertools.izip</code></a>, and <a href="https://docs.python.org/2/library/functions.html#xrange" rel="nofollow"><code>xrange</code></a> instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could also do it recursively:</p>
<pre><code>&gt;&gt;&gt; myenumerate = lambda l, n=0: [] if not l else (lambda ll = list(l): [(n, ll.pop(0))] + myenumerate(ll, n+1)()
</code></pre>
<p><code>list.pop(n)</code> returns the <code>n</code>th  value form the list, and returns it.</p>
<p>The only problem is that you <em>must</em> pass in a list:</p>
<pre><code>&gt;&gt;&gt; myenumerate([1,2,3,4,5,6,7,8])
[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)]
&gt;&gt;&gt; myenumerate("astring")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in &lt;lambda&gt;
AttributeError: 'str' object has no attribute 'pop'
&gt;&gt;&gt; myenumerate(list("astring"))
[(0, 'a'), (1, 's'), (2, 't'), (3, 'r'), (4, 'i'), (5, 'n'), (6, 'g')]
</code></pre>
<p>However, if you just blindly added calls to <code>list</code>, you would't be able to replicate the functionality required without using a slice.</p>
<p>A neat trick for bypassing this requirement is to use another lambda:</p>
<pre><code>&gt;&gt;&gt; myenumerate = lambda l, n=0: [] if not l else (lambda ll: [(n, ll.pop(0))] + myenumerate(ll, n+1))(list(l))

&gt;&gt;&gt; myenumerate("astring")
[(0, 'a'), (1, 's'), (2, 't'), (3, 'r'), (4, 'i'), (5, 'n'), (6, 'g')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>[(i,a[i])for i in range(len(a))]
</code></pre>
</div>
<span class="comment-copy">looks like it should return a dictionary with index as key.</span>
<span class="comment-copy">Am I missing something or are you trying to reinvent the <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate()</code> function</a>?</span>
<span class="comment-copy">you donwt missing</span>
<span class="comment-copy">Or, if it has to be a lambda: <code>my_enumerate = lambda L: list(ind,item for ind,item in enumerate(L))</code></span>
<span class="comment-copy">Your two examples seem quite different - the first expects the length of the list (and the list itself should also be in scope) and the second the list itself. Why not <code>lambda a: [(t, a[t]) for t in range(len(a))]</code>?</span>
<span class="comment-copy">@jonrsharpe, pasted the wrong  code. Actually irrelevant as the OP cannot index</span>
<span class="comment-copy">I read that as meaning that they were unable to do so, rather than prohibited from it; you may well be right.</span>
<span class="comment-copy">Thank you so much , i don't understand how i didn't see it my self....</span>
<span class="comment-copy">@H_meir, I thought you said you cannot index?</span>
