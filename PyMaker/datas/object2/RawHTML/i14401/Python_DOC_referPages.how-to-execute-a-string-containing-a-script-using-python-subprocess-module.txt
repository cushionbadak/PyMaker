<div class="post-text" itemprop="text">
<p>I receive a script in a string and trying to find a way to execute it using the subprocess module of python. e.g.</p>
<pre><code>import subprocess
script = """#!/usr/bin/python
            print "inside script"
         """
subprocess.Popen(script)
</code></pre>
<p>This throws an OSError: saying there is no such file or directory, which is fair enough as I think its trying to look for command name.</p>
<p>I then tried <code>subprocess.Popen(script, shell=True)</code> which works only for shell commands and totally ignores the #! at the top of the script. Is there any way to make suprocess run my script stored in string like its an executable file ?</p>
</div>
<div class="post-text" itemprop="text">
<p>This solution is based on <code>-c</code> (compile) Python interpreter cmdline argument. It ignores using shell properties entirely.</p>
<p>Popen may be created in similar way. <code>subprocess.call</code> was used to show that script is in fact executed, and python interpreter return code is changed by code executed.</p>
<pre><code>import subprocess

executable_code = """
print 'inside script'
print 123
"""

code_with_exception = """
raise Exception()
"""

ok_rc = subprocess.call(['python', '-c', executable_code])
assert ok_rc == 0

bad_rc = subprocess.call(['python', '-c', code_with_exception])
assert bad_rc == 1
</code></pre>
<p>Additional improvement would be to skip 'python' hardcoded string and use <a href="https://docs.python.org/2/library/sys.html#sys.executable" rel="nofollow"><code>sys.executable</code></a>.</p>
<blockquote>
<p>A string giving the absolute path of the executable binary for the Python interpreter, on systems where this makes sense. If Python is
  unable to retrieve the real path to its executable, sys.executable
  will be an empty string or None.</p>
</blockquote>
<pre><code>import sys
import subprocesss
code = "raise Exception()"
bad_rc = subprocess.call([sys.executable, '-c', code])
assert bad_rc == 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As you can read in the <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow">Popen Python Documentation</a> the parameter to <code>Popen</code> is an executable to launch, not the contents of some script to perform. You cannot use <code>Popen</code> in this manner.</p>
<p>If you really want to you could write the script to a file and then pass that filename to Popen, but that doesn't seem to be an elegant solution to whatever your problem is.</p>
<p>Seeing as all you want is simply to execute some Python code from a string, you'll want to use the <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow">exec builtin function</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can run scripts by pumping them into a child python's <code>stdin</code>. This may be a preferred solution to larger scripts:</p>
<pre><code>import sys
import subprocess as subp
import shutil

script = """\
import sys
print "hello", sys.argv
"""

p = subp.Popen([sys.executable, '-', 'arg1', 'arg2'], stdin=subp.PIPE)
p.stdin.write(script)
p.stdin.close()
p.wait()
</code></pre>
<p>I use this trick across <code>ssh</code> connections to control remote servers.</p>
</div>
<div class="post-text" itemprop="text">
<p>To execute a string as a Python script using <code>subprocess</code> module:</p>
<pre><code>&gt;&gt;&gt; import subprocess, sys, textwrap
&gt;&gt;&gt; subprocess.call(textwrap.dedent('''
...    print "Hello, world!"
... '''), shell=True, executable=sys.executable)
Hello, world!
0
</code></pre>
<p>Though as <a href="https://stackoverflow.com/a/30332828/4279">@wich suggested</a> you could use <a href="https://docs.python.org/3/library/functions.html#exec" rel="nofollow noreferrer">Python builtin function <code>exec()</code></a> -- it is a statement on Python 2:</p>
<pre><code>&gt;&gt;&gt; exec 'print "Hello, exec!"'
Hello, exec!
</code></pre>
<p>If you want to run Python code in a different process, you could use <a href="https://docs.python.org/3/library/multiprocessing.html" rel="nofollow noreferrer"><code>multiprocessing</code></a> or <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow noreferrer"><code>concurrent.futures</code> modules</a>:</p>
<pre><code>#!/urs/bin/env python2
from multiprocessing import Process, freeze_support

def run(code):
    exec code # Python 2

if __name__ == "__main__":
    freeze_support()
    Process(target=run, args=['print "Hello, multiprocessing"']).start()
</code></pre>
</div>
<span class="comment-copy">save the string into a file and then execute the actual script?</span>
<span class="comment-copy">Yeah, thats my last resort. Was hoping that I might have missed something and there is some other subprocess magic which can make this happen.</span>
<span class="comment-copy">What are you trying to achive?</span>
<span class="comment-copy">I am trying to mock some external process for testing. Somebody can pass a script in a string to my mocking function and I can execute that string instead of the actual process. For example someone can say mock git as sleep(60).</span>
<span class="comment-copy">This might work.</span>
<span class="comment-copy">This is awesome, thanks.</span>
<span class="comment-copy">you could use <code>p.communicate(script)</code> instead of the last 3 lines.</span>
<span class="comment-copy">@J.F.Sebastian is absolutely right. The important thing is that the pipe is closed which python sees as an EOF and executes the script.</span>
