<div class="post-text" itemprop="text">
<p>I am looking to count the number of times the values in an array change in polarity (EDIT: Number of times the values in an array cross zero). </p>
<p>Suppose I have an array:</p>
<pre><code>[80.6  120.8  -115.6  -76.1  131.3  105.1  138.4  -81.3
 -95.3  89.2  -154.1  121.4  -85.1  96.8  68.2]`
</code></pre>
<p>I want the count to be 8. </p>
<p>One solution is to run a loop and check for greater than or less than 0, and keep a history of the previous polarity. </p>
<p>Can we do this faster?</p>
<p>EDIT: My purpose is really to find something faster, because I have these arrays of length around 68554308, and I have to do these calculations on 100+ such arrays. </p>
</div>
<div class="post-text" itemprop="text">
<p>This produces the same result:</p>
<pre><code>import numpy as np
my_array = np.array([80.6, 120.8, -115.6, -76.1, 131.3, 105.1, 138.4, -81.3, -95.3,  
                     89.2, -154.1, 121.4, -85.1, 96.8, 68.2])
((my_array[:-1] * my_array[1:]) &lt; 0).sum()
</code></pre>
<p>gives:</p>
<pre><code>8
</code></pre>
<p>and seems to be the fastest solution:</p>
<pre><code>%timeit ((my_array[:-1] * my_array[1:]) &lt; 0).sum()
100000 loops, best of 3: 11.6 µs per loop
</code></pre>
<p>Compared to the fastest so far:</p>
<pre><code>%timeit (np.diff(np.sign(my_array)) != 0).sum()
10000 loops, best of 3: 22.2 µs per loop
</code></pre>
<p>Also for larger arrays:</p>
<pre><code>big = np.random.randint(-10, 10, size=10000000)
</code></pre>
<p>this:</p>
<pre><code>%timeit ((big[:-1] * big[1:]) &lt; 0).sum()
10 loops, best of 3: 62.1 ms per loop
</code></pre>
<p>vs:</p>
<pre><code>%timeit (np.diff(np.sign(big)) != 0).sum()
1 loops, best of 3: 97.6 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a <code>numpy</code> solution. Numpy's methods are generally pretty fast and well-optimized, but if you're not already working with <code>numpy</code> there's probably some overhead from converting the list to a <code>numpy</code> array:</p>
<pre><code>import numpy as np
my_list = [80.6, 120.8, -115.6, -76.1, 131.3, 105.1, 138.4, -81.3, -95.3,  89.2, -154.1, 121.4, -85.1, 96.8, 68.2]
(np.diff(np.sign(my_list)) != 0).sum()
Out[8]: 8
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Based on <a href="https://stackoverflow.com/a/30272583/471899">Scott's answer</a></p>
<p>The generator expression proposed by Scott uses <code>enumerate</code> which returns tuples containing index and list item. List item are not used in the expression at all and discarded later. So better solution in terms of time would be</p>
<pre><code>sum(1 for i in range(1, len(a)) if a[i-1]*a[i]&lt;0)
</code></pre>
<p>If your list <code>a</code> is really huge, <a href="https://docs.python.org/3/library/functions.html#func-range" rel="nofollow noreferrer"><code>range</code></a> may throw an exception. You can replace it with <code>itertools.islice</code> and <code>itertools.count</code>.</p>
<p>In Python version 2.x, use <a href="https://docs.python.org/2/library/functions.html#xrange" rel="nofollow noreferrer"><code>xrange</code></a> instead of Python 3's <code>range</code>.
In Python 3, <code>xrange</code> is no longer available.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think a loop is a straight forward way to go:</p>
<pre><code>a = [80.6, 120.8, -115.6, -76.1, 131.3, 105.1, 138.4, -81.3, -95.3, 89.2, -154.1, 121.4, -85.1, 96.8, 68.2]

def change_sign(v1, v2):
    return v1 * v2 &lt; 0

s = 0
for ind, _ in enumerate(a):
    if ind+1 &lt; len(a):
        if change_sign(a[ind], a[ind+1]):
            s += 1
print s  # prints 8
</code></pre>
<p>You could use a generator expression but it gets ugly:</p>
<pre><code>z_cross = sum(1 for ind, val in enumerate(a) if (ind+1 &lt; len(a)) 
              if change_sign(a[ind], a[ind+1]))
print z_cross  # prints 8
</code></pre>
<p><strong>EDIT:</strong></p>
<p>@Alik pointed out that for huge lists the best option in space and time (at least out of the solutions we have considered) is not to call <code>change_sign</code> in the generator expression but to simply do:</p>
<pre><code>z_cross = sum(1 for i, _ in enumerate(a) if (i+1 &lt; len(a)) if a[i]*a[i+1]&lt;0)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Seems like, you want to group numbers by their sign. This could be done using built-in method <code>groupby</code>:</p>
<pre><code>In [2]: l = [80.6,  120.8,  -115.6,  -76.1,  131.3,  105.1,  138.4,  -81.3, -95.3,  89.2,  -154.1,  121.4,  -85.1,  96.8,  68.2]

In [3]: from itertools import groupby

In [5]: list(groupby(l, lambda x: x &lt; 0))
Out[5]: 
[(False, &lt;itertools._grouper at 0x7fc9022095f8&gt;),
 (True, &lt;itertools._grouper at 0x7fc902209828&gt;),
 (False, &lt;itertools._grouper at 0x7fc902209550&gt;),
 (True, &lt;itertools._grouper at 0x7fc902209e80&gt;),
 (False, &lt;itertools._grouper at 0x7fc902209198&gt;),
 (True, &lt;itertools._grouper at 0x7fc9022092e8&gt;),
 (False, &lt;itertools._grouper at 0x7fc902209240&gt;),
 (True, &lt;itertools._grouper at 0x7fc902209908&gt;),
 (False, &lt;itertools._grouper at 0x7fc9019a64e0&gt;)]
</code></pre>
<p>Then you should use function <code>len</code> which returns the number of groups:</p>
<pre><code>In [7]: len(list(groupby(l, lambda x: x &lt; 0)))
Out[7]: 9
</code></pre>
<p>Obviously, there will be at least one group (for a non-empty list), but if you want to count the number of points, where a sequence changes its polarity, you could just subtract one group. Do not forget about the empty-list case.</p>
<p>You should also take care about zero elements: shouldn't they be extracted into another group? If so, you could just change the <code>key</code> argument (lambda function) of <code>groupby</code> function. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can achieve it using list comprehension:</p>
<pre><code>myList = [80.6, 120.8, -115.6, -76.1, 131.3, 105.1, 138.4, -81.3, -95.3,  89.2, -154.1, 121.4, -85.1, 96.8, 68.2]
len([x for i, x in enumerate(myList) if i &gt; 0 and ((myList[i-1] &gt; 0 and myList[i] &lt; 0) or (myList[i-1] &lt; 0 and myList[i] &gt; 0))])
</code></pre>
</div>
<span class="comment-copy">what is polarity?</span>
<span class="comment-copy">Are you sure your expected count is 8, not 6?</span>
<span class="comment-copy">Ok, so you are looking for the number of zero crossings?</span>
<span class="comment-copy">You should consider parallelising your code: look at <code>multiprocessing.Pool.map_async</code>, <a href="https://github.com/pydata/numexpr" rel="nofollow noreferrer">github.com/pydata/numexpr</a> , PyCUDA, or MapReduce.</span>
<span class="comment-copy">Indeed! I have been experimenting with that. Seems so simple, I would have never attempted doing that multiplication, betting that it would be too costly. Definitely the best answer.</span>
<span class="comment-copy">Nice answer. Thanks for posting here.</span>
<span class="comment-copy">This won't account for a list like <code>[ 1,  2,  1,  0, -1, -2, -1,  0,  1,  0]</code>. Wouldn't we want to add: <code>... + (x == 0)</code>?</span>
<span class="comment-copy">This is crazy fast.  I ran this against my and @Alik solution and I get a different result using numpy.  Any idea why?  See <a href="http://stackoverflow.com/questions/30279315/different-results-to-counting-zero-crossings-of-a-large-sequence" title="different results to counting zero crossings of a large sequence">stackoverflow.com/questions/30279315/…</a>.</span>
<span class="comment-copy">This counts an extra crossing for each 0 in the input. I think that's fixed by doing the following: <code>(np.diff(np.sign(my_list)) != 0).sum() - (my_list == 0).sum()</code></span>
<span class="comment-copy">This <b>does not work when there is a zero</b> in the array! <code>[ 1, 2, 0, -1, 0, 0, -1, 2]</code> should yield <code>2</code> zero crossings, which it does not. Here is <a href="http://stackoverflow.com/a/40809378/2192488">a solution that handles zeros correctly</a>.</span>
<span class="comment-copy">Just a note: <code>v1</code> and <code>v2</code> have different signs if <code>v1*v2 &lt; 0</code>, so you can simplify your code a little bit</span>
<span class="comment-copy">I am not sure, I am used to testing signs with multiplication so for me it makes code more readable. Anyway you can always leave a comment about <code>change_sign</code> function</span>
<span class="comment-copy">It might be useful in your generator expression, but it will certainly require a comment. <code>z_cross = sum(1 for i, _ in enumerate(a) if (i+1 &lt; len(a)) if a[i]*a[i+1]&lt;0)</code>. Also note, that this is not a list comprehension, but  a <a href="https://www.python.org/dev/peps/pep-0289/#rationale" rel="nofollow noreferrer">generator expression</a>.</span>
<span class="comment-copy">@Scott, I hope there is something in scipy/numpy that is faster! Thank you for actively brainstorming. I will spend a few more minutes on this before selecting an answer.</span>
<span class="comment-copy">@Scott, did a few tests. Plain cycle seems to be the slowest solution, then goes your generator expression and <a href="http://stackoverflow.com/questions/30272538/python-code-for-counting-number-of-zero-crossings-in-an-array#comment48645217_30272583">modified generator expression</a> leads by 25%</span>
<span class="comment-copy">Very promising solution! Could this be faster than looping? I am running some tests.</span>
<span class="comment-copy">this is definitely a different approach, but using groupby and lambda will make more expensive than using a simple for loop..</span>
<span class="comment-copy">@RahulMurmuria, no, this can't be faster, than looping, but it is definitely more readable than regular loop-based solution. If you are talking about speed, you should also provide the worst case and expected time.</span>
<span class="comment-copy">on the first iteration aren't you comparing the last value in mylist with the first? i.e. when <code>i=0</code> you have <code>myList[-1]&gt;0 and myList[0]&lt;0...</code></span>
<span class="comment-copy">This could be bad say if the first value was -80.6, in our example we would expect 9 zero crossings, but your solution will give 10.</span>
<span class="comment-copy">Thanks Scott, it is true, I added a condition to fix that problem.</span>
