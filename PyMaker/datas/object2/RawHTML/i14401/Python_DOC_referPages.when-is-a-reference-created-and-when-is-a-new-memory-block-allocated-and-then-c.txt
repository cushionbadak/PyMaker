<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; d
{1: 1, 2: 2, 3: 3}
&gt;&gt;&gt; lst = [d, d]
&gt;&gt;&gt; c=lst[0]
&gt;&gt;&gt; c[1]=5
&gt;&gt;&gt; lst
[{1: 5, 2: 2, 3: 3}, {1: 5, 2: 2, 3: 3}]
</code></pre>
<p>When <code>lst = [d, d]</code>, are <code>lst[0]</code> and <code>lsg[1]</code> both references to the memory block of <code>d</code>, instead of creating two memory blocks and copy the content of <code>d</code> to them respectively?</p>
<p>When <code>c=lst[0]</code>, is <code>c</code> just a reference to the memory occupied by <code>lst[0]</code>, instead of creating a new memory block and copy the content from <code>lst[0]</code>? </p>
<p>In Python, when is a reference created to point to an existing memory block, and when is a new memory block allocated and then copy? </p>
<p>This language feature of Python is different from C. What is the name of this language feature?</p>
<p>Thanks.</p>
</div>
<div class="post-text" itemprop="text">
<p>All variables (and other containers, such as dictionaries, lists, and object attributes) hold references to objects. Memory allocation occurs when the object is instantiated. Simple assignment always creates another reference to the existing object. For example, if you have:</p>
<pre><code>a = [1, 2, 3]
b = a
</code></pre>
<p>Then <code>b</code> and <code>a</code> point to the same object, a list. You can verify this using the <code>is</code> operator:</p>
<pre><code>print(b is a)    # True
</code></pre>
<p>If you change <code>a</code>, then <code>b</code> changes too, because they are two names for the same object.</p>
<pre><code>a.append(4)
print(b[3] == 4)     # True
print(b[3] is a[3])  # also True
</code></pre>
<p>If you want to create a copy, you must do so explicitly. Here are some ways of doing this:</p>
<ul>
<li>For lists, use a slice: <code>b = a[:]</code>.</li>
<li>For many types, you can use the type name to copy an existing object of that type: <code>b = list(a)</code>. When creating your own classes, this is a good approach to take if you need copy functionality.</li>
<li>The <code>copy</code> module has methods that can be used to copy objects (either shallowly or deeply).</li>
</ul>
<p>For immutable types, such as strings, numbers, and tuples, there is never any need to make a copy. You can only "change" these kinds of values by referencing different ones.</p>
<p>The best way of describing this is probably "everything's an object." In C, "primitive" types like integers are treated differently from arrays. In Python, they are not: all values are stored as references to objects—even integers.</p>
</div>
<div class="post-text" itemprop="text">
<p>This paragraph from <a href="https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects" rel="nofollow">the Python tutorial</a> should help clear things up for you:</p>
<blockquote>
<p>Objects have individuality, and multiple names (in multiple scopes)
  can be bound to the same object. This is known as aliasing in other
  languages. This is usually not appreciated on a first glance at
  Python, and can be safely ignored when dealing with immutable basic
  types (numbers, strings, tuples). However, aliasing has a possibly
  surprising effect on the semantics of Python code involving mutable
  objects such as lists, dictionaries, and most other types. This is
  usually used to the benefit of the program, since aliases behave like
  pointers in some respects. For example, passing an object is cheap
  since only a pointer is passed by the implementation; and if a
  function modifies an object passed as an argument, the caller will see
  the change — this eliminates the need for two different argument
  passing mechanisms as in Pascal.</p>
</blockquote>
<hr/>
<p>To answer your individual questions in more detail:</p>
<p><strong><em>When lst = [d, d], are lst[0] and lst[1] both references to the memory block of d, instead of creating two memory blocks and copy the content of d to them respectively?</em></strong></p>
<p>No. They don't refer to the memory block of <code>d</code>. <code>lst[0]</code> and <code>lst[1]</code> are aliasing the same object as <code>d</code>, <em>at that point in time</em>. Proof: If you assign <code>d</code> to a new object after initializing the list, <code>lst[0]</code> and <code>lst[1]</code> will be unchanged. If you <em>mutate</em> the object aliased by <code>d</code>, then the mutation is visible <code>lst[0]</code> and <code>lst[1]</code>, because they alias the same object.</p>
<p><strong><em>When c=lst[0], is c just a reference to the memory occupied by lst[0], instead of creating a new memory block and copy the content from lst[0]?</em></strong></p>
<p>Again no. It's not a reference to the memory occupied by <code>lst[0]</code>. Proof: if you assign <code>lst[0]</code> to a new object, c will be unchanged. If you modify a mutable object (like the dictionary that <code>lst[0]</code> points to) you will see the change in <code>c</code>, because <code>c</code> is referring to the same object, the original dictionary.</p>
<p><strong><em>In Python, when is a reference created to point to an existing memory block, and when is a new memory block allocated and then copy?</em></strong></p>
<p>Python doesn't really work with "memory blocks" in the same way that C does. It is an abstraction away from that. Whenever you create a new object, and assign it to a variable, you've obviously got memory allocated for that object. But you will never work with that memory directly, you work with references to the objects in that memory.</p>
<p>Those references are the <em>values</em> that get assigned to symbolic names, AKA variables, AKA aliases. "pass-by-reference" is a concept from pointer-based languages like C and C++, and <em>does not apply</em> to Python. There is a <a href="http://stupidpythonideas.blogspot.com/2013/11/does-python-pass-by-value-or-by.html" rel="nofollow">blog post</a> which I believe covers this topic the best.</p>
<p>It is often argued whether Python is pass-by-value, pass-by-reference, or pass-by-object-reference. The truth is that it doesn't matter how you think of it, as long as you understand that the entire language specification is just an abstraction for working with names and objects. Java and Ruby have similar execution models, but the Java docs call it pass-by-value while the Ruby docs call it pass-by-reference. The Python docs remain neutral on the subject, so it's best not to speculate and just see things for what they are.</p>
<p><strong><em>This language feature of Python is different from C. What is the name of this language feature?</em></strong></p>
<p>Associating names with objects is known as name binding. Allowing multiple names (in potentially multiple scopes) to be bound to the same object is known as aliasing. You can read more about aliasing <a href="https://docs.python.org/3/tutorial/classes.html#a-word-about-names-and-objects" rel="nofollow">in the Python tutorial</a> and <a href="http://en.wikipedia.org/wiki/Aliasing_%28computing%29" rel="nofollow">on Wikipedia</a>.</p>
<p>It might also be helpful for you to read would be the <a href="https://docs.python.org/3/reference/executionmodel.html#execution-model" rel="nofollow">execution model documentation</a> where it talks about name binding and scopes in more detail.</p>
</div>
<div class="post-text" itemprop="text">
<p>In short; Python is pass-by-reference. Objects are created and memory allocated upon their construction. Referencing objects does not allocate more memory unless you are either creating new objects or expanding existing objects (<em><code>list.append()</code></em>)</p>
<p>This post <a href="http://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="nofollow">Is Python pass-by-reference or pass-by-value</a> covers it very well.</p>
<p>As a side note; if you are worried about how memory is allocated in a manage programming language like Python then you're probably using the wrong language and/or prematurely optimizing. Also how memory is managed in Python is implemtnation specific as there are many implementations of Python; CPython (<em>what you are probably using</em>); Jython, IronPython, PyPy, MicroPython, etc.</p>
</div>
<span class="comment-copy">This post <a href="http://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="nofollow noreferrer">Is Python pass-by-reference or pass-by-value</a> covers it very well.</span>
<span class="comment-copy">This depends on python implementation. Also memory allocation in interpreted language are usually not a concern for a user. If you really need to worry about how memory is managed, than python is probably the wrong tool for your task.</span>
