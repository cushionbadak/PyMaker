<div class="post-text" itemprop="text">
<p>If the input contains a space separated line of int, like-</p>
<pre><code>1 3
</code></pre>
<p>I can map store it in an array using the <code>map()</code> function</p>
<pre><code>arr = map(int,sys.stdin.readline().split())
</code></pre>
<p>or even in two separate variables, by</p>
<pre><code>n,m = map(int,sys.stdin.readline().split())
</code></pre>
<p>Is there any way to use the same way to read an input line that contains mixed data types. eg.-</p>
<pre><code>foo 3
</code></pre>
<p>where <code>foo</code> is a string and <code>3</code> is an integer?</p>
</div>
<div class="post-text" itemprop="text">
<p>If you always had a string and non negative int:</p>
<pre><code>import sys
n, m = map(lambda x: (str, int)[x.isdigit()](x) ,sys.stdin.readline().split(None, 1)) 


print(n,m)
</code></pre>
<p>But the safest way is always to use a try/except when casting user input even when only expecting one type. </p>
<p>As requested checking for negative is possible:</p>
<pre><code>import sys
n, m = map(lambda x: (str, int)[x.isdigit() or x.strip("-").isdigit()](x) ,sys.stdin.readline().split())


print(n, m)
</code></pre>
<p>But <code>--10</code> <code>--10--</code> would also be pass the test but cause an error so again only for your specific case.</p>
</div>
<div class="post-text" itemprop="text">
<p>To do that you should be able to discriminate between strings that can represent integers and strings that cannot. An example is:</p>
<pre><code>def foo(s):
    try:
        return int(s)
    except ValueError:
        return s
</code></pre>
<p>Then you can normally use <code>map</code>:</p>
<pre><code>map(foo, sys.stdin.readline().split())
</code></pre>
<p>The above line for input:</p>
<pre><code>abcdef 110
</code></pre>
<p>will print:</p>
<pre><code>['abcdef', 110]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/stdtypes.html#str.isdigit" rel="nofollow"><code>str.isdigit</code></a> to test whether the string can be cast to an integer number.</p>
<pre><code>&gt;&gt;&gt; inpt = "foo 3"
&gt;&gt;&gt; [int(s) if s.isdigit() else s for s in inpt.split()]
</code></pre>
<p>Of course, you can do the same using <code>map</code> and <code>sys.stdin.readline</code> using a <code>lambda</code></p>
<pre><code>&gt;&gt;&gt; map(lambda s: int(s) if s.isdigit() else s, sys.stdin.readline().split())
foo 4
['foo', 4]
</code></pre>
<p>If you want to support all sorts of data types, you can try to <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>literal_eval</code></a> and fall back to the basic string if that does not work.</p>
<pre><code>import ast
def try_eval(string):
    try:
        return ast.literal_eval(string)
    except ValueError:
        return string

&gt;&gt;&gt; map(try_eval, "42 3.14 foo 'bar' [1,2,3]".split())
[42, 3.1400000000000001, 'foo', 'bar', [1, 2, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>map</code> is for when you want to apply the same transformation to every element of the input. That doesn't fit your use case; you want to treat the two inputs in different ways. Since the data has a fixed format of string, then integer, it'd be best to parse it in a way that always produces that format:</p>
<pre><code>x, y = raw_input().split()
y = int(y)
</code></pre>
<p>If you have more columns, you could make a list of which function to use to handle each column:</p>
<pre><code>handlers = [str, int, int, str, float, int, int]
a, b, c, d, e, f, g = [f(x) for (f, x) in zip(handlers, raw_input().split())]
</code></pre>
<p>The solutions suggested by the other answers don't account for the fixed format of the input. If the user inputs</p>
<pre><code>31 42
</code></pre>
<p><code>x</code> should be <code>"31"</code>, not <code>31</code>, and if the user inputs</p>
<pre><code>foo bar
</code></pre>
<p>that should be detected as an error, rather than assigning <code>"bar"</code> to <code>y</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do a quick "try / except" setup if you're not looking for anything fancy.</p>
<p>e.g., </p>
<pre><code>def convert(x):
    try:
        f = float(x)
        i = int(f)
        x = i if i == f else f
    except:
        pass
    return x

arr = map(convert, sys.stdin.readline().split())
</code></pre>
</div>
<span class="comment-copy">are the numbers alway positive ints?</span>
<span class="comment-copy">Is it expected that the first input is always interpreted as a string and the second input is always interpreted as an integer? If so, that changes how the input should be handled, and none of the answers really deal with that.</span>
<span class="comment-copy">@PadraicCunningham, no actually the numbers can be negative too, apparently.</span>
<span class="comment-copy">@user2357112 yes, it is always expected that the first input will be a string and the second as an integer (either positive or negative). How does it change how the input should be handled?</span>
<span class="comment-copy">@Deathstroke: I've posted an answer describing how to handle it.</span>
<span class="comment-copy">@Deathstroke, yep but really just a fun solution, using a try/except is the safest way, it will also allow for negative numbers.</span>
<span class="comment-copy">@PadraicCunningham, but do I need to check for safety if I know for sure that the input will be of the expected form? I mean, I'm going to use this to solve algorithmic problems on online judges. So I guess I should go for something that is faster more than something that is safer?</span>
<span class="comment-copy">@Deathstroke, if it is for something you can be sure of the input always being in that form then sure it is fine. I just meant in general a try is the best approach</span>
<span class="comment-copy">I see. Just out of curiosity, is there any way to also allow negative integers using the lambda function?</span>
<span class="comment-copy">Great answer. Since you are unpacking into <code>n, m</code> you may want to eliminate the possibility of a ValueError by limiting the split to 1. ie, <code>split(None, 1)</code></span>
<span class="comment-copy">Brilliant. Worked like a charm. Thanks. :-)</span>
<span class="comment-copy">Much cleaner than trying to LBYL whether the number is a valid <code>int</code>.</span>
<span class="comment-copy"><code>isdigit</code> doesn't actually test whether the string can be cast to an integer number, so you shouldn't use it for that purpose.</span>
<span class="comment-copy">@abarnert I am aware that <code>isdigit</code> does not handle negative numbers, but is there a case where <code>isdigit</code> will return <code>True</code> and casting to <code>int</code> will fail?</span>
<span class="comment-copy">Off the top of my head, in wide builds of at least some versions of 2.x, non-BMP Unicode digits pass <code>isdigit</code> but are rejected by <code>int</code>. Meanwhile, there are other things <code>isdigit</code> doesn't handle besides negative numbers, like <code>"+3"</code> and <code>" 2 "</code>, and non-BMP Unicode digits in narrow builds of 3.0-3.2. I have no idea whether these are the only cases. But that in itself is a reason not to use it: "I think these may be the only problems to test for" just means "I can't figure out how to write complete test coverage". By contrast, <code>try</code> around <code>int</code> is guaranteed to work.</span>
<span class="comment-copy">It doesn't actually seem clear from the question whether he's asking for this or the other answer… so it's definitely worth pointing out, whether it is what he actually wants or not.</span>
<span class="comment-copy">@abarnert: From the clarification in the comments, I'm pretty sure this is the right interpretation, but I could be mistaken.</span>
<span class="comment-copy">@user2357112 and @abarnet: For clarification, I'd like state that the format for the input that I'm expecting is always in the form of <code>foo 42</code> or <code>foo -42</code>. The input won't contain <code>32 42</code> or <code>foo bar</code>. It is always in the format of <code>str int</code></span>
<span class="comment-copy">Yes! This is what I was looking for.</span>
<span class="comment-copy">Ah, yes. It should be fixed now.</span>
<span class="comment-copy">Well it works for me. 'abc 123 4.5 6.7' returns ['abc', 123, 4.5, 6.7]. Can you explain what I'm missing?</span>
<span class="comment-copy">@AMacK: Not what you originally asked, but… converting to int via float is not always the same as converting to int directly, nor is it a good idea. Try it with <code>'100000000000000000000000'</code> and you'll get <code>[99999999999999991611392]</code>.</span>
<span class="comment-copy">That's a fair point.</span>
