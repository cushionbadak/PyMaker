<div class="post-text" itemprop="text">
<p>Here is my text file, which consists of a tuple on each line:</p>
<pre><code>(1, 2)
(3, 4)
(5, 6)
</code></pre>
<p>What's the most both rough and optimized perspective to read above file and generate a list like below structure:</p>
<pre><code>[[1,2],[3,4],[5,6]]
</code></pre>
<p>Here is my current approach, is not which truly what I want:</p>
<pre><code>with open("agentListFile.txt") as f:
        agentList = [agentList.rstrip('\n') for line in f.readlines()]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>ast.literal_eval</code> to safely evaluate the tuple and convert those tuples into a list inside a list-comp, eg:</p>
<pre><code>import ast
with open("agentListFile.txt") as f:
    agent_list = [list(ast.literal_eval(line)) for line in f]
</code></pre>
<p>for more information, read the <a href="https://docs.python.org/2/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">doc of <code>ast.literal_eval</code></a>, and <a href="https://stackoverflow.com/questions/15197673/using-pythons-eval-vs-ast-literal-eval">this thread</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is the fastest solution I've been able to come up with so far.</p>
<pre><code>def re_sol1():
    ''' re.findall on whole file w/ capture groups '''
    with open('agentListFile.txt') as f:
        numpairs = [[int(numstr)
            for numstr in numpair]
            for numpair in re.findall(r'(\d+), (\d+)', f.read())]
        return numpairs
</code></pre>
<p>It makes use of <a href="https://docs.python.org/3/library/re.html#re.findall" rel="nofollow"><code>re.findall</code></a> and the fact that all values are only positive integers. By using capture groups in the regular expression in combination with <code>re.findall</code>, you can efficiently grab pairs of positive integer strings and map them to integers in a list comprehension</p>
<p>To handle negative integers as well, you can use <code>r'-?\d+'</code> as your regular expression instead.</p>
<hr/>
<p>When I run the following code on Python 2.7.6 default version for Linux, it seems to show that <code>re_sol1</code> is the fastest:</p>
<pre><code>with open('agentListFile.txt', 'w') as f:
    for tup in zip(range(1, 1001), range(1, 1001)):
        f.write('{}\n'.format(tup))

funcs = []
def test(func):
    funcs.append(func)
    return func

import re, ast

@test
def re_sol1():
    ''' re.findall on whole file w/ capture groups '''
    with open('agentListFile.txt') as f:
        numpairs = [[int(numstr)
            for numstr in numpair]
            for numpair in re.findall(r'(\d+), (\d+)', f.read())]
        return numpairs

@test
def re_sol2():
    ''' naive re.findall on whole file '''
    with open('agentListFile.txt') as f:
        nums = [int(numstr) for numstr in re.findall(r'\d+', f.read())]
        numpairs = [nums[i:i+2] for i in range(0, len(nums), 2)]
        return numpairs

@test
def re_sol3():
    ''' re.findall on whole file w/ str.split '''
    with open('agentListFile.txt') as f:
        numpairs = [[int(numstr) 
            for numstr in numpair.split(', ')] 
            for numpair in re.findall(r'\d+, \d+', f.read())]
        return numpairs

@test
def re_sol4():
    ''' re.finditer on whole file '''
    with open('agentListFile.txt') as f:
        match_iterator = re.finditer(r'(\d+), (\d+)', f.read())
        numpairs = [[int(ns) for ns in m.groups()] for m in match_iterator]
        return numpairs

@test
def re_sol5():
    ''' re.match line by line '''
    with open('agentListFile.txt') as f:
        numpairs = [[int(ns) 
            for ns in re.match(r'\((\d+), (\d+)', line).groups()] 
            for line in f]
        return numpairs

@test
def re_sol6():
    ''' re.search line by line '''
    with open('agentListFile.txt') as f:
        numpairs = [[int(ns) 
            for ns in re.search(r'(\d+), (\d+)', line).groups()] 
            for line in f]
        return numpairs

@test
def sss_sol1():
    ''' strip, slice, split line by line '''
    with open("agentListFile.txt") as f:
        agentList = [map(int, line.strip()[1:-1].split(', ')) for line in f]
        return agentList

@test
def ast_sol1():
    ''' ast.literal_eval line by line '''
    with open("agentListFile.txt") as f:
        agent_list = [list(ast.literal_eval(line)) for line in f]
        return agent_list

### Begin tests ###

def all_equal(iterable):
    try:
        iterator = iter(iterable)
        first = next(iterator)
        return all(first == rest for rest in iterator)
    except StopIteration:
        return True

if all_equal(func() for func in funcs):
    from timeit import Timer

    def print_timeit(func, cnfg={'number': 1000}):
        print('{}{}'.format(Timer(func).timeit(**cnfg), func.__doc__))

    for func in funcs:
        print_timeit(func)
else:
    print('At least one of the solutions is incorrect.')
</code></pre>
<p>Sample output from a single run:</p>
<pre><code>1.50156712532 re.findall on whole file w/ capture groups 
1.53699707985 naive re.findall on whole file 
1.71362090111 re.findall on whole file w/ str.split 
1.97333717346 re.finditer on whole file 
3.36241197586 re.match line by line 
3.59856200218 re.search line by line 
1.71777415276 strip, slice, split line by line 
12.8218641281 ast.literal_eval line by line 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The code below relies on assumption, that your lines follow the same format <code>(number1, number2)</code></p>
<pre><code>def strip_slice_split_solution():
    with open("agentListFile.txt") as f:
        agentList = [map(int, line.strip()[1:-1].split(', ')) for line in f]
        return agentList    
</code></pre>
<p><code>s[1:-1]</code> will omit first and last characters (brackets) of <code>s</code>.</p>
<p>I put <a href="https://stackoverflow.com/revisions/30254825/3">Shashank's solution</a> (removed <code>import</code> from the function) and <a href="https://stackoverflow.com/revisions/30254225/2">Jon's solution</a> and mine into a file and decided to do a few tests. I generated a few files with  <code>5000-1000</code> lines in them to do tests.</p>
<p>Excerpt from test</p>
<pre><code>In [3]: %timeit re_solution()
100 loops, best of 3: 2.3 ms per loop

In [4]: %timeit strip_slice_split_solution()
100 loops, best of 3: 2.28 ms per loop

In [5]: %timeit ast_solution()
100 loops, best of 3: 14.1 ms per loop
</code></pre>
<p>All 3 functions produce the same result</p>
<pre><code>In [6]: ast_solution() == re_solution() == strip_slice_split_solution()
Out[6]: True
</code></pre>
</div>
<span class="comment-copy">@Alik: Please check the edit for my current method...</span>
<span class="comment-copy">What do you mean "rough" and "optimized"? If you want optimized, provide more details. Details allow people to cheat quite a bit and achieve greater optimization in most cases. Are all the tuples pairs of ints? How big is the file?</span>
<span class="comment-copy">@Shashank: The list consists of about 1000 2-member sublists and the list comprehension had not intrinsic suitable performance for me... but Jon's asnwer and using the <code>literal_eval()</code> method did something noticeable in the way of the improving the performance...</span>
<span class="comment-copy">@Ordenador Are the members all ints or can they be anything?</span>
<span class="comment-copy">@Shashank: they are just integers in the range of 1 up to 100...</span>
<span class="comment-copy">a succinct and deserving solution...!I appreciate</span>
<span class="comment-copy">@Shahank: Putting aside the point that it is considerably more complicated than the candidate solution and has ruined the readability, but the performance sounds got better... Thank you...</span>
<span class="comment-copy">@Ordenador Yes you're right, I guess I could make a different version that goes through the file line by line...but that is actually computationally harder for computers due to i/o and string-parsing bottlenecks and I was aiming for performance...</span>
<span class="comment-copy">All in all, I am grateful for your contribution.</span>
<span class="comment-copy">@Ordenador note that you could also re-factor this answer to do line by line and make the matching more explicit, eg: <code>agent_list = list(([int(i) for i in re.match(r'\((\d+), (\d+)\)', line).groups()] for line in f))</code></span>
<span class="comment-copy">Thank you, but I have an <code>AttributeError</code> that: <code>list object has no attribute 'rstrip'</code>...</span>
<span class="comment-copy">@Ordenador i've copied the code from your question and added a few calls on top of it. Fixed it.</span>
<span class="comment-copy">Those are strange results because I'm doing <code>Timer(func).timeit(number=1000)</code> and I get that my solution is always faster than yours on Python 2.7.6 default for linux. :p</span>
<span class="comment-copy">@Shashank is it significantly faster?</span>
<span class="comment-copy">Depends on what you consider significant. With <code>number=10000</code> I'm able to get 14.86 seconds for <code>re_solution</code>, and 17.81 for the <code>strip_slice_split_solution</code>. It's not super significant, I suppose, but I definitely don't think my solution is slower.</span>
