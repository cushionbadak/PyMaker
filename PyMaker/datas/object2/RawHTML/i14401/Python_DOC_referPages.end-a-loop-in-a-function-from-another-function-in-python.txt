<div class="post-text" itemprop="text">
<p>Is is possible in python to end a loop in a function from another function? 
This does not seem to work</p>
<p>Here is my code:</p>
<pre><code>from tkinter import*
root = Tk()
def loop():
    global superman
    superman=False
    while superman==False:
        print("It's doing something")
def endloop():
    global superman
    superman=True

btn_1 = Button(root, text="stop", command=endloop)
btn_1.pack()
btn_2 = Button(root, text="start", command=loop)
btn_2.pack()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem here is that your <code>while</code> loop just keeps running, meaning none of the rest of your code ever gets to run. That includes the Tkinter GUI, which means that your program doesn't respond to any user events, including the button click, so <code>endloop</code> never gets called.</p>
<p>More generally, you really can't have a function that just runs forever, or even for more than a fraction of a second, inside a GUI program. A single-threaded program can only do one thing at a time; if what it's doing is looping forever, then it's not doing anything else.</p>
<p>So, what <em>can</em> you do?</p>
<p>There are two basic options:</p>
<ol>
<li><p>Put the loop on a background thread. This means that any shared data now has to be explicitly synchronized, and it means the loop can't touch any of the GUI widgets—but in your case, that turns out to be pretty simple.</p></li>
<li><p>Break up the loop. Have it just do one iteration (or, say, 100 iterations, if they're really quick), and then use <code>after</code> or <code>after_idle</code> to ask Tkinter to call a function that does another one iteration (or 100 iterations) and <code>after</code>s again, and so on, until they're all done.</p></li>
</ol>
<p>I'll show you how to do the first one here.</p>
<pre><code>import threading
from tkinter import*
root = Tk()

def real_loop():
    while True:
        with superman_lock:
            if not superman:
                return
       print("It's doing something")
def loop():
    global superman
    global superman_lock
    superman=False
    superman_lock = threading.Lock()
    thread = threading.Thread(target=real_loop, daemon=True)
def endloop():
    global superman
    with superman_lock:
        superman=True

btn_1 = Button(root, text="stop", command=endloop)
btn_1.pack()
btn_2 = Button(root, text="start", command=loop)
btn_2.pack()
</code></pre>
<p>For the case where the only shared data is a "stop" flag, a <code>Condition</code> or <code>Event</code> is often better than a <code>Lock</code>. The <a href="https://docs.python.org/3/library/threading.html" rel="nofollow"><code>threading</code></a> docs explain the differences between the different kinds of sync objects, but not really at an introductory level. The Wikipedia article on <a href="http://en.wikipedia.org/wiki/Monitor_%28synchronization%29" rel="nofollow">monitors</a> might be a better starting point to learn, but if you can find a good tutorial on multithreading (not necessarily Python-specific; Python has basically the same sync objects as the C pthreads library, the C++ Boost library, the Java stdlib, etc.), that would probably be better.</p>
<p>For a much more detailed discussion, see <a href="http://stupidpythonideas.blogspot.com/2013/10/why-your-gui-app-freezes.html" rel="nofollow">Why your GUI app freezes</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Supposing your loop() function is doing some work in the background it would be a good idea to put that in a separate thread.
Using threading Events you can interact with the thread.</p>
<p>This code is not tested but it should give you an idea how I have solved such stuff in some cases:</p>
<pre><code>class Worker(threading.Thread):
    def __init__(self):
        threading.Thread.__init__()

        self.run_event = threading.Event()

    def run(self):
        self.run_event.wait()

        while self.run_event.is_set():
            print "It's doing something!"
</code></pre>
<p>You can then initialize the thread, it will call the run() method as soon as it is started and will wait in the first line for the run_event to be set.</p>
<p>So assuming you have a global variable that references your worker thread your loop() method triggered from the button would look like this:</p>
<pre><code>def loop():
    global worker_thread
    worker_thread.run_event.set()
</code></pre>
<p>By setting the run_event the self.run_event.wait() gets passed and the work loop is entered. This while loop runs as long as the threading event is set.</p>
<p>And your endloop() may look something like this:</p>
<pre><code>dev endloop():
    global worker_thread
    worker_thread.run_event.clear()
</code></pre>
<p>As soon as you clear the run_event in your thread, the while condition is no longer fulfilled and the loop quits.</p>
<p>Just a note:
This code is not complete nor tested but may give you an idea how it could be done. Don't forget to</p>
<pre><code>import threading
</code></pre>
<p>as well.</p>
<p>Hope this helps a little bit.
Greetz</p>
</div>
<span class="comment-copy">You didn't <i>call</i> <code>endloop</code>.</span>
<span class="comment-copy">How are you calling both functions? Supposed to be in threads.</span>
<span class="comment-copy">Sure but it' s actually in tkinter and a button it calling endloop()</span>
<span class="comment-copy">You'll want to look into the tkinter event loop; your <code>loop</code> button isn't giving the <code>endloop</code> button a chance to run. See <a href="http://stupidpythonideas.blogspot.com/2013/10/why-your-gui-app-freezes.html" rel="nofollow noreferrer">Why Your GUI App Freezes</a>.</span>
<span class="comment-copy">Thanks for this answer strangely my main program does not make tkinter crash of anything but the endloop don't kill the loop. And actually the loop is counting time.</span>
<span class="comment-copy">@ThierryLincoln: Please read more carefully. I did not say it will make Tkinter crash, and it won't. What it <i>will</i> do is make Tkinter stop responding to events. Which means your <code>endloop</code> function never gets called. Which is why it doesn't kill the loop.</span>
<span class="comment-copy">Thanks for replying actually I opened a thread yesterday about my critical error I'm really confused now and I need to give back this program tomorrow :( :  <a href="http://stackoverflow.com/questions/30413689/exception-with-tkinter-callback-because-loop-continues-in-the-background?noredirect=1" title="exception with tkinter callback because loop continues in the background">stackoverflow.com/questions/30413689/…</a></span>
<span class="comment-copy">Check the other stackoverflow question you linked here, I answered my ideas about it just a minute ago ;-)</span>
