<div class="post-text" itemprop="text">
<p>Earlier today, I read the question "<a href="https://stackoverflow.com/questions/30238783/raise-error-if-python-dict-comprehension-overwrites-a-key">Raise error if python dict comprehension overwrites a key</a>" and decided to try my hand at an answer.  The method that naturally occurred to me was to subclass <code>dict</code> for this.  However, I got stuck on my answer, and now I'm obsessed with getting this worked out for myself.  </p>
<p><strong>Notes:</strong></p>
<ul>
<li>No - I do not plan on turning in the answer to this question as an answer to the other question.</li>
<li>This is purely an intellectual exercise for me at this point.  As a practical matter, I would almost certainly use a <code>namedtuple</code> or a regular dictionary wherever I have a requirement for something like this.</li>
</ul>
<h1>My (not quite working) Solution:</h1>
<pre><code>class DuplicateKeyError(KeyError):
    pass



class UniqueKeyDict(dict):
    def __init__(self, *args, **kwargs):
        self.update(*args, **kwargs)


    def __setitem__(self, key, value):
        if key in self:  # Validate key doesn't already exist.
            raise DuplicateKeyError('Key \'{}\' already exists with value \'{}\'.'.format(key, self[key]))
        super().__setitem__(key, value)


    def update(self, *args, **kwargs):
        if args:
            if len(args) &gt; 1:
                raise TypeError('Update expected at most 1 arg.  Got {}.'.format(len(args)))
            else:
                try:
                    for k, v in args[0]:
                        self.__setitem__(k, v)
                except ValueError:
                    pass

        for k in kwargs:
            self.__setitem__(k, kwargs[k])
</code></pre>
<h1>My Tests and Expected Results</h1>
<pre><code>&gt;&gt;&gt; ukd = UniqueKeyDict((k, int(v)) for k, v in ('a1', 'b2', 'c3', 'd4'))  # Should succeed.
&gt;&gt;&gt; ukd['e'] = 5  # Should succeed.
&gt;&gt;&gt; print(ukd)
{'a': 1, 'b': 2, 'c': 3, d: 4, 'e': 5}
&gt;&gt;&gt; ukd['a'] = 5  # Should fail.
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 8, in __setitem__
__main__.DuplicateKeyError: Key 'a' already exists with value '1'.
&gt;&gt;&gt; ukd.update({'a': 5})  # Should fail.
&gt;&gt;&gt; ukd = UniqueKeyDict((k, v) for k, v in ('a1', 'b2', 'c3', 'd4', 'a5'))  # Should fail.
&gt;&gt;&gt;
</code></pre>
<p>I'm certain the issue is in my <code>update()</code> method, but I'm not able to determine just what I'm doing wrong.</p>
<p>Below is the original version of my <code>update()</code> method.  This version fails as expected on duplicates when calling <code>my_dict.update({k: v})</code> for a key/value pair already in the dict, but does not fail when including a duplicate key while creating the original dict, due to the fact that converting the args to a <code>dict</code> results in default behavior for a dictionary, i.e., overwriting the duplicate key.</p>
<pre><code>def update(self, *args, **kwargs):
    for k, v in dict(*args, **kwargs).items():
        self.__setitem__(k, v)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Note that, per the documentation:</p>
<ul>
<li><a href="https://docs.python.org/3/library/stdtypes.html#dict.update" rel="nofollow"><code>dict.update</code></a> takes a single <code>other</code> parameter, <em>"either another dictionary object or an iterable of key/value pairs"</em> (I've used <a href="https://docs.python.org/2/library/collections.html#collections.Mapping" rel="nofollow"><code>collections.Mapping</code></a> to test for this) and <em>"If keyword arguments are specified, the dictionary is then updated with those key/value pairs"</em>; and</li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#dict" rel="nofollow"><code>dict()</code></a> takes a single <code>Mapping</code> or <code>Iterable</code> along with optional <code>**kwargs</code> (the same as <code>update</code> accepts...).</li>
</ul>
<p>This is not quite the interface you have implemented, which is leading to some issues. I would have implemented this as follows:</p>
<pre><code>from collections import Mapping


class DuplicateKeyError(KeyError):
    pass


class UniqueKeyDict(dict):

    def __init__(self, other=None, **kwargs):
        super().__init__()
        self.update(other, **kwargs)

    def __setitem__(self, key, value):
        if key in self:
            msg = 'key {!r} already exists with value {!r}'
            raise DuplicateKeyError(msg.format(key, self[key]))
        super().__setitem__(key, value)

    def update(self, other=None, **kwargs):
        if other is not None:
            for k, v in other.items() if isinstance(other, Mapping) else other:
                self[k] = v
        for k, v in kwargs.items():
            self[k] = v
</code></pre>
<p>In use:</p>
<pre class="lang-none prettyprint-override"><code>&gt;&gt;&gt; UniqueKeyDict((k, v) for k, v in ('a1', 'b2', 'c3', 'd4'))
{'c': '3', 'd': '4', 'a': '1', 'b': '2'}
&gt;&gt;&gt; UniqueKeyDict((k, v) for k, v in ('a1', 'b2', 'c3', 'a4'))
Traceback (most recent call last):
  File "&lt;pyshell#8&gt;", line 1, in &lt;module&gt;
    UniqueKeyDict((k, v) for k, v in ('a1', 'b2', 'c3', 'a4'))
  File "&lt;pyshell#7&gt;", line 5, in __init__
    self.update(other, **kwargs)
  File "&lt;pyshell#7&gt;", line 15, in update
    self[k] = v
  File "&lt;pyshell#7&gt;", line 10, in __setitem__
    raise DuplicateKeyError(msg.format(key, self[key]))
DuplicateKeyError: "key 'a' already exists with value '1'"
</code></pre>
<p>and:</p>
<pre><code>&gt;&gt;&gt; ukd = UniqueKeyDict((k, v) for k, v in ('a1', 'b2', 'c3', 'd4'))
&gt;&gt;&gt; ukd.update((k, v) for k, v in ('e5', 'f6'))  # single Iterable
&gt;&gt;&gt; ukd.update({'h': 8}, g='7')  # single Mapping plus keyword args
&gt;&gt;&gt; ukd
{'e': '5', 'f': '6', 'a': '1', 'd': '4', 'c': '3', 'h': 8, 'b': '2', 'g': '7'}
</code></pre>
<p>If you ever end up using this, I'd be inclined to give it a different <code>__repr__</code> to avoid confusion!</p>
</div>
<div class="post-text" itemprop="text">
<p>It's interesting that simply overriding <code>__setitem__</code> is not enough to change the behavior of <code>update</code> in <code>dict</code>. I would have expected that <code>dict</code> would use its <code>__setitem__</code> method when it's being updated using <code>update</code>. In all cases, I think it's better to implement <code>collections.MutableMapping</code> to achieve the desired result without touching <code>update</code>:</p>
<pre><code>import collections

class UniqueKeyDict(collections.MutableMapping, dict):

    def __init__(self, *args, **kwargs):
        self._dict = dict(*args, **kwargs)

    def __getitem__(self, key):
        return self._dict[key]

    def __setitem__(self, key, value):
        if key in self:
            raise DuplicateKeyError("Key '{}' already exists with value '{}'.".format(key, self[key]))
        self._dict[key] = value

    def __delitem__(self, key):
        del self._dict[key]

    def __iter__(self):
        return iter(self._dict)

    def __len__(self):
        return len(self._dict)
</code></pre>
<p>Edit: included <code>dict</code> as base class to satisfy the <code>isinstance(x, dict)</code> check.</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not sure this is the problem but I just noticed that you are treating your <code>args</code> in the <code>update</code> method as a list of pairs:</p>
<pre><code>for k, v in args[0]
</code></pre>
<p>while you are actually supplying a dictionary:</p>
<pre><code>ukd.update({'a': 5})
</code></pre>
<p>Have you tried this:</p>
<pre><code>try:
    for k, v in args[0].iteritems():
        self.__setitem__(k, v)
except ValueError:
    pass
</code></pre>
<p>EDIT: Probably this error went unnoticed because you are <code>except</code>ing a <code>ValueError</code>, which is what treating a dictionary as a list of pairs will raise.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was able to achieve the goal with the following code:</p>
<pre><code>class UniqueKeyDict(dict):
    def __init__(self, *args, **kwargs):
        self.update(*args, **kwargs)

    def __setitem__(self, key, value):
        if self.has_key(key):
            raise DuplicateKeyError("%s is already in dict" % key)
        dict.__setitem__(self, key, value)

    def update(self, *args, **kwargs):
        for d in list(args) + [kwargs]:
            for k,v in d.iteritems():
                self[k]=v
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Why not do something along the lines inspired by MultiKeyDict using setdefault? This leaves the update method as a way to override the currently stored values, breaking, I know, the intent that d[k] = v == d.update({k, v}). In my application the override was useful. So before flagging this as not answering the OP question, please consider this answer might be useful for someone else.</p>
<pre><code>class DuplicateKeyError(KeyError):
    """File exception rasised by UniqueKeyDict"""
    def __init__(self, key, value):
        msg = 'key {!r} already exists with value {!r}'.format(key, value)
        super(DuplicateKeyError, self).__init__(msg)


class UniqueKeyDict(dict):
    """Subclass of dict that raises a DuplicateKeyError exception"""
    def __setitem__(self, key, value):
        if key in self:
            raise DuplicateKeyError(key, self[key])
        self.setdefault(key, value)


class MultiKeyDict(dict):
    """Subclass of dict that supports multiple values per key"""
    def __setitem__(self, key, value):
        self.setdefault(key, []).append(value)
</code></pre>
<p>Rather new to python so flame on, probably deserve it... </p>
</div>
<span class="comment-copy">If at most one positional argument is allowed, use <code>update(self, arg=None, **kwargs)</code> instead of allowing an arbitrary number of arguments.</span>
<span class="comment-copy">O/t, but shouldn't <code>DuplicateKeyError</code> subclass <code>KeyError</code>?</span>
<span class="comment-copy">@jonrsharpe - I thought of that a little while ago and will make the update.</span>
<span class="comment-copy">I haven't had the opportunity to test your answer (or any of the others yet), but a quick question about your implementation: Any particular reason you chose to use <code>Iterable</code> instead of <code>abc.Iterable</code>, which would've been my normal choice if I'd've thought to go down this path?  Also, the point about the <code>__repr__</code> is a good one.  I still wouldn't ordinarily use it, but I've thought of a few use cases for it.  Not sure if they would warrant the added complexity, however.</span>
<span class="comment-copy">@DougR. assuming you mean <code>collections.abc.Iterable</code> (there is no <code>Iterable</code> in <a href="https://docs.python.org/3/library/abc.html" rel="nofollow noreferrer"><code>abc</code></a>) it's an alias for the same thing: <i>"Changed in version 3.3: Moved Collections Abstract Base Classes to the <code>collections.abc</code> module. For backwards compatibility, they continue to be visible in this module as well."</i></span>
<span class="comment-copy"><b>Sigh</b> - I've got to be more precise.  You're absolutely correct - I did mean <code>collections.abc.Iterable</code>.  Thanks for the info - I should've looked it up myself.  I will definitely take a look and play with some code tonight.</span>
<span class="comment-copy">Hmm.  <code>ukd.update({'a', 5})</code> still fails.  I'm getting the error <code>ValueError: need more than 1 value to unpack</code>.  It should fail, but with a <code>DuplicateKeyError</code>.  I also tried <code>ukd.update({'f': 6})</code>, which should have succeeded, but got the same error.</span>
<span class="comment-copy">Only thing to add would be an <code>overwrite</code> method (because if you actually use this, you know you're going to want to at some point...), a <code>__repr__</code>, and documentation of the code.  When I finally get something like this hammered out, I like to feel like I've actually completed it.</span>
<span class="comment-copy">Good use of the included ABCs, but this way you have to implement six methods instead of three and (in case it's important) <code>isinstance(UniqueKeyDict(), dict)</code> will be <code>False</code> (although of course people should be using <code>isinstance(..., collections.Mapping)</code>!)</span>
<span class="comment-copy">That was counterintuitive to me as well, when I wrote my first iteration of <code>UniqueKeyDict</code> (not the best name, but the best I could come up with on short notice).  Also, the reason I subclass <code>dict</code> is so that <code>isinstance(UniqueKeyDict(), dict)</code> will be <code>True</code>, as well as the fact that I won't have to reimplement all the various methods.</span>
<span class="comment-copy">Well, we can always include dict in the base classes to satisfy the <code>isinstance</code> check without affecting the class' behavior</span>
<span class="comment-copy">And about the number of methods to implement, although more but fairly simple.</span>
<span class="comment-copy">Yes, in LOC terms it's only two longer than mine (ignoring whitespace and the fact that I've split the <code>raise</code> over two lines).</span>
<span class="comment-copy">You're absolutely correct about the error I was making, but that ended up not being the actual issue.  Thanks for the catch!</span>
<span class="comment-copy">Hmm.  <code>ukd.update({'a', 5})</code> is now the only test that fails.  I'm getting the error <code>ValueError: need more than 1 value to unpack</code>.  It should fail, but with a <code>DuplicateKeyError</code>.  I also tried <code>ukd.update({'f': 6})</code>, which should <b>not</b> have generated an error, but got the same error.</span>
<span class="comment-copy">Which Python version are you using? I used the following and it worked nicely: <code>i = UniqueKeyDict({1:1, 2:2, 3:3})          i.update({'a':1})     i.update({'a':2})</code></span>
<span class="comment-copy">Python 3.  I assume from the <code>d.iteritems()</code> that you're using Python 2?  When I moved your approach into 3, the only difference I had is that I split the <code>for</code> into two parts, one to process <code>args</code> and one to process <code>kwargs</code>.  When I use it as-is in Python3 just changing <code>d.iteritems()</code> to <code>d.items()</code>, then everything goes boom.</span>
<span class="comment-copy">Are you sure that you are using the values inside args? args is a tuple of values; in this case, I am expecting that args is a tuple of dictionaries. Therefore, I iterate over the dictionaries inside args (the first for loop in the solution) and before that (the second for loop) the tuples (key,value).</span>
