<div class="post-text" itemprop="text">
<p>Let's say the class Color is an enumeration:</p>
<pre><code>from enum import IntEnum
class Color(IntEnum):
    red = 1
    blue = 2
    green = 3
</code></pre>
<p>Now, let's say I want to associate each of those member with a function AND keeping their value. i.e doing something like this</p>
<pre><code>Colors.red()
</code></pre>
<p>Would call a function that I'd assign in someway.
And keeping the IntEnum behavior, meaning that </p>
<pre><code>Colors.red == 1
</code></pre>
<p>Would still return <code>True</code></p>
<p>I guess I need to define a new superclass for my enumeration, but how?</p>
<p>The only thing near that that I have managed to do is:</p>
<pre><code>class Colors(Enum):
    red = (1, f)
    blue = (2, g)
    green = (3, h)
</code></pre>
<p>Where <code>f</code> <code>g</code> and <code>h</code> are functions.
However. With this method, the only way to access the value is</p>
<pre><code>Colors.red.value[0]
</code></pre>
<p>And to call the function this is </p>
<pre><code>Colors.red.value[1](args)
</code></pre>
<p>Wich is, in my opinion, pretty ugly, especially when names are a bit longs, when you have to call function a lot of times and with a lots of arguments</p>
<p>So is there a way to do what I want or do I need to stick to the uggly version?</p>
</div>
<div class="post-text" itemprop="text">
<p>Against my better judgement, I've decided to unravel the magic threads that hold <code>Enum</code>s together. Here's what I came up with:</p>
<pre><code>from enum import Enum

class FuncEnum(Enum):
    def __init__(self, val, func=None):
        self.val = val
        self.func = func or lambda: None
    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)
    def __eq__(self, other):
        return self.val == other
    def __ge__(self, other):
        return self.val &gt;= other
    # and etc... not sure how @total_ordering will work here!

class Color(FuncEnum):
    red = (1, lambda x: x**2)
    blue = (2, lambda x: x**3)
    green = (3, lambda x: x**4)

Color.red(4)  # 16
Color.red == 1  # True
Color.blue(2)  # 8
</code></pre>
<p>This also supports reassignment, so afterwards:</p>
<pre><code>Color.red.func = str.lower
Color.red("LOWERCASE")  # "lowercase"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Simple and plain, although a nightmare for readability and comprehensibility. Simply implements Python callable interface by providing a <code>__call__</code> method. Bury it in some module, implement <code>__all__</code> and never import anything besides <code>Color</code> class.</p>
<pre><code>from enum import IntEnum
f1 = lambda x: x
f2 = lambda x: x*x
f3 = lambda x: x*x*x

class Color(IntEnum):
    red = 1
    blue = 2
    green = 3
    def __call__(self, *args, **kwargs):
        # alternatively some generic function of self.value
        return LUT[self](*args, **kwargs)


LUT = {Color.red: f1, Color.blue: f2, Color.green: f3}

assert Color.red(1) == 1
assert Color.blue(2) == 4
assert Color.green(3) == 27
assert Color.blue &gt; Color.red
</code></pre>
<p>Edit:
Much better (more readable, less hacky etc.) would be to define explicit callable interface on Enum.</p>
<pre><code>class Color(IntEnum):
    red = 1
    blue = 2
    green = 3
    def get_something(self, x):
        # e.g.
        return x ** self.value
</code></pre>
<p>Any users of this Enum would do something like:</p>
<pre><code>o = Obj()
o.color.get_something(123)
</code></pre>
<p>With with proper name of <code>get_something</code> would be readable, easy to understand for pylint and other static analysis tools and less error-prone.</p>
</div>
<span class="comment-copy">This is really unintuitive behavior. Can you not just put put your functions in a dictionary and call them by doing <code>d[Colors.red]()</code>?</span>
<span class="comment-copy">@Blender It's a good idea in deed. The only point on doing that is that forces you to re create a dictionnary, with each values. With big enums it'll take a lot of place. However the idea is really good and I'll think about it if there is no way to do what I'm looking for.</span>
<span class="comment-copy">How big are your enums?</span>
<span class="comment-copy">@ It could go from 12 to 20 items approximately. That's not that big, but that add 20 lines that could be avoided if there is a way to give the function at the same time as the value. Anyway I'm not complaining at all about your idea, it's really simple and effective!</span>
<span class="comment-copy">What exactly is wrong with just calling <code>Color.red.value</code> on the enum in your first example?</span>
<span class="comment-copy">Hmm, that's not far from what I thought of, but I missed the imlicit "magic" of  Enums, so I fiddled with creating callable ints (or somewhat). That's where I gave up.</span>
<span class="comment-copy">Wouldn't that require to create an instance of the class and call that instance, but neither the class itself, nor one of the class attributes? Hmm.. tried; and it seems to work, but I'm not sure why.</span>
<span class="comment-copy">@Olaf could you clarify? Enum does some of metaclass magic beneath, this solution is also very hacky (because of requirement being hacky itself) and I cannot understand what do you mean. <code>Color</code> is not a class here, and <code>red</code>, <code>green</code>, <code>blue</code> are not class attributes. Please refer to <a href="https://docs.python.org/3/library/enum.html#how-are-enums-different" rel="nofollow noreferrer">How are enums different?</a></span>
<span class="comment-copy">@Olaf Maybe becauses we are working with enums, where attributes are kind of instances. Anyway thanks, I'll try that. I'll let the thread open for some times to see other possibilities</span>
<span class="comment-copy">I just wondered why the <b>call</b> works on the class attributes (it certainly <i>is</i> a class actually, as everything is a class) and not on an instance. However the reference to metaclass "magic" does explain it. I did not take this into account; just read a primer on them. There seems to be much more behind them than I actually thought. Fascinating!</span>
<span class="comment-copy">Is is still possible to put the functions into the class definition as <code>@staticmethod</code> and use the class-dict to lookup them? e.g. using a unifirm naming scheme like <code>&lt;color&gt;_func</code> or similar? I think that would increase readability significantly (and keep everything in the class' namespace).</span>
