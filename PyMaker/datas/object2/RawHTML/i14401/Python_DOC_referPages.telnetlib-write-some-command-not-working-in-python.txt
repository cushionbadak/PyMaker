<div class="post-text" itemprop="text">
<p>I'm using Python's telnetlib.write() function for quite some time without issues, but in this case the command that I want to send does nothing. While the same command sent through SecureCRT works fine.</p>
<p>Here's more or less what I have:</p>
<pre><code>import telnetlib

tn = telnetlib.Telnet(HOST)

tn.read_until('login: ')
tn.write(user + '\n')

if pswrd:
    tn.read_until('Password: ')
    tn.write(pswrd + '\n')

tn.write('echo "" &gt; /path/to/file.log' + '\n')

tn.write('exit\n')
tn.close()
</code></pre>
<p>What this should do is clear the contents of file.log, but the file remains the same. Why is this happening? 
If it's worth mentioning, the telnet server is running SunOS. Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is almost certainly a timing error.</p>
<p>Without being able to debug it, or seeing the results of you debugging it, it's hard to be sure <em>exactly</em> what the problem is, but my guess is something like this:</p>
<p>The SunOS machine's <code>telnetd</code> server has a relatively small buffer, say 16 bytes. So, if you send it that whole command before the shell has started, it's only going to send 16 bytes of it to the shell. Which will, of course, not do what you want. But if you wait until the shell has started, it'll get the whole command, and therefore work.</p>
<p>By adding <code>tn_setdebuglevel(1)</code> to your program, you're changing the timingâ€”the extra time it takes to print out the debugging information is just enough to (usually) give the shell time to start before you've filled up the buffer, so it happens to work.</p>
<p>The password prompt probably has the same problem, which you solved by using `tn.read_until('Password: '). You just need to do the same thing here. For example (depending on what the expected prompt is):</p>
<pre><code># ...
tn.read_until('$')
tn.write('echo "" &gt; /path/to/file.log\n')
tn.read_until('$')
tn.write('exit\n')
tn.close()
</code></pre>
</div>
<span class="comment-copy">Well, what's actually going back and forth over the telnet session? Have you tried <a href="https://docs.python.org/3/library/telnetlib.html#telnetlib.Telnet.set_debuglevel" rel="nofollow noreferrer"><code>set_debuglevel</code></a> to see?</span>
<span class="comment-copy">Also, what makes you think it's the <code>write()</code> function that's not working, as opposed to, say, the <code>write</code> working perfectly and executing an <code>echo</code> command that fails with a permissions error or something? Or failing to log in, so you're not even talking to the shell? (For example, on many platforms, the <code>Password:</code> prompt doesn't have a space after the colon; using sample code that happened to work on one machine without even testing it to see if it works on your machine isn't a very good idea.)</span>
<span class="comment-copy">@abarnert Well, the code showed in my question is a simplified example, because there's a lot more going on in my script. So, I know that everything else is working, perhaps I should've started explaining that. If the problem is a matter of permissions it shouldn't have worked with SecureCRT, I believe. -- By other hand, I tried tn.set_debuglevel(1) and now is working, if I comment that line it doesn't work anymore. Don't know why, but it appears that the issue resolves that way.</span>
<span class="comment-copy">A simplified example is good, but not if it's so simplified that it doesn't actually reproduce the problem. (If you show us working code, we can't tell you what's wrong with it.) Please read <a href="http://stackoverflow.com/help/mcve">minimal, complete, verifiable example</a>.</span>
<span class="comment-copy">Meanwhile, if just adding <code>tn.set_debuglevel</code> makes a difference, you've most likely got some kind of timing issue. Maybe SunOS's <code>telnetd</code> is only buffering, say, 16 characters for the shell, so if you <code>write</code> a command without waiting for the shell to start it gets truncated, but writing debug info just happens to slow things down just enough that often the shell will have started in time and can read your whole command, so things now work 98% of the time instead of 2% of the time.</span>
