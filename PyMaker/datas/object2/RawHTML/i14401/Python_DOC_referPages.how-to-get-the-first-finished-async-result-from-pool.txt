<div class="post-text" itemprop="text">
<p>Let's say I have 3 tasks.</p>
<pre><code>tasks = [task1, task2, task3]
</code></pre>
<p>I want to run the 3 tasks in parallel so I put them in a thread pool.</p>
<pre><code>from multiprocessing.pool import ThreadPool
worker_pool = ThreadPool(len(tasks))
async_results = [worker_pool.apply_async(task) for task in tasks]
</code></pre>
<p>Then I need to <code>get()</code> these async result. Here is what I do:</p>
<pre><code>[async_result.get() for async_result in async_results]
</code></pre>
<p>However, this method tries to <code>get()</code> these async results one by one. It is possible that task2 actually fails in the middle of the process and I want to know this by <code>get()</code> the corresponding async result. In this case, the method here will actually be blocked at the first task. I can only notice task2 fails after task1 is finished. </p>
<p>I want to know if there is some way I can get the async result which is ready first.</p>
</div>
<div class="post-text" itemprop="text">
<p>I don't think multiprocessing's Pool is able to do this. You really should try <a href="https://docs.python.org/3/library/concurrent.futures.html" rel="nofollow"><code>concurrent.futures</code></a>, it provides more functionality than Pool, and easier to use.</p>
<p><a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed" rel="nofollow"><code>concurrent.futures.as_completed</code></a> is just for your task:</p>
<pre><code>import concurrent.futures

with concurrent.futures.ProcessPoolExecutor(max_workers=5) as worker_pool: 
    futures = [executor.submit(task) for task in tasks]
    for future in concurrent.futures.as_completed(futures):
        # completed task is yielded first 
        result = future.result()
</code></pre>
<p>And that's it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can look into <a href="https://docs.python.org/2/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool.imap_unordered" rel="nofollow">Pool.imap_unordered</a>:</p>
<pre><code>async_results = worker_pool.imap_unordered(apply, tasks)
results = [result for result in async_results]
</code></pre>
</div>
<span class="comment-copy"><code>imap_unordered</code> doesn't guarantee you'll get the first finished result first either.</span>
<span class="comment-copy">If the tasks take the same amount of time to complete then sure the order won't be by finished time. But if some tasks take longer than others, then chances are that using <code>imap_unordered</code> you'll get the results of finished tasks first (which I assumed is what the OP really cares about).</span>
