<div class="post-text" itemprop="text">
<p>First of all I wanted to say that my title is probably not describing my question correctly. I don't know how the process I am trying to accomplish is called, which made searching for a solution on stackoverflow or google very difficult. A hint regarding this could already help me a lot!</p>
<p>What I currently have are basically two lists with lists as elements.
Example:</p>
<pre><code>List1 = [ [a,b], [c,d,e], [f] ]
List2 = [ [g,h,i], [j], [k,l] ]
</code></pre>
<p>These lists are basically vertices of a graph I am trying to create later in my project, where the edges are supposed to be from List1 to List2 by rows.</p>
<p>If we look at the first row of each of the lists, I therefore have:</p>
<pre><code>[a,b] -&gt; [g,h,i]
</code></pre>
<p>However, I want to have assingments/edges of unique elements, so I need:</p>
<pre><code>[a] -&gt; [g]
[a] -&gt; [h]
[a] -&gt; [i]
[b] -&gt; [g]
[b] -&gt; [h]
[b] -&gt; [i]
</code></pre>
<p>The result I want to have is another list, with these unique assigments as elements, i.e.  </p>
<pre><code>List3 = [ [a,g], [a,h], [a,i], [b,g], ...]
</code></pre>
<p>Is there any elegant way to get from List1 and List2 to List 3?</p>
<p>The way I wanted to accomplish that is by going row by row, determining the amount of elements of each row and then write clauses and loops to create a new list with all combinations possible. This, however, feels like a very inefficient way to do it.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can <code>zip</code> your two lists, then use <code>itertools.product</code> to create each of your combinations. You can use <code>itertools.chain.from_iterable</code> to flatten the resulting list.</p>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; List1 = [ ['a','b'], ['c','d','e'], ['f'] ]
&gt;&gt;&gt; List2 = [ ['g','h','i'], ['j'], ['k','l'] ]
&gt;&gt;&gt; list(itertools.chain.from_iterable(itertools.product(a,b) for a,b in zip(List1, List2)))
[('a', 'g'), ('a', 'h'), ('a', 'i'), ('b', 'g'), ('b', 'h'), ('b', 'i'), ('c', 'j'), ('d', 'j'), ('e', 'j'), ('f', 'k'), ('f', 'l')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't want to use itertools, you can also use <a href="http://www.diveintopython3.net/comprehensions.html#listcomprehension" rel="nofollow">list comprehensions</a> in combination with <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip</code></a> to do this fairly elegantly:</p>
<pre><code>lst1 = [['a','b'], ['c','d','e'], ['f']]
lst2 = [['g','h','i'], ['j'], ['k','l']]
edges = [[x, y] for il1, il2 in zip(lst1, lst2) for x in il1 for y in il2]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import itertools
k = []
for a,b in zip(List1,List2):
    for j in itertools.product(a,b):
        k.append(j)
print k
</code></pre>
</div>
<span class="comment-copy">It looks like you want the <code>itertools.product</code> of each pair made by <code>zip</code>ping (or <code>itertools.izip</code>ping in 2.x) the two lists together.</span>
<span class="comment-copy">@jonrsharpe beat me to it, but I agree, this is a job for itertools ( <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow noreferrer">docs.python.org/2/library/itertools.html</a> )</span>
<span class="comment-copy">Thank you for your comments, I think this is exactly what I was looking for! I am trying out the solution outlined by Cyber below now.</span>
<span class="comment-copy">since you are using itertools, you may as well chain</span>
<span class="comment-copy">oh yeah :) good catch</span>
<span class="comment-copy"><code>chain.from_iterable</code> could be used to flatten the list. Of course you might need an extra <code>list()</code> call if a generator is not sufficient.</span>
<span class="comment-copy">The user asked for list within a list not a tuple inside a list.So you could you both the example here @Cyber.And your answer was good</span>
<span class="comment-copy">Thank you so much! I really have to get more familiar with these tools, instead of writing everything with for-loops.</span>
<span class="comment-copy">Some what similar to the above solution without using itertools.chain()</span>
