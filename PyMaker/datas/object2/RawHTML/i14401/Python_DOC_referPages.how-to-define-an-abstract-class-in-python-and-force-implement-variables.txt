<div class="post-text" itemprop="text">
<p>So, I am trying to define an abstract base class with couple of variables which I want to to make it mandatory to have for any class which "inherits" this base class.. So, something like:</p>
<pre><code>class AbstractBaseClass(object):
   foo = NotImplemented
   bar = NotImplemented
</code></pre>
<p>Now,</p>
<pre><code>class ConcreteClass(AbstractBaseClass):
    # here I want the developer to force create the class variables foo and bar:
    def __init__(self...):
        self.foo = 'foo'
        self.bar = 'bar'
</code></pre>
<p>This should throw error:</p>
<pre><code>class ConcreteClass(AbstractBaseClass):
    # here I want the developer to force create the class variables foo and bar:
    def __init__(self...):
        self.foo = 'foo'
        #error because bar is missing??
</code></pre>
<p>I maybe using the wrong terminology.. but basically, I want every developer who is "implementing" the above class to force to define these variables??</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update</strong>: <code>abc.abstractproperty</code> has been deprecated in Python 3.3. Use <code>property</code> with <code>abc.abstractmethod</code> instead as shown <a href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="nofollow noreferrer">here</a>.</p>
<pre><code>import abc

class AbstractBaseClass(object):

    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def foo(self):
        pass

    @abc.abstractproperty
    def bar(self):
        pass

class ConcreteClass(AbstractBaseClass):

    def __init__(self, foo, bar):
        self._foo = foo
        self._bar = bar

    @property
    def foo(self):
        return self._foo

    @foo.setter
    def foo(self, value):
        self._foo = value

    @property
    def bar(self):
        return self._bar

    @bar.setter
    def bar(self, value):
        self._bar = value
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>class AbstractBaseClass(object):
    def __init__(self):
        assert hasattr(self, 'foo')
        assert hasattr(self, 'bar')
</code></pre>
</div>
<span class="comment-copy">check out <a href="https://docs.python.org/2/library/abc.html" rel="nofollow noreferrer">docs.python.org/2/library/abc.html</a></span>
<span class="comment-copy"><code>abc</code> provides for abstract properties (which might be applicable here) and abstract methods, not general instance variables.</span>
<span class="comment-copy">But why to check those value at init stage, perhaps the user will define them later. So I think you should set them to None in the Abstract Base Class. And when you need it in some of your abcd methods. If there are again at None, then you'll throw an exception...</span>
<span class="comment-copy">Trust is pretty fundamental to Python programming, with duck typing, lack of private variables, and so on. Even if you could force the developer to initialize the class with those variables, what would stop them from deleting those variables later?</span>
<span class="comment-copy">You may want to demonstrate how to create a read-write property in addition to a read-only property.</span>
<span class="comment-copy">Added setters to make the properties writable</span>
<span class="comment-copy">That's easily defeated by simply overriding and not calling <code>AbstractBaseClass.__init__</code>.</span>
<span class="comment-copy">Also, assertions can be turned off.</span>
<span class="comment-copy">Anything in python could be overridden... If you don't call the base class <b>init</b> you are responsible of what you are doing.</span>
