<div class="post-text" itemprop="text">
<p>How to get previous or next object with this format of code?</p>
<pre><code>alignment = [[a,b,c],[2,3,4],[q,w,e]]

for obj in alignment:
    some code here to get previous object
</code></pre>
<p>I know how to do that with:</p>
<pre><code>for i in range(0,len(alignment)):
    alignment[i-1][objIndex]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/functions.html#enumerate" rel="nofollow"><code>enumerate</code></a> :</p>
<pre><code>alignment = [[a,b,c],[2,3,4],[q,w,e]]

for index,obj in enumerate(alignment):
    alignment[index-1] # pre
    alignment[index+1] # next
</code></pre>
<p><em>Note</em> that as a more efficient way for accessing to <code>next</code> items and refuse of multiple indexing you can use <a href="https://docs.python.org/2/library/functions.html#iter" rel="nofollow"><code>iter()</code></a> function to create an iterator object from your list (from second element to end) and access to   next elements in each iteration with <code>next</code> :</p>
<pre><code>&gt;&gt;&gt; l=[1,2,3,4]
&gt;&gt;&gt; it=iter(l[1:])
&gt;&gt;&gt; for i in l :
...   print i,next(it,None)
... 
1 2
2 3
3 4
4 None
</code></pre>
<p><em>Note</em> that if you don't pass the <code>None</code> as the second argument to <code>next()</code> function it will raise a <code>StopIteration</code> error.You can also handle it with a <code>try-except</code> statement.</p>
<p>Also for short lists you can use <code>zip</code> function and for long lists <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest" rel="nofollow"><code>itertools.izip()</code> function</a> (<code>zip</code> in python 3):</p>
<pre><code>&gt;&gt;&gt; for i,j in zip(l,l[1:]):
...   print i,j
... 
1 2
2 3
3 4
</code></pre>
<p><code>zip(l,l[1:])</code> will give you the following pairs of items :</p>
<pre><code>[(1, 2), (2, 3), (3, 4)]
</code></pre>
<p>and in the loop you can use <code>i</code> as the current item then <code>j</code> will be the next item or use <code>j</code> as the current then <code>i</code> will be the previous!:)</p>
</div>
<div class="post-text" itemprop="text">
<p>There are many different options depending on what your use for the neighbour entry is. For instance, if you only want to process pairs, and not modify the list:</p>
<pre><code>for left,right in zip(somelist[:-1], somelist[1:]):
  pass
</code></pre>
<p>Or if you need to keep the prior entry as a reference:</p>
<pre><code>prev = None
for item in somelist:
  pass
  prev = item
</code></pre>
<p><code>None</code> here is used in place of a prior item for the first, similar to how it's used for the next item after the last in Kasra's iter()-based example. </p>
</div>
<div class="post-text" itemprop="text">
<pre><code>for index, obj in enumerate(alignment):
    alignment[index-1]
</code></pre>
<p>The loop will give the index and object the previous object can be accessed by the (current index - 1) whereas the next by (current index + 1)</p>
</div>
<span class="comment-copy">This will regard the last item to be prior to the first, and cause an error when not finding a next item after the last.</span>
<span class="comment-copy">@YannVernier Indeed and its why is passed the <code>None</code> to <code>next</code> function.</span>
<span class="comment-copy">Why <i>for short lists</i>? The <code>zip()</code> solution is the best option in all cases. If you are in 2.x where <code>zip()</code> isn't lazy, using <code>itertools.izip()</code> is the solution.</span>
<span class="comment-copy">@Lattyware No <code>zip</code> is efficient for short and for long list <code>itertools</code> is the best i wanted to add this after that but seems that i have forgot it! O_0 ... thanks for reminding!</span>
<span class="comment-copy"><code>zip_longest()</code> in Python 3 is not the equivalent to <code>izip()</code> - in Python 3 <code>zip()</code> is lazy (has the behaviour of <code>izip()</code> in 2.x). <code>zip_longest()</code> is if you want a value with the items from the longer iterable, instead of stopping as the shortest one runs out.</span>
<span class="comment-copy">Just saw this question, and this was the first method that popped into my head...</span>
