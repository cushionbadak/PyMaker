<div class="post-text" itemprop="text">
<p>I come from a Javascript background (where properties can be accessed through both <code>.</code> and <code>[]</code> notation), so please forgive me, but what, exactly, is the difference between the two in Python?</p>
<p>From my experimentation it seeems that <code>[]</code> should always be used, both to get the index of a <code>list</code> or <code>set</code> and to get the value from a certain key in a <code>dictionary</code>.  Is this correct, and, if not, when do you use a <code>.</code> in Python?</p>
</div>
<div class="post-text" itemprop="text">
<p>The dot operator is used for accessing attributes of any object. For example, a complex number</p>
<pre><code>&gt;&gt;&gt; c = 3+4j
</code></pre>
<p>has (among others) the two attributes <code>real</code> and <code>imag</code>:</p>
<pre><code>&gt;&gt;&gt; c.real
3.0
&gt;&gt;&gt; c.imag
4.0
</code></pre>
<p>As well as those, it has a method, <code>conjugate()</code>, which is also an attribute:</p>
<pre><code>&gt;&gt;&gt; c.conjugate
&lt;built-in method conjugate of complex object at 0x7f4422d73050&gt;
&gt;&gt;&gt; c.conjugate()
(3-4j)
</code></pre>
<p>Square bracket notation is used for accessing members of a collection, whether that's by key in the case of a dictionary or other mapping:</p>
<pre><code>&gt;&gt;&gt; d = {'a': 1, 'b': 2}
&gt;&gt;&gt; d['a']
1
</code></pre>
<p>... or by index in the case of a sequence like a list or string:</p>
<pre><code>&gt;&gt;&gt; s = ['x', 'y', 'z']
&gt;&gt;&gt; s[2]
'z'
&gt;&gt;&gt; t = 'Kapow!'
&gt;&gt;&gt; t[3]
'o'
</code></pre>
<p>These collections also, separately, have attributes:</p>
<pre><code>&gt;&gt;&gt; d.pop
&lt;built-in method pop of dict object at 0x7f44204068c8&gt;
&gt;&gt;&gt; s.reverse
&lt;built-in method reverse of list object at 0x7f4420454d08&gt;
&gt;&gt;&gt; t.lower
&lt;built-in method lower of str object at 0x7f4422ce2688&gt;
</code></pre>
<p>... and again, in the above cases, these attributes happen to be methods.</p>
<p>While all objects have some attributes, not all objects have members. For example, if we try to use square bracket notation to access a member of our complex number <code>c</code>:</p>
<pre><code>&gt;&gt;&gt; c[0]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'complex' object is not subscriptable
</code></pre>
<p>... we get an error (which makes sense, since there's no obvious way for a complex number to have members).</p>
<p>It's possible to define how <code>[]</code> and <code>.</code> access work in a user-defined class, using the special methods <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__"><code>__getitem__()</code></a> and <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__"><code>__getattr__()</code></a> respectively. Explaining how to do so is beyond the scope of this question, but you can read more about it in the <a href="https://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes">Python Tutorial</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>.</code> is used for accessing attributes (including methods).  <code>[]</code> is used for accessing what are called "items", which typically are the contents of various kinds of container objects.</p>
<p>JavaScript does not distinguish these two things, but Python does.  You are correct that <code>[]</code> is used for accessing the data in a list or dict.  <code>.</code> is used, for instance, for accessing methods like <code>list.append</code> and <code>dict.update</code>.  It is also used for accessing other data on other kinds of objects; for instance, compiled regular expression objects have a <code>pattern</code> attribute holding the regex pattern (you would access it with <code>rx.pattern</code>).</p>
<p>In general, the convention is that <code>[]</code> is used for "open-ended" data storage where you don't know ahead of time how much or what sorts of data the object will hold; <code>.</code> is more commonly used for specific data that the object has "by nature" and which is accessed with a predefined name.  For instance, just knowing that something as a list doesn't tell you what's in it (for which you use <code>[]</code>), but it does tell you that you can append to it (and to access the append method you use <code>.</code>).</p>
<p>The other major difference between Python and JavaScript in this regard is that in Python, the behavior of both <code>.</code> and <code>[]</code> can be customized by the object.  So <code>obj.foo</code> or <code>obj[foo]</code> may do something special if <code>obj</code> is an object that defines its own behavior for them.  There are various custom types that make use of this for their own purposes.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>[]</code> is the index to a container, such as a list or dictionary.</p>
<p><code>.</code> is the member of an object and modules. It can be a method, member data, or attribute.</p>
<pre><code>&gt;&gt;&gt; xs = [1, 7, 3, 4, 5, 4, 3, 4, 1]

&gt;&gt;&gt; xs.count(4)
3

&gt;&gt;&gt; xs[1]
7
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Actually, Python uses the square brackets to enclose a key. For lists, this is an integer (unsigned) index or a slice, while for dicts this is a (hasable) object like string, tuple, etc. or even an integer (singe and unsigned).
This is straight-forward to many other languages which use a similar or even identical syntax.</p>
<p>The <code>.</code> is used to access members of an object, much like for C++, C, Java, JavaScript, etc. It would be quite simple to write a dictionary class which allows to use the dot-syntax to access its elements. However, for this, the keys have to be valid Python identifier <code>(letter { letter | digit |</code>_<code>}</code>.
However, this is not very common.</p>
<p>A set does not support indexing, as it is not ordered internally and there is not relation between a "key" and a "value".
For a list, you do not "get the index", but you do "get the value for an index". For a dict this is similar, but the "index" is more flexible. However, the dict does not allow slicing and is (like the set) unordered.</p>
<p>Sidenote: Python uses an internal dict for an object to organize its members. Just try on the console:</p>
<pre><code>class MyClass:
    def myfunc(self):
        pass

print(MyClass.__dict__)
</code></pre>
<p>You will get all attribute (name:value) of this class. Note the entry for <code>myfunc</code>.</p>
</div>
<span class="comment-copy">(Basically) use <code>[]</code> to access indexes and to create lists. Use <code>.</code> to access object methods</span>
<span class="comment-copy">@RafaelCardoso: <code>.</code> is for attributes in general, not just methods.</span>
<span class="comment-copy">Also worth noting you can override the behavior of these operators in user-defined classes by implementing the <a href="https://docs.python.org/2/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__getitem__</code></a> (for <code>[]</code>) and <a href="https://docs.python.org/2/reference/datamodel.html#object.__getattr__" rel="nofollow noreferrer"><code>__getattr__</code></a> (for <code>.</code>) methods.</span>
<span class="comment-copy">@augurar good point; I've added a short paragraph on that.</span>
<span class="comment-copy">From the docs: <a href="https://docs.python.org/3/reference/expressions.html#attribute-references" rel="nofollow noreferrer">Attribute references</a> and <a href="https://docs.python.org/3/reference/expressions.html#subscriptions" rel="nofollow noreferrer">Subscriptions</a></span>
