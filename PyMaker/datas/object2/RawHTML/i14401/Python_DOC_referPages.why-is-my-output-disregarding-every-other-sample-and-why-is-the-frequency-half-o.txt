<div class="post-text" itemprop="text">
<p>I'm playing with <a href="https://docs.python.org/3/library/wave.html" rel="nofollow">Python's wave module</a>, and I have run into two issues that I can't figure out.</p>
<ol>
<li><p>Every other sample has an amplitude of 0. The desired behavior is to have a continuous sinusoidal wave.</p></li>
<li><p>The produced frequency seems to be half of the desired frequency. Looking at the math, I can't figure why. I understand how to fix it. I just can't figure out the reasoning. In my mind, multiplying the frequency by 2π, not 4π, makes sense to me.</p>
<pre><code>from functools import partial, wraps
from math import pi, sin
import struct
import wave

class Wave:
    def __init__(self, frequency, amplitude=1.0, phase_shift=0.0, vertical_translation=0.0):
        self.frequency = frequency
        self.amplitude = amplitude
        self.phase_shift = phase_shift
        self.vertical_translation = vertical_translation

    def __call__(self, time):
        try:
            amplitude = self.amplitude(time)
        except TypeError:
            amplitude = self.amplitude

        try:
            frequency = self.frequency(time)
        except TypeError:
            frequency = self.frequency

        try:
            phase_shift = self.phase_shift(time)
        except TypeError:
            phase_shift = self.phase_shift

        try:
            vertical_translation = self.vertical_translation(time)
        except TypeError:
            vertical_translation = self.vertical_translation

        return amplitude * sin(2 * pi * frequency * time + phase_shift) + vertical_translation

if __name__ == '__main__':
    SAMPLE_RATE = 96000
    NUMBER_OF_CHANNELS = 1
    SAMPLE_WIDTH = 4
    MAX_AMPLITUDE = 2 ** (8 * SAMPLE_WIDTH - 1)

    with wave.open('output.wav', 'w') as output:
        output.setsampwidth(SAMPLE_WIDTH)
        output.setnchannels(NUMBER_OF_CHANNELS)
        output.setframerate(SAMPLE_RATE)
        output.setcomptype('NONE', 'Uncompressed')

        a440 = Wave(440)

        for time in range(SAMPLE_RATE // a440.frequency):
            sample = MAX_AMPLITUDE * a440(time / SAMPLE_RATE)
            output.writeframes(struct.pack('l', round(sample)))
</code></pre></li>
</ol>
<p>I'd greatly appreciate any insight.</p>
</div>
<div class="post-text" itemprop="text">
<p>I can not reproduce your issue. After running your code I get a perfect sine wave of the expected length (1/440Hz ≈ 0.0023s) when inspecting the .wav in Audacity:</p>
<p><img alt="sine wave" src="https://i.imgur.com/l2DianR.png"/></p>
<p>I do have one note for you, you can't simply round whatever comes out of <code>sin * MAX_AMPLITUDE</code>. You have to truncate towards negative infinity. This is because a (say) 8-bit sample goes from -128 to 127, not -128 to 128.</p>
</div>
<span class="comment-copy">Interesting. I get your output when I change the format from <code>'l'</code> to <code>'d'</code>. Apparently, long integers on my machine are 8-bytes whereas your machine must use 4-byte wide long integers. Well, shoot. So much for platform-independent code.</span>
<span class="comment-copy">@TylerCrompton That makes no sense, <code>d</code> is the double format.</span>
<span class="comment-copy">*shrug* I might have looked at the results when I tried <code>'i'</code>. Anyway, I fixed it by changing the the form to <code>'{}s'.format(SAMPLE_WIDTH)</code> and changing the value to be packed to <code>sample.to_bytes(SAMPLE_WIDTH, 'little', signed=True)</code>. Additionally, I couldn't use only <code>floor</code> for the rounding because it's possible that the sample would be exactly equal to <code>MAX_AMPLITUDE</code>. This is because there is an odd number of possible negative values and an even number of possible positive values when using two's complement. So I used <code>floor</code> and clipped any values out of the allowed range. Thanks!</span>
