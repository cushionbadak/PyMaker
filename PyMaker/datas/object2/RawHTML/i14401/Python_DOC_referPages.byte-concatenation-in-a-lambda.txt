<div class="post-text" itemprop="text">
<p>Let's say I have the following chain:</p>
<pre><code>bchain = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08'
</code></pre>
<p>Then I create an iterator for this chain:</p>
<pre><code>iterator = iter(bchain)
</code></pre>
<p>What I want to do is to have the first 4 bytes of bchain, but by using the iterator and exhaust it. And to do that in a lambda expression.</p>
<p>I have tried to do:</p>
<pre><code>lambda iterator: b''.join(next(iterator) for i in range(4))
</code></pre>
<p>But I get this error</p>
<pre><code>TypeError: sequence item 0: expected bytes, bytearray, or an object with the buffer interface, int found
</code></pre>
<p>It seems like next(iterator) gives the int represented by the next byte in the chain, and not the byte itself. The lambda, in this case, should output</p>
<pre><code>b'\x00\x01\x02\x03'
</code></pre>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>As the docs for <a href="https://docs.python.org/3/library/stdtypes.html#bytes" rel="nofollow"><code>bytes</code></a> explains:</p>
<blockquote>
<p>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers.</p>
</blockquote>
<p>In other words, if <code>b = b'abcd'</code>, then <code>b[0]</code> or <code>next(iter(b))</code> is <code>97</code>, not <code>b'a'</code>.</p>
<p>If you want to construct a <code>bytes</code> object from an iterable of small integers, don't use <code>b''</code>, just call the constructor:</p>
<pre><code>bytes(next(iterator) for i in range(4))
</code></pre>
<p>Of course a much simpler way to do what you wanted is to just slice the <code>bytes</code>:</p>
<pre><code>bchain[:4]
</code></pre>
<p>Or, if you want to work on any iterable of small integers, not just a <code>bytes</code>, use <a href="https://docs.python.org/3/library/itertools.html#itertools.islice" rel="nofollow"><code>islice</code></a>:</p>
<pre><code>bytes(itertools.islice(bchain, 4))
</code></pre>
<hr/>
<p>As J.F. Sebastian points out, this is the reason <a href="http://legacy.python.org/dev/peps/pep-0467/#addition-of-optimised-iterator-methods-that-produce-bytes-objects" rel="nofollow">PEP 467</a> includes <code>iterbytes</code>. Assuming it's added to Python 3.5, you could use <code>b.iterbytes()</code>--or, if <code>b</code> is just "some <code>bytes</code>-like iterable", <code>memoryview(b).iterbytes()</code>--instead of <code>iter(b)</code>, and then you wouldn't have this problem in the first place.</p>
</div>
<span class="comment-copy">Do you want only the first 4 bytes?</span>
<span class="comment-copy">You've way, way overcomplicated your problem. Do you want to know how to write this cleanly, or do you want to know why your existing code doesn't work?</span>
<span class="comment-copy"><code>bytes(next(iterator) for i in range(4))</code> did the works. Thank you. I've thought of slice but it doesn't increment the iterator itself for further manipulation.</span>
<span class="comment-copy">@RobinCarlier: As I said in the answer "If you want it to work on any iterableâ€¦, use <code>islice</code>" That includes iterators.</span>
<span class="comment-copy"><a href="http://legacy.python.org/dev/peps/pep-0467/#addition-of-optimised-iterator-methods-that-produce-bytes-objects" rel="nofollow noreferrer">pep 467 (draft) proposes <code>bytes.iterbytes()</code> method</a>: <code>iterator = bchain.iterbytes()</code></span>
