<div class="post-text" itemprop="text">
<p>I have a long list like this: <code>A = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23']</code></p>
<p>How can I get only the letters part without numbers and make them another list?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; [''.join([l for l in x if l.isalpha()]) for x in xs]
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub</code></a>, this is quite simple!</p>
<pre><code>&gt;&gt;&gt; strings = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23']
&gt;&gt;&gt; import re
&gt;&gt;&gt; [re.sub(r'[^A-Za-z]+', '', s) for s in strings]
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
<p>Want the numbers too?</p>
<pre><code>&gt;&gt;&gt; [re.sub(r'[^\d]+', '', s) for s in strings]
['123', '345', '23']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; A = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23']
&gt;&gt;&gt; B = list(map(lambda x: ''.join([letter for letter in x if letter.isalpha()]), A))
&gt;&gt;&gt; B
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
<p><code>filter()</code> would have been a better choice than <code>map()</code>:</p>
<pre><code>&gt;&gt;&gt; A = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23']
&gt;&gt;&gt; B = [''.join(filter(str.isalpha, a)) for a in A]
&gt;&gt;&gt; B
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
<p>This, of course, is basically identical to @chrisaycock's answer.</p>
<p>If you'd like to eliminate duplicate entries, use a <code>set</code>:</p>
<pre><code>&gt;&gt;&gt; A = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23', 'ABCd 95']
&gt;&gt;&gt; B = set(''.join(filter(str.isalpha, a)) for a in A)
&gt;&gt;&gt; B
{'Efhgh', 'dhAsadjkhdk', 'ABCd'}
</code></pre>
<p>If you'd like to eliminate duplicate entries but you need to preserve the ordering of the original list, sort a set by index:</p>
<pre><code>&gt;&gt;&gt; A = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23', 'ABCd 95']
&gt;&gt;&gt; B = [''.join(filter(str.isalpha, a)) for a in A]
&gt;&gt;&gt; B
['ABCd', 'Efhgh', 'dhAsadjkhdk', 'ABCd']
&gt;&gt;&gt; C = sorted(set(B), key=lambda x: B.index(x))
&gt;&gt;&gt; C
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
<p>or avoid an intermediate <code>list</code> and <code>set</code> by doing it manually:</p>
<pre><code>&gt;&gt;&gt; A = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23', 'ABCd 95']
&gt;&gt;&gt; B = []
&gt;&gt;&gt; for a in A:
...     b = ''.join(filter(str.isalpha, a))
...     if b not in B:
...             B.append(b)
...
&gt;&gt;&gt; B
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; values = ['ABCd 123', 'Efhgh 345', 'dhAsadjkhdk 23']

&gt;&gt;&gt; [value.split()[0] for value in values]
['ABCd', 'Efhgh', 'dhAsadjkhdk']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use regular expressions to search for the groups of letters in the list:</p>
<pre><code>words = map(lambda s: re.findall(r'[a-zA-Z]+', s), A)
words = list(itertools.chain.from_iterable(words))
</code></pre>
</div>
<span class="comment-copy">pythonic overkill :)</span>
<span class="comment-copy">You don't need to make an intermediate list, str.join works on any iterable.</span>
<span class="comment-copy">Much better than flattening the list of matches. +1</span>
<span class="comment-copy">Your solution is better than chrisaycock's answer, if only for the simple reason that in Python 3.x, filter returns an iterator instead of a string. (He's using an intermediate list instead of a generator) In Python 2.x, the advantage is pure elegance, you can simply do <code>filter(str.isalpha, s)</code> and it will automatically return a string without you having to join because filter does a smart type-check.</span>
<span class="comment-copy">Thank you @TigerhawkT3, I think I will use this. But after that, I need only one string if there's the same word of it. Like, I need only 'ABCd' but there is 5 'ABCd' element in the B list that you wrote actually.</span>
<span class="comment-copy">I've updated my answer to include solutions for removing duplicates, with and without preserving the original <code>list</code>'s order.</span>
<span class="comment-copy">This assumes a certain structure which hasn't been mentioned or confirmed and may be coincidental.</span>
<span class="comment-copy">@TigerhawkT3 need more test cases.</span>
