<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/12721676/python-bool-and-int-comparison-and-indexing-on-list-with-boolean-values">Python Bool and int comparison and indexing on list with boolean values</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<pre><code>In [1]: a=5

In [2]: print(["is odd", "is even"][a % 2 == 0])
is odd

In [3]: [a%2 == 0]
Out[3]: [False]
</code></pre>
<p>What I understood is <code>a % 2 == 0</code> evaluates to <code>True</code> or <code>False</code>.</p>
<p>So if it is True then that is equivalent to  1 and using list indices it's going to print <code>'is even'</code>.</p>
<p>I've read <a href="https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int">this</a> and came to know <code>bool</code> is an instance of <code>int</code>. </p>
<p>So when used as in index <code>bool</code> evaluates to it's equivalent number i.e <code>0</code> or <code>1</code>.</p>
<p><strong>My question</strong> </p>
<p>Based on intuition we can know whether it's going to be an <code>int</code> or <code>bool</code> </p>
<p>But how does Python know? Does it have any criteria when to use as <code>bool</code> and when to use as <code>int</code>? Anything from Python3 documentation would be appreiated.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 2.x this is not guaranteed as it is possible for <code>True</code> and <code>False</code> to be reassigned. However, even if this happens, boolean <code>True</code> and boolean <code>False</code> are still properly returned for comparisons.</p>
<p>In Python 3.x True and False are keywords and will always be equal to <code>1</code> and <code>0</code>.</p>
<p>Under normal circumstances in Python 2, and always in Python 3:</p>
<p><code>False</code> object is of type <code>bool</code> which is a subclass of <code>int</code>:</p>
<pre><code> object
   |
  int
   |
  bool
</code></pre>
<p>It is the only reason why in your example, <code>['zero', 'one'][False]</code> does work. It would not work with an object which is not a subclass of integer, because list indexing only works with integers, or objects that define the <code>__index__</code> method (thanks mark-dickinson).</p>
<p><strong>Edit:</strong></p>
<p>It is true of the current Python version, and of that of Python 3. The docs for Python 2.6 and the docs for Python 3 both say:</p>
<blockquote>
<p>There are two types of integers: [...] Integers (int) [...] Booleans (bool)
  and in the boolean subsection:</p>
<p>Booleans: These represent the truth values False and True [...] Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings "False" or "True" are returned, respectively.</p>
</blockquote>
<p>So booleans are explicitly considered as integers in Python 2.6 and 3.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>bool</code> instances, <code>True</code> and <code>False</code>, are separate from the <code>int</code> instances, <code>0</code> and <code>1</code>. The thing is that the bools behave like integers in many contexts. Such as <code>True+True</code> which is 2. However if we check if they are the same object we see it is not: <code>True is 1</code>. On the other hand it is true that <code>True is True</code>. Here's an example which behaves like integers but are printed as True and False and compares differently with <code>is</code>.</p>
<pre><code>class Bool(int):
    def __repr__(self):
        return 'True' if self==1 else 'False'
</code></pre>
<p><a href="https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values" rel="nofollow">https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values</a></p>
</div>
<span class="comment-copy">You are not evaluating an int here but a conditional expression thus you are of course receiving a bool</span>
<span class="comment-copy">Go ahead and run <code>False.real</code> and <code>True.real</code> and see what happens</span>
<span class="comment-copy">@IanAuld False.real=0,True.real=1</span>
<span class="comment-copy">pretty much clear explanation</span>
<span class="comment-copy">thanks mark-dickinson ??</span>
