<div class="post-text" itemprop="text">
<p>Recently, I'm beginner in python, and I've programmed an analog clock on Tkinter, which can display time every second. But this clock uses a <code>while 1</code> infinite loop to refresh the time, that totally blocks the rest of the program. Because I want to use it in an another program, as a parallel function, I had to reprogram the refreshing method.</p>
<p>I've found something about the <code>after()</code> function which can (I think) help me, but I get a <code>RuntimeError: maximum recursion depth exceeded in comparison</code> and I don't understand why. Is the drawing of my clock too heavy for python? I'll put the code here and hope someone understand my problem and can help me.</p>
<p>(PS 1: I don't take care about the code before "principle function" and I don't think the problem is there, but I'll still post it because I'm not sure at all that this part is debugged.</p>
<p>PS 2: I'm really sorry about my English which may be a problem, so tell me if you don't understand.)</p>
<pre><code>#list of imported modules
from tkinter import *
from math import cos, sin
from time import gmtime, sleep

#defining of secondary functions

def drawcircle(Alpha,Beta,Rayon,Couleur,can): #draw a circle base on center coord radius and color
    x1,y1,x2,y2=Alpha-Rayon, Beta-Rayon, Alpha+Rayon, Beta+Rayon
    can.create_oval(x1,y1,x2,y2,fill=Couleur)

def drawPetAig(CoordA, CoordZ, Taille, Omega, can): #function to drawn the second hand of the clock
    Pi = 3.141592
    Omega = ((Omega/60)+1)*30
    can.create_line(CoordA + (Taille/3) * cos(Pi*(Omega/180)), CoordZ + (Taille/3) * sin(Pi*(Omega/180)), CoordA - (Taille/8) * cos(Pi*(Omega/180)), CoordZ - (Taille/8) * sin(Pi*(Omega/180)) )

def drawGrdAig(CoordA, CoordZ, Taille, Omega, can): #function to draw the minute hand, based on center coord and minutes.
    Pi = 3.141592
    Omega = (Omega-15)*6
    can.create_line(CoordA + (Taille/1.5) * cos(Pi*(Omega/180)), CoordZ + (Taille/1.5) * sin(Pi*(Omega/180)), CoordA - (Taille/6) * cos(Pi*(Omega/180)), CoordZ - (Taille/6) * sin(Pi*(Omega/180)))

def drawSecAig(CoordA, CoordZ, Taille, Omega, can): #function to draw the hour hand
    Pi = 3.141592
    Omega = (Omega-15) *6
    can.create_line(CoordA + (Taille/1.5) * cos(Pi*(Omega/180)), CoordZ + (Taille/1.5) * sin(Pi*(Omega/180)), CoordA - (Taille/6) * cos(Pi*(Omega/180)), CoordZ - (Taille/6) * sin(Pi*(Omega/180)), fill = "red")

def fondhorloge(CoordA, CoordZ, Taille, can1):  #function drawing the backgroud of the clock
    Pi = 3.141592
    drawcircle(CoordA, CoordZ, Taille + (Taille/10), "grey6",can1) #drawing the surrounding of the clock
    drawcircle(CoordA, CoordZ, Taille, "ivory3",can1)#backgroud
    drawcircle(CoordA, CoordZ, Taille/80, "grey6",can1)#central point/needle articulation
    can1.create_line(CoordA + (Taille - (Taille/15)), CoordZ, CoordA + (Taille - (Taille/5)), CoordZ) #drawing the N/S/E/W decorativ hour position
    can1.create_line(CoordA, CoordZ + (Taille - (Taille/15)), CoordA, CoordZ + (Taille - (Taille/5)))
    can1.create_line(CoordA - (Taille - (Taille/15)), CoordZ, CoordA - (Taille - (Taille/5)), CoordZ)
    can1.create_line(CoordA, CoordZ - (Taille - (Taille/15)), CoordA, CoordZ - (Taille - (Taille/5)))

    #here, this 4*2 line defined the position of the 8 intermediate line between the N/S/E/W decorativ line.
    can1.create_line(CoordA + (Taille/1.05) * cos(Pi*(30/180)), CoordZ + (Taille/1.05) * sin(Pi*(30/180)), CoordA + (Taille/1.20) * cos(Pi*(30/180)), CoordZ + (Taille/1.20) * sin(Pi*(30/180)))
    can1.create_line(CoordA + (Taille/1.05) * cos(Pi*(60/180)), CoordZ + (Taille/1.05) * sin(Pi*(60/180)), CoordA + (Taille/1.20) * cos(Pi*(60/180)), CoordZ + (Taille/1.20) * sin(Pi*(60/180)))

    can1.create_line(CoordA - (Taille/1.05) * cos(Pi*(30/180)), CoordZ - (Taille/1.05) * sin(Pi*(30/180)), CoordA - (Taille/1.20) * cos(Pi*(30/180)), CoordZ - (Taille/1.20) * sin(Pi*(30/180)))
    can1.create_line(CoordA - (Taille/1.05) * cos(Pi*(60/180)), CoordZ - (Taille/1.05) * sin(Pi*(60/180)), CoordA - (Taille/1.20) * cos(Pi*(60/180)), CoordZ - (Taille/1.20) * sin(Pi*(60/180)))

    can1.create_line(CoordA + (Taille/1.05) * cos(Pi*(30/180)), CoordZ - (Taille/1.05) * sin(Pi*(30/180)), CoordA + (Taille/1.20) * cos(Pi*(30/180)), CoordZ - (Taille/1.20) * sin(Pi*(30/180)))
    can1.create_line(CoordA + (Taille/1.05) * cos(Pi*(60/180)), CoordZ - (Taille/1.05) * sin(Pi*(60/180)), CoordA + (Taille/1.20) * cos(Pi*(60/180)), CoordZ - (Taille/1.20) * sin(Pi*(60/180)))

    can1.create_line(CoordA - (Taille/1.05) * cos(Pi*(30/180)), CoordZ + (Taille/1.05) * sin(Pi*(30/180)), CoordA - (Taille/1.20) * cos(Pi*(30/180)), CoordZ + (Taille/1.20) * sin(Pi*(30/180)))
    can1.create_line(CoordA - (Taille/1.05) * cos(Pi*(60/180)), CoordZ + (Taille/1.05) * sin(Pi*(60/180)), CoordA - (Taille/1.20) * cos(Pi*(60/180)), CoordZ + (Taille/1.20) * sin(Pi*(60/180)))

#PRINCIPLE FUNCTION (here the problem starts)

def HORLOGE1(Gamma, Pi, Epsylon):# draw a clock with the center position x/x = gamma/pi and the radius = epsylon

    fondhorloge(Gamma, Pi, Epsylon, can1)# extracting time value
    patate = gmtime()
    heure = patate[3] + 1  # "+1" is changing time from english time to french time :P
    minute = patate[4]
    seconde = patate[5]

    print(heure, minute, seconde) # a simple test to watch what the programm is doing (run it, and you'll see, that this test is done tausend time per second, that why I think the problem is here.)
    drawPetAig(Gamma, Pi, Epsylon, minute, can1)
    drawGrdAig(Gamma, Pi, Epsylon, minute, can1)
    drawSecAig(Gamma, Pi, Epsylon, seconde, can1)
    fen1.after(1000, HORLOGE1(250, 250, 200))

#execution of the main function

fen1 = Tk()
can1 = Canvas(fen1, bg="white", height=500, width=500)
can1.pack()

HORLOGE1(250, 250, 200)

fen1.mainloop()
fen1.destroy()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that in the principle function, <code>HORLOGE1()</code> calls itself immediately while trying to arrange for it to be called again after the specified 1 second delay. This occurs in the last line:</p>
<pre><code>fen1.after(1000, HORLOGE1(250, 250, 200))
</code></pre>
<p>A simple way prevent this, would be to use something like this instead:</p>
<pre><code>fen1.after(1000, lambda: HORLOGE1(250, 250, 200))
</code></pre>
<p>What this does is create an anonymous function using a <a href="https://docs.python.org/3/reference/expressions.html?highlight=lambdas#lambda" rel="nofollow noreferrer"><code>lambda</code> expression </a>. The function created accepts/requires no arguments, and all it does is call <code>HORLOGE1(250, 250, 200)</code> when it's called. <em>That function</em> is what is then passed to <code>fen1.after()</code> as the second argument. </p>
<p>The notable thing is that doing this does <em>not</em> actually call <code>HORLOGE1()</code> in the process. The second argument to <code>.after()</code> should almost always be a callable — such as a function or a bound method — rather than the results of calling one, as you are doing.</p>
<p>After making the change, you should see something like this with moving clock hands on it:</p>
<p><img alt="screenshot of analog clock displayed in tkinter window" src="https://i.stack.imgur.com/AHH0a.png"/></p>
</div>
<span class="comment-copy">I think you mean the "hands" on an analogue clock. Please read <a href="http://stackoverflow.com/help/mcve">stackoverflow.com/help/mcve</a>. If you're <i>"not sure at all that this part is unbugged"</i> then <b>test it and find out</b> - narrowing down the problem to the smallest possible part of your code is exactly what you should do before asking a question (and may avoid needing to ask at all...)</span>
<span class="comment-copy">Off topic, but you could optimize the drawing of the clock and make it much "lighter" by doing all the redundant math calculations once and storing the values in local variables and then usin them to make the subsequent function calls thereby avoiding the doing of it over-and-over so many times whenever it's refreshed.</span>
<span class="comment-copy">Do you realize you are drawing a complete new clock every second? You really should draw the clock once, save a reference to the hands and then use <a href="http://effbot.org/tkinterbook/canvas.htm#Tkinter.Canvas.coords-method" rel="nofollow noreferrer"><code>canvas.coords</code></a> to change the location of the hands every second.</span>
<span class="comment-copy">It is because HORLOGE1() keeps calling itself that you are exceeding the recursion depth - each second it gets one level deeper.</span>
<span class="comment-copy">@neil: That's what the change in my answer fixes.</span>
<span class="comment-copy">I was trying to clarify to Vanry why a function calling itself was a problem and how it related to the error message (particularly "recursion depth").  Your answer clearly deals with how to solve it.</span>
<span class="comment-copy">@neil: Oh...it wasn't clear to me which "you" you were addressing. The person asking the question is usually referred to as the "OP" which is short for Original Poster (of the question) or explicitly via @.</span>
<span class="comment-copy">@neil: Actually now that I think about it, what you said in your original comment isn't quite right. <code>HORLOGE1()</code> exceeds the recursion limit the very first time it's called, which is before <code>fen1.after()</code> is even invoked, not "one level deeper each second" — the whole delayed timing mechanism that <code>after()</code> sets up never comes into play in the OP's version of the code because the recursion error occurs before it actually ever gets called.</span>
