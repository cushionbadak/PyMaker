<div class="post-text" itemprop="text">
<p>I recently compared the processing speeds of <code>[]</code> and <code>list()</code> and was surprised to discover that <code>[]</code> runs <em>more than three times faster</em> than <code>list()</code>. I ran the same test with <code>{}</code> and <code>dict()</code> and the results were practically identical: <code>[]</code> and <code>{}</code> both took around 0.128sec / million cycles, while <code>list()</code> and <code>dict()</code> took roughly 0.428sec / million cycles each.</p>
<p>Why is this? Do <code>[]</code> and <code>{}</code> (and probably <code>()</code> and <code>''</code>, too) immediately pass back a copies of some empty stock literal while their explicitly-named counterparts (<code>list()</code>, <code>dict()</code>, <code>tuple()</code>, <code>str()</code>) fully go about creating an object, whether or not they actually have elements?</p>
<p>I have no idea how these two methods differ but I'd love to find out.
I couldn't find an answer in the docs or on SO, and searching for empty brackets turned out to be more problematic than I'd expected.</p>
<p>I got my timing results by calling <code>timeit.timeit("[]")</code> and <code>timeit.timeit("list()")</code>, and <code>timeit.timeit("{}")</code> and <code>timeit.timeit("dict()")</code>, to compare lists and dictionaries, respectively. I'm running Python 2.7.9.</p>
<p>I recently discovered "<a href="https://stackoverflow.com/questions/18123965/why-if-true-is-slower-than-if-1">Why is if True slower than if 1?</a>" that compares the performance of <code>if True</code> to <code>if 1</code> and seems to touch on a similar literal-versus-global scenario; perhaps it's worth considering as well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>[]</code> and <code>{}</code> are <em>literal syntax</em>. Python can create bytecode just to create the list or dictionary objects:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(compile('[]', '', 'eval'))
  1           0 BUILD_LIST               0
              3 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(compile('{}', '', 'eval'))
  1           0 BUILD_MAP                0
              3 RETURN_VALUE        
</code></pre>
<p><code>list()</code> and <code>dict()</code> are separate objects. Their names need to be resolved, the stack has to be involved to push the arguments, the frame has to be stored to retrieve later, and a call has to be made. That all takes more time.</p>
<p>For the empty case, that means you have at the very least a <a href="https://docs.python.org/2/library/dis.html#opcode-LOAD_NAME" rel="noreferrer"><code>LOAD_NAME</code></a> (which has to search through the global namespace as well as the <a href="https://docs.python.org/2/library/__builtin__.html" rel="noreferrer"><code>__builtin__</code> module</a>) followed by a <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" rel="noreferrer"><code>CALL_FUNCTION</code></a>, which has to preserve the current frame:</p>
<pre><code>&gt;&gt;&gt; dis.dis(compile('list()', '', 'eval'))
  1           0 LOAD_NAME                0 (list)
              3 CALL_FUNCTION            0
              6 RETURN_VALUE        
&gt;&gt;&gt; dis.dis(compile('dict()', '', 'eval'))
  1           0 LOAD_NAME                0 (dict)
              3 CALL_FUNCTION            0
              6 RETURN_VALUE        
</code></pre>
<p>You can time the name lookup separately with <code>timeit</code>:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('list', number=10**7)
0.30749011039733887
&gt;&gt;&gt; timeit.timeit('dict', number=10**7)
0.4215109348297119
</code></pre>
<p>The time discrepancy there is probably a dictionary hash collision. Subtract those times from the times for calling those objects, and compare the result against the times for using literals:</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('[]', number=10**7)
0.30478692054748535
&gt;&gt;&gt; timeit.timeit('{}', number=10**7)
0.31482696533203125
&gt;&gt;&gt; timeit.timeit('list()', number=10**7)
0.9991960525512695
&gt;&gt;&gt; timeit.timeit('dict()', number=10**7)
1.0200958251953125
</code></pre>
<p>So having to call the object takes an additional <code>1.00 - 0.31 - 0.30 == 0.39</code> seconds per 10 million calls.</p>
<p>You can avoid the global lookup cost by aliasing the global names as locals (using a <code>timeit</code> setup, everything you bind to a name is a local):</p>
<pre><code>&gt;&gt;&gt; timeit.timeit('_list', '_list = list', number=10**7)
0.1866450309753418
&gt;&gt;&gt; timeit.timeit('_dict', '_dict = dict', number=10**7)
0.19016098976135254
&gt;&gt;&gt; timeit.timeit('_list()', '_list = list', number=10**7)
0.841480016708374
&gt;&gt;&gt; timeit.timeit('_dict()', '_dict = dict', number=10**7)
0.7233691215515137
</code></pre>
<p>but you never can overcome that <code>CALL_FUNCTION</code> cost.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>list()</code> requires a global lookup and a function call but <code>[]</code> compiles to a single instruction. See:</p>
<pre><code>Python 2.7.3
&gt;&gt;&gt; import dis
&gt;&gt;&gt; print dis.dis(lambda: list())
  1           0 LOAD_GLOBAL              0 (list)
              3 CALL_FUNCTION            0
              6 RETURN_VALUE        
None
&gt;&gt;&gt; print dis.dis(lambda: [])
  1           0 BUILD_LIST               0
              3 RETURN_VALUE        
None
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>list</code> is a <a href="https://docs.python.org/2/library/functions.html#list">function</a> to convert say a string to a list object, while <code>[]</code> is used to create a list off the bat. Try this (might make more sense to you):</p>
<pre><code>x = "wham bam"
a = list(x)
&gt;&gt;&gt; a
["w", "h", "a", "m", ...]
</code></pre>
<p>While</p>
<pre><code>y = ["wham bam"]
&gt;&gt;&gt; y
["wham bam"]
</code></pre>
<p>Gives you a actual list containing whatever you put in it.</p>
</div>
<div class="post-text" itemprop="text">
<p>The answers here are great, to the point and fully cover this question. I'll drop a further step down from byte-code for those interested. I'm using the most recent repo of CPython; older versions behave similar in this regard but slight changes might be in place.</p>
<p>Here's a break down of the execution for each of these, <code>BUILD_LIST</code> for <code>[]</code> and <code>CALL_FUNCTION</code> for <code>list()</code>.</p>
<hr/>
<h3><a href="https://github.com/python/cpython/blob/2f37d372927a4c2c843e2813c32354979c682919/Python/ceval.c#L2453" rel="noreferrer">The <code>BUILD_LIST</code> instruction:</a></h3>
<p>You should just view the horror:</p>
<pre class="lang-c prettyprint-override"><code>PyObject *list =  PyList_New(oparg);
if (list == NULL)
    goto error;
while (--oparg &gt;= 0) {
    PyObject *item = POP();
    PyList_SET_ITEM(list, oparg, item);
}
PUSH(list);
DISPATCH();
</code></pre>
<p>Terribly convoluted, I know. This is how simple it is:</p>
<ul>
<li>Create a new list with <a href="https://github.com/python/cpython/blob/2f37d372927a4c2c843e2813c32354979c682919/Objects/listobject.c#L140" rel="noreferrer"><code>PyList_New</code></a> (this mainly allocates the memory for a new list object), <code>oparg</code> signalling the number of arguments on the stack. Straight to the point.</li>
<li>Check that nothing went wrong with <code>if (list==NULL)</code>. </li>
<li>Add any arguments (in our case this isn't executed) located on the stack with <a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Include/listobject.h#L73" rel="noreferrer"><code>PyList_SET_ITEM</code></a> (a macro).</li>
</ul>
<p>No wonder it is fast! It's custom-made for creating new lists, nothing else :-)</p>
<h3><a href="https://github.com/python/cpython/blob/2f37d372927a4c2c843e2813c32354979c682919/Python/ceval.c#L3229" rel="noreferrer">The <code>CALL_FUNCTION</code> instruction:</a></h3>
<p>Here's the first thing you see when you peek at the code handling <code>CALL_FUNCTION</code>:</p>
<pre class="lang-c prettyprint-override"><code>PyObject **sp, *res;
sp = stack_pointer;
res = call_function(&amp;sp, oparg, NULL);
stack_pointer = sp;
PUSH(res);
if (res == NULL) {
    goto error;
}
DISPATCH();
</code></pre>
<p>Looks pretty harmless, right? Well, no, unfortunately not, <a href="https://github.com/python/cpython/blob/2f37d372927a4c2c843e2813c32354979c682919/Python/ceval.c#L4726" rel="noreferrer"><code>call_function</code></a> is not a straightforward guy that will call the function immediately, it can't. Instead, it grabs the object from the stack, grabs all arguments of the stack and then switches based on the type of the object; is it a:</p>
<ul>
<li><a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/methodobject.c#L489" rel="noreferrer"><code>PyCFunction_Type</code></a>? Nope, it is <code>list</code>, <code>list</code> isn't of type <code>PyCFunction</code></li>
<li><a href="https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/classobject.c#L334" rel="noreferrer"><code>PyMethodType</code></a>? Nope, see previous.</li>
<li><a href="https://github.com/python/cpython/blob/4106e4237df5397efc785ce4daa257aecb5bff75/Objects/funcobject.c#L628" rel="noreferrer"><code>PyFunctionType</code></a>? Nopee, see previous.</li>
</ul>
<p>We're calling the <code>list</code> type, the argument passed in to <code>call_function</code> is <a href="https://github.com/python/cpython/blob/a8b89cd0611f2732491a72b37651f110fb0ed8ec/Objects/listobject.c#L2624" rel="noreferrer"><code>PyList_Type</code></a>. CPython now has to call a generic function to handle any callable objects named <a href="https://github.com/python/cpython/blob/a8b89cd0611f2732491a72b37651f110fb0ed8ec/Objects/abstract.c#L2455" rel="noreferrer"><code>_PyObject_FastCallKeywords</code></a>, yay more function calls.</p>
<p>This function again makes some checks for certain function types (which I cannot understand why) and then, after creating a dict for kwargs <em>if required</em>, goes on to call <a href="https://github.com/python/cpython/blob/a8b89cd0611f2732491a72b37651f110fb0ed8ec/Objects/abstract.c#L2280" rel="noreferrer"><code>_PyObject_FastCallDict</code></a>.</p>
<p><code>_PyObject_FastCallDict</code> finally gets us somewhere! After performing <em>even more checks</em>  it <a href="https://github.com/python/cpython/blob/a8b89cd0611f2732491a72b37651f110fb0ed8ec/Objects/abstract.c#L2310" rel="noreferrer">grabs the <code>tp_call</code> slot from the <code>type</code></a> of the <code>type</code> we've passed in, that is, it grabs <code>type.tp_call</code>. It then proceeds to create a tuple out of of the arguments passed in with <code>_PyStack_AsTuple</code> and, finally, <em><a href="https://github.com/python/cpython/blob/a8b89cd0611f2732491a72b37651f110fb0ed8ec/Objects/abstract.c#L2322" rel="noreferrer">a call can finally be made</a></em>!</p>
<p><code>tp_call</code>, which matches <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L877" rel="noreferrer"><code>type.__call__</code></a> takes over and finally creates the list object. It calls the lists <code>__new__</code> which corresponds to <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L959" rel="noreferrer"><code>PyType_GenericNew</code></a> and allocates memory for it with <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L929" rel="noreferrer"><code>PyType_GenericAlloc</code></a>: <em>This is actually the part where it catches up with <code>PyList_New</code>, finally</em>. All the previous are necessary to handle objects in a generic fashion.</p>
<p>In the end, <code>type_call</code> calls <code>list.__init__</code> and initializes the list with any available arguments, then we go on a returning back the way we came. :-)</p>
<p>Finally, remmeber the <code>LOAD_NAME</code>, that's another guy that contributes here.</p>
<hr/>
<p>It's easy to see that, when dealing with our input, Python generally has to jump through hoops in order to actually find out the appropriate <code>C</code> function to do the job. It doesn't have the curtesy of immediately calling it because it's dynamic, someone might mask <code>list</code> (<em>and boy do many people do</em>) and another path must be taken. </p>
<p>This is where <code>list()</code> loses much: The exploring Python needs to do to find out what the heck it should do.</p>
<p>Literal syntax, on the other hand, means exactly one thing; it cannot be changed and always behaves in a pre-determined way.</p>
<p><sup>Footnote: All function names are subject to change from one release to the other. The point still stands and most likely will stand in any future versions, it's the dynamic look-up that slows things down.</sup></p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>Why is <code>[]</code> faster than <code>list()</code>?</h2>
</blockquote>
<p>The biggest reason is that Python treats <code>list()</code> just like a user-defined function, which means you can intercept it by aliasing something else to <code>list</code> and do something different (like use your own subclassed list or perhaps a deque). </p>
<p>It immediately creates a new instance of a builtin list with <code>[]</code>.</p>
<p>My explanation seeks to give you the intuition for this.</p>
<h3>Explanation</h3>
<p><code>[]</code> is commonly known as literal syntax. </p>
<p>In the grammar, this is referred to as a "list display". <a href="https://docs.python.org/3/reference/expressions.html#list-displays" rel="noreferrer">From the docs</a>:</p>
<blockquote>
<p>A list display is a possibly empty series of expressions enclosed in
  square brackets:</p>
<pre><code>list_display ::=  "[" [starred_list | comprehension] "]"
</code></pre>
<p>A list display yields a new list object, the contents being specified
  by either a list of expressions or a comprehension. When a
  comma-separated list of expressions is supplied, its elements are
  evaluated from left to right and placed into the list object in that
  order. When a comprehension is supplied, the list is constructed from
  the elements resulting from the comprehension.</p>
</blockquote>
<p>In short, this means that a builtin object of type <code>list</code> is created. </p>
<p>There is no circumventing this - which means Python can do it as quickly as it may.</p>
<p>On the other hand, <code>list()</code> can be intercepted from creating a builtin <code>list</code> using the builtin list constructor.</p>
<p>For example, say we want our lists to be created noisily:</p>
<pre><code>class List(list):
    def __init__(self, iterable=None):
        if iterable is None:
            super().__init__()
        else:
            super().__init__(iterable)
        print('List initialized.')
</code></pre>
<p>We could then intercept the name <code>list</code> on the module level global scope, and then when we create a <code>list</code>, we actually create our subtyped list:</p>
<pre><code>&gt;&gt;&gt; list = List
&gt;&gt;&gt; a_list = list()
List initialized.
&gt;&gt;&gt; type(a_list)
&lt;class '__main__.List'&gt;
</code></pre>
<p>Similarly we could remove it from the global namespace </p>
<pre><code>del list
</code></pre>
<p>and put it in the builtin namespace:</p>
<pre><code>import builtins
builtins.list = List
</code></pre>
<p>And now:</p>
<pre><code>&gt;&gt;&gt; list_0 = list()
List initialized.
&gt;&gt;&gt; type(list_0)
&lt;class '__main__.List'&gt;
</code></pre>
<p>And note that the list display creates a list unconditionally:</p>
<pre><code>&gt;&gt;&gt; list_1 = []
&gt;&gt;&gt; type(list_1)
&lt;class 'list'&gt;
</code></pre>
<p>We probably only do this temporarily, so lets undo our changes - first remove the new <code>List</code> object from the builtins:</p>
<pre><code>&gt;&gt;&gt; del builtins.list
&gt;&gt;&gt; builtins.list
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: module 'builtins' has no attribute 'list'
&gt;&gt;&gt; list()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'list' is not defined
</code></pre>
<p>Oh, no, we lost track of the original. </p>
<p>Not to worry, we can still get <code>list</code> - it's the type of a list literal:</p>
<pre><code>&gt;&gt;&gt; builtins.list = type([])
&gt;&gt;&gt; list()
[]
</code></pre>
<p>So...</p>
<blockquote>
<p>Why is <code>[]</code> faster than <code>list()</code>?</p>
</blockquote>
<p>As we've seen - we can overwrite <code>list</code> - but we can't intercept the creation of the literal type. When we use <code>list</code> we have to do the lookups to see if anything is there.</p>
<p>Then we have to call whatever callable we have looked up. From the grammar:</p>
<blockquote>
<p>A call calls a callable object (e.g., a function) with a possibly
  empty series of arguments:</p>
<pre><code>call                 ::=  primary "(" [argument_list [","] | comprehension] ")"
</code></pre>
</blockquote>
<p>We can see that it does the same thing for any name, not just list:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis('list()')
  1           0 LOAD_NAME                0 (list)
              2 CALL_FUNCTION            0
              4 RETURN_VALUE
&gt;&gt;&gt; dis.dis('doesnotexist()')
  1           0 LOAD_NAME                0 (doesnotexist)
              2 CALL_FUNCTION            0
              4 RETURN_VALUE
</code></pre>
<p>For <code>[]</code> there is no function call at the Python bytecode level:</p>
<pre><code>&gt;&gt;&gt; dis.dis('[]')
  1           0 BUILD_LIST               0
              2 RETURN_VALUE
</code></pre>
<p>It simply goes straight to building the list without any lookups or calls at the bytecode level.</p>
<h3>Conclusion</h3>
<p>We have demonstrated that <code>list</code> can be intercepted with user code using the scoping rules, and that <code>list()</code> looks for a callable and then calls it.</p>
<p>Whereas <code>[]</code> is a list display, or a literal, and thus avoids the name lookup and function call.</p>
</div>
<span class="comment-copy">Note: <code>()</code> and <code>''</code> are special, as they're not only empty, they're immutable, and as such, it's an easy win to make them singletons; they don't even construct new objects, just load the singleton for the empty <code>tuple</code>/<code>str</code>. Technically an implementation detail, but I have a hard time imagining why they <i>wouldn't</i>  cache the empty <code>tuple</code>/<code>str</code> for performance reasons. So your intuition about <code>[]</code> and <code>{}</code> passing back a stock literal was wrong, but it does apply to <code>()</code> and <code>''</code>.</span>
<span class="comment-copy">Also related: <a href="https://stackoverflow.com/questions/53977997/python-performance-comparison-for-creating-sets-set-vs-literal/53978015#53978015">Why is <code>{}</code> faster than calling <code>set()</code>?</a></span>
<span class="comment-copy">This does not directly address the question. The question was about why <code>[]</code> is faster than <code>list()</code>, not why <code>['wham bam']</code> is faster than <code>list('wham bam')</code>.</span>
<span class="comment-copy">@JeremyVisser That made little sense to me because <code>[]</code>/<code>list()</code> is exactly the same as <code>['wham']</code>/<code>list('wham')</code> because they have the same variable differences just as <code>1000/10</code> is the same as <code>100/1</code> in math. You could in theory take away <code>wham bam</code> and the fact would still be the same, that <code>list()</code> tries to convert something by calling a function name while <code>[]</code> will straight up just convert the variable. Function calls are different yes, this is just a logical overview of the issue as for instance a network map of a company is also logical of a solution/problem. Vote however you want.</span>
<span class="comment-copy">@JeremyVisser on the contrary, it shows that they do different operations on the content.</span>
<span class="comment-copy">+1 for pointing out that you can hijack <code>list</code> and the python compiler can't be sure if it will really return an empty list.</span>
