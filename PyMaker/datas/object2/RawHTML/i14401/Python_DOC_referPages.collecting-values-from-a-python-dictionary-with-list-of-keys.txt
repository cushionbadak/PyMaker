<div class="post-text" itemprop="text">
<pre><code>Dict = {'w1': 56, 'w2': 19, 'w3': 77, 'w4': 45, 'w5': 31}
myWords = ['w1','w4','w5']

OutputList=[]
for items in myWords:
    tmps = Dict[items]
    OutputList.append(tmps)
</code></pre>
<p>My question is can we, <em>without</em> using <strong><code>for</code> loop</strong>, collect the values (output) from a dictionary with a particular list ("myWord")?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is what <a href="https://docs.python.org/2/library/operator.html#operator.itemgetter" rel="noreferrer"><code>operator.itemgetter</code></a> is for:</p>
<pre><code>&gt;&gt;&gt; import operator
&gt;&gt;&gt; Dict = {'w1': 56, 'w2': 19, 'w3': 77, 'w4': 45, 'w5': 31}
&gt;&gt;&gt; myWords = ['w1','w4','w5']
&gt;&gt;&gt; operator.itemgetter(*myWords)(Dict)
[56, 45, 31]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use a <em>list comprehension</em>:</p>
<pre><code>OutputList = [Dict[x] for x in myWords]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here are benchmarks of several different methods:</p>
<pre><code>from __future__ import print_function
import timeit
from operator import itemgetter

def f1(d, l):
    '''map'''
    return list(map(d.get, l))

def f2(d, l):
    '''itemgetter'''
    return itemgetter(*l)(d)

def f3(d, l):
    '''list comprehension'''
    return [d[k] for k in l]

def f4(d, l):
    '''WRONG, but map and filter'''
    return list(map(lambda k: d[k], filter(d.get, l)))

def f5(d, l):
    '''simple for loop'''
    rtr=[]
    for e in l:
        rtr.append(d[e])
    return rtr  

def f6(d, l):
    '''CORRECTED map, filter '''    
    return list(map(lambda k: d[k], filter(d.__contains__, l))) 

if __name__ == '__main__':
    s=10000000
    d={'W{}'.format(k):k for k in range(s)} 
    l=['W{}'.format(x) for x in range(0,s,4)]

    times=[]                
    for f in (f1,f2,f3,f4,f5,f6):
        times.append((f.__doc__, timeit.timeit('f(d,l)', setup="from __main__ import f, d, l", number=10)))

    for e in sorted(times, key=itemgetter(1)):
         print('{:30}{:10.3f} seconds'.format(*e))
</code></pre>
<p>For Python 2.7, prints:</p>
<pre><code>itemgetter                         4.109 seconds
list comprehension                 4.467 seconds
map                                5.450 seconds
simple for loop                    6.132 seconds
CORRECTED map, filter             11.283 seconds
WRONG, but map and filter         11.852 seconds
</code></pre>
<p>Python 3.4:</p>
<pre><code>itemgetter                         5.196 seconds
list comprehension                 5.224 seconds
map                                5.923 seconds
simple for loop                    6.548 seconds
WRONG, but map and filter          9.080 seconds
CORRECTED map, filter              9.931 seconds
</code></pre>
<p>PyPy:</p>
<pre><code>list comprehension                 4.450 seconds
map                                4.718 seconds
simple for loop                    5.962 seconds
itemgetter                         7.952 seconds
WRONG, but map and filter          8.962 seconds
CORRECTED map, filter              9.909 seconds
</code></pre>
<p>You can see that even with a dictionary of similar size (1,000,000 elements) to what the OP states, that a simple 'for' loop is competitive with fancier methods. A list comprehension is very competitive. </p>
<p>You can also see that something that looks fancy is not that great.</p>
<p><em>premature optimization is the root of all evil</em></p>
</div>
<div class="post-text" itemprop="text">
<p>or to use map, if <code>myWords</code> contains keys the dictionary <code>Dict</code>, to use</p>
<pre><code>OutputList = map(Dict.get, myWords)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>l = ['a', 'b', 'c'] 
d = { 'a': 1, 'b': 2}
result = map(lambda x: d[x], filter(d.get, l))
print result #[1, 2]
</code></pre>
</div>
<span class="comment-copy">Why do you want to avoid using a for-loop?</span>
<span class="comment-copy"><b>Do not</b> use variables with an upper case name! <b>Do not</b> reuse the name of built-ins with only a changed capitalization!</span>
<span class="comment-copy">Not sure <i>how</i> you managed it, but it looks like you uncovered a bug. You cannot normally mark more than one answer as 'accepted' (you are supposed to pick the one that helped you the most). Yet here we are, with two answers marked as accepted.. See <a href="https://meta.stackoverflow.com/q/294342">How did this question get two accepted answers?</a></span>
<span class="comment-copy">Hi, Chepner If the dict is large said len(Dict.keys()) = 1048576, and my list about 10000, so the  operator.itemgetter can improve the performance when compare to For loop ?</span>
<span class="comment-copy">You would have to test it, but I imagine <code>itemgetter</code> should be faster.</span>
<span class="comment-copy">Hey chepner, nice answer. However a small suggestion .. Do add a link to the <a href="https://docs.python.org/2/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">docs</a> as it will really help those who don't know about <code>operator.itemgetter</code></span>
<span class="comment-copy">Good suggestion. I've added a link to the Python 2 docs; I don't think there are any differences in the <a href="https://docs.python.org/3.4/library/operator.html#operator.itemgetter" rel="nofollow noreferrer">Python 3 version</a>.</span>
<span class="comment-copy">Is a (<code>for</code>) loop implicit in a comprehension?</span>
<span class="comment-copy">yes, either way you have to loop over the list, in Python if possible it's better to use map and the builtin functions when iterating, because those are implemented in C</span>
<span class="comment-copy">@wwii: Just because the list comprehension syntax includes the keyword <code>for</code>, doesn't mean it is a "for loop".</span>
<span class="comment-copy">@Javier sometimes comprehensions are more efficient than using <code>map</code> and the other builtins.</span>
<span class="comment-copy">@ChinLim: The relative performance of the two options depends on your environment and data. I suggest you measure the performance of each to determine which is fastest on your system.</span>
<span class="comment-copy">Interesting that <code>itemgetter</code> is actually <i>worse</i> in PyPy, rather than just being less optimized.</span>
<span class="comment-copy">Hi, Jose. If the dict is large said  len(Dict.keys()) = 1048576, and my list about 10000, so the map function can improve the performance when compare to For loop ?</span>
<span class="comment-copy">@GregHewgill can you help me with this question, because I do not know</span>
<span class="comment-copy">@ChinLim, try it and see - <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow noreferrer">timeit</a></span>
<span class="comment-copy">this approach will include None in the OutputList if the element is not contained in the dictionary</span>
<span class="comment-copy">@Javier, yes .... you are right, add <code>None</code> .... is better chepner's solution in this case</span>
<span class="comment-copy">Hi Javier. Thanks.  What the "lamda x: d[x]" do in above example? In python help file the  map (function, sequence) , is this suggestion can work on huge dictionary and large list.. Thanjs</span>
<span class="comment-copy">could you explain why the vote down? This answer the question, with a different approach</span>
<span class="comment-copy">You're trying to obtain the values of the dictionary, Map will loop over the result of Filter, and will return a list with the first parameter (the lambda function) applied for every element resulted in filter. Try it in a Python shell, this will yield what you're expecting</span>
<span class="comment-copy">Hi, Javier.. Ur answer is useful.. May i know the vote down refer to ? Thanks.</span>
<span class="comment-copy">This actually does not work. If you have any value in the dict d that is not truth, it will be filtered out by filter since 'get' is returning the value.</span>
