<div class="post-text" itemprop="text">
<p>Testing alternatives to <code>for _ in range(n)</code> (to execute some action <code>n</code> times, even if the action does not depend on the value of <code>n</code>) I noticed that there is another formulation of this pattern that is faster, <code>for _ in [""] * n</code>.</p>
<p>For example: </p>
<pre><code>timeit('for _ in range(10^1000): pass', number=1000000)
</code></pre>
<p>returns 16.4 seconds;</p>
<p>whereas,</p>
<pre><code>timeit('for _ in [""]*(10^1000): pass', number=1000000)
</code></pre>
<p>takes 10.7 seconds.</p>
<p>Why is <code>[""] * 10^1000</code> so much faster than <code>range(10^1000)</code> in Python 3?</p>
<p>All testing done using Python 3.3</p>
</div>
<div class="post-text" itemprop="text">
<p>When iterating over <code>range()</code>, objects for all integers between 0 and <code>n</code> are produced; this takes a (small) amount of time, even with <a href="https://stackoverflow.com/questions/306313/pythons-is-operator-behaves-unexpectedly-with-integers">small integers having been cached</a>.</p>
<p>The loop over <code>[None] * n</code> on the other hand produces <code>n</code> references to 1 object, and creating that list is a little faster.</p>
<p>However, the <code>range()</code> object uses <em>far</em> less memory, <em>and</em> is more readable to boot, which is why people prefer using that. Most code doesn't have to squeeze every last drop from the performance.</p>
<p>If you need to have that speed, you can use a custom iterable that takes no memory, using <a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" rel="nofollow noreferrer"><code>itertools.repeat()</code></a> with a second argument:</p>
<pre><code>from itertools import repeat

for _ in repeat(None, n):
</code></pre>
<p>As for your timing tests, there are some problems with those.</p>
<p>First of all, you made an error in your <code>['']*n</code> timing loop; you did not embed two quotes, you concatenated two strings and produced an <em>empty list</em>:</p>
<pre><code>&gt;&gt;&gt; '['']*n'
'[]*n'
&gt;&gt;&gt; []*100
[]
</code></pre>
<p>That's going to be unbeatable in an iteration, as you iterated 0 times.</p>
<p>You also didn't use large numbers; <code>^</code> is the binary XOR operator, not the power operator:</p>
<pre><code>&gt;&gt;&gt; 10^1000
994
</code></pre>
<p>which means your test missed out on how long it'll take to create a <em>large</em> list of empty values.</p>
<p>Using better numbers and <code>None</code> gives you:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit
&gt;&gt;&gt; 10 ** 6
1000000
&gt;&gt;&gt; timeit("for _ in range(10 ** 6): pass", number=100)
3.0651066239806823
&gt;&gt;&gt; timeit("for _ in [None] * (10 ** 6): pass", number=100)
1.9346517859958112
&gt;&gt;&gt; timeit("for _ in repeat(None, 10 ** 6): pass", 'from itertools import repeat', number=100)
1.4315521717071533
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your problem is that you are incorrectly feeding <code>timeit</code>.</p>
<p>You need to give <code>timeit</code> strings containing Python statements. If you do</p>
<pre><code>stmt = 'for _ in ['']*100: pass'
</code></pre>
<p>Look at the value of <code>stmt</code>.  The quote characters inside the square brackets match the string delimiters, so they are interpreted as string delimiters by Python.  Since Python concatenates adjacent string literals, you'll see that what you really have is the same as <code>'for _ in [' + ']*100: pass'</code>, which gives you <code>'for _ in []*100: pass'</code>.</p>
<p>So your "super-fast" loop is just looping over the empty list, not a list of 100 elements.  Try your test with, for example,</p>
<pre><code>stmt = 'for _ in [""]*100: pass'
</code></pre>
</div>
<span class="comment-copy">Incidentally, it's idiomatic to use an underscore when you don't actually care about the value you're iterating: <code>for _ in range(n)</code></span>
<span class="comment-copy">For what it's worth the <code>timeit('for x in range(10): pass', number=10000000)</code> results are <code>5.320733592294609</code> and for <code>timeit('for x in [0]*10: pass',number=10000000)</code> are <code>4.120525842738559</code></span>
<span class="comment-copy">Let me make my point here: <code>[x] * 5</code> <b>does not</b> create a list containing 5 items of x but rather 5 copies of x. <i>By careful</i>.</span>
<span class="comment-copy">Another note: power operator in Python is <code>**</code> (<code>10**1000</code>); <code>^</code> is binary xor, <code>10^1000</code> yields <code>994</code>.</span>
<span class="comment-copy">I'm just going to assume you didn't mean XOR when you used <code>10^1000</code> there (it equals <code>994</code>) and actually meant pow: <code>**</code> (which equals 1 with 1000 zeroes)</span>
<span class="comment-copy">If you <i>really</i> need the performance, use PyPy ;).</span>
<span class="comment-copy">It took me a few reads to understand that the actual problem was the quotes. Could you clarify that? Thanks!</span>
<span class="comment-copy">Wow silly me! It seems it's still faster with <code>None</code> or <code>""</code> than <code>range()</code>...</span>
<span class="comment-copy">At the risk of making this useful/good answer not make sense, maybe the question should be changed back, or amended to include both versions. The original question isnt really being answered any more, Why is <code>[0]*100</code> (or anything similar) faster than <code>range(100)</code>?</span>
<span class="comment-copy">@Dunedubby A small speed difference is reasonable as <code>range</code> has to create <code>n</code> <code>int</code> objects, whereas <code>iter([None] * n)</code> can loop using C-side integers.</span>
<span class="comment-copy">@camz: because, as Veedrac states, no new integer objects have to be created (<code>range()</code> produces integers on demand).</span>
