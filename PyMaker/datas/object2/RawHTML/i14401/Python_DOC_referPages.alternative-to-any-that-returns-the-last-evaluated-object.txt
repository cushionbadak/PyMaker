<div class="post-text" itemprop="text">
<p>I just wrote a bit of code where I wanted to do:</p>
<pre><code>def foo(container)
    return any((some_obj.attr &lt;= 0 for some_obj in container))
</code></pre>
<p>where <code>foo</code> would return the first <code>some_obj</code> where <code>some_obj.attr</code> is zero or less. The alternative, I suppose, would be</p>
<pre><code>def foo(container):
    return next((some_obj for some_obj in container if some_obj.attr &lt;= 0), False)
</code></pre>
<p>but that feels very hacky.</p>
<p>I ended up writing it out, but I don't like how deeply nested it got.</p>
<pre><code>def foo(container):
    for some_obj in container:
        if some_obj.attr &lt;= 0:
            return some_obj
    return False
</code></pre>
<p>To clarify: <code>container</code> in this case is likely no more than 6 objects (and often 2 objects), though a general case is more useful. I'm also trying to optimize for ease of reading, not for performance.</p>
<p>Is there some better construct than this?</p>
</div>
<div class="post-text" itemprop="text">
<p>The docs for <a href="https://docs.python.org/3/library/functions.html#any"><code>any</code></a> explain that it's equivalent to:</p>
<pre><code>def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</code></pre>
<p>So, I don't think your code is too deeply nested if it has exactly the same structure as code that's used to illustrate the functionality of <code>any</code> itself.</p>
<p>Still, I would probably wrap this up in a function:</p>
<pre><code>def first(iterable, predicate):
    for element in iterable:
        if predicate(element):
            return element
    return False
</code></pre>
<p>So now you can do this:</p>
<pre><code>def foo(container):
    return first(container, lambda obj: obj.attr &lt;= 0)
</code></pre>
<p>Or, alternatively, just use a generator expression, and pass it to the two-argument <a href="https://docs.python.org/3/library/functions.html#next"><code>next</code></a>, as you're already doing:</p>
<pre><code>def foo(container):
    return next((obj for obj in container if obj.attr &lt;= 0), False)
</code></pre>
<p>That has the same "depth", it's just all horizontal instead of vertical.</p>
<p>Or, maybe, pull out the genexpr and name it:</p>
<pre><code>def foo(container):
    nonpositives = (obj for obj in container if obj.attr &lt;= 0)
    return next(nonpositives, False)
</code></pre>
<p>How would you choose between them? I think if the predicate is too complicated to read as a <code>lambda</code> but not complicated enough to be worth abstracting out into an out-of-line function, I'd go with the genexpr. Otherwise, the wrapper function. But it's really a matter of taste.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>next(filter</code> should do it, and here's a funny way to test <code>&lt;= 0</code>:</p>
<pre><code>&gt;&gt;&gt; next(filter((0).__ge__, [3,2,1,-1,-2]), False)
-1
</code></pre>
<p>Ha, even tricker:</p>
<pre><code>&gt;&gt;&gt; next(filter(0..__ge__, [3,2,1,-1,-2]), False)
-1
</code></pre>
<p>Or, as abarnert pointed out:</p>
<pre><code>&gt;&gt;&gt; next(filter(0 .__ge__, [3,2,1,-1,-2]), False)
-1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, to extend <a href="https://stackoverflow.com/a/30364476/908494">Stefan Pochmann's answer</a> to handle <code>obj.attr &lt;= 0</code>, still without needing a lambda:</p>
<pre><code>from operator import attrgetter
from functional import compose

next(filter(compose(0..__ge__, attrgetter('attr')), [3, 2, 1, -1, -2]), False)
</code></pre>
<p>If you don't have the <code>functional</code> module (which you probably don't, because the version on PyPI hasn't worked since Python 2.4 or so…) and don't want to search for a modern replacement, you can write <code>compose</code> yourself (and slightly better):</p>
<pre><code>def compose(f, g):
    @functools.wraps(f):
    def wrapper(x):
        return f(g(x))
    return wrapper
</code></pre>
<hr/>
<p>About once/year, there's a proposal to add <code>compose</code> to the stdlib, and maybe even give it an infix operator. With <a href="http://www.python.org/dev/peps/pep-0465/" rel="nofollow noreferrer"><code>@</code> being added for matrix multiplication</a>, you can guess the latest proposal.<sup>*</sup> So, if that happens (which it probably won't), you can do this:</p>
<pre><code>from operator import attrgetter

next(filter(0..__ge__ @ attrgetter('attr'), [3, 2, 1, -1, -2]), False)
</code></pre>
<p>Now the only thing we need is Haskell-style <a href="http://stupidpythonideas.blogspot.com/2015/05/operator-sectioning-for-python.html" rel="nofollow noreferrer">operator sectioning</a> so we can get rid of the bound method, the <code>..</code> hack, and the need for an <code>attrgetter</code> function (assuming you consider dot-attribution an operator, which it really isn't, but let's pretend…). Then:</p>
<pre><code>next(filter((&lt;= 0) @ (.attr), [3, 2, 1, -1, -2]), False)
</code></pre>
<hr/>
<p><sub>* In fact, it was proposed, twice, during the initial PEP 465 discussion, which is why the PEP mentions, "During discussions of this PEP, a similar suggestion was made to define <code>@</code> as a general purpose function composition operator, and this suffers from the same problem; <code>functools.compose</code> isn't even useful enough to exist."</sub></p>
</div>
<span class="comment-copy">I'd go with an explicit <code>for</code> loop.</span>
<span class="comment-copy">@user2357112 that's what I ended up doing. It seemed dangerously close to Arrow Of Doom. I included that case in my question, though.</span>
<span class="comment-copy">This is no more deeply nested than the "equivalent to" code documented for <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any</code></a> itself.</span>
<span class="comment-copy">The <code>next</code> certainly isn't hacky, maybe it doesn't appear so elegant but it's a viable option</span>
<span class="comment-copy">The two options you have already are both perfectly readable in my opinion  :)</span>
<span class="comment-copy">Well I was really hoping someone would come in and say "Oh, didn't you know you can do <code>or *container</code>?</span>
<span class="comment-copy">@AdamSmith: Honestly, I think if <code>lambda</code> were more light-weight (in terms of visibility/obtrusiveness), nobody would have a problem with functions like <code>first</code> or the builtin <code>filter</code> or <code>itertools.takewhile</code> in the first place, and we wouldn't have had to borrow comprehensions from Haskell. But Guido has already declared that "a problem not worth solving, except as an intellectual exercise", so… oh well, on those occasionally where you need to go just a little beyond what comprehensions make trivial, there's a bit of a jump in readability.</span>
<span class="comment-copy">I'm going to go ahead and give the checkmark here, if only because it has the best breakdown of when and why you'd choose different approaches.</span>
<span class="comment-copy">@abarnert Boo, zero doesn't belong to "negatives".</span>
<span class="comment-copy">@StefanPochmann: Thanks. That's always a risk in coming up with a "meaningful" name; you it can have the wrong meaning. :) Fixed.</span>
<span class="comment-copy">That's nice, but try working that with an attribute of an object instead of just numbers</span>
<span class="comment-copy">@jamylak just means it removes the ugly <code>int(0).__ge__</code> hack and turns it into a lambda. This is still valid :P</span>
<span class="comment-copy">@AdamSmith Yeah, I'd usually do a lambda as well, it's certainly more usual and flexible. But I also love the unusual and show people stuff that they might not have seen before :-)</span>
<span class="comment-copy">@AdamSmith Yes, I see it now, I had just overlooked it, sorry. Many of the questions posted here contain horrible code and I tend to disregard it and just focus on the given text/input/output. That bit me here, as there was no input/output and the code was good. It's also 6:24am and I should go to bed :-P</span>
<span class="comment-copy">@StefanPochmann: You're right about <code>0..__ge__</code> being valid because it's unambiguously a float literal followed by an attribution. I'm not use if <code>0.__ge__</code> is a <code>SyntaxError</code> because it's ambiguous, or because it was explicitly designed to be illegal to avoid that ambiguity, but either way, the basic idea is that <code>0.__ge__</code> could be a method on <code>0</code> or garbage following <code>0.</code>, as you said. You can also just use <code>0 .__ge__</code>, which is unambiguously the same as <code>(0).__ge__</code> and one char shorter, but a lot less readable.</span>
