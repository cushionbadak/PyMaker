<div class="post-text" itemprop="text">
<p>I'd like to modify the arguments passed to a method in a module, as opposed to replacing its return value.</p>
<p>I've found a way around this, but it seems like something useful and has turned into a lesson in mocking.</p>
<h3>module.py</h3>
<pre><code>from third_party import ThirdPartyClass

ThirdPartyClass.do_something('foo', 'bar')
ThirdPartyClass.do_something('foo', 'baz')
</code></pre>
<h3>tests.py</h3>
<pre><code>@mock.patch('module.ThirdPartyClass.do_something')
def test(do_something):
    # Instead of directly overriding its return value
    # I'd like to modify the arguments passed to this function.

    # change return value, no matter inputs
    do_something.return_value = 'foo'

    # change return value, based on inputs, but have no access to the original function
    do_something.side_effect = lambda x, y: y, x

    # how can I wrap do_something, so that I can modify its inputs and pass it back to the original function?
    # much like a decorator?
</code></pre>
<p>I've tried something like the following, but not only is it repetitive and ugly, it doesn't work. After some PDB introspection.. I'm wondering if it's simply due to however this third party library works, as I do see the original functions being called successfully when I drop a pdb inside the <code>side_effect</code>. </p>
<p>Either that, or some auto mocking magic I'm just not following that I'd love to learn about.</p>
<pre><code>def test():
    from third_party import ThirdPartyClass
    original_do_something = ThirdPartyClass.do_something

    with mock.patch('module.ThirdPartyClass.do_something' as mocked_do_something:
        def side_effect(arg1, arg2):
            return original_do_something(arg1, 'overridden')

        mocked_do_something.side_effect = side_effect

        # execute module.py
</code></pre>
<p>Any guidance is appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You may want to use parameter <code>wraps</code> for the mock call. (<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock" rel="noreferrer">Docs</a> for reference.) This way the original function will be called, but it will have everything from Mock interface.</p>
<p>So for changing parameters called to original function you may want to try it like that:</p>
<pre><code>#file org.py
def func(x):
    print(x)


#file main.py
from unittest import mock

import org


of = org.func
def wrapped(a):
    of('--{}--'.format(a))


with mock.patch('org.func', wraps=wrapped):
    org.func('x')
    org.func.assert_called_with('x')
</code></pre>
<p>result:</p>
<pre><code> --x--
</code></pre>
</div>
<span class="comment-copy">Why you say <i>it doesn't work</i>. What is the behaviour? AFAIK it should work and I used this way <a href="http://stackoverflow.com/a/30016312/4101725">more times</a>... I can explain the other details but before file an answer I would like to know why the <i>ugly</i> way donsn't work as expected.</span>
