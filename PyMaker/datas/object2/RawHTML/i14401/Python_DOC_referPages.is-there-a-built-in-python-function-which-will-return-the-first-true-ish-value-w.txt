<div class="post-text" itemprop="text">
<p>Here's the functionality I mean, and I do it pretty frequently so maybe I'm just reimplementing a built-in that I haven't seen:</p>
<pre><code>import itertools
def first(fn, *args):
    for x in itertools.chain(*args):
        value = fn(x)
        if value: return value

# Example use:
example = {'answer': 42, 'bring': 'towel'}
print first(example.get, ['dolphin', 'guide', 'answer', 'panic', 'bring'])
# Prints 42
</code></pre>
<p>Does Python let me do this with built-ins?</p>
</div>
<div class="post-text" itemprop="text">
<p>You essentially want to map <code>example.get</code> on the sequence, and get the first true-ish value. For that, you can use <code>filter</code> with the default filter function that does exactly that, and get the first of that using <code>next</code>:</p>
<pre><code>&gt;&gt;&gt; example = {'answer': 42, 'bring': 'towel'}
&gt;&gt;&gt; lst = ['dolphin', 'guide', 'answer', 'panic', 'bring']
&gt;&gt;&gt; next(filter(None, map(example.get, lst)))
42
</code></pre>
<p>In Python 3, all these things are lazy, so the whole sequence isn’t iterated. In Python 2, you can use <a href="https://docs.python.org/2/library/itertools.html" rel="nofollow"><code>itertools</code></a> to get the lazy versions of the builtins, <a href="https://docs.python.org/2/library/itertools.html#itertools.imap" rel="nofollow"><code>imap</code></a> and <a href="https://docs.python.org/2/library/itertools.html#itertools.ifilter" rel="nofollow"><code>ifilter</code></a></p>
</div>
<div class="post-text" itemprop="text">
<p>you can use <code>next()</code> builtin and generator expression:</p>
<pre><code>next(example[key] 
        for key in ['dolphin', 'guide', 'answer', 'panic', 'bring'] 
        if key in example)
</code></pre>
<p>if you want to use predefined function, it might be better to use filter, which accepts function as the first argument (lambda in example):</p>
<pre><code>next(itertools.ifilter(lambda txt: 'a' in txt, ['foo', 'bar']))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I don't think there's a built in function to do what you want. There is an arguably more Pythonic way of doing what you're doing:</p>
<pre><code>example = {'answer': 42, 'bring': 'towel'}
keys = ['dolphin', 'guide', 'answer', 'panic', 'bring']
print filter(lambda x: x, map(example.get, keys))[0]
</code></pre>
<p>The downside of this method is that it will iterate through the whole list, instead of breaking out at the first value. You also have to add extra checks to make sure the list isn't empty.</p>
</div>
<span class="comment-copy">You might want to explicitly note to use <code>itertools.ifilter</code>/<code>itertools.imap</code> on Python 2.x to make it lazy there.</span>
<span class="comment-copy">@dano Good point, added them. Thanks!</span>
<span class="comment-copy">good point with using <code>None</code> argument to <code>filter</code>, for truish values only</span>
<span class="comment-copy">This is basically the solution from the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer"><code>itertools</code> <code>first_true</code> recipe</a>.</span>
<span class="comment-copy">Yup I guess my example was a bit poor. This only works when there's a fast condition that can be used in the comprehension. If it's instead <code>next(expensive(v) for v in my_list if expensive(v))</code> it won't work as well.</span>
<span class="comment-copy">why? generator expression is lazily evaluated, so it won't make any unecessary operations. And it is pretty fast.</span>
<span class="comment-copy">@m.wasowski The point is that you wouldn’t want to run <code>expensive(v)</code> for both the filter <i>and then also</i> for the actual result.</span>
<span class="comment-copy">@poke that's only single additional call, should be irrelevant in most of the cases; the cost might be as well outweighted by comprehension that should be faster to run than filter  - it is impossible to tell without profiling both solutions on real-world data</span>
<span class="comment-copy">Actually my concern is more about the semantics of not wanting to call the function more than once rather than performance. In my specific case I log statistics based on what happens when the function is called and I would prefer not calling it twice for every check.</span>
