<div class="post-text" itemprop="text">
<p>New to Python and having done some reading, I'm making some methods in my custom class class methods rather than instance methods.</p>
<p>So I tested my code but I hadn't changed some of the method calls to call the method in the class rather than the instance, but they still worked:</p>
<pre><code>class myClass:
   @classmethod:
   def foo(cls):
      print 'Class method foo called with %s.'%(cls)

   def bar(self):
      print 'Instance method bar called with %s.'%(self)

myClass.foo()
thing = myClass()
thing.foo()
thing.bar()
</code></pre>
<p>This produces:</p>
<pre><code>class method foo called with __main__.myClass.
class method foo called with __main__.myClass.
instance method bar called with &lt;__main__.myClass instance at 0x389ba4&gt;.
</code></pre>
<p>So what I'm wondering is why I can call a class method (foo) on an instance (thing.foo), (although it's the class that gets passed to the method)? It kind of makes sense, as 'thing' is a 'myClass', but I was expecting Python to give an error saying something along the lines of 'foo is a class method and can't be called on an instance'.</p>
<p>Is this just an expected consequence of inheritance with the 'thing' object inheriting the foo method from its superclass?</p>
<p>If I try to call the instance method via the class:</p>
<pre><code>myClass.bar()
</code></pre>
<p>then I get:</p>
<pre><code>TypeError: unbound method bar() must be called with myClass instance...
</code></pre>
<p>which makes perfect sense.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can call it on an instance because <code>@classmethod</code> is a <a href="https://docs.python.org/2/glossary.html#term-decorator" rel="nofollow noreferrer">decorator</a> (it takes a function as an argument and returns a new function).</p>
<p>Here is some relavent information from the Python <a href="https://docs.python.org/2/library/functions.html#classmethod" rel="nofollow noreferrer">documentation</a></p>
<blockquote>
<p>It can be called either on the class (such as C.f()) or on an instance
  (such as C().f()). The instance is ignored except for its class. If a
  class method is called for a derived class, the derived class object
  is passed as the implied first argument.</p>
</blockquote>
<p>There's also quite a good SO discussion on <code>@classmethod</code> <a href="https://stackoverflow.com/questions/9247625/location-of-classmethod">here</a>. </p>
</div>
<span class="comment-copy">In Python, methods are not called <i>on</i> something. <code>thing.foo</code> is not a method call, it is an attribute access,  It is basically the same thing as <code>getattr(thing, "foo")</code>.</span>
<span class="comment-copy">@Alexey Surely 'foo` is a method and <code>thing.foo()</code> is calling the <code>foo</code> method of the object <code>thing</code>? Isn't an attribute Python's terminology for what other languages refer to as a variable or property?</span>
<span class="comment-copy">I think that "<code>(thing.foo)()</code> is calling the <code>foo</code> method of the object <code>thing</code>" (parentheses for clarity) is a metaphor for "<code>(thing.foo)()</code> is calling the callable object <code>thing.foo</code>", that is it.  AFAIU, this object is created dynamically when <code>getattr(thing, "foo")</code> is called, and of course it has a reference to <code>thing</code> object.</span>
<span class="comment-copy">Note the difference between object "attributes" that are defined by its class and the attributes that are "stored" in the object itself.  Because if you have a function (or any object/value) <code>bar</code>, you can write <code>thing.foo = bar</code>, and then call it <code>thing.foo()</code> if <code>bar</code> was callable. In this case the object returned by <code>thing.foo</code> is actually stored in the dictionary <code>thing.__dict__</code>, and not generated dynamically, as, i suppose, is the case with "instance methods" defined as a part of class definition.</span>
<span class="comment-copy">"Isn't an attribute Python's terminology for what other languages refer to as a variable or property?" -- AFAIU from my experiments with Python, Python plays its tricks by allowing <a href="https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access" rel="nofollow noreferrer">arbitrary customisation</a> of attribut getters and setters.  The "magic" happens when you write or read an attribute.  Attributes are not just record fields: using them can trigger arbitrary code.</span>
<span class="comment-copy">Thank you - I did various searches for inheritance, classmethods etc, but as you can imagine, the results were overwhelming. I would have been quite happy to simply accept that it works, but as an assembler programmer, I like to know how things work under the covers.</span>
<span class="comment-copy">"You can call it on an instance because @classmethod is a decorator" -- i do not follow this logic.</span>
<span class="comment-copy">@Alexey do you know what a decorator is?</span>
<span class="comment-copy">Yes. But i believe i can make a decorator such that the decorated function will produce a class attribute that will raise errors if called as an instance method (in fact, which will not be callable at all).  For example: <code>def decor(f): return 42</code>.</span>
