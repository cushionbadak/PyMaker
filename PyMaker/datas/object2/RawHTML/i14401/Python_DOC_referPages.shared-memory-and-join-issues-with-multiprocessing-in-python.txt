<div class="post-text" itemprop="text">
<p>I have written some codes as below, through which I wanted to test some specific problems with multiprocessing:</p>
<pre><code>import multiprocessing as mp
import sys
z = 10
file = open("test_file")
file2 = open("test_multiprocess", "w")
arr = []

def func(obj, idx):
    print("pid[%d] [%s]" % (idx,str(id(obj))))
    if idx == 1:
        obj += 3
    elif idx == 2:
        obj = open("test_multiprocess")
    elif idx == 3:
        obj = open("test_multiprocess_%d" % idx, "w")
    elif idx == 4:
        obj.append(idx)
    print("pid[%d] after changing [%s]" % (idx, str(id(obj))))
    sys.stdout.flush()

if __name__ == "__main__":
    data = {1:z, 2:file, 3:file2, 4:arr}
    p = []
    print("original id is [%s] [%s] [%s] [%s]" % (str(id(data[1])), str(id(data[2])), str(id(data[3])), str(id(data[4]))))
    print("==============================================================")
    for i in range(1, 5):
        p.append(mp.Process(target=func, args=(data[i], i)))
        p[len(p)-1].start()

    for i in range(i, len(p)):
        p[i].join()

    sys.stdout.flush()
    print("==============================================================")
    print("after process id is [%s] [%s] [%s] [%s]" % (str(id(data[1])), str(id(data[2])), str(id(data[3])), str(id(data[4]))))
</code></pre>
<p>However, when I ran this file, I found some weird phenomena. One particular output is as below:</p>
<pre><code>original id is [6330144] [140069930330512] [140069930330992] [140069873535384]
==============================================================
pid[1] [6330144]
pid[1] after changing [6330072]
pid[2] [140069930330512]
pid[2] after changing [140069864561880]
pid[3] [140069930330992]
pid[3] after changing [140069864561880]
==============================================================
after process id is [6330144] [140069930330512] [140069930330992] [140069873535384]
pid[4] [140069873535384]
pid[4] after changing [140069873535384]
</code></pre>
<p>First of all, when passing data[i] to subprocess, id(data[i]) does not change at all, but AFAIK python fork() is copy-on-accessing because of ref-count changing. Secondly, suppose it is copy-on-write in python, when obj is modified in subprocess, int/File type object does change its id but this is not true with type list as we can see its id never changes even compared with the original id. Last but not least, I use join to wait for all subprocesses to complete, but output of parent process seems to always be messed up with subprocess ones, why? Thanks if any one could explain these for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>None of this has anything to do with multiprocessing. You can run the exact same test just calling the same function in-process and you'll get the same results.</p>
<hr/>
<blockquote>
<p>First of all, when passing data[i] to subprocess, id(data[i]) does not change at all</p>
</blockquote>
<p>That's because you don't change <code>data[i]</code> anywhere.</p>
<p>When you pass <code>data[i]</code> as an argument, the <code>obj</code> parameter doesn't become a reference to the variable <code>data[i]</code>, it becomes a reference to the same <em>value</em> that's in that variable.</p>
<p>When you later do <code>obj = …</code>, that doesn't affect the value in any way; it just makes <code>obj</code> refer to a different value instead.</p>
<p>If you want to mutate <code>data</code>, you have to pass <code>data</code> itself (and, presumably, <code>i</code>); then the function can do <code>data[i] =</code>.</p>
<hr/>
<blockquote>
<p>Secondly, suppose it is copy-on-write in python, when obj is modified in subprocess, int/File type object does change its id but this is not true with type list</p>
</blockquote>
<p>Nope. The difference has nothing to do with the types, or with copy-on-write. <code>obj = …</code> never affects the original object. It doesn't matter whether it's an <code>int</code> or a <code>list</code>.</p>
<p>The reason you see different behavior isn't that the type is different, it's that you have different code. You don't do <code>obj = …</code>, you do <code>obj.append(…)</code>. That's a method on the object, which mutates it in-place.</p>
<p>(If you're curious about <code>obj += 3</code>, that one is a bit trickier. Augmented assignment <em>may</em> mutate the value in-place as well as assigning a new value to the variable, or it may just assign a new value to the variable. It's up to the value's type. Generally, mutable types like <code>list</code> will mutate in-place and assign <code>self</code> back to the variable; immutable types like <code>int</code> will of course never mutate in-place, they'll always assign a new value.)</p>
<hr/>
<p>My guess is that you're coming from a language like C++, where variables are actually memory locations where the values live, assignment is a mutating method (which normally copies values), and explicit references are references to variables, not to values. If so, it may help to think of every variable in Python a <code>std::shared_ptr&lt;boost::any&gt;</code>, not a <code>boost::any&amp;</code>.</p>
<hr/>
<blockquote>
<p>Last but not least, I use join to wait for all subprocesses to complete, but output of parent process seems to always be messed up with subprocess ones, why?</p>
</blockquote>
<p>Because you <em>don't</em> actually wait for all subprocesses to complete. This line:</p>
<pre><code>for i in range(i, len(p)):
</code></pre>
<p>… iterates over <code>range(5, 4)</code>, which is empty, so you don't <code>join</code> anything.</p>
<p>This is one of the many reasons it's better to iterate directly over collections:</p>
<pre><code>for proc in p:
    proc.join()
</code></pre>
<p>If you do it that way, there's no place to insert a hard-to-debug counting error.</p>
<hr/>
<p>Meanwhile, even though it turns out to be completely irrelevant to your actual code, if you're interested in what does and doesn't get inherited and how, read about <a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods" rel="nofollow">start methods</a> and the related <a href="https://docs.python.org/3/library/multiprocessing.html#the-spawn-and-forkserver-start-methods" rel="nofollow">programming recommendations</a>. But briefly: if you're using the <code>fork</code> method (the default on non-Windows systems), your globals are shared directly; if you're using <code>spawn</code> (the default on Windows), they're re-constructed from the source. But if you really need to share variables (which you really don't want to do anyway in most cases), you should almost never rely on the <code>fork</code> behavior, even if you're only going to run on Unix; use explicit <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow">shared memory</a>. (Also, if you really need to share anything that can be mutated by more than one process, you really need a <code>Lock</code> or other synchronization object.)</p>
</div>
<span class="comment-copy">Sorry to have made some mistakes above, but here is another question. Why does id(obj) in subprocess get the same value as the original print in parent process? should not the reference to data[i] (i.e. z or file* or arr) have changed when we pass it to the subprocess callback function?</span>
<span class="comment-copy">@kuixiong If two different variables reference the same value, they have the same <code>id</code>, because the <code>id</code> is a property of the value.</span>
<span class="comment-copy">Although <code>id</code> is a property of the value, but when reference count of value changes, subprocess should copy the value, right? For instance, when we call <code>mp.Process(target=func, args=(data[1], 1)).start()</code>, the reference of the value of <code>file</code> would change, then subprocess should make a copy of File Object, as a result, <code>obj</code> would not refer to the same object as <code>file</code> does. This is only my humble understanding, hope you would rectify my misunderstandings, thanks!</span>
