<div class="post-text" itemprop="text">
<p>I cloned <strong>thefuck</strong> source code from <a href="https://github.com/nvbn/thefuck" rel="nofollow">its repository</a>. Tried to install it for development by the following commands:</p>
<pre><code>pip install -r requirements.txt
python setup.py develop
</code></pre>
<p>It worked fine. Afterwards tried to run tests by:</p>
<pre><code>py.test
</code></pre>
<p>Got the following errors:</p>
<pre><code>================================== FAILURES ===================================
_______________________________ test_load_rule ________________________________

mocker = &lt;pytest_mock.MockFixture object at 0x03275A10&gt;

    def test_load_rule(mocker):
        match = object()
        get_new_command = object()
        load_source = mocker.patch(
            'thefuck.main.load_source',
            return_value=Mock(match=match,
                              get_new_command=get_new_command,
                              enabled_by_default=True,
                              priority=900))
        assert main.load_rule(Path('/rules/bash.py')) \
               == Rule('bash', match, get_new_command, priority=900)
&gt;       load_source.assert_called_once_with('bash', '/rules/bash.py')

tests\test_main.py:20:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python34\lib\unittest\mock.py:782: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

_mock_self = &lt;MagicMock name='load_source' id='52977776'&gt;
args = ('bash', '/rules/bash.py'), kwargs = {}
expected = (('bash', '/rules/bash.py'), {})
_error_message = &lt;function NonCallableMock.assert_called_with.&lt;locals&gt;._error_me
ssage at 0x032A1030&gt;
actual = call('bash', '\\rules\\bash.py'), cause = None

    def assert_called_with(_mock_self, *args, **kwargs):
        """assert that the mock was called with the specified arguments.

            Raises an AssertionError if the args and keyword args passed in are
            different to the last call to the mock."""
        self = _mock_self
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            raise AssertionError('Expected call: %s\nNot called' % (expected,))

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher((args, kwargs))
        actual = self._call_matcher(self.call_args)
        if expected != actual:
            cause = expected if isinstance(expected, Exception) else None
&gt;           raise AssertionError(_error_message()) from cause
E           AssertionError: Expected call: load_source('bash', '/rules/bash.py')

E           Actual call: load_source('bash', '\\rules\\bash.py')

C:\Python34\lib\unittest\mock.py:771: AssertionError
__________________ TestGetRules.test_get[conf_rules0-rules0] __________________

self = &lt;tests.test_main.TestGetRules object at 0x03286F50&gt;
monkeypatch = &lt;_pytest.monkeypatch.monkeypatch object at 0x03286CD0&gt;
glob = &lt;MagicMock name='glob' id='52981200'&gt;, conf_rules = []
rules = ['bash', 'lisp', 'bash', 'lisp']

    @pytest.mark.parametrize('conf_rules, rules', [
        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),
        (types.RulesNamesList(['bash']), ['bash', 'bash'])])
    def test_get(self, monkeypatch, glob, conf_rules, rules):
&gt;       glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]

tests\test_main.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = &lt;class 'pathlib.PosixPath'&gt;, args = ('bash.py',), kwargs = {}
self = PosixPath('bash.py')

    def __new__(cls, *args, **kwargs):
        if cls is Path:
            cls = WindowsPath if os.name == 'nt' else PosixPath
        self = cls._from_parts(args, init=False)
        if not self._flavour.is_supported:
            raise NotImplementedError("cannot instantiate %r on your system"
&gt;                                     % (cls.__name__,))
E           NotImplementedError: cannot instantiate 'PosixPath' on your system

C:\Python34\lib\site-packages\pathlib-1.0.1-py3.4.egg\pathlib.py:939: NotImpleme
ntedError
__________________ TestGetRules.test_get[conf_rules1-rules1] __________________

self = &lt;tests.test_main.TestGetRules object at 0x032BAB50&gt;
monkeypatch = &lt;_pytest.monkeypatch.monkeypatch object at 0x03275A30&gt;
glob = &lt;MagicMock name='glob' id='53194576'&gt;, conf_rules = ['bash']
rules = ['bash', 'bash']

    @pytest.mark.parametrize('conf_rules, rules', [
        (conf.DEFAULT_RULES, ['bash', 'lisp', 'bash', 'lisp']),
        (types.RulesNamesList(['bash']), ['bash', 'bash'])])
    def test_get(self, monkeypatch, glob, conf_rules, rules):
&gt;       glob.return_value = [PosixPath('bash.py'), PosixPath('lisp.py')]

tests\test_main.py:35:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = &lt;class 'pathlib.PosixPath'&gt;, args = ('bash.py',), kwargs = {}
self = PosixPath('bash.py')

    def __new__(cls, *args, **kwargs):
        if cls is Path:
            cls = WindowsPath if os.name == 'nt' else PosixPath
        self = cls._from_parts(args, init=False)
        if not self._flavour.is_supported:
            raise NotImplementedError("cannot instantiate %r on your system"
&gt;                                     % (cls.__name__,))
E           NotImplementedError: cannot instantiate 'PosixPath' on your system

C:\Python34\lib\site-packages\pathlib-1.0.1-py3.4.egg\pathlib.py:939: NotImpleme
ntedError
______________________________ test_side_effect _______________________________

ssh_error = ('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@
WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!  ...own_hosts', &lt;function ssh_e
rror.&lt;locals&gt;.reset at 0x033F16F0&gt;, &lt;function ssh_error.&lt;locals&gt;.known_hosts at
0x033F1198&gt;)

    def test_side_effect(ssh_error):
        errormsg, path, reset, known_hosts = ssh_error
        command = Command('ssh user@host', stderr=errormsg)
        side_effect(command, None)
        expected = ['123.234.567.890 asdjkasjdakjsd\n', '111.222.333.444 qwepoiw
qepoiss\n']
&gt;       assert known_hosts(path) == expected
E       assert ['123.234.567...oiwqepoiss\n'] == ['123.234.567....oiwqepoiss\n']

E         At index 1 diff: '98.765.432.321 ejioweojwejrosj\n' != '111.222.333.44
4 qwepoiwqepoiss\n'
E         Left contains more items, first extra item: '111.222.333.444 qwepoiwqe
poiss\n'
E         Use -v to get the full diff

tests\rules\test_ssh_known_host.py:61: AssertionError
=============== 4 failed, 122 passed, 2 skipped in 0.56 seconds ===============

C:\code\thefuck&gt;
</code></pre>
<p>I suspect that this tool is written to only work on Linux and unix-like command lines. </p>
<ul>
<li>What is the reason for this error? </li>
<li>And if it's a part of python library that is not implemented for Windows, are there any quick fixes?</li>
</ul>
<p>I want to start working on open source projects to become a better developer. Using Linux for my development tasks is not a problem. It would help me if I knew the opinions of more experienced developers about this. </p>
</div>
<div class="post-text" itemprop="text">
<p>The reason for this error is, that on Windows, <code>PosixPath</code> is not implemented. But there is <code>PurePosixPath</code>, which you can use wherever you want to use <code>PosixPath</code> for platform independent handling of POSIX paths. Alternatively, it might be possible that instead you actually want to have platform dependent paths (that is <code>/</code> on Linux and <code>\</code> on Windows), in which case you should just use <code>Path</code>.</p>
<p>From the <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow noreferrer">documentation</a> (below the inheritance diagram):</p>
<blockquote>
<p>Pure paths are useful in some special cases; for example:</p>
<ol>
<li>If you want to manipulate Windows paths on a Unix machine (or vice versa). You cannot instantiate a WindowsPath when running on
  Unix, but you can instantiate PureWindowsPath.</li>
</ol>
</blockquote>
</div>
