<div class="post-text" itemprop="text">
<p>What is the simplest (and most elegant) way, to find out if the <code>in</code> operator can be used in python?
If I open a python shell and type in:</p>
<pre><code>"" in 2
</code></pre>
<p>it prints:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: argument of type 'int' is not iterable
</code></pre>
<p>according to the <a href="https://docs.python.org/2/library/stdtypes.html#index-20" rel="nofollow">python-docs</a> an iterable is:</p>
<blockquote>
<p>container.<strong>iter</strong>()</p>
<p>Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different
  types of iteration, additional methods can be provided to specifically
  request iterators for those iteration types. (An example of an object
  supporting multiple forms of iteration would be a tree structure which
  supports both breadth-first and depth-first traversal.) This method
  corresponds to the tp_iter slot of the type structure for Python
  objects in the Python/C API.</p>
</blockquote>
<p>so </p>
<pre><code>hasattr([], "__iter__") and hasattr({}, "__iter__")
</code></pre>
<p>return <code>true</code> as expected, but</p>
<pre><code>hasattr("test_string", "__iter__")
</code></pre>
<p>returns false. But I can use </p>
<pre><code>"test" in "test_string"
</code></pre>
<p>without any problems. </p>
<p>By elegant I refer to NOT use a try-except solution</p>
</div>
<div class="post-text" itemprop="text">
<p>The iterator protocol doesn't actually require a type to support <code>__iter__</code>. It requires a type to <em>either</em> support <code>__iter__</code>, or <code>__getitem__</code> with sequential integer arguments starting from 0. See the <a href="https://docs.python.org/2/library/functions.html#iter"><code>iter</code></a> function for the best explanation of this in the docs.</p>
<p>So, <code>hasattr(x, "__iter__")</code> will give you false negatives if testing whether something is iterable.</p>
<p>So, how <em>can</em> you do this? Well, the right way, even if you don't like it, is:</p>
<pre><code>try:
    i = iter(x)
except TypeError:
    # not iterable
</code></pre>
<hr/>
<p>Also, note that, as the docs for <a href="https://docs.python.org/2/library/functions.html#hasattr"><code>hasattr</code></a> explain:</p>
<blockquote>
<p>This is implemented by calling <code>getattr(object, name)</code> and seeing whether it raises an exception or not.</p>
</blockquote>
<p>So, really, you're not avoiding exceptions at all; you're just coming up with a more convoluted way to raise an exception and hide that fact from yourself.</p>
<hr/>
<p>But meanwhile, iteration is a red herring in the first place. The <code>in</code> operator is implemented with the <a href="https://docs.python.org/2/reference/datamodel.html#object.__contains__"><code>__contains__</code></a> method. Container types that don't define a <code>__contains__</code> method will <em>fall back to</em> iterating and comparing, but types aren't <em>required</em> to implement it that way. You can have a <code>__contains__</code> that's much faster than iterating could be (as with <code>dict</code> and <code>set</code>); you can even be a container without being an iterable. (Note that the <a href="https://docs.python.org/2/library/collections.html#collections-abstract-base-classes"><code>collections</code> module ABCs</a> have separate <code>Container</code> and <code>Iterable</code> bases; neither one depends on the other.)</p>
<hr/>
<p>So, if you really wanted to do this without any exception handling, how could you?</p>
<p>Well, you have to check that at least one of the following is true:</p>
<ul>
<li><code>x</code> has a <code>__contains__</code> method.</li>
<li><code>x</code> has an <code>__iter__</code> method.</li>
<li><code>x</code> has a <code>__getitem__</code> method that, when called with the number <code>0</code>, either returns successfully or raises <code>IndexError</code>.</li>
</ul>
<p>Even if you accept that the last one can't possibly be tested without actually trying to call it with the number <code>0</code> and just assume that having <code>__getitem__</code> is "close enough", how can you test for this without relying on exceptions?</p>
<p>You really can't. You could, e.g., iterate over <code>dir(x)</code>, but that won't work for classes that define <code>__contains__</code> dynamically, e.g., in a <code>__getattr__</code> method that delegates to <code>self.real_sequence</code>.</p>
<p>And, even if you could, what happens if you have, say, a class that defines <code>__contains__</code> as taking no arguments? The attribute is there, but <code>in</code> is still going to raise a <code>TypeError</code>.</p>
<p>And all of this is ignoring the (implementation-dependent) rules on <a href="https://docs.python.org/2/reference/datamodel.html#new-style-special-lookup">which special methods are looked up on the object and which on the type itself</a>. For example, in CPython 2.7:</p>
<pre><code>&gt;&gt;&gt; class C(object): pass
&gt;&gt;&gt; c = C()
&gt;&gt;&gt; c.__contains__ = lambda self, x: return True
&gt;&gt;&gt; hasattr(c, '__contains__')
True
&gt;&gt;&gt; c.__contains__(2)
True
&gt;&gt;&gt; 2 in c
TypeError: argument of type 'C' is not iterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Try except <em>is</em> the correct and elegant way.</strong> </p>
<p>First of all, whether <code>a in b</code> will raise exception or not depends on <em>both</em> a and b, not just on b alone.  </p>
<p>The other problem is there are multiple ways that <code>in</code> works.  Here is an example of an object which supports <code>in</code>, but doesn't support iteration:</p>
<pre><code>&gt;&gt;&gt; class EvenNumbers(object):
...     def __contains__(self, n):
...         return n % 2 == 0
...     
&gt;&gt;&gt; even_numbers = EvenNumbers()
&gt;&gt;&gt; 4 in even_numbers
True
&gt;&gt;&gt; 5 in even_numbers
False
&gt;&gt;&gt; for even_number in even_numbers:
...     pass
... 
TypeError: 'EvenNumbers' object is not iterable
</code></pre>
<p>And here is an example of an object which supports iteration, but doesn't define <code>__contains__</code>:</p>
<pre><code>&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; even_numbers = (2*n for n in it.count())
&gt;&gt;&gt; 4 in even_numbers
True
&gt;&gt;&gt; even_numbers.__contains__
AttributeError: 'generator' object has no attribute '__contains__'
</code></pre>
<p>So to have a working LBYL implementation, you will have to take into account every possible method in which <code>a in b</code> can work (or not).  I have only listed a couple here, there are several others.  You will find your code becoming very long and ugly, and will eventually realise that try/except was the path of least resistance all along!</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>in</code> (and <code>not in</code>) operator uses <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow">__contains__()</a> to check for membership (<em>typically</em>). The simplest and most elegant way to check for this is either the direct existence of the <code>__contains__</code> attribute, or for the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Container" rel="nofollow">Container</a> abstract base class:</p>
<pre><code>hasattr(obj, '__contains__')

# Python 3: Container
import collections.abc
isinstance(obj, collections.abc.Container)

# Python 2: Container
import collections
isinstance(obj, collections.Container)
</code></pre>
<p>However, the documentation does mention:</p>
<blockquote>
<p>For objects that donâ€™t define <code>__contains__()</code>, the membership test first tries iteration via <code>__iter__()</code>, then the old sequence iteration protocol via <code>__getitem__()</code>, see <a href="https://docs.python.org/3/reference/expressions.html#membership-test-details" rel="nofollow">this section in the language reference</a>.</p>
</blockquote>
<p>So, if you want to be absolutely certain <code>in</code> can be used without relying on a try-except block, you should use:</p>
<pre><code>hasattr(obj, '__contains__') or hasattr(obj, '__iter__') or hasattr(obj, '__getitem__')
</code></pre>
<p>If you are expecting only <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Container" rel="nofollow">container</a>-like objects though, I would ignore <code>__iter__()</code> and maybe even <code>__getitem__()</code>, and just stick to <code>__contains__()</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can check whether <code>'__contains__' in dir(theobject)</code>, but I don't really think that <code>try</code> is inelegant.</p>
</div>
<span class="comment-copy">Aside: if you think of try-except as inelegant, you're going to find Python very frustrating.  (Your code is also probably going have race conditions all over the place, but that's another issue.)</span>
<span class="comment-copy">A problem with a dynamically typed language is indeed that the compiler can not check this at compile time (of course you buy something in return).</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-an-object-is-iterable">In Python, how do I determine if an object is iterable?</a></span>
<span class="comment-copy">You might also check for <code>__contains__</code></span>
<span class="comment-copy"><code>hasattr()</code> is just <code>getattr()</code> behind a try/except.  Trying to avoid exceptions is really not worth the trouble.</span>
<span class="comment-copy">That last one is interesting.  Irrespective of cpython, does python specify whether it will/will not look up on the instance or the class?</span>
<span class="comment-copy">@wim: IIRC, Python 2.x just says that "special methods" "may" be looked up on the class. I believe 3.x limits it to a specific list of special methods, but still leaves it up to the implementation whether or not they are looked up that way.</span>
<span class="comment-copy">Weird.  I wonder why they are vague about that.</span>
<span class="comment-copy">@wim: Here we go, <a href="https://docs.python.org/2/reference/datamodel.html#new-style-special-lookup" rel="nofollow noreferrer">3.4.12 Special method lookup for new-style classes</a>: "For new-style classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an objectâ€™s type, not in the objectâ€™s instance dictionary."</span>
<span class="comment-copy">@wim: It's an implementation-specific optimization, and they don't want to tie the hands of other implementations.</span>
<span class="comment-copy">If I could give you +2 just for the last paragraph, I would. Unfortunately, when I try, StackOverflow seems to raise an exception. :)</span>
<span class="comment-copy">Even checking for both <code>Iterable</code> and <code>Container</code> (or <code>hasattr</code>ing for both <code>__iter__</code> and <code>__contains__</code>) isn't sufficient; a class with <code>__getitem__</code> that returns or raises <code>IndexError</code> when called on the number <code>0</code> will fails both tests, but will still succeed with <code>in</code> (and with <code>iter</code>).</span>
<span class="comment-copy">For the latest edit: the simplest and most elegant way to check for this is to use <code>try:</code>/<code>except:</code>. And it has the nice side benefit of being correct, not just approximately/often correct.</span>
<span class="comment-copy">@abarnert: For 3.x I'm going to disagree with you.  AFAIK all the builtin types now support all the expected methods.  User-defined types will (or <i>should</i>) inherit from the classes in <code>collections.abc</code> because it saves them the trouble of defining all the mixin methods (like <code>.index()</code> for sequences).</span>
<span class="comment-copy">@cpburnz: You're not thinking in Python terms. The idea that exceptions should only be raised on a "real error" just doesn't fit in with a language where even a <code>for</code> loop is a <code>try</code> under the covers. Also, if it's a real error, that's exactly when you <i>don't</i> want <code>except</code>, so the exception can percolate up to the level where you can handle things appropriately (which may even be all the way up to aborting the program, if it's an unexpected logic error in your code).</span>
<span class="comment-copy">@cpburnz: Ah, I think I misread. You're saying you should always use an exception, it's just a question of whether you use a (local) <code>try</code>/<code>except</code> or just let the exception be an exception? In that case, I agree 100%.</span>
<span class="comment-copy">Of course that won't work if <code>theobject</code>'s type defines <code>__iter__</code> but not <code>__contains__</code>. Or a valid <code>__getitem__</code> but neither. Or if <code>theobject.__contains__</code> is stored in the instance dict rather than the type dict. Or if the type doesn't use a <code>__dict__</code>, or it does but <code>__contains__</code> is generated dynamically through a <code>__getattr__</code> or <code>__getattribute__</code> method.</span>
<span class="comment-copy">It can work in some cases, but of course <code>try..except</code> is the way to go.</span>
<span class="comment-copy">@abarnert: You missed one: The object defines a poorly-implemented <code>__dir__</code> and doesn't tell you what it implements correctly.  Also, I'm 85% sure you can't dynamically generate special methods even via the metaclass.</span>
<span class="comment-copy">@Kevin: Ooh, I didn't even think of that one, but you're right, you can always fake <code>__dir__</code>, and do so maliciously or ineptly. :)</span>
<span class="comment-copy">Here is another fun one, a call to <code>__contains__</code> itself could modify the instance or the class and delete the <code>__contains__</code> method  :)</span>
