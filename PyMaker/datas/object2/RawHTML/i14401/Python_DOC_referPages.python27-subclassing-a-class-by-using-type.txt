<div class="post-text" itemprop="text">
<p>I have the following class</p>
<pre><code>class Sample(object):
    def __init__(self, argument, argument2, argument3):
        self.value = argument
        self.value2 = argument2
        self.value3 = argument3
</code></pre>
<p>and I want to create a subclass of this by using <strong>type</strong> however I am not sure on how to populate the arguments to the <strong>__ init __</strong> method.</p>
<p>I also have this custom <strong>__ init __</strong> method which populates the object:</p>
<pre><code>def setup(self, arg, arg2, arg3):
    self.value = "good"
    self.value2 = "day"
    self.value3 = "sir"

myclass = type("TestSample", (Sample,), dict(__init__=setup))
</code></pre>
<p>however when I perform:</p>
<pre><code>myclass()
</code></pre>
<p>I get:</p>
<pre><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: setup() takes exactly 4 arguments (1 given)
</code></pre>
<p>Is there a way to pre-stuff these values in without having to provide them at object instatiation?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your subclass is working fine, but you gave it their own <code>__init__</code> method that still takes <em>four positional arguments</em>. One of those is <code>self</code>, but you still need to provide the other 3 when creating the object:</p>
<pre><code>myclass('some', 'argument', 'values')
</code></pre>
<p>Your function is <em>ignoring</em> those arguments otherwise, so perhaps you meant to not include them in the function signature? You don't have to match the parent class here:</p>
<pre><code>def setup(self):
    self.value = "good"
    self.value2 = "day"
    self.value3 = "sir"

myclass = type("TestSample", (Sample,), dict(__init__=setup))
</code></pre>
<p>Instead of setting the attributes directly, you could delegate that to the parent class still:</p>
<pre><code>def setup(self):
    Sample.__init__(self, 'good', 'day', 'sir')

myclass = type("TestSample", (Sample,), dict(__init__=setup))
</code></pre>
<p>If you wanted these to be <em>defaults</em> that you can override, use keyword arguments:</p>
<pre><code>def setup(self, argument='good', argument2='day', argument3='sir'):
    Sample.__init__(self, argument, argument2, argument3)

myclass = type("TestSample", (Sample,), dict(__init__=setup))
</code></pre>
<p>Now you can either omit the arguments, or provide different values for them:</p>
<pre><code>c1 = myclass()
c2 = myclass(argument2='weekend')
</code></pre>
</div>
<span class="comment-copy">You're probably looking for default arguments, written as <code>def f(x=1, y=2, ...): (...)</code>. Be advised however that those are mutable, e.g. if you use a container type (list, dict, set etc) as a default argument and add a value to it, it will still have that value on the next call.</span>
<span class="comment-copy">oh! so if I provide default arguments, then they wont take into effect due to the altered <b>init</b> method? Ill give that a go</span>
<span class="comment-copy">Why if I do a partial on setup does it not work ? i.e. dict(__init__=partial(setup, argument="good", argument2="day", argument3="sir")) whilst removing the default arguments. Isn't that equivalent to the first and second example of setup?</span>
<span class="comment-copy">@Har: <code>functools.partial()</code> objects do not implement the descriptor protocol and thus cannot be used as methods. Python 3.4 adds a <a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow noreferrer"><code>partialmethod</code> object</a> that <i>does</i>.</span>
<span class="comment-copy">wow thanks. I havnt come across the descriptor protocol before, Ill look into it</span>
<span class="comment-copy">@Har: there is a somewhat <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">technical HOWTO</a> on the subject.</span>
