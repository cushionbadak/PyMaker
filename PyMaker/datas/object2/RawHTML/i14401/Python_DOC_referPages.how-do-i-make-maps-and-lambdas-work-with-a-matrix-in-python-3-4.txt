<div class="post-text" itemprop="text">
<p>I often avoid me to write posts like this but I'm new in python 3.4 and I need a help with this code.</p>
<p>Suppose we have the following list:</p>
<pre><code>v = [ [ x, y ] for x in ['a','b','c'] for y in range(1,5) ]
</code></pre>
<p>It results a list of lists: [ ['a', '1'], ['a','2'], ... ]</p>
<p>Now I'd want to join those string. I've tried the following:</p>
<pre><code>p = map(lambda (x, y): ''.join(x,y), v)
</code></pre>
<p>It didn't work.</p>
<p>The error:</p>
<pre><code>TypeError: join() takes exactly one argument (2 given)
</code></pre>
<p>I've tried to look up in the documentation But I coudn't solve my problem though.</p>
<p>Does someone have some idea?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do:</p>
<pre><code>&gt;&gt;&gt; list(map(lambda x: ''.join(map(str, x)), v))
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
<p>This executes the function <code>lambda x: ''.join(map(str, x))</code> for each element in <code>v</code>. An element in <code>v</code> is a list with one string and one integer as values. This means <code>x</code>, as received by the <code>lambda</code> function, is a list with those two values.</p>
<p>We then need to ensure all values in that list are strings before passing them to <code>join()</code>. This means we'll call <code>map(str, x)</code> to turn all values in the sublist <code>x</code> into strings (<code>['a', 1]</code> becomes <code>['a', '1']</code>). We can then join them by passing the result of that to <code>''.join(...)</code> (<code>['a', '1']</code> becomes <code>['a1']</code>). This is done for each list in <code>v</code> so this gives us the desired result.</p>
<p>The result of <code>map</code> is a so-called <code>mapobject</code> in Python 3.x so we wrapped everything in a <code>list()</code> call to end up with a list.</p>
<p>Also, a list comprehension is arguably more readable here:</p>
<pre><code>&gt;&gt;&gt; [x[0] + str(x[1]) for x in v]
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p><code>lambda (x, y): ''.join(x,y)</code> isn't legal Python 3. Iterable unpacking of arguments was removed. <em>If you actually ran the code you showed on the version you mentioned, you would have gotten a syntax error, not the error you showed.</em></p></li>
<li><p>If you did indeed have a list as you describe, not the one you actually made, you would need to give <code>str.join</code> one iterable argument, not 2 arguments, so <code>lambda (x, y): ''.join([x,y])</code> (which is similar to the code you showed but not legal Python 3) or, more simply, <code>lambda x_y: ''.join(x_y)</code></p></li>
<li><p>That won't work for you, though, because <code>str.join</code> takes an iterable of strings, and the resulting list of lists in your case is  <code>[ ['a', 1], ['a',2], ... ]</code>, not <code>[ ['a', '1'], ['a','2'], ... ]</code>. You can't join a string and a number this way. (Which is fine, since <code>str.join</code> isn't even the right tool for the job.)</p></li>
<li><p><strong>Using <code>map</code>+<code>lambda</code> is <em>always</em> silly.</strong> Just use a generator expression in all situations you might use <code>map</code>+<code>lambda</code></p></li>
</ol>
<p>See the following examples (I used list comprehensions instead of generator expressions so we'd get useful reprs):</p>
<pre><code>py&gt; v = [ [ x, y ] for x in ['a','b','c'] for y in range(1,5) ]
py&gt; [''.join([let, num]) for let, num in v]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 1, in &lt;listcomp&gt;
TypeError: sequence item 1: expected str instance, int found
py&gt; ['{}{}'.format(let, num) for let, num in v]
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you just have a set amount of elements to join you can use <a href="https://docs.python.org/2/library/string.html#format-examples" rel="nofollow">str.format</a>:</p>
<pre><code>print(list(map(lambda x: "{}{}".format(*x) , v)))  

['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
<p>You can also do it for any amount of elements using <code>"{}" * len(x)</code>:</p>
<pre><code>print(list(map(lambda x: ("{}" * len(x)).format(*x) , v)))
</code></pre>
<p><code>*x</code> unpacks the sequence, <code>"{}" * len(x)</code> creates a <code>{}</code> for each element in each sublist. </p>
<p>Or unpack in a list comp:</p>
<pre><code>print([ "{}{}".format(*x) for x in v])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I agree with Mike that <code>map(lambda</code> is silly. In this case, <code>'{}{}'.format</code> pretty much does the job your lambda is supposed to do, so you can use that instead:</p>
<pre><code>starmap('{}{}'.format, v)
</code></pre>
<p>That uses <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow"><code>itertools.starmap</code></a>. If you want to use <code>map</code>, you can do it like this:</p>
<pre><code>map('{}{}'.format, *zip(*v))
</code></pre>
<p>But really I'd just do</p>
<pre><code>(c + str(n) for c, n in v)
</code></pre>
<hr/>
<p>Edit: A comparison of map+lambda vs generator expression, showing that the latter is shorter, clearer, more flexible (unpacking), and faster:</p>
<pre><code>&gt;&gt;&gt; from timeit import timeit

&gt;&gt;&gt; r = range(10000000)
&gt;&gt;&gt; timeit(lambda: sum(map(lambda xy: xy[0]+xy[1], zip(r, r))), number=1)
7.221420832748007
&gt;&gt;&gt; timeit(lambda: sum(x+y for x, y in zip(r, r)), number=1)
5.192609298897533

&gt;&gt;&gt; timeit(lambda: sum(map(lambda x: 2*x, r)), number=1)
5.870139625224283
&gt;&gt;&gt; timeit(lambda: sum(2*x for x in r), number=1)
4.4056527464802

&gt;&gt;&gt; r = range(10)
&gt;&gt;&gt; timeit(lambda: sum(map(lambda xy: xy[0]+xy[1], zip(r, r))), number=1000000)
7.047922363577214
&gt;&gt;&gt; timeit(lambda: sum(x+y for x, y in zip(r, r)), number=1000000)
4.78059718055448
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use another list comprehension:</p>
<pre><code>&gt;&gt;&gt; [''.join((x, str(y))) for x, y in v]
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
<p>If you don't need <code>v</code>, you can do in the first list comprehension:</p>
<pre><code>&gt;&gt;&gt; [''.join((x, str(y))) for x in ['a','b','c'] for y in range(1,5)]
['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4', 'c1', 'c2', 'c3', 'c4']
</code></pre>
</div>
<span class="comment-copy">Did you get an exception? How didn't it work?</span>
<span class="comment-copy">"it didn't work" - what didn't work? syntax error?</span>
<span class="comment-copy">I'm sorry, I fixed it</span>
<span class="comment-copy">The signature of <code>str.join</code>: <code>S.join(iterable) -&gt; str</code></span>
<span class="comment-copy"><code>lambda (x, y): ''.join(x,y)</code> isn't valid Python 3. Are you sure that's the version you're using?</span>
<span class="comment-copy">It worked.But I can't understand your first solution.</span>
<span class="comment-copy">@GuilhermeDuarte: I'll expand my answer.</span>
<span class="comment-copy">Sorry, I don't understand why using map(lamba is silly. I came from R and it's very usual write lines like that there.</span>
<span class="comment-copy">@GuilhermeDuarte Like Mike said: "Just use a generator expression" instead. See the "Edit:" part of my answer that I just added.</span>
