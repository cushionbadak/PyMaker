<div class="post-text" itemprop="text">
<p>I wrote a python script to search all <code>.avi</code> file in the current folder, and write their names in a file for later processing.</p>
<p>However I only get an empty file, even if I have a <code>.avi</code> in my folder.</p>
<p>Here's my code:</p>
<pre><code>import sh

f = open("film.txt", "w")

ending = [".avi", ".mp4"]
lsa = sh.ls("-a")
for i in lsa:
    if i in "*.avi":
        print(i, file=f)

f.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>open file via "with":</p>
<pre><code>with open("film.txt", "w") as f:
    for root, _, files in os.walk(os.getcwd()):
        for file in files:
            if file.endswith((".avi", ".mp4")):
                f.write(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>in</code> doesn't do such pattern matching. Assuming <code>i</code> is a string, just use</p>
<pre><code>i.endswith('.avi')
</code></pre>
<p>But for gods sake, don't call a string variable <code>i</code>.</p>
<p>Or to check for multiple endings at once (thanks @msvalkon for the reminder):</p>
<pre><code>i.endswith((".avi", ".mp4"))
</code></pre>
<p>And you could use Python's <code>glob</code> module which does come with such pattern functionality:</p>
<pre><code>import glob
with open("film.txt", "w") as f:
    for filename in glob.glob("*.avi"):
        print(filename, file=f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>file writes should be done like this:</p>
<pre><code>f.write(i)
</code></pre>
<p>but you probably also have a problem with <code>if i in "*.avi":</code></p>
<p>so your code would be</p>
<pre><code>import sh

f = open("film.txt", "w")

ending = [".avi", ".mp4"]
lsa = sh.ls("-a")
for i in lsa:
    for end in ending:
        if i.endswith(end): 
            print("found one {}".format(i))
            f.write(i)
f.close()
</code></pre>
<p>And now the nice version:</p>
<pre><code>import glob, itertools
patterns = ["*.avi","*.mp4"]
with open("film.txt", "w") as ofile:
    for fl in itertools.chain.from_iterable(glob.glob(pattern) for pattern in patterns):
        ofile.write(fl + "\n")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can simply use the built in <code>glob</code> module which does exactly what you want:</p>
<pre><code>import glob

with open("film.txt", "w") as f:
    f.write("\n".join(glob.glob("*.avi") + glob.glob("*.mp4")))
</code></pre>
<p><code>glob.glob</code> searches for files that match a certain pattern. If you use what I wrote it will search for files in the current directory which have <code>.avi</code> or <code>.mp4</code> file extensions</p>
<p>Note the use of a context manager (<code>with open(...)</code>) instead of <code>f = open(...)</code> and <code>f.close()</code>. This is more pythonic.</p>
<p>Also, I used <code>\n</code> joining to skip the <code>for</code> loop.</p>
</div>
<div class="post-text" itemprop="text">
<p>What <code>if i in "*.avi"</code> is doing is asking "is <code>i</code> a substring of <code>'*.avi'</code>"?  That is not a glob-matching operation.</p>
<p>The simplest solution is probably to use <a href="https://docs.python.org/3/library/glob.html" rel="nofollow"><code>glob</code></a> instead of <code>sh</code>.</p>
<pre><code>for i in glob.glob('*.avi') + glob.glob('*.mp4'):
    â€¦
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>modified the answer of Rain Lee a bit.</p>
<p>1st) define a function:</p>
<pre><code>def search_ending(path, extension):
    for root, dir, filenames in os.walk(path):
        for filename in filenames:
            if os.path.splitext(filename)[-1] == extension:
                yield os.path.join(root, filename)
</code></pre>
<p>2nd) call that function and put the results in a list:</p>
<pre><code>ext_list = list(search_pos(os.getcwd(), '.jpg'))
</code></pre>
<p>3rd) you could display it</p>
<pre><code>for line in ext_list:
        print('\n'+ line)
</code></pre>
</div>
<span class="comment-copy"><code>'a.avi' in '*.avi'</code> returns <code>False</code> to me. Are you sure this logic is correct? (Idk if this works in python 3, I use python2.7).</span>
<span class="comment-copy">Maybe add that <code>str.endswith</code> accepts a tuple of items to match so as per the example the OP has given: <code>i.endswith((".avi", ".mp4"))</code></span>
<span class="comment-copy">@msvalkon Thanks, I overlooked that as it wasn't in the text or the main code. Added it now.</span>
<span class="comment-copy">You can use <code>iglob</code> to avoid building a list</span>
<span class="comment-copy">@PadraicCunningham Oh wow, even Python 3 has that. I never used it and probably never will, as I don't fancy that <code>i</code> and my tolerance for number of files in one directory is around 100. And I claim if someone has a problem with <code>glob.glob</code>, then they have too many files in one place and <i>deserve</i> to suffer :-P</span>
<span class="comment-copy">I tried it,but empty output.</span>
<span class="comment-copy">@Pentagon98: try the nice version. I don't trust your <code>ls</code> thingy</span>
<span class="comment-copy">@Pentagon98: also make sure you run this in a dir that actually has these kind of files</span>
<span class="comment-copy">Unfortunately, <code>writelines</code> doesn't appear to add line endings.</span>
<span class="comment-copy">You're right. fixed it</span>
<span class="comment-copy">check out my solution which doesn't use a <code>for</code> loop</span>
<span class="comment-copy">It's asking not just those five, try <code>"av" in "*.avi"</code>.</span>
<span class="comment-copy">@StefanPochmann Oh, right. Brainfart!</span>
