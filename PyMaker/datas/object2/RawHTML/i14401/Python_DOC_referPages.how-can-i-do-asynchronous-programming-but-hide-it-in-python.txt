<div class="post-text" itemprop="text">
<p>Am just getting my head round Twisted, threading, stackless, etc. etc. and would appreciate some high level advice.</p>
<p>Suppose I have remote clients 1 and 2, connected via a websocket running in a page on their browsers. Here is the ideal goal:</p>
<pre><code>for cl in (1,2):
    guess[cl] = show(cl, choice("Pick a number:", range(1,11)))
checkpoint()
if guess[1] == guess[2]:
    show((1,2), display("You picked the same number!"))
</code></pre>
<p>Ignoring the mechanics of <code>show</code>, <code>choice</code> and <code>display</code>, the point is that I want the <code>show</code> call to be asynchronous. Each client gets shown the choice. The code waits at <code>checkpoint()</code> for all the threads (or whatever) to rejoin. </p>
<p>I would be interested in hearing answers even if they involve hairy things like rewriting the source code. I'd also be interested in less hairy answers which involve compromising a bit on the syntax.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, the most widely-used approach to async/event-based network programming that hides that model from the programmer is probably <a href="http://www.gevent.org/" rel="nofollow">gevent</a>.</p>
<p>Beware: this kind of trickery works by making tasks yield control implicitly, which encourages the same sorts of surprising bugs that tend to appear when OS threads are involved. Local reasoning about such problems is significantly harder than with explicit yielding, and the convenience of avoiding callbacks might not be worth the trouble introduced by the inherent <a href="https://glyph.twistedmatrix.com/2014/02/unyielding.html" rel="nofollow">pitfalls</a>. Perhaps just as important to a library author like yourself: this approach is not pure Python, and would force dependencies and interpreter restrictions on the users of your library.</p>
<p>A lot of discussion about this topic sprouted up (especially between the gevent and twisted camps) while Guido was working on the <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow">asyncio</a> library, which was called tulip at the time. He summarized the main issues <a href="http://laser.inf.ethz.ch/2012/slides/vanRossum/laser-async.pdf" rel="nofollow">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The most simple solution code wise is to use a framework like <a href="http://autobahn.ws/" rel="nofollow noreferrer">Autobahn</a> which support remote procdure calls (RPC). That means you can call some JavaScript in the browser and wait for the result.</p>
<p>If you want to call two clients, you will have to use threads.</p>
<p>You can also do it manually. The approach works along these lines:</p>
<ul>
<li>You need to pass a callback to <code>show()</code>.</li>
<li><code>show()</code> needs to register the callback with some kind of string ID in a global <code>dict</code></li>
<li><code>show()</code> must send this ID to the client</li>
<li>When the client sends the answer, it must include the ID.</li>
<li>The Python handler can then remove the callback from the global <code>dict</code> and invoke it with the answer</li>
<li>The callback needs to collect the results.</li>
<li>When it has enough results (two in your case), it must send status updates to the client.</li>
</ul>
<p>You can simplify the code using <code>yield</code> but the theory behind is a bit complex to understand: <a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python">What does the "yield" keyword do in Python?</a> and <a href="http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/" rel="nofollow noreferrer">coroutines</a></p>
</div>
<span class="comment-copy">Hide it from whom?</span>
<span class="comment-copy">From people writing code using my library, who need simplicity.</span>
<span class="comment-copy">This is helpful, including the hint for Autobahn. What about the question of how to hide it? I would like to make this style of programming simple for client code.</span>
<span class="comment-copy">See the links at the bottom and Autobahn example code for how to make this "simple". Personally, I prefer the obvious approach over <code>yield</code> and coroutines.</span>
