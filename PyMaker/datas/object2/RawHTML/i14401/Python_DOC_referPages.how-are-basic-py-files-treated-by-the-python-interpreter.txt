<div class="post-text" itemprop="text">
<p>Recently I have been trying to dig deeper into the core of python. Currently I am look into pythons module system and how "global", "local", and "nonlocal" variables are stored. More specifically, my question is how does the interpreter treat the file being run? Is it treated as its own module in the modules (or something similar)?</p>
</div>
<div class="post-text" itemprop="text">
<p>The top-level script is treated as a module, but with a few differences.</p>
<ul>
<li>Instead of its name being the script name minus a <code>.py</code> extension, its name is <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow"><code>__main__</code></a>.</li>
<li>The top-level script does not get looked up in the <code>.pyc</code> cache, nor compiled and cached there.</li>
</ul>
<p>Other than that, it's mostly the same: the interpreter compiles your script as a module, builds a <code>types.ModuleType</code> out of it, stores it in <code>sys.modules['__main__']</code>, etc.</p>
<p>Also look at <a href="https://docs.python.org/3/library/runpy.html" rel="nofollow"><code>runpy</code></a>, which explains how both <code>python spam.py</code> and <code>python-m spam</code> work. (As of, I think, 3.4, <code>runpy.run_path</code> should do <em>exactly</em> the same thing as running a script, not just something very similar.) And notice that the docs link to <a href="https://hg.python.org/cpython/file/3.4/Lib/runpy.py" rel="nofollow">the source</a>, so if you need to look up any specifics of the internals, you can.</p>
<hr/>
<p>The first difference is why you often see this idiom:</p>
<pre><code>if __name__ == '__main__':
    import sys
    main(sys.argv) # or test() or similar
</code></pre>
<p>That allows the same file <code>spam.py</code> to be used as a module (in which case its <code>__name__</code> will be <code>spam</code>) or as a script (in which case its <code>__name__</code> will be <code>__main__</code>), with code that you only want to be run in the script case.</p>
<hr/>
<p>If you're curious whether standard input to the interactive interpreter is treated the same way as a script, there are a lot more differences there. Most importantly, each statement is compiled and run as a statement with <code>exec</code>, rather than the whole script/module being compiled and run as a module.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Yes</strong>, that's essentially what happens. It's the <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow"><code>__main__</code></a> module. You can see this by running something like the following:</p>
<pre><code>x = 3
import __main__
print(__main__.x)
</code></pre>
<p>Either run as a script file, or on the interpreter, this will print:</p>
<pre><code>3
</code></pre>
</div>
<span class="comment-copy">As a side note, if you haven't upgraded to Python 3.4, this would be a really good time. The import system, the <code>run_module</code> system, startup and shutdown, etc. were all a huge mess. 2.7, 3.2, and 3.3 made a few steps in improving it; 3.4 had a massive overhaul with the goal of making the entire thing implementable in pure Python with no undocumented secrets (and therefore also hookable from within Python), except for the startup/shutdown part, which is only partially done in 3.4.</span>
