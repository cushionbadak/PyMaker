<div class="post-text" itemprop="text">
<p>I have a context manager over a large chunk of logic that looks like</p>
<pre><code>with open(file_name1, 'rb') as file1:
  with open(file_name2, 'a+b') as file2:
    logic_here
</code></pre>
<p>Unfortunately, there is an edge case where <code>file_name2</code> might be <code>None</code>. I still, however, want the <code>logic_here</code> to execute. Is there an elegant way to handle this without removing the context manager? It looks like I might need to resort to using a <code>try / catch</code> and manually calling <code>.close()</code> on the file. </p>
<p>I don't mind just opening any file as in theory, I don't care about the content of the writes that occur. I do want to avoid creating too many temporary files that I write to, and I do want to avoid accidentally writing on personal files that might already be on disk.</p>
</div>
<div class="post-text" itemprop="text">
<p>Quick, hacky solution, since that seems to be what you're looking for:</p>
<pre><code>if file_name2 is None:
    file_name2 = os.devnull
</code></pre>
<p>See: <a href="https://docs.python.org/2/library/os.html#os.devnull" rel="nofollow">https://docs.python.org/2/library/os.html#os.devnull</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You can create a custom function that either returns the file object, or a <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow"><code>StringIO</code></a> object:</p>
<pre><code>from io import StringIO

def openFileOrString (name, mode):
    if name != None:
        return open(name, mode)
    else:
        return StringIO()

with openFileOrString(file_name2, 'a+b') as file2:
    pass
</code></pre>
<p>Since StringIO is not a context manager in Python 2, you need to add a bit of boilerplate around it to make it work there. One way to do it would be to create a StringIO wrapper that is a context manager; a simpler way would be to just provide a new context manager that just uses the file’s context manager inside:</p>
<pre><code>from StringIO import StringIO
from contextlib import contextmanager

@contextmanager
def openFileOrString (name, mode):
    if name != None:
        with open(name, mode) as f:
            yield f
    else:
        yield StringIO()
</code></pre>
</div>
<span class="comment-copy">What exactly would you expect <code>file2</code> to be when there isn’t a second file? If your logic doesn’t depend on it, move the logic one level up.</span>
<span class="comment-copy">When there isn't a second file, I don't care about what I am writing to the file. Sadly, a large portion of <code>logic_here</code> already relies on needing to call .write().</span>
<span class="comment-copy">So you have lines <code>file2.write</code> in your logic but if <code>file_name2</code> wasn’t provided, you simply want to skip those automatically?</span>
<span class="comment-copy">Skipping the writes would be the ideal behavior. I see that I could also scan the current directory and generate a unique ID that would correspond to a file generated by the program itself. However, I would need to write logic for tracking files generated by the program to avoid creating an excess number of temporary files.</span>
<span class="comment-copy">I like this idea of handling it, if you put it into a function like @poke It seems reasonable, not even that hacky (well in terms of dealing with a problem that probably came from a hack)</span>
<span class="comment-copy">Nice, didn't know that. I'd do <code>open(file_name2 or os.devnull, 'a+b')</code>, though. Shorter, doesn't change the variable, and would handle the empty string as well.</span>
<span class="comment-copy">@StefanPochmann I like it!</span>
<span class="comment-copy">A <code>StringIO.StringIO</code> in Python 2 has no <code>__exit__</code>, so can't be used as a context manager.</span>
