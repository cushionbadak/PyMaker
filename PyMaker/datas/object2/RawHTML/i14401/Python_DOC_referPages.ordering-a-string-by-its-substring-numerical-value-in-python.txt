<div class="post-text" itemprop="text">
<p>I have a list of strings that need to be sorted in numerical order using as a int key two substrings.
Obviously using the <code>sort()</code> function orders my strings alphabetically so I get 1,10,2... that is obviously not what I'm looking for.</p>
<p>Searching around I found a key parameter can be passed to the <code>sort()</code> function, and using <code>sort(key=int)</code> should do the trick, but being my key a substring and not the whole string should lead to a cast error.</p>
<p>Supposing my strings are something like:</p>
<pre><code>test1txtfgf10
test1txtfgg2
test2txffdt3
test2txtsdsd1
</code></pre>
<p>I want my list to be ordered in numeric order on the basis of the first integer and then on the second, so I would have:</p>
<pre><code>test1txtfgg2
test1txtfgf10
test2txtsdsd1
test2txffdt3
</code></pre>
<p>I think I could extract the integer values, sort only them keeping track of what string they belong to and then ordering the strings, but I was wondering if there's a way to do this thing in a more efficient and elegant way.</p>
<p>Thanks in advance</p>
</div>
<div class="post-text" itemprop="text">
<p>Try the following</p>
<pre><code>In [26]: import re

In [27]: f = lambda x: [int(x) for x in re.findall(r'\d+', x)]

In [28]: sorted(strings, key=f)
Out[28]: ['test1txtfgg2', 'test1txtfgf10', 'test2txtsdsd1', 'test2txffdt3']
</code></pre>
<p>This uses regex (the <a href="https://docs.python.org/3/library/re.html" rel="nofollow"><code>re</code> module</a>) to find all integers in each string, then <a href="https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types" rel="nofollow">compares the resulting lists</a>. For example, <code>f('test1txtfgg2')</code> returns <code>[1, 2]</code>, which is then compared against other lists.</p>
</div>
<div class="post-text" itemprop="text">
<p>Extract the numeric parts and sort using them</p>
<pre><code>import re

d = """test1txtfgf10
test1txtfgg2
test2txffdt3
test2txtsdsd1"""

lines = d.split("\n")

re_numeric = re.compile("^[^\d]+(\d+)[^\d]+(\d+)$")

def key(line):
    """Returns a tuple (n1, n2) of the numeric parts of line."""
    m = re_numeric.match(line)
    if m:
        return (int(m.groups(1)), int(m.groups(2)))
    else:
        return None

lines.sort(key=key)
</code></pre>
<p>Now <code>lines</code> are</p>
<pre><code>['test1txtfgg2', 'test1txtfgf10', 'test2txtsdsd1', 'test2txffdt3']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import re
k = [
     "test1txtfgf10",
     "test1txtfgg2",
     "test2txffdt3",
     "test2txtsdsd1"
    ]

tmp = [([e for e in re.split("[a-z]",el) if e], el) for el in k ]
sorted(tmp, key=lambda k: tmp[0])
tmp = [res for cm, res in tmp]
</code></pre>
</div>
<span class="comment-copy">Python 2 or 3?  The reason I ask is that Python 2 has a <code>cmp</code> argument.</span>
<span class="comment-copy">While you <i>can</i> write this yourself, there are some very good "natural sort" libraries on PyPI that you may want to look at. Besides being easier, they may also have thought of edge cases you haven't, or optimized things in ways that you wouldn't bother to, etc.</span>
