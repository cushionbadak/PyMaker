<div class="post-text" itemprop="text">
<p>USAGE CONTEXT ADDED AT END</p>
<p>I often want to operate on an abstract object like a list.  e.g.</p>
<pre><code>def list_ish(thing):
    for i in xrange(0,len(thing)):
        print thing[i]
</code></pre>
<p>Now this appropriate if thing is a list, but will fail if thing is a dict for example.  what is the pythonic why to ask "do you behave like a list?"</p>
<p>NOTE:</p>
<pre><code>hasattr('__getitem__') and not hasattr('keys')
</code></pre>
<p>this will work for all cases I can think of, but I don't like defining a duck type negatively, as I expect there could be cases that it does not catch.</p>
<p>really what I want is to ask.<br/>
   "hey do you operate on integer indicies in the way I expect a list to do?"  e.g.</p>
<pre><code>  thing[i],  thing[4:7] = [...],   etc.
</code></pre>
<p>NOTE:  I do not want to simply execute my operations inside of a large try/except, since they are destructive.  it is not cool to try and fail here....</p>
<p>USAGE CONTEXT
-- A "point-lists"  is a list-like-thing that contains dict-like-things as its elements.
-- A "matrix" is a list-like-thing that contains list-like-things</p>
<p>-- I have a library of functions that operate on point-lists and also in an analogous way on matrix like things.  </p>
<p>-- for example, From the users point of view destructive operations like the "spreadsheet-like" operations "column-slice" can operate on both matrix objects and also on point-list objects in an analogous way -- the resulting thing is like the original one, but only has the specified columns.</p>
<p>-- since this particular operation is destructive it would not be cool to proceed as if an object were a matrix, only to find out part way thru the operation, it was really a point-list or none-of-the-above.</p>
<p>-- I want my 'is_matrix' and 'is_point_list' tests to be performant, since they sometimes occur inside inner loops.  So I would be satisfied with a test which only investigated element zero for example.  </p>
<p>-- I would prefer tests that do not involve construction of temporary objects, just to determine an object's type, but maybe that is not the python way.</p>
<p>in general I find the whole duck typing thing to be kinda messy, and fraught with bugs and slowness, but maybe I dont yet think like a true Pythonista</p>
<p>happy to drink more kool-aid...</p>
</div>
<div class="post-text" itemprop="text">
<p>One thing you can do, that should work quickly on a normal <code>list</code> and fail on a normal <code>dict</code>, is taking a zero-length slice from the front:</p>
<pre><code>try:
    thing[:0]
except TypeError:
    # probably not list-like
else:
    # probably list-like
</code></pre>
<p>The slice fails on <code>dict</code>s because slices are not hashable.</p>
<p>However, <code>str</code> and <code>unicode</code> also pass this test, and you mention that you are doing destructive edits. That means you probably also want to check for <code>__delitem__</code> and <code>__setitem__</code>:</p>
<pre><code>def supports_slices_and_editing(thing):
    if hasattr(thing, '__setitem__') and hasattr(thing, '__delitem__'):
        try:
            thing[:0]
            return True
        except TypeError:
            pass
    return False
</code></pre>
<p>I suggest you organize the requirements you have for your input, and the range of possible inputs you want your function to handle, more explicitly than you have so far in your question. If you really just wanted to handle <code>list</code>s and <code>dict</code>s, you'd be using <code>isinstance</code>, right? Maybe what your method does could only ever delete items, or only ever replace items, so you don't need to check for the other capability. Document these requirements for future reference.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>When dealing with built-in types</strong>, you can use the <a href="https://docs.python.org/2.6/library/collections.html#abcs-abstract-base-classes" rel="nofollow">Abstract Base Classes</a>. In your case, you may want to test against <code>collections.Sequence</code> or <code>collections.MutableSequence</code>:</p>
<pre><code>if isinstance(your_thing, collections.Sequence):
    # access your_thing as a list
</code></pre>
<p>This is supported in all Python versions after (and including) 2.6.</p>
<p><strong>If you are using your own classes</strong> to build <code>your_thing</code>, I'd recommend that you inherit from these abstract base classes as well (directly or indirectly). This way, you can ensure that the sequence interface is implemented correctly, and avoid all the typing mess.</p>
<p><strong>And for third-party libraries</strong>, there's no simple way to check for a sequence interface, if the third-party classes didn't inherit from the built-in types or abstract classes. In this case you'll have to check for every interface that you're going to use, and <em>only</em> those you use. For example, your <code>list_ish</code> function used <code>__len__</code> and <code>__getitem__</code>, so only check whether these two methods exist. A wrong behavior of <code>__getitem__</code> (e.g. a dict) should raise an exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>Perhaps their is no ideal pythonic answer here, so I am proposing a 'hack' solution, but don't know enough about the class structure of python to know if I am getting this right:</p>
<pre><code>def is_list_like(thing):
    return hasattr(thing, '__setslice__')

def is_dict_like(thing):
    return hasattr(thing, 'keys')
</code></pre>
<p>My reduce goals here are to simply have performant tests that will: </p>
<ul>
<li>(1) never call a dict-thing, nor a string-like-thing a list List item</li>
<li>(2) returns the right answer for python types </li>
<li>(3) will return the right answer if someone implement a "full" set of core method for a list/dict </li>
<li>(4) is fast (ideally does not allocate objects during the test)</li>
</ul>
<p>EDIT: Incorporated ideas from @DanGetz</p>
</div>
<span class="comment-copy">The accepted way to do Duck Typing in Python is to treat it like a duck, then use try/except to find out that it didn't work. Can you be a little more descriptive about why you don't think that will work in your case?</span>
<span class="comment-copy">Just check the type of <code>thing</code>? E.g. <a href="http://stackoverflow.com/questions/1835018/python-check-if-an-object-is-a-list-or-tuple-but-not-string" title="python check if an object is a list or tuple but not string">stackoverflow.com/questions/1835018/â€¦</a></span>
<span class="comment-copy">Are you just trying to fail-fast? Or do you really need to determine the type? If someone passes in a duck-typed "list" that doesn't derive <code>list</code>, how much of the <code>list</code> functionality do you require, or expect that they'll implement?</span>
<span class="comment-copy">Right off the bat, it's more Pythonic to use <code>for item in thing: print item</code> than to iterate over a sequence of indices.</span>
<span class="comment-copy">@dangetz  just as 'sort' returns no value, instead directly modifies the list it is sorting, my column_slice operation modified all points within the pointlist or it modifies the inner lists within a matrix.  So it is destructive -- my use case is serial operations over very large datasets, so like the numpy module, I allow the user to modify these structures in place, and require them to explicitly copy them, when they want to separate effect in on place from actions in another place.</span>
<span class="comment-copy">Relying on those ABCs is dangerous, though; they're missing <code>__subclasshook__</code>s, so for example, <code>issubclass(shelve.Shelf, collections.Mapping)</code> is <code>False</code>, even though <code>shelve.Shelf</code> is standard library code.</span>
<span class="comment-copy">@user2357112 This is a bug in the library then. And I believe it's fixed in 3.4</span>
<span class="comment-copy">It's not fixed. <code>shelve.Shelf</code> inherits from <code>MutableMapping</code> in Python 3.4, so that example doesn't reproduce the bug any more, but you still run into the same problem with any class that doesn't inherit from the ABC and isn't explicitly registered as a subclass. <a href="https://bugs.python.org/issue23864" rel="nofollow noreferrer">There's an open bug report on the bug tracker about it.</a></span>
<span class="comment-copy">Looks faster, yes. Are you intending to call it on every element of a sequence? I thought you had sequences of which all elements were of the same type, in which case speed would not be much of an issue. You should be aware that the official documentation does not mention the <code>__setslice__</code> special method. The "official" way appears to be calling <code>__setitem__</code> with a <code>slice()</code> value.</span>
<span class="comment-copy">@DanGetz:    Thanks for you patience.  I incorporated your 'official' approach, but in a way that only performs hasattr.  (Yes in the data martialing routines I will be performing a large 'type_case' on each element as I recurse thru structures, in order to perform the correct specialized dump/load for those structures.)</span>
<span class="comment-copy">Sorry, I should have been more specific: I wasn't talking about a <code>list.slice()</code> method; that doesn't exist. I was referring to the built-in <a href="https://docs.python.org/3/library/functions.html#slice" rel="nofollow noreferrer">slice objects</a>, which can be passed in to <code>__setitem__</code>.</span>
<span class="comment-copy">@DanGetz, got it.  yes I just verified that 'slice' was not an attr of basestring nor, of dict, but did not verify that it was a attr of list !   Ok I will revert my answer.  (for the record, I came up with my answer by doing set differences on the dir() for the respective classes.   The whole thing is hacky, but it will serve my purpose.  Thanks much for your dedication!</span>
