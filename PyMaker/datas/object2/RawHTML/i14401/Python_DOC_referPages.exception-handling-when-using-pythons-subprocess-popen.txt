<div class="post-text" itemprop="text">
<p>When dealing with open files, Python has the <code>with</code> syntax that makes sure the file closes when leaving the block - regardless of exceptions etc.</p>
<pre><code>with open('foo.txt') as f:
    foo = f.read()
</code></pre>
<p>Since processes are resources too, I was wondering: is something similar possible or recommended when using <code>Popen</code>? For example, should <a href="https://docs.python.org/2/library/subprocess.html#subprocess.Popen.kill"><code>Popen.kill(); Popen.communicate()</code></a> be run in a <code>finally</code> clause - assuming I don't mind blocking until the process finishes?</p>
</div>
<div class="post-text" itemprop="text">
<p>Starting from Python 3.2 <code>Popen</code> is a context manager.</p>
<p>from the <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow">docs</a>:</p>
<blockquote>
<p>Popen objects are supported as context managers via the with statement: on exit, standard file descriptors are closed, and the process is waited for.</p>
</blockquote>
<p>This should do pretty much what you want.</p>
<p>This is the relevant part from <code>subprocess.py</code> from the standard lib
in Python 3.4:</p>
<pre><code>def __enter__(self):
    return self

def __exit__(self, type, value, traceback):
    if self.stdout:
        self.stdout.close()
    if self.stderr:
        self.stderr.close()
    if self.stdin:
        self.stdin.close()
    # Wait for the process to terminate, to avoid zombies.
    self.wait()
</code></pre>
<p>Now you can do in Python 2.7</p>
<pre><code>from subprocess import Popen

class MyPopen(Popen):

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if self.stdout:
            self.stdout.close()
        if self.stderr:
            self.stderr.close()
        if self.stdin:
            self.stdin.close()
        # Wait for the process to terminate, to avoid zombies.
        self.wait()

if __name__ == '__main__':
    with MyPopen(['ls']) as p:
        print(p)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For 2.7 you could also use the <a href="https://docs.python.org/2/library/contextlib.html#contextlib.contextmanager" rel="nofollow noreferrer"><strong><code>@contextlib.contextmanager</code></strong></a>:</p>
<pre><code>import contextlib

@contextlib.contextmanager
def manage_process(process):
    try:
        yield process
    finally:
        for stream in [process.stdout, process.stdin, process.stderr]:
            if stream:
                stream.close()
        process.wait()
</code></pre>
<p>e.g:</p>
<pre><code>with manage_process(Popen(['ls'])) as p:
    print(p)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can add just two custom methods to any class to implement comptability with <code>with</code> statement.</p>
<pre><code>class CustomObject(object):
    def __enter__(self):
        """ This method execudes when entering block. """
        return thing_you_want_to_use

    def __exit__(self, type, value, traceback):
        """ This method execudes on block exit. """
        # Tear things down.
</code></pre>
</div>
<span class="comment-copy">If you were running a version pre python 3.2. you could just define a class with the <code>__enter__</code> and <code>__exit__</code> magic methods to use <code>with</code>.</span>
<span class="comment-copy">OK, cool. So it sounds like it's not a bad idea to do it in Python 2.7 as well, using <code>try...finally</code></span>
<span class="comment-copy">I added a Python 2.7 version by copying the code from python 3.4. Might need some testing though. ;)</span>
<span class="comment-copy">@z0r: there is <code>subprocess32</code> module that you can install on Python 2.7 (it provides other improvements too. Though it might not work on non-POSIX systems).</span>
