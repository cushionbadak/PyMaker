<div class="post-text" itemprop="text">
<p>Been struggling with this for a while.</p>
<p>Based on this thread: <a href="https://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them">Using global variables in a function other than the one that created them</a></p>
<p>I should be able to update the variable used by thread_2 by scheduling a task at certain times.</p>
<p>The code:</p>
<pre><code>import asyncio
from concurrent.futures import ProcessPoolExecutor
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime
import time


def day_limits():

        global variable
        variable = 90
        print ('Day Variable: ',variable)

def night_limits():

        global variable
        variable = 65
        print ('Night Variable: ',variable)


def thread_2():


    while True:

        c_hour = int(datetime.now().strftime("%H"))
        c_min = int(datetime.now().strftime("%M"))
        c_sec = int(datetime.now().strftime("%S"))

        print ('%02d:%02d:%02d - Variable: %d ' % (c_hour,c_min,c_sec,variable))

        time.sleep(2)


if __name__ == "__main__":

    variable = 60

    scheduler = AsyncIOScheduler()
    scheduler.add_job(day_limits, 'cron', hour=7,misfire_grace_time=3600,timezone='GB')
    scheduler.add_job(night_limits, 'cron', hour=19, minute=32,misfire_grace_time=3600,timezone='GB')
    scheduler.start()

    scheduler.print_jobs()

    executor = ProcessPoolExecutor(1)
    loop = asyncio.get_event_loop()
    baa = asyncio.async(loop.run_in_executor(executor, thread_2))


    try:
        loop.run_forever()

    except (KeyboardInterrupt, Exception):
        loop.stop()
        scheduler.shutdown()
</code></pre>
<p>Results in:</p>
<pre><code>19:31:54 - Variable: 60 
19:31:56 - Variable: 60 
19:31:58 - Variable: 60    
Night Variable:  65
19:32:00 - Variable: 60 
19:32:02 - Variable: 60 
</code></pre>
<p>I am missing something, but I can't see what!</p>
<p>Thoughts?</p>
<p>Thanks!!!</p>
</div>
<div class="post-text" itemprop="text">
<p>Because you're using a <code>ProcessPoolExecutor</code>, you need to use a process-safe object in place of an ordinary integer. If you only need to support Linux (and can therefore rely on having <code>fork()</code>), you can just use an ordinary, global <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value" rel="nofollow"><code>multiprocessing.Value</code></a> to do this.</p>
<pre><code>import asyncio
import multiprocessing
from concurrent.futures import ProcessPoolExecutor
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime
import time


def day_limits():
        variable.value = 90
        print ('Day Variable: ',variable.value)

def night_limits():
        variable.value = 65
        print ('Night Variable: ',variable.value)


def thread_2():
    while True:
        c_hour = int(datetime.now().strftime("%H"))
        c_min = int(datetime.now().strftime("%M"))
        c_sec = int(datetime.now().strftime("%S"))

        print ('%02d:%02d:%02d - Variable: %d ' % (c_hour,c_min,c_sec,variable.value))

        time.sleep(2)


if __name__ == "__main__":
    variable = multiprocessing.Value('i', 60)

    scheduler = AsyncIOScheduler()
    scheduler.add_job(day_limits, 'cron', hour=7,misfire_grace_time=3600,timezone='GB')
    scheduler.add_job(night_limits, 'cron', hour=19, minute=32,misfire_grace_time=3600,timezone='GB')
    scheduler.start()

    scheduler.print_jobs()

    executor = ProcessPoolExecutor(1)
    loop = asyncio.get_event_loop()
    baa = asyncio.async(loop.run_in_executor(executor, thread_2))


    try:
        loop.run_forever()

    except (KeyboardInterrupt, Exception):
        loop.stop()
        scheduler.shutdown()
</code></pre>
<p>If you need to support both Windows and Linux, you'll need to use a <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.sharedctypes.multiprocessing.Manager" rel="nofollow"><code>multiprocessing.Manager</code></a> to create the <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.managers.SyncManager.Value" rel="nofollow"><code>Value</code></a> object, and explicitly pass that object to the function you're running in the <code>Executor</code>:</p>
<pre><code>import asyncio
import multiprocessing
from concurrent.futures import ProcessPoolExecutor
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime
import time


def day_limits():
        variable.value = 90
        print ('Day Variable: ',variable.value)

def night_limits():
        variable.value = 65
        print ('Night Variable: ',variable.value)


def thread_2(variable):
    while True:
        c_hour = int(datetime.now().strftime("%H"))
        c_min = int(datetime.now().strftime("%M"))
        c_sec = int(datetime.now().strftime("%S"))

        print ('%02d:%02d:%02d - Variable: %d ' % (c_hour,c_min,c_sec,variable.value))

        time.sleep(2)


if __name__ == "__main__":

    m = multiprocessing.Manager()
    variable = m.Value('i', 60)

    scheduler = AsyncIOScheduler()
    scheduler.add_job(day_limits, 'cron', hour=7,misfire_grace_time=3600,timezone='GB')
    scheduler.add_job(night_limits, 'cron', hour=19, minute=32,misfire_grace_time=3600,timezone='GB')
    scheduler.start()

    scheduler.print_jobs()

    executor = ProcessPoolExecutor(1)
    loop = asyncio.get_event_loop()
    baa = asyncio.async(loop.run_in_executor(executor, thread_2, variable))  # Need to pass variable explicitly

    try:
        loop.run_forever()

    except (KeyboardInterrupt, Exception):
        loop.stop()
        scheduler.shutdown()
</code></pre>
<p>Because Windows lacks <code>fork</code> support, you need to explicitly pass the <code>Value</code> to the function you're running in the <code>Executor</code>. If you don't, the child process will say that the variable doesn't exist. However, since you're explicitly passing the <code>Value</code> to the <code>run_in_executor</code> method, you can't use an ordinary <code>multiprocessing.Value</code> - you'll get a <code>RuntimeError</code> saying that "Synchronized objects should only be shared between processes through inheritance".</p>
<p>Using the <code>multiprocessing.Manager</code> works around this; the <code>multiprocessing.Manager</code> starts a process that can create and managed process-shared objects. Calling <code>m.Value()</code> returns a <code>Proxy</code> to a shared <code>Value</code>, and that <code>Proxy</code> can be passed to <code>run_in_executor</code> without raising an exception.</p>
</div>
<div class="post-text" itemprop="text">
<p>The problem is simple: You are using ProcessPoolExecutor. So the jobs are run in another process, which has its own memory space. <code>variable</code> is set correctly there, but it has a different value (60) in the parent process, which is never changed.</p>
</div>
<span class="comment-copy">Is this your complete code snippet? Don't understand where the functions are being called?</span>
<span class="comment-copy">At the bottom in the main area. Two are called via APscheduler, and run correctly. Final thing is a thread by asyncio (baa line).</span>
<span class="comment-copy">I thought it probably was due to that. What is the solution? Some sort of pointer?</span>
