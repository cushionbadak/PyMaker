<div class="post-text" itemprop="text">
<p>I am confused about how to play around with the <code>asyncio</code> module in Python 3.4. I have a <code>searching</code> API for a search engine, and want to each search request to be run either parallel, or asynchronously, so that I don't have to wait for one search finish to start another.</p>
<p>Here is my high-level searching API to build some objects with the raw search results. The search engine itself is using some kind of asyncio mechanism, so I won't bother with that.</p>
<pre><code># No asyncio module used here now
class search(object):
  ...
  self.s = some_search_engine()
  ...
  def searching(self, *args, **kwargs):
    ret = {}
    # do some raw searching according to args and kwargs and build the wrapped results
    ...
    return ret
</code></pre>
<p>To try to async the requests, I wrote following test case to test how I can interact my stuff with the <code>asyncio</code> module.</p>
<pre><code># Here is my testing script
@asyncio.coroutine
def handle(f, *args, **kwargs):
  r = yield from f(*args, **kwargs)
  return r

s = search()
loop = asyncio.get_event_loop()
loop.run_until_complete(handle(s.searching, arg1, arg2, ...))
loop.close()
</code></pre>
<p>By running with pytest, it will return a <code>RuntimeError: Task got bad yield : {results from searching...}</code>, when it hits the line <code>r = yield from ...</code>. </p>
<p>I also tried another way.</p>
<pre><code># same handle as above
def handle(..):
  ....
s = search()
loop = asyncio.get_event_loop()
tasks = [
        asyncio.async(handle(s.searching, arg11, arg12, ...)),
        asyncio.async(handle(s.searching, arg21, arg22, ...)),
        ...
        ]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
</code></pre>
<p>By running this test case by pytest, it passes but some weird exception from the search engine will raise. And it says <code>Future/Task exception was never retrieved</code>.</p>
<p>Things I wish to ask:</p>
<ol>
<li>For my 1st try, is that the right way to use <code>yield from</code>, by returning the actual result from a function call?</li>
<li>I think I need to add some sleep to my 2nd test case to wait for the task finish, but how should I do that? And how can I get my function calls to return in my 2nd test case?</li>
<li>Is that a good way to implement asyncio with an existing module, by creating an async handler to handle requests?</li>
<li>If the answer to question 2 is NO, does every client calls to the class <code>search</code> needs to include <code>loop = get_event_loop()</code> this kind of stuffs to async the requests?</li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The problem is that you can't just call existing synchronous code as if it was an <code>asyncio.coroutine</code> and get asynchronous behavior. When you call <code>yield from searching(...)</code>, you're only going to get asynchronous behavior if <code>searching</code> itself is actually an <code>asyncio.coroutine</code>, or at least returns an <code>asyncio.Future</code>. Right now, <code>searching</code> is just a regular synchronous function, so calling <code>yield from searching(...)</code> is just going to throw an error, because it doesn't return a <code>Future</code> or coroutine.</p>
<p>To get the behavior you want, you'll need to have an asynchronous version of <code>searching</code> in addition to a <code>synchronous</code> version (or just drop the synchronous version altogether if you don't need it). You have a few options to support both:</p>
<ol>
<li>Rewrite <code>searching</code> as an <code>asyncio.coroutine</code> that it uses <code>asyncio</code>-compatible calls to do its I/O, rather than blocking I/O.  This will make it work in an <code>asyncio</code> context, but it means you won't be able to call it directly in a synchronous context anymore. Instead, you'd need to also provide an alternative synchronous <code>searching</code> method that starts an <code>asyncio</code> event loop and calls <code>return loop.run_until_complete(self.searching(...))</code>. See <a href="https://stackoverflow.com/questions/30155138/how-can-i-write-asyncio-coroutines-that-optionally-act-as-regular-functions">this question</a> for more details on that.</li>
<li><p>Keep your synchronous implementation of <code>searching</code>, and provide an alternative asynchronous API that uses <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.run_in_executor" rel="noreferrer"><code>BaseEventLoop.run_in_executor</code></a> to run your the <code>searching</code> method in a background thread:</p>
<pre><code>class search(object):
  ...
  self.s = some_search_engine()
  ...
  def searching(self, *args, **kwargs):
    ret = {}
    ...
    return ret

   @asyncio.coroutine
   def searching_async(self, *args, **kwargs):
      loop = kwargs.get('loop', asyncio.get_event_loop())
      try:
          del kwargs['loop']  # assuming searching doesn't take loop as an arg
      except KeyError:
          pass
      r = yield from loop.run_in_executor(None, self.searching, *args)  # Passing None tells asyncio to use the default ThreadPoolExecutor
      return r
</code></pre>
<p>Testing script:</p>
<pre><code>s = search()
loop = asyncio.get_event_loop()
loop.run_until_complete(s.searching_async(arg1, arg2, ...))
loop.close()
</code></pre>
<p>This way, you can keep your synchronous code as is, and at least provide methods that can be used in <code>asyncio</code> code without blocking the event loop. It's not as clean a solution as it would be if you actually used asynchronous I/O in your code, but its better than nothing.</p></li>
<li>Provide two completely separate versions of <code>searching</code>, one that uses blocking I/O, and one that's <code>asyncio</code>-compatible. This gives ideal implementations for both contexts, but requires twice the work.</li>
</ol>
</div>
<span class="comment-copy">Excellent! Thank you so much! I've seen some C++ coding about asyncio and they used <code>void foo(..) { bind(foo_callin, _1, _2, ...); }</code> and in <code>void foo_callin(..)</code> doing the real implementation. Is this the idea quite similar to your 2nd option?</span>
<span class="comment-copy">@ourlord Yes, if the <code>foo</code> function you're talking about is calling <code>foo_callin</code> in a background thread (and it sounds like that might be what's happening, depending on what is called addition to <code>bind(foo_callin, ..)</code>), it's doing something very similar to the second option.</span>
<span class="comment-copy">Oh yeah, I remember that the <code>bind</code> function is under a self-implement <code>async</code> namespace which should include a thread/task scheduler or manager. Things are getting really clear now! Thank you again for your comments!</span>
