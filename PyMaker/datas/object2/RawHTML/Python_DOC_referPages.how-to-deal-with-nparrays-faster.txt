<div class="post-text" itemprop="text">
<p>I have two images loaded in to two numpy array. I want to get the difference of them and remove the values less than 50 and set the rest of it to 255 with a final result of back and white image.  </p>
<pre><code>def count(base, image):
    x, y, z = base.shape
    sheet = np.zeros(base.shape)
    for i in range(x):
        for j in range(y):
            temp = 0
            for k in range(z):
                if base[i, j, k] &gt; image[i, j, k]:
                    t = base[i, j, k] - image[i, j, k]
                    if t &gt; 50:
                        temp = 255
                else:
                    t = image[i, j, k] - base[i, j, k]
                    if t &gt; 50:
                        temp = 255
            sheet[i, j] = [temp, temp, temp]

    array = sheet[:, :, 0]
</code></pre>
<p>this code does what i need it to do. but as you see i have used the most simplest for loop for this function and with the images being in the size of 2000*2000, it takes a long time to process. i need a way to rewrite this in a faster way. </p>
<p>thank you</p>
</div>
<div class="post-text" itemprop="text">
<p>Vectorizing your code looks straight-forward, except for one gotcha: Your data appear  to be unsigned ints (<code>uint8</code> by the look of it) which require a bit of extra attention since they frequently underflow with unexpected results. For example, the obvious <code>np.abs(image-base)&gt;50</code> to detect differences greater than 50 does not work, in fact <code>np.abs</code> is a nop on unsigned data. A careful translation would look more like</p>
<pre><code>sheet = np.array([[0,0,0],[255,255,255]], 'u1')[((np.maximum(base, image)-np.minimum(base, image))&gt;50).any(2).view('u1')]
</code></pre>
<p>or</p>
<pre><code>sheet = np.array([[0,0,0],[255,255,255]], 'u1')[(np.abs(np.subtract(image, base, dtype='i2'))&gt;50).any(2).view('u1')]
</code></pre>
<p>This</p>
<ol>
<li><p>correctly computes the subpixel wise difference,</p>
<ul>
<li><p>the first version mimics your if/else clause</p></li>
<li><p>the second forces a signed result type <code>'i2'</code> or <code>int16</code> for the difference</p></li>
</ul></li>
<li><p>detects those greater 50,</p></li>
<li><p>marks pixels with at least one such subpixel (<code>any(2)</code>),</p></li>
<li><p>converts the resulting boolean mask into indices (<code>.view('u1')</code>) 0 and 1</p></li>
<li><p>and uses those to index into a template array.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>Most of the operations work just as they would on scalars on NumPy arrays of the same size. I re-wrote the function as,</p>
<pre><code>def count_new(base, image, thresh=50):
    # these are the pixel absolute value differences
    differences = np.abs(base - image)

    # whether the difference exceeds the threshold
    big_difference = differences &gt; thresh

    # whether each pixel has at least one big difference
    big_difference = big_difference.any(axis=2)

    # return 255 where big differences, and 0 everywhere else
    return 255 * big_difference.astype(int)
</code></pre>
<p>Hopefully the comments make the intent of each line clear. Also checked this gives the same as the previous out-put</p>
<pre><code>x = np.random.randint(256, size=(10, 11, 3))
y = np.random.randint(256, size=(10, 11, 3))
assert((count(x,y) == count_new(x,y)).all())
</code></pre>
<p>which shows it does.</p>
</div>
<span class="comment-copy"><code>sheet = np.array([[0,0,0],[255,255,255]], 'u1')[(np.abs(image-base)&gt;50).any(2).view('u1')]</code>?</span>
<span class="comment-copy">@PaulPanzer this doesn't give the same results as the code.. seems like most of the pixels are 255 in this case.. having hard time figuring out how to edit.</span>
<span class="comment-copy">Argh, those bleedin' unsigned types! How's that: <code>sheet = np.array([[0,0,0],[255,255,255]], 'u1')[((np.maximum(base, image)-np.minimum(base, image))&gt;50).any(2).view('u1')]</code>?</span>
