<div class="post-text" itemprop="text">
<p>The current code I have, allows the function to call the wrapper decorator, and uses the function name in its code. However, I'm looking for a way to give the function a 'alias' in a way as an argument. Here's the current code:</p>
<pre><code>import os, sys

# Take user input
message = input('type command: ')

# Command wrapper
ALLCOMMANDS = {}
def command(function):
    ALLCOMMANDS[function.__name__] = function
    return function 

# Commands  
@command
def foo():
    print("bar")

@command
def goo():
    print('ber')

# Run appropriate command
if message in ALLCOMMANDS:
    ALLCOMMANDS[message]()
</code></pre>
<p>For example I would want to be able to call the function by a name such as '!foo' from the user input, so maybe the argument would look like <code>@command(name='!foo')</code>, I just don't know where to go from there to use that argument in the decorator since it already has an argument. </p>
<p>I attempted</p>
<pre><code># Command wrapper
ALLCOMMANDS = {}
def command(name):
    ALLCOMMANDS[name] = name
    return name
</code></pre>
<p>but keep getting errors and I assume I am missing something</p>
</div>
<div class="post-text" itemprop="text">
<p>You should read up a bit more on python decorators. You're getting an error with:</p>
<pre><code>def command(name):
    ALLCOMMANDS[name] = name
    return name
</code></pre>
<p>Because of the <code>return name</code>.</p>
<p>Decorators are just syntactic sugar. This:</p>
<pre><code>@command
def foo():
    print('bar')
</code></pre>
<p>Is equivalent to:</p>
<pre><code>def foo():
    print('bar')

foo = command(foo)
</code></pre>
<p>From this you can see why your original decorator works. At the end you <code>return function</code>.</p>
<p>Things get a little tricker when you have a decorator that takes arguments. Desugared the following:</p>
<pre><code>@command('nickname')
def foo():
    print('bar')
</code></pre>
<p>Looks like this:</p>
<pre><code>def foo():
    print('bar')

foo = command('nickname')(foo)
</code></pre>
<p>So, to write a decorator that takes arguments, the decorator needs to return a function that takes the function to decorate as an argument:</p>
<pre><code>def command(nickname):
    def wrapped(f):
        ALLCOMMANDS[nickname] = f
        return f
    return wrapped
</code></pre>
<p>Also consider making <code>ALLCOMMANDS</code> an attribute on your command instead of a global (<code>UPPER_SNAKE</code> is usually reserved for constants):</p>
<pre><code>def command(nickname):
    def wrapped(f):
        command._functions[nickname] = f
        return f
    return wrapped

command._functions = {}
</code></pre>
</div>
<span class="comment-copy">If you follow this you should be able to pass a name argument: <a href="https://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html#decorator-functions-with-decorator-arguments" rel="nofollow noreferrer">python-3-patterns-idioms-test.readthedocs.io/en/latest/â€¦</a></span>
<span class="comment-copy">Ah, makes sense. Appreciate the detailed help, and I'll implement those recommendations</span>
