<div class="post-text" itemprop="text">
<p>Let's say I have a list of dictionaries like so:</p>
<pre><code>dict[0] is
{'key_a': valuex1,
 'key_b': valuex2,
 'key_c': valuex3}

dict[1] is
{'key_a': valuey1,
 'key_b': valuey2,
 'key_c': valuey3}

dict[2] is
{'key_a': valuez1,
 'key_b': valuez2,
 'key_c': valuez3}
</code></pre>
<p>I would like to take these and construct a big dictionary like so:</p>
<pre><code>big_dict:
{'key_a': [valuex1, valuey1, valuez1],
 'key_b': [valuex2, valuey2, valuez2],
 'key_c': [valuex3, valuey3, valuez3]}
</code></pre>
<p>Is there any elegant "<a href="http://docs.python.org/library/functions.html#zip" rel="noreferrer">zip</a>"-like way for me to do this? </p>
<p>All the keys are always going to be identical. </p>
<p>I can always iterate the keys on each and construct a new dictionary of lists but that seems very un-pythonlike.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>big_dict = {}
for k in dicts[0]:
    big_dict[k] = [d[k] for d in dicts]
</code></pre>
<p>(I renamed your <code>dict</code> to <code>dicts</code> since dict is a built-in, and dicts makes more sense.)</p>
<p>Or, with a dict comprehension:</p>
<pre><code>{ k:[d[k] for d in dicts] for k in dicts[0] }
</code></pre>
<p>or, for Python &lt;2.7:</p>
<pre><code>dict((k, [d[k] for d in dicts]) for k in dicts[0])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If all the dicts have the same set of keys, this will work:</p>
<pre><code>dict((k, [d[k] for d in dictList]) for k in dictList[0])
</code></pre>
<p>If they may have different keys, you'll need to first built a set of keys by doing set unions on the keys of the various dicts:</p>
<pre><code>allKeys = reduce(operator.or_, (set(d.keys()) for d in dictList), set())
</code></pre>
<p>Then you'll need to protect against missing keys in some dicts:</p>
<pre><code>dict((k, [d[k] for d in [a, b] if k in d]) for k in allKeys)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can merge dictionaries in the following way:</p>
<pre><code>def merge_dicts(dict_list, separator=''):
    """
    Merges list of dictionaries to a single dictionary, Concatenates values with the same key.
    :param dict_list: list of dictionaries to be merged.
    :param separator: separator to be inserted between values of same key.
    :return: Merged dictionary.
    """
    return {k1: separator.join([d[k1] for d in dict_list if k1 in d])
            for k1 in set(reduce(lambda x, y: x+y, [k.keys() for k in dict_list]))
    }
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a>. The benefit of this solution is it does not require keys to be consistent across dictionaries, and it still maintains the minimum O(<em>n</em>) time complexity.</p>
<pre><code>from collections import defaultdict

dictList = [{'key_a': 'valuex1', 'key_b': 'valuex2', 'key_c': 'valuex3'},
            {'key_a': 'valuey1', 'key_b': 'valuey2', 'key_c': 'valuey3'},
            {'key_a': 'valuez1', 'key_b': 'valuez2', 'key_c': 'valuez3'}]            

d = defaultdict(list)
for myd in dictList:
    for k, v in myd.items():
        d[k].append(v)
</code></pre>
<p>Result:</p>
<pre><code>print(d)

defaultdict(list,
            {'key_a': ['valuex1', 'valuey1', 'valuez1'],
             'key_b': ['valuex2', 'valuey2', 'valuez2'],
             'key_c': ['valuex3', 'valuey3', 'valuez3']})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you are happy to use a 3rd party library you can use Pandas. The <code>pd.DataFrame</code> constructor accepts a list of dictionaries directly:</p>
<pre><code>import pandas as pd

res = pd.DataFrame(dictList).to_dict(orient='list')

{'key_a': ['valuex1', 'valuey1', 'valuez1'],
 'key_b': ['valuex2', 'valuey2', 'valuez2'],
 'key_c': ['valuex3', 'valuey3', 'valuez3']}
</code></pre>
</div>
<span class="comment-copy">Awesome. I learnt something new with the comprehension. Thanks!</span>
<span class="comment-copy">You could use a dictionary comprehension: <code>{k: [d[k] for d in dictList[ for k in dictList[0]}</code></span>
<span class="comment-copy">Yes, if you're using a Python version that supports dictionary comprehensions.  I'm using 2.6 myself so I don't have that.</span>
<span class="comment-copy">a dict comprehension is syntactically synonymous to a generator expression where <code>{key: value ...}</code> is replaced with <code>dict((key, value) ...)</code>, which is even valid in 2.6</span>
<span class="comment-copy">Thanks, that worked too.</span>
