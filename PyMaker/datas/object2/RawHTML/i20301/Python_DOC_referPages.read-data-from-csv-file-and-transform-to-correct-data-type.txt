<div class="post-text" itemprop="text">
<p>I've got following problem. I wrote a 2-dimensional list, where each column is of a different type (bool, str, int, list), to a csv-file.
Now I want to read out the data from the csv-file again. But every cell I read is interpreted as a string.</p>
<p>How can I automatically convert the read-in data into the correct type? Or better: Is there a possibility, to tell the csv-reader the correct data-type of each column?</p>
<p>Sample Data (like in csv-file):</p>
<pre class="lang-none prettyprint-override"><code>IsActive,Type,Price,States
True,Cellphone,34,"[1, 2]"
,FlatTv,3.5,[2]
False,Screen,100.23,"[5, 1]"
True,Notebook, 50,[1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As the <a href="https://docs.python.org/3/library/csv.html#csv.reader" rel="noreferrer">docs explain</a>, the CSV reader doesn't perform automatic data conversion. You have the QUOTE_NONNUMERIC format option, but that would only convert all non-quoted fields into floats. This is a very similar behaviour to other csv readers.</p>
<p>I don't believe Python's csv module would be of any help for this case at all. As others have already pointed out, <code>literal_eval()</code> is a far better choice.</p>
<p>The following does work and converts:</p>
<ul>
<li>strings </li>
<li>int</li>
<li>floats</li>
<li>lists</li>
<li>dictionaries</li>
</ul>
<p>You may also use it for booleans and NoneType, although these have to be formatted accordingly for <code>literal_eval()</code> to pass. LibreOffice Calc displays booleans in capital letters, when in Python booleans are Capitalized. Also, you would have to replace empty strings with <code>None</code> (without quotes)</p>
<p>I'm writing an importer for mongodb that does all this. The following is part of the code I've written so far.</p>
<p>[NOTE: My csv uses tab as field delimiter. You may want to add some exception handling too]</p>
<pre><code>def getFieldnames(csvFile):
    """
    Read the first row and store values in a tuple
    """
    with open(csvFile) as csvfile:
        firstRow = csvfile.readlines(1)
        fieldnames = tuple(firstRow[0].strip('\n').split("\t"))
    return fieldnames

def writeCursor(csvFile, fieldnames):
    """
    Convert csv rows into an array of dictionaries
    All data types are automatically checked and converted
    """
    cursor = []  # Placeholder for the dictionaries/documents
    with open(csvFile) as csvFile:
        for row in islice(csvFile, 1, None):
            values = list(row.strip('\n').split("\t"))
            for i, value in enumerate(values):
                nValue = ast.literal_eval(value)
                values[i] = nValue
            cursor.append(dict(zip(fieldnames, values)))
    return cursor
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to map your rows:</p>
<pre><code>data = """True,foo,1,2.3,baz
False,bar,7,9.8,qux"""

reader = csv.reader(StringIO.StringIO(data), delimiter=",")
parsed = (({'True':True}.get(row[0], False),
           row[1],
           int(row[2]),
           float(row[3]),
           row[4])
          for row in reader)
for row in parsed:
    print row
</code></pre>
<p>results in</p>
<pre><code>(True, 'foo', 1, 2.3, 'baz')
(False, 'bar', 7, 9.8, 'qux')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Props to Jon Clements and cortopy for teaching me about <code>ast.literal_eval</code>! Here's what I ended up going with (Python 2; changes for 3 should be trivial):</p>
<pre><code>from ast import literal_eval
from csv import DictReader
import csv


def csv_data(filepath, **col_conversions):
    """Yield rows from the CSV file as dicts, with column headers as the keys.

    Values in the CSV rows are converted to Python values when possible,
    and are kept as strings otherwise.

    Specific conversion functions for columns may be specified via
    `col_conversions`: if a column's header is a key in this dict, its
    value will be applied as a function to the CSV data. Specify
    `ColumnHeader=str` if all values in the column should be interpreted
    as unquoted strings, but might be valid Python literals (`True`,
    `None`, `1`, etc.).

    Example usage:

    &gt;&gt;&gt; csv_data(filepath,
    ...          VariousWordsIncludingTrueAndFalse=str,
    ...          NumbersOfVaryingPrecision=float,
    ...          FloatsThatShouldBeRounded=round,
    ...          **{'Column Header With Spaces': arbitrary_function})
    """

    def parse_value(key, value):
        if key in col_conversions:
            return col_conversions[key](value)
        try:
            # Interpret the string as a Python literal
            return literal_eval(value)
        except Exception:
            # If that doesn't work, assume it's an unquoted string
            return value

    with open(filepath) as f:
        # QUOTE_NONE: don't process quote characters, to avoid the value
        # `"2"` becoming the int `2`, rather than the string `'2'`.
        for row in DictReader(f, quoting=csv.QUOTE_NONE):
            yield {k: parse_value(k, v) for k, v in row.iteritems()}
</code></pre>
<p>(I'm a little wary that I might have missed some corner cases involving quoting. Please comment if you see any issues!)</p>
</div>
<div class="post-text" itemprop="text">
<p>An alternative (although it seems a bit extreme) in lieu of using <code>ast.literal_eval</code> is the <code>pyparsing</code> module available on PyPi - and see if the <a href="http://pyparsing.wikispaces.com/file/view/parsePythonValue.py" rel="nofollow">http://pyparsing.wikispaces.com/file/view/parsePythonValue.py</a> code sample is either appropriate for what you require, or can be easily adapted.</p>
</div>
<div class="post-text" itemprop="text">
<p>I know this is a fairly old question, tagged <a class="post-tag" href="/questions/tagged/python-2.5" rel="tag" title="show questions tagged 'python-2.5'">python-2.5</a>, but here's answer that works with Python 3.6+ which might be of interest to folks using more up-to-date versions of the language.</p>
<p>It leverages the built-in <code>typing.NamedTuple</code> class which was added in Python 3.5. What may not be evident from the documentation is that the "type" of each field can be a function. </p>
<p>The example usage code also uses so-called <a href="https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals" rel="nofollow noreferrer">f-string</a> literals which weren't added until Python 3.6, but their use isn't required to do the core data-type transformations.</p>
<pre><code>#!/usr/bin/env python3
import ast
import csv
import typing


class Rec(typing.NamedTuple):
    """ Define each field and type of a record. """
    IsActive : bool
    Type: str
    Price: float
    States: ast.literal_eval  # To handle list string represenations.


filename = 'test_transform.csv'

with open(filename, newline='') as file:
    for i, row in enumerate(csv.DictReader(file)):
        row = {field: Rec._field_types[field](value) for field, value in row.items()}
        print(f'row {i}:  {row}')
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>row 0:  {'IsActive': True, 'Type': 'Cellphone', 'Price': 34.0, 'States': [1, 2]}
row 1:  {'IsActive': False, 'Type': 'FlatTv', 'Price': 3.5, 'States': [2]}
row 2:  {'IsActive': True, 'Type': 'Screen', 'Price': 100.23, 'States': [5, 1]}
row 3:  {'IsActive': True, 'Type': 'Notebook', 'Price': 50.0, 'States': [1]}
</code></pre>
</div>
<span class="comment-copy">Do you want to map the "States" column to a list of integers?</span>
<span class="comment-copy">@Tichodroma: correct</span>
<span class="comment-copy">A bad idea: To convert the data, except string-data, to the correct format, I could use <code>eval</code>. But I'd prefer to avoid this method.</span>
<span class="comment-copy">Possibly look at <code>ast.literal_eval</code></span>
<span class="comment-copy">@JonClements: Good idea, but this method doesn't exist in Python version 2.5.1 (see: <a href="http://docs.python.org/library/ast.html#ast-helpers" rel="nofollow noreferrer">docs.python.org/library/ast.html#ast-helpers</a>)</span>
<span class="comment-copy">its good solution if we want any basic data type conversion</span>
<span class="comment-copy">As the OP has a bool column in their example. For <code>row[0]</code> assuming that only "True" is <code>True</code> you could use <code>{'True': True}.get(row[0], False)</code></span>
<span class="comment-copy">@Tichodroma: But how do i convert cells, which contain lists? (Like <code>[1]</code> or <code>"[2, 3, 4]"</code>)</span>
<span class="comment-copy">Good question :) I don't recommend <code>eval</code> but have no solution ATM.</span>
<span class="comment-copy">List format is json-like, so maybe <code>json.loads</code> will help. It should handle nested lists, integers and strings...</span>
<span class="comment-copy">Pyparsing is no longer hosted on wikispaces.com. Go to <a href="https://github.com/pyparsing/pyparsing" rel="nofollow noreferrer">github.com/pyparsing/pyparsing</a></span>
