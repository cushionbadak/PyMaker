<div class="post-text" itemprop="text">
<p>I was a bit curious if I could do more work in a function after returning a result.  Basically I'm making a site using the pyramid framework(which is simply coding in python) after I process the inputs I return variables to render the page but sometimes I want to do more work after I render the page.</p>
<p>For example, you come to my site and update your profile and all you care about is that its successful so I output a message saying 'success!' but after that done I want to take your update and update my activity logs of what your doing, update your friends activity streams, etc..  Right now I'm doing all that before I return the result status that you care about but I'm curious if I can do it after so users get their responses faster.</p>
<p>I have done multi-processing before and worst case I might just fork a thread to do this work but if there was a way to do work after a return statement then that would be simpler.</p>
<p>example:</p>
<pre><code>def profile_update(inputs):
  #take updates and update the database 
  return "it worked"
  #do maintainence processing now..
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No, unfortunately, once you hit the <code>return</code> statement, you return from the function/method (either with or without a return value).</p>
<p>From the <a href="http://docs.python.org/reference/simple_stmts.html?highlight=break#grammar-token-return_stmt" rel="noreferrer">docs for return</a>:</p>
<blockquote>
<p>return leaves the current function call with the expression list (or None) as return value.</p>
</blockquote>
<p>You may want to look into generator functions and the <strong><a href="http://docs.python.org/reference/expressions.html?highlight=generator#yield-expressions" rel="noreferrer">yield</a></strong> statement, this is a way to return a value from a function and continue processing and preparing another value to be returned when the function is called the next time.</p>
</div>
<div class="post-text" itemprop="text">
<p>Why don't you use a <a href="http://docs.python.org/library/contextlib.html#contextlib.contextmanager">contextmanager</a>? It basically does exactly what you want.</p>
<p>Here's the canonical example from the Python docs.</p>
<pre><code>from contextlib import contextmanager

@contextmanager
def tag(name):
    print "&lt;%s&gt;" % name
    yield
    print "&lt;/%s&gt;" % name
</code></pre>
<p>So for your function, you'd just do:</p>
<pre><code>@contextmanager
def profile_update(inputs):
  #take updates and update the database 
  yield "it worked"
  #do maintainence processing now..
</code></pre>
<p>And to call it, you'd just do:</p>
<pre><code>with profile_update(inputs) as result: #pre-yield and yield here
    # do whatever while in scope
# as you move out of scope of with statement, post-yield is executed
</code></pre>
<p>EDIT: I was just testing things out, and it turns out that, with a yield statement, the function still executes to the end.  Here's a dumb example that illustrates the point and when things get executed.</p>
<pre><code>def some_generator(lst):
    for elem in lst:
        yield elem
    lst[0] = "I WAS CHANGED POST-YIELD!!!!"

&gt;&gt;&gt; q = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; gen = some_generator(q)
&gt;&gt;&gt; for e in gen:
...    print e, q

0 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
1 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
2 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
3 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
4 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
5 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
6 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
7 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
8 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
9 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print q
['I WAS CHANGED POST YIELD!!!', 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>A contextmanager has the advantage of not requiring two <code>next</code> calls to get to the stop iteration (and cleaner syntax), but if you wanted to return multiple values or something, you could also do it this way, but you can see that the post yield statement doesn't actually get called until the generator raises StopIteration on the <code>next</code> call (the for loop ends when it gets <code>StopIteration</code>)</p>
<hr/>
<p>If for some reason, you require a higher degree of control than <code>@contextmanager</code> offers, you can also define a class with <code>__enter__</code> and <code>__exit__</code> methods:</p>
<pre><code>class MyContextClass(object):
    # ...

    def __enter__(self):
        # do some preprocessing
        return some_object

    def __exit__(self, exc_type, exc_value, traceback):
        # do some post processing
        # possibly do some processing of exceptions raised within the block
        if exc_type == MyCustomErrorType:
            return True #don't propagate the error
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could still do some work after return if you return from a try-block, the finally-block would <em>still</em> be executed, e.g.:</p>
<pre><code>def fun():
    try:
        return
    finally:
        print "Yay! I still got executed, even though my function has already returned!"
</code></pre>
<p>Quoting <a href="https://docs.python.org/3/reference/simple_stmts.html#the-return-statement" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>When return passes control out of a try statement with a finally
  clause, that finally clause is executed before really leaving the
  function.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>No, a return gives the value back to the caller and stops.</p>
<p>If the caller(s) are also under your control (not part of the pyramid framework), you could change <code>profile_updates</code> to look like the following:</p>
<pre><code>def profile_update(inputs):
    #take updates and update the database 
    def post_processing_task():
        #do maintainence processing now..
    return ("it worked", post_processing_task)
</code></pre>
<p>And then code the caller to expect a pair of <code>(response, task)</code>, rather than just a response. It can do something immediately with the <code>response</code> part (communicate it to the user), then call <code>task()</code> to handle the post-processing.</p>
<p>This allows <code>profile_update</code> to determine what code needs to be executed afterwards (and keep those details hidden and encapsulated from the higher level), but allows the higher level to determine the flow of communicating a response to the user and then executing the post-processing in the background.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import threading

def profile_update(inputs):

    # call function to take updates and update the database 
    update_function(inputs)

    # call the maintainence_function here
    t = threading.Thread(target=maintainence_function, args=[input1, input2])
    # setDaemon=False to stop the thread after complete
    t.setDaemon(False)
    # starting the thread
    t.start()

    # return response/anything-else you want to return
    return "it worked"



def update_function(inputs):
    # updating the database process here

def maintainence_function(input1, input2):
    #do maintainence processing now..
</code></pre>
<p>Here we use the threading functionality of python. </p>
<p>First we call the update function(you can also use this function in the thread if needed and if the response doesn't depend on this function and  if you need to give the response immediately). </p>
<p>Then we have create a thread which will complete the maintainence_function function and stop  after finishing it. But the response will not be delayed until that function is finished. </p>
<p>ie: return "it worked" will be returned and then also the thread maintains the working of the function maintainence_function if ts a bit process.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is possible to cheat with the <code>try-except-finally</code> structure. Example:</p>
<pre><code>def function():
  try:
    #do some stuff here
    return x
  except Exception:
    #do something when an error occures
  finally:
    #do here whatever you wanna do after return
</code></pre>
<p>Note, that the <code>finally</code> statement will be executed even if an exception was caught.</p>
</div>
<span class="comment-copy">I'm not familiar with python's threading, but most in threading models, starting up a thread is about as simple as calling a function. The complexity comes from making sure the work that's done in the thread is synchronized appropriately with the stuff that's happening asynchronously to the thread. It seems to me that complexity would exist to the same degree with whatever you might want to occur in the <code>#do maintainence processing now..</code> post-return step. If no synchronization would be necessary there, then none should be necessary in a thread. But, the converse is also true.</span>
<span class="comment-copy">interesting, didn't think of yield..I thought it was used to return a value to the function calling it not as a response. Basically I'm returning a http response in the form of a dictionary.  I can't change how HTTPS accepts returns but I'll do some digging and see if I can replace my command with yield. Interesting idea, thanks.</span>
<span class="comment-copy">I don't think yield would help here. A function using yield generates a sequence of values as they are required by iteration over the result of the call. The caller would have to be modified to expect a sequence from the function, to treat the first item as a response, and to then request more values in order to allow the code after the first yield to run.</span>
<span class="comment-copy">@Ben But clearly the caller has to indicate when the maintenance stuff should be run, because if everytime's fine we could just run it before returning. Which in returns means we need two calls anyhow and that's just what the coroutine needs.</span>
<span class="comment-copy">@Voo Yeah, I don't think there's a way to do this without modifying the caller to do the scheduling, which isn't explicitly spelled out in the answer. Yield doesn't help you schedule code to run after a function "returns" when the caller is unaware of this fact. It can be used for building a multi-stage function call, but not in a way that's transparent to the caller.</span>
<span class="comment-copy">@Ben I agree. But the only thing I can think of otherwise is using an extra thread and just randomly waiting for some time, which can work but really isn't something I'd want to write.</span>
<span class="comment-copy">@JoelCornett , nice edit there. that's a good point that <code>@contextmanager</code> is just syntactic sugar for a more complex class.</span>
<span class="comment-copy">I think <code>q</code> should be <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code> not <code>[0, 1, 2, 3, 4]</code> in your example</span>
<span class="comment-copy">@AlexandrPriymak yeah, I changed it when running on my machine, I'll fix it.</span>
<span class="comment-copy">@JeffTratner <code>__enter__</code> and <code>__exit__</code> are useful when we use <code>with</code> keyword, so they may not useful for function like using .</span>
<span class="comment-copy">But the finally would still run <i>before</i> the caller receives the returned value. This doesn't help you allow the caller to receive a response and notify the user, but <i>then</i> run more code.</span>
<span class="comment-copy">Depending on the use case, that might be fine.  It could be a convenient flow control technique to wrap your function's contents in try, and have a variety of different return statements, all of which would drop the flow directly to the finally block to perform maintenance.</span>
<span class="comment-copy">@Ben This worked for me. I returned a class attribute in the <code>try</code> block then cleared the attribute in the <code>finally</code> block and the return value was correct.</span>
<span class="comment-copy">+1 Great idea, I'll do some testing but very very interesting way of thinking about this problem!</span>
<span class="comment-copy">Huh. I had no idea Python could do this. Thank you kindly!</span>
<span class="comment-copy">It doesn't work for me...post_processing_task() executed but the client couldn't get the response like try-finally...</span>
