<div class="post-text" itemprop="text">
<p>Generally, when you want to iterate over a portion of a list in Python, the easiest thing to do is just slice the list. </p>
<pre><code># Iterate over everything except the first item in a list
#
items = [1,2,3,4]
iterrange = (x for x in items[1:])
</code></pre>
<p>But the slice operator creates a new list, which is not even necessary to do in many cases.  Ideally, I'd like some kind of slicing function that creates generators, as opposed to new list objects.  Something similar to this could be accomplished by creating a generator expression that uses a <code>range</code> to return only certain portions of the list:</p>
<pre><code># Create a generator expression that returns everything except 
# the first item in the list
#
iterrange = (x for x, idx in zip(items, range(0, len(items))) if idx != 0)
</code></pre>
<p>But this is sort of cumbersome.  I'm wondering if there is a better, more elegant way to do this.  So, what's the easiest way to slice a list so that a generator expression is created instead of a new list object?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/library/itertools.html#itertools.islice">itertools.islice</a>:</p>
<pre><code>import itertools

l = range(20)

for i in itertools.islice(l,10,15):
    print i

10
11
12
13
14
</code></pre>
<p>From the doc:</p>
<blockquote>
<p>Make an iterator that returns selected elements from the iterable</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Before I start, to be clear, the correct order of selecting between slicing approaches is usually:</p>
<ol>
<li><strong>Use regular slicing</strong> (the cost of copying all but the longest of inputs is usually not meaningful, and the code is much simpler). <strong>If the input might not be a sliceable sequence type, convert it to one, then slice, e.g. <code>allbutone = list(someiterable)[1:]</code>. This is simpler, and for most cases, typically faster, than any other approach.</strong></li>
<li><strong>If regular slicing isn't viable</strong> (the input isn't guaranteed to be a sequence and converting to a sequence before slicing might cause memory issues, or it's huge and the slice covers most of it, e.g. skipping the first 1000 and last 1000 elements of a 10M element <code>list</code>, so memory might be a concern), <strong><code>itertools.islice</code> is usually the correct solution</strong> as it's simple enough, and the performance cost is usually unimportant.</li>
<li><strong>If, and only if, <code>islice</code>'s performance is unacceptably slow (it adds some overhead to producing every item, though admittedly it's quite a small amount) <em>and</em> the amount of data to be skipped is small, while the data to be included is huge (e.g. the OP's scenario of skipping a single element and keeping the rest), keep reading</strong></li>
</ol>
<p>If you find yourself in case #3, you're in a scenario where <code>islice</code>'s ability to bypass initial elements (relatively) quickly isn't enough to make up for the incremental cost to produce the rest of the elements. In that case, you can improve performance by reversing your problem from <em>selecting</em> all elements <em>after</em> <code>n</code> to <em>discarding</em> all elements <em>before</em> <code>n</code>.</p>
<p>For this approach, you manually convert your input to an iterator, then explicitly pull out and discard <code>n</code> values, then iterate what's left in the iterator (but without the per-element overhead of <code>islice</code>). For example, for an input of <code>myinput = list(range(1, 10000))</code>, your options for selecting elements 1 through the end are:</p>
<pre><code># Approach 1, OP's approach, simple slice:
for x in myinput[1:]:

# Approach 2, Sebastian's approach, using itertools.islice:
for x in islice(myinput, 1, None):

# Approach 3 (my approach)
myiter = iter(myinput)  # Explicitly create iterator from input (looping does this already)
next(myiter, None) # Throw away one element, providing None default to avoid StopIteration error
for x in myiter:  # Iterate unwrapped iterator
</code></pre>
<p>If the number of elements to discard is larger, it's probably best to borrow <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">the <code>consume</code> recipe from the <code>itertools</code> docs</a>:</p>
<pre><code>def consume(iterator, n=None):
    "Advance the iterator n-steps ahead. If n is None, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)
</code></pre>
<p>which makes the approaches generalize for skipping <code>n</code> elements to:</p>
<pre><code># Approach 1, OP's approach, simple slice:
for x in myinput[n:]:

# Approach 2, Sebastian's approach, using itertools.islice:
for x in islice(myinput, n, None):

# Approach 3 (my approach)
myiter = iter(myinput)  # Explicitly create iterator from input (looping does this already)
consume(myiter, n)      # Throw away n elements
# Or inlined consume as next(islice(myiter, n, n), None)
for x in myiter:        # Iterate unwrapped iterator
</code></pre>
<p>Performance-wise, this wins by a meaningful amount for most large inputs (exception: <code>range</code> itself on Python 3 is already optimized for plain slicing; plain slicing can't be beat on actual <code>range</code> objects). <code>ipython3</code> microbenchmarks (on CPython 3.6, 64 bit Linux build) illustrate this (the definition of <code>slurp</code> in the setup is just a way to make the lowest overhead approach to running out an iterable so we minimize the impact of the stuff we're not interested in):</p>
<pre><code>&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10000))
... slurp(r[1:])
...
65.8 μs ± 109 ns per loop (mean ± std. dev. of 5 runs, 10000 loops each)

&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10000))
... slurp(islice(r, 1, None))
...
70.7 μs ± 104 ns per loop (mean ± std. dev. of 5 runs, 10000 loops each)

&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10000))
... ir = iter(r)
... next(islice(ir, 1, 1), None)  # Inlined consume for simplicity, but with islice wrapping to show generalized usage
... slurp(ir)
...
30.3 μs ± 64.1 ns per loop (mean ± std. dev. of 5 runs, 10000 loops each)
</code></pre>
<p>Obviously, the extra complexity of my solution isn't usually going to be worth it, but for moderate sized inputs (10K elements in this case), the performance benefit is clear; <code>islice</code> was the worst performer (by a small amount), plain slicing was slightly better (which reinforces my point about plain slicing almost always being the best solution when you have an actual sequence), and the "convert to iterator, discard initial, use rest" approach won by a huge amount, relatively speaking (well under half the time of either of the under solutions).</p>
<p>That benefit won't show up for tiny inputs, because the fixed overhead of loading/calling <code>iter</code>/<code>next</code>, and especially <code>islice</code>, will outweigh the savings:</p>
<pre><code>&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10))
... slurp(r[1:])
...
207 ns ± 1.86 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)

&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10))
... slurp(islice(r, 1, None))
...
307 ns ± 1.71 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)

&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10))
... ir = iter(r)
... next(islice(ir, 1, 1), None)  # Inlined consume for simplicity, but with islice wrapping to show generalized usage
... slurp(ir)
...
518 ns ± 4.5 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)

&gt;&gt;&gt; %%timeit -r5 slurp = deque(maxlen=0).extend; r = list(range(10))
... ir = iter(r)
... next(ir, None)  # To show fixed overhead of islice, use next without it
... slurp(ir)
...
341 ns ± 0.947 ns per loop (mean ± std. dev. of 5 runs, 1000000 loops each)
</code></pre>
<p>but as you can see, even for 10 elements the <code>islice</code>-free approach isn't <em>much</em> worse; by 100 elements, the <code>islice</code>-free approach is faster than all competitors, and by 200 elements, the generalized <code>next</code>+<code>islice</code> beats all competitors (obviously it doesn't beat <code>islice</code>-free given the 180 ns overhead of <code>islice</code>, but that's made up for by generalizing to skipping <code>n</code> elements as a single step, rather than needing to call <code>next</code> repeatedly for skipping more than one element). Plain <code>islice</code> rarely wins in the "skip a few, keep a lot" case due to the per element overhead the wrapper exacts (it didn't clearly beat eager slicing in the microbenchmarks until around 100K elements; it's memory efficient, but CPU inefficient), and it will do even worse (relative to eager slicing) in the "skip a lot, keep a few" case.</p>
</div>
<div class="post-text" itemprop="text">
<p>Try itertools.islice:</p>
<p><a href="http://docs.python.org/library/itertools.html#itertools.islice" rel="nofollow">http://docs.python.org/library/itertools.html#itertools.islice</a></p>
<pre><code>iterrange = itertools.islice(items, 1, None)
</code></pre>
</div>
<span class="comment-copy">I could be wrong, but I suspect if <a href="http://docs.python.org/library/itertools.html#itertools.islice" rel="nofollow noreferrer">itertools</a> couldn't find a more efficient way to do it (generally, as in islice), there may not be a way.</span>
<span class="comment-copy">Note that the <code>len(items)</code> is redundant; <code>items[1:]</code> is enough to slice a list.</span>
<span class="comment-copy">Generators come with their own overhead and unless you have a list with thousands of elements then creating a new list is meant to be as efficient if not more so.</span>
<span class="comment-copy">Please note, though, that islice's in-python implementation is not more efficient than the example in the question.</span>
<span class="comment-copy">@kojiro, not sure what you mean. <code>islice</code> objects are <a href="http://hg.python.org/cpython/file/45cd2d816f4d/Modules/itertoolsmodule.c#l1103" rel="nofollow noreferrer">implemented in c</a> in cpython.</span>
<span class="comment-copy">@kojiro This is not true. I performed a quick timeit test showing that using a generator expression is indeed faster that recreating lists. If your commenting the second statement though, I dont really get your point. <code>isclice</code> is exactly that what the OP was looking for. A quick and clean way to get a limited generator instead of a new list. The way shown in the question is far away from a good coding style as the OP pointed out already. I think it was only meant to be understood as an example of what the OP wanted to achieve.</span>
<span class="comment-copy">@kojiro: A third timeit tests shows: The method described in the question is even worser: list slice: 1.1535269123993572s ; islice: 0.87495659566315s ; range generator: 2.8627238423657673s; Times referencing to one million executions iterating from 10 to 15 (excluding) as shown in my post.</span>
<span class="comment-copy">@kojiro i simply measured the time required to iterate over 10,11,12,13,14 as shown above. The iterator was consequently replaced with the list slice ([10:15]); islice and the generator expression.</span>
<span class="comment-copy">Side-note: For the specific case of skipping one element, on Python 3,  <code>_, *allbutone = iterable</code> is an improvement on <code>allbutone = list(iterable)[1:]</code> when you can't be sure if <code>iterable</code> is a sequence (or if sequences other than <code>list</code> are possible, and the result must be a <code>list</code>). It doesn't scale to <code>n</code> skips though; even for constant <code>k</code> skips (e.g. 5 skips), it's kind of ugly: <code>_, _, _, _, _, *allbutfive = someiterable</code>. But I figured it was worth pointing out since it allows skipping at beginning <i>or</i> end <i>and</i> converts the rest to a <code>list</code> as a single step, which can be useful.</span>
<span class="comment-copy">You don't need <code>len(items)</code>, just provide <code>None</code></span>
<span class="comment-copy">You also don't need to create a generator - just <code>iterrange = itertools.islice(items, 1, None)</code> is enough</span>
<span class="comment-copy">@JonClements Good calls. I was trying to match the original, and apparently wasn't thinking as I did. Thanks.</span>
