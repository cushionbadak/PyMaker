<div class="post-text" itemprop="text">
<p>I have a time in UTC from which I want the number of seconds since epoch.</p>
<p>I am using strftime to convert it to the number of seconds. Taking 1st April 2012 as an example.</p>
<pre><code>&gt;&gt;&gt;datetime.datetime(2012,04,01,0,0).strftime('%s')
'1333234800'
</code></pre>
<p>1st of April 2012 UTC from epoch is 1333238400 but this above returns 1333234800 which is different by 1 hour. </p>
<p>So it looks like that strftime is taking my system time into account and applies a timezone shift somewhere. I thought datetime was purely naive?</p>
<p>How can I get around that? If possible avoiding to import other libraries unless standard. (I have portability concerns).</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to convert a python datetime to seconds since epoch you could do it explicitly:</p>
<pre><code>&gt;&gt;&gt; (datetime.datetime(2012,04,01,0,0) - datetime.datetime(1970,1,1)).total_seconds()
1333238400.0
</code></pre>
<p>In Python 3.3+ you can use <a href="https://docs.python.org/3/library/datetime.html?highlight=re#datetime.datetime.timestamp" rel="noreferrer"><code>timestamp()</code></a> instead:</p>
<pre><code>&gt;&gt;&gt; datetime.datetime(2012,4,1,0,0).timestamp()
1333234800.0
</code></pre>
<hr/>
<p><strong>Why you should not use <code>datetime.strftime('%s')</code></strong></p>
<p>Python doesn't actually support %s as an argument to strftime (if you check at <a href="http://docs.python.org/library/datetime.html#strftime-and-strptime-behavior" rel="noreferrer">http://docs.python.org/library/datetime.html#strftime-and-strptime-behavior</a> it's not in the list), the only reason it's working is because Python is passing the information to your system's strftime, which uses your local timezone.</p>
<pre><code>&gt;&gt;&gt; datetime.datetime(2012,04,01,0,0).strftime('%s')
'1333234800'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had serious issues with Timezones and such. The way Python handles all that happen to be pretty confusing (to me). Things seem to be working fine using the calendar module (see links <a href="https://stackoverflow.com/questions/2956886/python-calendar-timegm-vs-time-mktime">1</a>, <a href="http://docs.python.org/library/calendar.html" rel="noreferrer">2</a>, <a href="https://stackoverflow.com/questions/4046401/how-do-i-convert-a-datetime-to-a-utc-timestamp-in-python">3</a> and <a href="http://www.epochconverter.com/" rel="noreferrer">4</a>).</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; import calendar
&gt;&gt;&gt; aprilFirst=datetime.datetime(2012, 04, 01, 0, 0)
&gt;&gt;&gt; calendar.timegm(aprilFirst.timetuple())
1333238400
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import time
from datetime import datetime
now = datetime.now()

time.mktime(now.timetuple())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import time
from datetime import datetime
now = datetime.now()

# same as above except keeps microseconds
time.mktime(now.timetuple()) + now.microsecond * 1e-6
</code></pre>
<p>(Sorry, it wouldn't let me comment on existing answer)</p>
</div>
<div class="post-text" itemprop="text">
<p>This works in Python 2 and 3:</p>
<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; import calendar
&gt;&gt;&gt; calendar.timegm(time.gmtime())
1504917998
</code></pre>
<p>Just following the official docs...
<a href="https://docs.python.org/2/library/time.html#module-time" rel="nofollow noreferrer">https://docs.python.org/2/library/time.html#module-time</a></p>
</div>
<div class="post-text" itemprop="text">
<p>if you just need a timestamp in unix /epoch time, this one line works:</p>
<pre><code>created_timestamp = int((datetime.datetime.now() - datetime.datetime(1970,1,1)).total_seconds())
&gt;&gt;&gt; created_timestamp
1522942073L
</code></pre>
<p>and depends only on <code>datetime</code>
works in python2 and python3</p>
</div>
<div class="post-text" itemprop="text">
<p>For an explicit timezone-independent solution, use the pytz library.</p>
<pre><code>import datetime
import pytz

pytz.utc.localize(datetime.datetime(2012,4,1,0,0), is_dst=False).timestamp()
</code></pre>
<p>Output (float): 1333238400.0</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3.7</p>
<blockquote>
<p>Return a datetime corresponding to a date_string in one of the formats
  emitted by date.isoformat() and datetime.isoformat(). Specifically,
  this function supports strings in the format(s)
  YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]], where *
  can match any single character.</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat" rel="nofollow noreferrer">https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat</a></p>
</div>
<span class="comment-copy">related: <a href="http://stackoverflow.com/q/8777753/4279">Converting datetime.date to UTC timestamp in Python</a></span>
<span class="comment-copy">Am I the only one noting that you use octal literals in the numbers?</span>
<span class="comment-copy">related <a href="http://bugs.python.org/issue12750" rel="nofollow noreferrer">Python issue: datetime.strftime('%s') should respect tzinfo</a></span>
<span class="comment-copy">Newer Python 3.3+ has <code>datetime.datetime.timestamp(datetime.datetime.utcnow())</code></span>
<span class="comment-copy">I have been going crazy trying to figure out why i see strftime("%s") a lot, yet it's not in the docs.  Thank you for nothing this!</span>
<span class="comment-copy">don't use <code>.strftime("%s")</code>: it is not supported, it is not portable, it may silently produce a wrong result for an aware datetime object, it fails if input is in UTC (as in the question) but local timezone is not UTC</span>
<span class="comment-copy">@earthmeLon Your bracketing is wrong. Timedeltas (made by subtracting two datetimes) have total_seconds, but datetimes do not.</span>
<span class="comment-copy">This is not working for me: <code>AttributeError: 'datetime.timedelta' object has no attribute 'total_seconds'</code></span>
<span class="comment-copy">@Michael That function is new in Python 2.7, you must be using an older version. For versions before 2.7 you can do <code>td.seconds + td.days*24*3600</code>. This discards the microseconds part.</span>
<span class="comment-copy">+1 because it is the only answer that works for the input in the question.</span>
<span class="comment-copy">is this portable?</span>
<span class="comment-copy">It should be, yes</span>
<span class="comment-copy">This should be marked as the rightful answer, since this answers the concern in question. vnice kudos</span>
<span class="comment-copy">This 'works', but note the question stated:  "I have a time in UTC"  This method will always use the system's local timezone. There is no way to specify a timezone. If <code>aprilFirst</code> in this example were an 'aware' instance and used a timezone different from the system's timezone, the result would not be correct (the timezone gets lost in the <code>timetuple()</code> call).  To get the right answer for an 'aware' datetime you can use <code>awaredt.timestamp()</code> on recent Python 3. For Python 2 it's harder; one way is to use the <code>arrow</code> library. <code>arrow.get(awaredt).timestamp</code> will get it right.</span>
<span class="comment-copy">it is an incorrect way to write <code>time.time()</code> (<code>mktime()</code> may fail during DST transitions while <code>time.time()</code> continues to work). And it doesn't answer the question unless the local timezone is UTC (the input in the question is in UTC). Even if the input would represent a local time then <code>mktime()</code> may also fail for past/future dates if it doesn't use the tz database and if the local timezone may have different utc offsets over the years e.g., Europe/Moscow in 2010-2015 -- use UTC time (as in the question) or timezone-aware datetime objects instead.</span>
<span class="comment-copy">here're <a href="http://stackoverflow.com/a/26163706/4279">more issues with converting a local time (such as returned by <code>.now()</code>) to epoch timestamp (returned by <code>mktime()</code>)</a>. If you read it; you understand why UTC input (used in the question) is (much) more preferable than a naive datetime object representing local time</span>
<span class="comment-copy">That is because time.mktime does not take into consideration the  microsecond part, right?</span>
<span class="comment-copy">Correct.  The time tuple struct (based on C strut) doesn't have a space for microseconds, so we need to grab the info from the datetime object and add it at the end.</span>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/11743019/convert-python-datetime-to-epoch-with-strftime#comment45494488_17203956">it doesn't answer the question unless the local timezone is UTC</a></span>
<span class="comment-copy">On my machines, this works correctly even though my time zone is ET.</span>
<span class="comment-copy">1) This assumes you want to convert now, not a random datetime object.   2) You don't need calendar.        time.mktime(randomDateTime.timetuple()) + randomDateTime.microsecond * 1e-6</span>
<span class="comment-copy">@CharlesPlager time.mktime is incorrect; it interprets the argument in the local timezone, whereas the OP wants the time interpreted in UTC (as calendar.timegm does).</span>
<span class="comment-copy">Be aware that this was introduced in Python 3.7.</span>
