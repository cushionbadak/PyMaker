<div class="post-text" itemprop="text">
<p>Okay I'm having trouble not only with the problem itself but even with trying to explain my question. I have a directory tree consisting of about 7 iterations, so: <code>rootdir/a/b/c/d/e/f/destinationdir</code></p>
<p>The thing is some may have 5 subdirectory levels and some may have as many as ten, such as: </p>
<pre><code>rootdir/a/b/c/d/destinationdir
</code></pre>
<p>or:</p>
<p><code>rootdir/a/b/c/d/e/f/g/h/destinationdir</code></p>
<p>The only thing they have in common is that the destination directory is always named the same thing. The way I'm using the glob function is as follows:</p>
<p><code>for path in glob.glob('/rootdir/*/*/*/*/*/*/destinationdir'):<br/>
    --- os.system('cd {0}; do whatever'.format(path))</code></p>
<p>However, this only works for the directories with that precise number of intermediate subdirectories. Is there any way for me not to have to specify that number of <code>subdirectories(asterices)</code>; in other words having the function arrive at the destinationdir no matter what the number of intermediate subdirectories is, and allowing me to iterate through them. Thanks a lot!</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this could be done more easily with <code>os.walk</code>:</p>
<pre><code>def find_files(root,filename):
    for directory,subdirs,files in os.walk(root):
        if filename in files:
            yield os.join(root,directory,filename)
</code></pre>
<p>Of course, this doesn't allow you to have a glob expression in the filename portion, but you could check that stuff using regex or fnmatch.</p>
<p><strong>EDIT</strong></p>
<p>Or to find a directory:</p>
<pre><code>def find_files(root,d):
    for directory,subdirs,files in os.walk(root):
        if d in subdirs:
            yield os.join(root,directory,d)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a pattern for each level of indentation (increase <code>10</code> if needed):</p>
<pre><code>for i in xrange(10):
    pattern = '/rootdir/' + ('*/' * i) + 'destinationdir'
    for path in glob.glob(pattern):
        os.system('cd {0}; do whatever'.format(path))
</code></pre>
<p>This will iterate over:</p>
<pre><code>'/rootdir/destinationdir'
'/rootdir/*/destinationdir'
'/rootdir/*/*/destinationdir'
'/rootdir/*/*/*/destinationdir'
'/rootdir/*/*/*/*/destinationdir'
'/rootdir/*/*/*/*/*/destinationdir'
'/rootdir/*/*/*/*/*/*/destinationdir'
'/rootdir/*/*/*/*/*/*/*/destinationdir'
'/rootdir/*/*/*/*/*/*/*/*/destinationdir'
'/rootdir/*/*/*/*/*/*/*/*/*/destinationdir'
</code></pre>
<p>If you have to iterate over directories with arbitrary depth then I suggest dividing the algorithm in two steps: one phase where you investigate where all 'destinationdir' directories are located and a second phase where you perform your operations.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking for files, you can use the <a href="http://pypi.python.org/pypi/formic" rel="nofollow">Formic package</a> (disclosure: I wrote it) - this implements Apache Ant's FileSet Globs with the '**' wildcard:</p>
<pre><code>import formic
fileset = formic.FileSet(include="rootdir/**/destinationdir/*")

for file_name in fileset:
    # Do something with file_name
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This looks much easier to accomplish with a more versatile tool, like the <code>find</code> command (your <code>os.system</code> call indicates you're on a unix-like system, so this will work).</p>
<pre><code>os.system('find /rootdir -mindepth 5 -maxdepth 10 -type d -name destinationdir | while read d; do ( cd $d &amp;&amp; do whatever; ); done')
</code></pre>
<p>..Note that if you are going to put any user-supplied string into that command, this becomes drastically unsafe, and you should use subprocess.Popen instead, executing the shell and splitting the arguments yourself. It's safe as shown, though.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 3 <a href="https://docs.python.org/3/library/glob.html" rel="nofollow noreferrer">glob.glob</a> now accepts double wildcards to designate any number of intermediate directories </p>
</div>
<span class="comment-copy">I like this answer best because you actually use glob and it is simple.</span>
<span class="comment-copy">but be aware that the '**' glob pattern does not follow symlinks as it could end up in endless loops.</span>
