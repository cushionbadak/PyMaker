<div class="post-text" itemprop="text">
<pre><code>&gt;&gt;&gt; a=[1,2,3]
&gt;&gt;&gt; a.remove(2)
&gt;&gt;&gt; a
[1, 3]
&gt;&gt;&gt; a=[1,2,3]
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; a
[1, 3]
&gt;&gt;&gt; a= [1,2,3]
&gt;&gt;&gt; a.pop(1)
2
&gt;&gt;&gt; a
[1, 3]
&gt;&gt;&gt; 
</code></pre>
<p>Is there any difference between the above three methods to remove an element from a list?</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes, <code>remove</code> removes the <em>first</em> matching <em>value</em>, not a specific index:</p>
<pre><code>&gt;&gt;&gt; a = [0, 2, 3, 2]
&gt;&gt;&gt; a.remove(2)
&gt;&gt;&gt; a
[0, 3, 2]
</code></pre>
<p><code>del</code> removes the item at a specific index:</p>
<pre><code>&gt;&gt;&gt; a = [3, 2, 2, 1]
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; a
[3, 2, 1]
</code></pre>
<p>and <code>pop</code> removes the item at a specific index and returns it.</p>
<pre><code>&gt;&gt;&gt; a = [4, 3, 5]
&gt;&gt;&gt; a.pop(1)
3
&gt;&gt;&gt; a
[4, 5]
</code></pre>
<p>Their error modes are different too:</p>
<pre><code>&gt;&gt;&gt; a = [4, 5, 6]
&gt;&gt;&gt; a.remove(7)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: list.remove(x): x not in list
&gt;&gt;&gt; del a[7]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list assignment index out of range
&gt;&gt;&gt; a.pop(7)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: pop index out of range
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>del</code> to remove an element by index, <code>pop()</code> to remove it by index if you need the returned value, and <code>remove()</code> to delete an element by value.  The latter requires searching the list, and raises <code>ValueError</code> if no such value occurs in the list.</p>
<p>When deleting index <code>i</code> from a list of <code>n</code> elements, the computational complexities of these methods are</p>
<pre><code>del     O(n - i)
pop     O(n - i)
remove  O(n)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since no-one else has mentioned it, note that <code>del</code> (unlike <code>pop</code>) allows the removal of a range of indexes because of list slicing:</p>
<pre><code>&gt;&gt;&gt; lst = [3, 2, 2, 1]
&gt;&gt;&gt; del lst[1:]
&gt;&gt;&gt; lst
[3]
</code></pre>
<p>This also allows avoidance of an <code>IndexError</code> if the index is not in the list:</p>
<pre><code>&gt;&gt;&gt; lst = [3, 2, 2, 1]
&gt;&gt;&gt; del lst[10:]
&gt;&gt;&gt; lst
[3, 2, 2, 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Already answered quite well by others. This one from my end :)</p>
<p><a href="https://i.stack.imgur.com/9Yzgv.png" rel="noreferrer"><img alt="remove vs pop vs del" src="https://i.stack.imgur.com/9Yzgv.png"/></a></p>
<p>Evidently, <code>pop</code> is the only one which returns the value, and <code>remove</code> is the only one which searches the object, while <code>del</code> limits itself to a simple deletion. </p>
</div>
<div class="post-text" itemprop="text">
<p>pop    - Takes Index and returns Value</p>
<p>remove - Takes value, removes first occurrence, and returns nothing </p>
<p>delete - Takes index, removes value at that index, and returns nothing</p>
</div>
<div class="post-text" itemprop="text">
<p>Many best explanations are here but I will try my best to simplify more.</p>
<p>Among all these methods, reverse &amp; pop are <strong>postfix</strong> while delete is <strong>prefix</strong>.</p>
<p><strong>remove():</strong> It used to remove first occurrence of element</p>
<p><code>remove(i)</code> =&gt; first occurrence of i value </p>
<pre><code>&gt;&gt;&gt; a = [0, 2, 3, 2, 1, 4, 6, 5, 7]
&gt;&gt;&gt; a.remove(2)   # where i = 2
&gt;&gt;&gt; a
[0, 3, 2, 1, 4, 6, 5, 7]
</code></pre>
<p><strong>pop():</strong> It used to remove element if:</p>
<p><em>unspecified</em> </p>
<p><code>pop()</code> =&gt; from end of list</p>
<pre><code>&gt;&gt;&gt;a.pop()
&gt;&gt;&gt;a
[0, 3, 2, 1, 4, 6, 5]
</code></pre>
<p><em>specified</em> </p>
<p><code>pop(index)</code> =&gt; of index</p>
<pre><code>&gt;&gt;&gt;a.pop(2)
&gt;&gt;&gt;a
[0, 3, 1, 4, 6, 5]
</code></pre>
<h3>WARNING: Dangerous Method Ahead</h3>
<p><strong>delete()</strong>: Its a prefix method. </p>
<p>Keep an eye on two different syntax for same method: [] and (). It possesses power to:</p>
<p>1.Delete index  </p>
<p><code>del a[index]</code> =&gt; used to delete index and its associated value just like pop.</p>
<pre><code>&gt;&gt;&gt;del a[1]
&gt;&gt;&gt;a
[0, 1, 4, 6, 5]
</code></pre>
<p>2.Delete values in range [index 1:index N] </p>
<p><code>del a[0:3]</code> =&gt; multiple values in range</p>
<pre><code>&gt;&gt;&gt;del a[0:3]
&gt;&gt;&gt;a
[6, 5]
</code></pre>
<p>3.Last but not list, to delete whole list in one shot </p>
<p><code>del (a)</code> =&gt; as said above.</p>
<pre><code>&gt;&gt;&gt;del (a)
&gt;&gt;&gt;a
</code></pre>
<p>Hope this clarifies the confusion if any.</p>
</div>
<div class="post-text" itemprop="text">
<p>Any operation/function on different data structures is defined for particular actions. Here in your case i.e. removing an element, delete, Pop and remove. (If you consider sets, Add another operation - discard)
Other confusing case is while adding. Insert/Append. 
For Demonstration, Let us Implement deque. deque is a hybrid linear data structure, where you can add elements / remove elements from both ends.(Rear and front Ends) </p>
<pre><code>class Deque(object):

  def __init__(self):

    self.items=[]

  def addFront(self,item):

    return self.items.insert(0,item)
  def addRear(self,item):

    return self.items.append(item)
  def deleteFront(self):

    return self.items.pop(0)
  def deleteRear(self):
    return self.items.pop()
  def returnAll(self):

    return self.items[:]
</code></pre>
<p>In here, see the operations:</p>
<pre><code>def deleteFront(self):

    return self.items.pop(0)
def deleteRear(self):
    return self.items.pop()
</code></pre>
<p>Operations have to return something. So, pop -  With and without an index. 
If I don't want to return the value:
del self.items[0]</p>
<p>Delete by value not Index: </p>
<ul>
<li><p>remove : </p>
<pre><code>list_ez=[1,2,3,4,5,6,7,8]
for i in list_ez:
    if i%2==0:
        list_ez.remove(i)
print list_ez
</code></pre></li>
</ul>
<h1>Returns [1,3,5,7]</h1>
<p>let us consider the case of sets.</p>
<pre><code>set_ez=set_ez=set(range(10))

set_ez.remove(11)

# Gives Key Value Error. 
##KeyError: 11

set_ez.discard(11)

# Does Not return any errors.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While pop and delete both take indices to remove an element as stated in above comments. A key difference is the time complexity for them. The time complexity for pop() with no index is O(1) but is not the same case for deletion of last element.</p>
<p>If your use case is always to delete the last element, it's always preferable to use pop() over delete(). For more explanation on time complexities, you can refer to <a href="https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt" rel="nofollow">https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.deque.remove" rel="nofollow noreferrer">remove</a> operation on a list is given a value to remove. It searches the list to find an item with that value and deletes the first matching item it finds. It is an error if there is no matching item, raises a <a href="https://docs.python.org/3/library/exceptions.html#ValueError" rel="nofollow noreferrer">ValueError</a>.</p>
<pre><code>&gt;&gt;&gt; x = [1, 0, 0, 0, 3, 4, 5]
&gt;&gt;&gt; x.remove(4)
&gt;&gt;&gt; x
[1, 0, 0, 0, 3, 5]
&gt;&gt;&gt; del x[7]
Traceback (most recent call last):
  File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    del x[7]
IndexError: list assignment index out of range
</code></pre>
<p>The <a href="https://docs.python.org/3/tutorial/datastructures.html#the-del-statement" rel="nofollow noreferrer">del</a> statement can be used to delete an entire list. If you have a specific list item as your argument to del (e.g. listname[7] to specifically reference the 8th item in the list), it'll just delete that item. It is even possible to delete a "slice" from a list. It is an error if there index out of range, raises a <a href="https://docs.python.org/3/library/exceptions.html#IndexError" rel="nofollow noreferrer">IndexError</a>.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; del x[3]
&gt;&gt;&gt; x
[1, 2, 3]
&gt;&gt;&gt; del x[4]
Traceback (most recent call last):
  File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    del x[4]
IndexError: list assignment index out of range
</code></pre>
<p>The usual use of <a href="https://docs.python.org/3/library/collections.html#collections.deque.pop" rel="nofollow noreferrer">pop</a> is to delete the last item from a list as you use the list as a stack. Unlike del, pop returns the value that it popped off the list. You can optionally give an index value to pop and pop from other than the end of the list (e.g listname.pop(0) will delete the first item from the list and return that first item as its result). You can use this to make the list behave like a queue, but there are library routines available that can provide queue operations with better performance than pop(0) does. It is an error if there index out of range, raises a <a href="https://docs.python.org/3/library/exceptions.html#IndexError" rel="nofollow noreferrer">IndexError</a>.</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3] 
&gt;&gt;&gt; x.pop(2) 
3 
&gt;&gt;&gt; x 
[1, 2]
&gt;&gt;&gt; x.pop(4)
Traceback (most recent call last):
  File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    x.pop(4)
IndexError: pop index out of range
</code></pre>
<p>See <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">collections.deque</a> for more details.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can also use remove to remove a value by index as well.  </p>
<pre><code>n = [1, 3, 5]

n.remove(n[1])
</code></pre>
<p>n would then refer to [1, 5]</p>
</div>
<span class="comment-copy">Related post on similar lines for set data structure - <a href="https://stackoverflow.com/q/27850073/465053">Runtime difference between set.discard and set.remove methods in Python?</a></span>
<span class="comment-copy">I thought <code>del</code> was a python 2 syntax holdover like <code>print</code>, but it still works in python 3.</span>
<span class="comment-copy">@jxramos: <code>del</code> is not a syntax holdover, no. The syntax is unchanged, just like <code>return</code> or <code>if</code> or <code>while</code>.</span>
<span class="comment-copy">It is worth mentioning that users should be careful when iterating over a list and using these functions on it at the same time as they are iterating.</span>
<span class="comment-copy">Does pop require searching the list</span>
<span class="comment-copy">@kratos: No, see my edit.</span>
<span class="comment-copy">+1 for complexity breakdown. Illustrates how delete and pop are constant when the element is at the end of the list.</span>
<span class="comment-copy">Remember guys... anything index based is one shot O(n-1)... if you have to do a lookup (by value), it will traverse the collection until the element is found.</span>
<span class="comment-copy">@PepitoFernandez Look-ups by index in a list are O(1) in Python.  (A list in Python is similar to a vector in C++.)</span>
<span class="comment-copy">Thnx! One note: in python, due to the way the lists are implemented(there practically arrays...!), "Advance till that node position" is O(1)</span>
<span class="comment-copy">Great visual representation!</span>
<span class="comment-copy">This is wrong in multiple ways. There is no such method as <code>delete</code>. The differences are that <code>pop</code> returns the value, and that <code>del</code> works on slices. In cases where <code>pop</code> works, <code>del</code> has exactly the same computational complexity (and is slightly faster by a constant term).</span>
<span class="comment-copy">Try <code>n = [5, 3, 5]</code>, then <code>n.remove(n[2])</code>.</span>
<span class="comment-copy">@abarnert your use case works in sync with the below case n = [5,3,5] , then n.remove(5). Both of these remove the first encountered element from the list.</span>
<span class="comment-copy">@AkhilGhatiki <code>n.remove(n[2])</code> removes <code>n[0]</code>, not <code>n[2]</code>. So it’s not just linear time for no reason (maybe not a big deal when N=3), it’s also wrong (a big deal no matter what N is)</span>
<span class="comment-copy">@abarnert you are right !!!  I overlooked it. Thanks !!</span>
