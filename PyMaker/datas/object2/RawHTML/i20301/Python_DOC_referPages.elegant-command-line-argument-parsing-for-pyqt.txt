<div class="post-text" itemprop="text">
<p>I'm writing a new PyQt app. I'm trying to do everything related to the program and ui using as much of the PyQt APIs as possible as a means to improve my knowledge of PyQt and Qt in general.</p>
<p>The question I have is, is there an API within PyQt/Qt to handle command line argument parsing elegantly?</p>
<p>My research so far has turned up:</p>
<ul>
<li>an example of how to make it <a href="http://lateral.netmanagers.com.ar/weblog/posts/BB997.html">play nice with python's opt_parser</a> module, except it doesn't handle QApplication's built in arg parsing.</li>
<li><a href="http://techbase.kde.org/Development/Languages/Python/Using_PyKDE_4#KCmdLineArgs.2C_KAboutData">PyKDE's KCmdLineArgs</a> (which introduces an unwanted KDE dependency)</li>
<li>it looks like KCmdLineArgs is being ported upstream for Qt5.1 as QCommandLineParser, which is cool, but I'd like to be able to use it now, not 18 months from now.</li>
</ul>
<p>So how do PyQt applications normally handle this? or is opt_parser/argparse the way to go? </p>
<p>This is far from a nice solution...</p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys, argparse
from PyQt4 import QtGui

def main(argv):

  app = QtGui.QApplication(argv) # QApplication eats argv in constructor

  # We can get a QStringList out of QApplication of those arguments it 
  # didn't decide were reserved by Qt.
  argv2 = app.arguments()   

  # now we need to turn them back into something that optparse/argparse 
  # can understand, since a QStringList is not what it wants
  argv3 = []
  for i in argv2:
    argv3.append(str(i))

  # now we can pass this to optparse/argparse
  process_args(argv3)

  # dummy app
  mw = QtGui.QMainWindow()
  mw.show()
  sys.exit(app.exec_())

def process_args(argv):
  parser = argparse.ArgumentParser(description='PyQt4 argstest', 
                                   add_help=False)

  # we now have to add all of the options described at 
  # http://qt-project.org/doc/qt-4.8/qapplication.html#QApplication
  # but have them do nothing - in order to have them show up in the help list

  # add this to the list if Qt is a debug build (How to detect this?)
  parser.add_argument("-nograb", action=ignore,
                      help="don't grab keyboard/mouse for debugging")

  # add these to the list if Qt is a debug build for X11
  parser.add_argument("-dograb", action=ignore,
                      help="grab keyboard/mouse for debugging")
  parser.add_argument("-sync", action=ignore,
                      help="run in synchronous mode for debugging")

  # add all the standard args that Qt will grab on all platforms
  parser.add_argument("-reverse", action=ignore,
                      help="run program in Right-to-Left mode")
  # an example -- there are 10 such items in the docs for QApplication

  # then we need to figure out if we're running on X11 and add these
  parser.add_argument("-name", action=ignore,
                      help="sets the application name")
  # an example -- there are 13 such items in the docs

  # reimplement help (which we disabled above) so that -help works rather 
  # than --help; done to be consistent with the style of args Qt wants
  parser.add_argument("-h", "-help", action='help',
                      help="show this help message and exit")

  parser.parse_args(argv[1:])

class ignore(argparse.Action):
  # we create an action that does nothing, so the Qt args do nothing
  def __call__(self, parser, namespace, values, option_string=None):
    pass

if __name__ == "__main__":
  main(sys.argv)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="http://docs.python.org/library/argparse.html#module-argparse" rel="nofollow">argparse</a> if you're using <code>Python 2.7</code> (<a href="http://docs.python.org/library/optparse.html" rel="nofollow">optparse</a> if &lt; <code>2.7</code>), the package doesn't have to be specific to PyQt for you to handle commandline options.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best solution here is using the <code>argparse</code> module's <code>parse_known_args()</code> method (<a href="http://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_known_args" rel="nofollow noreferrer">docs</a>) to process the non-Qt command line options first. It's no more work in configuring the <code>ArgumentParser</code>â€”it just changes which method you call, and gives you a tuple instead of a single object in the return. That gives you the best of both worlds. </p>
<p>A simplified example that catches only a couple of the Qt 4.8 arguments and a few others, but gives the general idea.</p>
<pre><code># my_script.py

import argparse
from PyQt4 import QtGui  # this will work with PySide.QtGui, too

def process_cl_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--swallow', action='store')  # optional flag
    parser.add_argument('holy_hand_grenade', action='store')  # positional argument

    parsed_args, unparsed_args = parser.parse_known_args()
    return parsed_args, unparsed_args

if __name__ == '__main__':
    parsed_args, unparsed_args = process_cl_args()
    # QApplication expects the first argument to be the program name.
    qt_args = sys.argv[:1] + unparsed_args
    app = QtGui.QApplication(qt_args)
    # ... the rest of your handling: `sys.exit(app.exec_())`, etc.
</code></pre>
<p>Assume you were to run this like so:</p>
<pre class="lang-sh prettyprint-override"><code>$ python my_script.py -dograb --swallow=unladen 3 -style cde
</code></pre>
<p>Then <code>parsed_args</code> would have the usual <code>Namespace</code> with <code>holy_hand_grenade</code> set to <code>3</code> and <code>--swallow</code> set to <code>'unladen'</code>, while <code>unparsed_args</code> would have a simple list: <code>['-dograb', '-style,' 'cde']</code>. This in turn can be passed normally to the <code>QApplication</code> with the inclusion of the program name from <code>sys.argv[0]</code> (thanks to <a href="https://stackoverflow.com/users/104453/marcin">marcin</a> for <a href="https://stackoverflow.com/questions/11713006/elegant-command-line-argument-parsing-for-pyqt/21166631?noredirect=1#comment50925070_21166631">pointing this out</a>). We use <code>sys.argv[:1]</code> to get an array for concatenation with <code>unparsed_args</code>; you could just as well do <code>[sys.argv[0]]</code></p>
<p>Among other things, this lets you set up your application to specify whether to launch the Qt UI, to run as a command line, to run unit tests, and so forth instead if you so desired. Handling the non-Qt (or anything else) arguments first is better because it does not leave <code>argparse</code> dependent on the setup you're using, but the other way around.</p>
</div>
<div class="post-text" itemprop="text">
<p>You should really try <a href="http://docopt.org/" rel="nofollow">docopt</a>. It doesn't need any argument definitions. You have "Usage: " string and unparsed arguments as input, pass them into docopt() function, and you have parsed arguments as output.</p>
</div>
<span class="comment-copy">The whole point of my post at lateral.netmanagers.com.ar that you mentioned is that it does handle QApplication's builtin command line parsing. You define your own arguments using opt_parse/argparse/whatever, and as long as you don't define the same ones QApplication uses, everything just works.</span>
<span class="comment-copy">+1 as there is no reason to need pyqt supplied facilities when python stdlib has a pefectly full featured module.</span>
<span class="comment-copy">Okay, I read up on argparse and it seems nice, however it doesn't solve the issues of playing nice with QApplication's built in arg parsing. Eg: if you run <code>myPyQyApp.py -style cde</code> from the command line, QApplication intercepts that argument and makes everything look like 1996, but argparse has no idea this is happening. Which is why I'm searching for a PyQt solution. If none exists, then so be it, but the stdlib solution is not optimal.</span>
<span class="comment-copy">If you don't want Qt to parse the command line, just create the application like this:  <code>app = QtGui.QApplication([])</code></span>
<span class="comment-copy">I don't mind the Qt options. In particular I find very useful for testing: -style (for catching layout and drawing glitches - changing styles sometimes makes these obvious) and -reverse (for i18n).</span>
<span class="comment-copy">Okay, after sufficiently wasting many hours trying to find something better, I will use the kludge I posted in the original question and accept your answer that argparse is the way to go. Doesn't mean I'm overly excited by it, and will mark the code to be replaced when Qt 5.1 is released. Still, I appreciate the help.</span>
<span class="comment-copy">What if I want to let the qt app have access to parsed args?</span>
<span class="comment-copy">@qed, in that case, you could just pass <code>sys.argv</code> directly instead of <code>unparsed_args</code>.</span>
<span class="comment-copy">But can I use argparse inside QApplication?</span>
<span class="comment-copy">Ok, I got your point. parsed_args is accessible inside the app. Thanks.</span>
<span class="comment-copy">No problem! And yes, you can use <code>parsed_args</code> as you like throughout the app as well, of course.</span>
