<div class="post-text" itemprop="text">
<p>I know about <a href="http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences" rel="noreferrer">tuple unpacking</a> but what is this assignment called where you have multiple equals signs on a single line? a la <code>a = b = True</code></p>
<p>It always trips me up a bit especially when the RHS is mutable, but I'm having real trouble finding the right keywords to search for in the docs.</p>
</div>
<div class="post-text" itemprop="text">
<p>It's a chain of assignments and the term used to describe it is... </p>
<p><sup>- Could I get a drumroll please?</sup></p>
<h3><em>Chained Assignment</em>.</h3>
<hr/>
<p>I just gave it a quite google run and found that there isn't that much to read on the topic, probably since most people find it very straight-forward to use (and only the true geeks would like to know more about the topic).</p>
<hr/>
<p>In the previous expression the order of evaluation can be viewed as starting at the right-most <code>=</code> and then working towards the left, which would be equivalent of writing:</p>
<pre><code>b = True
a = b
</code></pre>
<hr/>
<p>The above order is what most language describe an <em>assignment-chain</em>, but python does it differently. In python the expression is evaluated as this below equivalent, though it won't result in any other result than what is previously described.</p>
<pre><code>temporary_expr_result = True

a = temporary_expr_result
b = temporary_expr_result
</code></pre>
<hr/>
<p>Further reading available here on stackoverflow:</p>
<ul>
<li><strong><a href="https://stackoverflow.com/questions/7601823/how-do-chained-assignments-work">How do chained assignments work?</a></strong> <a class="post-tag" href="/questions/tagged/python" rel="tag" title="show questions tagged 'python'">python</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>OK, "chained assignment" was the search term I was after, but after a bit more digging I think it's not strictly correct. but it is easier to search for than "a special case of the assignment statement".</p>
<p><a href="http://en.wikipedia.org/wiki/Assignment_%28computer_science%29" rel="nofollow noreferrer">The Wikipedia article</a> <a href="https://stackoverflow.com/users/577088/senderle">senderle</a> linked to says:</p>
<blockquote>
<p>In Python, assignment statements are not expressions and thus do not
  return a value. Instead, chained assignments are a series of
  statements with multiple targets for a single expression. The
  assignments are executed left-to-right so that <code>i = arr[i] = f()</code>
  evaluates the expression <code>f()</code>, then assigns the result to the leftmost
  target, <code>i</code>, and then assigns the same result to the next target,
  <code>arr[i]</code>, using the new value of <code>i</code>.</p>
</blockquote>
<p>Another <a href="http://pythonconquerstheuniverse.wordpress.com/2011/08/29/lambda_tutorial/#footnote2" rel="nofollow noreferrer">blog post</a> says:</p>
<blockquote>
<p>In Python, assignment statements do not return a value. Chained
  assignment (or more precisely, code that looks like chained assignment
  statements) is recognized and supported as a special case of the
  assignment statement.</p>
</blockquote>
<p>This seems the most correct to me, on a closer reading of <a href="http://docs.python.org/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">the docs</a> - in particular  <code>(target_list "=")+</code> - which also say</p>
<blockquote>
<p>An assignment statement evaluates the expression list ... and assigns
  the single resulting object to each of the target lists, from left to
  right.</p>
</blockquote>
<p>So it's not really "evaluated from right-most to left" - the RHS is evaluated and then assigned from left-most target to right - not that I can think of any real-world (or even contrived) examples where it would make a difference.</p>
</div>
<div class="post-text" itemprop="text">
<p>@refp's answer is further supported with this output using the <code>dis</code> (disassembly) module:</p>
<pre><code>&gt;&gt;&gt; def a(x):
...   g = h = x
...
&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(a)
  2           0 LOAD_FAST                0 (x)
              3 DUP_TOP
              4 STORE_FAST               1 (g)
              7 STORE_FAST               2 (h)
             10 LOAD_CONST               0 (None)
             13 RETURN_VALUE
</code></pre>
<p>The RHS is retrieved and duplicated, then stored into the destination variables left-to-right (try this yourself with <code>e = f = g = h = x</code>). </p>
<p>Some other posters have been confused if the RHS is a function call, like <code>a = b = fn()</code> - the RHS is only evaluated once, and then the result assigned to each successive variable. This may cause unwanted sharing if the returned value is a mutable, like a list or dict.</p>
<p>For those using <code>threading</code>, it is useful to note that there is no "atomicity" implied by the chained assignment form over multiple explicit assignment statements - a thread switch could occur between the assignments to g and h, and another thread looking at the two of them could see different values in the two variables.</p>
<p>From the <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow">documentation, 7.2. Assignment statements</a>, <code>g</code> and <code>h</code> being two <em>target lists</em>, <code>x</code> being the <em>expression list</em>:</p>
<blockquote>
<pre><code>assignment_stmt ::=  (target_list "=")+ (expression_list | yield_expression)
</code></pre>
<p>An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns <em>the single resulting object</em> to each of the target lists, <em>from left to right</em>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>got bitten by python's Chained Assignment today, due to my ignorance. in code</p>
<pre><code>if l1.val &lt;= l2.val:
    tail = tail.next = l1 # this line 
    l1 = l1.next
</code></pre>
<p>what I expected was</p>
<pre><code>tail.next = l1
tail = tail.next
# or equivalently 
# tail = l1
</code></pre>
<p>whereas I got below, which produce a self loop in the list, leave me in a endless loop, whoops...</p>
<pre><code>tail = l1
tail.next = l1 # now l1.next is changed to l1 itself
</code></pre>
<p>since for a = b = c,
one way (python, for example) equivalent to</p>
<pre><code>tmp = evaluate(c)
evaluate(a) = tmp
evaluate(b) = tmp
</code></pre>
<p>and have equal right operand for two assignment.</p>
<p>the other (C++, for example) equivalent to </p>
<pre><code>evaluate(b) = evaluate(c)
evaluate(a) = evaluate(b)
</code></pre>
<p>since in this case <code>a = b = c</code> is basically </p>
<pre><code>b = c
a = b
</code></pre>
<p>and two right hand operand could be different. </p>
<p>That why similar code works well in C++.</p>
</div>
<span class="comment-copy">I would call them "<a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Chained_assignment" rel="nofollow noreferrer">chained</a> <a href="http://stackoverflow.com/questions/7601823/how-do-chained-assignments-work">assignments</a>."</span>
<span class="comment-copy">It's calling this 'chained assignment' that is the real culprit. It'd be chained assignment if <code>a = b = c</code> meant that <code>b = c</code> is executed before <code>a = b</code>, but as you show that is not the case. Assignment takes place <i>sequentially</i> instead.</span>
<span class="comment-copy">This clarifies that in situations where like <code>x = dictionary['x'] = value</code> the dictionary does not use set then get (like would be done if it expanded to <code>dictionary['x'] = value; x = dictionary['x']</code>) but instead only sets the dictionary value.</span>
<span class="comment-copy">my description is from the developers point of view, as you state yourself: there is no <i>real-world</i> scenario where the wording would result in different results.  Or well, now I can actually think of one.. hold on, will update my answer with a little snippet to explain what I mean.</span>
<span class="comment-copy">nevermind, it won't make sense (and can't be done without a massive python hack, which is beyond the scope of the question), though I'll update my answer with some information from your post.</span>
<span class="comment-copy">please remember that this isn't like a normal forum where you can reply to previous posts with a new answer, if you have comments regarding contents in one post please use the "comment"-feature, quoting another answer in your post might cause trouble if one post is later deleted/altered.</span>
<span class="comment-copy">@refp I know how to use Stack Overflow. I wasn't replying to your answer, it prompted me to do some more digging and find my own answer. Last time I checked that was the right way to do things - <a href="http://blog.stackoverflow.com/2011/07/its-ok-to-ask-and-answer-your-own-questions/">blog.stackoverflow.com/2011/07/â€¦</a></span>
<span class="comment-copy">Contrived example to show order can matter: <code>x = [0, 1, 2, 3]; x[0:2] = x[1:3] = [4];</code> results in <code>[4, 4]</code>, if you reverse them then it results in <code>[4, 3]</code>.</span>
<span class="comment-copy">is there any documentation for this left-to-right evaluation available?</span>
<span class="comment-copy">@AshwiniChaudhary Yes, I've added the relevant excerpt from the documentation.</span>
<span class="comment-copy">Same! I think relying on this ordering is not pythonic however (I was interested in being "tricky" rather than sure it would work), any reader is not going to be 100% which way this goes. Better to be explicit in a case like this.</span>
