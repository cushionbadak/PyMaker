<div class="post-text" itemprop="text">
<p>If there is only one writer appending bytes to a <code>bytearray</code>, and multiple readers reading from it, is there any possibility that one or more readers read data that is neither before not after an extend?</p>
<p>For example, if the old data in the <code>bytearray</code> is <code>0123</code>, then the writer extends with <code>4567</code>, the new data would be <code>01234567</code>. Is it possible for any reader to (because of race conditions) read data such as <code>012345</code> or <code>0123abcd</code> during the extend?</p>
<p>Edit. The writer will call <code>.extend(data)</code> or use <code>+= data</code> to add data to the <code>bytearray</code>. The <code>data</code> is a <code>bytes</code> or another <code>bytearray</code> object.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you can guarantee just a single writer, then it depends on the <em>type of iterable</em> you are passing to the <code>bytearray.extend()</code> method or <code>+=</code> statement if this will be atomic.</p>
<p>Python threads are switched 'between bytecodes', and calling <code>bytearray.extend()</code> or applying the <code>+=</code> statement  to a <code>bytearray</code> object is a single bytecode, <em>provided iteration doesn't require bytecode execution</em>. If the object you pass in is an iterable implemented in Python, then all bets are off, because that requires multiple bytecode interpretation steps to execute.</p>
<p>E.g.:</p>
<pre><code>to_extend = (int(v) for v in '0123456789')
shared_bytearray_reference += to_extend  # not atomic, readers can see between 0 and 10 bytes appended
</code></pre>
<p>will not be atomic, because the generator expression loop is implemented in Python. </p>
<p>But extending from a <code>list</code> object <em>would</em> be atomic, because iteration over built-in type such as lists is implemented in native code:</p>
<pre><code>to_extend = [int(v) for v in '0123456789']
shared_bytearray_reference += to_extend  # atomic, readers will see 10 bytes appended
</code></pre>
<p>Similarly, if you are using the <code>map()</code> iterator with a Python function:</p>
<pre><code>to_extend = map(lambda v: int(v), '0123456789')`
shared_bytearray_reference += to_extend  # not atomic, readers can see between 0 and 10 bytes appended
</code></pre>
<p>This is not atomic because each iteration step calls into a Python function, and bytecode is executed each time.</p>
<p>But pass in a native function, like <code>int</code>:</p>
<pre><code>to_extend = map(int, '0123456789')  # int is a built-in native function
shared_bytearray_reference += to_extend  # atomic, readers will see 10 bytes appended
</code></pre>
<p>then everything can be executed in a single bytecode interpretation step.</p>
<p>Some native code will unlock the Global Interpreter Lock, allowing other Python threads to execute while the native code runs independently, but that almost never involves code that operates on Python types.</p>
<p>All in all, when in doubt, it is better to use a lock and not worry about wether or not the object you are iterating over is native. </p>
</div>
<span class="comment-copy">Please do show <i>how</i> you are appending those bytes. It is not the appending that is the issue, it is what code you use to do it.</span>
<span class="comment-copy">@MartijnPieters Edited. It's really one of the simplest use case, using <code>.extend()</code> or <code>+=</code>.</span>
<span class="comment-copy">Right, then my answer below applies. If <code>data</code> is a built-in sequence type  or <code>map()</code> that applies a built-in function, it is atomic, otherwise, it is not.</span>
<span class="comment-copy">@MartijnPieters My case only involves <code>bytes</code> and <code>bytearray</code>. From your answer, I guess I can keep it like that for now. But I was wondering how long we can rely on the fact that iteration over a <code>bytes</code> or <code>bytearray</code> is native? Is that in spec anywhere? Would you recommend a lock or another thread-safe container for this use case?</span>
<span class="comment-copy">There is no spec, I recommend locking when in doubt.</span>
