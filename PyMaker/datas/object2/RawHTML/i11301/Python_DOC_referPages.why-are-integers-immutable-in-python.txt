<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/8056130/immutable-vs-mutable-types">Immutable vs Mutable types</a>
<span class="question-originals-answer-count">
                    16 answers
                </span>
</li>
</ul>
</div>
<p>I understand the differences between mutable and immutable objects in Python. I have read many posts discussing the differences. However, I have not read anything regarding WHY integers are immutable objects.</p>
<p>Does there exist a reason for this? Or is the answer "that's just how it is"?</p>
<p>Edit: I am getting prompted to 'differentiate' this question from other questions as it seems to be a previously asked question. However, I believe what I'm asking is more of a philosophical Python question rather than a technical Python question.</p>
<p>It appears that 'primitive' objects in Python (i.e. strings, booleans, numbers, etc.) are immutable. I've also noticed that derived data types that are made up of primitives (i.e. dicts, lists, classes) are mutable. </p>
<p>Is the where the line is drawn whether or not an object is mutable? Primitive vs derived?</p>
</div>
<div class="post-text" itemprop="text">
<p>Making integers mutable would be very counter-intuitive to the way we are used to working with them.</p>
<p>Consider this code fragment:</p>
<pre><code>a = 1       # assign 1 to a
b = a+2     # assign 3 to b, leave a at 1
</code></pre>
<p>After these assignments are executed we expect <em>a</em> to have the value 1 and <em>b</em> to have the value 3. The addition operation is creating a new integer value from the integer stored in <em>a</em> and an instance of the integer 2.
If the addition operation just took the integer at <em>a</em> and just mutated it then both <em>a</em> and <em>b</em> would have the value 3.</p>
<p>So we expect arithmetic operations to create new values for their results - not to mutate their input parameters.</p>
<p>However, there are cases where mutating a data structure is more convenient and more efficient. Let's suppose for the moment that <code>list.append(x)</code> did not modify <code>list</code> but returned a new copy of <code>list</code> with <code>x</code> appended.
Then a function like this:</p>
<pre><code>def foo():
  nums = []
  for x in range(0,10):
    nums.append(x)
  return nums
</code></pre>
<p>would just return the empty list. (Remember - here <code>nums.append(x)</code> doesn't alter <code>nums</code> - it returns a new list with <code>x</code> appended. But this new list isn't saved anywhere.)</p>
<p>We would have to write the <code>foo</code> routine like this:</p>
<pre><code>def foo():
  nums = []
  for x in range(0,10):
    nums = nums.append(x)
  return nums
</code></pre>
<p>(This, in fact, is very similar to the situation with Python strings up until about 2.6 or perhaps 2.5.)</p>
<p>Moreover, every time we assign <code>nums = nums.append(x)</code> we would be copying a list that is increasing in size resulting in quadratic behavior.
For those reasons we make lists <em>mutable</em> objects.</p>
<p>A consequence to making lists mutable is that after these statements:</p>
<pre><code>a = [1,2,3]
b = a
a.append(4)
</code></pre>
<p>the list <em>b</em> has changed to <code>[1,2,3,4]</code>. This is something that we live with even though it still trips us up now and then.</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>What are the design decisions to make numbers immutable in Python?</strong></p>
<p>There are several reasons for immutability, let's see first <strong>what are the reasons for immutability?</strong></p>
<p>1- <em>Memory</em></p>
<ul>
<li>Saves memory. If it's well known that an object is immutable, it can be easily copied creating a new reference to the same object.</li>
<li>Performance. Python can allocate space for an immutable object at creation time, and the storage requirements are fixed and unchanging.</li>
</ul>
<p>2- <em>Fast execution</em>.</p>
<ul>
<li>It doesn't have to copy each part of the object, only a simple reference.</li>
<li>Easy to be compared, comparing equality by reference is faster than comparing values.</li>
</ul>
<p>3- <em>Security</em>:</p>
<ul>
<li>In Multi-threading apps Different threads can interact with data contained inside the immutable objects, without to worry about data consistency.</li>
<li>The internal state of your program will be consistent even if you have exceptions.</li>
<li>Classes should be immutable unless there's a very good reason to make them mutable....If a class cannot be made immutable, limit its mutability as much as possible</li>
</ul>
<p>4- <em>Ease to use</em></p>
<ul>
<li>Is easier to read, easier to maintain and less likely to fail in odd and unpredictable ways.</li>
<li>Immutable objects are easier to test, due not only to their easy mockability, but also the code patterns they tend to enforce.</li>
</ul>
<p>5- <em><a href="https://docs.python.org/3/faq/design.html#why-must-dictionary-keys-be-immutable" rel="nofollow">Keys must be immutable</a></em>. Which means you can use strings, <strong>numbers</strong> or tuples as dictionary key. This is something that you want to use.</p>
<pre><code>The hash table implementation of dictionaries uses a hash value calculated from the key value to find the key. If the key were a mutable object, its value could change, and thus its hash could also change. But since whoever changes the key object can’t tell that it was being used as a dictionary key, it can’t move the entry around in the dictionary. Then, when you try to look up the same object in the dictionary it won’t be found because its hash value is different. If you tried to look up the old value it wouldn’t be found either, because the value of the object found in that hash bin would be different.
</code></pre>
<hr/>
<p><strong>Going back to the integers:</strong></p>
<ul>
<li><p>Security (<strong>3</strong>), Easy to use (<strong>4</strong>) and capacity of using numbers as keys in dictionaries (<strong>5</strong>) are reasons for taken the decision of making numbers immutable.</p></li>
<li><p>Has fixed memory requirements since creation time (<strong>1</strong>).</p></li>
<li><p>All in Python is an object, the <strong>numbers</strong> (like strings) are "elemental" objects. No amount of activity will change the value 8 to anything else, and no amount of activity will change the string “eight” to anything else. This is because a <a href="https://docs.python.org/3/faq/design.html#why-are-python-strings-immutable" rel="nofollow">decision in the design</a> too.</p></li>
</ul>
</div>
<span class="comment-copy">What exactly about an integer would you want to mutate? The bits?</span>
<span class="comment-copy">Assuming immutability of some types enables all sorts of optimizations.  Those optimizations are <i>most</i> pronounced for <code>str</code>, but they come into play for <code>int</code>, <code>float</code>, <code>tuple</code>, <code>frozenset</code> too... Some would probably argue that immutability makes the code easier to read in lots of situations too.  Couple that with the fact that there isn't a natural way to mutate integers (other than <code>+=</code>, <code>*=</code>, ... which are fairly rare...) and there doesn't seem to be a good reason to not have immutable ints.</span>
<span class="comment-copy">If you can modify the value <code>1</code> to be <code>2</code> and the value <code>2</code> to be <code>1</code> then <code>2 + 2 == 1</code> would be <code>true</code>; is that really what you want?</span>
<span class="comment-copy">You may find <a href="http://stackoverflow.com/a/29604031/4014959">abarnert's answer</a> (to the question linked above by StanleyR) helpful.</span>
<span class="comment-copy">I don't think that the statement <code>"Making integers mutable would be very counter-intuituve to the way we are used to working with them."</code> is necessarily true.  There are lots of other languages which have mutable integers (<code>C</code> is a very common example...).  Just because we're used to python integers being immutable <i>now</i> doesn't mean that we were used to immutable integers when the original decision was made.</span>
<span class="comment-copy">The fact that <code>a += 2</code> creates a new integer is counter-intuitive to me.  Most of the time though, it really doesn't make a difference.  One key post that comes to mind is <a href="https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers">this one</a>, which is just one more oddity about the fact that "new" integers are not always created</span>
<span class="comment-copy">@ErikR consider in C: <code>int* a; int *b;  *a = 5; b = a; *a = 10;</code>.  Now the value of <code>*b</code> has changed also.</span>
<span class="comment-copy">@ErikR the difference is that integers in C are value types, and python has only reference types.  The closest analogy will be <code>int*</code> versus an integer in python.  In C, an integer at a location in memory can change, so in C the integer is mutable.  In python, an integer is a reference, but python does not allow you to change the value of the integer at the other end of that reference. C does.</span>
<span class="comment-copy">@ErikR a = 1 b = a+2 . This statement will not change value of a. You are saying if numbers are mutable then a will change. It will not. a = 1 b=a b= 10 this statement will change the value of a if number are mutable. beacuse a and b are pointing to same object and we are changing the value of object so it will reflect to both the objects</span>
