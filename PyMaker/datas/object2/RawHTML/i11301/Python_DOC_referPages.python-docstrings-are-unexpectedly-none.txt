<div class="post-text" itemprop="text">
<p>When I create a class with method like this:</p>
<pre class="lang-py prettyprint-override"><code>class Foo:
    """ A class """
    def bar():
        " Hello world "
        pass
</code></pre>
<p>I would expect the <code>__doc__</code> to return the first statement of the method, since both are strings. Unfortunately, this does not happen:  </p>
<pre class="lang-py prettyprint-override"><code>print(Foo.__doc__)
print(Foo().__doc__)
print(Foo.bar.__doc__)
print(Foo().bar.__doc__)
</code></pre>
<p>outputs <code>None</code> 4 times. Also the example here</p>
<p><a href="https://docs.python.org/3.4/library/functools.html?highlight=__doc__#functools.wraps" rel="nofollow">https://docs.python.org/3.4/library/functools.html?highlight=<strong>doc</strong>#functools.wraps</a></p>
<p>seems to fail, as the docstring is <code>None</code> for me:</p>
<pre class="lang-py prettyprint-override"><code>from functools import wraps
def my_decorator(f):
    @wraps(f)
    def wrapper(*args, **kwds):
        print('Calling decorated function')
        return f(*args, **kwds)
    return wrapper

@my_decorator
def example():
    """Docstring"""
    print('Called example function')
print(example.__doc__)
</code></pre>
<p>Which also prints <code>None</code>.</p>
<p>Why are the <code>__doc__</code>'s not set to the specified strings?</p>
<p>ideone snipplet: <a href="http://ideone.com/cZNUQe" rel="nofollow">http://ideone.com/cZNUQe</a></p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Update:</strong> Based on <a href="https://stackoverflow.com/questions/37551518/python-docstrings-are-unexpectedly-none#comment62592200_37551689">@user2357112's suggestion</a>, I found a way to reproduce ideone's behavior in a local interpreter, and it's likely the cause for the weird discrepancies. Specifically, it looks like ideone is running a wrapper script in Python <em>without</em> the <code>-OO</code> flag, but using <a href="https://docs.python.org/3/library/functions.html#compile" rel="nofollow">the <code>compile</code> builtin function</a> to compile the user provided code with <code>optimize=2</code> as the argument, then <code>eval</code>ing the resulting compiled code object. It looks like this causes the the split behavior previously mentioned; <code>sys.flags.optimize</code> is <code>0</code>, and <code>__debug__</code> is <code>True</code> (matching the state of the outer interpreter), but docstrings and <code>assert</code> statements are stripped (matching the optimization level used when <code>compile</code> is called).</p>
<p>To reproduce, run the following script with Python without passing the <code>-OO</code> flag:</p>
<pre><code>source = '''import sys
print(sys.flags)
print("Debug:", __debug__)
if __debug__:
    print("Debug")
else:
    print("Non-debug")
class Foo:
    """abc"""
print("Foo docstring:", Foo.__doc__)
assert True == False
'''

compiled = compile(source, '&lt;test&gt;', 'exec', optimize=2)
eval(compiled)
</code></pre>
<p>The output is:</p>
<pre><code>sys.flags(debug=0, inspect=0, interactive=0, optimize=0, dont_write_bytecode=0, no_user_site=0, no_site=0, ignore_environment=0, verbose=0, bytes_warning=0, quiet=0, hash_randomization=1, isolated=0)
Debug: True
Non-debug
Foo docstring: None
</code></pre>
<p>where the first two lines behave as if running without <code>-OO</code>, while the next two lines (and the absence of an <code>AssertionError</code>) behave as if <code>-OO</code> is in effect. It looks like <code>sys.flags</code> checks are performed at runtime (which means they reflect the main interpreter state), <code>__debug__</code> is half and half (<code>if</code> checks and possibly other conditional logic is performed at compile time, while other usage is runtime, note how <code>__debug__</code> <code>print</code>s as <code>True</code>, but tests as <code>False</code>), while stripping docstrings and <code>assert</code>s is finished entirely during compilation (so they reflect the state of <code>compile</code>'s <code>optimize</code> flag).</p>
<hr/>
<p><strong>Old answer that applies more often outside ideone</strong>:</p>
<p>For non-ideone cases, behavior like this would indicate you're running with the <code>-OO</code> switch (double optimized). When run with <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-OO" rel="nofollow"><code>-OO</code>, docstrings are stripped during byte code compilation, replaced with <code>None</code></a>; setting <code>PYTHONOPTIMIZE</code> environment variable to <code>2</code> would have the same effect.</p>
</div>
<span class="comment-copy">Wow: on my local machine these all output the expected docstrings (<code>sys.version == '3.4.3+ (default, Oct 14 2015, 16:03:50) \n[GCC 5.2.1 20151010]'</code>)</span>
<span class="comment-copy">Works on my machine, it might be a bug with ideone.</span>
<span class="comment-copy">Also: I saw the same behavior of <code>__doc__</code> being <code>None</code> on my machine for less minimal examples (== customer production code).</span>
<span class="comment-copy">Well, without those examples, I don't know how we can help.</span>
<span class="comment-copy">@MorganThrapp Obviously, my point is that I would need some time to get a better MWE.</span>
<span class="comment-copy">But the <code>optimize</code> flag is set to 0 <a href="http://ideone.com/Zq9TdR" rel="nofollow noreferrer">ideone.com/Zq9TdR</a></span>
<span class="comment-copy">@vaultah: On the other hand, if you deliberately feed Ideone a syntax error, the <a href="http://ideone.com/BD67QR" rel="nofollow noreferrer">traceback</a> you get is coming from the <code>py_compile</code> module rather than a regular Python syntax error. It seems to be performing separate compilation and execution steps. <code>py_compile</code> <a href="https://docs.python.org/3/library/py_compile.html" rel="nofollow noreferrer">defaults</a> to compiling code at the same optimization level as the current interpreter.</span>
<span class="comment-copy">I suspect that the Ideone guys set Python to run at <code>-OO</code> for the compilation pass without realizing that the compiled code would inherit that <code>-OO</code> setting, even when <code>-OO</code> is not specified for the execution pass.</span>
<span class="comment-copy">@vaultah: On further checks, agreed, something is fishy. It's halfway acting like <code>-OO</code> is set, and halfway like neither <code>-O</code> nor <code>-OO</code> is set; <code>assert</code>s and docstrings are stripped per <code>-OO</code>, but <code>sys.flags</code> and the special <code>__debug__</code> variable are acting like not even <code>-O</code> was set. I'm guessing ideone is using some custom Python implementation that doesn't quite match the expected, documented behavior, because it should not be possible for <code>assert</code>s to be skipped while <code>__debug__</code> is <code>True</code>, those are mutually exclusive, and both controlled by <code>-O</code> alone.</span>
<span class="comment-copy">@user2357112: I can't reproduce with <code>py_compile</code> (which writes out optimization level specific bytecode files), but I can get similar behavior with the <code>compile</code> built-in function. I'm investigating for complete repro in local Python.</span>
