<div class="post-text" itemprop="text">
<p>Long time user of this site but first time asking a question!  Thanks to all of the benevolent users who have been answering questions for ages :)</p>
<p>I have been using <code>df.apply</code> lately and ideally want to pass a dataframe into the <code>args</code> parameter to look something like so: <code> df.apply(testFunc, args=(dfOther), axis = 1)</code></p>
<p>My ultimate goal is to iterate over the dataframe I am passing in the <code>args</code> parameter and check logic against each row of the original dataframe, say <code> df </code>, and return some value from <code> dfOther </code>.  So say I have a function like this:</p>
<pre><code>def testFunc(row, dfOther):
    for index, rowOther in dfOther.iterrows():
        if row['A'] == rowOther[0] and row['B'] == rowOther[1]:
            return dfOther.at[index, 'C']

df['OTHER'] = df.apply(testFunc, args=(dfOther), axis = 1)
</code></pre>
<p>My current understanding is that <code>args</code> expects a Series object, and so if I actually run this we get the following error:</p>
<pre><code>ValueError: The truth value of a DataFrame is ambiguous. 
Use a.empty, a.bool(), a.item(), a.any() or a.all().
</code></pre>
<p>However before I wrote <code>testFunc</code> which only passes in a single dataframe, I had actually written <code>priorTestFunc</code>, which looks like this...  And it works!</p>
<pre><code>def priorTestFunc(row, dfOne, dfTwo):
    for index, rowOne in dfOne.iterrows():
        if row['A'] == rowOne[0] and row['B'] == rowOne[1]:
            return dfTwo.at[index, 'C']

df['OTHER'] = df.apply(testFunc, args=(dfOne, dfTwo), axis = 1)
</code></pre>
<p>So to my dismay I have been coming into the habit of writing <code>testFunc</code> like so and it has been working as intended:</p>
<pre><code>def testFunc(row, dfOther, _):
    for index, rowOther in dfOther.iterrows():
        if row['A'] == rowOther[0] and row['B'] == rowOther[1]:
            return dfOther.at[index, 'C']

df['OTHER'] = df.apply(testFunc, args=(dfOther, _), axis = 1)
</code></pre>
<p>I would really appreciate if someone could let me know why this would be the case and maybe errors that I will be prone to, or maybe another alternative for solving this kind of problem!!</p>
<p>EDIT:  As requested by the comment: My dfs generally look like the below.. They will have two matching columns and will be returning a value from the <code>dfOther.at[index, column]</code> I have considered <code>pd.concat([dfOther, df])</code> however I will be running an algorithm testing conditions on <code>df</code> and then updating it accordingly from specific values on <code>dfOther</code>(which will also be updating) and I would like <code> df</code> to be relatively neat, as opposed to making a multindex and throwing just about everything in it.  Also I am aware <code>df.iterrows</code> is in general slow, but these dataframes will be about 500 rows at the max, so scalability isn't really a massive concern for me at the moment.</p>
<pre><code>df
Out[10]: 
    A    B      C
0  foo  bur   6000
1  foo  bur   7000
2  foo  bur   8000
3  bar  kek   9000
4  bar  kek  10000
5  bar  kek  11000

dfOther
Out[12]: 
    A    B      C
0  foo  bur   1000
1  foo  bur   2000
2  foo  bur   3000
3  bar  kek   4000
4  bar  kek   5000
5  bar  kek   6000
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The error is in this line:</p>
<pre><code>  File "C:\Anaconda3\envs\p2\lib\site-packages\pandas\core\frame.py", line 4017, in apply
    if kwds or args and not isinstance(func, np.ufunc):
</code></pre>
<p>Here, <code>if kwds or args</code> is checking whether the length of <code>args</code> passed to <code>apply</code> is greater than 0. It is a common way to check if an iterable is empty:</p>
<pre><code>l = []

if l:
    print("l is not empty!")
else:
    print("l is empty!")
</code></pre>
<blockquote>
<p><code>l is empty!</code></p>
</blockquote>
<pre><code>l = [1]

if l:
    print("l is not empty!")
else:
    print("l is empty!")
</code></pre>
<blockquote>
<p><code>l is not empty!</code></p>
</blockquote>
<p>If you had passed a tuple to <code>df.apply</code> as <code>args</code>, it would return True and there wouldn't be a problem. However, Python does not interpret (df) as a tuple:</p>
<pre><code>type((df))
Out[39]: pandas.core.frame.DataFrame
</code></pre>
<p>It is just a DataFrame/variable inside parentheses. When you type <code>if df</code>:</p>
<pre><code>if df:
    print("df is not empty")

Traceback (most recent call last):

  File "&lt;ipython-input-40-c86da5a5f1ee&gt;", line 1, in &lt;module&gt;
    if df:

  File "C:\Anaconda3\envs\p2\lib\site-packages\pandas\core\generic.py", line 887, in __nonzero__
    .format(self.__class__.__name__))

ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
</code></pre>
<p>You get the same error message. However, if you use a comma to indicate that it'a tuple, it works fine:</p>
<pre><code>if (df, ):
    print("tuple is not empty")

tuple is not empty
</code></pre>
<p>As a result, adding a comma to <code>args=(dfOther)</code> by making it a <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences" rel="nofollow">singleton</a>  should solve the problem.</p>
<pre><code>df['OTHER'] = df.apply(testFunc, args=(dfOther, ), axis = 1)
</code></pre>
</div>
<span class="comment-copy">@macavich, spot on! It's a good catch!</span>
<span class="comment-copy">Thank you @ayhan for the well described and elegant answer.</span>
<span class="comment-copy">@macavich, please consider <a href="http://meta.stackexchange.com/a/5235">accepting</a> the most helpful answer - this will also indicate that your question has been answered</span>
