<div class="post-text" itemprop="text">
<p>I think my chances are slim based on the responses to other questions related to regular expressions.</p>
<p>I am try to parse numbers in different representations:</p>
<pre><code>12345(234567)
12345(234.56K)
</code></pre>
<p>from which I cannot control the source format.</p>
<p>I suppose I can come up with different regular expression for different formats. How to detect which format is which? Has it to be brute-force way to look for the letter 'K'?</p>
</div>
<div class="post-text" itemprop="text">
<p>This kind of thing is often done by iterating over a bunch of regular expressions and stopping when you find one that matches - because your conversion from a string to a number needs special parsing beyond the capabilities of regular expressions. That means you need to order them in a way that you know will give the right answer. In this case, you might do something like this:</p>
<pre><code>PARSERS = (
    (re.compile(r'([0-9]+)\(([-+0-9.]+)[mM]\)'), 1000000),
    (re.compile(r'([0-9]+)\(([-+0-9.]+)[kK]\)'), 1000),
    (re.compile(r'([0-9]+)\(([-+0-9.]+)\)'), 1),
)

def parse(num):
    for pattern, multiplier in PARSERS:
        match = pattern.match(num)
        if match is not None:
            return float(match.group(1)), float(match.group(2)) * multiplier
    raise ValueError("Failed to parse")
</code></pre>
<p>As an aside, this pattern is common in other places too, such as deciding <a href="http://www.tornadoweb.org/en/stable/guide/structure.html#the-application-object" rel="nofollow">which function will handle a web request</a> based on the URL.</p>
<p>Just for fun, here's an alternative implementation that uses dictionary lookups and a single regular expression instead of iteration:</p>
<pre><code>MULTIPLIER = {
    'M': 1000000,
    'K': 1000,
    '': 1,
}
PATTERN = re.compile(r'(\d+)\(([-+.\d]+)([kKmM]?)\)')

def parse(num):
    match = PATTERN.match(num)
    if match is None:
        raise ValueError("Failed to parse")
    first, second, suffix = match.groups()
    suffix = suffix.upper()
    if suffix not in MULTIPLIER:
        raise ValueError("Unrecognised multiplier %s" % suffix)
    return float(first), float(second) * MULTIPLIER[suffix]
</code></pre>
</div>
<span class="comment-copy"><code>([0-9])+</code> will only capture the last digit. Use <code>([0-9]+)</code>. Also <code>[0-9]</code> can be replaced with <code>\d</code>.</span>
<span class="comment-copy">@z0r: thanks! just that I thought chances are slim to have any response!</span>
<span class="comment-copy">@Alex: thanks for the optimization! :)</span>
<span class="comment-copy">@Alex: Thanks for the bug fix. I'm not sure about using <code>\d</code> though: in Python <a href="https://docs.python.org/3/reference/lexical_analysis.html#floating" rel="nofollow noreferrer"><code>float()</code>expects digits <code>"0"..."9"</code></a>, while <code>\d</code> will match other characters <a href="https://docs.python.org/2/library/re.html#regular-expression-syntax" rel="nofollow noreferrer">outside that range</a>.</span>
<span class="comment-copy">@chapter3 I added a second option that only uses one expression</span>
