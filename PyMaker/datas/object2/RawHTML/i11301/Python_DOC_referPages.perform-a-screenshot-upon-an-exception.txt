<div class="post-text" itemprop="text">
<p>Hey is there a way to capture a screenshot upon a an Exception, any Exception. My 'failed' solution which is placed in the <code>BaseTestCase</code>, <code>unittest.TestCase</code> subclass:</p>
<pre><code>class BaseTestCase(unittest.TestCase):
@classmethod
def setUpClass(cls):
"""some code"""

@property 
def failureException(self):
    class MyFailureException(Exception):
        def __init__(self_, *args, **kwargs):
            screenshot_dir = '../error_log'
            self.driver.save_screenshot('{0}/{1}.jpeg'.format(screenshot_dir, self.id()))
            return super().__init__(*args, **kwargs)

    MyFailureException.__name__ = Exception.__name__
    return MyFailureException
</code></pre>
<p>Originally it was <code>AssertionError</code> instead of the <code>Exception</code> but it would only catch assertion errors and I'm more interested in other kinds of errors</p>
</div>
<div class="post-text" itemprop="text">
<p>To take a screenshot when an error or failure occurs, check if there is an exception currently being handled in the <code>tearDown</code> method:</p>
<pre><code>import unittest, sys, exceptions
from selenium import webdriver


class TestCaseBase(unittest.TestCase):

    def setUp(self):
        self.driver = webdriver.Firefox()

    def tearDown(self):
        type, value, traceback = sys.exc_info()
        if type is exceptions.AssertionError :
            self.driver.save_screenshot(r'screenshot-failure.png')
        elif type is exceptions.Exception :
            self.driver.save_screenshot(r'screenshot-error.png')

        self.driver.quit()

class MyTestCase(TestCaseBase):

    def test_should_take_screenshot_on_failure(self):
        self.driver.get("http://stackoverflow.com/")
        self.assertTrue(False)

    def test_should_take_screenshot_on_error(self):
        self.driver.get("http://stackoverflow.com/")
        raise Exception("my exception")


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>You could also override the methods <code>TestResult.addError</code> and <code>TestResult.addFailure</code>:</p>
<pre><code>import unittest
from selenium import webdriver


class TestCaseBase(unittest.TestCase):

    def setUp(self):
        self.driver = webdriver.Firefox()

    def tearDown(self):
        self.driver.quit()

    def run(self, result=None):
        super(TestCaseBase, self).run(TestResultEx(result, self))


class MyTestCase(TestCaseBase):

    def test_should_take_screenshot_on_failure(self):
        self.driver.get("http://stackoverflow.com/")
        self.assertTrue(False)

    def test_should_take_screenshot_on_error(self):
        self.driver.get("http://stackoverflow.com/")
        raise Exception("my exception")


class TestResultEx(object):

    def __init__(self, result, testcase):
        self.result = result
        self.testcase = testcase

    def __getattr__(self, name):
        return object.__getattribute__(self.result, name)

    def addError(self, test, err):
        self.result.addError(test, err)
        self.testcase.driver.save_screenshot(r'screenshot-error.png')

    def addFailure(self, test, err):
        self.result.addFailure(test, err)
        self.testcase.driver.save_screenshot(r'screenshot-failure.png')


if __name__ == '__main__':
    unittest.main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use decorators to catch if your test case functions raise an exception.</p>
<p>To do this you would first need to create a decorator function that returns the function that you want your test cases to be wrapped in like the example below.</p>
<pre><code>def screenshot(func):
    def screenshot_exception(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except:
            self.driver.save_screenshot('{0}/{1}.jpeg'.format(screenshot_dir, self.id()))
            raise
    return screenshot_exception
</code></pre>
<p>Then for the test cases you want to get screenshots for you would just need to add the decorator above your test cases.</p>
<pre><code>@screenshot
def test_case_1():
    raise NameError('Test Error')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's better to save log from your exception into the file than taking a screenshot. For practice check this code:</p>
<pre><code>&gt;&gt;&gt; s = [1, 2]
&gt;&gt;&gt; try:
...  s[3]
... except IndexError as e:
...  print(e)
...
list index out of range
</code></pre>
<p>As you can see, it's possible to catch (and print) error message. Try using <code>open()</code> instead of <code>print()</code> to simply save error message into the file. Here's an example:</p>
<pre><code>s = [1, 2]
try:
    s[3]
except IndexError as e:
    file = open("logfile", "a")  # 'a' means append to file
    file.write(e)
    file.close()
</code></pre>
<p>This is the most simple solution to your problem.</p>
<p>Also, it's not wise to catch any exceptions that may occur. Better try to catch 2, 3 that are most likely to occur.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for a <a href="https://docs.python.org/3/tutorial/errors.html#handling-exceptions" rel="nofollow">try/except statement</a>:</p>
<pre><code>try:
    # your code (which may raise an Exception) goes here
except:
    # this code only runs if the code in the try block raised an exception
    driver.save_screenshot(screenshot_dir)
    raise  # this will propagate the exception
</code></pre>
</div>
<span class="comment-copy">Exactly what I was looking for. Thank you!</span>
<span class="comment-copy">hey thanks, had this before and was asked to find solution on a class level :(</span>
<span class="comment-copy">I can't basically put all of my individual tests into try, except block, thats like 500 lines of additional code. I need a solution on a class level and preferrably a screen shot</span>
<span class="comment-copy">same answer as above, that's on a method level, i need a solution on a test class level</span>
