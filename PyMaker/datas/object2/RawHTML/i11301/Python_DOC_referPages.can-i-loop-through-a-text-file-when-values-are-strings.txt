<div class="post-text" itemprop="text">
<p>I have a problem I'd be very grateful for help with.</p>
<p>Specifically, I have a gigantic text file; I need to replace specific strings in it with entries from a dictionary. Usefully, the words I need to replace are named in sequential fashion: 'Word1', 'Word2', ... , 'Wordn'.</p>
<p>Now, I'd like to write a 'for' loop that loops across the file, and for all instances of 'Wordx' replaces it with dictionary[x]. The problem, of course, is that 'Wordx' requires the 'x' part to function as a variable, which (so far as I know) can't be done inside a string. </p>
<p>Does anyone have workaround? I tried looking at regular expressions, but found nothing obvious (possibly because I also found it somewhat confusing).</p>
<p>(Note that I can when I generate the text file, I have complete control over the form the words I want to replace can take: i.e., it need not be 'Word11; it can be 'Wordeleven' or 'wordXI' or anything ascii at all.)   </p>
<p>Edit: To add more detail, as requested: my text file is an export of the javascript behind a survey file. The original survey software only allows me to enter text prompts one at a time (as opposed to pipe the in from a csv), but I have several thousand text prompts to enter (the words). My plan is to manually enter about 100 words ('Word1, ..., 'Word100'), export the survey javascript as a text file, write a script to replace the words with dictionary entries, import the resulting files, and join them into a new survey.</p>
<p>However, the issue remains whether I can use the number portion of a string as a variable to loop across</p>
</div>
<div class="post-text" itemprop="text">
<p>With <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow"><code>re.sub()</code></a>, you can pass it a function instead of a replacement string. This function can look up the replacement from a dictionary. For example:</p>
<pre><code>d = {'0': 'foo', '1': 'bar', '2': 'baz'}
re.sub(r'word(\d+)',
       lambda match: d[match.group(1)],
       "Hello word0, this is word2. How is word1?")
</code></pre>
<blockquote>
<p>Hello foo, this is baz. How is bar?</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<pre><code>n = 1
while not done:
    replace_str = 'Word' + str(n)
    # find and replace all instances of replace_str in the file text
    # set variable done if finished
    n += 1
</code></pre>
<p>Does that framework solve your needs? A string is not a variable: a string is a value which can be calculated, while a variable is a name, which (usually) is not calculated. With more difficulty you can also set strings like 'WordEleven' and so on.</p>
</div>
<div class="post-text" itemprop="text">
<p>I suppose the text file you were talking was like this:</p>
<blockquote>
<p>Hi! This is word1</p>
<p>I like to swim, word2 and word3 ....</p>
</blockquote>
<p>if so, then you can read line by line, split lines and replace words with values from dictionary, whose keys would be int(word[-1])</p>
<p>Here is the code,</p>
<pre><code>from __future__ import print_function

dict = {1: 'Aravind', 2: 'eat', 3:'play'}

def word_gen(file):
    for line in file:
        for word in line.split():

            if word[0:4] == 'word' and len(word) == 5:
                 print( dict[ int( word[-1] ) ], end=" " )  #remove int() if keys are are "chars" like {'1':'Mark',..}
                 #this------------------^

            else: print(word, end = " ")

        print("\r")


with open('re.txt', 'r') as f:
    word_gen(f)
</code></pre>
<p>now direct terminal output to another file with</p>
<pre><code>python replace.py &gt; replaced.txt
</code></pre>
<p>Hope that helps :)</p>
</div>
<span class="comment-copy">maybe you need show more clear example, more about your text file, and what you want</span>
<span class="comment-copy">How big in bytes is this "gigantic" text file?</span>
<span class="comment-copy">Eh, the size isn't really my point: I say 'gigantic' only to convey that it rewards writing some code, as opposed to doing a 'find' 'replace' one word at a time.</span>
<span class="comment-copy">This is great. The only issue I have with it is that the code throws an error if it encounters words with numbers that are not in the dictionary. This seems sub-optimal given that the author really just wants to replace where the integer is found in the dictionary, not react to all integers in the doc.</span>
<span class="comment-copy">I don't know how well <code>re.sub()</code> can handle "gigantic" text files as input.</span>
<span class="comment-copy">@Jason: Sure, but that only requires a minor adjustment to the replacement function. But what makes you think there <i>could</i> be words of the "wordx" pattern in the file that aren't in the dictionary? According to the info given, the OP has enough control over the file to prevent that situation from arising.</span>
<span class="comment-copy">@Jasper If the performance of <code>sub</code> is a problem with a large string, you could do it line-by-line.</span>
<span class="comment-copy">How does the loop know when it's done?</span>
<span class="comment-copy">Reading through a huge file repeatedly for each <code>n</code> is a very expensive method. It would be better to read through the file once, and do all the replacements on each line.</span>
<span class="comment-copy">I agree with those concerns. I ignored them in my answer because the question as originally written gave very few details, and I wanted to concentrate on what seemed to be the main issue, "'Wordx' requires the 'x' part to function as a variable, which (so far as I know) can't be done inside a string".</span>
<span class="comment-copy">For what it's worth, Rory Daulton's suggestion does capture what I was looking for in a fairly direct way. The other suggestions are excellent too, but this gives the kind of workaround that the problem needs. It may well be that it's less efficient––though the problem is a once-off.</span>
<span class="comment-copy">Very handy code––and easy to follow, too. Thanks!</span>
