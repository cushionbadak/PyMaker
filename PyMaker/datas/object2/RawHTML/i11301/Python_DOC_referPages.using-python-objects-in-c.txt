<div class="post-text" itemprop="text">
<p>I'm writing a code that calculates the images of nonlinear maps using methods from interval analysis, applies a minkowski sum and repeats for an arbitrary number of iterations.</p>
<p>I've written a working code in Python, however I would like to be able to implement some of the more iteration/recursion intensive parts of the algorithm in C++ to benefit from the increased speed. I have used Cython in the past with great results, but I'd like to practice my C++.</p>
<p>Also, my objects are complicated enough that I'd rather avoid having to implement them in C++ (baby steps!).</p>
<p>So my questions are:</p>
<p>1) Does using Python objects in C++ prevent any improvement in efficiency?</p>
<p>2) If not, is it possible to use Cython to wrap a C++ function which iterates/recurses over a python object?</p>
<p>To be more specific, I have a recursive algorithm that recurses over the left and right children of a BST (though it's a fairly heavily modified BST so I'd rather not get bogged down with the details of implementing it in C++), however the runtime is quite prohibitive, so I'd like to write it in C++.</p>
</div>
<div class="post-text" itemprop="text">
<p>Yes. You will get a speed-up over pure python but not on par with the increase you'd get if you were using pure <code>C/C++</code>. If you want to handle Python Objects you'll need to do it via the <a href="https://docs.python.org/3/c-api/index.html" rel="nofollow"><code>Python C/API</code></a>; this adds overhead to the execution, the price you must pay for being allowed to interact with Python. </p>
<p>Do note this involves a lot of complexity since you need to be familiar with the API and read up what functions do with object references, how to create Lists, pack Tuples et cetera. You can skip through all these if you just create a couple of <code>public</code> Cython <code>cdef</code> functions that wrap the methods on your objects. This generates all the <code>CPython</code> code that handles these for you.</p>
<p>A little example in which a silly object is wrapped and embedded might look like this (note, I'm using <code>.c</code> for this, <code>c++</code> has similar steps):</p>
<pre><code>class PyClass(object):

    def __init__(self):
        self.data = []

    def add(self, val):
        self.data.append(val)

    def __str__(self):
        return "Data: " + str(self.data)

cdef public object createPyClass():
    return PyClass()

cdef public void addData(object p, int val):
    p.add(val)

cdef public char* printCls(object p):
    return bytes(str(p), encoding = 'utf-8')
</code></pre>
<p>Compiling with <code>cython pycls.pyx</code> (use <code>--cplus</code> for <code>c++</code>) will generate a <code>.c</code> and <code>.h</code> file containing the source and the function declarations respectively. All you need to do now is create a <code>main.c</code> file that starts up Python and you're ready to call these functions:</p>
<pre><code>#include "Python.h"   // Python.h always gets included first.
#include "pycls.h"    // Include your header file.

int main(int argc, char *argv[])
{
    Py_Initialize();   // initialize Python
    PyInit_pycls();    // initialize module (initpycls(); in Py2)
    PyObject *obj = createPyClass();
    for(int i=0; i&lt;10; i++){
        addData(obj, i);
    }
    printf("%s\n", printCls(obj));
    Py_Finalize();
    return 0;
}
</code></pre>
<p>Compiling this with the proper flags (which you can obtain from <code>python3.5-config</code> of <code>python-config</code> [Py2]):</p>
<pre><code>gcc pycls.c main.c -L$(python3.5-config --cflags) -I$(python3.5-config --ldflags) -std=c99
</code></pre>
<p>Will create your executable which interacts with your object:</p>
<pre><code>./a.out
Data: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>All this is done by using <code>Cython</code> along with the <code>public</code> keyword that generates the <code>.h</code> header file. You could alternatively just compile a python module with Cython and create the header/handle the additional boilerplate yourself. Since I don't think you want to get boggled down with <code>C-API</code> learning, this shouldn't be the way to go.</p>
<p>As @freakish states in his comment, it would be ideal to extract the data (<a href="http://docs.scipy.org/doc/numpy-1.11.0/reference/c-api.array.html#c.PyArray_DATA" rel="nofollow"><code>numpy</code> has a <code>C-API</code> you can use for this</a>) and work on it in pure <code>C++</code>. Generally if you work your loops in <code>C/C++</code> and perform the grunt work there, you'll get good speed ups. </p>
</div>
<span class="comment-copy">If you are going to literally rewrite Python code in C++ then you will gain nothing. But you can extract data from Python objects and operate on pure C++, that will definitely give you great performance boost, mostly because you can drop heavy polymorphism.</span>
<span class="comment-copy">So, essentially you want to implement the data structure in <code>Python</code> and implement the algorithm that acts on that DS is <code>C++</code>, right?</span>
<span class="comment-copy">@Jim That's the idea :)</span>
<span class="comment-copy">Thanks for this.   I agree, the effort put into learning the API is probably not worth my time. Extracting the data seems like a good idea. I decided last night that I mine aswell try to rewrite my classes in C++ if I'm going seriously commit myself to learning the language.  If it so happens that I can't manage it, I'll look into the data extraction.</span>
