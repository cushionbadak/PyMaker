<div class="post-text" itemprop="text">
<p>The <a href="https://wiki.python.org/moin/TimeComplexity" rel="nofollow">Python wiki page on time complexity</a> says that deleting an item takes O(n) time. The <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow">description of the deque class in the documentation of the collections module</a> says that "<code>list</code> objects [...] incur O(n) memory movement costs for <code>pop(0)</code> and <code>insert(0, v)</code> operations which change both the size and position of the underlying data representation".</p>
<p>Why do lists need O(n) time? Isn't a list just a bunch of elements, or pointers to elements, physically next to each other in memory, along with a pointer to where the list starts? If so, why can't the <code>list</code> type have a <a href="https://docs.python.org/3/library/collections.html#collections.deque.popleft" rel="nofollow"><code>popleft</code></a> method, similar to the one in <code>collections.deque</code>, that removes the first element in O(1) time by appropriately incrementing the start pointer of the list?</p>
<p>I am not trying to solve any specific problem. I just want to satisfy my curiosity as to why it is designed that way.</p>
<p><strong>EDIT:</strong> Here is a diagram of how my <code>popleft</code> method would work:</p>
<p><strong>Before calling <code>popleft</code>:</strong></p>
<pre><code>-------------------------------------------------------------------
|    The   |  quick   |  brown   |   fox    |  jumps   |   over   |
-------------------------------------------------------------------
      ^
      pointer to list
</code></pre>
<p><strong>After calling <code>popleft</code>:</strong></p>
<pre><code>-------------------------------------------------------------------
|    The   |  quick   |  brown   |   fox    |  jumps   |   over   |
-------------------------------------------------------------------
                 ^
                 pointer to list
</code></pre>
<p>Before the call to <code>popleft</code>, the first element of the list is <code>The</code>, the 2nd is <code>quick</code>, etc. After the call, the place where the first element was is now unused memory (which may be left empty or claimed by the garbage collector), the new first element is <code>quick</code>, the new 2nd element is <code>brown</code>, etc. No large amount of data needs to be moved, and nothing needs to happen that takes O(n) time.</p>
</div>
<div class="post-text" itemprop="text">
<p>The pointer to where the list <em>really</em> starts must be retained for the purpose of freeing the memory appropriately.</p>
<p>Indeed, <code>remove(0)</code> could be made faster by having a second pointer which is increased in this case. And if an <code>.add(0, x)</code> happens afterwards, this could be made faster by decrementing this "data start timer" as long as it is bigger than the "memory start timer".</p>
<p>But all other operations, i. e. insertions and deletions to other indexes, would still be <code>O(n)</code>, so that wouldn't change much.</p>
<p>Just know what your operations will be and thus which data structure to pick.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python <code>list</code> is actually an array. <code>deque</code> is a real linked list. It is Python's fault for using the wrong term (for which I do not have an explanation). <code>O(n)</code> for insertion and deletion is normal for arrays (as following elements need to be shifted up or down), which is a tradeoff for the <code>O(1)</code> speed for get and set. Linked lists make a similar tradeoff in the opposite direction: <code>O(1)</code> for operations at ends, but <code>O(n)</code> for any access in the middle.</p>
</div>
<div class="post-text" itemprop="text">
<p>There's no reason it <em>couldn't</em> be, it just hasn't been. It is, however, a complication to the code, and the problem you're facing is usually an indicator that you're taking the wrong approach.</p>
<p>You could just implement this behavior yourself in a wrapper class, and use that in the cases where you know it will be worth it.</p>
<p>That said, <a href="https://bitbucket.org/pypy/pypy/pull-requests/282/add-a-copy-on-write-slice-list-strategy/diff" rel="nofollow">something similar has been submitted to PyPy</a>.</p>
</div>
<span class="comment-copy">I wouldn't expect insertion at the beginning to be consistently faster than O(n). I don't think it is unreasonable to expect deletion of the first element to be O(1). I don't know too much about memory allocation tricks. Would it be unreasonable to only free part of the allocated memory when my hypothetical <code>popleft</code> method is called?</span>
<span class="comment-copy">@EliasZamaria Most memory allocators don't let you free arbitrary subregions.</span>
<span class="comment-copy">@o11c, thanks. I had a feeling that someone thought more deeply about my plan and came up with a reason why it is not practical, but I was just a bit curious as to what that reason is.</span>
<span class="comment-copy">I seem to recall that there <i>is</i> some allocator that does something similar (though it wouldn't be a good idea for <code>sizeof(PyObject *)</code>, but my Google-fu is weak right now. But for <i>serious</i> allocators like jemalloc, the address actually encodes the size, so you fundamentally can't change the size of the allocation.</span>
<span class="comment-copy">I am not confused about the terminology. I am going to go into detail about how my proposed O(1) <code>popleft</code> method would work in the question.</span>
