<div class="post-text" itemprop="text">
<p>I have 2 lists of ordered times which are the start/stop times for ServiceA and ServiceB, respectively. I want to combine the lists in one list containing the start and stop times (in order) of when at least 1 of the services was running. (Both services always start after 00:01:00 and stop before 23:59:00.)</p>
<pre><code>Example:

ListA = ["08:03:19","14:22:22","17:00:02","18:30:01"]
ListB = ["15:19:03","18:00:00","18:35:05","19:01:00"]
... the magic happens
Result =["08:03:19","14:22:22","15:19:03","18:30:01","18:35:05","19:01:00"]
</code></pre>
<p>The code below does not produce the desired results. After numerous attempts that accounted for most but not all possible cases, I'm posting what I have currently. The lists could be vastly different, for example there may be no overlap or complete overlap between start/stop times of the 2 services.</p>
<pre><code>#!/usr/bin/python2.7

def combineOverlappingTimes(aList, bList, CurrentResults):
    ReturnList = []
    aStart = aList[0]
    aStop = aList[1]
    bStart = bList[0]
    bStop = bList[1]

    if len(CurrentResults) == 0:
        LastTimeInCurrentResults = "00:00:00"
    else:
        LastTimeInCurrentResults = CurrentResults[(len(CurrentResults)-1)]

    print "aStart= %s\naStop= %s\nbStart= %s\nbStop= %s" % (aStart,aStop,bStart,bStop)
    print "LastTimeInCurrentResults= %s" % LastTimeInCurrentResults
    if aStart &gt;= LastTimeInCurrentResults and bStart &gt;= LastTimeInCurrentResults:
        if aStart &gt; bStart:
            if bStart &gt; aStop:
                ReturnList.append( (aStart,aStop) )
            elif bStart &lt; aStop:
                ReturnList.append( (bStart,bStop ) )
        else: #(aStart &lt; bStart)
            if aStop &lt; bStart:
                ReturnList.append( (bStart,bStop) )
            elif aStop &gt; bStop: 
                ReturnList.append( (bStart,aStop) )
    elif aStart &gt;= LastTimeInCurrentResults:
        ReturnList.append( (aStart, aStop) )
    else: # either A or B is beforeLastTime
        if aStart &lt; LastTimeInCurrentResults:
            ReturnList.append( (LastTimeInCurrentResults, aStop) )
        elif bStart &lt; LastTimeInCurrentResults:
            ReturnList.append( (LastTimeInCurrentResults, bStop) )

    print ( "combineOverlappingTime ReturnList= " + str(ReturnList))
    print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n"
    return ReturnList

# main()
#####################################################################
def main():

    ListA = ["08:03:19","14:22:22","14:22:25","14:22:30","18:00:02","18:30:01"]
    ListB = ["14:22:36","15:18:10","15:19:03","18:00:01","18:00:05","19:01:00"]
    ResultList = []

    i = 0
    while i &lt; len(ListA):
        if i == 0:
            ListA_StartTime= ListA[i]
            ListA_StopTime = ListA[i+1]
        else:
            if i == len(ListA)-2:
                ListA_StartTime= ListA[i]
                ListA_StopTime = ListA[i+1]
            else:
                ListA_StartTime= ListA[i]
                ListA_StopTime = ListA[i+1]

        j = 0
        ListB_StartTime, ListB_StopTime = "",""
        for time in ListB:
            if j % 2 == 0:
                ListB_StartTime= time
            else:
                ListB_StopTime = time

            if ListB_StartTime!= "" and ListB_StopTime != "":
                tempSetA, tempSetB = [], []
                tempSetA.append(ListB_StartTime)
                tempSetA.append(ListB_StopTime)
                tempSetB.append(ListA_StartTime)
                tempSetB.append(ListA_StopTime)
                combinedTimes = combineOverlappingTimes(tempSetA, tempSetB, ResultList)
                for start,stop in combinedTimes:
                    ResultList.append(start)
                    ResultList.append(stop)
                ListB_StartTime, ListB_StopTime = "",""
            j += 1

        i += 2

    print "ResultList= %s \n\n" % str(ResultList)
    DesiredList = ["08:03:19","14:22:22","14:22:25","14:22:30","14:22:36","15:18:10","15:19:03","18:00:01","18:00:02","19:01:00"]
    print "Desired Results: %s" % str(DesiredList)


if __name__ == '__main__':
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could do this without a single for-loop by using <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow"><code>itertools.reduce</code></a> from the standard library to do the heavy lifting. Some consider this to be more idiomatic (except Guido of course who doesn't like the <code>reduce</code> function so much he chose to remove it from Python's prelude).</p>
<pre class="lang-py prettyprint-override"><code>from functools import reduce

# this would work with any comparable values in `aList` and `bList`
aList = [0, 3, 7, 10, 13, 14]
bList = [2, 4, 10, 11, 13, 15]

# split both lists into tuples of the form `(start, stop)`
aIntervals = list(zip(aList[::2], aList[1::2]))
bIntervals = list(zip(bList[::2], bList[1::2]))

# sort the joint list of intervals by start time
intervals = sorted(aIntervals + bIntervals)

# reduction function, `acc` is the current result, `v` is the next interval
def join(acc, v):
    # if an empty list, return the new interval
    if not acc:
        return [v]
    # pop the last interval from the list
    last = acc.pop()
    # if the intervals are disjoint, return both
    if v[0] &gt; last[1]:
        return acc + [last, v]
    # otherwise, join them together
    return acc + [(last[0], max(last[1], v[1]))]

# this is an iterator with joined intervals...
joined_intervals = reduce(join, intervals, [])

# ... which we can join back into a single list of start/stop times
print(list(sum(joined_intervals, ())))
</code></pre>
<p>The output is, as expected,</p>
<pre><code>[0, 4, 7, 11, 13, 15]
</code></pre>
<p>By testing with the timelike values in the provided example:</p>
<pre class="lang-py prettyprint-override"><code>aList = ['08:03:19', '14:22:22', '17:00:02', '18:30:01']
bList = ['15:19:03', '18:00:00', '18:35:05', '19:01:00']
</code></pre>
<p>this also yields the desired answer of</p>
<pre><code>['08:03:19', '14:22:22', '15:19:03', '18:30:01', '18:35:05', '19:01:00']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Breaking down the problem</h2>
<p>Your code can be more readable if you break it down into functions and plan before coding.</p>
<p>Your problem can be broken down into smaller manageable parts:</p>
<ol>
<li>Create a function that returns the total uptime of two timings.</li>
<li>Sort the timings in <code>aList</code> and <code>bList</code> in ascending order </li>
<li>Compare the first two timings of <code>aList</code> and <code>bList</code> to get the total uptime for the first two timings.</li>
</ol>
<p>4a. If it returns 4 timings, the timings given are disjoint. Take the last two timings and compare with the next two in <code>aList</code>.</p>
<p>4b. If not, the timings are connected. Take the two timings and compare with the next two and compare with the next two in <code>aList</code>.</p>
<ol start="5">
<li>With the results from 4, compare the timings in <code>bList</code> in a similar fashion as in 4.</li>
<li>Repeat until end of the list.</li>
</ol>
<p>The problem, after reading through your code, seems to be that it is too unclear what needs to be done (step by step).</p>
<h2>Solving the problem</h2>
<h3>1. Create a function that returns the total uptime of two timings.</h3>
<p>The timings will have these possible cases:</p>
<pre><code>NOT CONNECTED
Case 1
A: ---
B:      -----
Case 2
A:      -----
B: ---

CONNECTION
Connected A starts first
Case 1
A: -------
B:   ---------
Case 2
A: -------
B:   ---

Connected B starts first
Case 3
A:   ---------
B: -------
Case 4
A:   ---
B: -------

EQUALITY
Starting Equality
Case 1
A: ---
B: -----
Case 2
A: -----
B: ---

Ending Equality
Case 3
A: -----
B:   ---
Case 4
A:   ---
B: -----

Total Equality
Case 5
A: -----
B: -----
</code></pre>
<p>With that in mind, you can go ahead and create the code for it.</p>
<pre><code>def combined_uptime(a, b):
    # Only accept lists of length two
    aStart = a[0]
    aStop = a[1]
    bStart = b[0]
    bStop = b[1]

    # &lt; means "earlier than"
    # &gt; means "later than"

    # Unconnected
    # Not connected Case 1
    if aStop &lt; bStart:
        return (aStart, aStop, bStart, bStop)
    # Not connected Case 2
    elif bStop &lt; aStart:
        return (bStart, bStop, aStart, aStop)

    # From this point on, A and B are connected

    # CONNECTION
    # A starts first
    if aStart &lt;= bStart:
        if aStop &lt; bStop:
            # Connection Case 1 + Equality Case 1
            return (aStart, bStop)
        else:
            # Connection Case 2 + Equality Case 2 + Equality Case 3 + Equality Case 5
            return (aStart, aStop)
    else:
        if bStop &lt; aStop:
            # Connection Case 3
            return (bStart, aStop)
        else:
            # Connection Case 4 + Equality Case 4
            return (bStart, bStop)
</code></pre>
<h3>2. Sort the timings in aList and bList in ascending order.</h3>
<p>This can be done by converting all your timings to be stored as tuples, sort it, then remove the tuples.</p>
<pre><code>def sort_ascending(x):
    # Store each set in a tuple
    l = [(s, x[i*2 + 1]) for i, s in enumerate(x[::2])]

    # Sort in ascending order
    l.sort(key=lambda tup: tup[0])
    print l
    # Remove tuples
    ret_list = []
    [ret_list.extend(s) for s in l]
    return ret_list
</code></pre>
<h3>3-6. The recursive function</h3>
<p>You would see the last step includes repetition of the same process. This usually hints that a recursive function will do the job.</p>
<p>Using all the functions as mentioned above, here is the recursive function:</p>
<pre><code>def uptime(a, b, result=None):
    print a
    print b
    print result
    ret_list = []

    # Return the result if either a or b is empty
    if a == [] and b == []:
        return result
    elif a and b == []:
        return result.extend(a) or result[:]
    elif b and a == []:
        return result.extend(b) or result[:]

    # Prevent overwriting, make a copy
    aList = list(a)[:]
    bList = list(b)[:]

    # Get results from previous iteration
    if result:
        # Process aList
        results_aList = list(combined_uptime(aList[0:2], result))
        del aList[0:2]

        if len(results_aList) != 2:
            ret_list.extend(results_aList[0:2])
            del results_aList[0:2]

        # Process bList
        results_bList = list(combined_uptime(bList[0:2], results_aList))
        del bList[0:2]

        if len(results_bList) != 2:
            ret_list.extend(results_bList[0:2])
            del results_bList[0:2]

        print "CLEAR"
        # Add result
        ret_list.extend(uptime(aList, bList, results_bList))
    else:
        # First iteration
        results_aList_bList = list(combined_uptime(aList[0:2], bList[0:2]))
        del aList[0:2]
        del bList[0:2]

        if len(results_aList_bList) != 2:
            # Disjoint
            ret_list.extend(results_aList_bList[0:2])
            del results_aList_bList[0:2]
        print "CLEAr"
        ret_list.extend(uptime(aList, bList, results_aList_bList))
    return ret_list
</code></pre>
<p>In your test case that you gave in the comments, it will return</p>
<pre><code>["00:00:01","22:00:00", "22:00:00","23:58:59"]
</code></pre>
<p>when passed in</p>
<pre><code>ListA = ["00:00:01","22:00:00"]
ListB = ["08:00:00", "09:00:00", "22:00:00","23:58:59"]
</code></pre>
</div>
<span class="comment-copy">So you want to get the values <code>aList</code> and <code>bList</code> both have?</span>
<span class="comment-copy">No, Moon Cheesez, the question is about intersection of times period, not intersection of lists. The end result should be a list of start&amp;stop times when least 1 service was running. If ListA = ["00:00:01","22:00:00"] and ListB = [“08:00:00”, “09:00:00”, ”22:00:00”,”23:58:59"] the final list would be ["00:00:01","23:58:59”]. (An end result of ["00:00:01","22:00:00", "22:00:00","23:58:59”] would also be acceptable, since it represents the same "uptime".)</span>
