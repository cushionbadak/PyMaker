<div class="post-text" itemprop="text">
<p>Is there a canonical way to emit multiple keys from a single item in the input sequence so that they form a continuous sequence and I don't need to use a <code>reduce(...)</code> just to flatten the sequence?</p>
<p>e.g. if I wanted to expand each digit in a series of numbers into individual numbers in a sequence</p>
<pre><code>[1,12,123,1234,12345] =&gt; [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
</code></pre>
<p>then I'd write some python that looked a bit like this:</p>
<pre><code>somedata = [1,12,123,1234,12345]

listified = map(lambda x:[int(c) for c in str(x)], somedata)
flattened = reduce(lambda x,y: x+y,listified,[])
</code></pre>
<p>but would prefer not to have to call the <code>flattened = reduce(...)</code> if there was a neater (or maybe more efficient) way to express this.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>map(func, *iterables)</code> will always call <code>func</code> as many times as the length of the shortest iterable (assuming no Exception is raised). Functions always return a single object.  So <code>list(map(func, *iterables))</code> will always have the same length as the shortest iterable. </p>
<p>Thus <code>list(map(lambda x:[int(c) for c in str(x)], somedata))</code> will always have the same length as <code>somedata</code>. There is no way around that. </p>
<p>If the desired result (e.g. <code>[1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]</code>) has more items than the input (e.g. <code>[1,12,123,1234,12345]</code>) then something other than <code>map</code> must be used to produce it.</p>
<p>You could, for example, use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable" rel="nofollow"><code>itertools.chain.from_iterable</code></a> to flatten 2 levels of nesting:</p>
<pre><code>In [31]: import itertools as IT

In [32]: somedata = [1,12,123,1234,12345]

In [33]: list(map(int, IT.chain.from_iterable(map(str, somedata))))
Out[33]: [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]
</code></pre>
<p>or, to flatten a list of lists, <code>sum(..., [])</code> suffices:</p>
<pre><code>In [44]: sum(map(lambda x:[int(c) for c in str(x)], somedata), [])
Out[44]: [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]
</code></pre>
<p>but note that this is much slower than using <code>IT.chain.from_iterable</code> (see below).</p>
<hr/>
<p>Here is a benchmark (using <a href="https://ipython.org/" rel="nofollow">IPython</a>'s <code>%timeit</code>) testing the various methods on a list of 10,000 integers from 0 to a million:</p>
<pre><code>In [4]: import random
In [8]: import functools
In [49]: somedata = [random.randint(0, 10**6) for i in range(10**4)]

In [50]: %timeit list(map(int, IT.chain.from_iterable(map(str, somedata))))
100 loops, best of 3: 9.35 ms per loop

In [13]: %timeit [int(i) for i in list(''.join(str(somedata)[1:-1].replace(', ','')))]
100 loops, best of 3: 12.2 ms per loop

In [52]: %timeit [int(j) for i in somedata for j in str(i)]
100 loops, best of 3: 12.3 ms per loop

In [51]: %timeit sum(map(lambda x:[int(c) for c in str(x)], somedata), [])
1 loop, best of 3: 869 ms per loop

In [9]: %timeit listified = map(lambda x:[int(c) for c in str(x)], somedata); functools.reduce(lambda x,y: x+y,listified,[])
1 loop, best of 3: 871 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Got two ideas, one with list comprehentions:</p>
<pre><code>print [int(j) for i in somedata for j in list(str(i)) ]
</code></pre>
<p>Something new (from comments), string is already iterable, so it would be:</p>
<pre><code>print [int(j) for i in somedata for j in str(i) ]
</code></pre>
<p>second with opertations on strings and list comprehentions:</p>
<pre><code>print [int(i) for i in list(''.join(str(somedata)[1:-1].replace(', ','')))]
</code></pre>
<p>output for both:</p>
<pre><code>[1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]
</code></pre>
</div>
<span class="comment-copy">you don't need to call <code>list</code> on <code>str</code>. <code>str(i)</code> is already iterable.</span>
