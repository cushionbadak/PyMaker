<div class="post-text" itemprop="text">
<p>In Python, I have the two lists of different sizes:</p>
<pre><code>x = [[0,5,10],[0,10,5]]
y = [100,500,900]
</code></pre>
<p>What is the comparison happening at each step when I run:</p>
<pre><code>print x&gt;y
</code></pre>
<p>e.g. How does it compare say the first element: [0,5,10] vs 100?</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python 3, you can't compare those two lists because their elements are not of comparable types.</p>
<p>In Python 2, lists are always greater than integers, period, so your <code>x</code> is always greater than your <code>y</code> regardless of what elements are in <code>x</code>'s sublists.</p>
</div>
<div class="post-text" itemprop="text">
<p>The real problem is how to compare <code>[0,5,10]</code> vs <code>100</code>, i.e, a list vs an integer.</p>
<p>The answer depends on the Python version. In Python 3.x, the two types can't be compared. In Python 2.x, lists are always greater than integers because the type names <code>list</code> is greater than <code>int</code>.</p>
<p>In your example, the <code>print</code> statement in</p>
<pre><code>print x&gt;y
</code></pre>
<p>suggests that you are using Python 2.x, so the answer is <code>x &gt; y</code> would be <code>True</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Those comparisons won't work. <code>list</code> and <code>int</code> can't be compared. So it won't work</p>
</div>
<div class="post-text" itemprop="text">
<p>Just to expand on the other answers, the documentation is pretty good on this stuff.  From <a href="https://docs.python.org/2.7/tutorial/datastructures.html" rel="nofollow">the 2.7 documentation</a>:</p>
<blockquote>
<p>Sequence objects may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal.</p>
</blockquote>
<p>From <a href="https://docs.python.org/3.5/tutorial/datastructures.html" rel="nofollow">the 3.5 documentation</a>:</p>
<blockquote>
<p>Sequence objects may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Essentially <code>x == y</code> uses the magic <code>__eq__</code> method on objects to compare them. Different objects will behave differently, and you can even define your own custom equalities, but in general comparing objects of different types will always evaluate to <code>False</code> (<a href="https://docs.python.org/2/reference/expressions.html#not-in" rel="nofollow">Python2</a> and <a href="https://docs.python.org/3/reference/expressions.html#not-in" rel="nofollow">Python3</a> docs).</p>
<p>So in your example, <code>[0,5,10] == 100</code> evaluates to <code>False</code>, not because it checked to see if the elements in the list were equal to <code>100</code>, but because the two types were incompatible.</p>
</div>
<span class="comment-copy">Test it, you will see</span>
