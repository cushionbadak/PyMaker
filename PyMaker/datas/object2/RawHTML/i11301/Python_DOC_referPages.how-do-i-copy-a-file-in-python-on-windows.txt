<div class="post-text" itemprop="text">
<p>How do I copy a file in Python?</p>
<p>I couldn't find anything under <a href="https://docs.python.org/2/library/os.html" rel="noreferrer"><code>os</code></a>.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a> has many methods you can use. One of which is:</p>
<pre><code>from shutil import copyfile

copyfile(src, dst)
</code></pre>
<p>Copy the contents of the file named <code>src</code> to a file named <code>dst</code>. The destination location must be writable; otherwise, an <code>IOError</code> exception will be raised. If <code>dst</code> already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function. <code>src</code> and <code>dst</code> are path names given as strings. </p>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-none prettyprint-override"><code>┌──────────────────┬───────────────┬──────────────────┬──────────────┬───────────┐
│     Function     │Copies metadata│Copies permissions│Can use buffer│Dest dir OK│
├──────────────────┼───────────────┼──────────────────┼──────────────┼───────────┤
│shutil.copy       │      No       │        Yes       │    No        │    Yes    │
│shutil.copyfile   │      No       │        No        │    No        │    No     │
│shutil.copy2      │      Yes      │        Yes       │    No        │    Yes    │
│shutil.copyfileobj│      No       │        No        │    Yes       │    No     │
└──────────────────┴───────────────┴──────────────────┴──────────────┴───────────┘
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/2/library/shutil.html#shutil.copy2" rel="noreferrer"><code>copy2(src,dst)</code></a> is often more useful than <a href="https://docs.python.org/2/library/shutil.html#shutil.copyfile" rel="noreferrer"><code>copyfile(src,dst)</code></a> because:</p>
<ul>
<li>it allows <code>dst</code> to be a <em>directory</em> (instead of the complete target filename), in which case the <a href="https://docs.python.org/2/library/os.path.html#os.path.basename" rel="noreferrer">basename</a> of <code>src</code> is used for creating the new file;</li>
<li>it preserves the original modification and access info (mtime and atime) in the file metadata (however, this comes with a slight overhead).</li>
</ul>
<p>Here is a short example:</p>
<pre><code>import shutil
shutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given
shutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Copying a file is a relatively straightforward operation as shown by the examples below, but you should instead use the <a href="https://docs.python.org/library/shutil.html" rel="noreferrer">shutil stdlib module</a> for that.</p>
<pre class="lang-py prettyprint-override"><code>def copyfileobj_example(source, dest, buffer_size=1024*1024):
    """      
    Copy a file from source to dest. source and dest
    must be file-like objects, i.e. any object with a read or
    write method, like for example StringIO.
    """
    while True:
        copy_buffer = source.read(buffer_size)
        if not copy_buffer:
            break
        dest.write(copy_buffer)
</code></pre>
<p>If you want to copy by filename you could do something like this:</p>
<pre class="lang-py prettyprint-override"><code>def copyfile_example(source, dest):
    # Beware, this example does not handle any edge cases!
    with open(source, 'rb') as src, open(dest, 'wb') as dst:
        copyfileobj_example(src, dst)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use one of the copy functions from the <a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a> package:</p>
<pre>
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Function              preserves     supports          accepts     copies other
                      permissions   directory dest.   file obj    metadata  
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
<a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="noreferrer">shutil.copy</a>              ✔             ✔                 ☐           ☐
<a href="https://docs.python.org/3/library/shutil.html#shutil.copy2" rel="noreferrer">shutil.copy2</a>             ✔             ✔                 ☐           ✔
<a href="https://docs.python.org/3/library/shutil.html#shutil.copyfile" rel="noreferrer">shutil.copyfile</a>          ☐             ☐                 ☐           ☐
<a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer">shutil.copyfileobj</a>       ☐             ☐                 ✔           ☐
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
</pre>
<p>Example:</p>
<pre><code>import shutil
shutil.copy('/etc/hostname', '/var/tmp/testhostname')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use the <a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer">shutil module</a>.</p>
<pre><code>copyfile(src, dst)
</code></pre>
<p>Copy the contents of the file named src to a file named dst. The destination location must be writable; otherwise, an IOError exception will be raised. If dst already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function. src and dst are path names given as strings.</p>
<p>Take a look at <a href="https://docs.python.org/3/library/filesys.html" rel="noreferrer">filesys</a> for all the file and directory handling functions available in standard Python modules.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python, you can copy the files using</p>
<ul>
<li><strong><a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a></strong> module</li>
<li><strong><a href="https://docs.python.org/3/library/os.html" rel="noreferrer"><code>os</code></a></strong> module</li>
<li><strong><a href="https://docs.python.org/3/library/subprocess.html" rel="noreferrer"><code>subprocess</code></a></strong> module</li>
</ul>
<hr/>
<pre><code>import os
import shutil
import subprocess
</code></pre>
<hr/>
<h3>1) Copying files using <a href="https://docs.python.org/3/library/shutil.html" rel="noreferrer"><code>shutil</code></a> module</h3>
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfile" rel="noreferrer"><code>shutil.copyfile</code></a></strong>  signature</p>
<pre><code>shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)

# example    
shutil.copyfile('source.txt', 'destination.txt')
</code></pre>
<hr/>
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copy" rel="noreferrer"><code>shutil.copy</code></a></strong>  signature</p>
<pre><code>shutil.copy(src_file, dest_file, *, follow_symlinks=True)

# example
shutil.copy('source.txt', 'destination.txt')
</code></pre>
<hr/>
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copy2" rel="noreferrer"><code>shutil.copy2</code></a></strong>  signature</p>
<pre><code>shutil.copy2(src_file, dest_file, *, follow_symlinks=True)

# example
shutil.copy2('source.txt', 'destination.txt')  
</code></pre>
<hr/>
<p><strong><a href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" rel="noreferrer"><code>shutil.copyfileobj</code></a></strong>  signature</p>
<pre><code>shutil.copyfileobj(src_file_object, dest_file_object[, length])

# example
file_src = 'source.txt'  
f_src = open(file_src, 'rb')

file_dest = 'destination.txt'  
f_dest = open(file_dest, 'wb')

shutil.copyfileobj(f_src, f_dest)  
</code></pre>
<hr/>
<h3>2) Copying files using <a href="https://docs.python.org/3/library/os.html" rel="noreferrer"><code>os</code></a> module</h3>
<p><strong><a href="https://docs.python.org/3/library/os.html#os.popen" rel="noreferrer"><code>os.popen</code></a></strong>  signature</p>
<pre><code>os.popen(cmd[, mode[, bufsize]])

# example
# In Unix/Linux
os.popen('cp source.txt destination.txt') 

# In Windows
os.popen('copy source.txt destination.txt')
</code></pre>
<hr/>
<p><strong><a href="https://docs.python.org/3/library/os.html#os.system" rel="noreferrer"><code>os.system</code></a></strong>  signature</p>
<pre><code>os.system(command)


# In Linux/Unix
os.system('cp source.txt destination.txt')  

# In Windows
os.system('copy source.txt destination.txt')
</code></pre>
<hr/>
<h3>3) Copying files using <a href="https://docs.python.org/3/library/subprocess.html" rel="noreferrer"><code>subprocess</code></a> module</h3>
<p><strong><a href="https://docs.python.org/3/library/subprocess.html#subprocess.call" rel="noreferrer"><code>subprocess.call</code></a></strong>  signature</p>
<pre><code>subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)

# example (WARNING: setting `shell=True` might be a security-risk)
# In Linux/Unix
status = subprocess.call('cp source.txt destination.txt', shell=True) 

# In Windows
status = subprocess.call('copy source.txt destination.txt', shell=True)
</code></pre>
<hr/>
<p><strong><a href="https://docs.python.org/3/library/subprocess.html#subprocess.check_output" rel="noreferrer"><code>subprocess.check_output</code></a></strong>  signature</p>
<pre><code>subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)

# example (WARNING: setting `shell=True` might be a security-risk)
# In Linux/Unix
status = subprocess.check_output('cp source.txt destination.txt', shell=True)

# In Windows
status = subprocess.check_output('copy source.txt destination.txt', shell=True)
</code></pre>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p>Directory and File copy example - From Tim Golden's Python Stuff:</p>
<p><a href="http://timgolden.me.uk/python/win32_how_do_i/copy-a-file.html" rel="noreferrer">http://timgolden.me.uk/python/win32_how_do_i/copy-a-file.html</a></p>
<pre><code>import os
import shutil
import tempfile

filename1 = tempfile.mktemp (".txt")
open (filename1, "w").close ()
filename2 = filename1 + ".copy"
print filename1, "=&gt;", filename2

shutil.copy (filename1, filename2)

if os.path.isfile (filename2): print "Success"

dirname1 = tempfile.mktemp (".dir")
os.mkdir (dirname1)
dirname2 = dirname1 + ".copy"
print dirname1, "=&gt;", dirname2

shutil.copytree (dirname1, dirname2)

if os.path.isdir (dirname2): print "Success"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Look at module <strong>shutil</strong>. 
It contains function <strong>copyfile</strong>(<em>src</em>, <em>dst</em>) </p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <code>os.system('cp nameoffilegeneratedbyprogram /otherdirectory/')</code></p>
<p>or as I did it,  </p>
<pre><code>os.system('cp '+ rawfile + ' rawdata.dat')
</code></pre>
<p>where <code>rawfile</code> is the name that I had generated inside the program.</p>
<p>This is a Linux only solution </p>
</div>
<div class="post-text" itemprop="text">
<p>For large files, what I did was read the file line by line and read each line into an array. Then, once the array reached a certain size, append it to a new file. </p>
<pre><code>for line in open("file.txt", "r"):
    list.append(line)
    if len(list) == 1000000: 
        output.writelines(list)
        del list[:]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-py prettyprint-override"><code>from subprocess import call
call("cp -p &lt;file&gt; &lt;file&gt;", shell=True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I suggest using <a href="https://stackoverflow.com/a/123212/6327658">Swati's</a> answer, but supposing you have a <strong>text file</strong> and don't want to use additional libraries in your code just to copy it, you can use the following one-liner:</p>
<pre><code>with open(source, 'r') as src, open(dest, 'w') as dst: dst.write(src.read())
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Firstly, I made an exhaustive cheatsheet of shutil methods for your reference.</p>
<pre><code>shutil_methods =
{'copy':['shutil.copyfileobj',
          'shutil.copyfile',
          'shutil.copymode',
          'shutil.copystat',
          'shutil.copy',
          'shutil.copy2',
          'shutil.copytree',],
 'move':['shutil.rmtree',
         'shutil.move',],
 'exception': ['exception shutil.SameFileError',
                 'exception shutil.Error'],
 'others':['shutil.disk_usage',
             'shutil.chown',
             'shutil.which',
             'shutil.ignore_patterns',]
}
</code></pre>
<p>Secondly, explain methods of copy in exmaples:</p>
<blockquote>
<ol>
<li><code>shutil.copyfileobj(fsrc, fdst[, length])</code> manipulate opened objects</li>
</ol>
</blockquote>
<pre><code>In [3]: src = '~/Documents/Head+First+SQL.pdf'
In [4]: dst = '~/desktop'
In [5]: shutil.copyfileobj(src, dst)
AttributeError: 'str' object has no attribute 'read'
#copy the file object
In [7]: with open(src, 'rb') as f1,open(os.path.join(dst,'test.pdf'), 'wb') as f2:
    ...:      shutil.copyfileobj(f1, f2)
In [8]: os.stat(os.path.join(dst,'test.pdf'))
Out[8]: os.stat_result(st_mode=33188, st_ino=8598319475, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067347, st_mtime=1516067335, st_ctime=1516067345)
</code></pre>
<blockquote>
<ol start="2">
<li><code>shutil.copyfile(src, dst, *, follow_symlinks=True)</code>  Copy and rename</li>
</ol>
</blockquote>
<pre><code>In [9]: shutil.copyfile(src, dst)
IsADirectoryError: [Errno 21] Is a directory: ~/desktop'
#so dst should be a filename instead of a directory name
</code></pre>
<blockquote>
<ol start="3">
<li><code>shutil.copy()</code>  Copy without preseving the metadata</li>
</ol>
</blockquote>
<pre><code>In [10]: shutil.copy(src, dst)
Out[10]: ~/desktop/Head+First+SQL.pdf'
#check their metadata
In [25]: os.stat(src)
Out[25]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066425, st_mtime=1493698739, st_ctime=1514871215)
In [26]: os.stat(os.path.join(dst, 'Head+First+SQL.pdf'))
Out[26]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066427, st_mtime=1516066425, st_ctime=1516066425)
# st_atime,st_mtime,st_ctime changed
</code></pre>
<blockquote>
<ol start="4">
<li><code>shutil.copy2()</code>  Copy with preseving the metadata</li>
</ol>
</blockquote>
<pre><code>In [30]: shutil.copy2(src, dst)
Out[30]: ~/desktop/Head+First+SQL.pdf'
In [31]: os.stat(src)
Out[31]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067055, st_mtime=1493698739, st_ctime=1514871215)
In [32]: os.stat(os.path.join(dst, 'Head+First+SQL.pdf'))
Out[32]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067063, st_mtime=1493698739, st_ctime=1516067055)
# Preseved st_mtime
</code></pre>
<blockquote>
<ol start="5">
<li>`shutil.copytree()``</li>
</ol>
</blockquote>
<p>Recursively copy an entire directory tree rooted at src, returning the destination directory</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>open(destination, 'wb').write(open(source, 'rb').read())
</code></pre>
<p>Open the source file in read mode, and write to destination file in write mode.</p>
<p>Above Code is self explanatory, anything to explain it more is like adding more overhead to the payload. </p>
<blockquote>
<p>Not all answers need explanation</p>
</blockquote>
</div>
<span class="comment-copy">It seems that cp is not a system call and therefore does not belong to the os module.  It is a shell command, so it is put in the shutil module.</span>
<span class="comment-copy">What is the difference between copy and copyfile?</span>
<span class="comment-copy">in copy(src, dst) the dst can be a directory.</span>
<span class="comment-copy">Note that not all metadata will be copied, depending on your platform.</span>
<span class="comment-copy">from shutil import copyFile ImportError: cannot import name copyFile</span>
<span class="comment-copy">@MonaJalal It's case sensitive, don't use capital F.</span>
<span class="comment-copy">Could also add that copy and copy2 accept directory as destination contrary to copyfile which require to specify the complete name.</span>
<span class="comment-copy">@jezrael Extracted from the doc: <code>dst must be the complete target file name; look at shutil.copy() for a copy that accepts a target directory path.</code> (here: <a href="https://docs.python.org/3/library/shutil.html#shutil.copyfile" rel="nofollow noreferrer">docs.python.org/3/library/shutil.html#shutil.copyfile</a>)</span>
<span class="comment-copy">Now this is just bad, bad API design.</span>
<span class="comment-copy">What does the "Dest dir OK" column indicate? Does it mean it doesn't check if the destination directory is OK before copying?</span>
<span class="comment-copy">According to your table the copyfile is totally useless !! while in the previous answer with 2115 votes, it's the first suggested !! and also this answer has got votes !! it's confusing !!!!</span>
<span class="comment-copy">Although the documentation warns that copy2 does not preserve all metadata, this is just what I needed as I wanted the items you list.  Thanks!</span>
<span class="comment-copy">Your answer is a bit deceptive. Your choice of words for <code>shutil.copy2('/dir/file.ext', '/new/dir')</code> suggests that copy2 will create a new directory. But in this case <code>dir</code> must already exist as a <b>directory</b> or else <code>file.ext</code> will be copied to a new <b>file</b> called <code>dir</code>.</span>
<span class="comment-copy">I am trying to randomly copy 100k files from 1 million files. <code>copyfile</code> is considerably faster than <code>copy2</code></span>
<span class="comment-copy">am I correct to assume that <code>shutil.copy2('/dir/file.ext', '/new/dir/')</code> (with slash after the target path) will remove the ambiguity over whether to copy to a new file called "dir" or to put the file into a directory of that name?</span>
<span class="comment-copy">@Vijay I believe this overhead is due to copying the metadata.</span>
<span class="comment-copy">I noticed a while ago that the module is called shutil (singular) and not shutils (plural), and indeed it <i>is</i> in Python 2.3. Nevertheless I leave this function here as an example.</span>
<span class="comment-copy">Copying a file's <i>contents</i> is a straightforward operation. Copying the file with its metadata is anything but straightforward, even more so if you want to be cross-platform.</span>
<span class="comment-copy">True. Looking at the shutil docs, the copyfile function also won't copy metadata.</span>
<span class="comment-copy">BTW, if you want to copy the contents between two file-like objects, there's <code>shutil.copyfileobj(fsrc, fdst)</code></span>
<span class="comment-copy">Yes, I'm not sure why you wouldn't just copy the source of <code>shutil.copyfileobj</code>.  Also, you don't have any <code>try, finally</code> to handle closing the files after exceptions.  I would say however, that your function shouldn't be responsible for opening and closing the files at all.  That should go in a wrapper function, like how <code>shutil.copyfile</code> wraps <code>shutil.copyfileobj</code>.</span>
<span class="comment-copy">Just curious, how did you generate that table?</span>
<span class="comment-copy">@lightalchemist I just used vim as a scratchpad, copied the used unicode symbols from a wikipedia table and copied the result into the stackoverflow editor for final polishing.</span>
<span class="comment-copy">Ok. For a moment I thought there was some emacs/vim magic going on that allows one to generate tables with unicode! Nevertheless thank you!</span>
<span class="comment-copy">this is not portable, and unnecessary since you can just use shutil.</span>
<span class="comment-copy">Even when <code>shutil</code> is not available - <code>subprocess.run()</code>  (without <code>shell=True</code>!) is the better alternative to <code>os.system()</code>.</span>
<span class="comment-copy">shutil is more portable</span>
<span class="comment-copy">this seems a little redundant since the writer should handle buffering. <code>for l in open('file.txt','r'): output.write(l)</code> should work find; just setup the output stream buffer to your needs. or you can go by the bytes by looping over a try with <code>output.write(read(n)); output.flush()</code> where <code>n</code> is the number of bytes you'd like to write at a time.  both of these also don't have an condition to check which is a bonus.</span>
<span class="comment-copy">Yes, but I thought that maybe this could be easier to understand because it copies entire lines rather than parts of them (in case we don't know how many bytes each line is).</span>
<span class="comment-copy">Very true. Coding for teaching  and coding for efficiency are very different.</span>
<span class="comment-copy">@owns To add to this question a year later, <code>writelines()</code> has shown slightly better performance over <code>write()</code> since we don't waste time consistently opening a new filestream, and instead write new lines as one large bytefeed.</span>
<span class="comment-copy">looking at the source - writelines calls write, <a href="https://hg.python.org/cpython/file/c6880edaf6f3/Modules/_io/bytesio.c" rel="nofollow noreferrer">hg.python.org/cpython/file/c6880edaf6f3/Modules/_io/bytesio.c</a>.  Also, the file stream is already open, so write wouldn't need to reopen it every time.</span>
<span class="comment-copy">This depends on the platform, so i would not use is.</span>
<span class="comment-copy">Such a <code>call</code> is unsecure. Please refere to the subproces docu about it.</span>
<span class="comment-copy">this is not portable, and unnecessary since you can just use shutil.</span>
<span class="comment-copy">Hmm why Python, then?</span>
<span class="comment-copy">Maybe detect the operating system before starting (whether it's DOS or Unix, because those are the two most used)</span>
<span class="comment-copy">This reads the complete source file into memory before writing it back. Thus, this unnecessarily wastes memory for all but the smallest file copy operations.</span>
<span class="comment-copy">Is that true? I think <code>.read()</code> and <code>.write()</code> are buffered by default (at least for CPython).</span>
<span class="comment-copy">Code only answers are discouraged. Please add some explanation as to how this solves the problem, or how this differs from the existing answers. <a href="https://stackoverflow.com/review/low-quality-posts/22545904">From Review</a></span>
<span class="comment-copy">The idea is nice and the code is beautiful, but a proper copy() function can do more things, such as copying attributes (+x bit), or for example deleting the already-copied bytes in case a disk-full condition is found.</span>
<span class="comment-copy"><b>All</b> answers need explanation, even if it is one sentence. No explanation sets bad precedent and is not helpful in understanding the program. What if a complete Python noob came along and saw this, wanted to use it, but couldn't because they don't understand it? You want to be helpful to all in your answers.</span>
