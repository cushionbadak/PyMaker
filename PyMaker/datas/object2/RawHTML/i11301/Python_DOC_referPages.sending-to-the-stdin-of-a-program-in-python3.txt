<div class="post-text" itemprop="text">
<p>I have to files, <strong>main.py</strong> and <strong>child.py</strong>.</p>
<p>I am trying to send a string to the stdin of <strong>main.py</strong>.</p>
<p>This is my incomplete code:</p>
<h1>main.py</h1>
<pre><code>from subprocess import *
import time

def main():
    program = Popen(['python.exe'. 'child.py', 'start'])
    while True: #waiting for'1' to be sent to the stdin
        if sys.stdin == '1':
            print('text)

if __name__ == '__main__':
    main()
</code></pre>
<h1>child.py</h1>
<pre><code>import sys

if sys.argv[1] == 'start':
    inp = input('Do you want to send the argument?\n').lower()
    if inp == 'no':
        sys.exit()
    elif inp == 'yes':
        #Somehow send '1' to the stdin of 1.py while it is running
</code></pre>
<p>I have no idea how to do this.</p>
<p>I am running windows 10 with python 3.5.1</p>
<p>-Thanks</p>
<p>EDIT:
When I am sending the argument back to main.py, I can not re-open the program. os.system re-opens the program which is not useful in my case.</p>
<p>These programs are a small demo of what I am trying to do. In my actual program, I am not able to do that as the two programs are "communicating" with each other an need to be open at all times.</p>
<p>What I need answered is a way to send an argument to main.py perhaps using stdin but when I am sending my argument, It can not re-open the program. Some examples like os.system re-open the program which is not what I am trying to do. I need main.py open at all times.</p>
<p>I have my new current code which is not working. A window pops up and then closes.</p>
<h1>main.py</h1>
<pre><code>from subprocess import Popen, PIPE, STDOUT
x = Popen(['python.exe', '2.py', 'start'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)
while x.poll() is None:
    if b'Do you want to send the argument?' in x.stdout.read():
        x.stdin.write(b'yes\n')
</code></pre>
<h1>child.py</h1>
<pre><code>import sys
import time
time.sleep(1)
if 1 = 1:
    inp = input('Do you want to send the argument?\n').lower()
    if inp == 'no':
        sys.exit()
    elif inp == 'yes':
        sys.stdout.write('1')
        sys.stdout.flush()
</code></pre>
<p>That is my code.</p>
</div>
<div class="post-text" itemprop="text">
<p>What you need is something along the lines of (in <code>main.py</code>):</p>
<pre><code>from subprocess import Popen, PIPE, STDOUT
x = Popen(['some_child.exe', 'parameter'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)

while x.poll() is None:
    child_output = x.stdout.readline()
    print(child_output)
    if b'Do you want to send the argument?' in child_output:
        x.stdin.write(b'yes\n')
        x.stdin.flush()
x.stdout.close()
x.stdin.close()
</code></pre>
<p>You're assuming <code>child.exe</code> (in your mockup demo, <code>python.exe</code>) is communicating with <code>main.py</code> via <code>sys.stdin/stdout</code>, however these I/O's are used to communicate with the shell that spawned the process.</p>
<p>Much like the childs <code>stdout/stdin</code> will be communicating with the shell that spawned that process, in this case <code>Popen()</code>.</p>
<p>Each spawned child process of <code>subprocess.Popen(...)</code> will be isolated with it's own <code>stdout/stdin/stderr</code>, otherwise every subprocess would make a huge mess of your main process stdout/stdin. This means you'll have to check for output on that particular subprocess and write to it accordingly as done in the above example.</p>
<p>One way to look at it is this:
<a href="https://i.stack.imgur.com/L2QWa.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/L2QWa.png"/></a></p>
<p>You're starting <code>main.py</code>, and you communicate with it via <code>sys.stdout</code> and <code>sys.stdin</code>. Each <code>input()</code> in <code>main.py</code> will output something to <code>sys.stdout</code> so you can read it.</p>
<p>Exactly the same logic applies to <code>child.exe</code> where every <code>input()</code> will output something to it's <code>sys.stdout</code> <em>(- But remember - <code>sys</code> is not a shared variable across processes)</em>.</p>
<pre><code>import sys

if sys.argv[1] == 'start':
    inp = input('Do you want to send the argument?\n').lower()
    if inp == 'no':
        sys.exit()
    elif inp == 'yes':
        #Somehow send '1' to the stdin of 1.py while it is running
        sys.stdout.write('1')
        sys.stdout.flush()
</code></pre>
<p>But a simple <code>print(1)</code> would do the same because it will essentially output the <code>1</code> to <code>sys.stdout</code> for you.</p>
<p>Edit 2018: Don't forget to close your inputs and outputs, as they might leave open file descriptors on your file system, hogging resources and causing problems later in life.</p>
<h2>Other conveyers of information</h2>
<p>Assuming you have control of the code to <code>child.exe</code> and you can modify the communication pipe in any way, some other options are:</p>
<ul>
<li>sockets - Use regular sockets to communicate, on *nix the most efficient would be Unix sockets.</li>
<li>Some other solutions can be found here: <a href="https://stackoverflow.com/q/18231415/929999">Best way to return a value from a python script</a></li>
</ul>
<h2>More cautionary tails!</h2>
<ul>
<li><p><code>.readline()</code> will assume there's a <code>\n</code> somewhere in your data, most likely at the end. I switched to <code>.readline()</code> for two reasons, <code>.read()</code> will hang and wait for <code>EOF</code> unless you specify exactly how many bytes to read, if I'm not out on a bicycle. To be able to read all kinds of output you need to incorporate <a href="https://docs.python.org/3/library/select.html" rel="nofollow noreferrer">select.select()</a> into your code - or a buffer of some sort where you call <code>x.stdout.read(1)</code> to read one byte at a time. Because if you try to read <code>.read(1024)</code> and there's not 1024 bytes in the buffer, your read will hang until there are 1024 characters.</p></li>
<li><p>I left a bug in your <code>child.py</code> code on purpose (mine works) - It's trivial and basic Python - in hopes that it's a learning experience on how to debug errors (you mentioned you're not good at it, this is a way to learn).</p></li>
</ul>
</div>
<span class="comment-copy">Why not just do <code>import child</code>?</span>
<span class="comment-copy">Generic question: why do you want to do this? What is the context?</span>
<span class="comment-copy">@VikasMadhusudana No, it's not: <code>Popen</code> already does that here. It's about passing stdout to the stdin of another program (in this case the parent), which in *nix parliance is shell related, not really Python.</span>
<span class="comment-copy">The way I'm using this program, I cant just import child. @Torxed</span>
<span class="comment-copy">The way main.py and child.py looks, yes you can because child would inherit <code>sys.argv</code> from the parent and there's also other ways to do regular python imports with custom arguments and global Variables.</span>
<span class="comment-copy">Okay, I kind of get what you mean. Could you give an example with using the stdout? @Torxed</span>
<span class="comment-copy">@nic there's an example at the top of my answer? It's not perfect because I'm coding on me phone. I can perfect the code in a sec.</span>
<span class="comment-copy">okay, can you give the example with both the two files code? The reason why I say anoth example is because child.py has no variable "x" as it dose not have main.py open as a variable "x". Thanks</span>
<span class="comment-copy">@SilentMonk Depending on what you mean with buffering in this case. Yes, if you do not empty the buffer of <code>x.stdout</code>, buffering will hang the process - There for it's extremely important to empty the IO buffer.</span>
<span class="comment-copy">@SilentMonk and yes, if the full output is not complete but in fact divided mid way my if statement won't catch the expected output. Kept it simple tho because OP is already confused about the IO. Should mention it tho.</span>
