<div class="post-text" itemprop="text">
<p>What's the best way, both aesthetically and from a performance perspective, to split a list of items into multiple lists based on a conditional? The equivalent of:</p>
<pre><code>good = [x for x in mylist if x in goodvals]
bad  = [x for x in mylist if x not in goodvals]
</code></pre>
<p>is there a more elegant way to do this?</p>
<p>Update: here's the actual use case, to better explain what I'm trying to do:</p>
<pre><code># files looks like: [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi'), ... ]
IMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')
images = [f for f in files if f[2].lower() in IMAGE_TYPES]
anims  = [f for f in files if f[2].lower() not in IMAGE_TYPES]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<pre><code>good = [x for x in mylist if x in goodvals]
bad  = [x for x in mylist if x not in goodvals]
</code></pre>
<p>is there a more elegant way to do this?</p>
</blockquote>
<p>That code is perfectly readable, and extremely clear!</p>
<pre><code># files looks like: [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi'), ... ]
IMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')
images = [f for f in files if f[2].lower() in IMAGE_TYPES]
anims  = [f for f in files if f[2].lower() not in IMAGE_TYPES]
</code></pre>
<p>Again, this is <em>fine!</em></p>
<p>There might be slight performance improvements using sets, but it's a trivial difference, and I find the list comprehension far easier to read, and you don't have to worry about the order being messed up, duplicates being removed as so on.</p>
<p>In fact, I may go another step "backward", and just use a simple for loop:</p>
<pre><code>images, anims = [], []

for f in files:
    if f.lower() in IMAGE_TYPES:
        images.append(f)
    else:
        anims.append(f)
</code></pre>
<p>The a list-comprehension or using <code>set()</code> is fine until you need to add some other check or another bit of logic - say you want to remove all 0-byte jpeg's, you just add something like..</p>
<pre><code>if f[1] == 0:
    continue
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>good, bad = [], []
for x in mylist:
    (bad, good)[x in goodvals].append(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's the lazy iterator approach:</p>
<pre><code>from itertools import tee

def split_on_condition(seq, condition):
    l1, l2 = tee((condition(item), item) for item in seq)
    return (i for p, i in l1 if p), (i for p, i in l2 if not p)
</code></pre>
<p>It evaluates the condition once per item and returns two generators, first yielding values from the sequence where the condition is true, the other where it's false.</p>
<p>Because it's lazy you can use it on any iterator, even an infinite one:</p>
<pre><code>from itertools import count, islice

def is_prime(n):
    return n &gt; 1 and all(n % i for i in xrange(2, n))

primes, not_primes = split_on_condition(count(), is_prime)
print("First 10 primes", list(islice(primes, 10)))
print("First 10 non-primes", list(islice(not_primes, 10)))
</code></pre>
<p>Usually though the non-lazy list returning approach is better:</p>
<pre><code>def split_on_condition(seq, condition):
    a, b = [], []
    for item in seq:
        (a if condition(item) else b).append(item)
    return a, b
</code></pre>
<p>Edit: For your more specific usecase of splitting items into different lists by some key, heres a generic function that does that:</p>
<pre><code>DROP_VALUE = lambda _:_
def split_by_key(seq, resultmapping, keyfunc, default=DROP_VALUE):
    """Split a sequence into lists based on a key function.

        seq - input sequence
        resultmapping - a dictionary that maps from target lists to keys that go to that list
        keyfunc - function to calculate the key of an input value
        default - the target where items that don't have a corresponding key go, by default they are dropped
    """
    result_lists = dict((key, []) for key in resultmapping)
    appenders = dict((key, result_lists[target].append) for target, keys in resultmapping.items() for key in keys)

    if default is not DROP_VALUE:
        result_lists.setdefault(default, [])
        default_action = result_lists[default].append
    else:
        default_action = DROP_VALUE

    for item in seq:
        appenders.get(keyfunc(item), default_action)(item)

    return result_lists
</code></pre>
<p>Usage:</p>
<pre><code>def file_extension(f):
    return f[2].lower()

split_files = split_by_key(files, {'images': IMAGE_TYPES}, keyfunc=file_extension, default='anims')
print split_files['images']
print split_files['anims']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Problem with all proposed solutions is that it will scan and apply the filtering function twice. I'd make a simple small function like this:</p>
<pre><code>def SplitIntoTwoLists(l, f):
  a = []
  b = []
  for i in l:
    if f(i):
      a.append(i)
    else:
      b.append(i)
 return (a,b)
</code></pre>
<p>That way you are not processing anything twice and also are not repeating code.</p>
</div>
<div class="post-text" itemprop="text">
<p>My take on it. I propose a lazy, single-pass, <code>partition</code> function,
which preserves relative order in the output subsequences.</p>
<h2>1. Requirements</h2>
<p>I assume that the requirements are:</p>
<ul>
<li>maintain elements' relative order (hence, no sets and
dictionaries)</li>
<li>evaluate condition only once for every element (hence not using
(<code>i</code>)<code>filter</code> or <code>groupby</code>)</li>
<li>allow for lazy consumption of either sequence (if we can afford to
precompute them, then the naïve implementation is likely to be
acceptable too)</li>
</ul>
<h2>2. <code>split</code> library</h2>
<p>My <code>partition</code> function (introduced below) and other similar functions
have made it into a small library:</p>
<ul>
<li><a href="https://bitbucket.org/astanin/python-split" rel="nofollow noreferrer">python-split</a></li>
</ul>
<p>It's installable normally via PyPI:</p>
<pre><code>pip install --user split
</code></pre>
<p>To split a list base on condition, use <code>partition</code> function:</p>
<pre><code>&gt;&gt;&gt; from split import partition
&gt;&gt;&gt; files = [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi') ]
&gt;&gt;&gt; image_types = ('.jpg','.jpeg','.gif','.bmp','.png')
&gt;&gt;&gt; images, other = partition(lambda f: f[-1] in image_types, files)
&gt;&gt;&gt; list(images)
[('file1.jpg', 33L, '.jpg')]
&gt;&gt;&gt; list(other)
[('file2.avi', 999L, '.avi')]
</code></pre>
<h2>3. <code>partition</code> function explained</h2>
<p>Internally we need to build two subsequences at once, so consuming
only one output sequence will force the other one to be computed
too. And we need to keep state between user requests (store processed
but not yet requested elements). To keep state, I use two double-ended
queues (<code>deques</code>):</p>
<pre><code>from collections import deque
</code></pre>
<p><code>SplitSeq</code> class takes care of the housekeeping:</p>
<pre><code>class SplitSeq:
    def __init__(self, condition, sequence):
        self.cond = condition
        self.goods = deque([])
        self.bads = deque([])
        self.seq = iter(sequence)
</code></pre>
<p>Magic happens in its <code>.getNext()</code> method. It is almost like <code>.next()</code>
of the iterators, but allows to specify which kind of element we want
this time. Behind the scene it doesn't discard the rejected elements,
but instead puts them in one of the two queues:</p>
<pre><code>    def getNext(self, getGood=True):
        if getGood:
            these, those, cond = self.goods, self.bads, self.cond
        else:
            these, those, cond = self.bads, self.goods, lambda x: not self.cond(x)
        if these:
            return these.popleft()
        else:
            while 1: # exit on StopIteration
                n = self.seq.next()
                if cond(n):
                    return n
                else:
                    those.append(n)
</code></pre>
<p>The end user is supposed to use <code>partition</code> function. It takes a
condition function and a sequence (just like <code>map</code> or <code>filter</code>), and
returns two generators. The first generator builds a subsequence of
elements for which the condition holds, the second one builds the
complementary subsequence. Iterators and generators allow for lazy
splitting of even long or infinite sequences.</p>
<pre><code>def partition(condition, sequence):
    cond = condition if condition else bool  # evaluate as bool if condition == None
    ss = SplitSeq(cond, sequence)
    def goods():
        while 1:
            yield ss.getNext(getGood=True)
    def bads():
        while 1:
            yield ss.getNext(getGood=False)
    return goods(), bads()
</code></pre>
<p>I chose the test function to be the first argument to facilitate
partial application in the future (similar to how <code>map</code> and <code>filter</code>
have the test function as the first argument).</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>First go</strong> (pre-OP-edit): Use sets:</p>
<pre><code>mylist = [1,2,3,4,5,6,7]
goodvals = [1,3,7,8,9]

myset = set(mylist)
goodset = set(goodvals)

print list(myset.intersection(goodset))  # [1, 3, 7]
print list(myset.difference(goodset))    # [2, 4, 5, 6]
</code></pre>
<p>That's good for both readability (IMHO) and performance.</p>
<p><strong>Second go</strong> (post-OP-edit):</p>
<p>Create your list of good extensions as a set:</p>
<pre><code>IMAGE_TYPES = set(['.jpg','.jpeg','.gif','.bmp','.png'])
</code></pre>
<p>and that will increase performance.  Otherwise, what you have looks fine to me.</p>
</div>
<div class="post-text" itemprop="text">
<p>I basically like Anders' approach as it is very general.  Here's a version that puts the categorizer first (to match filter syntax) and uses a defaultdict (assumed imported).</p>
<pre><code>def categorize(func, seq):
    """Return mapping from categories to lists
    of categorized items.
    """
    d = defaultdict(list)
    for item in seq:
        d[func(item)].append(item)
    return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><a href="http://docs.python.org/library/itertools.html#itertools.groupby" rel="noreferrer">itertools.groupby</a> almost does what you want, except it requires the items to be sorted to ensure that you get a single contiguous range, so you need to sort by your key first (otherwise you'll get multiple interleaved groups for each type).  eg.</p>
<pre><code>def is_good(f):
    return f[2].lower() in IMAGE_TYPES

files = [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi'), ('file3.gif', 123L, '.gif')]

for key, group in itertools.groupby(sorted(files, key=is_good), key=is_good):
    print key, list(group)
</code></pre>
<p>gives:</p>
<pre><code>False [('file2.avi', 999L, '.avi')]
True [('file1.jpg', 33L, '.jpg'), ('file3.gif', 123L, '.gif')]
</code></pre>
<p>Similar to the other solutions, the key func can be defined to divide into any number of groups you want.</p>
</div>
<div class="post-text" itemprop="text">
<p>Personally, I like the version you cited, assuming you already have a list of <code>goodvals</code> hanging around.  If not, something like:</p>
<pre><code>good = filter(lambda x: is_good(x), mylist)
bad = filter(lambda x: not is_good(x), mylist)
</code></pre>
<p>Of course, that's really very similar to using a list comprehension like you originally did, but with a function instead of a lookup:</p>
<pre><code>good = [x for x in mylist if is_good(x)]
bad  = [x for x in mylist if not is_good(x)]
</code></pre>
<p>In general, I find the aesthetics of list comprehensions to be very pleasing.  Of course, if you don't actually need to preserve ordering and don't need duplicates, using the <code>intersection</code> and <code>difference</code> methods on sets would work well too.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to make it in FP style:</p>
<pre><code>good, bad = [ sum(x, []) for x in zip(*(([y], []) if y in goodvals else ([], [y])
                                        for y in mylist)) ]
</code></pre>
<p>Not the most readable solution, but at least iterates through mylist only once.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def partition(pred, iterable):
    'Use a predicate to partition entries into false entries and true entries'
    # partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9
    t1, t2 = tee(iterable)
    return filterfalse(pred, t1), filter(pred, t2)
</code></pre>
<p>Check <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow">this</a></p>
</div>
<div class="post-text" itemprop="text">
<p>I think a generalization of splitting a an iterable based on N conditions is handy</p>
<pre><code>from collections import OrderedDict
def partition(iterable,*conditions):
    '''Returns a list with the elements that satisfy each of condition.
       Conditions are assumed to be exclusive'''
    d= OrderedDict((i,list())for i in range(len(conditions)))        
    for e in iterable:
        for i,condition in enumerate(conditions):
            if condition(e):
                d[i].append(e)
                break                    
    return d.values()
</code></pre>
<p>For instance: </p>
<pre><code>ints,floats,other = partition([2, 3.14, 1, 1.69, [], None],
                              lambda x: isinstance(x, int), 
                              lambda x: isinstance(x, float),
                              lambda x: True)

print " ints: {}\n floats:{}\n other:{}".format(ints,floats,other)

 ints: [2, 1]
 floats:[3.14, 1.69]
 other:[[], None]
</code></pre>
<p>If the element may satisfy multiple conditions, remove the break. </p>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes, it looks like list comprehension is not the best thing to use !</p>
<p>I made a little test based on the answer people gave to this topic, tested on a random generated list. Here is the generation of the list (there's probably a better way to do, but it's not the point) :</p>
<pre><code>good_list = ('.jpg','.jpeg','.gif','.bmp','.png')

import random
import string
my_origin_list = []
for i in xrange(10000):
    fname = ''.join(random.choice(string.lowercase) for i in range(random.randrange(10)))
    if random.getrandbits(1):
        fext = random.choice(good_list)
    else:
        fext = "." + ''.join(random.choice(string.lowercase) for i in range(3))

    my_origin_list.append((fname + fext, random.randrange(1000), fext))
</code></pre>
<p>And here we go</p>
<pre><code># Parand
def f1():
    return [e for e in my_origin_list if e[2] in good_list], [e for e in my_origin_list if not e[2] in good_list]

# dbr
def f2():
    a, b = list(), list()
    for e in my_origin_list:
        if e[2] in good_list:
            a.append(e)
        else:
            b.append(e)
    return a, b

# John La Rooy
def f3():
    a, b = list(), list()
    for e in my_origin_list:
        (b, a)[e[2] in good_list].append(e)
    return a, b

# Ants Aasma
def f4():
    l1, l2 = tee((e[2] in good_list, e) for e in my_origin_list)
    return [i for p, i in l1 if p], [i for p, i in l2 if not p]

# My personal way to do
def f5():
    a, b = zip(*[(e, None) if e[2] in good_list else (None, e) for e in my_origin_list])
    return list(filter(None, a)), list(filter(None, b))

# BJ Homer
def f6():
    return filter(lambda e: e[2] in good_list, my_origin_list), filter(lambda e: not e[2] in good_list, my_origin_list)
</code></pre>
<p>Using the <a href="https://gist.github.com/sekimura/660557" rel="nofollow" title="cmpthese function">cmpthese</a> function, the best result is the dbr answer :</p>
<pre><code>f1     204/s  --    -5%   -14%   -15%   -20%   -26%
f6     215/s     6%  --    -9%   -11%   -16%   -22%
f3     237/s    16%    10%  --    -2%    -7%   -14%
f4     240/s    18%    12%     2%  --    -6%   -13%
f5     255/s    25%    18%     8%     6%  --    -8%
f2     277/s    36%    29%    17%    15%     9%  --
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yet another solution to this problem. I needed a solution that is as fast as possible. That means only one iteration over the list and preferably O(1) for adding data to one of the resulting lists. This is very similar to the solution provided by <em>sastanin</em>, except much shorter:</p>
<pre><code>from collections import deque

def split(iterable, function):
    dq_true = deque()
    dq_false = deque()

    # deque - the fastest way to consume an iterator and append items
    deque((
      (dq_true if function(item) else dq_false).append(item) for item in iterable
    ), maxlen=0)

    return dq_true, dq_false
</code></pre>
<p>Then, you can use the function in the following way:</p>
<pre><code>lower, higher = split([0,1,2,3,4,5,6,7,8,9], lambda x: x &lt; 5)

selected, other = split([0,1,2,3,4,5,6,7,8,9], lambda x: x in {0,4,9})
</code></pre>
<p>If you're not fine with the resulting <code>deque</code> object, you can easily convert it to <code>list</code>, <code>set</code>, whatever you like (for example <code>list(lower)</code>). The conversion is much faster, that construction of the lists directly.</p>
<p>This methods keeps order of the items, as well as any duplicates.</p>
</div>
<div class="post-text" itemprop="text">
<p>For perfomance, try <code>itertools</code>.</p>
<blockquote>
<p>The <a href="http://docs.python.org/library/itertools.html" rel="nofollow noreferrer">itertools</a> module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an “iterator algebra” making it possible to construct specialized tools succinctly and efficiently in pure Python.</p>
</blockquote>
<p>See <a href="http://docs.python.org/library/itertools.html#itertools.ifilter" rel="nofollow noreferrer">itertools.ifilter</a> or imap.</p>
<blockquote>
<p>itertools.ifilter(predicate, iterable)</p>
<p>Make an iterator that filters elements from iterable returning only those for which the predicate is True</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>Sometimes you won't need that other half of the list.
For example:</p>
<pre><code>import sys
from itertools import ifilter

trustedPeople = sys.argv[1].split(',')
newName = sys.argv[2]

myFriends = ifilter(lambda x: x.startswith('Shi'), trustedPeople)

print '%s is %smy friend.' % (newName, newName not in myFriends 'not ' or '')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Inspired by @gnibbler's <a href="https://stackoverflow.com/a/12135169/182469">great (but terse!) answer</a>, we can apply that approach to map to multiple partitions:</p>
<pre><code>from collections import defaultdict

def splitter(l, mapper):
    """Split an iterable into multiple partitions generated by a callable mapper."""

    results = defaultdict(list)

    for x in l:
        results[mapper(x)] += [x]

    return results
</code></pre>
<p>Then <code>splitter</code> can then be used as follows:</p>
<pre><code>&gt;&gt;&gt; l = [1, 2, 3, 4, 2, 3, 4, 5, 6, 4, 3, 2, 3]
&gt;&gt;&gt; split = splitter(l, lambda x: x % 2 == 0)  # partition l into odds and evens
&gt;&gt;&gt; split.items()
&gt;&gt;&gt; [(False, [1, 3, 3, 5, 3, 3]), (True, [2, 4, 2, 4, 6, 4, 2])]
</code></pre>
<p>This works for more than two partitions with a more complicated mapping (and on iterators, too):</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; l = xrange(1, 23)
&gt;&gt;&gt; split = splitter(l, lambda x: int(math.log10(x) * 5))
&gt;&gt;&gt; split.items()
[(0, [1]),
 (1, [2]),
 (2, [3]),
 (3, [4, 5, 6]),
 (4, [7, 8, 9]),
 (5, [10, 11, 12, 13, 14, 15]),
 (6, [16, 17, 18, 19, 20, 21, 22])]
</code></pre>
<p>Or using a dictionary to map:</p>
<pre><code>&gt;&gt;&gt; map = {'A': 1, 'X': 2, 'B': 3, 'Y': 1, 'C': 2, 'Z': 3}
&gt;&gt;&gt; l = ['A', 'B', 'C', 'C', 'X', 'Y', 'Z', 'A', 'Z']
&gt;&gt;&gt; split = splitter(l, map.get)
&gt;&gt;&gt; split.items()
(1, ['A', 'Y', 'A']), (2, ['C', 'C', 'X']), (3, ['B', 'Z', 'Z'])]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is the fastest way.</p>
<p>It uses <code>if else</code>, (like dbr's answer) but creates a set first. A set reduces the number of operations from O(m * n) to O(log m) + O(n), resulting in a 45%+ boost in speed.</p>
<pre><code>good_list_set = set(good_list)  # 45% faster than a tuple.

good, bad = [], []
for item in my_origin_list:
    if item in good_list_set:
        good.append(item)
    else:
        bad.append(item)
</code></pre>
<p>A little shorter:</p>
<pre><code>good_list_set = set(good_list)  # 45% faster than a tuple.

good, bad = [], []
for item in my_origin_list:
    out = good if item in good_list_set else bad
    out.append(item)
</code></pre>
<p>Benchmark results:</p>
<pre><code>filter_BJHomer                  80/s       --   -3265%   -5312%   -5900%   -6262%   -7273%   -7363%   -8051%   -8162%   -8244%
zip_Funky                       118/s    4848%       --   -3040%   -3913%   -4450%   -5951%   -6085%   -7106%   -7271%   -7393%
two_lst_tuple_JohnLaRoy         170/s   11332%    4367%       --   -1254%   -2026%   -4182%   -4375%   -5842%   -6079%   -6254%
if_else_DBR                     195/s   14392%    6428%    1434%       --    -882%   -3348%   -3568%   -5246%   -5516%   -5717%
two_lst_compr_Parand            213/s   16750%    8016%    2540%     967%       --   -2705%   -2946%   -4786%   -5083%   -5303%
if_else_1_line_DanSalmo         292/s   26668%   14696%    7189%    5033%    3707%       --    -331%   -2853%   -3260%   -3562%
tuple_if_else                   302/s   27923%   15542%    7778%    5548%    4177%     343%       --   -2609%   -3029%   -3341%
set_1_line                      409/s   41308%   24556%   14053%   11035%    9181%    3993%    3529%       --    -569%    -991%
set_shorter                     434/s   44401%   26640%   15503%   12303%   10337%    4836%    4345%     603%       --    -448%
set_if_else                     454/s   46952%   28358%   16699%   13349%   11290%    5532%    5018%    1100%     469%       --
</code></pre>
<p>The full benchmark code for Python 3.7 (modified from FunkySayu):</p>
<pre><code>good_list = ['.jpg','.jpeg','.gif','.bmp','.png']

import random
import string
my_origin_list = []
for i in range(10000):
    fname = ''.join(random.choice(string.ascii_lowercase) for i in range(random.randrange(10)))
    if random.getrandbits(1):
        fext = random.choice(list(good_list))
    else:
        fext = "." + ''.join(random.choice(string.ascii_lowercase) for i in range(3))

    my_origin_list.append((fname + fext, random.randrange(1000), fext))

# Parand
def two_lst_compr_Parand(*_):
    return [e for e in my_origin_list if e[2] in good_list], [e for e in my_origin_list if not e[2] in good_list]

# dbr
def if_else_DBR(*_):
    a, b = list(), list()
    for e in my_origin_list:
        if e[2] in good_list:
            a.append(e)
        else:
            b.append(e)
    return a, b

# John La Rooy
def two_lst_tuple_JohnLaRoy(*_):
    a, b = list(), list()
    for e in my_origin_list:
        (b, a)[e[2] in good_list].append(e)
    return a, b

# # Ants Aasma
# def f4():
#     l1, l2 = tee((e[2] in good_list, e) for e in my_origin_list)
#     return [i for p, i in l1 if p], [i for p, i in l2 if not p]

# My personal way to do
def zip_Funky(*_):
    a, b = zip(*[(e, None) if e[2] in good_list else (None, e) for e in my_origin_list])
    return list(filter(None, a)), list(filter(None, b))

# BJ Homer
def filter_BJHomer(*_):
    return list(filter(lambda e: e[2] in good_list, my_origin_list)), list(filter(lambda e: not e[2] in good_list,                                                                             my_origin_list))

# ChaimG's answer; as a list.
def if_else_1_line_DanSalmo(*_):
    good, bad = [], []
    for e in my_origin_list:
        _ = good.append(e) if e[2] in good_list else bad.append(e)
    return good, bad

# ChaimG's answer; as a set.
def set_1_line(*_):
    good_list_set = set(good_list)
    good, bad = [], []
    for e in my_origin_list:
        _ = good.append(e) if e[2] in good_list_set else bad.append(e)
    return good, bad

# ChaimG set and if else list.
def set_shorter(*_):
    good_list_set = set(good_list)
    good, bad = [], []
    for e in my_origin_list:
        out = good if e[2] in good_list_set else bad
        out.append(e)
    return good, bad

# ChaimG's best answer; if else as a set.
def set_if_else(*_):
    good_list_set = set(good_list)
    good, bad = [], []
    for e in my_origin_list:
        if e[2] in good_list_set:
            good.append(e)
        else:
            bad.append(e)
    return good, bad

# ChaimG's best answer; if else as a set.
def tuple_if_else(*_):
    good_list_tuple = tuple(good_list)
    good, bad = [], []
    for e in my_origin_list:
        if e[2] in good_list_tuple:
            good.append(e)
        else:
            bad.append(e)
    return good, bad

def cmpthese(n=0, functions=None):
    results = {}
    for func_name in functions:
        args = ['%s(range(256))' % func_name, 'from __main__ import %s' % func_name]
        t = Timer(*args)
        results[func_name] = 1 / (t.timeit(number=n) / n) # passes/sec

    functions_sorted = sorted(functions, key=results.__getitem__)
    for f in functions_sorted:
        diff = []
        for func in functions_sorted:
            if func == f:
                diff.append("--")
            else:
                diff.append(f"{results[f]/results[func]*100 - 100:5.0%}")
        diffs = " ".join(f'{x:&gt;8s}' for x in diff)

        print(f"{f:27s} \t{results[f]:,.0f}/s {diffs}")


if __name__=='__main__':
    from timeit import Timer
cmpthese(1000, 'two_lst_compr_Parand if_else_DBR two_lst_tuple_JohnLaRoy zip_Funky filter_BJHomer if_else_1_line_DanSalmo set_1_line set_if_else tuple_if_else set_shorter'.split(" "))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you insist on clever, you could take Winden's solution and just a bit spurious cleverness:</p>
<pre><code>def splay(l, f, d=None):
  d = d or {}
  for x in l: d.setdefault(f(x), []).append(x)
  return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If your concern is not to use two lines of code for an operation whose semantics only need once you just wrap some of the approaches above (even your own) in a single function:</p>
<pre><code>def part_with_predicate(l, pred):
    return [i for i in l if pred(i)], [i for i in l if not pred(i)]
</code></pre>
<p>It is not a lazy-eval approach and it does iterate twice through the list, but it allows you to partition the list in one line of code.</p>
</div>
<div class="post-text" itemprop="text">
<p>Already quite a few solutions here, but yet another way of doing that would be -</p>
<pre><code>anims = []
images = [f for f in files if (lambda t: True if f[2].lower() in IMAGE_TYPES else anims.append(t) and False)(f)]
</code></pre>
<p>Iterates over the list only once, and looks a bit more pythonic and hence readable to me. </p>
<pre><code>&gt;&gt;&gt; files = [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi'), ('file1.bmp', 33L, '.bmp')]
&gt;&gt;&gt; IMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')
&gt;&gt;&gt; anims = []
&gt;&gt;&gt; images = [f for f in files if (lambda t: True if f[2].lower() in IMAGE_TYPES else anims.append(t) and False)(f)]
&gt;&gt;&gt; print '\n'.join([str(anims), str(images)])
[('file2.avi', 999L, '.avi')]
[('file1.jpg', 33L, '.jpg'), ('file1.bmp', 33L, '.bmp')]
&gt;&gt;&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I'd take a 2-pass approach, separating evaluation of the predicate from filtering the list:</p>
<pre><code>def partition(pred, iterable):
    xs = list(zip(map(pred, iterable), iterable))
    return [x[1] for x in xs if x[0]], [x[1] for x in xs if not x[0]]
</code></pre>
<p>What's nice about this, performance-wise (in addition to evaluating <code>pred</code> only once on each member of <code>iterable</code>), is that it moves a lot of logic out of the interpreter and into highly-optimized iteration and mapping code. This can speed up iteration over long iterables, as described <a href="https://stackoverflow.com/a/25881130/3408454">in this answer</a>.</p>
<p>Expressivity-wise, it takes advantage of expressive idioms like comprehensions and mapping.</p>
</div>
<div class="post-text" itemprop="text">
<h1>solution</h1>
<pre><code>from itertools import tee

def unpack_args(fn):
    return lambda t: fn(*t)

def separate(fn, lx):
    return map(
        unpack_args(
            lambda i, ly: filter(
                lambda el: bool(i) == fn(el),
                ly)),
        enumerate(tee(lx, 2)))
</code></pre>
<h1>test</h1>
<pre><code>[even, odd] = separate(
    lambda x: bool(x % 2),
    [1, 2, 3, 4, 5])
print(list(even) == [2, 4])
print(list(odd) == [1, 3, 5])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you don't mind using an external library there two I know that nativly implement this operation:</p>
<pre><code>&gt;&gt;&gt; files = [ ('file1.jpg', 33, '.jpg'), ('file2.avi', 999, '.avi')]
&gt;&gt;&gt; IMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')
</code></pre>
<ul>
<li><p><a href="http://iteration-utilities.readthedocs.io/en/latest/generated/partition.html" rel="nofollow noreferrer"><code>iteration_utilities.partition</code></a>:</p>
<pre><code>&gt;&gt;&gt; from iteration_utilities import partition
&gt;&gt;&gt; notimages, images = partition(files, lambda x: x[2].lower() in IMAGE_TYPES)
&gt;&gt;&gt; notimages
[('file2.avi', 999, '.avi')]
&gt;&gt;&gt; images
[('file1.jpg', 33, '.jpg')]
</code></pre></li>
<li><p><a href="http://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.partition" rel="nofollow noreferrer"><code>more_itertools.partition</code></a></p>
<pre><code>&gt;&gt;&gt; from more_itertools import partition
&gt;&gt;&gt; notimages, images = partition(lambda x: x[2].lower() in IMAGE_TYPES, files)
&gt;&gt;&gt; list(notimages)  # returns a generator so you need to explicitly convert to list.
[('file2.avi', 999, '.avi')]
&gt;&gt;&gt; list(images)
[('file1.jpg', 33, '.jpg')]
</code></pre></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Not sure if this is a good approach but it can be done in this way as well</p>
<pre><code>IMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')
files = [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi')]
images, anims = reduce(lambda (i, a), f: (i + [f], a) if f[2] in IMAGE_TYPES else (i, a + [f]), files, ([], []))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For example, splitting list by even and odd</p>
<pre><code>arr = range(20)
even, odd = reduce(lambda res, next: res[next % 2].append(next) or res, arr, ([], []))
</code></pre>
<p>Or in general:</p>
<pre><code>def split(predicate, iterable):
    return reduce(lambda res, e: res[predicate(e)].append(e) or res, iterable, ([], []))
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Shortest posible way</li>
<li>Predicate applies only once for each element</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>Requires knowledge of functional programing paradigm</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>If the list is made of groups and intermittent separators, you can use:</p>
<pre class="lang-py prettyprint-override"><code>def split(items, p):
    groups = [[]]
    for i in items:
        if p(i):
            groups.append([])
        groups[-1].append(i)
    return groups
</code></pre>
<p>Usage:</p>
<pre class="lang-py prettyprint-override"><code>split(range(1,11), lambda x: x % 3 == 0)
# gives [[1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def partition(pred, seq):
  return reduce( lambda (yes, no), x: (yes+[x], no) if pred(x) else (yes, no+[x]), seq, ([], []) )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>My favorite recipe for this is: </p>
<pre><code>goodvals = set(goodvals)    # Turbocharges the performance by 55%!  
good, bad = [], []
_ = [good.append(x) if x in goodvals else bad.append(x) for x in mylist]
</code></pre>
<p>Simple, fast, and readable; the way Python was meant to be.</p>
<ul>
<li>By making <code>goodvals</code> into a <code>set</code> (which uses a hash table) instead of a
<code>tuple</code>, we get super fast lookups. </li>
<li>Each item in <code>mylist</code> is checked only
once. this helps make it faster.</li>
<li><code>_ =</code> is a Pythonic way to declare that we are discarding the result of the list comprehension on purpose. It's not a bug.</li>
</ul>
<p>(Based on dansalmo's comment to <a href="https://stackoverflow.com/a/12135169/2529619">this</a> answer, because it seems to deserve to be its own answer.)</p>
<p><strong>EDIT:</strong> </p>
<p>Converting <code>goodvals</code> into a set turbocharges performance by 55% on my benchmark. Using a <code>tuple</code> is O(n * m), while converting it into a <code>set</code> is O(log n + m). </p>
<p>Besides, <code>goodvals</code>, (i.e. n), is only five items long. <code>mylist</code>, (i.e. m), can have hundreds of items. Furthermore, creating a set is probably highly optimized under the hood in C language code.</p>
<p>Here is the benchmark code that I used. It is based on code taken from <a href="https://stackoverflow.com/a/31448772/2529619">this</a> answer and modified to work with Python v3.7.0 running on Windows 7. </p>
<pre><code>good_list = ['.jpg','.jpeg','.gif','.bmp','.png']

import random
import string
my_origin_list = []
for i in range(10000):
    fname = ''.join(random.choice(string.ascii_lowercase) for i in range(random.randrange(10)))
    if random.getrandbits(1):
        fext = random.choice(list(good_list))
    else:
        fext = "." + ''.join(random.choice(string.ascii_lowercase) for i in range(3))

    my_origin_list.append((fname + fext, random.randrange(1000), fext))

# Parand
def f1(*_):
    return [e for e in my_origin_list if e[2] in good_list], [e for e in my_origin_list if not e[2] in good_list]

# dbr
def f2(*_):
    a, b = list(), list()
    for e in my_origin_list:
        if e[2] in good_list:
            a.append(e)
        else:
            b.append(e)
    return a, b

# John La Rooy
def f3(*_):
    a, b = list(), list()
    for e in my_origin_list:
        (b, a)[e[2] in good_list].append(e)
    return a, b

# # Ants Aasma
# def f4():
#     l1, l2 = tee((e[2] in good_list, e) for e in my_origin_list)
#     return [i for p, i in l1 if p], [i for p, i in l2 if not p]

# My personal way to do
def f5(*_):
    a, b = zip(*[(e, None) if e[2] in good_list else (None, e) for e in my_origin_list])
    return list(filter(None, a)), list(filter(None, b))

# BJ Homer
def f6(*_):
    return list(filter(lambda e: e[2] in good_list, my_origin_list)), list(filter(lambda e: not e[2] in good_list,                                                                             my_origin_list))

# ChaimG's answer; as a list.
def f7(*_):
    good, bad = [], []
    for e in my_origin_list:
        _ = good.append(e) if e[2] in good_list else bad.append(e)
    return good, bad

# ChaimG's answer; as a set.
def f8(*_):
    good, bad = [], []
    good_list_set = set(good_list)
    for e in my_origin_list:
        _ = good.append(e) if e[2] in good_list_set else bad.append(e)
    return good, bad

def cmpthese(n=0, functions=None):
    results = {}
    for func_name in functions:
        args = ['%s(range(256))' % func_name, 'from __main__ import %s' % func_name]
        t = Timer(*args)
        results[func_name] = 1 / (t.timeit(number=n) / n) # passes/sec

    functions_sorted = sorted(functions, key=results.__getitem__)
    for f in functions_sorted:
        diff = []
        for func in functions_sorted:
            if func == f:
                diff.append("    --")
            else:
                diff.append("%5.0f%%" % (results[f]/results[func]*100 - 100))
        diffs = " ".join(diff)

        print("%s\t%6d/s %s" % (f, results[f], diffs))


if __name__=='__main__':
    from timeit import Timer
cmpthese(1000, 'f1 f2 f3 f5 f6 f7 f8'.split(" "))
</code></pre>
</div>
<span class="comment-copy">landed here looking for a way to have a condition in the set builder statement, your question answered my question :)</span>
<span class="comment-copy"><i>split</i> is an unfortunate description of this operation, since it already has a specific meaning with respect to Python strings. I think <i>divide</i> is a more precise (or at least less overloaded in the context of Python iterables) word to describe this operation. I landed here looking for a list equivalent of <code>str.split()</code>, to <i>split</i> the list into an ordered collection of consecutive sub-lists. E.g. <code>split([1,2,3,4,5,3,6], 3) -&gt; ([1,2],[4,5],[6])</code>, as opposed to <i>dividing</i> a list's elements by category.</span>
<span class="comment-copy"><a href="http://www.gossamer-threads.com/lists/engine?do=post_view_flat;post=1065226;page=1;mh=-1;list=python;sb=post_latest_reply;so=ASC" rel="nofollow noreferrer">Discussion</a> of the same topic on python-list.</span>
<span class="comment-copy">IMAGE_TYPES should be a set instead of a tuple: <code>IMAGE_TYPES = set('.jpg','.jpeg','.gif','.bmp','.png')</code>. n(1) instead of n(o/2), with practically no difference in readability.</span>
<span class="comment-copy">Isn't there a list comprehension way without having to loop through the list twice?</span>
<span class="comment-copy">The problem is that this violates the DRY principle. It'd be nice if there was a better way to do this.</span>
<span class="comment-copy">Once the appetite for functional programming (Haskell), or functional style (LINQ) is raised, we start to smell Python for its age - <code>[x for x in blah if ...]</code> - verbose, <code>lambda</code> is clumsy and limited... It feels like driving the coolest car from 1995 today. Not the same as back then.</span>
<span class="comment-copy">@TomaszGandor FTR, Haskell is <i>older</i> than Python (and actually influenced its design). I think the syntax for list comprehension and lambdas was deliberately kept a bit on the verbose side, perhaps to discourage over-using them. Which is indeed a bit of a risk... as much as I like Haskell, I can see why many people find Python generally more readable.</span>
<span class="comment-copy">the simple for loop is the best way to do this... a single loop, very clear and readable</span>
<span class="comment-copy">That is incredibly ingenious! It took me a while to understand what was happening though. I'd like to know if others think this can be considered readable code or not.</span>
<span class="comment-copy"><code>good.append(x) if x in goodvals else bad.append(x)</code> is more readable.</span>
<span class="comment-copy">@dansalmo Especially since you can make it a one-liner with the for-cycle, and if you wanted to append something more complicated than <code>x</code>, you can make it into one <code>append</code> only: <code>for x in mylist: (good if isgood(x) else bad).append(x)</code></span>
<span class="comment-copy">@dansalmo  "more readable" . Yes. But not more fun.</span>
<span class="comment-copy">This code, altough witty, isn't readable.</span>
<span class="comment-copy">That's a lot of code to replace two list comprehensions..</span>
<span class="comment-copy">You're probably right that this violates the YAGNI principle. It is based on the assumption that number of different lists that things can be partitioned into will grow in the future.</span>
<span class="comment-copy">It may be a lot of code but if <code>[ x for x in my_list if ExpensiveOperation(x) ]</code> takes a long time to run, you certainly don't want to do it twice!</span>
<span class="comment-copy">+1 for offering multiple variations including iterator-based and a specific "in X" solution. The OP's "in goodvals" might be small, but replacing this with a very large dictionary or expensive predicate could be expensive. Also it reduces the need to write the list comprehension twice <i>everywhere</i> it's needed, thus reducing the likelihood for introducing typos/user error. Nice solution. Thanks!</span>
<span class="comment-copy">Note that <code>tee</code> stores all the values between the iterators it returns, so it won't really save memory if you loop over one entire generator and then the other.</span>
<span class="comment-copy">I agree. I was looking for an "elegant" (i.e. here meaning short and built-in/implicit) way to do this without scanning the list twice, but this seems (without profiling) to be the way to go. Of course it would only matter anyway for large amounts of data.</span>
<span class="comment-copy">IMHO, if you know a way of doing it with less cpu usage (and thus less power drain), there is no reason not to use it.</span>
<span class="comment-copy">@winden ...Porting all my Python to C. ;)</span>
<span class="comment-copy">not best solution if the lists were in some order before splitting and you need them to stay in that order.</span>
<span class="comment-copy">Wouldn't that remove duplicates?</span>
<span class="comment-copy">Creating a set is O(n log n).  Iterating the list twice is O(n).  The set solution may be more elegant (when it's correct in the first place) but is most certainly slower as n increases.</span>
<span class="comment-copy">@dash-tom-bang Iterating the list is O(n * n). That's because each item in the list may need to be compared with each item in <code>goodvals</code>.</span>
<span class="comment-copy">@dash-tom-bang See my answers and the benchmarks.</span>
<span class="comment-copy">I was going to try to pick out the statements from <a href="http://legacy.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">Zen of Python</a> that apply here, but it's too many for a comment. =) Awesome piece of code.</span>
<span class="comment-copy">Of course, <code>filter(lambda x: is_good(x), mylist)</code> can be reduced to <code>filter(is_good, mylist)</code></span>
<span class="comment-copy">adding the extra function call actually doubles (!) the execution time, compared to the list comprehensions, from what I've seen in profiling. it's hard to beat a list comprehension, most of the time.</span>
<span class="comment-copy">Although it iterates through the list only once, the performance is not that good because of the list appends. Appending to a list is potentially expensive operation (when compared with deque.append for example). Actually, this solution is extremely slow when compared with other solutions in here (21.4s on 100000 random integers and testing their value).</span>
<span class="comment-copy">ifilter/imap (and generators in general) are pretty slow... in general, in my profiling, if you take a list comprehension like <code>[x for x in a if x &gt; 50000]</code> on a simple array of 100000 integers (via random.shuffle), <code>filter(lambda x: x&gt; 50000, a)</code> will take 2x as long, <code>ifilter(lambda x: x&gt; 50000, a); list(result)</code> takes about 2.3x as long. Strange but true.</span>
<span class="comment-copy">...just noticed this is basically the same as @alan-isaac has already answered.</span>
<span class="comment-copy">The "d or {}" is a bit dangerous.  If an empty dict gets passed in, it won't be mutated in place.</span>
<span class="comment-copy">True, but it gets returned, so... Actually, this is the perfect example of why you <i>don't</i> want to add more clever to your code. :-P</span>
<span class="comment-copy">Looks like two lines of code to me.  If you mean it's only one line at the call site, that doesn't change by splitting the last line above into two.  The concern is that if executing <code>pred(i)</code> takes a long time you're doubling your wait.</span>
<span class="comment-copy">I didn't downvote you, but your answer is not ideal because creating a set is a n log n operation, much slower than the other solutions which will run in n time</span>
<span class="comment-copy">@Patrick: A set is 44% faster than a tuple. Source: Benchmark.</span>
