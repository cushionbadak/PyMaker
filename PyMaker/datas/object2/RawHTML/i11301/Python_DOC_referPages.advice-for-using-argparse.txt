<div class="post-text" itemprop="text">
<p>I am writing a python command line client program to interface with an api. The user uses the client program to run following command and the client program makes following example calls to api</p>
<blockquote>
<p>python run.py --car --&gt; calls method get_all(vehicle_type) which requests--&gt;  /car/all    --&lt; which returns list of all cars</p>
<p>python run.py --van --&gt;  /van/all    --&gt; which returns list of all vans</p>
<p>/car/id/123  --&gt; --&gt; calls method get_by_id(vehicle_type, id) which requests --&gt; returns list of car with id 123</p>
</blockquote>
<p>And similar for all others. </p>
<blockquote>
<p>/car/color/red return list of car with color red</p>
<p>/car/model_no/31x  return car with model_no 31x</p>
<p>/van/id/312  returns list of van with id 321</p>
</blockquote>
<p>I am using arg parse for this purpose and having trouble properly putting this. Right now, I am doing. </p>
<pre><code>parser = argparse.ArgumentParser()
grp1 = parser.add_mutually_exclusive_group(required=True)
grp2 = parser.add_mutually_exclusive_group()

grp1.add_argument('--car', action='store_const', const='car')
grp1.add_argument('--van', action='store_const', const='van')

grp2.add_argument('--id', help='get by id')
grp2.add_argument('--model_no', help='get by model number')
grp2.add_argument('--color', help='get by color') 

arg_dict = {k:v for k, v in vars(args).items() if v}
</code></pre>
<p>when I run this code for command.  </p>
<blockquote>
<p>python run.py --car --id  123</p>
</blockquote>
<p>I get</p>
<blockquote>
<p>{'car' : 'car' , 'id' : '123'}</p>
</blockquote>
<p>I am looping through this dict and using getattr to call function by the key name 'get_by_{name}'.format(name = key).
However, my code doesn't looks nice as I have to check if the length is 1 then call get all function and check for vehicle type. Is there a better way to properly use argparse to make code more compact.</p>
</div>
<div class="post-text" itemprop="text">
<p>I find when using mutually_exclusive_groups I frequently make use of the <a href="https://docs.python.org/3/library/argparse.html#dest" rel="nofollow"><code>dest</code> option</a> so you have one variable with a dynamic value:</p>
<pre><code>import argparse

parser = argparse.ArgumentParser()
grp1 = parser.add_mutually_exclusive_group(required=True)
grp2 = parser.add_mutually_exclusive_group()

group_1_options = {"action":"store_const",'dest':"vehicle"}

grp1.add_argument('--car', const="car", **group_1_options)
grp1.add_argument('--van', const='van', **group_1_options)
</code></pre>
<p>Then for the second group you can use <code>type</code> to apply a change when the option is specified, so that it saves a reference to the option text specified:</p>
<pre><code>parser.set_defaults(request=("get_all",None))

request_args = {"id":'get by id',
                "model_no":"get by model number",
                "color":"get by color"}

grp2 = parser.add_mutually_exclusive_group()
for arg_name, help_text in request_args.items():
    grp2.add_argument("--"+arg_name, help=help_text, dest="request",
                      type=(lambda x, arg_text=arg_name:(arg_text,x)))
</code></pre>
<p>Then the request can be retrieved like:</p>
<pre><code>def test(argline):
    namespace = parser.parse_args(argline.split())
    kind,value = namespace.request
    print(namespace.vehicle, kind, value)
</code></pre>
<p>Then you are guaranteed to just have to deal with the <code>vehicle</code> and <code>request</code> options:    </p>
<pre><code>&gt;&gt;&gt; test("--van")
van get_all None
&gt;&gt;&gt; test("--car --id 123")
car id 123
&gt;&gt;&gt; test("--model_no 55 --van")
van model_no 55
&gt;&gt;&gt; test("--car --id") #invalid because there is no request value
usage: test.py [-h] (--car | --van)
               [--color REQUEST | --id REQUEST | --model_no REQUEST]
test.py: error: argument --id: expected one argument
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A relatively straight forward way of doing what you want (I think) is:</p>
<pre><code>import argparse

def get_all(vehicle_type, *value):   # optional value parameter
    print('all', vehicle_type)

def get_by_id(vehicle_type, id):
    print('id', vehicle_type, id)

def get_by_color(vehicle_type, color):
    print('color', vehicle_type, color)

def get_by_model(vehicle_type, model):
    print('model', vehicle_type, model)

parser = argparse.ArgumentParser()
parser.add_argument('--vehicle_type','-v',choices=['car','van'])
# could be mutually exclusive group with --car and --var

getby_group = parser.add_mutually_exclusive_group()
getby_group.add_argument('--id')
getby_group.add_argument('--color')
getby_group.add_argument('--model')

args = parser.parse_args()

if args.id:
    get_by_id(args.vehicle_type, args.id)
elif args.color:
    get_by_color(args.vehicle_type, args.color)
elif args.model:
    get_by_model(args.vehicle_type, args.model)
else:
    get_all(args.vehicle_type)
</code></pre>
<p>You could use <code>default=argparse.SUPPRESS</code> to keep <code>id</code> out of <code>args</code> (like what you do with <code>arg_dict = {k:v for k, v in vars(args).items() if v}</code>.  But it easier to test</p>
<pre><code>if args.id:
   ...
</code></pre>
<p>than</p>
<pre><code>if hasattr(args,'id'):
    ...
</code></pre>
<p>or</p>
<pre><code>if get(vars,'id',None):
     ...
</code></pre>
<p>If you really wanted to generate the function name from <code>args</code> values you could do a dictionary lookup (<code>locals()</code> or a custom dictionary).  Internally <code>argparse</code> uses a <code>registries</code> dictionary via <code>parser.register</code>.</p>
<pre><code>fn = locals().get('get_by_%s'%'id')
fn(args.vehicle_type, args.id)
</code></pre>
<p>The <code>argparse</code> docs shows how <code>parser.set_defaults</code> can be used to define an <code>args</code> attribute as a function.  But that particular use only applies to subparsers.</p>
<p>You could use <code>const</code> to set an function, eg</p>
<pre><code>getby_group.add_argument('--id',dest='fn',action='store_const', const=get_by_id)
</code></pre>
<p>Then</p>
<pre><code>args.fn(...) 
</code></pre>
<p>would run <code>get_by_id</code> function.</p>
<p>&lt; removed a version that uses this <code>store_const</code>.  It had problems accepting a value; set edit history for details &gt;</p>
<p>===================</p>
<p>Here's a custom action approach to defining a <code>fn</code> attribute and a <code>value</code></p>
<pre><code>class GetAction(argparse._StoreAction):
    # barest customization
    def __init__(self, *args, **kwargs):
        fn=kwargs.pop('fn')
        super(GetAction, self).__init__(*args, **kwargs)
        self.fn = fn 
    def __call__(self, parser, namespace, values, option_string=None):
        super(GetAction, self).__call__(parser, namespace, values, option_string=None)
        setattr(namespace, 'fn', self.fn)

parser.set_defaults(fn=get_all)  # default action    
getby_group.add_argument('--id',   dest='value', action=GetAction, fn=get_by_id)
getby_group.add_argument('--color',dest='value', action=GetAction, fn=get_by_color)
getby_group.add_argument('--model',dest='value', action=GetAction, fn=get_by_model)
args = parser.parse_args()
args.fn(args.vehicle_type, args.value)
</code></pre>
<p>BUT - notice that the class definition requires more lines of code than the <code>if-else</code> tree.  And took me longer to write.</p>
</div>
<span class="comment-copy">by <code>grp1 = parser.add(..)</code> do you possibly mean <code>grp1.add_argument(...)</code> ?</span>
<span class="comment-copy">Thanks for the correction.</span>
<span class="comment-copy">Thank you very much. This makes it much more easier. But,  color takes argument though. This one seems to return the request type but i also need request argument, which for example could be red.</span>
<span class="comment-copy">right... so this would definitely simplify the first group but I'm not sure how to simplify the second group.</span>
<span class="comment-copy">wait, is this even what you were looking for or am I going in the complete wrong direction?</span>
<span class="comment-copy">I am just looking for a nice compact way to do it. I think you answer definitely helps. If you have more suggestions (like way you would approach this),  I would be happy to listen.</span>
<span class="comment-copy">Is it possible to get the arguments color, id, model_number as something like NameSpace(vehicle='van', request= {'color' : 'red'})</span>
<span class="comment-copy">the first way is definitely the simplest but the OP is specifically looking for something more compact and your last example fails since it makes <code>value</code> required and completely irrelevant to the option specified before it.</span>
<span class="comment-copy">With a custom action class you could set the <code>fn</code> attribute as well as take a value.  That just moves the complexity to the parser definition.  Sometimes avoiding a simple <code>if else</code> tree isn't worth the effort.</span>
<span class="comment-copy">Oh you were suggesting making a <b>custom</b> action class, that was not clear.</span>
<span class="comment-copy">I've worked out a custom action that would define both a <code>fn</code> attribute and take a value.</span>
<span class="comment-copy">Honestly I feel like a feature in exclusive mutual group of "the name of the option selected is stored in this variable and the value of that option is stored in this variable" would be a really useful feature, anyway I think the custom action is much easier to expand on as adding an option with the <code>if/else</code> would require adding three lines in the most basic case but consistently 1 line with the custom action.</span>
