<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/2709821/what-is-the-purpose-of-self">What is the purpose of self?</a>
<span class="question-originals-answer-count">
                    19 answers
                </span>
</li>
</ul>
</div>
<p>In the following example <code>employee</code> is not used in the <code>__init__</code> function, but we used it in the <code>add_employee</code> function calling <code>self.employee.append()</code>. 
Why is that? Why did we use <code>self.employee.append()</code> instead of <code>employee.append()</code> ? I thought we only use <code>self</code> for variables in the <code>__init__</code> function.</p>
<pre><code>class Workers():
    employee = []

    def __init__(self, name):
        self.name = name
        self.skills = []
        self.add_employee()

    def add_employee(self):
        self.employee.append(self.name)
        print('{} added to list'.format(self.name))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>employee</code> object is a class variable, not an instance variable. This means it is shared across all instances of that class. You can access it with <code>classname.classvariablename</code> or <code>instancename.classvariablename</code>. If you reassign an instance's version of it with something like <code>instancename.classvariablename = newvalue</code>, that instance will have a new instance variable of that name that masks its access to the class variable with the <code>self</code> reference (i.e., you won't be able to do <code>instancename.classvariablename</code> to get the class variable), but other instances - and the class - will still be able to (i.e., <code>classname.classvariable</code> will still work, and <code>otherinstancename.classvariable</code> will still point to that class variable). The following example demonstrates this.</p>
<pre><code>&gt;&gt;&gt; class A:
...     l = []
...
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; b = A()
&gt;&gt;&gt; a.l
[]
&gt;&gt;&gt; A.l
[]
&gt;&gt;&gt; a.l = 3
&gt;&gt;&gt; b.l
[]
&gt;&gt;&gt; b.l.append(1)
&gt;&gt;&gt; b.l
[1]
&gt;&gt;&gt; A.l
[1]
&gt;&gt;&gt; a.l
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>employee</code>, <code>__init__</code>, and <code>add_employee</code> are just attributes of the class <code>Workers</code>.</p>
<p><code>employee</code> is an attribute being a list, and <code>__init__</code> is another attribute, being a method.</p>
<p>Also from the [def documentation](
<a href="https://docs.python.org/3/reference/compound_stmts.html#grammar-token-funcdef" rel="nofollow">https://docs.python.org/3/reference/compound_stmts.html#grammar-token-funcdef</a>):</p>
<blockquote>
<p>A function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function).</p>
</blockquote>
<p>so <code>employees</code> and <code>__init__</code> and all other methods are really the same: names in a namespaces.</p>
<p>See also 
<a href="https://docs.python.org/3/tutorial/classes.html#class-objects" rel="nofollow">https://docs.python.org/3/tutorial/classes.html#class-objects</a></p>
</div>
<span class="comment-copy">Try <code>employee.append()</code> you should get a NameError on <code>employee</code></span>
<span class="comment-copy">@cricket_007 I know, that's why I asked</span>
