<div class="post-text" itemprop="text">
<p>How can I create a zip archive of a directory structure in Python? </p>
</div>
<div class="post-text" itemprop="text">
<p>As others have pointed out, you should use <a href="http://docs.python.org/library/zipfile.html" rel="noreferrer">zipfile</a>. The documentation tells you what functions are available, but doesn't really explain how you can use them to zip an entire directory. I think it's easiest to explain with some example code:</p>
<pre><code>#!/usr/bin/env python
import os
import zipfile

def zipdir(path, ziph):
    # ziph is zipfile handle
    for root, dirs, files in os.walk(path):
        for file in files:
            ziph.write(os.path.join(root, file))

if __name__ == '__main__':
    zipf = zipfile.ZipFile('Python.zip', 'w', zipfile.ZIP_DEFLATED)
    zipdir('tmp/', zipf)
    zipf.close()
</code></pre>
<p>Adapted from: <a href="http://www.devshed.com/c/a/Python/Python-UnZipped/" rel="noreferrer">http://www.devshed.com/c/a/Python/Python-UnZipped/</a></p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way is to use <a href="https://docs.python.org/3/library/shutil.html#shutil.make_archive" rel="noreferrer"><code>shutil.make_archive</code></a>. It supports both zip and tar formats.</p>
<pre><code>import shutil
shutil.make_archive(output_filename, 'zip', dir_name)
</code></pre>
<p>If you need to do something more complicated than zipping the whole directory (such as skipping certain files), then you'll need to dig into the <a href="https://docs.python.org/3/library/zipfile.html" rel="noreferrer"><code>zipfile</code></a> module as others have suggested.</p>
</div>
<div class="post-text" itemprop="text">
<p>To add the contents of <code>mydirectory</code> to a new zip file, including all files and subdirectories:</p>
<pre><code>import os
import zipfile

zf = zipfile.ZipFile("myzipfile.zip", "w")
for dirname, subdirs, files in os.walk("mydirectory"):
    zf.write(dirname)
    for filename in files:
        zf.write(os.path.join(dirname, filename))
zf.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>How can I create a zip archive of a directory structure in Python?</h1>
</blockquote>
<h2>In a Python script</h2>
<p>In Python 2.7+, <code>shutil</code> has a <code>make_archive</code> function.</p>
<pre><code>from shutil import make_archive
make_archive(
  'zipfile_name', 
  'zip',           # the archive format - or tar, bztar, gztar 
  root_dir=None,   # root for archive - current working dir if None
  base_dir=None)   # start archiving from here - cwd if None too
</code></pre>
<p>Here the zipped archive will be named <code>zipfile_name.zip</code>. If <code>base_dir</code> is farther down from <code>root_dir</code> it will exclude files not in the <code>base_dir</code>, but still archive the files in the parent dirs up to the <code>root_dir</code>.</p>
<p>I did have an issue testing this on Cygwin with 2.7 - it wants a root_dir argument, for cwd:</p>
<pre><code>make_archive('zipfile_name', 'zip', root_dir='.')
</code></pre>
<h2>Using Python from the shell</h2>
<p>You can do this with Python from the shell also using the <code>zipfile</code> module:</p>
<pre><code>$ python -m zipfile -c zipname sourcedir
</code></pre>
<p>Where <code>zipname</code> is the name of the destination file you want (add <code>.zip</code> if you want it, it won't do it automatically) and sourcedir is the path to the directory.</p>
<h2>Zipping up Python (or just don't want parent dir):</h2>
<p>If you're trying to zip up a python package with a <code>__init__.py</code> and <code>__main__.py</code>, and you don't want the parent dir, it's </p>
<pre><code>$ python -m zipfile -c zipname sourcedir/*
</code></pre>
<p>And</p>
<pre><code>$ python zipname
</code></pre>
<p>would run the package. (Note that you can't run subpackages as the entry point from a zipped archive.)</p>
<h2>Zipping a Python app:</h2>
<p>If you have python3.5+, and specifically want to zip up a Python package, use <a href="https://docs.python.org/3/library/zipapp.html" rel="noreferrer">zipapp</a>:</p>
<pre><code>$ python -m zipapp myapp
$ python myapp.pyz
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This function will recursively zip up a directory tree, <em>compressing</em> the files, and recording the correct relative filenames in the archive. The archive entries are the same as those generated by <code>zip -r output.zip source_dir</code>.</p>
<pre><code>import os
import zipfile
def make_zipfile(output_filename, source_dir):
    relroot = os.path.abspath(os.path.join(source_dir, os.pardir))
    with zipfile.ZipFile(output_filename, "w", zipfile.ZIP_DEFLATED) as zip:
        for root, dirs, files in os.walk(source_dir):
            # add directory (needed for empty dirs)
            zip.write(root, os.path.relpath(root, relroot))
            for file in files:
                filename = os.path.join(root, file)
                if os.path.isfile(filename): # regular files only
                    arcname = os.path.join(os.path.relpath(root, relroot), file)
                    zip.write(filename, arcname)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use shutil, which is part of python standard library set. 
Using shutil is so simple(see code below): </p>
<ul>
<li>1st arg: Filename of resultant zip/tar file, </li>
<li>2nd arg: zip/tar, </li>
<li>3rd arg: dir_name</li>
</ul>
<p>Code:</p>
<pre><code>import shutil
shutil.make_archive('/home/user/Desktop/Filename','zip','/home/username/Desktop/Directory')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For adding compression to the resulting zip file, check out <a href="http://neopatel.blogspot.ca/2010/07/creating-zip-file-in-python-and.html" rel="noreferrer">this link</a>.</p>
<p>You need to change:</p>
<pre><code>zip = zipfile.ZipFile('Python.zip', 'w')
</code></pre>
<p>to </p>
<pre><code>zip = zipfile.ZipFile('Python.zip', 'w', zipfile.ZIP_DEFLATED)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've made some changes to <a href="https://stackoverflow.com/a/1855118">code given by Mark Byers</a>. Below function will also adds empty directories if you have them. Examples should make it more clear what is the path added to the zip.</p>
<pre><code>#!/usr/bin/env python
import os
import zipfile

def addDirToZip(zipHandle, path, basePath=""):
    """
    Adding directory given by \a path to opened zip file \a zipHandle

    @param basePath path that will be removed from \a path when adding to archive

    Examples:
        # add whole "dir" to "test.zip" (when you open "test.zip" you will see only "dir")
        zipHandle = zipfile.ZipFile('test.zip', 'w')
        addDirToZip(zipHandle, 'dir')
        zipHandle.close()

        # add contents of "dir" to "test.zip" (when you open "test.zip" you will see only it's contents)
        zipHandle = zipfile.ZipFile('test.zip', 'w')
        addDirToZip(zipHandle, 'dir', 'dir')
        zipHandle.close()

        # add contents of "dir/subdir" to "test.zip" (when you open "test.zip" you will see only contents of "subdir")
        zipHandle = zipfile.ZipFile('test.zip', 'w')
        addDirToZip(zipHandle, 'dir/subdir', 'dir/subdir')
        zipHandle.close()

        # add whole "dir/subdir" to "test.zip" (when you open "test.zip" you will see only "subdir")
        zipHandle = zipfile.ZipFile('test.zip', 'w')
        addDirToZip(zipHandle, 'dir/subdir', 'dir')
        zipHandle.close()

        # add whole "dir/subdir" with full path to "test.zip" (when you open "test.zip" you will see only "dir" and inside it only "subdir")
        zipHandle = zipfile.ZipFile('test.zip', 'w')
        addDirToZip(zipHandle, 'dir/subdir')
        zipHandle.close()

        # add whole "dir" and "otherDir" (with full path) to "test.zip" (when you open "test.zip" you will see only "dir" and "otherDir")
        zipHandle = zipfile.ZipFile('test.zip', 'w')
        addDirToZip(zipHandle, 'dir')
        addDirToZip(zipHandle, 'otherDir')
        zipHandle.close()
    """
    basePath = basePath.rstrip("\\/") + ""
    basePath = basePath.rstrip("\\/")
    for root, dirs, files in os.walk(path):
        # add dir itself (needed for empty dirs
        zipHandle.write(os.path.join(root, "."))
        # add files
        for file in files:
            filePath = os.path.join(root, file)
            inZipPath = filePath.replace(basePath, "", 1).lstrip("\\/")
            #print filePath + " , " + inZipPath
            zipHandle.write(filePath, inZipPath)
</code></pre>
<p>Above is a simple function that should work for simple cases. You can find more elegant class in my Gist:
<a href="https://gist.github.com/Eccenux/17526123107ca0ac28e6" rel="nofollow noreferrer">https://gist.github.com/Eccenux/17526123107ca0ac28e6</a></p>
</div>
<div class="post-text" itemprop="text">
<p>You probably want to look at the <code>zipfile</code> module; there's documentation at <a href="http://docs.python.org/library/zipfile.html" rel="nofollow noreferrer">http://docs.python.org/library/zipfile.html</a>.</p>
<p>You may also want <code>os.walk()</code> to index the directory structure.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have another code example that may help, using python3, pathlib and zipfile.
It should work in any OS.</p>
<pre><code>from pathlib import Path
import zipfile
from datetime import datetime

DATE_FORMAT = '%y%m%d'


def date_str():
    """returns the today string year, month, day"""
    return '{}'.format(datetime.now().strftime(DATE_FORMAT))


def zip_name(path):
    """returns the zip filename as string"""
    cur_dir = Path(path).resolve()
    parent_dir = cur_dir.parents[0]
    zip_filename = '{}/{}_{}.zip'.format(parent_dir, cur_dir.name, date_str())
    p_zip = Path(zip_filename)
    n = 1
    while p_zip.exists():
        zip_filename = ('{}/{}_{}_{}.zip'.format(parent_dir, cur_dir.name,
                                             date_str(), n))
        p_zip = Path(zip_filename)
        n += 1
    return zip_filename


def all_files(path):
    """iterator returns all files and folders from path as absolute path string
    """
    for child in Path(path).iterdir():
        yield str(child)
        if child.is_dir():
            for grand_child in all_files(str(child)):
                yield str(Path(grand_child))


def zip_dir(path):
    """generate a zip"""
    zip_filename = zip_name(path)
    zip_file = zipfile.ZipFile(zip_filename, 'w')
    print('create:', zip_filename)
    for file in all_files(path):
        print('adding... ', file)
        zip_file.write(file)
    zip_file.close()


if __name__ == '__main__':
    zip_dir('.')
    print('end!')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here is a variation on the answer given by Nux that works for me:</p>
<pre><code>def WriteDirectoryToZipFile( zipHandle, srcPath, zipLocalPath = "", zipOperation = zipfile.ZIP_DEFLATED ):
    basePath = os.path.split( srcPath )[ 0 ]
    for root, dirs, files in os.walk( srcPath ):
        p = os.path.join( zipLocalPath, root [ ( len( basePath ) + 1 ) : ] )
        # add dir
        zipHandle.write( root, p, zipOperation )
        # add files
        for f in files:
            filePath = os.path.join( root, f )
            fileInZipPath = os.path.join( p, f )
            zipHandle.write( filePath, fileInZipPath, zipOperation )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Try the below one .it worked for me</strong>.  </p>
<pre><code>import zipfile, os
zipf = "compress.zip"  
def main():
    directory = r"Filepath"
    toZip(directory)
def toZip(directory):
    zippedHelp = zipfile.ZipFile(zipf, "w", compression=zipfile.ZIP_DEFLATED )

    list = os.listdir(directory)
    for file_list in list:
        file_name = os.path.join(directory,file_list)

        if os.path.isfile(file_name):
            print file_name
            zippedHelp.write(file_name)
        else:
            addFolderToZip(zippedHelp,file_list,directory)
            print "---------------Directory Found-----------------------"
    zippedHelp.close()

def addFolderToZip(zippedHelp,folder,directory):
    path=os.path.join(directory,folder)
    print path
    file_list=os.listdir(path)
    for file_name in file_list:
        file_path=os.path.join(path,file_name)
        if os.path.isfile(file_path):
            zippedHelp.write(file_path)
        elif os.path.isdir(file_name):
            print "------------------sub directory found--------------------"
            addFolderToZip(zippedHelp,file_name,path)


if __name__=="__main__":
    main()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want a functionality like the compress folder of any common graphical file manager you can use the following code, it uses the <a href="https://docs.python.org/2/library/zipfile.html" rel="nofollow">zipfile</a> module. Using this code you will have the zip file with the path as its root folder. </p>
<pre><code>import os
import zipfile

def zipdir(path, ziph):
    # Iterate all the directories and files
    for root, dirs, files in os.walk(path):
        # Create a prefix variable with the folder structure inside the path folder. 
        # So if a file is at the path directory will be at the root directory of the zip file
        # so the prefix will be empty. If the file belongs to a containing folder of path folder 
        # then the prefix will be that folder.
        if root.replace(path,'') == '':
                prefix = ''
        else:
                # Keep the folder structure after the path folder, append a '/' at the end 
                # and remome the first character, if it is a '/' in order to have a path like 
                # folder1/folder2/file.txt
                prefix = root.replace(path, '') + '/'
                if (prefix[0] == '/'):
                        prefix = prefix[1:]
        for filename in files:
                actual_file_path = root + '/' + filename
                zipped_file_path = prefix + filename
                zipf.write( actual_file_path, zipped_file_path)


zipf = zipfile.ZipFile('Python.zip', 'w', zipfile.ZIP_DEFLATED)
zipdir('/tmp/justtest/', zipf)
zipf.close()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Modern Python (3.6+) using the <a href="https://docs.python.org/3.6/library/pathlib.html" rel="nofollow noreferrer"><code>pathlib</code></a> module for concise OOP-like handling of paths, and <a href="https://docs.python.org/3.6/library/pathlib.html#pathlib.Path.rglob" rel="nofollow noreferrer"><code>pathlib.Path.rglob()</code></a> for recursive globbing. As far as I can tell, this is equivalent to George V. Reilly's answer: zips with compression, the topmost element is a directory, keeps empty dirs, uses relative paths. </p>
<pre><code>from pathlib import Path
from zipfile import ZIP_DEFLATED, ZipFile

from os import PathLike
from typing import Union


def zip_dir(zip_name: str, source_dir: Union[str, PathLike]):
    src_path = Path(source_dir).expanduser().resolve(strict=True)
    with ZipFile(zip_name, 'w', ZIP_DEFLATED) as zf:
        for file in src_path.rglob('*'):
            zf.write(file, file.relative_to(src_path.parent))
</code></pre>
<p>Note: as optional type hints indicate, <code>zip_name</code> can't be a Path object (<a href="https://bugs.python.org/issue28231" rel="nofollow noreferrer">would be fixed in 3.6.2+</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>To give more flexibility, e.g. select directory/file by name use:</p>
<pre><code>import os
import zipfile

def zipall(ob, path, rel=""):
    basename = os.path.basename(path)
    if os.path.isdir(path):
        if rel == "":
            rel = basename
        ob.write(path, os.path.join(rel))
        for root, dirs, files in os.walk(path):
            for d in dirs:
                zipall(ob, os.path.join(root, d), os.path.join(rel, d))
            for f in files:
                ob.write(os.path.join(root, f), os.path.join(rel, f))
            break
    elif os.path.isfile(path):
        ob.write(path, os.path.join(rel, basename))
    else:
        pass
</code></pre>
<p>For a file tree:</p>
<pre><code>.
├── dir
│   ├── dir2
│   │   └── file2.txt
│   ├── dir3
│   │   └── file3.txt
│   └── file.txt
├── dir4
│   ├── dir5
│   └── file4.txt
├── listdir.zip
├── main.py
├── root.txt
└── selective.zip
</code></pre>
<p>You can e.g. select only <code>dir4</code> and <code>root.txt</code>:</p>
<pre><code>cwd = os.getcwd()
files = [os.path.join(cwd, f) for f in ['dir4', 'root.txt']]

with zipfile.ZipFile("selective.zip", "w" ) as myzip:
    for f in files:
        zipall(myzip, f)
</code></pre>
<p>Or just <code>listdir</code> in script invocation directory and add everything from there:</p>
<pre><code>with zipfile.ZipFile("listdir.zip", "w" ) as myzip:
    for f in os.listdir():
        if f == "listdir.zip":
            # Creating a listdir.zip in the same directory
            # will include listdir.zip inside itself, beware of this
            continue
        zipall(myzip, f)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a modern approach, using pathlib, and a context manager. Puts the files directly in the zip, rather than in a subfolder.</p>
<pre><code>def zip_dir(filename: str, dir_to_zip: pathlib.Path):
    with zipfile.ZipFile(filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
        # Use glob instead of iterdir(), to cover all subdirectories.
        for directory in dir_to_zip.glob('**'):
            for file in directory.iterdir():
                if not file.is_file():
                    continue
                # Strip the first component, so we don't create an uneeded subdirectory
                # containing everything.
                zip_path = pathlib.Path(*file.parts[1:])
                # Use a string, since zipfile doesn't support pathlib  directly.
                zipf.write(str(file), str(zip_path))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I prepared a function by consolidating Mark Byers' solution with Reimund and Morten Zilmer's comments (relative path and including empty directories). As a best practice, <code>with</code> is used in ZipFile's file construction.  </p>
<p>The function also prepares a default zip file name with the zipped directory name and '.zip' extension. Therefore, it works with only one argument: the source directory to be zipped.</p>
<pre><code>import os
import zipfile

def zip_dir(path_dir, path_file_zip=''):
if not path_file_zip:
    path_file_zip = os.path.join(
        os.path.dirname(path_dir), os.path.basename(path_dir)+'.zip')
with zipfile.ZipFile(path_file_zip, 'wb', zipfile.ZIP_DEFLATED) as zip_file:
    for root, dirs, files in os.walk(path_dir):
        for file_or_dir in files + dirs:
            zip_file.write(
                os.path.join(root, file_or_dir),
                os.path.relpath(os.path.join(root, file_or_dir),
                                os.path.join(path_dir, os.path.pardir)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code># import required python modules
# You have to install zipfile package using pip install

import os,zipfile

# Change the directory where you want your new zip file to be

os.chdir('Type your destination')

# Create a new zipfile ( I called it myfile )

zf = zipfile.ZipFile('myfile.zip','w')

# os.walk gives a directory tree. Access the files using a for loop

for dirnames,folders,files in os.walk('Type your directory'):
    zf.write('Type your Directory')
    for file in files:
        zf.write(os.path.join('Type your directory',file))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well, after reading the suggestions I came up with a very similar way that works with 2.7.x without creating "funny" directory names (absolute-like names), and will only create the specified folder inside the zip.</p>
<p>Or just in case you needed your zip to contain a folder inside with the contents of the selected directory.</p>
<pre><code>def zipDir( path, ziph ) :
 """
 Inserts directory (path) into zipfile instance (ziph)
 """
 for root, dirs, files in os.walk( path ) :
  for file in files :
   ziph.write( os.path.join( root, file ) , os.path.basename( os.path.normpath( path ) ) + "\\" + file )

def makeZip( pathToFolder ) :
 """
 Creates a zip file with the specified folder
 """
 zipf = zipfile.ZipFile( pathToFolder + 'file.zip', 'w', zipfile.ZIP_DEFLATED )
 zipDir( pathToFolder, zipf )
 zipf.close()
 print( "Zip file saved to: " + pathToFolder)

makeZip( "c:\\path\\to\\folder\\to\\insert\\into\\zipfile" )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Function to create zip file. </p>
<pre><code>def CREATEZIPFILE(zipname, path):
    #function to create a zip file
    #Parameters: zipname - name of the zip file; path - name of folder/file to be put in zip file

    zipf = zipfile.ZipFile(zipname, 'w', zipfile.ZIP_DEFLATED)
    zipf.setpassword(b"password") #if you want to set password to zipfile

    #checks if the path is file or directory
    if os.path.isdir(path):
        for files in os.listdir(path):
            zipf.write(os.path.join(path, files), files)

    elif os.path.isfile(path):
        zipf.write(os.path.join(path), path)
    zipf.close()
</code></pre>
</div>
<span class="comment-copy">Don't use the solution suggested in the accepted answer but the one further down using <code>make_archive</code> from <code>shutil</code> (if you want to zip a single directory recursively).</span>
<span class="comment-copy">I would add a second argument to the write call, passing <code>os.path.relpath(os.path.join(root, file), os.path.join(path, '..'))</code>. That would let you zip a directory from any working directory, without getting the full absolute paths in the archive.</span>
<span class="comment-copy">There's a funny recursion going on when I try to zip a folder and output the resultant zip to the same folder. :-)</span>
<span class="comment-copy"><code>shutil</code> makes it really easy in just a single line. Please check the answer below..</span>
<span class="comment-copy">you may be more interested by doing ziph.write(os.path.join(path,file), arcname=file) so that the filenames inside the archive are not relative to the hard drive</span>
<span class="comment-copy">I am getting "The compressed (zipped) folder is empty" on Windows 7</span>
<span class="comment-copy"><code>shutil</code> is part of the standard python library. This should be the top answer</span>
<span class="comment-copy">This is the most concise answer here and also has the advantage of adding all subdirectories and files to the archive directly, rather than having everything included in a top-level folder (which results in a redundant level in the folder structure when unzipping).</span>
<span class="comment-copy"><b>WARN: shutil.make_archive is not threadsafe</b></span>
<span class="comment-copy">@cmcginty could you please be a bit more specific as to what aspect of it is not thread-safe? Will running multiple threads while one calls this cause the interpreter to crash?</span>
<span class="comment-copy">Be warned that prior to Python 3.4, shutil.make_archive does not support ZIP64 and will fail on creating ZIP files larger than 2GB.</span>
<span class="comment-copy">For me this code throwing below error    TypeError: invalid file: &lt;zipfile.ZipFile [closed]&gt;</span>
<span class="comment-copy">Can't you use a <code>with</code> instead of having to call <code>close()</code> yourself at the end?</span>
<span class="comment-copy">this should be the accepted answer</span>
<span class="comment-copy">this is a good option but is not thread safe right?</span>
<span class="comment-copy">The path handling could be greatly simplified by using <a href="http://doughellmann.com/2008/01/pymotw-os-path.html" rel="nofollow noreferrer">os.path</a>. See my answer.</span>
<span class="comment-copy">You are right, relpath makes it a bit simpler. Thanks.</span>
<span class="comment-copy">Bug: zipHandle.write(os.path.join(root, ".")) does not take basePath into consideration.</span>
<span class="comment-copy">Yes, you're probably right. I've later enhnaced this a bit ;-) <a href="https://gist.github.com/Eccenux/17526123107ca0ac28e6" rel="nofollow noreferrer">gist.github.com/Eccenux/17526123107ca0ac28e6</a></span>
<span class="comment-copy">This zips, but doesn't compress.</span>
<span class="comment-copy">This solution ignore files inside folder of the parent folder.</span>
<span class="comment-copy">please explain with an example so that i can correct my answer</span>
