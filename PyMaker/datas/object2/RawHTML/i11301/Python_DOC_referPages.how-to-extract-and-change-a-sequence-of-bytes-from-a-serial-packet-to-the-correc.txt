<div class="post-text" itemprop="text">
<p><code>374c4f4f00000800ff74**d102**29190300006f00fffffffffffffffffffff</code></p>
<p>This is the serial packet I am processing using pyserial. The two bytes in bold actually correspond to a real world measurement which corresponds to <code>721</code>(decimal) or <code>02d1</code>(hex). How do I extract those bytes in python and get the correct int value which is 721?</p>
</div>
<div class="post-text" itemprop="text">
<p>Processing to and from such byte strings is quickly and easily done with the <code>struct</code> library functions <code>pack</code>/<code>pack_to</code>  and <code>unpack</code>/<code>unpack_from</code>:</p>
<p>While it is normally best practice to unpack/unpack the entire packet you can use the _from &amp; _to versions to selectively manipulate packets.</p>
<p>In your case:</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; val # Generated using  binascii.unhexlify
 b'7LOO\x00\x00\x08\x00\xfft\xd1\x02)\x19\x03\x00\x00o\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
&gt;&gt;&gt; struct.unpack_from('&lt;H', val, 10)
(721,) # Note the return is a tupple so you need the 0th element
&gt;&gt;&gt; struct.unpack_from('&lt;H', val, 10)[0]
721
</code></pre>
<h2>More info</h2>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; help (struct.unpack)
Help on built-in function unpack in module _struct:

unpack(...)
    unpack(fmt, buffer) -&gt; (v1, v2, ...)

    Return a tuple containing values unpacked according to the format string
    fmt.  Requires len(buffer) == calcsize(fmt). See help(struct) for more
    on format strings.
&gt;&gt;&gt; help (struct.pack)
Help on built-in function pack in module _struct:

pack(...)
    pack(fmt, v1, v2, ...) -&gt; bytes

    Return a bytes object containing the values v1, v2, ... packed according
    to the format string fmt.  See help(struct) for more on format strings.

&gt;&gt;&gt; help(struct)
Help on module struct:

NAME
    struct

DESCRIPTION
    Functions to convert between Python values and C structs.
    Python bytes objects are used to hold the data representing the C struct
    and also as format strings (explained below) to describe the layout of data
    in the C struct.

    The optional first format char indicates byte order, size and alignment:
      @: native order, size &amp; alignment (default)
      =: native order, std. size &amp; alignment
      &lt;: little-endian, std. size &amp; alignment
      &gt;: big-endian, std. size &amp; alignment
      !: same as &gt;

    The remaining chars indicate types of args and must match exactly;
    these can be preceded by a decimal repeat count:
      x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;
      ?: _Bool (requires C99; if not available, char is used instead)
      h:short; H:unsigned short; i:int; I:unsigned int;
      l:long; L:unsigned long; f:float; d:double.
    Special cases (preceding decimal count indicates length):
      s:string (array of char); p: pascal string (with count byte).
    Special cases (only available in native format):
      n:ssize_t; N:size_t;
      P:an integer type that is wide enough to hold a pointer.
    Special case (not in native mode unless 'long long' in platform C):
      q:long long; Q:unsigned long long
    Whitespace between formats is ignored.

    The variable struct.error is an exception raised on errors.
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your hex-encoded string is of odd length, so I don't know where the padding's missing from, see below</p>
<pre><code>In [18]: s = '374c4f4f00000800ff74d10229190300006f00fffffffffffffffffffff0' # a nibble of padding at the end

In [19]: buffer = binascii.unhexlify(s)

In [20]: buffer
Out[20]: b'7LOO\x00\x00\x08\x00\xfft\xd1\x02)\x19\x03\x00\x00o\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0'

In [21]: struct.unpack('&lt;10BH18B', buffer)
Out[21]:
(55,
 76,
 79,
 79,
 0,
 0,
 8,
 0,
 255,
 116,
 721,
 ...
</code></pre>
<p>For more information on what the format strings in <code>pack</code> and <code>unpack</code> can be, see the <a href="https://docs.python.org/3/library/struct.html?highlight=pack#struct-format-strings" rel="nofollow">documentation</a>. In short, <code>&lt;</code> stands for little-endian, <code>B</code> for unsigned char (assumed 8-bit width), <code>H</code> for short (assumed 16-bit width).</p>
</div>
<div class="post-text" itemprop="text">
<p>Since the actual format strings are somewhat strange at first sight, I have given you a solution based on the above answer: </p>
<ul>
<li>The command unhexlify will convert the 4 byte ascii representation back to a two byte binary representation of your integer.</li>
<li>the '&lt;' takes care of your reversed byte order in your integer <a href="https://docs.python.org/3/library/struct.html" rel="nofollow">(Formatting details)</a></li>
<li>The 'i' means that we are facing a two byte integer</li>
</ul>
<p>Hope that helps.</p>
<pre><code>import struct 
from binascii import unhexlify

s ="374c4f4f00000800ff74d10229190300006f00fffffffffffffffffffff"
s1= s[20:24]

print struct.unpack('&lt;h', unhexlify(s1))[0]
</code></pre>
</div>
