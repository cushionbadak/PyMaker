<div class="post-text" itemprop="text">
<p>Is there a method like <code>isiterable</code>? The only solution I have found so far is to call</p>
<pre><code>hasattr(myObj, '__iter__')
</code></pre>
<p>But I am not sure how fool-proof this is.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Checking for <code>__iter__</code> works on sequence types, but it would fail on e.g. strings <strong>in Python 2</strong>. I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):</p>
<pre><code>try:
    some_object_iterator = iter(some_object)
except TypeError as te:
    print some_object, 'is not iterable'
</code></pre>
<p>The <code>iter</code> built-in checks for the <code>__iter__</code> method or in the case of strings the <code>__getitem__</code> method.</p></li>
<li><p>Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object. The Python glossary:</p>
<blockquote>
<p>Pythonic programming style that determines an object's type by inspection of its method or attribute signature rather than by explicit relationship to some type object ("If it looks like a <strong>duck</strong> and quacks like a <strong>duck</strong>, it must be a <strong>duck</strong>.") By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). <strong>Instead, it typically employs the EAFP (Easier to Ask Forgiveness than Permission) style of programming.</strong></p>
<p>...</p>
<pre><code>try:
   _ = (e for e in my_object)
except TypeError:
   print my_object, 'is not iterable'
</code></pre>
</blockquote></li>
<li><p>The <a href="http://docs.python.org/library/collections.html#abcs-abstract-base-classes" rel="noreferrer"><code>collections</code></a> module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:</p>
<pre><code>from collections.abc import Iterable

if isinstance(e, Iterable):
    # e is iterable
</code></pre>
<p>However, this does not check for classes that are iterable through <code>__getitem__</code>.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<h2>Duck typing</h2>
<pre><code>try:
    iterator = iter(theElement)
except TypeError:
    # not iterable
else:
    # iterable

# for obj in iterator:
#     pass
</code></pre>
<h2>Type checking</h2>
<p>Use the <a href="https://docs.python.org/library/abc.html" rel="noreferrer">Abstract Base Classes</a>. They need at least Python 2.6 and work only for new-style classes.</p>
<pre><code>from collections.abc import Iterable   # import directly from collections for Python &lt; 3.3

if isinstance(theElement, Iterable):
    # iterable
else:
    # not iterable
</code></pre>
<p>However, <code>iter()</code> is a bit more reliable as described <a href="https://docs.python.org/library/collections.abc.html#collections.abc.Iterable" rel="noreferrer">by the documentation</a>:</p>
<blockquote>
<p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are
  registered as Iterable or that have an <code>__iter__()</code> method, but
  it does not detect classes that iterate with the <code>__getitem__()</code>
  method. The only reliable way to determine whether an object
  is iterable is to call <code>iter(obj)</code>.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>I'd like to shed a little bit more light on the interplay of <code>iter</code>, <code>__iter__</code> and <code>__getitem__</code> and what happens behind the curtains. Armed with that knowledge, you will be able to understand why the best you can do is</p>
<pre><code>try:
    iter(maybe_iterable)
    print('iteration will probably work')
except TypeError:
    print('not iterable')
</code></pre>
<p>I will list the facts first and then follow up with a quick reminder of what happens when you employ a <code>for</code> loop in python, followed by a discussion to illustrate the facts.</p>
<h1>Facts</h1>
<ol>
<li><p>You can get an iterator from any object <code>o</code> by calling <code>iter(o)</code> if at least one of the following conditions holds true: <br/><br/>a) <code>o</code> has an <code>__iter__</code> method which returns an iterator object. An iterator is any object with an <code>__iter__</code> and a <code>__next__</code> (Python 2: <code>next</code>) method. <br/><br/>b) <code>o</code> has a <code>__getitem__</code> method.</p></li>
<li><p>Checking for an instance of <code>Iterable</code> or <code>Sequence</code>, or checking for the
attribute <code>__iter__</code> is not enough.</p></li>
<li><p>If an object <code>o</code> implements only <code>__getitem__</code>, but not <code>__iter__</code>, <code>iter(o)</code> will construct
an iterator that tries to fetch items from <code>o</code> by integer index, starting at index 0. The iterator will catch any <code>IndexError</code> (but no other errors) that is raised and then raises <code>StopIteration</code> itself.</p></li>
<li><p>In the most general sense, there's no way to check whether the iterator returned by <code>iter</code> is sane other than to try it out.</p></li>
<li><p>If an object <code>o</code> implements <code>__iter__</code>, the <code>iter</code> function will make sure
that the object returned by <code>__iter__</code> is an iterator. There is no sanity check
if an object only implements <code>__getitem__</code>.</p></li>
<li><p><code>__iter__</code> wins. If an object <code>o</code> implements both <code>__iter__</code> and <code>__getitem__</code>, <code>iter(o)</code> will call <code>__iter__</code>.</p></li>
<li><p>If you want to make your own objects iterable, always implement the <code>__iter__</code> method.</p></li>
</ol>
<h1><code>for</code> loops</h1>
<p>In order to follow along, you need an understanding of what happens when you employ a <code>for</code> loop in Python. Feel free to skip right to the next section if you already know.</p>
<p>When you use <code>for item in o</code> for some iterable object <code>o</code>, Python calls <code>iter(o)</code> and expects an iterator object as the return value. An iterator is any object which implements a <code>__next__</code> (or <code>next</code> in Python 2) method and an <code>__iter__</code> method. </p>
<p>By convention, the <code>__iter__</code> method of an iterator should return the object itself (i.e. <code>return self</code>). Python then calls <code>next</code> on the iterator until <code>StopIteration</code> is raised. All of this happens implicitly, but the following demonstration makes it visible:</p>
<pre><code>import random

class DemoIterable(object):
    def __iter__(self):
        print('__iter__ called')
        return DemoIterator()

class DemoIterator(object):
    def __iter__(self):
        return self

    def __next__(self):
        print('__next__ called')
        r = random.randint(1, 10)
        if r == 5:
            print('raising StopIteration')
            raise StopIteration
        return r
</code></pre>
<p>Iteration over a <code>DemoIterable</code>:</p>
<pre><code>&gt;&gt;&gt; di = DemoIterable()
&gt;&gt;&gt; for x in di:
...     print(x)
...
__iter__ called
__next__ called
9
__next__ called
8
__next__ called
10
__next__ called
3
__next__ called
10
__next__ called
raising StopIteration
</code></pre>
<h1>Discussion and illustrations</h1>
<p><strong>On point 1 and 2: getting an iterator and unreliable checks</strong></p>
<p>Consider the following class:</p>
<pre><code>class BasicIterable(object):
    def __getitem__(self, item):
        if item == 3:
            raise IndexError
        return item
</code></pre>
<p>Calling <code>iter</code> with an instance of <code>BasicIterable</code> will return an iterator without any problems because <code>BasicIterable</code> implements <code>__getitem__</code>.</p>
<pre><code>&gt;&gt;&gt; b = BasicIterable()
&gt;&gt;&gt; iter(b)
&lt;iterator object at 0x7f1ab216e320&gt;
</code></pre>
<p>However, it is important to note that <code>b</code> does not have the <code>__iter__</code> attribute and is not considered an instance of <code>Iterable</code> or <code>Sequence</code>:</p>
<pre><code>&gt;&gt;&gt; from collections import Iterable, Sequence
&gt;&gt;&gt; hasattr(b, '__iter__')
False
&gt;&gt;&gt; isinstance(b, Iterable)
False
&gt;&gt;&gt; isinstance(b, Sequence)
False
</code></pre>
<p>This is why <a href="http://shop.oreilly.com/product/0636920032519.do">Fluent Python</a> by Luciano Ramalho recommends calling <code>iter</code> and handling the potential <code>TypeError</code> as the most accurate way to check whether an object is iterable. Quoting directly from the book:</p>
<blockquote>
<p>As of Python 3.4, the most accurate way to check whether an object <code>x</code> is iterable is to call <code>iter(x)</code> and handle a <code>TypeError</code> exception if it isn’t. This is more accurate than using <code>isinstance(x, abc.Iterable)</code> , because <code>iter(x)</code> also considers the legacy <code>__getitem__</code> method, while the <code>Iterable</code> ABC does not.</p>
</blockquote>
<p><strong>On point 3: Iterating over objects which only provide <code>__getitem__</code>, but not <code>__iter__</code></strong></p>
<p>Iterating over an instance of <code>BasicIterable</code> works as expected: Python
constructs an iterator that tries to fetch items by index, starting at zero, until an <code>IndexError</code> is raised. The demo object's <code>__getitem__</code> method simply returns the <code>item</code> which was supplied as the argument to <code>__getitem__(self, item)</code> by the iterator returned by <code>iter</code>.</p>
<pre><code>&gt;&gt;&gt; b = BasicIterable()
&gt;&gt;&gt; it = iter(b)
&gt;&gt;&gt; next(it)
0
&gt;&gt;&gt; next(it)
1
&gt;&gt;&gt; next(it)
2
&gt;&gt;&gt; next(it)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>
<p>Note that the iterator raises <code>StopIteration</code> when it cannot return the next item and that the <code>IndexError</code> which is raised for <code>item == 3</code> is handled internally. This is why looping over a <code>BasicIterable</code> with a <code>for</code> loop works as expected:</p>
<pre><code>&gt;&gt;&gt; for x in b:
...     print(x)
...
0
1
2
</code></pre>
<p>Here's another example in order to drive home the concept of how the iterator returned by <code>iter</code> tries to access items by index. <code>WrappedDict</code> does not inherit from <code>dict</code>, which means instances won't have an <code>__iter__</code> method.</p>
<pre><code>class WrappedDict(object): # note: no inheritance from dict!
    def __init__(self, dic):
        self._dict = dic

    def __getitem__(self, item):
        try:
            return self._dict[item] # delegate to dict.__getitem__
        except KeyError:
            raise IndexError
</code></pre>
<p>Note that calls to <code>__getitem__</code> are delegated to <code>dict.__getitem__</code> for which the square bracket notation is simply a shorthand.</p>
<pre><code>&gt;&gt;&gt; w = WrappedDict({-1: 'not printed',
...                   0: 'hi', 1: 'StackOverflow', 2: '!',
...                   4: 'not printed', 
...                   'x': 'not printed'})
&gt;&gt;&gt; for x in w:
...     print(x)
... 
hi
StackOverflow
!
</code></pre>
<p><strong>On point 4 and 5: <code>iter</code> checks for an iterator when it calls <code>__iter__</code></strong>:</p>
<p>When <code>iter(o)</code> is called for an object <code>o</code>, <code>iter</code> will make sure that the return value of <code>__iter__</code>, if the method is present, is an iterator. This means that the returned object
must implement <code>__next__</code> (or <code>next</code> in Python 2) and <code>__iter__</code>. <code>iter</code> cannot perform any sanity checks for objects which only
provide <code>__getitem__</code>, because it has no way to check whether the items of the object are accessible by integer index.</p>
<pre><code>class FailIterIterable(object):
    def __iter__(self):
        return object() # not an iterator

class FailGetitemIterable(object):
    def __getitem__(self, item):
        raise Exception
</code></pre>
<p>Note that constructing an iterator from <code>FailIterIterable</code> instances fails immediately, while constructing an iterator from <code>FailGetItemIterable</code> succeeds, but will throw an Exception on the first call to <code>__next__</code>.</p>
<pre><code>&gt;&gt;&gt; fii = FailIterIterable()
&gt;&gt;&gt; iter(fii)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: iter() returned non-iterator of type 'object'
&gt;&gt;&gt;
&gt;&gt;&gt; fgi = FailGetitemIterable()
&gt;&gt;&gt; it = iter(fgi)
&gt;&gt;&gt; next(it)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/path/iterdemo.py", line 42, in __getitem__
    raise Exception
Exception
</code></pre>
<p><strong>On point 6: <code>__iter__</code> wins</strong></p>
<p>This one is straightforward. If an object implements <code>__iter__</code> and <code>__getitem__</code>, <code>iter</code> will call <code>__iter__</code>. Consider the following class</p>
<pre><code>class IterWinsDemo(object):
    def __iter__(self):
        return iter(['__iter__', 'wins'])

    def __getitem__(self, item):
        return ['__getitem__', 'wins'][item]
</code></pre>
<p>and the output when looping over an instance:</p>
<pre><code>&gt;&gt;&gt; iwd = IterWinsDemo()
&gt;&gt;&gt; for x in iwd:
...     print(x)
...
__iter__
wins
</code></pre>
<p><strong>On point 7: your iterable classes should implement <code>__iter__</code></strong></p>
<p>You might ask yourself why most builtin sequences like <code>list</code> implement an <code>__iter__</code> method when <code>__getitem__</code> would be sufficient.</p>
<pre><code>class WrappedList(object): # note: no inheritance from list!
    def __init__(self, lst):
        self._list = lst

    def __getitem__(self, item):
        return self._list[item]
</code></pre>
<p>After all, iteration over instances of the class above, which delegates calls to <code>__getitem__</code> to <code>list.__getitem__</code> (using the square bracket notation), will work fine:</p>
<pre><code>&gt;&gt;&gt; wl = WrappedList(['A', 'B', 'C'])
&gt;&gt;&gt; for x in wl:
...     print(x)
... 
A
B
C
</code></pre>
<p>The reasons your custom iterables should implement <code>__iter__</code> are as follows:</p>
<ol>
<li>If you implement <code>__iter__</code>, instances will be considered iterables, and <code>isinstance(o, collections.Iterable)</code> will return <code>True</code>.</li>
<li>If the the object returned by <code>__iter__</code> is not an iterator, <code>iter</code> will fail immediately and raise a <code>TypeError</code>.</li>
<li>The special handling of <code>__getitem__</code> exists for backwards compatibility reasons. Quoting again from Fluent Python:</li>
</ol>
<blockquote>
<p>That is why any Python sequence is iterable: they all implement <code>__getitem__</code> . In fact,
  the standard sequences also implement <code>__iter__</code>, and yours should too, because the
  special handling of <code>__getitem__</code> exists for backward compatibility reasons and may be
  gone in the future (although it is not deprecated as I write this).</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>This isn't sufficient: the object returned by <code>__iter__</code> must implement the iteration protocol (i.e. <code>next</code> method). See the relevant section in the <a href="http://docs.python.org/library/stdtypes.html#iterator-types" rel="noreferrer">documentation</a>.</p>
<p>In Python, a good practice is to "try and see" instead of "checking".</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>try:
  #treat object as iterable
except TypeError, e:
  #object is not actually iterable
</code></pre>
<p>Don't run checks to see <s>if your duck really is a duck</s> to see if it is iterable or not, treat it as if it was and complain if it wasn't.</p>
</div>
<div class="post-text" itemprop="text">
<p>In Python &lt;= 2.5, you can't and shouldn't - iterable was an "informal" interface.</p>
<p>But since Python 2.6 and 3.0 you can leverage the new ABC (abstract base class) infrastructure along with some builtin ABCs which are available in the collections module:</p>
<pre><code>from collections import Iterable

class MyObject(object):
    pass

mo = MyObject()
print isinstance(mo, Iterable)
Iterable.register(MyObject)
print isinstance(mo, Iterable)

print isinstance("abc", Iterable)
</code></pre>
<p>Now, whether this is desirable or actually works, is just a matter of conventions. As you can see, you <em>can</em> register a non-iterable object as Iterable - and it will raise an exception at runtime. Hence, isinstance acquires a "new" meaning - it just checks for "declared" type compatibility, which is a good way to go in Python.</p>
<p>On the other hand, if your object does not satisfy the interface you need, what are you going to do? Take the following example:</p>
<pre><code>from collections import Iterable
from traceback import print_exc

def check_and_raise(x):
    if not isinstance(x, Iterable):
        raise TypeError, "%s is not iterable" % x
    else:
        for i in x:
            print i

def just_iter(x):
    for i in x:
        print i


class NotIterable(object):
    pass

if __name__ == "__main__":
    try:
        check_and_raise(5)
    except:
        print_exc()
        print

    try:
        just_iter(5)
    except:
        print_exc()
        print

    try:
        Iterable.register(NotIterable)
        ni = NotIterable()
        check_and_raise(ni)
    except:
        print_exc()
        print
</code></pre>
<p>If the object doesn't satisfy what you expect, you just throw a TypeError, but if the proper ABC has been registered, your check is unuseful. On the contrary, if the <code>__iter__</code> method is available Python will automatically recognize object of that class as being Iterable.</p>
<p>So, if you just expect an iterable, iterate over it and forget it. On the other hand, if you need to do different things depending on input type, you might find the ABC infrastructure pretty useful.</p>
</div>
<div class="post-text" itemprop="text">
<p>The best solution I've found so far:</p>
<p><code>hasattr(obj, '__contains__')</code></p>
<p>which basically checks if the object implements the <code>in</code> operator.</p>
<p><strong>Advantages</strong> (none of the other solutions has all three):</p>
<ul>
<li>it is an expression (works as a <strong>lambda</strong>, as opposed to the <strong>try...except</strong> variant)</li>
<li>it is (should be) implemented by all iterables, including <strong>strings</strong> (as opposed to <code>__iter__</code>)</li>
<li>works on any Python &gt;= 2.5</li>
</ul>
<p>Notes: </p>
<ul>
<li>the Python philosophy of "ask for forgiveness, not permission" doesn't work well when e.g. in a list you have both iterables and non-iterables and you need to treat each element differently according to it's type (treating iterables on try and non-iterables on except <em>would</em> work, but it would look butt-ugly and misleading)</li>
<li>solutions to this problem which attempt to actually iterate over the object (e.g. [x for x in obj]) to check if it's iterable may induce significant performance penalties for large iterables (especially if you just need the first few elements of the iterable, for example) and should be avoided</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>I found a nice solution <a href="http://bytes.com/topic/python/answers/514838-how-test-if-object-sequence-iterable" rel="nofollow noreferrer">here</a>:</p>
<pre><code>isiterable = lambda obj: isinstance(obj, basestring) \
    or getattr(obj, '__iter__', False)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try this:</p>
<pre><code>def iterable(a):
    try:
        (x for x in a)
        return True
    except TypeError:
        return False
</code></pre>
<p>If we can make a generator that iterates over it (but never use the generator so it doesn't take up space), it's iterable. Seems like a "duh" kind of thing. Why do you need to determine if a variable is iterable in the first place?</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the <a href="https://docs.python.org/2/glossary.html#term-iterable" rel="noreferrer">Python 2 Glossary</a>, iterables are</p>
<blockquote>
<p>all sequence types (such as <code>list</code>, <code>str</code>, and <code>tuple</code>) and some non-sequence types like <code>dict</code> and <code>file</code> and objects of any classes you define with an <code>__iter__()</code> or <code>__getitem__()</code> method. Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), ...). When an iterable object is passed as an argument to the built-in function iter(), it returns an iterator for the object.</p>
</blockquote>
<p>Of course, given the general coding style for Python based on the fact that it's “Easier to ask for forgiveness than permission.”, the general expectation is to use</p>
<pre><code>try:
    for i in object_in_question:
        do_something
except TypeError:
    do_something_for_non_iterable
</code></pre>
<p>But if you need to check it explicitly, you can test for an iterable by <code>hasattr(object_in_question, "__iter__") or hasattr(object_in_question, "__getitem__")</code>. You need to check for both, because <code>str</code>s don't have an <code>__iter__</code> method (at least not in Python 2, in Python 3 they do) and because <code>generator</code> objects don't have a <code>__getitem__</code> method.</p>
</div>
<div class="post-text" itemprop="text">
<p>I often find convenient, inside my scripts, to define an <code>iterable</code> function.
(Now incorporates Alfe's suggested simplification):</p>
<pre><code>import collections

def iterable(obj):
    return isinstance(obj, collections.Iterable):
</code></pre>
<p>so you can test if any object is iterable in the very readable form</p>
<pre><code>if iterable(obj):
    # act on iterable
else:
    # not iterable
</code></pre>
<p>as you would do with the<code>callable</code> function</p>
<p>EDIT: if you have numpy installed, you can simply do: from <code>numpy import iterable</code>, 
which is simply something like</p>
<pre><code>def iterable(obj):
    try: iter(obj)
    except: return False
    return True
</code></pre>
<p>If you do not have numpy, you can simply implement this code, or the one above.</p>
</div>
<div class="post-text" itemprop="text">
<p><a class="post-tag" href="/questions/tagged/pandas" rel="tag" title="show questions tagged 'pandas'">pandas</a> has a built-in function like that:</p>
<pre><code>from pandas.util.testing import isiterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since <strong>Python 3.5</strong> you can use the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">typing</a> module from the standard library for type related things:</p>
<pre><code>from typing import Iterable

...

if isinstance(my_item, Iterable):
    print(True)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def is_iterable(x):
    try:
        0 in x
    except TypeError:
        return False
    else:
        return True
</code></pre>
<p>This will say yes to all manner of iterable objects, but it will <strong>say no to strings in Python 2</strong>. (That's what I want for example when a recursive function could take a string or a container of strings.  In that situation, <a href="https://stackoverflow.com/a/1952481/673991">asking forgiveness</a> may lead to obfuscode, and it's better to ask permission first.)</p>
<pre><code>import numpy

class Yes:
    def __iter__(self):
        yield 1;
        yield 2;
        yield 3;

class No:
    pass

class Nope:
    def __iter__(self):
        return 'nonsense'

assert is_iterable(Yes())
assert is_iterable(range(3))
assert is_iterable((1,2,3))   # tuple
assert is_iterable([1,2,3])   # list
assert is_iterable({1,2,3})   # set
assert is_iterable({1:'one', 2:'two', 3:'three'})   # dictionary
assert is_iterable(numpy.array([1,2,3]))
assert is_iterable(bytearray("not really a string", 'utf-8'))

assert not is_iterable(No())
assert not is_iterable(Nope())
assert not is_iterable("string")
assert not is_iterable(42)
assert not is_iterable(True)
assert not is_iterable(None)
</code></pre>
<p>Many other strategies here will say yes to strings. Use them if that's what you want.</p>
<pre><code>import collections
import numpy

assert isinstance("string", collections.Iterable)
assert isinstance("string", collections.Sequence)
assert numpy.iterable("string")
assert iter("string")
assert hasattr("string", '__getitem__')
</code></pre>
<p>Note: is_iterable() will say yes to strings of type <code>bytes</code> and <code>bytearray</code>.</p>
<ul>
<li><code>bytes</code> objects in Python 3 are iterable <code>True == is_iterable(b"string") == is_iterable("string".encode('utf-8'))</code> There is no such type in Python 2.</li>
<li><code>bytearray</code> objects in Python 2 and 3 are iterable <code>True == is_iterable(bytearray(b"abc"))</code></li>
</ul>
<p>The O.P. <code>hasattr(x, '__iter__')</code> approach will say yes to strings in Python 3 and no in Python 2 (no matter whether <code>''</code> or <code>b''</code> or <code>u''</code>). Thanks to @LuisMasuelli for noticing it will also let you down on a buggy <code>__iter__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The easiest way, respecting the Python's <a href="https://en.wikipedia.org/wiki/Duck_typing" rel="nofollow">duck typing</a>, is to catch the error (Python knows perfectly what does it expect from an object to become an iterator):</p>
<pre><code>class A(object):
    def __getitem__(self, item):
        return something

class B(object):
    def __iter__(self):
        # Return a compliant iterator. Just an example
        return iter([])

class C(object):
    def __iter__(self):
        # Return crap
        return 1

class D(object): pass

def iterable(obj):
    try:
        iter(obj)
        return True
    except:
        return False

assert iterable(A())
assert iterable(B())
assert iterable(C())
assert not iterable(D())
</code></pre>
<p><strong>Notes</strong>:</p>
<ol>
<li>It is irrelevant the distinction whether the object is not iterable, or a buggy <code>__iter__</code> has been implemented, if the exception type is the same: anyway you will not be able to iterate the object.</li>
<li><p>I think I understand your concern: How does <code>callable</code> exists as a check if I could also rely on duck typing to raise an <code>AttributeError</code> if <code>__call__</code> is not defined for my object, but that's not the case for iterable checking?</p>
<p>I don't know the answer, but you can either implement the function I (and other users) gave, or just catch the exception in your code (your implementation in that part will be like the function I wrote - just ensure you isolate the iterator creation from the rest of the code so you can capture the exception and distinguish it from another <code>TypeError</code>.</p></li>
</ol>
</div>
<div class="post-text" itemprop="text">
<p>The <code>isiterable</code> func at the following code returns <code>True</code> if object is iterable. if it's not iterable returns <code>False</code></p>
<pre><code>def isiterable(object_):
    return hasattr(type(object_), "__iter__")
</code></pre>
<p>example</p>
<pre><code>fruits = ("apple", "banana", "peach")
isiterable(fruits) # returns True

num = 345
isiterable(num) # returns False

isiterable(str) # returns False because str type is type class and it's not iterable.

hello = "hello dude !"
isiterable(hello) # returns True because as you know string objects are iterable
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of checking for the <code>__iter__</code> attribute, you could check for the <code>__len__</code> attribute, which is implemented by every python builtin iterable, including strings. </p>
<pre><code>&gt;&gt;&gt; hasattr(1, "__len__")
False
&gt;&gt;&gt; hasattr(1.3, "__len__")
False
&gt;&gt;&gt; hasattr("a", "__len__")
True
&gt;&gt;&gt; hasattr([1,2,3], "__len__")
True
&gt;&gt;&gt; hasattr({1,2}, "__len__")
True
&gt;&gt;&gt; hasattr({"a":1}, "__len__")
True
&gt;&gt;&gt; hasattr(("a", 1), "__len__")
True
</code></pre>
<p>None-iterable objects would not implement this for obvious reasons. However, it does not catch user-defined iterables that do not implement it, nor do generator expressions, which <code>iter</code> can deal with. However, this can be done in a line, and adding a simple <code>or</code> expression checking for generators would fix this problem. (Note that writing <code>type(my_generator_expression) == generator</code> would throw a <code>NameError</code>. Refer to <a href="https://stackoverflow.com/questions/6416538/how-to-check-if-an-object-is-a-generator-object-in-python">this</a> answer instead.)</p>
<blockquote>
<p>You can use GeneratorType from types:</p>
<pre><code>&gt;&gt;&gt; import types
&gt;&gt;&gt; types.GeneratorType
&lt;class 'generator'&gt;
&gt;&gt;&gt; gen = (i for i in range(10))
&gt;&gt;&gt; isinstance(gen, types.GeneratorType)
True
</code></pre>
<p>--- accepted answer by utdemir</p>
</blockquote>
<p>(This makes it useful for checking if you can call <code>len</code> on the object though.)</p>
</div>
<div class="post-text" itemprop="text">
<p>It's always eluded me as to why python has <code>callable(obj) -&gt; bool</code> but not <code>iterable(obj) -&gt; bool</code>...<br>
surely it's easier to do <code>hasattr(obj,'__call__')</code> even if it is slower.</br></p>
<p>Since just about every other answer recommends using <code>try</code>/<code>except TypeError</code>, where testing for exceptions is generally considered bad practice among any language, here's an implementation of <code>iterable(obj) -&gt; bool</code> I've grown more fond of and use often:</p>
<p>For python 2's sake, I'll use a lambda just for that extra performance boost...<br>
(in python 3 it doesn't matter what you use for defining the function, <code>def</code> has roughly the same speed as <code>lambda</code>)</br></p>
<pre><code>iterable = lambda obj: hasattr(obj,'__iter__') or hasattr(obj,'__getitem__')
</code></pre>
<p>Note that this function executes faster for objects with <code>__iter__</code> since it doesn't test for <code>__getitem__</code>.</p>
<p>Most iterable objects should rely on <code>__iter__</code> where special-case objects fall back to <code>__getitem__</code>, though either is required for an object to be iterable.<br>
(and since this is standard, it affects C objects as well)</br></p>
</div>
<div class="post-text" itemprop="text">
<p>Not really <em>"correct"</em> but can serve as quick check of most common types like strings, tuples, floats, etc...</p>
<pre><code>&gt;&gt;&gt; '__iter__' in dir('sds')
True
&gt;&gt;&gt; '__iter__' in dir(56)
False
&gt;&gt;&gt; '__iter__' in dir([5,6,9,8])
True
&gt;&gt;&gt; '__iter__' in dir({'jh':'ff'})
True
&gt;&gt;&gt; '__iter__' in dir({'jh'})
True
&gt;&gt;&gt; '__iter__' in dir(56.9865)
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Apart from regular try and except, you could run help.</p>
<pre><code>temp= [1,2,3,4]
help(temp)
</code></pre>
<p>help would give all the methods that could be run on that object(it could be any object and may not be a list as per example), which is temp in this case. </p>
<p>Note: This would be something you would manually do.</p>
</div>
<span class="comment-copy"><code>__getitem__</code> is also sufficient to make an object iterable</span>
<span class="comment-copy">FWIW: <code>iter(myObj)</code> succeeds if <code>isinstance(myObj, dict)</code>, so if you're looking at a <code>myObj</code> that could be a sequence of <code>dict</code>s or a single <code>dict</code>, you'll succeed in both cases. A subtlety that is important if you want to know what's a sequence and what isn't. (in Python 2)</span>
<span class="comment-copy"><code>__getitem__</code> is also sufficient to make an object iterable ... <b>if it starts at zero index</b>.</span>
<span class="comment-copy"><code>[e for e in my_object]</code> can raise an exception for other reasons, ie <code>my_object</code> is undefined or possible bugs in <code>my_object</code> implementation.</span>
<span class="comment-copy">A string <i>is</i> a sequence (<code>isinstance('', Sequence) == True</code>) <i>and</i> as any sequence it <i>is</i> iterable (<code>isinstance('', Iterable)</code>). Though <code>hasattr('', '__iter__') == False</code> and it might be confusing.</span>
<span class="comment-copy">If <code>my_object</code> is very large (say, infinite like <code>itertools.count()</code>) your list comprehension will take up a lot of time/memory. Better to make a generator, which will never try to build a (potentially infinite) list.</span>
<span class="comment-copy">What if <i>some_object</i> throws TypeError caused by other reason(bugs etc.) too? How can we tell it from the "Not iterable TypeError"?</span>
<span class="comment-copy">Note that in Python 3: <code>hasattr(u"hello", '__iter__')</code> returns <code>True</code></span>
<span class="comment-copy">From "Fluent Python" by Luciano Ramalho:  As of Python 3.4, the most accurate way to check whether an object x is iterable is to call iter(x) and handle a TypeError exception if it isn’t. This is more accurate than using isinstance(x, abc.Iterable), because iter(x) also considers the legacy <b>getitem</b> method, while the Iterable ABC does not.</span>
<span class="comment-copy">In case you're thinking "oh I'll just <code>isinstance(x, (collections.Iterable, collections.Sequence))</code> instead of <code>iter(x)</code>", note that this still won't detect an iterable object that implements only <code>__getitem__</code> but not <code>__len__</code>.  Use <code>iter(x)</code> and catch the exception.</span>
<span class="comment-copy">"duck typing" I believe? :)</span>
<span class="comment-copy">@willem: or "don't ask for permission but for forgiveness" ;-)</span>
<span class="comment-copy">@willem Both "permission" and "forgiveness" styles qualify as duck typing. If you ask what an object can <i>do</i> rather than what it <i>is</i>, that's duck typing.  If you use introspection, that's "permission"; if you just try to do it and see if it works or not, that's "forgiveness".</span>
<span class="comment-copy">Technically, during iteration your computation might throw a <code>TypeError</code> and throw you off here, but basically yes.</span>
<span class="comment-copy">@willem: Please use timeit to perform a benchmark.  Python exceptions are often faster than if-statements.  They can take a slightly shorter path through the interpreter.</span>
<span class="comment-copy">@willem: IronPython has slow (compared to CPython) exceptions.</span>
<span class="comment-copy">A working try: statement is really fast. So if you have few exceptions, try-except is fast. If you expect many exceptions, “if” can be faster.</span>
<span class="comment-copy">Shouldn't the exception object be caught by adding "<code>as e</code>" after <code>TypeError</code> instead of by adding "<code>, e</code>"?</span>
<span class="comment-copy">don't use bare <code>except:</code> in the example code for beginners. It promotes bad practice.</span>
<span class="comment-copy">J.F.S: I wouldn't, but I needed to go through multiple exception-raising code and I didn't want to catch the specific exception... I think the purpose of this code is pretty clear.</span>
<span class="comment-copy">Nice, but why not use the collections module as proposed in <a href="http://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-a-variable-is-iterable/1952481#1952481" title="in python how do i determine if a variable is iterable">stackoverflow.com/questions/1952464/…</a>?  Seems more expressive to me.</span>
<span class="comment-copy">It's shorter (and doesn't require additional imports) without losing any clarity: having a "contains" method feels like a natural way to check if something is a collection of objects.</span>
<span class="comment-copy">Just because something can contain something doesn't necessarily mean it's iterable.  For example, a user can check if a point is in a 3D cube, but how would you iterate through this object?</span>
<span class="comment-copy">This is incorrect. An iterable itself does not support <b>contains</b>, at least with Python 3.4.</span>
<span class="comment-copy">What about <code>iterable(itertools.repeat(0))</code>? :)</span>
<span class="comment-copy">@badp, the <code>(x for x in a)</code> just creates a generator, it doesn't do any iteration on a.</span>
<span class="comment-copy">Is trying <code>(x for x in a)</code> precisely equivalent to trying <code>iterator = iter(a)</code>? Or there are some cases where the two are different?</span>
<span class="comment-copy">Isn't <code>for _ in a: break</code> more straightforward ? Is it slower ?</span>
<span class="comment-copy">@Mr_and_Mrs_D that's bad if the tested object is an iterator that's iterated over afterwards (it will be 1 item short since it's position can't be reset), creating garbage generators doesn't iterate over the object as they're not iterated over, though I'm not certain that it will 100% raise a TypeError if not iterable.</span>
<span class="comment-copy">Whenever you do sth like <code>if x: return True</code> <code>else: return False</code> (with <code>x</code> being boolean) you can write this as <code>return x</code>.  In your case <code>return isinstance(…)</code> without any <code>if</code>.</span>
<span class="comment-copy">Since you acknowledge that Alfe's solution is better, why didn't you edit your answer to simply say that?  Instead, you now have BOTH versions in your answer. Unnecessary verbosity. Submitting an edit to fix this.</span>
<span class="comment-copy">You should catch "TypeError" in the ` except: return False ` line. Catching everything is a bad pattern.</span>
<span class="comment-copy">Know that. I translated that piece of code from the NumPy library, which uses the generic exception.</span>
<span class="comment-copy">Just because a code is taken from NumPy doesn't mean it's good... pattern or not, the only time catching everything should be done is if you're explicitly error handling inside your program.</span>
<span class="comment-copy">so many detailed answers above with many upvotes and you throw in an unexplained answer... meh</span>
<span class="comment-copy">Please do not post bare code. Also include an explanation of what this is doing.</span>
<span class="comment-copy">unfortunately not all iterable objects use <code>__len__</code>... for this case, it's usually the improper use of calculating distance between 2 objects. where <code>obj.dist()</code> could be easily substituted.</span>
<span class="comment-copy">Yeah. Most user defined iterables implement iter and getitem but not len. However, built in types do, and if you want to check if you can call len function on it, checking for len is more secure. But you are right.</span>
<span class="comment-copy">Solution already given by @Anaphory</span>
<span class="comment-copy">he doesn't provide working code, let alone talk about python performance...  although this answer was really just for convenience like I've seen done numerous times on here.</span>
