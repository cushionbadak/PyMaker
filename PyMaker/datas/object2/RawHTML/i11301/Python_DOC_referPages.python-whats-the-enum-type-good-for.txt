<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/22586895/python-enum-when-and-where-to-use">Python enum, when and where to use?</a>
<span class="question-originals-answer-count">
                    2 answers
                </span>
</li>
</ul>
</div>
<p>In Python 3.4, we got an Enum lib in the standard library: <code>enum</code>. We can get a backport for <code>enum</code> that works with Python 2.4 to 2.7 (and even 3.1 to 3.3), <a href="https://pypi.python.org/pypi/enum34" rel="noreferrer">enum34</a> in pypi.</p>
<p>But we've managed to get along for quite some time without this new module - so why do we now have it?</p>
<p>I have a general idea about the purpose of enums from other languages. In Python, it has been common to use a bare class as follows and refer to this as an enum:</p>
<pre><code>class Colors:
    blue = 1
    green = 2
    red = 3
</code></pre>
<p>This can be used in an API to create a canonical representation of the value, e.g.:</p>
<pre><code>function_of_color(Colors.green)
</code></pre>
<p>If this has any criticisms, it's mutable, you can't iterate over it (easily), and how are we to know the semantics of the integer, <code>2</code>?</p>
<p>Then I suppose I could just use something like a namedtuple, which would be immutable?</p>
<pre><code>&gt;&gt;&gt; Colors = namedtuple('Colors', 'blue green red')
&gt;&gt;&gt; colors = Colors('blue', 'green', 'red')
&gt;&gt;&gt; colors
Colors(blue='blue', green='green', red='red')
&gt;&gt;&gt; list(colors)
['blue', 'green', 'red']
&gt;&gt;&gt; len(colors)
3
&gt;&gt;&gt; colors.blue
'blue'
&gt;&gt;&gt; colors.index(colors.blue)
0
</code></pre>
<p>The creation of the namedtuple is a little redundant (we have to write each name twice), and so somewhat inelegant. Getting the "number" of the color is also a little inelegant (we have to write <code>colors</code> twice). Value checking will have to be done with strings, which will be a little less efficient.</p>
<p>So back to enums.</p>
<p>What's the purpose of enums? What value do they create for the language? When should I use them and when should I avoid them?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h2>What's the purpose of enums? What value do they create for the language? When should I use them and when should I avoid them?</h2>
</blockquote>
<p>The Enum type got into Python via <a href="https://www.python.org/dev/peps/pep-0435/" rel="noreferrer">PEP 435</a>. The reasoning given is:</p>
<blockquote>
<p>The properties of an enumeration are useful for defining an immutable, related set of constant values that may or may not have a semantic meaning.</p>
</blockquote>
<p>When using numbers and strings for this purpose, they could be characterized as <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="noreferrer">"magic numbers"</a> or "magic strings". Numbers rarely carry with them the semantics, and strings are easily confused (capitalization? spelling? snake or camel-case?)</p>
<p>Days of the week and school letter grades are examples of this kind of collections of values. </p>
<p>Here's an example from the <a href="https://docs.python.org/3/library/enum.html#creating-an-enum" rel="noreferrer">docs</a>:</p>
<pre><code>from enum import Enum

class Color(Enum):
    red = 1
    green = 2
    blue = 3
</code></pre>
<p>Like the bare class, this is much more readable and elegant than the namedtuple example, it is also immutable, and it has further benefits as we'll see below.</p>
<h3>Strictly dominant: The type of the enum member is the enum</h3>
<pre><code>&gt;&gt;&gt; type(Color.red)
&lt;enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.green, Color)
True
</code></pre>
<p>This allows you to define functionality on the members in the Enum definition. Defining functionality on the values could be accomplished with the other prior methods, but it would be very inelegant.</p>
<h3>Improvement: String coercion</h3>
<p>The string representation is human readable, while the repr has more information:</p>
<pre><code>&gt;&gt;&gt; print(Color.red)
Color.red
&gt;&gt;&gt; print(repr(Color.red))
&lt;Color.red: 1&gt;
</code></pre>
<p>I find this to be an improvement over the magic numbers and even possibly better than strings from the namedtuple.</p>
<h3>Iteration (parity):</h3>
<p>The enum supports iteration (like the namedtuple, but not so much the bare class) too:</p>
<pre><code>&gt;&gt;&gt; for color in Color:
        print(color)
Color.red
Color.green
Color.blue
</code></pre>
<p>The <code>__members__</code> attribute is an <code>OrderedDict</code> mapping the names of the enums to their respective enum objects (similar to namedtuple's <code>_asdict()</code> function).</p>
<h3>Supported by pickle (parity)</h3>
<p>You can serialize and deserialize the enum (in case anyone was worried about this):</p>
<pre><code>&gt;&gt;&gt; import pickle
&gt;&gt;&gt; color.red is pickle.loads(pickle.dumps(color.red))
True
</code></pre>
<h3>Improvement: Aliases</h3>
<p>This is a nice feature that the bare class doesn't have, and it would be difficult to tell the alias was there in the <code>namedtuple</code>.</p>
<pre><code>class Color(Enum):
    red = 1
    green = 2
    blue = 3
    really_blue = 3
</code></pre>
<p>The alias comes after the canonical name, but they are both the same:</p>
<pre><code>&gt;&gt;&gt; Color.blue is Color.really_blue
True
</code></pre>
<p>If aliases should be prohibited to avoid value collisions, use the <code>enum.unique</code> decorator (a strictly dominant feature).</p>
<h3>Strictly dominant: comparisons done with <code>is</code></h3>
<p>The enum is intended to be tested with <code>is</code>, which is a fast check for a single object's identity in the process.</p>
<pre><code>&gt;&gt;&gt; Color.red is Color.red
True
&gt;&gt;&gt; Color.red is Color.blue
False
&gt;&gt;&gt; Color.red is not Color.blue
True
</code></pre>
<p>Tests for equality work as well, but tests for identity with <code>is</code> are optimal.</p>
<h3>Different semantics from other Python classes</h3>
<p>Enum classes have different semantics from regular Python types. The values of the Enum are instances of the Enum, and are singletons in memory for those values - there is no other purpose for instantiating them.</p>
<pre><code>&gt;&gt;&gt; Color.red is Color('red')
</code></pre>
<p>This is important to keep in mind, perhaps it is a downside, but comparing on this dimension is comparing apples with oranges.</p>
<h3>Enums not assumed to be ordered</h3>
<p>While the Enum class knows what order the members are created in, enums are not assumed to be ordered. This is a feature because many things that may be enumerated have no natural order, and therefore order would be arbitrary. </p>
<p>However, you can give your enums order (see the next section).</p>
<h3>Subclassing</h3>
<p>You can't subclass an Enum with members declared, but you <em>can</em> subclass an Enum that doesn't declare members to share behavior (see the OrderedEnum recipe in the <a href="https://docs.python.org/3/library/enum.html#orderedenum" rel="noreferrer">docs</a>). </p>
<p>This is a feature - it makes little sense to subclass an Enum with members, but again, the comparison is apples and oranges.</p>
<h2>When should I use <code>enum.Enum</code>?</h2>
<p>This is the new canonical enumeration in Python. Collaborators will expect your enums to behave like these enums.</p>
<p>Use it anywhere you have a canonical source of enumerated data in your code where you want explicitly specified to use the canonical name, instead of arbitrary data. </p>
<p>For example, if in your code you want users to state that it's not <code>"Green"</code>, <code>"green"</code>, 2, or <code>"Greene"</code>, but <code>Color.green</code> - use the enum.Enum object. It's both explicit and specific.</p>
<p>There are a lot of examples and recipes in the <a href="https://docs.python.org/3/library/enum.html#interesting-examples" rel="noreferrer">documentation</a>.</p>
<h3>When should I avoid them?</h3>
<p>Stop rolling your own or letting people guess about magic numbers and strings. Don't avoid them. Embrace them. </p>
<p>However, if your enum members are required to be integers for historic reasons, there's the <code>IntEnum</code> from the same module, which has the same behavior, but is also an integer because it subclasses the builtin <code>int</code> before subclassing <code>Enum</code>. From <code>IntEnum</code>'s help:</p>
<pre><code>class IntEnum(builtins.int, Enum)
</code></pre>
<p>we can see that the IntEnum values would test as an instance of an <code>int</code>.</p>
</div>
