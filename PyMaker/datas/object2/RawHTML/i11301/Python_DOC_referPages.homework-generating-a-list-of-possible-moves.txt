<div class="post-text" itemprop="text">
<p>I am trying to generate a list of possible moves for a checkers-like game. For example, at the start of the game the board would look like [[1,1,1], [0,0,0], [2,2,2]]. My function would take the color (one for white, or two for black) and move the pieces either one space forward, or one space diagonal to capture another piece. So the list of first possible moves with white going first is  [[[0,1,1], [1,0,0], [2,2,2]] , [[1,0,1], [0,1,0, [2,2,2]] , [[1,1,1], [0,0,1, [2,2,2]]]</p>
<p>So far I have:</p>
<pre><code>def generateMoves(color, board):

    newboard = []
    subboard = []
    board = [[1, 1, 1], [0, 0, 0], [2, 2, 2]]
    x = 0

    for i in board:
        while x &lt; len(board):
            subboard.append(board[x])
            newboard.append(subboard)
            x += 1
    return newboard
</code></pre>
<p>But I can't figure out what modifications I need to make to it to calculate the new list of possible moves.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, we must note that moving forward or backwards depends on the owner of the piece.</p>
<p>We'll take as an argument the direction of the movement, with the code of the player, the code of the opponent and the board.</p>
<p>Now I'll define a function which generates the possible moves. The format is (original piece row, original piece column, new piece row, new piece column)</p>
<pre><code>def generate_moves(player, direction, board, opponent)
 for y, row in enumerate(board):
  for x, piece in enumerate(row):
   # Check if the piece belongs to the player
   if piece == player:
    new_row = y + direction
    # Check we don't go out of bounds
    if new_row &gt;= 0 and new_row &lt; len(board);
     # Check that the new square is not occupied by the same player
     if board[new_row][x] != player:
      # Produce the "advance" move
      yield (y,x ,new_row,x)
     # Now check if you can "eat" an opponent piece
     for side_offset in (+1, -1):
      # +1: check diagonal right, -1: check diagonal left
      new_column = x + side_offset
      if new_column &gt;= 0  and new_column &lt; len(row) and board[new_row][new_column] == opponent:
       yield (y, x, new_row, new_column)
</code></pre>
<p>Now we have a generator that generates all the possible moves on the board.
We can use it to modify the board to our needs.</p>
<pre><code>board = [....]
for player, direction, opponent in ((1,-1,2),(2,+1,1)):
 # Player 1 goes down (-1), player 2 goes up (+1)
 for move in generate_moves(player, direction, board, opponent):
  # REMEMBER: do not modify the board, as the object is shared inside the generator
  new_board = deepcopy(board) # You need to implement the deep copy
  col, row, new_col, new_row = move
  # The piece is no longer in the old position
  new_board[col][row] = 0
  # But in the new position instead!
  new_board[new_col, new_row] = player

  # Do something with the new_board
</code></pre>
</div>
<span class="comment-copy">Is this homework?</span>
<span class="comment-copy">For starters you'll need to iterate through all the board positions, find those that contain <code>color</code> and then check each on of those to determine what valid moves it could make.</span>
<span class="comment-copy">There are many things you need to do. So its best that you start with a few hints. First, find a good representation of how a "move" will be represented (examples are,  <code>[(row1, col1), (row2, col2)]</code>, <code>[(row, col), ('forward' | 'diagLeft' | 'diagRight')]</code>, etc. ). Second, find the <i>locations</i> of every piece (given 1 or 2). Third, Given a location for a piece, see if there is a piece that can be captured. If so, return that. Otherwise, see if it can move forward. If so return that. Forth, loop through all pieces to find their moves, and append to an empty list.</span>
<span class="comment-copy">Fifth, if the list contains a <i>capturing move</i>, eliminate all "forward" moves. Each of these can be converted into a function. So try writing these functions first.</span>
<span class="comment-copy">This is the sort of thing generator functions were made for...  A generator function could <code>yield</code> each mutation of the board without you having to explicitly remember which mutations were already tried.  (But... this sounds like a homework question.  If this is homework, are you <i>allowed</i> to use generators?  Any other restrictions we should know about before answering?  No point building a solution around, say, <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a> if you can't use it.)</span>
