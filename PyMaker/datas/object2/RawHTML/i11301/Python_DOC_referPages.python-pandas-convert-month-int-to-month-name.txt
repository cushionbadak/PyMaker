<div class="post-text" itemprop="text">
<p>Most of the info I found was not in python&gt;pandas&gt;dataframe hence the question.</p>
<p>I want to transform an integer between 1 and 12 into an abbrieviated month name.</p>
<p>I have a df which looks like:</p>
<pre><code>   client Month
1  sss    02
2  yyy    12
3  www    06
</code></pre>
<p>I want the df to look like this:</p>
<pre><code>   client Month
1  sss    Feb
2  yyy    Dec
3  www    Jun
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this efficiently with combining <code>calendar.month_abbr</code> and <code>df[col].apply()</code></p>
<pre><code>import calendar
df['Month'] = df['Month'].apply(lambda x: calendar.month_abbr[x])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One way of doing that is with the <code>apply</code> method in the dataframe but, to do that, you need a map to convert the months. You could either do that with a function / dictionary or with Python's own datetime.</p>
<p>With the datetime it would be something like:</p>
<pre><code>def mapper(month):
    date = datetime.datetime(2000, month, 1)  # You need a dateobject with the proper month
    return date.strftime('%b')  # %b returns the months abbreviation, other options [here][1]

df['Month'].apply(mapper)
</code></pre>
<p><br/></p>
<p>In a simillar way, you could build your own map for custom names. It would look like this:</p>
<pre><code>months_map = {01: 'Jan', 02: 'Feb'}
def mapper(month):
    return months_map[month]
</code></pre>
<p><br/></p>
<p>Obviously, you don't need to define this functions explicitly and could use a <code>lambda</code> directly in the apply method.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can do this easily with a column apply.</p>
<pre><code>import pandas as pd

df = pd.DataFrame({'client':['sss', 'yyy', 'www'], 'Month': ['02', '12', '06']})

look_up = {'01': 'Jan', '02': 'Feb', '03': 'Mar', '04': 'Apr', '05': 'May',
            '06': 'Jun', '07': 'Jul', '08': 'Aug', '09': 'Sep', '10': 'Oct', '11': 'Nov', '12': 'Dec'}

df['Month'] = df['Month'].apply(lambda x: look_up[x])
df

  Month client
0   Feb    sss
1   Dec    yyy
2   Jun    www
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>strptime</code> and <code>lambda</code> function for this:</p>
<pre><code>from time import strptime
df['Month'] = df['Month'].apply(lambda x: strptime(x,'%b').tm_mon) 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since the abbreviated month names is the first three letters of their full names, we could first convert the <code>Month</code> column to <code>datetime</code> and then use <code>dt.month_name()</code> to get the full month name and finally use <code>str.slice()</code> method to get the first three letters, all using pandas and only in one line of code:</p>
<pre><code>df['Month'] = pd.to_datetime(df['Month'], format='%m').dt.month_name().str.slice(stop=3)

df

  Month client
0   Feb sss
1   Dec yyy
2   Jun www
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Having tested all of these on a large dataset, I have found the following to be fastest:</p>
<pre class="lang-py prettyprint-override"><code>import calendar
def month_mapping():
    # I'm lazy so I have a stash of functions already written so
    # I don't have to write them out every time. This returns the
    # {1:'Jan'....12:'Dec'} dict in the laziest way...
    abbrevs = {}
    for month in range (1, 13):
        abbrevs[month] = calendar.month_abbr[month]
    return abbrevs

abbrevs = month_mapping()

df['Month Abbrev'} = df['Date Col'].dt.month.map(mapping)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <a href="https://docs.python.org/3/library/calendar.html" rel="nofollow noreferrer"><code>calendar</code></a> module is useful, but <a href="https://docs.python.org/3/library/calendar.html#calendar.month_abbr" rel="nofollow noreferrer"><code>calendar.month_abbr</code></a> is array-like: it cannot be used directly in a vectorised fashion. For an efficient mapping, you can construct a dictionary and then use <code>pd.Series.map</code>:</p>
<pre><code>import calendar
d = dict(enumerate(calendar.month_abbr))
df['Month'] = df['Month'].map(d)
</code></pre>
<p>Performance benchmarking shows a ~130x performance differential:</p>
<pre><code>import calendar

d = dict(enumerate(calendar.month_abbr))
mapper = calendar.month_abbr.__getitem__

np.random.seed(0)
n = 10**5
df = pd.DataFrame({'A': np.random.randint(1, 13, n)})

%timeit df['A'].map(d)       # 7.29 ms per loop
%timeit df['A'].map(mapper)  # 946 ms per loop
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def mapper(month):
   return month.strftime('%b') 

df['Month'] = df['Month'].apply(mapper)
</code></pre>
<p>Reference:</p>
<ul>
<li><a href="http://strftime.org/" rel="nofollow noreferrer">http://strftime.org/</a></li>
</ul>
</div>
<span class="comment-copy">Note this solution is akin to <code>list.__getitem__</code> in a Python-level loop, i.e. it does not take advantage of vectorised functionality available to Pandas. Extracting to a dictionary and then mapping is much more efficient, as per <a href="https://stackoverflow.com/a/54310169/9209546">this answer</a>.</span>
