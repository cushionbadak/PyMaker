<div class="post-text" itemprop="text">
<p>Here is a simple client which connects and sends a text message:</p>
<pre><code>class Client(asyncore.dispatcher):

    def __init__(self, host, port):
        asyncore.dispatcher.__init__(self)
        self.create_socket()
        self.connect( (host, port) )
        self.buffer = bytes("hello world", 'ascii')

    def handle_connect(self):
        pass

    def handle_close(self):
        self.close()

    def handle_read(self):
        print(self.recv(8192))

    def writable(self):
        return (len(self.buffer) &gt; 0)

    def writable(self):
        return True

    def handle_write(self):
        sent = self.send(self.buffer)
        print('Sent:', sent)
        self.buffer = self.buffer[sent:]


client = Client('localhost', 8080)
asyncore.loop()
</code></pre>
<p>And here is the server which has to receive the message and echo it back:</p>
<pre><code>class Server(asyncore.dispatcher):
    def __init__(self, host, port):
        asyncore.dispatcher.__init__(self)
        self.create_socket()
        self.set_reuse_addr()
        self.bind((host, port))
        self.listen(5)

    def handle_read(self):
        self.buffer = self.recv(4096)
        while True:
            partial = self.recv(4096)
            print('Partial', partial)
            if not partial:
                break
            self.buffer += partial

    def readable(self):
        return True

    def handle_write(self):
        pass

    def handle_accepted(self, sock, addr):
        print('Incoming connection from %s' % repr(addr))
        self.handle_read()
        print(self.buffer)


if __name__ == "__main__":
    server = Server("localhost", 8080)
    asyncore.loop()
</code></pre>
<p>The problem is that server isn't reading anything. When I print self.buffer the output is:</p>
<blockquote>
<p>b''</p>
</blockquote>
<p>What am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you need two handlers: One for the server socket (where you expect only <code>accept</code>), and one for the actual communication sockets. In addition, you can only call <code>read</code> once in <code>handle_read</code>; if you call it twice, the second call may block, and that's not allowed in asyncore programming. Don't worry though; if your read did not get everything, you'll immediately be notified again once your read handler returns.</p>
<pre><code>import asyncore

class Handler(asyncore.dispatcher):
    def __init__(self, sock):
        self.buffer = b''
        super().__init__(sock)

    def handle_read(self):
        self.buffer += self.recv(4096)
        print('current buffer: %r' % self.buffer)


class Server(asyncore.dispatcher):
    def __init__(self, host, port):
        asyncore.dispatcher.__init__(self)
        self.create_socket()
        self.set_reuse_addr()
        self.bind((host, port))
        self.listen(5)

    def handle_accepted(self, sock, addr):
        print('Incoming connection from %s' % repr(addr))
        Handler(sock)


if __name__ == "__main__":
    server = Server("localhost", 1234)
    asyncore.loop()
</code></pre>
</div>
<span class="comment-copy">Where is <code>self.accept()</code> in your server's code?</span>
<span class="comment-copy">I think that is not required in async sockets: <a href="https://docs.python.org/3/library/asyncore.html" rel="nofollow noreferrer">docs.python.org/3/library/asyncore.html</a> I have this code from the last example. And also the connection is accepted as the print statement in handle_accepted prints it out.</span>
<span class="comment-copy">ok, i saw it. I have read the doc of Py 2. But it think, you should use a separate class to handle the connection with the client. If you write all together, it couldn't be async.</span>
