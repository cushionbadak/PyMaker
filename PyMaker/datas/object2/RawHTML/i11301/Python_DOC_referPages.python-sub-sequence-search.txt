<div class="post-text" itemprop="text">
<p>I have a sequence 'abccabac' and a subsequence 'abc'. 
I need to get indices of all occurences of subsequence 'abc' in the sequence.
What is the memory efficient way of doing it?   </p>
<h2><strong>Example:</strong></h2>
<h2>Input:</h2>
<pre><code>**sequence**: 'abccabac' **subsequence**: 'abc'  
</code></pre>
<p><strong>Output</strong>: </p>
<pre><code> 012   
 013  
 017  
 057  
 457
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the absolute most strait forward way I can think of is using <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" rel="nofollow"><code>itertools.combinations</code></a></p>
<pre><code>import itertools

sequence = "abccabac"

subsequence = "abc"

for combo in itertools.combinations(enumerate(sequence), len(subsequence)):
    if "".join(pair[1] for pair in combo) == subsequence:
        print([pair[0] for pair in combo])
</code></pre>
<p>If your actual sequence contains lots of characters that are not even in the subsequence then filtering out the irrelevant characters before starting the <code>combinations</code> would definitely provide a substantial efficiency boost:</p>
<pre><code>char_generator = (pair for pair in enumerate(sequence) if pair[1] in subsequence)
for combo in itertools.combinations(char_generator, len(subsequence)):
    ...
</code></pre>
<p>as well instead of joining each combination you can just use <code>all</code> which will only check characters until one is found to be not equal:</p>
<pre><code>char_generator = (pair for pair in enumerate(sequence) if pair[1] in subsequence)
for combo in itertools.combinations(char_generator, len(subsequence)):
    if all(pair[1]==char for pair,char in zip(combo,subsequence)):
        print([pair[0] for pair in combo])
</code></pre>
<p>Here is a different alternative I just put together, I imagine the algorithm could be optimized even more but this is about the best I could come up with.  The <code>sub_sequence_generator</code> creates a list of indices for each letter of the sub sequence, then the <code>sub_helper</code> for each level of the recursion goes through all indices for the next letter of the subsequence starting after the indice of the last letter.</p>
<pre><code>import itertools
import bisect

def sub_helper(cur_i, combo, all_options):
    #cur_i is the index of the letter in the subsequence
    #cur_idx is the index of the sequence which contains that letter
    if cur_i&gt;0:
        prev_i = combo[cur_i-1]
    else:
        prev_i = -1
    cur_options = all_options[cur_i]
    start_i = bisect.bisect(cur_options,prev_i)
    cur_i_gen = itertools.islice(cur_options,start_i,None)
    if cur_i+1 == len(all_options): #last one:
        for cur_idx in cur_i_gen:
            combo[cur_i] = cur_idx
            yield tuple(combo)
    else:
        for cur_idx in cur_i_gen:
            combo[cur_i] = cur_idx
            yield from sub_helper(cur_i+1, combo, all_options)


def sub_sequence_generator(sequence,sub_seq):
    indices_map = {c:[] for c in set(sub_seq)} #create a list for each character
    for i,c in enumerate(sequence):
        try:
            indices_map[c].append(i,) #the helper is simpler if they are all stored as single element tuples
        except KeyError:
            pass

    # now we have indices for each character of the sub_sequence
    # we just need to put them in a sequence that corelates to the subsequence
    chr_indices = tuple(indices_map[c] for c in sub_seq)

    return sub_helper(0,[None]*len(chr_indices), chr_indices)

sequence = "abccabac"
subsequence = "abc"

for idxs in sub_sequence_generator(sequence,subsequence):
    print(idxs)
</code></pre>
<p>In terms of memory this will make a list for each character of the subsequence, containing the indices in the main sequence where that character is present.  A tuple of these lists, and a list of the indices that is continually updated and a tuple for each time a combination is <code>yield</code>ed, and iterators like <code>islice</code> so this is extremely memory efficient, however since I have not extensively tested it I cannot give any guarantee it is bug free.</p>
</div>
<span class="comment-copy">asking for a memory efficient way might suggests you have a way that is not memory efficient. Maybe you would be willing to share it with us to give us something to work with?</span>
<span class="comment-copy">This is the 'needle-in-a-haystack' problem. The <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" rel="nofollow noreferrer">Knuth-Morris-Pratt algorithm</a> is generally considered the most efficient algorithm in terms of time and space complexity. Implement it and see.</span>
<span class="comment-copy">@AkshatMahajan that looks like an algorithm to find a consecutive substring without repeated rechecking, This is not asking for consecutive characters.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen ? OP says he's looking for "indices of all occurrences of subsequence 'abc' in the sequence". KMP is search algorithm for finding occurrence of substring in text. It can be fairly easily generalised to not halt at the first occurrence. Not sure I understand what the issue is.</span>
<span class="comment-copy">yes but finding a word in a text means that all the letters of the word are obviously consecutive (come right after each other) but sub sequence of <code>abc</code> only occurs once in the sequence <code>abccabac</code> right at the beginning.  the indices <code>0 5 7</code> are indices of an <code>a</code> a <code>b</code> and a <code>c</code> but not right next to each other.</span>
<span class="comment-copy">Not sure if you'd call this efficient. Invoking <code>combinations</code> creates 56 elements with this sequence (8 letters) and subsequence (3 letters), which are fairly small inputs, making runtime approximately O(n^2) - I shudder to think what the length would look like for longer text. :P</span>
<span class="comment-copy">maybe not efficient in runtime but it is efficient in memory which is what the question was specifically asking for, I am looking into another way of doing this with sets but the logic is not as simple as this one.</span>
<span class="comment-copy">I'm not sure how it relates to big O notation but combinations always generates <code>n! / r! / (n-r)!</code> where n is the length of the sequence and r is the length of subsequence, I completely agree that this is not at all the best way to do it.</span>
<span class="comment-copy">@TadhgMcDonald-Jensen Thanks ! This is exactly what I am trying to do, my subsequence may not go more than 6-7 chars long, but my sequence may be pretty long, using itertools may make the search space explode.</span>
<span class="comment-copy">@verdict_11 I added a recursive solution, other then heavily relying on concatenating tuples it is fairly memory and execution efficient.</span>
