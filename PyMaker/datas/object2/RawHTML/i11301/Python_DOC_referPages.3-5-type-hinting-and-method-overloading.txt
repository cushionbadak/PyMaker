<div class="post-text" itemprop="text">
<p>Edit: I misunderstood the feature currently. <a href="https://www.python.org/dev/peps/pep-0484/#function-method-overloading" rel="nofollow">It's not designed for multiple dispatch</a>:</p>
<blockquote>
<p>NOTE: While it would be possible to provide a multiple dispatch implementation using this syntax, its implementation would require using sys._getframe() , which is frowned upon. Also, designing and implementing an efficient multiple dispatch mechanism is hard, which is why previous attempts were abandoned in favor of functools.singledispatch() . (See PEP 443 , especially its section "Alternative approaches".) In the future we may come up with a satisfactory multiple dispatch design, but we don't want such a design to be constrained by the overloading syntax defined for type hints in stub files. It is also possible that both features will develop independent from each other (since overloading in the type checker has different use cases and requirements than multiple dispatch at runtime -- e.g. the latter is unlikely to support generic types).</p>
</blockquote>
<p>====</p>
<p>I've been off in Java-land for a while, and I'm returning to Python 3.5. I want to use the new type hinting feature, but I'm having trouble with method overloading. From my reading of the feature, this should be supported. </p>
<p>Here's a quick little class that I'm working on:</p>
<p><strong>licensing.pyi</strong> (note the pyi)</p>
<pre><code>import typing
import gitlab


class LicensingChecker(object):
    @typing.overload
    def __init__(self, url: str, api_key: str) -&gt; None: ...
    @typing.overload
    def __init__(self, gl: gitlab.Gitlab) -&gt; None: ...

    def iter_projects(self) -&gt; typing.Iterator[str]: ...
</code></pre>
<p><strong>licensing.py</strong></p>
<pre><code>import gitlab
import string


class LicenseChecker(object):
    def __init__(self, gl):
        self.gl = gl

    def __init__(self, url, api_key):
        self.gl = gitlab.Gitlab(url, api_key)

    def iter_projects(self):
        p = set()
        for i in string.ascii_lowercase:
            for x in self.gl.projects.search(i):
                if x not in p:
                    p.add(x)
                    yield x.name
</code></pre>
<p>This is a toy example, but the idea is rather conventional. I provide two constructors one that takes an already existing gitlab client and another that will instantiate it. (There's no need for dual constructors for this script, but I saw <code>@typing.overload</code> and wanted to see how it works.)</p>
<p>Pycharm and Cpython seem to be happy with this code, but the first constructor is inaccessible -- like <code>@typing.overload</code> decorator isn't working:</p>
<pre><code>&gt;&gt;&gt; import gitlab
&gt;&gt;&gt; import licensing
&gt;&gt;&gt; licensing.LicenseChecker(gitlab.Gitlab('https://blah.blah.blah/gitlab', 'hunter2'))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: __init__() missing 1 required positional argument: 'api_key'
</code></pre>
<p>Is there something special I have to do to get the overloading working? Presently, I'm just invoking either the built-in REPL or ipython. </p>
</div>
<div class="post-text" itemprop="text">
<p>Untyped Python does not support overloading. Your second <code>__init__</code> is overwriting the first one, thus the error. You need to write a single <code>__init__</code> with runtime type-checking:</p>
<pre><code>def __init__(self, arg1, arg2=None):
    if isinstance(arg1, gitlab.Gitlab) and arg2 is None:
        self.gl = arg1
    elif arg1 is not None and arg2 is not None:
        self.gl = gitlab.Gitlab(arg1, arg2)
    else:
        raise TypeError('........')
</code></pre>
<p>(there is <a href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="nofollow"><code>functools.singledispatch</code></a> which can simulate overloading with only one argument changing type but it is not suitable for your case)</p>
<hr/>
<p>The <code>@typing.overload</code> decorator just tells the type checker there can be multiple combinations of arguments, it does not mean you could write the implementation in two different functions with the same name now. From <a href="https://www.python.org/dev/peps/pep-0484/#function-method-overloading" rel="nofollow">PEP 484</a>:</p>
<blockquote>
<p>Uses of the <code>@overload</code> decorator as shown above are suitable for stub files. In regular modules, a series of <code>@overload</code>-decorated definitions must be followed by <strong>exactly one</strong> non-<code>@overload</code>-decorated definition (for the same function/method). <strong>The <code>@overload</code>-decorated definitions are for the benefit of the type checker only</strong>, since they will be overwritten by the non-<code>@overload</code>-decorated definition, while the latter is used at runtime but should be ignored by a type checker.</p>
</blockquote>
</div>
<span class="comment-copy">The previous constructor appears to have been overridden - does @typing overloading apply to 'non methods'?</span>
<span class="comment-copy">Yeah, I realized type hinting is not for multiple dispatch. I appreciate the effort of trying to implement a method to do this, but that's pretty darn ugly (<code>isinstance</code>, if/else ladder, compound conditionals, throwing <code>TypeError</code>). I don't think it makes any sense to offer a multiple constructor API if the language doesn't provide multiple dispatch. <code>@singledispatch</code> is nearly as ugly. I suppose this is one of those Zen of Python things where the conclusion is "don't do that."</span>
