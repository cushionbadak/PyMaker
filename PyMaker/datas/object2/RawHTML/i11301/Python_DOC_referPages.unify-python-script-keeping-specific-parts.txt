<div class="post-text" itemprop="text">
<p>I want to unify two slightly different scripts.</p>
<p>My idea was to keep the common part in a file (<em>modX.py</em>) and create two other files to gives two different entry points (<em>A.py</em> and <em>B.py</em>). The common part will be called through an 'import'.</p>
<pre><code>from modX import *
</code></pre>
<p>Now, I don't see how I can have specific parts in <em>modX</em>. One idea was to test a variable having different values in <em>A.py</em> and <em>B.py</em>.</p>
<p>In <em>modX.py</em> :</p>
<pre><code>if 'is_A' in globals():
    my_string = "spam"
else:
    my_string = "eggs"
</code></pre>
<p><em>A.py</em> :</p>
<pre><code>is_A = True
from modX import *
print("I love {}".format(my_string))
</code></pre>
<p>How can <em><code>my_string</code></em> get "spam" ?</p>
<p>Altough putting all the common part in a function can be more pythonic, I would avoid refactoring <em>modX.py</em> too much if I can.</p>
</div>
<div class="post-text" itemprop="text">
<p>I've never figured out a way to pass arguments to a module on import — although it would be very useful. However there are ways to work around the limitation which make use of the fact that modules objects are cached in the <code>sys.modules</code> dictionary when they're first imported <strong><em>and</em></strong> can be replaced with an instance of a class. Note that attributes assigned to the class instance (<code>self</code>) effectively become the module's attributes after it's stored in <code>sys.modules</code>.</p>
<p>Here's how that could be used in your example:</p>
<p><strong><code>modX.py</code></strong></p>
<pre><code>import sys

class MyModule(object):
    def __init__(self, arg=None):
        if arg == 'is_A':
            self.my_string = 'spam'
        else:
            self.my_string = 'eggs'

        def called_by(arg):  # nested function - no self
            import sys
            # Replace module entry with new instance of MyModule
            sys.modules[__name__] = MyModule(arg)

        self.called_by = called_by

# Replace module entry in sys.modules[__name__] with a default instance of
# MyModule (and create an additional reference to original module so it's not
# deleted)
_ref, sys.modules[__name__] = sys.modules[__name__], MyModule()
del sys  # clean-up namespace (optional)
</code></pre>
<p><strong><code>A.py</code></strong></p>
<pre><code>from modX import *
called_by('is_A')  # changes modX
from modX import *  # do it again to get modified version

print("I love {}".format(my_string))  # -&gt; I love spam
</code></pre>
<p><strong><code>B.py</code></strong></p>
<pre><code>from modX import *

print("I love {}".format(my_string))  # -&gt; I love eggs
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason that it is not work is because <strong>modX.globals()</strong> is different object the <strong>A.globals()</strong></p>
<p>You do it like that:
In modX.py :</p>
<pre><code>def foo():
    if 'is_A' in globals():
        return "spam"
    else:
        return "eggs"
</code></pre>
<p>A.py :</p>
<pre><code>from modX import *
modX.is_A = True
print("I love {}".format(foo()))
</code></pre>
<p>You can also try to use at <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow">inspect</a> module, maybe you find the way with that. Tell us if it help you.</p>
</div>
<span class="comment-copy">This approach should work, though, as you said, is non pythonic. Are you getting an error when you try this?</span>
<span class="comment-copy">You can't pass arguments to <code>modX</code> through <code>globals()</code> that way.</span>
<span class="comment-copy">Your code snippet works as expected ! This work around implies such tweaking that make it hard to maintain. Anyway, thank you for the interesting explanation.</span>
<span class="comment-copy">You're welcome. Can you be more specific about what about it is difficult to maintain? I might be able to improve the answer...</span>
<span class="comment-copy">It's just quite tricky for my use case. I could spend more time maintaining this part than having the two modules separated.</span>
<span class="comment-copy">In that case it sounds like your design could be improved. Putting common code in separate module and importing it wherever needed is an excellent approach. However the problem appears to be having something uncommon in the module. I suggest you try to refactor your code somehow so <code>modX</code> is <i>more</i> generic — enough so that <code>A.py</code> and <code>B.py</code> can both use it without having to customize its functionality at import-time. Since apparently they both don't need to use <code>modX</code> at the same time, maybe you could just add a module function that configures (assigns values to) some module-level variables.</span>
<span class="comment-copy">I was aware of that solution (that was what I means when I said "putting all the common part in a function"). I was looking for something keeping the original structure of the module.</span>
