<div class="post-text" itemprop="text">
<p>I'm sorry for how basic this question is. </p>
<p>The aim: This is my output from a software program:</p>
<pre><code>1   590 SC  1.000   LEU2_YEAST  100%
1   590 EC  1.000   LEU2_ECOLI  100%
2   467 SC  1.000   FADH_YEAST  100%
2   467 EC  1.000   ADH3_ECOLI  100%
3   463 SC  1.000   6PG1_YEAST  100%
3   463 SC  0.816   6PG2_YEAST
3   463 EC  1.000   6PGD_ECOLI  100%
3   463 EC  0.903   6PG9_ECOLI
4   446 SC  1.000   YME1_YEAST  59%
4   446 EC  1.000   FTSH_ECOLI  100%
5   411 SC  1.000   ADH4_YEAST  100%
5   411 EC  1.000   ADH2_ECOLI  99%
8   256 SC  1.000   ATM1_YEAST  100%
8   256 EC  1.000   HLYB_ECOLI  99%
8   256 EC  0.987   HLY2_ECOLI
9   252 SC  1.000   MDL2_YEAST  100%
9   252 SC  0.203   MDL1_YEAST
9   252 EC  1.000   MSBA_ECOLI  99%
</code></pre>
<p>For those with a biology background, I want to pull out ONLY the reciprocal best hits. For those with a non-biology background, I want to extract the pairs of genes, only if the number in the first column only appears twice.</p>
<p>For example, we can see the number 1 appears twice in the first column of the file:</p>
<pre><code> 1  590 SC  1.000   LEU2_YEAST  100%
 1  590 EC  1.000   LEU2_ECOLI  100%
</code></pre>
<p>but the number 3 appears 4 times appears in the first column of the file:</p>
<pre><code>3   463 SC  1.000   6PG1_YEAST  100%
3   463 SC  0.816   6PG2_YEAST
3   463 EC  1.000   6PGD_ECOLI  100%
3   463 EC  0.903   6PG9_ECOLI
</code></pre>
<p>So for this sample file, the output would look like this:</p>
<pre><code>LEU2_YEAST LEU2_ECOLI
FADH_YEAST ADH3_ECOLI
YME1_YEAST FTSH_ECOLI
ADH4_YEAST ADH2_ECOLI
</code></pre>
<p>As these are the only four pairs of lines in the file.</p>
<p>This is my code:</p>
<pre><code>import sys
Dict1 = {}
for line in open(sys.argv[1]):
    line = line.strip().split()
    if line[0] not in Dict1.keys():
        Dict1[line[0]] = [line[4]] 
    elif line[0] in Dict1.keys():
        Dict1[line[0]].append(line[4])

for i in Dict1.values():
    if len(i) == 2:
        print i[0] + "\t" + i[1] 
</code></pre>
<p>This works, the output it prints is:</p>
<pre><code>LEU2_YEAST  LEU2_ECOLI
FADH_YEAST  ADH3_ECOLI
ADH4_YEAST  ADH2_ECOLI
YME1_YEAST  FTSH_ECOLI
</code></pre>
<p>I'm just curious as to how other people would do it? In reality, my actual data set will have thousands of lines, so I'm wondering if there's a more efficient (either in terms of time or memory) way of doing this? Or how people would add in "checks" to make sure the number only appears twice? At this stage, I have mastered python basics, so I'm looking into ways to design code better.</p>
</div>
<div class="post-text" itemprop="text">
<p>A possible improvement is to change the <code>if line[0] not in Dict1.keys()</code> to <code>if line[0] not in Dict1</code>, since <code>not in Dict1.keys()</code> is a O(n) operation, whereas <code>not in Dict</code> is about O(1).  </p>
<p>I'm not sure about the real performance gain. You should use <a href="https://docs.python.org/3/library/time.html" rel="nofollow">time</a> to figure that out.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your file is sorted by the numbers in the first line, you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow"><code>itertools.groupby</code></a>:</p>
<pre><code>from itertools import groupby
import operator

with open(sys.argv[1]) as infile:
    # split lines and group them by the number in the first column
    groups= groupby([line.strip().split() for line in infile], operator.itemgetter(0))
# convert groups to lists and discard keys
groups= [list(lines) for _, lines in groups]
# discard groups that don't have 2 items and format the output
groups= ['%s\t%s'%(lines[0][4],lines[1][4]) for lines in groups if len(lines)==2]
# alternatively you can use
#   groups= ['\t'.join(zip(*lines)[4]) for lines in groups if len(lines)==2]

print '\n'.join(groups)
</code></pre>
</div>
<span class="comment-copy">"My actual data set will have thousands of lines."  In this case performance will not be an issue.  Your code would have to be very inefficient before performance became a problem.</span>
<span class="comment-copy">If your file is sorted by the first column you can use <code>itertools.groupby</code>.</span>
<span class="comment-copy">If you are using Python 2, <code>Dict1.keys()</code> will create a list each time it is called.  Just do <code>if line[0] not in Dict1:</code>.  Matter of fact don't even do that. Get rid of the if-else and do <code>Dict1.setdefault(line[0], []).append(line[4])</code>.  Also, <code>line.strip().split()</code> will have the same effect as <code>line.split()</code> as <code>split</code> without arguments ignores leading and trailing whitespace.</span>
<span class="comment-copy">For this data set, <code>groupby</code> is definitely the way to go.</span>
<span class="comment-copy">It depends on whether Eva is using Python 2 or Python 3.  In Python 3, <code>dict.keys()</code> returns a view object. The docs state that "Keys views are set-like since their entries are unique and hashable.  [View objects] provide a dynamic view on the dictionaryâ€™s entries, which means that when the dictionary changes, the view reflects these changes."</span>
<span class="comment-copy">From the format of the <code>print</code> statements, looks like Python2.</span>
<span class="comment-copy">Does this work? <code>groupby</code> uses deferred iterators to walk the different group lists (which you construct using <code>list(lines)</code> in the list comprehension). But by this time in your posted code, you are outside the scope of the <code>with</code> statement, so the input file has been closed.  I think your list comprehension, which actually creates the groups, needs to be inside the scope of the <code>with</code> statement. Once that is done, the file can safely be closed.</span>
<span class="comment-copy">@PaulMcGuire Thanks for the heads-up, fixed it by using a list comprehension instead of a generator.</span>
