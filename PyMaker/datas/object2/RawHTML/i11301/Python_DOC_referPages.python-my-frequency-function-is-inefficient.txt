<div class="post-text" itemprop="text">
<p>I'm writing a function that returns the number of times appeared of a word that appeared the most in the list of words.</p>
<pre><code>def max_frequency(words):
    """Returns the number of times appeared of the word that
    appeared the most in a list of words."""

    words_set = set(words)
    words_list = words
    word_dict = {}

    for i in words_set:
        count = []
        for j in words_list:
            if i == j:
                count.append(1)
        word_dict[i] = len(count)

    result_num = 0
    for _, value in word_dict.items():
        if value &gt; result_num:
            result_num = value
    return result_num
</code></pre>
<p>For example:</p>
<pre><code>words = ["Happy", "Happy", "Happy", "Duck", "Duck"]
answer = max_frequency(words)
print(answer)

3
</code></pre>
<p>But this function is slow when dealing with large amount of words in a list, for example, a list of 250,000 words takes over 4 minutes for this function to present the output. So I'm seeking help to tweak this.</p>
<p>I don't want to import anything.</p>
</div>
<div class="post-text" itemprop="text">
<p>While I fully agree with the comments related to your <em>I don't want to import anything</em> statement, I found your question amusing, so let's try it.</p>
<p>You don't need to build a <code>set</code>. Just go directly with <code>words</code>.</p>
<pre><code>words = words = ["Happy", "Happy", "Happy", "Duck", "Duck"]
words_dict = {}

for w in words:
    if w in words_dict:
        words_dict[w] += 1
    else:
        words_dict[w] = 1

result_num = max(words_dict.values())

print(result_num)
# 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To prevent multiple passes of your list for each unique word, you can simply iterate over it once and update dictionary values for each count. </p>
<pre><code>counts = {}
for word in words:
    counts[word] = counts.get(word, 0) + 1
</code></pre>
<p><strong>Outputs</strong>:</p>
<pre><code>&gt;&gt;&gt; print(max(counts.values()))
3
</code></pre>
<hr/>
<p>That being said, this can be done much nicer using a <code>defaultdict</code> instead of <code>get</code> or using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a>... limiting yourself to no imports in Python is never really a good idea if you have the choice. </p>
<p>For instance, using <code>collections.Counter</code>:</p>
<pre><code>from collections import Counter
counter = Counter(words)
most_common = counter.most_common(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this code which is about 760% faster.</p>
<pre><code>def max_frequency(words):
    """Returns the number of times appeared of the word that
    appeared the most in a list of words."""

    count_dict = {}
    max = 0

    for word in words:
        current_count = 0

        if word in count_dict:
            current_count = count_dict[word] = count_dict[word] + 1
        else:
            current_count = count_dict[word] = 1

        if current_count &gt; max:
            max = current_count

    return max
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h3>Data size similar to OP's</h3>
<p>Let's start with a list of words</p>
<pre><code>In [55]: print(words)
['oihwf', 'rpowthj', 'trhok', 'rtpokh', 'tqhpork', 'reaokp', 'eahopk', 'qeaopker', 'okp[qrg', 'okehtq', 'pinjjn', 'rq38na', 'aogopire', "apoe'ak", 'apfobo;444', 'jiaegro', '908qymar', 'pe9irmp4', 'p9itoijar', 'oijor8']
</code></pre>
<p>and compone at random these words to form a text</p>
<pre><code>In [56]: from random import choice
In [57]: text = ' '.join(choice(words) for _ in range(250000))
</code></pre>
<h3>Different methods are possible</h3>
<p>From the text we can have a list of words in the text (note, <code>wl</code> is very different from <code>words</code>...)</p>
<pre><code>In [58]: wl = text.split()
</code></pre>
<p>from this list we want to extract a dictionary, or a dictionary-like object, with a count of the occurrences, we have many options.</p>
<p>First option, we build a dictionary containing all the different words in <code>wl</code> and we set the value, for each key, equal to zero and later we do another loop on the list of words to count the occurrences</p>
<pre><code>In [59]: def count0(wl):
    wd = dict(zip(wl,[0]*len(wl)))
    for w in wl: wd[w] += 1            
    return wd
   ....: 
</code></pre>
<p>Second option, we start with an empty dictionary and use the <code>get()</code> method that allows for a default value</p>
<pre><code>In [60]: def count1(wl):
    wd = dict()                   
    for w in wl: wd[w] = wd.get(w, 0)+1
    return wd
   ....: 
</code></pre>
<p>Third and last option, we use a component of the <em>standard</em> library</p>
<pre><code>In [61]: def count2(wl):
    from collections import Counter
    wc = Counter(wl)
    return wc
   ....: 
</code></pre>
<h1>Is one method better than the others?</h1>
<p>Which is best? the one you like the most... at any rate, here are the respective timings</p>
<pre><code>In [62]: %timeit count0(wl) # start with a dict with 0 values
10 loops, best of 3: 82 ms per loop

In [63]: %timeit count1(wl) # uses .get(key, 0)
10 loops, best of 3: 92 ms per loop

In [64]: %timeit count2(wl) # uses collections.Counter
10 loops, best of 3: 43.8 ms per loop
</code></pre>
<p>As expected, the fastest procedure is the one that uses <code>collections.Counter</code>, but I was a little surprised in noticing that the first option, that makes TWO passes over the data, is faster than the second one... my guess (I mean: guess) is that all the testing for new values is done while instantiating the dictionary, probably inside some <code>C</code> code.</p>
</div>
<span class="comment-copy">"I don't want to import anything." - thats nonsense. The stdlib is there for a reason. If e.g. <code>itertools</code> or <code>collections</code> has something appropriate and you don't use it you should feel bad because that makes you a bad programmer in that moment (only excuse is homework where you are not allowed to use the stdlib etc)</span>
<span class="comment-copy">i think you either <code>don't want to import anything</code> or searching for performance, because these two statements are <i>almost always</i> mutually exclusive</span>
<span class="comment-copy">Great use of dictionary, I never knew .values() existed</span>
<span class="comment-copy">++ for <code>collections.Counter</code> example</span>
