<div class="post-text" itemprop="text">
<p>Up to now I do this:</p>
<pre><code>rets=set(pool.map_async(my_callback, args.hosts).get(60*4))
</code></pre>
<p>If the timeout is hit, I get an exception:</p>
<pre><code> File "/usr/lib/python2.7/multiprocessing/pool.py", line 524, in get
    raise TimeoutError
multiprocessing.TimeoutError
</code></pre>
<p>I would like to handle this gracefully:</p>
<p>The output for all hosts I could reach should go into <code>rets</code> and all hosts which timed out should go into a separate list.</p>
<p>How could this be done?</p>
</div>
<div class="post-text" itemprop="text">
<p>As far as I know, you can't, or at least not with <code>map_async</code>. <code>map_async</code> is a convenience method there to solve a particular problem for a particular use case, and that doesn't match up with what you've got because you want more fine control.</p>
<p>However, you can still do it, you just need to use the more fine-grained methods in the multiprocessing module. In particular, you can add jobs to your pool on the fly by using <code>apply_async</code>, which gives you much more control over how to handle success and failure of individual tasks. </p>
<p>Below is a pretty minimal example that I think does what you want:</p>
<pre><code>from multiprocessing.pool import Pool, TimeoutError
from time import sleep, time


def task_function(xx):
    print('Task %d running' % xx)
    sleep(xx)
    print('Task %d ended' % xx)
    return 'Result of task %d' % xx

pl = Pool()
results = [
    pl.apply_async(task_function, (_xx,)) 
    for _xx in range(10)]

start = time()
wait_until = start + 5

rets = []
timed_out_results = []

for res in results:
    timeout = wait_until - time()
    if timeout &lt; 0:
        timeout = 0

    try:
        rets.append(res.get(timeout))
    except TimeoutError:
        timed_out_results.append(res)

print('%s ended' % (rets,))
print('%s timedout' % (timed_out_results,))
</code></pre>
<p>This runs 10 jobs that print a line, sleep, then print another line. The first sleeps for 0 seconds, the next for 1, the next 2 etc. We timeout the pool after 5 seconds, and so we expect 5 tasks to have finished and 5 tasks to have timed out.</p>
<p><strong>Be aware that</strong> I have not stopped the tasks that are still running, and so in the real world they may continue and finish in the time it takes to print the results. You'll have to work out how much you care about that / what to do about it.</p>
</div>
<span class="comment-copy">try-except is obviously the solution, so I'm wondering what is the catch?</span>
<span class="comment-copy"><code>hosts I could reach</code> goes in <code>try</code>, <code>all hosts which timed out</code> go in <code>TimeoutError exception</code>.... where is the rocket science here?</span>
<span class="comment-copy">@JohnMee you say try-except is the solutions. But how? I my_callback() gets called 100 times in parallel. There is one line in the code: calling map_async(). AFAIK <code>rets</code> is empty if an exception gets raised. How to get two lists: result of  not timed out calls and  list of timed out hosts?</span>
<span class="comment-copy">Ah, i see, the "catch" is that everything is happening in a one-liner.  You'll need to <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.AsyncResult" rel="nofollow noreferrer">trawl through the docs</a> and work out how to break it up into a multiline problem so you have one statement invoking one process and thus can catch the timeout on that one, and no other.</span>
