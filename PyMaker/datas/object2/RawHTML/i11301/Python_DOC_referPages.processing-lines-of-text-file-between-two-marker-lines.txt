<div class="post-text" itemprop="text">
<p>My code processes lines read from a text file (see "Text Processing Details" at end).  I need to amend my code so that it carries out the same task, but only with words in between certain points.</p>
<blockquote>
<p>Code should not bother about this text. Skip it.</p>
<p>*****This is the marker to say where to start working with text. Don't do anything until after these last three asterisks.&gt;***</p>
<p>Work with all of the code in this section</p>
<p>*****Stop working with the text when the first three asterisks are seen*****</p>
<p>Code should not bother about this text. Skip it.</p>
</blockquote>
<p>The markers for all situations are three asterisks. Markers only count when they appear at the beginning and the end of the line.</p>
<p>What should I use to make my code only work in between the second and third set of asterisks?</p>
<h1>Text Processing Details</h1>
<p>My code reads a text file, makes all the words lowercase, and splits the words, putting them into a list:</p>
<pre><code>infile = open(filename, 'r', encoding="utf-8")
text = infile.read().lower().split()
</code></pre>
<p>It then strips that list of all grammatical symbols in the words:</p>
<pre><code>list_of_words = [word.strip('\n"-:\';,.') for word in text]
</code></pre>
<p>Finally, for each word in that list, if it only contains alphabetic symbols, it gets appended to a new list. That list is then returned:</p>
<pre><code>for word in list_of_words:
    if word.isalpha():
        list_2.append(word)
return list_2
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>What appears to be one task, "count the words between two marker lines", is actually several.  Separate the different tasks and decisions into separate functions and generators, and it will be <em>vastly</em> easier.</p>
<p>Step 1:  Separate the file I/O from the word counting.  Why should the word-counting code care where the words came from?</p>
<p>Step 2:  Separate selecting the lines to process from the file handling <em>and</em> the word counting.  Why should the word-counting code be given words it's <em>not</em> supposed to count?  This is still far too big a job for one function, so it will be broken down further.  (This is the part you're asking about.)</p>
<p>Step 3:  Process the text.  You've already done that, more or less.  (I'll assume your text-processing code ends up in a function called <code>words</code>).</p>
<h1>1.  Separate file I/O</h1>
<p>Reading text from a file is really two steps: first, open and read the file, then strip the newline off each line.  These are two jobs.</p>
<pre class="lang-python3 prettyprint-override"><code>def stripped_lines(lines):
    for line in lines:
        stripped_line = line.rstrip('\n')
        yield stripped_line

def lines_from_file(fname):
    with open(fname, 'rt', encoding='utf8') as flines:
        for line in stripped_lines(flines):
            yield line
</code></pre>
<p>Not a hint of your text processing here.  The <code>lines_from_file</code> generator just yield whatever strings were found in the file... after stripping their trailing newline.  (Note that a plain <code>strip()</code> would also remove leading and trailing whitespace, which you have to preserve to identify marker lines.)</p>
<h1>2.  Select only the lines between markers.</h1>
<p>This is really more than one step.  First, you have to know what is and isn't a marker line.  That's just one function.</p>
<p>Then, you have to advance past the first marker (while throwing away any lines encountered), and finally advance to the second marker (while <em>keeping</em> any lines encountered).  Anything after that second marker won't even be read, let alone processed.</p>
<p>Python's generators can <em>almost</em> solve the rest of Step 2 for you.  The only sticking point is that closing marker...  details below.</p>
<h2>2a.  What is and is not a marker line?</h2>
<p>Identifying a marker line is a yes-or-no question, obviously the job of a Boolean function:</p>
<pre class="lang-python3 prettyprint-override"><code>def is_marker_line(line, start='***', end='***'):
    '''
    Marker lines start and end with the given strings, which may not
    overlap.  (A line containing just '***' is not a valid marker line.)
    '''
    min_len = len(start) + len(end)
    if len(line) &lt; min_len:
        return False
    return line.startswith(start) and line.endswith(end)
</code></pre>
<p>Note that a marker line need not (from my reading of your requirements) contain any text between the start and end markers --- six asterisks (<code>'******'</code>) is a valid marker line.</p>
<h2>2b.  Advance past the first marker line.</h2>
<p>This step is now easy: just throw away every line until we find a marker line (and junk it, too).  This function doesn't need to worry about the second marker line, or what if there <em>are</em> no marker lines, or anything else.</p>
<pre class="lang-python3 prettyprint-override"><code>def advance_past_next_marker(lines):
    '''
    Advances the given iterator through the first encountered marker
    line, if any.
    '''
    for line in lines:
        if is_marker_line(line):
            break
</code></pre>
<h2>2c.  Advance past the second marker line, saving content lines.</h2>
<p>A generator could easily yield every line after the "start" marker, but if it discovers there <em>is</em> no "end" marker, there's no way to go back and un-<code>yield</code> those lines.  So, now that you've finally encountered lines you (might) actually care about, you'll have to save them all in a list until you know whether they're valid or not.</p>
<pre class="lang-python3 prettyprint-override"><code>def lines_before_next_marker(lines):
    '''
    Yields all lines up to but not including the next marker line.  If
    no marker line is found, yields no lines.
    '''
    valid_lines = []
    for line in lines:
        if is_marker_line(line):
            break
        valid_lines.append(line)
    else:
        # `for` loop did not break, meaning there was no marker line.
        valid_lines = []
    for content_line in valid_lines:
        yield content_line
</code></pre>
<h2>2d.  Gluing Step 2 together.</h2>
<p>Advance past the first marker, then yield everything until the second marker.</p>
<pre class="lang-python3 prettyprint-override"><code>def lines_between_markers(lines):
    '''
    Yields the lines between the first two marker lines.
    '''
    # Must use the iterator --- if it's merely an iterable (like a list
    # of strings), the call to lines_before_next_marker will restart
    # from the beginning.
    it = iter(lines)
    advance_past_next_marker(it)
    for line in lines_before_next_marker(it):
        yield line
</code></pre>
<p>Testing functions like this with a bunch of input files is annoying.  Testing it with lists of strings is easy, but lists are not generators <em>or</em> iterators, they're iterables.  The one extra <code>it = iter(...)</code> line was worth it.</p>
<h1>3.  Process the selected lines.</h1>
<p>Again, I'm assuming your text processing code is safely wrapped up in a function called <code>words</code>.  The only change is that, instead of opening a file and reading it to produce a list of lines, you're <em>given</em> the lines:</p>
<pre class="lang-python3 prettyprint-override"><code>def words(lines):
    text = '\n'.join(lines).lower().split()
    # Same as before...
</code></pre>
<p>...except that <code>words</code> should probably be a generator, too.</p>
<p>Now, calling <code>words</code> is easy:</p>
<pre class="lang-python3 prettyprint-override"><code>def words_from_file(fname):
    for word in words(lines_between_markers(lines_from_file(fname))):
        yield word
</code></pre>
<p>To get the <code>words_from_file</code> <code>fname</code>, you yield the <code>words</code> found in the <code>lines_between_markers</code>, selected from the <code>lines_from_file</code>...  Not quite English, but close.</p>
<h1>4. Call <code>words_from_file</code> from your program.</h1>
<p>Wherever you already have <code>filename</code> defined --- presumably inside <code>main</code> somewhere --- call <code>words_from_file</code> to get one word at a time:</p>
<pre class="lang-python3 prettyprint-override"><code>filename = ...  # However you defined it before.
for word in words_from_file(filename):
    print(word)
</code></pre>
<p>Or, if you really need those words in a <code>list</code>:</p>
<pre class="lang-python3 prettyprint-override"><code>filename = ...
word_list = list(words_from_file(filename))
</code></pre>
<h1>Conclusion</h1>
<p>That this would have been <em>much</em> harder trying to squeeze it all into one or two functions.  It wasn't just one task or decision, but many.  The key was breaking it into tiny jobs, each of which was easy to understand and test.</p>
<p>The generators got rid of a lot of boilerplate code.  Without generators, almost every function would have required a <code>for</code> loop just to <code>some_list.append(next_item)</code>, like in <code>lines_before_next_marker</code>.</p>
<p>If you have Python 3.3+, the <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow"><code>yield from ...</code> construct</a>, erases even more boilerplate.  Every generator containing a loop like this:</p>
<pre class="lang-python3 prettyprint-override"><code>for line in stripped_lines(flines):
    yield line
</code></pre>
<p>Could be re-written as:</p>
<pre class="lang-python3 prettyprint-override"><code>yield from stripped_lines(flines)
</code></pre>
<p>I counted four of them.</p>
<p>For more on the subject of iterables, generators, and functions that use them, see Ned Batchelder's "<a href="http://nedbatchelder.com/text/iter.html" rel="nofollow">Loop Like a Native</a>", available as a 30-minute <a href="https://www.youtube.com/watch?v=EnSu9hHGq5o" rel="nofollow">video from PyCon US 2013</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I recommend using regular expressions.</p>
<pre><code>from re import compile, findall

exp = compile(r'\*{5}([^\*]+)\*{3}|"([^"]+)"')

infile = open(filename, 'r', encoding="utf-8")

text = infile.read().lower()  # Notice, no .split()
text_exclusive = ' '.join([''.join(block) for block in findall(exp, text)])

# use text_exclusive from this point forward with your code
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can get only the text between your asterisks with regex:</p>
<pre><code>import re
betweenAstericks = re.search(r"\*{5}.+?\*{3}(.+?)\*{3}", text, re.DOTALL).group(1)
</code></pre>
</div>
<span class="comment-copy">What qualifies as a start or end marker isn't very well defined...  How many asterisks make the two "start" markers, 3 or 5-then-3?  Do they have to be separated?  (If the input starts with 8 asterisks in a row, is that <i>both</i> of your "start" markers, or just the first one?)  Do  the markers only count when they appear at the beginning or end of a line, or can they appear anywhere in a line?</span>
<span class="comment-copy">The markers for all situations are three asterisks. Markers only count when they appear at the beginning and the end of the line.</span>
<span class="comment-copy">Using this code then tying it all together inside of a main function like so:    <code>def main():             word_list = list(words_from_file(fname))     for word in word_list:         print(word) main()</code>    Returns this error: "builtins.NameError: name 'fname' is not defined" in regards to the line with this code:    <code>word_list = list(words_from_file(fname))</code></span>
<span class="comment-copy">@Hidden  You used the variable <code>filename</code>, not <code>fname</code>...  I changed it.</span>
<span class="comment-copy">I tried changing the variable names. Still had the same error.</span>
<span class="comment-copy">@Hidden:  I've edited my answer to make it clear that this belongs inside the program you already have.  Call <code>words_from_file</code> wherever you already have <code>filename</code> defined.  (I assumed that was <code>main</code>, since you didn't say otherwise.)</span>
