<div class="post-text" itemprop="text">
<p>My <code>createIndividual</code> function is trying to take a list of lists of lists called <code>courses</code>, and then add members of a global list variable (<code>PEOPLE</code>) to it randomly. The code is:</p>
<pre><code>def createIndividual(courses):
    # Courses is equal to an individual, but
    # without people
    individual = courses.copy()
    for course in individual:
        myPeople = PEOPLE.copy()
        random.shuffle(myPeople)
        for table in course:
            while len(table) &lt; table.maximum:
                table.append(myPeople.pop())
    return individual
</code></pre>
<p>I ran this function a bunch of times, trying to get lots of copies with different results. However, each time it created the exact same results for the <code>course</code> variable within each individual. </p>
<p>The results differed between runs of the program, but were the same within a single run.</p>
<p>An example value of the <code>courses</code> argument would be:</p>
<pre><code>[[[], [], []],
 [[], [], []]]
</code></pre>
<p>The innermost "lists" are actually <code>Table()</code> classes, which have a <code>maximum</code> value defined, but in all other ways act like lists. The <code>maximum</code> attribute of each <code>Table</code> is 3.</p>
<p>The list of <code>PEOPLE</code> would be:</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>The first <code>individual</code> created was:</p>
<pre><code>[[[4, 3, 8], [5, 9, 2], [1, 6, 7]],
 [[4, 3, 8], [5, 9, 2], [1, 6, 7]]]
</code></pre>
<p>The second <code>individual</code> created was:</p>
<pre><code>[[[9, 8, 3], [7, 2, 1], [6, 5, 4]],
 [[9, 8, 3], [7, 2, 1], [6, 5, 4]]]
</code></pre>
<p>These continue with apparent randomness, but each <code>course</code> in the <code>individual</code> is always identical to the other <code>course</code>s within the same <code>individual</code>, regardless of how I change the parameters. </p>
</div>
<div class="post-text" itemprop="text">
<p>This question really needs more detail to answer it with confidence, but since there's a common error that could produce this weird result (and since I wasn't able to reproduce it any other way)...</p>
<p>I think the problem is not in your <code>createIndividual</code> function, but in the data structure you're feeding it.  Here's a bit of my <code>main</code> function that produced exactly the random output you expected:</p>
<pre class="lang-python3 prettyprint-override"><code>from pprint import pprint
# pprint is essential for pretty-printing deeply nested data.

class Table(object):
    ...
    # Guesswork on my part, plus a custom __str__ and __repr__.

def main():
    # This creates a list of two lists-of-three-Tables.
    distinct_courses = [[Table() for __ in range(3)] for __ in range(2)]

    filled_courses = createIndividual(distinct_courses)
    pprint(filled_courses)
</code></pre>
<p>Output:</p>
<pre class="lang-python3 prettyprint-override"><code>[[Table([1, 2, 3]), Table([5, 8, 6]), Table([7, 4, 9])],
 [Table([7, 5, 3]), Table([2, 6, 8]), Table([9, 1, 4])]]
</code></pre>
<p>To reproduce your problem, I had to create <code>courses</code> using the list-multiplication syntax, which doesn't do what most beginners (and some tutorials) think it does:</p>
<blockquote>
<h2><a href="https://docs.python.org/3/library/stdtypes.html#typesseq-common" rel="nofollow">4.6.1. Common Sequence Operations</a></h2>
<p>[table omitted]</p>
<p>Notes:</p>
<ol start="2">
<li>[...]  Note that items in the sequence <em>s</em> are not copied; they are referenced multiple times. This often haunts new Python programmers; [...]</li>
</ol>
<p>Further explanation is available in the FAQ entry <a href="https://docs.python.org/3/faq/programming.html#faq-multidimensional-list" rel="nofollow">How do I create a multidimensional list?</a>.</p>
</blockquote>
<p>I'm guessing somewhere in your code, you did something like this:</p>
<pre class="lang-python3 prettyprint-override"><code>def bogus_main():
    # This creates a single lists-of-three-Tables...
    course = [Table() for __ in range(3)]
    # ...then creates a list of two references to the _same_ list.
    aliased_courses = [course] * 2

    filled_courses = createIndividual(aliased_courses)
    pprint(filled_courses)
</code></pre>
<p>Output using the aliased lists:</p>
<pre class="lang-python3 prettyprint-override"><code>[[Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])],
 [Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])]]
</code></pre>
<p>Since both <code>courses[0]</code> and <code>courses[1]</code> point to the <em>same</em> list, two weird things happen.  First, the contents of the "two" <code>course</code>s will be the same, as you've already noticed.  Each update seems to add a pair of identical <code>Table</code>s to two different lists, although it's really just adding one <code>Table</code> to one list... and then printing that list twice...  You can see this in action by adding an extra <code>pprint</code> to <code>createIndividual</code>:</p>
<pre class="lang-python3 prettyprint-override"><code>[[Table([]), Table([]), Table([])],
 [Table([]), Table([]), Table([])]]

[[Table([7, 9, 2]), Table([]), Table([])],
 [Table([7, 9, 2]), Table([]), Table([])]]

[[Table([7, 9, 2]), Table([8, 6, 1]), Table([])],
 [Table([7, 9, 2]), Table([8, 6, 1]), Table([])]]

[[Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])],
 [Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])]]

[[Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])],
 [Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])]]

[[Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])],
 [Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])]]

[[Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])],
 [Table([7, 9, 2]), Table([8, 6, 1]), Table([5, 3, 4])]]
</code></pre>
<p>Second, notice how the last three "updates" don't actually change anything?  Something <em>should</em> have failed when you tried to add 18 values to only 9 slots.  Unfortunately, the <code>maximum</code> field that protects you from over-filling a <code>Table</code> also saves you from the error that could have tipped you off earlier.  From <code>createIndividual</code>:</p>
<pre class="lang-python3 prettyprint-override"><code>for table in course:
    while len(table) &lt; table.maximum:
        # Once the "first" aliased course list is full, this will
        # never pop another person, because there's no place to
        # store them.
        table.append(myPeople.pop())
    print(len(myPeople))  # My addition.
    # Prints 6, 3, and 0 during the first `course`, then prints
    # 9, 9, and 9... myPeople never changes the second time through.
</code></pre>
<p>After the "first" (really, the only) three <code>Table</code>s are filled, they're all at <code>maximum</code> length, so neither <code>individual</code> or <code>myPeople</code> will change again.</p>
<p>Contrast the list-comprehension version in my <code>main</code>, which creates six different <code>Table</code> objects, like you'd expect:</p>
<pre class="lang-python3 prettyprint-override"><code>[[Table([]), Table([]), Table([])],
 [Table([]), Table([]), Table([])]]

[[Table([1, 2, 3]), Table([]), Table([])],
 [Table([]), Table([]), Table([])]]

[[Table([1, 2, 3]), Table([5, 8, 6]), Table([])],
 [Table([]), Table([]), Table([])]]

[[Table([1, 2, 3]), Table([5, 8, 6]), Table([7, 4, 9])],
 [Table([]), Table([]), Table([])]]

[[Table([1, 2, 3]), Table([5, 8, 6]), Table([7, 4, 9])],
 [Table([7, 5, 3]), Table([]), Table([])]]

[[Table([1, 2, 3]), Table([5, 8, 6]), Table([7, 4, 9])],
 [Table([7, 5, 3]), Table([2, 6, 8]), Table([])]]

[[Table([1, 2, 3]), Table([5, 8, 6]), Table([7, 4, 9])],
 [Table([7, 5, 3]), Table([2, 6, 8]), Table([9, 1, 4])]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have to use <code>deepcopy</code> because your lists store another lists and you have to copy them too. Look for examples: <a href="http://www.python-course.eu/deep_copy.php" rel="nofollow">http://www.python-course.eu/deep_copy.php</a></p>
</div>
<span class="comment-copy">Among other possible problems, you appear to be creating a shuffled copy of <code>PEOPLE</code>, and then using that one copy to fill a bunch of <code>table</code>s (lists?), without verifying you have enough people to do so.  If it ever runs out, <code>myPeople.pop()</code> will raise <code>IndexError: pop from empty list</code>.</span>
<span class="comment-copy">Also, what exactly is passed as the argument to the <code>courses</code> parameter?  It <i>can't</i> be a list of lists, because a <code>list</code> doesn't have a <code>copy</code> method.  (Also, I really don't understand what you mean by "<code>courses</code> is equal to an individual, but without people".</span>
<span class="comment-copy">Lists don't have a <code>.maximum</code> either, come to think of it.  There's <i>no way</i> <code>courses</code> or <code>table</code> are normal Python lists.  Please (re-)read how to create a "<a href="https://stackoverflow.com/help/mcve">Minimal, Complete, and Verifiable example</a>", and then <a href="https://stackoverflow.com/posts/37647863/edit">edit</a> your post to include the information we need to answer it.</span>
<span class="comment-copy">Sorry @KevinJ.Chase. I really appreciate your help- I haven't been on Stackoverflow long, still trying to learn how to ask well.</span>
<span class="comment-copy">Looks like lists <i>do</i> have <code>copy</code> methods in  recent versions of Python.  From <a href="https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types" rel="nofollow noreferrer">4.6.3. Mutable Sequence Types</a>, note 5:  "<i>New in version 3.3</i>: <code>clear()</code> and <code>copy()</code> methods.".   I only had an older version of Python handy when I wrote that comment.</span>
<span class="comment-copy">Wow. This is exactly what I did. Thank you so much for your time and effort; I had no idea the problem could lie there. This is an amazing answer- and a great lesson on how list-multiplication syntax works. I kept seeing other people using it, and thought I'd try it. Thank you again so much!</span>
<span class="comment-copy">@PaulBuga:  List multiplication is a shortcut that I really don't think is worth the confusion.  It can work if the list contains <i>only</i> immutable values (meaning it can't contain another list, among other things), or if you <i>never</i> alter it or anything it contains.  Also, there are a few occasions where you really do want lists of aliases... but not many.  I just avoid it.</span>
<span class="comment-copy">Good to know. Thank you so much again!</span>
<span class="comment-copy">Thanks! Never knew that could be an issue.</span>
<span class="comment-copy">Well, I've changed the line 4 to be myPeople = deepcopy(PEOPLE), and line 2 to be individual = deepcopy(courses) and the same issue happens.</span>
<span class="comment-copy">Show  code where <code>courses</code> and <code>PEOPLE</code> are defined.</span>
