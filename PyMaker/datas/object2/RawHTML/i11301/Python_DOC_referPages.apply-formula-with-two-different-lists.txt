<div class="post-text" itemprop="text">
<p>I have two lists like this:</p>
<pre><code>listA = [51, 988, 1336, 2067, 1857, 3160]
listB = [1, 2, 3, 4, 5, 6]
</code></pre>
<p>I have to apply this formula in the lists:</p>
<pre><code>n / pi * ((x*0.1)+1)**2 - pi * (x*0.1)**2
</code></pre>
<p>The 'n' is the elements of listA, 'x' is the elements that correspond to the same index of 'n' in listB.</p>
<p>I need to apply this formula to all the elements in both list. So that when the loop runs the first time it needs to do this:</p>
<pre><code>51/pi*((1*0.1)+1)**2 - pi *(1*0.1)**2
</code></pre>
<p>For the second this, it needs to do this:</p>
<pre><code>988/pi*((2*0.1)+1)**2 - pi*(2*0.1)**2
</code></pre>
<p>And it repeats until the end of both lists.</p>
<p>I know I have to use a 'for' loop, but my problem is that I don't know how to get the elements from the second list. I'm trying to do this:</p>
<pre><code>for n in listA:
   n/pi*((......))
</code></pre>
<p>Inside thhe brackets it should be the elements from listB but I don't know how to get them, and they need to have the same index as the element from listA.
The output should be a third list with the result of each formula applied.</p>
<p>I have tried to explained myself the best way possible, but if you don't understand my question feel free to ask any question. </p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>I assume both lists have the same size all the time, most pythonic way is to use lambda and list comprehensions:</p>
<pre><code>listA = [51, 988, 1336, 2067, 1857, 3160]
listB = [1, 2, 3, 4, 5, 6]

from math import pi

formula = lambda n,x: n / pi * ((x*0.1)+1)**2 - pi * (x*0.1)**2

res = [ formula(a,b) for a,b in zip(listA,listB) ]

&gt;&gt; [19.621466242038217,
 452.96994140127384,
 718.7747248407644,
 1289.7268993630569,
 1329.8678662420382,
 2575.175332484077]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code></a> them:</p>
<pre><code>for a, b in zip([1,2,3], [4,5,6]):
  print a, b
</code></pre>
<p>will yield</p>
<pre><code>1 4
2 5
3 6
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>numpy <strong>vectorized</strong> approach will be <strong>much</strong> faster compared to regular for/list comprehension/etc. especially on big lists:</p>
<pre><code>import numpy as np

listA = np.array([51, 988, 1336, 2067, 1857, 3160])
listB = np.array([1, 2, 3, 4, 5, 6])
result = listA / np.pi * ((listB*0.1)+1)**2 - np.pi * (listB*0.1)**2
</code></pre>
<p>Output:</p>
<pre><code>In [175]: result
Out[175]: array([   19.61148715,   452.74017757,   718.41005008,  1289.07255327,  1329.19288378,  2573.86868192])
</code></pre>
<p><strong>Timing and comparison on two 1M lists:</strong></p>
<pre><code>In [183]: A = np.random.randint(1,100, 10**6)

In [184]: B = np.random.randint(1,100, 10**6)

In [185]: formula = lambda n,x: n / pi * ((x*0.1)+1)**2 - pi * (x*0.1)**2
</code></pre>
<p>Vectorized numpy approach:</p>
<pre><code>In [186]: %timeit formula(A, B)
10 loops, best of 3: 65.4 ms per loop
</code></pre>
<p>List comprehension:</p>
<pre><code>In [191]: %timeit [ formula(a,b) for a,b in zip(A.tolist(),B.tolist()) ]
1 loop, best of 3: 3.6 s per loop
</code></pre>
<p><strong>Conclusion:</strong> vectorized approach is 55 times faster</p>
</div>
<div class="post-text" itemprop="text">
<p>This code for first formula:</p>
<pre><code>from math import pi

def func(l1, l2):
    l = list()
    for x,n in zip(l1, l2):
        l.append(n / pi * ((x*0.1)+1)**2 - pi * (x*0.1)**2)
    return l

listA = [51, 988, 1336, 2067, 1857, 3160]
listB = [1, 2, 3, 4, 5, 6]
print  func(listA, listB)
</code></pre>
<p>Output:</p>
<pre><code>[-69.86851405497168, -24325.709794885548, -38773.5481974975,   
 -79297.55058963387, -52859.75700368613, -121787.02310052476]
</code></pre>
</div>
<span class="comment-copy">They have to be calculated after formula 1, until the end of both lists</span>
<span class="comment-copy">You need to print result or store?</span>
<span class="comment-copy">I need to return it, since this will happend inside a function</span>
<span class="comment-copy">OK, look to code.</span>
