<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/22077881/yes-reporting-error-with-subprocess-communicate">'yes' reporting error with subprocess communicate()</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I'm trying to launch several bash routines
from a GUI based software. The problem I'm facing is a piping issue.
Here the test bash-script (<em>bashScriptTest.sh</em>):</p>
<pre><code>#!/bin/bash
#---------- Working
ls | sort | grep d &gt; testFile.txt
cat testFile.txt
#---------- NOT working
echo $RANDOM &gt; testFile2.txt
for i in `seq 1 15000`; do
    echo $RANDOM &gt;&gt; testFile2.txt
done
awk '{print $1}' testFile2.txt | sort -g | head -1
</code></pre>
<p>And here the python script that creates the error:</p>
<pre><code>import subprocess
#
with open('log.txt','w') as outfile:
    CLEAN=subprocess.Popen("./bashScriptTest.sh", stdout=outfile, stderr=outfile)
    print CLEAN.pid
    OUTSEE=subprocess.Popen(['x-terminal-emulator', '-e','tail -f '+outfile.name])
</code></pre>
<p>As you can see from running the python script, the Broken-pipe error is encountered 
not in the first three pipes (first line) but instead after the huge work done by awk.
I need to manage an huge quantities of routine and subroutines in bash
and also using the shell==True flag doesn't change a thing.
I tried to write everything in the most pythonic way but unfortunately there is no
chance I can rewrite all the piping step inside python.
Another thing to mention is that if you test the bash script inside a terminal 
everything works fine.
Any help would be really appreciated. Thanks in advance!</p>
<p><strong>EDIT 1:</strong></p>
<p>The log file containing the error says:</p>
<pre><code>bashScriptTest.sh
log.txt
stack.txt
testFile2.txt
test.py
3
sort: write failed: standard output: Broken pipe
sort: write error
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Okay so this is a little bit obscure, but it just so happens that I ran across a similar issue while researching a <a href="https://mail.python.org/pipermail/tutor/2007-October/thread.html#58040" rel="nofollow">question on the python-tutor mailing list</a> some time ago. </p>
<p>The reason you're seeing different behavior when running your script via the subprocess module (in python) vs. bash directly, is that python overrides the disposition of SIGPIPEs to SIG_IGN (ignore) for all child processes (globally). </p>
<p>When the following pipeline is executed ...</p>
<pre><code>awk '{print $1}' testFile2.txt | sort -g | head -1
</code></pre>
<p>... <code>head</code> will exit after it prints the first line of stdout from the <code>sort</code> command, due to the <code>-1</code> flag. When the <code>sort</code> command attempts to write more lines to its stdout, a SIGPIPE is raised. </p>
<p>The default action of a SIGPIPE; when the pipeline is executed in a shell like bash, for example; is to terminate the sort command. </p>
<p>As stated earlier, python overrides the default action with SIG_IGN (ignore), so we end up with this bizarre, and somewhat inexplicable, behavior.</p>
<hr/>
<p>That's all well and good, but you might be wondering what to do now? It's dependant on the version of python you're using ... </p>
<p>For Python 3.2 and greater, you're already set. <a href="https://docs.python.org/3/library/subprocess.html#popen-constructor" rel="nofollow"><code>subprocess.Popen</code> in 3.2</a> added the <code>restore_signals</code> parameter, which defaults to <code>True</code>, and effectively solves the issue without further action. </p>
<p>For previous versions, you can supply a callable to the <code>preexec_fn</code> argument of <code>subprocess.Popen</code>, as in ... </p>
<pre><code>import signal
def default_sigpipe():
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)

# ...

with open('log.txt','w') as outfile:
    CLEAN=subprocess.Popen("./bashScriptTest.sh", 
                           stdout=outfile, stderr=outfile
                           preexec_fn=default_sigpipe)
</code></pre>
<p>I hope that helps!</p>
<p><strong>EDIT:</strong> It should probably be noted that your program is actually functioning properly, AFAICT, as is. You're just seeing additional error messages that you wouldn't normally see when executing the script in a shell directly (for the reasons stated above). </p>
<p>See Also:</p>
<ul>
<li><a href="https://mail.python.org/pipermail/python-dev/2007-July/073831.html" rel="nofollow">https://mail.python.org/pipermail/python-dev/2007-July/073831.html</a></li>
<li><a href="https://bugs.python.org/issue1652" rel="nofollow">https://bugs.python.org/issue1652</a></li>
</ul>
</div>
<span class="comment-copy">Please add the error message and stack trace! :)</span>
<span class="comment-copy">When do you wait for the processes to end?</span>
<span class="comment-copy">@Andr√©Laszlo I've edited the question!</span>
<span class="comment-copy">@busfault I don't think I understand your question.</span>
<span class="comment-copy">@SergeBallesta I don't think the problem is in my program, but instead is inside python's subprocess module. I've just recreated the error. This happens just by calling those 5 lines of python code to run the bash-script.</span>
<span class="comment-copy">Thanks really a lot...it fixed my problem, really strange issue for Python. Glad they solved during development</span>
<span class="comment-copy">Your <code>default_sigpipe()</code> function changes state globally. I think this is a mistake. Simply doing this once will have the same effect:  <code>signal.signal(signal.SIGPIPE, signal.SIG_DFL)</code></span>
