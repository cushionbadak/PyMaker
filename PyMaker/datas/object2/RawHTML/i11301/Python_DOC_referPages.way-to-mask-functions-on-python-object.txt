<div class="post-text" itemprop="text">
<p>I have a class that inherit from OrderedDict, but I don't know if this is the right way to accomplish what I need.  </p>
<p>I would like the class to have the duel method of the javascript '.' notation like <code>obj.&lt;property&gt;</code> and I would also like the users to be able to access the class properties like <code>obj['myproperty']</code> but I was to hide all the key() and get() functions.  The inheritance model is providing good functionality, but it cluttering up the object with additional methods that are not really needed.</p>
<p>Is it possible to get the dictionary behavior without all the other functions coming along?  </p>
<p>For this discussion, let's assume my class is this:</p>
<pre><code>from six.moves.urllib import request
import json
class MyClass(OrderedDict):
     def __init__(self, url):
        super(MyClass, self).__init__(url=url)
        self._url = url
        self.init()
     def init(self):
        # call the url and load the json
        req = request.Request(self._url)
        res = json.loads(request.urlopen(req).read())
        for k,v in res.items():
           setattr(self, k, v)
        self.update(res)
        self.__dict__.update(res)

if __name__ == "__main__":
    url = "https://sampleserver5.arcgisonline.com/ArcGIS/rest/services?f=json"
    props = MyClass(url=url)
    props.currentVersion
</code></pre>
<p>Is there another way to approach this dilemma? </p>
<p>Thanks</p>
</div>
<div class="post-text" itemprop="text">
<p>If all you want is <code>x['a']</code> to work the same way as <code>x.a</code> without any other functionality of dictionaries, then don't inherit from <code>dict</code> or <code>OrderedDict</code>, instead just forward key/indice operations (<a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow"><code>__getitem__</code>, <code>__setitem__</code> and <code>__delitem__</code></a>) to <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow">attribute operations</a>:</p>
<pre><code>class MyClass(object):
    def __getitem__(self,key):
        try: #change the error to a KeyError if the attribute doesn't exist
            return getattr(self,key)
        except AttributeError:
            pass
        raise KeyError(key)

    def __setitem__(self,key,value):
        setattr(self,key,value)
    def __delitem__(self,key):
        delattr(self,key)
</code></pre>
<p>As an added bonus, because these special methods don't check the instance variables for the method name it doesn't break if you use the same names:</p>
<pre><code>x = MyClass()
x['__getitem__'] = 1
print(x.__getitem__) #still works
print(x["__getattr__"]) #still works
</code></pre>
<p>The only time it will break is when trying to use <code>__dict__</code> since that is where the instance variables are actually stored:</p>
<pre><code>&gt;&gt;&gt; x = MyClass()
&gt;&gt;&gt; x.a = 4
&gt;&gt;&gt; x.__dict__ = 1 #stops you right away
Traceback (most recent call last):
  File "&lt;pyshell#36&gt;", line 1, in &lt;module&gt;
    x.__dict__ = 1
TypeError: __dict__ must be set to a dictionary, not a 'int'
&gt;&gt;&gt; x.__dict__ = {} #this is legal but removes all the previously stored values!
&gt;&gt;&gt; x.a
Traceback (most recent call last):
  File "&lt;pyshell#38&gt;", line 1, in &lt;module&gt;
    x.a
AttributeError: 'MyClass' object has no attribute 'a'
</code></pre>
<p>In addition you can still use the normal dictionary methods by using <code>vars()</code>:</p>
<pre><code>x = MyClass()
x.a = 4
x['b'] = 6
for k,v in vars(x).items():
    print((k,v))

#output
('b', 6)
('a', 4)
&gt;&gt;&gt; vars(x)
{'b': 6, 'a': 4}
</code></pre>
</div>
<span class="comment-copy">@LutzHorn I saw this post, and I felt it was different enough.</span>
<span class="comment-copy">@LutzHorn - I know that, but I feel this is more about should dictionary be used for inheritance in mimicking the bracket method and JS dot notation than in 'private'.  I think you are too quick to bounce :)</span>
<span class="comment-copy">Then maybe don't use inheritance but a facade.</span>
<span class="comment-copy">Can you remove the duplication flag so other can provide answers?  Duplication is like the kiss of death here.</span>
<span class="comment-copy">@josh1234 why do you want to use OrderedDict if you don't want to use <code>.keys()</code> or <code>.items()</code> or other methods that accompany dictionaries?  you may consider looking at <a href="http://stackoverflow.com/questions/4984647/accessing-dict-keys-like-an-attribute-in-python">Accessing dict keys like an attribute in Python?</a> if you have not already but if you only need lookups I'd think it would be more beneficial to forward dictionary lookups to attribute lookups so that you don't need to inherit from <code>dict</code> at all.</span>
<span class="comment-copy">This question is tagged with both Python 2.7 and Python 3.x, so you might want to ask if the OP really wants both. If so, I think you'll have to drop <code>raise ... from</code>.</span>
<span class="comment-copy">thanks, changed it so I believe it works identically for both versions now.</span>
