<div class="post-text" itemprop="text">
<p>I have a nested list in Python as:</p>
<pre><code>lst = ['alpha', ['beta', 'gamma'], ['delta', 'peta', 'lambda']]
</code></pre>
<p>I need a function that will return a list having the Cartesian product of them. Well, I think Cartesian product is not a right word, but still in a logical way the result will look like:</p>
<pre><code>final_lst = your_magical_function(lst)
print final_lst

'''
[['alpha','beta','delta'],
['alpha','beta','peta'],
['alpha','beta','lambda'],
['alpha','gamma','delta'],
['alpha','gamma','peta']
['alpha','gamma','lambda']]
'''
</code></pre>
<p>A function with recursion or without, both are welcomed.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use<a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a>, which will require you to slightly modify your input (<code>'alpha'</code> to <code>['alpha']</code>):</p>
<pre><code>from itertools import product

lst = [['alpha'],['beta','gamma'],['delta','peta','lambda']]

for res in product(*lst):
    print(res)

&gt;&gt; ('alpha', 'beta', 'delta')

('alpha', 'beta', 'peta')
('alpha', 'beta', 'lambda')
('alpha', 'gamma', 'delta')
('alpha', 'gamma', 'peta')
('alpha', 'gamma', 'lambda') 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/2/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product</code></a> once you've converted all the items to lists:</p>
<pre><code>&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; lst = ['alpha',['beta','gamma'],['delta','peta','lambda']]
&gt;&gt;&gt; list(product(*(x if isinstance(x, list) else [x] for x in lst)))
[('alpha', 'beta', 'delta'), ('alpha', 'beta', 'peta'), ('alpha', 'beta', 'lambda'), ('alpha', 'gamma', 'delta'), ('alpha', 'gamma', 'peta'), ('alpha', 'gamma', 'lambda')]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is great to use libraries in Python! However, if you are looking for a pure Python implementation:</p>
<pre><code>def CartesianProduct(list_entry):
# Save Sizes of Everything
size_dictionary = {}

# Get Size of Entire Entry List
size_dictionary["full_size"] = len(list_entry)

# Get Sizes of All Sub Entries
for i in range(len(list_entry)):
    if not (isinstance(list_entry[i],list)):
        list_entry[i] = [list_entry[i]]
    size_dictionary[i] = len(list_entry[i])

# Now lets create the cartesian product
# Lets Create a Dictionary to hold all of the results
cartesian_result = {}

# Lets get the size of the final result
final_result_amount = 1
for i in range(size_dictionary["full_size"]):
    final_result_amount = final_result_amount * size_dictionary[i]

# And create the final results
for i in range(final_result_amount):
    cartesian_result[i] = []

    for j in range(size_dictionary["full_size"]):
        cartesian_result[i].append(list_entry[j][i % size_dictionary[j]])

    print(cartesian_result[i])

def main():
    lst = ['alpha',['beta','gamma'],['delta','peta','lambda']]
    CartesianProduct(lst)

main()
</code></pre>
<p>It is not nearly as pretty and simple as using itertools, but nonetheless it is fun to implement the logic that the libraries use once in awhile.</p>
</div>
<span class="comment-copy">Why do you have to use recursion?</span>
<span class="comment-copy">It's okay, I dont really need a recursive function.</span>
