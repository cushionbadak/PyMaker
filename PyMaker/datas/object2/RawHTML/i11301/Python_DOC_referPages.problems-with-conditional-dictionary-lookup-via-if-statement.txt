<div class="post-text" itemprop="text">
<p>I have a dictionary which I am populating with values. The values are served to the dictionary through a for-loop.</p>
<pre><code>storageDict = {}
listholder = ["word1", "word2", "word2", "word3", "word4", "word5", "word6", "word7"]
values = ["word1", "word2", "word3", "word2", "word5", "word6", "word7", "word8"]
index_tracker = 0

for each_element in listholder:
    if index_tracker == 7:
        pass
    else:
        storageDict[str(each_element)] = values[index_tracker]
        index_tracker += 1

print(storageDict)
</code></pre>
<p>This gives me the following output:</p>
<pre><code> {'word5': 'word6', 'word1': 'word1', 'word3': 'word2', 'word4': 'word5', 'word6': 'word7', 'word2': 'word3'}
</code></pre>
<p>While all key-value combinations are unique I would like to avoid any scenarios whereby the dictionary contains a key-value combination that is the same as the value-key combination. i.e In the dictionary above we have the following two key-value combinations:</p>
<ul>
<li><code>'word3': 'word2'</code></li>
<li><code>'word2': 'word3'</code></li>
</ul>
<p>I would therefore like to check whether a value-key combination and key-value combination is already in the dictionary before committing it to the dict. I came up with the following code, but PyCharm is giving me a <code>KeyError</code>:</p>
<pre><code>storageDict = {}
listholder = ["word1", "word2", "word2", "word3", "word4", "word5", "word6", "word7"]
values = ["word1", "word2", "word3", "word2", "word5", "word6", "word7", "word8"]
index_tracker = 0

for each_element in listholder:
    if index_tracker == 7:
        pass
    else:
        if storageDict[each_element] == values[index_tracker] and storageDict[values[index_tracker]] == each_element:
             pass
        else:
            storageDict[each_element] = values[index_tracker]
            index_tracker += 1

print(storageDict)
</code></pre>
<p>My desired output is one for the two scenarios:</p>
<pre><code>    {'word5': 'word6', 'word1': 'word1', 'word4': 'word5', 'word6': 'word7', 'word2': 'word3'}
</code></pre>
<p>or:</p>
<pre><code>    {'word5': 'word6', 'word1': 'word1', 'word3': 'word2', 'word4': 'word5', 'word6': 'word7'}
</code></pre>
<p>Here's the <code>KeyError</code>:</p>
<pre><code>Traceback (most recent call last):
File "C:/Users/Admin/PycharmProjects/momely/placementarchitect/testbench.py", line 42, in &lt;module&gt;
if storageDict[each_element] == values[index_tracker] and storageDict[values[index_tracker]] == each_element:
KeyError: 'word1'
</code></pre>
<p>I believe I understand why the error occurs. By including my check in the conditional if statement I am requesting the key-value for a dictionary key that doesn't exist yet.</p>
<p>But how would anyone check a key-value then?</p>
<p>I considered working with tuples instead but will require the dictionary's fast loopup in a different operation.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one way to do it. I basically <a href="https://docs.python.org/2/library/functions.html#zip" rel="nofollow">zip</a> them, filter the entries we don't need and then convert the filtered list into <a href="https://docs.python.org/2/library/functions.html#func-dict" rel="nofollow">dict</a>.</p>
<pre><code>listholder = ["word1", "word2", "word2", "word3", "word4", "word5", "word6", "word7"]
values = ["word1", "word2", "word3", "word2", "word5", "word6", "word7", "word8"]
filtered = []
allItems = zip(listholder, values)
for key, value in allItems:
    if not ( (key,value) in filtered or (value, key) in filtered):
        filtered.append((key,value))
print dict(filtered)
</code></pre>
<p>Output:</p>
<pre><code>{'word5': 'word6', 'word4': 'word5', 'word7': 'word8', 'word6': 'word7', 'word1': 'word1', 'word2': 'word3'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>RESPONSE INACCURATE</strong></p>
<p>Ok. With the help of @spectras and @wwii (thank you for pointing me in the right direction) I was able to come up with a solution. The issue was in the way I set up my logical check in combination with not using the some_dict.get(item) method. </p>
<p>Here the solution:</p>
<pre><code>storageDict = {}
listholder = ["word1", "word2", "word2", "word3", "word4", "word5", "word6", "word7"]
values = ["word1", "word2", "word3", "word2", "word5", "word6", "word7", "word8"]
index_tracker = 0

for each_element in listholder:
    if index_tracker == 7:
        pass
    else:
        if storageDict.get(each_element) == storageDict.get(values[index_tracker]) and each_element == storageDict.get(values[index_tracker]):
            pass
        else:
            storageDict[each_element] = values[index_tracker]
        index_tracker += 1

print(storageDict)
</code></pre>
<p>This generates the output as desired:</p>
<pre><code>{'word5': 'word2', 'word7': 'word6', 'word6': 'word5', 'word2': 'word1', 'word3': 'word2', 'word4': 'word3'}
</code></pre>
<p>Thank you everyone for your useful tips. This really helped me resolve this.</p>
<p>M</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>zip</code> on both list and check if a key-value pair has an alternate value-key pair in the dictionary:</p>
<pre><code>d = {}

for k, v in list(zip(listholder, values))[:-1]:
    if v in d:
        if d[v] == k:
            continue
    d[k] = v

print(d)
# {'word5': 'word6', 'word4': 'word5', 'word2': 'word3', 'word1': 'word1', 'word6': 'word7'}
</code></pre>
<p>Existing keys get updated in your original code, and you're skipping the last items in both lists. I have replicated those here.</p>
</div>
<span class="comment-copy">Actually what is your expecting output ?</span>
<span class="comment-copy">Hi there. My desired output is this: {'word5': 'word6', 'word1': 'word1', 'word3': 'word2', 'word4': 'word5', 'word6': 'word7'}. Will add above.</span>
<span class="comment-copy">You can check that <code>item in some_dict</code> =&gt; <code>True</code> if <code>some_dict</code> has <code>item</code> as a key. Or you can just handle the <code>KeyError</code> exception. Or you can use the <code>dict.get</code> method, <code>some_dict.get(item)</code> will return the value if there is such a key, or  Ì€None` if there is not.</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/stdtypes.html#dict.get" rel="nofollow noreferrer"><code>dict.get</code></a> is made for this.</span>
<span class="comment-copy">Hi there. That is one part of the solution. But this won't solve my problem exactly. If I used some_dict.get(item) in the if statement instead (if storageDict.get(each_element) == values[index_tracker] and storageDict.get(values[index_tracker]) == each_element:). I get the same output: {'word2': 'word3', 'word5': 'word6', 'word6': 'word7', 'word3': 'word2', 'word4': 'word5', 'word1': 'word1'}. Here the combinations 'word2': 'word3', and 'word3': 'word2' are still there.</span>
<span class="comment-copy">The entry  'word1': 'word1' is missing in this. From your comment below the question it seems you wanted that?</span>
<span class="comment-copy">Oh yeah! You are right! NOW i need to down-vote my own response! LOL! Thank you for picking that up!</span>
<span class="comment-copy">No problem. There are multiple ways to solve this. I posted one such way.</span>
