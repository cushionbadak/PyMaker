<div class="post-text" itemprop="text">
<p>I have two lists: one contain the name of pages like <code>['Barrel - Part 1', 'Petit Trees (sketch)', 'Island (sketch)']</code> and the other list contain the corresponding page number like <code>[1, 2, 3]</code></p>
<p>I want to create a dictionary from two lists such that the splitted words from list one as a key and corresponding value from list two as value. And if key already is in dictionary then append value to it.</p>
<p>For the above example I want a dictionary like:</p>
<pre><code>{
 'Barrel': [1],
 '-': [1],
 'Part': [1],
 '1': [1],
 'Petit': [2],
 'Trees': [2],
 # '(sketch)': [2],
 'Island': [3],
 '(sketch)':[2, 3]   #in this line the value appended as the key already has a value 2                                     
}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You might be surprised that the results are out of order, but that's because dicts in python don't have an order. If you want them ordered you'll need to use something other than a vanilla dict.</p>
<pre><code>titles =  ['Barrel - Part 1', 'Petit Trees (sketch)', 'Island (sketch)']
pages =  [1, 2, 3]

finalDict = {}
for title, page in zip(titles, pages):
    for word in title.split(" "):
        if word not in finalDict.keys():
            finalDict[word] = [int(page)]
        else:
            finalDict[word] += [int(page)]

print(finalDict)
</code></pre>
<p>This outputs:</p>
<pre><code>{'Part': [1], '1': [1], 'Trees': [2], 'Island': [3], 'Barrel': [1], '-': [1], '(sketch)': [2, 3], 'Petit': [2]}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow noreferrer"><code>zip()</code></a> to loop through the two lists simultaneously. If you don't need the dict to be in order, it's much easier to use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict()</code></a> than a normal dictionary:</p>
<pre><code>import collections

titles =  ['Barrel - Part 1', 'Petit Trees (sketch)', 'Island (sketch)']
pages =  [1, 2, 3]

d = collections.defaultdict(list)

for title, page in zip(titles, pages):
    for word in title.split():
        d[word].append(page)
</code></pre>
<p>Although since your <code>pages</code> is just a list of subsequent numbers, it's probably better to use <a href="https://docs.python.org/3/library/functions.html#enumerate" rel="nofollow noreferrer"><code>enumerate</code></a> so you don't have to update the <code>pages</code> list every time you make changes:</p>
<pre><code>import collections

titles =  ['Barrel - Part 1', 'Petit Trees (sketch)', 'Island (sketch)']
d = collections.defaultdict(list)

for page, title in enumerate(titles, start=1):
    for word in title.split():
        d[word].append(page)
</code></pre>
<p>Now if you <em>do</em> need the dict to be in order, you can use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer"><code>OrderedDict</code></a> combined with @Keatinge's answer:</p>
<pre><code>import collections

titles =  ['Barrel - Part 1', 'Petit Trees (sketch)', 'Island (sketch)']
d = collections.OrderedDict()

for title, page in enumerate(titles, start=1):
    for word in title.split():
        if word not in d:
            d[word] = [page]
        else:
            d[word].append(page)
</code></pre>
<p>Or if you only need the output to be sorted, use the earlier <code>defaultdict</code> solution and throw in <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow noreferrer"><code>sorted()</code></a> when outputting the values:</p>
<pre><code>for key in sorted(d.keys()):
    print('{0}: {1}'.format(key, d[key]))
</code></pre>
<p>Finally, you <em>could</em> use an <a href="https://stackoverflow.com/questions/6190331/can-i-do-an-ordered-default-dict-in-python"><code>OrderedDefaultDict</code></a>, but most would argue that this is a bit of an overkill for such a simple program.</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehension approach. </p>
<p>Basically double iteration in list comprehension is used here (look more pythonic to me). Another way of iterating would be using <code>itertools.chain</code>. </p>
<pre><code>from collections import defaultdict
d = defaultdict(list)
page_names =  ['Barrel - Part 1', 'Petit Trees (sketch)', 'Island (sketch)']
pages =  [1, 2, 3]

for k, v in [(y, x[1]) for x in zip(page_names, pages) for y in x[0].split(' ')]:
    d[k].append(v)
</code></pre>
<p>And to convert the a list with duplicated keys, if the order is not a concern. Then <code>coolections.defaultdict</code> would be quite useful. Though pure base python approach would also work, and it will be something like this:</p>
<pre><code>d = {}
for x in l:
    if x.key not in l:
        d[x.key] = []
    d[x.key].append(x.value)
</code></pre>
</div>
<span class="comment-copy">can you provide us any attempted code from your part? If you don't have any, this should get you started: <a href="http://www.pythonforbeginners.com/dictionary/dictionary-manipulation-in-python" rel="nofollow noreferrer">pythonforbeginners.com/dictionary/â€¦</a></span>
<span class="comment-copy">You can use an <a href="https://pymotw.com/2/collections/ordereddict.html" rel="nofollow noreferrer"><code>collections.OrderedDict</code></a> to order them.</span>
<span class="comment-copy">Just figured I'd put it out there.</span>
<span class="comment-copy">Thanks @Keatinge, this is what I wanted, I'm sorry, by mistake I downvoted your answer, how can I now upvote? I'm really sorry.</span>
<span class="comment-copy">Honestly you should mark Markus Meskanen's post as the answer, it's undeniably better.</span>
<span class="comment-copy">While my answer might be better, there's really nothing wrong with Keatinge's answer. Please stop downvoting him, or if there's a reason to downvote, let everyone else know too.</span>
<span class="comment-copy">I think <code>zip(page_names, page)</code> is supposed to be <code>zip(page_names, pages)</code> (page changed to pages)</span>
<span class="comment-copy">@Keatinge Good catch, fixed!</span>
<span class="comment-copy">@MarkusMeskanen You can make <code>OrderedDictionary</code> code more concise by replacing <code>if word not in d:             d[word] = [page]         else:             d[word].append(page)</code> with <code>d.setdefault(word, []).append(page)</code></span>
