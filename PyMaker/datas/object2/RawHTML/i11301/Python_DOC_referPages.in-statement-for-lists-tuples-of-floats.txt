<div class="post-text" itemprop="text">
<p>Should the use of <strong>in</strong> or <strong>not in</strong> be avoided when dealing with lists/tuples of floats? Is its implementation something like the code below or is it something more sophisticated?</p>
<pre><code>check = False
for item in list_to_search_the_value_in:
    if value_to_search_for == item:
        check = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>in</code> and <code>not in</code> should be your preferred way of membership testing. Both operators can make use (via <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="nofollow"><code>__contains__()</code></a>) of any optimized membership test that the container offers.</p>
<p>Your problem is with the <code>float</code> part, because <code>in</code> makes an equality comparison with <code>==</code> (optimized to check for identity, first).</p>
<p>In general, for floating point comparing for equality does not yield the desired results. Hence for lists of floats, you want something like</p>
<pre><code>def is_in_float(item, sequence, eps=None):
    eps = eps or 2**-52
    return any((abs(item - seq_item) &lt; eps) for seq_item in sequence)
</code></pre>
<p>Use with sorting and binary search to find the closest matching float at your convenience.</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="nofollow">Here's</a> the part of the documentation saying that <code>in</code> checks for equality on sequence types. So no, this should not be used for sequences of floats.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>in</code> operator uses regular equality checks behind the scenes, so it has the same limitations as <code>__eq__()</code>  when it comes to floats. Use with caution if at all.</p>
<pre><code>&gt;&gt;&gt; 0.3 == 0.4 - 0.1
False

&gt;&gt;&gt; 0.3 in [0.4 - 0.1]
False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since <code>in</code> operator uses equality check, it'll frequently fail, since <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">floating point math is "broken"</a> (well, it's not, but you get a point).</p>
<p>You may easily achieve similar functionality by using <code>any</code>:</p>
<pre><code>epsilon = 1e-9

check = any(abs(f - value_to_search_for) &lt; epsilon for f in seq)
# or
check = False
if any(abs(f - value_to_search_for) &lt; epsilon for f in seq):
    check = True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Python's <code>list</code> type has its <code>__contains__</code> method <a href="https://hg.python.org/cpython/file/default/Objects/listobject.c#l399" rel="nofollow">implemented in C</a>:</p>
<pre><code>static int
list_contains(PyListObject *a, PyObject *el)
{
    Py_ssize_t i;
    int cmp;

    for (i = 0, cmp = 0 ; cmp == 0 &amp;&amp; i &lt; Py_SIZE(a); ++i)
        cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),
                                           Py_EQ);
    return cmp;
}
</code></pre>
<p>A literal translation to Python might be:</p>
<pre><code>def list_contains(a, el):
    cmp = False
    for i in range(len(a)):
        if cmp: break 
        cmp = a[i] == el
    return cmp
</code></pre>
<p>Your example is a more idiomatic translation.</p>
<p>In any case, as the other answers have noted, it uses equality to test the list items against the element you're checking for membership. With <code>float</code> values, that can be perilous, as numbers we'd expect to be equal may not be due to floating point rounding.</p>
<p>A more <code>float</code>-safe way of implementing the check yourself might be:</p>
<pre><code>any(abs(x - el) &lt; epsilon for x in a)
</code></pre>
<p>where <code>epsilon</code> is some small value. How small it needs to be will depend on the size of the numbers you're dealing with, and how precise you care to be. If you can estimate the amount of numeric error that might differentiate <code>el</code> an equivalent value in the list, you can set <code>epsilon</code> to one order of magnitude larger and be confident that you'll not give a false negative (and probably only give false positives in cases that are impossible to get right).</p>
</div>
<span class="comment-copy">You might want to have a look <a href="http://stackoverflow.com/questions/2217001/override-in-operator-in-python">here</a>. The <code>in</code> operator should be preferred as it can make use of any special containment test the container offers (e.g. <code>set.__contains__()</code> is a lot faster than <code>list.__contains__()</code>). The problem is with the <code>float</code> part, because comparing floats from different sources for equality is usually a numerical no-go.</span>
<span class="comment-copy">Yes. Comparing floats for equality is best avoided, for the <a href="http://stackoverflow.com/questions/588004/is-floating-point-math-broken?rq=1">usual reasons</a>.</span>
<span class="comment-copy">A possible alternative is to sort the list of floats, and use binary search to find the closest match, subtract and check if the difference is less than a given limit.</span>
<span class="comment-copy">@dhke: so if i understand you correctly, you are saying that in general it should be used because it's implementation varies depending on the container type (faster for sets) but when the container contains floats it should be avoided. Right?</span>
<span class="comment-copy">@Ev.Kounis Yes, but dependent on your use case. If you know the numbers inside the sequence are from the same source, there is no harm in comparing floats for equality. But if the numbers are from different sources, i.e. one from a table and the other the result of user input, numerical errors will come back to bite you.</span>
