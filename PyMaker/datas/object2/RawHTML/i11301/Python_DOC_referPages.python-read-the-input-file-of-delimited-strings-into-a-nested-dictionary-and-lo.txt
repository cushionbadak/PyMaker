<div class="post-text" itemprop="text">
<p>My input file would look like this:</p>
<pre><code>1111;A:aaaa,B:aaaa,F:aaaa  
2222;A:aaaa,B:aaaa,E:aaaa  
3333;C:aaaa,D:aaaa,E:aaaa,F:aaaa  
4444;D:aaaa  
5555;C:bbbb  
2222;A:bbbb,B:bbbb  
2222;A:cccc,B:cccc  
1111;C:cccc,D:cccc,E:cccc,F:cccc  
2222;A:dddd,B:dddd  
1111;A:eeee,B:eeee  
1111;A:ffff,B:ffff  
2222;C:ffff,E:ffff,F:ffff  
1111;A:gggg,B:gggg,C:gggg  
3333;C:gggg,E:gggg,F:gggg  
5555;A:hhhh,B:hhhh
</code></pre>
<p>I would like to get something like in java would be nested maps with the list of strings in the inner map structure.</p>
<pre><code>Map&lt;'String, Map&lt;'String, List{String}&gt;&gt;
</code></pre>
<p>something like this:</p>
<pre><code>&lt;1111:
      &lt;'A':{'aaaa','eeee','ffff','gggg'}&gt;
      &lt;'B':{'aaaa','eeee','ffff','gggg'}&gt;
      &lt;'C':{'cccc','gggg'}&gt;
      &lt;'D':{'cccc'}&gt;
      &lt;'E':{'cccc'}&gt;
      &lt;'F':{'aaaa','cccc'}&gt;
&gt;
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Python equivalent of a Java <code>Map</code> is a <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="nofollow"><code>dict</code></a>, and parsing such a simple input can be easily done with <a href="https://docs.python.org/2/library/stdtypes.html#str.split" rel="nofollow"><code>split</code></a>.</p>
<p>The simplest way I can think of is:</p>
<pre class="lang-py prettyprint-override"><code>nested_dict = dict()

for line in file:
    key, val = line.split(';')
    if key not in nested_dict:
        nested_dict[key] = dict()
    for part in val.split(','):
        key2, val2 = part.split(':')
        if key2 not in nested_dict[key]:
            nested_dict[key][key2] = []
        nested_dict[key][key2].append(val2)
</code></pre>
<p>You could omit the <code>if</code> statements using a <code>defaultdict</code> to make it a bit nicer.</p>
<pre><code>from collections import defaultdict
nested_dict = defaultdict(lambda: defaultdict(list))

for line in file:
    key, val = line.split(';')
    for part in val.split(','):
        key2, val2 = part.split(':')
        nested_dict[key][key2].append(val2)
</code></pre>
<p>A remark: in these example even numeric keys are stored as strings. It might be desirable, but if not, you can simply convert them to integers using <code>int</code> when assigning the dict value.</p>
<h3>Update</h3>
<p>To iterate over the "leafs" of yous nested dictionary, you can use the <code>values</code> method of <code>dict</code>s, which returns an iterator over the dictionary values:</p>
<pre class="lang-py prettyprint-override"><code>for dct in nested_dict.values():
    for val in dct.values():
        do_something(val)
</code></pre>
<p>In python 2.7 and below using the <code>itervalues</code> method is recommended over <code>values</code>, as it returns an iterator instead of a list.</p>
<p>Also, you can write a simple generator that loops over the values.</p>
<pre class="lang-py prettyprint-override"><code>def leafgen(nested_dict):
    for dct in nested_dict.values():
        for val in dct.values():
            yield val
</code></pre>
<p>Then you can do</p>
<pre class="lang-py prettyprint-override"><code>for val in leafgen(nested_dict):
    do_something(val)
</code></pre>
<p>And you get some built-in functions for free, for example you can do</p>
<pre><code>['aaaa'] in leafgen(nested_dict)
</code></pre>
</div>
<span class="comment-copy">If you would like to do so, just do it. What is the question you have for this Q&amp;A site?</span>
<span class="comment-copy">Thank you, that is what I wanted for creating a dictionary.</span>
<span class="comment-copy">Now, how would I loop throuh it to do something for each val2?</span>
<span class="comment-copy">Dicts provide a <code>values</code> method which returns an iterator with their values so you could do something like: <code>for dct in nested_dict.values(): for val in dct.values(): do_something(val)</code> (I will update the answer with a properly indented version in a minute)</span>
