<div class="post-text" itemprop="text">
<p>I want to make a shallow copy of an <code>itertools.cycle</code> object, but I don't know how because it has no builtin copy method. I want to achieve something like the following, where I create a copy of the cycle, iterate through it a few times, then copy the original again, and iterate a few more times <em>starting from the beginning of the cycle</em>.</p>
<pre><code>c = "ABCD"
cyc = itertools.cycle(c)

cyc_copy = cyc.copy()
for i in range(2):
    print(next(cyc_copy))
cyc_copy = cyc.copy()
for i in range(2):
    print(next(cyc_copy))

&gt; A
  B
  A
  B
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It may require some refactoring, but a factory would work well here.</p>
<pre><code>from itertools import cycle

cycle_factory = lambda: cycle('1234')

c1 = cycle_factory()
print next(c1) # 1

c2 = cycle_factory()
print next(c2) # 1
</code></pre>
<p>Otherwise, I'm not sure you're going to be able to satisfy the criteria of starting at the beginning of the cycle each time. The class-based approached will also work, but requires a lot more overhead. </p>
<p>One of the issues with the <code>itertools.tee</code> approach is that it will resume iteration where the tee-d iterator left off instead of starting from the beginning. Thus, you have to tee it at the beginning. This may be the only option if you do not have control over how the cycle is generated.</p>
</div>
<div class="post-text" itemprop="text">
<p>Copying the cycle itself is going to run into problems. For example, <a href="http://ideone.com/sLSmjK" rel="nofollow"><code>copy.copy</code>ing it doesn't produce independent copies</a>.</p>
<p>Instead of trying to copy the cycle, I recommend recreating it from your original object:</p>
<pre><code>new_cyc = itertools.cycle(c)
</code></pre>
<p>If the object you made your original cycle from is an iterator, you can't just call <code>cycle</code> on it repeatedly. Instead, make a list before you call <code>cycle</code> the first time, and keep the list:</p>
<pre><code>c_list = list(c)
cyc = itertools.cycle(c_list)

# later
new_cyc = itertools.cycle(c_list)
</code></pre>
<p>If the object you made your original cycle from is an iterator that might or might not be infinite, you can't safely call <code>list</code> on it. Instead, you can <code>tee</code> it <em>before</em> creating the cycle and <code>copy.copy</code> the unadvanced tee when you need to make a new cycle. (<code>tee</code> supports copying.)</p>
<pre><code>c_tee, c_tee2 = itertools.tee(c)
cyc = itertools.cycle(c_tee2)

# Copy c_tee, not the c_tee2 we already used.
new_cyc = itertools.cycle(copy.copy(c_tee))
</code></pre>
<p>All this assumes you control the creation of the cycle. If you're receiving a cycle from elsewhere, you might not have access to the object it cycles over. In that case, your best option is to <code>tee</code> the cycle itself. This could be expensive if you need to go through many loops of the cycle:</p>
<pre><code>cyc_master, cyc1 = itertools.tee(cyc)
# Use cyc1

# Later
cyc2 = copy.copy(cyc_master)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could create a custom class to do what you want:</p>
<pre><code>import itertools

class CopyCycle:
    def __init__(self, iterable):
        self.iterable = iterable
        self._cycle = itertools.cycle(self.iterable)

    def cycle(self):
        return self

    def __iter__(self):
        return self

    def next(self):
        return self._cycle.next()

    def __next__(self):  #Python 3+
        return self._cycle.next()

    def copy(self):
        return CopyCycle(self.iterable)


if __name__ == '__main__':
    cyc = CopyCycle("ABCD").cycle()
    for i in range(5):
        print(next(cyc))

    cyc_copy = cyc.copy()
    for i in range(2):
        print(next(cyc_copy))
    cyc_copy = cyc.copy()
    for i in range(2):
        print(next(cyc_copy))
</code></pre>
<p>Outputs:</p>
<pre>
A
B
C
D
A
A
B
A
B
</pre>
</div>
<div class="post-text" itemprop="text">
<p><code>copy</code> should do the trick:    </p>
<pre><code>&gt;&gt;&gt; from copy import copy
&gt;&gt;&gt; cyc_copy = copy(cyc)
&gt;&gt;&gt; next(cyc_copy)
'A'
&gt;&gt;&gt; next(cyc_copy)
'B'
&gt;&gt;&gt; cyc_copy = copy(cyc)
&gt;&gt;&gt; next(cyc_copy)
'A'
&gt;&gt;&gt; next(cyc_copy)
'B'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>Method 1:</strong> making two <code>itertools.cycle</code> objects</p>
<pre><code>import itertools
c = 'ABCD'
cyc1 = itertools.cycle(c)
cyc2 = itertools.cycle(c)
for _ in range(2): print(next(cyc1))  # prints A\nB\n
for _ in range(2): print(next(cyc2))  # prints A\nB\n
</code></pre>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="//repl.it/embed/IRcx/0.js"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p><strong>[Preferred Solution] Method 2:</strong> split into n iterators by using <code>itertools.tee</code></p>
<pre><code>import itertools
cyc = itertools.cycle('ABCD')
cyc1, cyc2 = itertools.tee(cyc, 2)
for _ in range(2): print(next(cyc1))  # prints A\nB\n
for _ in range(2): print(next(cyc2))  # prints A\nB\n
</code></pre>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="//repl.it/embed/IRcx/2.js"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p><strong>Warning using <code>copy</code> module</strong> using the <code>copy.copy</code> function will not create a copy of the iterator as expected. </p>
<pre><code>import itertools, copy
cyc = itertools.cycle('ABCD')
cyc1 = copy.copy(cyc)
cyc2 = copy.copy(cyc)
for _ in range(2): print(next(cyc1))  # prints A\nB\n
for _ in range(2): print(next(cyc2))  # prints C\nD\n
</code></pre>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="//repl.it/embed/IRcx/3.js"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p><strong>Workaround using <code>copy</code> module:</strong> a possible solution for this can be to use <code>copy.deepcopy</code> function.</p>
<pre><code>import itertools, copy
cyc = itertools.cycle('ABCD')
cyc1 = copy.deepcopy(cyc)
cyc2 = copy.deepcopy(cyc)
for _ in range(2): print(next(cyc1))  # prints A\nB\n
for _ in range(2): print(next(cyc2))  # prints A\nB\n
</code></pre>
<p><div class="snippet" data-babel="false" data-console="true" data-hide="false" data-lang="js">
<div class="snippet-code">
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="//repl.it/embed/IRcx/4.js"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
</div>
<span class="comment-copy"><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" rel="nofollow noreferrer"><code>itertools.tee</code></a>.</span>
<span class="comment-copy"><code>itertools.tee</code> works, but it requires storing all outputs of the original <code>cycle</code> iterator, including duplicate outputs from when the cycle loops back on itself.</span>
<span class="comment-copy">Are you in a situation where you only have access to the cycle and not the original iterable? It seems like just making new cycles would be sensible.</span>
<span class="comment-copy"><a href="http://ideone.com/bKWVDc" rel="nofollow noreferrer">This seems to fail for some cycles.</a></span>
<span class="comment-copy">Trying to call copy on the cycle gives me <code>TypeError: cycle expected 1 arguments, got 0</code>. Is it version dependent? I'm using python 2.7.6</span>
<span class="comment-copy">Upon further testing, it seems to be version-dependent. Python 2 gives the <code>TypeError</code>. Python 3 gives a <a href="http://ideone.com/lw5Ynd" rel="nofollow noreferrer">different, subtler error</a> - the cycles aren't independent. They're sharing some underlying state that causes <code>next</code>-ing one to affect the other.</span>
<span class="comment-copy">I tried this on python 3.4, and there seemed to be no problems.</span>
<span class="comment-copy"><a href="http://ideone.com/sLSmjK" rel="nofollow noreferrer">There are definitely problems.</a></span>
