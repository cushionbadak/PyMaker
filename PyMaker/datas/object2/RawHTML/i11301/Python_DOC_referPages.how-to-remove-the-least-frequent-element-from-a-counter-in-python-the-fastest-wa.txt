<div class="post-text" itemprop="text">
<p>I'd like to implement a Counter which drops the least frequent element when the counter's size going beyond some threshold. For that I need to remove the least frequent element.</p>
<p>What is the fastest way to do that in Python?</p>
<p>I know <code>counter.most_common()[-1]</code>, but it creates a whole list and seems slow when done extensively? Is there a better command (or maybe a different data structure)?</p>
</div>
<div class="post-text" itemprop="text">
<p>You may implement <code>least_common</code> by borrowing implementation of <code>most_common</code> and performing necessary changes.</p>
<p>Refer to <a href="https://hg.python.org/cpython/file/2.7/Lib/collections.py" rel="nofollow"><code>collections</code> source in Py2.7</a>:</p>
<pre><code>def most_common(self, n=None):
    '''List the n most common elements and their counts from the most
    common to the least.  If n is None, then list all element counts.

    &gt;&gt;&gt; Counter('abcdeabcdabcaba').most_common(3)
    [('a', 5), ('b', 4), ('c', 3)]

    '''
    # Emulate Bag.sortedByCount from Smalltalk
    if n is None:
        return sorted(self.iteritems(), key=_itemgetter(1), reverse=True)
    return _heapq.nlargest(n, self.iteritems(), key=_itemgetter(1))
</code></pre>
<p>To change it in order to retrieve least common we need just a few adjustments.</p>
<pre><code>import collections
from operator import itemgetter as _itemgetter
import heapq as _heapq


class MyCounter(collections.Counter):
    def least_common(self, n=None):
        if n is None:
            return sorted(self.iteritems(), key=_itemgetter(1), reverse=False)  # was: reverse=True
        return _heapq.nsmallest(n, self.iteritems(), key=_itemgetter(1))  # was _heapq.nlargest
</code></pre>
<p>Tests:</p>
<pre><code>c = MyCounter("abbcccddddeeeee")
assert c.most_common() == c.least_common()[::-1]
assert c.most_common()[-1:] == c.least_common(1)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your stated goal is to remove items in the counter below a threshold, just reverse the counter (so the values becomes a list of keys with that value) and then remove the keys in the counter below the threshold.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; c=Counter("aaaabccadddefeghizkdxxx")
&gt;&gt;&gt; c
Counter({'a': 5, 'd': 4, 'x': 3, 'c': 2, 'e': 2, 'b': 1, 'g': 1, 'f': 1, 'i': 1, 'h': 1, 'k': 1, 'z': 1})

counts={}
for k, v in c.items():
    counts.setdefault(v, []).append(k)

tol=2   
for k, v in counts.items():
    if k&lt;=tol:
        c=c-Counter({}.fromkeys(v, k))
&gt;&gt;&gt; c
Counter({'a': 5, 'd': 4, 'x': 3})
</code></pre>
<p>In this example, all counts less than or equal to 2 are removed. </p>
<p>Or, just recreate the counter with a comparison to your threshold value:</p>
<pre><code>&gt;&gt;&gt; c
Counter({'a': 5, 'd': 4, 'x': 3, 'c': 2, 'e': 2, 'b': 1, 'g': 1, 'f': 1, 'i': 1, 'h': 1, 'k': 1, 'z': 1})
&gt;&gt;&gt; Counter({k:v for k,v in c.items() if v&gt;tol})
Counter({'a': 5, 'd': 4, 'x': 3})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you only want to get the least common value, then the most efficient way to handle this is to simply get the minimum value from the counter (dictionary).</p>
<p>Since you can only say whether a value is the lowest, you actually need to look at all items, so a time complexity of O(n) is really the lowest we can get. However, we do not need to have a linear space complexity, as we only need to remember the lowest value, and not all of them. So a solution that works like <code>most_common()</code> in reverse is too much for us.</p>
<p>In this case, we can simply use <code>min()</code> with a custom key function here:</p>
<pre><code>&gt;&gt;&gt; c = Counter('foobarbazbar')
&gt;&gt;&gt; c
Counter({'a': 3, 'b': 3, 'o': 2, 'r': 2, 'f': 1, 'z': 1})

&gt;&gt;&gt; k = min(c, key=lambda x: c[x])
&gt;&gt;&gt; del c[k]
&gt;&gt;&gt; c
Counter({'a': 3, 'b': 3, 'o': 2, 'r': 2, 'z': 1})
</code></pre>
<p>Of course, since dictionaries are unordered, you do not get any influence on which of the lowest values is removed that way in case there are multiple with the same lowest occurrence.</p>
</div>
<span class="comment-copy">You could have a min heap that associates values with their frequency. Then check the top of the min-heap and remove that element from the DS storing the values.</span>
<span class="comment-copy">The problem with <code>counter.most_common()[-1]</code> also is that <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common" rel="nofollow noreferrer">items with equal counts are ordered arbitrarily.</a></span>
<span class="comment-copy">This will still create a full list with all items, so it has the same downside as <code>most_common()</code>. And actually no real benefit since accessing the last element of a list has the same time complexity as accessing the first.</span>
<span class="comment-copy">@poke you may pass an argument <code>n</code> to most_common (least_common) to avoid creating huge list. It's used right there in tests, <code>c.least_common(1)</code>.</span>
