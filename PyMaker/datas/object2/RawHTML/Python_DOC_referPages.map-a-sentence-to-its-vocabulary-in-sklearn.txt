<div class="post-text" itemprop="text">
<p>I'm using <code>CountVectorizer</code> to get the list of words in a list of strings</p>
<pre><code>from sklearn.feature_extraction.text import CountVectorizer
raw_text = [
    'The dog hates the black cat',
    'The black dog is good'
]
raw_text = [x.lower() for x in raw_text]
vocabulary = vectorizer.vocabulary_ 
vocabulary = dict((v, k) for k, v in vocabulary.iteritems())
vocabulary
</code></pre>
<p>In vocabulary I have then the following data, which are correct</p>
<pre><code>{0: u'black', 1: u'cat', 2: u'dog', 3: u'good', 4: u'hates', 5: u'is', 6: u'the'}
</code></pre>
<p>What I would like to obtain now is the original sentences "mapped" to those new values, something like:</p>
<pre><code>expected_output = [
    [6, 2, 4, 6, 0, 1],
    [6, 0, 2, 5, 3]
]
</code></pre>
<p>I tried exploring the Sklearn documentation but I can not really find anything that seems to do that and I don't even know the right terminology for the operation I'm trying to perform so I can not find any results in Google.</p>
<p>Is there any way to achieve this result?</p>
</div>
<div class="post-text" itemprop="text">
<p>Lookup each word like this:</p>
<pre><code>from sklearn.feature_extraction.text import CountVectorizer
raw_text = [
    'The dog hates the black cat',
    'The black dog is good'
]

cv = CountVectorizer()
cv.fit_transform(raw_text)


vocab = cv.vocabulary_.copy()

def lookup_key(string):
    s = string.lower()
    return [vocab[w] for w in s.split()]

list(map(lookup_key, raw_text))
</code></pre>
<p>Out:</p>
<pre><code>[[6, 2, 4, 6, 0, 1], [6, 0, 2, 5, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Can you try the following:</p>
<pre><code>mydict = {0: u'black', 1: u'cat', 2: u'dog',
          3: u'good', 4: u'hates', 5: u'is', 6: u'the'}


def get_val_key(val):
    return list(mydict.keys())[list(mydict.values()).index(val.lower())]


raw_text = [
    'The dog hates the black cat',
    'The black dog is good'
]
expected_output = [list(map(get_val_key, text.split())) for text in raw_text]
print(expected_output)
</code></pre>
<p>Output:</p>
<pre><code>[[6, 2, 4, 6, 0, 1], [6, 0, 2, 5, 3]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I think you can just fit the text to build the vocabulary and then use the vocabulary to create the required mapping using <code>build_analyzer()</code></p>
<pre><code>from sklearn.feature_extraction.text import CountVectorizer
raw_text = [
    'The dog hates the black cat',
    'The black dog is good'
]
vectorizer = CountVectorizer()
vectorizer.fit(raw_text)

analyzer = vectorizer.build_analyzer()
[[vectorizer.vocabulary_[i]  for i in analyzer(doc)]  for doc in raw_text]
</code></pre>
<p>Output:</p>
<blockquote>
<p>[[6, 2, 4, 6, 0, 1], [6, 0, 2, 5, 3]]</p>
</blockquote>
</div>
<span class="comment-copy">Compared to the solution in another answer here, this solution should typically have much better run time for large volumes of text.</span>
<span class="comment-copy"><code>.split()</code> does not consider the stop words or other prepossessing, which countVectorizer might be done when building the vocabulary</span>
<span class="comment-copy">@AI_Learning good point. Perhaps using a -1 for any stop words that were removed would be sufficient for OP's use case.</span>
<span class="comment-copy">Glad it helped. Happy Coding!!!</span>
<span class="comment-copy">Works, but has quadratic time complexity because of the use of list of values. Another answer here provides much better typical run time, by reversing the dict.</span>
