<div class="post-text" itemprop="text">
<p>What would be the way for python decorator to become "polymorphic"? What I mean is it seeks for one exact parameter of decorated function, does something to/with it, then passes the modified parameter to the function. However, this parameter with common name has arbitrary position in any decorated function.</p>
<pre><code>def decorator(func):
    def wrapper(exactly_this_param, *args):
        new = do_smth(exactly_this_param)
        return func(exactly_this_param=new, *args)
    return wrapper

@decorator
def func1(a, b, exactly_this_param, c):
    # does something

@decorator
def func2(exactly_this_param):
    # does something

@decorator
def func3(a, b, c, d, e, exactly_this_param, *args, **kwargs):
    # does something
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With keyword arguments (kwargs) this would be easy since *kwargs gives you the names and values of keyword arguments inside the decorator. 
So you would receive something like this:</p>
<pre><code>func3(1,2,3,4,5,6,7,test="hallo")
</code></pre>
<p>would give you:</p>
<pre><code>kwargs{'test': 'hallo'}
</code></pre>
<p>So you could just search for "exactly_this_param" and change it ..</p>
<p>BUT you chose to use normal args. This is one step more but also possible.</p>
<p><strong>So here is a possible solution:</strong> (I used python 3)</p>
<p>With "non keyword arguments" (args) you can use the combination of:</p>
<ul>
<li>args -&gt; gives you a tuple of the actual values of this func call</li>
<li>func.<strong>code</strong>.co_varnames -&gt; gives you the argument names as in the function definition</li>
</ul>
<p>I assigned them to the varaible <em>func_params</em></p>
<pre><code>func_params = func.__code__.co_varnames
</code></pre>
<p>So you can look for the index of <em>"exactly_this_param"</em> in <em>func.<strong>code</strong>.co_varnames</em> and change the value in args at exactly this index as well.  This is this block:</p>
<pre><code>new_args[func_params.index("exactly_this_param")]=999
</code></pre>
<p>You also have to convert <em>args</em> to a list (<em>new_args</em>) and back to a tuple, since tuples are immutable in python.</p>
<p>This results in something like this (example code - but running):</p>
<pre><code>def decorator(func):
def wrapped(*args, **kwargs):
    # a tuple of the names of the parameters that func accepts
    print("    ... decorator magic ....")
    print("    .... args" + str(args))
    print("    .... kwargs" + str(kwargs))
    func_params = func.__code__.co_varnames
    print("    .... param_names:" + str(func_params))
    # grab all of the kwargs that are not accepted by func
    new_args=list(args)
    new_args[func_params.index("exactly_this_param")]=999
    args=tuple(new_args)
    print("    .... new_args" + str(args))
    return func(*args, **kwargs)
return wrapped

@decorator
def func1(a, b, exactly_this_param, c):
    # does something
    print("func1 =&gt; exactly_this_slightly_different_param: " + str(exactly_this_param))

@decorator
def func2(exactly_this_param):
    # does something
    print("func2 =&gt;  exactly_this_slightly_different_param: " + str(exactly_this_param))

@decorator
def func3(a, b, c, d, e, exactly_this_param, *args, **kwargs):
    # does something
    print("func3 =&gt;  exactly_this_slightly_different_param: " + str(exactly_this_param))

if __name__ == "__main__":
    func1(1,2,3,4)
    func2(12)
    func3(1,2,3,4,5,6,7,test="hallo")
</code></pre>
<p>The resulting output shows that the paramter is always found and changed to 999.</p>
<pre><code>c:\khz\devel&gt;python test_dec.py
    ... decorator magic ....
    .... args(1, 2, 3, 4)
    .... kwargs{}
    .... param_names:('a', 'b', 'exactly_this_param', 'c')
    .... new_args(1, 2, 999, 4)
func1 =&gt; exactly_this_slightly_different_param: 999
    ... decorator magic ....
    .... args(12,)
    .... kwargs{}
    .... param_names:('exactly_this_param',)
    .... new_args(999,)
func2 =&gt;  exactly_this_slightly_different_param: 999
    ... decorator magic ....
    .... args(1, 2, 3, 4, 5, 6, 7)
    .... kwargs{'test': 'hallo'}
    .... param_names:('a', 'b', 'c', 'd', 'e', 'exactly_this_param', 'args', 'kwargs')
    .... new_args(1, 2, 3, 4, 5, 999, 7)
func3 =&gt;  exactly_this_slightly_different_param: 999
</code></pre>
<p>Answer based on <a href="https://stackoverflow.com/questions/582056/getting-list-of-parameter-names-inside-python-function">this SO question</a>.</p>
</div>
<span class="comment-copy">Might want to look into <a href="https://docs.python.org/3/library/inspect.html" rel="nofollow noreferrer"><code>inspect</code></a></span>
