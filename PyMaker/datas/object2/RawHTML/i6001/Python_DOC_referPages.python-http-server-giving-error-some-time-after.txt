<div class="post-text" itemprop="text">
<p>I coded a Python HTTP server as below and I run the server from the directory which this python file exist. I am typing "python myserver.py" in the cmd and server succesfully starts and reads the index.html in the directory but my problem is after some time my code gives the following error and closes the server </p>
<p>Traceback (most recent call last):
  File "myserver.py", line 20, in 
    requesting_file = string_list[1]
IndexError: list index out of range</p>
<p>How can I fix this problem ?</p>
<pre><code>import socket

HOST,PORT = '127.0.0.1',8082

my_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
my_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
my_socket.bind((HOST,PORT))
my_socket.listen(1)

print('Serving on port ',PORT)

while True:
    connection,address = my_socket.accept()
    request = connection.recv(1024).decode('utf-8')
    string_list = request.split(' ')     # Split request from spaces

    print (request)

    method = string_list[0]
    requesting_file = string_list[1]

    print('Client request ',requesting_file)

    myfile = requesting_file.split('?')[0] # After the "?" symbol not relevent here
    myfile = myfile.lstrip('/')
    if(myfile == ''):
        myfile = 'index.html'    # Load index file as default

    try:
        file = open(myfile,'rb') # open file , r =&gt; read , b =&gt; byte format
        response = file.read()
        file.close()

        header = 'HTTP/1.1 200 OK\n'

        if(myfile.endswith(".jpg")):
            mimetype = 'image/jpg'
        elif(myfile.endswith(".css")):
            mimetype = 'text/css'
        else:
            mimetype = 'text/html'

        header += 'Content-Type: '+str(mimetype)+'\n\n'

    except Exception as e:
        header = 'HTTP/1.1 404 Not Found\n\n'
        response = '&lt;html&gt;&lt;body&gt;&lt;center&gt;&lt;h3&gt;Error 404: File not found&lt;/h3&gt;&lt;p&gt;Python HTTP Server&lt;/p&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;'.encode('utf-8')

    final_response = header.encode('utf-8')
    final_response += response
    connection.send(final_response)
    connection.close()
</code></pre>
<hr/>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom" rel="nofollow noreferrer"><code>socket.recv(n)</code></a> is not guaranteed to read the entire <em>n</em> bytes of the message in one go and can return fewer bytes than requested in some circumstances.</p>
<p>Regarding your code it's possible that only the <code>method</code>, or part thereof, is received without any space character being present in the received data. In that case <code>split()</code> will return a list with one element, not two as you assume.</p>
<p>The solution is to check that a full message has been received. You could do that by looping until sufficient data has been received, e.g. you might ensure that some minimum number of bytes has been received by checking the length of data and looping until the minimum has been reached.</p>
<p>Alternatively you might continue reading until a new line or some other sentinel character is received. It's probably worth capping the length of the incoming data to avoid your server being swamped by data from a rogue client.</p>
<p>Finally, check whether <code>split()</code> returns the two values that you expect and handle accordingly if it does not. Furthermore, be very careful about the file name; what if it contains a relative path, e.g. <code>../../etc/passwd</code>?</p>
</div>
<span class="comment-copy">Maybe <code>string_list</code> has just one element.</span>
<span class="comment-copy">I solve the problem by adding    if not request:     # time.sleep(0.01)         continue</span>
<span class="comment-copy">@erkevarol: that solution will only work if the client closes the connection without sending any data. It is still possible that a truncated message could be received.</span>
