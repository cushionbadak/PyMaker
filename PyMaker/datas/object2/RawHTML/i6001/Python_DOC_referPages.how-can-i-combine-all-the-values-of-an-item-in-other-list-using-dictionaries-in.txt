<div class="post-text" itemprop="text">
<p>i have two lists and need to combine the into one dictionary that the key are the letters and the values are the value in the other list.
for example:</p>
<pre><code>map_keys_to_values_list(["a", "b", "a"], [15, 3, 6])
</code></pre>
<p>wll give me :</p>
<pre><code>{'a': [15, 6], 'b': [3]}
</code></pre>
<p>i tried: </p>
<pre><code>def keys_to_values_list(k_lst, v_lst):
    lst = []
    for i in range(len(k_lst)):
        v=[]
        #v.append(v_lst[i])
        t = (k_lst[i],v)
        lst.append(t)
    my_dict = dict(lst)
    for k in my_dict.keys():
        val = my_dict.get(k)
        for m in range(len(k_lst)):
            val.append(v_lst[m])


    return my_dict
</code></pre>
<p>but i get all the values in my value list</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>def keys_to_values_list(keys, values):
    d = dict()
    for i in range(len(keys)):
        if keys[i] in d:
            d[keys[i]].append(values[i])
        else:
            d[keys[i]] = [values[i]]
    return d
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow noreferrer"><code>collections.defaultdict</code></a> passing the default factory as <code>list</code> to collect all the values belonging to the same character:</p>
<pre><code>from collections import defaultdict

def map_keys_to_values_list(keys, values):
    d = defaultdict(list)
    for k, v in zip(keys, values):
        d[k].append(v)
    d.default_factory = None
    return d
</code></pre>
<p>After building the dict, you can set the <code>default_factory</code> of the dict to <code>None</code> so that further key access does not produce a new list for missing keys, but instead will raise the more appropriate <code>KeyError</code>:</p>
<pre><code>&gt;&gt;&gt; d = map_keys_to_values_list(["a", "b", "a"], [15, 3, 6])
&gt;&gt;&gt; d
defaultdict(None, {'a': [15, 6], 'b': [3]})
&gt;&gt;&gt; d['c']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'c'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this one too:</p>
<pre><code>def mapKeysToValues(keyList, valueList):
    return {k : [value for index, value in enumerate(valueList) if keyList[index]==k] for k in keyList}

keyList = ["a", "b", "a"]
valueList = [15, 3, 6]

print(mapKeysToValues(keyList, valueList))
</code></pre>
<p>Output:</p>
<pre><code>{'a': [15, 6], 'b': [3]}
</code></pre>
</div>
<span class="comment-copy">Instead of setting default_factory to None, why not just calling dict(d) and returning a pure dict?</span>
<span class="comment-copy">@EnricoBorba No, I wouldn't do that. That creates a new <i>vanilla</i> dict object which could be pretty expensive for large dicts. Setting <code>default_factory</code> to <code>None</code> is totally cheap as compared to <code>dict(d)</code>; <code>d</code> is already a dict subclass instance.</span>
