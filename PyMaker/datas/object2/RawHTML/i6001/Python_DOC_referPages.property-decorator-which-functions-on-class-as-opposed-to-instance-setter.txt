<div class="post-text" itemprop="text">
<p>I have a class with two class methods (using the classmethod() function) for getting and setting what is essentially a static variable.  I tried to use the property() function with these, but it results in an error.  I was able to reproduce the error with the following in the interpreter:</p>
<pre><code>class Foo(object):
    _var = 5
    @classmethod
    def getvar(cls):
        return cls._var
    @classmethod
    def setvar(cls, value):
        cls._var = value
    var = property(getvar, setvar)
</code></pre>
<p>I can demonstrate the class methods, but they don't work as properties:</p>
<pre><code>&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.getvar()
5
&gt;&gt;&gt; f.setvar(4)
&gt;&gt;&gt; f.getvar()
4
&gt;&gt;&gt; f.var
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: 'classmethod' object is not callable
&gt;&gt;&gt; f.var=5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: 'classmethod' object is not callable
</code></pre>
<p>Is it possible to use the property() function with classmethod decorated functions?</p>
</div>
<div class="post-text" itemprop="text">
<p>A property is created on a class but affects an instance.  So if you want a classmethod property, create the property on the metaclass.</p>
<pre><code>&gt;&gt;&gt; class foo(object):
...     _var = 5
...     class __metaclass__(type):  # Python 2 syntax for metaclasses
...         pass
...     def getvar(cls):
...         return cls._var
...     def setvar(cls, value):
...         cls._var = value
...     
&gt;&gt;&gt; foo.__metaclass__.var = property(foo.getvar.im_func, foo.setvar.im_func)
&gt;&gt;&gt; foo.var
5
&gt;&gt;&gt; foo.var = 3
&gt;&gt;&gt; foo.var
3
</code></pre>
<p>But since you're using a metaclass anyway, it will read better if you just move the classmethods in there.</p>
<pre><code>&gt;&gt;&gt; class foo(object):
...     _var = 5
...     class __metaclass__(type):  # Python 2 syntax for metaclasses
...         @property
...         def var(cls):
...             return cls._var
...         @var.setter
...         def var(cls, value):
...             cls._var = value
... 
&gt;&gt;&gt; foo.var
5
&gt;&gt;&gt; foo.var = 3
&gt;&gt;&gt; foo.var
3
</code></pre>
<p>or, using Python 3's <code>metaclass=...</code> syntax, and the metaclass defined outside of the <code>foo</code> class body, and the metaclass responsible for setting the initial value of <code>_var</code>:</p>
<pre><code>&gt;&gt;&gt; class foo_meta(type):
&gt;&gt;&gt;     def __init__(cls):
...         cls._var = 5
...     @property
...     def var(cls):
...         return cls._var
...     @var.setter
...     def var(cls, value):
...         cls._var = value
...         
&gt;&gt;&gt; class foo(metaclass=foo_meta):
...     pass
...
&gt;&gt;&gt; foo.var
5
&gt;&gt;&gt; foo.var = 3
&gt;&gt;&gt; foo.var
3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Reading the <a href="http://www.python.org/download/releases/2.2/descrintro/#property" rel="nofollow noreferrer">Python 2.2 release</a> notes, I find the following.</p>
<blockquote>
<p>The get method [of a property] won't be called when
  the property is accessed as a class
  attribute (C.x) instead of as an
  instance attribute (C().x). If you
  want to override the __get__ operation
  for properties when used as a class
  attribute, you can subclass property -
  it is a new-style type itself - to
  extend its __get__ method, or you can
  define a descriptor type from scratch
  by creating a new-style class that
  defines __get__, __set__ and
  __delete__ methods.</p>
</blockquote>
<p><strong>NOTE: The below method doesn't actually work for setters, only getters.</strong></p>
<p>Therefore, I believe the prescribed solution is to create a ClassProperty as a subclass of property.</p>
<pre><code>class ClassProperty(property):
    def __get__(self, cls, owner):
        return self.fget.__get__(None, owner)()

class foo(object):
    _var=5
    def getvar(cls):
        return cls._var
    getvar=classmethod(getvar)
    def setvar(cls,value):
        cls._var=value
    setvar=classmethod(setvar)
    var=ClassProperty(getvar,setvar)

assert foo.getvar() == 5
foo.setvar(4)
assert foo.getvar() == 4
assert foo.var == 4
foo.var = 3
assert foo.var == 3
</code></pre>
<p>However, the setters don't actually work:</p>
<pre><code>foo.var = 4
assert foo.var == foo._var # raises AssertionError
</code></pre>
<p><code>foo._var</code> is unchanged, you've simply overwritten the property with a new value.</p>
<p>You can also use <code>ClassProperty</code> as a decorator:</p>
<pre><code>class foo(object):
    _var = 5

    @ClassProperty
    @classmethod
    def var(cls):
        return cls._var

    @var.setter
    @classmethod
    def var(cls, value):
        cls._var = value

assert foo.var == 5
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I hope this dead-simple read-only <code>@classproperty</code> decorator would help somebody looking for classproperties.</p>
<pre><code>class classproperty(object):

    def __init__(self, fget):
        self.fget = fget

    def __get__(self, owner_self, owner_cls):
        return self.fget(owner_cls)

class C(object):

    @classproperty
    def x(cls):
        return 1

assert C.x == 1
assert C().x == 1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<h1>Is it possible to use the property() function with classmethod decorated functions?</h1>
</blockquote>
<p>No. </p>
<p>However, a classmethod is simply a bound method (a partial function) on a class accessible from instances of that class.</p>
<p>Since the instance is a function of the class and you can derive the class from the instance, you can can get whatever desired behavior you might want from a class-property with <code>property</code>:</p>
<pre><code>class Example(object):
    _class_property = None
    @property
    def class_property(self):
        return self._class_property
    @class_property.setter
    def class_property(self, value):
        type(self)._class_property = value
    @class_property.deleter
    def class_property(self):
        del type(self)._class_property
</code></pre>
<p>This code can be used to test - it should pass without raising any errors:</p>
<pre><code>ex1 = Example()
ex2 = Example()
ex1.class_property = None
ex2.class_property = 'Example'
assert ex1.class_property is ex2.class_property
del ex2.class_property
assert not hasattr(ex1, 'class_property')
</code></pre>
<p>And note that we didn't need metaclasses at all - and you don't directly access a metaclass through its classes' instances anyways.</p>
<h2>writing a <code>@classproperty</code> decorator</h2>
<p>You can actually create a <code>classproperty</code> decorator in just a few lines of code by subclassing <code>property</code> (it's implemented in C, but you can see equivalent Python <a href="https://docs.python.org/3/howto/descriptor.html#properties" rel="noreferrer">here</a>):</p>
<pre><code>class classproperty(property):
    def __get__(self, obj, objtype=None):
        return super(classproperty, self).__get__(objtype)
    def __set__(self, obj, value):
        super(classproperty, self).__set__(type(obj), value)
    def __delete__(self, obj):
        super(classproperty, self).__delete__(type(obj))
</code></pre>
<p>Then treat the decorator as if it were a classmethod combined with property:</p>
<pre><code>class Foo(object):
    _bar = 5
    @classproperty
    def bar(cls):
        """this is the bar attribute - each subclass of Foo gets its own.
        Lookups should follow the method resolution order.
        """
        return cls._bar
    @bar.setter
    def bar(cls, value):
        cls._bar = value
    @bar.deleter
    def bar(cls):
        del cls._bar
</code></pre>
<p>And this code should work without errors:</p>
<pre><code>def main():
    f = Foo()
    print(f.bar)
    f.bar = 4
    print(f.bar)
    del f.bar
    try:
        f.bar
    except AttributeError:
        pass
    else:
        raise RuntimeError('f.bar must have worked - inconceivable!')
    help(f)  # includes the Foo.bar help.
    f.bar = 5

    class Bar(Foo):
        "a subclass of Foo, nothing more"
    help(Bar) # includes the Foo.bar help!
    b = Bar()
    b.bar = 'baz'
    print(b.bar) # prints baz
    del b.bar
    print(b.bar) # prints 5 - looked up from Foo!


if __name__ == '__main__':
    main()
</code></pre>
<p>But I'm not sure how well-advised this would be. An old mailing list <a href="https://mail.python.org/pipermail/python-ideas/2011-January/008959.html" rel="noreferrer">article</a> suggests it shouldn't work.</p>
<h2>Getting the property to work on the class:</h2>
<p>The downside of the above is that the "class property" isn't accessible from the class, because it would simply overwrite the data descriptor from the class <code>__dict__</code>.</p>
<p>However, we can override this with a property defined in the metaclass <code>__dict__</code>. For example:</p>
<pre><code>class MetaWithFooClassProperty(type):
    @property
    def foo(cls):
        """The foo property is a function of the class -
        in this case, the trivial case of the identity function.
        """
        return cls
</code></pre>
<p>And then a class instance of the metaclass could have a property that accesses the class's property using the principle already demonstrated in the prior sections:</p>
<pre><code>class FooClassProperty(metaclass=MetaWithFooClassProperty):
    @property
    def foo(self):
        """access the class's property"""
        return type(self).foo
</code></pre>
<p>And now we see both the instance</p>
<pre><code>&gt;&gt;&gt; FooClassProperty().foo
&lt;class '__main__.FooClassProperty'&gt;
</code></pre>
<p>and the class </p>
<pre><code>&gt;&gt;&gt; FooClassProperty.foo
&lt;class '__main__.FooClassProperty'&gt;
</code></pre>
<p>have access to the class property.</p>
</div>
<div class="post-text" itemprop="text">
<h1>Python 3!</h1>
<p>Old question, lots of views, sorely in need of a one-true Python 3 way. </p>
<p>Luckily, it's easy with the <code>metaclass</code> kwarg:</p>
<pre><code>class FooProperties(type):

    @property
    def var(cls):
        return cls._var

class Foo(object, metaclass=FooProperties):
    _var = 'FOO!'
</code></pre>
<p>Then, <code>&gt;&gt;&gt; Foo.var</code></p>
<blockquote>
<p>'FOO!'</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>There is no reasonable way to make this "class property" system to work in Python.</p>
<p>Here is one unreasonable way to make it work. You can certainly make it more seamless with increasing amounts of metaclass magic.</p>
<pre><code>class ClassProperty(object):
    def __init__(self, getter, setter):
        self.getter = getter
        self.setter = setter
    def __get__(self, cls, owner):
        return getattr(cls, self.getter)()
    def __set__(self, cls, value):
        getattr(cls, self.setter)(value)

class MetaFoo(type):
    var = ClassProperty('getvar', 'setvar')

class Foo(object):
    __metaclass__ = MetaFoo
    _var = 5
    @classmethod
    def getvar(cls):
        print "Getting var =", cls._var
        return cls._var
    @classmethod
    def setvar(cls, value):
        print "Setting var =", value
        cls._var = value

x = Foo.var
print "Foo.var = ", x
Foo.var = 42
x = Foo.var
print "Foo.var = ", x
</code></pre>
<p>The knot of the issue is that properties are what Python calls "descriptors". There is no short and easy way to explain how this sort of metaprogramming works, so I must point you to the <a href="http://users.rcn.com/python/download/Descriptor.htm" rel="noreferrer">descriptor howto</a>.</p>
<p>You only ever need to understand this sort of things if you are implementing a fairly advanced framework. Like a transparent object persistence or RPC system, or a kind of domain-specific language.</p>
<p>However, in a comment to a previous answer, you say that you </p>
<blockquote>
<p>need to modify an attribute that in such a way that is seen by all instances of a class, and in the scope from which these class methods are called does not have references to all instances of the class.</p>
</blockquote>
<p>It seems to me, what you really want is an <a href="http://en.wikipedia.org/wiki/Observer_pattern" rel="noreferrer">Observer</a> design pattern.</p>
</div>
<div class="post-text" itemprop="text">
<p>Setting it only on the meta class doesn't help if you want to access the class property via an instantiated object, in this case you need to install a normal property on the object as well (which dispatches to the class property). I think the following is a bit more clear:</p>
<pre><code>#!/usr/bin/python

class classproperty(property):
    def __get__(self, obj, type_):
        return self.fget.__get__(None, type_)()

    def __set__(self, obj, value):
        cls = type(obj)
        return self.fset.__get__(None, cls)(value)

class A (object):

    _foo = 1

    @classproperty
    @classmethod
    def foo(cls):
        return cls._foo

    @foo.setter
    @classmethod
    def foo(cls, value):
        cls.foo = value

a = A()

print a.foo

b = A()

print b.foo

b.foo = 5

print a.foo

A.foo = 10

print b.foo

print A.foo
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Because I need to modify an attribute that in such a way that is seen by all instances of a class, and in the scope from which these class methods are called does not have references to all instances of the class.</p>
</blockquote>
<p>Do you have access to at least one instance of the class? I can think of a way to do it then:</p>
<pre><code>class MyClass (object):
    __var = None

    def _set_var (self, value):
        type (self).__var = value

    def _get_var (self):
        return self.__var

    var = property (_get_var, _set_var)

a = MyClass ()
b = MyClass ()
a.var = "foo"
print b.var
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Half a solution, __set__ on the class does not work, still. The solution is a custom property class implementing both a property and a staticmethod</p>
<pre><code>class ClassProperty(object):
    def __init__(self, fget, fset):
        self.fget = fget
        self.fset = fset

    def __get__(self, instance, owner):
        return self.fget()

    def __set__(self, instance, value):
        self.fset(value)

class Foo(object):
    _bar = 1
    def get_bar():
        print 'getting'
        return Foo._bar

    def set_bar(value):
        print 'setting'
        Foo._bar = value

    bar = ClassProperty(get_bar, set_bar)

f = Foo()
#__get__ works
f.bar
Foo.bar

f.bar = 2
Foo.bar = 3 #__set__ does not
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Give this a try, it gets the job done without having to change/add a lot of existing code.</p>
<pre><code>&gt;&gt;&gt; class foo(object):
...     _var = 5
...     def getvar(cls):
...         return cls._var
...     getvar = classmethod(getvar)
...     def setvar(cls, value):
...         cls._var = value
...     setvar = classmethod(setvar)
...     var = property(lambda self: self.getvar(), lambda self, val: self.setvar(val))
...
&gt;&gt;&gt; f = foo()
&gt;&gt;&gt; f.var
5
&gt;&gt;&gt; f.var = 3
&gt;&gt;&gt; f.var
3
</code></pre>
<p>The <code>property</code> function needs two <code>callable</code> arguments. give them lambda wrappers (which it passes the instance as its first argument) and all is well.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a solution which should work for both access via the class and access via an instance which uses a metaclass.</p>
<pre><code>In [1]: class ClassPropertyMeta(type):
   ...:     @property
   ...:     def prop(cls):
   ...:         return cls._prop
   ...:     def __new__(cls, name, parents, dct):
   ...:         # This makes overriding __getattr__ and __setattr__ in the class impossible, but should be fixable
   ...:         dct['__getattr__'] = classmethod(lambda cls, attr: getattr(cls, attr))
   ...:         dct['__setattr__'] = classmethod(lambda cls, attr, val: setattr(cls, attr, val))
   ...:         return super(ClassPropertyMeta, cls).__new__(cls, name, parents, dct)
   ...:

In [2]: class ClassProperty(object):
   ...:     __metaclass__ = ClassPropertyMeta
   ...:     _prop = 42
   ...:     def __getattr__(self, attr):
   ...:         raise Exception('Never gets called')
   ...:

In [3]: ClassProperty.prop
Out[3]: 42

In [4]: ClassProperty.prop = 1
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-4-e2e8b423818a&gt; in &lt;module&gt;()
----&gt; 1 ClassProperty.prop = 1

AttributeError: can't set attribute

In [5]: cp = ClassProperty()

In [6]: cp.prop
Out[6]: 42

In [7]: cp.prop = 1
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-7-e8284a3ee950&gt; in &lt;module&gt;()
----&gt; 1 cp.prop = 1

&lt;ipython-input-1-16b7c320d521&gt; in &lt;lambda&gt;(cls, attr, val)
      6         # This makes overriding __getattr__ and __setattr__ in the class impossible, but should be fixable
      7         dct['__getattr__'] = classmethod(lambda cls, attr: getattr(cls, attr))
----&gt; 8         dct['__setattr__'] = classmethod(lambda cls, attr, val: setattr(cls, attr, val))
      9         return super(ClassPropertyMeta, cls).__new__(cls, name, parents, dct)

AttributeError: can't set attribute
</code></pre>
<p>This also works with a setter defined in the metaclass.</p>
</div>
<div class="post-text" itemprop="text">
<p>After searching different places, I found a method to define a classproperty
valid with Python 2 and 3.</p>
<pre><code>from future.utils import with_metaclass

class BuilderMetaClass(type):
    @property
    def load_namespaces(self):
        return (self.__sourcepath__)

class BuilderMixin(with_metaclass(BuilderMetaClass, object)):
    __sourcepath__ = 'sp'        

print(BuilderMixin.load_namespaces)
</code></pre>
<p>Hope this can help somebody :)</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's my suggestion.  Don't use class methods.  </p>
<p>Seriously.  </p>
<p>What's the reason for using class methods in this case?  Why not have an ordinary object of an ordinary class?</p>
<hr/>
<p>If you simply want to change the value, a property isn't really very helpful is it?  Just set the attribute value and be done with it.</p>
<p>A property should only be used if there's something to conceal -- something that might change in a future implementation.  </p>
<p>Maybe your example is way stripped down, and there is some hellish calculation you've left off.  But it doesn't look like the property adds significant value.</p>
<p>The Java-influenced "privacy" techniques (in Python, attribute names that begin with _) aren't really very helpful.  Private from whom?  The point of private is a little nebulous when you have the source (as you do in Python.)</p>
<p>The Java-influenced EJB-style getters and setters (often done as properties in Python) are there to facilitate Java's primitive introspection as well as to pass muster with the static language compiler.  All those getters and setters aren't as helpful in Python.</p>
</div>
<span class="comment-copy">This doesn't seem to work for me in Python 3.2.  If I change foo.__metaclass__.var = property(foo.getvar.im_func, foo.setvar.im_func) to foo.__metaclass__.var = property(foo.getvar.__func__, foo.setvar.__func__) I get "AttributeError: type object 'foo' has no attribute 'var'" when executing "foo.var".</span>
<span class="comment-copy"><i>SIGH</i> double correction: this works in Python 2.7, but not Python 3.2.</span>
<span class="comment-copy">@MichaelKelley - That's because the syntax for <a href="http://www.python.org/dev/peps/pep-3115/" rel="nofollow noreferrer">metaclasses has changed in Python 3.x</a></span>
<span class="comment-copy">I am not quite sure to understand, what would be the Python 3.x way to write this then ?</span>
<span class="comment-copy">@Josay: You'd need to define the metaclass first, then define the class using the new <code>class Foo(metaclass=...)</code> syntax.</span>
<span class="comment-copy">I don't think the setter part of the ClassProperty actually works as described: while the example's assertions all pass, at the end foo._var == 4 (not 3, as implied). Setting the property clobbers the property itself. When class-properties were discussed on <a href="http://mail.python.org/pipermail/python-ideas/2011-January/008950.html" rel="nofollow noreferrer">python-dev</a> <a href="http://mail.python.org/pipermail/python-ideas/2011-January/008959.html" rel="nofollow noreferrer">it was pointed out that, while getters are trivial, setters are difficult (impossible?) without a metaclass</a></span>
<span class="comment-copy">@Gabriel Totally correct. I can't believe no one pointed that out for two years.</span>
<span class="comment-copy">I'm also not sure why you don't not just use <code>self.fget(owner)</code> and remove the need to have to use a <code>@classmethod</code> at all here? (that's what <code>classmethod</code> <i>does</i>, translate <code>.__get__(instance, owner)(*args, **kwargs)</code> to <code>function(owner, *args, **kwargs)</code> calls, via an intermediary; properties don't need the intermediary).</span>
<span class="comment-copy">Your demonstration is lacking any actual transformation in either the getter or the setter that would neatly demonstrate that your <code>foo.var = 3</code> assignment <b>doesn't actually go through the property</b>, and instead has simply replaced the property object on <code>foo</code> with an integer. If you added <code>assert isinstance(foo.__dict__['var'], ClassProperty)</code> calls between your assertions you'd see that fail after <code>foo.var = 3</code> is executed.</span>
<span class="comment-copy">Python classes don't support descriptor binding on setting <i>on the class itself</i>, only on getting (so <code>instance.attr</code>, <code>instance.attr = value</code> and <code>del instance.attr</code> will all bind the descriptor found on <code>type(instance)</code>, but while <code>classobj.attr</code> binds, <code>classobj.attr = value</code> and <code>del classobj.attr</code> do <i>not</i> and instead replace or delete the descriptor object itself). You need a metaclass to support setting and deleting (making the class object the instance, and the metaclass the type).</span>
<span class="comment-copy">Does this work with subclasses? (can a subclass override classproperties?)</span>
<span class="comment-copy">Umm yes? <code>class D(C): x = 2; assert D.x == 2</code></span>
<span class="comment-copy">I wish this worked when I use it in <code>.format</code> like <code>"{x}".format(**dict(self.__class__.__dict__, **self.__dict__))</code> :(</span>
<span class="comment-copy">This isn't read-only. <code>C.x = 10; assert C.x == 10</code></span>
<span class="comment-copy">@Nathan Not only... when you set it you override all <code>x</code> access by  <code>10</code>. I like this approach because is neat and simple but sounds like an antipattern</span>
<span class="comment-copy">that is to say there is no simple way out of the box</span>
<span class="comment-copy">@mehmet Is this not simple? <code>Foo</code> is an instance of its metaclass, and <code>@property</code> can be used for its methods just as it can for those of instances of <code>Foo</code>.</span>
<span class="comment-copy">you had to define another class for a class, that is double the complexity assuming the metaclass is not reusable.</span>
<span class="comment-copy">I like the idea of the code example, but it seems like it would be a little clunky in practice.</span>
<span class="comment-copy">What I'm trying to accomplish is pretty straight forward setting and getting of a single attribute that's used as a flag to modify the behavior of all instances so I think Observer would be overblown for what I'm trying to do.  If there were multiple attributes in question then I'd be more inclined.</span>
<span class="comment-copy">It seems that just making the functions public and calling them directly was the simplist solution.  I was curious if I was doing something wrong or if I was trying to do was impossible.  Sorry about the multiple comments by the way.  300 character limit sucks.</span>
<span class="comment-copy">The nifty thing about the code example is that you can implement all the clunky bits once and then inherit them. Just move the _var into the derived class.  class D1(Foo):   _var = 21  class D2(Foo)   _var = "Hello"  D1.var  21 D2.var Hello</span>
<span class="comment-copy">setter doesn't work</span>
<span class="comment-copy">It does not however work on the class.</span>
<span class="comment-copy">As Florian Bösch points out, the syntax required (by third-party libraries or legacy code) is foo.var.</span>
<span class="comment-copy">If this method is something you found somewhere, it would be good to give a link (see <a href="/help/referencing">How to reference material written by others</a>)</span>
<span class="comment-copy">Because I need to modify an attribute that in such a way that is seen by all instances of a class, and in the scope from which these class methods are called does not have references to all instances of the class.</span>
