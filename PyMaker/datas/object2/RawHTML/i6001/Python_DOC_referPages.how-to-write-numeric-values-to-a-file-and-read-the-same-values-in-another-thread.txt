<div class="post-text" itemprop="text">
<p>I want to write 4 numeric values to a file using one thread and read the same values in an another thread. All of this should of course be simultaneous. The second thread will only read values not modify them. Can it be done? </p>
</div>
<div class="post-text" itemprop="text">
<p>First of all, if you want to transfer data among threads which belong to the same process - you don't need to do it using files as a communication point. The easiest way is to use <a href="https://docs.python.org/3.6/library/queue.html#module-Queue" rel="nofollow noreferrer">queues</a> which are thread safe python mechanisms to send data from one thread to another using a <a href="https://en.wikipedia.org/wiki/FIFO_and_LIFO_accounting" rel="nofollow noreferrer">FIFO</a> style.</p>
<pre><code>#!/usr/bin/python3
from threading import Thread
from queue import Queue
from time import sleep

q = Queue()


def run_func_in_diff_thread(func, *args):
    t = Thread(target=func, args=args)
    t.setDaemon = True
    t.start()


def writer(data_set):
    global q  # queue must be shared/common for our threads
    print("Writer thread started")
    for elem in data_set:
        q.put(elem)  # put current elem into queue
        print("%s &gt; %d" % ("writer", elem))
        sleep(1)
    q.put(-1)  # something like last element
    print("Writer thread finished since last element has been put")


def reader():
    global q  # queue must be shared/common for our threads
    print("Reader thread started")
    while True:
        elem = q.get()  # remove and return an item from the queue
        print("%s &gt; %d" % ("reader", elem))
        sleep(0.1)
        if elem == -1:
            break
    print("Reader thread finished since last element has been received")


data = [x for x in range(5)]
run_func_in_diff_thread(writer, data)
run_func_in_diff_thread(reader)
</code></pre>
<p>You will get the following output:</p>
<pre><code>Writer thread started
writer &gt; 0
Reader thread started
reader &gt; 0
writer &gt; 1
reader &gt; 1
writer &gt; 2
reader &gt; 2
writer &gt; 3
reader &gt; 3
writer &gt; 4
reader &gt; 4
Writer thread finished since last element has been put
reader &gt; -1
Reader thread finished since last element has been received
</code></pre>
<p>This is very simple, isnt' it?</p>
<p>Ok, if you really need to use a file to send data between your threads, I can suggest the following:</p>
<pre><code>#!/usr/bin/python3
from threading import Thread, Lock
from time import sleep

lock = Lock()  # lock to synchronize your threads


def run_func_in_diff_thread(func, *args):
    t = Thread(target=func, args=args)
    t.setDaemon = True
    t.start()

def read_or_write(path, type='r', data=None):
    if type == 'r':
        with open(path, type) as f:
            elem = f.readlines()[-1]  # read last element
            print("Read data from file &lt; %d" % int(elem))
            if int(elem) == -1:
                print("Received last element. Stop reading")
                return False
            return True

    else:
        with open(path, type) as f:
            print("Write data to file &gt; %d" % data)
            f.write("%s\n" % str(data))
            return True


def func_runner(func, file_path, type, data_set=None):
    if type == "a":
        # writer
        for data in data_set:
            lock.acquire()
            read_or_write(file_path, type, data)
            lock.release()
            sleep(1)
    else:
        # reader
        while True:
            lock.acquire()
            res = func(file_path, type)
            lock.release()
            if not res:
                break
            sleep(1)

data_set = [x for x in range(5)]
data_set.append(-1)  # something like last element
file_path = "file.txt"
run_func_in_diff_thread(func_runner, read_or_write, file_path, "a", data_set)
run_func_in_diff_thread(func_runner, read_or_write, file_path, "r")
</code></pre>
<p>And you'll get the following output:</p>
<pre><code>Write data to file &gt; 0
Read data from file &lt; 0
Read data from file &lt; 0
Write data to file &gt; 1
Read data from file &lt; 1
Write data to file &gt; 2
Read data from file &lt; 2
Write data to file &gt; 3
Read data from file &lt; 3
Write data to file &gt; 4
Read data from file &lt; 4
Write data to file &gt; -1
Read data from file &lt; -1
Received last element. Stop reading
</code></pre>
<p>In this case you need to use <a href="https://docs.python.org/3/library/threading.html#lock-objects" rel="nofollow noreferrer">Lock</a> - built-in mechanism to synchronize threads to avoid data corruption.</p>
<p>As I said, please consider using Queue rather than using a file for thread syncing.</p>
</div>
<span class="comment-copy">Do you <i>need</i> to write data to a file, or do you just want to pass information between threads and this is the first approach that came to mind? Perhaps you could be using <a href="https://docs.python.org/3.6/library/queue.html" rel="nofollow noreferrer">Queues</a> instead, which do a lot of the heavy lifting for you.</span>
<span class="comment-copy">The data is used in another script so I think its better to write to a file. Dont you think?</span>
<span class="comment-copy">Depends on your definition of simultaneous, but yes, of course it can be done.  Do you need to use a file though? Have you looked at <a href="https://docs.python.org/2/library/queue.html" rel="nofollow noreferrer">queues</a>? What have you tried?</span>
<span class="comment-copy">Two scripts can share objects without having to write to a file, if one script imports the other.</span>
<span class="comment-copy">I'm not familiar with queues. Could you refer me to something to get started?</span>
<span class="comment-copy">Also, you can use queues to send data among different processes that's useful in many cases. But in this case it should be <code>queue</code> from <code>multiprocessing</code> module. Docs are <a href="https://docs.python.org/2/library/multiprocessing.html#exchanging-objects-between-processes" rel="nofollow noreferrer">here</a>.</span>
