<div class="post-text" itemprop="text">
<p>I am an engineer and I use a python REPL as an advanced calculator while working. I use the "previous output" feature of the REPL, which is _, often.</p>
<pre><code>&gt;&gt;&gt;45*0.344
15.48
&gt;&gt;&gt;_*2
30.96
</code></pre>
<p>Something like that.</p>
<p>For some reason I find it kind of a chore to type the underscore though. I've used the Haskell REPL, which uses "it" as the previous output variable, which I find easier to type.</p>
<p>I learned that iPython lets you define macros that execute some code. So I popped open an iPython shell and defined a %macro called "it" that mimics the "_".</p>
<pre><code>In [1]: _
Out[1]: ''

In [2]: %macro it 1
Macro `it` created. To execute, type its name (without quotes).
=== Macro contents: ===
_
</code></pre>
<p>I can call "it" like so:</p>
<pre><code>In [1]: 4
Out[1]: 4

In [2]: it
Out[2]: 4
</code></pre>
<p>However, when I try to do something with "it" like <code>it*4</code>, I get the error <code>unsupported operand type(s) for *: 'Macro' and 'int'</code>.</p>
<p>I want "it" to be the type it's returning instead of the type Macro, so that I can use it just like I use "_".</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of going the macro route you could also change the code where <code>_</code> gets assigned. <a href="https://docs.python.org/3/library/sys.html#sys.displayhook" rel="nofollow noreferrer"><code>sys.displayhook</code></a> does this and can be changed:</p>
<blockquote>
<p>The display of these values can be customized by assigning another
  one-argument function to sys.displayhook.</p>
</blockquote>
<p>So we can simply save in <code>__builtins__.it</code> or whatever name you like:</p>
<pre><code>import sys
ipython_displayhook = sys.displayhook
def mydisplayhook(value):
    if value is not None:
        __builtins__.it = value
    return ipython_displayhook(value)
sys.displayhook = mydisplayhook
</code></pre>
<p>This works in the normal python shell, but somehow ipython prevents with tampering with <code>sys.displayhook</code>. The code in ipython that handles the displayhook is in <code>IPython.core.displayhook.DisplayHook</code> so we can monkey patch that:</p>
<pre><code>import IPython.core.displayhook
__call__ = IPython.core.displayhook.DisplayHook.__call__

def mycall(self, value):
    if value is not None:
        __builtins__.it = value
    __call__(self, value)

IPython.core.displayhook.DisplayHook.__call__ = mycall
</code></pre>
<p>This is a bit hacky. Things may break, but after testing this for 5 seconds it seems that it works. </p>
<p>You probably don't want to type that everytime you start ipython, but we can automate that. <a href="https://stackoverflow.com/questions/11124578/automatically-import-modules-when-entering-the-python-or-ipython-interpreter">This answer</a> says you can simply put a file into <code>~/.ipython/profile_default/startup/</code> which gets then executed everytime.</p>
</div>
<div class="post-text" itemprop="text">
<p>When I try that I get</p>
<pre><code>In [329]: it.value
Out[329]: '_\n'
</code></pre>
<p>The macro includes the '\n'.  So a stand alone <code>it</code> behaves ok. But it can't be used in-line.</p>
</div>
<span class="comment-copy">I like this idea but, a) should be displayhook not displayhandler, but I changed that, and b) I'm getting a NameError that "it" is not defined.  And I'm not quite good enough at python to figure out exactly what's wrong.</span>
<span class="comment-copy">Somehow mixed "handler" and "hook", sorry. I tested in the normal python shell, and there this solution actually works. IPython though somehow prevents changing the displayhook, but through monkeypatching we can still achieve what we want. See my edit.</span>
