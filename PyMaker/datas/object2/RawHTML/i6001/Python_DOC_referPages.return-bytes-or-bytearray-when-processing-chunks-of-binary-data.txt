<div class="post-text" itemprop="text">
<p>When returning/yielding chunks of binary data, is it more idiomatic to return <code>bytes</code> or <code>bytearray</code>?</p>
<p>My function accumulates data in a <code>bytearray</code> and currently returns <code>bytes(myarray)</code>. Are there any reasons for or against returning just 
the <code>bytearray</code> directly? In particular, if a function expects <code>bytes</code> and gets <code>bytearray</code>, are there any possible pitfalls (as long as it doesn't check the actual type)?</p>
<p>According to the <a href="https://docs.python.org/3.1/library/functions.html#bytearray" rel="nofollow noreferrer">documentation of <code>bytearray</code></a>:</p>
<blockquote>
<p>It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as <strong>most methods that the <code>bytes</code> type has</strong>, see <a href="https://docs.python.org/3.1/library/stdtypes.html#bytes-methods" rel="nofollow noreferrer">Bytes and Byte Array Methods</a>.</p>
</blockquote>
<p>(My emphasis.) This suggests that <code>bytearray</code> can be used in any place that where <code>bytes</code> is expected.</p>
</div>
<div class="post-text" itemprop="text">
<p>They are not interchangeable for every possible case. Some code may use type checking and they have different types. Like their names, types are <code>bytearray</code> and <code>bytes</code>.</p>
<p>After question edit:</p>
<p>The only difference is that <a href="https://docs.python.org/3.1/library/functions.html#bytes" rel="nofollow noreferrer">bytes is an immutable version of bytearray</a>.</p>
<p>So, <code>bytearray</code> can be used in any place where <code>bytes</code> is expected.</p>
</div>
<span class="comment-copy"><code>ByteArray</code> got index but <code>bytes</code> haven't any idea about of index. Byte-array protect all patterns from wrong encodings, but can't use directly, need translate before usage(mean bytes(byte-array)). So short description : <b><code>bytearray</code> is raw source, <code>bytes</code> are output.</b></span>
<span class="comment-copy">Note: This isn't perfect. Some APIs will perform an <code>isinstance(x, bytes)</code> check without also allowing <code>bytearray</code>. Inconsistencies <a href="https://bugs.python.org/issue34465" rel="nofollow noreferrer">like this are usually considered a bug</a>, but it does happen.</span>
<span class="comment-copy">@ShadowRanger Using <code>if isinstance(address, bytes):</code> will exclude <code>bytearray</code>. So, why <code>bytes</code>, why not <code>bytearray</code>? It does seem as a bug to me as long as <code>bytes</code> and <code>bytearray</code> both represent a bytes string. <code>if isinstance(address, (bytes, bytearray)):</code> would be correct.</span>
<span class="comment-copy">I was pointing out that this was a mistake that usually gets fixed when noticed. I'm not trying to justify it. That said, even allowing <code>bytes</code>+<code>bytearray</code> is usually not broad enough; byte-width <code>memoryview</code>s, <code>array.array</code>s, and <code>mmap.mmap</code>s, among others, should all be interchangeable. In modern Python, they <i>finally</i> added <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.ByteString" rel="nofollow noreferrer">an ABC to group these, <code>collections.abc.ByteString</code></a>, but it's going to take a while for all the tests in the standard library to use it reliably.</span>
<span class="comment-copy">@ShadowRanger I just did emphasize your point. Even <code>collections.abc.ByteString</code> <a href="https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L941" rel="nofollow noreferrer">will just check</a> for <code>bytes</code> and <code>bytearray</code>. According to <a href="https://www.python.org/dev/peps/pep-3137/#comparisons" rel="nofollow noreferrer">PEP3137</a> <code>bytes</code> and <code>bytearray</code> are comparable and orderable. Also, I do agree with your points made in your second comment.</span>
<span class="comment-copy">You're right. While the only registrations performed in <code>collections.abc</code> are for <code>bytes</code> and <code>bytearray</code>, and third party types are allowed and expected to register themselves as <code>ByteString</code>s when appropriate, there is a problem with most such use cases since, aside from <code>mmap.mmap</code> (which could register itself, but doesn't), most such types (<code>memoryview</code>, <code>array.array</code>, <code>numpy</code> <code>array</code> type) are too general to have them always fit <code>ByteString</code>, which leaves manual instance checks (e.g. convert to <code>memoryview</code> catching <code>TypeError</code>, check <code>v.c_contiguous and v.ndim == 1 and v.format == 'B'</code>).</span>
