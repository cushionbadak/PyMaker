<div class="post-text" itemprop="text">
<pre><code>$ python -c 'import urllib.parse; print(urllib.error.HTTPError)'
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
AttributeError: module 'urllib' has no attribute 'error'
</code></pre>
<p>That's expected. I haven't imported <code>urllib.error</code> module.</p>
<pre><code>$ python -c 'import urllib.request; print(urllib.request.HTTPError)'
&lt;class 'urllib.error.HTTPError'&gt;
</code></pre>
<p>This one too. <code>urllib.request</code> <a href="https://github.com/python/cpython/blob/v3.7.0a2/Lib/urllib/request.py#L102" rel="nofollow noreferrer">imports</a> <code>urllib.error</code>:</p>
<pre><code>from urllib.error import URLError, HTTPError, ContentTooShortError
</code></pre>
<p>So the names are available via <code>urllib.request</code>.</p>
<pre><code>$ python -c 'import urllib.request; print(urllib.error.HTTPError)'
&lt;class 'urllib.error.HTTPError'&gt;
</code></pre>
<p>But not this one. What makes me able to access <code>HTTPError</code> via <code>urllib.error</code>? I've read <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">the</a> <a href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="nofollow noreferrer">docs</a>, but saw no clues there.</p>
</div>
<div class="post-text" itemprop="text">
<p>OK, let's see:</p>
<pre><code>import urllib.parse
globals()
</code></pre>
<p>You will see an item:</p>
<pre><code>'urllib': &lt;module 'urllib' from 'C:\\Users\\XXXX\\AppData\\Local\\Programs\\Python\\Python35\\lib\\urllib\\__init__.py'&gt;
</code></pre>
<p>Then, try <code>dir(urllib)</code>, you will see:</p>
<pre><code>['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'parse']
</code></pre>
<p>So there is a <code>parse</code> in <code>urllib</code>, but not <code>request</code> or <code>error</code>. Because <code>parse</code> doesn't import them.</p>
<p>Now let's go to <code>urllib.request</code>:</p>
<pre><code>import urllib.request
globals()
</code></pre>
<p>Get an item:</p>
<pre><code>'urllib': &lt;module 'urllib' from 'C:\\Users\\XXXX\\AppData\\Local\\Programs\\Python\\Python35\\lib\\urllib\\__init__.py'&gt;
</code></pre>
<p>It is the same as <code>import urllib.parse</code>.</p>
<p>Then try <code>dir(urllib)</code> again:</p>
<pre><code>['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'error', 'parse', 'request', 'response']
</code></pre>
<p>There are <code>'error', 'parse', 'request', 'response'</code> in it. Why? <strong>Because <code>urllib.request</code> imports them</strong>.</p>
<p>Let me try and explain it in more details. Importing <code>urllib.request</code> first imports <code>urllib</code>, then <code>urllib.request</code>. Importing <code>urllib</code> gives us <code>urllib</code> symbol in local scope, representing module having been imported. Importing <code>urllib.request</code> imports <code>urllib.error</code> among other things. Which adds <code>error</code> symbol to <code>urllib</code> module. And <strong>since we have reference to <code>urllib</code></strong>, that makes us able to access <code>urllib.error</code> after importing <code>urllib.request</code>. Consider the following example:</p>
<p><code>./main.py</code></p>
<pre><code>#!/usr/bin/env python
import a.b
print(a.c.c)   # 2
print(d.e.e)   # NameError
</code></pre>
<p><code>./a/b.py</code></p>
<pre><code>import a.c
import d.e
b = 1
</code></pre>
<p><code>./a/c.py</code></p>
<pre><code>c = 2
</code></pre>
<p><code>./d/e.py</code>:</p>
<pre><code>e = 3
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Unsure whether it is what you expected, but this is <em>by design</em>. Is you look at the sources of urllib/parse.py and urllib/request.py you will see an important difference: the former only import the re, sys and collections modules when the latter (in addition to other unrelated modules) also explicitely imports symbols from urllib.error, urllib.parse and urllib.response.</p>
<p>That is the reason why you find them available even if the import was not in your own source file.</p>
<p>A more detailed answer would require a detailed description of Python import machinery and is far beyond what is appropriate in a SO answer. Please refer to the official documentation for a more in depth explaination.</p>
</div>
<span class="comment-copy">I think, "Because urllib.request imports them" doesn't cut it. From my point of view, "module A importing module B, and module B importing module C" doesn't mean that module C gets available from module A. What do you say of <a href="https://stackoverflow.com/questions/47459717/does-importing-a-module-in-python-execute-all-the-modules-imports-in-local-scop#comment81876008_47459951">my explanation</a>? On a side note, your showing how to inspect the matter was pretty educational.</span>
<span class="comment-copy">The critical point is that no matter how you use <code>import A.B.C...</code>. You first get the access to top scope <code>A</code>. So you will have access to every submodules if they have been imported somewhere.</span>
<span class="comment-copy">I'd say the critical point is that <code>import</code> can affect parent scopes. If I <code>import</code> <code>A.B</code> and <code>A.B</code> <code>import</code>s <code>A.C</code>, I'd probably expect to find <code>C</code> under <code>A.B.A.C</code>. Not that it's the right thing to do, just what I'd expect.</span>
<span class="comment-copy">This is designed to efficiently manage module importing. Every module in python will be imported only once. If it works as you expect, suppose <code>import A.B</code> and <code>A.B</code> import <code>A.C</code>, then you get <code>A.B.A.C</code>, but after you also manually <code>import A.C</code>, in this case, what are you having now? Two identical modules <code>A.B.A.C</code> and <code>A.C</code>.</span>
<span class="comment-copy">Although we can make <code>C</code> of <code>A.B.A</code> a reference of <code>C</code> of <code>A</code>, this will disturb the scope in such a simple example, isn't it?</span>
<span class="comment-copy">Can you at least give some clues regarding what makes <code>urllib.error</code> available? I believe I've read the description of that machinery and am still at a loss. And by the way, should I only import <code>urllib.request</code> then and access all the methods via <code>urllib.request</code> only? Or each via corresponding module?</span>
<span class="comment-copy">Let me try to explain it. <code>import urllib.request</code> == <code>import urllib</code> + <code>import urllib.request</code>. <code>import urllib</code> finds and loads the module, then binds it into local scope as <code>urllib</code>. <code>import urllib.request</code> finds and loads the module and binds it into <code>urllib</code>'s scope as <code>request</code>. While loading <code>urllib.request</code>, it imports <code>urllib.error</code> which probably binds the latter into <code>urllib</code>'s scope as <code>error</code>. That's what makes us able to access <code>HTTPError</code> via <code>urllib.error.HTTPError</code>. Am I wrong?</span>
