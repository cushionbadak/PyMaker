<div class="post-text" itemprop="text">
<p>I have a function that takes a path to a file as an argument.</p>
<pre><code>output = process('path/to/file.txt')
</code></pre>
<p>I was wondering if I could easily doctest such a function. I supply an example input file somewhere along the source code, and I can compare the output to what I expect (a string, a python object, or possibly the content of another file).</p>
<p>The issue is that the path in my test is necessarily relative. Relative to the <em>working directory of the calling script</em> that is.</p>
<p>This means that all the paths in the docstring must be aware of the test suite's entry point. Clearly that is not ideal. In a more sophisticated testing environment I would be able to use <code>__file__</code> to make the path absolute, but in a doctest, <code>__file__</code> does not exist.</p>
<p>What is the usual set-up when supplying stimuli as a file?</p>
<p>I hope to hear some better solutions than just 'always run the test suite from the same working directory'.</p>
<p><strong>EDIT</strong>: I'd like to run the doctests from a centralized test suite entry point.</p>
<pre><code>import doctest
import mymodule

doctest.testmod(mymodule)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you are doing this at the module level, I assume that you have also <a href="https://packaging.python.org/tutorials/distributing-packages/" rel="nofollow noreferrer">packaged your modules as a proper Python package</a> using something like <code>setuptools</code> and be deployed onto some environment where the tests will then be executed.  Also, you are only partially correct in the assumption where <code>__file__</code> doesn't exist - it also is not defined for a module imported from a zipped Python egg (which are getting more rare as wheels became the de facto packaging method, but they can and do exist).</p>
<p>There are a number of possible approaches, varying in complexity and trade offs and whether it works depend on how the module(s) to be tested are structured.</p>
<p>1) (Not recommended, but included anyway because sometimes this works best in the cases of simplest examples.) The laziest, but the most stable, self-contained and cross platform way - and it assumes that the file opening methods is only done in that one module that was to be tested and are done using the same call (e.g. <code>open</code>), the usage of <a href="https://docs.python.org/3/library/doctest.html#doctest.testmod" rel="nofollow noreferrer"><code>extraglobs</code></a> argument can be used to substitute the <code>open</code> call.  e.g.</p>
<pre><code>from io import StringIO
import doctest
import mymodule

files = {
    'path/to/file1.txt': '... contents of file1.txt ...', 
    'path/to/file2.txt': '... contents of file2.txt ...',
} 

def lazyopen(p, flag='r'):
    result = StringIO(files[p] if flag == 'r' else '')
    result.name = p 
    return result

doctest.testmod(mymodule, extraglobs={'open': lazyopen})
</code></pre>
<p>2) Create a real testsuite, rather than using the builtin ones through <code>doctest.testmod</code></p>
<p>While the shorthand is useful, it is too limited as it is standalone, it cannot be used in conjunction with other testsuites that might get built.  Consider creating a dedicated test module (e.g. <code>mymodule/tests.py</code>).  I generally prefer creating a directory named <code>mymodule/tests</code>, with unittests named something like <code>test_mysubmodule.py</code>, and a <code>__init__.py</code> that contain the test_suite setup like so</p>
<pre><code>def make_suite():
    import mymodule
    import os

    def setUp(suite):
        suite.olddir = os.getcwd()  # save the current working directory
        os.chdir(targetdir)  # need to define targetdir

    def tearDown(suite):
        os.chdir(suite.olddir)  # restore the original working directory

    return doctest.DocTestSuite(mymodule, setUp=setUp, tearDown=tearDown)
</code></pre>
<p>So we have covered the basic, but <code>targetdir</code> needs to be defined.  Again, multiple things you can consider:</p>
<p>1) Create a temporary directory and populate the directory with the required files using <code>setup</code>, and <code>os.chdir</code> to that, and remove the temporary directory in <code>tearDown</code>.  Either manually write data stored as strings inside the test module, copy from your project or extract from an archive, but how do we actually get those?  Which leads to...</p>
<p>2) If the source files are inside your project, and <code>setuptools</code> is available/installed in the environment, simply use <a href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#resource-extraction" rel="nofollow noreferrer"><code>pkg_resources.resource_filename</code></a> to get the location, and assign <code>targetdir</code> to that.  The <code>setUp</code> might now look something like</p>
<pre><code>    def setUp(suite):
        suite.olddir = os.getcwd()
        targetdir = pkg_resources.resource_filename('mymodule', '')
        os.chdir(targetdir)
</code></pre>
<p>Also, finally, as this is now a real test suite that is produced by the <code>make_suite</code> function within <code>mymodules.tests</code>, the execution of that must be done using a testrunner, which fortunately is included as part of the default unittest framework as a simple command which can be done like so:</p>
<pre><code>$ python -m unittest mymodule.tests.make_suite
.
----------------------------------------------------------------------
Ran 1 test in 0.014s

OK
</code></pre>
<p>Also, as that is a real test suite, it can be integrated with the testsuite globbing from the <code>unittest</code> module to combine everything into a single complete test suite for your entire package.</p>
<pre><code>def make_suite():
    # ... the other setup code

    # this loads all unittests in mymodule from `test_*.py` files
    # inside `mymodule.tests`
    test_suite = test_loader.discover(
        'mymodule.tests', pattern='test_*.py')
    test_suite.addTest(
        doctest.DocTestSuite(mymodule, setUp=setUp, tearDown=tearDown))
    return test_suite
</code></pre>
<p>Again, the <code>python -m unittest</code> command may be used to execute the tests returned by the complete test suite.</p>
</div>
<span class="comment-copy">What is the code that set up the doctests that are referenced here? What I mean is, are they from docstrings inside a module, or a collection of text files?</span>
<span class="comment-copy">Added some info. Thanks for asking.</span>
<span class="comment-copy">Thanks a lot! I very much appreciate the effort you put into this answer. It seems like <code>pkg_resources.resource_filename</code> is what I was looking for. I will play around with it tomorrow. If no other answer appears by then I will accept this one. For now, have a +1.</span>
<span class="comment-copy">Thanks again, your answer was both very instructive and on point. For what it's worth, I now settled with a py.test fixture (which is what I am using rather than unittest) that is automatically applied to all doctests. It changes the cwd as you suggested. Works well AFAICT.</span>
<span class="comment-copy">Yeah, <code>py.test</code> is fine, it simplifies a lot of the test harness setup workflow, (a very) slight downside is that others that want to test your code will need to have py.test installed in their environment.</span>
