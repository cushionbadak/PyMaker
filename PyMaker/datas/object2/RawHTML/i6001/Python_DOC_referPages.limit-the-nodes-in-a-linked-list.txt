<div class="post-text" itemprop="text">
<p>Is it possible to limit the nodes kept in a linked list?  </p>
<p>For simplicity, take the example below:</p>
<pre><code>import numpy as np

class LinkedList():
    def __init__(self,data,prev):
        self.data = data
        self.prev = prev

myData_prev = None

for x in range(10):
    data = np.random.random((3,2))
    myData = LinkedList(data,myData_prev)

    myData_prev = myData

print(myData.data)
print(myData.prev.data)
print(myData.prev.prev.data)
print(myData.prev.prev.prev.data)  ## DELETED OR NO LONGER AVAILABLE
</code></pre>
<p>Pretend the 'data' is quite large or the range is indefinite.  Is it possible to limit the nodes kept in memory?  For simplicity, say I only need the latest 3 nodes or 30%.  </p>
<p>I guess I have 2 questions. First, how can the above question be done, maintaining the linked list approach.  Second, is there a better approach not using a linked list.  I guess I could use a queue/deque or heapq with a limit, but it'll be kind of harder to get the data in relation to the other, right?</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next
    def __repr__(self):
        return 'Node({}, {})'.format(self.data, self.next)

class LinkedList:      
    def __init__(self, iterable=(), maxlen=3):
        self.head = None
        self.length = 0
        if maxlen &lt; 2:
            raise ValueError
        self.maxlen = maxlen
        for item in iterable:
            self.add(item)
    def add(self, data):
        self._check_and_remove_last()
        self.head = Node(data, self.head)
        self.length += 1
    def _check_and_remove_last(self):
        if self.length &lt; self.maxlen:
            return
        new_tail = self.head
        while new_tail.next.next:
            new_tail = new_tail.next
        # new_tail.next is now the last Node in the Linked List
        new_tail.next = None
        self.length -= 1
</code></pre>
<p>Removing the last element of the linked list means you either have to keep track of the second-to-last node in the linked list (not a very natural thing to do), or traverse the whole linked list every time. You can get around this by using a doubly linked list and doing something like <code>self.tail.prev.next = None</code>, or just using the built in <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a> which makes all this a breeze</p>
</div>
<span class="comment-copy">Your question is not clear: if you want to restrict the <i>number of nodes</i> in a list - of course you can do it, it's up to you how you want to implement it: if it's "full" you can either ignore a request to "add" a new node, drop the oldest one, etc. If you want to control what's in-memory and what not then AFAIK it's not doable in Python, but even if it would - it doesn't make any sense. If you want to work on lower-level - use lower level languages. Do you have a <i>real</i> reason to come up with such a requirement?</span>
<span class="comment-copy">did you benchmark your application, measured the memory in-use and found that <i>this</i> is a bottleneck?</span>
<span class="comment-copy">Linked List isn't a great data structure for this.  It's doable, but you're probably looking for a <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>deque</code></a>.</span>
<span class="comment-copy">how do i 'drop' the oldest ones from the linked list?  I didnt benchmark but i can see the memory being used go up to 4GB when running the program. Its for a programming game where I am trying to implement machine learning.  There's no need to keep the very old input data that were many many turns ago thats why I would like to limit the nodes being kept.  Its not necessary, it still works, just wondering if its possible.</span>
<span class="comment-copy">ok thanks for showing me a possible implementation.  But yea I guess linked list is not really the way to go for this scenario.  Thanks again</span>
