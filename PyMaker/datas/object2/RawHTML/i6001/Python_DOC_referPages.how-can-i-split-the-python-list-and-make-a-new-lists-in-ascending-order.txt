<div class="post-text" itemprop="text">
<p>In the Python
If there are </p>
<pre><code>[1,2,3,4,1,2,3,1,2,1] 
</code></pre>
<p>lists,
I want to split the list when the size is reduced like this</p>
<pre><code>[1,2,3,4], [1,2,3], [1,2], [1]
</code></pre>
<p>How do I code it?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use Pandas to do this in three lines:</p>
<pre><code>import pandas as pd
s = pd.Series([1,2,3,4,1,2,3,1,2,1])
s.groupby(s.diff().lt(0).cumsum()).apply(list).tolist()
</code></pre>
<p>Output:</p>
<pre><code>[[1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]
</code></pre>
<h3>Details how it works:</h3>
<p>First create a pandas series from the list, then use the <code>diff</code> method in pd.Series to get the difference from the previous value:</p>
<pre><code>s.diff()

0    NaN
1    1.0
2    1.0
3    1.0
4   -3.0
5    1.0
6    1.0
7   -2.0
8    1.0
9   -1.0
dtype: float64
</code></pre>
<p>The negative values are indicate the start of a new "sub" list.  So, we use <code>lt(0)</code> to mark those records where a new "sub" list should start.</p>
<pre><code>s.diff().lt(0)

0    False
1    False
2    False
3    False
4     True
5    False
6    False
7     True
8    False
9     True
dtype: bool
</code></pre>
<p>Next, we are going to use <code>cumsum</code> to create a grouping term. <code>cumsum</code> will only increment when True, so all falses that are next to each other get the same value, then True increments and next group of falses get that new value, until the next True.</p>
<pre><code>s.diff().lt(0).cumsum()

0    0
1    0
2    0
3    0
4    1
5    1
6    1
7    2
8    2
9    3
dtype: int32
</code></pre>
<p>Now, we can use <code>groupby</code> with <code>apply</code> to create a new series with these sublist as rows.  We are grouping on that newly create grouping term from above and apply the python <code>list</code> to those values in a that group, thus creating the "sub" list.</p>
<pre><code>s.groupby(s.diff().lt(0).cumsum()).apply(list)

0    [1, 2, 3, 4]
1       [1, 2, 3]
2          [1, 2]
3             [1]
dtype: object
</code></pre>
<p>Lastly, we apply the <code>tolist</code> method on the series to return the series as a list.</p>
<pre><code>s.groupby(s.diff().lt(0).cumsum()).apply(list).tolist()
</code></pre>
<p>Final Output:</p>
<pre><code>[[1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This might be the algorithm you are looking for - </p>
<pre><code>a=[1,2,3,4,1,2,3,1,2,1]
b=[]
c=[]
for i in range(len(a)-1):
    b.append(a[i])
    if a[i] &gt; a[i+1]:
        c.append(b)
        b=[]
print(c)
</code></pre>
<p>It outputs a list of sorted lists - </p>
<p><code>[[1, 2, 3, 4], [1, 2, 3], [1, 2]]</code></p>
<p>Let me know if that helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are looking to split the list when the next number is less than previous one than this might help:</p>
<pre><code>arr = [1,2,3,4,1,2,3,1,2,1]
b = []
start = 0
for i in range(len(arr)):
  if(arr[i] &lt; arr[i-1]):
    b.append(arr[start:i])
    start = i
b.append(arr[start:])
print(b)
</code></pre>
<p>Output: 
<code>[[1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]</code></p>
<p>Hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just for fun, I wanted to see if you could rework the code given in the docs as a sample implementation of <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> to suit your needs in a general way. The result is a generator whose elements are sub-generators representing your sub-lists. The determination when to split is done by a user-defined function of two variables that accepts each successive pair of neighboring elements and returns <code>True</code> when they are in different groups:</p>
<pre>
from collections import deque

class splitby:
    # [''.join(s) for s in splitby('AAAABBBCCDAABBB', operator.eq)] --&gt; ['AAAA', 'BBB', 'CC', 'D', 'AA', 'BBB']
    def __init__(self, iterable, splitter):
        self.splitfunc = splitter
        self.it = iter(iterable)
        self.segment = None
    def __iter__(self):
        return self
    def __next__(self):
        if self.segment:
            deque(self.segment, maxlen=0)
            if self.segment is None:
                raise StopIteration
        else:
            self.curvalue = next(self.it)
        self.segment = self._splitter()
        return self.segment
    def _splitter(self):
        split = False
        while not split:
            yield self.curvalue
            prev = self.curvalue
            try:
                self.curvalue = next(self.it)
            except StopIteration:
                self.segment = None
                return
            split = self.splitfunc(prev, self.curvalue)
</pre>
<p>The whole thing can be applied to your input list with a splitter function of <a href="https://docs.python.org/3/library/operator.html#operator.gt" rel="nofollow noreferrer"><code>operator.gt</code></a> or <a href="https://docs.python.org/3/reference/datamodel.html#object.__gt__" rel="nofollow noreferrer"><code>int.__gt__</code></a> if your list will only ever contain ints. A suitable wrapping in <code>list</code> will not only properly consume the elements, but will also make the output match your question:</p>
<pre>
from operator import gt

x = [1, 2, 3, 4, 1, 2, 3, 1, 2, 1]
[list(s) for s in splitby(x, gt)]
</pre>
<p>The result is:</p>
<pre><code>[[1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]
</code></pre>
<p>Here is an IDEOne link: <a href="https://ideone.com/UW483U" rel="nofollow noreferrer">https://ideone.com/UW483U</a></p>
<p><strong>TL;DR</strong></p>
<p>This is massive overkill for most situations, so don't do it this way. I was just having some fun, but the code here does technically solve your problem. If you put the class into your library somewhere, the actual usage is a one-liner.</p>
</div>
<span class="comment-copy">Can you edit/append to your question with what have you tried (however inefficient it seems to you) ?</span>
<span class="comment-copy">Take a look at this: <a href="http://www.garyrobinson.net/2008/04/splitting-a-pyt.html" rel="nofollow noreferrer">garyrobinson.net/2008/04/splitting-a-pyt.html</a></span>
<span class="comment-copy">@shash678 I started with i = 0 and tried to process it with a "while" statement.</span>
<span class="comment-copy">@Doda Good site thank you! I will refer you !!</span>
<span class="comment-copy">@Taek Hyung Kim please upvote other answer as well.</span>
<span class="comment-copy">I'd call that one line.  +1</span>
<span class="comment-copy">Oh ... There is a neat way to do this. Let me apply! Thank you!!</span>
<span class="comment-copy">WOW, It is amazing to think of using b! Thank you very much.</span>
