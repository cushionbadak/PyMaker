<div class="post-text" itemprop="text">
<p>I have a dictionary like this:</p>
<pre><code>{0: [3406, 3076, 3470], 1: [3792, 3076, 3470], 2: [3470, 3076, 3406], 3: [3792, 3470, 3406], 4: [3470, 3292, 3406], 6: [3792, 3406, 3470]}
</code></pre>
<p>As you can appreciate 0 and 2 are not equal but share the same elements, I would like to remove these elements in the dictionary that are the same. In this case it would be reduce to:</p>
<pre><code>{0: [3406, 3076, 3470], 1: [3792, 3076, 3470], 2: [3792, 3470, 3406], 3: [3470, 3292, 3406]}
</code></pre>
<p>Edit:</p>
<p>aux = 0
definitivo={}</p>
<p>for key1, value1 in result.items():</p>
<pre><code>for key2, value2 in result.items():

    if key1!=key2:
        if len(list(set(value1).intersection(value2)))==3:
            definitivo[aux]=value1
            aux = aux+1
</code></pre>
<p>print(definitivo)</p>
<p>I attempted to just get the ones which intersectation is 3 to, then, eliminate them. But it's not working.</p>
</div>
<div class="post-text" itemprop="text">
<p>Change the value of dict to tuple, sort it and store it in another lookup dict. Check for presence of every new value in the lookup and then filter out already present values.</p>
<pre><code>data = {0: [3406, 3076, 3470], 1: [3792, 3076, 3470], 2: [3470, 3076, 3406], 3: [3792, 3470, 3406], 4: [3470, 3292, 3406], 6: [3792, 3406, 3470]}

lookup = dict()
i = 0
filter_data = dict()

for k in data:
    value = tuple(sorted(data[k]))
    if value not in lookup:
        lookup[value] = 1
        filter_data[i] = data[k]
        i = i + 1

print (filter_data)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could convert every list to a <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow noreferrer"><code>frozenset</code></a>. This way, you can use the set as a dict key, and any set that appears twice will be overwritten:</p>
<pre><code>&gt;&gt;&gt; data = {0: [3406, 3076, 3470], 1: [3792, 3076, 3470], 2: [3470, 3076, 3406], 3: [3792, 3470, 3406], 4: [3470, 3292, 3406], 6: [3792, 3406, 3470]}
&gt;&gt;&gt; uniq = {frozenset(l):k for k,l in data.items()}
{frozenset({3470, 3076, 3406}): 2, frozenset({3792, 3076, 3470}): 1, frozenset({3792, 3406, 3470}): 6, frozenset({3406, 3292, 3470}): 4}
</code></pre>
<p>You can invert the pairs and convert the sets back to a list:</p>
<pre><code>&gt;&gt;&gt; {i:list(s) for s,i in uniq.items()}
{2: [3470, 3076, 3406], 1: [3792, 3076, 3470], 6: [3792, 3406, 3470], 4: [3406, 3292, 3470]}
</code></pre>
<p>Note that the key order cannot be kept since the original data is a dict, which is unordered in Python.</p>
</div>
<div class="post-text" itemprop="text">
<p>Another simple method for recognizing equal unique values can be as follows :</p>
<ol>
<li><strong>Sort</strong> the array inside the key</li>
<li><strong>Delete</strong> if equal</li>
</ol>
<p><em>Note</em> : This is an <strong>algorithm</strong></p>
<blockquote>
<pre><code>for key1,value1 in dict:
    for key2,value2 in dict:
        if key1 != key2 and value1.sort()==value2.sort():
            del dict['key2']
</code></pre>
</blockquote>
</div>
<span class="comment-copy">Have you attempted anything thus far? If so, please edit your question and provide your attempts.</span>
<span class="comment-copy"><code>1</code> and <code>0</code> don't share the same elements.</span>
<span class="comment-copy">op, if you don't need order in the elements of your lists (you say [3792, 3076, 3470] == [3406, 3076, 3470]) then replace the lists with sets: <a href="https://docs.python.org/3.5/" rel="nofollow noreferrer">docs.python.org/3.5</a>  if you use sets, this will be easier</span>
<span class="comment-copy"><code>0</code> and <code>1</code> are different, maybe you meant <code>0</code> and <code>2</code>? Do the dictionary keys matter at all? You seem to just be using them for numbering. If multiple lists are equivalent which one should be kept? It seems like what you want is a set of frozensets, not a dict of lists.</span>
<span class="comment-copy">Yes 0 and 2, sorry, I corrected it. I will check the frozensets, I'm prettu new to python.</span>
<span class="comment-copy">Thank you!! I didn't think about sorting the tuples. Great!</span>
<span class="comment-copy">You use <code>lookup</code> as a <code>set</code>, so you probably should use a <code>set</code> instead of a dict.</span>
