<div class="post-text" itemprop="text">
<p>My code uses <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer"><code>yield from</code></a> in <code>python3</code> in <strong><em>recursive calls</em></strong> and it works perfectly fine. The problem right now is that this was <em>introduced from</em> <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP-380</a> in <a href="https://docs.python.org/3/whatsnew/3.3.html" rel="nofollow noreferrer"><code>python 3.3</code></a> and I need it to work in <a href="https://www.python.org/download/releases/2.7/" rel="nofollow noreferrer"><code>python 2.7</code></a>. I read up on a few articles and none of them were detailed enough or simple enough.</p>
<p>Few referred articles :</p>
<ul>
<li><p><a href="https://stackoverflow.com/questions/17581332/converting-yield-from-statement-to-python-2-7-code">Converting “yield from” statement to Python 2.7 code</a></p></li>
<li><p><a href="https://www.reddit.com/r/learnpython/comments/4rc15s/yield_from_and_python_27/" rel="nofollow noreferrer"><code>yield from</code> and Python 2.7</a></p></li>
</ul>
<p>and few others.</p>
<p>I have recreated a small Sample code <em>(which takes in a multi-level list and returns a flattened list)</em> that is <strong><em>very minimalistic</em></strong> compared to my requirements.</p>
<pre><code>#python 3
def foo(obj):
    for ele in obj:
        if isinstance(ele, list):
            yield from foo(ele)
        else:
            yield ele
</code></pre>
<p>#driver values :</p>
<pre><code>&gt;&gt;&gt; l = [1, [2, 3, [4,5]]]
&gt;&gt;&gt; list(foo(l))
=&gt;  [1, 2, 3, 4, 5]
</code></pre>
<p>The same converted does not work in <code>python 2.7</code> due to the non-availability of <code>yield from</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>You <strong>still need to loop</strong>. It doesn't matter that you have recursion here. </p>
<p>You need to loop over the generator produced by the recursive call and yield the results:</p>
<pre><code>def foo(obj):
    for ele in obj:
        if isinstance(ele, list):
            for res in foo(ele):
                yield res
        else:
            yield ele
</code></pre>
<p>Your recursive call produces a generator, and you need to pass the results of the generator onwards. You do so by looping over the generator and yielding the individual values.</p>
<p><strong>There are no better options</strong>, other than upgrading to Python 3.</p>
<p><code>yield from</code> essentially passes on the responsibility to loop over to the caller, and passes back any <code>generator.send()</code> and <code>generator.throw()</code> calls to the delegated generator. You don't have any need to pass on <code>.send()</code> or <code>.throw()</code>, so what remains is taking responsibility to do the looping yourself.</p>
<p>Demo:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version_info
sys.version_info(major=2, minor=7, micro=14, releaselevel='final', serial=0)
&gt;&gt;&gt; def foo(obj):
...     for ele in obj:
...         if isinstance(ele, list):
...             for res in foo(ele):
...                 yield res
...         else:
...             yield ele
...
&gt;&gt;&gt; l = [1, [2, 3, [4,5]]]
&gt;&gt;&gt; list(foo(l))
[1, 2, 3, 4, 5]
</code></pre>
<p><code>yield from</code> was introduced in <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP 380 -- <em>Syntax for Delegating to a Subgenerator</em></a> (not PEP 342), specifically because a loop over the sub-generator would not delegate <code>generator.throw()</code> and <code>generator.send()</code> information.</p>
<p>The PEP explicitly states:</p>
<blockquote>
<p>If yielding of values is the only concern, this can be performed without much difficulty using a loop such as</p>
<pre><code>for v in g:
    yield v
</code></pre>
</blockquote>
<p>The <a href="https://www.python.org/dev/peps/pep-0380/#formal-semantics" rel="nofollow noreferrer"><em>Formal Semantics</em></a> has a Python implementation equivalent that may look intimidating at first, but you can still pick out that it <em>loops</em> (with <code>while 1:</code>, looping ends when there is an exception or <code>StopIteration</code> is handled, new values are retrieved with <code>next()</code> or <code>generator.send(..)</code>), and yields the results (with <code>yield _y</code>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Why do you say "my code cannot work with loops and needs to be recursive"? You can easily use a loop in a recursive generator:</p>
<pre><code>def foo(obj):
    for ele in obj:
        if isinstance(ele, list):
            #yield from foo(ele)
            for t in foo(ele):
                yield t 
        else:
            yield ele

l = [1, [2, 3, [4, 5]]]
print list(foo(l))
</code></pre>
<p><strong>output</strong></p>
<pre><code>[1, 2, 3, 4, 5]
</code></pre>
</div>
<span class="comment-copy">Why does it have to be recursive? Internally <code>yield from</code> is also just a loop.</span>
<span class="comment-copy">Yet <code>yield from</code> is, at it's heart, a loop with delegation. You don't need the delegation, but you <i>still need to loop</i>.</span>
<span class="comment-copy">Ok. Stupid me. It works. The answers there were bit confusing and I couldn't get it. Let me change the question.</span>
<span class="comment-copy">Note that <code>yield from</code> was not introduced in PEP 342. <a href="https://www.python.org/dev/peps/pep-0380/" rel="nofollow noreferrer">PEP 380</a> handles <code>yield from</code>.</span>
<span class="comment-copy">@MartijnPieters : noted</span>
<span class="comment-copy">Yup, this works.</span>
<span class="comment-copy">Nice answer. As usual. ;)</span>
<span class="comment-copy">Yup, this works.</span>
