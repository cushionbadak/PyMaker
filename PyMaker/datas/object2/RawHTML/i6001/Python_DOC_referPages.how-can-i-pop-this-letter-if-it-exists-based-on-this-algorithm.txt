<div class="post-text" itemprop="text">
<p>I'm trying to pop any letters given by the user, for example if they give you a keyword "ROSES" then these letters should be popped out of the list.</p>
<p>Note: I have a lot more explanation after the <strong>SOURCE CODE</strong> </p>
<p><strong>SOURCE CODE</strong></p>
<pre><code>  alphabet = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"]
        encrypted_message = []
        key_word = str(input("Please enter a word:"))
        key_word = list(key_word)
        #print(key_word)

        check_for_dup = 0


        for letter in key_word:
            for character in alphabet:
                if letter in character:
                    check_for_dup +=1
                    alphabet.pop(check_for_dup)

        print(alphabet) 
        print(encrypted_message)
</code></pre>
<p><strong>SAMPLE INPUT</strong> </p>
<p>Let's say keyword is "Roses"</p>
<p>this what it gives me a list of the following <strong>['A', 'C', 'E', 'G', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']</strong></p>
<p>But that's wrong It should of just removed the characters that existed in the keyword given by the user, like the word "Roses" each letter should of been removed and not in the list being popped. as you can see in the list the letters "B","D","F","H",etc were gone. What I'm trying to do is pop the index of the alphabet letters that the keyword exists.</p>
<p>this is what should of happened.</p>
<p><strong>["A","B","C","D","F","G","H","I","J","K","L","M","N","P","Q","T","U","V","W","X","Y","Z"]</strong></p>
<p>The letters of the keyword "ROSES" were deleted of the list</p>
</div>
<div class="post-text" itemprop="text">
<p>There is some shortcomings in your code here is an implementation that works:</p>
<pre><code>alphabet = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"]
key_word = str(input("Please enter a word:"))

for letter in key_word.upper():
    if letter in alphabet:
        alphabet.remove(letter)

print(alphabet) 
</code></pre>
<p><strong>Explanations</strong></p>
<ol>
<li>You can iterate on a string, no need to cast it as a list</li>
<li>Use remove since you can use the <code>str</code> type directly</li>
<li>You need to <a href="https://www.tutorialspoint.com/python/string_upper.htm" rel="nofollow noreferrer"><code>.upper()</code></a> the input because you want to remove <code>A</code> if the user input <code>a</code></li>
</ol>
<p>Note that I did not handle <code>encrypted_message</code> since it is unused at the moment.</p>
<p>Also, as some comments says you could use a <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">set</a> instead of a list since lookups are faster for sets.</p>
<pre><code>alphabet = {"A","B","C","D",...}
</code></pre>
<p><strong>EDIT</strong></p>
<pre><code>alphabet = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"]
key_word = str(input("Please enter a word:"))
encrypted_message = []
for letter in key_word.upper():
    if letter in alphabet:
        alphabet.remove(letter)
        encrypted_message.append(letter)

encrypted_message.extend(alphabet)
</code></pre>
<p>This is a new implementation with the handling of your <code>encrypted_message</code>. This will keep the order of the alphabet after the input of the user. Also, if you're wondering why there's no duplicate, you will be appending only if <code>letter is in alphabet</code> which means the second time it won't be in <code>alphabet</code> and therefore not added to your <code>encrypted_message</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>you can directly check with input key<br/>
iterate all the letters in data, and check whether or not the letter in the input_key, if yes discard it</p>
<pre><code>  data = ['A', 'C', 'E', 'G', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
  input_key = 'Roses'
  output = [l for l in data if l not in input_key.upper()]
  print output

  ['A', 'C', 'G', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do something like this....</p>
<pre><code>import string
alphabet = list(string.ascii_lowercase)

user_word = 'Roses'
user_word = user_word.lower()

letters_to_remove = set(list(user_word)) # Create a unique set of characters to remove

for letter in letters_to_remove:
  alphabet.remove(letter)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>alphabet = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"]

# this can be accepted as a user input as well
userinput = "ROSES"

# creates a list with unique values in uppercase
l = set(list(userinput.upper()))

# iterates over items in l to remove 
# the corresponding items in alphabet
for x in l:
    alphabet.remove(x)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>' '.join(alphabet).translate({ord(c): "" for c in keyword}).split()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>import string
key_word = set(input("Please enter a word:").lower())
print(sorted(set(string.ascii_lowercase) - key_word))
</code></pre>
<p>Explanation:</p>
<p>When checking for (in)existence, it's better to use <code>set</code>. <a href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="nofollow noreferrer">https://docs.python.org/3/tutorial/datastructures.html#sets</a></p>
<p>Instead of iterating over it N times (N = number of input characters), you hash the character N times and check if there's already something at the result hash or not.
If you check the speed, try with <code>"WXYZZZYW"</code> and you'll see that it'll be a lot slower than if it were <code>"ABCDDDCA"</code> with the <code>list</code> way. With <code>set</code>, it will be always the same time.</p>
<p>The rest is pretty trivial. Casting to lowercase (or uppercase), to make sure it hits a match, case insensitive. </p>
<p>And then, we end by doing a <code>set</code> difference (<code>-</code>). It's all the items that are in the first set but not in the second one.</p>
</div>
<span class="comment-copy">Thank you so much your answer makes so much sense! and also once I have popped the letters how can I join the modified list to the keyword given by the user? like "R","O","S","E","A,"B".............. Notice the double "s" in roses no duplicates.</span>
<span class="comment-copy">I'd like to add that <code>["A", "B", ...]</code> can perhaps be concisely rewritten using <a href="https://docs.python.org/3/library/string.html#string.ascii_uppercase" rel="nofollow noreferrer"><code>string.ascii_uppercase</code></a>.</span>
<span class="comment-copy">is the order important for you ? Would   "R","O","S","E","Y,"M"... be acceptable. Or you would like to have "R","O","S","E","A,"B" where the rest of the letters after ROSE are in order.</span>
<span class="comment-copy">@Davidmark let me know if order is important for you and I will edit my answer.</span>
<span class="comment-copy">@Davidmark I edited my answer, since you asked for ordeting before this is how I implemented it.</span>
<span class="comment-copy">is it possible I can see a solution where I could understand what's happening please? other than list comprehensions?</span>
<span class="comment-copy">@Davidmark added</span>
<span class="comment-copy">Is there a reason you specifically do not want to use a correct solution (list comprehensions)? This is a very pythonic way of solving the problem.</span>
<span class="comment-copy">For long inputs, it's recommended to use a set as existence checking takes O(1).</span>
<span class="comment-copy">@Reti43 agree. set should be better</span>
