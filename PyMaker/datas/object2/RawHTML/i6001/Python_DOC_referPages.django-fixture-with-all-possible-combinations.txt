<div class="post-text" itemprop="text">
<p>I am trying to test a statistics function, which counts what type of objects I have in my database. For this I would like to create at least one instance of each possible combination of model fields. Random test data requires a lot of test objects to make sure all possible combinations are met.</p>
<p>Here is a shortened example from one of my models:</p>
<pre><code>class Member(models.Model)
    is_active = models.BooleanField()
    name = models.CharField()
    balance = models.IntegerField()
    division = models.ForeignKey(Division, on_delete=models.CASCADE)

Class Division(models.Model)
    name = models.CharField()
</code></pre>
<p>This is how I'm doing it right now using django_dynamic_fixture:</p>
<pre><code>from django.test import TestCase
from django_dynamic_fixture import G
from members.models import Member

class StatisticsTestCase(TestCase):
    def setUp(self):
        for is_active in [True, False]:
            for balance in [-100, 0, 100]:
                for division in Division.objects.all()
                    G(Member, is_active=is_active, balance=balance, division=division)
</code></pre>
<p>But this looks pretty bad and is hard to read. Is there a simpler way with better to read code to create all possible combinations of properties of an object?</p>
<p>I'm open to different test data generators as long as they work nicely with Python 3 and Django.</p>
</div>
<div class="post-text" itemprop="text">
<pre class="lang-python prettyprint-override"><code>import itertools

combinations = list(itertools.product(*[[True, False], [-100, 0, 100]]))
for division in Division.objects.all():
    for is_active, balance in combinations:
        G(Member, is_active=is_active, balance=balance, division=division)
</code></pre>
<hr/>
<p>Update:
</p>
<pre><code>import itertools

combinations = list(itertools.product([True, False], [-100, 0, 100], Division.objects.all()))
for is_active, balance, division in combinations:
    G(Member, is_active=is_active, balance=balance, division=division)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Sara's answer is a good step forward, but I am still not satisfied by the code readability, so I am answering my own question.</p>
<pre><code>variants = {
    'is_active': [True, False],
    'balance': [-100, 0, 100],
    'division': list(Division.objects.all())
}

names = sorted(variants)
products = [dict(zip(names, prod)) for prod in it.product(*(variants[name] for name in names))]

for combination in products:
    G(Member, **combination)
</code></pre>
<p>Now anyone wanting to change this test can easily see which property is tested with which values. Thanks go to <a href="https://stackoverflow.com/questions/41870807/how-do-you-turn-a-dict-of-lists-into-a-list-of-dicts-with-all-combinations">this</a> q&amp;a for the dict solution.</p>
</div>
<span class="comment-copy">Here - <code>product(*[[True, False], [-100, 0, 100]])</code> - why are you passing the arguments in a list and then unpacking the list? Just <code>product([True, False], [-100, 0, 100])</code> works fine. No need to convert the generator to a <code>list</code>, either. Generators are much more efficient than plain lists.</span>
<span class="comment-copy">Also, you can further improve the answer by putting the <code>division</code> objects in <code>combinations</code> as well.</span>
<span class="comment-copy">Yes, good idea, and I will write an update, as for your first question, I'd say either way works since the function doesn't specify the input length: <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools.product</a></span>
<span class="comment-copy">Hm, I think this is better to read, but still not satisfying. Now I'd build a long list of values with no relation to their meaning, but their order. That's fine for 3 properties, but if you have 10 properties it would be better to have a dict where the values are connected to a label.</span>
<span class="comment-copy">Also I was hoping to find this as a ready-made feature in some test data/fixture generator ;)</span>
<span class="comment-copy">There's a <code>SyntaxError</code> in your code at <code>[*Division.objects.all()]</code>. You can't unpack a list within a list. You're right. I've a very narrow view.</span>
<span class="comment-copy">@xyres <code>Division.objects.all()</code> returns a <code>django.db.models.query.QuerySet</code> which can be unpacked like this. But since I'm the person talking about readability: <code>list(Division.objects.all()</code> is better to understand. Thanks for pointing it out.</span>
<span class="comment-copy">No, <code>[*Division.objects.all()]</code> is a <code>SyntaxError</code>. It has got nothing to with Django <code>QuerySet</code>, because <code>SyntaxError</code> means that it is not a valid Python syntax. You can't use <code>*</code> to unpack something anywhere other than while passing arguments to a function. You can try it in a Python shell and see what I mean.</span>
<span class="comment-copy">@xyres Could it be you did not realize my question is about Python 3? Because it is and in Python 3 <code>[*[1, 2]]</code> is not a syntax error.</span>
<span class="comment-copy">Yeah, you're right.</span>
