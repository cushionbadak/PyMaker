<div class="post-text" itemprop="text">
<p>I would like to construct list <code>x</code> from two lists <code>y</code> and <code>z</code>. I want all elements from <code>y</code> be placed where <code>ypos</code> elements point. For example:</p>
<pre><code>y = [11, 13, 15]
z = [12, 14]
ypos = [1, 3, 5]
</code></pre>
<p>So, <code>x</code> must be <code>[11, 12, 13, 14, 15]</code></p>
<p>Another example:</p>
<pre><code>y = [77]
z = [35, 58, 74]
ypos = [3]
</code></pre>
<p>So, <code>x</code> must be <code>[35, 58, 77, 74]</code></p>
<p>I've written function that does what I want but it looks ugly:</p>
<pre><code>def func(y, z, ypos):
    x = [0] * (len(y) + len(z))
    zpos = list(range(len(y) + len(z)))
    for i, j in zip(y, ypos):
        x[j-1] = i
        zpos.remove(j-1)
    for i, j in zip(z, zpos):
        x[j] = i
    return x
</code></pre>
<p>How to write it in pythonic way?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the lists are very long, repeatedly calling <code>insert</code> <a href="https://stackoverflow.com/a/27073672/1639625">might not be very efficient</a>. Alternatively, you could create two <code>iterators</code> from the lists and construct a list by getting the <code>next</code> element from either of the iterators depending on whether the current index is in <code>ypos</code> (or a <code>set</code> thereof):</p>
<pre><code>&gt;&gt;&gt; ity = iter(y)
&gt;&gt;&gt; itz = iter(z)
&gt;&gt;&gt; syp = set(ypos)
&gt;&gt;&gt; [next(ity if i+1 in syp else itz) for i in range(len(y)+len(z))]
[11, 12, 13, 14, 15]
</code></pre>
<p>Note: this will insert the elements from <code>y</code> in the order they appear in <code>y</code> itself, i.e. the first element of <code>y</code> is inserted at the <em>lowest</em> index in <code>ypos</code>, not necessarily at the <em>first</em> index in <code>ypos</code>. If the elements of <code>y</code> should be inserted at the index of the <em>corresponding element</em> of <code>ypos</code>, then either <code>ypos</code> has to be in ascending order (i.e. the first index of <code>ypos</code> is also the lowest), or the iterator of <code>y</code> has to be sorted by the same order as the indices in <code>ypos</code> (afterwards, <code>ypos</code> itself does not have to be sorted, as we are turning it into a <code>set</code> anyway).</p>
<pre><code>&gt;&gt;&gt; ypos = [5,3,1]   # y and z being same as above
&gt;&gt;&gt; ity = iter(e for i, e in sorted(zip(ypos, y)))
&gt;&gt;&gt; [next(ity if i+1 in syp else itz) for i in range(len(y)+len(z))]
[15, 12, 13, 14, 11]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You should use <code>list.insert</code>, this is what it was made for!</p>
<pre><code>def func(y, z, ypos):
    x = z[:]
    for pos, val in zip(ypos, y):
        x.insert(pos-1, val)
    return x
</code></pre>
<p>and a test:</p>
<pre><code>&gt;&gt;&gt; func([11, 13, 15], [12, 14], [1,3,5])
[11, 12, 13, 14, 15]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>With large lists, it might be a good idea to work with <a href="http://www.numpy.org/" rel="noreferrer"><code>numpy</code></a>.</p>
<h1>Algorithm</h1>
<ul>
<li>create a new array as large as <code>y + z</code></li>
<li>calculate coordinates for <code>z</code> values</li>
<li>assign <code>y</code> values to <code>x</code> at <code>ypos</code></li>
<li>assign <code>z</code> values to <code>x</code> at <code>zpos</code></li>
</ul>
<p>The complexity should be <code>O(n)</code>, with <code>n</code> being the total number of values.</p>
<pre><code>import numpy as np

def distribute_values(y_list, z_list, y_pos):
    y = np.array(y_list)
    z = np.array(z_list)
    n = y.size + z.size
    x = np.empty(n, np.int)
    y_indices = np.array(y_pos) - 1
    z_indices = np.setdiff1d(np.arange(n), y_indices, assume_unique=True)
    x[y_indices] = y
    x[z_indices] = z
    return x

print(distribute_values([11, 13, 15], [12, 14], [1, 3, 5]))
# [11 12 13 14 15]
print(distribute_values([77], [35, 58, 74], [3]))
# [35 58 77 74]
</code></pre>
<p>As a bonus, it also works fine when <code>ypos</code> isn't sorted:</p>
<pre><code>print(distribute_values([15, 13, 11], [12, 14], [5, 3, 1]))
# [11 12 13 14 15]
print(distribute_values([15, 11, 13], [12, 14], [5, 1, 3]))
# [11 12 13 14 15]
</code></pre>
<h1>Performance</h1>
<p>With <code>n</code> set to 1 million, this approach is a bit faster than <a href="https://stackoverflow.com/users/1639625/tobias-k">@tobias_k's answer</a> and 500 times faster than <a href="https://stackoverflow.com/a/47443369/6419007">@Joe_Iddon's answer</a>.</p>
<p>The lists were created this way:</p>
<pre><code>from random import random, randint
N = 1000000
ypos = [i+1 for i in range(N) if random()&lt;0.4]
y = [randint(0, 10000) for _ in ypos]
z = [randint(0, 1000) for _ in range(N - len(y))
</code></pre>
<p>Here are the results with <a href="https://docs.python.org/3/library/timeit.html" rel="noreferrer"><code>%timeit</code></a> and IPython:</p>
<pre><code>%timeit eric(y, z, ypos)
131 ms ± 1.54 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

%timeit tobias(y, z, ypos)
224 ms ± 977 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit joe(y,z, ypos)
54 s ± 1.48 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Assuming that the <code>ypos</code> indices are sorted, here is another solution using iterators, though this one also supports <code>ypos</code> of unknown or infinite length:</p>
<pre><code>import itertools

def func(y, ypos, z):
    y = iter(y)
    ypos = iter(ypos)
    z = iter(z)
    next_ypos = next(ypos, -1)
    for i in itertools.count(start=1):
        if i == next_ypos:
            yield next(y)
            next_ypos = next(ypos, -1)
        else:
            yield next(z)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want the elements in <code>ypos</code> to be placed at the <code>x</code> index where each element's index in <code>ypos</code> should correspond with the same <code>y</code> index's element:</p>
<ol>
<li>Initialize <code>x</code> to the required size using all null values.</li>
<li>Iterate through the zipped <code>y</code> and <code>ypos</code> elements to fill in each corresponding <code>y</code> element into <code>x</code>.</li>
<li>Iterate through <code>x</code> and replace each remaining null value with <code>z</code> values where each replacement will choose from <code>z</code> in increasing
order.</li>
</ol>
<p></p>
<pre><code>y = [11, 13, 15]
z = [12, 14]
ypos = [1, 5, 3]

x = [None] * (len(y) + len(z))
for x_ypos, y_elem in zip(ypos, y):
    x[x_ypos - 1] = y_elem

z_iter = iter(z)
x = [next(z_iter) if i is None else i for i in x]
# x -&gt; [11, 12, 15, 14, 13]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h1>Pythonic way</h1>
<pre><code>y = [11, 13, 15]
z = [12, 14]
ypos = [1, 3, 5]

x = z[:]

for c, n in enumerate(ypos):
    x.insert(n - 1, y[c])

print(x)
</code></pre>
<p>output</p>
<blockquote>
<p>[11, 12, 13, 14, 15]</p>
</blockquote>
<h1>In a function</h1>
<pre><code>def func(y, ypos, z):
    x = z[:]
    for c,n in enumerate(ypos):
        x.insert(n-1,y[c])
    return x

print(func([11,13,15],[1,2,3],[12,14]))
</code></pre>
<p>outoput</p>
<blockquote>
<p>[11, 12, 13, 14, 15]</p>
</blockquote>
<h1>Using zip</h1>
<pre><code>y, z, ypos = [11, 13, 15], [12, 14], [1, 3, 5]

for i, c in zip(ypos, y):
    z.insert(i - 1, c)

print(z)
</code></pre>
<p>[out:] </p>
<pre><code>&gt; [11, 12, 13, 14, 15]
</code></pre>
</div>
<span class="comment-copy">I guess you need to post this question to <a href="https://codereview.stackexchange.com/">codereview.stackexchange.com</a>.</span>
<span class="comment-copy">@TigranSaluev Changing the name would make it ok, so not really I think.</span>
<span class="comment-copy">@martineau, sorry, fixed</span>
<span class="comment-copy">@scharette He has working code and is looking to improve it's style to closer fit a language. That isn't within the scope of SO.</span>
<span class="comment-copy">Excellent approach. It mimics the way you'd distribute cards from two decks.</span>
<span class="comment-copy">One more point: this code only works if ypos is sorted.</span>
<span class="comment-copy">It's not clear at first, but you basically sort <code>ypos</code> again since you iterate with an increasing <code>i</code>. You can try with <code>f([15, 13, 11], [12, 14], [5, 3, 1])</code>. It returns <code>[15, 12, 13, 14, 11]</code>, as if <code>ypos</code> was <code>[1, 3, 5]</code>.</span>
<span class="comment-copy">@EricDuminil Ah, now I get what you mean. But <code>ypos</code> does not have to be sorted, instead my approach ignores any order of <code>ypos</code> and just adds the elements from <code>y</code> in the order they have, not at the "corresponding" position in <code>ypos</code>. Interesting point.</span>
<span class="comment-copy">@tobias_k: Indeed. <code>ypos</code> can be written in any order you want but <code>y</code> should be written in the same order as a sorted <code>ypos</code>. :)</span>
<span class="comment-copy">since the question was about constructing a new list, you should copy <code>z</code> so it is not modifying the original list.</span>
<span class="comment-copy">Good point, I will update the answer</span>
<span class="comment-copy">This assumes the indexes will be in order</span>
<span class="comment-copy">@C.Feenstra The question assumes they are. It is impossible to know how they should be ordered (i.e. do we order just the <code>indexes</code>, or do we <code>zip</code> them, then order) so I decided this wasn't necessary. However if the OP explicitly states their position on this aspect then by all means, I will update the answer <b>:)</b></span>
<span class="comment-copy">Yes, the order in <code>x</code> must hold like in your answer</span>
<span class="comment-copy">Nice timing analysis, but I'd say mine only takes 1.5 times longer (in fact, I got 135 and 179 ms respectively). :-P Surprised Joe's isn't slower, though, I'd expect it to be quadratic.</span>
<span class="comment-copy">@tobias_k: Yes, it depends on the system and underlying libraries. Factor 1.5 or 2 isn't much with such a large list. I was surprised by Joe 's answer with smaller lists. With <code>n=100</code>, it was actually a bit faster than yours for example.</span>
