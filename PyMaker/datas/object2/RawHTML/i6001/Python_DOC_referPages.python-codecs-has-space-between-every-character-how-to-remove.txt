<div class="post-text" itemprop="text">
<p>I am trying to write a list of tuples to a CSV file. I want to use codecs because of UTF-8 issues in csv module. I am using python 2.7.13 </p>
<p>The code write fine but when i open the file, i see a space between every character even when i didnt put any space. How do i remove the space? using <code>replace</code> or <code>strip</code> doesnt work. </p>
<pre><code>import codecs

tup_list = [('a','b','c',123,456),('d','e','f',789,101)]
</code></pre>
<p>write each row to the codecs file</p>
<pre><code>f = codecs.open("test2.csv", "w", "utf-8")
for row in tup_list:
    print &gt;&gt; f,row[0],",",row[1],",",row[2],",",row[3],",",row[4]
</code></pre>
<p>open the file</p>
<pre><code>with open('test2.csv','rb') as f:
    for row in f:
    print row
</code></pre>
<p>output </p>
<pre><code>a , b , c , 123 , 456

d , e , f , 789 , 101
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Either:</p>
<pre><code>f.write('{}\n'.format(','.join(row)))
</code></pre>
<p>Or, my personal favorite:</p>
<pre><code>import csv

with open('test2.csv', 'wb') as f:
   writer = csv.writer(f)
   for row in tup_list:
      writer.writerow(row)
</code></pre>
</div>
<span class="comment-copy">That's an issue with <code>print</code>, not <code>codecs</code>.</span>
<span class="comment-copy">It's a <code>print</code> feature not <code>codecs</code> issue.</span>
<span class="comment-copy">One: Never use <code>codecs.open</code>; it's buggy in numerous subtle ways, and you want <code>io.open</code> (equivalent to Python 3's built-in <code>open</code>) on Python 2.6 and higher. Two: You need to use the <code>csv</code> module (or on Python 2, the third party <code>unicodecsv</code> module) to parse CSV. If you do otherwise, you'll get things wrong, either by failing to split at all in this case, or by getting the complex rules for quoting wrong when you figure out splitting the naive way.</span>
<span class="comment-copy">Side-note: By using Py3's <code>print</code> function, you could avoid those extra spaces and simplify the <code>print</code>. Add <code>from __future__ import print_function</code> to the <i>very</i> top of your file, and you can use <a href="https://docs.python.org/2/library/functions.html#print" rel="nofollow noreferrer">the <code>print</code> function</a> with a <code>sep</code> argument to simplify things, e.g. <code>print &gt;&gt; f,row[0],",",row[1],",",row[2],",",row[3],",",row[4]</code> becomes the much simpler <code>print(*row, sep=',')</code> (using <a href="https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists" rel="nofollow noreferrer"><code>*</code>-unpacking</a> to avoid explicitly writing <code>row</code> and an index over and over).</span>
<span class="comment-copy">This doesn't change the fact that you should be using <a href="https://docs.python.org/2/library/csv.html" rel="nofollow noreferrer">the <code>csv</code> module</a>, but I thought I'd mention that Py3's (and Py2's after <code>__future__</code> import) <code>print</code> function is much more powerful/flexible (and much less weird, involving no special case syntax features) than the old Py2 <code>print</code> statement.</span>
<span class="comment-copy">Heck, don't even need the explicit loop; there's <a href="https://docs.python.org/2/library/csv.html#csv.csvwriter.writerows" rel="nofollow noreferrer">a <code>writerows</code> method</a> too, so you could remove the loop in favor of <code>writer.writerows(tup_list)</code>, or even one-line the whole body of the <code>with</code> if you're only writing the one sequence with <code>csv.writer(f).writerows(tup_list)</code>.</span>
