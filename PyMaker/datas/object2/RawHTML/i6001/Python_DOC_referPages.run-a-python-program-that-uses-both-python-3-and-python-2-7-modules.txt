<div class="post-text" itemprop="text">
<p>I'm looking for a way to combine python 3.x and python 2.x modules in same program.</p>
<p>Currently, we'd like to load them using YAPSI, but I'm guessing that's a lost cause.</p>
<p>** Obviously, its module that is dependent on lib's that currently aren't converted to python 3 and will take much time to do.</p>
</div>
<div class="post-text" itemprop="text">
<p>from @Frrank answer; i highly recommend you to convert that module source codes to python 3x by yourself! or with many tools that you can find by searching in google ...</p>
<p><strong>but generally I think there is no pythonic way for this issue. but Yes You Can; with tricky ways! ( There are three tricky ways ) :</strong></p>
<p><strong>First :</strong></p>
<blockquote>
<ol>
<li><p>Download both python 2x and 3x portable interpreters</p></li>
<li><p>Copy and paste them into same folder</p></li>
<li><p>Write each part of your program Separately with their original
  interpreters ( write your program as functional or object orinted )</p></li>
<li><p>Make a main program with python3x and call those two parts with
  subprocess, exec or other methods</p></li>
<li><p>Now you can compile this folder to a exe file or make a setup (
  package exe file ) and done!</p></li>
</ol>
</blockquote>
<p><strong>Second :</strong> </p>
<blockquote>
<p>If you are friendly with <a href="http://cython.org" rel="nofollow noreferrer">cython</a> you can convert each part of your
  program to C/C++, then you can merge or re_convert them to python
  codes!</p>
</blockquote>
<p><strong>Third :</strong></p>
<blockquote>
<p>If you are friendly with <a href="http://www.jython.org/" rel="nofollow noreferrer">jython</a> you can convert each part of your
  program to java ( jar file ), then you can merge or re_convert them to python
  codes!</p>
</blockquote>
<p>Good Luck ...</p>
</div>
<div class="post-text" itemprop="text">
<p>You can but it's a lot of work. The problems mostly are syntax errors in print-statements. 
Simple print will work on any version.</p>
<pre><code>   print(" Supports all versions of Python!")
</code></pre>
<p>However, if you use any more advanced feature of print which is inevitable,  you either end up with a syntax error or not printing what you intended. Python 2’s trailing comma has in Python 3 become a parameter, so if you use trailing commas to avoid the newline after a print, this will in Python 3 look like</p>
<pre><code> print('Text to print', end=' ') 
</code></pre>
<p>which is a syntax error under Python 2.</p>
<p>Under Python 2.6 there is a </p>
<pre><code>__future__ import 
</code></pre>
<p>to make print into a function. So to avoid any syntax errors and other differences you should start any file where you use print() with from 
<strong>future</strong> import print_function. The <strong>future</strong> import only works under Python 2.6 and later, so for Python 2.5 and earlier you have two options. You can either convert the more complex print to something simpler, or you can use a separate print function that works under both Python 2 and Python 3.
To solve print issue you can write your own print functions which is more tricker.</p>
<p>2) Import errors.
They occurred because reorganization of the standard library getting around is very easy like</p>
<pre><code>try:
    import configparser
except ImportError:
    import ConfigParser as configparser
</code></pre>
<p>this will only work for renamed imports, for new modules or who are mergers or sub-modules of several old modules you have to convert them 2to3 which is pretty easy.</p>
<p>3) Integer incompatibilities.</p>
<p>In Python 3 the first one is that the int and the long types have been merged this means that you can’t specify that an integer should be long by adding the L suffix any more. 1L is a syntax error in Python 3.
you can avoid it like</p>
<pre><code>import sys
if sys.version_info &gt; (3,):
    long = int
long(1)
1L
</code></pre>
<p>Another change is that the syntax for octal literals has also changed. To . avoid you can use the decimal or hex value and put the octal value in a comment like</p>
<pre><code>f = 420 # 644 in octal, 'rw-r--r--'
</code></pre>
<p>4) Handling binary data.
The trickiest and most complicated of them all. You can read it documentation <a href="https://docs.python.org/3/howto/pyporting.html" rel="nofollow noreferrer">here</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 2 and 3 don't cooperate within one process. You could use <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="nofollow noreferrer">remote procedure calls</a> though, perhaps using <a href="http://pythonhosted.org/Pyro4/" rel="nofollow noreferrer">Pyro (Python remote objects)</a>. This has similar performance concerns as the pipes within multiprocessing. <a href="https://pypi.python.org/pypi/SharedArray" rel="nofollow noreferrer">SharedArray</a> can operate faster using shared memory, but is limited to numeric arrays. </p>
</div>
<span class="comment-copy">Why do you want to do that. Any specific use case?</span>
<span class="comment-copy">Mainly due to modules dependent on large 3rd party libraries which some are python 3 and others are python 2. That's why its an issue to simply convert using 2to3 tool or others.</span>
