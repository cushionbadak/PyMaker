<div class="post-text" itemprop="text">
<p>I can check the presence of a file or folder using <strong><em>OS</em></strong> library very easily.
The following two links have described that
<a href="https://stackoverflow.com/questions/8933237/how-to-find-if-directory-exists-in-python">directoryExistance </a><a href="https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python">fileExistance</a></p>
<p>I am attempting to use the <strong><em>subprocess</em></strong> library to do the same</p>
<p>and, I tried a couple of approaches already</p>
<p>1- <code>status = subprocess.call(['test','-e',&lt;path&gt;])</code>, which is always returning 1, no matter what I pass in path.</p>
<p>2- Using getstatusoutput, </p>
<blockquote>
<p>/bin/sh: 1: : Permission denied</p>
<pre><code>status, result = subprocess.getstatusoutput([&lt;path&gt;])
print(status)
print(result)
</code></pre>
<p>which is working fine because status variable returns 126 if the file/folder exist and 127 when the file/folder doesn't exist. Also the result variable contains message but the "result" variable contains the message : Permission denied</p>
</blockquote>
<p>But the second solution looks like a hack to me. Is their a better way, of doing this ?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>test</code> command is a shell builtin, and on many platforms doesn't exist as an independent command you can run.</p>
<p>If you use <code>shell=True</code> to use the shell to run this command, you should pass in a single string, not a list of tokens.</p>
<pre><code>status = subprocess.call("test -e '{}'".format(path), shell=True)
</code></pre>
<p>This will produce a malformed command if <code>path</code> contains any single quotes; try <code>path.replace("'", r"\'")</code> if you want to be completely correct and robust, or use one of the existing quoting functions to properly escape any shell metacharacters in the command you pass in.</p>
<p>The <code>subprocess</code> library now offers a function <code>run()</code> which is slightly less unwieldy than the old legacy <code>call()</code> function; if backwards compatibility is not important, you should probably switch to that... or, as several commenters have already implored you, not use <code>subprocess</code> for this task when portable, lightweight native Python solutions are available.</p>
</div>
<div class="post-text" itemprop="text">
<p>As pointed in the comments section</p>
<pre><code>status = subprocess.call(['test','-e',&lt;path&gt;]) 
</code></pre>
<p>can be made to work with a shell expansion if we use <strong><em>"shell=True"</em></strong></p>
<p>Although using os.path might be much more efficient anyways.</p>
</div>
<span class="comment-copy">"/bin/sh: 1: : Permission denied", is written by mistake in the second point.</span>
<span class="comment-copy">The modern way is to use <a href="https://docs.python.org/3/library/pathlib.html#basic-use" rel="nofollow noreferrer"><code>pathlib</code></a>.</span>
<span class="comment-copy">Not working with '~'. In my ubuntu platform</span>
<span class="comment-copy">I need my path to be somethig like '~/workspace/datasets'.</span>
<span class="comment-copy">@glibdud. Using <code>shell=True</code> only works if the command is a string, rather than a list, and there are <a href="https://docs.python.org/3/library/subprocess.html#security-considerations" rel="nofollow noreferrer">security considerations</a> to take into account.</span>
<span class="comment-copy">For what it's worth, <code>test -e</code> merely checks whether an entry with the given name exists in the file system. Perhaps you are actually looking for <code>test -f</code> and <code>test -d</code> which additionally check whether it refers to a regular file or a directory, respectively.</span>
