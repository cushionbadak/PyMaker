<div class="post-text" itemprop="text">
<p>I've created my own thread class that will be used in a threadpool as follows:</p>
<pre><code>class SendFilesThread(threading.Thread):
    execute = True

    def __init__(self, port, rate, fileQueue):
        self.daemon = True
        self.fileQueue = fileQueue
        #Other initialization

    def run(self):
        while SendFilesThread.execute == True or not self.fileQueue.empty():
            self.filename = self.fileQueue.get()
            #some file processing
            self.fileQueue.task_done()

    @staticmethod
    def terminate():
        SendFilesThread.execute = False
</code></pre>
<p>In the main thread of the program, after I have processed all of my files, I try and shut down the threadpool as follows:</p>
<pre><code>SendFilesThread.terminate()
for t in threadPool:
    if t.is_alive():
        t.join()
exit()
</code></pre>
<p>My understanding is that if I call <code>join()</code> it will block the calling thread, in this case the main thread, from continuing until the joined thread finishes processing. My issue is that despite the thread completing, it never returns to the main thread and the program just hangs. Am I doing anything wrong when shutting down my threadpool?</p>
</div>
<div class="post-text" itemprop="text">
<p>if <code>fileQueue</code> is a <code>multiprocessing.Queue</code> or <code>queue.Queue</code>, then its <code>.get()</code> method will block until something arrives in the queue. Try using <code>.get_nowait()</code> but you may have to wrap it in a try block if you want execution to continue even when the queue is empty.</p>
<pre><code>try:
    self.filename = self.fileQueue.get_nowait()
except queue.Empty:
    time.sleep(1)
</code></pre>
<p>see <a href="https://docs.python.org/2/library/queue.html#queue-objects" rel="nofollow noreferrer">queue docs</a> for more</p>
</div>
<div class="post-text" itemprop="text">
<p>There are two things. First, from a design standpoint it's a bit odd to have the <code>execute</code> flag be at the class-level. It's usually better to have it be a flag on each class <em>instance</em>.</p>
<p>Second, you have a race condition. The <code>execute</code> flag is accessed by more than one thread, and not protected by a synchronization primitive, such as a mutex. This means that the <code>terminate()</code> call can be run (and the flag set) <em>after</em> any worker thread checks the flag, but <em>before</em> that thread tries to dequeue the next filename. Because you're calling <code>get()</code> without a timeout, the worker thread will hang here, and the main thread will block in the <code>t.join()</code> call. Deadlock ensues.</p>
<p>There are many ways around this. You can use a thread-synchronization primitive such as a mutex to protect the <code>execute</code> flag, or use a <code>threading.Event</code> object in place of a simple boolean. </p>
<p>Another, and in my opinion simpler, solution is to send a "sentinel" value on the same queue, which indicates that the thread should quit. It looks like you're sending string filenames, so an empty string could be a good choice. (<code>None</code> is also commonly used.)</p>
<p>The work-loop for each thread now looks like this:</p>
<pre><code>def run(self):
    while True:
        self.filename = self.fileQueue.get()
        if self.filename == '':
            return
        # Process file
</code></pre>
<p>Rather than the <code>terminate()</code> static method, the main thread places an empty string (i.e., <code>fileQueue.enqueue('')</code>) for each worker thread you have.</p>
</div>
<span class="comment-copy">Since you set <code>self.daemon = True</code>, the thread will be terminated automatically when the main thread quitsâ€”so you don't need to do the <code>join()</code>s. However in <code>SendFilesThread.__init__()</code> you forgot to initialize the base class with <code>Thread.__init__()) </code> (or better <code>super().__init__()</code>) before doing anything else as the <a href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="nofollow noreferrer">documentation</a> says to do.</span>
<span class="comment-copy">Actually, I did do that. <code>#Other initialization</code> can be assumed to include all other necessary steps in initialize a thread properly. There were many other lines in the <code>__init__</code> method that I thought would just bog down the question in needless lines of code. I am aware that making the treads daemons will force them to terminate when the main thread terminates, that is why I made them daemons in the first place. My issue is that after all files have been sent into my <code>fileQueue</code> the threads need to be given time to complete before the main thread closes.</span>
<span class="comment-copy">That worked! Thank you I can't believe I missed something so small.</span>
<span class="comment-copy">Very good points. I did not think it was necessary to synchronize calls to my execute flag since it is not a data structure.</span>
<span class="comment-copy">@nb12345 Yep, pretty much anything that can be accessed by multiple threads, no matter the object type, is prone to data races.</span>
