<div class="post-text" itemprop="text">
<p>Right now I have a list of for example  </p>
<pre><code>data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff']  
</code></pre>
<p>I want to remove the words with the repeated letters, in which I want to remove the words</p>
<pre><code>'aa','aac','bbb','bcca','ffffff'
</code></pre>
<p>Maybe <code>import re</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>Thanks to this thread: <a href="https://stackoverflow.com/questions/29158996/regex-to-determine-if-string-is-a-single-repeating-character">Regex to determine if string is a single repeating character</a></p>
<p>Here is the re version, but I would stick to PM2 ring and Tameem's solutions if the task was as simple as this:</p>
<pre><code>import re
data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff']  
[i for i in data if not re.search(r'^(.)\1+$', i)]
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['dog', 'cat', 'a', 'aac', 'bcca']
</code></pre>
<p>And the other:</p>
<pre><code>import re
data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff']  
[i for i in data if not re.search(r'((\w)\2{1,})', i)]
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['dog', 'cat', 'a']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Loop is the way to go. Forget about sets so far as they do not work for words with repetitive letters.</p>
<p>Here is a method you can use to determine if word is valid in a single loop:</p>
<pre><code>def is_valid(word):
    last_char = None
    for i in word:
        if i == last_char:
            return False

        last_char = i

    return True
</code></pre>
<p><strong>Example</strong></p>
<pre><code>In [28]: is_valid('dogo')
Out[28]: True

In [29]: is_valid('doo')
Out[29]: False
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The original version of this question wanted to drop words that consist entirely of repetitions of a single character. An efficient way to do this is to use sets. We convert each word to a set, and if it consists of only a single character the length of that set will be 1. If that's the case, we can drop that word, unless the original word consisted of a single character.</p>
<pre><code>data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff'] 
newdata = [s for s in data if len(s) == 1 or len(set(s)) != 1]
print(newdata)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['dog', 'cat', 'a', 'aac', 'bcca']
</code></pre>
<hr/>
<p>Here's code for the new version of your question, where you want to drop words that contain any repeated characters. This one's simpler, because we don't need to make a special test for one-character words..</p>
<pre><code>data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff'] 
newdata = [s for s in data if len(set(s)) == len(s)]
print(newdata)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['dog', 'cat', 'a']
</code></pre>
<hr/>
<p>If the repetitions have to be consecutive, we can handle that using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>groupby</code></a>.</p>
<pre><code>from itertools import groupby

data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff', 'abab', 'wow'] 
newdata = [s for s in data if max(len(list(g)) for _, g in groupby(s)) == 1]
print(newdata)
</code></pre>
<p><strong>output</strong></p>
<pre><code>['dog', 'cat', 'a', 'abab', 'wow']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a way to check if there are consecutive repeated characters:</p>
<pre><code>def has_consecutive_repeated_letters(word):
    return any(c1 == c2 for c1, c2 in zip(word, word[1:]))
</code></pre>
<p>You can then use a list comprehension to filter your list:</p>
<pre><code>words = ['dog','cat','a','aa','aac','bbb','bcca','ffffff', 'abab', 'wow']
[word for word in words if not has_consecutive_repeated_letters(word)]
# ['dog', 'cat', 'a', 'abab', 'wow']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>One line is all it takes :)</p>
<pre><code>data = ['dog','cat','a','aa','aac','bbb','bcca','ffffff']  
data =  [value for value in data if(len(set(value))!=1 or len(value) ==1)]
print(data)
</code></pre>
<p><strong>Output</strong></p>
<pre><code>['dog', 'cat', 'a', 'aac', 'bcca']
</code></pre>
</div>
<span class="comment-copy">Sorry, made an edit. Not from the first character, but anywhere exists repeated letters</span>
<span class="comment-copy">Please do <b>not</b> change your question after you have received valid answers when the change invalidates those answers!</span>
<span class="comment-copy">You might want to put the "consecutively repeated" from your title in your question, and add a word like "abab" to make it clear (assuming I'm right) that you want it to remain.</span>
<span class="comment-copy">Don't edit a question mid-way again. If you continue to do so, your posts will be closed. Changing your question after others have taken the time to solve your original query is very disrespectful to their time.</span>
<span class="comment-copy">Not familiar with Regex, so maybe will just use the loop and sets for now.</span>
<span class="comment-copy">@JieNiu But that's where you are wrong. If you have more of these tasks Regex is the only place to go</span>
<span class="comment-copy">@JieNiu The answer you chose doesn't handle words like <code>'wow'</code></span>
<span class="comment-copy">Cool. Will take a look of the reference on Regex. Thanks.</span>
<span class="comment-copy">@AntonvBR: It's by far not the "only place to go" but it can be a very powerful tool indeed.</span>
<span class="comment-copy">sets do not consider repetitive letters in the word so it is not sufficient.</span>
<span class="comment-copy">This won't work for <code>'wow'</code> for instance.</span>
<span class="comment-copy">@AntonvBR Now it does. ;)</span>
<span class="comment-copy">@PM2Ring Yep, upvoted. However I think OP was unclear from beginning chancing the content of his question multiple times.</span>
<span class="comment-copy">Looks good to me.</span>
