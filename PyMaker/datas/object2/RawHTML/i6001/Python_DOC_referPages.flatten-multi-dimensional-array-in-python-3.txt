<div class="post-text" itemprop="text">
<p>I have a list of numbers:  testList = [1, [1], [12], 2, 3]</p>
<p>I want it to become:  flatList = [1, 1, 12, 2, 3]</p>
<p>Using a typical list comprehension such as below is not working.</p>
<pre><code>flatList = [val for sublist in testList for val in sublist]
TypeError: 'int' object is not iterable
</code></pre>
<p>I suspected it is because the un-nested items are being treated as iterable sublists, so I tried this:</p>
<pre><code>flatList = [val if isinstance(sublist, int) == False else val for sublist in testlist for val in sublist]
</code></pre>
<p>But I am unclear on the syntax, or if there is some better way to do this. Trying to remove val from the else clause means val is undefined. As is, it still gives me the same TypeError.</p>
<p>The code below does work for me, but I am interested to see if it can be done in list comprehension style, and people's opinions on that.</p>
<pre><code>for sublist in testlist:
    if type(sublist) == int:
        flat.append(sublist)
    else:
        for val in sublist:
            flat.append(val)
print(flat)

&gt;&gt;&gt;[1, 1, 12, 2, 3]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since you're using Python 3, you can take advantage of <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="nofollow noreferrer"><code>yield from</code></a> with a recursive function. It has been introduced in Python 3.3.</p>
<p>As a bonus, you can flatten arbitrary nested lists, tuples, sets or ranges:</p>
<pre><code>test_list = [1, [1], [12, 'test', set([3, 4, 5])], 2, 3, ('hello', 'world'), [range(3)]]

def flatten(something):
    if isinstance(something, (list, tuple, set, range)):
        for sub in something:
            yield from flatten(sub)
    else:
        yield something


print(list(flatten(test_list)))
# [1, 1, 12, 'test', 3, 4, 5, 2, 3, 'hello', 'world', 0, 1, 2]
print(list(flatten('Not a list')))
# ['Not a list']
print(list(flatten(range(10))))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>Here's another example with a debug line:</p>
<pre><code>def flatten(something, level=0):
    print("%sCalling flatten with %r" % ('  ' * level, something))
    if isinstance(something, (list, tuple, set, range)):
        for sub in something:
            yield from flatten(sub, level+1)
    else:
        yield something

list(flatten([1, [2, 3], 4]))
#Calling flatten with [1, [2, 3], 4]
#  Calling flatten with 1
#  Calling flatten with [2, 3]
#    Calling flatten with 2
#    Calling flatten with 3
#  Calling flatten with 4
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the sublists always contain only one item then</p>
<pre><code>flatList = [item[0] if isinstance(item, list) else item for item in testList]
</code></pre>
</div>
<span class="comment-copy">Can the sub-list contain more than one integer?</span>
<span class="comment-copy">In else block, you can replace the for with <code>flat.extend(sublist)</code></span>
<span class="comment-copy">@AidanHorton It can contain more than one integer.</span>
<span class="comment-copy">@stack_n_queue thanks for pointing that out.</span>
<span class="comment-copy">I'd name <code>something</code> <code>iterable</code>, instead.</span>
<span class="comment-copy">Alright, it's up to you, but I'd raise a <code>TypeError</code> if <code>something</code> isn't an iterable (since it makes no sense to call flatten on integers and strings?)</span>
<span class="comment-copy">Right, I get it now. I often have trouble wrapping my head around recursion :)</span>
<span class="comment-copy">Wow, very useful. Not a function I was familiar with, and it's good to see how isinstance() can be used with multiple types.</span>
<span class="comment-copy">Thanks, useful in those cases.</span>
