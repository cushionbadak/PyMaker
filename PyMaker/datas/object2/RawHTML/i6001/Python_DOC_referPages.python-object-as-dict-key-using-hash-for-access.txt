<div class="post-text" itemprop="text">
<p>Take this super simple class:</p>
<pre><code>class Foo():
    def __init__(self, iden):
        self.iden = iden
    def __hash__(self):
        return hash(self.iden)
    def __repr__(self):
        return str(self.iden)
</code></pre>
<p>The goal is to create instances of the class to use as dict keys.  If <code>__repr__</code> is omitted, the keys are the standard object address.  With <code>__repr__</code> a printable representation might be:</p>
<pre><code>f = Foo(1)
g = Foo(2)
d = {f:'a', g:'b'}
print(d)
&gt;&gt;&gt; {1:'a', 2:'b'}
</code></pre>
<p>When attempting to access the dict by key though, it does not appear to be immediately obvious how to utilize the <code>__repr__</code> (or <code>__str__</code> for that matter) representation as the key.</p>
<pre><code>print(d[1]) 
&gt;&gt;&gt; KeyError
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First thing's first: <code>__repr__()</code> is a red herring. It only affects how the object is displayed. It has nothing to do with what you're trying to do.</p>
<p>If you want to have two separate objects refer to the same slot in a dict, you need two things (<a href="https://stackoverflow.com/questions/9010222/how-can-python-dict-have-multiple-keys-with-same-hash">reference</a>):</p>
<ul>
<li>The objects must have the same hash (<code>hash(obj1) == hash(obj2)</code>).</li>
<li>The objects must compare equal (<code>obj1 == obj2</code>).</li>
</ul>
<p>Your above implementation does the former, but not the latter. You need to add an <code>__eq__()</code> method (which is actually required by the <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">documentation</a> when you define <code>__hash__()</code>, anyway).</p>
<pre><code>class Foo():
    def __init__(self, iden):
        self.iden = iden
    def __hash__(self):
        return hash(self.iden)
    def __eq__(self, other):
        return self.iden == other
</code></pre>
<p>Â </p>
<pre><code>&gt;&gt;&gt; d = {Foo(1) : 'a'}
&gt;&gt;&gt; d[1]
'a'
</code></pre>
</div>
<span class="comment-copy">How to utilize <code>__str__</code>/<code>__repr__</code> to do <i>what</i>, exactly? An object's place in a <code>dict</code> (or <code>set</code>) is based only on its hash. <code>__repr__</code> only affects how an object <i>appears</i>, not how you can reference it.</span>
<span class="comment-copy">The answer is no. As I said, the repr is only relevant to how the object is <i>displayed</i>, not how you can reference it.</span>
<span class="comment-copy">@glibdud The above fails using <code>__hash__</code> as well.  <code>hash(1) == 1</code>, but <code>d[1]</code> fails with a key error.</span>
<span class="comment-copy">Good point. It appears that something else (possibly type?) is taken into account in addition to hash. I'll see if I can find a reference.</span>
