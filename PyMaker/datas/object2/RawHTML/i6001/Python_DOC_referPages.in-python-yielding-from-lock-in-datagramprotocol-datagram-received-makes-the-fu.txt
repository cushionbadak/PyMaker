<div class="post-text" itemprop="text">
<p>I want to synchronize data from between coroutines and I end up with a method not being called whenever there is "yield" inside it.</p>
<p>To be more precise, when I implement a DatagramProtocol class with the method datagram_received as per the doc (<a href="https://docs.python.org/3/library/asyncio-protocol.html#udp-echo-server-protocol" rel="nofollow noreferrer">inspired from this</a>), everything works fine, I receive the data. As soon as I add a "yield" inside the method datagram_received, the method is never called anymore. Here is an example:</p>
<pre><code>loop = asyncio.get_event_loop()
lock = asyncio.Lock(loop=loop)

class MyProtocol(asyncio.DatagramProtocol):
    def datagram_received(self, data, addr):
        global my_data, lock
        print("here")
        # uncomment the following lines and datagram_received is 
        # not called at all (never see the "here" on the console)
        #yield from lock
        #try:
        #    my_data = float(data.decode())
        #finally:
        #    lock.release()

loop.run_until_complete(loop.create_datagram_endpoint(MyProtocol, sock=create_socket(10000)))

loop.run_forever()
</code></pre>
<p>How can a method suddenly get not being called depending on the content of the method?</p>
<p>What am I missing? How the synchronization should be done?</p>
</div>
<div class="post-text" itemprop="text">
<h3>What am I missing?</h3>
<p>Documentation that inspired you also states:</p>
<blockquote>
<p>Coroutines can be scheduled in a protocol method using ensure_future(), but there is no guarantee made about the execution order. Protocols are not aware of coroutines created in protocol methods and so will not wait for them.</p>
<p>To have a reliable execution order, use stream objects in a coroutine with yield from. For example, the StreamWriter.drain() coroutine can be used to wait until the write buffer is flushed.</p>
</blockquote>
<p>You cannot <code>yield from</code>/<code>await</code> inside <code>datagram_received</code>, you may:</p>
<pre><code>class MyProtocol(asyncio.DatagramProtocol):
    def datagram_received(self, data, addr):
        global my_data, lock
        print("here")
        loop.ensure_future(some_function())

    @asyncio.coroutine
    def some_function(self):
        yield from lock
        try:
            my_data = float(data.decode())
        finally:
            lock.release()
</code></pre>
<h3>How can a method suddenly get not being called depending on the content of the method?</h3>
<p>Use of <code>yield</code> or <code>yield from</code> in a function, makes it a generator. So <code>datagram_received</code> returns generator object. To actually execute the code (till yield) you should use <code>next</code>, asyncio does it with (generator-based) coroutines (but again <code>datagram_received</code> isn`t one)</p>
<pre><code>&gt;&gt;&gt; def test():
...     print('test')
...     yield from 'A'
... 
&gt;&gt;&gt; test()
&lt;generator object test at 0x7f4165d42fc0&gt;
&gt;&gt;&gt; next(test())
test
'A'
</code></pre>
<p>More about generators: <a href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/" rel="nofollow noreferrer">https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/</a></p>
</div>
<span class="comment-copy">What is <code>lock</code>?</span>
<span class="comment-copy">lock is simply a asyncio.Lock object</span>
<span class="comment-copy">edited code to add the lock variable to clarify context</span>
<span class="comment-copy"><code>yield</code> caused your function to return a generator. You need to iterate over it for the code to execute.</span>
<span class="comment-copy">@dim, could you put that as an answer? with maybe an example?</span>
<span class="comment-copy">Awesome, hope it helps other programmers that come from other languages like me!</span>
