<div class="post-text" itemprop="text">
<p>I have to use functional programming to implement the following function takes in a list of numbers from 0 to 9. The goal is to find the five consecutive elements of the list that have the greatest product. The function should return tuple of the index of the greatest product and the value of the greatest product <strong>without</strong> using the <em>max</em> function.</p>
<p>I can easily implement this without functional programming but I am having trouble implementing it without any loops.
This is my approach so far but the part that I am stuck on is how to loop through the array to find those consecutive five numbers without loops. I am trying to use map to do that but I don't think it is correct. Is it possible to incorporate enumerate in any way? Any help is appreciated. </p>
<pre><code>def find_products(L):
    val = map(lambda a: reduce(lambda x,y: x*y, L),L)
    print (val)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This doesn't have any explicit loops or call the <code>max</code> function. The function assumes that there're at least five elements in the input list and outputs a tuple <code>(start_index, max_product)</code>.</p>
<pre><code>from functools import reduce, partial
import operator

def f(l):
    win = zip(l, l[1:], l[2:], l[3:], l[4:])
    products = map(partial(reduce, operator.mul), win)
    return reduce(lambda x, y: x if x[1] &gt; y[1] else y, enumerate(products))
</code></pre>
<pre><code>In [2]: f([1, 2, 3, 4, 7, 8, 9])
Out[2]: (2, 6048)

In [3]: f([2, 6, 7, 9, 1, 4, 3, 5, 6, 1, 2, 4])
Out[3]: (1, 1512)
</code></pre>
<p><code>win = zip(l, l[1:], l[2:], l[3:], l[4:])</code> creates a sliding window iterator of size 5 over the input list. <code>products = map(partial(reduce, operator.mul), win)</code> is an iterator calling <code>partial(reduce, operator.mul)</code> (translates to <code>reduce(operator.mul, ...)</code>) on every element of <code>win</code>. <code>reduce(lambda x, y: x if x[1] &gt; y[1] else y, enumerate(products))</code> adds a counter to <code>products</code> and returns the index-value pair with the highest value.</p>
<p>If you need a more general version and/or the input list is large you'd use <code>itertools.islice</code>:</p>
<pre><code>from itertools import islice

def f(l, n=5):
    win = zip(*(islice(l, i, None) for i in range(n)))
    ...
</code></pre>
<p>The code above uses a generator expression which is a loop, technically. A pure functional version of that might look like</p>
<pre><code>from itertools import islice

def f(l, n=5):
    win = zip(*map(lambda i: islice(l, i, None), range(n)))
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>from functools import reduce #only for python3, python2 doesn't need import
def find_products(L):
    if len(L)==0:
        return 0
    if len(L) &lt;= 5:
        return reduce( lambda x,y:x*y, L)
    pdts = ( reduce(lambda a,b:a*b,L[pos:pos+5]) for pos in range(len(L)-4)) # or pdts = map(lambda pos: reduce(lambda a,b:a*b,L[pos:pos+5],0),range(len(L)-4))
    mx = reduce(lambda x,y: x if x&gt;y else y, pdts)
    return mx
</code></pre>
<p><code>pdts</code> contains all the possible 5 tuple products, and then using <a href="https://docs.python.org/2/library/functions.html#reduce" rel="noreferrer"><code>reduce</code></a> to mimic the <code>max</code> function, we find the maximum among the products.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do the following:</p>
<ul>
<li>For each start index in <code>range(0, len(L) - 5)</code></li>
<li>Map the index to the tuple of <code>start</code> and the product of items <code>L[start:start + 5]</code></li>
<li>Reduce the tuples to the one that has the highest product</li>
<li>Get the first value of the resulting tuple = the start index of the 5 elements that have the highest product</li>
<li>Return the slice <code>L[result:result + 5]</code></li>
</ul>
<p>This algorithm could be further improved to avoid re-calculating sub-products, but use a "rolling product", that is updated as you reduce from left to right, dividing by the element that was dropped, and multiplying by the new element that was added.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a Haskell solution, which is purely functional:</p>
<pre><code>import Data.List

multiply :: [Int] -&gt; Int
multiply = foldr (*) 1

consecutiveProducts :: [Int] -&gt; [(Int,Int)]
consecutiveProducts xs =
    [(i,multiply $ take 5 h) | (i,h) &lt;- zipped, length h &gt;= 5]
    where
        indices = reverse [0..(length xs)]
        zipped = zip indices (tails xs)

myComp (i1,h1) (i2,h2) = compare h2 h1

main = print $ head $ sortBy myComp $ consecutiveProducts [4,5,3,1,5,3,2,3,5]
</code></pre>
<p>Here is what it does:</p>
<ul>
<li>Starting in the last line, it computes the consecutive products from that list.</li>
<li><p><code>tails xs</code> gives all the subsets starting with different starting values:</p>
<pre><code>&gt; tails [4,5,3,1,5,3,2,3,5]
[[4,5,3,1,5,3,2,3,5],[5,3,1,5,3,2,3,5],[3,1,5,3,2,3,5],[1,5,3,2,3,5],[5,3,2,3,5],[3,2,3,5],[2,3,5],[3,5],[5],[]]
</code></pre></li>
<li>From these tails we only take those that are at least 5 elements long.</li>
<li>Then we <code>zip</code> them with natural numbers such that we have the starting index associated with it.</li>
<li>From each of the subsets we take the first five elements.</li>
<li>These five elements are passed to the <code>multiply</code> function. There those are reduced to a single number, the product.</li>
<li>After that we go back to the last line, we sort the list by the product value descending.</li>
<li>From the resulting list we only take the first element.</li>
<li>And then we print the result, which is <code>(5,450)</code> for my input data.</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>This solution uses <code>reduce</code> to calculate a 5-value product, list comprehension for generating all of those products, tuple creation for having the index to go with each, <code>reduce</code> again to get the best tuple.</p>
<p>An <code>if else</code> operator is used to catch the case when there are no 5 values in the input. </p>
<pre><code>from functools import reduce

def find_products(values):
    return None if len(values) &lt; 5 else reduce(
        lambda best, this: this if this[1] &gt; best[1] else best,
        [(i, reduce(lambda a,b: a*b, values[i:i+5], 1)) for i in range(0, len(values)-4)]
    )

result = find_products([1, 0, 8, 3, 5, 1, 0, 2, 2, 3, 2, 2, 1])
print (result)
</code></pre>
<p>Output for the example call is:</p>
<pre><code>(7, 48)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><strong>A Pure Python Solution using <code>recursion</code></strong> </p>
<p>First, we need to create a <code>recursive</code> <code>function</code> to find the <code>product</code> of a <code>list</code>:</p>
<pre><code>def product(l, i=0, s=1):
    s *= l[i]
    if i+1 &lt; len(l):
        return product(l, i+1, s)
    return s
</code></pre>
<p>which we can do some tests for:</p>
<pre><code>&gt;&gt;&gt; product([1, 2, 3])
6
&gt;&gt;&gt; product([1, 1, 1])
3
&gt;&gt;&gt; product([2, 2, 2])
8
</code></pre>
<hr/>
<p>Then, we can use this <code>function</code> in another <code>recursive</code> <code>function</code> to solve your problem:</p>
<pre><code>def find_products(l, i=0, t=(0, -1)):
     p = product(l[i:i+5])
     if p &gt; t[1]:
         t = (i, p)
     if i+5 &lt; len(l):
         return find_products(l, i+1, t)
     return t
</code></pre>
<p>which works!</p>
<p>Here are some tests to show it working:</p>
<pre><code>&gt;&gt;&gt; find_products([1, 1, 5, 5, 5, 5, 5, 1, 1])
(2, 3125)
&gt;&gt;&gt; find_products([1, 1, 1, 1, 1, 0, 0, 0, 0])
(0, 1)
&gt;&gt;&gt; find_products([1, 4, 5, 2, 7, 9, 3, 1, 1])
(1, 2520)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><em>want one liner using max  and without max try this</em></p>
<pre><code>from numpy import prod
l=[2,6,7,9,1,4,3]
max([prod(l[i:i+5]) for i in range(len(l))])
sorted([prod(l[i:i+5]) for i in range(len(l))])[-1]  // without max
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Imperative paradigm is often:</p>
<pre><code> state = state0
 while condition:
   # change state 
</code></pre>
<p>This is the "natural" way of programming for lot of people and you know how do that in this way.</p>
<p>The pure <a href="https://en.wikipedia.org/wiki/Functional_programming" rel="nofollow noreferrer">functional paradigm</a> forbid variables, which have some advantages . It works with functions which communicates through parameters(IN) and return values(OUT). It frequently uses recursive functions.</p>
<p>A generic functional recursive scheme is : </p>
<pre><code>f = lambda *args : result(*args) if  condition(*args) else f(*newparams(*args))   
</code></pre>
<p>Here we can find a solution with <code>(l,i,imax,prodmax)</code> as parameters, and:</p>
<pre><code>condition = lambda  l,i,_,__ : i&gt;=len(l)-5        

result = lambda _,__,*args : args

newparams = lambda l,i,imax,prodmax: (l, i+1, imax, prodmax)  \
            if   l[i]*l[i+1]*l[i+2]*l[i+3]*l[i+4] &lt;= prodmax  \
            else (l, i+1, i, l[i]*l[i+1]*l[i+2]*l[i+3]*l[i+4]) 
</code></pre>
<p>None other than functions have been defined.</p>
<p>You can even define no functions to do that, see  <a href="https://stackoverflow.com/questions/481692/can-a-lambda-function-call-itself-recursively-in-python">here</a> for example, but readability suffers even more.  </p>
<p>Run :</p>
<pre><code>In [1]: f([random.randint(0,9) for i in range (997)],0,0,0)
Out[1]: (386, 59049)                
</code></pre>
<p>Python limits this approach by setting recursive depth to 2000, and from Python 3, by hiding functional tools in the module <code>functools</code>.  </p>
</div>
<span class="comment-copy"><code>map</code> and <code>reduce</code> use <code>loops</code> behind the scenes, trying to avoid using loops in <code>list-comprehensions</code> for example is going to be pretty difficult and has no real benefit.</span>
<span class="comment-copy">You can almost straightforwardly avoid loops if instead you use recursion. Haskell does it this way. However, Haskell has optimizations for this, Python likely does not. So you will quickly run into the maximum recursion depth. — What is your motivation to do it in a functional style, anyway?</span>
<span class="comment-copy">functional programming =/= avoiding loops.</span>
<span class="comment-copy">I realize that you said <code>max</code> is not allowed, but it's worth noting that, in real functional programming, the best way to do this would probably be to use the max function with a sliding window iterator (e.g. <code>max(sliding(L, 5), key=product)</code> for suitable definitions of <code>sliding</code> and <code>product</code>).</span>
<span class="comment-copy">IMO, loop vs recursion is just an instance of sequential thinking vs divide-and-conquer.</span>
<span class="comment-copy">This looks good and probably the closest to what OP is expecting.</span>
<span class="comment-copy">BTW, you could use <code>win = zip(*(l[i:] for i in range(5)))</code> for a more general answer.</span>
<span class="comment-copy">@EricDuminil yeah, but if the list is huge <code>itertools.islice</code> should be preferred</span>
<span class="comment-copy">I am still confused as to what the partial operation is doing? what would happen if we didn't use it?</span>
<span class="comment-copy">@comp.eng. see the docs for <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer"><code>functools.partial</code></a>. We'd have to use <code>lambda x: reduce(operator.mul, x)</code> instead</span>
<span class="comment-copy">Please correct me if I'm wrong, but we cannot use conditional statements in functional programming right? Or any loops inside the list comprehension?</span>
<span class="comment-copy">@comp.eng. there's nothing wrong with conditionals in functional programming. Haskell has if, guard clauses and pattern matching, all forms of conditionals -- there's no way to stop recursion without conditions.</span>
<span class="comment-copy">You requested some feedback. This code looks sensible. You will eventually have a problem with the maximum recursion depth in Python. Also the overhead of calling a function in Python is not negligible because they are all virtual. So I would think that using <code>reduce</code> and <code>map</code> would be faster and easier to read. I still don't understand the motivation of the OP.</span>
<span class="comment-copy">@MartinUeding Yea, I hadn't considered the maximum recursion depth good point. And I agree that what the OP wants isn't really practical</span>
<span class="comment-copy">max prohibited :) .</span>
<span class="comment-copy">@B.M.  i updated my code hope you would like it</span>
