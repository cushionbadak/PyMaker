<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3389148/python-class-variables-or-class-variables-in-general">Python class variables or class variables in general</a>
<span class="question-originals-answer-count">
                    4 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/1697273/differences-between-static-and-instance-variables-in-python-do-they-even-exist">Differences between static and instance variables in python. Do they even exist?</a>
<span class="question-originals-answer-count">
                    6 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/2424451/compound-assignment-to-python-class-and-instance-variables">Compound assignment to Python class and instance variables</a>
<span class="question-originals-answer-count">
                    5 answers
                </span>
</li>
<li>
<a dir="ltr" href="/questions/68645/are-static-class-variables-possible">Are static class variables possible?</a>
<span class="question-originals-answer-count">
                    17 answers
                </span>
</li>
</ul>
</div>
<pre><code>&gt;&gt;&gt; class a:
...     b=5
...     def __init__(self,x,y):
...             self.x=x
...             self.y=y
...
&gt;&gt;&gt; p=a(5,6)
&gt;&gt;&gt; q=a(5,6)
&gt;&gt;&gt; a.b
5
&gt;&gt;&gt; a.b+=1
&gt;&gt;&gt; p.b
6
&gt;&gt;&gt; q.b
6
&gt;&gt;&gt; q.b-=1
&gt;&gt;&gt; q.b
5
&gt;&gt;&gt; p.b
6
&gt;&gt;&gt; a.b
6
</code></pre>
<p>As you see, on changing the <strong>class variable</strong> by an instance's method, the same doesn't gets reflected in the class variable and the class variable of other instance. Why is it so?</p>
</div>
<div class="post-text" itemprop="text">
<p>Because <code>q.b -= 1</code> creates an instance variable with the name <code>b</code>, look in your <code>__dict__</code>:</p>
<pre><code>q.__dict__
{'b': 4, 'x': 5, 'y': 6}

p.__dict__
{'x': 5, 'y': 6}
</code></pre>
<p><code>q.b</code> is different than <code>a.b</code>, you've shadowed <code>a.b</code> after the assignment. Take note that this isn't a Python 3 specific issue, Python 2 also behaves in the same way.</p>
<p>This is clearly stated in the <a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" rel="nofollow noreferrer">assignment statement section</a> of the Language Reference:</p>
<blockquote>
<p>Note: If the object is a class instance and the attribute reference occurs on both sides of the assignment operator, the RHS expression, <code>a.x</code> can access either an instance attribute or (if no instance attribute exists) a class attribute. The LHS target <code>a.x</code> is always set as an instance attribute, creating it if necessary. Thus, the two occurrences of <code>a.x</code> do not necessarily refer to the same attribute: if the RHS expression refers to a class attribute, the LHS creates a new instance attribute as the target of the assignment: </p>
<pre><code>class Cls:
    x = 3             # class variable
inst = Cls()
inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3
</code></pre>
<p>This description does not necessarily apply to descriptor attributes, such as properties created with <code>property()</code>.</p>
</blockquote>
</div>
<span class="comment-copy">You can read a class attribute from the instance, but as soon as you set an instance attribute with the same name, it is shadowed. <code>+=</code> and <code>-=</code> do that.</span>
