<div class="post-text" itemprop="text">
<p>I came around <a href="https://stackoverflow.com/questions/47304999/attributeerror-module-tensorflow-has-no-attribute-python/">this question</a> and got quite disappointed by how the <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow" rel="nofollow noreferrer">tensorflow</a> developers try to make the <code>tensorflow</code> directory appear as the actual package, whereas the actual package root is actually <code>tensorflow/python</code>. By using a <code>__init__.py</code> file of the form</p>
<pre><code>from tensorflow.python import *
del python
</code></pre>
<p>they try to achieve this goal. This results in some inconsistent behaviour (at least so it seems to me) when working with the package, e.g.</p>
<pre><code>import tensorflow.python                # seems to work
tensorflow.python                       # AttributeError: no attribute 'python'
from tensorflow.python import Session   # works as expected
tensorflow.python.Session               # AttributeError: no attribute 'python'
from tensorflow import python           # works as expected

tensorflow.nn                           # works as expected
import tensorflow.nn                    # ImportError: no module 'tensorflow.nn'
tensorflow.nn.tanh                      # works as expected
from tensorflow.nn import tanh          # ImportError: no module 'tensorflow.nn'
</code></pre>
<p>Now, I was wondering whether/how it could be possible to avoid most/all of these issues to get a more consistent behaviour. The first set of inconsistencies could be easily resolved by not deleting the <code>python</code> attribute. However, given that the goal would be to make the complete package appear as if it is a sub-package, this might not be entirely satisfactory.</p>
<p>To keep things simple, let's consider the following package structure</p>
<pre><code>package/
    __init__.py
    api/
        __init__.py
        code.py
</code></pre>
<p>where <code>package/api/code.py</code> looks something like</p>
<pre><code>def a(): 
    return 'alpha'
def b(): 
    return 'bravo'
</code></pre>
<p>and <code>package/api/__init__.py</code> would be</p>
<pre><code>import package.api.code
</code></pre>
<p>would it be possible to create <code>package/__init__.py</code> so that the following works</p>
<pre><code>import package.api                      # ImportError: no module 'package.api'
package.api                             # AttributeError: no attribute 'api'
from package.api import code            # ImportError: no module 'package.api'
package.api.code                        # AttributeError: no attribute 'api'
from package import api                 # ImportError: cannot import 'api'

package.code                            # works as expected
import package.code                     # works as above
package.code.a                          # works as expected
from package import a                   # correctly imports function a
</code></pre>
<p>I believe that the last four lines of code should give the expected result by adding to <code>sys.modules</code>, but I do not seem to be able to find a way to make <code>import package.api</code> fail.</p>
<p>Would anyone have an idea on how this could be done? Feel free to point me to use-cases that I am overlooking or should consider to achieve the above-mentioned goal.</p>
</div>
<div class="post-text" itemprop="text">
<p>First of all - I must say that I literally hate "shady" techniques like this. It has a bad effect on various IDE intellisense and makes the library structure less understandable. But still...</p>
<p>If you want the submodule code.py to act as an actual subpackage, you need to create a dummy module:</p>
<pre><code>package/
    __init__.py
    api/
        __init__.py
        code.py
    code/
        __init__.py
</code></pre>
<p>Add this in code/__init__py:</p>
<pre><code>from package.api.code import *
</code></pre>
<p>And this in package/__init__.py:</p>
<pre><code>from package.code import *
</code></pre>
<p>And then this part should work as intended:</p>
<pre><code>import package.code            # works as expected
package.code                   # works as expected
package.code.a                 # works as expected
from package import a          # works as expected
</code></pre>
<p>If you further add this to the package/__init__.py:</p>
<pre><code>import package.api
del package.api
</code></pre>
<p>You basically disconnect user from accessing package.api, but nothing else, and they can still access the submodule through subpackage using 'from x import y':</p>
<pre><code>import package.api            # works
package.api.a()               # AttributeError: module 'package' has no attribute 'api'

import package.api.code       # works
package.api.code.a()          # AttributeError: module 'package' has no attribute 'api'

from package.api import code  # works
code.a()                      # works

from package import api       # works
api.code.a()                  # AttributeError: module 'package.api' has no attribute 'code'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I managed to write something that <strong>almost</strong> works (in <code>package/__init__.py</code>):</p>
<pre><code>import sys

from package.api import *

for key in sys.modules:
    parts = key.split('.')
    if len(parts) &gt; 1 and parts.pop(0) == __name__:
        subkey = parts.pop(0)
        if subkey == 'api' and len(parts) == 0:
            sys.modules['.'.join([__name__, subkey])] = None
        elif subkey == 'api':
            m = sys.modules.pop(key)
            sys.modules['.'.join([__name__] + parts)] = m
del api        
del sys
</code></pre>
<p>The import errors suggest that it is still quite a hack, but apart from that most all of the examples work as specified <strong>iff</strong> the package has already been loaded once (i.e. if <code>import package</code> or alike has been invoked before running the statements from my question). If the first statement is <code>import package.api</code>, there is thus no <code>ImportError</code> as I would like. </p>
<p>In an attempt to find a solution for this problem, I stumbled upon <a href="https://stackoverflow.com/a/24687316/4375377">this answer</a>, which practically leads to the same behaviour with much more elegant code:</p>
<pre><code>import sys

from package import api

# clean up this module
self = sys.modules.pop(__name__)
del self

# this module becomes hidden module
sys.modules[__name__] = api
sys.modules[api.__name__] = None

del api
del sys
</code></pre>
<p>However, this still suffers from the problem that if the first import is something like <code>import package.api</code>, no <code>ImportError</code> is thrown. </p>
</div>
<span class="comment-copy">Can you try: import package.code as code</span>
<span class="comment-copy">@PeterMajko What do you mean with that? This should normally work if <code>import package.code</code> works...</span>
<span class="comment-copy">It works perfectly fine if you use "import x from y as z": <a href="https://ibb.co/kHkPL6" rel="nofollow noreferrer">Check this image</a></span>
<span class="comment-copy">@PeterMajko I know, I noticed that <code>from tensorflow import python</code> does indeed work (I edited my question accordingly), but should it? I assume the idea of <code>del python</code> in <code>tensorflow/__init__.py</code> is to make the tensorflow package appear as if it were <code>tensorflow/python</code>. In this case, this is not the kind of behaviour that I would like to see.</span>
<span class="comment-copy">They have some reason to do it like that. Perhaps ask them why they took this approach? :)</span>
<span class="comment-copy">I actually would like to see consistent behaviour: if the import <code>import package.api</code> works, <code>package.api.a()</code> should work as well. However, it would be even more interesting to have <code>import package.api</code> fail with an <code>ImportError</code> and keep the <code>AttributeError</code> when invoking <code>package.api.a()</code>.</span>
<span class="comment-copy">This is by design... it is how python loaders work.</span>
<span class="comment-copy">ANother thing is - you really shouldn't do this, if you want to just make it "nice" and promote submodule as a subpackage -.- I would kill people for this</span>
<span class="comment-copy">It is rather easy to make the import consistent (and thus "nice") without tweaking the import system (just get rid of the delete statement, and everything is consistent). I was just wondering what the possibilities/limitations of python are on this subject. Please don't kill me...</span>
<span class="comment-copy">Lol :) It's ok. For all possibilities about import/load I suggest <a href="https://docs.python.org/3/reference/import.html" rel="nofollow noreferrer">this</a>. I believe that you would be able to construct something what  works as you describe from all this knowledge - the question would be - why would you do it? :) (no need to answer, haha)</span>
