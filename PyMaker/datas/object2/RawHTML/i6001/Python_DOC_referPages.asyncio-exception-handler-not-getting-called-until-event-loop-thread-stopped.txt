<div class="post-text" itemprop="text">
<p>I am setting an exception handler on my asyncio event loop. However, it doesn't seem to be called until the event loop thread is stopped. For example, consider this code:</p>
<pre><code>def exception_handler(loop, context):
    print('Exception handler called')

loop = asyncio.get_event_loop()

loop.set_exception_handler(exception_handler)

thread = Thread(target=loop.run_forever)
thread.start()

async def run():
    raise RuntimeError()

asyncio.run_coroutine_threadsafe(run(), loop)

loop.call_soon_threadsafe(loop.stop, loop)

thread.join()
</code></pre>
<p>This code prints "Exception handler called", as we might expect. However, if I remove the line that shuts-down the event loop (<code>loop.call_soon_threadsafe(loop.stop, loop)</code>) it no longer prints anything.</p>
<p>I have a few questions about this:</p>
<ul>
<li><p>Am I doing something wrong here?</p></li>
<li><p>Does anyone know if this is the intended behaviour of asyncio exception handlers? I can't find anything that documents this, and it seems a little strange to me. </p></li>
</ul>
<p>I'd quite like to have a long-running event loop that logs errors happening in its coroutines, so the current behaviour seems problematic for me.</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a few problems in the code above:</p>
<ul>
<li><code>stop()</code> does not need a parameter</li>
<li>The program ends before the coroutine is executed (<code>stop()</code> was called before it).</li>
</ul>
<p>Here is the fixed code (without exceptions and the exception handler):</p>
<pre><code>import asyncio
from threading import Thread


async def coro():
    print("in coro")
    return 42


loop = asyncio.get_event_loop()
thread = Thread(target=loop.run_forever)
thread.start()

fut = asyncio.run_coroutine_threadsafe(coro(), loop)

print(fut.result())

loop.call_soon_threadsafe(loop.stop)

thread.join()
</code></pre>
<p><code>call_soon_threadsafe()</code> returns a future object which holds the exception (it does not get to the default exception handler):</p>
<pre><code>import asyncio
from pprint import pprint
from threading import Thread


def exception_handler(loop, context):
    print('Exception handler called')
    pprint(context)


loop = asyncio.get_event_loop()

loop.set_exception_handler(exception_handler)

thread = Thread(target=loop.run_forever)
thread.start()


async def coro():
    print("coro")
    raise RuntimeError("BOOM!")


fut = asyncio.run_coroutine_threadsafe(coro(), loop)
try:
    print("success:", fut.result())
except:
    print("exception:", fut.exception())

loop.call_soon_threadsafe(loop.stop)

thread.join()
</code></pre>
<p>However, coroutines that are called using <code>create_task()</code> or <code>ensure_future()</code> will call the exception_handler:</p>
<pre><code>async def coro2():
    print("coro2")
    raise RuntimeError("BOOM2!")


async def coro():
    loop.create_task(coro2())
    print("coro")
    raise RuntimeError("BOOM!")
</code></pre>
<p>You can use this to create a small wrapper:</p>
<pre><code>async def boom(x):
    print("boom", x)
    raise RuntimeError("BOOM!")


async def call_later(coro, *args, **kwargs):
    loop.create_task(coro(*args, **kwargs))
    return "ok"


fut = asyncio.run_coroutine_threadsafe(call_later(boom, 7), loop)
</code></pre>
<p>However, you should probably consider using a <a href="https://docs.python.org/3/library/queue.html" rel="nofollow noreferrer">Queue</a> to communicate with your thread instead.</p>
</div>
<span class="comment-copy">did youraise any error ? <code>asyncio.run_coroutine_threadsafe(run(), loop)</code> you started <code>run function</code> without thread(for function run <code>run != run()</code>)</span>
<span class="comment-copy">@dsgdfg: I'm not quite sure what you mean, but bear in mind that run is a coroutine, so calling run() does not run it.</span>
<span class="comment-copy">Great, thanks Udi. To summarise, it was actually my erroneous call to <code>loop.call_soon_threadsafe(loop.stop, loop)</code> that caused the exception handler to be invoked, and not the <code>run()</code> coroutine. So, <code>asyncio.run_coroutine_threadsafe</code> never seems to cause the exception handler to be invoked.</span>
