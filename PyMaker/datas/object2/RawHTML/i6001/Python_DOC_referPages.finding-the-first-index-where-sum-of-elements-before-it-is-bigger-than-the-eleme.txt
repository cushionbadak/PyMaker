<div class="post-text" itemprop="text">
<p>I have to find the first index where sum of elements up to that index (itself not included) is bigger than the element itself. If there is no such element just return -1. 
My code: </p>
<pre><code>def bigger_sum(numbers):
    tmp_var = 0
    for i in range(len(numbers)):
        tmp_var += numbers[i]
        if tmp_var &gt; numbers[i]:
            return i
        return -1
</code></pre>
<p></p>
<pre><code>[1, 2, 3, 4] =&gt; 3
[1, 2, 3] =&gt; -1
[1, 2] =&gt; -1
</code></pre>
<p>I got correct output only on last two lists <code>-1</code>, but if i try first list the output is empty. What is wrong with the code?</p>
</div>
<div class="post-text" itemprop="text">
<p>Firstly reduce the indentation level of the <code>return -1</code> as you want to do that only once you have iterated over the whole list not for each index.</p>
<p>If you do that your code will look like this:</p>
<pre><code>def bigger_sum(numbers):
    tmp_var = 0
    for i in range(len(numbers)):
        tmp_var += numbers[i]
        if tmp_var &gt; numbers[i]:
            return i
    return -1
</code></pre>
<p>Your code will now return <code>1</code> for all of your test cases since the if condition will always be true on the second iteration of the loop. <em>Can you see why?</em></p>
<p>To fix this issue of the <code>temp_value</code> being prematurely incremented move the <code>tmp_var += numbers[i]</code> line to the bottom of the for loop block:</p>
<pre><code>def bigger_sum(numbers):
  tmp_var = 0
  for i in range(len(numbers)):
    if tmp_var &gt; numbers[i]:
      return i
    tmp_var += numbers[i]
  return -1

print(bigger_sum([1, 2, 3, 4])) # 3
print(bigger_sum([1, 2, 3])) # -1
print(bigger_sum([1, 2])) # -1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You violate your "itself not included" rule by adding to <code>tmp_var</code> before checking<br/><code>tmp_var &gt; numbers[i]</code>.</p>
<p>In addition, you return <code>-1</code> from your function the first time when <code>tmp_var &lt;= numbers[i]</code>. You want the return statement <em>after</em> the loop.</p>
<pre><code>def bigger_sum(numbers):
    tmp_var = 0
    for i, item in enumerate(numbers):
        if tmp_var &gt; item:
            return i
        tmp_var += item
    return -1

print(bigger_sum([1, 2, 3, 4])) # 3
print(bigger_sum([1, 2, 3])) # -1
print(bigger_sum([1, 2])) # -1
</code></pre>
<p>I allowed myself to enhance your code with <code>enumerate</code>, because <code>range(len(numbers))</code> is an atrocity.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the description you need to consider <strong>sum of elements up to that index (itself not included)</strong>, this means that you shouldn't include the value of the current index within the sum of the previous elements. </p>
<p>Here's how to change your code: </p>
<pre><code>def bigger_sum(numbers):
    tmp_var = 0
    for i in range(len(numbers)-1):
        tmp_var += numbers[i]
        # Compare the sum of elements 
        # up to this index, to the next index 
        if tmp_var &gt; numbers[i+1]:
            return i+1
    return -1
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two problems with your code:</p>
<ol>
<li>The increment should happen after the comparison (according to your own stated rules).</li>
<li>The <code>return -1</code> line should happen outside the loop. This may just be a typo on your part.</li>
</ol>
<p>You could remove loops entirely and write a one- liner using <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>itertools.accumulate</code></a> to generate the running sum:</p>
<pre>
from itertools import accumulate

next((i for i, (n, s) in enumerate(zip(numbers, accumulate(numbers))) if 2 * n &lt; s), -1)
</pre>
<p>I use <code>2 * n</code> here because the running sum <code>s</code> includes the current element <code>n</code>. Testing <code>n &lt; s - n</code> is the same as testing <code>2 * n &lt; s</code>.</p>
<p>The return value of <code>-1</code> is provided by the default parameter to <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer"><code>next</code></a>.</p>
<p><a href="https://ideone.com/fIhS6i" rel="nofollow noreferrer">IDEOne link</a></p>
</div>
<span class="comment-copy">your indentation is off on the final return. It's pure coincidence that the last two work.</span>
<span class="comment-copy">An alternative loop phrasing that works better for non-indexable iterables is <code>for i, n in enumerate(numbers):</code>. Use <code>n</code> instead of <code>numbers[i]</code> in this notation.</span>
<span class="comment-copy">I saw in some examples that people use <code>for i, item in enumerate</code>. Is it so much better than to use just  <code>range(len()) </code>?</span>
<span class="comment-copy">@AITs, it's more flexible because some iterables can not be indexed like a list or tuple. Also, once you get used to it, it looks more elegant.</span>
