<div class="post-text" itemprop="text">
<p>Suppose you have a dict like this</p>
<pre><code>dict_h = {'seven': [8, 9, 10]}
</code></pre>
<p>And I want to iterate over it like this</p>
<pre><code>for key, values in dict_h.items():
    for value in values:
        print('key value', key, value)
</code></pre>
<p>Is there any way to do that in one line? I looked through itertools to see if there was something but came up with nothing.</p>
<p>Ideally something like</p>
<pre><code>for key, value in iter_keyvalue(dict_h):
    print('key value', key, value)
</code></pre>
<p>In both cases, I'd want the output to be </p>
<pre><code>"key value seven 8"
"key value seven 9"
"key value seven 10"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a generator expression which does this:</p>
<pre><code>((key, value) for key, values in dict_h.items() for value in values)
</code></pre>
<p>If you use this generator, you have one line:</p>
<pre><code>for key, value in ((key, value) for key, values in dict_h.items() for value in values):
    print('key value', key, value)
</code></pre>
<p>If you need this several times, you can of course build a function out of it:</p>
<pre><code>def iter_keyvalue(d):
    return ((key, value) for key, values in d.iteritems() for value in values)
</code></pre>
<p>and then use it as you suggested.</p>
<p>Note that you can write the function as a generator function on its own:</p>
<pre><code>def iter_keyvalue(d):
    for key, values in d.iteritems():
        for value in values:
            yield key, value
</code></pre>
<p>The first one creates the generator object from a generator expression, the second one is a "proper" generator function which exactly does the same.</p>
<p>Both versions are functionally equivalent. The only visible difference is the generator object's <code>__name__</code>s, which is <code>'&lt;genexpr&gt;'</code> in the first case and <code>'iter_keyvalue'</code> in the second case. This difference is also visible in the <code>repr</code> of the objects.</p>
<p>While the second one looks cleaner, the first one is closer to the OP's request to have only one line.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use a <a href="https://docs.python.org/3.6/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> or a <a href="https://docs.python.org/3/reference/expressions.html#generator-expressions" rel="nofollow noreferrer">generator expression</a> combining the nested loops, e.g:</p>
<pre><code>&gt;&gt;&gt; dict_h = {'seven': [8, 9, 10]}
&gt;&gt;&gt; print(*["key value {} {}".format(k, v) for k, values in dict_h.items() for v in values], sep="\n")
key value seven 8
key value seven 9
key value seven 10
</code></pre>
<p>That said, in code that will have to be maintained, you should really favour <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">readability</a> over brevity.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>dic_h = {'seven': [8, 9, 10]}
</code></pre>
<p>This works for your situation:</p>
<pre><code>print('\n'.join(["Key Value {} {}".format(k, v) for k in dic_h for v in dic_h[k]]))

Key Value seven 8
Key Value seven 9
Key Value seven 10
</code></pre>
<p>This solution make use of a List Comprehension.</p>
<p>More info on List Comprehensions <a href="http://www.pythonforbeginners.com/basics/list-comprehensions-in-python" rel="nofollow noreferrer">here</a>, <a href="http://www.secnetix.de/olli/Python/list_comprehensions.hawk" rel="nofollow noreferrer">here</a>, and <a href="https://duckduckgo.com/?q=python%20list%20comprehension&amp;atb=v19&amp;ia=web" rel="nofollow noreferrer">here</a>.</p>
<p>Also, Google <code>str.join</code> if it's new to you.</p>
</div>
<div class="post-text" itemprop="text">
<p>One line would be:</p>
<pre><code>for key, value in ((key, value) for key, values in dict_h.items() for value in values): print('key, value', key, value)
</code></pre>
</div>
<span class="comment-copy">You can, but remember that in most cases, you should consider readability over reducing some lines,</span>
<span class="comment-copy">istead of <code>return</code> you should be having <code>yield</code> to keep it working as a generator.</span>
<span class="comment-copy">And it is actually not working. Should be <code>yield ((key, value) for key, values in d.items() for value in values)</code></span>
<span class="comment-copy">@Ev.Kounis Indeed it did not work, but not because of a missing <code>yield</code>, but because of missing parentheses in the generator expression. A generator expression is another valid approach to create a generator object. Nevertheless I now show two alternatives to create this function.</span>
<span class="comment-copy">Instead of a List Comprehension, it would have been enough to use a generator expression. Looks nearly the same, but has a possible difference on the running time and memory consumption.</span>
<span class="comment-copy">@glglgl It probably would be faster.</span>
<span class="comment-copy">@glglgl I actually timed both using the timeit module. There was virtually no difference, but if anything, the list comprehension version tended to be faster(we're talking by 0.01/0.02 s)... which I didn't expect. Perhaps that's an anomaly, but either way, they were virtually identical with this tiny amount of data.</span>
<span class="comment-copy">That's kind of a fake "one line" though ;)</span>
<span class="comment-copy">You are right. But it still counts. ;-)</span>
<span class="comment-copy">@mrCarnivore it is not working properly though.. Did you run it?</span>
<span class="comment-copy">@Ev.Kounis: Can you provide an example?</span>
<span class="comment-copy">@Ev.Kounis: Not the most understandable complaint since I did run it before I posted it. However, after rereading the question you are right and I misread the request and have modified my answer to reflect that.</span>
