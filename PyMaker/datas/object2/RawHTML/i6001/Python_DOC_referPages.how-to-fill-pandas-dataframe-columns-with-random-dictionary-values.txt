<div class="post-text" itemprop="text">
<p>I'm new to Pandas and I would like to play with random text data. I am trying to add 2 new columns to a DataFrame df which would be each filled by a key (newcol1) + value (newcol2) randomly selected from a dictionary. </p>
<pre><code>countries = {'Africa':'Ghana','Europe':'France','Europe':'Greece','Asia':'Vietnam','Europe':'Lithuania'}
</code></pre>
<p>My df already has 2 columns and I'd like something like this :</p>
<pre><code>    Year Approved Continent    Country
0   2016      Yes    Africa      Ghana
1   2016      Yes    Europe  Lithuania
2   2017       No    Europe     Greece
</code></pre>
<p>I can certainly use a for or while loop to fill df['Continent'] and df['Country'] but I sense .apply() and np.random.choice may provide a simpler more pandorable solution for that. </p>
</div>
<div class="post-text" itemprop="text">
<p>Yep, you're right. You can use <code>np.random.choice</code> + <code>map</code>:</p>
<pre><code>df

    Year Approved
0   2016      Yes
1   2016      Yes
2   2017       No

df['Continent'] = np.random.choice(list(countries), len(df))
df['Country'] = df['Continent'].map(countries)

df

    Year Approved Continent    Country
0   2016      Yes    Africa      Ghana
1   2016      Yes      Asia    Vietnam
2   2017       No    Europe  Lithuania
</code></pre>
<p>You choose <code>len(df)</code> number of keys at random from the <code>country</code> key-list, and then use the <code>country</code> dictionary as a mapper to find the country equivalents of the previously picked keys.</p>
<hr/>
<p>For the second step of replacement, <code>pd.Series.replace</code> also works:</p>
<pre><code>df['Country'] = df.Continent.replace(countries)

df

    Year Approved Continent    Country
0   2016      Yes    Africa      Ghana
1   2016      Yes      Asia    Vietnam
2   2017       No    Europe  Lithuania
</code></pre>
<hr/>
<p>For the sake of completeness, you can also use <code>apply</code> + <code>dict.get</code>:</p>
<pre><code>df['Country'] = df.Continent.apply(countries.get)

df

    Year Approved Continent    Country
0   2016      Yes    Africa      Ghana
1   2016      Yes      Asia    Vietnam
2   2017       No    Europe  Lithuania
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also try using <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.sample.html#pandas-dataframe-sample" rel="nofollow noreferrer"><code>DataFrame.sample()</code></a>:</p>
<pre><code>df.join(
    pd.DataFrame(list(countries.items()), columns=["continent", "country"])
    .sample(len(df), replace=True)
    .reset_index(drop=True)
)
</code></pre>
<p>Which can be made faster if your continent-country map is already a dataframe.</p>
<hr/>
<p>If you're on Python 3.6, another method would be to use <a href="https://docs.python.org/3/library/random.html#random.choices" rel="nofollow noreferrer"><code>random.choices()</code></a>:</p>
<pre><code>df.join(
    pd.DataFrame(choices([*countries.items()], k=len(df)), columns=["continent", "country"])
)
</code></pre>
<p><code>random.choices()</code> is similar to <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.random.choice.html#numpy-random-choice" rel="nofollow noreferrer"><code>numpy.random.choice()</code></a> except that you can pass a list of key-value tuple pairs whereas <code>numpy.random.choice()</code> only accepts 1-D arrays.</p>
</div>
<span class="comment-copy">Brilliant ! I thought I had to go in one go, I now understand the various 2-step mapping options.</span>
<span class="comment-copy">@ozaarm keep in mind that with every version older than 3.6, you need a two step solution. To do it in a single step on python3.6, you can use random.choices as the other answer shows, but speed would still be a concern of mine then.</span>
