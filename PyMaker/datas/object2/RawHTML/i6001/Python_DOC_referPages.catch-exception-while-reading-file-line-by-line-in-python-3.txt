<div class="post-text" itemprop="text">
<p>Consider the following code:</p>
<pre><code>with open('file.txt', 'r') as f:
    for line in f:
        print(line)
</code></pre>
<p>In Python 3, the interpreter tries to decode the strings it reads, which might lead to exceptions like <code>UnicodeDecodeError</code>. These can of course be caught with a <code>try ... except</code> block around the whole loop, but I would like to handle them on a per-line basis.</p>
<p><strong>Question:</strong> Is there a way to directly catch and handle exceptions for each line that is read? Hopefully without changing the simple syntax of iterating over the file too much?</p>
</div>
<div class="post-text" itemprop="text">
<p>The Pythonic way is probably to register an error handler with <code>codecs.register_error_handler('special', handler)</code> and declare it in the open function:</p>
<pre><code>with open('file.txt', 'r', error='special') as f:
    ...
</code></pre>
<p>That way if there is an offending line, the <code>handler</code> will the called with the <code>UnicodeDecodeError</code>, and will be able to return a replacement string or re-raise the error.</p>
<p>If you want a more evident processing, an alternate way would be to open the file in binary mode and explicitely decode each line:</p>
<pre><code>with open('file.txt', 'rb') as f:
    for bline in f:
        try:
            line = bline.decode()
            print(line)
        except UnicodeDecodeError as e:
            # process error
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Instead of employing a <code>for</code> loop, you could call <code>next</code> on the file-iterator yourself and catch the <code>StopIteration</code> manually.</p>
<pre><code>with open('file.txt', 'r') as f:
    while True:
        try:
            line = next(f)
            # code
        except StopIteration:
            break
        except UnicodeDecodeError:
            # code
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Place your try-except catch inside the for loop, like so:</p>
<pre><code>with open('file.txt', 'r') as f:
    for line in f:
      try:  
        print(line)
      except:
        print("uh oh")
        # continue
</code></pre>
</div>
<span class="comment-copy">why not putting the try after the open and before the "for line in f"??</span>
<span class="comment-copy">Sorry if I did not clarify what I am after here: I want to be able to go on with reading the file even if one of the lines leads to an exception.</span>
<span class="comment-copy">You can supply an <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer"><code>errors</code> arg to open</a>. If your data is really bad, maybe you should open it in binary mode and decode each line explicitly, although that's slower.</span>
<span class="comment-copy">s when you catch your exception just print it out and write "continue" - and it will without doing anything else , and continue to the next line</span>
<span class="comment-copy">Python is free to decode in blocks (in a buffer), so this is not necessarily going to skip just single lines.</span>
<span class="comment-copy">@MartijnPieters Interesting, didn't know that.</span>
<span class="comment-copy">it is probably the <code>for line in f:</code> that raises it, that's why</span>
<span class="comment-copy">The <code>for</code> loop is the culprit of calling <code>f.__next__</code> so that's where the error happens. It's too late when we're inside the loop body.</span>
<span class="comment-copy">Ah, gotcha. I like your suggested solution in that case @timgeb.</span>
