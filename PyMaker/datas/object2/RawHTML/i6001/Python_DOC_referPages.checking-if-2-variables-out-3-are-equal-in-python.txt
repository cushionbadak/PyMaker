<div class="post-text" itemprop="text">
<p>I am making a code where three dice are rolled and if all three dice are equal the values are added. If 2 of the dice are equal then the 2 equal dice values are added and the odd dice value is subtracted from the sum.</p>
<p>This is my code so far</p>
<pre><code>import random

d1 = random.randint(1,6)
d2 = random.randint(1,6)
d3 = random.randint(1,6)

print(d1)
print(d2)
print(d3)

if d1 == d2 and d2 == d3:
    score = d1 + d2 + d3
elif d1 == d2 or d1 == d3 or d2 == d3:
</code></pre>
<p>Now I don't know how I would find out which of the 2 dice are equal to be able to add them together. How would I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use a sequence of <code>if-statements</code>:</p>
<pre><code>if d1 == d2:
    if d2 == d3:
        score = d1 + d2 + d3
    else:
        score = (d1 + d2) - d3
elif d2 == d3:
    score = (d2 + d3) - d1
elif d1 == d3:
    score = (d1 + d3) - d2
else:
    score = 0
</code></pre>
<p><em>The brackets aren't necessary, just make it a bit clearer</em></p>
</div>
<div class="post-text" itemprop="text">
<p>I might use <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow noreferrer"><code>collections.Counter</code></a> for this.</p>
<p>A <code>Counter</code> is a <code>dict</code> subclass that counts objects. In the resulting dictionary, the keys are the objects being counted while the values are the number of times those objects appear.</p>
<p>We can create a count of dice rolls by passing a list of the results of <code>random.randint()</code> to <code>Counter</code>'s constructor, like so:</p>
<pre><code>Counter(random.randint(1,6) for _ in range(3)) # 3 6-sided rolls
</code></pre>
<p>In addition to accessing the counts via <code>dict</code>'s <code>[]</code> operator, we can also access them via <code>Counter.most_common()</code>, which returns a list containing all of the rolls and their associated counts.</p>
<p>In our program, <code>rolls[0]</code> is the most common roll and its count, <code>rolls[0][0]</code> is the value of the roll, <code>rolls[0][1]</code> is the number of times it was rolled. Similarly, <code>rolls[1][0]</code> is the second-most common value.</p>
<pre><code>import random
from collections import Counter

rolls = Counter(random.randint(1,6) for _ in range(3)).most_common()

if len(rolls) == 1:
    score = rolls[0][0] * 3
elif len(rolls) == 2:
    score = rolls[0][0] * 2 - rolls[1][0]
else:
    score = 0

print (rolls, score)
</code></pre>
<p>You haven't specified what the correct score is when there are no matches. The above algorithm gives a score of <code>0</code> if there are no matches.</p>
<p>Here is another algorithm which scores the negative sum of all the dice if there are no matches. In essence, it adds up all of the matching dice and subtracts each singleton die. This gives the answer you request for each of the cases you describe but punishes non-matching rolls more severely. Notice how this version generalizes easily to different numbers of dice and different numbers of sides.</p>
<pre><code>import random
from collections import Counter

rolls = Counter(random.randint(1, 6) for _ in range(3)).most_common()

score = sum(roll[0] * (-1 if roll[1]==1 else 1) * roll[1] for roll in rolls)

print(rolls, score)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using sets is probably the most elegant solution to determine <em>if</em> you have a repeat, but it does not tell you which element repeats.</p>
<p>You could maintain all your dice in a list:</p>
<pre><code>d = [random.randint(1,6) for _ in range(3)]
</code></pre>
<p>You can sort the list. If all the elements are the same, the first and last value will match. If there is a repeat, the middle element will match either the first or the last one:</p>
<pre><code>d.sort()
if d[0] == d[2]:
    score = sum(d)
elif d[0] == d[1]:
    score = d[0] + d[1] - d[2]
elif d[1] == d[2]:
    score = d[1] + d[2] - d[0]
else:
    score = 0
</code></pre>
</div>
<span class="comment-copy">should anything happen if all the values are different?</span>
<span class="comment-copy">Is there any distinction between the dice?</span>
<span class="comment-copy">When all three are different then <code>score = 0</code> @timgeb</span>
<span class="comment-copy">All three dice are the same @MadPhysicist</span>
<span class="comment-copy">What exactly do you mean by "previous sum". Do you mean another sum, or the one of the two numbers?</span>
<span class="comment-copy">You missed the case where <code>d1 == d3</code> and <code>d2</code> is different.</span>
<span class="comment-copy">@leekaiinthesky Sorry about that!</span>
<span class="comment-copy">Can you provide a little bit of additional clarification? Newbies (like myself) may get stuck in parts. I was able to follow along since I've used counters, but OP may be unfamiliar.</span>
<span class="comment-copy">Yes I don't know how the counter works</span>
<span class="comment-copy">OP later clarified that the sum is indeed zero for no matches. Good guess.</span>
<span class="comment-copy">For posterity: 2nd example can return 0 like so: <code>if rolls[0][1] == 1: score = 0</code> / <code>else: score=sum(...)</code></span>
<span class="comment-copy">This will cause an error. Where is <code>prev</code> coming from? And how is it influencing the score?</span>
<span class="comment-copy">@PauloAlmeida. <code>prev</code> is a placeholder for the "previous" sum OP is referring to in the question. I will fix as soon as OP has responded to my request for clarification.</span>
<span class="comment-copy">@PauloAlmeida. Fixed</span>
<span class="comment-copy">Ok, I see. I like your solution, because of the sort. It's similar to the accepted one but with less need for logic. I was wondering if it would be possible to come up with an elegant generic solution (for any number of dice), but that's a different question (and it would need additional conditions to decide what to sum and subtract).</span>
<span class="comment-copy">@PauloAlmeida. This is probably the first step. The second step would be to determine what you want to do with matches. In either case, Rob's solution is infinitely more flexible that this one since it computes a proper histogram.</span>
