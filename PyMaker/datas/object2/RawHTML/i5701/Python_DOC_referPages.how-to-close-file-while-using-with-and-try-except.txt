<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/3774328/implementing-use-of-with-object-as-f-in-custom-class-in-python">Implementing use of 'with object() as f' in custom class in python</a>
<span class="question-originals-answer-count">
                    3 answers
                </span>
</li>
</ul>
</div>
<p>I wrote this example to show myself that <code>__exit__</code> is not being run when an exception occurs:</p>
<pre><code>class A(object):
    def __enter__(self):
        print('enter')
    def __exit__(self):
        print('exit')
try:
    with A() as a:
        raise RunTimeError()
except Exception as e:
    print('except')
</code></pre>
<p>Output:</p>
<pre><code>enter
except
</code></pre>
<p>That said, what is the correct way to use a <code>with</code> statement and catch exceptions, while making sure <code>__exit__</code> is being run in the end?
Thanks!</p>
</div>
<div class="post-text" itemprop="text">
<p>The <strong><code>__exit__</code> function is called</strong>, regardless whether the <code>with</code> body raises errors or not. Your function needs to have additional parameters <code>exc_type</code> (the type of the exception), <code>exc_value</code> (the exception object), and <code>traceback</code> (the traceback that is generated).</p>
<p>In case the <code>with</code> body did <em>not</em> raise an <code>Error</code>, the three parameters are <code>None</code>. In case there is an error, they take the values described above.</p>
<p>But you can for instance close a file, regardless whether there is an error and then later handle the error.</p>
<p>So we can here implement it for instance as:</p>
<pre><code>class A(object):
    def __enter__(self):
        <b>self.file = open('some_file.txt')</b>
        <b>return self.file</b>

    def __exit__(self<b>, exc_type, exc_value, traceback</b>):
        <b>print(('exit', exc_type, exc_value, traceback))</b>
        # close the file, regardless of exceptions
        <b>self.file.close()</b>
        <b>return False</b>  # silence the exception?</code></pre>
<p>If we now write something like:</p>
<pre><code>with A():
    raise Exception
</code></pre>
<p>We will obtain the exception, the <code>__exit__</code> function will print:</p>
<pre><code>('exit', &lt;class 'Exception'&gt;, Exception(), &lt;traceback object at 0x7fc512c924c8&gt;)
</code></pre>
<p>We can inspect the exception class, exception value and traceback, and handle accordingly. For instance based on the exception, we might decide to close a file, send a bug report, abort the SQL transaction or not.</p>
<p>The <code>__exit__</code> function also has a return value (if not specified, a Python function returns <code>None</code>). In case the <code>__exit__</code> function returns an object with <em>truthiness</em> <code>True</code>, it will <em>surpress</em> the exception: the exception will not raise out of the <code>with</code> block. Otherwise it will be raised out of the <code>with</code> block. For instance in our example, we still receive the exception.</p>
<pre><code>class SilenceExceptions(object):
    def __enter__(self):
        pass

    def __exit__(self<b>, exc_type, exc_value, traceback</b>):
        <b>return True</b>  # silence ALL exceptions</code></pre>
<p>If we now call:</p>
<pre><code>with SilenceExceptions():
    raise Error
</code></pre>
<p>we will not see the exception, since it is "<em>catched</em>" in the <code>__exit__</code> function.</p>
</div>
<span class="comment-copy">The errors first pass through <code>__exit__</code> your <code>__exit__</code> functions needs to have parameters <code>exc_type, exc_value, traceback</code> (<a href="https://docs.python.org/3/reference/datamodel.html#object.__exit__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__exit__</a>).</span>
<span class="comment-copy">maybe this helps you <a href="https://stackoverflow.com/questions/713794/catching-an-exception-while-using-a-python-with-statement" title="catching an exception while using a python with statement">stackoverflow.com/questions/713794/â€¦</a></span>
<span class="comment-copy">BTW, that code does not actually raise a <code>RuntimeError</code> but a <code>NameError</code> :-P</span>
<span class="comment-copy">@tobias_k: <code>__exit__</code> is called, but it results in a <code>TypeError</code> (since the  parameters do not match) and that type error is then handled in the <code>except</code> block.</span>
<span class="comment-copy">@WillemVanOnsem Ah, of course, that makes sense. Lesson learned: Never just print "except" without showing the cause.</span>
<span class="comment-copy">Thanks. That said, would you say, in this case, that my try-with structure is the correct and usual way of doing this? (And not, for example, with the try-with order reversed)?</span>
<span class="comment-copy">That depends whether you want to catch exceptions <i>within</i> the block. For instance if you process a file, and you want to ignore the lines that fail to parse, the <code>try:</code> should be placed in the <code>with:</code> (and in a <code>for</code> loop in the <code>with</code>). In case you want to close the context if the error raises, then it is common to place the <code>with</code> in the <code>try</code>. Since you then offer the context amanger the change to solve the problem at context level.</span>
