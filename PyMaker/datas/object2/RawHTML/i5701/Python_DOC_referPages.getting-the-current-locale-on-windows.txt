<div class="post-text" itemprop="text">
<h2>Context</h2>
<p><em>Getting</em> the locale with python on Windows seems to be broken:</p>
<pre class="lang-none prettyprint-override"><code>(trash0) PS C:\Users\myname\venv\trash0\Lib\site-packages&gt; python.exe
Python 3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 17:26:49) [MSC v.1900 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.platform
'win32'
&gt;&gt;&gt; import locale
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'fr-FR')
'fr-FR'
&gt;&gt;&gt; locale.getlocale()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "C:\Program Files\Python36-32\lib\locale.py", line 581, in getlocale
    return _parse_localename(localename)
  File "C:\Program Files\Python36-32\lib\locale.py", line 490, in _parse_localename
    raise ValueError('unknown locale: %s' % localename)
ValueError: unknown locale: fr-FR
&gt;&gt;&gt;
</code></pre>
<p>I do not know much about Windows but I have checked <code>fr-FR</code> belongs to <a href="https://msdn.microsoft.com/en-us/library/cc233982.aspx" rel="nofollow noreferrer">the correct locale names for Windows</a>. Note that using <code>en-US</code> or <code>en-GB</code> get the same result.</p>
<p>Yet <em>setting</em> the locale works correctly because:</p>
<ul>
<li>using <code>locale.setlocale()</code> with any unknown value would raise an exception:</li>
</ul>
<pre class="lang-none prettyprint-override"><code>    &gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'anythingundefined')
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
      File "C:\Program Files\Python36-32\lib\locale.py", line 598, in setlocale
        return _setlocale(category, locale)
    locale.Error: unsupported locale setting
    &gt;&gt;&gt;
</code></pre>
<ul>
<li>once set, it's possible to check it is taken into account:</li>
</ul>
<pre class="lang-none prettyprint-override"><code>    &gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'fr-FR')
    'fr-FR'
    &gt;&gt;&gt; locale.str(12.3)
    '12,3'
    &gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'en-GB')
    'en-GB'
    &gt;&gt;&gt; locale.str(12.3)
    '12.3'
    &gt;&gt;&gt;
</code></pre>
<h2>Question</h2>
<p>I need to <em>temporarily</em> set the locale to <code>en-US</code> (in order to perform some things that require this locale) and then switch back to the default locale. How is it possible to do it if <code>locale.getlocale()</code> is broken? I've read the <a href="https://docs.python.org/3/library/locale.html" rel="nofollow noreferrer">python doc about locale</a> but can't figure out any workaround to achieve this (nor whether it is possible at all).</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's how to monkey patch the <code>locale</code> module as I was trying to describe in my comments under your question.</p>
<p>First the monkey-patching module, <code>locale_patch.py</code>:</p>
<pre><code>""" Module that monkey-patches the locale module so it remembers the last
arguments to setlocale() that didn't raise an exception and will allow them to
be retrieved later by calling a new function named setting_values() which also
gets added.
"""
import locale as _locale

_last_category, _last_locale = None, None

def my_setlocale(category, locale=None):
    global _last_category, _last_locale

    try:
        result = _orig_setlocale(category, locale)
    except _locale.Error:
        raise  # Didn't work, ignore arguments.

    if locale is not None:  # Was a setting modified by call?
        _last_category, _last_locale = category, locale  # Remember args.

    return result

def setting_values():
    global _last_category, _last_locale

    if _last_category is None:
        raise _locale.Error('setlocale() has never been called to change settings')

    return _last_category, _last_locale


# Monkey-patch the module.
_orig_setlocale = _locale.setlocale
_locale.setlocale = my_setlocale
_locale.setting_values = setting_values  # New module function.
</code></pre>
<p>Sample usage:</p>
<pre><code>import locale
import locale_patch  # Apply monkey-patch(es).

try:
    locale.setlocale(locale.LC_ALL, 'fr_FR.UTF-8') # locale.Error: unsupported locale setting
except locale.Error:
    print("locale.setlocale(locale.LC_ALL, 'fr_FR.UTF-8') didn't work")
try:
    print(locale.setting_values())
except locale.Error:
    print("locale.setting_values() didn't work")  # Expected.

try:
    locale.setlocale(locale.LC_ALL, locale='fr_FR.UTF-8')
except locale.Error:
    print("locale.setlocale(locale.LC_ALL, locale='fr_FR.UTF-8') didn't work")
try:
    print(locale.setting_values())
except locale.Error:
    print("locale.setting_values() didn't work")  # Expected.

locale.setlocale(locale.LC_ALL, 'fr-FR')
results = locale.setting_values()
print(results)  # -&gt; (0, 'fr-FR')  # The 0 is the numeric value of locale.LC_ALL

locale.setlocale(*results)  # Works OK.
</code></pre>
</div>
<span class="comment-copy">You could monkey-patch the <code>locale</code> module and replace <code>setlocale()</code> with your own function that remembered the last locale successfully set, and likewise replace <code>getlocale()</code> with a function that uses that saved value if there is one.</span>
<span class="comment-copy"><code>locale.getlocale</code> hasn't been updated to support parsing Windows locale names that are delimited by a hyphen (e.g. "fr-FR"). These names are based on RFC 4646 language tags. They were introduced in Vista, along with many new NLS functions that use locale names instead of LCIDs.</span>
<span class="comment-copy">You can use the legacy C runtime locale strings that are delimited by an underscore. These use 3-letter abbreviations such as "FRA_FRA[.codepage]" or "ENU_USA.[codepage]", or long names such as "French_France[.codepage]" or "English_United States[.codepage]". The optional codepage is the numeric identifier of a legacy codepage, such as "ENU_USA.1252".</span>
<span class="comment-copy">@martineau Thanks for your suggestion! I've been thinking about it but I think I'm still stuck in the same place: I cannot figure out how a monkey-patched version of <code>getlocale()</code> could find out to which value the user <i>may</i> have set the locale previously (before calling my library's functions at all).</span>
<span class="comment-copy">@eryksun Thanks for these precious informations! I have been thinking that maybe it would be up to the user to choose a working value, after all. If the user sets its locale to <code>fra_fra</code>, <code>getlocale()</code> does not raise an exception. Only problem then is, the value it returns cannot be used by <code>setlocale()</code>, so it's not possible to set the locale back to a usable value, <i>unless</i> it would be possible to use a kind of conversion table that would let e.g. <code>fra_fra</code> match the value returned by <code>getlocale()</code>. I couldn't find the list of legacy codes, is there any web page that still lists them?</span>
<span class="comment-copy">Many thanks, this is very clear and actually not as complicated as I thought would be. If I understand everything well, I do <code>import locale_patch</code> in the <code>__init__.py</code> of my library and this will cause importing of my library to automatically patch the locale. Then the only situation where <code>RuntimeError</code> may be inappropriately raised is if the user sets the locale <i>before</i> importing my library, what looks like not really good code (import statements should be at start of code).</span>
<span class="comment-copy">There's a small error to fix in the code of your answer: using <code>locale</code> as keyword argument of <code>my_setlocale()</code> locally overrides <code>locale</code> and in case of an error raised by the original <code>setlocale()</code> then instead of raising it further, the expression <code>locale.Error</code> raises itself an exception (to complain that <code>str</code> does not have an <code>Error</code> attribute). I renamed this keyword to <code>value</code> and everything works fine.</span>
<span class="comment-copy">@zezollo: Good catch. It was that way because I just copied what's shown in the <a href="https://docs.python.org/3/library/locale.html#locale.setlocale" rel="nofollow noreferrer">current documentation</a>—which of course isn't "real" code. FWIW, in my update I renamed it <code>locale_name</code> only because it's a little more descriptive than simply <code>value</code>. <code>;¬)</code></span>
<span class="comment-copy">Well my correction is not as good as it looked like, because <code>locale</code> is <i>indeed</i> used as keyword in the original <code>setlocale()</code> (as in the doc...), so the patch fails on calls that were correct with the original <code>setlocale</code>, like <code>setlocale(locale.LC_ALL, locale='fr_FR.UTF-8')</code> (that raise <code>TypeError: my_setlocale() got an unexpected keyword argument 'locale'</code>).</span>
<span class="comment-copy">Sorry for the delay. Your solution (<code>import locale as _locale</code> and related changes) is simple, looks best and works fine on both Linux and Windows (sorry for this <code>fr_FR.UTF-8</code>, that can be used on Linux only). Many thanks! And a happy new year!</span>
