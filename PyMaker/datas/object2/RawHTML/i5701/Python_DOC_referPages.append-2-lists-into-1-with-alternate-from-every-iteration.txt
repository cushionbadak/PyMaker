<div class="post-text" itemprop="text">
<p>I have 2 lists </p>
<pre><code>W = ['w1', 'w2'] 
D = [1,2,3,4,5,6]
</code></pre>
<p>I want to iterate over them such that I get a final list </p>
<pre><code>final = [ [' w1',  1],  ['w2', 2], ['w1', 3], ['w2', 4], ['w1', 5], ['w2', 6]]  
</code></pre>
<p>(in the same order) </p>
<p>I was trying to iterate over <code>W</code> and <code>D</code></p>
<pre><code>for i in W:
    for j in D:
        if j % 2 == 1 and i == 'w1' :
            final. append ([i, j] 
</code></pre>
<p>my logic was to divide by %2 to find whether it is odd or even, but it's not working.  </p>
</div>
<div class="post-text" itemprop="text">
<p>you mean this?</p>
<pre><code>[['w1' if i%2==1 else 'w2',i ] for i in D]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle</code></a> and <a href="https://docs.python.org/3.6/library/functions.html#zip" rel="nofollow noreferrer"><code>zip</code></a>.</p>
<pre><code>&gt;&gt;&gt; from itertools import cycle
&gt;&gt;&gt; W = ['w1', 'w2'] 
&gt;&gt;&gt; D = [1,2,3,4,5,6]
&gt;&gt;&gt; list(x for x in zip(cycle(W), D))
[('w1', 1), ('w2', 2), ('w1', 3), ('w2', 4), ('w1', 5), ('w2', 6)]
</code></pre>
<p>Those elements are tuples if that reeeally matters then we can add a stage to map them to list.</p>
<p>To explain it a little, <code>cycle</code> creates an infinite iterable of the values passed to it. So by itself that would go on forever yielding 'w1', 'w2', 'w1', 'w2' and so on. Then we can use zip, to combine it with <code>D</code> which has finite length and so allows the sequence to end.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>W = ['w1', 'w2'] 
D= [1,2,3,4,5,6]
new_d = [[W[0], a] if i%2 ==0 else [W[1], a] for i, a in enumerate(D)]
</code></pre>
<p>Output:</p>
<pre><code>[['w1', 1], ['w2', 2], ['w1', 3], ['w2', 4], ['w1', 5], ['w2', 6]]
</code></pre>
<p>Or, for a more generic solution:</p>
<pre><code>new_d = [[W[i%len(W)], a] for i, a in enumerate(D)]
</code></pre>
<p>Output:</p>
<pre><code>[['w1', 1], ['w2', 2], ['w1', 3], ['w2', 4], ['w1', 5], ['w2', 6]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try this:</p>
<pre><code>W = ['w1', 'w2'] 
D= [1,2,3,4,5,6]
final = []

for i in range(len(D)):
    if i%2 == 0:
        final.append([W[0], D[i]])
    else:
        final.append([W[1], D[i]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>final = [ [W[i%len(W)], x]for i,x in enumerate(D)]
</code></pre>
<p>output:</p>
<pre><code>[['w1', 1], ['w2', 2], ['w1', 3], ['w2', 4], ['w1', 5], ['w2', 6]]
</code></pre>
<p>Use my code:
you don't need consider the length of W,D. it's more effieient and elengent</p>
</div>
<div class="post-text" itemprop="text">
<p>Why not just use the modulus itself?</p>
<pre><code>for i, d in enumerate(D):
    final.append([ W[i % len(W)], d ])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to import any module , Here is recursive approach :</p>
<pre><code>W = ['w1', 'w2']
D= [1,2,3,4,5,6]

def recur(one,second):
    if not second:
        return 0
    else:

        for k in zip(second[:len(one)],one):
            print(k)

        return recur(one,second[len(one):])

print(recur(W,D))
</code></pre>
<p>output:</p>
<pre><code>(1, 'w1')
(2, 'w2')
(3, 'w1')
(4, 'w2')
(5, 'w1')
(6, 'w2')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could try this solution:</p>
<pre><code>W = ['w1', 'w2'] 
D= [1,2,3,4,5,6]

result = [[W[D.index(x) % len(W)], x] for x in D]

print(result)
# [['w1', 1], ['w2', 2], ['w1', 3], ['w2', 4], ['w1', 5], ['w2', 6]]
</code></pre>
<p>Which obtains the index of each element in <code>D</code> and mods it. This is the most straightforward approach, with different variations shown in other answers. </p>
<p>Another approach is to create an iterator with <a href="https://docs.python.org/3.6/library/itertools.html#itertools.cycle" rel="nofollow noreferrer"><code>itertools.cycle()</code></a>, and alternate between <code>'w1'</code> and <code>'w2'</code> consecutively with <a href="https://docs.python.org/3.3/library/functions.html#next" rel="nofollow noreferrer"><code>next()</code></a>:</p>
<pre><code>from itertools import cycle

W = ['w1', 'w2'] 
D= [1,2,3,4,5,6]

iterator = cycle(W)

result = [[next(iterator), x] for x in D]

print(result)
# [['w1', 1], ['w2', 2], ['w1', 3], ['w2', 4], ['w1', 5], ['w2', 6]]
</code></pre>
<p>The benefit of the second approach is that it uses <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow noreferrer">Lazy evaluation</a>. You also don't have to worry about any indices, just the lists themselves. </p>
</div>
<div class="post-text" itemprop="text">
<p><code>zip</code> enough copies of <code>W</code> to cover <code>D</code> with <code>D</code>, unpack into sublists</p>
<pre><code>W = ['w1', 'w2', 'y~'] 
D= [1,2,3,4,5,6]

[[*a] for a in zip(W*(len(D)//len(W) + 1), D)]

Out[106]: [['w1', 1], ['w2', 2], ['y~', 3], ['w1', 4], ['w2', 5], ['y~', 6]]
</code></pre>
</div>
