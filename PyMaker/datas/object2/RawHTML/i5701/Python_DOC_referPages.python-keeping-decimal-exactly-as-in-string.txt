<div class="post-text" itemprop="text">
<p>I'm new to Python, and I have an issue with decimals and can't figure out for a few hours already how to solve it. Basically I want to read CSV file with pandas and keep the decimals exactly as they are stored in text, for future comparisons and simple math operations.
So here's what I have on the input:  </p>
<pre><code>is_string_dtype(report['item_weight_kg'])
Out[12]: True
l = report.loc[report['item'] == 'B0WY']
num1 = l['item_weight_kg'][8210]

num1
Out[14]: '22.000370049504'
</code></pre>
<p>then I am trying to convert them to float, which gives me the value which ends with <strong>3999</strong> insead of <strong>4</strong></p>
<pre><code>report['item_weight_kg'] = report.apply(lambda x: float(x['item_weight_kg']), axis = 1 )

l = report.loc[report['item'] == 'B0WY']
num1 = l['item_weight_kg'][8210]

num1
Out[17]: 22.000370049503999
</code></pre>
<p>right after importing the dataset, I've tried to convert it to float, and in console it works properly, returns me the desired value, but when I am trying to apply it to the whole dataset, it doesn't</p>
<pre><code>float(decimal.Decimal(l['item_weight_kg'][8210]))
Out[23]: 22.000370049504

report['item_weight_kg'] = report.apply(lambda x: float(decimal.Decimal(x['item_weight_kg'])), axis = 1 )    
l = report.loc[report['item'] == 'B0WY']
num1 = l['item_weight_kg'][8210]

num1
Out[25]: 22.000370049503999
</code></pre>
<p>does anyone have an idea how this can be solved? I've been trying to google, but couldn't find a solution.</p>
<p>Thanks a lot.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have some good and bad news for you.
<br/>
The bad news is that in python:<br/>
<code>0.1 + 0.2</code> will give you <code>0.30000000000000004</code>
<br/>
And <code>0.1 + 0.2 == 0.3</code> will give <code>False</code>.
<br/>
This is not just in python. This phenomena occurs in very large number of programming languages. In fact, there is a whole website dedicated to it! : <a href="https://0.30000000000000004.com/" rel="nofollow noreferrer">https://0.30000000000000004.com/</a>
<br/>
You can read more about this in the official python docs, <a href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="nofollow noreferrer">here</a>.
<br/>
The thing is, dealing with floats is tricky, especially when you try to do exact math (i.e. equality) just like your case.
<br/>
<strong>Never expect exact math when dealing with floats!</strong>
<br/>
Instead, when you try to check to floats for equality, you check if they are <strong>very close</strong> to each other.
Python 3.5+ provides this functionality (<a href="https://docs.python.org/3/whatsnew/3.5.html#pep-485-a-function-for-testing-approximate-equality" rel="nofollow noreferrer">see here</a>), and you can implement one yourself.
<br/>
A simple float equality comparison goes like this:</p>
<pre><code>epsilon = 0.0000001 # the smallest acceptable precision error
def float_equals(a,b):
    return abs(a-b) &lt;= epsilon
</code></pre>
<p>But what if we want more precision than what standard python offers?
<br/>
In that case you can use an arbitrary precision library, like <a href="http://mpmath.org/" rel="nofollow noreferrer">mpmath</a>. That's the good news (maybe, idk).</p>
</div>
<div class="post-text" itemprop="text">
<p>Normally I'd use print formatting for strings or the round function.</p>
<p><a href="https://docs.python.org/3/library/functions.html?highlight=round#round" rel="nofollow noreferrer">https://docs.python.org/3/library/functions.html?highlight=round#round</a></p>
<p>Because you are using decimal you might meet your requirements by altering precision </p>
<p><a href="https://docs.python.org/3/library/decimal.html?highlight=round" rel="nofollow noreferrer">https://docs.python.org/3/library/decimal.html?highlight=round</a></p>
</div>
<span class="comment-copy">You can format strings of floats of desired precision using %.2f for 2 digits after a decimal</span>
<span class="comment-copy">I can't do that because later(in this record example) I need to compare 22.000370049504 to 22.000370049504003, and precision reduction will equalize the results. moreover in the dataset I have numbers with different quantity of digits after decimal.</span>
<span class="comment-copy">Are you aware that <code>22.000370049503999</code> and <code>22.000370049504</code> are two different representations of the exact same actual value? That value is just being displayed in two different ways (here, because it occurs as a Python <code>float</code> in one case and a NumPy <code>float64</code> in the other). What's the <i>actual</i> problem that this is causing you? The difference is purely in the representation, and as such, will have no effect on the "future comparisons and simple math operations" that you mention.</span>
<span class="comment-copy">Also, note that the actual value stored (in both cases) is exactly <code>22.00037004950399932567961513996124267578125</code>. With binary floating-point, what you see is <b>not</b> what you get.</span>
