<div class="post-text" itemprop="text">
<p>Is there a reason why looping through an implicit tuple in a <code>for</code> loop is okay, but when you do it in a comprehension you get a syntax error? </p>
<p>For example:</p>
<pre><code>for i in 'a','b','c': 
    print(i)

'a'
'b'
'c'
</code></pre>
<p>But in a comprehension: </p>
<pre><code>&gt;&gt;&gt; [i for i in 'a','b','c']
  File "&lt;stdin&gt;", line 1
    [i for i in 'a','b','c']
                   ^
SyntaxError: invalid syntax
</code></pre>
<p>Is there a reason for this? I wasn't sure about the correct terminology, so my searches yielded nothing useful. </p>
<p><strong>Update:</strong></p>
<p>Per the comments, this syntax <em>is</em> valid for Python 2.x, but not for Python 3.x. </p>
</div>
<div class="post-text" itemprop="text">
<p>This changed in Python3, mainly in order to make list comprehensions more consistent with generator expressions.</p>
<p>With for-loops and list comprehensions, there is no ambiguity when using a tuple with no parentheses, because the former is always terminated by a colon, and the latter by either a closing bracket or a <code>for/if</code> keyword.</p>
<p>However, part of the design of generator expressions requires that they can be used "bare" as function arguments:</p>
<pre><code>&gt;&gt;&gt; list(i for i in range(3))
[0, 1, 2]
</code></pre>
<p>which creates some ambiguity for unparenthesized tuples, because any commas may introduce a new argument:</p>
<pre><code>&gt;&gt;&gt; list(i for i in 0, 1, 2)
  File "&lt;stdin&gt;", line 1
SyntaxError: Generator expression must be parenthesized if not sole argument
</code></pre>
<p>So tuples must always be parenthesized in generator expressions, and the same restriction now also applies to list comprehensions in order to preserve consistency.</p>
<p>PS:</p>
<p>Guido van Rossum wrote a article that spells out all the details on this subject in his History of Python blog:</p>
<ul>
<li><a href="https://python-history.blogspot.co.uk/2010/06/from-list-comprehensions-to-generator.html" rel="noreferrer">From List Comprehensions to Generator Expressions</a></li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Because the <code>for i in</code> in the first code is a different syntactical construction than the <code>for i in</code> in the second code.</p>
<p>The first case is <a href="https://docs.python.org/3/reference/compound_stmts.html#the-for-statement" rel="nofollow noreferrer">a <code>for</code> statement, which has the grammar</a>:</p>
<pre><code>for_stmt ::=  "for" target_list "in" expression_list ":" suite
             ["else" ":" suite]
</code></pre>
<p><code>'a', 'b', 'c'</code> is most definitely an <a href="https://docs.python.org/3/reference/expressions.html#grammar-token-expression_list" rel="nofollow noreferrer"><code>expression_list</code></a>, so that works out.</p>
<p>In the second case, however, the inline <code>for</code> inside square brackets forces the code to be interpreted as a list comprehension, and in Python 3, <a href="https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries" rel="nofollow noreferrer">list comprehensions must have the syntax</a>:</p>
<pre><code>comprehension ::=  expression comp_for
comp_for      ::=  "for" target_list "in" or_test [comp_iter]
comp_iter     ::=  comp_for | comp_if
comp_if       ::=  "if" expression_nocond [comp_iter]
</code></pre>
<p>Note that the part after the <code>in</code> must be an <code>or_test</code>, yet comma-delimited expressions create <a href="https://docs.python.org/3/reference/expressions.html#expression-lists" rel="nofollow noreferrer">expression lists</a>, and an expression list cannot be an <code>or_test</code> --- or, put another way, <code>or</code> has higher precedence than comma.  Python thus thinks the comprehension ends at the comma, so that the three elements of the list are:</p>
<pre><code>i for i in 'a'
'b'
'c'
</code></pre>
<p>which (unless you put the <code>i for i in 'a'</code> in parentheses) is obviously invalid.</p>
<p>As to why this works in Python 2 ... I'm still looking.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think the problem is here: in the latter case it is not so obvious which objects are you iterating:</p>
<pre><code>&gt;&gt;&gt; [i for i in ('a','b','c')]
['a', 'b', 'c']
</code></pre>
<p>Where's a border between elements? Is it an array of 3 elements: generator and 2 integers?  Like this:</p>
<pre><code>&gt;&gt;&gt; [(i for i in 'a'),'b','c']
[&lt;generator object &lt;genexpr&gt; at 0x10cefeeb8&gt;, 'b', 'c']
</code></pre>
<p><code>for</code> doesn't have such ambiguity - so it doesn't need parenthesis. </p>
</div>
<span class="comment-copy">i never liked <i>implicit tuples</i> so both look bad to me but the question is interesting</span>
<span class="comment-copy">Would it be the <code>:</code> that helps to recognize the end of the implicit tuple?</span>
<span class="comment-copy">It works in Python 2.7 but not in Python 3</span>
<span class="comment-copy">@nigel222: That wouldn't be ambiguous, since interpreting it as iterating <code>"abc"</code>, then an unrelated comma joined clause of <code>"def"</code> would be illegal syntax anyway; a list comprehension can't also define discrete items in the list.</span>
<span class="comment-copy">@Scott: That PEP is specific to function calling rules; nothing would prevent the list comprehension from being invoked by packing a tuple before beginning the comprehension. Py3 list comps are implemented as nested scopes invoked in a function-like way, but they don't have parameter lists that are defined in code, they aren't unpacking their arguments in the way that PEP forbids, so that PEP doesn't apply.</span>
<span class="comment-copy">Is it <i>obviously</i> invalid? Python allows lists of arbitrary objects like <code>[[1,2], "cat", Date]</code>. Potentially confusing, for sure.</span>
<span class="comment-copy">Per <a href="http://stackoverflow.com/a/41128011/364696">@ekhumoro's answer</a>, it likely worked in Python 2 because list comprehensions were invented in Python 2 before generalized comprehension syntax and generator expressions existed. They didn't behave like generator expressions, set/dict comprehensions, etc., leaking variables into surrounding scope, allowing unparenthesized iterables, etc. In Python 3, for simplification and consistency, list comprehensions were changed to something more closely akin to wrapping a genexpr in the list constructor, and genexpr limits were inherited by side-effect.</span>
<span class="comment-copy">As for the "why this works in Python 2": The grammar explicitly allows for comma-separated lists: <a href="https://docs.python.org/2/reference/expressions.html#grammar-token-old_expression%60" rel="nofollow noreferrer"><code>old_expression</code></a>.</span>
<span class="comment-copy">Basically, genexpr has a good reason to forbid unparenthesized tuples (as noted in the answer, it creates problems when you're reusing function call parens to wrap the genexpr as a single argument to a function), and listcomps follow the same rules so there aren't subtle gotcha in switching from one to the other.</span>
