<div class="post-text" itemprop="text">
<p>Hey guys so I have done a lot of research into <code>_init_()</code> but still don't get it. From what I currently understand it must be used for all instances of a class to pass object args?</p>
<p>I understand the use of <code>self</code> but for whatever reason I can not seem to wrap my head around the point of <code>_init_()</code>. Why do we have to use it. When is it useful and what purpose does it serve other than the instantiation of instances of a class?</p>
<p>How is it a constructor if the said object has already been made before the call to <code>_init_()</code>?</p>
<p>Generally speaking I just have no idea on the why, how or when behind <code>_init_()</code> other than it is used for instantiation of instances of a class, it can have multiple args which seem to be specific to the instance of the class. It must be called for each instance?</p>
</div>
<div class="post-text" itemprop="text">
<p>I am not an expert on this but AFAIK the <code>__init__</code> method is a built-in method of every class or metaclass, that is called exactly in the class instantiation. </p>
<h2>Why or what for would you use the <code>__init__</code> method?</h2>
<p>Well, you can use it for many things, but the main purpose is to pass arguments into the class instance when it is instantiated. Actually when you do <code>class(*args, **kwargs)</code> these get passed along to <code>__init__</code>, where you might either make use of them or not.</p>
<p>For example:</p>
<pre><code>class Vehicle:

    name = 'vehicle'
    price = None
    canMove = False
    position = 0

    def __init__(self, price, name=None, canMove=False):
        self.name = name if name else self.name
        self.price = price

    def move(self, distance):
        if self.canMove:
            self.position += distance
            return 'The vehicle moved {0} meters'.format(distance)
        return 'The vehicle cannot move'


class Car(Vehicle):
    name = 'car'
    consumption = 100 # (litres per meter)
    fuel = 0 # (litres )

    def __init__(self, fuel, consumption=None, *args, **kwargs):
        self.fuel = fuel
        self.consumption = consumption if consumption else self.consumption
        super().__init__(*args, **kwargs)

    def move(self, distance):
        if self.canMove and self.hasFuel():
            available_d = self.fuel / self.consumption
            if distance &lt;= available_d:
                self.fuel -= self.consumption*distance
                self.position += distance
                return 'The vehicle moved {0} meters and has {1} litres left.'.format(distance, self.fuel)
            return 'The vehicle cannot move since it does not have fuel enough'
        return 'The vehicle cannot move since it does not have any fuel'


    def hasFuel(self):
        return True if self.fuel &gt; 0 else False

    def giveFuel(self, litres):
        self.fuel += litres
</code></pre>
<p>If you take some time to read the code, you will see how there are necessary tasks that need to be run in the <code>__init__</code> method, such as variable assignment, doing checks or running other processes.</p>
<p>Also when you inherit from another class the behaviour gets a bit more complicated. As you see I have to call the mother class with the <code>super().__init__()</code> call in order to run the rest of the tasks that were being done in it.</p>
<h2><code>__init__</code> in use</h2>
<p>So let's play around with this piece of code I have just created.</p>
<p>You could create your vehicle just like this:</p>
<pre><code>myVehicle = Vehicle()
</code></pre>
<p>However that would raise an error, since the <code>__init__</code> method is requiring to pass one compulsory argument, <code>price</code>. All the rest are optional fields, but that is obligatory for the instantiation to happen. Therefore you could try again with this:</p>
<pre><code>myVehicle = Vehicle(10000)
</code></pre>
<p>You can access the value you have just passed doing:</p>
<pre><code>myVehicle.price
</code></pre>
<p>You can also pass the rest of the elements, but they are not obligatory:</p>
<pre><code>myVehicle2 = Vehicle(10000, name='myVehicle2', canMove=True)
</code></pre>
<p>Bear in mind that we could also assign them after the instantiation to our first vehicle:</p>
<pre><code>myVehicle.name = 'myVehicle'
</code></pre>
<p>So now we have two different vehicles, but one can move and the other can't. We can see this if we run:</p>
<pre><code>myVehicle.move(100)
</code></pre>
<p>Whereas <code>myVehicle2.move(100)</code> won't raise the error. If you change the property of the first vehicle afterwards it will work, regardless of the value you passed to <code>__init__</code> initially.</p>
<p>It works similar for our Car class. If we do <code>Car()</code>:</p>
<pre><code>&gt;&gt;&gt; Car()
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
TypeError: __init__() missing 1 required positional argument: 'fuel'
</code></pre>
<p>Even if we do <code>Car(fuel=140)</code>:</p>
<pre><code>&gt;&gt;&gt; Car(fuel=140)
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in &lt;module&gt;
  File "&lt;input&gt;", line 10, in __init__
TypeError: __init__() missing 1 required positional argument: 'price'
</code></pre>
<p>All these arguments are defined in the <code>__init__</code> section, and the <code>price</code> tag is required because it inherits form the parent class.</p>
<p>Look at how the values work correctly when we try to move our car:</p>
<pre><code>&gt;&gt;&gt; myCar = Car(price=10000, fuel=150, consumption=10)
&gt;&gt;&gt; myCar.move(10)
'The vehicle cannot move since it does not have any fuel' # we actually have not enabled its canMove property
&gt;&gt;&gt; myCar.canMove = True
&gt;&gt;&gt; myCar.move(10)
'The vehicle moved 10 meters and has 50 litres left.'
&gt;&gt;&gt; myCar.move(1)
'The vehicle moved 1 meters and has 40 litres left.'
&gt;&gt;&gt; myCar.move(30)
'The vehicle cannot move since it does not have fuel enough'
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It gets called when that type of object gets created, so you can do whatever class-specific initialization is needed, and don't have to remember to make a separate initialization call.  That is what it is used for; that is what purpose it serves.</p>
</div>
<span class="comment-copy">It's purpose is to initialize values that belong to this particular instance of the class. You don't have to define one, but in that case the instances created will have an empty initial stateâ€”which doesn't sound very useful. What part of the <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization" rel="nofollow noreferrer">documentation</a> was unclear?</span>
<span class="comment-copy">So what purpose does that serve? Can these values be used elsewhere ?</span>
<span class="comment-copy">I'd suggest you look at some Python code that uses classes and see how <code>__init__</code> is being used. It should become clear then what its purpose is. For example, take a look at the <a href="https://github.com/requests/requests/blob/master/requests/models.py#L194" rel="nofollow noreferrer"><code>Request</code> class</a> from the popular <code>requests</code> library. You can see how each instance is <i>configured</i> with certain values and then those values are used from other methods.</span>
<span class="comment-copy">Say you had some class <code>Car</code>. All cars have a color.  To make a new <code>Car</code> object <code>c</code> such that <code>c.color</code> is <code>"red"</code>, you would have <code>def __init__(self, color): self.color = color</code>.  Then after <code>c = Car('red')</code>, <code>c</code> would be a <code>Car</code> object such that <code>c.color == 'red'</code></span>
<span class="comment-copy">Doesn't seem to me like you done "a lot of research". See <a href="https://meta.stackoverflow.com/questions/261592/how-much-research-effort-is-expected-of-stack-overflow-users"><b>How much research effort is expected of Stack Overflow users?</b></a>.</span>
<span class="comment-copy">Love this answer. Makes things a lot clearer. I think tonight when I get home I will mess around with this code and learn for myself. Thanks so much !!!</span>
<span class="comment-copy">@Aeryes please if you like it consider upvoting and accepting it with the check button. Also feel free to ask any further question if you'd like.</span>
<span class="comment-copy">I do have one question about the call to super. What args are been used in this instance. Also I gladly upvoted and will accept it.</span>
<span class="comment-copy">So yeah, super what it does is to call the mother class. So you must admit all those <code>*args, **kwargs</code> and pass them to the parent <code>__init__</code> method unless you want to overwrite it completely. <code>*args, **kwargs</code>  are, for short, a reduced way of expressing all the possible arguments that the class instantiation might accept (and in general any method or function). So if I did not do that, I would not be able to set on instantiation the price of the vehicle (I could still do it later).</span>
<span class="comment-copy">I see so basically you are using the args that you provided in the mother class of 'Vechile' so the class 'Car inherits these and can use them in its own way?</span>
<span class="comment-copy">So what kind of class initialization would need to be done? If I assign args to the instance can they be used outside of the instance. Like assigning an instance of a class an arg of x = 2. Can I use x outside of the <i>init</i>.</span>
<span class="comment-copy">In the "lot of research" you have done, you have never seen an example of how the args to <code>__init__</code> get used?</span>
<span class="comment-copy">I know it takes some time to write a good, clear and simple answer about this topic, but you might agree with me that yours is none of those.</span>
<span class="comment-copy">In all honesty I am just trying to learn, the hostility isn't needed. Yes I have but I am trying to get better examples from people who have been doing this for some time. Sorry for trying to learn.</span>
