<div class="post-text" itemprop="text">
<p>I am learning Python and right now I am on the topic of scopes and nonlocal statement.
At some point I thought I figured it all out, but then nonlocal came and broke everything down.</p>
<p>Example number 1:</p>
<pre><code>print( "let's begin" )
def a():
    def b():
        nonlocal x
        x = 20
    b()

a()
</code></pre>
<p>Running it naturally fails.<br/>
What is more interesting is that <code>print(</code>) does not get executed. Why?.</p>
<p>My understanding was that enclosing <code>def a()</code> is not executed until <code>print()</code> is executed, and nested <code>def b()</code> is executed only when <code>a()</code> is called. I am confused...</p>
<p>Ok, let's try example number 2:</p>
<pre><code>print( "let's begin" )
def a():
    if False: x = 10
    def b():
        nonlocal x
        x = 20
    b()

a()
</code></pre>
<p>Aaand... it runs fine.
Whaaat?! How did THAT fix it? <code>x = 10</code> in function <code>a</code> is never executed!</p>
<p>My understanding was that nonlocal statement is evaluated and executed at run-time, searching enclosing function's call contexts and binding local name <code>x</code> to some particular "outer" <code>x</code>. And if there is no <code>x</code> in outer functions - raise an exception. Again, at run-time.</p>
<p>But now it looks like this is done at the time of syntax analysis, with pretty dumb check "look in outer functions for <code>x = blah</code>, if there is something like this - we're fine," even if that <code>x = blah</code> is never executed...</p>
<p>Can anybody explain me when and how nonlocal statement is processed?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can see what the scope of <code>b</code> knows about free variables (available for binding) from the scope of <code>a</code>, like so:</p>
<pre><code>import inspect

print( "let's begin" )

def a():
    if False:
        x = 10

    def b():
        print(inspect.currentframe().f_code.co_freevars)
        nonlocal x
        x = 20

    b()

a()
</code></pre>
<p>Which gives:</p>
<pre><code>let's begin
('x',)
</code></pre>
<p>If you comment out the <code>nonlocal</code> line, and remove the <code>if</code> statement with <code>x</code> inside, the you'll see the free variables available to <code>b</code> is just <code>()</code>.</p>
<p>So let's look at what bytecode instruction this generates, by putting the definition of <code>a</code> into IPython and then using <code>dis.dis</code>:</p>
<pre><code>In [3]: import dis

In [4]: dis.dis(a)
  5           0 LOAD_CLOSURE             0 (x)
              2 BUILD_TUPLE              1
              4 LOAD_CONST               1 (&lt;code object b at 0x7efceaa256f0, file "&lt;ipython-input-1-20ba94fb8214&gt;", line 5&gt;)
              6 LOAD_CONST               2 ('a.&lt;locals&gt;.b')
              8 MAKE_FUNCTION            8
             10 STORE_FAST               0 (b)

 10          12 LOAD_FAST                0 (b)
             14 CALL_FUNCTION            0
             16 POP_TOP
             18 LOAD_CONST               0 (None)
             20 RETURN_VALUE
</code></pre>
<p>So then let's look at <a href="https://github.com/python/cpython/blob/1896793520a49a6f97ae360c0b288967e56b005e/Python/ceval.c#L2220" rel="nofollow noreferrer">how <code>LOAD_CLOSURE</code> is processed in <code>ceval.c</code></a>.</p>
<pre><code>TARGET(LOAD_CLOSURE) {
    PyObject *cell = freevars[oparg];
    Py_INCREF(cell);
    PUSH(cell);
    DISPATCH();
}
</code></pre>
<p>So we see it must look up <code>x</code> from <code>freevars</code> of the enclosing scope(s). </p>
<p>This is mentioned <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names" rel="nofollow noreferrer">in the Execution Model documentation</a>, where it says:</p>
<blockquote>
<p>The nonlocal statement causes corresponding names to refer to previously bound variables in the nearest enclosing function scope. SyntaxError is raised <strong>at compile time</strong> if the given name does not exist in any enclosing function scope.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>First, understand that python will check your module's syntax and if it detects something invalid it raises a <code>SyntaxError</code> which stops it from running at all. Your first example raises a <code>SyntaxError</code> but to understand exactly why is pretty complicated although it is easier to understand if you know how <code>__slots__</code> works so I will quickly introduce that first.</p>
<hr/>
<p>When a class defines <code>__slots__</code> it is basically saying that the instances should only have those attributes so each object is allocated memory with space for only those, trying to assign other attributes raises an error</p>
<pre><code>class SlotsTest:
    __slots__ = ["a", "b"]

x = SlotsTest()

x.a = 1 ; x.b = 2
x.c = 3 #AttributeError: 'SlotsTest' object has no attribute 'c'
</code></pre>
<p>The reason <code>x.c = 3</code> can't work is that there is <em>no memory space</em> to put a <code>.c</code> attribute in.</p>
<p>If you do not specify <code>__slots__</code> then all instances are created with a dictionary to store the instance variables, dictionaries do not have any limitations on how many values they contain</p>
<pre><code>class DictTest:
    pass

y = DictTest()
y.a = 1 ; y.b = 2 ; y.c = 3
print(y.__dict__) #prints {'a': 1, 'b': 2, 'c': 3}
</code></pre>
<hr/>
<p>Python functions work similar to <code>slots</code>. When python checks the syntax of your module it finds all variables assigned (or attempted to be assigned) in each function definition and uses that when constructing frames during execution.  </p>
<p>When you use <code>nonlocal x</code> it gives an inner function access to a specific variable in the outer function scope but <strong>if there is no variable defined</strong> in the outer function then <strong><code>nonlocal x</code> has no space to point to.</strong></p>
<p>Global access doesn't run into the same issue since python modules are created with a dictionary to store its attributes.  So <code>global x</code> is allowed even if there is no global reference to <code>x</code></p>
</div>
<span class="comment-copy"><a href="https://stackoverflow.com/q/46018872/7954504">Related question</a> you may find useful</span>
<span class="comment-copy">putting <code>nonlocal</code> requires the variable to actually point to an existing variable, the first one <b>fails to compile.</b></span>
<span class="comment-copy">If you weren't aware that python was compiled, it may be worth reading <a href="https://softwareengineering.stackexchange.com/questions/136942/why-doesnt-python-need-a-compiler">this  softwareengineering.SE post</a></span>
<span class="comment-copy">all languages (except assembly) have to be compiled at some point, you can't give <a href="https://stackoverflow.com/questions/12673074/how-should-i-understand-the-output-of-dis-dis">human text to a CPU</a> and expect it to do reasonable things!  The difference is that <code>a + b</code> instead of compiling to "run specific function with <code>a</code> and <code>b</code>" will compile to something like "look for <code>+</code> operation on <code>a</code>, if it isn't defined check for reverse <code>+</code> on <code>b</code>, if that is also undefined raise an error"</span>
<span class="comment-copy">"This is mentioned in the Execution Model documentation..." Is as far as I can tell the answer to the question in itself, you may want to put it at the top of your answer to have the form "the documentation says this isn't allowed, let me explain why"</span>
<span class="comment-copy">Thanks for the link to the Execution Model. I guess Python's execution process is far more complex than "read a line, execute statement in it, read next line..." Yet I don't quite understand necessity for such complexities...</span>
<span class="comment-copy">I recognize this is a badly formed answer, I'm not sure how else to explain this without either talking about <code>slots</code> or how python handles stack memory which would be far worse.</span>
<span class="comment-copy">It's not that badly formed as you think it is - it gave me some understanding of Python. So, basically, the first phase of execution of a Python script - is syntax analysis, when Python machine determines what can actually later exist? Isn't this contrary to the whole "dynamic" paradigm?.. What about variables created via exec()?</span>
<span class="comment-copy">Regardless of how it is interpreted, it will need to convert the code to something it can execute at some point, doing it per-file instead of per-line makes sense because if you have a long script it's nice to know you forgot a bracket on the last line <i>before</i> it tries to run it.  As well python makes clear guarantee that globals will be dynamic like dictionaries (see <code>help(globals)</code> note) and does not guarantee this for locals or closures (see <code>help(locals)</code> note)</span>
<span class="comment-copy">as for <code>exec</code>, it must use a <b>dictionary</b> for its local and global namespace, if none are provided it uses the current global one and a new dictionary for local variables or if one is given it uses it for globals and locals.  In any case, it can't directly interact with the namespace of a function because it doesn't store local variables in a dictionary in the default C implementation.</span>
