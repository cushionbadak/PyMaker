<div class="post-text" itemprop="text">
<p>I was thinking of applying the map function twice in order to allow it to act as a double for loop but I don't know if that makes sense. 
Is that the way to go about it?</p>
<p>For example, this is what I am working on:</p>
<p>In imperative:</p>
<pre><code>def degree(A):
    n = len(A)
    t = []
    for i in range(n):
        d = 0
        for j in range(n):
            d+=A[i][j]
        t.append(d)

    return t
</code></pre>
<p>In functional:</p>
<pre><code>def degree(A):
    n = len(A)
    t = []
    map(lambda x,y:x+y,A)
</code></pre>
<p>If it was a single for loop then I would approach it as I did above. So I was trying to implement a double map, but I do not know what how to structure that.
Any help would be appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You are summing the inner lists <code>A</code>, so just apply <code>sum</code> to each nested list in <code>A</code>:</p>
<pre><code>def degree(A):
    return map(sum, A)
</code></pre>
<p>You could also consider using a list comprehension or generator expression (depending on whether or not you need to produce the result lazily (<code>map()</code> in Python 2 produces a list, in Python 3 it works lazily):</p>
<pre><code>def degree(A):
    # returns a list
    return [sum(row) for row in A]

def degree(A):
    # returns a generator
    return (sum(row) for row in A)
</code></pre>
<p>You can otherwise produce <code>i</code> and <code>j</code> as a <em>cartesian product</em>, using <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>itertools.product()</code></a>; however, you'd be passing in a <em>tuple</em> of integers to the map callable:</p>
<pre><code>from itertools import product

map(lambda ij: A[ij[0]][ij[1]] ** 2, product(range(len(A)), 2))
</code></pre>
<p>This can be remedied by using <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow noreferrer"><code>itertools.starmap()</code></a> instead:</p>
<pre><code>from itertools import product, starmap

starmap(lambda i, j: A[i][i] ** 2, product(range(len(A)), 2))
</code></pre>
<p>Neither produces a sum; I demoed a <code>lambda</code> that produces the square of the innermost values instead, so you get one long sequence of all values, squared, without distinction between rows. That's how mapping works, it produces a value <em>per item processed in the input</em>.</p>
<p>You could also just <em>nest</em> the <code>map()</code> calls; put the inner <code>map()</code> in the callable for the outer <code>map()</code>:</p>
<pre><code>map(lambda r: map(lambda v: v ** 2, r), A)
</code></pre>
<p>but note that this then produces a lazy sequence of lazy objects in Python 3. Again, summing doesn't make sense in this scenario, as there is no accumulation of results.</p>
<p>For a generic <em>cumulation</em> of results across a sequence, you want to use the <a href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="nofollow noreferrer"><code>functools.reduce()</code> function</a>; <em>that</em> callable applies a callable on a running result and the next value in a sequence. You can produce a sum with your <code>lambda x, y: x + y</code> function and <code>map()</code>:</p>
<pre><code>map(lambda r: reduce(lambda x, y: x + y, r, 0), A)
</code></pre>
<p>But for <em>just summing</em>, the <code>reduce(lambda x, y: x + y, &lt;iterable&gt;, 0)</code> syntax is just a verbose and slower way of spelling <code>sum(&lt;iterable&gt;)</code>.</p>
</div>
<span class="comment-copy">You do much more than just have a double loop, you also create a sum in the inner loop.</span>
<span class="comment-copy">You could get the same effect with <code>map(sum, A)</code>, by the way, no need to nest anything.</span>
<span class="comment-copy">Your attempt at <code>map()</code> doesn't make any sense in your context; where you thinking of <code>reduce()</code> perhaps? <code>map()</code> takes any number of iterables, and applies those together as inputs, but <code>map(..., A)</code> only has <b>one</b> input, so <i>one</i> argument for the lambda. You then build a sequence of results, not a total sum. <code>reduce()</code> produces a single result from repeated calls to a function and the input sequence.</span>
<span class="comment-copy">so I am wondering how would that take care of the A[i][j] part, the matrix that is formed with the double loop?</span>
<span class="comment-copy">are both those methods equivalent?</span>
<span class="comment-copy">@ce1: both what methods? No, the <code>product()</code> method doesn't produce the same results; you can't produce the same results with <code>product()</code> as you reset <code>d</code> each iteration of the outer loop.</span>
<span class="comment-copy">If the line were to be d+=A[i][j] * X[j] where X is a list passed to the function, how would the map(sum, A) change in functional programming?</span>
<span class="comment-copy">@ce1: use <code>zip()</code> to pair up rows from <code>A</code> with <code>X</code>: <code>(sum(a * x for a, x in zip(r, X) for r in A)</code> in a generator expression, or <code>from operator import mul</code> then <code>map(lambda r: sum(map(prod, r, X)), A)</code> if you must use <code>map()</code> over comprehensions.</span>
