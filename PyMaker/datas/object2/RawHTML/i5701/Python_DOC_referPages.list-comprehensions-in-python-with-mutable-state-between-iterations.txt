<div class="post-text" itemprop="text">
<p>I have something which is an awful lot like a list comprehension in Python, except that it shares mutable state between iterations. Is there any way to do it with a list comprehension?</p>
<pre><code>def f(x):
    """ 5-bit LFSR """
    return (x &gt;&gt; 1) ^ (0x12*(x&amp;1))

def batch(f, x, n):
    result = [x]
    for _ in xrange(1,n):
        x = f(x)
        result.append(x)
    return result

batch(f, 1, 5)
</code></pre>
<p>which returns <code>[1, 18, 9, 22, 11]</code>. Here the important thing is the <code>batch</code> function, not <code>f(x)</code> which is here just a simple example to illustrate the issue.</p>
<p>Alternatively I could implement using a generator:</p>
<pre><code>def batch(f, x, n):
    yield x
    for _ in xrange(1,n):
        x = f(x)
        yield x

list(batch(f, 1, 5))
</code></pre>
<p>But it smells a little awkward. What I'm looking for is something like this...</p>
<pre><code>batch = [??? for _ in xrange(n)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>No. Deliberately no. Eventually they put in <code>itertools.accumulate</code>, which is the closest thing to an Officially Recommended way to implement recurrence relations in a functional manner, but it doesn't exist on 2.7. You could copy the "roughly equivalent to" Python implementation from the <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="noreferrer">docs</a> if you want.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Is there any way to do it with a list comprehension?</p>
<p>What I'm looking for is something like this...</p>
<pre><code>batch = [??? for _ in xrange(n)]
</code></pre>
</blockquote>
<p>Sure, no problem:</p>
<pre><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; n = 5
&gt;&gt;&gt; [prev.append(f(prev[0])) or prev.pop(0) for prev in [[x]] for _ in xrange(n)]
[1, 18, 9, 22, 11]
</code></pre>
<h1>Note: This is a bad idea. <sup><sub><sub>(I pretty much only did this because user2357112 said there is no way)</sub></sub></sup></h1>
</div>
<div class="post-text" itemprop="text">
<p>You <em>could</em> do this in a single line, using e.g. <code>reduce</code> (or <code>functools.reduce</code> in Python 3):</p>
<pre><code>&gt;&gt;&gt; f = lambda x: (x &gt;&gt; 1) ^ (0x12*(x&amp;1))
&gt;&gt;&gt; x, n = 1, 5
&gt;&gt;&gt; functools.reduce(lambda lst, _: lst + [f(lst[-1])], range(1, n), [x])
[1, 18, 9, 22, 11]
</code></pre>
<p>But this is not only ugly, but also inefficient, as it will create a new list in each iteration. Or in a similar fashion to Stefan's approach, without creating intermediate lists:</p>
<pre><code>&gt;&gt;&gt; functools.reduce(lambda lst, _: lst.append(f(lst[-1])) or lst, range(1, n), [x])
[1, 18, 9, 22, 11]
</code></pre>
<p>Or, as already hinted in the other answer, you could use <code>itertools.accumulate</code>, which is a lot better, but still a bit of a mis-use, as it actually expects a binary function, whereas here we use neither the second parameter, nor the actual iterable passed into the function, except for the very first value.</p>
<pre><code>&gt;&gt;&gt; list(itertools.accumulate([x] * n, lambda y, _: f(y)))
[1, 18, 9, 22, 11]
</code></pre>
</div>
<span class="comment-copy">this smells suspiciously like one of those pesky Haskell monads would be useful, if I could only understand it.</span>
<span class="comment-copy">"except that it shares mutable state between iterations. Is there any way to do it with a list comprehension" there might be some hacky way, but if it invovles mutating state, then it probably <b>shouldn't be a list-comprehension</b></span>
<span class="comment-copy">Also, "sharing mutable state between iterations" doesn't sound like anything in Haskell.</span>
<span class="comment-copy">no, but stateful monads does</span>
<span class="comment-copy">You could define a recursive generator using <code>yield from</code>.</span>
<span class="comment-copy">...or just use my <code>batch</code> function. OK, thanks!</span>
<span class="comment-copy">Holy hell that's sneaky.</span>
<span class="comment-copy">I am not sure whether I should upvote or downvote this...</span>
<span class="comment-copy">@tobias_k So do both. But please down first.</span>
<span class="comment-copy">While this is probably the cleanest, best-encapsulated form of state variables in a list comprehension I've seen (no leakage of the state variable into the surrounding scope, at least on Python 3), there's still a reason I didn't post anything like this: every instance of this kind of code on Stack Overflow, getting upvotes, increases the risk that people will think this kind of thing is a good idea and actually use it in their code.</span>
<span class="comment-copy">@user2357112 Better now? :-)</span>
<span class="comment-copy">While I consider using <code>itertools.accumulate</code> for this to be ugly, recurrence relations are explicitly listed as a use case in the <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" rel="nofollow noreferrer"><code>accumulate</code> docs</a>, with example code.</span>
<span class="comment-copy">@StefanPochmann Good point, fixed, but that makes it even uglier.</span>
<span class="comment-copy">@tobias_k Well then make it <i>prettier</i> instead :-). If you followed the documentation, you'd use <code>repeat(x, n)</code>. And since you're willing to create a list, you could simply use <code>[x] * n</code>.</span>
<span class="comment-copy">For <code>reduce</code> you could also use <code>lst.__iadd__([f(lst[-1])])</code>, though I prefer the <code>append</code>+<code>or lst</code> (despite it being three characters longer! :-)</span>
<span class="comment-copy">Ha, how about: <code>reduce(lambda lst, _: lst.append(f(lst[-1])) or lst, [[x]] * n)</code>. I actually laughed about this one... using the common <code>[[x]] * n</code> 2D-list gotcha... but it's ok here because the repeated references are ignored... I think that's just beautiful.</span>
