<div class="post-text" itemprop="text">
<p>I am currently trying to program a game called Pah Tum. The game involves a board that is 7x7. For the board I just created a list with 7 lists containing 7 elements each, basically I just made each row into a list and merged them into a big list:</p>
<pre><code>board = [[0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0]]
</code></pre>
<p>The game should have an undo function, which enables the player to go back one step. I thought I could just append the whole board into a seperate list and use that to go back a step.</p>
<pre><code>        if input == 'u' or input == 'U':
            board = board_list[-1]
            del board_list[-1]
</code></pre>
<p>until here it works, but for some reason the board_list (the list I'm appending the current board to) always updates as a whole, meaning each element changes and becomes the new board.</p>
<p>eg. if I have</p>
<pre><code>#board = [[0, 'B'], [0, 0]]
board_list.append(board)
.
.
.
#board = [[0, 'B'], [0, 'B']]
board_list.append(board)
</code></pre>
<p>after the first append I'd get</p>
<pre><code>board_list = [[[0, 'B'], [0, 0]]]
</code></pre>
<p>and the second one leaves me with</p>
<pre><code>board_list = [[[0, 'B'], [0, 'B']], [[0, 'B'], [0, 'B']]]
</code></pre>
<p>I have no idea why this happens. I searched for similar questions but I only see undo functions for canvases and I'm not sure if I can use them for this scenario.</p>
</div>
<div class="post-text" itemprop="text">
<p>When you append <code>board</code> to <code>board_list</code> you're adding a <em>reference</em> to the <em>original</em> <code>board</code>. Perhaps a better option would be to add the previous state for the changed cell when you make a move:</p>
<pre><code>moves.append([x, y, board[x][y]])
</code></pre>
<p>And then when you undo you reapply that state:</p>
<pre><code>undo_move = moves[-1]
board[undo_move[0]][undo_move[1]] = undo_move[2]
del moves[-1]
</code></pre>
<p>Or more pythonically:</p>
<pre><code>x, y, board[x][y] = moves.pop()
</code></pre>
<p>Alternatively, you could make a copy of the entire board and store that in the list instead.</p>
</div>
<div class="post-text" itemprop="text">
<p>In order to create a list of board copies you need to implement a deep copying method for your board class. Otherwise, all you're doing is copying the same pointer over and over. Python passes by reference and that's the source of your problem.
Implement a new method which creates a new board with the same fields as your current board and return a pointer to that board from that method.
I'd recommend reading some about shallow and deep copies. You can find more details <a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">here</a>.</p>
</div>
<span class="comment-copy">You're adding a reference to the original board to <code>board_list</code>, <i>not a copy</i> of the board</span>
<span class="comment-copy">But I'm using the same variable 'Board' when I change a '0', would making a new Board variable help?</span>
<span class="comment-copy">Ok I'll try to implement that. It shouldn't be a problem and thank you for the fast answer!</span>
<span class="comment-copy">Ok, I tried using deepcopy and it did work, but i thought it would be better to implement your method, since that would make the 'moves' list not as big and it works. Thank you very much again.</span>
<span class="comment-copy">Instead of those three undo lines you can simply do <code>x, y, board[x][y] = moves.pop()</code>.</span>
<span class="comment-copy">@StefanPochmann Bah, of course you can, good point, I was thinking that all of the changes when performing operations like that occurred simultaneously, and so <code>x</code> and <code>y</code> would be undefined during the <code>board[x][y]</code> part when doing that, although after testing they are indeed set before <code>board[x][y]</code> is set to the last value</span>
<span class="comment-copy">@NickA Yeah, and I think this one is a particularly nice usage of that "trick". I'm glad you chose the right storage order :-)</span>
<span class="comment-copy"><a href="https://docs.python.org/3/library/copy.html" rel="nofollow noreferrer">docs.python.org/3/library/copy.html</a></span>
<span class="comment-copy">Unless the board class is doing something unusual, they don't need to implement a method at all; <code>copy.deepcopy</code> will "just work".</span>
<span class="comment-copy">Indeed it should ^^</span>
<span class="comment-copy">Thank you as well for the quick answer, I tried implementing it and it worked I appreciate it!</span>
<span class="comment-copy">My pleasure :) keep in mind that deep/shallow copying objects should always be thought of when giving copies of your objects to external users. Otherwise they can use the pointer you've given them to modify your objects without using your API.</span>
