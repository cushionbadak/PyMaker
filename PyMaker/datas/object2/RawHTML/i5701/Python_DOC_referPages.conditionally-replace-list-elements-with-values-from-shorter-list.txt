<div class="post-text" itemprop="text">
<p>I am new to python and trying to simply replace the values of a list when they meet a condition with values from a shorter list.</p>
<p>For example:</p>
<pre><code>list1 = [1,0,1,0,1,0]
list2 = [1,2,3]
</code></pre>
<p>The output I want is:</p>
<pre><code>list1 = [1,1,1,2,1,3]
</code></pre>
<p>I can use a loop with a counter:</p>
<pre><code>counter = 0
for i, j in enumerate(list1):
    if j == 1:
        list1[i] = list2[counter]
        counter += 1
</code></pre>
<p>But this seems inefficient for something so simple, so I'm guessing there might be a way to do this with a list comprehension, something like:</p>
<pre><code>[list2[i] if j == 0 else j for i,j in enumerate(list1)]
</code></pre>
<p>(although this fails due the lists being different lengths).</p>
<p>Is there any other concise way of doing this in base python, perhaps using <code>map</code> or <code>filter</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use an iterator made from the short list and just call <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">next</a> on it in the comprehension:</p>
<pre><code>list1 = [1, 0, 1, 0, 1, 0]
list2 = [1, 2, 3]

it2 = iter(list2)

[x if x != 0 else next(it2) for x in list1]
# [1, 1, 1, 2, 1, 3]
</code></pre>
<p>Note that you can provide a default value to <a href="https://docs.python.org/3/library/functions.html#next" rel="nofollow noreferrer">next</a> if there are not enough filler elements:</p>
</div>
<div class="post-text" itemprop="text">
<p>Try something like:</p>
<pre><code>[x if x else list2.pop(0) for x in list1]
</code></pre>
<p>Note this removes items from <code>list2</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you want to use <a href="https://docs.python.org/3.6/library/functions.html#map" rel="nofollow noreferrer"><code>map()</code></a>, you could try this:</p>
<pre><code>from collections import deque

list1 = [1,0,1,0,1,0]
list2 = [1,2,3]

queue = deque(list2)

result = list(map(lambda x : x if x else queue.popleft(), list1))

print(result)
</code></pre>
<p>Which outputs:</p>
<pre><code>[1, 1, 1, 2, 1, 3]
</code></pre>
<p><strong>Note:</strong> I used a stack/queue data structure, <a href="https://docs.python.org/2/library/collections.html#collections.deque" rel="nofollow noreferrer"><code>collections.deque</code></a> to allow a <code>O(1)</code> <code>popleft()</code> from the front, instead of using <code>pop(0)</code>, which is <code>O(n)</code>. If you don't wish to use this library, you can just reverse <code>list2</code> beforehand, and call <code>pop()</code>, which is also <code>O(1)</code>. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>list1 = [1,0,1,0,1,0]
list2 = [1,2,3]
new_list = [list2[list1[:i].count(a)] if a != 1 else a for i, a in enumerate(list1)]
</code></pre>
<p>Output:</p>
<pre><code>[1, 1, 1, 2, 1, 3]
</code></pre>
</div>
<span class="comment-copy">Shorter code isn't necessarily more efficient code. Unless this is for a code golf challenge, I'm failing to see what's wrong with the solution you have.</span>
<span class="comment-copy">Good point, I suppose it's just because I use this type of operation a lot in other languages (where you can just use logical indexing), and I'm looking for something similar in terms of ease of typing.</span>
<span class="comment-copy">While this works, you should note that every <code>pop(0)</code> is <code>O(N)</code>.</span>
<span class="comment-copy">@schwobaseggl Nice catch.</span>
<span class="comment-copy">I guess you could reverse the list beforehand, and then call <code>pop()</code>. But then reversing a list is <code>O(N)</code>, which shouldn't be a problem.</span>
<span class="comment-copy">@RoadRunner except as written it does <code>O(n)</code> <code>O(n)</code> pops, so it's <code>O(n^2)</code>. Reversing it first reduces that complexity to <code>O(n)</code> + <code>O(n)</code> instead.</span>
