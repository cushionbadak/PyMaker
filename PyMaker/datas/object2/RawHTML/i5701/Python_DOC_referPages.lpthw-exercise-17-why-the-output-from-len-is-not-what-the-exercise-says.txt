<div class="post-text" itemprop="text">
<p>I wrote the following Python 3 script:</p>
<pre><code>from sys import argv
from os.path import exists

script, from_file, to_file = argv

print(f"Copying from {from_file} to {to_file}")

in_file = open(from_file)
indata = in_file.read()

print(f"The input file is {len(indata)} bytes long")

print(f"Does the output file exist? {exists(to_file)}")
print("Ready, hit RETURN to continue, CTRL-C to abort.")
input()

out_file = open(to_file, 'w')
out_file.write(indata)

print("Alright, all done.")

out_file.close()
in_file.close()
</code></pre>
<p>Apparently the output of <code>len(indata)</code> should be:</p>
<pre><code>The input file is 21 bytes long
</code></pre>
<p>But I get:</p>
<pre><code>The input file is 46 bytes long
</code></pre>
<p>The <code>from_file</code> is a file called test.txt which contains the text "This is a test file."</p>
<p>I double-checked the text inside test.txt. I thought that the difference may be on the computer since I'm using Windows and the teacher doesn't.</p>
<p><a href="https://i.stack.imgur.com/H6SJP.png" rel="nofollow noreferrer">Expected output of the exercise according to Zed</a></p>
<p><em>This is my first post here and I already tried to find something about this issue. Although I found some questions about exercise 17, I found nothing about the bytes difference.</em></p>
</div>
<div class="post-text" itemprop="text">
<h2>Short version</h2>
<p>You get this output because the file is encoded as UTF-16, probably because the editor you used to save it has that behavior on Windows, and you didn't specify an encoding to read it with, so Python guessed wrong. To avoid this kind of issue, you should always add an encoding argument to the <code>open</code> function, whether reading or writing:</p>
<pre><code>in_file = open(from_file, encoding='utf-16')
# ...
out_file = open(to_file, 'w', encoding='utf-16')
</code></pre>
<h2>Long version</h2>
<p>21 is the number of bytes in the file when encoded as UTF-8 with a terminating LF character (<code>'\n'</code>), without a <a href="https://en.wikipedia.org/wiki/Byte_order_mark" rel="nofollow noreferrer">byte order mark (BOM)</a>.</p>
<p>46 is the number of bytes in the file when encoded as UTF-16 with a terminating CR+LF combination (<code>'\r\n'</code>) and a BOM (byte-order mark).</p>
<p>Much as we'd like to think text is "just text", it has to be encoded somehow into bytes (see <a href="https://stackoverflow.com/questions/6224052/what-is-the-difference-between-a-string-and-a-byte-string">this Q&amp;A</a> for more information). On Linux, the most widely followed convention is to use UTF-8 for everything. On Windows, UTF-16 is more common, but you also get other encodings.</p>
<p>Python's <code>open</code> function has an <code>encoding</code> argument that you can use to tell Python that the file you're opening is UTF-16, and then you'll get a different result:</p>
<pre><code>in_file = open(from_file, encoding='utf-16')
</code></pre>
<p>What's it doing instead? Well, <a href="https://docs.python.org/3/library/functions.html#open" rel="nofollow noreferrer">the <code>open</code> function is documented to use <code>locale.getpreferredencoding(False)</code> if you don't specify an encoding</a>, so you can find out by typing <code>import locale; locale.getpreferredencoding(False)</code>. But I can save you the effort by telling you that the preferred encoding on Windows is <a href="https://en.wikipedia.org/wiki/Windows-1252" rel="nofollow noreferrer">Windows-1252</a>. And if you take the string <code>"This is a test file."</code>, encode it into UTF-16, and decode it as Windows-1252, you'll see the unusual string you discovered:</p>
<pre><code>&gt;&gt;&gt; line = "This is a test file."
&gt;&gt;&gt; line_bytes = line.encode('utf-16')
&gt;&gt;&gt; line_bytes.decode('windows-1252')
'ÿþT\x00h\x00i\x00s\x00 \x00i\x00s\x00 \x00a\x00 \x00t\x00e\x00s\x00t\x00 \x00f\x00i\x00l\x00e\x00.\x00'
</code></pre>
<p>The <code>ÿþ</code> is how Windows-1252 treats the BOM. There's still something not quite right, since <code>len(line_bytes)</code> is only 42, not 46, so I have to assume something else is going on with the line endings; if you add <code>\r\n</code> to the original string you do get a 46-character string.</p>
<p>Note that even on Linux, Zed's output is misleading: the input file is 21 <strong>Unicode code points</strong> long, not 21 bytes. It happens to also be 21 bytes only because all the characters in the file are in the ASCII subset of UTF-8 (which is the preferred encoding on Linux, and can be encoded into one byte per character).</p>
</div>
<span class="comment-copy">Your file may contains blank spaces. Oh and yes: which Python version are you using ?</span>
<span class="comment-copy">Both Windows and my Ubuntu VM confirm that this should be <i>20</i> bytes long. Possibly errata within the book.</span>
<span class="comment-copy">Ups, thanks, @brunodesthuilliers, super newbie mistake. Python 3, I will edit the question.</span>
<span class="comment-copy">I see @Mangohero1. Your output is closet to the "correct one". Thanks for check it.</span>
<span class="comment-copy">This seriously looks like the utf-16 encoded representation of "This is a test file" - except for the BOM (should be <code>"\xff\xfe"</code>, not "ÿþ"). You have to understand that strings/byte strings/unicode strings etc are totally different beasts in Python2 and Python3. How did you generate your test file ?</span>
<span class="comment-copy">Really interesting @trentcl. I repeated the full exercise and I got a different result, 42 bytes. This time, before I tried the script I opened test.txt with the Windows Notepad and I pressed "Supr" just after the dot just to be sure there wasn't an extra line or something I couldn't see.  Since I got a different result, something changed...  By the way, thanks for your answer I upvoted your comment, however, I don't have yet enough reputation to upvote "publically".</span>
<span class="comment-copy">@Naiara No problem, and welcome to Stack Overflow! You can accept an answer by clicking the check mark next to it, but I suggest you wait a day or so before doing so because answered questions are less likely to get attention, including upvotes, corrections and additional answers.</span>
<span class="comment-copy">@Naiara By the way, you can edit the file in Notepad and when you click "Save as..." there is an Encoding option that you can use to save in UTF-8. Most editors support this feature one way or another. I don't know how you would do that in PowerShell or if it's even possible.</span>
<span class="comment-copy">I saved the file in UTF-8. The result now is <code>The input file is 23 bytes long</code> which is really close to the original.  I guess my question was a little basic or pointless, I mean, 23 bytes or 42 bytes in such a simple file... But thanks to all your answers guys I learned something new about the Encoding format and that's great.</span>
<span class="comment-copy">@Naiara That could mean it's encoded as UTF-8 without a line terminator but with a byte-order mark (the BOM in UTF-8 is 3 bytes, see also <a href="https://stackoverflow.com/questions/6769311/how-windows-notepad-interpret-characters#6769431">this answer</a>), but you are still decoding it as Windows-1252. If you <code>print(repr(indata))</code> now you will probably get something like <code>'ï»¿This is a test file.'</code> You <i>have</i> to specify the exact encoding to correctly read from (or write to) a text file.</span>
