<div class="post-text" itemprop="text">
<p>I ask for your advice. I want to understand the work of an async on a simple example. According to the legend, you need to create 1000 workers who return some result. But you need to return it as soon as it is ready.
Here is an example:</p>
<pre><code>import asyncio


async def worker(number):
    print("worker # %d" % number)
    await asyncio.sleep(0)
    return str(number)


async def print_when_done(tasks):
    for res in asyncio.as_completed(tasks):
        print("Result worker %s" % await res)


coros = [worker(i) for i in range(10)]
loop = asyncio.get_event_loop()
loop.run_until_complete(print_when_done(coros))
loop.close()
</code></pre>
<p>The problem is that the result of the work of this example is not synchronous, it simply calls the function without blocking the main process, and at the end it returns the responses of all functions</p>
<pre><code>worker # 2
worker # 3
worker # 4
worker # 1
worker # 0
Result worker 2
Result worker 3
Result worker 4
Result worker 1
Result worker 0
</code></pre>
<p>But how to achieve the result in a similarity:</p>
<pre><code>worker # 2
worker # 3
worker # 4
Result worker 3
Result worker 2
worker # 1
Result worker 4
worker # 0
Result worker 1
Result worker 0
</code></pre>
<p>You can create a ThreadPoolExecutor, of course, or the ProcessPoolExecutor. But then why do you need Asyncio, you can create threads without it and work with them.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait" rel="nofollow noreferrer"><code>asyncio.wait</code></a>:</p>
<pre><code>from concurrent.futures import FIRST_COMPLETED

async def print_when_done(pending):
    while True:
        if not pending:
            break

        done, pending = await asyncio.wait(pending, return_when=FIRST_COMPLETED)

        for res in done:
            print("Result worker %s" % res)
</code></pre>
<blockquote>
<p>But then why do you need Asyncio, you can create threads without it and work with them.</p>
</blockquote>
<p>Sure, threads can be more efficient and you can do more things with them, but single-threaded asynchronous cooperative multi-tasking is simpler to coordinate.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>it simply calls the function without blocking the main process, and at
  the end it returns the responses of all functions</p>
</blockquote>
<p>It starts all workers concurrently and this is how it should be, calculates theirs results immediately (since worker doesn't contain anything actually I/O blocking) and return results same time.</p>
<p>If you want to see workers return results in a different time you should make them execute different time - for example, by placing <code>await asyncio.sleep(randint(1, 3))</code> instead your 0-sleep.</p>
<hr/>
<p>I'm not sure I understood why you want this:</p>
<pre><code>worker # 2
worker # 3
worker # 4
Result worker 3
</code></pre>
<p>Since you have <code>print</code> in a top of each worker (without some I/O blocking actions before it) and run all workers concurrently - you will see all theirs prints immediately, before any result.</p>
<p>My random guess is that you may be want to limit count of workers running parallely? In this case you can use synchronization primitives like <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore" rel="nofollow noreferrer">asyncio.Semaphore</a>.</p>
<hr/>
<p>Here's example contains all above:</p>
<pre><code>import asyncio
from random import randint

sem = asyncio.Semaphore(3)  # don't allow more then 3 workers parallely


async def worker(number):
    async with sem:
        print("started # %d" % number)
        await asyncio.sleep(randint(1, 3))
        return str(number)


async def main():
    coros = [worker(i) for i in range(10)]

    for res in asyncio.as_completed(coros):
        print("finished %s" % await res)


if __name__ ==  '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.run_until_complete(loop.shutdown_asyncgens())
        loop.close()
</code></pre>
<p>Output:</p>
<pre><code>started # 0
started # 6
started # 7
started # 2
finished 7
started # 8
finished 0
started # 3
finished 6
started # 9
finished 2
started # 4
finished 8
started # 1
started # 5
finished 3
finished 9
finished 4
finished 1
finished 5
</code></pre>
</div>
<span class="comment-copy">Thanks for the answer. In your version, the answers also come after all the workers are done, but in a random order, they are executed asynchronously. But still, is it possible to get a synchronous response with AsyncIO, because the threads are good, but they require a lot of resources to create them, and if I have them a million</span>
<span class="comment-copy">If all the workers are done in a single cycle of the event loop, then yes, they'll probably all flood in at once. In reality you'd probably use coroutines with varying runtime, in which case they should come in over several event loop iterations.</span>
<span class="comment-copy">Putting it like this, <code>as_completed</code> might already be doing what you want and your issue is simply that all your workers finished simultaneously. I admit to being unfamiliar with <code>as_completed</code>.</span>
<span class="comment-copy">You are basically right. Replacing asyncio.sleep (0) with asyncio.sleep (randint (0.5)) I got the result as it was done. But again, only after all the workers have been created. In other words, if the first worker received, for example, asyncio.sleep (0), then he in theory should immediately return the result, rather than wait for the initialization of the remaining 10,000 vorkers</span>
<span class="comment-copy">Well, no, because all those workers execute on the same thread. The function which is doing the creation of the workers must first yield control of the thread to the event loop (using <code>await</code>). The workers can't actually execute while your worker-creation code is still running. That's the fundamental difference between threading and asyncio. That's the <b><i>cooperative</i></b> in cooperative multi-tasking; functions must yield the execution context to allow others to run.</span>
<span class="comment-copy">Thanks for the answer. I fully agree with you. Your example is very suitable. Why do I need to understand how to achieve this? For example, I need to run 1,000,000 asynchronously, and return the results as soon as they are processed. If you add randin instead of 0, you are right, the result will return as you complete it.  But it will start returning only after the initialization of all tasks has been completed. But why, for example, the first task that got 0 and is ready to immediately answer, wait until the rest is initialized. How to achieve this is the main question</span>
