<div class="post-text" itemprop="text">
<p>Here are two strings:</p>
<pre><code>d = '123'
list1 = '12345'
</code></pre>
<p>Apparently, there are three elements contained in d, which are '1', '2', '3'.
Now, try to replace these three elements by using the elements in list1. And print every possible combination down.</p>
<p>So, we could replace '1' by '1', '2', '3', '4', '5', alternatively, but don't forget we need to do the same thing for '2' and '3' in d.</p>
<p>Then the result would look like:</p>
<pre><code>'111', '112', '113', '114', '115'
'121', '122', '123', '124', '125'
...
...
...
'541', '542', '543', '544', '545'
'551', '552', '553', '554', '555'
</code></pre>
<p>Many thanks for @tobais_k reminding, this question could be described as 'equal characters in the input to be mapped to equal characters in the output'. </p>
<p>Thus if we have <code>d1 = '111222333'</code> the output would be </p>
<pre><code>'111111111', '111111222', '111111333', '111111444', '111111555',
'111222111', '111222222', ..., 
'555555111', '555555222', '555555333', '555555444', '555555555'
</code></pre>
<p>If <code>d2 = '123123123'</code>, the situation will be very different with d1, because we can't get '111111222' from d2. The result would be:</p>
<pre><code>'111111111', '112112112', '113113113', '114114114', '115115115',
'121121121', '122122122', '123123123', '124124124', '125125125',
...
'551551551', '552552552', '553553553', '554554554', '555555555'
</code></pre>
<p>And here's my code to give the result above:</p>
<pre><code>d = '123'
list1 = '12345'
list2 = sorted(set(d))

# make a dict to recognize the position of each element
position = {}
for i in list2:
    position[i] = []
    for (x,y) in enumerate(d):
        if y==i:
            position[i].append(x)
print(position)
# in this caseï¼Œit should return{'1': [0], '2': [1], '3': [2]}


for i1 in list1:
    for i2 in list1:
        for i3 in list1:
            c = list(d)
            # because we know the exact position for each element
            # then we make a new list every time
            # just replace the right element at the right place
            f = [i1, i2, i3]
            j = 0
            for (k,v) in position.items():
                for x in v:
                    c[x]=f[j]
                j += 1
            print(''.join(y for y in c))
</code></pre>
<p>You may wish to try <code>d = '123123123'</code> or <code>d = '111222333'</code> whatever, to check the result,  but notice that they are several embedded "for" in the code and make this code not so Pythonic. </p>
<p>Is there any more elegant way to give the same result?</p>
<p>My code seems a little awkward and no doubt I can learn more from you; then, this skill would help under other situation, e.g. we have a complicate encryptedD ='bccle', key = 'ap'; after passing through this simple programme, we may find out the D actually means 'apple'.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/itertools.html#product" rel="nofollow noreferrer"><code>itertools.product</code></a> to get all the combinations, and combine those with <a href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="nofollow noreferrer"><code>str.maketrans</code></a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="nofollow noreferrer"><code>str.translate</code></a> to map the original characters to their replacements.</p>
<pre><code>&gt;&gt;&gt; d = "121"
&gt;&gt;&gt; list1 = 'abc'
&gt;&gt;&gt; chars = list(set(d))
&gt;&gt;&gt; [d.translate(str.maketrans(dict(zip(chars, prod))))
...  for prod in itertools.product(list1, repeat=len(chars))]
['aaa', 'aba', 'aca', 'bab', 'bbb', 'bcb', 'cac', 'cbc', 'ccc']
</code></pre>
<p>Lets's also have a look at the intermediate results to better understand what's happening:</p>
<pre><code>&gt;&gt;&gt; [prod for prod in itertools.product(list1, repeat=len(chars))]
[('a', 'a'), ('a', 'b'),... , ('c', 'c')]
&gt;&gt;&gt; [dict(zip(chars, prod)) for prod in itertools.product(list1, repeat=len(chars))]
[{'2': 'a', '1': 'a'}, {'2': 'b', '1': 'a'},... , {'2': 'c', '1': 'c'}]
&gt;&gt;&gt; [str.maketrans(dict(zip(chars, prod))) for prod in itertools.product(list1, repeat=len(chars))]
[{49: 'a', 50: 'a'}, {49: 'a', 50: 'b'},... , {49: 'c', 50: 'c'}]
</code></pre>
<hr/>
<p>Or as a generator function (based on first version by @AntonvBR)</p>
<pre><code>def func(values, order):
    """ Returns the combinations of values defined by the set 
    of the order translated back to the length of the order.

    &gt;&gt;&gt; list(func(values='ab', order='1212'))
    ['aaaa', 'baba', 'abab', 'bbbb']
    """
    s = list(set(order))
    for prod in itertools.product(values, repeat=len(s)):
        d = dict(zip(s, prod))
        yield order.translate(str.maketrans(d))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Try product:</p>
<pre><code>import itertools
s = '12345'

["".join(p) for p in itertools.product(s, repeat=3)]
</code></pre>
<p>And if you want to use <code>d = '123'</code> you can change repeat param to <code>len(d)</code>.</p>
<hr/>
<p>Question got updated and an alternative solution would be:</p>
<pre><code>import itertools

s = '12345'
d = '111222333'

[''.join(dict(zip(set(d),p))[k] for k in d) for 
    p in itertools.product(s, repeat=len(set(d)))]
</code></pre>
<p>However.. I ran some small timings and the accepted answer is faster. So I'd stick to that.</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>we have a complicate encryptedD ='bccle', key = 'ap'; after passing through this simple programme, we may find out the D actually means 'apple'.</p>
</blockquote>
<pre><code>import itertools

d = 'bccle'
key = 'ap'
</code></pre>
<p><strong>Step: 1</strong> - Create a list of lists: <code>[[b],[c],[c],[l],[e]]</code></p>
<pre><code>z = [list(x) for x in d]
</code></pre>
<p><strong>Step: 2</strong> - Append the key letters to the list: <code>[[b,a,p],[c,a,p],[c,a,p],[l,a,p][e,a,p]]</code></p>
<pre><code>z = [set(y + list(key)) for y in z]
</code></pre>
<p><strong>Step: 3</strong> - Use <code>itertools.product()</code> to create the combinatoric list of words.</p>
<pre><code>[''.join(t) for t in list(itertools.product(*z))]
</code></pre>
<p>'apple' is one of the results.</p>
</div>
<div class="post-text" itemprop="text">
<p>Everyone is going to give you loop solution, If you want to try little different approach not that same old loop approach then you can try this :</p>
<blockquote>
<p>Without loop in one line :</p>
</blockquote>
<pre><code>d = '123'
list1 = '12345'

import itertools


print(list(map(lambda x:list(map(lambda y:"".join((x,y[0],y[1])),itertools.product(list1,repeat=2))),d)))
</code></pre>
<p>output:</p>
<pre><code>[['111', '112', '113', '114', '115', '121', '122', '123', '124', '125', '131', '132', '133', '134', '135', '141', '142', '143', '144', '145', '151', '152', '153', '154', '155'], ['211', '212', '213', '214', '215', '221', '222', '223', '224', '225', '231', '232', '233', '234', '235', '241', '242', '243', '244', '245', '251', '252', '253', '254', '255'], ['311', '312', '313', '314', '315', '321', '322', '323', '324', '325', '331', '332', '333', '334', '335', '341', '342', '343', '344', '345', '351', '352', '353', '354', '355']]
</code></pre>
</div>
<span class="comment-copy">Confusing as 1,2,3 has nothing to do with the question. You would just need to find combos with list1 and 3.</span>
<span class="comment-copy">@AntonvBR Exactly, it's nothing like a replacement of a string, but a simple combinatorics question.</span>
<span class="comment-copy">@Anton vBR Actually, it does matter.  OP should have provided different numbers, like <code>d = '678'</code> and <code>list1 = '12345'</code>  Check out my solution below.</span>
<span class="comment-copy">@Anton vBR In this case, the d is simple. (I tried to used a complicated string to consult others but confused them, too :) ) If <code>d1 = '111222333'</code> and <code>d2 = '123123123'</code>, the situation will be different.  For d1, one result could be <code>'111111222'</code>, but d2 cant give the same result, although some of the results could be the same (e.g. <code>'111111111', '555555555'</code>). But I learned from your answer that the itertools is a really powerful and elegant library, still many thanks for your time on my question.</span>
<span class="comment-copy">@FanLiu I don't get what you are saying with d1 and d2.  Can you show an example with its output maybe?  I'm now wondering if I gave you a correct answer or not.</span>
<span class="comment-copy">Removed the list() around set and added a function based on your solution to reapply, hope you don't mind. +1</span>
<span class="comment-copy">@AntonvBR The <code>list</code> may not be necessary, but I'd like to keep it to ensure same iteration order (call me superstitious if you like). Also, changed the function to a generator, as the product might become <i>really</i> big.</span>
<span class="comment-copy">I think OP want's equal characters in the input to be mapped to equal characters in the output.</span>
<span class="comment-copy">@tobias_k You really know me, man:) I'll change the discription by using your idea, and hope you don't mind.</span>
<span class="comment-copy">Those <i>are</i> strings that just coincidentally contain digits. Also, your algorithm will only replace a single character at a time and not create all possible combinations.</span>
<span class="comment-copy">@tobias_k I have changed my answer.  I found out that I was completely wrong the first time.  Thank you.</span>
<span class="comment-copy">I gave the same result as you did firstly. Thanks for supporting and I'll learn the way to use 'itertools'</span>
