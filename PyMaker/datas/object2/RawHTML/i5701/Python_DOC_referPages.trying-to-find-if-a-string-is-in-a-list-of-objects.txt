<div class="post-text" itemprop="text">
<p>I'm not sure if this is possible as having trouble finding and answer online, could be as I don't know have to work the question. so the code below is a basic example of what I am trying to do. </p>
<pre><code>class Names():
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return self.name

&gt;&gt;&gt; i = []
&gt;&gt;&gt; i.append(Names("bob"))
&gt;&gt;&gt; i.append(Names("jill"))
&gt;&gt;&gt; i
[bob, jill]
&gt;&gt;&gt; "bob" in i
False
</code></pre>
<p>I have a list of the Name class and want to return True if a name already exists in there. If know how I could get this working?</p>
</div>
<div class="post-text" itemprop="text">
<p>There are a couple of ways you could do this.</p>
<p>The easiest is to iterate through with <code>any</code>:</p>
<pre><code>any(item.name == 'bob' for item in i)
</code></pre>
<p>The more complex version is to define an <code>__eq__</code> method on your class:</p>
<pre><code>def __eq__(self, val):
    return self.name == val
</code></pre>
<p>and now your original <code>"bob" in i</code> code will work.</p>
<p>(For real code, you'd probably want to check in that method if you're between two instances of Names, rather than with a string.)</p>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate over your list and check the <code>.name</code> attribute of each object against your string.</p>
<pre><code>&gt;&gt;&gt; any('bob' == j.name for j in i)
True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To point out more detail.</p>
<p>When you ask </p>
<pre><code>"bob" in i
</code></pre>
<p>you are asking if the string <code>"bob"</code> is in the list. 
Even if you ask if</p>
<pre><code>Names("bob") in i
</code></pre>
<p>you get False because that exact object isn't in the list.</p>
<p>You can add an <code>__eq__</code> method inside you class if you want to treate <code>Names</code> with the same <code>name</code> as identical:</p>
<pre><code>class Names():
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return self.name
    def __eq__(self, other):
        return self.name == other.name
</code></pre>
</div>
<span class="comment-copy">do <code>print([type(h) for h in i])</code> and you will see why <code>False</code> is returned. Or simply notice that there are no quotes (<code>bob</code> .vs. <code>'bob'</code>)</span>
<span class="comment-copy">Look on this topic here you can find your answer: <a href="https://stackoverflow.com/questions/3435089/how-to-check-if-object-already-exists-in-a-list" title="how to check if object already exists in a list">stackoverflow.com/questions/3435089/â€¦</a></span>
<span class="comment-copy">@KrzysztofPacholski Wrong language?</span>
<span class="comment-copy">Exactly what I was thinking of, using <code>__eq__</code>.</span>
<span class="comment-copy">Worth mentioning <code>__hash__</code> if you're over-riding <code>__eq__</code> as you're making the object unhashable without it <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" rel="nofollow noreferrer">docs.python.org/3/reference/datamodel.html#object.__hash__</a></span>
<span class="comment-copy">Thanks all the <b>eq</b> has worked perfect :)</span>
<span class="comment-copy">I have to imagine that there's a more OOP oriented way of doing this, by overloading some magic method somewhere...</span>
<span class="comment-copy">There is, but I tend to be cautious with how liberally I allow equality to be defined. I tend to reserve that for equality between two objects by checking some subset of their attributes</span>
