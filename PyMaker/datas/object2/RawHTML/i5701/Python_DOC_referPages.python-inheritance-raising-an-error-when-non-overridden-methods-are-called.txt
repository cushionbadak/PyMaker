<div class="post-text" itemprop="text">
<p>I am writing a subclass of <code>dict</code> that maps from string keys to values of arbitrary types. If a key is a regex, it is stored and queried separately.</p>
<pre><code>class RegexDict(dict):
    def __init__(self):
        super().__init__()  # non-regex keys in the parent class
        self.regex_dict = {}  # regex keys in the child class

    def __getitem__(self, key):
        try:
            return super().__getitem__(key)
        except KeyError:
            for x in self.regex_dict:
                if re.fullmatch(x, key):
                    return self.regex_dict[x]
        raise KeyError(key)

    def __setitem__(self, key, value):
        key, is_regex = key
        if is_regex:
            self.regex_dict[key] = value
        else:
            super().__setitem__(key, value)
</code></pre>
<p>Because this class will be used by other libraries (which is why I have to use inheritance), I want to make sure that an error is raised when non-overridden methods in the base class are called. How should I do this?</p>
</div>
<div class="post-text" itemprop="text">
<p>You should inherit from <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer"><code>collections.abc.MutableMapping</code></a> instead of dict.</p>
<p>It will fill in the gaps automatically, and also let you know which things you have to implement.</p>
<p>In addition to <code>__getitem__</code> and <code>__setitem__</code>, you’ll also have to implement <code>__delitem__</code>, <code>__iter__</code> and <code>__len_</code>. If you can’t implement those reasonably, you can raise e.g. <code>NotImplementedError</code> from them (even though that will limit the use of your class a lot).</p>
<p>This will have the advantage that all dict methods which only need <code>__getitem__</code> and <code>__setitem__</code> (+ what you implement) internally will work out of the box.</p>
</div>
<div class="post-text" itemprop="text">
<p>Don't subclass. To convince third-party libs that your object is a <em>dict</em>, set <code>__class__</code> attribute.</p>
<pre><code>class RegexDict():
    __class__ = dict

    def __init__(self):
        self.non_regex_dict = {}
        self.regex_dict = {}

    def __getitem__(self, key):
        try:
            return self.non_regex_dict[key]
        except KeyError:
            for x in self.regex_dict:
                if re.fullmatch(x, key):
                    return self.regex_dict[x]
        raise KeyError(key)

    def __setitem__(self, key, value):
        key, is_regex = key
        if is_regex:
            self.regex_dict[key] = value
        else:
            self.non_regex_dict[key] = value

rd = RegexDict()
print(isinstance(rd, dict))
rd.clear()
</code></pre>
<p>output:</p>
<pre><code>True
Traceback (most recent call last):
  File "libo.py", line 30, in &lt;module&gt;
    rd.clear()
AttributeError: 'RegexDict' object has no attribute 'clear'
</code></pre>
</div>
<span class="comment-copy">Sadly, from my experience, inheriting <i>MutableMapping</i> is not enough for many libs, even for mainstream like <i>pandas</i>. Additionally, those methods working out of the box seem to be in contrary to OPs needs.</span>
<span class="comment-copy">This is indeed the ideal case, but I do need to make the class work with <code>pandas</code>. Internally, <code>pandas</code> calls <code>np.dtype()</code>, which is unfortunately not compatible with custom types.</span>
<span class="comment-copy">This solution did not work with <code>pandas</code> on my machine. It failed when <code>pandas</code> called <code>np.dtype()</code> with a <code>RegexDict</code> instance. I'm interested in why this didn't work but inheritance did, but I wan't able to find <code>np.dtype()</code> in the Numpy source code.</span>
<span class="comment-copy">@LiboYin Could you provide an example? Please edit your question.</span>
