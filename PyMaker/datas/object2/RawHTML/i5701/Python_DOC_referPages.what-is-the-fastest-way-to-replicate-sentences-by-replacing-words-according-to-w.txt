<div class="post-text" itemprop="text">
<p>I have a word list and some sentences I need to replicate:</p>
<pre><code>wordlist_dict = {
    'class1': ['word_a', 'word_b', 'word_c'],
    'class2': ['word_d', 'word_e'],
    'class3': ['word_f', 'word_g', 'word_h', 'word_i', 'word_a']
}

sent_list = [
    "I have a sentence with word_g",
    "And another sentence with word_d",
    "Don't forget word_b",
    "no keyword here",
    "Last sentence with word_c and word_e"
]
</code></pre>
<p>My expected results are:</p>
<pre><code>I have a sentence with word_f
I have a sentence with word_h
I have a sentence with word_i
I have a sentence with word_a
And another sentence with word_e
Don't forget word_a
Don't forget word_c
Last sentence with word_a and word_d
Last sentence with word_a and word_e
Last sentence with word_b and word_d
Last sentence with word_b and word_e
Last sentence with word_c and word_d
</code></pre>
<p>Here is my method:</p>
<pre><code>import re

pattern_list = []
pattern_all = ''
wordlist = sorted(wordlist_dict.values())
for v in wordlist:
    pattern_list.append('({})+'.format('|'.join(v)))
    pattern_all += '|' + '|'.join(v)
pattern_all = '({})+'.format(pattern_all[1:])
print(pattern_list)
# ['(word_a|word_b|word_c)+', '(word_d|word_e)+', '(word_f|word_g|word_h|word_i)+']
print(pattern_all)
# (word_a|word_b|word_c|word_d|word_e|word_f|word_g|word_h|word_i)+

new_sent_list = []
for sent in sent_list:
    match_list = re.findall(pattern_all, sent)
    print(match_list)
    if match_list:
        for match in match_list:
            for i in range(len(pattern_list)):
                if re.search(pattern_list[i], sent):
                    if match in wordlist[i]:
                        match_wordlist = wordlist[i]
                        match_wordlist.remove(match)
                        for word in match_wordlist:
                            new_sent_list.append(sent.replace(match, word))
                    else:
                        continue
</code></pre>
<p>And I wonder if there is any way more efficient to do this because my word list and sentence list are much larger than in the example. Thanks in advance.</p>
<p>Update: I just realized there are words that belong to more than one class and sentences that have more than one keyword, so my code doesn't work now.</p>
</div>
<div class="post-text" itemprop="text">
<p>First, you could "invert" the <code>wordlist_dict</code> to a dictionary mapping words to their classes. Here, I'll assume that each word is in only one class, otherwise it get's a bit more complicated.</p>
<pre><code>wordclass_dict = {w: c for c in wordlist_dict for w in wordlist_dict[c]}
</code></pre>
<p>Next, you can find all the occurrences of any of the words, using the <code>pattern</code> to (a) get all the words classes, and (b) create a template for re-formatting the sentence. Note that I wrap the pattern into word boundaries <code>\b</code> so it does not match word-fragments.</p>
<pre><code>pattern = r"\b(" + "|".join(wordclass_dict) + r")\b"
classes = [wordclass_dict[c] for c in re.findall(pattern, sentence)]
template = re.sub(pattern, "{}", sentence)
</code></pre>
<p>Now, you can iterate the <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow noreferrer"><code>product</code></a> of all the possible replacements and substitute them:</p>
<pre><code>for prod in itertools.product(*(wordlist_dict[c] for c in classes)):
    print(template.format(*prod))
</code></pre>
<p>This way, the result for sentence <code>"And another sentence with word_a and word_d"</code> is:</p>
<pre><code>And another sentence with word_a and word_d
And another sentence with word_a and word_e
And another sentence with word_b and word_d
And another sentence with word_b and word_e
And another sentence with word_c and word_d
And another sentence with word_c and word_e
</code></pre>
<p>This should be considerably faster than your approach (did not time it, though), as it only searches twice for the <code>pattern</code>, whereas you search for each individual pattern separately. Also, this works for sentences that have more than one placeholder word.</p>
<hr/>
<p>If a word <em>can</em> be in multiple classes, you can use this:</p>
<pre><code>wordclass_dict = collections.defaultdict(list)
for c in wordlist_dict:
    for w in wordlist_dict[c]:
        wordclass_dict[w].append(c)

# pattern, classes, template as above

for prod in itertools.product(*([w for c in cls for w in wordlist_dict[c]] 
                                for cls in classes)):
    print(template.format(*prod))
</code></pre>
<p>You <em>could</em> also <code>extend</code> the <code>wordclass_dict</code> entries with all the words thenselves, instead of their class names, making the <code>product</code> much simpler, but at the price of potentially much higher space requirements, depending on the size of the word classes and the "overlap".</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's an alternative version that implements the following idea: have an inverted dictionary "word -&gt; class" for a quick lookup. This assumes the mapping is invertable. Then, kick off <code>replace()</code> to print the replacement on all other words within the word class.</p>
<pre><code>def replace(s, v, c):
    for w in filter(lambda w: w != v, wordlist_dict[c]):
        print(s.replace(v, w))

def invert(d):
    inv = {}
    for (c,ws) in d.items():
        for w in ws:
            inv[w] = c
    return inv

inv_dict = invert(wordlist_dict)

for s in sent_list:
    for w in s.split():
        if w in inv_dict:
            replace(s, w, inv_dict[w])
            break
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try this:</p>
<pre><code>import re
wordlist_dict = {
'class1': ['word_a', 'word_b', 'word_c'],
'class2': ['word_d', 'word_e'],
'class3': ['word_f', 'word_g', 'word_h', 'word_i']
}

sent_list = [
  "I have a sentence with word_g",
  "And another sentence with word_d",
  "Don't forget word_b",
  "no key word here"
]
final_data = [filter(lambda x:x!=''.join(re.findall('(?&lt;=\s)[a-zA-Z]+_[a-zA-Z]+$', i)), [c for a, c in wordlist_dict.items() if any(h.endswith(''.join(re.findall('(?&lt;=\s)[a-zA-Z]+_[a-zA-Z]+$', i))) for h in c)][0]) for i in sent_list]
new_final_data = [a for i, a in enumerate(final_data) if not any(c in d for d in final_data[:i] for c in a)]
second_final_data = reduce(lambda x, y:x+y, [[a[:-6]+b for b in c] for a, c in zip(sent_list, new_final_data)])
</code></pre>
<p>Output:</p>
<pre><code>['I have a sentence with word_f', 'I have a sentence with word_h', 'I have a sentence with word_i', 'And another sentence with word_e', "Don't forget word_a", "Don't forget word_c"]
</code></pre>
</div>
<span class="comment-copy">If your code is otherwise working, you may ask on <a href="https://codereview.stackexchange.com">Code Review</a>. Thanks in advance.</span>
<span class="comment-copy">I just realized there are words that belong to more than one class and sentences that have more than one keyword, but thanks for the help.</span>
<span class="comment-copy">Sorry but I'm having difficulty in reading your code. Could you explain a little bit? Also I just realized there are words that belong to more than one class and sentences that have more than one keyword.</span>
<span class="comment-copy">@T.Stark If it comforts you, I'm having trouble reading that code, as well. :-P Ajax, maybe you could break that "one-liner" down to many lines, or extract that (identical?) <code>join</code> part into a <code>lambda</code>?</span>
