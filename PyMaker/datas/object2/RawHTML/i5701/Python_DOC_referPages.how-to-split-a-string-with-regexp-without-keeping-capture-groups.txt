<div class="post-text" itemprop="text">
<p>I want to split text with a regular expression <strong><em>with backreference</em></strong> in <code>Python</code>.</p>
<pre><code>rexp = re.compile(r"([`]{1,})ABC\1")
rexp.split("blahblah``ABC``blahblah")
</code></pre>
<p>I got <code>['blahblah', '``', 'blahblah']</code> but expected <code>['blahblah', 'blahblah']</code>.
How can I split string without keeping capture groups?</p>
</div>
<div class="post-text" itemprop="text">
<p>From the <a href="https://docs.python.org/3/library/re.html#re.split" rel="nofollow noreferrer"><code>re.split()</code></a> documentation: </p>
<blockquote>
<p>If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list.</p>
</blockquote>
<p>Since you want to use a backreference you can't avoid the first capturing group, but you can make the rest of them non-capturing and post-process your split to get what you want, e.g.:</p>
<pre><code>rexp = re.compile(r"([`]{1,})-&gt;\s*(?:\S+)\s*\|(?:.+?)&lt;-\1")
rexp.split("blahblah``-&gt;Left|Right&lt;-``blahblah")[0::2]  # ['blahblah', 'blahblah']
</code></pre>
<p><strong>UPDATE</strong>: I just noticed that you changed your pattern in the meantime, but the principle is just the same:</p>
<pre><code>rexp = re.compile(r"([`]{1,})ABC\1")  # also, if optimizing, equivalent to: (`+)ABC\1
rexp.split("blahblah``ABC``blahblah")[0::2]  # ['blahblah', 'blahblah']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could first replace the split pattern with a unique delimiter then split on that:</p>
<pre><code>&gt;&gt;&gt; s="blahblah``ABC``blahblah"
&gt;&gt;&gt; delim="&lt;-split-&gt;"
&gt;&gt;&gt; re.split(delim, re.sub(r"([`]+)ABC\1", delim, s))
['blahblah', 'blahblah']
</code></pre>
<p>The advantage to this approach is you do not need to make an assumption on where the split pattern is in your string. </p>
<p>You can also then use the speedier Python split since you have converted a regex target to fixed strings:</p>
<pre><code>&gt;&gt;&gt; re.sub(r"([`]+)ABC\1", delim, s).split(delim)
['blahblah', 'blahblah']
</code></pre>
<hr/>
<h1>Update</h1>
<p>Timing showing this is just as fast as the accepted answer:</p>
<pre><code>import re

def f1(s):
    rexp = re.compile(r"([`]{1,})ABC\1")
    return rexp.split(s)[0::2]

def f2(s):
    delim="&lt;-split-&gt;"  
    rexp1=re.compile(r"([`]+)ABC\1")  
    rexp2=re.compile(delim)
    return rexp2.split(rexp1.sub(delim, s))

def f3(s):
    delim="&lt;-split-&gt;"  
    rexp=re.compile(r"([`]+)ABC\1")  
    return rexp.sub(delim, s).split(delim) 

if __name__=='__main__':
    import timeit    
    for case, x in (('small',1000),('med',10000),('large',1000000)):  
        s="blahblah``ABC``blahblah"*x
        print("Case {}, {:,} x, All equal: {}".format(case,x,(f1(s)==f2(s)==f3(s))))
        for f in (f1,f2,f3):
            print("   {:^10s}{:.4f} secs".format(f.__name__, timeit.timeit("f(s)", setup="from __main__ import f, s", number=10)))
</code></pre>
<p>On my older iMac, Python 3.6, prints:</p>
<pre><code>Case small, 1,000 x, All equal: True
       f1    0.0049 secs
       f2    0.0048 secs
       f3    0.0045 secs
Case med, 10,000 x, All equal: True
       f1    0.0512 secs
       f2    0.0536 secs
       f3    0.0526 secs
Case large, 1,000,000 x, All equal: True
       f1    5.2092 secs
       f2    5.6808 secs
       f3    5.5388 secs
</code></pre>
<p>With PyPy, it is faster to do it the way I am suggesting:</p>
<pre><code>Case small, 1,000 x, All equal: True
       f1    0.0020 secs
       f2    0.0021 secs
       f3    0.0012 secs
Case med, 10,000 x, All equal: True
       f1    0.0325 secs
       f2    0.0288 secs
       f3    0.0217 secs
Case large, 1,000,000 x, All equal: True
       f1    4.4900 secs
       f2    3.0680 secs
       f3    2.1079 secs
</code></pre>
<p>So not sure what you mean by <em>for very large input string, it's a terrible cost...</em> -- the timing show it is either the same or faster even with huge input strings.</p>
</div>
<span class="comment-copy">@GarbageCollector But I can't use non-capturing groups due to backreference.</span>
<span class="comment-copy">Make other group non-capturing make this problem really simple, thanks!</span>
<span class="comment-copy">for very large input string, it's a terrible cost...</span>
<span class="comment-copy">It won't be any worse than using re.split with a similar regex. See timing... On PyPy, it is significantly <i>faster</i></span>
