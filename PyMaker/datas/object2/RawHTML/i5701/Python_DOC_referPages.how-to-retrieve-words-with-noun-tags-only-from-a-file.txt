<div class="post-text" itemprop="text">
<p>I need to retrieve only those words from a file whose pos tags are:'NN'or 'NNP' or 'NNS' or 'NNPS'.
My sample input is:</p>
<pre><code>  [['For,IN', ',,,', 'We,PRP', 'the,DT', 'divine,NN', 'caused,VBD', 'apostle,NN', 'We,PRP', 'vouchsafed,VBD', 'unto,JJ', 'Jesus,NNP', 'the,DT', 'son,NN', 'of,IN', 'Mary,NNP', 'all,DT', 'evidence,NN', 'of,IN', 'the,DT', 'truth,NN', ',,,', 'and,CC', 'strengthened,VBD', 'him,PRP', 'with,IN', 'holy,JJ'], [ 'be,VB', 'nor,CC', 'ransom,NN', 'taken,VBN', 'from,IN', 'them,PRP', 'and,CC', 'none,NN', '\n']]
</code></pre>
<p>My expected output is:</p>
<pre><code> [ 'divine', 'apostle','Jesus', 'son','Mary',  'evidence',  'truth',  'ransom', 'none']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your input is a <code>list</code> of a <code>list</code>, You could use a <a href="https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions" rel="nofollow noreferrer">nested list comprehension</a>:</p>
<pre><code>a_list = [['For,IN', ',,,', 'indeed,RB', ',,,', 'We,PRP', 'vouchsafed,VBD', 'unto,JJ', 'Moses,NNPS', 'the,DT', 'divine,NN', 'writ,NN', 'and,CC', 'caused,VBD', 'apostle,NN', 'after,IN', 'apostle,NN', 'to,TO', 'follow,VB', 'him,PRP', ';,:', 'and,CC', 'We,PRP', 'vouchsafed,VBD', 'unto,JJ', 'Jesus,NNP', ',,,', 'the,DT', 'son,NN', 'of,IN', 'Mary,NNP', ',,,', 'all,DT', 'evidence,NN', 'of,IN', 'the,DT', 'truth,NN', ',,,', 'and,CC', 'strengthened,VBD', 'him,PRP', 'with,IN', 'holy,JJ']]

pos_tags = (',NN', ',NNP', ',NNS', ',NNPS')

nouns = [s.split(',')[0] for sub in a_list for s in sub if s.endswith(pos_tags)]

print(nouns)

['Moses', 'divine', 'writ', 'apostle', 'apostle', 'Jesus', 'son', 'Mary', 'evidence', 'truth']
&gt;&gt;&gt; 
</code></pre>
<p><strong>Edit</strong>:</p>
<pre><code>a_list = [['For,IN', ',,,', 'We,PRP', 'the,DT', 'divine,NN', 'caused,VBD', 'apostle,NN', 'We,PRP', 'vouchsafed,VBD', 'unto,JJ', 'Jesus,NNP', 'the,DT', 'son,NN', 'of,IN', 'Mary,NNP', 'all,DT', 'evidence,NN', 'of,IN', 'the,DT', 'truth,NN', ',,,', 'and,CC', 'strengthened,VBD', 'him,PRP', 'with,IN', 'holy,JJ'], ['be,VB', 'nor,CC', 'ransom,NN', 'taken,VBN', 'from,IN', 'them,PRP', 'and,CC', 'none,NN', '\n']]
pos_tags = (',NN', ',NNP', ',NNS', ',NNPS')

nouns = [s.split(',')[0] for sub in a_list for s in sub if s.endswith(pos_tags)]

print(nouns)

['divine', 'apostle', 'Jesus', 'son', 'Mary', 'evidence', 'truth', 'ransom', 'none']
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's a simple method based on list comprehensions:</p>
<pre><code>x = ['For,IN', ....]
y = [w.split(',')[0] for w in x if ',NN' in w]
</code></pre>
<p>It basically iterates over all words, takes only those that contain <code>",NN"</code> and cuts out the part before the comma.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can try something like this with regular expression in just one line :</p>
<pre><code>import re
pattern=r'\w+(?=,NN)'
data=[['For,IN', ',,,', 'We,PRP', 'the,DT', 'divine,NN', 'caused,VBD', 'apostle,NN', 'We,PRP', 'vouchsafed,VBD', 'unto,JJ',
  'Jesus,NNP', 'the,DT', 'son,NN', 'of,IN', 'Mary,NNP', 'all,DT', 'evidence,NN', 'of,IN', 'the,DT', 'truth,NN', ',,,',
  'and,CC', 'strengthened,VBD', 'him,PRP', 'with,IN', 'holy,JJ'],
 ['be,VB', 'nor,CC', 'ransom,NN', 'taken,VBN', 'from,IN', 'them,PRP', 'and,CC', 'none,NN', '\n']]

print(list(map(lambda x:list(filter(lambda y:re.search(pattern,y)!=None,x)),data)))
</code></pre>
<p>output:</p>
<pre><code>[['divine,NN', 'apostle,NN', 'Jesus,NNP', 'son,NN', 'Mary,NNP', 'evidence,NN', 'truth,NN'], ['ransom,NN', 'none,NN']]
</code></pre>
<p>Now if you want without 'NN' then :</p>
<pre><code>print([re.search(pattern,j).group() for i in data for j in i if isinstance(i,list) if re.search(pattern,j)!=None])
</code></pre>
<p>output:</p>
<pre><code>['divine', 'apostle', 'Jesus', 'son', 'Mary', 'evidence', 'truth', 'ransom', 'none']
</code></pre>
</div>
<span class="comment-copy">It gives list index out of range error.</span>
<span class="comment-copy">@Nisa, please see the code work at <a href="https://repl.it/repls/RedSandyBluefish" rel="nofollow noreferrer">repl.it</a>.</span>
<span class="comment-copy">i have input like this :  [['For,IN', ',,,',  'We,PRP',  'the,DT', 'divine,NN',  'caused,VBD', 'apostle,NN',  'We,PRP', 'vouchsafed,VBD', 'unto,JJ', 'Jesus,NNP', 'the,DT', 'son,NN', 'of,IN', 'Mary,NNP', 'all,DT', 'evidence,NN', 'of,IN', 'the,DT', 'truth,NN', ',,,', 'and,CC', 'strengthened,VBD', 'him,PRP', 'with,IN', 'holy,JJ'], [ 'be,VB', 'nor,CC', 'ransom,NN', 'taken,VBN', 'from,IN', 'them,PRP',  'and,CC', 'none,NN', '\n']]</span>
<span class="comment-copy">please check my input format in the comment then suggest some solution..with this input it is giving list index out of range error in repl.it as well.</span>
<span class="comment-copy">Please see the edit work at <a href="https://repl.it/repls/PerkyImmediateImperatorangel" rel="nofollow noreferrer">repl.it</a>.</span>
<span class="comment-copy">It is giving an empty list. As you can see in my sample input it is a list within a list.</span>
<span class="comment-copy">Well then replace x by x[0].</span>
