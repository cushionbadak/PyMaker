<div class="post-text" itemprop="text">
<p>I'm trying to speed up a section of code that's called a LOT in the hope to cut a script run-time down.</p>
<p>Say I have a multidimensional array:</p>
<pre><code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<p>And a single-dimensional array of indices:</p>
<pre><code>[2], [0], [1]
</code></pre>
<p>Without a loop, is there a way to retrieve those indices from the multi-dimensional array, i.e,:</p>
<pre><code>[3], [4], [8]
</code></pre>
<p>Any help appreciated!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could use <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="nofollow noreferrer"><code>itertools.starmap</code></a></p>
<pre><code>import itertools


def get_values_from_indices(array_values, array_indices):
    """
    This function will accept two params, 
    once is a multi-dimensional list, and other one is list of indices.
    """
    return list(itertools.starmap(lambda x, y: x[y[0]], zip(array_values, array_indices)))
</code></pre>
<p><strong>DEMO</strong></p>
<pre><code>multi_dimensional_array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
list_of_indices = [[2], [0], [1]]

result = get_values_from_indices(multi_dimensional_array , list_of_indices)

print(result)
# [3, 4, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Not sure exactly how you would want your result, but with numpy you could achieve something similar below.</p>
<pre><code>import numpy as np
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# array([[1, 2, 3],
#   [4, 5, 6],
#   [7, 8, 9]])

a[[0,1,2],[2,0,1]] # array([3, 4, 8])
a[[0,1,2],[1,2,1]] # array([2, 6, 8])
</code></pre>
<p>May even be,</p>
<pre><code>indices = [[2],[0],[1]]
a[range(len(indices)), np.reshape(indices, -1)] # array([3, 4, 8])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions:</p>
<pre><code>listOfList = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

indexInto = [2, 0, 1]       # first version works for this
indexTwo = [[2], [0], [1]]  # second version works for this

# first version
values = [listOfList[lili][indexInto[lili]] for lili in range(len(listOfList))] # both lists need same length

# second version
values2 = [listOfList[lili][indexTwo[lili][0]] for lili in range(len(listOfList))] # both lists need same length

print( values)
print( values2)
</code></pre>
<p>Output:</p>
<pre><code>[3, 4, 8]    
[3, 4, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Another numpy solution:</p>
<pre><code>a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

a2 = [[2], [0], [1]]

a[np.arange(len(a)), np.concatenate(a2)]  # array([3, 4, 8])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Numpy solution:</p>
<pre><code>import numpy as np

L = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
ind = [[2], [0], [1]]
a = np.array(L)
b = np.array(ind)

c = a[np.arange(len(a)), b.reshape(-1)]
print (c.tolist())
[3, 4, 8]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Lambda solution with map without importing any external module in just one line :</p>
<pre><code>list_1=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
indices=[[2], [0], [1]]

print(list(map(lambda x,y :list(map(lambda z:x[z],y)),list_1,indices)))
</code></pre>
<p>output:</p>
<pre><code>[[3], [4], [8]]
</code></pre>
</div>
<span class="comment-copy">Question is not clear</span>
<span class="comment-copy">Does a list comprehension also count as for loop?</span>
<span class="comment-copy">How big is your array?</span>
<span class="comment-copy">I'm already using itertools for flattening a multidimensional array - I'll give this a go and report back!</span>
<span class="comment-copy">I've learned a lot about lambdas and iterables in the last hour and I've been able to do what I'd hoped using a map function.  Sadly, it's only slightly faster - but every bit counts!  Thanks heaps :)</span>
