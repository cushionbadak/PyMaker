<div class="post-text" itemprop="text">
<p>I have class in which I want to implement list-like or dict-like behavior through a class variable.</p>
<pre><code>class Property(list):
    def __init__(self, data: list = None, name: str):
        self.data = data or []
        self.name = name

prop = Property([1,2,3,4,5,6,7,8,9,10], 'property')
print(prop[1])  # 2
print(prop[:3])  # [1, 2, 3]
print(prop.name)  # 'property'
</code></pre>
<p>I want Property when it is called with some list methods, like append(), pop(), index() to work with self.data variable as list.</p>
<pre><code>class Node(dict):
    def __init__(self, data: dict = None):
        self.data = data or {}
        self.order = []
        for x in data:
            # do stuff to fill data &amp; order

node = Node({'a': '1', 'b': '2', 'c': '3'})
print(node.keys())  # ['a', 'b', 'c']
print('c' in node)  # True
print(node['b'])  # '2'
print(node.order)  # some ordered list
</code></pre>
<p>Same here, I want it to work directly with self.data variable with dict-like methods.</p>
<p>Is there a way to do so with something like <code>super().__init__()</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>You want the UserList and UserDict classes from the <a href="https://docs.python.org/3/library/collections.html" rel="nofollow noreferrer">collections</a> module.  You can't get the behaviour you expect by inheriting directly from the builtin list and dict types because they're implemented in C (in CPython at least), so these classes were made for this purpose. </p>
<pre><code>from collections import UserList, UserDict, OrderedDict

class Property(UserList):
    def __init__(self, data: list = None, name: str = None):
        self.data = data or []
        self.name = name

prop = Property([1,2,3,4,5,6,7,8,9,10], 'property')
print(prop[1])  # 2
print(prop[:3])  # [1, 2, 3]
print(prop.name)  # 'property'

class Node(UserDict):
    def __init__(self, data: dict = None):
        self.data = OrderedDict(data) if data else OrderedDict()

node = Node({'a': '1', 'b': '2', 'c': '3'})
print(node.keys())  # KeysView(OrderedDict([('a', '1'), ('b', '2'), ('c', '3')]))
print([c for c in node.keys()]) # ['a','b','c']
print('c' in node)  # True
print(node['b'])  # '2'
</code></pre>
<p>You need to do some more work on your dict class but I think you can figure that out.</p>
<p>It's also worth noting that you could use an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> for Node data, which gives you the ordering you want.</p>
</div>
<span class="comment-copy">In that case, you may not want an <code>__init__</code> method in your subclass...</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ, I have edited the examples ^_^</span>
<span class="comment-copy">You must decide whether you want Property to be a list subclass or have a list as an attribute.  Don't make it both.  If instances are a list, initialize self, not self.data.  If instances have a list as 'data', you must write the Property methods that call data methods yourself.</span>
<span class="comment-copy">"you can't really" is ambigous. Either you can or you can't. And you can, but you'll not be able to get the expected behaviour when overriding special methods.</span>
<span class="comment-copy">Hence "you can't really", because as you say you can but you won't get any of the behaviour you want.</span>
<span class="comment-copy">That's right, I am just suggesting you to be explicit in your answer, for those unaware of this, as might be the OP case.</span>
<span class="comment-copy">Fair enough, edited the answer.</span>
<span class="comment-copy">@Turksarama thanks for the idea, I'll try to figure it out.</span>
