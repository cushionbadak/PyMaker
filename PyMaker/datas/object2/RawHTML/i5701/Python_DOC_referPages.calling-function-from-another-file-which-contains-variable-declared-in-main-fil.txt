<div class="post-text" itemprop="text">
<p>I'm creating simple notepad program in Tkinter. I decided to put functions in separate file. Is it possible if the functions are operating on variables declared in main file?
This is snippet of the code:
main.py</p>
<pre><code>from tkinter import *
from otherfile import cut
root = Tk()
....
menu_edit.add_command(label='Cut', compound='left', command=cut)
...
main_text = Text(root, wrap ='word')
main_text.pack(expand='yes', fill = 'both')
</code></pre>
<p>now I have otherfile.py</p>
<pre><code>def cut():
    main_text.event_generate('&lt;&lt;Cut&gt;&gt;')
    return 'break'
</code></pre>
<p>Once I run it I'll get:
Exception in Tkinter callback</p>
<pre><code>Traceback (most recent call last):
  File "C:...\tkinter\__init__.py", line 1699, in __call__
    return self.func(*args)
  File "C:\....otherfile.py", line 3, in cut
    main_text.event_generate('&lt;&lt;Cut&gt;&gt;')
NameError: name 'main_text' is not defined
</code></pre>
<p>So I guess otherfile.py does not understand main_text which is defined in main.py. Is there a way to bypass it and allow me to put all the functions in different py file?</p>
</div>
<div class="post-text" itemprop="text">
<p><code>cut</code> is trying to use a global variable from another file. Even if you found a way to get around circular imports, it's a messy way to go about things. It's better to write functions that operate independent of global variables. For one thing, it makes them much easier to modify and test. When you need to deal with assigning <code>command=function</code> and <code>function</code> takes variables, <a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="nofollow noreferrer">functools.partial</a> is your friend. </p>
<pre><code>def cut(tk_text_obj):
    tk_text_obj.event_generate('&lt;&lt;Cut&gt;&gt;')
    return 'break'
</code></pre>
<p>and then in main file, first declare <code>main_text</code> and then use <code>functools.partial</code> to create a callable that takes no arguments.</p>
<pre><code>from functools import partial
from tkinter import *
from otherfile import cut
root = Tk()
....
main_text = Text(root, wrap ='word')
cut_main_text = partial(cut, main_text)
menu_edit.add_command(label='Cut', compound='left', command=cut_main_text)
# or just combine the above two lines using command=partial(cut, main_text)
...
main_text.pack(expand='yes', fill = 'both')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It is possible. You should import <code>main</code> in <code>otherfile</code> or modify <code>otherfile.cut</code> method to accept main_text as method argument. Second option depends on that if <code>menu_edit.add_command</code> allows passing arguments to command.</p>
<p>I think you have two problems.</p>
<ol>
<li>Circular imports which are a real pain.</li>
<li>Everything which is declared on module level is called during module import.</li>
</ol>
<p>I believe below example is moreover situation you have.</p>
<p>a.py:</p>
<pre><code>import b
commands = []

def add_command(cmd):
    commands.append(cmd)

def run_commands():
    for cmd in commands:
        print cmd()

def local_cmd():
    return 'local cmd output'

if __name__ == '__main__':
    add_command(local_cmd)
    add_command(b.b_cmd)
    run_commands()
</code></pre>
<p>b.py:</p>
<pre><code>import a

def b_cmd():
   l = a.local_cmd()
   return 'B %s B' % l
</code></pre>
<p>Above snippet works as expected when running with <code>python a.py</code>.</p>
<p>But when you skip <code>if __name__ == '__main__':</code> you will observe similar situation. Script fails because when you import <code>a</code> in <code>b</code>, <code>add_command(b.b_cmd)</code> in <code>a</code> is called, but <code>b</code> was not imported yet.</p>
</div>
<div class="post-text" itemprop="text">
<p>It is a bad practice and tons of headache to use global variables. May I suggest to modify <code>cut()</code> to take a parameter:</p>
<pre><code># otherfile.py
def cut(text_control):
    text_control.event_generate('&lt;&lt;Cut&gt;&gt;')
    return 'break'
</code></pre>
<p>Then in the main module, call it as such:</p>
<pre><code># main.py
menu_edit.add_command(label='Cut', compound='left', command=lambda: cut(main_text))
</code></pre>
<p>This way, you don't have to deal with troubles later. Besides, you can now use function <code>cut()</code> for other text boxes if you want.</p>
</div>
<span class="comment-copy">Have you tried importing? like putting <code>from main import main_text</code> at the top of your otherfile.py?</span>
<span class="comment-copy">@PhillipMartin it ends up even worse: Traceback (most recent call last):   File "C:\....", line 2, in &lt;module&gt;     from NoteFunc import *   File "C:\....y", line 2, in &lt;module&gt;     from Notenote import main_text   File "C:\....", line 54, in &lt;module&gt;     compound='left', command=cut) NameError: name 'cut' is not defined</span>
