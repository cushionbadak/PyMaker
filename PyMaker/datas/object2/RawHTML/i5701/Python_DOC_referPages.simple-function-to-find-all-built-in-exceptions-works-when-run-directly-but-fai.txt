<div class="post-text" itemprop="text">
<p>I have a function that is supposed to generate a tuple of all built-in exceptions, (for use in the <code>except (Exception1, Exception2, etc...) as error:</code> form) and when I run it normally, it works just fine.</p>
<pre><code>def get_exceptions():

    exceptionList = []

    for item in dir(__builtins__):
        if item.find('Error') != -1:
            exec('exceptionList.append({})'.format(item))

    return tuple(exceptionList)

if __name__ == '__main__':
    print(get_exceptions())
</code></pre>
<p>and when run:</p>
<pre><code>(&lt;class 'ArithmeticError'&gt;, &lt;class 'AssertionError'&gt;, &lt;class 'AttributeError'&gt;, &lt;class 'BlockingIOError'&gt;, &lt;class 'BrokenPipeError'&gt;, &lt;class 'BufferError'&gt;, &lt;class 'ChildProcessError'&gt;, &lt;class 'ConnectionAbortedError'&gt;, &lt;class 'ConnectionError'&gt;, &lt;class 'ConnectionRefusedError'&gt;, &lt;class 'ConnectionResetError'&gt;, &lt;class 'EOFError'&gt;, &lt;class 'OSError'&gt;, &lt;class 'FileExistsError'&gt;, &lt;class 'FileNotFoundError'&gt;, &lt;class 'FloatingPointError'&gt;, &lt;class 'OSError'&gt;, &lt;class 'ImportError'&gt;, &lt;class 'IndentationError'&gt;, &lt;class 'IndexError'&gt;, &lt;class 'InterruptedError'&gt;, &lt;class 'IsADirectoryError'&gt;, &lt;class 'KeyError'&gt;, &lt;class 'LookupError'&gt;, &lt;class 'MemoryError'&gt;, &lt;class 'NameError'&gt;, &lt;class 'NotADirectoryError'&gt;, &lt;class 'NotImplementedError'&gt;, &lt;class 'OSError'&gt;, &lt;class 'OverflowError'&gt;, &lt;class 'PermissionError'&gt;, &lt;class 'ProcessLookupError'&gt;, &lt;class 'ReferenceError'&gt;, &lt;class 'RuntimeError'&gt;, &lt;class 'SyntaxError'&gt;, &lt;class 'SystemError'&gt;, &lt;class 'TabError'&gt;, &lt;class 'TimeoutError'&gt;, &lt;class 'TypeError'&gt;, &lt;class 'UnboundLocalError'&gt;, &lt;class 'UnicodeDecodeError'&gt;, &lt;class 'UnicodeEncodeError'&gt;, &lt;class 'UnicodeError'&gt;, &lt;class 'UnicodeTranslateError'&gt;, &lt;class 'ValueError'&gt;, &lt;class 'OSError'&gt;, &lt;class 'ZeroDivisionError'&gt;)
</code></pre>
<p>which is just as I wanted.
however, at the following, through the shell,</p>
<pre><code>&gt;&gt;&gt; import list_exceptions
&gt;&gt;&gt; list_exceptions.get_exceptions()
()
</code></pre>
<p>nothing happens. </p>
<p>even in a file:</p>
<pre><code>import list_exceptions
print(list_exceptions.get_exceptions())
</code></pre>
<p>i get:</p>
<pre><code>()
</code></pre>
<p>this seems very strange. any help would be great!
by the way, I looked at these, they weren't really related to what I had in mind.<br/>
<a href="https://stackoverflow.com/questions/29548587/import-fails-when-running-python-as-script-but-not-in-ipython">import fails when running python as script, but not in iPython?</a><br/>
<a href="http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html" rel="nofollow noreferrer">http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html</a></p>
<p>if you have any questions, just ask :)</p>
</div>
<div class="post-text" itemprop="text">
<p>The fundamental problem with your approach is that you are relying on two things you shouldn't rely on. The first is <code>dir</code>, the behavior of which should <em>not be relied on</em> because it exists mostly to aid debugging in the interactive shell. From the <a href="https://docs.python.org/3/library/functions.html#dir" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>If the object does not provide <code>__dir__()</code>, the function tries its
  best to gather information from the object’s <code>__dict__</code> attribute, if
  defined, and from its type object. The resulting list is not
  necessarily complete, and may be inaccurate when the object has a
  custom <code>__getattr__()</code>.</p>
<p>...</p>
<p><strong>Note</strong> Because <code>dir()</code> is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of
  names more than it tries to supply a rigorously or consistently
  defined set of names, and its detailed behavior may change across
  releases. For example, metaclass attributes are not in the result list
  when the argument is a class.</p>
</blockquote>
<p>Furthermore, you use the <code>__builtins__</code> variable, which <em>is an implementation detail</em> Again, from the <a href="https://docs.python.org/3.4/library/builtins.html" rel="nofollow noreferrer">docs</a>:</p>
<blockquote>
<p>As an implementation detail, most modules have the name <code>__builtins__</code>
  made available as part of their globals. The value of <code>__builtins__</code> is
  normally either this module or the value of this module’s <code>__dict__</code>
  attribute. Since this is an implementation detail, it may not be used
  by alternate implementations of Python.</p>
</blockquote>
<p>Essentially, you are relying on two unreliable things. Note, what is <em>actually happening</em> in your case is that when you run the module directly, it returns the actual <code>builtins</code> module, however, when the module is imported, <code>__builtins__</code> contains the "value of this module's <code>__dict__</code>". A few debugging prints could have illuminated this:</p>
<pre><code># builtinstest.py
def get_exceptions():

    print(type(__builtins__))
    print(dir(__builtins__))
</code></pre>
<p>And from the interactive interpreter:</p>
<pre><code>&gt;&gt;&gt; import builtinstest
&gt;&gt;&gt; builtinstest.get_exceptions()
&lt;class 'dict'&gt;
['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
</code></pre>
<p>So when you call <code>dir</code> on a <code>dict</code> object, it simply returns the attributes introspectable from the dict-object, e.g. <code>copy</code>, <code>fromkeys</code>, <code>get</code>, <code>items</code> and all the other <code>dict</code> methods. The solution is to use the <code>builtins</code> module and don't use <code>dir</code>, use <code>vars</code> (which just returns the <code>__dict__</code> attribute), since you want the attributes of the module object.</p>
<p>Finally, your approach with <code>exec</code> is not good. If you want to do this sanely, check if it is a subclass of <code>BaseException</code>, which is the parent class of all built-in exceptions, so from <a href="https://docs.python.org/3/library/exceptions.html#BaseException" rel="nofollow noreferrer">the docs</a>:</p>
<blockquote>
<p>exception <code>BaseException</code></p>
<p>The base class for all built-in exceptions. It is not meant to be 
     directly inherited by user-defined classes (for that, use <code>Exception</code>).</p>
</blockquote>
<p>So something like:</p>
<pre><code>import builtins
def get_exceptions_sanely():
    exception_list = []
    for obj in  vars(builtins).values():
        if isinstance(obj, type) and issubclass(obj, BaseException):
            exception_list.append(obj)
    return tuple(exception_list)
</code></pre>
<p>Does what you are trying to accomplish. Note, this iterates over the <em>values</em> directly, so you don't end up using something like <code>eval</code> or <code>exec</code>, which is an abuse in this case. Note, this catches <em>every</em> built-in exception, things like warnings, (e.g. <code>BytesWarning</code>) and more esoteric things like <code>SystemExit</code>. </p>
<h3> Finally</h3>
<p>Just because you <em>can</em> do this, doesn't mean you <em>should</em>. Your stated purpose is:</p>
<blockquote>
<p>I have a function that is supposed to generate a tuple of all built-in
  exceptions, (for use in the <code>except (Exception1, Exception2, etc...)
  as error:</code> form)</p>
</blockquote>
<p>Well, you could just use <code>except BaseException as error</code> instead of going through the rigamarole of finding those exceptions in the first place (indeed, <code>except &lt;something&gt;</code> essentially checks if <code>&lt;something&gt;</code> <code>issubclass</code> of whatever error is being raised. And fundamentally, there is <em>rarely</em> ever any good reason to have such a broad <code>except</code> clause. You should always try to catch as narrow an exception as possible.</p>
</div>
<div class="post-text" itemprop="text">
<p>This works, and seems to be the common technique for getting at the builtins module.</p>
<pre><code>def get_exceptions():

    exceptionList = []

    for k in __builtins__.keys():
        if k.find('Error') != -1:
            exec('exceptionList.append({})'.format(k))

    return tuple(exceptionList)


if __name__ == '__main__':
    print(get_exceptions())
</code></pre>
</div>
<span class="comment-copy">I am using the <code>exec</code> function so it adds the actual exception, not the string.</span>
<span class="comment-copy">You can use <code>getattr(__builtins__, item)</code> to similar effect</span>
<span class="comment-copy">Ok, so what would that look like? I have never used <code>getattr</code> before.</span>
<span class="comment-copy">In a terminal, <code>item.find('Error') != -1</code> is always false.  Don't know why (yet), but that is what is happening.</span>
<span class="comment-copy">ya, it is strange, I am on windows, and whenever I import it, in an IDE, or from any command line, it never works. when I run it by double clicking, or by running from cmd or powershell, it works just fine</span>
<span class="comment-copy">wow. I am amazed at the detail of this answer. I just learned a lot about things I had no idea about, and all sorts of cool things. by the way, I wanted to be able to catch all exceptions and give them a name, because I am making a game and if an exception is thrown, I want to put the exception in a message box and have it be reported back to me. that is why I didnt just use <code>except:</code> because you cant do <code>except as thingy.</code> thank you!</span>
<span class="comment-copy">@Michael yeah, generally, you do <code>except Exception as e</code>, sometimes you do that just to report something, maybe do cleanup, then exit. Again, you probably <i>should not</i> be letting exceptions pass silently, of course, it isn't always possible, but in the case of a game, and built-in exceptions, you should be handling them or fixing the cause</span>
<span class="comment-copy">of course. I know putting just an <code>except:</code> default anywhere is a terrible idea   because the whole idea of the traceback system is to crash your program when something unexpected happens. if an exception happens in my game, it will open a message box, try and save progress, and call <code>sys.exit</code>.</span>
<span class="comment-copy">i got:   <code>Traceback (most recent call last):   File "C:\Users\Michael\Desktop\list_exceptions.py", line 12, in &lt;module&gt;     print(get_exceptions())   File "C:\Users\Michael\Desktop\list_exceptions.py", line 5, in get_exceptions     for k in __builtins__.keys(): AttributeError: 'module' object has no attribute 'keys' &gt;&gt;&gt; </code></span>
<span class="comment-copy">I used: <code>import builtins     keys = builtins.__dict__</code> and that worked.</span>
