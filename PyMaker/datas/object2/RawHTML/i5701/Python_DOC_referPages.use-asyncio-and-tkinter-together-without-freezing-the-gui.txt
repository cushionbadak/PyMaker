<div class="post-text" itemprop="text">
<p>I want to use <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow noreferrer"><code>asyncio</code></a> in combination with a <a href="https://docs.python.org/3/library/tkinter.html" rel="nofollow noreferrer"><code>tkinter</code></a> GUI.
I am new to <code>asyncio</code> and my understanding of it is not very detailed.
The example here starts 10 task when clicking on the first button. The task are just simulating work with a <code>sleep()</code> for some seconds.</p>
<p>The example code is running fine with Python <code>3.6.4rc1</code>. <strong>But
the problem</strong> is that the GUI is freezed. When I press the first button and start the 10 asyncio-tasks I am not able to press the second button in the GUI until all tasks are done. The GUI should never freeze - that is my goal.</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from tkinter import *
from tkinter import messagebox
import asyncio
import random

def do_freezed():
    """ Button-Event-Handler to see if a button on GUI works. """
    messagebox.showinfo(message='Tkinter is reacting.')

def do_tasks():
    """ Button-Event-Handler starting the asyncio part. """
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(do_urls())
    finally:
        loop.close()

async def one_url(url):
    """ One task. """
    sec = random.randint(1, 15)
    await asyncio.sleep(sec)
    return 'url: {}\tsec: {}'.format(url, sec)

async def do_urls():
    """ Creating and starting 10 tasks. """
    tasks = [
        one_url(url)
        for url in range(10)
    ]
    completed, pending = await asyncio.wait(tasks)
    results = [task.result() for task in completed]
    print('\n'.join(results))


if __name__ == '__main__':
    root = Tk()

    buttonT = Button(master=root, text='Asyncio Tasks', command=do_tasks)
    buttonT.pack()
    buttonX = Button(master=root, text='Freezed???', command=do_freezed)
    buttonX.pack()

    root.mainloop()
</code></pre>
<h2>A _side problem</h2>
<p>...is that I am not able to run the task a second time because of this error.</p>
<pre class="lang-none prettyprint-override"><code>Exception in Tkinter callback
Traceback (most recent call last):
  File "/usr/lib/python3.6/tkinter/__init__.py", line 1699, in __call__
    return self.func(*args)
  File "./tk_simple.py", line 17, in do_tasks
    loop.run_until_complete(do_urls())
  File "/usr/lib/python3.6/asyncio/base_events.py", line 443, in run_until_complete
    self._check_closed()
  File "/usr/lib/python3.6/asyncio/base_events.py", line 357, in _check_closed
    raise RuntimeError('Event loop is closed')
RuntimeError: Event loop is closed
</code></pre>
<h2>Multithreading</h2>
<p>Whould multithreading be a possible solution? Only two threads - each loop has it's own thread?</p>
</div>
<div class="post-text" itemprop="text">
<p>In a slight modification to your code, I created the asyncio <code>event_loop</code> in the main thread and passed it as an argument to the asyncio thread. Now Tkinter won't freeze while the urls are fetched.</p>
<pre><code>from tkinter import *
from tkinter import messagebox
import asyncio
import threading
import random

def _asyncio_thread(async_loop):
    async_loop.run_until_complete(do_urls())


def do_tasks(async_loop):
    """ Button-Event-Handler starting the asyncio part. """
    threading.Thread(target=_asyncio_thread, args=(async_loop,)).start()


async def one_url(url):
    """ One task. """
    sec = random.randint(1, 8)
    await asyncio.sleep(sec)
    return 'url: {}\tsec: {}'.format(url, sec)

async def do_urls():
    """ Creating and starting 10 tasks. """
    tasks = [one_url(url) for url in range(10)]
    completed, pending = await asyncio.wait(tasks)
    results = [task.result() for task in completed]
    print('\n'.join(results))


def do_freezed():
    messagebox.showinfo(message='Tkinter is reacting.')

def main(async_loop):
    root = Tk()
    Button(master=root, text='Asyncio Tasks', command= lambda:do_tasks(async_loop)).pack()
    buttonX = Button(master=root, text='Freezed???', command=do_freezed).pack()
    root.mainloop()

if __name__ == '__main__':
    async_loop = asyncio.get_event_loop()
    main(async_loop)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Trying to run both event loops at the same time is a dubious proposition.  However, since root.mainloop simply calls root.update repeatedly, one can simulate mainloop by calling update repeatedly as an asyncio task.  Here is a test program that does so.  I presume adding asyncio tasks to the tkinter tasks would work.  I checked that it still runs with 3.7.0a2.</p>
<pre><code>"""Proof of concept: integrate tkinter, asyncio and async iterator.

Terry Jan Reedy, 2016 July 25
"""

import asyncio
from random import randrange as rr
import tkinter as tk


class App(tk.Tk):

    def __init__(self, loop, interval=1/120):
        super().__init__()
        self.loop = loop
        self.protocol("WM_DELETE_WINDOW", self.close)
        self.tasks = []
        self.tasks.append(loop.create_task(self.rotator(1/60, 2)))
        self.tasks.append(loop.create_task(self.updater(interval)))

    async def rotator(self, interval, d_per_tick):
        canvas = tk.Canvas(self, height=600, width=600)
        canvas.pack()
        deg = 0
        color = 'black'
        arc = canvas.create_arc(100, 100, 500, 500, style=tk.CHORD,
                                start=0, extent=deg, fill=color)
        while await asyncio.sleep(interval, True):
            deg, color = deg_color(deg, d_per_tick, color)
            canvas.itemconfigure(arc, extent=deg, fill=color)

    async def updater(self, interval):
        while True:
            self.update()
            await asyncio.sleep(interval)

    def close(self):
        for task in self.tasks:
            task.cancel()
        self.loop.stop()
        self.destroy()


def deg_color(deg, d_per_tick, color):
    deg += d_per_tick
    if 360 &lt;= deg:
        deg %= 360
        color = '#%02x%02x%02x' % (rr(0, 256), rr(0, 256), rr(0, 256))
    return deg, color

loop = asyncio.get_event_loop()
app = App(loop)
loop.run_forever()
loop.close()
</code></pre>
<p>Both the tk update overhead and time resolution increase as the interval is decreased.  For gui updates, as opposed to animations, 20 per second may be enough.</p>
<p>I recently succeeded in running async def coroutines containing tkinter calls and awaits with mainloop.  The prototype uses asyncio Tasks and Futures, but I don't know if adding normal asyncio tasks would work.  If one wants to run asyncio and tkinter tasks together, I think running tk update with an asyncio loop is a better idea.</p>
<p>EDIT: A least as used above, exception without async def coroutines kill the coroutine but are somewhere caught and discarded.  Silent error are pretty obnoxious.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can keep the GUI alive after pressing the <code>Button</code> by adding a call to <code>root.update_idletasks()</code> in the right spot:</p>
<pre><code>from tkinter import *
from tkinter import messagebox
import asyncio
import random

def do_freezed():
    """ Button-Event-Handler to see if a button on GUI works. """
    messagebox.showinfo(message='Tkinter is reacting.')

def do_tasks():
    """ Button-Event-Handler starting the asyncio part. """
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(do_urls())
    finally:
        loop.close()

async def one_url(url):
    """ One task. """
    sec = random.randint(1, 15)
    root.update_idletasks()  # ADDED: Allow tkinter to update gui.
    await asyncio.sleep(sec)
    return 'url: {}\tsec: {}'.format(url, sec)

async def do_urls():
    """ Creating and starting 10 tasks. """
    tasks = [one_url(url) for url in range(10)]
    completed, pending = await asyncio.wait(tasks)
    results = [task.result() for task in completed]
    print('\n'.join(results))


if __name__ == '__main__':
    root = Tk()

    buttonT = Button(master=root, text='Asyncio Tasks', command=do_tasks)
    buttonT.pack()
    buttonX = Button(master=root, text='Freezed???', command=do_freezed)
    buttonX.pack()

    root.mainloop()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I've had great luck running an I/O loop on another thread, started at the beginning of the app creation, and tossing tasks onto it using <code>asyncio.run_coroutine_threadsafe(..)</code>.  </p>
<p>I'm kind of surprised that I can make changes to the tkinter widgets on the other asyncio loop/thread, and maybe it's a fluke that it works for me -- but it does work.</p>
<p>Notice that while the asyncio tasks are happening, the <em>other</em> button is still alive and responding.  I always like to  the disable/enable thing on the other button so you don't fire off multiple tasks accidentally, but that's just a UI thing.</p>
<pre><code>import threading
from functools import partial
from tkinter import *
from tkinter import messagebox
import asyncio
import random


# Please wrap all this code in a nice App class, of course

def _run_aio_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()
aioloop = asyncio.new_event_loop()
t = threading.Thread(target=partial(_run_aio_loop, aioloop))
t.daemon = True  # Optional depending on how you plan to shutdown the app
t.start()

buttonT = None

def do_freezed():
    """ Button-Event-Handler to see if a button on GUI works. """
    messagebox.showinfo(message='Tkinter is reacting.')

def do_tasks():
    """ Button-Event-Handler starting the asyncio part. """
    buttonT.configure(state=DISABLED)
    asyncio.run_coroutine_threadsafe(do_urls(), aioloop)

async def one_url(url):
    """ One task. """
    sec = random.randint(1, 3)
    # root.update_idletasks()  # We can delete this now
    await asyncio.sleep(sec)
    return 'url: {}\tsec: {}'.format(url, sec)

async def do_urls():
    """ Creating and starting 10 tasks. """
    tasks = [one_url(url) for url in range(3)]
    completed, pending = await asyncio.wait(tasks)
    results = [task.result() for task in completed]
    print('\n'.join(results))
    buttonT.configure(state=NORMAL)  # Tk doesn't seem to care that this is called on another thread


if __name__ == '__main__':
    root = Tk()

    buttonT = Button(master=root, text='Asyncio Tasks', command=do_tasks)
    buttonT.pack()
    buttonX = Button(master=root, text='Freezed???', command=do_freezed)
    buttonX.pack()

    root.mainloop()
</code></pre>
</div>
<span class="comment-copy">Your code works for me using Python 3.6.3 (on Windows). It takes a while, but eventually prints out 10 lines in this format <code>url: 3  sec: 6</code>, <code>url: 4  sec: 4</code>, etc. Perhaps you're encountering a bug that has been fixed (if you're using an earlier version of Python).</span>
<span class="comment-copy">@martineau With 3.7.0a2 on win10, I get the same error when pressing the Asyncio Tasks button a second time.</span>
<span class="comment-copy">@martineau But the GUI freezes while the tasks are running, right? That is the problem. About the bug: Please provide a link to the bug report.</span>
<span class="comment-copy">buhtz: Yes, it freezes for a short time. If I click the other button while it's frozen, then when it unfreezes, the pop-up comes up. I didn't have a specific bug in mind, which is why I said <i>perhaps</i> it was one.</span>
<span class="comment-copy">Your question is similar to this <a href="https://stackoverflow.com/q/47627900/6634373">one</a>, and my answer works with your setup. All you need is re-struct your program (like @Terry suggested) a little and bind your coroutines properly (via <code>command</code>/<code>bind</code>). First problem is obvious - you stuck in the inner loop (<code>asyncio</code>), while the outer loop in unreachable (<code>tkinter</code>), hence GUI in unresponsive state. Second one - you already closed <code>asyncio</code> loop. You either should close it once at the end (as @Terry proposed) or should create <a href="https://stackoverflow.com/a/45600858/6634373">a new one</a> each time.</span>
<span class="comment-copy">Could you please adapt my MWE to your solution.</span>
<span class="comment-copy">At least for the present, I leave it to you to experiment.</span>
<span class="comment-copy">Then your answer does not fit to my question and dies not help other readers what would be the main goal of stackexchange.</span>
<span class="comment-copy">The answer does help other people.</span>
<span class="comment-copy">I recently found a different way to drive coroutines with tk.mainloop that does not used anything from asyncio.  It should work better for applications that do <i>not</i> use asyncio.  For applications that use both, update (my answer) or update_idletasks(martineau's answer, and likely better if sufficient) in the main thread or asynio loop in a separate thread (oat's answer) are possible solutions.  I don't plan to experiment more with using mainloop when using both (asyncio's loop was faster in one experiment I did).</span>
<span class="comment-copy">It is not working. The behaviour doesn't changed. Have you tested your solution with my MWE?</span>
<span class="comment-copy">Yes, I ran it with the code in your questionâ€”whatever it was when I posted my answer anyway (in case you've changed it since then).</span>
<span class="comment-copy">In that case would you please post your complete working code.</span>
