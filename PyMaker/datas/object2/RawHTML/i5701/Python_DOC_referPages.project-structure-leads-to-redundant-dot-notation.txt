<div class="post-text" itemprop="text">
<p>I have created a Python package which builds on the structure indicated in Kenneth Reitz' "Repository Structure and Python" (<a href="https://www.kennethreitz.org/essays/repository-structure-and-python" rel="nofollow noreferrer">1</a>). The main package path is:</p>
<pre><code>/projects-folder (not site-packages)
    /package
        /package
            __init__.py
            Datasets.py
            Draw.py
            Gmaps.py
            ShapeSVG.py
            project.py
        __init__.py
        setup.py
</code></pre>
<p>With the current structure, I must use the following module import syntax:</p>
<pre><code>import package.package.Datasets
</code></pre>
<p>I would prefer to type the following:</p>
<pre><code>import package.Datasets
</code></pre>
<p>I am capable of typing the same word twice, of course, but it feels wrong in a deeper sense, i.e., I am structuring my package incorrectly or misunderstanding how Python interprets that structure.</p>
<p>The outer <code>__init__.py</code> is required for Python to detect this package at all, per the docs (<a href="https://docs.python.org/3/tutorial/modules.html#packages" rel="nofollow noreferrer">2</a>). But that sets up <code>/package/</code> as the top level of the package and <code>/package/package/</code> as a sub-package, forcing me into the unwieldy import syntax above.</p>
<p>To avoid this, it seems that my options are to:</p>
<ul>
<li>Create a package in which the outer folder contains the top level of package modules.</li>
<li>Add the inner folder to my <code>PYTHONPATH</code> environment variable.</li>
</ul>
<p>Yet both of these seem like suboptimal workarounds for something that shouldn't be an issue in the first place. What should I do?</p>
</div>
<div class="post-text" itemprop="text">
<p>You've misunderstood. You have two <code>package</code> packages for some reason, but the source you cite never said to do that. The outer folder, with <code>setup.py</code>, is not supposed to be a package.</p>
<p>It sounds like you're running Python in <code>projects-folder</code> and trying to import your package from there. That's not what you should be doing. You have several options to get your package into the import system. (I'll refer to the folder with <code>setup.py</code> in it as <code>setupfolder</code>, to distinguish it from the inner folder):</p>
<ul>
<li>Build your package with <code>setup.py</code>, for example, <code>python setup.py bdist-wheel --universal</code>, and install the built package with pip.</li>
<li>Skip the build step and just run <code>pip install path/to/setupfolder</code>. Building the package produces an installer useful if you want to distribute your package, but maybe you don't want to do that.</li>
<li>"Install" the package's source tree in development mode with <code>pip install -e path/to/setupfolder</code>, so the Python import system will locate the package's source tree when performing imports. This is handy because you don't have to rebuild and reinstall if you edit the source repository, although you'll still want to restart any running Python processes that are using the package.</li>
<li>Run Python from directly inside the <code>setupfolder</code>.</li>
</ul>
<p>Any of these options will cause your package to be importable directly as <code>package</code> instead of <code>package.package</code>, as it should be.</p>
</div>
<div class="post-text" itemprop="text">
<p>While I do not entirely agree with your package structure, you can make use of <a href="https://docs.python.org/3/tutorial/modules.html#importing-from-a-package" rel="nofollow noreferrer"><code>__all__</code></a> and possibly the one legitimate use for star imports I've seen so far. <code>__init__.py</code> can serve more purposes than just identifying your folder as a package or sub-package.</p>
<p><strong>Using a Star Import</strong></p>
<p>In <code>package/package/__init__.py</code>, add a variable <code>__all__</code> that declares all the public elements you want to export:</p>
<pre><code>__all__ = ['Datasets', 'Draw', 'Gmaps', 'ShapeSVG', 'project']
</code></pre>
<p>In <code>package/__init__.py</code> do <code>from package.package import *</code>. Now all the attributes that were available as <code>package.package.x</code> will also be available as <code>package.x</code>.</p>
<p>If you want to directly copy <code>package.package.__all__</code> to <code>package.__all__</code> (which is optional, but will allow you to do <code>from package import *</code> properly), you can do something like</p>
<pre><code>from package.package import *
from package.package import __all__ as _all
__all__ = _all
del _all
</code></pre>
<p><strong>Not Using a Star Import</strong></p>
<p>You can accomplish the same thing without using <code>package.package.__all__</code> at all. Just add <code>__all__</code> directly to <code>package/__init__.py</code> and use <code>from package.package import x</code>-style imports:</p>
<pre><code>from package.package import (
    Datasets, Draw, Gmaps, ShapeSVG, project
)
# As before, package.__all__ is optional
__all__ = ['Datasets', 'Gmaps', 'ShapeSVG', 'project']
</code></pre>
<p>I would still recommend having a <code>package.package.__all__</code> variable, but it is optional for this particular purpose.</p>
<p><strong>Pros and Cons</strong></p>
<p>Both approaches are pretty legitimate and I have seen both used in major projects. The first approach reduces redundancy. You only define the public exports in one place: <code>package.package.__all__</code>. The star imports and <code>package.__all__</code> reference that definition directly, leading to one place that you really have to maintain. On the other hand, there are times when you want to separate the "full" <code>package.package.x</code> API from what you expose via <code>package.x</code> to the casual user. In that case, go with the second option. The only downside here is that you have to be more careful to keep <code>package.__all__</code> and the corresponding imports synchronized properly.</p>
<p><strong>Note</strong></p>
<p>A number of projects I've seen (numpy especially comes to mind), export the attributes of the individual modules to the top level using this technique. For example, if you had a function <code>package.package.Datasets.get_data</code>, it would be listed in <code>package.package.Datasets.__all__</code>, which would be imported into <code>pacakge.package.__init__</code>, appended to <code>package.package.__all__</code>, and then be referenced by the top-level package and <code>package.__all__</code>.</p>
</div>
<span class="comment-copy">I dont think thats right, you can look at <a href="https://github.com/django/django" rel="nofollow noreferrer">Django project</a> for reference.</span>
