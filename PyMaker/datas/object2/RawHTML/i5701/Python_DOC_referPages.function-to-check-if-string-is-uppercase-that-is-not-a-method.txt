<div class="post-text" itemprop="text">
<p>I'm writing a program that checks if a given password has at least 1 upper case letter and 1 lower case letter. I could easily check that like this:</p>
<pre><code>    #Password needs to have at least 1 upper case letter
    has_upper_letter = False
    for letter in password:
        if letter.isupper():
            has_upper_letter = True
            break
    if not has_upper_letter:
        raise forms.ValidationError(_("The password needs to have at least 1 upper case letter"))

    #Password needs to have at least 1 lower case letter
    has_lower_letter = False
    for letter in password:
        if letter.islower():
            has_lower_letter = True
            break
    if not has_lower_letter:
        raise forms.ValidationError(_("The password needs to have at least 1 lower case letter"))
</code></pre>
<p>But this code is repetitive. I want to only write the logic in checking the letters for a certain kind of letter once. My idea is to write a function that takes the <code>isupper()</code> or <code>islower()</code> function as an argument. The problem though, is that the <code>isupper()</code> and <code>islower()</code> methods exist as a method on the strings themselves. If I could only get a function that <strong>takes the string that I want to check</strong> as its argument, my problem would be solved. Is there such a thing? Feel free to post better solutions to my problem.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/operator.html#operator.methodcaller" rel="nofollow noreferrer"><code>operator.methodcaller()</code></a>, or you can use <a href="https://docs.python.org/3/library/functions.html#getattr" rel="nofollow noreferrer"><code>getattr()</code></a>; either can be used to call a method dynamically:</p>
<pre><code>from operator import methodcaller

def matches_test(test, password):
    return any(map(test, password))

has_lower_letter = matches_test(methodcaller('islower'), password)
has_upper_letter = matches_test(methodcaller('isupper'), password)
</code></pre>
<p><code>methodcaller()</code> calls the named method on anything you pass to it:</p>
<pre><code>&gt;&gt;&gt; from operator import methodcaller
&gt;&gt;&gt; upper = methodcaller('isupper')
&gt;&gt;&gt; upper('ABC')
True
&gt;&gt;&gt; upper('abc')
False
</code></pre>
<p><code>methodcaller()</code> objects also accept additional arguments to pass in, so <code>methodcaller('foo', 42)</code> would call <code>.foo(42)</code> on any object you pass to it.</p>
<p>The <a href="https://docs.python.org/3/library/functions.html#any" rel="nofollow noreferrer"><code>any()</code> function</a> is just a (much more compact) way of writing your <code>for</code> loop with <code>if</code> test and <code>break</code>; it loops through the iterable you pass in and stops the moment a <code>True</code> result is produced; if no <code>True</code> result is ever produced, <code>False</code> is returned.</p>
<p><code>getattr()</code> lets you access variable attributes; methods are just attributes you call:</p>
<pre><code>def matches_test(methodname, password):
    return any(getattr(l, methodname)() for l in password)

has_lower_letter = matches_test('islower', password)
has_upper_letter = matches_test('isupper', password)
</code></pre>
<p>You can also pass in an <em>unbound string method</em>, so <code>str.isupper</code> or <code>str.islower</code>; passing in a new string value is like binding the method to that string:</p>
<pre><code>&gt;&gt;&gt; str.isupper('ABC')
True
</code></pre>
<p>So the following also works:</p>
<pre><code>def matches_test(test, password):
    return any(test(l) for l in password)

has_lower_letter = matches_test(str.islower, password)
has_upper_letter = matches_test(str.isupper, password)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can pass a lambda expression:</p>
<pre><code>def check_password(password, f):
   return any(f(i) for i in password)

print(check_password("theString", lambda x:x.isupper()))
</code></pre>
<p>Or, pass the desired string method to the function:</p>
<pre><code>print(check_password("theString", str.isupper))
</code></pre>
<p>Output:</p>
<pre><code>True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A different approach to this problem would be to use a regular expression.  The following code will validate a password with the rules:</p>
<ul>
<li>Password must be between 8 and 16 characters </li>
<li>Password must contain upper and lower case letters</li>
<li>Password must contain a digit</li>
</ul>
<p>Code:</p>
<pre><code>import re

def pswd_check(pswd):
    m=re.match("(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,16}$", pswd)
    return m!=None

if __name__ == "__main__":
    print(pswd_check("testthis"))
    print(pswd_check("t3sttHis"))
</code></pre>
<p>Output:</p>
<pre><code>False
True
</code></pre>
</div>
<span class="comment-copy">by the way, I do not recommend this kind of password checks. A relatively long (&gt;11 chars) minimum length and prohibition of simple repititions are easier on users and more secure than e.g. 6 words with at least one upper and one lower case character.</span>
<span class="comment-copy">Unless you're trying  to keep it Python 2 compatible - one could just pass it <code>str.islower</code> and <code>str.isupper</code>...</span>
<span class="comment-copy">@JonClements: also an option, I'll expand.</span>
<span class="comment-copy">um, as much as I sometimes like the <code>operator</code> module, a simple <code>upper = lambda thing: thing.isupper()</code> would be shorter, not need an import, imho (but that's really just a ho) clearer :)</span>
<span class="comment-copy">@Martijn yeah... if one's only ever going to be working with a <code>str</code> then it's quite convenient - otherwise, it's a no-go.</span>
<span class="comment-copy">@MarcusMÃ¼ller: <code>str.isupper</code> is shorter still, but a <code>methodcaller()</code> is more flexible in that you can add arguments.</span>
