<div class="post-text" itemprop="text">
<p>I have a raw SQL to be executed in SQLAlchemy with optional parameters coming from a query string.</p>
<p>I did a function to build the sentences to a where clause:</p>
<pre><code>def queryParams(self, params):
    params = urllib.parse.parse_qs(params)
    query = ""
    for (key, val) in params.items():
        for value in val:
            if(re.match("/(\d+(\.\d+)?)/", value) != False or (value == "false" or value == "true")):
                query += ' AND ' + key + ' = ' + value
            else:
                query += ' AND ' + key + ' = ' + "'" + value + "'"

    return query
</code></pre>
<p>The problem is when I need to execute the query, I have to concat this to a SQL string and it's not good for a SQL Injection happening.</p>
<pre><code>    s = text(
        'select a.cod_lim_judicial, a.desc_lim_judicial, a.dt_lim_judicial, '
        'a.dt_validade, a.nr_mandado, a.tipo_liminar, a.folhas_incidencia, '
        'a.num_folha, a.mes_ano_folha, p.mat_servidor, p.cod_depend, a.perc_pa '
        'from folha.fl_liminar a, folha.fl_pens_x_liminar p '
        'where a.cod_lim_judicial = p.cod_lim_judicial (+)' + self.queryParams(parameters))
    result = conn.execute(s).fetchall()
</code></pre>
<p>How can I use optional parameters using prepared statement?</p>
<p>Thanks to advance!</p>
</div>
<div class="post-text" itemprop="text">
<p>Here's a somewhat simplified example of what you could do:</p>
<pre><code>In [42]: def queryParams(params):
    ...:     params = urllib.parse.parse_qs(params)
    ...:     for key, val in params.items():
    ...:         # Trust the implicit conversions:
    ...:         # https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/Data-Type-Comparison-Rules.html#GUID-6DB331B5-0F34-4215-9A20-16AEA9D7FF4B
    ...:         yield column(key) == val
    ...: 
</code></pre>
<p>Using <a href="http://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.column" rel="nofollow noreferrer"><code>column()</code></a> handles quoting reserved words and mixed case, and escaping bad characters in column names, but you should still possibly whitelist though. The comparison produces a binary SQL expression object, with the bound parameter <code>val</code>. You can combine <a href="http://docs.sqlalchemy.org/en/latest/core/tutorial.html#using-text-fragments-inside-bigger-statements" rel="nofollow noreferrer">Core constructs with text fragments</a> in order to generate your query:</p>
<pre><code>In [43]: params = 'asdf=1&amp;qwer=true&amp;foo=baz'

In [44]: s = select([text("""
    ...:         a.cod_lim_judicial, a.desc_lim_judicial, a.dt_lim_judicial,
    ...:         a.dt_validade, a.nr_mandado, a.tipo_liminar, a.folhas_incidencia,
    ...:         a.num_folha, a.mes_ano_folha, p.mat_servidor, p.cod_depend, a.perc_pa""")]).\
    ...:     select_from(
    ...:         outerjoin(
    ...:             text("folha.fl_liminar a"),
    ...:             text("folha.fl_pens_x_liminar p"),
    ...:             text("a.cod_lim_judicial = p.cod_lim_judicial"))).\
    ...:     where(and_(*queryParams(params)))
    ...: 


In [45]: print(s)
SELECT 
        a.cod_lim_judicial, a.desc_lim_judicial, a.dt_lim_judicial,
        a.dt_validade, a.nr_mandado, a.tipo_liminar, a.folhas_incidencia,
        a.num_folha, a.mes_ano_folha, p.mat_servidor, p.cod_depend, a.perc_pa 
FROM folha.fl_liminar a LEFT OUTER JOIN folha.fl_pens_x_liminar p ON a.cod_lim_judicial = p.cod_lim_judicial 
WHERE asdf = :asdf_1 AND qwer = :qwer_1 AND foo = :foo_1
</code></pre>
</div>
<span class="comment-copy">what's wrong with using <b>SQLAlchemy</b> to construct the query?</span>
<span class="comment-copy">Note that <a href="https://docs.python.org/3/library/re.html#re.regex.match" rel="nofollow noreferrer"><code>re.match("/(\d+(\.\d+)?)/", value) != False</code></a> is going to be True always, since <code>re.match()</code> returns either a match object or None.</span>
<span class="comment-copy">Thank you very much! One more question. How do I pass those values through execute() since I have a key-value syntax?</span>
<span class="comment-copy">I'm sorry, but I didn't get you. The values have already been bound as params to the statement construct. The <code>print(s)</code> simply displays he query's statement, but the object also contains the params.</span>
<span class="comment-copy">So in order to execute the <code>select()</code> construct assigned to <code>s</code>, simply <code>execute(s)</code>.</span>
<span class="comment-copy">I printed like you said and it comes like your example, but when i try to execute it, says that SQL was not properly ended</span>
<span class="comment-copy">I'm not too familiar with Oracle and didn't know that the AS keyword in aliasing a table is illegal in Oracle. Removed it from the example. If you're using an old enough version of Oracle, then the (now) standard left join syntax is illegal as well and you'll have to revert to using the <code>(+)</code>.</span>
