<div class="post-text" itemprop="text">
<p>I have 3 threads. Each thread stores a <code>val</code>. And each thread receives messages from a websocket. When <code>on_message()</code> is called in each thread, <code>val</code> is updated and I want to call a function in my main thread to sum the <code>val</code>s of all 3 threads.</p>
<pre><code>thread1.start()
thread2.start()
thread3.start()
</code></pre>
<p>My current solution is</p>
<pre><code>while True:
    sum = thread1.val + thread2.val + thread3.val
</code></pre>
<p>The problem is that this code is using 100% CPU and repeatedly calculating the <code>sum</code> even if no <code>val</code> is updated. But I don't want to use <code>sleep()</code> because as soon as <code>val</code> in any thread is updated I need the sum to be calculated ASAP. I have read about using a queue but I don't want to use a <code>Queue</code> because I don't need them all executed, only the most recent.
So is there a way to call a function in the main thread when <code>on_message()</code> is called in thread 1, 2, or 3?</p>
</div>
<div class="post-text" itemprop="text">
<p>A <a href="https://docs.python.org/3/library/queue.html#module-queue" rel="nofollow noreferrer"><code>Queue</code></a> would actually be the appropriate method for going about this. You have each updated value added the the queue and the main thread will wait for an item to be added each time. You could format it as some kind of "Event Stream" so you know where it comes from. Each value in the queue might look something like:</p>
<pre><code>{
    "source": "THREAD_A",
    "value": 42
}
</code></pre>
<p>I'm assuming in each thread you have some kind of <code>produce()</code> function. It might look something like this:</p>
<pre><code>def produce(event_queue):
    while True:
        value = do_something()
        event_queue.put({"source": ME, "value": value})
</code></pre>
<p>And then in your main thread:</p>
<pre><code>values = {"THREAD_A": 0, "THREAD_B": 0, "THREAD_C": 0}
while True:
    s = sum(values.values())
    # ...
    last_event = event_queue.get()
    values[last_event["source"]] = last_event["value"]
</code></pre>
<p>The <code>get()</code> function causes the main thread to wait until the next event comes in, then it continues and processes that value. As such, it'll recalculate exactly once for each new message that arrives.</p>
<p>To keep with your <code>on_message()</code> metaphor, you can just think of <code>last_event</code> as the value you call <code>on_message()</code> with, and everything that happens immediately after it as the interior of that method. I mean, you could write it as it's own method if you wanted.</p>
<pre><code>values = {"THREAD_A": 0, "THREAD_B": 0, "THREAD_C": 0}
def on_message(v, message):
    v[last_event["source"]] = last_event["value"]
    s = sum(v.values())
    # ...

while True:
    last_message = event_queue.get()
    on_message(values, last_message)
</code></pre>
<p>Hope this gives you a bit of an idea.</p>
</div>
<span class="comment-copy">When <code>on_message()</code> is called in each thread, how can you be sure the other two <code>vals</code> are available for summing? Threads can call functions "anywhere". Functions are just code, and can be executed by any thread at any time. They may not be able to complete their processing if the values they need to do so aren't available yet.</span>
<span class="comment-copy">I actually have it in a try except block</span>
<span class="comment-copy">Unfortunately, that's not at all what I meantâ€”which was only that you can't sum the values until they're all produced. The answer you've accepted <i>seems</i> to deal with that in the sense of there being a "last event" (but that's not entirely clear to me).</span>
