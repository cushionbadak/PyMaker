<div class="post-text" itemprop="text">
<p>Is there a better way to use glob.glob in python to get a list of multiple file types such as .txt, .mdown, and .markdown?  Right now I have something like this:</p>
<pre><code>projectFiles1 = glob.glob( os.path.join(projectDir, '*.txt') )
projectFiles2 = glob.glob( os.path.join(projectDir, '*.mdown') )
projectFiles3 = glob.glob( os.path.join(projectDir, '*.markdown') )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Maybe there is a better way, but how about:</p>
<pre><code>&gt;&gt;&gt; import glob
&gt;&gt;&gt; types = ('*.pdf', '*.cpp') # the tuple of file types
&gt;&gt;&gt; files_grabbed = []
&gt;&gt;&gt; for files in types:
...     files_grabbed.extend(glob.glob(files))
... 
&gt;&gt;&gt; files_grabbed   # the list of pdf and cpp files
</code></pre>
<p>Perhaps there is another way, so wait in case someone else comes up with a better answer.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>from glob import glob

files = glob('*.gif')
files.extend(glob('*.png'))
files.extend(glob('*.jpg'))

print(files)
</code></pre>
<p>If you need to specify a path, loop over match patterns and keep the join inside the loop for simplicity:</p>
<pre><code>from os.path import join
from glob import glob

files = []
for ext in ('*.gif', '*.png', '*.jpg'):
   files.extend(glob(join("path/to/dir", ext)))

print(files)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Chain the results:</p>
<pre><code>import itertools as it, glob

def multiple_file_types(*patterns):
    return it.chain.from_iterable(glob.iglob(pattern) for pattern in patterns)
</code></pre>
<p>Then:</p>
<pre><code>for filename in multiple_file_types("*.txt", "*.sql", "*.log"):
    # do stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>glob</code> returns a list: why not just run it multiple times and concatenate the results?</p>
<pre><code>from glob import glob
ProjectFiles = glob('*.txt') + glob('*.mdown') + glob('*markdown')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>with glob it is not possible. you can use only:<br/>
* matches everything<br/>
? matches any single character<br/>
[seq] matches any character in seq<br/>
[!seq] matches any character not in seq  </p>
<p>use os.listdir and a regexp to check patterns:</p>
<pre><code>for x in os.listdir('.'):
  if re.match('.*\.txt|.*\.sql', x):
    print x
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For example, for <code>*.mp3</code> and <code>*.flac</code> on multiple folders, you can do:</p>
<pre><code>mask = r'music/*/*.[mf][pl][3a]*'
glob.glob(mask)
</code></pre>
<p>The idea can be extended to more file extensions, <strong><em>but</em></strong> you have to check that the combinations won't match any other unwanted file extension you may have on those folders. So, <em>be careful</em> with this.</p>
</div>
<div class="post-text" itemprop="text">
<p>After coming here for help, I made my own solution and wanted to share it. It's based on user2363986's answer, but I think this is more scalable. Meaning, that if you have 1000 extensions, the code will still look somewhat elegant.</p>
<pre><code>from glob import glob

directoryPath  = "C:\\temp\\*." 
fileExtensions = [ "jpg", "jpeg", "png", "bmp", "gif" ]
listOfFiles    = []

for extension in fileExtensions:
    listOfFiles.extend( glob( directoryPath + extension ))

for file in listOfFiles:
    print(file)   # Or do other stuff
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>A one-liner, Just for the hell of it..</p>
<pre><code>folder = "C:\\multi_pattern_glob_one_liner"
files = [item for sublist in [glob.glob(folder + ext) for ext in ["/*.txt", "/*.bat"]] for item in sublist]
</code></pre>
<p>output:</p>
<pre><code>['C:\\multi_pattern_glob_one_liner\\dummy_txt.txt', 'C:\\multi_pattern_glob_one_liner\\dummy_bat.bat']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This is a Python 3.4+ <code>pathlib</code> solution:</p>
<pre><code>exts = ".pdf", ".doc", ".xls", ".csv", ".ppt"
filelist = (str(i) for i in map(pathlib.Path, os.listdir(src)) if i.suffix.lower() in exts and not i.stem.startswith("~"))
</code></pre>
<p>Also it ignores all file names starting with <code>~</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Here is one-line list-comprehension variant of Pat's answer (which also includes that you wanted to glob in a specific project directory):</p>
<pre class="lang-python prettyprint-override"><code>import os, glob
exts = ['*.txt', '*.mdown', '*.markdown']
files = [f for ext in exts for f in glob.glob(os.path.join(project_dir, ext))]
</code></pre>
<p>You loop over the extensions (<code>for ext in exts</code>), and then for each extension you take each file matching the glob pattern (<code>for f in glob.glob(os.path.join(project_dir, ext)</code>).</p>
<p>This solution is <em>short</em>, and without any unnecessary for-loops, nested list-comprehensions, or functions to clutter the code. Just pure, expressive, pythonic <em>Zen</em>. </p>
<p>This solution allows you to have a custom list of <code>exts</code> that can be changed without having to update your code. (This is always a good practice!)</p>
<p>The list-comprehension is the same used in Laurent's solution (which I've voted for). But I would argue that it is usually unnecessary to factor out a single line to a separate function, which is why I'm providing this as an alternative solution.</p>
<p><strong>Bonus:</strong> </p>
<p>If you need to search not just a single directory, but also all sub-directories, you can pass <code>recursive=True</code> and use the multi-directory glob symbol <code>**</code> <sup>1</sup>:</p>
<pre><code>files = [f for ext in exts 
         for f in glob.glob(os.path.join(project_dir, '**', ext), recursive=True)]
</code></pre>
<p>This will invoke <code>glob.glob('&lt;project_dir&gt;/**/*.txt', recursive=True)</code> and so on for each extension.</p>
<p><sup>1</sup> Technically, the <code>**</code> glob symbol simply matches one or more characters <em>including forward-slash</em> <code>/</code> (unlike the singular <code>*</code> glob symbol). In practice, you just need to remember that as long as you surround <code>**</code> with forward slashes (path separators), it matches zero or more directories.</p>
</div>
<div class="post-text" itemprop="text">
<p>I have released <a href="http://pypi.python.org/pypi/formic" rel="nofollow">Formic</a> which implements multiple includes in a similar way to Apache Ant's <a href="http://ant.apache.org/manual/dirtasks.html#patterns" rel="nofollow">FileSet and Globs</a>.</p>
<p>The search can be implemented:</p>
<pre><code>import formic
patterns = ["*.txt", "*.markdown", "*.mdown"]
fileset = formic.FileSet(directory=projectDir, include=patterns)
for file_name in fileset.qualified_files():
    # Do something with file_name
</code></pre>
<p>Because the full Ant glob is implemented, you can include different directories with each pattern, so you could choose only those .txt files in one subdirectory, and the .markdown in another, for example:</p>
<pre><code>patterns = [ "/unformatted/**/*.txt", "/formatted/**/*.mdown" ]
</code></pre>
<p>I hope this helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>Not <code>glob</code>, but here's another way using a list comprehension:</p>
<pre><code>extensions = 'txt mdown markdown'.split()
projectFiles = [f for f in os.listdir(projectDir) 
                  if os.path.splitext(f)[1][1:] in extensions]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following function <code>_glob</code> globs for multiple file extensions.</p>
<pre><code>import glob
import os
def _glob(path, *exts):
    """Glob for multiple file extensions

    Parameters
    ----------
    path : str
        A file name without extension, or directory name
    exts : tuple
        File extensions to glob for

    Returns
    -------
    files : list
        list of files matching extensions in exts in path

    """
    path = os.path.join(path, "*") if os.path.isdir(path) else path + "*"
    return [f for files in [glob.glob(path + ext) for ext in exts] for f in files]

files = _glob(projectDir, ".txt", ".mdown", ".markdown")
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>files = glob.glob('*.txt')
files.extend(glob.glob('*.dat'))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>To <code>glob</code> multiple file types, you need to call <a href="https://docs.python.org/3/library/glob.html#glob.glob" rel="nofollow noreferrer"><code>glob()</code></a> function several times in a loop. Since this function returns a list, you need to concatenate the lists.</p>
<p>For instance, this function do the job:</p>
<pre><code>import glob
import os


def glob_filetypes(root_dir, *patterns):
    return [path
            for pattern in patterns
            for path in glob.glob(os.path.join(root_dir, pattern))]
</code></pre>
<p>Simple usage:</p>
<pre><code>project_dir = "path/to/project/dir"
for path in sorted(glob_filetypes(project_dir, '*.txt', '*.mdown', '*.markdown')):
    print(path)
</code></pre>
<p>You can also use <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="nofollow noreferrer"><code>glob.iglob()</code></a> to have an iterator:</p>
<blockquote>
<p>Return an iterator which yields the same values as glob() without actually storing them all simultaneously.</p>
</blockquote>
<pre><code>def iglob_filetypes(root_dir, *patterns):
    return (path
            for pattern in patterns
            for path in glob.iglob(os.path.join(root_dir, pattern)))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try to make a manual list comparing the extension of existing with those you require.</p>
<pre><code>ext_list = ['gif','jpg','jpeg','png'];
file_list = []
for file in glob.glob('*.*'):
  if file.rsplit('.',1)[1] in ext_list :
    file_list.append(file)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use filter:</p>
<pre><code>import os
import glob

projectFiles = filter(
    lambda x: os.path.splitext(x)[1] in [".txt", ".mdown", ".markdown"]
    glob.glob(os.path.join(projectDir, "*"))
)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could also use <code>reduce()</code> like so:</p>
<pre><code>import glob
file_types = ['*.txt', '*.mdown', '*.markdown']
project_files = reduce(lambda list1, list2: list1 + list2, (glob.glob(t) for t in file_types))
</code></pre>
<p>this creates a list from <code>glob.glob()</code> for each pattern and reduces them to a single list.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>import os    
import glob
import operator
from functools import reduce

types = ('*.jpg', '*.png', '*.jpeg')
lazy_paths = (glob.glob(os.path.join('my_path', t)) for t in types)
paths = reduce(operator.add, lazy_paths, [])
</code></pre>
<p><a href="https://docs.python.org/3.5/library/functools.html#functools.reduce" rel="nofollow noreferrer">https://docs.python.org/3.5/library/functools.html#functools.reduce</a>
<a href="https://docs.python.org/3.5/library/operator.html#operator.add" rel="nofollow noreferrer">https://docs.python.org/3.5/library/operator.html#operator.add</a></p>
</div>
<div class="post-text" itemprop="text">
<p>One glob, many extensions... but imperfect solution (might match other files).</p>
<pre><code>filetypes = ['tif', 'jpg']

filetypes = zip(*[list(ft) for ft in filetypes])
filetypes = ["".join(ch) for ch in filetypes]
filetypes = ["[%s]" % ch for ch in filetypes]
filetypes = "".join(filetypes) + "*"
print(filetypes)
# =&gt; [tj][ip][fg]*

glob.glob("/path/to/*.%s" % filetypes)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I had the same issue and this is what I came up with </p>
<pre><code>import os, sys, re

#without glob

src_dir = '/mnt/mypics/'
src_pics = []
ext = re.compile('.*\.(|{}|)$'.format('|'.join(['png', 'jpeg', 'jpg']).encode('utf-8')))
for root, dirnames, filenames in os.walk(src_dir):
  for filename in filter(lambda name:ext.search(name),filenames):
    src_pics.append(os.path.join(root, filename))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For example:</p>
<pre><code>import glob
lst_img = []
base_dir = '/home/xy/img/'

# get all the jpg file in base_dir 
lst_img += glob.glob(base_dir + '*.jpg')
print lst_img
# ['/home/xy/img/2.jpg', '/home/xy/img/1.jpg']

# append all the png file in base_dir to lst_img
lst_img += glob.glob(base_dir + '*.png')
print lst_img
# ['/home/xy/img/2.jpg', '/home/xy/img/1.jpg', '/home/xy/img/3.png']
</code></pre>
<p>A function:</p>
<pre><code>import glob
def get_files(base_dir='/home/xy/img/', lst_extension=['*.jpg', '*.png']):
    """
    :param base_dir:base directory
    :param lst_extension:lst_extension: list like ['*.jpg', '*.png', ...]
    :return:file lists like ['/home/xy/img/2.jpg','/home/xy/img/3.png']
    """
    lst_files = []
    for ext in lst_extension:
        lst_files += glob.glob(base_dir+ext)
    return lst_files
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Use a list of extension and iterate through</p>
<pre><code>from os.path import join
from glob import glob

files = ['*.gif', '*.png', '*.jpg']
for ext in files:
   files.extend(glob(join("path/to/dir", ext)))

print(files)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Yet another solution (use <code>glob</code> to get paths using multiple match <code>patterns</code> and combine all paths into a single list using <code>reduce</code> and <code>add</code>):</p>
<pre><code>import functools, glob, operator
paths = functools.reduce(operator.add, [glob.glob(pattern) for pattern in [
    "path1/*.ext1",
    "path2/*.ext2"]])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>This Should Work:</p>
<pre><code>import glob
extensions = ('*.txt', '*.mdown', '*.markdown')
for i in extensions:
    for files in glob.glob(i):
        print (files)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>this worked for me:</p>
<pre><code>import glob
images = glob.glob('*.JPG' or '*.jpg' or '*.png')
</code></pre>
</div>
<span class="comment-copy">Very related: <a href="https://stackoverflow.com/q/48181073/880783">stackoverflow.com/q/48181073/880783</a></span>
<span class="comment-copy"><code>files_grabbed = [glob.glob(e) for e in ['*.pdf', '*.cpp']]</code></span>
<span class="comment-copy">Novitoll's solution is short, but it ends up creating nested lists.</span>
<span class="comment-copy">you could always do this ;) <code>[f for f_ in [glob.glob(e) for e in ('*.jpg', '*.mp4')] for f in f_]</code></span>
<span class="comment-copy">files_grabbed = [<i>glob.glob(e) for e in ['</i>.pdf', '*.cpp']]</span>
<span class="comment-copy">This loops twice through the list of files. In the first iteration it checks for *.pdf and in the second it checks for *.cpp. Is there a way to get it done in one iteration? Check the combined condition each time?</span>
<span class="comment-copy">This ones is great for its simplicity and readability.</span>
<span class="comment-copy">glob.glob -&gt; glob.iglob so that the iterators chain is fully lazy evaluated</span>
<span class="comment-copy">I found the same solution but didn't know about <code>chain.from_iterable</code>.  So this is similar, but less readable: <code>it.chain(*(glob.iglob(pattern) for pattern in patterns))</code>.</span>
<span class="comment-copy">This is possibly the most readable solution given. I would change the case of <code>ProjectFiles</code> to <code>projectFiles</code>, but great solution.</span>
<span class="comment-copy">end your regex with $ to match only the end of the filenames</span>
<span class="comment-copy">I like this approach - if glob's expressiveness isn't powerful enough, upgrade to a more powerful regex system, don't hack on it using e.g. <code>itertools</code> because subsequent pattern changes also have to be hacky (say you want to allow upper and lower case). Oh, and it might be cleaner to write <code>'.*\.(txt|sql)'</code></span>
<span class="comment-copy">Is there any reason to prefer os.listdir('.') over glob.iglob('<i>.</i>')?</span>
<span class="comment-copy">Doesn't work for me. I use <code>directoryPath  = "/Users/bla/bla/images_dir*." </code></span>
<span class="comment-copy">I would need more info to debug this for you... Are you getting an exception? Also, if you're on Windows, that path doesn't look like it would work (missing drive letter).</span>
<span class="comment-copy">Good answers also provide some explanation of code and perhaps even some of your reasoning behind the code.</span>
<span class="comment-copy">This cannot possibly work as you intend it to. The <code>or</code> operator returns the first "non-falsy" value, so in your case: <code>*.JPG</code>. This turns your call into <code>glob.glob('*.JPG')</code>, meaning it will only return <code>*.JPG</code> files, completely forgetting about the other extensions.</span>
