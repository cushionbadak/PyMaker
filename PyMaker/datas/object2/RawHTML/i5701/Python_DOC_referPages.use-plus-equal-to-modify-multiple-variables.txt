<div class="post-text" itemprop="text">
<p>When using the += operator in Python you can do</p>
<pre><code>&gt;&gt;&gt;a=42
&gt;&gt;&gt;a+=1
&gt;&gt;&gt;a
43
</code></pre>
<p>Now let's say I have</p>
<pre><code>&gt;&gt;&gt;a=1
&gt;&gt;&gt;b=1
&gt;&gt;&gt;c=1
</code></pre>
<p>and want to do</p>
<pre><code>&gt;&gt;&gt;a, b, c += 1, 2, 3
</code></pre>
<p>to be shorthand for</p>
<pre><code>&gt;&gt;&gt;a+=1
&gt;&gt;&gt;b+=2
&gt;&gt;&gt;c+=3
</code></pre>
<p>Right now my code looks like</p>
<pre><code>rt, gt, bt = 0,0,0
for yi in range(self.ysize):
    for xi in range(self.xsize):
        ri, gi, bi, = self.pix[xi, yi][:3]
        rt += ri
        gt += gi
        bt += bi
num_pixels = self.xsize*self.ysize
r = rt/num_pixels
g = gt/num_pixels
b = bt/num_pixels
return int(r), int(g), int(b)
</code></pre>
<p>I'd like to be able to set the three values in one line so that the code is cleaner.</p>
<p>Is there a way to use += for this?</p>
<p>Is there a way to do this that is short and concise (not defining a function to do it for me)</p>
<p>Is there a better way to loop through a 2-d array and average the tuples?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <code>numpy</code> to get this behavior:</p>
<pre><code>x = np.arange(5)
x += np.arange(5)
print x

array([0, 2, 4, 6, 8])
</code></pre>
<p>Packing / unpacking steps:</p>
<pre><code>vals = np.array([a, b, c])
vals += 1, 2, 3
# now you can use vals[0] for a, vals[1] for b and vals[2] for c
# but if you want to keep using a,b,c variable names:
a,b,c = vals 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>the short answer is no. 
 augmented assignment cannot be used with tuple unpacking</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>numpy</code> solution is great if using it, however you could also perform the calculation on one line by simply not using <code>+=</code>:</p>
<pre><code>rt, gt, bt = rt + ri, gt + gi, bt + bi
</code></pre>
<p>Or if you use a list for <code>rt</code>, <code>gt</code> and <code>bt</code> you could use <code>map</code> and <code>zip</code>:</p>
<pre><code>sums = [0, 0, 0]
for yi in range(self.ysize):
    for xi in range(self.xsize):
        sums = map(sum, zip(sums, self.pix[xi, yi][:3])
sums = list(sums) # alternatively: rt, gt, bt = sums
</code></pre>
<p>In fact using this method you likely could reduce your code to:</p>
<pre><code>sums = [0, 0, 0]
for yi in range(self.ysize):
    for xi in range(self.xsize):
        sums = map(sum, zip(sums, self.pix[xi, yi][:3])
num_pixels = self.xsize*self.ysize
return tuple(map(lambda x:int(x/num_pixels), sums))
</code></pre>
</div>
<span class="comment-copy">Is that really going to make your code cleaner?</span>
<span class="comment-copy">I feel like rt, gt, bt += ri, gi, bi is cleaner. If not cleaner then shorter with similar readability</span>
<span class="comment-copy">You could define your own sequence container type (that was similar to <code>tuple</code>s and <code>list</code>s) and define its <a href="https://docs.python.org/3/library/operator.html#operator.iadd" rel="nofollow noreferrer"><code>iadd()</code> (or <code>__iadd__()</code>)</a> method to do what you want (but you can't change how it works for the built-in container classes).</span>
<span class="comment-copy">If <code>pix</code> is a picture (I'm guessing), then why would each pixel not be representable as an array with three values? You should encode it such that you can do <code>t += self.pix[:,xi,yi]</code>. For example make <code>pix</code> a 3D numpy array.</span>
<span class="comment-copy">OP wants multiple variables, a numpy array is still a single entity. so there would need to be an unpacking step.</span>
<span class="comment-copy">Sure. and a packing step too...</span>
<span class="comment-copy">np arrays do ok for a homogeneous group, it wouldn;t easily extend to a mix of ints, floats, strings, tuples, lists, etc</span>
<span class="comment-copy">No, it will work for any thing that has addition defined: <code>np.array([1, 2.0, "three", np.array([4,5])], dtype=object) + np.array([6,7.0,"eight",np.array([9,10])], dtype=object)</code> ==&gt; <code>array([7, 9.0, 'threeeight', array([13, 15])], dtype=object)</code></span>
<span class="comment-copy">that earns you an upvote</span>
<span class="comment-copy">Lol! <code>rt, gt, bt = rt + ri, gt + gi, bt + bi</code> is more complicated than <code>rt += r1; gt += gi; bt += bi</code>!</span>
<span class="comment-copy">@Cris ha good point!</span>
