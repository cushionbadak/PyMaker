<div class="post-text" itemprop="text">
<p>I'm running many subprocesses (more than I have cores) and, if one meets a certain condition, I set a value of a global variable <strong><code>global bailout</code></strong>.</p>
<p>Then if <code>bailout</code> was set, all subsequent subprocesses exit as quickly as possible.</p>
<p>See e.g. this simple example, where I multiply the results of my 20 calls to a <code>loop()</code> function, but I "bail out" if any of those calls returns zero:</p>
<pre><code>import sys
import random
import multiprocessing

def loop(tup):
    global bailout
    if bailout==1:                    # obey a global bail out "flag"
        return 0
    x = random.random() - 0.5
    if x &lt; 0:
        bailout = 1                   # set a global bail out "flag"
        return 0
    return x

def top():
    global bailout
    bailout = 0
    runtups = 20 * [[0]]              # a dummy parameter [0] for function "loop"
    pool = multiprocessing.Pool()
    results = pool.imap(loop, runtups)
    pool.close()
    res = 1
    sys.stdout.write("1")
    for result in results:
        sys.stdout.write(" * %g" % result)
        res = res * result
    sys.stdout.write(" = %g\n" % res)

top()
</code></pre>
<p>It works just fine (or to be precise, it has worked every time I've tried it). i.e. my desktop has 4 cores, and if one of the first 4 subprocesses sets bailout to 1 (as almost always happens in this example), then all subsequent runs exit on the <strong><code>if bailout==1</code></strong> condition.</p>
<p>But is it safe?</p>
<p>I mean, all a subprocess can ever do is set <code>bailout</code> to 1. But what if two subprocesses both want to set bailout to 1? Is it possible for them to attempt it at the same time, causing bailout to become undefined? Or is it guaranteed that this will never happen, (perhaps because the top level process always handles the completed subprocesses serially?)</p>
</div>
<div class="post-text" itemprop="text">
<p>Globals are not shared between processes. If you add some logging to <code>loop</code>, you can see what's really going on:</p>
<pre><code>def loop(tup):
    global bailout
    if bailout==1:
        print(f'pid {os.getpid()} had bailout 1')
        return 0
    x = random.random() - 0.5
    if x &lt; 0:
        print(f'pid {os.getpid()} setting bailout 1')
        bailout = 1
        return 0
    return x
</code></pre>
<p>This will produce output like:</p>
<pre><code>pid 30011 setting bailout 1
pid 30013 setting bailout 1
pid 30015 setting bailout 1
pid 30009 setting bailout 1
pid 30010 setting bailout 1
pid 30011 had bailout 1
pid 30013 had bailout 1
pid 30009 had bailout 1
pid 30014 setting bailout 1
pid 30015 had bailout 1
pid 30010 had bailout 1
pid 30011 had bailout 1
1 * 0.494123 * 0.0704172 * 0 * 0.10829 * 0 * 0.465238 * 0 * 0.0638724 * 0 * 0 * 0 * 0.227231 * 0 * 0 * 0 * 0 * 0 * 0 * 0.463628 * 0.372984 = 0
</code></pre>
<p>What's happening is that <code>multiprocessing.Pool()</code> is starting 4 processes, which are being re-used as they become available. So while processing the 20 items in <code>runtups</code>, eventually each individual process has its <code>bailout</code> set to 1. When that process is reused, it triggers the bailout clause.</p>
<p>Since you're randomly deciding when to set <code>bailout = 1</code>, it's possible for it to never happen while processing the 20 items, or it may happen in some processes but not others, so you may not get the same results I pasted above, but at least some of the processes are likely to go into bailout mode.</p>
<p>If you're looking for a reliable way to share state between processes, check out <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes</a>.</p>
</div>
<div class="post-text" itemprop="text">
<h2>Is it possible?<br/>Is it safe?<br/>Is it guaranteed?</h2>
<p>While GIL-stepping indeed makes all the threads-based ( not the subprocesses-based ) multiprocessing efforts to still appear in a pure-<code>[SERIAL]</code> processing-flow, the question is more about a principal approach and whether all the above raised issues are safely satisfied.</p>
<hr/>
<h2>Rather do not try to go against documented pieces of advice:</h2>
<p>Best let's mention the explicit statements from the documentation:</p>
<blockquote>
<p><strong><a href="https://docs.python.org/2/library/multiprocessing.html#programming-guidelines" rel="nofollow noreferrer">16.6.3. Programming guidelines</a></strong></p>
<p>...</p>
<p><strong>Explicitly pass resources to child processes</strong></p>
<p>On Unix a child process can make use of a shared resource created in a parent process using a global resource. However, it is better to pass the object as an argument to the constructor for the child process.</p>
<p>Apart from making the code (potentially) compatible with Windows this also ensures that as long as the child process is still alive the object will not be garbage collected in the parent process. This might be important if some resource is freed when the object is garbage collected in the parent process.</p>
</blockquote>
<hr/>
<p>and</p>
<blockquote>
<p><strong><a href="https://docs.python.org/2/library/multiprocessing.html#windows" rel="nofollow noreferrer">16.6.3.2 Windows</a></strong></p>
<p>...</p>
<p><strong>Global variables</strong></p>
<p>Bear in mind that if code run in a child process tries to access a global variable, then the value it sees (if any) may not be the same as the value in the parent process at the time that <strong><code>Process.start</code></strong> was called.</p>
<p>However, global variables which are just module level constants cause no problems.</p>
</blockquote>
<hr/>
<p>Besides the native pythonic tools to help communicate or "share" state ( which not only I advocate, where possible, to better never share ), there are smart tools for designing indeed <a class="post-tag" href="/questions/tagged/distributed-systems" rel="tag" title="show questions tagged 'distributed-systems'">distributed-systems</a>, using multi-agent concepts, where each thread may use other lightweight communication tools, being performance less penalised, than the native GIL-stepped operations allow ( ref. ZeroMQ, nanomsg et al ).</p>
</div>
<span class="comment-copy">In case it's not obvious, all I'm trying to do is "break" from a parallel loop, once I know that running the remaining runs of "loop" will not affect my answer. So the real question is, what's the best way to break from a parallel loop.</span>
