<div class="post-text" itemprop="text">
<p>I have dataset with many columns.
I want to take average of each column by grouping them with 'Club'</p>
<p>My data is in the form of string and  some of the data is in the form
'60+2' or '58-1'</p>
<p>I want to convert this string datatype into integer so that i can use them for 
calculating mean.</p>
<p>As i have searched and need re to skip '+ &amp; -'.
.str.split is used to split the string. </p>
<p>In my case pd.to_numeric wil not work as I want to edit bulk column at once</p>
<pre><code>    complete_dataset is dataframe

    cols = [i for i in complete_dataset.columns if i not in ['Name','Club', 'Nationality', 'Age', 'Overall', 'Potential', 'Special']]
    for col in cols:
        col = complete_dataset[col] #.str.split('+').astype(int)
        print(col)
        for x in col:
            value = x
            print(value)
    #     df[col]=pd.to_numeric(df[col])
</code></pre>
<p>This is giving output as</p>
<pre><code>    Name: Acceleration, dtype: object
    89
    92-4
    94
    88-6
    58+2
    79
    70+9
    76
    94
</code></pre>
<p>Also I want to use this data for further calculations</p>
<p>Thank you</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>I want to remove symbols and add or subtract the numbers as per symbol
  and convert the string into integer.</p>
</blockquote>
<h2><code>ast.literal_eval</code></h2>
<p>Alright, one good way of doing this is using python's safe eval - <code>ast.literal_eval</code>.</p>
<pre><code>import ast

df.Acceleration = df.Acceleration.apply(ast.literal_eval)
df

   Acceleration
0            89
1            88
2            94
3            82
4            60
5            79
6            79
7            76
8            94

df.Acceleration.dtype
dtype('int64')
</code></pre>
<p><code>literal_eval</code> evaluates only certain string expressions. Assuming you have a column of strings with expressions that can be evaluated, this will evaluate them and return numeric results.</p>
<p>Note that if you have a column of mixed integers and strings, the simplest thing to do would be to convert the entire column to string and apply <code>literal_eval</code>.</p>
<pre><code>df['Acceleration'] = df.Acceleration.astype(str).apply(ast.literal_eval)
</code></pre>
<hr/>
<h2><code>pd.eval</code>/<code>df.eval</code></h2>
<p>Another good way of doing this is using <code>pandas</code>' safe eval - <code>pd.Series.eval</code>, as mentioned by <a href="https://stackoverflow.com/a/47927498/4909087">this answer</a>. </p>
<pre><code>df.Acceleration = df.eval(df.Acceleration)
df

   Acceleration
0            89
1            88
2            94
3            82
4            60
5            79
6            79
7            76
8            94
</code></pre>
<hr/>
<h2>Handling Malformed Data</h2>
<p>On the off chance that your data contains invalid strings, a slightly different solution is needed, because everything mentioned above is going to fail. We'll need to define a function that handles these errors accordingly.</p>
<pre><code>def parse(x):
    try:
        return ast.literal_eval(x) # pd.eval(x)
    except ValueError:
        return np.nan

df.Acceleration = df.Acceleration.apply(parse)
df

   Acceleration
0            89
1            88
2            94
3            82
4            60
5            79
6            79
7            76
8            94
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Since your'e using Pandas, I would recommend using <code>pandas.eval()</code> instead of Python's <code>eval()</code> method as correctly pointed out by Coldspeed (Thanks!). </p>
<p>The advantage of using <code>pandas.eval()</code> is that it only evaluates Python expressions and not Python statements, therefore is much safer and compared to the <code>ast.literal_eval()</code> method (<a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow noreferrer">link to the documentation</a>) should also run a little bit faster . </p>
<p>Concretely, you can amend your code to do the following:</p>
<pre><code>import pandas

# Your code to read in the DataFrame goes in here.

complete_dataset['Acceleration'] = pandas.eval(complete_dataset['Acceleration'])
</code></pre>
<p>This evaluates all expressions that are stored in the column called Acceleration in <code>df</code>. The method should perform much faster and the output will the an integer or float depending on the expressions stored in the column. </p>
<p>For more details, please take a look at the <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.eval.html" rel="nofollow noreferrer">Pandas documentation</a>. </p>
</div>
<span class="comment-copy">I don't understand. Where is your input? And what do you want the output to be? Do you want to remove the symbols? Do you want to evaluate the expressions? Do you want to extract the integers separately? What is it?</span>
<span class="comment-copy">@COLDSPEED,  I want to remove symbols and add or subtract the numbers as per symbol and convert the string into integer</span>
<span class="comment-copy">What are the "integer pandas" in your question title?</span>
<span class="comment-copy">Is this safe ?<code>df.Name.apply(lambda x : pd.eval(x))</code> :-)</span>
<span class="comment-copy">@Wen It is safe. But <code>pd.eval(df.Name)</code> is just as safe and faster!</span>
<span class="comment-copy">Aha, :-) got it</span>
<span class="comment-copy">@COLDSPEED , thank you for this answer, It is working for some column only and throwing error as "malformed node or string: 30"</span>
<span class="comment-copy">As i am new to python and pandas, searching for the same</span>
<span class="comment-copy">No! <code>eval</code> is a <i>bad</i> idea. Use <code>ast.literal_eval</code> instead. See my answer for details.</span>
<span class="comment-copy">If you can remove the first bit of your answer, and elaborate on <code>df.eval</code>, you'll have my upvote.</span>
<span class="comment-copy">For example, <code>df.eval(df.Acceleration)</code> will also return an answer, and I'm guessing should be faster than my answer. ;-)</span>
<span class="comment-copy">Thanks for all the comments :) I've amended the answer as suggested. In my experience the pandas functions are usually much faster but who knows ;)</span>
