<div class="post-text" itemprop="text">
<p>I have objects that each have a unique ID and these objects are inserted to various lists. These objects need to be removed frequently from the middle of its corresponding list which would be <code>O(n)</code> typically, so I'd like to keep their locations in a <code>dict</code> and retrieve the object's location in <code>O(1)</code> each time I want to remove it.</p>
<pre><code>class Node(object):
    def __init__(self, lst_id, unique_id):
        self.lst_id = lst_id
        self.unique_id = unique_id

n1 = Node('a', 1)
n2 = Node('a', 2)
n3 = Node('b', 3)
node_lsts = {}
for node in [n1,n2,n3]:
    if node.lst_id in node_lsts:
        node_lsts[node.lst_id].append(node)
    else:
        node_lsts[node.lst_id] = [node]

nodes_hash = {n1.unique_id: n1, n2.unique_id: n2, n3.unique_id: n3}

ID_TO_REMOVE = 1
</code></pre>
<p>In example above, if I simply called <code>del nodes_hash[ID_TO_REMOVE]</code>, the corresponding object in <code>node_lsts</code> remains even though it is removed from the dictionary - how should I get it removed from its corresponding list in <code>O(1)</code>?</p>
<p>In C++ I can keep the pointers to list neighbors as node member variables (linked list) and look up a node by its memory address, get pointers to its neighbors, unlink that node from its neighbors (thereby removing it from the 'list') and finally free the node. I'm trying to replicate this behavior.</p>
</div>
<div class="post-text" itemprop="text">
<p>You can easily create a doubly linked list in Python:</p>
<pre><code>class DoublyLinkedListNode(object):
    def __init__(self, unique_id, lst_id, left=None, right=None):
        self.unique_id, self.lst_id = unique_id, lst_id

        self.left = left
        self.right = right

    def remove(self):
        if self.left is not None:
            self.left.right = self.right

        if self.right is not None:
            self.right.left = self.left

        self.left = None
        self.right = None

    def append(self, node):
        node.left = self
        node.right = self.right

        if self.right is not None:
            self.right.left = node
            node.right = self.right

        self.right = node

    def prepend(self, node):
        node.left = self.left
        node.right = self

        if self.left is not None:
            self.left.right = node

        self.left = node

    def iter_left(self):
        current = self

        while current.left is not None:
            yield current.left
            current = current.left

    def iter_right(self):
        current = self

        while current.right is not None:
            yield current.right
            current = current.right
</code></pre>
<p>Being a linked list, this has <em>O(1)</em> insertion and deletion for any given node. If you can keep a reference to each node via a dictionary or some other better-suited data structure, this will allow you average case <em>O(1)</em> access and fast sequential iteration.</p>
<pre><code>class ListContainer(object):
    def __init__(self):
        self.lists = {}
        self.node_mapping = {}

    def append(self, node):
        if node.lst_id in self.lists:
            self.lists[node.lst_id].append(node)
        else:
            self.lists[node.lst_id] = node

        self.node_mapping[node.unique_id] = node

    def remove(self, node):
        ...
</code></pre>
<p>Note that this is all wasted effort if you're going to have only a few hundred elements in your lists. Pure-Python data structures probably will not be faster than your Python implementation's list data structures for so few elements. Big-O notation ignores the constant term, which can be prohibitively large if you're not dealing with enough elements (e.g. the <a href="https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm" rel="nofollow noreferrer">Coppersmith-Winograd algorithm</a>).</p>
</div>
<div class="post-text" itemprop="text">
<p>Instead of using a list nested in a dict you can use a dict nested in a dict:</p>
<pre><code>node[node.lst_id] = {node1.unique_id: node1, node2.unique_id: node2, ... }
</code></pre>
<p>Assuming <code>ID_TO_REMOVE</code> is a <code>unique_id</code> you can remove it with:</p>
<pre><code>node_to_remove = nodes_hash[ID_TO_REMOVE]
del node_lsts[node_to_remove.lst_id][node_to_remove.unique_id]
</code></pre>
<p>Full code:</p>
<pre><code>class Node(object):
    def __init__(self, lst_id, unique_id):
        self.lst_id = lst_id
        self.unique_id = unique_id

    def __repr__(self):
        return "[lst_id: {}, unique_id: {}]".format(self.lst_id, self.unique_id)

n1 = Node('a', 1)
n2 = Node('a', 2)
n3 = Node('b', 3)
node_lsts = {}
for node in [n1,n2,n3]:
    if not node.lst_id in node_lsts:
        node_lsts[node.lst_id] = {}
    node_lsts[node.lst_id][node.unique_id] = node

nodes_hash = {n1.unique_id: n1, n2.unique_id: n2, n3.unique_id: n3}

ID_TO_REMOVE = 1

print("node_lsts", node_lsts)
node_to_remove = nodes_hash[ID_TO_REMOVE]
print("node_to_remove", node_to_remove)
del node_lsts[node_to_remove.lst_id][node_to_remove.unique_id]
print("node_lsts", node_lsts)
</code></pre>
<p><strong>OUTPUT</strong></p>
<pre><code>node_lsts {'a': {1: [lst_id: a, unique_id: 1], 2: [lst_id: a, unique_id: 2]}, 'b': {3: [lst_id: b, unique_id: 3]}}
node_to_remove [lst_id: a, unique_id: 1]
node_lsts {'a': {2: [lst_id: a, unique_id: 2]}, 'b': {3: [lst_id: b, unique_id: 3]}}
</code></pre>
<p>Since we're now using dictionaries everything is done in O(1) and we avoid the performance issue that was presented when we try to remove an element from a list.</p>
</div>
<span class="comment-copy">What do you frequently do with <code>nodes_lst_a</code>? Random access? Iteration? Appending to either end of the list?</span>
<span class="comment-copy">Maybe I'm missing something by why not remove it from <code>nodes_lst_a</code> using the index in <code>nodes_hash</code>? further, why don't you use <i>only</i> the hash?</span>
<span class="comment-copy">@alfasin: <code>lst.pop(k)</code> is around <i>O(len(lst) - k)</i>, which isn't that great for random popping.</span>
<span class="comment-copy">@Katie You would have to find or create a linked list implementation to achieve this in Python. The standard library doesn't provide this (there is <code>deque</code> but this doesn't allow to reference nodes in the deque). Python's <code>list</code> is more like <code>std::vector&lt;Object*&gt;</code> in C++</span>
<span class="comment-copy">@Katie Yes, in the hundreds I suspect the naive solution might still be competitive.</span>
<span class="comment-copy">Wow I can't believe how fast you coded this up. As noted in my comments, it seems like <a href="https://pythonhosted.org/llist/" rel="nofollow noreferrer">pythonhosted.org/llist</a> has a stable C implementation of a doubly linked list.</span>
<span class="comment-copy">(For future readers:) Regarding the constant term, yes, this was actually just a Python placeholder for future optimizations. I've had similar use cases in C++ where it was cheaper to use <code>std::vector</code> for cache locality over chasing pointers in a doubly-linked list. Unfortunately in Python I don't have enough control to go that far.</span>
<span class="comment-copy">Your response is technically correct but doesn't preserve the desired properties for why I put it in a list in the first place (append ordering, iteration etc.) Gave an upvote nevertheless.</span>
<span class="comment-copy">@Katie you can use an <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow noreferrer">OrderedDict</a> if you care about the order of insertion.</span>
