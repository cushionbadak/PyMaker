<div class="post-text" itemprop="text">
<p>How do I save a list of python dictionaries to a file, where each <code>dict</code>will be saved in one line? I know I can use <code>json.dump</code> to save the list of dictionaries. But I can only save the list in compact form (the full list in one line) or indented, where for all dictionaries keys a newline is added. </p>
<p>EDIT:</p>
<p>I want my final file.json look like this:</p>
<pre><code>[{key1:value,key2:value},
{key1:value,key2:value},
...
{key1:value,key2:value}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>For fun I adapted <a href="https://stackoverflow.com/a/13252112/355230">my answer</a> to another somewhat related question to make it do what you want. <br/>
Note that currently it only changes the formatting of a <code>dict</code> if it's in a list.</p>
<pre><code>import _ctypes
import json
import re

class OneDictPerLine(object):
    def __init__(self, value):
        self.value = value
    def __repr__(self):
        if not isinstance(self.value, list):
            return repr(self.value)
        else:  # Sort the representation of any dicts in the list.
            reps = ('{{{}}}'.format(', '.join(
                        ('{!r}: {}'.format(k, v) for k, v in sorted(v.items()))
                    )) if isinstance(v, dict)
                        else
                    repr(v) for v in self.value)
            return '[' + ',\n'.join(reps) + ']'


def di(obj_id):
    """ Reverse of id() function. """
    # from https://stackoverflow.com/a/15012814/355230
    return _ctypes.PyObj_FromPtr(obj_id)


class MyEncoder(json.JSONEncoder):
    FORMAT_SPEC = "@@{}@@"
    regex = re.compile(FORMAT_SPEC.format(r"(\d+)"))

    def default(self, obj):
        return (self.FORMAT_SPEC.format(id(obj)) if isinstance(obj, OneDictPerLine)
                else super(MyEncoder, self).default(obj))

    def encode(self, obj):
        format_spec = self.FORMAT_SPEC  # Local var to expedite access.
        json_repr = super(MyEncoder, self).encode(obj)  # Default JSON repr.

        # Replace any marked-up object ids in the JSON repr with the value
        # returned from the repr() of the corresponding Python object.
        for match in self.regex.finditer(json_repr):
            id = int(match.group(1))
            # Replace marked-up id with actual Python object repr().
            json_repr = json_repr.replace(
                       '"{}"'.format(format_spec.format(id)), repr(di(id)))

        return json_repr
</code></pre>
<p>Sample usage:</p>
<pre><code>data = [
    {"key01":"value","key02":"value"},
    {"key11":"value","key12":"value"},
    {"key21":"value","key22":"value"}
]

print(json.dumps(OneDictPerLine(data), cls=MyEncoder))
</code></pre>
<p>Output:</p>
<pre class="lang-none prettyprint-override"><code>[{'key01': value, 'key02': value},
{'key11': value, 'key12': value},
{'key21': value, 'key22': value}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I agree with another response -- the best you can do is to <code>json.dump</code> each <code>dict</code> individually and write the commas and newlines manually. Here is how I would do that:</p>
<pre><code>import json

data = [
    {"key01":"value","key02":"value"},
    {"key11":"value","key12":"value"},
    {"key21":"value","key22":"value"}
]

import json
with open('file.json', 'w') as fp:
    fp.write(
        '[' +
        ',\n'.join(json.dumps(i) for i in data) +
        ']\n')
</code></pre>
<p>Result:</p>
<pre class="lang-json prettyprint-override"><code>[{"key01": "value", "key02": "value"},
{"key12": "value", "key11": "value"},
{"key22": "value", "key21": "value"}]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your final <code>file.json</code> example is not a valid JSON. Assuming you want to just convey the form with it you might try extending the <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" rel="nofollow noreferrer"><code>json.JSONEncoder</code></a>, but assuming you don't have nested structures in your dictionaries a quick and dirty approach would be to just construct the file manually, i.e.</p>
<pre><code>import json

your_data = [  # lets define some test data
    {"key1.0": "value", "key2.0": "value"},
    {"key1.1": "value", "key2.1": "value"},
    {"key1.2": "value", "key2.2": "value"},
    {"key1.3": "value", "key2.3": "value"},
]

with open("file.json", "w") as f:  # open our file for writing
    f.write("[")  # begin a JSON array
    if your_data:  # a check to determine that our array is not empty
        for element in your_data:  # now loop through your elements one by one
            json.dump(element, f)  # JSON encode each element and write it to the file
            f.write(",\n")  # close the element entry with a comma and a new line
        f.seek(-3, 1)  # go back to the last separator to clear out the comma
    f.write("]")  # end the JSON array
    f.truncate()  # remove the rest, just in case
</code></pre>
<p>Which will produce:</p>
<pre>[{"key1.0": "value", "key2.0": "value"},
{"key1.1": "value", "key2.1": "value"},
{"key1.2": "value", "key2.2": "value"},
{"key1.3": "value", "key2.3": "value"}]</pre>
</div>
<span class="comment-copy">So you don't want to have your JSON compacted or pretty-printed, what else is there? Can you show a desired format?</span>
<span class="comment-copy">I made a minor edit to show what I'm looking for.</span>
<span class="comment-copy">I am curious as to <i>why</i> you want this format.</span>
<span class="comment-copy">Well, not a particular technical reason. Just because I find it a bit more nicer in case I need to visualize it. :)</span>
