<div class="post-text" itemprop="text">
<p>Let's quote numpy manual: <a href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing" rel="noreferrer">https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</a></p>
<blockquote>
<p>Advanced indexing is triggered when the selection object, obj, is a non-tuple sequence object, an ndarray (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing: integer and Boolean.</p>
<p>Advanced indexing always returns a copy of the data (contrast with basic slicing that returns a view).</p>
</blockquote>
<p>Then operating on what was returned by advanced indexing should never modify the original array. And indeed:</p>
<pre><code>import numpy as np

arr = np.array([0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
indexes = np.array([3, 6, 4])

slicedArr = arr[indexes]
slicedArr *= 5
arr
</code></pre>
<p>This prints:</p>
<pre><code>array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
</code></pre>
<p>However, this does not always seem to be the case. Oddly if I don't save whatever was returned by the <code>[]</code> operator to an intermediate variable I am somehow operating on the original array. Please consider this example:</p>
<pre><code>import numpy as np

arr = np.array([0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
indexes = np.array([3, 6, 4])

arr[indexes] *= 5
arr
</code></pre>
<p>This prints:</p>
<pre><code>array([  0,  10,  20, 150, 200,  50, 300,  70,  80,  90])
</code></pre>
<p>I do not complain. Actually, this is a life saver for me. Yet, I fail to understand why does this work and I'd really like to understand this.</p>
<p>To my best understanding, as soon as I write <code>arr[indexes]</code> I am creating a copy of the array; so the subsequent <code>*= 5</code> should operate on this copy and not on the original array. The result of this calculation should, however, be discarded, since it is not written to any variable.</p>
<p>Yet manifestly I am wrong.</p>
<p>Where is my misunderstanding?</p>
</div>
<div class="post-text" itemprop="text">
<p>While statements</p>
<pre><code>a = expr
</code></pre>
<p>and</p>
<pre><code>a[x] = expr
</code></pre>
<p>look similar, they are actually fundamentally different. The first binds the name 'a' to expr.
The second is more or less <a href="https://docs.python.org/3/reference/datamodel.html#emulating-container-types" rel="nofollow noreferrer">equivalent</a> to <code>a.__setitem__(x, expr)</code>. What <code>__setitem__</code> actually does is up to whoever implemented it, but the conventional semantics is to update the container object <code>a</code> at the position indicated by <code>x</code> with <code>expr</code>.
In particular, no intermediate object "representing <code>a[x]</code>" is created.</p>
<p>Just for the sake of completeness <code>a[x]</code> if it is not on the l.h.s. of what syntactically looks like an assignment is more or less equivalent to <code>a.__getitem__(x)</code>.</p>
<p><strong>Update</strong> in response to a follow-up question (What happens when <code>a[x] *= 5</code> is executed?) let us instrument the relevant methods so we can see what is going on. Below, <code>__imul__</code> is the in-place multiplication "magic method":</p>
<pre><code>import numpy as np

class spy(np.ndarray):
    def __getitem__(self, key):
        print('getitem',  key)
        return super().__getitem__(key)
    def __setitem__(self, key, value):
        print('setitem', key)
        return super().__setitem__(key, value)
    def __imul__(self, other):
        print('imul', other)
        return super().__imul__(other)

a = spy((5, 5))
a[...] = 1
a[[1,2],[4,2]] *= 5
</code></pre>
<p>Prints:</p>
<pre><code>setitem Ellipsis
getitem ([1, 2], [4, 2])
imul 5
setitem ([1, 2], [4, 2])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The key point here is </p>
<blockquote>
<p>Advanced indexing always <strong><em>returns</em></strong> a copy of the data </p>
</blockquote>
<p>In your second example you're not using the index to return anything. You're only using the index to modify the values. So the object that you're modifying is the original object. Not the copy.</p>
</div>
<span class="comment-copy">the difference is that your first example goes through <code>__getitem__</code> which does produce a copy because it must. your second example is not  equivalent because assignment to something of the form <code>var[idx]</code> invokes <code>var.__setitem__</code> which allows the implementation to assign directly to something that is not representable as a view</span>
<span class="comment-copy">The second example <i>assigns</i> to <code>arr[indexes]</code>, where the first example does not.</span>
<span class="comment-copy">Unlike in C++, <code>a[b] = c</code> cannot be decomposed into "retrieve <code>a[b]</code>" and "assign to the thing you retrieved"; index assignment is a single operation distinct from index retrieval and regular assignment.</span>
<span class="comment-copy">@user2357112 Kudos for U for going to my profile and seeing my most common tag :)</span>
<span class="comment-copy">Can <code>a[x] *= 5</code> be decomposed into <code>a[x] = (a[x] * 5)</code>? Is, therefore, <code>a[x] *= 5</code> equivalent to <code>a.__setitem__(x, a.__getitem__(x)*5)</code>? Am I getting this right or wrong?</span>
<span class="comment-copy">@gaazkam almost right, <code>*=</code> checks if its <code>l.h.s.</code> has a method <code>__imul__</code> which implements in-place multiplication. So the intermediate returned by <code>a.__getitem__(x)</code> is actually changed in-place before it is passed to <code>a.__setitem__</code>.</span>
<span class="comment-copy">@gaazkam I've updated the answer to cover this.</span>
