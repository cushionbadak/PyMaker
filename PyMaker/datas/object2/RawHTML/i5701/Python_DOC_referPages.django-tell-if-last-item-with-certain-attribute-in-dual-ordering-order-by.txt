<div class="post-text" itemprop="text">
<p>In a Django queryset how can I tell if the list item I'm on (when iterating) is the list item that has a certain attribute.</p>
<p>Example: I order a queryset by:</p>
<pre><code>  MyModel.objects.all().order_by('-featured', '-created_at')
</code></pre>
<p>So, all objects which are featured first by their appropriate time and then all non-featured items sorted by time properly as well.</p>
<p>When iterating in the template I want to be able to tell if I've hit the last "featured" item in the dual-ordering (such that featured = True).</p>
<p>Example usage: If last item -&gt; display banner separating featured / non-featured -&gt; continue iterating displaying non-featured after banner.</p>
<pre><code>{% for object in object_list %}
    # display object
    {% if last item with attribute %} 
          # display banner
    {% endif %}
{% endfor %}
</code></pre>
<p>I know I can do another queryset to get the count, but that's an extra query I'd like to avoid. </p>
</div>
<div class="post-text" itemprop="text">
<p>You can group the items in the queryset using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow noreferrer"><code>itertools.groupby</code></a> before passing it to the template. Then you'll show the banner when the group key changes from <code>True</code> to <code>False</code>:</p>
<pre><code>from itertools import groupby

qs = MyModel.objects.all().order_by('-featured', '-created_at')
grouped_qs = groupby(qs, lambda x: x.featured)
</code></pre>
<p>And then in your template:</p>
<pre class="lang-html prettyprint-override"><code>{% for k, g in grouped_qs %}
   {% if not k %}
       &lt;!- show banner --&gt;
   {% endif %}

   {% for model_obj in g %}
       &lt;!- do something with model_obj --&gt;
   {% endfor %}
{% endfor %}
</code></pre>
</div>
<span class="comment-copy">Doesn't this mess up the time ordering which I have to preserve?</span>
<span class="comment-copy">@Overflow2341313 No it doesn't.</span>
<span class="comment-copy">Awesome. Thanks for the solution. Will accept when I can.</span>
<span class="comment-copy">Is there any reason pagination would break this? I tried iterating using a copy of the queryset (since pagiantion doesn't work on groupby) passed as a context variable and when iterating only one object shows out of the group.</span>
<span class="comment-copy">Django caches the iterators / iterates over them. SO, the solution was to convert it to a list before django does. This prevents the data from being lost in the template.</span>
