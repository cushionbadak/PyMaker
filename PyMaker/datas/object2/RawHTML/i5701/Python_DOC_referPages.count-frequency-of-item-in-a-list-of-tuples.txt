<div class="post-text" itemprop="text">
<p>I have a list of tuples as shown below. I have to count how many items have a number greater than 1. The code that I have written so far is very slow. Even if there are around 10K tuples, if you see below example string appears two times, so i have to get such kind of strings. My question is what is the best way to achieve the count of strings here by iterating over the generator</p>
<p>List:</p>
<pre><code> b_data=[('example',123),('example-one',456),('example',987),.....]
</code></pre>
<p>My code so far:</p>
<pre><code>blockslst=[]
for line in b_data:
    blockslst.append(line[0])

blocklstgtone=[]
for item in blockslst:
    if(blockslst.count(item)&gt;1):
        blocklstgtone.append(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You've got the right idea extracting the first item from each tuple. You can make your code more concise using a list/generator comprehension, as I show you below.</p>
<p>From that point on, the most idiomatic manner to find frequency counts of elements is using a <code>collections.Counter</code> object.</p>
<ol>
<li>Extract the first elements from your list of tuples (using a comprehension)</li>
<li>Pass this to <code>Counter</code></li>
<li>Query count of <code>example</code></li>
</ol>
<pre><code>from collections import Counter

counts = Counter(x[0] for x in b_data)
print(counts['example'])
</code></pre>
<p>Sure, you can use <code>list.count</code> if it’s only <em>one</em> item you want to find frequency counts for, but in the general case, a <code>Counter</code> is the way to go.</p>
<hr/>
<p>The advantage of a <code>Counter</code> is it performs frequency counts of <em>all</em> elements (not just <code>example</code>) in linear (<code>O(N)</code>) time. Say you also wanted to query the count of another element, say <code>foo</code>. That would be done with -</p>
<pre><code>print(counts['foo'])
</code></pre>
<p>If <code>'foo'</code> doesn’t exist in the list, <code>0</code> is returned.</p>
<p>If you want to find the most common elements, call <code>counts.most_common</code> - </p>
<pre><code>print(counts.most_common(n))
</code></pre>
<p>Where <code>n</code> is the number of elements you want to display. If you want to see everything, don't pass <code>n</code>.</p>
<hr/>
<p>To retrieve counts of most common elements, one efficient way to do this is to query <code>most_common</code> and then extract all elements with counts over 1, efficiently with <code>itertools</code>.</p>
<pre><code>from itertools import takewhile

l = [1, 1, 2, 2, 3, 3, 1, 1, 5, 4, 6, 7, 7, 8, 3, 3, 2, 1]
c = Counter(l)

list(takewhile(lambda x: x[-1] &gt; 1, c.most_common()))
[(1, 5), (3, 4), (2, 3), (7, 2)]
</code></pre>
<p>(OP edit) Alternatively, use a <em>list comprehension</em> to get a list of items having count &gt; 1 - </p>
<pre><code>[item[0] for item in counts.most_common() if item[-1] &gt; 1]
</code></pre>
<p>Keep in mind that this isn’t as efficient as the <code>itertools.takewhile</code> solution. For example, if you have one item with count &gt; 1, and a million items with count equal to 1, you’d end up iterating over the list a million and one times, when you don’t have to (because <code>most_common</code> returns frequency counts in descending order). With <code>takewhile</code> that isn’t the case, because you stop iterating as soon as the condition of count &gt; 1 becomes false.</p>
</div>
<div class="post-text" itemprop="text">
<p>First method :</p>
<blockquote>
<p><strong>What about without loop ?</strong></p>
</blockquote>
<pre><code>print(list(map(lambda x:x[0],b_data)).count('example'))
</code></pre>
<p>output:</p>
<pre><code>2
</code></pre>
<p>Second method :</p>
<p>You can calculate using simple dict , without importing any external module or without making it so complex:</p>
<pre><code>b_data = [('example', 123), ('example-one', 456), ('example', 987)]

dict_1={}
for i in b_data:
    if i[0] not in dict_1:
        dict_1[i[0]]=1
    else:
        dict_1[i[0]]+=1

print(dict_1)



print(list(filter(lambda y:y!=None,(map(lambda x:(x,dict_1.get(x)) if dict_1.get(x)&gt;1 else None,dict_1.keys())))))
</code></pre>
<p>output:</p>
<pre><code>[('example', 2)]
</code></pre>
<blockquote>
<p>Test_case :</p>
</blockquote>
<pre><code>b_data = [('example', 123), ('example-one', 456), ('example', 987),('example-one', 456),('example-one', 456),('example-two', 456),('example-two', 456),('example-two', 456),('example-two', 456)]
</code></pre>
<p>output:</p>
<pre><code>[('example-two', 4), ('example-one', 3), ('example', 2)]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Time it took me to do this
  <a href="https://stackoverflow.com/users/5904928/ayodhyankit-paul">ayodhyankit-paul</a>
  posted the same - leaving it in non the less for the generator code
  for testcases and timing:</p>
</blockquote>
<p>Creating <strong>100001</strong> items took roughly 5 seconds, counting took about <strong>0.3s</strong>,
filtering on counts was too fast to measure (with datetime.now() - did not bother with <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow noreferrer">perf_counter</a>) - all in all it took <strong>less then 5.1s</strong> from start to finish for about 10 times the data you operate on.</p>
<p>I think this similar to what <code>Counter</code> in <a href="https://stackoverflow.com/users/4909087/c%e1%b4%8f%ca%9f%e1%b4%85s%e1%b4%98%e1%b4%87%e1%b4%87%e1%b4%85">COLDSPEED</a>s <a href="https://stackoverflow.com/a/47843727/7505395">answer</a> does: </p>
<p>foreach <code>item</code> in <code>list of tuples</code>:</p>
<ul>
<li>if <code>item[0]</code> not in list, put into <code>dict</code> with <code>count of 1</code></li>
<li>else <code>increment count</code> in dict <code>by 1</code></li>
</ul>
<p>Code:</p>
<pre><code>from collections import Counter
import random
from datetime import datetime # good enough for a loong running op


dt_datagen = datetime.now()
numberOfKeys = 100000 


# basis for testdata
textData = ["example", "pose", "text","someone"]
numData = [random.randint(100,1000) for _ in range(1,10)] # irrelevant

# create random testdata from above lists
tData = [(random.choice(textData)+str(a%10),random.choice(numData)) for a in range(numberOfKeys)] 

tData.append(("aaa",99))

dt_dictioning = datetime.now()

# create a dict
countEm = {}

# put all your data into dict, counting them
for p in tData:
    if p[0] in countEm:
        countEm[p[0]] += 1
    else:
        countEm[p[0]] = 1

dt_filtering = datetime.now()
#comparison result-wise (commented out)        
#counts = Counter(x[0] for x in tData)
#for c in sorted(counts):
#    print(c, " = ", counts[c])
#print()  
# output dict if count &gt; 1
subList = [x for x in countEm if countEm[x] &gt; 1] # without "aaa"

dt_printing = datetime.now()

for c in sorted(subList):
    if (countEm[c] &gt; 1):
        print(c, " = ", countEm[c])

dt_end = datetime.now()

print( "\n\nCreating ", len(tData) , " testdataitems took:\t", (dt_dictioning-dt_datagen).total_seconds(), " seconds")
print( "Putting them into dictionary took \t", (dt_filtering-dt_dictioning).total_seconds(), " seconds")
print( "Filtering donw to those &gt; 1 hits took \t", (dt_printing-dt_filtering).total_seconds(), " seconds")
print( "Printing all the items left took    \t", (dt_end-dt_printing).total_seconds(), " seconds")

print( "\nTotal time: \t", (dt_end- dt_datagen).total_seconds(), " seconds" )
</code></pre>
<p>Output:</p>
<pre><code># reformatted for bevity
example0  =  2520       example1  =  2535       example2  =  2415
example3  =  2511       example4  =  2511       example5  =  2444
example6  =  2517       example7  =  2467       example8  =  2482
example9  =  2501

pose0  =  2528          pose1  =  2449          pose2  =  2520      
pose3  =  2503          pose4  =  2531          pose5  =  2546          
pose6  =  2511          pose7  =  2452          pose8  =  2538          
pose9  =  2554

someone0  =  2498       someone1  =  2521       someone2  =  2527
someone3  =  2456       someone4  =  2399       someone5  =  2487
someone6  =  2463       someone7  =  2589       someone8  =  2404
someone9  =  2543

text0  =  2454          text1  =  2495          text2  =  2538
text3  =  2530          text4  =  2559          text5  =  2523      
text6  =  2509          text7  =  2492          text8  =  2576      
text9  =  2402


Creating  100001  testdataitems took:    4.728604  seconds
Putting them into dictionary took        0.273245  seconds
Filtering donw to those &gt; 1 hits took    0.0  seconds
Printing all the items left took         0.031234  seconds

Total time:      5.033083  seconds 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Let me give you an example to make you understand.Although this example is very much different than your example, I found it very helpful while solving these type of questions.</p>
<pre><code>from collections import Counter

a = [
(0, "Hadoop"), (0, "Big Data"), (0, "HBase"), (0, "Java"),
(1, "Postgres"), (2, "Python"), (2, "scikit-learn"), (2, "scipy"),
(2, "numpy"), (2, "statsmodels"), (2, "pandas"), (3, "R"), (3, "Python"),
(3, "statistics"), (3, "regression"), (3, "probability"),
(4, "machine learning"), (4, "regression"), (4, "decision trees"),
(4, "libsvm"), (5, "Python"), (5, "R"), (5, "Java"), (5, "C++"),
(5, "Haskell"), (5, "programming languages"), (6, "statistics"),
(6, "probability"), (6, "mathematics"), (6, "theory"),
(7, "machine learning"), (7, "scikit-learn"), (7, "Mahout"),
(7, "neural networks"), (8, "neural networks"), (8, "deep learning"),
(8, "Big Data"), (8, "artificial intelligence"), (9, "Hadoop"),
(9, "Java"), (9, "MapReduce"), (9, "Big Data")
]
# 
# 1. Lowercase everything
# 2. Split it into words.
# 3. Count the results.

dictionary = Counter(word for i, j in a for word in j.lower().split())

print(dictionary)

# print out every words if the count &gt; 1
[print(word, count) for word, count in dictionary.most_common() if count &gt; 1]
</code></pre>
<p>Now this is your example solved in the above manner</p>
<pre><code>from collections import Counter
a=[('example',123),('example-one',456),('example',987),('example2',987),('example3',987)]

dict = Counter(word for i,j in a for word in i.lower().split() )

print(dict)

[print(word ,count) for word,count in dict.most_common() if count &gt; 1  ]
</code></pre>
</div>
<span class="comment-copy">By the way, that isn't a generator expression, it's a list.</span>
<span class="comment-copy">Most common method, is there way it can give me all the strings like example having count &gt; 1</span>
<span class="comment-copy">@min2bro Yes, why not. query <code>most_common</code>, and iterate over with a loop. Let me write up a small answer.</span>
<span class="comment-copy">Thanks for <code>Counter</code> - did not know that one and recreated it the same as Ayodhyankit Paul did</span>
<span class="comment-copy">@coldspeed, Added the list comprehension to only get the list of Strings having count greater than 1</span>
<span class="comment-copy">The only problem here is that I need to again iterate over the dict_1 dictionary to find the strings having count greater than 1</span>
<span class="comment-copy">@min2bro i have update the  solution now check , you even don't need loop there or any external module.</span>
<span class="comment-copy">I am looking for all the strings which have count &gt; 1, so the above solution works for one string count at a time</span>
<span class="comment-copy">Your code is just a re-implementation of <code>Counter</code>. Why are you reinventing the wheel?</span>
<span class="comment-copy">@min2bro if you want for all string then go with my second solution , and yeah i fixed that issue now you don't have to iterate over dic_t dictionary to find the strings having count greater than 1 check .</span>
<span class="comment-copy">@COOLDSPEED mentions in other answer that this is about what Counter does internally - so dont use mine, use <code>Counter</code> ;) my guess would be it works even smarter.</span>
<span class="comment-copy">I can still appreciate a well put together answer. Upvoted, cheers.</span>
