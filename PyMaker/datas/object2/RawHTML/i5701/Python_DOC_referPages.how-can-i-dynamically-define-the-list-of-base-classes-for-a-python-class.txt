<div class="post-text" itemprop="text">
<p>I have a custom Django <a href="https://docs.djangoproject.com/en/dev/topics/class-based-views/mixins/" rel="nofollow noreferrer">mixin</a> which should be imported/added to a view class <strong>only</strong> if some app is <a href="https://docs.djangoproject.com/en/dev/ref/applications/#django.apps.apps.is_installed" rel="nofollow noreferrer">installed</a>, e.g.</p>
<pre><code>class MyView(LoginRequiredMixin, CustomMixin, View):
    #                            ^
    #                            this is an optional mixin
    pass
</code></pre>
<p>How to achieve this in Django?</p>
</div>
<div class="post-text" itemprop="text">
<p>Not that this is good design practice or anything, but one way you could achieve this is attempt to import your mixin at application boot time, just as you would normally, but wrap it in a try/except so that if the app is not installed, you create a stub class of the same name that does nothing. This way the name is resolved in either case and you won't fall over any import errors at startup time.</p>
<p>Something like this:</p>
<pre><code>try:
    from conditional_app import CustomMixin
except ImportError:
    class CustomMixin(object):
        pass

class MyView(LoginRequiredMixin, CustomMixin, View):
    pass
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The parameter list passed to a class definition in Python 3 supports all of the features of a function call, meaning you can use <code>*args</code> and <code>**kwargs</code>-style arguments in the class base list:</p>
<pre><code>bases = [LoginRequiredMixin]

if apps.is_installed("some_app"):
    bases.append(CustomMixin)

class MyView(*bases, View):
    ...
</code></pre>
<p>Alternatively, you can use a <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" rel="nofollow noreferrer">metaclass</a>:</p>
<pre><code>from django.apps import apps

class MixinsMeta(type):
    def __new__(cls, name, bases, namespace, **kwargs):
        # customize the `bases` tuple here..
        return super().__new__(cls, name, bases, namespace)
</code></pre>
<p>Then in the view:</p>
<pre><code>class MyView(View, metaclass=MixinsMeta):
    ...
</code></pre>
</div>
<span class="comment-copy">I have seen this pattern in many frequently used django-packages. I don't think there is a much cleaner way.</span>
