<div class="post-text" itemprop="text">
<p>The first demo:</p>
<pre><code>class B:
    def __init__(self):
        self.name = '234'
    # def __getattribute__(self, name):
    #     print('getattr')
    def __getattr__(self, name):    
        print('get')
    def __setattr__(self, name, value):
        print('set')
    def __delattr__(self, name):
        print('del')


b = B()
print(b.__dict__)
b.name
</code></pre>
<p><code>b.__dict__</code> is <code>{}</code>, but the second demo:</p>
<pre><code>class B:
    def __init__(self):
        self.name = '234'
    def __getattribute__(self, name):
        print('getattr')
    def __getattr__(self, name):
        print('get')
    def __setattr__(self, name, value):
        print('set')
    def __delattr__(self, name):
        print('del')


b = B()
print(b.__dict__)
b.name
</code></pre>
<p><code>b.__dict__</code> is <code>None</code>, why? And <code>b.__dict__</code> invokes <code>__getattribute__</code>, but don't invoke <code>__getattr__</code>, does it mean <code>__getattribute__</code> will prevent from invoking <code>__getattr__</code>?</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>__getattribute__</code>, <code>__setattr__</code> and <code>__delattr__</code> methods are called for all attribute access (getting, setting and deleting). <code>__getattr__</code> on the other hand is <em>only called for missing attributes</em>; it is not normally already implemented, but if it is then <code>__getattribute__</code> calls it if it could not otherwise locate the attribute, or if an <code>AttributeError</code> was raised by <code>__getattribute__</code>.</p>
<p>You replaced the standard implementations of the 3 main methods with methods that do nothing but print and return <code>None</code> (the default in the absence of an explicit <code>return</code> statement). <code>__dict__</code> is just another attribute access, and your <code>__getattribute__</code> method returns <code>None</code>, and never itself calls <code>__getattr__</code> or raises an <code>AttributeError</code>.</p>
<p>From the <a href="https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access" rel="nofollow noreferrer"><em>Customizing attribute access</em> documentation</a>:</p>
<blockquote>
<p><code>object.__getattr__(self, name)</code><br/>
  Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for <code>self</code>).</p>
</blockquote>
<p>and </p>
<blockquote>
<p><code>object.__getattribute__(self, name)</code><br/>
  Called unconditionally to implement attribute accesses for instances of the class. <strong>If the class also defines <code>__getattr__()</code>, the latter will not be called unless <code>__getattribute__()</code> either calls it explicitly or raises an <code>AttributeError</code>.</strong></p>
</blockquote>
<p>(Bold emphasis mine).</p>
<p>Either call the base implementation (via <code>super().__getattribute__</code>) or raise an <code>AttributeError</code>:</p>
<pre><code>&gt;&gt;&gt; class B:
...     def __init__(self):
...         self.name = '234'
...     def __getattribute__(self, name):
...         print('getattr')
...         return super().__getattribute__(name)
...     def __getattr__(self, name):
...         print('get')
...     def __setattr__(self, name, value):
...         print('set')
...     def __delattr__(self, name):
...         print('del')
...
&gt;&gt;&gt; b = B()
set
&gt;&gt;&gt; b.__dict__
getattr
{}
&gt;&gt;&gt; b.name
getattr
get
&gt;&gt;&gt; class B:
...     def __init__(self):
...         self.name = '234'
...     def __getattribute__(self, name):
...         print('getattr')
...         raise AttributeError(name)
...     def __getattr__(self, name):
...         print('get')
...     def __setattr__(self, name, value):
...         print('set')
...     def __delattr__(self, name):
...         print('del')
...
&gt;&gt;&gt; b = B()
set
&gt;&gt;&gt; b.__dict__
getattr
get
&gt;&gt;&gt; b.name
getattr
get
</code></pre>
<p>Note that by calling <code>super().__getattribute__</code> the actual <code>__dict__</code> attribute is found. By raising an <code>AttributeError</code> instead, <code>__getattr__</code> was called, which also returned <code>None</code>.</p>
</div>
<span class="comment-copy"><code>b.name</code> don't call <code>__getattr__</code> either, but <code>b</code> don't have attribute <code>name</code>, so why don't call <code>__getattr__</code>?</span>
<span class="comment-copy">@gaussclb: <code>b.name</code> <b>does</b> call <code>__getattribute__</code>; <code>get</code> is printed.</span>
<span class="comment-copy">It prints <code>getattr</code> not <code>get</code>, why not call <code>__getattr__</code>?</span>
<span class="comment-copy">ah, your second example. Your <code>__getattribute__</code> replaced the built-in version, so nothing is calling <code>__getattr__</code>.</span>
<span class="comment-copy">@gaussclb: but it isn't, because that's the responsibility of <code>__getattribute__</code>. Your implementation <i>doesn't call it</i>.</span>
