<div class="post-text" itemprop="text">
<p>I am trying to use a multiprocessing <code>Pool</code> without a return value for parallel calculation. It could be faster if there's no need to return and retrieve values from the subprocess. Is there a way to do that?</p>
<p>Here is a simple example:</p>
<pre><code>from multiprocessing import Pool

def fun(a):
    # do something.. 
    a["1"]=100

a={
   "1":12
   }
multi = [a] * 10
p = Pool(4)
p.map(fun, multi)
data = [a["1"] for a in multi]
print(data)
&gt;&gt;&gt; [12, 12, 12, 12, 12, 12, 12, 12, 12, 12]

[fun(a) for a in multi]
data = [a["1"] for a in multi]
print(data)
&gt;&gt;&gt; [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]
</code></pre>
<p>Does anybody know why? And is there a solution for that?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your function <code>fun</code></p>
<pre><code>def fun(a):
    # do something.. 
    a["1"]=100
</code></pre>
<p>changes a mutable argument <code>a</code>. However when you call this using <code>p.map(fun, multi)</code> each item in the <code>multi</code> list is pickled, sent to a worker process and mutated there. This can't have any effect on the original items in the list in the calling process.</p>
<p>You can create data structures that can be shared between processes, so called <a href="https://docs.python.org/3/library/multiprocessing.html#proxy-objects" rel="nofollow noreferrer">proxy objects</a>, using <a href="https://docs.python.org/3/library/multiprocessing.html#managers" rel="nofollow noreferrer">managers</a>. You'd have to create 10 shared dictionaries. In your example you only have one dictionary, the list contains 10 references to it, <code>data = [a["1"] for a in multi]</code> will always only contain the same value because <code>a</code> is always the same object.</p>
<p>So this should work:</p>
<pre><code>from multiprocessing import Pool, Manager
import random

def fun(a):
    # to show that the dictionaries are different
    a["1"] = random.random()

if __name__ == '__main__':
    m = Manager()
    p = Pool(4)
    multi = [m.dict() for _ in range(10)]
    p.map(fun, multi)
    data = [a["1"] for a in multi]
    print(data)
</code></pre>
<p>Note that <code>multi = m.list([a] * 10)</code> or similar would not work, because only list access is synchronized, not updates of the contained elements. But all of this creates additional IPC overhead and probably will be worse then just using the return value of the function if you can.</p>
</div>
<span class="comment-copy">The "return and retrieve values from subprocess" part is unlikely to be a bottleneck, that is a very fast operation</span>
<span class="comment-copy">For example, if no need to retrieve values, would it be more faster to use <code>p.map_async</code> instead of <code>p.map</code>?</span>
<span class="comment-copy">See <a href="https://stackoverflow.com/questions/35908987/python-multiprocessing-map-vs-map-async" title="python multiprocessing map vs map async">stackoverflow.com/questions/35908987/â€¦</a></span>
<span class="comment-copy"><a href="https://www.youtube.com/watch?v=9zinZmE3Ogk" rel="nofollow noreferrer">PyBay 2017 Keynote on Concurrency</a></span>
<span class="comment-copy">Thanks for wwli. I think the answer below by mata make it clear. It can/do share state by using proxy objects.</span>
<span class="comment-copy">Thanks! It did work. I learned something new about proxy objects. It is very helpful and inspiring!</span>
<span class="comment-copy">I had to say that calculation goes extremely slow compared with the regular dictionary list, when data becomes large for multi processes.</span>
<span class="comment-copy">That's what I ment with <i>IPC overhead</i>, each access behind the scene needs to be synchronized, data sent to a different process and so on. If you have to exchange large amounts of data between your processes, then multiprocessing won't really help much. If your program can be changed to work with <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes" rel="nofollow noreferrer">shared memory</a>, that may help.</span>
