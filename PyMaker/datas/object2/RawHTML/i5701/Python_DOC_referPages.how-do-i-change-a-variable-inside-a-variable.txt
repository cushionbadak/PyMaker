<div class="post-text" itemprop="text">
<p>Here's my code :</p>
<pre><code>hp1 = 100
health1 = 'you have', hp1

hp1 = hp1 - 50
health1

print hp1
print health1
</code></pre>
<p>This is what it prints :</p>
<pre><code>50
('you have', 100)
</code></pre>
<p>Why doesn't the hp1 change inside the health?</p>
</div>
<div class="post-text" itemprop="text">
<p>To do what you wish to do, you must use a <strong>class</strong>. This is the closest form of a pointer you will encounter in python.</p>
<p>Here is an example :</p>
<pre><code>class Health():
    def __init__(self, value):
        self.hp = value

    def __repr__(self):
        return 'You have {}.'.format(self.hp)

health = Health(100)
hp_clone = health
health.hp -= 50

print hp_clone
# Program outputs : You have 50.
</code></pre>
<p>Your question is also a possible duplicate of
<a href="https://stackoverflow.com/questions/3106689/pointers-in-python">Pointers in Python?</a> .</p>
<p>What is happening here in your program has been explained by the others.</p>
</div>
<div class="post-text" itemprop="text">
<p>To automatically change the output with any mutations of <code>hp1</code>, you can use a class:</p>
<pre><code>class Health:
   def __init__(self, health):
       self.health = health
   def __add__(self, val):
       return Health(self.health + val)
   def __sub__(self, val):
       return Health(self.health - val)
   def __repr__(self):
       return "you have {}".format(self.health)

hp1 = Health(100)
hp1 -= 50
print(hp1)
</code></pre>
<p>Output:</p>
<pre><code>you have 50
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The following line:</p>
<pre><code>health1 = 'you have', hp1
</code></pre>
<p>Is creating a <code>tuple</code> with two values: <code>"you have"</code> and <code>100</code> (Note that the value of <code>hp1</code> is <strong><em>copied</em></strong>, and not <strong><em>referenced</em></strong>). It's then assigning this <code>tuple</code> to a new variable named <code>health1</code>.</p>
<p><code>health1</code> has nothing to do with <code>hp1</code>. If <code>hp1</code> get overriden, deleted, thrown away, or anything happens to it, <code>health1</code> doesn't care.</p>
<hr/>
<p>If you are so eager to pass this variable a reference, you can create a wrapper class around the <code>int</code> type:</p>
<pre><code>class IntWrapper(object):
     def __init__(self, value):
          self.value = value
     def __add__(self, value):
          return IntWrapper(self.value + value)
     def __iadd__(self, value):
          self.value += value
          return self
     def __sub__(self, value):
          return IntWrapper(self.value - value)
     def __isub__(self, value):
          self.value -= value
          return self
     def __str__(self):
          return str(self.value)
     def __repr__(self):
          return str(self)

hp1 = IntWrapper(100)
health1 = 'you have', hp1

hp1 -= 50

print hp1          # 50
print health1      # ('you have', 50)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Because you defined <code>health1</code> - a <code>(string, int)</code> tuple - as <code>hp1</code> was still 100 and didn't change it since then. This is not a pointer in C/C++ sense, just a copy by value.</p>
</div>
<div class="post-text" itemprop="text">
<p>In your code you have done like this,</p>
<pre><code>hp1 = 100 # setting hp1 as 100
health1 = 'you have', hp1 # making a tuple 

hp1 = hp1 - 50 # subracting 50 from hp1 -&gt; gives 50 as result
health1 # simply calling health1

print hp1 # displaying hp1
print health1 # displaying health1
</code></pre>
<p>In this code, </p>
<p>You defined <code>hp1</code> as <code>100</code>, let it be stored in a location <code>1000</code></p>
<p>You made a tuple names <code>health1</code> as <code>'you have', hp1</code>. It will be stored in a location say <code>2000</code></p>
<p>You subtracted 50 from <code>hp1</code> making <code>hp1</code> 50, this will make no change to <code>health1</code> variable because it is stored in different location. But it will change the value of <code>hp1</code></p>
<p>Hope this helps.!!</p>
</div>
<span class="comment-copy">Why do you expect it to change?</span>
<span class="comment-copy">because i subtracted 50 from hp1. I'm new to python so I don't reallly know what i'm doing haha</span>
<span class="comment-copy">Recommended reading: <a href="https://nedbatchelder.com/text/names.html" rel="nofollow noreferrer">nedbatchelder.com/text/names.html</a></span>
<span class="comment-copy">You evaluated <code>hp1</code> at the point where you assigned it to <code>health1</code>.  After that they had no connection.  You're not thinking this through.  Suppose you had instead used <code>5 + hp1**2/(1 - hp1)</code>.  Would you still expect the value to track?  Did you think you were creating a closure, and that the expression was reevaluated each time <code>health1</code> was referenced?  Clearly not.</span>
<span class="comment-copy">@StefanPochmann Yes, it's true that <code>health[1] is hp1</code> is <code>True</code> at that point.  But that's not what I meant.  I meant that changing either has no effect on the other.</span>
<span class="comment-copy">This is the first answer that addresses the <i>intent</i> of the question, rather than just explaining the observed results.</span>
<span class="comment-copy">@chepner Well, to be fair, the OP explicitly asked <i>"Why doesn't the hp1 change inside the health?</i>", and not <i>"How to...?"</i></span>
<span class="comment-copy">To be fair, in your example, you could have done <code>a = 0 ; a += 50 ; print a</code>. I believe you should have written what I answered to be in the OP's scope.</span>
<span class="comment-copy">Uh... what is this? That does <b>not</b> do the desired thing.</span>
<span class="comment-copy">If "the value is copied, not referenced", then why is <code>health1[1] is hp1</code> true?</span>
<span class="comment-copy">Terminology nitpick: there are no primitive types in Python. <code>int</code> objects are full objects, just like any other.</span>
<span class="comment-copy">@juanpa.arrivillaga Check out <a href="http://pythonvisually.com/ebook/primitive-data-types.html" rel="nofollow noreferrer">pythonvisually.com/ebook/primitive-data-types.html</a> and <a href="https://en.wikipedia.org/wiki/Primitive_data_type" rel="nofollow noreferrer">en.wikipedia.org/wiki/Primitive_data_type</a></span>
<span class="comment-copy">@StefanPochmann I agree. However, if it don't change the internal value then it will not accomplish what OP wants, because <code>hp1</code> would point to a new reference, and <code>health1</code> would be pointing to a stale one.</span>
<span class="comment-copy">@MatiasCicero Yes, but you'd better not do that with <code>__sub__</code>. Do that with <code>__isub__</code> instead. Or maybe better with <code>decrease</code> or so, calling it as <code>hp1.decrease(50)</code> without assignment notation.</span>
<span class="comment-copy">what's the solution though?</span>
<span class="comment-copy">Solution to what? Change the variable if you want it to change. Don't change them otherwise. I don't see a problem. Work through a tutorial to get a feeling for how these things work: <a href="https://docs.python.org/3/tutorial/" rel="nofollow noreferrer">docs.python.org/3/tutorial</a></span>
<span class="comment-copy">There was no copy by value. Assignment in Python <i>never copies</i></span>
