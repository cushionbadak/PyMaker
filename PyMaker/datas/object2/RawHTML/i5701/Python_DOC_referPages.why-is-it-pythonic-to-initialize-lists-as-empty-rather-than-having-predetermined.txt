<div class="post-text" itemprop="text">
<div class="question-status question-originals-of-duplicate">
<p>This question already has an answer here:</p>
<ul>
<li>
<a dir="ltr" href="/questions/311775/python-create-a-list-with-initial-capacity">Python - Create a list with initial capacity</a>
<span class="question-originals-answer-count">
                    9 answers
                </span>
</li>
</ul>
</div>
<p><strong>Short version of my question:</strong> Why is it common practice in Python to initialize an empty list even when the size of the list might change many times such as the following:</p>
<pre><code>arr = []
for i in range(10):
   arr.append(i)
</code></pre>
<p><strong><em>Isn't it computationally expensive to change the size of an array iteratively?</em></strong></p>
<p><strong>Long version of my question:</strong> I'm used to using MATLAB and am relatively new to Python. When I want to create an array, it is common practice in MATLAB to initialize an array of zeros of appropriate size, and then replace the elements of the array with the elements you want to end up with. This is because changing the size of an array iteratively in MATLAB is computationally expensive. Is there something about Python that avoids this expense? When I see people answer Python questions on this website that involve preinitializing a list to be added to, they always create an empty list and subsequently change the size, something I have always regarded as inefficient.</p>
</div>
<div class="post-text" itemprop="text">
<p>Python does not grow the list one by one.  It always allocates large chunks. The chunk size is dependent on the size of the list. So the pre-allocated space gets bigger when the list get bigger.</p>
<p>For example, if you do 10 million appends, it does about 100 allocation, i.e. steps growing the list.</p>
<p>If you start with an empty list and grow it by appending one element at a time you get this steps the actually allocate new memory:</p>
<pre><code> list size:  allocations
        10:   3
       100:  10
      1000:  27
     10000:  46
    100000:  65
   1000000:  85
  10000000: 104
</code></pre>
<p>MATLAB array are more comparable to NumPy arrays. These array are fixed in size an growing them step-by-step is very expensive.</p>
</div>
<div class="post-text" itemprop="text">
<p>The main point of creating a list and populating it later would be <em>because</em> you don't know how many elements are going to make their way into it.  Since lists dynamically resize themselves, and arrays inherently <strong>do not</strong>, as they are typically reserved in contiguous blocks of memory and lists don't have to be, it's convenient to author your code in such a way that takes advantage of this fact.</p>
<p>However, the above isn't a good use of creating a list.  You would want to use a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a> instead to generate this:</p>
<pre><code>arr = [i for i in range(10)]
</code></pre>
<p>You would <em>want</em> to fill the list if you know how many elements you have in it.  You <em>can't</em> fill the list if you <em>don't</em> know.</p>
</div>
<span class="comment-copy">it is not array, it is list. list works different than array.</span>
<span class="comment-copy">For avoiding the expense, <code>list</code>s are designed to grow by larger steps as they increase in size (so the <code>realloc</code>s reduce as the number of elements increases), and they only store pointers to their contents, so when <code>realloc</code> has to move the allocation, it's effectively just a <code>memcpy</code> of <code>8 * numelements</code> bytes; it costs a little, but the overhead of the Python interpreter generally masks small costs like that.</span>
<span class="comment-copy">@furas: This is <a href="https://docs.python.org/2/faq/design.html#how-are-lists-implemented" rel="nofollow noreferrer">not quite correct</a> (or at least correct only in Python context, due to how it twisted the usual terminology). For some unknown reason, Python co-opted the term "list" to what every other language calls "array" or "vector". Then numpy took the unused term "array" and stole it for itself.</span>
<span class="comment-copy">This is nice. Do you have any source on the numbers?</span>
<span class="comment-copy">Self-generated with pympler. :)</span>
<span class="comment-copy">@cᴏʟᴅsᴘᴇᴇᴅ <a href="https://github.com/python/cpython/blob/master/Objects/listobject.c#L50" rel="nofollow noreferrer">github.com/python/cpython/blob/master/Objects/listobject.c#L50</a></span>
