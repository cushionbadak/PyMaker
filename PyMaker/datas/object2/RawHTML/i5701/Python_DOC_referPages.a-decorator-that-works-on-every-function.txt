<div class="post-text" itemprop="text">
<p>I want to print Hello World on every function call and I'm using decorators to achieve this.  </p>
<pre><code>def hello_decorator(fn):
    def ret_fn(*args, **kwargs):
        print("Hello world")
        return fn(*args, **kwargs)
    return ret_fn
</code></pre>
<p>Assuming that this caused a function to error out, while an undecorated version of that function worked fine, what might be the problem with the decorator?  The issue isn't with print since I can remove that and the issue remains.</p>
<p>Is there a better way to wrap a function and call it exactly the way it would have been called without the prototype?</p>
</div>
<div class="post-text" itemprop="text">
<p>A decorator must return a function.</p>
<pre><code>def hello_decorator(fn):
    def ret_fn(*args, **kwargs):
        print("Hello world")
        return fn(*args, **kwargs)
    return ret_fn
</code></pre>
</div>
<span class="comment-copy">This is not a valid decorator. A decorator should return a function.</span>
<span class="comment-copy">Take a look at <a href="https://pypi.python.org/pypi/wrapt" rel="nofollow noreferrer">wrapt</a>.</span>
<span class="comment-copy">What do you mean by “called without the prototype”. Can you explain further?</span>
<span class="comment-copy">@LaurentLAPORTE read as called, without knowing the prototype.  I meant how can you decorate an arbitrary function without knowing it's prototype?</span>
<span class="comment-copy">@1419636215 Exactly as you currently do, by passing <code>*args</code> and <code>**kwargs</code> straight through. Further, you can use <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow noreferrer">functools.wraps</a> to preserve more details of the decorated function (e.g. name, docstring, etc.)</span>
<span class="comment-copy">Sorry about that.  I've edited the code in the question.</span>
