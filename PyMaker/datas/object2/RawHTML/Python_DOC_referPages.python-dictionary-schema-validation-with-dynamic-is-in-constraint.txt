<div class="post-text" itemprop="text">
<p>I am looking for a solution for the validation of a dictionary with one constraint being an <code>is in</code> constraint where the values considered valid stem from the dictionary being validated itself.</p>
<p>For instance, imagine the following pseudo-schema</p>
<pre><code>{
    "notions" : [ string ],
    "category" : [ is in notions ]
}
</code></pre>
<p>To be totally clear, I also express the constraints of this pseudo-schema verbally. These are the constraints I want to validate, be <code>d</code> the dictionary to validate:</p>
<ol>
<li><code>set(d.keys()) == {"notions", "categories"}</code></li>
<li><code>isinstance(d["notions"], list)</code></li>
<li><code>isinstance(notion, str) for notion in d["notions"]</code></li>
<li><code>isinstance(d["category"], list)</code></li>
<li><code>element is in d["notion"] for element in d["category"]</code></li>
</ol>
<p>Don't ask, whether this specific data structure makes any sense. It does not. I just made it up, to create a minimum example for my problem. My actual dictionary schema is much more complex and would have multiple references to values from the dict. That is why I would like to avoid to define and validate the constraints manually, and would prefer a schema-based solution.</p>
<p>I have looked into some schema validation libraries, but I haven't found this feature included anywhere. Is there a solution based on some libraries, maybe with a small tweak? I would rather prefer not to invent the wheel a second time.</p>
</div>
<div class="post-text" itemprop="text">
<p>In general, schema validators try to avoid pulling in data into the validator. The <a href="https://json-schema.org/" rel="nofollow noreferrer">JSON-schema standard</a>, for example, is <a href="https://github.com/json-schema-org/json-schema-spec/issues/51" rel="nofollow noreferrer">debating adding <code>$data</code> access in schemas</a> but hasn't (yet) implemented the idea (even though they have <a href="https://github.com/json-schema-org/json-schema-spec/labels/%24data" rel="nofollow noreferrer">several use cases for it</a>).</p>
<p>The general objection is that making the validation schema dependent on the data it is validating makes it hard to keep validation context-free (which makes implementation easier, and makes validation in parallel a lot easier), and it makes static analysis of schemas much harder (as the schema changes with the data at runtime).</p>
<p>That said, the <a href="https://docs.pylonsproject.org/projects/colander/en/latest/index.html" rel="nofollow noreferrer">Colander project</a> can do what you want, as it allows you to trivially define validators in Python code.</p>
<p>For example:</p>
<pre><code>import colander

class Foo(colander.MappingSchema):
    @colander.instantiate()
    class notions(colander.SequenceSchema):
        notion = colander.SchemaNode(colander.String())

    @colander.instantiate()
    class category(colander.SequenceSchema):
        cat = colander.SchemaNode(colander.String())

    def validator(self, node, cstruct):
        """Validate that all category values are listed in notions"""
        notions = set(cstruct['notions'])
        if not notions.issuperset(cstruct['category']):
            raise colander.Invalid(
                node['category'], 
                "All categories must be listed in notions"
            )
</code></pre>
<p>Note that the validator is defined at the level where both <code>notions</code> and <code>category</code> are defined in, as a validator only has access to the 'local' section of the data being validated (with all child node validations already haven taken place). If you defined the validator only for <code>category</code> then you couldn't access the <code>notions</code> list, and you can count on the <code>notions</code> list already having been validated. The validator raises an <code>Invalid</code> exception, and the first argument is the <code>category</code> schema node to lay the blame squarely on the values in that list.</p>
<p>A Colander schema validates as it de-serializes; you can see the input of the <code>Schema.deserialize()</code> method as unvalidated data (a <em>colander serialization</em>) and the output as application-ready data (<em>appdata</em>), validated and cleaned up. That's because Colander will also put default values in place if missing, can produce tuples, sets, <code>datetime</code> values, and more, and also supports data preparation (cleaning up HTML, etc.) as you process it with the schema.</p>
<p>With some demo input the above schema validates and returns the validated structure if successful:</p>
<pre><code>&gt;&gt;&gt; schema = Foo()
&gt;&gt;&gt; schema.deserialize({'notions': [], 'category': []})
{'notions': [], 'category': []}
&gt;&gt;&gt; schema.deserialize({'notions': ['foo', 'bar'], 'category': []})
{'notions': ['foo', 'bar'], 'category': []}
&gt;&gt;&gt; schema.deserialize({'notions': ['foo', 'bar'], 'category': ['foo']})
{'notions': ['foo', 'bar'], 'category': ['foo']}
&gt;&gt;&gt; schema.deserialize({'notions': ['foo', 'bar'], 'category': ['foo', 'spam']})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/.../site-packages/colander/__init__.py", line 2381, in deserialize
    self.validator(self, appstruct)
  File "&lt;string&gt;", line 17, in validator
colander.Invalid: {'category': 'All categories must be listed in notions'}
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Your dictionary is that complex then you're doing this all wrong. Consider creating classes and store an object of that class in the dictionary. Those classes can also hold other objects of other classes. This way you'll avoid the nesting of dictionaries. Create functions within classes to validate its data. </p>
</div>
<span class="comment-copy">Well, ok, we don't need to talk about the schema. But I have no idea what <code>isinstance(notion, string) for notion in d["notions"]</code> (point 3) is supposed to do.</span>
<span class="comment-copy">@roganjosh Sorry, this was supposed to be <code>isinstance(notion, str) for notion in d["notions"]</code>, it should mean that all items of the list <code>d["notions"]</code> are strings.</span>
<span class="comment-copy">I kinda half expect the <a href="https://docs.python.org/3/library/typing.html" rel="nofollow noreferrer">typing module</a> to cover some of this when <i>building</i> the dictionary but not all of it. This is pretty extensive testing; I assume this is a test suite and not part of the regular flow?</span>
<span class="comment-copy"><code>d.keys() == ["notions", "categories"]</code> might suffer from dictionaries being unordered in Python &lt; 3.7 (you might get away with 3.6) and then <code>element is in d["notion"] for element in d["category"]</code> just keeps growing.</span>
<span class="comment-copy">@roganjosh: typing deals with object types, not values. <code>str</code> is an object type, <code>all(v in d['notion'] for v in d['category'])</code> is a value restriction.</span>
<span class="comment-copy">Nesting of dictionaries? Where is that happening?</span>
<span class="comment-copy">"You're doing it all wrong" is a pretty strong statement and I don't think it's substantiated. The OP is just putting in a lot of checks to ensure the dict is consistent with what they expect.</span>
<span class="comment-copy">My first approach was actually to create a bunch of classes to tackle the validation. After having finished this, I thought: "There must be an easier solution" (My use case has 6 levels of nesting.) And I really think, it is not good style to create a lot of classes for this validation. Whenever the schema changes, or I want to have additional schemas, I need to write a bunch of new classes. This does not seem very DRY to me.</span>
<span class="comment-copy">Ok let me take a step back. In any case you have to keep some sort of documentation of where and when you're implementing those validation checks. I would still write separate classes on separate files and document it. At least that way my code is cleaner and easier to read.</span>
<span class="comment-copy">This is a common problem to solve when validating de-serialised from a standardised programming-language-neutral data exechange format of key-value pairings and sequences of values. Like JSON, or YAML. You can transform such a structure into instances, but you may want to validate the data first, as early as possible, before you do so. What the OP is asking for is entirely reasonable.</span>
