<div class="post-text" itemprop="text">
<p>I have two lists with the same length, say 3.</p>
<pre><code>A=[1,2,3]
B=[4,5,6]
</code></pre>
<p>I want to get Cartesian product of the two, <strong>but</strong> the element at the same position shouldn't be count i.e. :</p>
<pre><code>(1,5),(1,6),(2,4),(2,6),(3,4),(3,5)
</code></pre>
<p>How shall I do that?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can nearly directly jot down your 'refined' carthesian product:</p>
<pre><code> ((a[i], b[j]) 
      for i in range(len(a))
      for j in range(len(b))
      if i != j)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>So here's my way to do it use <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow"><code>zip()</code></a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.product" rel="nofollow"><code>itertools.product()</code></a>:</p>
<pre><code>import itertools
A = [1, 2, 3]
B = [4, 5, 6]

spe = set(zip(A, B))
l = [i for i in itertools.product(A, B) if i not in spe]
</code></pre>
<hr/>
<p>From the document of <code>itertools.product()</code>:</p>
<blockquote>
<p><code>itertools.product(*iterables, repeat=1)</code><br/>
  Cartesian product of input iterables.</p>
<p>Equivalent to nested for-loops in a generator expression. For example, <code>product(A, B)</code> returns the same as <code>((x,y) for x in A for y in B)</code>.</p>
<p>The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the inputâ€™s iterables are sorted, the product tuples are emitted in sorted order.</p>
</blockquote>
<p>And <code>zip()</code> does <em>Make an iterator that aggregates elements from each of the iterables.</em> As the document says.</p>
<hr/>
<p>So my code create a set and it has the elements which you don't want, then <code>itertools.product(A, B)</code> produces the full list, <code>if i not in spe</code> removes the elements which you don't want in that list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Just get the product in the normal way, then filter it out:</p>
<pre><code>import itertools
A=[1,2,3]
B=[4,5,6]
prod = ((x,y) for x,y in itertools.product(A, B) if A.index(x) != B.index(y))
</code></pre>
<p>Result:</p>
<pre><code>&gt;&gt;&gt; for p in prod:
...     print(p)
...
(1, 5)
(1, 6)
(2, 4)
(2, 6)
(3, 4)
(3, 5)
</code></pre>
<p><code>prod</code> is a generator there, so remember to instead create a comprehension with <code>prod = [...]</code> if you plan on using it more than once.</p>
<p>Note that this doesn't work if <code>A</code> and <code>B</code> contain repeated elements. To solve this, <code>enumerate</code> it and discard the items with unwanted indices:</p>
<pre><code>prod = (item for idx,item in enumerate((x,y) for x,y in itertools.product(A, B)) if idx%(len(A)))
</code></pre>
<p>Result:</p>
<pre><code>&gt;&gt;&gt; for p in prod:
...     print(p)
...
(1, 5)
(1, 6)
(2, 5)
(2, 6)
(3, 5)
(3, 6)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Without any indexing on the lists nor any calculation based on the length of the lists, using plain enumerate</p>
<pre><code>&gt;&gt;&gt; g=((a,b) for pa,a in enumerate(A) for pb,b in enumerate(B) if pa!=pb)
&gt;&gt;&gt; for t in g: print(t)
... 
(1, 5)
(1, 6)
(2, 4)
(2, 6)
(3, 4)
(3, 5)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can iterate <code>list A</code> and iterate <code>list B</code> for each value of <code>list A</code>. If index of both list differs, you can print out the combination of elements from both lists.</p>
<pre><code>for i in range(len(A)):
        for j in range(len(B)):
                if i != j:
                        print '(',A[i],B[j],')'


( 1 5 )
( 1 6 )
( 2 4 )
( 2 6 )
( 3 4 )
( 3 5 )
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try the following approaches. Since the cartesian product is a set, I will provide my answer as a set of tuples:</p>
<h3>Using a set comprehension</h3>
<pre><code>&gt;&gt;&gt; A=[1,2,3]
&gt;&gt;&gt; B=[4,5,6]
&gt;&gt;&gt; {(a, b) for i, a in enumerate(A) for j, b in enumerate(B) if i != j}
{(1, 5), (1, 6), (2, 4), (2, 6), (3, 4), (3, 5)}
</code></pre>
<p>I use <code>enumerate(l)</code> in order to have a tuple <code>(index, element)</code> at each iteration in which <code>index</code> is the index of each <code>element</code> of <code>l</code>.</p>
<h3>Using itertools</h3>
<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; {(a, b) for a, b in itertools.product(A, B) if A.index(a) != B.index(b)}
{(1, 5), (1, 6), (2, 4), (2, 6), (3, 4), (3, 5)}
</code></pre>
</div>
<span class="comment-copy">I just added an answer to your question!</span>
<span class="comment-copy">This is the clear solution.  In fact, I was about to post essentially the identical thing until I saw you already had :)</span>
<span class="comment-copy">How well does this extend to multiple <code>list</code>s, in terms of code size?</span>
<span class="comment-copy">@TigerhawkT3: N(len(lists)).  For multiple lists, a clause has to be added, and the condition would have to be altered to <code>not (i == j or i == k or ...)</code>.  In case you don't know the number of operands upfront, you would need a helper function.  But probably then you're better off using numpy or the like.</span>
<span class="comment-copy">That's pretty much why I tried to stick with <code>itertools.product</code>, yeah. I guess each approach has its drawbacks.</span>
<span class="comment-copy">since you mention <code>set</code>... how about <code>set(product(A, B)) - set(zip(A, B))</code>?</span>
<span class="comment-copy">What happens for <code>A=[1, 1, 1] x B=[2, 2, 2]</code>?  "Return the index in the list of <i>the first</i> item whose value is x. It is an error if there is no such item. "</span>
<span class="comment-copy">Two problems:  (1) The test inside the comprehension adds a factor of n to the performance, since it will search both lists for each and every result item.  Instead of O(n^2), it will be O(n^3).  And (2) It will fail if either list contains a duplicate element.  Consider A=[1,1] and B=[2,3].  The result should be [(1,3), (1,2)], but instead this will incorrectly give [(!,3), (1,2)].</span>
<span class="comment-copy">Then it would break, but the question didn't specify repeated elements.</span>
<span class="comment-copy">@TigerhawkT3: silly question, is it :)?</span>
<span class="comment-copy">I'll fix it, though. :)</span>
<span class="comment-copy">There's no difference between your answer and xtofl's answer...</span>
<span class="comment-copy">It's easier to understand this answer for a beginner.</span>
<span class="comment-copy">A code block alone does not provide a good answer. Please add explanations (why it solve the issue, where was the mistake, etc...)</span>
<span class="comment-copy">@LouisBarranqueiro Updated</span>
