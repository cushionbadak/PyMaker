<div class="post-text" itemprop="text">
<p>For this problem I am dealing with a big list,that it was imported from a CSV file, but let's say
I have a list like this:</p>
<pre><code>[['name','score1','score2''score3''score4']
 ['Mike','5','1','6','2']
 ['Mike','1','1','1','1']
 ['Mike','3','0','3','0']
 ['jose','0','1','2','3']
 ['jose','2','3','4','5']
 ['lisa','4','4','4','4']]
</code></pre>
<p>and I want to have another list with this form(the sum of all score for each student):</p>
<pre><code>[['Mike','9','2','10','3']
 ['jose','2','4','6','8']
 ['lisa','4','4','4','4']]
</code></pre>
<p>any ideas how this can be done?
I've been trying many ways, and I could not make it.
I was stuck when there where more than 2 same names, my solution only kept the last 2 lines to add.
I am new in python and programming in general.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you are just learning Python I always recommend try to implement things without relying on external libraries.  A good starting step is to start by trying to break the problem up into smaller components:</p>
<ol>
<li>Remove the first entry (the column titles) from the input list.  You don't need it for your result.</li>
<li><p>For each remaining entry:</p>
<ol>
<li>Convert every entry except the first to an integer (so you can add them).</li>
<li>Determine if you have already encountered an entry with the same name (first column value).  If not: add the entry to the output list.  Otherwise: merge the entry with the one already in the output list (by adding values in the columns).</li>
</ol></li>
</ol>
<p>One possible implementation follows (untested):</p>
<pre><code>input_list = [['name','score1','score2''score3''score4'],
              ['Mike','5','1','6','2'],
              ['Mike','1','1','1','1'],
              ['Mike','3','0','3','0'],
              ['jose','0','1','2','3'],
              ['jose','2','3','4','5'],
              ['lisa','4','4','4','4']]
print input_list

# Remove the first element
input_list = input_list[1:]

# Initialize an empty output list
output_list = []

# Iterate through each entry in the input
for val in input_list:
    # Determine if key is already in output list
    for ent in output_list:
        if ent[0] == val[0]:
            # The value is already in the output list (so merge them)
            for i in range(1, len(ent)):
                # We convert to int and back to str
                # This could be done elsewhere (or not at all...)
                ent[i] = str(int(ent[i]) + int(val[i]))
            break
    else:
        # The value wasn't in the output list (so add it)
        # This is a useful feature of the for loop, the following
        # is only executed if the break command wasn't reached above
        output_list.append(val)

#print input_list
print output_list
</code></pre>
<p>The above is not as efficient as using a dictionary or importing a library that can perform the same operation in a couple of lines, however it demonstrates a few features of the language.  Be careful when working with lists though, the above modifies the input list (try un-commenting the print statement for the input list at the end).</p>
</div>
<div class="post-text" itemprop="text">
<p>Let us say you have </p>
<pre><code>In [45]: temp
Out[45]: 
 [['Mike', '5', '1', '6', '2'],
  ['Mike', '1', '1', '1', '1'],
  ['Mike', '3', '0', '3', '0'],
  ['jose', '0', '1', '2', '3'],
  ['jose', '2', '3', '4', '5'],
  ['lisa', '4', '4', '4', '4']]
</code></pre>
<p>Then, you can use Pandas ...</p>
<pre><code>import pandas as pd 

temp = pd.DataFrame(temp)
def test(m):
     try:    return int(m)
     except: return m

temp = temp.applymap(test)
print temp.groupby(0).agg(sum)
</code></pre>
<p>If you are importing it from a cvs file, you can directly read the file using <code>pd.read_csv</code></p>
</div>
<div class="post-text" itemprop="text">
<p>You could use better solution as suggested but if you'd like to implement yourself and learn, you can follow and I will explain in comments:</p>
<pre><code># utilities for iteration. groupby makes groups from a collection
from itertools import groupby
# implementation of common, simple operations such as
# multiplication, getting an item from a list
from operator import itemgetter

def my_sum(groups):
    return [
        ls[0] if i == 0 else str(sum(map(int, ls))) # keep first one since it's name, sum otherwise
        for i, ls in enumerate(zip(*groups)) # transpose elements and give number to each
    ]

# list comprehension to make a list from another list
# group lists according to first element and apply our function on grouped elements
# groupby reveals group key and elements but key isn't needed so it's set to underscore
result = [my_sum(g) for _, g in groupby(ls, key=itemgetter(0))]
</code></pre>
<p>To understand this code, you need to know about <code>list comprehension</code>, <code>*</code> operator, (<code>int</code>, <code>enumerate</code>, <code>map</code>, <code>str</code>, <code>zip</code>) built-ins and some handy modules, <code>itertools</code> and <code>operator</code>.</p>
<p>You edited to add header which will break our code so we need to remove it  such that we need to pass <code>ls[1:]</code> to <code>groupby</code> instead of <code>ls</code>. Hope it helps.</p>
</div>
<div class="post-text" itemprop="text">
<p>As a beginner I would consider turning your data into a simpler structure like a dictionary, so that you are just summing a list of list. Assuming you get rid of the header row then you can turn this into a dictionary:</p>
<pre><code>&gt;&gt;&gt; data_dict = {}
&gt;&gt;&gt; for row in data:
...     data_dict.setdefault(row[0], []).append([int(i) for i in row[1:]])
&gt;&gt;&gt; data_dict
{'Mike': [[5, 1, 6, 2], [1, 1, 1, 1], [3, 0, 3, 0]],
 'jose': [[0, 1, 2, 3], [2, 3, 4, 5]],
 'lisa': [[4, 4, 4, 4]]}
</code></pre>
<p>Now it should be relatively easy to loop over the dict and sum up the lists (you may want to look a <code>sum</code> and <code>zip</code> as a way to do that.</p>
</div>
<div class="post-text" itemprop="text">
<p>This is well suited for <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="nofollow"><code>collections.Counter</code></a></p>
<pre><code>from collections import Counter, defaultdict

csvdata = [['name','score1','score2','score3','score4'],
           ['Mike','5','1','6','2'],
           ['Mike','1','1','1','1'],
           ['Mike','3','0','3','0'],
           ['jose','0','1','2','3'],
           ['jose','2','3','4','5'],
           ['lisa','4','4','4','4']] 

student_scores = defaultdict(Counter)
score_titles = csvdata[0][1:]
for row in csvdata[1:]:
    student = row[0]
    scores = dict(zip(score_titles, map(int, row[1:])))
    student_scores[student] += Counter(scores)
print(student_scores["Mike"])
# &gt;&gt;&gt; Counter({'score3':10, 'score1':9, 'score4':3, 'score2':2})
</code></pre>
<p><a href="https://docs.python.org/3.3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict</code></a></p>
</div>
<span class="comment-copy">What is the difference between these two formats? Sorry your question is unclear.</span>
<span class="comment-copy">based on first element you are trying to add remaining element in list, for ex: mike is same for 3 list if you add corresponding element in list you will get ['mikke', 5+1+3,1+1+0,6+1+3,2+1+0= = ['mike', 9,2,10,3]</span>
<span class="comment-copy">Learn <code>python pandas</code> to solve this problem in one line! You also need to show some code before putting question on stack overflow!</span>
