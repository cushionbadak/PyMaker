<div class="post-text" itemprop="text">
<p>I understand that in python, whenever you access a class/instance variable, it will call <code>__getattribute__</code> method to get the result. However I can also use <code>obj.__dict__['x']</code> directly, and get what I want.</p>
<p>I am a little confused about what is the difference? 
Also when I use <code>getattr(obj, name)</code>, is it calling <code>__getattribute__</code> or <code>obj.__dict__[name]</code> internally?</p>
<p>Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>__getattribute__()</code> method is for lower level attribute processing.</p>
<p>Default implementation tries to find the name 
in the internal <code>__dict__</code> (or <code>__slots__</code>). If the attribute is not found, it calls <code>__getattr__()</code>.</p>
<p>UPDATE (as in the comment):</p>
<p>They are different ways for finding attributes in the Python data model. They are internal methods designed to fallback properly in any possible situation. A clue: "The machinery is in <code>object.__getattribute__()</code> which transforms <code>b.x</code> into <code>type(b).__dict__['x'].__get__(b, type(b))</code>." from docs.python.org/3/howto/descriptor.html</p>
</div>
<div class="post-text" itemprop="text">
<p>Not every python object has a dictionary where it's attributes are stored, there are slots, properties and attributes, that are calculated, wenn needed. You can also overwrite <code>__getattribute__</code> and <code>__getattr__</code>. Attribute access is more complicated, than a simple dictionary lookup. So the normal way to access attribute is by</p>
<pre><code>obj.x
</code></pre>
<p>wenn you have a variable with attribute name:</p>
<pre><code>getattr(obj, name)
</code></pre>
<p>Normally you shouldn't use the internal attributes <code>__xxx__</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>Attributes in <code>__dict__</code> are only a subset of all attributes that an object has.</p>
<p>Consider this class:</p>
<pre><code>class C:
    ac = "+AC+" 
    def __init__(self):
        self.ab = "+AB+" 

    def show(self):
        pass
</code></pre>
<p>An instance <code>ic = C()</code> of this class will have attributes <code>'ab'</code>, <code>'ac'</code> and <code>'show'</code> (and few others). The <code>__gettattribute__</code> will find them all, but only the 'ab' is stored in the <code>ic.__dict__</code>. The other two can be found in <code>C.__dict__</code>.</p>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/3278077/difference-between-getattr-vs-getattribute" title="difference between getattr vs getattribute">stackoverflow.com/questions/3278077/…</a> should clear your doubt.</span>
<span class="comment-copy">@AashishP thanks for commenting. But that post explains difference between <code>__getattr__</code> and <code>__getattribute__</code>. It seems that <code>getattr</code> has little to do with <code>__getattr__</code>, so are you implying that <code>getattr</code> actually equals to <code>obj.__dict__[name]</code>?</span>
<span class="comment-copy">Yeah, right. I tried to dig CPython source code and here is what I found, in plain language, <a href="http://stackoverflow.com/questions/24863787/python-the-getattribute-method-and-descriptors" title="python the getattribute method and descriptors">stackoverflow.com/questions/24863787/…</a></span>
<span class="comment-copy">Also, you can check C implementation of <code>getattr</code> <a href="https://github.com/python/cpython/blob/1364858e6ec7abfe04d92b7796ae8431eda87a7a/Python/bltinmodule.c#L985" rel="nofollow noreferrer">here</a></span>
<span class="comment-copy">@AashishP thanks, I will read the source code.</span>
<span class="comment-copy">Does that mean <code>__getattribute__</code> will call try find attribute in <code>__dict__</code>, and do more things? In other word: <code>__getattribute__</code> is a superset of <code>__dict__</code> method.</span>
<span class="comment-copy">They are different ways for finding attributes in the Python data model. They are internal methods designed to fallback properly in any possible situation. A clue: "The machinery is in <code>object.__getattribute__()</code> which transforms <code>b.x</code> into <code>type(b).__dict__['x'].__get__(b, type(b))</code>."  from <a href="https://docs.python.org/3/howto/descriptor.html" rel="nofollow noreferrer">docs.python.org/3/howto/descriptor.html</a></span>
<span class="comment-copy">Thanks for the clarification. I read somewhere that when I use <code>obj.x</code>, it will can <code>__getattribute__</code>, if not found, <code>__getattr__</code> will be called. Where is the internal <code>__dict__</code> variable? If it is used when I access an instance attribute, and not recommended to use it directly, what is the point of it?</span>
