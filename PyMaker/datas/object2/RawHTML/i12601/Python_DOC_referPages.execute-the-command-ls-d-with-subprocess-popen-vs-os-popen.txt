<div class="post-text" itemprop="text">
<p>On Linux OS, the python code below provides the directories inside the current directory.</p>
<pre><code>dirs = os.popen('ls -d */').read().split(os.linesep)
print dirs
</code></pre>
<p>Because <code>os.popen</code> is deprecated, I'm migrating this call to <code>subprocess.Popen</code></p>
<pre><code>proc = subprocess.Popen(['ls', '-d', '*/'], stdout=subprocess.PIPE)
outp = proc.stdout.read()
print outp
</code></pre>
<p>However for some reason this doesn't work, I get the following error</p>
<pre><code>ls: cannot access */: No such file or directory
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p><code>*/</code> only works if globbing is being performed; in <code>os.popen</code>, the whole string is being evaluated by a shell which is wrapping the actual <code>ls</code> process, and the shell is performing the expansion. When you use the <code>list</code> based <code>Popen</code>, it's passing the literal string <code>*/</code> to <code>ls</code>, and <code>ls</code> doesn't expand globs on its own.</p>
<p>You could pass a <code>str</code> and <code>shell=True</code> to <code>Popen</code>, but that's just reopening the performance, security and stability holes that <code>os.popen</code> has. Easier is to avoid subprocesses at all, just use the <a href="https://docs.python.org/3/library/glob.html" rel="nofollow"><code>glob</code> module</a> or one of <code>os.listdir</code>/<a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow"><code>os.scandir</code></a>/<code>os.walk</code> instead of using subprocesses at all.</p>
<p>For example, in Python 3.5 with <a href="https://docs.python.org/3/library/os.html#os.scandir" rel="nofollow"><code>os.scandir</code></a>, you can get all the directories in the working directory extremely efficiently with:</p>
<pre><code>import os

dirs = [x.name for x in os.scandir() if x.is_dir()]
</code></pre>
<p>On earlier versions of Python, <code>os.listdir</code> + <code>os.path.isdir</code> can be used to do the same thing slightly less efficiently (it involves a <code>stat</code> of each entry which <code>os.scandir</code> can avoid, but for small directories and/or local filesystems, the <code>stat</code> cost is trivial):</p>
<pre><code>import os, os.path

dirs = [f for f in os.listdir('.') if os.path.isdir(f)]
</code></pre>
</div>
<span class="comment-copy">Star-expansion is done by the shell, which <code>Popen</code> doesn't use unless you add <code>shell=True</code>.</span>
<span class="comment-copy">Side-note: <code>.split(os.linesep)</code> is better expressed as <code>.splitlines()</code> (which will avoid keeping a trailing empty string when the file ends in a newline). Or in the case of reading from a file-like object, you can do <code>lines = map(str.rstrip, filelikeobj)</code> to strip as you read, instead of slurping, then splitting.</span>
<span class="comment-copy">BTW, editing answers into questions is frowned on here, and explicit advice from meta is to edit them out when they're offered (<a href="http://meta.stackoverflow.com/questions/278050/editing-self-answer-out-of-question" title="editing self answer out of question">meta.stackoverflow.com/questions/278050/â€¦</a>).</span>
<span class="comment-copy">BTW, the reason <code>['ls', '-d', '*/']</code> with <code>shell=True</code> showed you everything is that in that mode, the <code>-d</code> and the <code>*/</code> are passed as arguments <i>to the shell</i>, not to <code>ls</code>; you would need to run <code>['ls "$@"', '-d', '*/']</code> to pass them through... though that would put you back to your original bug, as it would be passing <code>*/</code> as a literal rather than expanding it as a glob.</span>
<span class="comment-copy">@Charles, I appreciate all help and always try to help others, and I really don't care about the grumpy people on SO.</span>
<span class="comment-copy">You might want to include the explicit <code>os.Popen('ls -ld */', shell=True)</code> call in your answer to moot the need the OP felt to edit that into their question.</span>
<span class="comment-copy">@CharlesDuffy: <code>os.Popen</code> isn't a thing (assume you meant <code>subprocess.Popen</code>). And I'm extremely reluctant to provide code examples using <code>shell=True</code>; it's not hard to figure out how to do it from <a href="https://docs.python.org/3/library/subprocess.html" rel="nofollow noreferrer">the docs</a>; people who won't read the docs for something this simple are the same sorts of people who would ignore all the text saying "<code>shell=True</code> is a <i>terrible</i> idea" and just blindly copy-paste the terrible code. Particularly in this case, where using subprocesses at all is a terrible idea; Python built-ins will be faster, easier, more secure.</span>
<span class="comment-copy">I do agree with you on that case; using builtins is also more correct -- <a href="http://mywiki.wooledge.org/ParsingLs" rel="nofollow noreferrer">mywiki.wooledge.org/ParsingLs</a>.</span>
<span class="comment-copy">@CharlesDuffy: I added example code for getting a list of directories from the working directory the right way; you're right that I should provide the good example code to counteract the relentless drive to write bad code. :-)</span>
<span class="comment-copy">@CharlesDuffy: Nope, that's the brilliance of <code>os.scandir</code>; on UNIX-like systems, it's exposing the <code>opendir</code>/<code>readdir</code> API; <a href="http://linux.die.net/man/3/readdir" rel="nofollow noreferrer"><code>readdir</code> gets you <code>d_type</code> for free as part of iteration</a>, it only <code>stat</code>s if the entry is a symlink (and you can prevent that by passing <code>follow_symlinks=False</code> to <code>is_dir()</code>); if it does need to <code>stat</code>, it caches it so additional tests don't <code>stat</code> again. On Windows, using <code>FindFirstFile</code>/<code>FindNextFile</code>, it almost never <code>stat</code>s for any metadata, because that API gives all the info for free with a single read from the file system.</span>
