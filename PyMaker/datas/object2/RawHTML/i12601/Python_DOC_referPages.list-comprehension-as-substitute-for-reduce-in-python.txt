<div class="post-text" itemprop="text">
<p>The following python tutorial says that:</p>
<blockquote>
<p>List comprehension is a complete substitute for the lambda function as well as the functions <code>map()</code>, <code>filter()</code> and <code>reduce()</code>.</p>
<p><a href="http://python-course.eu/python3_list_comprehension.php">http://python-course.eu/python3_list_comprehension.php</a></p>
</blockquote>
<p>However, it does not mention an example how a list comprehension can substitute a <code>reduce()</code> and I can't think of an example how it should be possible.</p>
<p>Can please someone explain how to achieve a reduce-like functionality with list comprehension or confirm that it isn't possible?</p>
</div>
<div class="post-text" itemprop="text">
<p>Ideally, list comprehension is to create a new list. Quoting <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">official documentation</a>,</p>
<blockquote>
<p><strong>List comprehensions provide a concise way to create lists.</strong> Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.</p>
</blockquote>
<p>whereas <code>reduce</code> is used to reduce an iterable to a single value. Quoting <a href="https://docs.python.org/3/library/functools.html#functools.reduce"><code>functools.reduce</code></a>,</p>
<blockquote>
<p>Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to <strong>reduce the sequence to a single value</strong>.</p>
</blockquote>
<p>So, list comprehension cannot be used as a drop-in replacement for <code>reduce</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>I was surprised at first to find that Guido van Rossum, creator of Python, was against <code>reduce</code>. His reasoning was that beyond summing, multiplying, and-ing, and or-ing, using <code>reduce</code> yields an unreadable solution that is better suited by a function which iterates through and updates an accumulator. His article on the matter is <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="nofollow noreferrer">here</a>. So no, there isn't a list comprehension alternative to <code>reduce</code>, instead the "pythonic" way is to implement an accumulating function the old fashioned way: </p>
<p>Instead of: </p>
<p><code>out = reduce((lambda x,y: x*y),[1,2,3])</code></p>
<p>Use:</p>
<pre><code>def prod(myList):
    out = 1
    for el in myList:
        out *= el
    return out
</code></pre>
<p>Of course nothing stops you from continuing to use <code>reduce</code> (python 2) or <code>functools.reduce</code> (python 3)</p>
</div>
<div class="post-text" itemprop="text">
<p>List comprehensions are supposed to return <em>lists</em>. If your reduce is supposed to return a list, then yes, you can replace it with a list comprehension.</p>
<p>But this is no obstacle to providing "reduce-like functionality". Python lists can contain any object. If you'll accept your result contained in a single-item list, then there is a <code>[...][0]</code> list comprehension form that can replace any <code>reduce()</code> whatsoever.</p>
<p>This should be obvious, but that form is</p>
<pre><code>[x for x in [reduce(function, sequence, initial)]][0]
</code></pre>
<p>for some binary <code>function</code> and and some iterable <code>sequence</code> and some <code>initial</code> value. Or, if you want the <code>initial</code> from the first of the iterable,</p>
<pre><code>[x for x in [reduce(function, sequence)]][0]
</code></pre>
<hr/>
<p>Arguably, the above is cheating, and also pointless, since you could just use <code>reduce</code> without the comprehension. So let's try it without <code>reduce</code>.</p>
<pre><code>[stack.append(function(stack.pop(), e)) or stack[0]
 for stack in ([initial],)
 for e in sequence][-1]
</code></pre>
<p>This produces a list of all the intermediate values, and we want the last one. <code>[-1]</code> is just as easy as <code>[0]</code>. We need an accumulator to reduce, but can't use assignment statements in a comprehension, hence the <code>stack</code> (which is just a list), but we could have used many other data structures here. The <code>.append()</code> always returns <code>None</code>, so we use <code>or stack[0]</code> to put the value so far in the resulting list.</p>
<p>It's a little more difficult without <code>initial</code>,</p>
<pre><code>[stack.append(function(stack.pop(), e)) or stack[0]
 for it in [iter(sequence)]
 for stack in [[next(it)]]
 for e in it][-1]
</code></pre>
<p>Really, you might as well use a <code>for</code> statement at this point.</p>
<hr/>
<p>But this takes up memory for the list of intermediate values. For a very long sequence, that might be a problem. But we can avoid that too by using generator expressions.</p>
<p>Doing this is tricky, so let's start with an easier example and work up to it.</p>
<pre><code>stack = [initial]
[stack.append(function(stack.pop(), e)) for e in sequence]
stack.pop()  # returns the answer
</code></pre>
<p>It computes the answer, but also creates a useless list of <code>None</code>s. We can avoid that by converting it to a generator expression inside a list comprehension.</p>
<pre><code>stack = [initial]
[_ for _s in (stack.append(function(stack.pop(), e)) or ()
              for e in sequence)
 for _ in _s]
stack.pop()
</code></pre>
<p>The list comprehension exhausts the generator that updates the stack, but returns an empty list itself. This is possible because the inner loop always has zero iterations, because <code>_s</code> is always an empty tuple.</p>
<p>We can move the <code>stack.pop()</code> inside if the last <code>_s</code> has one element. It doesn't matter what that element is though. So we chain on a <code>[None]</code> as the final <code>_s</code>.</p>
<pre><code>from itertools import chain
stack = [initial]
[stack.pop()
 for _s in chain((stack.append(function(stack.pop(), e)) or ()
                  for e in sequence),
                 [[None]])
 for _ in _s][0]
</code></pre>
<p>Again, we have a single-item list comprehension. We can also implement <code>chain</code> as a generator expression. And you've already seen how to move the <code>stack</code> variable inside using a single-item list.</p>
<pre><code>[stack.pop()
 for stack in [[initial]]
 for _s in (
         x
         for xs in [
                 (stack.append(function(stack.pop(), e)) or ()
                  for e in sequence),
                 [[None]],
         ]
         for x in xs)
 for _ in _s][0]
</code></pre>
<p>And we can also get the initial from the sequence for the two-argument <code>reduce</code>.</p>
<pre><code>[stack.pop()
 for it in [iter(sequence)]
 for stack in [[next(it)]]
 for _s in (
         x
         for xs in [
                 (stack.append(function(stack.pop(), e)) or ()
                  for e in it),
                 [[None]],
         ]
         for x in xs)
 for _ in _s][0]
</code></pre>
<p>This is insane. But it works. So yes, it's <em>possible</em> to get "reduce-like functionality" with comprehensions. That doesn't mean you <em>should</em>. Seven <code>for</code>s is too hard!</p>
</div>
<div class="post-text" itemprop="text">
<p>You could accomplish something like a reduce with a comprehension by using a couple of helper functions that I've named <code>last</code> and <code>cofold</code>:</p>
<pre><code>&gt;&gt;&gt; last(r(a+b) for a, b, r in cofold(range(10)))
45
</code></pre>
<p>This is functionally equivalent to</p>
<pre><code>&gt;&gt;&gt; reduce(lambda a, b: a+b, range(10))
45
</code></pre>
<p>Note that unlike <code>reduce()</code> the comprehension didn't use a <code>lambda</code>.</p>
<p>The trick is to use a generator with a callback to "return" the result of the operator. <code>cofold</code> is the <a href="https://en.wikipedia.org/wiki/Corecursion" rel="nofollow noreferrer">corecursive dual</a> of the reduce (or fold) function.</p>
<pre><code>_sentinel = object()
def cofold(it, initial=_sentinel):
    if initial is _sentinel:
        it = iter(it)
        accumulator = next(it)
    else:
        accumulator = initial
    def callback(result):
        nonlocal accumulator 
        accumulator = result
        return result
    for element in it:
        yield accumulator, element, callback
</code></pre>
<p>Here's <code>cofold</code> in a list comprehension.</p>
<pre><code>&gt;&gt;&gt; [r(a+b) for a, b, r in cofold(range(10))]
[1, 3, 6, 10, 15, 21, 28, 36, 45]
</code></pre>
<p>The elements represent each step in the dual reduction. The last one is our answer. The <code>last</code> function is trivial.</p>
<pre><code>def last(it):
    for e in it:
        pass
    return e
</code></pre>
<p>Unlike <code>reduce</code>, <code>cofold</code> is a lazy generator, so it can safely act on infinite iterables when used in a generator expression.</p>
<pre><code>&gt;&gt;&gt; from itertools import islice, count
&gt;&gt;&gt; lazy_results = (r(a+b) for a, b, r in cofold(count()))
&gt;&gt;&gt; [*islice(lazy_results, 0, 9)]
[1, 3, 6, 10, 15, 21, 28, 36, 45]
&gt;&gt;&gt; next(lazy_results)
55
&gt;&gt;&gt; next(lazy_results)
66
</code></pre>
</div>
<span class="comment-copy">"Removed reduce(). Use functools.reduce() if you really need it; however, 99 percent of the time an explicit for loop is more readable." (<a href="https://docs.python.org/3.0/whatsnew/3.0.html#builtins" rel="nofollow noreferrer">source</a>)</span>
<span class="comment-copy">I would recommend finding a better source for your learning. The quoted page says "Generator Comprehension", which is not the right term and the explanation given is also not that satisfactory.</span>
