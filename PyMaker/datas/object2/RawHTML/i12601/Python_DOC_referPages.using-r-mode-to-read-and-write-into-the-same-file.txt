<div class="post-text" itemprop="text">
<p>I have a script that successfully removes a column from a csv file. Currently it does this by creating a new file. I want it to write to the original file rather than create a new one.
I’ve tried this by using the r+ mode for open but it’s not working how I want. See notes below. I think r+ mode is the one I need but I’m struggling to find working examples to learn from.</p>
<p>my code:</p>
<pre><code>    import csv

    in_file = "Path to Source"
    out_file = "Path to Result"

    with open(in_file, 'r', newline='') as inf, \
        open(out_file, 'w', newline='') as outf:
     reader = csv.reader(inf)
     writer = csv.writer(outf)

     for r in reader:
         writer.writerow((r[0],r[1],r[2],r[3],r[4],r[5],r[6]))
</code></pre>
<p>attempt using <code>r+</code> mode:</p>
<pre><code>with open(in_file, 'r+', newline='') as inf:
    reader = csv.reader(inf)
    writer = csv.writer(inf)

    for r in reader:
        writer.writerow((r[0],r[1],r[2],r[3],r[4],r[5],r[6]))
</code></pre>
<p>This fails with the error <code>list index out of range</code></p>
</div>
<div class="post-text" itemprop="text">
<p>From what I see, as the reader reads, the writer writes. On the same file.</p>
<p>Files have a 'cursor', i.e. a current position upon which they are read from/written to.</p>
<p>So the writer is overwriting the next row in the file after the one the reader has just read, with catastrophic consequences on the following readings.</p>
<p>I think the first approach is the best one: create a new file and then rename it (the original input file is deleted automatically)</p>
<pre><code>import csv, os
in_file = "Path to Source"
out_file = "Path to Result"

with open(in_file, 'r', newline='') as inf, \
     open(out_file, 'w', newline='') as outf:
    reader = csv.reader(inf)
    writer = csv.writer(outf)
    for r in reader:
        writer.writerow(r[:7])

os.rename(out_file, in_file)
</code></pre>
</div>
<span class="comment-copy">from what I see, as the reader reads, the writer writes. Files have a 'cursor', i.e. a current position upon which they are read from/written to. So the writer is overwriting the next row after the one the reader has just read. Why not create a new file and then rename it?</span>
<span class="comment-copy">Thanks Pynchia. I got an error cannot rename when file exist so inserted os.remove(in_file)  just before os.rename(out_file, in_file) and this now works. Thanks for your help.</span>
<span class="comment-copy">@bassmann: Since you're using <code>newline=''</code>, I'm guessing you're using Python 3. If that's the case (and you're on 3.3 or higher), you can use <a href="https://docs.python.org/3/library/os.html#os.replace" rel="nofollow noreferrer"><code>os.replace</code></a>, which has consistent replacing behavior on Linux and Windows (replacing existing files without a prompt). Avoids the race conditions involved with deleting, then renaming.</span>
