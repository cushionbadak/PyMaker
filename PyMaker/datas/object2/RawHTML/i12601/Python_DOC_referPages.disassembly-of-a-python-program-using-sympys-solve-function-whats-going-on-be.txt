<div class="post-text" itemprop="text">
<p>I have this Python code which solves a 3 variable linear equation.</p>
<pre><code>import numpy as np

from sympy import *

init_printing(use_latex='mathjax')

A = Matrix([[-2,3,-1],[2,2,3],[-4,-1,1]])

x,y,z= symbols('x,y,z')
In[12]:

X =Matrix([[x],[y],[z]])

B = Matrix([[1],[1],[1]])

solve(A*X-B)
</code></pre>
<p><a href="https://i.stack.imgur.com/5wLYV.png" rel="nofollow noreferrer"><img alt="snapshot of python program" src="https://i.stack.imgur.com/5wLYV.png"/></a></p>
<p>I am happy as well as baffled with that output. I want to understand what steps sympy follows to solve this, and what solver it's using?     </p>
<p>Part 1 of the question is <strong>How is sympy solving <code>AX-B</code> above?</strong> </p>
<p>Part 2: In general is there a <em>method</em> to see the disassembly for any python program (for the purpose of understanding it)?  </p>
</div>
<div class="post-text" itemprop="text">
<p>There are two basic methods:</p>
<p><strong>Read the source</strong></p>
<p>The best way to understand it is to read the source. In IPython, you can type <code>solve??</code> and it will show you the source code, as well as what file that source is in. You can also look at the <a href="https://github.com/sympy/sympy" rel="nofollow">SymPy GitHub</a>.</p>
<p><code>solve</code> in SymPy is a bit complicated, because it can solve many different types of equations. I believe in this case, you want to look at <a href="https://github.com/sympy/sympy/blob/1403bcb511def74d90178ff0f1d83f4412bc1096/sympy/solvers/solvers.py#L2103" rel="nofollow"><code>solve_linear_system</code></a>, which uses row reduction. That will be replaced with <a href="https://github.com/sympy/sympy/blob/1403bcb511def74d90178ff0f1d83f4412bc1096/sympy/solvers/solveset.py#L1085" rel="nofollow"><code>linsolve</code></a> in a future version, which uses essentially the same algorithm (Gauss-Jordan elimination). </p>
<p><strong>Use a visual debugger</strong></p>
<p>Another way to understand what is going on is to step through the code in a visual debugger. I recommend a debugger that can show you the code of the function that is being run, as well as a list of the variable, along with their values (pdb is not a great debugger in this respect). I personally prefer PuDB, which runs in the terminal, but there are other good ones as well. The advantage of using a debugger is that you can see exactly what code paths are being traversed and what values the variables have at each step. </p>
</div>
<span class="comment-copy">You can <code>import dis</code>, then call <code>dis.dis(solve)</code> but this will give you <a href="https://docs.python.org/3/library/dis.html" rel="nofollow noreferrer">disassembled bytecode</a>, not sure that's exactly what you're asking for. In fact I just did so and <code>dis.dis(sympy.solve)</code> results in a ~2k line disassembly dump. You can also look at <a href="https://docs.python.org/3/library/dis.html#dis.show_code" rel="nofollow noreferrer"><code>dis.show_code(sympy.solve)</code></a></span>
<span class="comment-copy">Disassembling is a solution, when you doesn't have access to the source code, but SymPy is <a href="https://github.com/sympy/sympy" rel="nofollow noreferrer">Open Source</a></span>
<span class="comment-copy">@soon Thats partially true. Disassembly (also) comes handy when (cross)checking compiler optimization level effects. In cases where one can make programs faster by writing in-line assembly, disassembly makes the implementation visible. However, I get your point that I should look at the source of <code>sympy</code>. Thanks.</span>
<span class="comment-copy">@CoryKramer It seems <code>dis.show_code()</code> is available in python &gt;= 3.2 I'm using 2.7 . The disassembly dump created by <code>dis.dis()</code> is too low level. I will try with a higher(newer) version of python. Thanks.</span>
<span class="comment-copy">Don't literally disassemble it with dis. That's way too low level to understand the algorithm of a function.</span>
