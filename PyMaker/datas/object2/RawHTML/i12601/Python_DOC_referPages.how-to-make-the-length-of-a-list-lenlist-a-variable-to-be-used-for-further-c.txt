<div class="post-text" itemprop="text">
<p>Is it possible to make the result from <code>len(factors)</code> be assigned as a variable? What I have so far is <code>h = int(len(factors))</code>, however i'm not sure if this actually does anything. My code below is attempting to take an integer 'r' and represent 'r' in the form (2^k)*t+1. This part of the code below is dealing with finding this product of powers of two and some other odd integer (2^k)*t.
It could be that I am going about this the wrong way, but from my research and trial and error, I have finally got this to work so far. But now more issues arise when extracting certain values.</p>
<pre><code>from math import *

def executeproth():
   r = input("Number to test:")
   n = int(r)-1
   d = 2
   factors = []
   while n % 2 == 0:
      factors.append(d)
      n = int(n/d) 
      h = int(len(factors))
      print(n, factors, h)
#     k = eval(2**h)
   return factors
executeproth()
</code></pre>
<p>For example an input of 29 yields the following:</p>
<pre><code>Number to test:29
14 [2] 1
7 [2, 2] 2
</code></pre>
<p>So in this instance, t=7, k=2, so we would have 29=(2^2)*7+1.
What I want to do is now take the third lines values, namely the '2', and use this for further calculations. But the commented out line # k = eval(2**h) throws the error as follows:</p>
<pre><code>TypeError: eval() arg 1 must be a string, bytes or code object
</code></pre>
<p>So from what I can understand, the thing I am trying to evaluate is not in the correct form. I also wonder if the problem arises due to the nature of the while loop that keeps feeding values back in and creating multiples lists, as shown, and hence multiple values of h <code>len(factors)</code>.
How would one print only the results of the 'final' iteration in the while loop? i.e. <code>7 [2,2] 2</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here this should fulfil your requirement,I don't think you really need to evaluate <code>k</code>.
Also this addresses the second part of your question too, to print the final result of the loop.
And it is as Gregory pointed out that convert explicitly to int only when needed and eval is for strings, your expression was already in integer terms.</p>
<pre><code>def executeproth():
    r = input("Number to test:")
    n = int(r) - 1
    d = 2
    factors = []
    while n % 2 == 0:
        factors.append(d)
        n = n // d
        h = len(factors)
        #print(n, factors, h)
    else:
        print"{} = ( 2 ^ {} ) * {} + 1".format(r,h,n)
    return factors

executeproth()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>First of all, you don't need to explicitly convert a value to an <code>int</code> just to use it in an expression in general. You do need it when processing the input since <code>input()</code> returns a string.</p>
<p>It is more idiomatic to use integer division <code>a // b</code> instead of <code>int(a/b)</code> in python 3.</p>
<p>Finally, <code>eval</code> is for evaluating strings, not expressions. Expressions are always evaluated.</p>
<pre><code>from math import *

def executeproth():
   r = input("Number to test:")
   n = int(r)-1
   d = 2
   factors = []
   while n % 2 == 0:
      factors.append(d)
      n = n // d 
      h = len(factors)
      print(n, factors, h)
      k = 2**h
      # does the same thing but is less efficient
      # k = eval("2**h")
   return factors

executeproth()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As others have said you don't need <code>eval</code> here. In fact, you should generally avoid using <code>eval</code> since it can be <a href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" rel="nofollow">dangerous</a>. And in most situations where you <em>do</em> need to evaluate an expression in string form you can generally get by with the much safer <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow">ast.literal_eval</a>. However, at this stage of your learning it's unlikely that you will encounter many situations where you need to work with such advanced features of the language.</p>
<p>Anyway, here are a few more improvements to your code.</p>
<p>You don't need to import the <code>math</code> module since you aren't using any of the functions or constants defined in it. But when you <em>do</em> need to import a module it's best to avoid the <code>from module_name import *</code> form since that pollutes your namespace with all of the names defined in the module.</p>
<p>You don't need to store those 2s in a list - just count them.</p>
<p>It's better to do your input (and input validation) in the outer layers of your program rather than doing it deep in the functions that perform your calculations.</p>
<p>Python provides various augmented assignment operators that you can use when you want to perform a simple operation on a value and store the result back under the original name. Eg <code>count += 1</code> adds <code>1</code> to <code>count</code>, saving the result in <code>count</code>.</p>
<p>Python allows you to return multiple objects as a tuple, so you can return the final value of <code>n</code> and the count of the number of factors of 2 that you've found.</p>
<pre><code>def executeproth(r):
    n = r - 1
    count = 0   
    if r != 0:
        while n % 2 == 0:
            count += 1
            n //= 2
    return n, count

r = int(input("Number to test: "))
n, count = executeproth(r)
k = 2 ** count
print("{0} = {1} * 2 ** {2} + 1".format(r, n, count))

#v = n*k + 1
#if v != r:
#   print("Error!")
</code></pre>
<p>The <code>if r != 0:</code> prevents infinite looping if <code>r</code> is zero. </p>
<p>I've also added a (commented-out) test at the end. It's a good idea to do simple tests like that to make sure we're getting what we expect. Writing useful tests is an important part of program development.</p>
<p>Typical output:</p>
<pre><code>Number to test: 0
0 = -1 * 2 ** 0 + 1

Number to test: 29
29 = 7 * 2 ** 2 + 1

Number to test: 57
57 = 7 * 2 ** 3 + 1
</code></pre>
</div>
<span class="comment-copy">You didn't <code>eval()</code> anything but <code>2**h</code>. Why did you think you had to <code>eval()</code> that in particular?</span>
<span class="comment-copy">is it correct to assume this means you will always pass an odd number to this function?</span>
<span class="comment-copy">Yes it will always be an odd number</span>
