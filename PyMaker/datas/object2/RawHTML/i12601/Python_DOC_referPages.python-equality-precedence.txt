<div class="post-text" itemprop="text">
<pre><code>class L(object):
    def __eq__(self, other):
        print 'invoked L.__eq__'
        return False

class R(object):
    def __eq__(self, other):
        print 'invoked R.__eq__'
        return False

left = L()
right = R()
</code></pre>
<p>With this code, left side gets the first shot at comparison, as <a href="https://docs.python.org/2/reference/datamodel.html?highlight=__eq__#object.__eq__">documented</a> in the data model:</p>
<pre><code>&gt;&gt;&gt; left == right
invoked L.__eq__
False
</code></pre>
<p>But if we make a slight modification on line 6 (everything else the same):</p>
<pre><code>class R(L):
</code></pre>
<p>Now the <em>right</em> side gets to have the first shot at comparison.  </p>
<pre><code>&gt;&gt;&gt; left == right
invoked R.__eq__
False
</code></pre>
<p>Why is that?  Where is it documented, and what's the reason for the design decision?</p>
</div>
<div class="post-text" itemprop="text">
<p>This is documented under the <a href="https://docs.python.org/2/reference/datamodel.html#emulating-numeric-types">numeric operations</a>, further down the page, with an explanation for why it works that way:</p>
<blockquote>
<p>Note: If the right operand’s type is a subclass of the left operand’s type and that subclass provides the reflected method for the operation, this method will be called before the left operand’s non-reflected method. This behavior allows subclasses to override their ancestors’ operations.</p>
</blockquote>
<p>The <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__">Python 3 documentation</a> additionally mentions it in the section you were looking at:</p>
<blockquote>
<p>If the operands are of different types, and right operand’s type is a direct or indirect subclass of the left operand’s type, the reflected method of the right operand has priority, otherwise the left operand’s method has priority. Virtual subclassing is not considered.</p>
</blockquote>
</div>
