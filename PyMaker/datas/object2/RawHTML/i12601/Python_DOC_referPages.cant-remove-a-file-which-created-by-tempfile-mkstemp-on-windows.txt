<div class="post-text" itemprop="text">
<p>Here's my example code:</p>
<pre><code>import os
from tempfile import mkstemp

fname = mkstemp(suffix='.txt', text=True)[1]
os.remove(fname)
</code></pre>
<p>When I run it on my Linux, it works fine. But when I run it on my Windows XP using Python 3.4.4, it raised the following error:</p>
<pre><code>Traceback (most recent call last):
  File "C:\1.py", line 5, in &lt;module&gt;
    os.remove(fname)
PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'C:\\DOCUME~1\\IEUser\\LOCALS~1\\Temp\\tmp3qv6ppcf.txt'
</code></pre>
<p>However, when I use <code>tempfile.NamedTemporaryFile()</code> to create a temp file and close it, it removed automatically. </p>
<p>Why Windows can't remove files created by <code>mkstemp</code>? Where am I doing wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp" rel="noreferrer">the documentation</a>:</p>
<blockquote>
<p>Creates a temporary file in the most secure manner possible. [...]</p>
<p>[...]</p>
<p><code>mkstemp()</code> returns a tuple containing an OS-level handle to an open file (as would be returned by <code>os.open()</code>) and the absolute pathname of that file, in that order.</p>
</blockquote>
<pre><code>fd, fname = mkstemp(suffix='.txt', text=True)
os.close(fd)
os.remove(fname)
</code></pre>
</div>
<span class="comment-copy">Did you try closing it first?</span>
<span class="comment-copy">@IgnacioVazquez-Abrams: Huh? Where did I open it? Isn't <code>mkstemp()</code> just create the file? There's no <code>open()</code> in my code and <code>fname</code> is a string object.</span>
<span class="comment-copy">Note that mkstemp() returns a <b>tuple</b> with an open file handle. Until you don't close that handle the file is in use (...by another process: your own one). It works on Windows because of how os.remove() works (<i>On Windows, attempting to remove a file that is in use causes an exception to be raised; on Unix, the directory entry is removed but the storage allocated to the file is not made available until the original file is no longer in use</i>).</span>
<span class="comment-copy">With <code>NamedTemporaryFile</code>, Python is using WinAPI <code>FILE_FLAG_DELETE_ON_CLOSE</code>, which requires <code>DELETE</code> access and the file is opened with <code>FILE_SHARE_DELETE</code> sharing. That means you can call <code>os.remove</code> on it without getting a sharing violation, but note that the file isn't actually removed until the last kernel reference or handle is closed. The delete-on-close flag causes the file-system to mark the file to be unlinked, but this doesn't happen until the last reference is closed. An existing handle can call <code>SetFileInformationByHandle</code> to undo the delete disposition.</span>
<span class="comment-copy"><code>mkstemp</code> doesn't use <code>FILE_FLAG_DELETE_ON_CLOSE</code> (via the CRT <code>O_TEMPORARY</code> flag), so it doesn't open the file with <code>DELETE</code> access or <code>FILE_SHARE_DELETE</code> sharing. When you try to call <code>os.remove</code> on it, that calls WinAPI <code>DeleteFile</code>, which tries to open with <code>DELETE</code> access to set the delete disposition, which fails because you have the file open without delete sharing.</span>
