<div class="post-text" itemprop="text">
<p>My program must compare dates and print sum of that day/date.
dates will be always on ascending order.</p>
<p>file:</p>
<pre><code>09/12/2015|9380.0
09/12/2015|7667.0
10/12/2015|3190.0
14/12/2015|3190.0
14/12/2015|5940.0
</code></pre>
<p>result:</p>
<pre><code>09/12/2015 -&gt; 17047.0
10/12/2015 -&gt; 3190.0
14/12/2015 -&gt; 9130.0
</code></pre>
<p>This is my program now</p>
<pre><code>start = "09/12/2015"
end = "14/12/2015"

startstart = datetime.strptime(start, "%d/%m/%Y")
endend   = datetime.strptime(end,"%d/%m/%Y")

with open("fileName.txt", "r") as report:
    allData = csv.reader(report, delimiter = "|")

    for line in allData:
        dataLine = datetime.strptime(line[0], "%d/%m/%Y")
        if dataLine &gt;= startstart and dataLine &lt;= endend :
            print("{0} -&gt; {1}|".format(line[0], line[1]))
</code></pre>
<p>my result now with this program:</p>
<pre><code>09/12/2015 -&gt; 9380.0
09/12/2015 -&gt; 7667.0
10/12/2015 -&gt; 3190.0
14/12/2015 -&gt; 3190.0
14/12/2015 -&gt; 5940.0
</code></pre>
<p>Problem is i print every date and price, i need to make one date and sum of all prices for that date.</p>
</div>
<div class="post-text" itemprop="text">
<p>I'd suggest use <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>collections.defaultdict()</code></a>  to sum the numbers, and use <a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow"><code>sorted()</code></a> to keep order like below:</p>
<pre><code>from datetime import datetime
from collections import defaultdict

start = "09/12/2015"
end = "14/12/2015"

start = datetime.strptime(start, "%d/%m/%Y")
end = datetime.strptime(end, "%d/%m/%Y")

d = defaultdict(float)

with open('file') as f:
    l = [i.split('|') for i in f.read().splitlines()]

for key, value in l:
    d[key] += float(value)

l = sorted(((key, value) for (key, value) in d.items()
            if datetime.strptime(key, "%d/%m/%Y") &gt;= start and
            datetime.strptime(key, "%d/%m/%Y") &lt;= end),
           key=lambda x: datetime.strptime(x[0], "%d/%m/%Y"))

for key, value in l:
    print('{} -&gt; {}'.format(key, value))
</code></pre>
<hr/>
<p>However, since you want keep order, I'd also suggest that use <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict" rel="nofollow"><code>collections.OrderedDict()</code></a>. Here's another example, maybe more simple than the above one:</p>
<pre><code>from datetime import datetime
from collections import OrderedDict
start = "09/12/2015"
end = "14/12/2015"

start = datetime.strptime(start, "%d/%m/%Y")
end = datetime.strptime(end, "%d/%m/%Y")

with open('file') as f:
    l = [i.split('|') for i in f.read().splitlines()]

d = OrderedDict()

for key, value in l:
    date = datetime.strptime(key, "%d/%m/%Y")
    if date &gt;= start and date &lt;= end:
        try:
            d[key] += float(value)
        except KeyError:
            d[key] = float(value)

for key, value in d.items():
    print('{} -&gt; {}'.format(key, value))
</code></pre>
<hr/>
<p>Demo:</p>
<pre><code>09/12/2015 -&gt; 17047.0
10/12/2015 -&gt; 3190.0
14/12/2015 -&gt; 9130.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
from datetime import strptime
from itertools import groupby

# this could also be written as
#   get_day = lambda row: row[0]
# or as
#   from operator import itemgetter    # thanks to @ShadowRanger!
#   get_day = itemgetter(0)
def get_day(row):
    return row[0]

def get_date(s):
    return strptime(s, "%d/%m/%Y")

start = get_date("09/12/2015")
end   = get_date("14/12/2015")

with open("filename.csv", newline='') as inf:
    rows = csv.reader(inf, delimiter='|')
    for day, day_rows in groupby(rows, get_day):
        if start &lt;= get_date(day) &lt;= end:
            day_total = sum(float(v) for d,v in day_rows)
            print("{} -&gt; {}".format(day, day_total))
</code></pre>
<p>which (on the given input) produces</p>
<pre><code>09/12/2015 -&gt; 17047.0
10/12/2015 -&gt; 3190.0
14/12/2015 -&gt; 9130.0
</code></pre>
<p>as desired.</p>
<p><strong>Edit:</strong> a lambda is a way to make a nameless function that returns a single value; <code>fn = lambda x: x[0]</code> is exactly the same as</p>
<pre><code>def fn(x):
    return x[0]
</code></pre>
<p>I have rewritten it as a separate function instead of a lambda ;-) Hope that helps.</p>
<p><strong>Edit2:</strong> in this example <code>groupby</code> takes</p>
<pre><code>[
    ('09/12/2015', '9380.0'),
    ('09/12/2015', '7667.0'),
    ('10/12/2015', '3190.0'),
    ('14/12/2015', '3190.0'),
    ('14/12/2015', '5940.0')
]
</code></pre>
<p>and converts it to</p>
<pre><code>[
    ('09/12/2015', [('09/12/2015', '9380.0'), ('09/12/2015', '7667.0')]),
    ('10/12/2015', [('10/12/2015', '3190.0'),]),
    ('14/12/2015', [('14/12/2015', '3190.0'), ('14/12/2015', '5940.0')])
]
</code></pre>
<p>(ie a sub-list for each day). You can then easily get the per-day subtotals (which is what the <code>day_total = sum(...)</code> line is doing).</p>
<p><strong>Edit3:</strong> I have added in the start-date and end-date checking.</p>
</div>
<div class="post-text" itemprop="text">
<p>You don't need to convert to datetime, just use an OrderedDict to group and sum:</p>
<pre><code>from collections import OrderedDict
import csv
with open("in.csv") as f:
    od = OrderedDict()
    # dte = date string, f = number
    for dte, f in csv.reader(f,delimiter="|"):
        # cast to float
        f = float(f)
        # if we have not seen the key before,
        #  it will get added  with default value of 0
        od.setdefault(dte, 0)
        # access by key/date and add to value
        od[dte] += f

for t in od.items():
    print("{} ---&gt; {}".format(*t))
</code></pre>
<p>Output:</p>
<pre><code>09/12/2015 ---&gt; 17047.0
10/12/2015 ---&gt; 3190.0
14/12/2015 ---&gt; 9130.0
</code></pre>
<p>If you want to look up a particular date you can access using the datestring.</p>
<pre><code>print(od[start])
17047.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just read the data into a list that ends up looking like this:</p>
<pre><code>data = [[date_1, price_1], [date_2, price_2], ..., [date_n, price_n]]
</code></pre>
<p>Then use this bit of code:</p>
<pre><code>from operator import itemgetter

prices = {}
for entry in data:
    try:
        prices[entry[0]] += entry[1]
    except KeyError:
        prices[entry[0]] = entry[1]

sorted_prices = sorted(prices.items(), key=itemgetter(0))
</code></pre>
<p>I haven't tested this, but this is the right idea. Depending on how much data you're working with, you might want to use a solution that keeps the data sorted as it goes. That would require a lot of data to be necessary though. You could use <code>OrderedDict</code> from the <code>collections</code> library in such a case.</p>
</div>
<div class="post-text" itemprop="text">
<p>I found using dict to accumulate the price easier to understand, however you may disagree:</p>
<pre><code>import csv
from datetime import datetime

#read in data
with open('filename.csv', 'r') as report:
    alldata = [row for row in
               csv.reader(report, delimiter = "|")]

#define a dict to store each date (as key) and price (as value)
datePrice = {}

#use dict.get function to accumulate price
for row in alldata:
    dateKey = datetime.strptime(row[0], "%d/%m/%Y")
    datePrice[dateKey] =  datePrice.get(dateKey, 0) + float(row[1])

#make a sorted list of keys and iterate through the list
for date in sorted(datePrice):
    print("{0} -&gt; {1}".format(datetime.strftime(date, "%d/%m/%Y")
                              , datePrice[date]))
</code></pre>
<p>This was the output:</p>
<pre><code>&gt;09/12/2015 -&gt; 17047.0
&gt;10/12/2015 -&gt; 3190.0
&gt;14/12/2015 -&gt; 9130.0
</code></pre>
</div>
<span class="comment-copy">Is your file guaranteed to be date ascending ordered?</span>
<span class="comment-copy">Yes i use date function for input</span>
<span class="comment-copy">Simple...keep track of the current_date (summing as you go) and only print when the date changes.</span>
<span class="comment-copy">yes i have problem with that i don't know how to compare date with date</span>
<span class="comment-copy">This will print dates and prices from whole file ?</span>
<span class="comment-copy">@Blurred: Ah...actually it prints the result which you want if you just choose print them. However I've said how to write them into a file in my answer.</span>
<span class="comment-copy">Still can't figure out how i can print date range i want.</span>
<span class="comment-copy">@Blurred: Oh, so you also need keep the date order right?</span>
<span class="comment-copy">When i print doesn't matter how dates and price will be printed, also dates in file will be always on ascending order.</span>
<span class="comment-copy">uh i don't understand program with lambda code can u explain me a little bit ?</span>
<span class="comment-copy">Lambdas are functions without a name. <code>lambda x: x[0]</code> is a function that returns the first item in a sequence. Note that the <code>return</code> keyword must be omitted.</span>
<span class="comment-copy">i'm still confused with this groupby function, and day_total line</span>
<span class="comment-copy">This is almost certainly the most efficient solution on the CPython reference interpreter. You could do <code>from operator import itemgetter</code> and pass the <code>groupby</code> <code>key</code> function as <code>itemgetter(0)</code> to move even more work to the C layer (avoid <code>lambda</code>s or separately defined functions in favor of self-documenting utility functions).</span>
<span class="comment-copy">how i can implement here date range which user entries, this program will print dates and sum from from whole file ?</span>
<span class="comment-copy">could you comment your code and explain me a little bit, can't figure out 100%</span>
<span class="comment-copy">@Blurred, I added some comments, it is pretty straightforward, we group by date and add each number as we go</span>
<span class="comment-copy">i don't need to sort data , dates will be always on ascending order, also can u rewrite this using lists?</span>
<span class="comment-copy">Dictionaries aren't sorted in the name of efficiency. So you lose the ordering of the data. So I sorted it after adding up the values. The <code>sorted_prices</code> variable ends up being a list.</span>
