<div class="post-text" itemprop="text">
<p>I would love to implement the following:</p>
<pre><code>print(i) for i in xrange(10)
</code></pre>
<p>However, this does not work in neither python2 nor python3. What is the limitation of the language? Or what did I do wrong?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong><a href="https://en.wikipedia.org/wiki/Set-builder_notation" rel="nofollow">Set builder notation</a> (called generator expressions in Python) only work when you are building a set.</strong>  The notation you are using is set builder notation (generator expressions) (something like <code>x for x in range(10) if ...</code>).  That being said, you can use a regular for loop</p>
<pre><code>for i in xrange(10):
    print(i)
</code></pre>
<p>or set builder notation building an empty set:</p>
<pre><code>&gt;&gt;&gt; x = [print(i) for i in xrange(10)]
0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt; x
[None, None, None, None, None, None, None, None, None, None]
&gt;&gt;&gt; 
</code></pre>
<p>The reason the set has all the none values is because you are never adding to the set, but only printing stuff out.</p>
</div>
<div class="post-text" itemprop="text">
<p>Like this:</p>
<pre><code>for i in xrange(10): print(i)
</code></pre>
<p>You could also do something like this, but only in Python 3 where <code>print</code> is a function. This is an abuse of generator expressions, though.</p>
<pre><code>any(print(i) for i in range(10))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The form <code>x for x in &lt;sequence&gt;</code> is meant to result in a list. It was originally this:</p>
<pre><code>&gt;&gt;&gt; [i for i in range(10)] 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>introduced in Python 2.0, <a href="https://www.python.org/dev/peps/pep-0202/" rel="nofollow">Python Enhancement Proposal 202</a>, coming from a variation of uses of map() and filter(). Those functions, and list comprehensions, originate with functional programming environments, which tend to lean towards no-side-effects and no-surprise-state-changes and so on. </p>
<p>In the case where list comprehensions support a function call, it's intended for something like this simple transformation:</p>
<pre><code>&gt;&gt;&gt; [math.sin(x) for x in whatever]
[0.1, 0.2, ...]
</code></pre>
<p>The function is intended to change one list item into a new list item - and the output is still a list.</p>
<p>This syntax lost the surrounding brackets <code>[ ]</code> a couple of years later in <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">PEP289</a> as they became more memory-efficient Generator Comprehensions in Python 2.4. These are intended for when you don't need the full list output <em>as a list</em> because you are processing all the contents as soon as you get them - e.g. <code>sum(i for i in range(10))</code> can add up all the numbers as they appear, without waiting for the full sequence to finish computing first.</p>
<p>The way you want to use it - <code>print(x) for x in &lt;sequence&gt;</code> is in the form of a generator comprehension, but you don't want the generator, the list, the sequence. You only want to do it for a side effect which happens when you call the function.</p>
<p>That's not impossible, you can do this in Python 2</p>
<pre><code>import sys
[sys.stdout.write(str(i) + '\n') for i in range(10)]
</code></pre>
<p>and as @wim notes in a comment, this in Python 3:</p>
<pre><code>[print(i) for i in range(10)]
</code></pre>
<p>However, print() doesn't return anything useful, the newly built list or generator is irrelevant and immediately thrown away.</p>
<p>This structure is confusing/misleading to people reading your code, you are explicitly using the "I want to build a list" format when you don't want to build a list.</p>
<p>It's also against the original ideas of list comprehensions and their origins in functional programming - it's much easier to reason about things when they don't have side effects.</p>
<p>From the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow">Zen of Python</a>:</p>
<ul>
<li>Explicit is better than implicit.</li>
</ul>
<p>If you want to iterate over a sequence and print something, explicitly iterate over a list and print it (<code>for item in sequence: print(item)</code>). Don't start with "I'm going to build a new list, oh I sneakily printed something as a side effect, then threw the list away". </p>
<p>It's hard to read your intent - did you mean to do that? What did you want it to do?</p>
<p>It's harder to explain - what does this code do? "It builds a new list of <code>None</code>s which are the return values from printing the list items". That's putting the focus of what's happening in all the wrong places.</p>
</div>
<div class="post-text" itemprop="text">
<p>Your attempt is syntactically incorrect but you can do actually do it in one line using print as a function and do it without the need for the explicit for loop:</p>
<pre><code>print(*range(10), sep="\n")
</code></pre>
<p>Would be equivalent to:</p>
<pre><code> for i in range(10):
    print(i)
</code></pre>
<p>and output:</p>
<pre><code>In [32]: print(*range(10),sep="\n")
0
1
2
3
4
5
6
7
8
9
In [2]: print(*range(10))
0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>And in python2 you just need to import <code>print_function</code>:</p>
<pre><code>from __future__ import print_function

In [3]: print(*xrange(10),sep="\n")
0
1
2
3
4
5
6
7
8
In [4]: print(*xrange(10))
0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>or using <code>str.join</code>:</p>
<pre><code>print("\n".join(map(str,range(10))))
</code></pre>
</div>
<span class="comment-copy">if this statement can be written as <code>for i in xrange(10): print(i)</code>, why would  there would be a second way of writing it?</span>
<span class="comment-copy">the hack <code>[print(i) for i in range(10)]</code> should work in python3 ...</span>
<span class="comment-copy">you can use <code>for i in xrange(10): print(i)</code> but probably nobody puts any function in one line with <code>for</code> because it makes code less readable.</span>
<span class="comment-copy">It's simply not valid syntax, for either current major Python version, per <a href="https://docs.python.org/2/reference/index.html" rel="nofollow noreferrer">docs.python.org/2/reference/index.html</a> and <a href="https://docs.python.org/3/reference/index.html" rel="nofollow noreferrer">docs.python.org/3/reference/index.html</a>. You can't just have a generator expression on its own as a valid statement.</span>
<span class="comment-copy">That's a <i>generator expression</i>, it can be used in e.g. set, dict and list comprehensions but there's no such thing as <i>"set builder notation"</i> in Python.</span>
<span class="comment-copy">Please see the link at the top.</span>
<span class="comment-copy">Interesting - never heard it called that before @jonrsharpe.  Learn something everyday :)  Post edited</span>
<span class="comment-copy">"Why print cannot be used with for on the same line in python 2/3?"  'Why' is the key word. You never actually answer the question.</span>
<span class="comment-copy">But it can, as I have demonstrated. Twice.</span>
<span class="comment-copy">Ok - you do demonstrate that it is possible.  You don't explain why his isn't working.</span>
<span class="comment-copy">You didn't explain why OP's particular attempt failed, which was the implied main question.</span>
<span class="comment-copy">Because for code to be run by the Python interpreter, it must be written in Python. The question is equivalent to "Why isn't Python something other than Python?"</span>
