<div class="post-text" itemprop="text">
<p>How do I iterate through two lists in Python? I want exactly the result of</p>
<pre><code>list1, list2, list3 = [0, 1], ['a', 'b'], [2, 3] # example data

for item in list1 + list2 + list3:
    print(item)
</code></pre>
<p>But I think adding lists and then iterating through them is not efficient. I used <code>for</code> loop to iterate through the lists:</p>
<pre><code>for list_ in (list1, list2, list3):
    for item in list_:
        print(item)
</code></pre>
<p>But when I checked this with <code>timeit</code> execution time of both was very similar.</p>
<p>Is it possible to make it faster?</p>
</div>
<div class="post-text" itemprop="text">
<p>For small data sets you will not find much difference. But normally if you want to chain and iterate multiple iterables, then you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="noreferrer"><code>itertools.chain</code></a>, like this</p>
<pre><code>&gt;&gt;&gt; list1, list2, list3 = [0, 1], ['a', 'b'], [2, 3]
&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; for item in chain(list1, list2, list3):
...     print(item)
0
1
a
b
2
3
</code></pre>
<p>This doesn't create any intermediate data structures and iterate each of the iterables one by one. The value returned by <code>chain</code> is an iterator. So that also doesn't create a container with all the items in it and it is very memory efficient if the iterables are going to be very big.</p>
<p>And <code>itertools.chain</code> is effectively the same as your second approach. Quoting the equivalent implementation from the official docs</p>
<pre><code>def chain(*iterables):
    # chain('ABC', 'DEF') --&gt; A B C D E F
    for it in iterables:
        for element in it:
            yield element
</code></pre>
<hr/>
<p>If we look at the byte code generated for the first program you have shown, with this</p>
<pre><code>from dis import dis
list1, list2, list3 = [0, 1], ['a', 'b'], [2, 3]


def func():
    for item in list1 + list2 + list3:
        print(item)

dis(func)
</code></pre>
<p>it would be something like</p>
<pre><code>  6           0 SETUP_LOOP              27 (to 30)
              3 LOAD_GLOBAL              0 (list1)
              6 LOAD_GLOBAL              1 (list2)
              9 BINARY_ADD          
             10 LOAD_GLOBAL              2 (list3)
             13 BINARY_ADD          
             14 GET_ITER            
        &gt;&gt;   15 FOR_ITER                11 (to 29)
             18 STORE_FAST               0 (item)

  7          21 LOAD_FAST                0 (item)
             24 PRINT_ITEM          
             25 PRINT_NEWLINE       
             26 JUMP_ABSOLUTE           15
        &gt;&gt;   29 POP_BLOCK           
        &gt;&gt;   30 LOAD_CONST               0 (None)
             33 RETURN_VALUE        
</code></pre>
<p>As you can see, the <code>BINARY_ADD</code> code is used twice. It means that <code>list1</code> and <code>list2</code> are added first and a temporary list is created and that is again added with <code>list3</code>. This will be highly inefficient if any of the lists is very big.</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <code>itertools.chain</code>:</p>
<pre><code>for item in itertools.chain(list1, list2, list2):
    print(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can use the method <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" rel="nofollow"><code>chain</code></a> from <code>itertools</code> module to chain the three lists into single one:</p>
<pre><code>from itertools import chain:

for item in chain(list1, list2, list3):
    print(item)
</code></pre>
<p>OR:</p>
<pre><code>for item in chain.from_iterable([list1,list2,list3]):
    print(item)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're more of a numbers person, here is a test case providing evidence that it is inefficient to add the lists together before iterating through.</p>
<p>Note that <code>hugelists.py</code> contains three lists each containing 10,000 random four-digit numbers.</p>
<pre><code>from hugelists import list_one, list_two, list_three
from itertools import chain
from datetime import datetime

def method_one():
    start_time = datetime.now()
    for item in list_one + list_two + list_three:
        pass
    stop_time = datetime.now()
    return stop_time - start_time

def method_two():
    start_time = datetime.now()
    for item in chain(list_one, list_two, list_three):
        pass
    stop_time = datetime.now()
    return stop_time - start_time

if __name__ == "__main__":
    print method_one()
    print method_two()
</code></pre>
<p>Results:</p>
<pre><code>&gt; python test.py
0:00:00.001720
0:00:00.001014
&gt; python test.py
0:00:00.001865
0:00:00.000997
&gt; python test.py
0:00:00.001603
0:00:00.000833
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can try the builtin <a href="https://docs.python.org/3/library/functions.html#zip" rel="nofollow">zip()</a> function.</p>
<pre><code>&gt;&gt;&gt; for m, n, k in zip([1,2,3,4,5], list('abcde'), [2,11,25,102,53]):
        print(m, n, k)


1 a 2
2 b 11
3 c 25
4 d 102
5 e 53
</code></pre>
<p>Notice you can put other iterables into it.</p>
<pre><code>for m, n, k in zip(range(1,6), 'abcde', [2,11,25,102,53]):
    print(m, n, k)


1 a 2
2 b 11
3 c 25
4 d 102
5 e 53
</code></pre>
</div>
<span class="comment-copy"><a href="http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python" title="making a flat list out of list of lists in python">stackoverflow.com/questions/952914/â€¦</a></span>
