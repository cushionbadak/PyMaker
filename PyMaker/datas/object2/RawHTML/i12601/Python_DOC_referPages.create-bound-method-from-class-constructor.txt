<div class="post-text" itemprop="text">
<p>I have a dictionary like class with methods that return views of its keys, values and items. The methods for doing this are about as simple as you can get:</p>
<pre><code>class MyType(collections.MutableMapping):

    def keys(self):
        return collections.KeysView(self)
</code></pre>
<p>However, this seems pointless to create a method for something so simple; all I am doing is passing <code>self</code> onto yet another callable. I would prefer to simply treat the class constructor for <code>KeysView</code> as a bound method. Doing the following creates a nested class (which is good because sometimes that is exactly what you want), but it looks closer to what I would want to do:</p>
<pre><code>class MyType(collections.MutableMapping):

    keys = collections.KeysView
</code></pre>
<p>Is there anything builtin to Python or its standard library to do this? Maybe something like this:</p>
<pre><code>class MyType(collections.MutableMapping):

    keys = bind_constructor_as_method(collections.KeysView)
</code></pre>
<p>I feel like there should be something in <code>functools</code> that would do the job, but there isn't anything that pops out as the right answer at first look. Maybe <code>functools.partial</code>, but the name isn't very descriptive of what I'm trying to do.</p>
<p>Will I just need to hand roll a custom descriptor class to make something like this work?</p>
<p><strong>NOTE</strong>:</p>
<p>For work I often need to use Python 2.7, so although Python 3.x answers are still appreciated (and useful), they probably won't totally mitigate the issue for me personally. However, they may help someone else with this question, so please still include them!</p>
</div>
<div class="post-text" itemprop="text">
<p><a href="https://docs.python.org/3/library/functools.html#functools.partialmethod" rel="nofollow"><code>functools.partialmethod()</code></a> is what you are looking for. This creates a method where <code>self</code> is the first argument.</p>
<pre><code>import functools

class MyType(collections.MutableMapping):

    keys = functools.partialmethod(collections.KeysView)
</code></pre>
<p>You can also specify other arguments, like if you wanted to pass <code>self, 1, 2, key=5</code> to <code>func()</code>, you would do <code>functools.partialmethod(func, 1, 2, key=5)</code>.</p>
<p>But do note this is only available in Python 3.4 and above.</p>
</div>
<div class="post-text" itemprop="text">
<p>After some thought (and some help from this SO post <a href="https://stackoverflow.com/questions/972/adding-a-method-to-an-existing-object-instance">here</a>), I have come up with another solution that works across Python versions 2 and 3, although it is less idiomatic. It definitely isn't very clear what is happening like it is when using <code>partialmethod</code> as @Artyer suggests. Really, this is what Python is doing under the hood whenever a new instance is created, but made more explicit; you're seeing how the sausage is made. :/</p>
<pre><code>import types
import collections

class MyType(collections.MutableMapping):
    def __init__(self, *args, **kwargs):
        # do class specific stuff here

        # create bound method per instance
        self.keys = types.MethodType(collections.KeysView, self)
</code></pre>
<p>Better yet, we can do it in <code>__new__</code> to be more certain that inherited classes get it:</p>
<pre><code>import types
import collections

class MyType(collections.MutableMapping):
    def __new__(cls, *args, **kwargs):
        self = super(MyType, cls).__new__(cls)

        # create bound method per instance
        self.keys = types.MethodType(collections.KeysView, self)
        return self
</code></pre>
<p>If you don't like the relatively undocumented nature of <code>types.MethodType</code>, you can use <code>functools.partial</code> instead:</p>
<pre><code>import functools
import collections

class MyType(collections.MutableMapping):
    def __new__(cls, *args, **kwargs):
        self = super(MyType).__new__(cls)

        # create bound method per instance
        self.keys = functools.partial(collections.KeysView, self)
        return self
</code></pre>
<p><strong>NOTE:</strong> For Python 2/3 compatibility, you should <em><strong>not</strong></em> use the third optional <code>class</code> argument for <code>types.MethodType</code>; it is exists in Python 2, but is removed in Python 3 apparently.</p>
</div>
<span class="comment-copy">I should probably tag my question a bit better. Most of my code needs to run in Python 2.7 for work environments and <code>partialmethod</code> is only available starting in 3.4. Even on personal stuff, I like to make it as backward compatible as possible, especially if it is open source (many people are still constrained to the 2.x line of Python). However, this answer is still useful. I will look at the standard library to see what they are doing for this and I can see if it is worth backporting or modifying for my own needs.</span>
<span class="comment-copy">@eestrada Well, you can always try to import it, and when you fail, implement your own version of functools.partialmethod (You can find it by running <code>import inspect; import functools; print(inspect.getsource(functools.partialmethod))</code>) in any Python 3.4+ interpreter.</span>
<span class="comment-copy">Yes, importing with <code>try/except</code> is a good idea; I have often done that in the past for other things that differ between versions (like <code>functools.lru_cache</code>, or <code>unicode</code>). The source code for <a href="https://hg.python.org/cpython/file/3.5/Lib/functools.py#l267" rel="nofollow noreferrer"><code>partialmethod</code></a> isn't super long, but it is long enough that it would probably need to be kept in a separate module. I was hoping I could fake something in a handful of lines that I could just include as boilerplate when needed, but it seems that making a full descriptor class is necessary for the right behavior.</span>
