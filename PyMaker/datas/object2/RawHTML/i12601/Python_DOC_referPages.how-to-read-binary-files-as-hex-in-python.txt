<div class="post-text" itemprop="text">
<p>I want to read a file with data, coded in hex format:</p>
<pre><code>01ff0aa121221aff110120...etc
</code></pre>
<p>the files contains &gt;100.000 such bytes, some more than 1.000.000 (they comes form DNA sequencing)</p>
<p>I tried the following code (and other similar):</p>
<pre><code>filele=1234563
f=open('data.geno','r')
c=[]
for i in range(filele):
  a=f.read(1)
  b=a.encode("hex")
  c.append(b)
f.close()
</code></pre>
<p>This gives each byte separate "aa" "01" "f1" etc, that is perfect for me!</p>
<p>This works fine up to (in this case) byte no 905 that happen to be "1a". I also tried the ord() function that also stopped at the same byte.</p>
<p>There might be a simple solution?</p>
</div>
<div class="post-text" itemprop="text">
<p>Simple solution is <a href="https://docs.python.org/2/library/binascii.html" rel="nofollow noreferrer"><code>binascii</code></a>:</p>
<pre><code>import binascii

# Open in binary mode (so you don't read two byte line endings on Windows as one byte)
# and use with statement (always do this to avoid leaked file descriptors, unflushed files)
with open('data.geno', 'rb') as f:
    # Slurp the whole file and efficiently convert it to hex all at once
    hexdata = binascii.hexlify(f.read())
</code></pre>
<p>This just gets you a <code>str</code> of the hex values, but it does it much faster than what you're trying to do. If you really want a bunch of length 2 strings of the hex for each byte, you can convert the result easily:</p>
<pre><code>hexlist = map(''.join, zip(hexdata[::2], hexdata[1::2]))
</code></pre>
<p>which will produce the list of len 2 <code>str</code>s corresponding to the hex encoding of each byte. To avoid temporary copies of <code>hexdata</code>, you can use a similar but slightly less intuitive approach that avoids slicing by using the same iterator twice with <code>zip</code>:</p>
<pre><code>hexlist = map(''.join, zip(*[iter(hexdata)]*2))
</code></pre>
<p><strong>Update:</strong></p>
<p>For people on Python 3.5 and higher, <a href="https://docs.python.org/3/library/stdtypes.html#bytes.hex" rel="nofollow noreferrer"><code>bytes</code> objects spawned a <code>.hex()</code> method</a>, so no module is required to convert from raw binary data to ASCII hex. The block of code at the top can be simplified to just:</p>
<pre><code>with open('data.geno', 'rb') as f:
    hexdata = f.read().hex()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If the file is encoded in hex format, shouldn't each byte be represented by 2 characters?  So </p>
<pre><code>c=[]
with open('data.geno','rb') as f:
    b = f.read(2)
    while b:
        c.append(b.decode('hex'))
        b=f.read(2)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Just an additional note to these, make sure to add a break into your .read of the file or it will just keep going.</p>
<pre><code>def HexView():
    with open(&lt;yourfilehere&gt;, 'rb') as in_file:
        while True:
            hexdata = in_file.read(16).hex()     # I like to read 16 bytes in then new line it.
            if len(hexdata) == 0:                # breaks loop once no more binary data is read
                break
            print(hexdata.upper())               # I also like it all in caps. 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Thanks for all interesting answers!</p>
<p>The simple solution that worked immediately, was to change "r" to "rb",
so:</p>
<pre><code>f=open('data.geno','r')  # don't work
f=open('data.geno','rb')  # works fine
</code></pre>
<p>The code in this case is actually only two binary bites, so one byte contains four data, binary; 00, 01, 10, 11.</p>
<p>Yours!</p>
</div>
<span class="comment-copy">When you say it stopped, did you get an exception, or what?  Also to be clear, this is a binary file that you want to read as a sequence of hex encoded byte values?</span>
<span class="comment-copy">If you're reading a binary file it is good practice to use <code>'rb'</code> as your flags to <code>open</code>.</span>
<span class="comment-copy">I can't come up with any reason this would fail assuming you're rendering the code accurately. Every discrete byte value (and the empty string for that matter) encodes as hex just fine for me (in Py2, the <code>hex</code> codec was removed from <code>str.encode</code> in Py3). Try it by itself for every possible character: <code>for c in map(chr, range(256)): print c.encode('hex')</code>. They all work. My answer optimizes to do most of the work at the C layer (in exchange for slightly higher peak memory usage), but your code as given can't break in any way that makes sense. Please give the exact exception or misbehavior.</span>
<span class="comment-copy">The question's grammar ambiguous, that opening sentence could also mean "I want to read the data and encode it as hex". The rest of the question states they want two character strings, which favors that interpretation. I'll admit it's rather confusing.</span>
<span class="comment-copy">I andertsood the question the same way. +1</span>
