<div class="post-text" itemprop="text">
<p>I use redis-py (pip install redis) to get list : </p>
<pre><code>r_server = redis.Redis("localhost")
r_list = []
len = r_server.llen("test")
for item in range( r_server.llen("test") ):
  r_list.append(r_server.rpop("test"))
print r_list
for r in r_list:
    print r
    print type(r)
</code></pre>
<p>The result :</p>
<pre><code>["{'a': 1, 'b': 2}", "{'a': 2, 'b': 3}"]
{'a': 1, 'b': 2}
&lt;type 'str'&gt;
{'a': 2, 'b': 3}
&lt;type 'str'&gt;  
</code></pre>
<p>The question the type is <code>string</code>
But I want a <code>dict</code> </p>
<p>Because I have to do something like this :</p>
<pre><code>match = [dct for dct in r_list if int(dct["a"]) &gt;=0 ]
</code></pre>
<p>It will cause error: <code>TypeError: string indices must be integers, not str</code></p>
<p>How can I convert it ?? </p>
</div>
<div class="post-text" itemprop="text">
<p>You're looking for <a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" rel="nofollow"><code>ast.literal_eval</code></a>. </p>
<p>Set the response callback for the <em>RPOP</em> command to <code>ast.literal_eval</code></p>
<pre><code>import ast
r_server.set_response_callback('RPOP', ast.literal_eval)
</code></pre>
<p>or call <code>ast.literal_eval</code> on each element of the Redis list you receive in the loop</p>
<pre><code>from ast import literal_eval

r_list = []

for item in range(r_server.llen("test")):
    r_list.append(literal_eval(r_server.rpop("test")))
</code></pre>
<p>Of course, you can also use <code>eval</code>, but <code>ast.literal_eval</code> is much safer.</p>
</div>
<div class="post-text" itemprop="text">
<p>If you don't care about security, just use built-in eval(). </p>
<pre>
v = ["{'a': 1, 'b': 2}", "{'a': 2, 'b': 3}"]
res = [eval(x) for x in v]
print(res)
</pre>
<p>returns</p>
<pre>
[{'a': 1, 'b': 2}, {'a': 2, 'b': 3}]
</pre>
</div>
<div class="post-text" itemprop="text">
<p>I tried following:</p>
<pre><code>&gt;&gt;&gt; v = ["{'a': 1, 'b': 2}", "{'a': 2, 'b': 3}"]
&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval(v[0])
{'a': 1, 'b': 2}

&gt;&gt;&gt; d = ast.literal_eval(v[0])
&gt;&gt;&gt; d['a']
1
&gt;&gt;&gt; 
</code></pre>
<p>To modify to your case, you have to do the import at the beginning and instead of print r do print ast.literal_eval(r).</p>
<p>For your 'match' statement, I'd take a two step approach (and also check if the dictionary has the proper key).</p>
</div>
