<div class="post-text" itemprop="text">
<p>As I understand the global statement in the code below, it should prevent function_two from rebinding the name test and instead modify test in function_one.  However, I get NameError: global name 'test' is not defined.</p>
<pre><code>def function_one():
    test = 1
    def function_two():
        global test
        test += 1
    function_two()
    print test
function_one()
</code></pre>
<p>I have looked and I can't find an example like this.  What am I missing?</p>
</div>
<div class="post-text" itemprop="text">
<p>Python 2 does not support the concept of a <em>non-local</em>. Closures (accessing <code>test</code> from a parent function) only support <em>read access</em>, not assignment in Python 2.</p>
<p>The <code>global</code> keyword really does mean <em>global</em>, e.g. that the name lives in the module (global) namespace. The namespace of the <code>function_one()</code> function is not global, it is local (to that function).</p>
<p>In Python 3, you can mark a name as <a href="https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement" rel="nofollow"><code>nonlocal</code></a>, which would make your example work as expected. See <a href="https://www.python.org/dev/peps/pep-3104/" rel="nofollow">PEP 3104 - <em>Access to Names in Outer Scopes</em></a>.</p>
<p>In Python 2, you'll have to resort to tricks instead. Make the name an attribute of the nested function, for example. 'reading' the function object as a closure is allowed, as is setting attributes on such closed-over objects:</p>
<pre><code>def function_one():
    def function_two():
        function_two.test += 1

    function_two.test = 1
    function_two()

    print test
</code></pre>
<p>Another trick is to use a <em>mutable</em> object, such as a list or a dictionary. Again, you are only <em>reading</em> the closed-over name, then altering the resulting object directly:</p>
<pre><code>def function_one():
    test = [1]

    def function_two():
        test[0] += 1

    function_two()

    print test[0]
</code></pre>
</div>
<span class="comment-copy">You misunderstood. <code>global</code> does not mean the same thing as <code>nonlocal</code> (Python 3 only). <code>global</code> really means <i>global</i>, e.g. <i>not in a function</i>. <code>test</code> in <code>function_two</code> expects there to be a global name <code>test</code>; the local name <code>test</code> in <code>function_one()</code> is ignored.</span>
<span class="comment-copy">Are you using Python 2 or Python 3? Presumably Python 2, since you use <code>print</code> as a statement.</span>
<span class="comment-copy">@name_no: no, that'll not work. You'll get a <code>UnboundLocalError: local variable 'test' referenced before assignment</code> exception.</span>
<span class="comment-copy">Related: <a href="https://www.python.org/dev/peps/pep-3104/" rel="nofollow noreferrer">python.org/dev/peps/pep-3104</a></span>
<span class="comment-copy">Yes, it is code without a purpose.  I just wanted a simple example that demonstrated my confusion with the global statement.  The answers were very enlightening.</span>
