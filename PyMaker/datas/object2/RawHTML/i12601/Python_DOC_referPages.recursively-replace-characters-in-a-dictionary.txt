<div class="post-text" itemprop="text">
<p>How do I change all dots <code>.</code> to underscores (in the dict's keys), <strong>given an arbitrarily nested dictionary</strong>?</p>
<p>What I tried is write two loops, but then I would be limited to 2-level-nested dictionaries.</p>
<p>This ...</p>
<pre><code>{
    "brown.muffins": 5,
    "green.pear": 4,
    "delicious.apples": {
        "green.apples": 2
    {
}
</code></pre>
<p>... should become:</p>
<pre><code>{
    "brown_muffins": 5,
    "green_pear": 4,
    "delicious_apples": {
        "green_apples": 2
    {
}
</code></pre>
<p>Is there an elegant way?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can write a recursive function, like this</p>
<pre><code>from collections.abc import Mapping
def rec_key_replace(obj):
    if isinstance(obj, Mapping):
        return {key.replace('.', '_'): rec_key_replace(val) for key, val in obj.items()}
    return obj
</code></pre>
<p>and when you invoke this with the dictionary you have shown in the question, you will get a new dictionary, with the dots in keys replaced with <code>_</code>s</p>
<pre><code>{'delicious_apples': {'green_apples': 2}, 'green_pear': 4, 'brown_muffins': 5}
</code></pre>
<p><strong>Explanation</strong></p>
<p>Here, we just check if the current object is an instance of <code>dict</code> and if it is, then we iterate the dictionary, replace the key and call the function recursively. If it is actually not a dictionary, then return it as it is.</p>
</div>
<div class="post-text" itemprop="text">
<p>Assuming <code>.</code> is only present in keys and all the dictionary's contents are primitive literals, the really cheap way would be to use <code>str()</code> or <code>repr()</code>, do the replacement, then <code>ast.literal_eval()</code> to get it back:</p>
<pre><code>d ={
    "brown.muffins": 5,
    "green.pear": 4,
    "delicious_apples": {
        "green.apples": 2
    } # correct brace
}
</code></pre>
<p>Result:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval(repr(d).replace('.','_'))
{'delicious_apples': {'green_apples': 2}, 'green_pear': 4, 'brown_muffins': 5}
</code></pre>
<p>If the dictionary has <code>.</code> outside of keys, we can replace more carefully by using a regular expression to look for strings like <code>'ke.y':</code> and replace only those bits:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; ast.literal_eval(re.sub(r"'(.*?)':", lambda x: x.group(0).replace('.','_'), repr(d)))
{'delicious_apples': {'green_apples': 2}, 'green_pear': 4, 'brown_muffins': 5}
</code></pre>
<p>If your dictionary is very complex, with <code>'.'</code> in values and dictionary-like strings and so on, use a real recursive approach. Like I said at the start, though, this is the cheap way.</p>
</div>
<span class="comment-copy">Define method to loop over dictionary keys/values, if key has dot, replace, if value is another dict, enter recursion (call the same method but now with this dict)</span>
<span class="comment-copy">What have you tried? Don't get that 'arbitrarely nested' with 'got two loops'.</span>
<span class="comment-copy">The beauty of recursion, baby</span>
<span class="comment-copy">@PeterWood - That's a possibility with any recursion. If the structure isn't nested very deeply, it'll probably be fine.</span>
<span class="comment-copy">@PeterWood stack overflow, baby :P</span>
<span class="comment-copy">why not <code>dict</code> instead of <code>Mapping</code> ?</span>
<span class="comment-copy">@IronFist When you check if it is an instance of <code>dict</code>, you are restricting it to just <code>dict</code> and its subclasses. Instead, you relax the condition a little and allow any class which has few methods which would make it look like a dictionary. You might want to look at <a href="https://docs.python.org/3/glossary.html#term-mapping" rel="nofollow noreferrer">mapping</a> definition.</span>
<span class="comment-copy">forgive lack of knowledge here..:P .. One more thing, it's just as suggestion, don't you think it's safe to wrap it with <code>tr-except</code> block to be safe from reaching maximum iteration if that matters, and raise an exception when so or any control measure against it...?</span>
<span class="comment-copy">@IronFist This is not production ready code :D I don't expect anyone to use it as it is. They can increase the recursion limit if they like :-)</span>
<span class="comment-copy">That would also replace in the values, though</span>
<span class="comment-copy">@cricket_007 I think he's talking about integral amounts of fruits and confections.</span>
<span class="comment-copy">@erip - still not what OP asked</span>
<span class="comment-copy">Assuming you don't have <code>{'my.key': __my_method}</code> :P</span>
<span class="comment-copy">@erip ideally, it should also be useful for future visitors, not just OPs specific case. Very creative nonetheless</span>
