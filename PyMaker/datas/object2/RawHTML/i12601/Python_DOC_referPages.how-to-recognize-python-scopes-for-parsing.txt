<div class="post-text" itemprop="text">
<p>i have to make a python compiler using javacc and i have a problem with python scopes how can i check that how many lines of a code is in a different scope?</p>
<pre><code>options
{
  static = true;
}

PARSER_BEGIN(MyNewGrammar)
package test;

public class MyNewGrammar
{
  public static void main(String args []) throws ParseException
  {
    MyNewGrammar parser = new MyNewGrammar(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");
      try
      {
        switch (MyNewGrammar.one_line())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Goodbye.");
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        MyNewGrammar.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }
}

PARSER_END(MyNewGrammar)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* OPERATORS */
{
    &lt; PLUS : "+" &gt;
|   &lt; MINUS : "-" &gt;
|   &lt; MULTIPLY : "*" &gt;
|   &lt; DIVIDE : "/" &gt;
|   &lt;IF: "if"&gt;
|   &lt;AND: "and"&gt;
|   &lt;BREAK: "break"&gt;
|   &lt;CLASS: "class"&gt;
|   &lt;CONTINUE: "continue"&gt;
|   &lt;OR: "or"&gt;
|   &lt;PASS: "pass"&gt;
|   &lt;PRINT: "print"&gt;
|   &lt;ELIF: "elif"&gt;
|   &lt;ELSE: "else"&gt;
|   &lt;EXEPT: "exept"&gt;
|   &lt;EXEC: "exec"&gt;
|   &lt;FINALLY: "finally"&gt;
|   &lt;FOR: "for"&gt;
|   &lt;IN: "in"&gt;
|   &lt;DEF: "def"&gt;
|   &lt;DEL: "del"&gt;
|   &lt;IS: "is"&gt;
|   &lt;NOT: "not"&gt;
|   &lt;RAIS: "rais"&gt;
|   &lt;RETURN: "return"&gt;
|   &lt;TRY: "try"&gt;
|   &lt;WHILE: "while"&gt;
|   &lt;WITH: "with"&gt;
|   &lt;YIELD: "yield"&gt;
|   &lt;FROM: "from"&gt;
|   &lt;GLOBAL: "global"&gt;
|   &lt;IMPORT: "import"&gt;
|   &lt;RANGE: "range"&gt;
|   &lt;XRANGE: "xrange"&gt;
}

TOKEN :
{
  &lt; CONSTANT : (&lt; DIGIT &gt;)+ &gt;
| &lt;id: (&lt;LETTER&gt;)(&lt;LETTER&gt;|&lt;DIGIT&gt;)* &gt;
| &lt;LETTER: (&lt;LOWER&gt;|&lt;UPPER&gt;) &gt;
| &lt;literal:"\""((&lt; LETTER &gt;)|(&lt; DIGIT &gt;))+ "\"" &gt;
| &lt; #DIGIT : [ "0"-"9" ] &gt;
| &lt; #LOWER: ["a" - "z"]&gt;
| &lt; #UPPER: ["A" - "Z"]&gt;
}

int one_line() :
{}
{
  sum() |forp()";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void sum() :
{}
{
  term()
  (
    (
      &lt; PLUS &gt;
    | &lt; MINUS &gt;
    )
    term()
  )*
}

void term() :
{}
{
  unary()
  (
    (
      &lt; MULTIPLY &gt;
    | &lt; DIVIDE &gt;
    )
    unary()
  )*
}
void unary() :
{}
{
  &lt; MINUS &gt; element()
| element()
}

void element() :
{}
{
  &lt; CONSTANT &gt;
| "(" sum() ")"
}
void forp():
{}
{
  "for"&lt; id &gt;"in"range()
}
void range():
{}
{
    "range""("(&lt; id &gt;|&lt; CONSTANT &gt;)","(&lt; id &gt;|&lt; CONSTANT &gt;)")"|"xrange""("(&lt; id &gt;|&lt; CONSTANT &gt;)","(&lt; id &gt;|&lt; CONSTANT &gt;)")"
}
</code></pre>
<p>how can i parse for with all the statements that are in its scope</p>
</div>
<div class="post-text" itemprop="text">
<p>The thing that makes parsing python interesting is the indentation. The standard gives rules for inserting INDENT and DEDENT tokens. We could to that in JavaCC, but the following takes another approach, which is to use semantic lookahead.</p>
<pre><code>void for_stmt() : {
    int col = getToken(1).beginColumn ;
} {
    "for" exprlist() "in" testlist() ":" suite(col)
    [ {checkColumn( col ) ;} 'else' ':' suite(col) ]
}

void suite(int col) : {
    int newCol ;
} {
    &lt;NEWLINE&gt;
    { newCol = checkIndent(col) ; }
    stmtsAndDedent(newCol)
|
    simple_stmt(col)
}

// One or more stmt followed by a dedent 
void stmtsAndDedent(int col) : {
    stmt(col)
    (
        LOOKAHEAD( dedenting(col) ) {}
    |
        stmtsAndDedent(col)
    )
 }
}

void stmt(int col) : {
} {
    simple_stmt(col)
|
    {checkColumn(col) ;}
    compound_stmt()
}

void simple_stmt() : {
} {
    {checkColumn(col) ;}
    small_stmt() (";" small_stmt())* [";"] &lt;NEWLINE&gt;
}
</code></pre>
<p>Now it remains to write some java methods</p>
<pre><code>int checkIndent(int col) {
    Token tk = getToken(1) ;
    int newCol = tk.beginColumn ; 
    if( newCol &lt;= col ) {
        throw new ParseException( "Expected token at line " +tk.beginLine+
                                  " column " +tk.beginColumn+
                                  " was expected to be indented by more than "
                                  +col+ " characters.") ; }
    return newCol ; }

boolean dedenting(int col) {
    Token tk = getToken(1) ;
    return tk.beginColumn &lt; col ; }

void checkColumn(int col) {
    Token tk = getToken(1) ;
    int newCol = tk.beginColumn ; 
    if( newCol != col ) {
        throw new ParseException( "Expected token at line " +tk.beginLine+
                                  " column " +tk.beginColumn+
                                  " was expected to be indented by exactly "
                                  +col+ " characters.") ; } }
</code></pre>
<p>This is all untested, but I think it will work once minor errors are fixed.</p>
<p>Once you can parse, counting lines is trivial.</p>
</div>
<span class="comment-copy">By "scope" do you mean "suite", as in the grammar at <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow noreferrer">docs.python.org/3/reference/grammar.html</a> ?</span>
<span class="comment-copy">i mean like java or c when you write "for" you use {} to tell that the code between these {} are in "for" scope, in python we dont have {} for this purpose, instead of that we use space. how can i recognize how many lines are in for example in a "for" scope?</span>
<span class="comment-copy">That's what C folks call a "block statement" and python folks call a "suite".</span>
<span class="comment-copy">I've assumed that EOF tokens begin at column 0. I think that's so.</span>
