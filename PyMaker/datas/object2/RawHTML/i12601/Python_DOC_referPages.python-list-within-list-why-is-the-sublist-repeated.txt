<div class="post-text" itemprop="text">
<p>Problem: Create an list from a given a string of numbers from 1-9 and such that every number in the string is inserted into the mainlist and every following smaller number will be inserted into a sublist until finding a greater number than the preceding which then will be inserted onto the normal(main) list and continue.</p>
<blockquote>
<p>question: ex. string = '654976' expected result = [6,[5,4],9,[7,6]]
  actual = [6,[5,4],[5,4],9,[7,6],[7,6]] &lt;= why is sublist is repeated?</p>
</blockquote>
<pre><code>def create_inner_list(string):
    mainlist = []
    prev = 0
    sublist = []
    if len(string) &lt;= 1
        return mainlist.append(string)
    for each in string:
        if int(each) &lt;= prev:
            prev = int(each)
            sublist.append(int(each))
            print(sublist)
            mainlist.append(sublist)
            print(mainlist)
            continue
        sublist = []
        mainlist.append(int(each))
        prev = int(each)
    return mainlist
</code></pre>
<p>I also did try to use a split method on the string but it didn't help much, or didn't exactly understand how to use it. Hope it is clear. Thanks in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>You're appending sublist for each number in sublist once. You have to move the <code>append(sublist)</code> outside the <code>if</code>:</p>
<pre><code>def create_inner_list(string):
    prev = 0
    mainlist = []
    sublist = []
    for each in string:
        if int(each) &lt;= prev:
            prev = int(each)
            sublist.append(int(each))
        else:
            if sublist:
                mainlist.append(sublist)
            sublist = []
            mainlist.append(int(each))
            prev = int(each)
    if sublist:
        mainlist.append(sublist)
    return mainlist
</code></pre>
<p>or a bit more sophisticated:</p>
<pre><code>def create_inner_list(string):
    prev = 0
    current_list = mainlist = []
    for each in string:
        if int(each) &lt;= prev:
            if current_list is mainlist:
                current_list = []
                mainlist.append(current_list)
        else:
            current_list = mainlist
        prev = int(each)
        current_list.append(prev)
    return mainlist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>It's because of your <code>continue</code> statement. </p>
<p>After each iteration of</p>
<pre><code>for each in string:
</code></pre>
<p>You expect your sublist to be reinitialized with the code</p>
<pre><code>sublist = []
</code></pre>
<p>But with your <code>continue</code> statement, you are skipping that step (and so you are adding the same list a second time on the next iteration). Make sure you reinitialize your sublist at the beginning of each loop:</p>
<pre><code>for each in string:
    sublist = []
    ...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The reason you are seeing each sublist twice is because your are adding the sublist to the mainlist each time you find an element that is lower than the previous one.</p>
<pre><code>def create_inner_list(string):
    mainlist = []
    prev = 0
    sublist = []
    if len(string) &lt;= 1
        return mainlist.append(string)
    for each in string:
        if int(each) &lt;= prev:
            prev = int(each)
            sublist.append(int(each))
            print(sublist)            &lt;----- This code is executed once
            mainlist.append(sublist)  &lt;-----  for each element you are 
            print(mainlist)           &lt;-----  adding to the sublist
            continue
        sublist = []
        mainlist.append(int(each))
        prev = int(each)
    return mainlist
</code></pre>
<p>Also, after the for loop you should check if there is a non-empty sublist that has not been apended to the mainlist.</p>
<p>Try with this instead:</p>
<pre><code>def create_inner_list(string):
    mainlist = []
    prev = 0
    sublist = []
    if len(string) &lt;= 1:
        return mainlist.append(string)
    for each in string:
        if int(each) &lt;= prev:
            prev = int(each)
            sublist.append(int(each))
            continue
        if len(sublist) &gt; 0:
            mainlist.append(sublist)
            sublist = []
        mainlist.append(int(each))
        prev = int(each)
        print(mainlist)
    if len(sublist) &gt; 0:
        mainlist.append(sublist)
        sublist = []
        print(mainlist)
    return mainlist
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Here's another solution using <a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">itertools.groupby</a> and "static" variables</p>
<pre><code>import itertools as it

def group_f(value):
    value = int(value)
    if not hasattr(group_f, 'prev'):
        group_f.prev = 0
        group_f.g = False
    if value &gt; group_f.prev:
        group_f.g = not group_f.g
    group_f.prev = value
    return group_f.g

def create_inner_list(s):
    res = []
    for _, values in it.groupby(s, group_f):
        res.append(next(values))
        res.append(list(values))
    return res

print(create_inner_list('654976'))
</code></pre>
<p>which produces</p>
<pre><code>['6', ['5', '4'], '9', ['7', '6']]
</code></pre>
<p>Basically, <code>group_f</code> returns an alternating sequence of True/False upon every subsequence.</p>
<p><code>groupby</code> uses it to group the original input values into groups, therefore splitting the input sequence into subsequences.</p>
<p><code>create_inner_list</code> uses those to form a new list, appending the first element of each group and the remaining elements as a list.</p>
</div>
<div class="post-text" itemprop="text">
<p>How about this?:</p>
<pre><code>def create_inner_list(string1):

    main_list = []

    for i in range(0, len(string1), 3):

        main_list.append(string1[i])

        if len(string1) - i == 2:
            main_list.append(string1[i+1])

        elif len(string1) - i == 1:
            break

        else:
            main_list.append(list(string1[i+1] + string1[i+2]))

    return main_list

def main():

    string2 = '714683241390'
    print create_inner_list(string2)

main()
</code></pre>
</div>
<span class="comment-copy">Thanks @Daniel, I am accepting your answer although there are many others with correct answers.</span>
<span class="comment-copy">thanks, @marian0 +1</span>
<span class="comment-copy">Thanks @Pynchia, I am going to learn itertools module soon! +1</span>
<span class="comment-copy">Your answer does not follows the logic of the program in the question (sublists should have all elements that are lower than the previous one). Also have a look at <a href="http://meta.stackexchange.com/questions/148272/is-there-any-benefit-to-allowing-code-only-answers-while-blocking-code-only-ques">this</a> about code only answers (this is just to improve your answers quality and has nothing to do with the downvote)</span>
<span class="comment-copy">I see,  my bad... I guess the example confused me for a little bit :)</span>
