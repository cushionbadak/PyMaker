<div class="post-text" itemprop="text">
<p>I have a situation when the classic <a href="https://docs.python.org/3/tutorial/floatingpoint.html#representation-error" rel="nofollow">representation error</a> in Python started to be a problem: I need them to be used for Matrix operations in Numpy and the <strong>decimal</strong> type is not supported yet. </p>
<p>You all know that if I do <code>111.85 * 111.85</code> I will get <code>12510.422499999999</code> but if I <code>round(12510.422499999999, 4)</code> I can get the proper result which is of course <code>12510.4225</code>.</p>
<p>But the actual questions are: </p>
<ul>
<li>Is this round stuff a good idea and a good practice?</li>
<li>Will this work for all cases? sometimes the decimals position where the ..999 decimals could be more</li>
<li>And finally, How to get the appropriate number of decimal positions to use with the round for all possible values?</li>
</ul>
</div>
<div class="post-text" itemprop="text">
<p>Even if you round the number, the decimal still won't be <em>exactly</em> what you expect it to be.  Python may display only the most significant bits, but the underlying decimal inaccuracy is still there. </p>
<p>The python docs <a href="https://docs.python.org/3/tutorial/floatingpoint.html#floating-point-arithmetic-issues-and-limitations" rel="nofollow">devote a section to it</a></p>
<blockquote>
<p>Many users are not aware of the approximation because of the way
  values are displayed. Python only prints a decimal approximation to
  the true decimal value of the binary approximation stored by the
  machine. On most machines, if Python were to print the true decimal
  value of the binary approximation stored for 0.1, it would have to
  display</p>
<pre><code>&gt;&gt;&gt; 0.1
0.1000000000000000055511151231257827021181583404541015625
</code></pre>
<p>That is more digits than most people find useful, so Python keeps the
  number of digits manageable by displaying a rounded value instead</p>
<pre><code>&gt;&gt;&gt; 1 / 10
0.1
</code></pre>
</blockquote>
<p>For most use cases, the inaccuracy can safely be ignored.  If you are
dealing with extremely small or extremely large numbers or need
accuracy out to many decimal places, you can use the <a href="https://docs.python.org/2/library/decimal.html#module-decimal" rel="nofollow">decimal</a>
library</p>
<pre><code> &gt;&gt;&gt; Decimal('111.85') * Decimal('111.85')
 Decimal('12510.4225')
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The real issue here is to identify how the representation error could start to be a problem in the first place.  </p>
<p>You should not be using the representation for human-readable printing of floats, you should be using for example <code>str.format</code> or some other presentation method.  </p>
<p>Keep your numbers as numbers for all calculations (whether you do that with floats or Decimals or whatever...) and only round or truncate things at presentation.  </p>
</div>
<span class="comment-copy">If you want more accuracy than floats can provide, consider using the <code>decimal</code> or <code>fraction</code> modules.</span>
<span class="comment-copy">No, you <i>don't</i> get the "proper" result from the <code>round</code> operation! It might <i>look</i> like <code>12510.4225</code> when printed, but the value that Python's storing is actually <code>12510.422500000000582076609134674072265625</code>. Now you need to ask yourself whether that's really any better for your purposes than the original result of <code>12510.422499999998763087205588817596435546875</code>. (And the answer is 'probably not'.)</span>
<span class="comment-copy">@Kevin I need those values to be supported by <i>Numpy</i> for some matrix operations, and I think decimal/fraction are still not supported</span>
<span class="comment-copy">(And for more ranting along the lines above, see <a href="http://stackoverflow.com/a/22155830/270986.">stackoverflow.com/a/22155830/270986.</a>)</span>
<span class="comment-copy">A possible solution is to move the <code>.</code> to the right until you have an integer (in your example, you will move 2 positions to get <code>11185</code>) and then you can multiply integers, and will manually add a <code>.</code> in the correct place (which will be 2+2=4 positions to the left)</span>
<span class="comment-copy">Is not actually a displaying human-readable values, I use those values for calculations but for this case I would like more accuracy, and i would like to use Decimals but Numpy doesn't support this type as long as i know.</span>
<span class="comment-copy">@GermanRosales: Your original pre-rounded answer is already accurate to less than 0.7 ulps. If that level of accuracy isn't good enough (why not?) then float64 isn't going to meet your needs. But you should figure out whether you really do need that level of accuracy.</span>
<span class="comment-copy">@MarkDickinson I am afraid float64 doesn't fit my needs, but I can't do matrix inverse operation with float128 (I am getting an error with numpy's inverse operation)</span>
<span class="comment-copy">@GermanRosales: Hmm, then it sounds like you've got a hard problem to solve. At any rate, <code>round</code> isn't going to help you: I think there are already a couple of good answers to your posted question here. Maybe you should ask a new question about high-precision matrix inversion? (Or maybe there are numerical reformulations of your problem that would avoid the need for the high precision in the first place.)</span>
<span class="comment-copy">In my experience, almost all of the time when guys think they need higher precision arithmetic they actually don't.  They just need smarter maths</span>
