<div class="post-text" itemprop="text">
<p>I'm working on a function that takes in a filename of a CSV and converts each line to a dictionary and then returns a list of the dictionaries created (to be able to iterate through and organize in later functions.  I've gotten it to do what I want by doing the following but feel there's got to be a better way.  Any suggestions for improvement?</p>
<pre><code>import re

def import_incidents(filename):
    """Imports CSV and returns list of dictionaries for each incident"""
    with open(filename, 'r') as file:
        data = file.read()
        data = data.split('\n')
        list_of_data = []
        headers = True
        for line in data:
            line = line.split('","')
            if headers == True:
                #Skip header and set to false
                headers = False
            elif len(line) == 1 or line[3] == '':
                #File always has a 1 lenth final line, skip it.
                #Events can leave blank policies, skip those too.
                pass
            else:
                temp_dict = {}
                temp_dict['id'] = re.sub('"', '', line[0])
                temp_dict['time'] = re.sub('GMT-0600','',line[1])
                temp_dict['source'] = line[2]
                temp_dict['policy'] = line[3]
                temp_dict['destination'] = line[5]
                temp_dict['status'] = line[10]
                list_of_data.append(temp_dict)

return list_of_data

print(import_incidents('Incidents (Yesterday Only).csv'))
</code></pre>
<p>Sample of CSV contents:</p>
<pre><code>"ID","Incident Time","Source","Policies","Channel","Destination","Severity","Action","Maximum Matches","Transaction Size","Status",
"9511564","29 Dec. 2015, 08:33:59 AM GMT-0600","Doe, John","Encrypted files","HTTPS","blah.blah.com","Medium","Permitted","0","47.7 KB","Closed - Authorized",
"1848446","29 Dec. 2015, 08:23:36 AM GMT-0600","Smith, Joe","","HTTP","google.com","Low","Permitted","0","775 B","Closed"
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You have reinvented the <a href="https://docs.python.org/3/library/csv.html#csv.DictReader" rel="nofollow"><code>csv.DictReader()</code> class</a>, I'm afraid:</p>
<pre><code>import csv

def import_incidents(filename):
    with open(filename, 'r', newline='') as file:
        reader = csv.DictReader(file)
        for row in reader:
            if not row or not row['Policies']:
                continue
            row['Incident Time'] = re.sub('GMT-0600', '', row['Incident Time'])
            yield row
</code></pre>
<p>This relies on the header row for the dictionary keys. You can define your own dictionary keys with the <code>fieldnames</code> argument to <code>DictReader()</code> (the <code>fieldnames</code> field is matched, in order, to the columns in the file), but then the first row in the file is still read like any other row. You can use the <code>next()</code> function to skip rows (see <a href="https://stackoverflow.com/questions/14257373/skip-the-headers-when-editing-a-csv-file-using-python/14257599#14257599">Skip the headers when editing a csv file using Python</a>).</p>
</div>
<div class="post-text" itemprop="text">
<h2>Original task: List of dicts</h2>
<p>You can use <a href="http://pandas.pydata.org/" rel="nofollow noreferrer">pandas</a>. It is fast and can do it in a few lines; </p>
<pre><code>import pandas as pd
df = pd.read_csv('incidents.csv')
df['Incident Time'] = df['Incident Time'].str.replace('GMT-0600', '')
list_of_data = df.dropna(subset=['Policies']).to_dict(orient='records')
</code></pre>
<p>Now <code>list_of_data</code> contains:</p>
<pre><code>[{'Action': 'Permitted',
  'Channel': 'HTTPS',
  'Destination': 'blah.blah.com',
  'ID': 9511564,
  'Incident Time': '29 Dec. 2015, 08:33:59 AM ',
  'Maximum Matches': 0,
  'Policies': 'Encrypted files',
  'Severity': 'Medium',
  'Source': 'Doe, John',
  'Status': 'Closed - Authorized',
  'Transaction Size': '47.7 KB',
  'Unnamed: 11': nan}]
</code></pre>
<p>The <code>.dropna(subset='Policies')</code> removes the lines that have <code>NaN</code>s in the column <code>Policies</code>, i.e. missing values.  </p>
<h2>Pandas-only solution:</h2>
<p>If you don't want the list of dicts, keep the dataframe:</p>
<pre><code>df = pd.read_csv('incidents.csv', parse_dates=[1]).dropna(subset=['Policies'])
</code></pre>
<p>This reads the <code>Incident Time</code> as very convenient <code>datetime64[ns]</code>object. The dataframe looks like this:</p>
<p><a href="https://i.stack.imgur.com/GEr6J.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/GEr6J.png"/></a></p>
</div>
<span class="comment-copy">Have a look at csv.DictReader: <a href="https://docs.python.org/2/library/csv.html#csv.DictReader" rel="nofollow noreferrer">docs.python.org/2/library/csv.html#csv.DictReader</a></span>
<span class="comment-copy">Ha!  Great.  Good to know it's been done before now.</span>
<span class="comment-copy">@PadraicCunningham: I documented my assumption about the header. The 'empty line' can be skipped with <code>if not row or not row['policy']: continue</code>.</span>
<span class="comment-copy">Getting:    &lt;generator object import_incidents at 0x0000005CA2C94830&gt;</span>
<span class="comment-copy">@PadraicCunningham: <code>csv.DictReader()</code> handles quotes properly.</span>
<span class="comment-copy">@user987654321: yes, I produced a generator function, not a list. Use iteration (like a <code>for</code> loop), or call <code>list()</code> on that generator object to produce a list again.</span>
<span class="comment-copy">Would there be any additional advantages to working with pandas?</span>
<span class="comment-copy">Yes. You don`t need to convert the dataframe into a list of dicts in the first place. It si way more powerful than a plain dictionary or list. It is also really fast when used in the right way. Lots of it is written in Cython for speed.</span>
<span class="comment-copy">What's the .dropna(subset='Policies') for?</span>
<span class="comment-copy">Also... have a strange character that is picked up in reading the .csv.. instead of the "ID" i get a \ufeff"ID" from the file need to input.  Some sort of special character inserted (my guess).  Any way to have this be stripped off?</span>
<span class="comment-copy">Your file has a byteorder mark (BOM). Try to open the file with the encoding <code>utf-8-sig</code>: <code>pd.read_csv('incidents.csv', encoding='utf-8-sig')</code>.</span>
