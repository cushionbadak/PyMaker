<div class="post-text" itemprop="text">
<p>I'm trying to create a circle class using the magic methods <code>__getattr__</code> and <code>__setattr__</code>, and I seem to have my <code>__getattr__</code> working, but when I implement <code>__setattr__</code> (which should only allow the values for <code>x</code> and <code>y</code> to be set if the value is an int, and raise an <code>AttributeError</code> when the user tries to set the attributes <code>area</code>, <code>circumference</code>, and <code>distance</code> to <code>circle</code>), my <code>__getattr__</code> throws the maximum recursion error. When I comment it out, the <code>__getattr__</code> then works just fine. </p>
<pre><code>from math import pi, hypot, sqrt
'''
Circle class using __getattr__, and __setattr__ (rename circle2)
'''


# __getattr__(self, name): Automatically called when the attribute name
#       is accessed and the object has no such attribute.
# __setattr__(self, name, value): Automatically called when an attempt is made to bind the attribute name to value.

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
        self.area = pi * self.r * self.r
        self.circumference = 2 * pi * self.r
        self.distance_to_origin = abs(sqrt((self.x - 0)*(self.x - 0) + (self.y - 0) * (self.y - 0)) - self.r)

    def __getattr__(self, name):
        if name in ["x", "y", "r", "area", "circumference", "distance_to_origin"]:
            print('__get if statement') # check getattr working
            return getattr(self, name)
        else:
            print('Not an attribute')
            return None
    '''
    def __setattr__(self, name, value):
        print(name, value)
        if name in ['x', 'y']:
            if isinstance(value, int):
                print('we can set x,y')
                self.__dict__[name] = value
            else:  # value isn't an int
                raise TypeError('Expected an int')
        elif name in ['area', 'circumference', 'distance_to_origin']:
            raise RuntimeError('Cannot set attribute')
    '''

if __name__ == '__main__':

    circle = Circle(x=3, y=4, r=5)
    # print(circle.x)
    print(circle.__getattr__('x'))
    # print(circle.y)
    print(circle.__getattr__('y'))
    # print(circle.r)
    print(circle.__getattr__('r'))
    # print(circle.area)
    print(circle.__getattr__('area'))
    # print(circle.circumference)
    print(circle.__getattr__('circumference'))
    # print(circle.distance_to_origin)
    print(circle.__getattr__('distance_to_origin'))
    # print(circle.test)
    '''
    tests = [('circle.x = 12.3', "print('Setting circle.x to non-integer fails')"),
             ('circle.y = 23.4', "print('Setting circle.y to non-integer fails')"),
             ('circle.area = 23.4', "print('Setting circle.area fails')"),
             ('circle.circumference = 23.4', "print('Setting circle.circumference fails')"),
             ('circle.distance_to_origin = 23.4', "print('Setting circle.distance_to_origin fails')"),
             ('circle.z = 5.6', "print('Setting circle.z fails')"),
             ('print(circle.z)', "print('Printing circle.z fails')")]
    for test in tests:
        try:
            exec(test[0])
        except:
            exec(test[1])
    '''
</code></pre>
<p>With <code>__setattr__</code> commented out, the testing code:</p>
<pre><code>if __name__ == '__main__':

    circle = Circle(x=3, y=4, r=5)
    # print(circle.x)
    print(circle.__getattr__('x'))
    # print(circle.y)
    print(circle.__getattr__('y'))
    # print(circle.r)
    print(circle.__getattr__('r'))
    # print(circle.area)
    print(circle.__getattr__('area'))
    # print(circle.circumference)
    print(circle.__getattr__('circumference'))
    # print(circle.distance_to_origin)
    print(circle.__getattr__('distance_to_origin'))
</code></pre>
<p>prints out:</p>
<pre><code>__get if statement
3
__get if statement
4
__get if statement
5
__get if statement
78.53981633974483
__get if statement
31.41592653589793
__get if statement
0.0
</code></pre>
</div>
<div class="post-text" itemprop="text">
<h2>Improved solution</h2>
<p>Based on the discussion here, this is a shorter and improved version. Achieves the same as the original solution:</p>
<pre><code>from math import pi, hypot, sqrt


class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        super().__setattr__('r', r)
        super().__setattr__('area', pi * self.r * self.r)
        super().__setattr__('circumference', 2 * pi * self.r)
        super().__setattr__('distance_to_origin',
                            abs(sqrt(self.x * self.x + self.y * self.y) - self.r))

    def __setattr__(self, name, value):
        if name in ['x', 'y']:
            if isinstance(value, int):
                print('we can set x,y')
                super().__setattr__(name, value)
            else:  # value isn't an int
                raise TypeError('Expected an int for: {}'.format(name))
        else:
            raise AttributeError('Cannot set attribute: {}'.format(name))
</code></pre>
<h2>Solution</h2>
<p>Avoiding <code>__getattr__()</code> all together and using a flag <code>self._intialized</code> to signal if the <code>__init__()</code> was already run would work:</p>
<pre><code>from math import pi, hypot, sqrt
'''
Circle class using __getattr__, and __setattr__ (rename circle2)
'''


# __getattr__(self, name): Automatically called when the attribute name
#       is accessed and the object has no such attribute.
# __setattr__(self, name, value): Automatically called when an attempt is made to bind the attribute name to value.

class Circle:
    def __init__(self, x, y, r):
        self._intialized = False
        self.x = x
        self.y = y
        self.r = r
        self.area = pi * self.r * self.r
        self.circumference = 2 * pi * self.r
        self.distance_to_origin = abs(sqrt(self.x * self.x + self.y * self.y) - self.r)
        self._intialized = True


    def __setattr__(self, name, value):
        if name in ['_intialized']:
            self.__dict__[name] = value
            return
        if name in ['x', 'y']:
            if isinstance(value, int):
                print('we can set x,y')
                self.__dict__[name] = value
            else:  # value isn't an int
                raise TypeError('Expected an int for: {}'.format(name))
        elif not self._intialized:
            self.__dict__[name] = value

        elif name in ['area', 'circumference', 'distance_to_origin']:
            raise AttributeError('Cannot set attribute: {}'.format(name))

if __name__ == '__main__':

    circle = Circle(x=3, y=4, r=5)
    print('x:', circle.x)
    print('y:', circle.y)
    print('r:', circle.r)
    print('area:', circle.area)
    print('circumference:', circle.circumference)
    print('distance_to_origin:', circle.distance_to_origin)
    tests = [('circle.x = 12.3', "print('Setting circle.x to non-integer fails')"),
             ('circle.y = 23.4', "print('Setting circle.y to non-integer fails')"),
             ('circle.area = 23.4', "print('Setting circle.area fails')"),
             ('circle.circumference = 23.4', "print('Setting circle.circumference fails')"),
             ('circle.distance_to_origin = 23.4', "print('Setting circle.distance_to_origin fails')"),
             ('circle.z = 5.6', "print('Setting circle.z fails')"),
             ('print(circle.z)', "print('Printing circle.z fails')")]
    for test in tests:
        try:
            exec(test[0])
        except:
            exec(test[1])
</code></pre>
<p>The output looks good:</p>
<pre><code>python get_set_attr.py 
we can set x,y
we can set x,y
x: 3
y: 4
r: 5
area: 78.53981633974483
circumference: 31.41592653589793
distance_to_origin: 0.0
Setting circle.x to non-integer fails
Setting circle.y to non-integer fails
Setting circle.area fails
Setting circle.circumference fails
Setting circle.distance_to_origin fails
Printing circle.z fails
</code></pre>
<h2>Variation</h2>
<p>This would allow setting an attribute with any other name:</p>
<pre><code>circle.xyz = 100
</code></pre>
<p>But it would not be there:</p>
<pre><code>circle.xyz


Traceback (most recent call last):
  File "get_set_attr.py", line 62, in &lt;module&gt;
    circle.xyz
 AttributeError: 'Circle' object has no attribute 'xyz'
</code></pre>
<p>This implementation of <code>__setattr__</code> would avoid this:</p>
<pre><code>def __setattr__(self, name, value):
    if name in ['_intialized']:
        self.__dict__[name] = value
        return
    if name in ['x', 'y']:
        if isinstance(value, int):
            print('we can set x,y')
            self.__dict__[name] = value
            return
        else:  # value isn't an int
            raise TypeError('Expected an int for: {}'.format(name))
    elif not self._intialized:
        self.__dict__[name] = value
    else:
        raise AttributeError('Cannot set attribute: {}'.format(name))
</code></pre>
<h2>When to use <code>__getattr__()</code>?</h2>
<p>When you access an attribute that does not exist, Python raises an <code>AttributeError</code>:</p>
<pre><code>class A:
    pass
a = A()
a.xyz

....
AttributeError: 'A' object has no attribute 'xyz'
</code></pre>
<p>Python calls <code>__getattr__()</code>  only if an attribute does <strong>not</strong> exist.
One use case is a wrapper around another object instead of using inheritance.
For example, we can define a <code>ListWrapper</code> that uses an list but allows only white-listed attributes:</p>
<pre><code>class ListWrapper:
    _allowed_attrs = set(['append', 'extend'])
    def __init__(self, value=None):
        self._wrapped = list(value) if value is not None else []
    def __getattr__(self, name):
        if name in self._allowed_attrs:
            return getattr(self._wrapped, name)
        else:
            raise AttributeError('No attribute {}.'.format(name))
    def __repr__(self):
        return repr(self._wrapped)
</code></pre>
<p>We can use it just like list:</p>
<pre><code>&gt;&gt;&gt; my_list = ListWrapper('abc')
&gt;&gt;&gt; my_list
['a', 'b', 'c']
</code></pre>
<p>Append elements:</p>
<pre><code>&gt;&gt;&gt; my_list.append('x')
&gt;&gt;&gt; my_list
['a', 'b', 'c', 'x']
</code></pre>
<p>But we cannot use any other attribute except the ones defined in <code>_allowed_attrs</code>:</p>
<pre><code>my_list.index('a')
...

AttributeError: No attribute index.
</code></pre>
<p>What the <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__getattr__#object.__getattr__" rel="nofollow">docs</a> says:</p>
<blockquote>
<pre><code>object.__getattr__(self, name)
</code></pre>
<p>Called when an attribute lookup has not found the attribute in the usual places (i.e. it is not an instance attribute nor is it found in the class tree for self). name is the attribute name. This method should return the (computed) attribute value or raise an <code>AttributeError</code> exception.</p>
<p>Note that if the attribute is found through the normal mechanism, <code>__getattr__()</code> is not called. (This is an intentional asymmetry between <code>__getattr__()</code> and <code>__setattr__()</code>.) This is done both for efficiency reasons and because otherwise <code>__getattr__()</code> would have no way to access other attributes of the instance. Note that at least for instance variables, you can fake total control by not inserting any values in the instance attribute dictionary (but instead inserting them in another object). See the <code>__getattribute__()</code> method below for a way to actually get total control over attribute access.</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>You may be interested in the couple of problems you had in your code that were causing the problem.</p>
<p>You cannot set the following directly in <code>__init__()</code> because the assignments trigger a call to <code>__setattr__()</code>, which sets only <code>x</code> and <code>y</code>. Because of this, these attributes were never set.</p>
<pre><code>self.r = r
self.area = pi * self.r * self.r
self.circumference = 2 * pi * self.r
self.distance_to_origin = abs(sqrt((self.x - 0)*(self.x - 0) + (self.y - 0) * (self.y - 0)) - self.r)
</code></pre>
<p>You are not checking for <code>r</code> in <code>__setattr__()</code>. This caused <code>r</code> to be ignored silently, and then when <code>r</code> was accessed to set <code>area</code> in <code>__init__()</code>, <code>__getattr__()</code> called <code>getattr()</code> called <code>__getattr__()</code> called <code>getattr()</code> and so on (because <code>r</code> was not set), which caused the recursion.</p>
<pre><code>elif name in ['area', 'circumference', 'distance_to_origin']:
    raise RuntimeError('Cannot set attribute')
</code></pre>
<p>Here is fixed code. Changes have been marked below with <code>mod</code> in comments.</p>
<pre><code>#!/usr/bin/python3

from math import pi, hypot, sqrt
'''
Circle class using __getattr__, and __setattr__ (rename circle2)
'''


# __getattr__(self, name): Automatically called when the attribute name
#       is accessed and the object has no such attribute.
# __setattr__(self, name, value): Automatically called when an attempt is made to bind the attribute name to value.

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        # mod : can't set via self.__getattr__
        super().__setattr__("r", r)
        super().__setattr__("area", pi * self.r * self.r)
        super().__setattr__("circumference", 2 * pi * self.r)
        super().__setattr__("distance_to_origin", abs(sqrt((self.x - 0)*(self.x - 0) + (self.y - 0) * (self.y - 0)) - self.r))

    def __getattr__(self, name):
        print("===== get:", name)
        if name in ["x", "y", "r", "area", "circumference", "distance_to_origin"]:
            print('__get if statement') # check getattr working
            return getattr(self, name)
        else:
            print('Not an attribute')
            return None

    def __setattr__(self, name, value):
        print("===== set:", name, value)
        if name in ['x', 'y']:
            if isinstance(value, int):
                print('we can set x,y')
                super().__setattr__(name, value) # mod : better
            else:  # value isn't an int
                raise TypeError('Expected an int')
        elif name in ['r', 'area', 'circumference', 'distance_to_origin']: # mod : add 'r'
            raise RuntimeError('Cannot set attribute')

if __name__ == '__main__':

    circle = Circle(x=3, y=4, r=5)
    # print(circle.x)
    print(circle.__getattr__('x'))
    # print(circle.y)
    print(circle.__getattr__('y'))
    # print(circle.r)
    print(circle.__getattr__('r'))
    # print(circle.area)
    print(circle.__getattr__('area'))
    # print(circle.circumference)
    print(circle.__getattr__('circumference'))
    # print(circle.distance_to_origin)
    print(circle.__getattr__('distance_to_origin'))
    # print(circle.test)
    '''
    tests = [('circle.x = 12.3', "print('Setting circle.x to non-integer fails')"),
             ('circle.y = 23.4', "print('Setting circle.y to non-integer fails')"),
             ('circle.area = 23.4', "print('Setting circle.area fails')"),
             ('circle.circumference = 23.4', "print('Setting circle.circumference fails')"),
             ('circle.distance_to_origin = 23.4', "print('Setting circle.distance_to_origin fails')"),
             ('circle.z = 5.6', "print('Setting circle.z fails')"),
             ('print(circle.z)', "print('Printing circle.z fails')")]
    for test in tests:
        try:
            exec(test[0])
        except:
            exec(test[1])
    '''
</code></pre>
</div>
<span class="comment-copy"><code>if name == ...</code> should almost certainly be <code>if name in ...</code>, and <code>if value is int:</code> should almost certainly be <code>if isinstance(value, int):</code>. Not a cause of a recursion error, but this is terrible code all around.</span>
<span class="comment-copy">Also, using <code>getattr</code> inside <code>__getattr__</code> without having set anything on the instance (so it's still not going to be an existing value) should cause recursion errors by itself.</span>
<span class="comment-copy">@ShadowRanger I've been going between in and == and this version happened to still have the ==, but I've since changed it. Can you repeat your second comment, I keep rereading it but I don't follow what you're saying.</span>
<span class="comment-copy"><code>getattr(x, 'abc')</code> goes through the exact same code path as <code>x.abc</code>. If <code>x.abc</code> doesn't exist, the <code>__getattr__</code> is invoked to try to satisfy the missing attribute (so you know the attribute doesn't exist if you're in <code>__getattr__</code> in the first place). If the "can't find attribute handler" then turns around and, without modification, asks for the same attribute on itself, the end result is predictable. You can't just ask for it again without having set the value; the attribute still isn't there.</span>
<span class="comment-copy">@ShadowRanger Okay, so <code>__getattr__</code> should only be called if I'm trying to access an attribute that doesn't exist? So if I were to do <code>circle.test</code> then <code>__getattr__</code> would be run to try and find the attribute <code>test</code>?</span>
<span class="comment-copy">Why would it be better to avoid using <code>__getattr__</code> altogether? Wouldn't you need it if you were to do <code>circle.test</code> (an attribute of circle that doesn't exist) to return that that attribute doesn't exit?</span>
<span class="comment-copy">Python dos this for you. Try  <code>circle.test</code> on my <i>Variation</i>. It raises <code>AttributeError: 'Circle' object has no attribute 'test' </code>. No need to implement it yourself.</span>
<span class="comment-copy">so when would it be necessary to implement both <code>__getattr__</code> and <code>__setattr__</code>? I'm thinking you'd want to implement <code>__setattr__</code> as a checker almost so that user's can't implement "invalid" values for an attribute, but what about <code>__getattr__</code>?</span>
<span class="comment-copy">There is nothing wrong with the idea behind the use of <code>__getattr__()</code> and <code>__setattr__()</code> in the OP. You use them when you want to intercept attribute access and assignment to do any number of things. This is a fairly usual technique to implement a lot of interesting functionality (e.g. <code>ORM</code>). There were just a couple of small bugs in the OP. See my post below. The solution here though seems to use avoidance instead of actually solving the real problem.</span>
<span class="comment-copy">While <code>circle.__getattr__('x')</code> shows the text <code>===== get: x __get if statement</code>, <code>circle.x</code> does not. So <code>__getattr__()</code> is <b>not</b> called for the typical attribute access. So it does not make much sense to have it in the first place.</span>
<span class="comment-copy"><code>__getattr__()</code> is necessary to implement access to <code>virtual</code> or <code>computed</code> attributes. These attributes never exist for real, and their value is obtained by some other means (e.g. computation). When you do need to intercept <i>any</i> access, whether the attribute exists or not, you would use <code>__getattribute__()</code> instead. Its good to have either in your toolbox.</span>
<span class="comment-copy">I know this. But in <b>this</b>  case <code>self.x</code> exits. It is <b>not</b> computed and <code>self.x</code> does <b>not</b> call <code>__getattr__()</code>. The same is true for <code>y</code>, <code>r</code>, <code>area</code>, <code>circumference</code>, and <code>distance_to_origin</code>. Hence, no need to implement  <code>__getattr__()</code> the way its here at all. You don't gain anything in addition to Pythons default behavior.</span>
