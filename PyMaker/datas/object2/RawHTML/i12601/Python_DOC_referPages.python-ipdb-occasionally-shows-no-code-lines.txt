<div class="post-text" itemprop="text">
<p>Interrupting execution of python code with</p>
<pre><code>import ipdb; ipdb.set_trace()
</code></pre>
<p>sometimes (but not always) drops me into ipdb <em>without</em> showing surrounding lines of code, even if I issue the <code>l</code> command. Ie, I get something like</p>
<pre><code>&gt; /path/to/file.py(58)main()
ipdb&gt;
</code></pre>
<p>instead of</p>
<pre><code>&gt; /path/to/file.py(58)main()
-&gt; print('hello 2')
  55     print('hello')
  56     import pdb; pdb.set_trace()
  57
  58  -&gt; print('hello 2')
  59     print('hello 3')
ipdb&gt;
</code></pre>
<p>Does anyone know how to show lines of code?</p>
<p>Edit: If I <code>s</code>tep into a new function (situated in another file), a single surrounding line each side does appear.</p>
</div>
<div class="post-text" itemprop="text">
<p><code>ipdb</code> is a wrapper around the stock python debugger <a href="https://docs.python.org/3/library/pdb.html" rel="nofollow noreferrer">pdb</a> so in those cases where <code>ipdb</code> can't show line numbers neither will <code>pdb</code> be able to do so.</p>
<p><code>pdb</code> gets its source text from python module <a href="https://docs.python.org/3/library/linecache.html" rel="nofollow noreferrer">linecache</a>. And there are various things that can foil it. The most obvious case is when there <em>is no</em> source file. </p>
<p>This happens if you are evaluating a string. For example maybe are in the middle of <code>eval("x+1")</code> or <code>exec("z=1+2")</code>. </p>
<p>Along those same lines, you might have defined function via <code>exec</code> and you are now in the middle of running that function. For example:</p>
<pre><code>exec("def five(): return 5")
five()
</code></pre>
<p>The way you may be able to tell that you are in this kind of case is to adjust the stack frame and look at the calling context. So when that happens, run <code>up</code> or <code>bt</code> (backtrace):</p>
<p>If you see: </p>
<pre><code> (Pdb) up
&gt; &lt;string&gt;(1)&lt;module&gt;()
</code></pre>
<p>The <code>&lt;string&gt;</code> thing means that you are in this situation. A backtrace may show something like: </p>
<pre><code>/usr/lib/python2.7/bdb.py(400)run()
-&gt; exec cmd in globals, locals
&gt; &lt;string&gt;(1)&lt;module&gt;()
</code></pre>
<p>Other ways where the source might not exist may be that the source code was deleted, or maybe the bytecode was <a href="https://stackoverflow.com/questions/33348067/modifying-python-bytecode/40105522#40105522">generated all by itself</a>, or via an AST.</p>
<p>There is another debugger for Python called <a href="https://pypi.python.org/pypi/trepan" rel="nofollow noreferrer"><em>trepan</em></a> (for Python 3 see <a href="https://pypi.python.org/pypi/trepan3k" rel="nofollow noreferrer"><em>trepan3k</em></a>) that tries a <em>lot</em> harder to find the source text. And it also tries to verify that the source code it shows matches what the Python interpreter is running by using more than just the basename part of the filename. </p>
<p>The debugger can even reconstruct the Python source code when there is none! This magic is done via <a href="https://pypi.python.org/pypi?name=uncompyle6&amp;version=2.9.8&amp;:action=display" rel="nofollow noreferrer">uncompyle6</a>.</p>
<p>So show this, here is an example for this simple Python program: </p>
<pre><code>x = 3
eval("x+1")
exec("z=2")
</code></pre>
<p>Now we run the debugger: </p>
<pre><code>$ trepan3k /tmp/foo.py
(/tmp/foo.py:1): &lt;module&gt;
-&gt; 1 x = 3
(trepan3k) step
(/tmp/foo.py:2 @6): &lt;module&gt;
-- 2 eval("x+1")

(trepan3k) step
(&lt;string&gt;:1): &lt;module&gt;
(/tmp/foo.py:2 @12): &lt;module&gt;
-&gt; 2 eval("x+1")
(trepan3k) list
** No file &lt;string&gt; found
(trepan3k) deparse .
return x + 1
(trepan3k) step
(&lt;string&gt;:1 @7): &lt;module&gt;
(/tmp/foo.py:2 @12): &lt;module&gt;
&lt;- 2 eval("x+1")
R=&gt; 4
(trepan3k) step
(/tmp/foo.py:3 @16): &lt;module&gt;
-- 3 exec("z=2")
(trepan3k) list
End position changed to last line 3 
 1      x = 3
 2      eval("x+1")
 3  -&gt;  exec("z=2")
(trepan3k) step
(&lt;string&gt;:1): &lt;module&gt;
(/tmp/foo.py:3 @22): &lt;module&gt;
-&gt; 3 exec("z=2")
(trepan3k) list
** No file &lt;string&gt; found
(trepan3k) deparse .
z = 2
</code></pre>
<p>If this isn't enough, you can also disassemble the code to see that. And if you happen to know where the python source file is but for some reason the debugger can't find it on its own, you can tell it where the source code lives using <a href="http://python2-trepan.readthedocs.io/en/latest/commands/set/substitute.html" rel="nofollow noreferrer"><code>set substitute</code></a>. </p>
</div>
<span class="comment-copy">This happens to me as well. But in my case, 'l' does work, so I do 'n/s' and then 'l'.</span>
