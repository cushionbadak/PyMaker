<div class="post-text" itemprop="text">
<p>I want to rotate k element in a list in python. For example, n = 7, k = 3, and the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>Here is the statement I wrote. It seems to work in the command line.</p>
<pre><code>nums = nums[k%len(nums):] + nums[:k%len(nums)]
</code></pre>
<p>But when I encapsulate it in a function like:</p>
<pre><code>def rotate(nums, k):
    nums = nums[k%len(nums):] + nums[:k%len(nums)]
    return
</code></pre>
<p>I want to modify nums directly, but this function doesn't work.</p>
<p>I know that I can use a for loop like:</p>
<pre><code>for i in range(k):
    nums.insert(0,nums.pop())
</code></pre>
<p>but I want to know why the previous method doesn't work?</p>
</div>
<div class="post-text" itemprop="text">
<p>What you want is a slice assignment:</p>
<pre><code>nums[:] = nums[k%len(nums):] + nums[:k%len(nums)]
</code></pre>
<p>This mutates the list that was passed in, so the change is visible after the function returns.  Assigning just to <code>nums</code> merely makes <code>nums</code> point to a different list inside the function; it doesn't affect the original list.</p>
</div>
<div class="post-text" itemprop="text">
<p>Are you sure you want to modify nums?  You need not create a separate list even if you do not modify nums.  One advantage of the following approach is that it will work with any sequence.</p>
<pre><code>from itertools import islice
def rotate(lst, k):
    n = len(lst)
    start = n - (k % n)  #handle all ints
    for item in islice(lst, start, None):
        yield item
    for item in islice(lst, 0, start):
        yield item
</code></pre>
<p>If you insist on modifying nums as you say, you can still do so.  E.g.,</p>
<pre><code>nums = [x + 1 for x in range(7)]
nums[:] = rotate(nums,-10)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The <code>nums</code> that is inside the function is only within that function. So you need to return it from that function. One way is like this (python 2.7 code, add parentheses to <code>print</code> if you use 3.x):</p>
<pre><code>nums = [1, 2, 3, 4, 5, 6, 7]
k = 3


def rotate(nums, k):
    return nums[k%len(nums):] + nums[:k%len(nums)]

print 'Original', nums
nums = rotate(nums, k)
print 'Rotated', nums
</code></pre>
</div>
<span class="comment-copy">You create a new list inside the function then don't return or assign anything as a result; why did you expect that to make changes outside the function?</span>
<span class="comment-copy"><code>nums=...</code> sets the local variable <code>nums</code>, but does not change the actual original list <code>nums</code>. for the inverse problem see <a href="http://stackoverflow.com/questions/2322068/python-passing-list-as-argument" title="python passing list as argument">stackoverflow.com/questions/2322068/â€¦</a></span>
<span class="comment-copy">Side-note: Even fixed with slice assignment, this is incredibly inefficient if the <code>list</code> is of significant size (you make a complete copy of the <code>list</code>, then copy back into the original <code>list</code>); if rotating sequences is important in your use case, consider <a href="https://docs.python.org/3/library/collections.html#collections.deque" rel="nofollow noreferrer">using <code>collections.deque</code></a> which can perform rotation much more efficiently, with direct support for <a href="https://docs.python.org/3/library/collections.html#collections.deque.rotate" rel="nofollow noreferrer">in-place rotation</a>.</span>
