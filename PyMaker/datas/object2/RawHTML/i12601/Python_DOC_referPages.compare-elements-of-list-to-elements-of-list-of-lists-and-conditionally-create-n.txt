<div class="post-text" itemprop="text">
<p>It is about financial data. I have a list of the 70% percentiles of return data at 72 dates:</p>
<pre><code>list = [0.11,0.12,...,0.125]
</code></pre>
<p>Furthermore I have a list of lists which contains the 72 returns at the different dates for 500 companies (= 500 lists and 72 entries per list):</p>
<pre><code>list_of_lists = [[0.09,0.08,...,0.15],...,[0.1,0.34,...,0.01]]
</code></pre>
<p>What I want to do now is compare the first entry of my list (<code>0.11</code>) to all the entries in my first list in the list of lists. If the entry in the first list exceeds the <code>0.11</code> threshold (so in this case the <code>0.15</code> above) I want to add this number to a new list. Then I want to do the same with the second entry in <code>list</code> (<code>0.12</code>) and the second list in <code>list_of_lists</code>. In the end I basically want to obtain 72 lists (or a new list of lists) which contain the returns that are above the respective 70% percentile.</p>
</div>
<div class="post-text" itemprop="text">
<p>You could do this with list comprehension I think:</p>
<pre><code>thresholds = [0.11,0.12,0.125]
quotes = [[0.09,0.08,0.15],[0.09,0.08,0.15],[0.1,0.34,0.01]]
[filter(lambda x: x &gt; thresholds[idx],qts) for idx,qts in enumerate(quotes)]
</code></pre>
<p>I made some real lists out of the given ones (omitting the <code>...</code>) such that this is an example that compiles.</p>
<p>The list comprehension works as follows: we iterate over the <code>qts</code> from <code>quotes</code> (and also obtain the corresponding index <code>idx</code>, which is used to obtain the threshold). Next we perform a <code>filter</code> operation on the <code>qts</code> and only allow elements that are larger than the <code>threshold[idx]</code> (the threshold for that timestamp).</p>
<p>Running this with <code>python</code> gives:</p>
<pre><code>$ python
Python 2.7.9 (default, Apr  2 2015, 15:33:21) 
[GCC 4.9.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; thresholds = [0.11,0.12,0.125]
&gt;&gt;&gt; quotes = [[0.09,0.08,0.15],[0.09,0.08,0.15],[0.1,0.34,0.01]]
&gt;&gt;&gt; [filter(lambda x: x &gt; thresholds[idx],qts) for idx,qts in enumerate(quotes)]
[[0.15], [0.15], [0.34]]
</code></pre>
<p>which seems to be what you want.</p>
<p><strong>EDIT</strong> In <a class="post-tag" href="/questions/tagged/python-3.x" rel="tag" title="show questions tagged 'python-3.x'">python-3.x</a>, this should work as well, although the filter is "delayed":</p>
<pre><code>$ python3
Python 3.4.3 (default, Mar 26 2015, 22:03:40) 
[GCC 4.9.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; thresholds = [0.11,0.12,0.125]
&gt;&gt;&gt; quotes = [[0.09,0.08,0.15],[0.09,0.08,0.15],[0.1,0.34,0.01]]
&gt;&gt;&gt; res=[filter(lambda x: x &gt; thresholds[idx],qts) for idx,qts in enumerate(quotes)]
&gt;&gt;&gt; res[0]
&lt;filter object at 0x7f0d3fbc2be0&gt;
&gt;&gt;&gt; list(res[0])
[0.15]
</code></pre>
<p>If you want to <em>materialize</em> the lists straight away, you can slightly alter the list comprehension to:</p>
<pre><code>[list(filter(lambda x: x &gt; thresholds[idx],qts)) for idx,qts in enumerate(quotes)]
</code></pre>
<p>Which results in:</p>
<pre><code>&gt;&gt;&gt; [list(filter(lambda x: x &gt; thresholds[idx],qts)) for idx,qts in enumerate(quotes)]
[[0.15], [0.15], [0.34]]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If I understand your question correctly, you have 500 lists of 72 values and 72 threshold values. You want to compare the <em>n</em><sup>th</sup> value of <em>each</em> list with the <em>n</em><sup>th</sup> value of your list of thresholds. In other words, you want to proceed column-wise. It's easiest to first <a href="https://en.wikipedia.org/wiki/Transpose" rel="nofollow noreferrer">transpose</a> <code>list_of_lists</code> using <a href="https://stackoverflow.com/a/17037588/1523776">this one cool trick</a>, so that each column in <code>list_of_lists</code> becomes a row:</p>
<pre><code>transposed = zip(*list_of_lists)
</code></pre>
<p>Now we can work with rows. Pair each number in your list of thresholds with its corresponding row in <code>transposed</code>.</p>
<pre><code>lists_with_thresholds = zip(list, transposed)
</code></pre>
<p>Each item in <code>lists_with_thresholds</code> is a pair containing a cutoff point and the values to which we want to compare it. The ducks are lined up in a row; we just have to find the values in the second part of the pair which exceed the corresponding cutoff point.</p>
<pre><code>result = []
for threshold, values in lists_with_thresholds:
    values_over_threshold = []
    for x in values:
        if x &gt; threshold:
            values_over_threshold.append(x)
    result.append(values_over_threshold)
</code></pre>
<p>Or, squishing the nested <code>for</code> loops up into a nested <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow noreferrer">list comprehension</a>:</p>
<pre><code>result = [[x for x in values if x &gt; threshold]
          for threshold, values in zip(list, zip(*list_of_lists))]
</code></pre>
<p>These two versions are exactly equivalent - they compile into the same byte code, for all intents and purposes - but I like the list comprehension better because it's shorter and it has a more functional feel.</p>
</div>
<div class="post-text" itemprop="text">
<p>I think this is what you want:</p>
<pre><code>new_list = []
for i in lists_of_lists:
    for j in i:
        if j &gt; list[0]:
            new_list.append(j)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You could use a list comprehension:</p>
<pre><code>list = [4, 3, 2, 3, 4, 5]
list_of_lists = [[6, 1, 3, 7, 2, 5], [1, 2, 6, 3, 8, 1], [1, 2, 3, 2, 7, 6]]

above = [[ret for i, ret in enumerate(lst) if ret &gt; list[i]] for lst in list_of_lists]
</code></pre>
<blockquote>
<p>[[6, 3, 7], [6, 8], [3, 7, 6]]</p>
</blockquote>
<p>This will remove all entries in your lists in <code>list_of_lists</code> that are less or equal to the corresponding element of <code>list</code>.</p>
</div>
<span class="comment-copy">You say <i>500 lists and 72 entries per list</i>, shouldn't this by <i>72 lists and 500 entries per list</i>?</span>
<span class="comment-copy">Not an answer, but I would definitely suggest looking into using a library like e.g. <a href="http://www.numpy.org/" rel="nofollow noreferrer"><code>numpy</code></a>.</span>
<span class="comment-copy">How would I apply this in python 3? I get a TypeError: 'list' object is not callable.</span>
<span class="comment-copy">@AlexanderEser: I do not get this error, see updated answer.</span>
<span class="comment-copy">now it works as well. thank you!</span>
<span class="comment-copy">This is exactly what I wanted. Thank you!</span>
<span class="comment-copy">Although I think this works, it's a but <i>un-pythonic</i> to call list modifiers. That's why they invented list comprehension. +1 nevertheless ;).</span>
<span class="comment-copy">OP wants the elements of the sublists which are greater than the <i>corresponding</i> element of <code>list</code>, not <code>list[0]</code>. Also, this will produce a flat list whereas OP wants a list of lists.</span>
<span class="comment-copy">Thanks! I did it like this since I knew there would be plenty of list comprehension answers, and for beginners list comp is harder to read (at least for me it was). And I guess misunderstood the OP....</span>
<span class="comment-copy">OP wants the elements of the sublists which are greater than the <i>corresponding</i> element of <code>list</code>.</span>
<span class="comment-copy">Alright, fixed that. I think that wasn't totally clear from the question.</span>
