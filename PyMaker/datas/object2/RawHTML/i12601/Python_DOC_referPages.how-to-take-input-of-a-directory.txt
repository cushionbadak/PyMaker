<div class="post-text" itemprop="text">
<p>What I'm trying to do is troll through a directory of log files which begin like this "filename001.log" there can be 100s of files in a directory</p>
<p>The code I want to run against each files is to check to make sure that the 8th position of the log always contains a number. I have a suspicion that a non-digit is throwing off our parser. Here's some simple code I'm trying to check this:</p>
<pre><code># import re
from urlparse import urlparse

a = '/folderA/filename*.log' #&lt;&lt; currently this only does 1 file
b = '/folderB/' #&lt;&lt; I'd like it to write the same file name as it read
with open(b, 'w') as newfile, open(a, 'r') as oldfile:
    data = oldfile.readlines()
    for line in data:
        parts = line.split()
        status = parts[8]  # value of 8th position in the log file
        isDigit = status.isdigit()

        if isDigit = False:
                print " Not A Number :",status
                newfile.write(status)
</code></pre>
<p>My problem is:</p>
<ol>
<li>How do I tell it to read all the files in a directory? (The above really only works for 1 file at a time)</li>
<li>If I find something is not a number I would like to write that character into a file in a different folder but of the same name as the log file. For example I find filename002.log has a "*" in one of the log lines. I would like folderB/filename002.log to made and the non-digit character to the written.</li>
</ol>
<p>Sounds sounds simple enough I'm just a not very good at coding.</p>
</div>
<div class="post-text" itemprop="text">
<p>To read files in one directory matching a given pattern and write to another, use the <a href="https://docs.python.org/3/library/glob.html#glob.iglob" rel="nofollow"><code>glob</code> module</a> and the <code>os.path</code> functions to construct the output files:</p>
<pre><code>srcpat = '/folderA/filename*.log'
dstdir = '/folderB'
for srcfile in glob.iglob(srcpat):
   if not os.path.isfile(srcfile): continue

   dstfile = os.path.join(dstdir, os.path.basename(srcfile))
   with open(srcfile) as src, open(dstfile, 'w') as dst:
       for line in src:
           parts = line.split()
           status = parts[8]  # value of 8th position in the log file
           if not status.isdigit():
               print " Not A Number :", status
               dst.write(status)  # Or print &gt;&gt;dst, status if you want newline
</code></pre>
<p>This will create empty files even if no bad entries are found. You can either wait until you're finished processing the files (and the <code>with</code> block is closed) and just check the file size for the output and delete it if empty then, or you can move to a lazy approach where you delete the output file before beginning iteration unconditionally, but don't open it; only if you get a bad value do you open the file (for append instead of write to keep earlier loops' output from being discarded), write to it, allow it to close.</p>
</div>
<div class="post-text" itemprop="text">
<ol>
<li><p>Import os and use: <code>for filenames in os.listdir('path'):</code>. This will list all files in the directory, including subdirectories.</p></li>
<li><p>Simply open a second file with the correct path. Since you already have filename from iterating with the above method, you only have to replace the directory. You can use <code>os.path.join</code> for that.</p></li>
</ol>
</div>
<span class="comment-copy">Maybe this help You will get list of all files of current directory  then read one by one at the time. <a href="http://stackoverflow.com/questions/3207219/how-to-list-all-files-of-a-directory-in-python" title="how to list all files of a directory in python">stackoverflow.com/questions/3207219/â€¦</a></span>
<span class="comment-copy">Why bother with <code>os.walk</code> when they only need files in a single directory, not the whole tree? And why use append mode when they're producing a single output file for each input file (if a single shared output file was being used and reopened, sure, but otherwise?).</span>
<span class="comment-copy">You are right. I'll improve my answer a lil</span>
