<div class="post-text" itemprop="text">
<p>Currently, the first part of my code works correctly. If it detects that the first character (index 0) is a vowel it stops and adds "yay" to the end of word.</p>
<p>The second part is intended to capture consonants up to the first vowel. This works correctly.</p>
<p>The problem occurs when I try to take the original word and slice off everything up to the first vowel and create a new substring out of it. This would mean that if the user inputs "hello" it should output "ellohay". I can get "hellohay" but can't figure out how to capture those initial consonants and slice them out.</p>
<pre><code># Pig Latinify

vowels = ['a', 'e', 'i', 'o', 'u']
consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z']


def pig_latinify():
    state = True
    while state == True:

        user_input = raw_input("Enter a word to be translated: ").lower()

        # If the first character in input is a vowel add 'yay' to input and print.
        if user_input[0] in vowels[0:]:
            print ""
            print "Begins with a vowel." 
            pig_output = user_input + "yay"
            print user_input, "becomes:", pig_output
            print ""
        else:
            print ""
            print "Doesn't begin with a vowel."

            captured_consonants = ""
            captured_substring = ""
            new_user_input = ""

            # Capture the consonants up to the first vowel
            for i in user_input:
                if i in vowels:
                    break
                if i in consonants:
                    captured_consonants = captured_consonants + i

            # Slice user_input up to the first vowel and create a substring beginng from the first vowel until the end of the string.
                if i in consonants:
                    break
                if i in vowels:
                    captured_substring = captured_substring + i 
                print captured_substring

            # Concatenate substring of user_input with captured_consonants and 'ay'
            pig_output = captured_substring + captured_consonants + "ay"
            print user_input, "becomes:", pig_output
            print ""

pig_latinify()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Using regex would probably be your best bet:</p>
<pre><code># Pig Latinify
import re

vowels = list('aeiou')

def pig_latinify():
    state = True
    while state == True:

        user_input = raw_input("Enter a word to be translated: ").lower()

        # If the first character in input is a vowel add 'yay' to input and print.
        if user_input[0] in vowels[0:]:
            print ""
            print "Begins with a vowel." 
            pig_output = user_input + "yay"
            print user_input, "becomes:", pig_output
            print ""
        else:
            print ""
            print "Doesn't begin with a vowel."

            r = re.search("(.*?)([aeiou].*)", user_input)

            # Capture the consonants up to the first vowel
            captured_consonants = r.groups()[0]

            # Slice user_input up to the first vowel and create a substring beginng from the first vowel until the end of the string.
            captured_substring = r.groups()[1]

            # Concatenate substring of user_input with captured_consonants and 'ay'
            pig_output = captured_substring + captured_consonants + "ay"
            print user_input, "becomes:", pig_output
            print ""

pig_latinify()
</code></pre>
<p>This basically non-greedily searches the string until it hits a vowel, and makes two groups of the consonants and the vowel+following string, and manipulates them accordingly. </p>
<pre><code>$ python pig_latin.py 
Enter a word to be translated: hello

Doesn't begin with a vowel.
hello becomes: ellohay

Enter a word to be translated: hi

Doesn't begin with a vowel.
hi becomes: ihay

Enter a word to be translated: apple

Begins with a vowel.
apple becomes: appleyay
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>if you want to drop all leading chars until you hit a vowel you can use <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" rel="nofollow">itertools.dropwhile</a>:</p>
<pre><code>from itertools import dropwhile
user_input = "hello"

vowels = {"a","e","i","o","u"}

up_to = "".join(dropwhile(lambda x: x not in vowels, user_input))
print(up_to + user_input[:len(user_input) - len(up_to)]+"ay")
</code></pre>
<p>output: ellohay</p>
<p><code>lambda x: x not in vowels</code> means we want to drop all chars until we find a character in vowels. If you want to work for upper or lowercase add the uppercase vowels to the set or switch the lambda to <code>x.lower() not in vowels</code></p>
</div>
<div class="post-text" itemprop="text">
<p>This code looks rather strange. For instance, the second  <code>if i in vowels:</code> is never reached.</p>
<p>Instead of this you may want to:</p>
<ol>
<li>Find the position of first vowel - let it be <code>pos</code></li>
<li>check if <code>pos</code> &gt; 0</li>
<li><code>return user_input[pos:] + user_input[:pos-1] + 'ay'</code> </li>
</ol>
</div>
<span class="comment-copy">When you say "non-greedily" does that mean not using a loop and iterating over each index value? It does it as a "search" instead?</span>
<span class="comment-copy">@lookininward Non-greedily means that it goes until the first vowel in the input, and groups that. If it was greedy, it would go until the last-vowel in the input.</span>
<span class="comment-copy">@lookininward <a href="https://docs.python.org/2/howto/regex.html#repeating-things" rel="nofollow noreferrer">docs.python.org/2/howto/regex.html#repeating-things</a> for a deeper explanation.</span>
<span class="comment-copy">@lookininward please mark an answer as correct if any of them here helped solve your problem.</span>
<span class="comment-copy">Or just change the lambda to <code>x.lower()</code> ?</span>
<span class="comment-copy">@JonClements, True, the OP is actually calling lower on the input string so probably a moot point but I will add it anyway</span>
<span class="comment-copy">...and <code>set('aeiou')</code> is a bit less typing :)</span>
<span class="comment-copy">I don't think that's exactly the pig latin OP's looking for. He wants "ellohay" not "elloyay". But I love how succinct your solution is!</span>
<span class="comment-copy">@VaibhavAggarwal, indeed, not sure where I saw the other <code>y</code>, have not even had a drink yet...</span>
