<div class="post-text" itemprop="text">
<p>I have the following code:</p>
<pre><code>import os
import sys
import tempfile
import subprocess

with tempfile.NamedTemporaryFile('w+') as f:
    if sys.platform == 'linux':
        subprocess.call('vim', f.name)
    elif sys.platform == 'nt':
        os.system(f.name)
</code></pre>
<p>It opens <code>foobar.txt</code> using either <code>vim</code> on Linux, or the default editor on Windows. On Linux it works fine: <a href="http://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile" rel="noreferrer"><code>tempfile.NamedTemporaryFile()</code></a> creates a temporary file and <code>vim</code> opens it. On Windows, however, the system says:</p>
<blockquote>
<p>The process cannot access the file because it is being used by another process.</p>
</blockquote>
<p>I guess that's because the script is currently <em>using</em> the file.</p>
<p>Why does it work on Linux, and how do I get it to work on Windows?</p>
</div>
<div class="post-text" itemprop="text">
<p>I've run into this problem before. My problem was that I had to write to a file and then use that file's name as an argument in a command.</p>
<p>The reason this works in Linux is that, as <a href="https://stackoverflow.com/users/4014959/pm-2ring">@PM 2Ring</a> said in the comments, Linux allows multiple processes to write to the same file, but Windows does not.</p>
<p>There are two approaches to tackle this.</p>
<p>One is to create a <a href="https://docs.python.org/2/library/tempfile.html#tempfile.mkdtemp" rel="nofollow noreferrer">temporary directory</a> and create a file in that directory.</p>
<pre><code># Python 2 and 3
import os
import tempfile

temp_dir = tempfile.mkdtemp()
try:
    temp_file = os.path.join(temp_dir, 'file.txt')
    with open(temp_file, 'w') as f:
        pass  # Create the file, or optionally write to it.
    try:
        do_stuff(temp_file)  # In this case, open the file in an editor.
    finally:
        os.remove(file_name)
finally:
    os.rmdir(temp_dir)
</code></pre>
<pre><code># Python 3 only
import tempfile

with tempfile.TemporaryDirectory() as temp_dir:
    temp_file = os.path.join(temp_dir, 'file.txt')
    with open(temp_file, 'w') as f:
        pass  # Create the file, or optionally write to it.
    do_stuff(temp_file)
    # with tempfile.TemporaryDirectory(): automatically deletes temp_file
</code></pre>
<p>Another approach is to create the temporary file with <code>delete=False</code> so that when you close it, it isn't deleted, and then delete it manually later.</p>
<pre><code># Python 2 and 3
import os
import tempfile

fp = tempfile.NamedTemporaryFile(suffix='.txt', delete=False)
try:
    fp.close()
    do_stuff(fp.name)
finally:
    os.remove(fp.name)
</code></pre>
<p>Here is a little context manager that can make files:</p>
<pre><code>import os
import tempfile

_text_type = type(u'')

class ClosedTemporaryFile(object):
    __slots__ = ('name',)
    def __init__(self, data=b'', suffix='', prefix='tmp', dir=None):
        fp = tempfile.mkstemp(suffix, prefix, dir, isinstance(data, _text_type))
        self.name = fp.name
        if data:
            try:
                fp.write(data)
            except:
                fp.close()
                self.delete()
                raise
        fp.close()

    def exists(self):
        return os.path.isfile(self.name)

    def delete(self):
        try:
            os.remove(self.name)
        except OSError:
            pass

    def open(self, *args, **kwargs):
        return open(self.name, *args, **kwargs)

    def __enter__(self):
        return self.name

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.delete()

    def __del__(self):
        self.delete()
</code></pre>
<p>Usage:</p>
<pre><code>with ClosedTemporaryFile(suffix='.txt') as temp_file:
    do_stuff(temp_file)
</code></pre>
</div>
<span class="comment-copy">This is basic Windows I/O. All files are opened with a particular access (read/write data, delete, set attributes, etc) and an access sharing mode. <code>NamedTemporary</code> opens the file with delete access, as required by the delete-on-close flag, and shares all access (read, write, and delete). Subsequently opening the file again requires sharing delete access, which most programs don't allow.</span>
<span class="comment-copy">FYI, you can undo the effect of the delete-on-close flag by opening a 2nd handle for the file before closing the first. When the first handle is closed, it sets a delete disposition on the file, but it isn't deleted until all handles are closed. Use the 2nd handle to undo the delete disposition via <code>SetFileInformationByHandle</code>. Now you can close the 2nd handle, and the file won't be deleted.</span>
<span class="comment-copy">Haha, @KevinGuan Knowing eryksun from a long time, he has solved more problems in comments than answers, one reason why I like him as a person. :) (Hopefully he will post an answer this time)</span>
<span class="comment-copy">@KevinGuan: If you close a <code>tempfile.NamedTemporaryFile</code> (or a plain <code>tempfile.TemporaryFile``) it will be destroyed. See [the docs](https://docs.python.org/3/library/tempfile.html) for details. Perhaps you could use a </code>tempfile.mkstemp` file?</span>
<span class="comment-copy">@KevinGuan: Unix allows multiple processes to write to the same file, but you do have to be careful, as discussed in <a href="http://stackoverflow.com/questions/7842511/safe-to-have-multiple-processes-writing-to-the-same-file-at-the-same-time-cent">this U&amp;L question</a>.</span>
