<div class="post-text" itemprop="text">
<p>Give a method that sums all the numbers in a <code>list</code>. The method should be able to   skip elements that are not numbers. So, <code>sum([1, 2, 3])</code> should be <code>6</code> but <code>sum(['A', 1, 'B', 2, 3])</code> <em>should also</em> be <code>6</code>. How can I accomplish this?</p>
<p>What I have already tried so far:</p>
<pre><code>def foo(list):
    dict = "ABCDEFGHIJKLMN"
    n = 0
    for i in range(0, len(list) - 1):
        if list[i].str in dict:
            ""
        else:    
            n= n + list[i]
    return n

print foo([1, 2, 3, 4, 5, 6, "A", "B"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can do this with a simple one liner:</p>
<pre><code>l1 = [1, 2, 3, 'A']

sum(filter(lambda i: isinstance(i, int), l1))
# prints 6
</code></pre>
<p>Or, if you need it inside a function:</p>
<pre><code>def foo(l1):
    return sum(filter(lambda i: isinstance(i, int), l1))
</code></pre>
<p>Additionally, as noted in the comments, <strong>don't</strong> use names like <code>dict</code> and <code>list</code> for your variables; *they will shadow they build-in names for the dictionary (<code>dict</code>) and (<code>list</code>) types. You'll then need to explicitly <code>del dict, list</code> in order to use them as intended.</p>
<hr/>
<p>But, let me explain. What <strong><a href="https://docs.python.org/2.7/library/functions.html#filter" rel="nofollow"><code>filter</code></a></strong> does is here is: </p>
<p><strong>a)</strong> It takes a function as its first argument:</p>
<pre><code># this function will return True if i is an int
# and false otherwise
lambda i: isinstance(i, int)
</code></pre>
<p>and then takes every element inside the list <code>l1</code> (second argument) and evaluates whether it is <code>True</code> or <code>False</code> based on the function. </p>
<p><strong>b)</strong> Then, <code>filter</code> will essentially filter out any objects inside list <code>l1</code> that are not instances of <code>int</code> (i.e the function returns <code>False</code> for them). As a result, for a list like <code>[1, 2, 3, 'A']</code> filter is going to return <code>[1, 2, 3]</code> which will then be summed up by <strong><a href="https://docs.python.org/2.7/library/functions.html#sum" rel="nofollow"><code>sum()</code></a></strong>.</p>
<p>Some Examples:</p>
<pre><code>foo([1, 2, 3, 'A'])
# 6

foo([1, 2, 3])
# 6

foo([1, 2, 3, 'HELLO', 'WORLD'])
# 6
</code></pre>
<hr/>
<p><strong>Slight caveat:</strong> </p>
<p>As is, this doesn't sum up <code>float</code> values, it drops them (and any other numeric types for that case). If you need that too, simply add the <code>float</code> type in the <code>lambda</code> function as so:</p>
<pre><code>lambda i: isinstance(i, (int, float))
</code></pre>
<p>Now, your function sums floats too:</p>
<pre><code>foo([1, 2, 3, 3.1,  'HELLO', 'WORLD'])
# 9.1
</code></pre>
<p>Add any other types as necessary in the <code>lambda</code> function to catch the cases that you need.</p>
<hr/>
<p><strong>A catch all case:</strong></p>
<p>As noted by <strong>@Copperfield</strong> you can check for objects that are instances of any number by utilizing the <strong><a href="https://docs.python.org/2.7/library/numbers.html#numbers.Number" rel="nofollow"><code>numbers.Number</code></a></strong> abstract base class in the <strong><a href="https://docs.python.org/2.7/library/numbers.html" rel="nofollow"><code>numbers</code></a></strong> module. This acts as a catch-all case for numeric values:</p>
<pre><code>import numbers # must import
sum(filter(lambda i: isinstance(i, numbers.Number), l1))
</code></pre>
<p><strong>Simpler and a bit faster, too:</strong></p>
<p>Additionally, as noted by <strong>@ShadowRanger</strong>, and since <a href="https://www.reddit.com/r/learnpython/comments/2emwwh/lambdas_are_confusing_me/" rel="nofollow"><em><code>lambda</code> might not be the most comfortable construct for new users</em></a>, one could simply use <em><a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">a generator expression</a></em> (which is also faster) with <code>sum</code> to get the same exact result:</p>
<pre><code>sum(val for val in l1 if isinstance(val, numbers.Number))
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>The Pythonic way is to do a try/except. While you could do this in a one liner, I prefer to break things out a bit to see exactly what is happening.</p>
<pre><code>val=0
for item in list:
    try:
        val+=int(item)
    except ValueError:
        pass
</code></pre>
<p>If you want to include floating points, simply change the <code>int</code> to a <code>float</code>. Floating points are anything with a decimal, among others.</p>
</div>
<div class="post-text" itemprop="text">
<pre><code>sum([x for x in list if isinstance(x, (int, long, float))])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>use filter and isinstance like this</p>
<pre><code>&gt;&gt;&gt; test = [1,2,3,4,5,6,"A","B"]
&gt;&gt;&gt; sum(filter(lambda x:isinstance(x,int),test))
21
&gt;&gt;&gt; 
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def foo(list):
dict= "ABCDEFGHIJKLMN"
n=0
for i in range(0,len(list)-1):
    if str(list[i]) in dict:
        ""
    else:    
        n= n+list[i]
return n
print foo([1,2,3,4,5,6,"A","B"])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>def filtersum(L):
    if not L: return 0
    if not isinstance(L[0], int): return filtersum(L[1:])
    return L[0] + filtersum(L[1:])
</code></pre>
<p>Output:</p>
<pre><code>In [28]: filtersum([1,2,3])
Out[28]: 6

In [29]: filtersum([1,'A', 2,3])
Out[29]: 6
</code></pre>
</div>
<span class="comment-copy">Replace <code>list[i].str</code> with <code>str(list[i])</code>.</span>
<span class="comment-copy">Sounds like homework to me.</span>
<span class="comment-copy">@JonasGr√∂ger He posted the code he wrote I guess.</span>
<span class="comment-copy">@Delgan I didn't see a error message or a unexpected result. He just pasted the code there.</span>
<span class="comment-copy">Notes: avoid variable names like <code>dict</code> and <code>list</code> since they are the names of built-in functions. Your variable named <code>dict</code> is actually a string, not a dictionary. Perhaps a name like <code>letters</code> would be clearer.</span>
<span class="comment-copy">to include every numeric type without mention each one, you can use the corresponding <a href="https://docs.python.org/3/library/numbers.html" rel="nofollow noreferrer">ABC</a>, for example <code>isinstance(item, numbers.Number)</code></span>
<span class="comment-copy">If you'd need a <code>lambda</code> to use <code>map</code>/<code>filter</code>, you may as well just use a generator expression (or list comp); you gain nothing in terms of either brevity or speed as soon as you resort to <code>lambda</code>s with <code>map</code>/<code>filter</code>.</span>
<span class="comment-copy">The speed loss is neglidgible in this context but exists nontheless, I will edit my asnwer to include the generator based <code>sum</code> since it is also most explicit. The biggest loss here is probably due to <code>lambda</code> being an odd construct, and confusing people, especially new comers.</span>
<span class="comment-copy">Not sure why you're being voted down. If this was anything more complicated than "Add the numbers" then this is <b><i>exactly</i></b> how to do it. The cheeky one-liner isn't better.</span>
<span class="comment-copy">@AdamSmith: Sadly that is the case. Too many Python programmers like to try to cram as much as possible into a single line of code...</span>
<span class="comment-copy">While I +1'd and in general do agree (as Adam said, in more complicated cases), <i>in this case</i> a <code>try-catch</code> is overkill. Additionally, you are wraping an <code>item</code> in an <code>int</code> call when it really shouldn't be necessary and, in order to generalize to encompass all Numbers, you'd probably do an <code>if isinstance</code> and drop the <code>try</code> altogether. <code>filter</code> is such a wonderful little function for exactly these things, can't see why you hatin' on it.</span>
<span class="comment-copy">Downside to this approach: If the distinction between values to be kept and values to be dropped is based on type (<code>str</code> dropped, <code>int</code> kept), this code will fail if the input is <code>(1, 2, '3', '4')</code> by returning <code>10</code> instead of <code>3</code>; <code>int</code> will happily coerce numeric <code>str</code> to <code>int</code>.</span>
<span class="comment-copy">The exercise said add all the <i>numbers</i>, not integers. So why not just change "val+=int(item)" to "val+=item"? That seems to me to fix the downside that's been mentioned - has the added virtue of then being exactly the solution I was about to post before seeing this, heh.</span>
<span class="comment-copy">Best answer. Maybe using filter() would be more explicit.</span>
<span class="comment-copy"><code>filter</code> is really only "better" when it gains you something on speed or brevity (and it only gains you speed when you can pass it a built-in function implemented in C on CPython). For something like this, a generator expression is best (same as current answer, but without the brackets that make a <code>list</code> comprehension, which means no intermediate <code>list</code>s being created and thrown away); it's no more or less explicit, and likely slightly faster.</span>
<span class="comment-copy">Why have you added your wrong code as an answer? You can delete it.</span>
<span class="comment-copy">it is working now by str(list[i])</span>
<span class="comment-copy">But it won't work if you have strings apart from A-N. E.g. Try "Z"</span>
<span class="comment-copy">the way to say that you do nothing in a block of code is by using <a href="https://docs.python.org/2.7/reference/simple_stmts.html#pass" rel="nofollow noreferrer"><code>pass</code></a>. And in this case you can also use <code>if str(list[i]) not in dict</code> or <code>if not (str(list[i]) in dict)</code> and do the sum</span>
<span class="comment-copy">@Copperfield: Actually, even if you put the <code>not</code> first, you still don't need additional parens; <code>not x in y</code> is already equivalent to (if slightly less readable to my mind) <code>x not in y</code>, no need for parens.</span>
<span class="comment-copy">why recursion? that is unnecessary overhead</span>
<span class="comment-copy">OP wants answers for an exam - I imagine a professor would be quite impressed with this response from student in an intro to programming class</span>
<span class="comment-copy">A code block alone does not provide a good answer. Please add explanations (why it solve the issue, where was the mistake, etc...)</span>
