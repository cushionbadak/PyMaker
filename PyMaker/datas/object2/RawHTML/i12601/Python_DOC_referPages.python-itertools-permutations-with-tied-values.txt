<div class="post-text" itemprop="text">
<p>I want to find <em>efficiently</em> permutations of a vector which has tied values. </p>
<p>E.g., if <code>perm_vector = [0,0,1,2]</code> I would want to obtain as output all combinations of <code>[0,0,1,2], [0,0,2,1], [0,1,2,0]</code> and so on, but I don't want to obtain <code>[0,0,1,2]</code> twice which is what the standard <code>itertools.permutations(perm_vector)</code> would give. </p>
<p>I tried the following but it works really SLOW when <code>perm_vector grows</code> in len:</p>
<pre><code>vectors_list = []
for it in itertools.permutations(perm_vector):
    vectors_list.append(list(it))
df_vectors_list  = pd.DataFrame( vectors_list)
df_gb = df_vectors_list.groupby(list(df_vectors_list.columns)) 
vectors_list = pd.DataFrame(df_gb.groups.keys()).T
</code></pre>
<p>The question is of more general "speed-up" nature, actually. The main time is spent on creating the permutations of long vectors - even without the duplicity, creation of permutations of a vector of 12 unique values takes a "infinity". Is there a possibility to call the itertools iteratively without accessing the entire permutations data but working on bunches of it? </p>
</div>
<div class="post-text" itemprop="text">
<p>Try this if perm_vector is small:</p>
<pre><code>import itertools as iter
{x for x in iter.permutations(perm_vector)}
</code></pre>
<p>This should give you unique values, because now it becomes a set, which by default delete duplications.</p>
<p>If perm_vector is large, you might want to try backtracking:</p>
<pre><code>def permu(L, left, right, cache):
    for i in range(left, right):
        L[left], L[i] = L[i], L[left]
        L_tuple = tuple(L)
        if L_tuple not in cache:                
            permu(L, left + 1, right, cache)
            L[left], L[i] = L[i], L[left]
            cache[L_tuple] = 0
cache = {}
permu(perm_vector, 0, len(perm_vector), cache)
cache.keys()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>How about this:</p>
<pre><code>from collections import Counter

def starter(l):
    cnt = Counter(l)
    res = [None] * len(l)
    return worker(cnt, res, len(l) - 1)

def worker(cnt, res, n):
    if n &lt; 0:
        yield tuple(res)
    else:
        for k in cnt.keys():
            if cnt[k] != 0:
                cnt[k] = cnt[k] - 1
                res[n] = k
                for r in worker(cnt, res, n - 1):
                    yield r
                cnt[k] = cnt[k] + 1
</code></pre>
</div>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/6534430/why-does-pythons-itertools-permutations-contain-duplicates-when-the-original">Why does Python's itertools.permutations contain duplicates? (When the original list has duplicates)</a></span>
<span class="comment-copy">Here's an external <a href="http://blog.bjrn.se/2008/04/lexicographic-permutations-using.html" rel="nofollow noreferrer">link</a> from a comment in the thread referenced by the above comment that could be helpful.</span>
<span class="comment-copy">there is a recipe for this in the itertools module, check the unique_everseen recipe: <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow noreferrer">docs.python.org/3/library/itertools.html#itertools-recipes</a></span>
<span class="comment-copy">Something based on the idea of C++'s <code>std::next_permutation</code> may be appropriate; <code>std::next_permutation</code> handles duplicates the way you want. I recommend implementing it yourself at least once as a learning experience, but there are also <a href="http://matteolandi.blogspot.com/2009/09/python-nextpermutation_13.html" rel="nofollow noreferrer">existing implementations available</a>.</span>
<span class="comment-copy">While this technically works, it still generates all duplicate permutations before filtering, so it's extremely inefficient when there are many duplicates.</span>
<span class="comment-copy">@user2357112 That's true..  If the list is big, might need to use backtracking and memoization to make it more efficient.  I posted my code above (it'd be great if there's a way to avoid "if" within the "for loop" though)..</span>
