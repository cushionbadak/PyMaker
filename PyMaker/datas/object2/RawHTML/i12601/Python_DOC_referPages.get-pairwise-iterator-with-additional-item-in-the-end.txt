<div class="post-text" itemprop="text">
<p>The goal: e.g. given finite iterator <code>p0, p1, ..., pn</code> turn into <code>(p0, p1), (p1, p2), ..., (pn-1, pn), (pn, None)</code> — iterator through pairs of consecutive items with special last item.</p>
<p><code>pairwise()</code> function exists in the documentation as example of <code>itertools</code> usage:</p>
<pre><code>def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)
</code></pre>
<p>But  I want additionally add yet another item to the end of iterator (if it is finite) with some default value for the second element of pair (e.g., <code>None</code>).</p>
<p>How to efficiently implement this additional functionality?</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest"><code>itertools.zip_longest</code></a>:</p>
<pre><code>def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return zip_longest(a, b)
</code></pre>
<p>When one of the input iterators runs out, <code>zip_longest</code> pads it with a filler value, which defaults to <code>None</code>.</p>
</div>
<div class="post-text" itemprop="text">
<p>As for adding <code>(sn, None)</code> at the end, as user2357112 already answered, you can just use <code>zip_longest</code> so one already exhausted iterator is not stopping the whole sequence (so the <code>a</code> iterator can still yield the last element).</p>
<p>For all other situations, e.g. if you want to add further elements at the end, you can just make a generator function itself. All the <code>itertools</code> function are already lazy generators, only producing new results when you request the next element in the result, and you can easily consume those from within a generator.</p>
<p>Let’s say, you need <code>pairwise</code> to yield a sentinel value <code>(None, None)</code> at the end, then you could simply yield the results from <code>zip_longest</code> and then yield another item:</p>
<pre><code>def example (iterable):
    a, b = tee(iterable)
    next(b, None)
    yield from zip_longest(a, b)
    yield (None, None)
</code></pre>
<p>The <code>yield from</code> syntax actually came with Python 3.3. For earlier versions, especially Python 2, you would need to do that manually by looping over the items and yielding them again:</p>
<pre><code>def example (iterable):
    a, b = tee(iterable)
    next(b, None)
    for x in zip_longest(a, b):
        yield x
    yield (None, None)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>You can create a generator:</p>
<pre><code>def pairwise(iterable, additional=None):
    iterable = iter(iterable)
    first, second = next(iterable), next(iterable)
    while 1:
        yield first,second
        try:
            first,second = second, next(iterable)
        except TypeError:
            yield second, additional
            break
</code></pre>
<p>Results:</p>
<pre><code>&gt;&gt;&gt; list(pairwise([1,2,3], 'a'))
[(1, 2), (2, 3), (3, 'a')]
&gt;&gt;&gt; list(pairwise('abc', 'a'))
[('a', 'b'), ('b', 'c'), ('c', 'a')]
&gt;&gt;&gt; list(pairwise('abcd', 'a'))
[('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'a')]
</code></pre>
<p>For an infinite iterable:</p>
<pre><code>&gt;&gt;&gt; a = pairwise(infi(), 6)
&gt;&gt;&gt; for i in range(10):
...     print(next(a))
...
(0, 1)
(1, 2)
(2, 3)
(3, 0)
(0, 1)
(1, 2)
(2, 3)
(3, 0)
(0, 1)
(1, 2)
</code></pre>
</div>
<span class="comment-copy">Downvote because...?</span>
