<div class="post-text" itemprop="text">
<p>A simple recursive factorial method works perfectly:</p>
<pre><code>def fact(n):
    if n == 0:
        return 1
    return n * fact(n-1)
</code></pre>
<p>But I wanted to experiment a little and use a <code>dict</code> instead. Logically, this should work, but a bunch of print statements tell me that <code>n</code>, instead of stopping at <code>0</code>, glides down across the negative numbers until the maximum recursion depth is reached:</p>
<pre><code>def recursive_fact(n):
    lookup = {0: 1}
    return lookup.get(n, n*recursive_fact(n-1))
</code></pre>
<p>Why is that?</p>
</div>
<div class="post-text" itemprop="text">
<p><strong>Python doesn't lazily evaluate parameters.</strong></p>
<p>The default value passed to <code>dict.get</code> call will also be evaluated before calling the <code>dict.get</code>.</p>
<p>So, in your case, the default value has a recursive call and since your condition is never met, it does infinite recursion.</p>
<p>You can confirm this, with this program</p>
<pre><code>&gt;&gt;&gt; def getter():
...     print("getter called")
...     return 0
... 
&gt;&gt;&gt; {0: 1}.get(0, getter())
getter called
1
</code></pre>
<p>Even though the key <code>0</code> exists in the dictionary, since all parameters passed to functions in Python will be evaluated, <code>getter</code> is also invoked, before the actual <code>dict.get</code> is made.</p>
<hr/>
<p>If all you want to do is to avoid multiple recursive evaluations when the values are already evaluated, then you use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache"><code>functools.lru_cache</code></a>, if you are using Python 3.2+</p>
<pre><code>&gt;&gt;&gt; @functools.lru_cache()
... def fact(n):
...     print("fact called with {}".format(n))
...     if n == 0:
...         return 1
...     return n * fact(n-1)
... 
&gt;&gt;&gt; fact(3)
fact called with 3
fact called with 2
fact called with 1
fact called with 0
6
&gt;&gt;&gt; fact(4)
fact called with 4
24
</code></pre>
<p>This decorator simply caches the results for the parameters passed and if the same call is made again, it will simply return the value from the cache.</p>
<hr/>
<p>If you want to fix your custom caching function to work, then you need to define the <code>look_up</code> outside the function, so that it will not be created whenever the function is called.</p>
<pre><code>&gt;&gt;&gt; look_up = {0: 1}
&gt;&gt;&gt; def fact(n):
...     if n not in look_up:
...         print("recursing when n is {}".format(n))
...         look_up[n] = n * fact(n - 1)
...     return look_up[n]
... 
&gt;&gt;&gt; fact(3)
recursing when n is 3
recursing when n is 2
recursing when n is 1
6
&gt;&gt;&gt; fact(4)
recursing when n is 4
24
&gt;&gt;&gt; fact(4)
24
</code></pre>
<p>Otherwise you can use the default parameter, like this</p>
<pre><code>&gt;&gt;&gt; def fact(n, look_up={0: 1}):
...     if n not in look_up:
...         print("recursing when n is {}".format(n))
...         look_up[n] = n * fact(n - 1)
...     return look_up[n]
</code></pre>
</div>
<span class="comment-copy">Oh, I get it. So the <code>default=</code> argument gets evaluated even if the first condition is met. Seems a little counterintuitive, but at least my problem is solved. Thanks!</span>
<span class="comment-copy">@shooqie Actually, before calling <code>.get</code> function itself, Python should know the actual values to be passed. So, it will evaluate all the expressions passed as parameters. In your case, one of the expressions happen to be recursive call and it simply does that, before even calling <code>.get</code></span>
<span class="comment-copy">@shooqie Do you come from a functional programming background? From an imperative point of view, it is mandatory that all arguments must be evaluated before a function can be called.</span>
<span class="comment-copy">@Jasper Is that question for me? Since OP expected that the default parameter will not be evaluated until it is used, I assumed that OP is familiar with the lazy evaluation of parameters in other languages.</span>
<span class="comment-copy">It is properly tagged now, I was asking OP.</span>
