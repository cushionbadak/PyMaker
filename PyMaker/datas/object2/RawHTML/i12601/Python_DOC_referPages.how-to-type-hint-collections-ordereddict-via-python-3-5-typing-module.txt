<div class="post-text" itemprop="text">
<p>I want to use an OrderedDict where the key is a Enum and where the item is a certain class. </p>
<p>How do I use the typing module to hint this?
What is the analog to this hinted namedtuple::</p>
<pre><code>Move = typing.NamedTuple('Move', [('actor', Actor), ('location', Location)])
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>As noted in a comment by AChampion, you can use <code>MutableMapping</code>:</p>
<pre><code>class Actor(Enum):
    # ...Actor enum menbers...

class Location:
    # ...Location class body...

class MapActor2Location(OrderedDict, MutableMapping[Actor, Location]):
    pass
</code></pre>
<hr/>
<p>Addendum for people like me who haven't used the <code>typing</code> module before: note that the type definitions use indexing syntax (<code>[T]</code>) <strong>without</strong> parentheses. I initially tried something like this:</p>
<pre><code>class MyMap(OrderedDict, MutableMapping([KT, VT])): pass
</code></pre>
<p>(Note the extraneous parentheses around <code>[KT, VT]</code>!)</p>
<p>This gives what I consider a rather confusing error:</p>
<pre><code>TypeError: Can't instantiate abstract class MutableMapping with abstract methods __delitem__, __getitem__, __iter__, __len__, __setitem__
</code></pre>
</div>
<span class="comment-copy">But if I do that, how is YourDict an OrderedDict?</span>
<span class="comment-copy">You could use <code>typing.MutableMapping</code>, if you need a specific type for OrderedDict you would have to create it <code>class OrderedDictType(OrderedDict, MutableMapping[KT, VT])</code></span>
<span class="comment-copy">For the addendum, I realize that there's no good reason why parentheses would make any sense where I put them, but the fact remains that that's what my fingers produced without me really even noticing, and the error message wasn't <i>quite</i> as helpful as I'd have liked. I went down the rabbit hole of <code>abc</code>'s "virtual subclasses" before figuring out I'd made a basic syntax mistake.</span>
<span class="comment-copy">Inheriting from <code>MutableSequence</code> makes no sense, as this type is not a sequence, and the mapping and sequence APIs are incompatible.</span>
<span class="comment-copy">@user2357112 The <i>entire point</i> of an <code>OrderedDictionary</code> is to be a sequentially iterable type with guaranteed iteration order (unlike a normal <code>dict</code>). This is how a sequence <a href="https://docs.python.org/3/glossary.html#term-sequence" rel="nofollow noreferrer">is defined by <code>abc</code></a>. And, again, note that this is confirmed by the error that occurs when you <i>don't</i> inherit from <code>MutableSequence</code>.</span>
<span class="comment-copy">@user2357112 I've edited the answer to explain why <code>MutableSequence</code> is necessary.</span>
<span class="comment-copy">Also, <a href="http://ideone.com/ZcTC3G" rel="nofollow noreferrer">no <code>MutableSequence</code>, no error!</a></span>
