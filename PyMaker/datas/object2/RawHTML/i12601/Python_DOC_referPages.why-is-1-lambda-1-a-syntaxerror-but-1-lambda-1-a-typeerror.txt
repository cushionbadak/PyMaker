<div class="post-text" itemprop="text">
<p>In the interactive interpeter the following two expressions raise different errors depending on the addition of parenthesis:</p>
<blockquote>
<p><code>1 + lambda: 1</code> results in a <code>SyntaxError</code> </p>
</blockquote>
<pre><code>&gt;&gt;&gt; 1 + lambda: 1
  File "&lt;ipython-input-17-ae284d908963&gt;", line 1
     1 + lambda: 1
              ^
SyntaxError: invalid syntax
</code></pre>
<blockquote>
<p><code>1 + (lambda: 1)</code> results in a <code>TypeError</code></p>
</blockquote>
<pre><code>&gt;&gt;&gt;&gt; 1 + (lambda: 1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'function'
</code></pre>
<p>I understand the differences <code>SyntaxError</code> and <code>TypeError</code>, that is, what they essentially mean, but I don't really understand why exactly this happens. </p>
<p>I have tried <a href="https://docs.python.org/3/reference/expressions.html" rel="nofollow">reading</a> <strong><a href="https://hg.python.org/cpython/file/tip/Grammar/Grammar" rel="nofollow">the Grammar</a></strong>, but it really is all Greek to me. The <code>expr</code> (which I would of though denotes expressions) is defined as:</p>
<pre><code>expr: xor_expr ('|' xor_expr)*
</code></pre>
<p>While lambdas:</p>
<pre><code>lambdef: 'lambda' [varargslist] ':' test
</code></pre>
<p>These did not help much. The same applies for Python 2.x and for 3.x. So, why do parenthesis do that alters the exception result in this context?</p>
</div>
<div class="post-text" itemprop="text">
<blockquote>
<p>Why does <code>1 + lambda: 1</code> raise a <code>SyntaxError</code> ?</p>
</blockquote>
<p>The syntax error is raised because the grammar doesn't support it. From the <a href="https://docs.python.org/3/reference/grammar.html" rel="nofollow">Full Grammar Specification</a> we can see that the <code>test</code> rule, which <a href="http://effbot.org/zone/simple-top-down-parsing.htm" rel="nofollow">is the basic expression element</a> <em>and not the ill-named <code>expr</code></em>, has the form of:</p>
<pre><code>test: or_test ['if' or_test 'else' test] | lambdef
test_nocond: or_test | lambdef_nocond
</code></pre>
<p>where <a href="https://docs.python.org/3/reference/introduction.html#notation" rel="nofollow">the vertical bar <code>|</code> is used to seperate alternative substitutions for this rule</a>. </p>
<p>As a result, each expression must either begin with an <strong><a href="https://docs.python.org/3/reference/expressions.html#boolean-operations" rel="nofollow"><code>or_test</code></a></strong> <strong>or</strong> a <strong><a href="https://docs.python.org/3/reference/expressions.html#lambda" rel="nofollow"><code>lambdadef</code></a></strong>. If a <code>lambdadef</code> is not found in the beginning of an expression a <code>SyntaxError</code> is appropriately raised during parsing:</p>
<pre><code>&gt;&gt;&gt; import parser; parser.expr('1 + lambda: 1') 
# SyntaxError: invalid syntax
</code></pre>
<p>[<strong>Note</strong>: From the <code>or_test</code> member of <code>test</code> we can generate practically every other expression in Python by substitutions]</p>
<hr/>
<blockquote>
<p>Why does <code>1 + (lambda: 1)</code> raise a <code>TypeError</code> ?</p>
</blockquote>
<p>Because parenthesis are used as <a href="https://docs.python.org/3/reference/expressions.html#atoms" rel="nofollow"><code>enclosures</code></a>:</p>
<pre><code>enclosure ::=  parenth_form | list_display | dict_display | set_display
               | generator_expression | yield_atom
</code></pre>
<p>where <strong><a href="https://docs.python.org/3/reference/expressions.html#grammar-token-parenth_form" rel="nofollow"><code>parenth_form</code></a></strong> is:</p>
<pre><code>parenth_form ::=  "(" [expression_list] ")"
</code></pre>
<p>The parenthesis here will isolate the <code>lambda: 1</code> from the rest of the expression and confine it in an expression (<code>test</code>) of its own. Since the new expression is <code>(lambda: 1)</code> it is syntactically valid (<em>since <code>lambdadef</code> is an element at the beginning of the expression</em>). As such, there is no rule which can trigger a <code>SyntaxError</code>. (if you did <code>1 + (1 + lambda: 1)</code> the same <code>SyntaxError</code> is triggered).</p>
<p>Additionally, we can actually verify the fact that <code>(lambda: 1)</code> is a new <code>test</code> rule by looking at (<em>the relevant section</em>) of the list-based parse tree and cross-referencing it with the numbers contained in <strong><a href="https://hg.python.org/cpython/file/tip/Include/graminit.h" rel="nofollow"><code>Include/graminit.h</code></a></strong>. </p>
<p>We can generate the parse tree from:</p>
<pre><code>&gt;&gt;&gt; parse_tree = parser.expr("1 + (lambda: 1)")
&gt;&gt;&gt; parse_tree.tolist()

# further up the list, another [304, exists, denoting the 
# 'outer' expression

#.. snipped ..
            [323,
             [7, '(', 1, 4],
             [324,
              [304,   # &lt;-- indicating new expression
               [306,
                [1, 'lambda', 1, 5],
                [11, ':', 1, 11],
#.. snipped ..
</code></pre>
<p>and by viewing the <a href="https://hg.python.org/cpython/file/tip/Include/graminit.h#l51" rel="nofollow">definition for <code>test</code></a> we can see that <code>304</code> defines a new <code>test</code>.</p>
<p>As a result, the expression will be parsed and consequently compiled with no issues:</p>
<pre><code>&gt;&gt;&gt; code_obj = parse_tree.compile()
</code></pre>
<p>It is during execution were the evaluation will happen and Python will discover that addition is unsupported for the objects of <code>int</code> and <code>function</code>. When it discovers it, a <code>TypeError</code> is raised: </p>
<pre><code>&gt;&gt;&gt; exec(code_obj)
# TypeError: unsupported operand type(s) for +: 'int' and 'function'
</code></pre>
</div>
