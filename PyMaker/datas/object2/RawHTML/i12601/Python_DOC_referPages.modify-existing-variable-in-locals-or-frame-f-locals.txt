<div class="post-text" itemprop="text">
<p>I have found some vaguely related questions to this question, but not any clean and specific solution for CPython. And I assume that a "valid" solution is interpreter specific.</p>
<p>First the things I think I understand:</p>
<ul>
<li><code>locals()</code> gives a non-modifiable dictionary.</li>
<li>A function may (and indeed does) use some kind of optimization to access its local variables</li>
<li><code>frame.f_locals</code> gives a <code>locals()</code> like dictionary, but less prone to hackish things through <code>exec</code>. Or at least I have been less able to do hackish undocumented things like the <code>locals()['var'] = value ; exec ""</code></li>
<li><code>exec</code> is capable to do weird things to the local variables, but it is not reliable --e.g. I read somewhere that it doesn't work in Python 3. Haven't tested.</li>
</ul>
<p>So I understand that, given those limitations, it will never be safe to <em>add</em> extra variables to the locals, because it breaks the interpreter structure.</p>
<p>However, it should be possible to change a variable already existing, isn't it?</p>
<p>Things that I considered</p>
<ul>
<li>In a function <code>f</code>, one can access the <code>f.func_code.co_nlocals</code> and <code>f.func_code.co_varnames</code>.</li>
<li>In a frame, the variables can be accessed / checked / read through the <code>frame.f_locals</code>. This is in the use case of setting a tracer through <code>sys.settrace</code>.</li>
<li>One can easily access the function in which a frame is --cosidering the use case of setting a trace and using it to "do things" in with the local variables given a certain trigger or whatever.</li>
</ul>
<p>The variables should be somewhere, preferably writeable... but I am not capable of finding it. Even if it is an array (for interpreter efficient access), or I need some extra C-specific wiring, I am ready to commit to it.</p>
<p>How can I achieve that modification of variables from a tracer function or from a decorated wrapped function or something like that?</p>
<p>A full solution will be of course appreciated, but even some pointers will help me greatly, because I'm stuck here with lots of non writeable dictionaries :-/</p>
<hr/>
<p>Edit: Hackish <code>exec</code> is doing things like <a href="https://stackoverflow.com/a/1450341/1433901">this</a> or <a href="https://stackoverflow.com/a/8028785/1433901">this</a></p>
</div>
<div class="post-text" itemprop="text">
<p>It exists an undocumented C-API call for doing thigs like that:</p>
<p><code>PyFrame_LocalsToFast</code></p>
<p>There is some more discussion in <a href="http://pydev.blogspot.com.es/2014/02/changing-locals-of-frame-frameflocals.html" rel="nofollow">this PyDev blog post</a>. The basic idea seems to be:</p>
<pre><code>import ctypes

...

frame.f_locals.update({
    'a': 'newvalue',
    'b': other_local_value,
})
ctypes.pythonapi.PyFrame_LocalsToFast(
    ctypes.py_object(frame), ctypes.c_int(0))
</code></pre>
<p>I have yet to test if this works as expected.</p>
<p>Note that there might be some way to access the <code>Fast</code> directly, to avoid an indirection if the requirements is only modification of existing variable. But, as this seems to be mostly non-documented API, source code is the documentation resource.</p>
</div>
<div class="post-text" itemprop="text">
<p>Based on the notes from MariusSiuram, I wrote a recipe that show the behavior.</p>
<p>The conclusions are:</p>
<ol>
<li>we can modify an existing variable</li>
<li>we can delete an existing variable</li>
<li>we can NOT add a new variable.</li>
</ol>
<p>So, here is the code:</p>
<pre><code>import inspect
import ctypes

def parent():
    a = 1
    z = 'foo'

    print('- Trying to add a new variable ---------------')
    hack(case=0)  # just try to add a new variable 'b'
    print(a)
    print(z)
    assert a == 1
    assert z == 'foo'

    try:
        print (b)
        assert False  # never is going to reach this point
    except NameError, why:
        print("ok, global name 'b' is not defined")

    print('- Trying to remove an existing variable ------')
    hack(case=1)
    print(a)
    assert a == 2
    try:
        print (z)
    except NameError, why:
        print("ok, we've removed the 'z' var")

    print('- Trying to update an existing variable ------')
    hack(case=2)
    print(a)
    assert a == 3


def hack(case=0):
    frame = inspect.stack()[1][0]
    if case == 0:
        frame.f_locals['b'] = "don't work"
    elif case == 1:
        frame.f_locals.pop('z')
        frame.f_locals['a'] += 1
    else:
        frame.f_locals['a'] += 1

    # passing c_int(1) will remove and update variables as well
    # passing c_int(0) will only update
    ctypes.pythonapi.PyFrame_LocalsToFast(
        ctypes.py_object(frame),
        ctypes.c_int(1))

if __name__ == '__main__':
    parent()
</code></pre>
<p>The output would be like:</p>
<pre><code>- Trying to add a new variable ---------------
1
foo
ok, global name 'b' is not defined
- Trying to remove an existing variable ------
2
foo
- Trying to update an existing variable ------
3
</code></pre>
</div>
<span class="comment-copy">The dictionary returned by <code>locals()</code> can be modified: you are doing it in your example! And what's "hackish and undocumented" in <code>locals()['var'] = value ; exec ""</code> ? What's the point of exec-ing an empty string? And why does <code>exec</code> do weird things? In Python 3 <code>exec</code> is simply a function (like <code>print</code>), nothing special</span>
<span class="comment-copy">it looks like <a href="http://meta.stackexchange.com/q/66377/137096">XY problem</a>. What is your actual issue? Provide more context. To change a local variable e.g., a list <code>x</code>, just call its methods:<code>x.append("something")</code> or <code>a = 1</code> "changes" local variable <code>a</code> to <code>1</code>.</span>
<span class="comment-copy">@AndreaCorbellini According to <a href="https://docs.python.org/3/library/functions.html?highlight=locals#locals" rel="nofollow noreferrer">official documentation</a>: <b>Note</b> The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.  -- And you may find some questions that take about it, like <a href="http://stackoverflow.com/a/5958992/1433901">this answer</a></span>
<span class="comment-copy">Why don't you just store your variables in a dict? Or <code>if change=='a': a=v; elif change=='b'...</code></span>
<span class="comment-copy">@J.F.Sebastian I would like a technical answer. However, a plausible use case would be an automatic checkpointing framework. Which is capable to (through <code>trace</code> functions) store the state of locals and globals and proceed to resume execution in a certain point (line number) while leaving the locals and globals "correct". Specially critical if there are lines with side effects which the framework wants to avoid executing again.</span>
