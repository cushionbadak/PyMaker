<div class="post-text" itemprop="text">
<p>I have a list of numbers and I'm trying to write a function that will choose n random indices i such i's likelihood is percentages[i]</p>
<p>Function:</p>
<pre><code>def choose_randomly(probabilities, n):
    percentages = accumulated_s(probabilities)
    result = []
    for i in range(n):
        r = random()
        for j in range(n):
            if r &lt; percentages[j]:
                result = result + [j]
    return result
</code></pre>
<p>accumulated_s will just generate a corresponding list of probabilities. </p>
<p>I'm expecting results like this:</p>
<pre><code>choose_randomly([1, 2, 3, 4], 2) -&gt; [3 3 0]
choose_randomly([1, 2, 3, 4], 2) -&gt; [1 3 1] 
</code></pre>
<p>The problem is that this is not returning n indicies. Can anyone point out what I'm doing wrong? 
Thank you so much!</p>
</div>
<div class="post-text" itemprop="text">
<p>Once you've found the right range of probabilities, you're done; <code>break</code> out of the inner loop to generate the next value, or you'll act as if all probabilities above the correct threshold were matched as well:</p>
<pre><code>    # Enumerate all percentages, not just first n
    for j, pct in enumerate(percentages):
        if r &lt; pct:
            result.append(j)  # Don't create tons of temporary lists; mutate in place
            break  # &lt;-- Don't add more results
</code></pre>
<p>Also note, if you have a lot of values in the set of probabilities, it may make sense to use functions from the <a href="https://docs.python.org/3/library/bisect.html" rel="nofollow"><code>bisect</code> module</a> to find the correct value, rather than scanning linearly each time; for a small number of entries in <code>percentages</code>, linear scanning is fine, but for a large number, <code>O(log n)</code> lookups may beat <code>O(n)</code> scans.</p>
</div>
<span class="comment-copy">this question has been asked many times. See "Related" in the right.</span>
<span class="comment-copy">Thank you so much. Is there any ways to make it generate exactly n indicies though? I edited the code and it works fine, but it does not generate exactly n elements.</span>
<span class="comment-copy">If you <code>break</code> correctly in the inner loop, the other loop should cover it. Only reason it wouldn't is if the values in <code>percentages</code> were wrong. As written, you'd want ascending cumulative percentages, e.g. <code>[0.1, 0.3, 0.7, 1.0]</code>. If it doesn't end with <code>1.0</code> or higher, you'd drop data when the random value generated exceeded the highest value in <code>percentages</code>.</span>
<span class="comment-copy">Oh, and on rechecking, looks like you were iterating <code>percentages</code> wrong (stopping after <code>n</code> checks, instead of checking the whole sequence). I've fixed that in my answer (and used <code>enumerate</code> so you'd getting values and indices at once to save work).</span>
<span class="comment-copy">Ok, I got it! thank you!</span>
