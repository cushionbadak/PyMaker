<div class="post-text" itemprop="text">
<p>Let's consider any user-defined pythonic class. If I call <code>dir(obect_of_class)</code>, I get the list of its attributes:</p>
<pre><code>['__class__', '__delattr__', '__dict__', '__dir__', ... '__weakref__', 'bases', 
'build_full_name', 'candidates', ... 'update_name'].
</code></pre>
<p>You can see 2 types of attributes in this list:</p>
<ul>
<li>built-in attributes, </li>
<li>user defined.</li>
</ul>
<p>I need to override <code>__dir__</code> so, that it will return only user defined attribltes. How I can do that? </p>
<p>It is clear, that if in overridden function I call itself, it gives me infinite recursion. So, I want to do somethig like this:</p>
<pre><code>def __dir__(self):
        return list(filter(lambda x: not re.match('__\S*__', x), dir(self)))
</code></pre>
<p>but evade the infinite recursion.</p>
<p>In general, how can I modify a built-in function if I don't want to write it from scratch but want to modify the existing function?</p>
</div>
<div class="post-text" itemprop="text">
<p>Use <a href="https://docs.python.org/3/library/functions.html#super"><code>super</code></a> to call parent's implementation of <code>__dir__</code>; avoid the recursion:</p>
<pre><code>import re


class AClass:

    def __dir__(self):
        return [x for x in super().__dir__() if not re.match(r'__\S+__$', x)]

    def method(self):
        pass
</code></pre>
<hr/>
<pre><code>&gt;&gt;&gt; dir(AClass())
['method']
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Do you want to do it on your custom class or globally for <code>dir()</code> function?</p>
<p>First approach (class-only):</p>
<pre><code>class MyClass:
    def f(self):
        return None

    def __dir__(self):
        return list(filter(lambda x: not re.match('__\S*__', x), super().__dir__()))


print(dir(MyClass()))  # ['f'] 
</code></pre>
<p>Basically what's done here is calling <code>__dir__()</code> of superclass (not class itself) and filtering it in subclass.</p>
<p>Second approach (shadowing global dir function):</p>
<pre><code>import re


def dir(obj):
    return list(filter(lambda x: not re.match('__\S*__', x), __builtins__.dir(obj)))

print(dir({}))  # ['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
</code></pre>
<p>Here all calls to <code>dir()</code> would be filtered. As you can see - it'll work for all types, including built-in types.</p>
</div>
<span class="comment-copy">Did you try using <code>dir(ClassName)</code> instead?</span>
<span class="comment-copy">Why using generators is better than using <code>list(filter...))</code>?</span>
<span class="comment-copy">@VeLKerr, It's not a generator, but a list comprehension. For me, it's a lot easier to read.</span>
<span class="comment-copy">Ok, it's working, but it's very strange because <code>super()</code>-object hasn't user defined fields. So, could you explain, <i>why</i> it's working?</span>
<span class="comment-copy">@VeLKerr, Please follow the link the answer. <a href="https://docs.python.org/3/library/functions.html#super" rel="nofollow noreferrer"><code>super</code></a>.</span>
<span class="comment-copy">I want to override <code>__dir()__</code> only for my class, but thanks a lot for the explanation of the global shadowing. P.S. <code>super()</code> works for me even without arguments (I edited the post).</span>
