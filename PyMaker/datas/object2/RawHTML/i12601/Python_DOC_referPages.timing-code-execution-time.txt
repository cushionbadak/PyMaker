<div class="post-text" itemprop="text">
<p>So, I am interested in timing some of the code I am setting up. Borrowing a timer function from the 4th edition of <em>Learning Python</em>, I tried:</p>
<pre><code>import time
reps = 100
repslist = range(reps)

def timer(func):
    start = time.clock()
    for i in repslist:
        ret = func()
    elasped = time.clock()-start
    return elapsed
</code></pre>
<p>Then, I paste in whatever I want to time, and put:</p>
<pre><code>print(timer(func))    #replace func with the function you want to time
</code></pre>
<p>When I run it on my code, I do get an answer, but it's nonsense. Suspecting something was wrong, I put a <code>time.sleep(0.1)</code> call in my code, and got a result of <code>0.8231</code></p>
<p>Does anybody know why this might be the case or how to fix it? I suspect that the <code>time.clock()</code> call might be at fault.</p>
</div>
<div class="post-text" itemprop="text">
<p>According to the help docs for <code>clock</code>:</p>
<blockquote>
<p>Return the CPU time or real time since the start of the process or since the first call to clock().  This has as much precision as the system records.</p>
</blockquote>
<p>The second call to <code>clock</code> already returns the elapsed time between it and the first <code>clock</code> call. You don't need to manually subtract <code>start</code>.</p>
<p>Change</p>
<pre><code>elasped = time.clock()-start
</code></pre>
<p>to</p>
<pre><code>elasped = time.clock()
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you want to timer a function perhaps give decorators a try(documentation <a href="https://docs.python.org/2/reference/compound_stmts.html#function" rel="nofollow">here</a>):</p>
<pre><code>import time

def timeit(f):    
    def timed(*args, **kw):
        ts = time.time()
        result = f(*args, **kw)
        te = time.time()
        print 'func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts)
        return result
    return timed
</code></pre>
<p>Then when you write a function you just use the decorator, here:</p>
<pre><code>@timeit
def my_example_function():
    for i in range(10000):
        print "x"
</code></pre>
<p>This will print out the time the function took to execute:</p>
<blockquote>
<p>func:'my_example_function' args:[(), {}] took: 0.4220 sec</p>
</blockquote>
</div>
<div class="post-text" itemprop="text">
<p>After fixing the typo in the first intended use of <code>elapsed</code>, your code works fine with either <code>time.clock</code> or <code>time.time</code> (or Py3's <code>time.monotonic</code> for that matter) on my Linux system.</p>
<p>The difference would be in the (OS specific) behavior for <code>clock</code>; on most UNIX-like OSes it will return the processor time used by the program since it launched (so time spent blocked, on I/O, locks, page faults, etc. wouldn't count), while on Windows it's a wall clock timer (so time spent blocked would count) that counts seconds since first call.</p>
<p>The UNIX-like version of <code>time.clock</code> is also fairly unreliable if used in a long running program when <code>clock_t</code> is only 32 bits; the value it returns will wrap roughly every 72 minutes of processor time.</p>
<p>Of course, <code>time.time</code> isn't perfect either; it follows the system clock, so an NTP time update (or any other change to the system clock) occurring between calls will give erroneous results (on Python 3.3+, you'd use <code>time.monotonic</code> to avoid this problem). It's also not guaranteed to have granularity finer than 1 second, so if your function doesn't take an awfully long time to run, on a system with low res <code>time.time</code> you won't get particularly useful results.</p>
<p>Really, you should be looking at the Python batteries designed for this (that also handle issues like garbage collection overhead and the like). The <a href="https://docs.python.org/3/library/timeit.html" rel="nofollow"><code>timeit</code> module</a> already has a function that does what you want, but handles all the edge cases and issues I mentioned. For example, to time some global function named <code>foo</code> for 100 reps, you'd just do:</p>
<pre><code>import timeit

def foo():
    ...

print(timeit.timeit('foo()', 'from __main__ import foo', number=100))
</code></pre>
<p>It fixes most of the issues I mention by selecting the best timing function for the OS you're on (and also fixes other sources of jitter, e.g. cyclic garbage collection, which is disabled during the test and reenabled at the end).</p>
<p>Even if you don't want to use that for some reason, if you're using Python 3.3 or higher, take a look at the replacements for <code>time.clock</code>, e.g. <a href="https://docs.python.org/3/library/time.html#time.perf_counter" rel="nofollow"><code>time.perf_counter</code></a> (includes time spent sleeping) or <a href="https://docs.python.org/3/library/time.html#time.process_time" rel="nofollow"><code>time.process_time</code></a> (includes only CPU time), both of which are portable, reliable, fast, and high resolution for better accuracy.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>time.sleep()</code> will terminate for any signal. read about it here ...</p>
<p><a href="http://www.tutorialspoint.com/python/time_sleep.htm" rel="nofollow">http://www.tutorialspoint.com/python/time_sleep.htm</a></p>
</div>
<span class="comment-copy">did you tried using <code>time.time()</code> instead?</span>
<span class="comment-copy">Is this your actual code? I tried running it and got <code>NameError: global name 'elapsed' is not defined</code>. Please post the code that you're actually running.</span>
<span class="comment-copy">time.time() works, my code now functions properly.</span>
<span class="comment-copy">I used the time.time() solution suggested above, but now I know what the problem with time.clock() was.</span>
<span class="comment-copy">@Kevin: If it's returning the time since start of process, or <code>clock</code> was called anywhere else in the program (or libraries it uses), then you'd still want to subtract the <code>start</code> time; if <code>start</code> happened to be <code>0</code>, so be it, no harm done (at worst you've added the overhead of an extra byte code or two to the timed block), but if it wasn't, you'd have timed a lot of stuff unrelated to what you're testing.</span>
