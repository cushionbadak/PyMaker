<div class="post-text" itemprop="text">
<p>Good day. I'm trying to solve problem with logging in Python. I'm using Python 3.5.1. I have application, which using a class, imported from other module. I can't enable logging for it. This is a simple representation:</p>
<pre><code># test.py
import logging

from test_class import TestClass


logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(logging.FileHandler('test_log.log', mode='w'))


if __name__ == '__main__':
    logger.info('Importing class')
    t = TestClass()
    t.make_call()
    t.make_another_call()
    logger.info('End')

# test_class.py
import logging


class TestClass(object):

    def __init__(self):
        self.logger = logging.getLogger('test_class.TestClass')

    def make_call(self):
        self.logger.info('Make a call')

    def make_another_call(self):
        self.logger.info('Make another call')
</code></pre>
<p>As you see, logger must wrote to file for lines (two from main module, and two from class. But when I've open log file, I see:</p>
<pre><code># test_log.log
Importing class
End
</code></pre>
<p>So, two logger calls from class didn't have an effect. Any idea, why it's don't work? Thank you in advance.</p>
</div>
<div class="post-text" itemprop="text">
<p>From <a href="https://docs.python.org/3/library/logging.html#logger-objects" rel="nofollow">the docs</a>:</p>
<blockquote>
<p>Multiple calls to getLogger() with the same name will always return a reference to the same Logger object.</p>
<p>The name is potentially a period-separated hierarchical value, like foo.bar.baz (though it could also be just plain foo, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of foo, loggers with names of foo.bar, foo.bar.baz, and foo.bam are all descendants of foo. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction <code>logging.getLogger(__name__)</code>. That’s because in a module, <code>__name__</code> is the module’s name in the Python package namespace.</p>
</blockquote>
<p>The way you call <code>getLogger</code> in your code, the call in <code>test.py</code> is done with <code>__main__</code> and the call in <code>test_class.py</code> is done with <code>test_class</code>, so the latter is not a descendant of the former.</p>
<p>Instead, if, when you set up the handler, you do it on an object you got from calling <code>getLogger()</code> with no argument you will be  setting up the handler on the root logging object and all other calls to <code>getLogger()</code> will be further down the hierarchy and will use the handler you specify. </p>
<p>If you want to continue to have the name set for your logging statements in the main module, you can just call <code>getLogger</code> again after you've set up the handler.</p>
<p>For example:</p>
<pre><code># Call getLogger with no args to set up the handler
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
logger.addHandler(logging.FileHandler('test_log.log', mode='w'))


if __name__ == '__main__':
    # call getLogger again with a name to tag subsequent log statements
    logger = logging.getLogger(__name__)
    logger.info('Importing class')
    t = TestClass()
    t.make_call()
    t.make_another_call()
    logger.info('End')
</code></pre>
</div>
<span class="comment-copy">Thank you so much! Work like a charm. :-)</span>
