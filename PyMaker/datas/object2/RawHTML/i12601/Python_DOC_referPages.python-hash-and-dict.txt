<div class="post-text" itemprop="text">
<p>If we have 2 separate <code>dict</code>, both with the same <code>keys</code> and <code>values</code>, when we print them it will come in different orders, as expected.<br/>
So, let's say I want to to use <code>hash()</code> on those <code>dict</code>:  </p>
<pre><code>hash(frozenset(dict1.items()))
hash(frozenset(dict2.items()))
</code></pre>
<p>I'm doing this to make a new <code>dict</code> with the <code>hash()</code> value created as the new keys .<br/>
Even showing up different when printing <code>dict</code>, the value createad by <code>hash()</code> will always be equal? If no, how to make it always the same so I can  make comparisons successfully?</p>
</div>
<div class="post-text" itemprop="text">
<p>If the keys and values <code>hash</code> the same, <code>frozenset</code> is designed to be a stable and unique representation of the underlying values. <a href="https://docs.python.org/3/library/stdtypes.html#frozenset" rel="nofollow">The docs explicitly state</a>:</p>
<blockquote>
<p>Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other).</p>
</blockquote>
<p>And <a href="https://docs.python.org/3/glossary.html#term-hashable" rel="nofollow">the rules for hashable types require that</a>:</p>
<blockquote>
<p>Hashable objects which compare equal must have the same hash value.</p>
</blockquote>
<p>So by definition <code>frozenset</code>s with equal, hashable elements are equal and hash to the same value. This can only be violated if a user-defined class which does not obey the rules for hashing and equality is contained in the resulting <code>frozenset</code> (but then you've got bigger problems).</p>
<p>Note that this does not mean they'll iterate in the same order or produce the same <code>repr</code>; thanks to chaining on hash collisions, two <code>frozenset</code>s constructed from the same elements in a different order need not iterate in the same order. But they're still equal to one another, and hash the same (precise outputs and ordering is implementation dependent, could easily vary between different versions of Python; this just happens to work on my Py 3.5 install to create the desired "different iteration order" behavior):</p>
<pre><code>&gt;&gt;&gt; frozenset([1,9])
frozenset({1, 9})
&gt;&gt;&gt; frozenset([9,1])
frozenset({9, 1}) # &lt;-- Different order; consequence of 8 buckets colliding for 1 and 9
&gt;&gt;&gt; hash(frozenset([1,9]))
-7625378979602737914
&gt;&gt;&gt; hash(frozenset([9,1]))
-7625378979602737914 # &lt;-- Still the same hash though
&gt;&gt;&gt; frozenset([1,9]) == frozenset([9,1])
True # &lt;-- And still equal
</code></pre>
</div>
<span class="comment-copy">So, consider <code>key1</code> from the 1st line and <code>key2</code> from the 2nd. If I make <code>if (key1 == key1)</code> will always be true? Just making sure, sorry bout my lack of experience.</span>
<span class="comment-copy">Why would they come in different orders? There's no randomness in hashing <i>or</i> dictionary insertion right?</span>
<span class="comment-copy">Well, <code>dicts</code> don't have a specified order right? I'm wondering if this can change the <code>hash</code> value</span>
<span class="comment-copy">@JayanthKoushik: Order can change for <code>dict</code>s with the same keys if there are hash collisions, and the history of the <code>dict</code>s differs. If you insert two objects with the same hash (after cut down to match number of buckets) into a <code>dict</code> (or <code>set</code>/<code>frozenset</code>), <code>a</code> and <code>b</code>, and in a different collection, insert <code>b</code> then <code>a</code>, then the relative ordering of those two items will differ. And it's even more complex if values are deleted, not just added, thanks to dummy placeholders used to ensure chained values aren't lost. Simple example in <a href="http://stackoverflow.com/a/34605784/364696">my answer</a>.</span>
<span class="comment-copy">@AdrianoFerrariCardoso: It can't. As noted in <a href="http://stackoverflow.com/a/34605784/364696">my answer</a>, <code>frozenset</code> and hashable guarantees ensure that the hash is consistent, even though ordering might differ depending on how the <code>frozenset</code> is constructed.</span>
