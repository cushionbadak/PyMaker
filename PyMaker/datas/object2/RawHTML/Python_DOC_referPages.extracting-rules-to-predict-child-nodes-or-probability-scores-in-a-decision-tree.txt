<div class="post-text" itemprop="text">
<p>I am relatively new to Python implementation of Decision Tree.  I am trying to extract rules to predict only child nodes and I need it to be able to predict probability scores (not just final classification) for new data and possibly transfer the algorithm to the other users.  Is there an easy way to do it?  I found some solutions at (<a href="https://stackoverflow.com/questions/20224526/how-to-extract-the-decision-rules-from-scikit-learn-decision-tree">How to extract the decision rules from scikit-learn decision-tree?</a>).  However, when I test them, I am not obtaining all of my child nodes for some reason (My tree is very large and deep).  Any advice is appreciated.  Thank you.  </p>
<p>I have updated the first code in the link above to produce nodes and it seems to work best with the large trees.  However, I am having hard time make it work with pd Dataframes.  Here is example: 
import pandas as pd
import numpy as np
from sklearn.tree import DecisionTreeClassifier</p>
<h1>dummy data:</h1>
<pre><code>df = pd.DataFrame({'col1':[0,1,2,3],'col2':[3,4,5,6],'dv':[0,1,0,1]})
df
# create decision tree
dt = DecisionTreeClassifier(random_state=0, max_depth=5, min_samples_leaf=1)
dt.fit(df.loc[:,('col1','col2')], df.dv)

from sklearn.tree import _tree

def tree_to_code(tree, feature_names):
    tree_ = tree.tree_
    feature_name = [
        feature_names[i] if i != _tree.TREE_UNDEFINED else "undefined!"
        for i in tree_.feature
    ]
    print ("def tree({}):".format(", ".join(feature_names)))

    def recurse(node, depth):
        indent = "  " * depth
        if tree_.feature[node] != _tree.TREE_UNDEFINED:
            name = feature_name[node]
            threshold = tree_.threshold[node]
            print ("{}if {} &lt;= {}:".format(indent, name, threshold))
            recurse(tree_.children_left[node], depth + 1)
            print ("{}else:  # if {} &gt; {}".format(indent, name, threshold))
            recurse(tree_.children_right[node], depth + 1)
        else:
            print ("{}return {}".format(indent, node))

    recurse(0, 1)

tree_to_code(dt, df.columns)
</code></pre>
<p>Above call produces below code:   </p>
<pre><code>def tree(col1, col2, dv):
  if col2 &lt;= 3.5:
    return 1
  else:  # if col2 &gt; 3.5
    if col1 &lt;= 1.5:
      return 3
    else:  # if col1 &gt; 1.5
      if col1 &lt;= 2.5:
        return 5
      else:  # if col1 &gt; 2.5
        return 6
</code></pre>
<p>And, when I call above code as below I get error that I am missing one argument.  How can I revise the code to make it work on pandas DataFrame?  </p>
<p><code>tree('col1', 'col2', 'dv_pred')</code></p>
</div>
<div class="post-text" itemprop="text">
<p>Here is a working solution</p>
<pre class="lang-py prettyprint-override"><code>import pandas as pd
from sklearn.tree import _tree
from sklearn.tree import DecisionTreeClassifier

df = pd.DataFrame({'col1':[0,1,2,3],'col2':[3,4,5,6],'dv':[0,1,0,1]})

# create decision tree
dt = DecisionTreeClassifier(random_state=0, max_depth=5, min_samples_leaf=1)
features = ['col1','col2']
dt.fit(df.loc[:,features], df.dv)


def tree_to_code(tree, feature_names):
    tree_ = tree.tree_
    feature_name = [
        feature_names[i] if i != _tree.TREE_UNDEFINED else "undefined!"
        for i in tree_.feature
    ]
    print ("def tree(x):")

    def recurse(node, depth):
        indent = "  " * depth
        if tree_.feature[node] != _tree.TREE_UNDEFINED:
            name = feature_name[node]
            threshold = tree_.threshold[node]
            print ("{}if x['{}'] &lt;= {}:".format(indent, name, threshold))
            recurse(tree_.children_left[node], depth + 1)
            print ("{}else:  # if x['{}'] &gt; {}".format(indent, name, threshold))
            recurse(tree_.children_right[node], depth + 1)
        else:
            print ("{}return {}".format(indent, node))

    recurse(0, 1)

tree_to_code(dt,  df[features].columns)
</code></pre>
<p>Then to get the predictions</p>
<pre class="lang-py prettyprint-override"><code>df.apply(tree, axis=1)
</code></pre>
</div>
<span class="comment-copy">It would be good if you provided an example of your expected and actual output.</span>
<span class="comment-copy">I just tested it on a very large tree and it worked very well.  This solution is very robust.  Thank you!</span>
