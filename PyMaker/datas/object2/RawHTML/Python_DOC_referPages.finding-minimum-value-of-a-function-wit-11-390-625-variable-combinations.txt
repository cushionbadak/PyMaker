<div class="post-text" itemprop="text">
<p>I am working on a code to solve for the optimum combination of diameter size of number of pipelines. The objective function is to find the least sum of pressure drops in six pipelines. </p>
<p>As I have 15 choices of discrete diameter sizes which are [2,4,6,8,12,16,20,24,30,36,40,42,50,60,80] that can be used for any of the six pipelines that I have in the system, the list of possible solutions becomes 15^6 which is equal to 11,390,625 </p>
<p>To solve the problem, I am using Mixed-Integer Linear Programming using Pulp package. I am able to find the solution for the combination of same diameters (e.g. [2,2,2,2,2,2] or [4,4,4,4,4,4]) but what I need is to go through all combinations (e.g. [2,4,2,2,4,2] or [4,2,4,2,4,2] to find the minimum. I attempted to do this but the process is taking a very long time to go through all combinations. Is there a faster way to do this ? </p>
<p>Note that I cannot calculate the pressure drop for each pipeline as the choice of diameter will affect the total pressure drop in the system. Therefore, at anytime, I need to calculate the pressure drop of each combination in the system.  </p>
<p>I also need to constraint the problem such that the rate/cross section of pipeline area &gt; 2. </p>
<p>Your help is much appreciated. </p>
<p>The first attempt for my code is the following:</p>
<pre><code>from pulp import * 
import random 
import itertools
import numpy

rate = 5000
numberOfPipelines = 15 

def pressure(diameter):
    diameterList = numpy.tile(diameter,numberOfPipelines)
    pressure = 0.0
    for pipeline in range(numberOfPipelines):
        pressure +=  rate/diameterList[pipeline]
    return pressure 
diameterList = [2,4,6,8,12,16,20,24,30,36,40,42,50,60,80]

pipelineIds = range(0,numberOfPipelines)
pipelinePressures = {} 

for diameter in diameterList: 
   pressures = [] 
   for pipeline in range(numberOfPipelines): 
      pressures.append(pressure(diameter))
   pressureList = dict(zip(pipelineIds,pressures))
   pipelinePressures[diameter] = pressureList 
   print 'pipepressure', pipelinePressures 
prob = LpProblem("Warehouse Allocation",LpMinimize)

use_diameter = LpVariable.dicts("UseDiameter", diameterList, cat=LpBinary) 
use_pipeline = LpVariable.dicts("UsePipeline", [(i,j) for i in pipelineIds for j in diameterList], cat = LpBinary)

## Objective Function: 
prob += lpSum(pipelinePressures[j][i] * use_pipeline[(i,j)] for i in pipelineIds for j in diameterList)

## At least each pipeline must be connected to a diameter: 
for i in pipelineIds: 
   prob += lpSum(use_pipeline[(i,j)] for j in diameterList) ==1 

## The diameter is activiated if at least one pipelines is assigned to it: 
for j in diameterList: 
  for i in pipelineIds: 
     prob += use_diameter[j] &gt;= lpSum(use_pipeline[(i,j)])


## run the solution

prob.solve()
print("Status:", LpStatus[prob.status])

for i in diameterList:
    if use_diameter[i].varValue&gt; pressureTest:
        print("Diameter Size",i)

for v in prob.variables():
    print(v.name,"=",v.varValue)
</code></pre>
<p>This what I did for the combination part which took really long time. </p>
<pre><code>xList = np.array(list(itertools.product(diameterList,repeat = numberOfPipelines)))
        print len(xList)
        for combination in xList:
            pressures = [] 
            for pipeline in range(numberOfPipelines):
               pressures.append(pressure(combination))
            pressureList = dict(zip(pipelineIds,pressures))
            pipelinePressures[combination] = pressureList
            print 'pipelinePressures',pipelinePressures
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I would iterate through all combinations, I think you would run into memory problems otherwise trying to model ALL combinations in a MIP.</p>
<p>If you iterate through the problems perhaps using the multiprocessing library to use all cores, it shouldn't take long just remember only to hold information on the best combination so far, and not to try and generate all combinations at once and then evaluate them.</p>
<p>If the problem gets bigger you should consider Dynamic Programming Algorithms or use pulp with column generation.</p>
</div>
<span class="comment-copy">The numbers involved seem fairly doable by brute force. Have you tried calculating the objective function of all the combinations and then picking out the optimized value?</span>
<span class="comment-copy">If itertools.product is slow and your problem has fixed number of pipes, consider using loops or recursion to generate the combinations</span>
<span class="comment-copy">I would second the suggestion below to use Dynamic Programming. Without a full description of the problem I can't be sure, but I'm pretty confident the problem could be decomposed into a series of stages and so could be tackled effectively using Dynamic Programming.</span>
