<div class="post-text" itemprop="text">
<p>Python is a relatively new language for me. Unit Testing and Dependency Injection are something that I've been doing for a little while now, so I'm familiar with it from a C# perspective.</p>
<p>Recently, I wrote this piece of Python code:
</p>
<pre><code>import requests  # my dependency: http://docs.python-requests.org/en/latest/

class someClass:
    def __init__(self):
        pass

    def __do(self, url, datagram):
        return requests.post(self, url, datagram)
</code></pre>
<p>And then I realized that I had just created a hard-coded dependency. Bleh.</p>
<p>I had considered changing my code to do "Constructor" Dependency Injection:</p>
<pre><code>def __init__(self,requestLib=requests):
    self.__request = requestLib

def __do(self, url, datagram):
    return self.__request.post(self, url, datagram)
</code></pre>
<p>This now allows me to inject a fake/mock dependency for the sake of Unit Testing, but wasn't sure if this was considered Python-ic. So I'm appealing to the Python community for guidance. </p>
<p>What are some examples of Python-ic ways to do basic DI (mostly for the sake of writing Unit Tests that utilize Mocks/Fakes)?</p>
<p><strong>ADDENDUM</strong> For anyone curious about the Mock answer, I decided to ask a separate question here: <a href="https://stackoverflow.com/questions/33353855/how-does-mock-patch-know-which-parameter-to-use-for-each-mock-object">How does @mock.patch know which parameter to use for each mock object?</a> </p>
</div>
<div class="post-text" itemprop="text">
<p>Don't do that. Just import requests as normal and use them as normal. Passing libraries as arguments to your constructors is a fun thing to do, but not very pythonic and unnecessary for your purposes. To mock things in unit tests, use mock library. In python 3 it is built into the standard library</p>
<p><a href="https://docs.python.org/3.4/library/unittest.mock.html" rel="noreferrer">https://docs.python.org/3.4/library/unittest.mock.html</a></p>
<p>And in python 2 you need to install it separately </p>
<p><a href="https://pypi.python.org/pypi/mock" rel="noreferrer">https://pypi.python.org/pypi/mock</a></p>
<p>Your test code would look something like this (using python 3 version)</p>
<pre><code>from unittest import TestCase
from unittest.mock import patch

class MyTest(TestCase):
    @patch("mymodule.requests.post")
    def test_my_code(self, mock_post):
        # ... do my thing here...
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>While injecting the requests module can be a bit too much, it is a very good practice to have some dependencies as injectable.</p>
<p>It may be the case that a full-fledged framework is just what you need. For that there are excellent modules out there such as <a href="https://github.com/alecthomas/injector" rel="nofollow noreferrer">Injector</a>.</p>
<p>A more minimalist and straight forward approach would be to use a decorator to do the job for you. There are a handful of modules for that <a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=dependency-injection&amp;submit=search" rel="nofollow noreferrer">out there</a>.</p>
<p>I maintain one such module: <a href="https://github.com/allrod5/injectable" rel="nofollow noreferrer">Injectable</a>, which provides a Python 3 <code>@autowired</code> decorator to enable easy and clean dependency injection.</p>
<p>The main points of this decorator are that:</p>
<ul>
<li>the function does not have to be aware of the autowiring at all</li>
<li>dependencies can be lazy initialized</li>
<li>the caller is able to explicitly pass the dependency instances if desired</li>
</ul>
<p>Basically you turn <strong>code like this</strong>:</p>
<pre><code>def __init__(self, *, model: Model = None, service: Service = None):
    if model is None:
        model = Model()

    if service is None:
        service = Service()

    self.model = model
    self.service = service
    # actual code
</code></pre>
<p><strong>into this</strong>:</p>
<pre><code>@autowired
def __init__(self, *, model: Model, service: Service):
    self.model = model
    self.service = service
    # actual code
</code></pre>
<p>No complex stuff, no setup, no workflows enforced.</p>
</div>
<span class="comment-copy">Note that <code>__leading_double_underscore</code> invokes name mangling, and should generally be avoided. Wouldn't it be easier to <a href="https://docs.python.org/3/library/unittest.mock.html" rel="nofollow noreferrer"><code>mock</code> out <code>requests</code></a> for the module under test than inject it?</span>
<span class="comment-copy">I read that the __leading double underscore was to mark a method private. Was I mistaken? If so, how should I mark something private?</span>
<span class="comment-copy">Would it be easier to mock out requests for the module rather than inject it? I don't know. I'm not familiar with Python ways of doing things, which is why I'm asking.  ;)</span>
<span class="comment-copy"><code>_leading_single_underscore</code> is <i>private-by-convention</i> (see <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">python.org/dev/peps/pep-0008</a>) - nothing is ever truly private in Python, though, and even name-mangled attributes are accessible if you're determined. We're all consenting adults!</span>
<span class="comment-copy">C# <a href="https://msdn.microsoft.com/en-gb/library/ff650441.aspx" rel="nofollow noreferrer">has mocking, too</a>! There's a C# explanation of mocking vs. injection <a href="http://stackoverflow.com/a/5433231/3001761">here</a>.</span>
<span class="comment-copy">So I'm trying to parse your code. What does the '@patch("mymodule.requests") do? And why are you passing in a "requests" to the "test_my_code" method. Also, what would the mock for "requests.post" look like?</span>
<span class="comment-copy">The patch decorator substitutes requests module in your code for a mock. My code is most likely incorrect, you would have to patch every function in requests separately to make it work. The patched function is passed as an argument to the test, so you can do asserts against it. Read the docs for unittest and mock for more info on their usage.</span>
<span class="comment-copy">Thanks for the help. I gave you the check mark.  :)</span>
