<div class="post-text" itemprop="text">
<p>Let's say I am writing a unit test for a function that returns a floating point number, I can do it as such in full precision as per my machine:</p>
<pre><code>&gt;&gt;&gt; import unittest
&gt;&gt;&gt; def div(x,y): return x/float(y)
... 
&gt;&gt;&gt;
&gt;&gt;&gt; class Testdiv(unittest.TestCase):
...     def testdiv(self):
...             assert div(1,9) == 0.1111111111111111
... 
&gt;&gt;&gt; unittest.main()
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>Will the same full floating point precision be the same across OS/distro/machine?</p>
<p>I could try to round off and do a unit test as such:</p>
<pre><code>&gt;&gt;&gt; class Testdiv(unittest.TestCase):
...     def testdiv(self):
...             assert round(div(1,9),4) == 0.1111
... 
&gt;&gt;&gt;
</code></pre>
<p>I could also do an assert with <code>log(output)</code> but to keep to a fix decimal precision, I would still need to do rounding or truncating. </p>
<p>But what other way should one pythonically deal with unittesting for floating point output?</p>
</div>
<div class="post-text" itemprop="text">
<p>The precision of <code>float</code> in Python is dependent on the underlying C representation. From <a href="https://docs.python.org/3/tutorial/floatingpoint.html#representation-error" rel="noreferrer"><em>Tutorial/Floating Point Arithmetic: Issues and Limitations, 15.1</em></a>:</p>
<blockquote>
<p>Almost all machines today (November 2000) use IEEE-754 floating point
  arithmetic, and almost all platforms map Python floats to IEEE-754
  “double precision”.</p>
</blockquote>
<hr/>
<p>As for testing, a better idea is to use existing functionality, e.g. <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual" rel="noreferrer"><code>TestCase.assertAmostEqual</code></a>:</p>
<blockquote>
<p><strong><em>assertAlmostEqual(first, second, places=7, msg=None, delta=None)</em></strong></p>
<p>Test that <em>first</em> and <em>second</em> are approximately (or not approximately)
  equal by computing the difference, rounding to the given number of
  decimal <em>places</em> (default 7), and comparing to zero. If <em>delta</em> is supplied instead of <em>places</em> then the difference between <em>first</em> and <em>second</em> must be less or equal to (or greater than) <em>delta</em>.</p>
</blockquote>
<p>Example:</p>
<pre><code>import unittest

def div(x, y): return x / float(y)

class Testdiv(unittest.TestCase):
    def testdiv(self):
        self.assertAlmostEqual(div(1, 9), 0.1111111111111111)
        self.assertAlmostEqual(div(1, 9), 0.1111, places=4)

unittest.main() # OK
</code></pre>
<p>If you prefer to stick to <code>assert</code> statement, you could use the <a href="https://docs.python.org/3/library/math.html#math.isclose" rel="noreferrer"><code>math.isclose</code></a> (Python 3.5+):</p>
<pre><code>import unittest, math

def div(x, y): return x / float(y)

class Testdiv(unittest.TestCase):
    def testdiv(self):
        assert math.isclose(div(1, 9), 0.1111111111111111)

unittest.main() # OK
</code></pre>
<p>The default relative tolerance of <code>math.close</code> is 1e-09, <em>"which assures that the two values are the same within about 9 decimal digits."</em>. For more information about <code>math.close</code> see <a href="https://www.python.org/dev/peps/pep-0485" rel="noreferrer">PEP 485</a>.</p>
</div>
<div class="post-text" itemprop="text">
<p>The <code>unittest.TestCase</code> class has specific methods for comparing floats: <a href="https://docs.python.org/3.5/library/unittest.html#unittest.TestCase.assertAlmostEqual" rel="nofollow"><code>assertAlmostEqual</code></a> and <a href="https://docs.python.org/3.5/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" rel="nofollow"><code>assertNotAlmostEqual</code></a>. To quote the documentation:</p>
<blockquote>
<p><strong>assertAlmostEqual</strong>(<em>first, second, places=7, msg=None, delta=None</em>)
  <strong>assertNotAlmostEqual</strong>(<em>first, second, places=7, msg=None, delta=None</em>)</p>
<p>Test that <em>first</em> and <em>second</em> are approximately (or not approximately)
  equal by computing the difference, rounding to the given number of
  decimal <em>places</em> (default 7), and comparing to zero. Note that these
  methods round the values to the given number of <em>decimal places</em> (i.e.
  like the <a href="https://docs.python.org/3.5/library/functions.html#round" rel="nofollow"><code>round()</code></a> function) and not <em>significant digits</em>.</p>
<p>If <em>delta</em> is supplied instead of <em>places</em> then the difference between
  <em>first</em> and <em>second</em> must be less or equal to (or greater than) <em>delta</em>.</p>
</blockquote>
<p>Thus, you could test the function like this:</p>
<pre><code>self.assertAlmostEqual(div(1, 9), 0.1111111111111111)  # round(a-b, 7) == 0
self.assertAlmostEqual(div(1, 9), 0.1111, 4)           # round(a-b, 4) == 0
</code></pre>
<p>Using the <code>TestCase.assert*</code> methods is preferred over bare <code>assert</code> statements because the latter can be optimized out in some cases. Also, test failure messages produced by the methods are generally much more informative.</p>
</div>
