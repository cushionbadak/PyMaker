<div class="post-text" itemprop="text">
<p>I'm trying to implement a singleton in Python, and after reading <a href="https://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons-in-python/33201#33201">this post</a> I find myself even more confused than before. There are way too many answers, and many of them have received their fair number of votes. Now the problem may not be that I have a singleton, but the fact that the state has to be initialized only once. I tried a couple of implementations <code>SingletonA</code> and <code>SingletonB</code> but I can't manage this to work. For my real problem, the <code>__init__</code> function is quite heavy so I have to do it only once. This is what I have so far:</p>
<pre><code>class ClassA:

    def __init__(self):

        # some state
        print("Creating state in A")
        self.X = 1.
        self.Y = 2.

class SingletonA(ClassA):
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(SingletonA, cls).__new__(
                                cls, *args, **kwargs)
        return cls._instance


class ClassB:

    __shared_state = {}

    def __init__(self):

        if not bool(ClassB.__shared_state):

            # some state
            print("Creating state in B")
            self.X = 1.
            self.Y = 2.

        self.__dict__ = self.__shared_state


def singleton(cls):
    obj = cls()
    # Always return the same object
    cls.__new__ = staticmethod(lambda cls: obj)
    # Disable __init__
    try:
        del cls.__init__
    except AttributeError:
        pass
    return cls

@singleton
class SingletonB(ClassB):
    pass

if __name__ == "__main__":

    a1 = SingletonA()
    a2 = SingletonA()
    if (id(a1) == id(a2)):
        print("Same",a1.X, a1.Y)
    else:
        print("Different",a1.X, a1.Y)

    b1 = SingletonB()
    b2 = SingletonB()
    if (id(b1) == id(b2)):
        print("Same",b1.X, b1.Y)
    else:
        print("Different",b1.X, b1.Y)
</code></pre>
<p>Now this is printing:</p>
<pre><code>$ python singleton.py 
Creating state in B
Creating state in B
Same 1.0 2.0
Creating state in A
Creating state in A
Same 1.0 2.0
</code></pre>
<p>Pointing to the fact that indeed I have a singleton class, but I want to avoid the creation of state. </p>
</div>
<div class="post-text" itemprop="text">
<p>This cannot work, because <code>__init__</code> method is called after object creation through <code>__new__</code>. Extract from <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="nofollow">Python Language Reference</a></p>
<blockquote>
<p>If <code>__new__()</code> returns an instance of cls, then the new instanceâ€™s <code>__init__()</code> method will be invoked like <code>__init__(self[, ...])</code>, where <code>self</code> is the new instance and the remaining arguments are the same as were passed to <code>__new__()</code>.</p>
</blockquote>
<p>You should instead have a special initialization method distinct from <code>__init__</code> and called at <code>_instance</code> creation.</p>
<p>Code could be (no need for a parent class, so I omitted it):</p>
<pre><code>class SingletonA:
    _instance = None
    def __init__(self):

        # some state
        print("Creating dummy state in SingletonA")

    def _init(self):

        # some state
        print("Creating state in SingletonA")
        self.X = 1.
        self.Y = 2.
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super(SingletonA, cls).__new__(
                cls, *args, **kwargs)
            cls._instance._init()
        return cls._instance
</code></pre>
<p>But in fact, you can simply build the instance at declaration time:</p>
<pre><code>class SingletonA:
    def __init__(self):

        # some state
        print("Creating dummy state in SingletonA")

    def _init(self):

        # some state
        print("Creating state in A")
        self.X = 1.
        self.Y = 2.
    def __new__(cls, *args, **kwargs):
        return cls._instance

SingletonA._instance = super(SingletonA, SingletonA).__new__(SingletonA)
SingletonA._instance._init()
</code></pre>
<p>Both ways would cause following output (for SingletonA part):</p>
<pre><code>Creating state in A
Creating dummy state in SingletonA
Creating dummy state in SingletonA
('Same', 1.0, 2.0)
</code></pre>
<p>Completely removing the <code>__init__</code> method would cause one single initialization.</p>
<p>The annotation version could be:</p>
<pre><code>class ClassB:

    def __init__(self):

            # some state
            print("Creating state in B")
            self.X = 1.
            self.Y = 2.


def singleton(cls):
    obj = cls()
    # Always return the same object
    cls._instance = obj
    cls.__new__ = staticmethod(lambda cls: cls._instance)
    # Disable __init__
    cls.__init__ = (lambda self: None)
    return cls

@singleton
class SingletonB(ClassB):
    pass
</code></pre>
<p>simply storing the singleton instance in the class itself </p>
</div>
<div class="post-text" itemprop="text">
<p>If I understand you correctly, this is all what you need:</p>
<pre><code># edited according to discussion in comments
class C:
    _shared_dict = None
    def __init__(self):
        if self._shared_dict is None:
            print("initializing")
            self.x = 1 
            self.y = 2 
            self.__class__._shared_dict = self.__dict__
        else:
            self.__dict__ = self._shared_dict

a=C()
b=C()

print(id(a), a.x, a.y)
print(id(b), b.x, b.y)
</code></pre>
<p>All instances will share the same data and this data will be computed only once.</p>
<p>Please note that you can refer to the shared data as <code>self._shared_dict</code> when reading, but must use the full name of a class attribute <code>self.__class__._shared_dict</code> when writing to it.</p>
</div>
<span class="comment-copy">Impressive answer. Thanks Serge. I like the annotation version the best. Now, I've read in some posts that using singletons is not Pythonic. Do you have any comments on this?</span>
<span class="comment-copy">Is there a way to do that with a dictionary the way I tried to do it with the <code>__shared_state</code> variable? I have lots of variables that are assigned in <code>__init__</code></span>
<span class="comment-copy">@aaragon: I think yes. I have edited the code in my answer.</span>
