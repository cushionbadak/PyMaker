<div class="post-text" itemprop="text">
<p>I have a text file in the format</p>
<pre><code>word lemma
word lemma
word lemma    
</code></pre>
<p>like this</p>
<pre><code>workers  work
went     go
going    go
work     work
working  work
</code></pre>
<p>What I have to do is to collect in dict the lemma with its words, so the output will like this</p>
<pre><code>{work: workers, work, working}
{go: went, going}
</code></pre>
<p>I tried this</p>
<pre><code>mydict = {}
for line in myfile.splitlines():
    lemma = line.split()[1]
    word = line.split()[0]
    mydict[lemma] = word
</code></pre>
<p>But this code gives the following output:</p>
<pre><code>{'work': 'working', 'go': 'going'}
</code></pre>
<p>Can someone help?</p>
</div>
<div class="post-text" itemprop="text">
<p>Your code is almost right! The problem is that <code>mydict[lemma] = word</code> is going to <em>overwrite</em> any existing <code>word</code>s associated with that <code>lemma</code>. In reality each lemma can have more than one word associated with it , so what we really want to do is add the new word to a collection, rather than overwrite the existing value. The natural way to model this is with a dict of <em>lists</em> of strings, rather than a dict of strings.</p>
<pre><code>mydict = {}
for line in myfile.splitlines():
    word, lemma = line.split()
    if lemma in mydict:
        mydict[lemma].append(word)
    else:
        mydict[lemma] = [word]
</code></pre>
<p>What does that <code>if</code> statement mean? If there is already an entry for a given <code>lemma</code> in <code>mydict</code>, then we add it to the list. If it's not already there, we initialise the entry with a singleton list.</p>
<p>I've also taken the liberty of using Python's syntax for unpacking sequences. <code>word, lemma = line.split()</code> is equivalent to <code>word = line.split()[0]; lemma = line.split()[1]</code>.</p>
<p>One of the nice things about Python is that many simple tasks are catered for by the standard library. This sort of use-case is just what the standard library's <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="nofollow"><code>defaultdict</code></a> was designed for. When you index into a <code>defaultdict</code> using the subscripting operator (<code>dict[x]</code>), if no value is found it is created using the function you supply. Here, we tell the <code>defaultdict</code> to initialise a new list.</p>
<pre><code>from collections import defaultdict
mydict = defaultdict(list)
</code></pre>
<p>Now the code is simpler because <code>defaultdict</code> is taking care of checking <code>if lemma in mydict</code> for us. It'll always give us back a (possibly-empty) list to which we can add the word.</p>
<pre><code>for line in myfile.splitlines():
    word, lemma = line.split()
    mydict[lemma].append(word)
</code></pre>
<p>In a comment, you suggested that you didn't want duplicate <code>word</code>s in the output. The standard library can help here, too. <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow"><code>set</code></a> is a data structure a bit like a list, except that it doesn't remember the order of the elements, and it automatically removes duplicates. (Under the hood, it works like a <code>dict</code> with only keys and no values.)</p>
<p>We just need to change the <code>defaultdict</code> function from <code>list</code> to <code>set</code>, and change the <code>append</code> method to the version which works on <code>set</code>s (which is called <code>add</code>.)</p>
<pre><code>from collections import defaultdict
mydict = defaultdict(set)

for line in myfile.splitlines():
    word, lemma = line.split()
    mydict[lemma].add(word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>as my comment suggests, you need to make a list as your value, not just setting the value for each key. somethign like this should work.</p>
<pre><code>mydict = {}
for line in myfile.splitlines():
    lemma = line.split()[1]
    word = line.split()[0]
    if lemma in mydict.keys():
        mydict[lemma].append(word)
    else:
        mydict[lemma] = [word]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Well I would suggest using a <code>defaultdict</code>, initialized with a <code>list</code> from the <code>collections</code> module. It fits this case since you can easily add new elements and have the <code>list</code> ready for adding elements. </p>
<p>Creating a <code>defaultdict</code> is easily done by importing it from collections and providing a <code>list</code> as the sole argument:</p>
<pre><code>from collections import defaultdict

mydict = defaultdict(list)
</code></pre>
<p>Then, you can iterate for every line in your file and <code>append()</code> the <code>word</code> according to the value of <code>lemma</code> :</p>
<pre><code>with open('lemmaaa', 'r') as myfile:
    for line in myfile:
        lemma = line.split()[1]
        word = line.split()[0]
        mydict[lemma].append(word)
</code></pre>
<p>Using the input you supplied, <code>print(mydict)</code> outputs the mapping you're looking for: </p>
<pre><code>defaultdict(&lt;type 'list'&gt;, {'go': ['went', 'going'], 'work': ['workers', 'work', 'working']})
</code></pre>
</div>
<div class="post-text" itemprop="text">
<pre><code>import csv
import collections

with open('path/to/file') as infile:
    answer = collections.defaultdict(list)
    for word, lemma in csv.reader(infile, delimiter='\t'):
        answer[lemma].append(word)
</code></pre>
<p>If you want to do this without any help from csv:</p>
<pre><code>answer = {}
with open('path/to/file') as infile:
    for line in infile:
        word, lemma = line.split()
        if lemma not in answer: answer[lemma] = []
        answer[lemma].append(word)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>If you're interested in the <s>insane</s> functional approach to this, there is a "single logical line" way to get it done, that doesn't involve creating an empty dictionary and avoids the repeated calls to <code>append</code></p>
<pre><code>import itertools
import operator

with open('myfile.txt') as myfile:
    mydict = dict((k, [p[1] for p in grp]) 
         for k, grp in itertools.groupby(
             sorted(list(reversed(ln.split())) for ln in myfile),
             operator.itemgetter(0)))
</code></pre>
<p>which says
take each line of the file, split it, then <a href="https://docs.python.org/3/library/functions.html#reversed" rel="nofollow">reverse</a> it<br/>
<a href="https://docs.python.org/3/library/functions.html#sorted" rel="nofollow">sort</a> those lines<br/>
<a href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="nofollow">group</a> them by their element<a href="https://docs.python.org/2/library/operator.html#operator.itemgetter" rel="nofollow"><code>[0]</code></a><br/>
map the element <code>[0]</code> to each word in the group by taking the <code>[1]</code> of the reversed split line.</p>
</div>
<span class="comment-copy">i think you mean to do <code>line.split()[1]</code>. also, this will not work completely because you are going to be overwriting the current value for the key with whatever is next, ie the value for <code>work</code> will always be replaced by the last value with <code>work</code>. you would not to initialize a list as the value then append each matching matching value to that list</span>
<span class="comment-copy">I edited the code</span>
<span class="comment-copy">What about if there are many same words for one lemma, and I want not duplicates in the words?</span>
<span class="comment-copy">@Fawy Good question! Use a <a href="https://docs.python.org/3/library/functions.html#func-set" rel="nofollow noreferrer"><code>set</code></a> instead of a <code>list</code>. <code>set</code>s automatically remove duplicates. I'll update my answer.</span>
<span class="comment-copy">My pleasure :-)</span>
