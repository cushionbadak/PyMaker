<div class="post-text" itemprop="text">
<p>I have 2 lists. One contains <code>values</code>, the other contains the <code>levels</code> those values hold in a sum tree. (the lists have same length)</p>
<p>For example: </p>
<pre><code>[40,20,5,15,10,10] and [0,1,2,2,1,1]
</code></pre>
<p>Those lists correctly correspond because</p>
<pre><code>- 40
- - 20
- - - 5
- - - 15
- - 10
- - 10

(20+10+10) == 40 and (5+15) == 20
</code></pre>
<p>I need to check if a given list of values and a list of its levels corresponds correctly. So far I have managed to put together this function, but for some reason it's not returning True for correct lists <em>array</em> and <em>numbers</em>. Input <em>numbers</em> here would be <code>[40,20,5,15,10,10]</code> and <em>array</em> would be <code>[0,1,2,2,1,1]</code></p>
<pre><code>def testsum(array, numbers):
    k = len(array)
    target = [0]*k
    subsum = [0]*k
    for x in range(0, k):
        if target[array[x]]!=subsum[array[x]]:
            return False
        target[array[x]]=numbers[x]
        subsum[array[x]]=0
        if array[x]&gt;0:
            subsum[array[x]-1]+=numbers[x]
    for x in range(0, k):
        if(target[x]!=subsum[x]):
            print(x, target[x],subsum[x])
            return False
    return True
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>I got this running using <a href="https://docs.python.org/3/library/itertools.html" rel="nofollow"><code>itertools.takewhile</code></a> to grab the subtree under each level. Toss that into a recursive function and assert that all recursions pass.</p>
<p>I've slightly improved my initial implementation by grabbing a <code>next_v</code> and <code>next_l</code> and testing early to see if the current node is a parent node and only building <code>subtree</code> if there's something to build. That inequality check is much cheaper than iterating through the whole <code>vs_ls</code> zip.</p>
<pre><code>import itertools

def testtree(values, levels):
    if len(values) == 1:
        # Last element, always true!
        return True
    vs_ls = zip(values, levels)
    test_v, test_l = next(vs_ls)
    next_v, next_l = next(vs_ls)
    if next_l &gt; test_l:
        subtree = [v for v,l in itertools.takewhile(
            lambda v_l: v_l[1] &gt; test_l,
            itertools.chain([(next_v, next_l)], vs_ls))
                   if l == test_l+1]
        if sum(subtree) != test_v and subtree:
            #TODO test if you can remove the "and subtree" check now!
            print("{} != {}".format(subtree, test_v))
            return False
    return testtree(values[1:], levels[1:])

if __name__ == "__main__":
    vs = [40, 20, 15, 5, 10, 10]
    ls = [0, 1, 2, 2, 1, 1]
    assert testtree(vs, ls) == True
</code></pre>
<p>It unfortunately adds a lot of complexity to the code since it pulls out the first value that we need, which necessitates an extra <code>itertools.chain</code> call. That's not ideal. Unless you're expecting to get very large lists for <code>values</code> and <code>levels</code>, it might be worthwhile to do <code>vs_ls = list(zip(values, levels))</code> and approach this list-wise rather than iterator-wise. e.g...</p>
<pre><code>...
vs_ls = list(zip(values, levels))
test_v, test_l = vs_ls[0]
next_v, next_l = vs_ls[1]
...

    subtree = [v for v,l in itertools.takewhile(
        lambda v_l: v_l[1] &gt; test_l,
        vs_ls[1:]) if l == test_l+1]
</code></pre>
<p>I still think the fastest way is probably to iterate once with an approach almost like a state machine and grab all the possible subtrees, then check them all individually. Something like:</p>
<pre><code>from collections import namedtuple

Tree = namedtuple("Tree", ["level_num", "parent", "children"])
# equivalent to
# # class Tree:
# #     def __init__(self, level_num: int,
# #                        parent: int,
# #                        children: list):
# #         self.level_num = level_num
# #         self.parent = parent
# #         self.children = children

def build_trees(values, levels):
    trees = []  # list of Trees
    pending_trees = []
    vs_ls = zip(values, levels)
    last_v, last_l = next(vs_ls)
    test_l = last_l + 1
    for v, l in zip(values, levels):
        if l &gt; last_l:
            # we've found a new tree
            if l != last_l + 1:
                # What do you do if you get levels like [0, 1, 3]??
                raise ValueError("Improper leveling: {}".format(levels))
            test_l = l

            # Stash the old tree and start a new one.
            pending_trees.append(cur_tree)
            cur_tree = Tree(level_num=last_l, parent=last_v, children=[])

        elif l &lt; test_l:
            # tree is finished

            # Store the finished tree and grab the last one we stashed.
            trees.append(cur_tree)
            try:
                cur_tree = pending_trees.pop()
            except IndexError:
                # No trees pending?? That's weird....
                # I can't think of any case that this should happen, so maybe
                # we should be raising ValueError here, but I'm not sure either
                cur_tree = Tree(level_num=-1, parent=-1, children=[])

        elif l == test_l:
            # This is a child value in our current tree
            cur_tree.children.append(v)
    # Close the pending trees
    trees.extend(pending_trees)
    return trees
</code></pre>
<p>This should give you a list of <code>Tree</code> objects, each of which having the following attributes</p>
<pre><code>level_num  := level number of parent (as found in levels)
parent     := number representing the expected sum of the tree
children   := list containing all the children in that level
</code></pre>
<p>After you do that, you should be able to simply check</p>
<pre><code>all([sum(t.children) == t.parent for t in trees])
</code></pre>
<p>But note that I haven't been able to test this second approach.</p>
</div>
<span class="comment-copy">You could work your way from the middle of the lists and compare from there, I think it would be a more interesting approach</span>
<span class="comment-copy">How would that work?</span>
<span class="comment-copy">Can't you just create a tree then check the sums while traversing the tree?</span>
<span class="comment-copy">I am trying to do that.</span>
<span class="comment-copy">@user3050748: can you give me please another tree? ie. some ancestor according parents. I already do this tree. So i need another tree for testing</span>
<span class="comment-copy">This seems to be working! Thank you so much!</span>
<span class="comment-copy">@user3050748 I've added a bit of an improvement on the first approach and what should be a significantly more time efficient approach below (though as yet untested). Let me know if there's anything you don't understand</span>
<span class="comment-copy">If I try to call on your second approach it gives me an error at line <code>trees.append(cur_tree)</code> : <code>local variable 'cur_tree' is referenced before assignment</code></span>
