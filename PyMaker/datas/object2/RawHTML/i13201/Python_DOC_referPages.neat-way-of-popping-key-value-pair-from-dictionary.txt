<div class="post-text" itemprop="text">
<p><code>pop</code> is a great little function that, when used on dictionaries (given a known key) removes the item with that key from the dictionary and also returns the corresponding value. But what if I want the key as well?</p>
<p>Obviously, in simple cases I could probably just do something like this:</p>
<pre><code>pair = (key, some_dict.pop(key))
</code></pre>
<p>But if, say, I wanted to pop the key-value pair with the lowest value, following the above idea I would have to do this...</p>
<pre><code>pair = (min(some_dict, key=some.get), some_dict.pop(min(some_dict, key=some_dict.get)))
</code></pre>
<p>... which is hideous as I have to do the operation twice (obviously I could store the output from <code>min</code> in a variable, but I'm still not completely happy with that). So my question is: Is there an elegant way to do this? Am I missing an obvious trick here?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can define yourself dictionary object using python <a href="https://docs.python.org/3/library/abc.html" rel="nofollow">ABC</a>s which provides the infrastructure for defining <a href="https://docs.python.org/3/glossary.html#term-abstract-base-class" rel="nofollow"><em>abstract base classes</em></a>. And then overload the <code>pop</code> attribute of python dictionary objects based on your need:</p>
<pre><code>from collections import Mapping

class MyDict(Mapping):
    def __init__(self, *args, **kwargs):
        self.update(dict(*args, **kwargs))

    def __setitem__(self, key, item): 
        self.__dict__[key] = item

    def __getitem__(self, key): 
        return self.__dict__[key]

    def __delitem__(self, key): 
        del self.__dict__[key]

    def pop(self, k, d=None):
        return k,self.__dict__.pop(k, d)

    def update(self, *args, **kwargs):
        return self.__dict__.update(*args, **kwargs)

    def __iter__(self):
        return iter(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def __repr__(self): 
        return repr(self.__dict__)
</code></pre>
<p>Demo:</p>
<pre><code>d=MyDict()

d['a']=1
d['b']=5
d['c']=8

print d
{'a': 1, 'c': 8, 'b': 5}

print d.pop(min(d, key=d.get))
('a', 1)

print d
{'c': 8, 'b': 5}
</code></pre>
<p><em>Note</em> : As @chepner suggested in comment as a better choice you can override <code>popitem</code>, which already returns a key/value pair.</p>
</div>
<div class="post-text" itemprop="text">
<p>A heap supports the pop-min operation you describe. You'll need to create a heap from your dictionary first, though.</p>
<pre><code>import heapq
# Must be two steps; heapify modifies its argument in-place.
# Reversing the key and the value because the value will actually be
# the "key" in the heap. (Or rather, tuples are compared 
# lexicographically, so put the value in the first position.)
heap = [(v, k) for k, v in some_dict.items()]
heapq.heapify(heap)

# Get the smallest item from the heap
value, key = heapq.heappop(heap)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>here is a simpler implementation</p>
<pre><code>class CustomDict(dict):
    def pop_item(self, key):
        popped = {key:self[key]} #save "snapshot" of the value of key before popping
        self.pop(key)
        return popped

a = CustomDict()
b = {"hello":"wassup", "lol":"meh"}
a.update(b)
print(a.pop_item("lol"))
print(a)
</code></pre>
<p>So here we create a custom <code>dict</code> that pops the item you want and gives out the key-value pair</p>
</div>
<span class="comment-copy">store the output from <code>min</code> in a variable</span>
<span class="comment-copy">@JBernardo I had thought of that. It is obviously better, but I still feel there should be a better way without one.</span>
<span class="comment-copy">You might want a heap, rather than a <code>dict</code>. See the <code>heapq</code> module.</span>
<span class="comment-copy">why are you unhappy with using variables?</span>
<span class="comment-copy">Sounds to me like if there was a way, it would be an optional argument to <code>some_dict.popitem()</code> - but docs give no argument there, so I think there would be no method for that.</span>
<span class="comment-copy">It would be better to override <code>popitem</code>, which already returns a key/value pair, and allow it to take an optional key argument.</span>
<span class="comment-copy">@chepner Yes, that would be better. I just showed the way.</span>
<span class="comment-copy">Thanks, accepted as it gave a solution to the general problem.</span>
<span class="comment-copy">I guess storing the key in a variable as suggested by JBernado is preferable to implementing a whole new class.</span>
<span class="comment-copy">Thanks for answering. That's great for the minimum, but that was just an example of the more general problem of popping both the key and value, given a certain key (sorry if that was unclear). Ideal solution would able to do the same thing with other criteria.</span>
<span class="comment-copy">@J.F.Sebastian Oops. I knew that, but then while testing something out I got lazy and forgot that <code>heap</code> was just a list whose order was amenable to the <code>heapq</code> functions, rather than an instance of a distinct heap type.</span>
<span class="comment-copy">Please add some explanation!</span>
<span class="comment-copy">ok wilco I'll add some explainations</span>
