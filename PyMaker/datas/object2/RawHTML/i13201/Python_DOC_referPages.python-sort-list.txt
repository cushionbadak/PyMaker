<div class="post-text" itemprop="text">
<p>I'm trying to get it so that it finds the average of the numbers inside the list, then sorts the averages by highest average.
Here's what I have o far: </p>
<pre><code>d = defaultdict(list)
for name, score in ListAvg:
    d[name].append(score)
print(d.items())
</code></pre>
<p>This currently prrints:</p>
<pre><code>dict_items([('J', ['10', '8', '4']), ('D', ['10', '7', '6']),
('I', ['10', '9', '7']), ('G', ['10', '9', '6']),
('C', ['9', '7',     '5']), ('B', ['8', '6', '5']),
('F', ['8', '7', '6']), ('E', ['9', '8', '5']),
('A', ['8', '6', '5']), ('H', ['10', '7', '6'])])
</code></pre>
<p>Ideally I want it to print something like:</p>
<pre><code>dict_items([('I', ['8.66']),  ('G', ['8.33'],
('D', ['7.66']),), ('H', ['7.66']),
('J', ['7.33']), ('E', ['7.33']), 
('C', ['7']), ('F', ['7']), 
('A', ['6.66']), ('B', ['6.33'])])
</code></pre>
<p>Any way how I can make this happen, or at least have it print the names with the averages in that order?</p>
</div>
<div class="post-text" itemprop="text">
<p>You can use <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow">statistics.mean</a> using   to get the the average and reverse sort the the tuple pairs by the second element. </p>
<pre><code>d = dict([('Jordan', ['10', '8', '4']), ('David', ['10', '7', '6']),
('Zak', ['10', '9', '7']), ('Luke', ['10', '9', '6']),
('Chloe', ['9', '7',     '5']), ('Charlotte', ['8', '6', '5']),
('Josh', ['8', '7', '6']), ('Dominic', ['9', '8', '5']),
('Matthew', ['8', '6', '5']), ('Harry', ['10', '7', '6'])])

from statistics import mean
from operator import itemgetter

print(sorted(((k,mean(map(int,v))) for k,v in d.items()),key=itemgetter(1),reverse=True))

[('Zak', 8.666666666666666), ('Luke', 8.333333333333334),
 ('David', 7.666666666666667),('Harry', 7.666666666666667), 
('Jordan', 7.333333333333333), ('Dominic', 7.333333333333333), 
('Josh', 7.0), ('Chloe', 7.0), ('Charlotte', 6.333333333333333), 
('Matthew', 6.333333333333333)]
</code></pre>
<p>If you want a dict create an <code>OrderedDict</code> for the sorted tuples:</p>
<pre><code>from collections import OrderedDict
new_d = OrderedDict(sorted(((k,mean(map(int,v))) 
                    for k,v in d.items()),key=itemgetter(1),reverse=True))

print(new_d)
OrderedDict([('Zak', 8.666666666666666), ('Luke', 8.333333333333334), 
('David', 7.666666666666667), ('Harry', 7.666666666666667), 
('Dominic', 7.333333333333333), ('Jordan', 7.333333333333333), 
('Chloe', 7.0), ('Josh', 7.0), ('Charlotte', 6.333333333333333),
 ('Matthew', 6.333333333333333)])
</code></pre>
<p>The <code>OrderedDict</code> will maintain the insertion order which is users sorted from  highest to lowest average.</p>
</div>
<div class="post-text" itemprop="text">
<p>Using <code>sum</code> and <code>len</code> and <code>sorted</code> to calculate <strong>average</strong> and sort by it:</p>
<pre><code># the sort function calculates the average for the list
avg = lambda x: sum(int(i) for i in x[1])/len(x[1]))
sorted_by_average = sorted(d.items()), key=avg)
</code></pre>
<p>More verbose average:</p>
<pre><code>def avg(item):
    lst = item[1]
    # summarize values as ints
    sum_lst = sum(int(x) for x in lst)
    return sum_lst / len(lst)
</code></pre>
</div>
<span class="comment-copy">That's a funny way to use a list comprehension to avoid modifying the list whilst iterating. Just use a set instead, as order doesn't matter.</span>
<span class="comment-copy">Dictionaries are not ordered, unless you use something like <code>OrderedDict</code> in which case you'll have to add your default empty list.</span>
<span class="comment-copy">Thank you so much! This worked perfectly!</span>
<span class="comment-copy">No worries, you're welcome</span>
