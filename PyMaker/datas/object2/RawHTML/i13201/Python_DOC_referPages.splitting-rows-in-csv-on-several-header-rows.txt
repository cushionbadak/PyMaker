<div class="post-text" itemprop="text">
<p>I am very new to python, so please be gentle. </p>
<p>I have a .csv file, reported to me in this format, so I cannot do much about it:</p>
<pre><code>ClientAccountID   AccountAlias   CurrencyPrimary    FromDate
         SomeID      SomeAlias          SomeCurr    SomeDate
        OtherID     OtherAlias         OtherCurr   OtherDate
ClientAccountID   AccountAlias   CurrencyPrimary    AssetClass
         SomeID      SomeAlias          SomeCurr     SomeClass
        OtherID     OtherAlias         OtherCurr     OtherDate
      AnotherID   AnotherAlias       AnotherCurr   AnotherDate
</code></pre>
<p>I am using the csv package in python, so i have:</p>
<pre><code>with open(theFile, 'rb') as csvfile:
    theReader = csv.DictReader(csvfile, delimiter = ',')
</code></pre>
<p>Which, as I understand it, creates the dictionary 'theReader'. How do I subset this dictionary, into several dictionaries, splitting them by the header rows in the original csv file? Is there a simple, elegant, non-loop way to create a list of dictionaries (or even a dictionary of dictionaries, with account IDs as keys)?  Does that make sense?</p>
<p>Oh. Please note the header rows are not equivalent, but the header rows will always begin with 'ClientAccountID'.</p>
<p>Thanks to @ codie, I am now using the following to split the csv into several dicts, based on using the '\t' delimiter. </p>
<pre><code>with open(theFile, 'rb') as csvfile:
    theReader = csv.DictReader(csvfile, delimiter = '\t')
</code></pre>
<p>However, I now get the entire header row as a key, and each other row as a value. How do I further split this up?</p>
<p>Thanks to @Benjamin Hodgson below, I have the following:</p>
<pre><code>from csv import DictReader
from io import BytesIO

stringios = []

with open('file.csv', 'r') as f:
    stringio = None
    for line in f:
        if line.startswith('ClientAccountID'):
            if stringio is not None:
                stringios.append(stringio)
            stringio = BytesIO()
        stringio.write(line)
        stringio.write("\n")
    stringios.append(stringio)

data = [list(DictReader(x.getvalue(), delimiter=',')) for x in stringios]
</code></pre>
<p>If I print the first item in stringios, I get what I would expect. It looks like a single csv. However, if I print the first item in data, using below, i get something odd:</p>
<pre><code>for row in data[0]:
    print row
</code></pre>
<p>It returns:</p>
<pre><code>{'C':'U'}
{'C':'S'}
{'C':'D'}
...
</code></pre>
<p>So it appears it is splitting every character, instead of using the comma delimiter.</p>
</div>
<div class="post-text" itemprop="text">
<p>If I've understood your question correctly, you have a single CSV file which contains multiple tables. Tables are delimited by header rows which always begin with the string <code>"ClientAccountID"</code>.</p>
<p>So the job is to read the CSV file into a list of lists-of-dictionaries. Each entry in the list corresponds to one of the tables in your CSV file.</p>
<p>Here's how I'd do it:</p>
<ol>
<li>Break up the single CSV file with multiple tables into multiple files each with a single table. (These files could be in-memory.) Do this by looking for lines which start with <code>"ClientAccountID"</code>.</li>
<li>Read each of these files into a list of dictionaries using a <code>DictReader</code>.</li>
</ol>
<p>Here's some code to read the file into a list of <a href="https://docs.python.org/3/library/io.html#io.StringIO" rel="nofollow"><code>StringIO</code></a>s. (A <code>StringIO</code> is an in-memory file. It works by wrapping a string up into a file-like interface).</p>
<pre><code>from csv import DictReader
from io import StringIO

stringios = []

with open('file.csv', 'r') as f:
    stringio = None
    for line in f:
        if line.startswith('ClientAccountID'):
            if stringio is not None:
                stringio.seek(0)
                stringios.append(stringio)
            stringio = StringIO()
        stringio.write(line)
        stringio.write("\n")
    stringio.seek(0)
    stringios.append(stringio)
</code></pre>
<p>If we encounter a line starting with <code>'ClientAccountID'</code>, we put the current <code>StringIO</code> into the list and start writing to a new one. When you've finished, remember to add the last one to the list too.
Don't forget (as I did, in an earlier version of this answer) to rewind the <code>StringIO</code> after you've written to it using <code>stringio.seek(0)</code>. </p>
<p>Now it's straightforward to loop over the <code>StringIO</code>s to get a table of dictionaries.</p>
<pre><code>data = [list(DictReader(x, delimiter='\t')) for x in stringios]
</code></pre>
<p>For each file-like object in the list <code>stringios</code>, create a <code>DictReader</code> and read it into a list.</p>
<p>It's not too hard to modify this approach if your data is too big to fit into memory. Use generators instead of lists and do the processing line-by-line.</p>
</div>
<div class="post-text" itemprop="text">
<p>If your data was not comma or tab delimited you could use <code>str.split</code>, you can combine it with <code>itertools.groupby</code> to delimit the headers and rows:</p>
<pre><code>from itertools import groupby, izip, imap

with open("test.txt") as f:
    grps, data = groupby(imap(str.split, f), lambda x: x[0] == "ClientAccountID"), []
    for k, v in grps:
        if k:
            names = next(v)
            vals = izip(*next(grps)[1])
            data.append(dict(izip(names, vals)))

from pprint import pprint as pp

pp(data)
</code></pre>
<p>Output:</p>
<pre><code>[{'AccountAlias': ('SomeAlias', 'OtherAlias'),
  'ClientAccountID': ('SomeID', 'OtherID'),
  'CurrencyPrimary': ('SomeCurr', 'OtherCurr'),
  'FromDate': ('SomeDate', 'OtherDate')},
 {'AccountAlias': ('SomeAlias', 'OtherAlias', 'AnotherAlias'),
  'AssetClass': ('SomeClass', 'OtherDate', 'AnotherDate'),
  'ClientAccountID': ('SomeID', 'OtherID', 'AnotherID'),
  'CurrencyPrimary': ('SomeCurr', 'OtherCurr', 'AnotherCurr')}]
</code></pre>
<p>If it is tab delimited just change one line:</p>
<pre><code>with open("test.txt") as f:
    grps, data = groupby(csv.reader(f, delimiter="\t"), lambda x: x[0] == "ClientAccountID"), []
    for k, v in grps:
        if k:
            names = next(v)
            vals = izip(*next(grps)[1])
            data.append(dict(izip(names, vals)))
</code></pre>
</div>
<span class="comment-copy">use a tab delimiter, <code>(\t)</code> not a comma delimiter</span>
<span class="comment-copy">Oh. How simple. How do I then create the sub-dictionaries?</span>
<span class="comment-copy"><code>for row in theReader: do something()</code> where row is a dict of values in the given row. Python does all the magic under the covers for you.</span>
<span class="comment-copy">You need to present a few actual lines from the csv files to allow us to give you an proper answer. If the case is that you have a csv file with multiple different id's in blocks of three (or seven) lines, then you need to do a little bit of magic when reading the file. The current example is ambigous...</span>
<span class="comment-copy">You need to make up some fake data to better know what the format is. Take the first 10 lines or something and obfuscate the data.</span>
<span class="comment-copy">I am getting an error: stringio.write(line) TypeError: unicode argument expected, got 'str'  And yes, you understood perfectly what I am trying to do. Thanks.</span>
<span class="comment-copy">This answer is Python 3 code. I'm guessing you're on 2.7, based on that error message. Try changing <code>StringIO</code> to <code>BytesIO</code>.</span>
<span class="comment-copy">Yes, I am using 2.7. That information is probably relevant... Apologies. Still running into problems, as it appears to work, but 'data' is empty when it completes. I am working through it.</span>
<span class="comment-copy">Suggests that there aren't any lines which start with <code>'ClientAccountID'</code>. Is there some whitespace at the start of the line? If so try <code>line.strip().startswith('ClientAccountID')</code> instead of <code>line.startswith(...)</code>. (Also, I just spotted and fixed a bug in the answer ;)</span>
<span class="comment-copy">I got it working... somewhat. See Edits above.</span>
<span class="comment-copy">This is nice. I did not know about this lambda thing, but it is very useful. Also, could you use str.split in the second as well? Is there not a way to pass a different delimiter (\t) to it?</span>
<span class="comment-copy">Also, looking at the documentation for imap, it says  imap(function, *iterables), implying that the file f is iterable? I am new to python, and I am just curious, but when passing a file, its interpreted as a set of iterable lines? If so, you iterate the lines, str.split them, then group them by lines whos first term is ClientAccountID? I think I understand it correctly, but it just seems... unusual (?) that the file is just an iterable set of lines? Or is that (fairly) normal?  Thanks for this!</span>
<span class="comment-copy">@lukehawk, you can pass whatever delimiter you want but in the map example you would need to use <code>map(lambda x: x.split("whatever")</code>, we can pass <code>str.split</code> because it is callable so we don't need a lambda, yes a file object returns it's own iterator so you will get a line at a time as you iterate over it, the imap splits the each line on any whitespace, then each time we <code>if k</code> is True we have a line with the first column == "ClientAccountID" so we call next on the groupby object to get all the lines either up to the next row with "ClientAccountID" or the end of the file</span>
