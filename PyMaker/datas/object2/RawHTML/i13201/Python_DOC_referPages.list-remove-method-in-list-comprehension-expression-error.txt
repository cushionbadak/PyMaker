<div class="post-text" itemprop="text">
<p>I am creating a classical "set" class to practice, and the first thing I want to do is remove all duplicates.  I know I could do it easily with dictionary keys, but I wanted to try to improve my list comprehension.  These two functions should do the same thing, but the second doesn't work.  Why?</p>
<pre><code>for element in elements:
            if elements.count(element) &gt; 1:
                elements.remove(element)
        print(elements)
</code></pre>
<p>The second:</p>
<pre><code>self.elements = [elements.remove(element) for element in elements
                 if elements.count(element) &gt; 1]
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>Don't iterate over and remove from the same list, you should also use a <code>Counter</code> dict to count the occurrences of each element if your objects are hashable:</p>
<pre><code>from collections import Counter
cn = Counter(elements)
# elements[:] changes original list
elements[:] = (ele for ele in elements if ch[ele] &lt; 2)
</code></pre>
<p>In your second code because <code>list.remove</code> is an <strong>inplace</strong> operation  it will just add <code>None's</code> to your list anytime <code>if elements.count(element) &gt; 1</code> is <code>True</code> or else do nothing so the two code examples are completely different. </p>
<p>The first code if it does work only works by chance.  When you remove an element from your list what a pointer was pointing to previously can change so you end up removing the wrong elements from your list.</p>
<p>An example of what your second code is doing and why your first is the wrong approach:</p>
<pre><code>In [20]: l = [2,3,1,4,1,5]

In [21]: l = [l.remove(i)  if i &gt; 1 else i for i in l]

In [22]: l
Out[22]: [None, 1, None, None]
</code></pre>
<p>Because you have changed the pointer values you end up removing the second <code>1</code> and with a few None's added because like all functions that operate inplace or don't specify a return value in python they return None by default.</p>
<p>If you actually want to get a unique set of all elements and not just keep the unique elements which is what your code seems to be attempting and also maintain the order, a <code>collections.OrderedDict</code> dict will do what you need:</p>
<pre><code>from collections import OrderedDict
elements[:] =  collections.OrderedDict.fromkeys(elements)
</code></pre>
</div>
<div class="post-text" itemprop="text">
<p>There are two issues with your code. The first issue is what you're explicitly asking about: The list comprehension version is going to assign a whole bunch of <code>None</code> values to <code>self.elements</code>. The <code>None</code> values are simply the return values from your calls to <code>list.remove</code>. It modifies the list in place, and doesn't have anything useful to return (so it returns <code>None</code>).</p>
<p>The comprehension <code>[element for element in elements if elements.count(element) == 1 or elements.remove(element)]</code> will work the same as your other code (since <code>None</code> is falsey and <code>or</code> short-circuits), but it still runs into the second issue. (It's also a bit of an ugly hack: The new list created by the comprehension will have the same contents as <code>elements</code> since <code>remove</code> modifies <code>elements</code> in place, and it's quite confusing. Writing hard to understand code is generally not a good idea.)</p>
<p>The second issue is that modifying a list while you are iterating over it can cause issues. List iterators work by index. The first item yielded by the iterator is from index 0, the second is from index 1, and so on. If you modify the list by removing an item early in the list, you'll shift the indexes of all the later items.</p>
<p>So, say you remove the first item (from index 0) just after your iterator has shown it to you. The list will shift all the later values up, but the iterator won't know about this. It will still yield the item at index 1 next, even though that used to be the item at index 2 (before the list was modified). The item originally at index 1 (and at index 0 after the previous item was removed) will be skipped by the iteration.</p>
<p>Here's a simple example of this issue, where values 2, 5, and 8 will be not be printed:</p>
<pre><code>L = list(range(10)) # [0,1,2,3,4,5,6,7,8,9]
for x in L:
    print(x)
    if x % 3 == 1: # true for 1,4, and 7
        L.remove(x)
</code></pre>
<p>In the example, the logic for removing values is pretty simple and we never skip a value we would normally want to remove (so <code>L</code> has the expected value of <code>[0,2,3,5,6,8,9]</code> at the end), other code may not work as nicely.</p>
<p>A way to avoid this issue is to iterate over a copy of the list, while modifying the original. In this situation we'll also need to <code>count</code> in the original, rather than the copy:</p>
<pre><code>for element in elements[:]: # copy list with a slice here!
    if elements.count(element) &gt; 1:
        elements.remove(element)  # modify the original list
</code></pre>
<p>This is rather inefficient though, since removing an item from a list (at a position other than the end) needs to take the time to shift all the later values up one position. Counting is also slow, as you need to iterate the whole list for each item. It's much more efficient to keep track of the unique items you've seen so far, and skip duplicated items when you see them later:</p>
<pre><code>seen = set()
results = []
for element in elements:
   if element not in seen:
       seen.add(element)
       results.append(element)
</code></pre>
<p>You can even build a somewhat awkward list comprehension (with side effects) of this code:</p>
<pre><code>seen = set()
results = [element for element in elements
           if not (element in seen or seen.add(element))]
</code></pre>
<p>A better approach is usually to bundle the deduplicating logic into a generator function (like the <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="nofollow"><code>unique_everseen</code> recipe</a> in the <code>itertools</code> documentation), and then call it with <code>list(dedupe(elements))</code>.</p>
</div>
<span class="comment-copy">Neither of the versions of your code will do what you want. Mutating a list as you are iterating over it will skip some values!</span>
<span class="comment-copy">Possible duplicate of <a href="http://stackoverflow.com/questions/1207406/remove-items-from-a-list-while-iterating-in-python">Remove items from a list while iterating in Python</a></span>
<span class="comment-copy">what about list(set(elements)) ?</span>
<span class="comment-copy">Thanks, this makes sense!</span>
<span class="comment-copy">No prob,  the Counter dict approach  also makes your code <code>O(n)</code> as opposed to <code>O(n^2)</code> as we only do a single pass to get the counts and then one more pass to filter the original list</span>
<span class="comment-copy">The <code>Counter</code> code doesn't do what the questioner wants. It eliminates <i>all copies</i> of duplicated values, instead of all but one.</span>
<span class="comment-copy">@Blckknght, it does what the OP is attempting to do with count so what they actually want is debatable, anyway that is secondary to what the OP asked as the question was about the reason the second code did not match the first and remove all duplicates could actually be just removing elements that appear more than once</span>
<span class="comment-copy">@PadraicCunningham: I think the desire for a deduplicated list is pretty clear. The result should be something like <code>list(set(elements))</code> (perhaps with some specific order). You <i>can</i> use a <code>Counter</code> to improve the OP's original approach (replacing <code>elements.count[element]</code> with <code>cn[element]</code> and <code>elements.remove(element)</code> with <code>cn[element] -= 1</code>, and adding some new logic to yield the results), but your code is doing something different (<i>finding</i> the unique values, instead of <i>making</i> all the values unique).</span>
